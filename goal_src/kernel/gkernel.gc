;;-*-Lisp-*-
(in-package goal)

;; name: gkernel.gc
;; name in dgo: gkernel
;; dgos: KERNEL


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; System Globals
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Set version number symbols
(define *kernel-version* (the binteger (logior (ash *kernel-major-version* 16) *kernel-minor-version*)))
(define *irx-version* (the binteger (logior (ash *irx-major-version* 16) *irx-minor-version*)))

;; Set default options. The C Kernel may modify these before loading the engine.

;; Can be 'boot, 'listener, or 'debug-boot
;; set to 'boot when DiskBooting.
(define *kernel-boot-mode* 'listener) 

;; DebugBootLevel in C Kernel
(define *kernel-boot-level* (the symbol #f))

;; The number of DECI messages received.
;; The C Kernel increments this.
(define *deci-count* 0)

;; Some debug stats. Unused?
(define *last-loado-length* 0)
(define *last-loado-global-usage* 0)
(define *last-loado-debug-usage* 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Relocate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Objects on a dynamic process heap may be relocated.
;; They should provide their own relocate method to do any fixups
;; for any references.
(defmethod relocate object ((this object) (offset int))
  this
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Kernel Package System
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The kernel has a weird package system. It's not really used and doesn't do much.
;; Both the C Kernel and GOAL Kernel update the kernel-packages list.
;; The list is used to avoid loading the same package multiple times.

(define *kernel-packages* '())

(defun load-package ((package string) (allocation kheap))
  "Load a Package from a CGO/DGO"
  (unless (nmember package *kernel-packages*)
    ;; #xf = OUTPUT_LOAD, OUTPUT_TRUE, EXECUTE, PRINT_LOGIN
    (dgo-load package allocation #xf #x200000)
    (set! *kernel-packages* (cons package *kernel-packages*))
    )
  )

(defun unload-package ((package string))
  "Mark a package as unloaded, if it was loaded previously"
  (let ((pack (nmember package *kernel-packages*)))
    (when pack
      (set! *kernel-packages* (delete! (car pack) *kernel-packages*))
      )
    *kernel-packages*
    )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Kernel Globals
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The kernel context is a global which stores the state of the kernel.
(define *kernel-context* (new 'static 'kernel-context
                              :prevent-from-run (process-mask execute sleep)
                              :next-pid 2
                              :current-process #f
                              :relocating-process #f
                              :low-memory-message #t
                              )
        )

;; the main stack for running GOAL code!
(define *dram-stack* (new 'global 'array 'uint8 DPROCESS_STACK_SIZE))

;; I don't think this stack is used, but I'm not sure.
(set! (-> *kernel-context* fast-stack-top) *scratch-memory-top*)

;; A context with all process masks set to 0. This can be used to iterate through a process tree
;; without executing anything, to find a process for instance.
(define *null-kernel-context* (new 'static 'kernel-context))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Thread and CPU Thread
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; A GOAL thread represents the execution of code in a process.
; Each process has a "main thread", which is suspended and resumed.
; A process may also execute various temporary threads which always run until completion.
; A "temporary thread" cannot suspend and resume, but a "main thread" can.
; The currently executing thread of a process is the "top-thread".

; Some GOAL threads also have the ability to "back up" their stack, while others are "temporary".
; The main thread of a process can "back up" it's stack, and all others are temporary.

; All threads are actually cpu-threads. It's not clear why there are two separate types.
; Perhaps the thread was the public interface and cpu-thread is internal to the kernel?

(defmethod delete thread ((obj thread))
  "Clean up a thread. This assumes it's the top-thread of the process and restores the previous top thread."
  (when (eq? obj (-> obj process main-thread))
    ;; We have attempted to delete the main thread, which is bad.
    (break)
    )
  
  ;; restore the old top-thread.
  (set! (-> obj process top-thread) (-> obj previous))
  (none)
  )

(defmethod print thread ((obj thread))
  "Print thread."
  (format #t "#<~A ~S of ~S pc: #x~X @ #x~X>" (-> obj type) (-> obj name) (-> obj process name) (-> obj pc) obj)
  obj)

(defmethod stack-size-set! thread ((this thread) (stack-size int))
  "Set the backup stack size of a thread. This should only be done on the main-thread.
  This should be done immediately after allocating the main-thread"
  
  (let ((proc (-> this process)))
    (cond
      ((neq? this (-> proc main-thread))
       ;; oops. can only change the size of a main-thread's stack.
       (msg-err "illegal attempt change stack size of ~A when the main-thread is not the top-thread.~%" proc)
       (break) ;; ADDED
       )
      
      ((= (-> this stack-size) stack-size)
       ;; we already have this size. Don't do anything.
       )
      
      ((eq? (-> proc heap-cur) (&+ this (-> this type size) (- *gtype-basic-offset*) (-> this stack-size)))
       ;; our heap cur point to right after us. So we can safely bump it forward to give us more space.
       (set! (-> proc heap-cur) (the pointer (&+ this (-> this type size) (- *gtype-basic-offset*) stack-size)))
       (set! (-> this stack-size) stack-size)
       )
      (else
        (msg-err "illegal attempt change stack size of ~A after more heap allocation has occured.~%" proc)
        )
      )
    )
  (none)
  )

(defmethod new cpu-thread ((allocation symbol) (type-to-make type) (parent-process process) (name symbol) (stack-size int) (stack-top pointer))
  "Create a new CPU thread. Will allocate the main thread if none exists, otherwise a temp thread.
  Sets the thread as the top-thread of the process
  This is a special new method which ignores the allocation symbol.
  The stack-top is for the execution stack.
  The stack-size is for the backup stack (applicable for main thread only)"
  
  ;; first, let's see if we're doing the main or temp thread
  (let* ((obj (cond
                ((-> parent-process top-thread)
                 ;; we're allocating a temporary thread, the main thread already exists.
                 ;; we can stash the cpu-thread structure at the bottom of the stack.
                 ;; we assume the smaller PROCESS_STACK_SIZE
                 (the cpu-thread (&+ stack-top
                                     (- PROCESS_STACK_SIZE)
                                     *gtype-basic-offset*
                                     ))
                 )
                (else
                  ;; the main thread. We need the main thread's cpu-thread to stick around, so we put it in the 
                  ;; process heap.
                  (let ((alloc (align16 (-> parent-process heap-cur)))) ;; start at heap cur, aligned
                    ;; bump heap to include our thread + its stack
                    (set! (-> parent-process heap-cur) (the pointer (+ alloc (-> type-to-make size) stack-size)))
                    (the cpu-thread (+ alloc *gtype-basic-offset*))
                    )
                  )
                )))
    
    ;; set up the type manually, as we allocated the memory manually
    (set! (-> obj type) type-to-make)
    
    ;; set up thread
    (set! (-> obj name) name)
    (set! (-> obj process) parent-process)
    ;; start stack at the top
    (set! (-> obj sp) stack-top)
    (set! (-> obj stack-top) stack-top)
    ;; remember the previous thread, in case we're a temp thread
    (set! (-> obj previous) (-> parent-process top-thread))
    ;; and make us the top!
    (set! (-> parent-process top-thread) obj)
    
    ;; set up our suspend/resume hooks. By default just use the thread's methods.
    ;; but something else could install a different hook if needed.
    (set! (-> obj suspend-hook) (method obj thread-suspend))
    (set! (-> obj resume-hook) (method obj thread-resume))
    
    ;; remember how much space we have for the backup stack.
    (set! (-> obj stack-size) stack-size)
    obj
    )
  )


(defmethod asize-of cpu-thread ((obj cpu-thread))
  "Get the size of a cpu-thread"
  ;; we need this because the cpu-thread is stored in the process stack
  (the int (+ (-> obj type size) (-> obj stack-size)))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Remove Exit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun remove-exit ()
  "This is likely a defbehavior for process.
  Pops a single stack frame, if there is one."
  (rlet ((self :reg r13 :type process))
        (when (-> self stack-frame-top)
          (set! (-> self stack-frame-top) (-> self stack-frame-top next))
          )
        )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Process Tree
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; GOAL processes are stored in a left child, right sibling tree.
;; The base class of process is process-tree.
;; Each process-tree element has a process-mask which indicates what type of node it is.

(defun-debug stream<-process-mask (stream (mask int))
  "Print out a process mask. This function may have been auto-generated?"
  ; 24
  (if (not (eq? 0 (logand mask (process-mask death))))
      (format stream "death "))
  ; 23
  (if (not (eq? 0 (logand mask (process-mask attackable))))
      (format stream "attackable "))  
  ; 22
  (if (not (eq? 0 (logand mask (process-mask projectile))))
      (format stream "projectile "))  
  ; 21
  (if (not (eq? 0 (logand mask (process-mask entity))))
      (format stream "entity "))
  ; 20
  (if (not (eq? 0 (logand mask (process-mask ambient))))
      (format stream "ambient "))    
  ; 19
  (if (not (eq? 0 (logand mask (process-mask platform))))
      (format stream "platform "))
  ; 18
  (if (not (eq? 0 (logand mask (process-mask camera))))
      (format stream "camera "))  
  ; 17
  (if (not (eq? 0 (logand mask (process-mask enemy))))
      (format stream "enemy "))  
  ; 16
  (if (not (eq? 0 (logand mask (process-mask collectable))))
      (format stream "collectable "))
  ; 15
  (if (not (eq? 0 (logand mask (process-mask crate))))
      (format stream "crate "))  
  ; 14
  (if (not (eq? 0 (logand mask (process-mask sidekick))))
      (format stream "sidekick "))
  ; 13
  (if (not (eq? 0 (logand mask (process-mask target))))
      (format stream "target "))  
  ; 12
  (if (not (eq? 0 (logand mask (process-mask movie-subject))))
      (format stream "movie-subject "))
  ; 11
  (if (not (eq? 0 (logand mask (process-mask movie))))
      (format stream "movie "))
  ; 10
  (if (not (eq? 0 (logand mask (process-mask going))))
      (format stream "going "))  
  ; 9
  (if (not (eq? 0 (logand mask (process-mask heap-shrunk))))
      (format stream "heap-shrunk "))
  ; 8
  (if (not (eq? 0 (logand mask (process-mask process-tree))))
      (format stream "process-tree "))  
  ; 7
  (if (not (eq? 0 (logand mask (process-mask sleep-code))))
      (format stream "sleep-code "))
  ; 6
  (if (not (eq? 0 (logand mask (process-mask sleep))))
      (format stream "sleep "))  
  ; 5
  (if (not (eq? 0 (logand mask (process-mask actor-pause))))
      (format stream "actor-pause "))  
  ; 4
  (if (not (eq? 0 (logand mask (process-mask progress))))
      (format stream "progress "))
  ; 3
  (if (not (eq? 0 (logand mask (process-mask menu))))
      (format stream "menu "))    
  ; 2
  (if (not (eq? 0 (logand mask (process-mask pause))))
      (format stream "pause "))
  ; 1
  (if (not (eq? 0 (logand mask (process-mask draw))))
      (format stream "draw "))  
  ; 0
  (if (not (eq? 0 (logand mask (process-mask execute))))
      (format stream "execute "))  
  )

;; game state
(define *master-mode* 'game)
(define *pause-lock* #f)

(defmethod new process-tree ((allocation symbol) (type-to-make type) (name basic))
  "Create a process-tree node"
  ;; allocate
  (let ((obj (object-new)))
    (set! (-> obj name) name)
    (set! (-> obj mask) (process-mask process-tree))
    (set! (-> obj parent) #f)
    (set! (-> obj brother) #f)
    (set! (-> obj child) #f)
    
    (set! (-> obj self) obj)
    (set! (-> obj ppointer) (&-> obj self))
    obj
    )
  )

(defmethod inspect process-tree ((obj process-tree))
  "Inspect a process-tree node."
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tname: ~S~%" (-> obj name))
  (format #t "~Tmask: #x~X~%" (-> obj mask))
  (format #t "~Tparent: ~A~%" (as-process (-> obj parent)))
  (format #t "~Tbrother: ~A~%" (as-process (-> obj brother)))
  (format #t "~Tchild: ~A~%" (as-process (-> obj child)))
  obj
  )


(defmethod new process ((allocation symbol) (type-to-make type) (name basic) (stack-size int))
  "Allocate a new process.
  The process stack is initially set to the entire process memory."
  (let ((obj (if (eq? (-> allocation type) symbol)
                 (object-new (the int (+ (-> process size) stack-size))) ;; symbol, allocate on heap
                 (the process (&+ allocation *gtype-basic-offset*)))))   ;; treat as address.
    
    ;; initialize
    (set! (-> obj name) name)
    (set! (-> obj status) 'dead)
    (set! (-> obj pid) 0)
    (set! (-> obj pool) #f)
    (set! (-> obj allocated-length) stack-size)
    (set! (-> obj top-thread) #f)
    (set! (-> obj main-thread) #f)
    
    ;; set up the heap to start at the stack
    (set! (-> obj heap-cur) (-> obj stack))
    (set! (-> obj heap-base) (-> obj stack))
    
    ;; and end at the end of the stack.
    (set! (-> obj heap-top) (&-> (-> obj stack) (-> obj allocated-length)))
    ;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; heap top-base bug
    ;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; original there was something like (set! (-> heap-top-base) (-> heap-top))
    ;; but this overlaps with the stack-frame-top and did nothing.
    ;; this is likely because they added the concept of heap "top" to kheaps in
    ;; general, but not to process heaps.
    
    ;; setup state stuff
    (set! (-> obj stack-frame-top) #f)
    (set! (-> obj state) #f)
    (set! (-> obj next-state) #f)
    (set! (-> obj entity) #f)
    
    ;; setup handlers
    (set! (-> obj trans-hook) #f)
    (set! (-> obj post-hook) #f)
    (set! (-> obj event-hook) #f)

    ;; setup process tree
    (set! (-> obj parent) #f)
    (set! (-> obj brother) #f)
    (set! (-> obj child) #f)
    
    ;; setup reference stuff.
    (set! (-> obj self) obj)
    (set! (-> obj ppointer) (&-> obj self))
    obj
    )            
  )

(defun inspect-process-heap ((obj process))
  "Inspect the heap of a process."
  (let ((ptr (&+ (-> obj heap-base) *gtype-basic-offset*))) ; point to first basic
    ;; loop over objects
    (while (< (the int ptr) (the int (-> obj heap-cur)))
      ;; inspect the object
      (inspect (the basic ptr))
      ;; seek to the next object on the heap.
      (set! ptr (&+ ptr (align16 (asize-of (the basic ptr)))))
      )
    )
  )

(defmethod inspect process ((obj process))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tname: ~S~%" (-> obj name))
  (format #t "~Tmask: #x~X~%" (-> obj mask))
  (format #t "~Tstatus: ~A~%" (-> obj status))
  (format #t "~Tmain-thread: ~A~%" (-> obj main-thread))
  (format #t "~Ttop-thread: ~A~%" (-> obj top-thread))
  (format #t "~Tentity: ~A~%" (-> obj entity))
  (format #t "~Tstate: ~A~%" (-> obj state))
  (format #t "~Tnext-state: ~A~%" (-> obj next-state))
  (format #t "~Ttrans-hook: ~A~%" (-> obj trans-hook))
  (format #t "~Tpost-hook: ~A~%" (-> obj post-hook))
  (format #t "~Tevent-hook: ~A~%" (-> obj event-hook))
  (format #t "~Tparent: ~A~%" (as-process (-> obj parent)))
  (format #t "~Tbrother: ~A~%" (as-process (-> obj brother)))
  (format #t "~Tchild: ~A~%" (as-process (-> obj child)))
  (format #t "~Tconnection-list: ~`connectable`P~%" (-> obj connection-list))
  (format #t "~Tstack-frame-top: ~A~%" (-> obj stack-frame-top))
  (format #t "~Theap-base: #x~X~%" (-> obj heap-base))
  (format #t "~Theap-top: #x~X~%" (-> obj heap-top))
  (format #t "~Theap-cur: #x~X~%" (-> obj heap-cur))

  ;; print all objects on the process heap
  (protect (*print-column*)
    (+! *print-column* *tab-size*)
    (format #t "----~%")
    (inspect-process-heap obj)
    (format #t "----~%")
    )

  (format #t "~Tallocated-length: ~D~%" (-> obj allocated-length))
  (format #t "~Tstack[~D] @ #x~X~%" (-> obj allocated-length) (-> obj stack))
  obj
  )

(defmethod asize-of process ((obj process))
  (the int (+ (-> process size) (-> obj allocated-length)))
  )

(defmethod print process ((obj process))
  (format #t "#<~A ~S ~A :state ~S " 
          (-> obj type) 
          (-> obj name) 
          (-> obj status) 
          (when (-> obj state) (-> obj state name)))
  
  (format #t ":stack ~D/~D :heap ~D/~D @ #x~X>"
          (process-stack-used obj)
          (process-stack-size obj)
          (process-heap-used obj)
          (process-heap-size obj)
          obj
          )
  obj
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Context Suspend And Resume - Kernel
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; the following functions are used for managing contexts.
;; saved registers: rbx, rbp, r10, r11, r12

;; DANGER - THE KERNEL DOES NOT SAVE ITS FLOATING POINT CONTEXT!!!!

;; we use this to store a GOAL pointer to the kernel's stack pointer when executing user code.
;; to get back to the kernel, we use this global symbol.
(define-extern *kernel-sp* pointer)

(defun return-from-thread ()
  "Context switch to the saved kernel context now.
  This is intended to be jumped to with the ret instruction
  at the end of a normal function, so this should preserve rax."
  (declare (asm-func none)
           ;(print-asm)
           )
  (rlet ((sp :reg rsp :type uint)
         (off :reg r15 :type uint)
         (s0 :reg rbx :type uint)
         (s1 :reg rbp :type uint)
         (s2 :reg r10 :type uint)
         (s3 :reg r11 :type uint)
         (s4 :reg r12 :type uint)
         )
        ;; get the kernel stack pointer as a GOAL pointer
        (.load-sym :sext #f sp *kernel-sp*)
        ;; convert it back to a real pointer
        (.add sp off)
        
        ;; restore saved registers...
        ;; without coloring system because this is "cheating".
        (.pop :color #f s4)
        (.pop :color #f s3)
        (.pop :color #f s2)
        (.pop :color #f s1)
        (.pop :color #f s0)
        ;; return to the kernel function that called the user code
        (.ret)
        )
  )

(defun return-from-thread-dead ()
  "Like return from thread, but we clean up our process with deactivate first.
  The return register is not preserved here, instead we return the value of deactivate"
  (declare (asm-func none)
           ;(print-asm)
           )
  (rlet ((pp :reg r13 :type process)
         (sp :reg rsp :type uint)
         (off :reg r15 :type uint)
         (s0 :reg rbx :type uint)
         (s1 :reg rbp :type uint)
         (s2 :reg r10 :type uint)
         (s3 :reg r11 :type uint)
         (s4 :reg r12 :type uint)
         )
        
        ;; first call the deactivate method.
        (deactivate pp)
        ;; get the kernel stack pointer as a GOAL pointer
        (.load-sym :sext #f sp *kernel-sp*)
        ;; convert it back to a real pointer
        (.add sp off)
        
        ;; restore saved registers...
        ;; without coloring system because this is "cheating".
        (.pop :color #f s4)
        (.pop :color #f s3)
        (.pop :color #f s2)
        (.pop :color #f s1)
        (.pop :color #f s0)
        ;; return to the kernel function that called the user code
        (.ret)
        )
  )

(defun reset-and-call ((obj thread) (func function))
  "Make the given thread the top thread, reset the stack, and call the function.
  Sets up a return trampoline so when the function returns it will return to the
  kernel context."
  (declare (asm-func none)
           ;(print-asm)
           )
  
  (rlet ((pp :reg r13 :type process)
         (sp :reg rsp :type uint)
         (off :reg r15 :type uint)
         (s0 :reg rbx :type uint)
         (s1 :reg rbp :type uint)
         (s2 :reg r10 :type uint)
         (s3 :reg r11 :type uint)
         (s4 :reg r12 :type uint)
         )
        
        ;; set up the process pointer
        (set! pp (-> obj process))
        ;; mark the process as running and set its top thread
        (set! (-> pp status) 'running)
        (set! (-> pp top-thread) obj)
        
        ;; save the current kernel regs
        (.push :color #f s0)
        (.push :color #f s1)
        (.push :color #f s2)
        (.push :color #f s3)
        (.push :color #f s4)
        
        ;; make rsp a GOAL pointer
        (.sub sp off)
        ;; and store it
        (set! *kernel-sp* (the pointer sp)) ;; todo, asm form here?
        
        ;; setup the rsp for the new thread
        (set! sp (the uint (-> obj stack-top)))
        (.add sp off)
        
        ;; push the return trampoline to the stack for the user code to return to
        (.push 0) ;; for 16-byte stack alignment.
        (.push return-from-thread)
        ;; and call the function!
        (.jr func)
        )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Context Suspend And Resume - Thread
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; todo thread suspend
;; todo thread resume


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Process Dead Pool
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; a dead-pool is a collection of processes of fixed size that you can get processes from.

(defmethod new dead-pool ((allocation symbol) (type-to-make type) (count int) (stack-size int) (name basic))
  "Create a pool of count dead processes, each with a fixed size stack-size"
  (let ((obj (object-new)))
    ;; setup process naming
    (set! (-> obj name) name)
    (set! (-> obj mask) (process-mask process-tree))
    ;; setup process tree
    (set! (-> obj parent) #f)
    (set! (-> obj brother) #f)
    (set! (-> obj child) #f)
    ;; setup ref
    (set! (-> obj self) obj)
    (set! (-> obj ppointer) (&-> obj self))
    
    (dotimes (i count)
      ;; create each process
      (let ((old-bro (-> obj child))
            (next ((method process new) allocation process 'dead stack-size)))
        (set! (-> obj child) (as-ppointer next))
        (set! (-> next parent) (as-ppointer obj))
        (set! (-> next pool) obj)
        (set! (-> next brother) old-bro)
        )
      )
    obj
    )
  )

(defun kernel-dispatcher ()
  "Kernel Dispatcher Function. This gets called from the main loop in kboot.cpp's KernelCheckAndDispatch"
  
  ;; check if we have a new listener function to run
  (when *listener-function*
    ;; we do! enable method-set for debug purposes
    (+! *enable-method-set* 1)
    
    ;; execute and print result
    (let ((result (*listener-function*)))
      (format #t "~D~%" result)
      )
    (+! *enable-method-set* -1)
    
    ;; clear the pending function.
    (set! *listener-function* (the (function object) #f))
    )
  )
