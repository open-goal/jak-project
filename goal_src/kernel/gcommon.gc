;;-*-Lisp-*-
(in-package goal)

;; name: gcommon.gc
;; name in dgo: gcommon
;; dgos: KERNEL

;; gcommon is the first file compiled and loaded.
;; it's expected that this function will mostly be hand-decompiled



(defun identity ((a0-0 object))
  a0-0
  )

(defun 1/ ((a0-0 float))
  (/ (l.f L345) a0-0)
  )

(defun + ((a0-0 int) (a1-0 int))
  (+ a0-0 a1-0)
  )

(defun - ((a0-0 int) (a1-0 int))
  (- a0-0 a1-0)
  )

(defun * ((a0-0 int) (a1-0 int))
  (* a0-0 a1-0)
  )

(defun / ((a0-0 int) (a1-0 int))
  (/ a0-0 a1-0)
  )

(defun ash ((value int) (shift-amount int))
  "Arithmetic shift value by shift-amount.  
  A positive shift-amount will shift to the left and a negative will shift to the right.
  "
  
  ;; currently the compiler does not support "ash", so this function is also used to implement "ash".
  ;; in the future, the compiler should be able to use constant propagation to turn constant shifts
  ;; into x86 constant shifts when possible (which are faster). The GOAL compiler seems to do this.
  
  ;; The original implementation was inline assembly, to take advantage of branch delay slots:
  ;;  (or v1 a0 r0)      ;; likely inserted by register coloring, not entirely needed
  ;;  (bgezl a1 end)     ;; branch to function end if positive shift (left)...
  ;;  (dsllv v0 v1 a1)   ;; do left shift in delay slot
  ;;  
  ;;  (dsubu a0 r0 a1)   ;; negative shift amount for right shift
  ;;  (dsrav v0 v1 a0)   ;; do right shift
  ;;  (label end)
  
  (declare (inline))
  (if (> shift-amount 0)
      ;; these correspond to x86-64 variable shift instructions.
      ;; the exact behavior of GOAL shifts (signed/unsigned) are unknown so for now shifts must
      ;; be manually specified.
      (shl value shift-amount)
      (sar value (- shift-amount))
      )
  )

(defun mod ((a0-0 int) (a1-0 int))
  (mod a0-0 a1-0)
  )


(defun rem ((a0-0 int) (a1-0 int))
  (mod a0-0 a1-0)
  )

(defun abs ((a int))
  "Take the absolute value of an integer"
  
  ;; short function, good candidate for inlining
  (declare (inline))
  
  ;; The original implementation was inline assembly, to take advantage of branch delay slots:
  ;;  (or v0 a0 r0)     ;; move input to output unchanged, for positive case
  ;;  (bltzl v0 end)    ;; if negative, execute the branch delay slot below...
  ;;  (dsubu v0 r0 v0)  ;; negate
  ;;  (label end)
  
  
  (if (> a 0) ;; condition is "a > 0"
      a       ;; true case, return a
      (- a)   ;; false case, return -a. (- a) is like (- 0 a)
      )
  )

(defun min ((a int) (b int))
  "Compute minimum."
  
  ;; The original implementation was inline assembly, to take advantage of branch delay slots:
  ;;  (or v0 a0 r0)    ;; move first arg to output (case of second arg being min)
  ;;  (or v1 a1 r0)    ;; move second arg to v1 (likely strange coloring)
  ;;  (slt a0 v0 v1)   ;; compare args
  ;;  (movz v0 v1 a0)  ;; conditional move the second arg to v0 if it's the minimum
  
  (declare (inline))
  (if (> a b) b a)
  )

(defun max ((a int) (b int))
  "Compute maximum."
  (declare (inline))
  (if (> a b) a b)
  )

(defun logior ((a0-0 int) (a1-0 int))
  (logior a0-0 a1-0)
  )

(defun logand ((a0-0 int) (a1-0 int))
  (logand a0-0 a1-0)
  )

(defun lognor ((a int) (b int))
  "Compute not or."
  ;; Note - MIPS has a 'nor' instruction, but x86 doesn't.
  ;; the GOAL x86 compiler therefore doesn't have a nor operation,
  ;; so lognor is implemented by this inline function instead.
  (declare (inline))
  (lognot (logior a b))
  )

(defun logxor ((a0-0 int) (a1-0 int))
  (logxor a0-0 a1-0)
  )

(defun lognot ((a0-0 int))
  (lognot a0-0)
  )

(defun false-func () '#f)

(defun true-func () '#t)

(define format _format)

;; vec4s - this is present in the game as a 128-bit integer child type full of 4 floats.
;; this doesn't seem to be used, and OpenGOAL doesn't support bitfields or 128-bit integers yet, so it is omitted.
;; I suspect this was unused because putting 4 floats in a 128-bit integer register is not an incredibly useful thing to do
;; - accessing all of these floats will be very slow.


(deftype bfloat (basic)
  ((data float :offset-assert 4))

  :size-assert 8
  :method-count-assert 9
  :flag-assert #x900000008
  )

(defmethod print bfloat ((a0-0 bfloat))
  (local-vars
   (gp-0 bfloat)
   )
  (begin (set! gp-0 a0-0) (format '#t L343 (-> gp-0 data)) gp-0)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Type System
;;;;;;;;;;;;;;;;;;;;;;;;;;

; The asize-of method should return the total size in memory used by an object.
; It's used for traversing heaps of basics and copying basics.
; Most basic/structure types are "fixed size", and their default asize-of method will simply
; return the "size" field of their type, so you don't have to worry about it.
; However, some types are dynamic (like a string) and require that you provide your own method.
; A common approach is to have an "allocated-length" field, then have the asize-of method return
;  (+ (-> obj type size) (* elem-size (-> obj allocated-length)))
; asize-of returns the actual size, including the type field, and can have any alignment.

;; A "type" object contains some basic information about a type as well as the list of methods.
;; Some types have more methods than others, so the method table makes "type" a dynamic type.
;; As a result, we should define an "asize-of" method for type. It's possibly unused and it's wrong.

(defmethod asize-of type ((a0-0 type))
  (the-as int (logand (l.d L346) (+ (shl (-> a0-0 allocated-length) 2) 43)))
  )

(defun basic-type? ((a0-0 basic) (a1-0 type))
  (local-vars
   (v1-0 type)
   (a0-1 type)
   (a2-0 symbol)
   )
  (begin
   (set! v1-0 (-> a0-0 type))
   (set! a0-1 object)
   (until
    (begin (set! v1-0 (-> v1-0 parent)) (= v1-0 a0-1))
    (if (= v1-0 a1-0) (return '#t (set! v1-0 0)))
    )
   '#f
   )
  )

(defun type-type? ((a0-0 type) (a1-0 type))
  (local-vars
   (v1-0 type)
   (a2-0 symbol)
   (a2-1 symbol)
   )
  (begin
   (set! v1-0 object)
   (until
    (begin (set! a0-0 (-> a0-0 parent)) (or (= a0-0 v1-0) (zero? a0-0)))
    (if (= a0-0 a1-0) (return '#t (set! v1-0 0)))
    )
   '#f
   )
  )

(defun find-parent-method ((a0-0 type) (a1-0 int))
  (local-vars
   (v0-0 function)
   (v1-2 function)
   (v1-5 symbol)
   (a2-1 symbol)
   (a2-4 symbol)
   )
  (begin
   (set! v1-2 (-> a0-0 methods a1-0))
   (until
    (!= v0-0 v1-2)
    (if (= a0-0 object) (return nothing (set! v1-2 0)))
    (set! a0-0 (-> a0-0 parent))
    (set! v0-0 (-> a0-0 methods a1-0))
    (if (zero? v0-0) (return nothing (set! v1-2 0)))
    )
   (set! v1-5 '#f)
   v0-0
   )
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; pair and list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun ref ((a0-0 object) (a1-0 int))
  (local-vars
   (v1-0 int)
   (v1-1 symbol)
   (v1-2 symbol)
   )
  (begin
   (set! v1-0 0)
   (while
    (< v1-0 a1-0)
    (nop!)
    (nop!)
    (set! a0-0 (cdr a0-0))
    (set! v1-0 (+ v1-0 1))
    )
   (set! v1-1 '#f)
   (set! v1-2 '#f)
   (car a0-0)
   )
  )

(defmethod length pair ((a0-0 pair))
  (local-vars
   (v0-0 int)
   (v1-1 object)
   (v1-2 symbol)
   (a0-2 symbol)
   )
  (begin
   (cond
    ((= a0-0 '()) (set! v0-0 0))
    (else
     (set! v1-1 (cdr a0-0))
     (set! v0-0 1)
     (while
      (and (!= v1-1 '()) (< (shl (the-as int v1-1) 62) 0))
      (set! v0-0 (+ v0-0 1))
      (set! v1-1 (cdr v1-1))
      )
     (set! v1-2 '#f)
     )
    )
   v0-0
   )
  )

(defmethod asize-of pair ((a0-0 pair))
  (the-as int (-> pair size))
  )

(defun last ((a0-0 object))
  (local-vars
   (v0-0 object)
   (v1-1 symbol)
   )
  (begin
   (set! v0-0 a0-0)
   (while (!= (cdr v0-0) '()) (nop!) (nop!) (set! v0-0 (cdr v0-0)))
   (set! v1-1 '#f)
   v0-0
   )
  )

(defun member ((a0-0 object) (a1-0 object))
  (local-vars
   (v0-0 object)
   (v1-0 object)
   (a0-1 symbol)
   (a1-2 symbol)
   )
  (begin
   (set! v1-0 a1-0)
   (while (not (or (= v1-0 '()) (= (car v1-0) a0-0))) (set! v1-0 (cdr v1-0)))
   (set! a0-1 '#f)
   (if (!= v1-0 '()) v1-0)
   )
  )

(define-extern name= (function basic basic symbol))

(defun nmember ((a0-0 basic) (a1-0 object))
  (local-vars
   (v0-1 object)
   (v1-1 symbol)
   (v1-2 symbol)
   (s5-0 basic)
   (gp-0 object)
   )
  (begin
   (set! s5-0 a0-0)
   (set! gp-0 a1-0)
   (while
    (not (or (= gp-0 '()) (name= (car gp-0) s5-0)))
    (set! gp-0 (cdr gp-0))
    )
   (set! v1-2 '#f)
   (if (!= gp-0 '()) gp-0)
   )
  )

(defun assoc ((a0-0 object) (a1-0 object))
  (local-vars
   (v0-0 object)
   (v1-0 object)
   (a0-1 symbol)
   (a1-2 symbol)
   )
  (begin
   (set! v1-0 a1-0)
   (while
    (not (or (= v1-0 '()) (= (car (car v1-0)) a0-0)))
    (set! v1-0 (cdr v1-0))
    )
   (set! a0-1 '#f)
   (if (!= v1-0 '()) (car v1-0))
   )
  )

(defun assoce ((a0-0 object) (a1-0 object))
  (local-vars
   (v0-0 object)
   (v1-0 object)
   (a0-1 symbol)
   (a1-2 symbol)
   )
  (begin
   (set! v1-0 a1-0)
   (while
    (not (or (= v1-0 '()) (= (car (car v1-0)) a0-0) (= (car (car v1-0)) 'else)))
    (set! v1-0 (cdr v1-0))
    )
   (set! a0-1 '#f)
   (if (!= v1-0 '()) (car v1-0))
   )
  )

(defun nassoc ((a0-0 string) (a1-0 object))
  (local-vars
   (v0-2 object)
   (v1-1 object)
   (v1-3 symbol)
   (a1-1 object)
   (s5-0 string)
   (gp-0 object)
   )
  (begin
   (set! s5-0 a0-0)
   (set! gp-0 a1-0)
   (while
    (not
     (or
      (= gp-0 '())
      (begin
       (set! a1-1 (car (car gp-0)))
       (if (pair? a1-1) (nmember s5-0 a1-1) (name= a1-1 s5-0))
       )
      )
     )
    (set! gp-0 (cdr gp-0))
    )
   (set! v1-3 '#f)
   (if (!= gp-0 '()) (car gp-0))
   )
  )

(defun nassoce ((a0-0 string) (a1-0 object))
  (local-vars
   (v0-2 object)
   (v1-1 object)
   (v1-4 symbol)
   (s4-0 object)
   (s5-0 string)
   (gp-0 object)
   )
  (begin
   (set! s5-0 a0-0)
   (set! gp-0 a1-0)
   (while
    (not
     (or
      (= gp-0 '())
      (begin
       (set! s4-0 (car (car gp-0)))
       (if
        (pair? s4-0)
        (nmember s5-0 s4-0)
        (or (name= s4-0 s5-0) (= s4-0 'else))
        )
       )
      )
     )
    (set! gp-0 (cdr gp-0))
    )
   (set! v1-4 '#f)
   (if (!= gp-0 '()) (car gp-0))
   )
  )

(defun append! ((a0-0 object) (a1-0 object))
  (local-vars
   (v1-1 object)
   (v1-2 object)
   (a2-1 symbol)
   (a2-3 symbol)
   )
  (cond
   ((= a0-0 '()) a1-0)
   (else
    (set! v1-1 a0-0)
    (while (!= (cdr v1-1) '()) (nop!) (nop!) (set! v1-1 (cdr v1-1)))
    (set! a2-1 '#f)
    (when (!= v1-1 '()) (set! (cdr v1-1) a1-0) (set! v1-2 a1-0))
    a0-0
    )
   )
  )

(defun delete! ((a0-0 object) (a1-0 object))
  (local-vars
   (v1-1 object)
   (a0-1 symbol)
   (a0-3 symbol)
   (a2-0 object)
   (a3-1 symbol)
   )
  (the-as
   pair
   (cond
    ((= a0-0 (car a1-0)) (cdr a1-0))
    (else
     (set! v1-1 a1-0)
     (set! a2-0 (cdr a1-0))
     (while
      (not (or (= a2-0 '()) (= (car a2-0) a0-0)))
      (set! v1-1 a2-0)
      (set! a2-0 (cdr a2-0))
      )
     (set! a0-1 '#f)
     (if (!= a2-0 '()) (set! (cdr v1-1) (cdr a2-0)))
     a1-0
     )
    )
   )
  )

(defun delete-car! ((a0-0 object) (a1-0 object))
  (local-vars
   (v1-2 object)
   (a0-1 symbol)
   (a0-3 symbol)
   (a2-0 object)
   (a3-1 symbol)
   )
  (cond
   ((= a0-0 (car (car a1-0))) (cdr a1-0))
   (else
    (set! v1-2 a1-0)
    (set! a2-0 (cdr a1-0))
    (while
     (not (or (= a2-0 '()) (= (car (car a2-0)) a0-0)))
     (set! v1-2 a2-0)
     (set! a2-0 (cdr a2-0))
     )
    (set! a0-1 '#f)
    (if (!= a2-0 '()) (set! (cdr v1-2) (cdr a2-0)))
    a1-0
    )
   )
  )


(defun insert-cons! ((a0-0 object) (a1-0 object))
  (local-vars
   (a3-0 object)
   (gp-0 object)
   )
  (begin
   (set! gp-0 a0-0)
   (set! a3-0 (delete-car! (car gp-0) a1-0))
   (new 'global pair gp-0 a3-0)
   )
  )

(defun sort ((a0-0 object) (a1-0 (function object object object)))
  (local-vars
   (v1-1 object)
   (v1-2 symbol)
   (v1-3 symbol)
   (v1-5 object)
   (v1-7 symbol)
   (v1-10 symbol)
   (v1-11 symbol)
   (v1-12 symbol)
   (a0-2 symbol)
   (s1-0 object)
   (s2-0 object)
   (s3-0 object)
   (s4-0 int)
   (s5-0 (function object object object))
   (gp-0 object)
   )
  (begin
   (set! gp-0 a0-0)
   (set! s5-0 a1-0)
   (set! s4-0 -1)
   (while
    (nonzero? s4-0)
    (set! s4-0 0)
    (set! s3-0 gp-0)
    (while
     (not (or (= (cdr s3-0) '()) (>= (shl (the-as int (cdr s3-0)) 62) 0)))
     (set! s2-0 (car s3-0))
     (set! s1-0 (car (cdr s3-0)))
     (set! v1-1 (s5-0 s2-0 s1-0))
     (when
      (and (or (not v1-1) (> (the-as int v1-1) 0)) (!= v1-1 '#t))
      (set! s4-0 (+ s4-0 1))
      (set! (car s3-0) s1-0)
      (set! (car (cdr s3-0)) s2-0)
      (set! v1-5 s2-0)
      )
     (set! s3-0 (cdr s3-0))
     )
    (set! v1-10 '#f)
    (set! v1-11 '#f)
    )
   (set! v1-12 '#f)
   gp-0
   )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; inline array
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a parent class for boxed "inline arrays" classes, 
;; An inline-array is an array with a bunch of objects back-to-back, as opposed to a bunch of
;; references back to back.
;; Most inline-arrays are unboxed and are just data - this is a somewhat rarely used container parent
;; class for a class that wraps an unboxed inline-array.
;; the "heap-base" field of the type is used to store the indexing scale.

(deftype inline-array-class (basic)
  ((length int32 :offset-assert 4)
   (allocated-length int32 :offset-assert 8)
   (data uint8 :dynamic)
   (_pad uint8 4)
   )
  (:methods (new (symbol type int) _type_ 0)    ;; we will override print later on. This is optional to include
            )
  )

(defmethod new inline-array-class ((a0-0 symbol) (a1-0 type) (a2-0 int))
  (local-vars
   (v0-0 inline-array-class)
   (v1-2 symbol)
   (gp-0 int)
   )
  (begin
   (set! gp-0 a2-0)
   (set!
    v0-0
    (object-new
     a0-0
     a1-0
     (+ (-> a1-0 size) (* (the-as uint gp-0) (-> a1-0 heap-base)))
     )
    )
   (when
    (nonzero? v0-0)
    (set! (-> v0-0 length) gp-0)
    (set! (-> v0-0 allocated-length) gp-0)
    )
   v0-0
   )
  )

(defmethod length inline-array-class ((a0-0 inline-array-class))
  (-> a0-0 length)
  )

(defmethod asize-of inline-array-class ((a0-0 inline-array-class))
  (the-as
   int
   (+
    (-> a0-0 type size)
    (the-as
     uint
     (* (-> a0-0 allocated-length) (the-as int (-> a0-0 type heap-base)))
     )
    )
   )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; array
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; boxed "pointer like" array.
;; unlike inline-array-class, all arrays are type array, but the content-type field stores the element type.
;; the stride of an array is 4, unless the element is a number, in which case the stride is the "size"

(defmethod new array ((a0-0 symbol) (a1-0 type) (a2-0 type) (a3-0 int))
  (local-vars
   (v0-1 array)
   (s5-0 int)
   (gp-0 type)
   )
  (begin
   (set! gp-0 a2-0)
   (set! s5-0 a3-0)
   (set!
    v0-1
    (object-new
     a0-0
     a1-0
     (+
      (-> a1-0 size)
      (the-as uint (* s5-0 (if (type-type? gp-0 number) (-> gp-0 size) 4)))
      )
     )
    )
   (set! (-> v0-1 allocated-length) s5-0)
   (set! (-> v0-1 length) s5-0)
   (set! (-> v0-1 content-type) gp-0)
   v0-1
   )
  )

(defmethod print array ((a0-0 array))
  (local-vars
   (v1-1 symbol)
   (v1-5 symbol)
   (v1-10 symbol)
   (v1-15 symbol)
   (v1-20 symbol)
   (v1-24 symbol)
   (v1-28 symbol)
   (v1-33 symbol)
   (v1-38 symbol)
   (v1-39 symbol)
   (v1-40 symbol)
   (v1-42 object)
   (v1-44 symbol)
   (v1-49 symbol)
   (v1-59 symbol)
   (v1-68 symbol)
   (a0-21 symbol)
   (a1-11 string)
   (a2-8 int)
   (s5-0 int)
   (s5-1 int)
   (s5-2 int)
   (s5-3 int)
   (s5-4 int)
   (s5-5 int)
   (s5-6 int)
   (s5-7 int)
   (s5-8 int)
   (s5-9 int)
   (s5-10 int)
   (s5-11 int)
   (t9-10 (function _varargs_ object))
   (gp-0 array)
   )
  (begin
   (set! gp-0 a0-0)
   (format '#t L342)
   (cond
    ((type-type? (-> gp-0 content-type) integer)
     (set! v1-1 (-> gp-0 content-type symbol))
     (cond
      ((= v1-1 'int32)
       (set! s5-0 0)
       (while
        (< s5-0 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-0) L341 L340)
         (-> (the-as (array int32) gp-0) s5-0)
         )
        (set! s5-0 (+ s5-0 1))
        )
       (set! v1-5 '#f)
       '#f
       )
      ((= v1-1 'uint32)
       (set! s5-1 0)
       (while
        (< s5-1 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-1) L341 L340)
         (-> (the-as (array uint32) gp-0) s5-1)
         )
        (set! s5-1 (+ s5-1 1))
        )
       (set! v1-10 '#f)
       '#f
       )
      ((= v1-1 'int64)
       (set! s5-2 0)
       (while
        (< s5-2 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-2) L341 L340)
         (-> (the-as (array int64) gp-0) s5-2)
         )
        (set! s5-2 (+ s5-2 1))
        )
       (set! v1-15 '#f)
       '#f
       )
      ((= v1-1 'uint64)
       (set! s5-3 0)
       (while
        (< s5-3 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-3) L339 L338)
         (-> (the-as (array uint64) gp-0) s5-3)
         )
        (set! s5-3 (+ s5-3 1))
        )
       (set! v1-20 '#f)
       '#f
       )
      ((= v1-1 'int8)
       (set! s5-4 0)
       (while
        (< s5-4 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-4) L341 L340)
         (-> (the-as (array int8) gp-0) s5-4)
         )
        (set! s5-4 (+ s5-4 1))
        )
       (set! v1-24 '#f)
       '#f
       )
      ((= v1-1 'uint8)
       (set! s5-5 0)
       (while
        (< s5-5 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-5) L341 L340)
         (-> (the-as (array uint8) gp-0) s5-5)
         )
        (set! s5-5 (+ s5-5 1))
        )
       (set! v1-28 '#f)
       '#f
       )
      ((= v1-1 'int16)
       (set! s5-6 0)
       (while
        (< s5-6 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-6) L341 L340)
         (-> (the-as (array int16) gp-0) s5-6)
         )
        (set! s5-6 (+ s5-6 1))
        )
       (set! v1-33 '#f)
       '#f
       )
      ((= v1-1 'uint16)
       (set! s5-7 0)
       (while
        (< s5-7 (-> gp-0 length))
        (format
         '#t
         (if (zero? s5-7) L341 L340)
         (-> (the-as (array uint16) gp-0) s5-7)
         )
        (set! s5-7 (+ s5-7 1))
        )
       (set! v1-38 '#f)
       '#f
       )
      (else
       (set! v1-40 (or (= v1-1 'uint128) (= v1-1 'int128)))
       (cond
        (v1-40
         (set! s5-8 0)
         (while
          (< s5-8 (-> gp-0 length))
          (set! t9-10 format)
          (set! a0-21 '#t)
          (set! a1-11 (if (zero? s5-8) L339 L338))
          (set!
           v1-42
           (+ (shl s5-8 4) (the-as int (the-as (array uint128) gp-0)))
           )
          (.lq a2-8 12 v1-42)
          (t9-10 a0-21 a1-11 a2-8)
          (set! s5-8 (+ s5-8 1))
          )
         (set! v1-44 '#f)
         '#f
         )
        (else
         (set! s5-9 0)
         (while
          (< s5-9 (-> gp-0 length))
          (format
           '#t
           (if (zero? s5-9) L341 L340)
           (-> (the-as (array int32) gp-0) s5-9)
           )
          (set! s5-9 (+ s5-9 1))
          )
         (set! v1-49 '#f)
         '#f
         )
        )
       v1-39
       )
      )
     )
    (else
     (cond
      ((= (-> gp-0 content-type) float)
       (set! s5-10 0)
       (while
        (< s5-10 (-> gp-0 length))
        (if
         (zero? s5-10)
         (format '#t L343 (-> (the-as (array float) gp-0) s5-10))
         (format '#t L337 (-> (the-as (array float) gp-0) s5-10))
         )
        (set! s5-10 (+ s5-10 1))
        )
       (set! v1-59 '#f)
       '#f
       )
      (else
       (set! s5-11 0)
       (while
        (< s5-11 (-> gp-0 length))
        (if
         (zero? s5-11)
         (format '#t L336 (-> (the-as (array basic) gp-0) s5-11))
         (format '#t L335 (-> (the-as (array basic) gp-0) s5-11))
         )
        (set! s5-11 (+ s5-11 1))
        )
       (set! v1-68 '#f)
       '#f
       )
      )
     )
    )
   (format '#t L334)
   gp-0
   )
  )

(defmethod inspect array ((a0-0 array))
  (local-vars
   (v1-1 symbol)
   (v1-5 symbol)
   (v1-10 symbol)
   (v1-15 symbol)
   (v1-20 symbol)
   (v1-24 symbol)
   (v1-28 symbol)
   (v1-33 symbol)
   (v1-38 symbol)
   (v1-39 symbol)
   (v1-40 symbol)
   (v1-42 object)
   (v1-44 symbol)
   (v1-49 symbol)
   (v1-55 symbol)
   (v1-60 symbol)
   (a0-25 symbol)
   (a1-15 string)
   (a2-13 int)
   (a3-10 int)
   (s5-0 int)
   (s5-1 int)
   (s5-2 int)
   (s5-3 int)
   (s5-4 int)
   (s5-5 int)
   (s5-6 int)
   (s5-7 int)
   (s5-8 int)
   (s5-9 int)
   (s5-10 int)
   (s5-11 int)
   (t9-14 (function _varargs_ object))
   (gp-0 array)
   )
  (begin
   (set! gp-0 a0-0)
   (format '#t L333 gp-0 (-> gp-0 type))
   (format '#t L332 (-> gp-0 allocated-length))
   (format '#t L331 (-> gp-0 length))
   (format '#t L330 (-> gp-0 content-type))
   (format '#t L329 (-> gp-0 allocated-length) (-> gp-0 data))
   (cond
    ((type-type? (-> gp-0 content-type) integer)
     (set! v1-1 (-> gp-0 content-type symbol))
     (cond
      ((= v1-1 'int32)
       (set! s5-0 0)
       (while
        (< s5-0 (-> gp-0 length))
        (format '#t L328 s5-0 (-> (the-as (array int32) gp-0) s5-0))
        (set! s5-0 (+ s5-0 1))
        )
       (set! v1-5 '#f)
       '#f
       )
      ((= v1-1 'uint32)
       (set! s5-1 0)
       (while
        (< s5-1 (-> gp-0 length))
        (format '#t L328 s5-1 (-> (the-as (array uint32) gp-0) s5-1))
        (set! s5-1 (+ s5-1 1))
        )
       (set! v1-10 '#f)
       '#f
       )
      ((= v1-1 'int64)
       (set! s5-2 0)
       (while
        (< s5-2 (-> gp-0 length))
        (format '#t L328 s5-2 (-> (the-as (array int64) gp-0) s5-2))
        (set! s5-2 (+ s5-2 1))
        )
       (set! v1-15 '#f)
       '#f
       )
      ((= v1-1 'uint64)
       (set! s5-3 0)
       (while
        (< s5-3 (-> gp-0 length))
        (format '#t L327 s5-3 (-> (the-as (array uint64) gp-0) s5-3))
        (set! s5-3 (+ s5-3 1))
        )
       (set! v1-20 '#f)
       '#f
       )
      ((= v1-1 'int8)
       (set! s5-4 0)
       (while
        (< s5-4 (-> gp-0 length))
        (format '#t L328 s5-4 (-> (the-as (array int8) gp-0) s5-4))
        (set! s5-4 (+ s5-4 1))
        )
       (set! v1-24 '#f)
       '#f
       )
      ((= v1-1 'uint8)
       (set! s5-5 0)
       (while
        (< s5-5 (-> gp-0 length))
        (format '#t L328 s5-5 (-> (the-as (array int8) gp-0) s5-5))
        (set! s5-5 (+ s5-5 1))
        )
       (set! v1-28 '#f)
       '#f
       )
      ((= v1-1 'int16)
       (set! s5-6 0)
       (while
        (< s5-6 (-> gp-0 length))
        (format '#t L328 s5-6 (-> (the-as (array int16) gp-0) s5-6))
        (set! s5-6 (+ s5-6 1))
        )
       (set! v1-33 '#f)
       '#f
       )
      ((= v1-1 'uint16)
       (set! s5-7 0)
       (while
        (< s5-7 (-> gp-0 length))
        (format '#t L328 s5-7 (-> (the-as (array uint16) gp-0) s5-7))
        (set! s5-7 (+ s5-7 1))
        )
       (set! v1-38 '#f)
       '#f
       )
      (else
       (set! v1-40 (or (= v1-1 'int128) (= v1-1 'uint128)))
       (cond
        (v1-40
         (set! s5-8 0)
         (while
          (< s5-8 (-> gp-0 length))
          (set! t9-14 format)
          (set! a0-25 '#t)
          (set! a1-15 L327)
          (set! a2-13 s5-8)
          (set! v1-42 (+ (shl s5-8 4) (the-as int gp-0)))
          (.lq a3-10 12 v1-42)
          (t9-14 a0-25 a1-15 a2-13 a3-10)
          (set! s5-8 (+ s5-8 1))
          )
         (set! v1-44 '#f)
         '#f
         )
        (else
         (set! s5-9 0)
         (while
          (< s5-9 (-> gp-0 length))
          (format '#t L328 s5-9 (-> gp-0 s5-9))
          (set! s5-9 (+ s5-9 1))
          )
         (set! v1-49 '#f)
         '#f
         )
        )
       v1-39
       )
      )
     )
    (else
     (cond
      ((= (-> gp-0 content-type) float)
       (set! s5-10 0)
       (while
        (< s5-10 (-> gp-0 length))
        (format '#t L326 s5-10 (-> gp-0 s5-10))
        (set! s5-10 (+ s5-10 1))
        )
       (set! v1-55 '#f)
       '#f
       )
      (else
       (set! s5-11 0)
       (while
        (< s5-11 (-> gp-0 length))
        (format '#t L325 s5-11 (-> gp-0 s5-11))
        (set! s5-11 (+ s5-11 1))
        )
       (set! v1-60 '#f)
       '#f
       )
      )
     )
    )
   gp-0
   )
  )

(defmethod length array ((a0-0 array))
  (-> a0-0 length)
  )

(defmethod asize-of array ((a0-0 array))
  (local-vars
   (s4-0 array)
   )
  (begin
   (set! s4-0 a0-0)
   (the-as
    int
    (+
     (-> array size)
     (the-as
      uint
      (*
       (-> s4-0 allocated-length)
       (if
        (type-type? (-> s4-0 content-type) number)
        (-> s4-0 content-type size)
        4
        )
       )
      )
     )
    )
   )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; memcpy and similar
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mem-copy! ((a0-0 pointer) (a1-0 pointer) (a2-0 int))
  (local-vars
   (v0-0 pointer)
   (v1-0 int)
   (v1-1 symbol)
   (v1-2 symbol)
   )
  (begin
   (set! v0-0 a0-0)
   (set! v1-0 0)
   (while
    (< v1-0 a2-0)
    (set! (-> (the-as (pointer int8) a0-0)) (-> (the-as (pointer uint8) a1-0)))
    (set! a0-0 (+ a0-0 (the-as uint 1)))
    (set! a1-0 (+ a1-0 (the-as uint 1)))
    (set! v1-0 (+ v1-0 1))
    )
   (set! v1-1 '#f)
   (set! v1-2 '#f)
   v0-0
   )
  )

(defun mem-set32! ((a0-0 pointer) (a1-0 int) (a2-0 int))
  (local-vars
   (v0-0 pointer)
   (v1-0 int)
   (v1-1 symbol)
   (v1-2 symbol)
   )
  (begin
   (set! v0-0 a0-0)
   (set! v1-0 0)
   (while
    (< v1-0 a1-0)
    (set! (-> (the-as (pointer int32) a0-0)) a2-0)
    (set! a0-0 (+ a0-0 (the-as uint 4)))
    (nop!)
    (set! v1-0 (+ v1-0 1))
    )
   (set! v1-1 '#f)
   (set! v1-2 '#f)
   v0-0
   )
  )

(defun mem-or! ((a0-0 pointer) (a1-0 pointer) (a2-0 int))
  (local-vars
   (v0-0 pointer)
   (v1-0 int)
   (v1-1 symbol)
   (v1-2 symbol)
   )
  (begin
   (set! v0-0 a0-0)
   (set! v1-0 0)
   (while
    (< v1-0 a2-0)
    (set!
     (-> (the-as (pointer int8) a0-0))
     (logior
      (-> (the-as (pointer uint8) a0-0))
      (-> (the-as (pointer uint8) a1-0))
      )
     )
    (set! a0-0 (+ a0-0 (the-as uint 1)))
    (set! a1-0 (+ a1-0 (the-as uint 1)))
    (set! v1-0 (+ v1-0 1))
    )
   (set! v1-1 '#f)
   (set! v1-2 '#f)
   v0-0
   )
  )

(defun fact ((a0-0 int))
  (local-vars
   (gp-0 int)
   )
  (begin (set! gp-0 a0-0) (if (= gp-0 1) 1 (* gp-0 (fact (+ gp-0 -1)))))
  )

(defun print ((a0-0 object))
  ((method-of-type (type-of a0-0) print) a0-0)
  )

(defun printl ((a0-0 object))
  (local-vars
   (v1-2 object)
   (a0-1 object)
   (gp-0 object)
   )
  (begin
   (set! gp-0 a0-0)
   (set! a0-1 gp-0)
   (set! v1-2 ((method-of-type (type-of a0-1) print) a0-1))
   (format '#t L324)
   gp-0
   )
  )

(defun inspect ((a0-0 object))
  ((method-of-type (type-of a0-0) inspect) a0-0)
  )

(defun print-tree-bitmask ((a0-0 int) (a1-0 int))
  (local-vars
   (v1-3 symbol)
   (s4-0 int)
   (s5-0 int)
   (gp-0 int)
   )
  (begin
   (set! gp-0 a0-0)
   (set! s5-0 a1-0)
   (set! s4-0 0)
   (while
    (< s4-0 s5-0)
    (if (zero? (logand gp-0 1)) (format '#t L323) (format '#t L322))
    (set! gp-0 (shr (the-as uint gp-0) 1))
    (set! s4-0 (+ s4-0 1))
    )
   (set! v1-3 '#f)
   '#f
   )
  )

(defun valid? ((a0-0 object) (a1-0 type) (a2-0 basic) (a3-0 basic) (a4-0 object))
  (local-vars
   (v1-1 symbol)
   (v1-3 symbol)
   (v1-4 object)
   (v1-5 symbol)
   (v1-6 object)
   (v1-7 symbol)
   (v1-8 object)
   (v1-9 symbol)
   (v1-10 int)
   (v1-11 int)
   (v1-12 symbol)
   (v1-13 object)
   (v1-14 symbol)
   (v1-15 object)
   (v1-16 symbol)
   (v1-17 object)
   (v1-19 symbol)
   (v1-20 object)
   (v1-21 symbol)
   (v1-22 object)
   (v1-23 symbol)
   (v1-24 object)
   (v1-26 symbol)
   (v1-29 symbol)
   (v1-31 object)
   (v1-33 symbol)
   (v1-35 symbol)
   (v1-37 object)
   (v1-39 symbol)
   (v1-41 object)
   (v1-43 int)
   (v1-44 int)
   (v1-45 symbol)
   (v1-46 object)
   (v1-47 int)
   (v1-48 int)
   (v1-49 symbol)
   (v1-50 object)
   (a0-5 basic)
   (s3-0 type)
   (s4-0 basic)
   (s5-0 object)
   (s7-0 none)
   (gp-0 object)
   )
  (begin
   (set!
    v1-1
    (begin
     (set! gp-0 a0-0)
     (set! s3-0 a1-0)
     (set! s4-0 a2-0)
     (set! s5-0 t0-0)
     (and
      (>= (the-as uint gp-0) (the-as uint __START-OF-TABLE__))
      (< (the-as uint gp-0) (the-as uint 134217728))
      )
     )
    )
   (cond
    ((not s3-0)
     (cond
      ((nonzero? (logand (the-as int gp-0) 3))
       (if s4-0 (set! v1-4 (format s5-0 L321 gp-0 s4-0)))
       '#f
       )
      ((not v1-1) (if s4-0 (set! v1-6 (format s5-0 L320 gp-0 s4-0))) '#f)
      (else '#t)
      )
     )
    ((and a3-0 (not gp-0)) '#t)
    (else
     (cond
      ((= s3-0 structure)
       (cond
        ((nonzero? (logand (the-as int gp-0) 15))
         (if s4-0 (set! v1-8 (format s5-0 L319 gp-0 s4-0 s3-0)))
         '#f
         )
        ((or
          (not v1-1)
          (begin
           (set! v1-10 32768)
           (.daddu v1-11 v1-10 s7-0)
           (< (the-as uint gp-0) (the-as uint v1-11))
           )
          )
         (if s4-0 (set! v1-13 (format s5-0 L318 gp-0 s4-0 s3-0)))
         '#f
         )
        (else '#t)
        )
       )
      ((= s3-0 pair)
       (cond
        ((!= (logand (the-as int gp-0) 7) 2)
         (if s4-0 (set! v1-15 (format s5-0 L319 gp-0 s4-0 s3-0)))
         '#f
         )
        ((not v1-1)
         (if s4-0 (set! v1-17 (format s5-0 L318 gp-0 s4-0 s3-0)))
         '#f
         )
        (else '#t)
        )
       )
      ((= s3-0 binteger)
       (cond
        ((zero? (logand (the-as int gp-0) 7)) '#t)
        (else (if s4-0 (set! v1-20 (format s5-0 L319 gp-0 s4-0 s3-0))) '#f)
        )
       )
      ((!= (logand (the-as int gp-0) 7) 4)
       (if s4-0 (set! v1-22 (format s5-0 L319 gp-0 s4-0 s3-0)))
       '#f
       )
      ((not v1-1) (if s4-0 (set! v1-24 (format s5-0 L318 gp-0 s4-0 s3-0))) '#f)
      ((and (= s3-0 type) (!= (type-of gp-0) type))
       (if s4-0 (set! v1-31 (format s5-0 L317 gp-0 s4-0 s3-0 (type-of gp-0))))
       '#f
       )
      (else
       (set!
        v1-33
        (and (!= s3-0 type) (not (valid? (type-of gp-0) type '#f '#t 0)))
        )
       (cond
        (v1-33
         (if s4-0 (set! v1-37 (format s5-0 L317 gp-0 s4-0 s3-0 (type-of gp-0))))
         '#f
         )
        ((not (type-type? (type-of gp-0) s3-0))
         (if s4-0 (set! v1-41 (format s5-0 L316 gp-0 s4-0 s3-0 (type-of gp-0))))
         '#f
         )
        ((= s3-0 symbol)
         (set! v1-43 32768)
         (.daddu v1-44 v1-43 s7-0)
         (cond
          ((>= (the-as uint gp-0) (the-as uint v1-44))
           (if s4-0 (set! v1-46 (format s5-0 L315 gp-0 s4-0 s3-0)))
           '#f
           )
          (else '#t)
          )
         )
        ((begin
          (set! v1-47 32768)
          (.daddu v1-48 v1-47 s7-0)
          (< (the-as uint gp-0) (the-as uint v1-48))
          )
         (if s4-0 (set! v1-50 (format s5-0 L314 gp-0 s4-0 s3-0)))
         '#f
         )
        (else '#t)
        )
       )
      )
     )
    )
   )
  )

(defun mem-print ((a0-0 (pointer uint32)) (a1-0 int))
  (local-vars
   (v1-19 symbol)
   (s4-0 int)
   (s5-0 int)
   (gp-0 (pointer uint32))
   )
  (begin
   (set! gp-0 a0-0)
   (set! s5-0 a1-0)
   (set! s4-0 0)
   (while
    (< s4-0 (sar s5-0 2))
    (format
     0
     L354
     (+ (+ (shl (shl s4-0 2) 2) 0) (the-as int gp-0))
     (-> gp-0 (shl s4-0 2))
     (-> gp-0 (+ (shl s4-0 2) 1))
     (-> gp-0 (+ (shl s4-0 2) 2))
     (-> gp-0 (+ (shl s4-0 2) 3))
     )
    (set! s4-0 (+ s4-0 1))
    )
   (set! v1-19 '#f)
   '#f
   )
  )