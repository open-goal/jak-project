;;-*-Lisp-*-
(in-package goal)

;; name: geometry.gc
;; name in dgo: geometry
;; dgos: GAME, ENGINE

(defun vector-flatten! ((dst vector) (src vector) (plane-normal vector))
  "Get the projection of src onto a plane with the given normal
   The normal should have magnitude 1.0."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf) ;; src
         (vf2 :class vf) ;; normal
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> src quad))
    (.lvf vf2 (&-> plane-normal quad))
    (.mov.vf vf3 vf0 :mask #b1000)
    (.outer.product.vf vf3 vf1 vf2) ;; has the right magnitude, but rotation is off by 90 degrees
    (.outer.product.vf vf3 vf2 vf3) ;; rotate by 90 about normal of plane
    (.svf (&-> dst quad) vf3)
    dst
    )
  )

(defun vector-reflect! ((dst vector) (src vector) (plane-normal vector))
  "Reflect a vector off of a plane."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    ;; we want to split the vector into normal / tangent components.
    ;; let src = T + N, where T dot plane-normal = 0.
    ;; then the reflection is T - N = 2 * T - src.
    ;; we can compute T from vector-flatten!'s trick
    (init-vf0-vector)
    (.lvf vf1 (&-> src quad))
    (.lvf vf2 (&-> plane-normal quad))
    (.mov.vf vf3 vf0 :mask #b1000)
    (.outer.product.vf vf3 vf1 vf2)
    (.outer.product.vf vf3 vf2 vf3) ;; vf3 is the projection on the plane
    (.add.vf acc vf3 vf3 :mask #b111) ;; double that part
    (.sub.mul.w.vf vf3 vf1 vf0 acc :mask #b111) ;; and subtract the original
    (.svf (&-> dst quad) vf3)
    dst
    )
  )

(defun vector-reflect-flat! ((dst vector) (src vector) (plane-normal vector))
  "This is a weird one. It doesn't care about the value of src dot normal
   and it effectively replaces the component of src normal to the plane with
   the plane's normal.  I think this requires src/normal to both be unit vectors
   in order to make sense.
   NOTE: src should point from positive halfspace to negative otherwise it
   doesn't work."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> src quad))
    (.lvf vf2 (&-> plane-normal quad))
    (.mov.vf vf3 vf0 :mask #b1000)
    (.outer.product.vf vf3 vf1 vf2)
    (.outer.product.vf vf3 vf2 vf3) ;; part on the plane (requires normal to be unit)
    (.add.vf vf3 vf3 vf2 :mask #b111) ;; add normal to that.
    (.svf (&-> dst quad) vf3)
    dst
    )
  )

(defun vector-reflect-true-flat! ((dst vector) (src vector) (plane-normal vector))
  "Not really a reflect. Same as flatten"
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> src quad))
    (.lvf vf2 (&-> plane-normal quad))
    (.mov.vf vf3 vf0 :mask #b1000)
    (.outer.product.vf vf3 vf1 vf2)
    (.outer.product.vf vf3 vf2 vf3)
    (.svf (&-> dst quad) vf3)
    dst
    )
  )

(defun vector-reflect-flat-above! ((dst vector) (src vector) (plane-normal vector))
  "A hacked up version of reflect, probably to make their collision system work.
   It is a less aggressive version of reflect that also has a limit to the output
   normal component"
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> src quad))
    (.lvf vf2 (&-> plane-normal quad))
    (.mov.vf vf3 vf0 :mask #b1000)
    (.outer.product.vf vf3 vf1 vf2)
    (.outer.product.vf vf3 vf2 vf3)
    (.svf (&-> dst quad) vf3)

    ;; dst is now the normal part of src
    (let* ((f0-0 (vector-length dst)) ;; len of normal component
           (f1-1 (vector-dot dst plane-normal)) ;; always zero?
           ;; f1-3 = .02 * length of normal.  f1-2 is always zero here
           (f1-2 (- (* 0.02 f0-0) f1-1))
           )

      ;; scale down and limit the normal component
      (vector+float*! dst dst plane-normal (fmin 16384.0 (* 16.0 f1-2)))
      )
    )
  )

(defun vector-segment-distance-point! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (local-vars (v0-0 float) (v1-0 float) (v1-1 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    (.lvf vf3 (&-> arg1 quad))
    (.lvf vf4 (&-> arg2 quad))
    (.lvf vf5 (&-> arg0 quad))
    (.sub.vf vf1 vf4 vf3)
    (.sub.vf vf6 vf5 vf3)
    (.mul.vf vf2 vf1 vf1)
    (.mul.x.vf acc vf0 vf2 :mask #b1000)
    (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
    (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
    (.sqrt.vf Q vf2 :ftf #b11)
    (.wait.vf)
    (.add.vf vf2 vf0 Q :mask #b1)
    (.nop.vf)
    (.nop.vf)
    (.div.vf Q vf0 vf2 :fsf #b11 :ftf #b0)
    (.mov v1-0 vf2)
    (let ((f2-0 v1-0))
      (.wait.vf)
      (.mul.vf vf1 vf1 Q)
      (.mul.vf vf7 vf1 vf6)
      (let ((f1-0 0.0))
        (.add.y.vf vf7 vf7 vf7 :mask #b1)
        (.add.z.vf vf7 vf7 vf7 :mask #b1)
        (.mov v1-1 vf7)
        (let ((f0-0 v1-1))
          (b! (< f0-0 f1-0) cfg-4 :likely-delay (set! f0-0 f1-0))
          (b! (< f2-0 f0-0) cfg-4 :likely-delay (set! f0-0 f2-0))
          (label cfg-4)
          (let ((v1-2 f0-0))
            (.mov vf7 v1-2)
            )
          )
        )
      )
    (.mul.x.vf vf1 vf1 vf7)
    (b! (= arg3 #f) cfg-6 :delay (.mov.vf vf8 vf0 :mask #b1000))
    (.add.vf vf8 vf3 vf1 :mask #b111)
    (.svf (&-> arg3 quad) vf8)
    (label cfg-6)
    (.sub.vf vf2 vf6 vf1)
    (.mul.vf vf2 vf2 vf2)
    (.mul.x.vf acc vf0 vf2 :mask #b1000)
    (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
    (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
    (.sqrt.vf Q vf2 :ftf #b11)
    (.wait.vf)
    (.add.vf vf2 vf0 Q :mask #b1)
    (.nop.vf)
    (.mov v0-0 vf2)
    v0-0
    )
  )

(defun vector-line-distance ((arg0 vector) (arg1 vector) (arg2 vector))
  (let* ((a1-3 (vector-normalize! (vector-! (new-stack-vector0) arg2 arg1) 1.0))
         (gp-1 (vector-! (new-stack-vector0) arg0 arg1))
         (f0-1 (vector-dot a1-3 gp-1))
         (v1-3 (vector-float*! (new-stack-vector0) a1-3 f0-1))
         )
    (vector-length (vector-! (new-stack-vector0) gp-1 v1-3))
    )
  )

(defun vector-line-distance-point! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (let* ((a1-3 (vector-normalize! (vector-! (new-stack-vector0) arg2 arg1) 1.0))
         (s4-1 (vector-! (new-stack-vector0) arg0 arg1))
         (f0-1 (vector-dot a1-3 s4-1))
         (v1-4 (vector-float*! (new-stack-vector0) a1-3 f0-1))
         )
    (if arg3
        (vector+! arg3 arg1 v1-4)
        )
    (vector-length (vector-! (new-stack-vector0) s4-1 v1-4))
    )
  )

(defun vector-orient-by-quat! ((arg0 vector) (arg1 vector) (arg2 quaternion))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> arg2 vec quad))
    (.lvf vf6 (&-> arg1 quad))
    (.add.vf vf5 vf1 vf1)
    (.add.w.vf vf2 vf0 vf1 :mask #b1)
    (.add.z.vf vf2 vf0 vf1 :mask #b10)
    (.sub.y.vf vf2 vf0 vf1 :mask #b100)
    (.sub.w.vf vf2 vf0 vf0 :mask #b1000)
    (.sub.z.vf vf3 vf0 vf1 :mask #b1)
    (.add.w.vf vf3 vf0 vf1 :mask #b10)
    (.add.x.vf vf3 vf0 vf1 :mask #b100)
    (.sub.w.vf vf3 vf0 vf0 :mask #b1000)
    (.add.y.vf vf4 vf0 vf1 :mask #b1)
    (.sub.x.vf vf4 vf0 vf1 :mask #b10)
    (.add.w.vf vf4 vf0 vf1 :mask #b100)
    (.sub.w.vf vf4 vf0 vf0 :mask #b1000)
    (.outer.product.vf vf2 vf5 vf2)
    (.outer.product.vf vf3 vf5 vf3)
    (.outer.product.vf vf4 vf5 vf4)
    (.add.w.vf vf2 vf2 vf0 :mask #b1)
    (.add.w.vf vf3 vf3 vf0 :mask #b10)
    (.add.w.vf vf4 vf4 vf0 :mask #b100)
    (.mul.w.vf acc vf0 vf6)
    (.add.mul.x.vf acc vf2 vf6 acc)
    (.add.mul.y.vf acc vf3 vf6 acc)
    (.add.mul.z.vf vf6 vf4 vf6 acc)
    (.svf (&-> arg0 quad) vf6)
    arg0
    )
  )

(defun forward-down->inv-matrix ((arg0 matrix) (arg1 vector) (arg2 vector))
  (vector-normalize-copy! (-> arg0 vector 2) arg1 1.0)
  (vector-cross! (the-as vector (-> arg0 vector)) (-> arg0 vector 2) arg2)
  (vector-normalize! (the-as vector (-> arg0 vector)) 1.0)
  (vector-cross! (-> arg0 vector 1) arg1 (the-as vector (-> arg0 vector)))
  (vector-normalize! (-> arg0 vector 1) 1.0)
  (set! (-> arg0 vector 3 quad) (the-as uint128 0))
  (set! (-> arg0 vector 0 w) 0.0)
  (set! (-> arg0 vector 1 w) 0.0)
  (set! (-> arg0 vector 2 w) 0.0)
  (set! (-> arg0 vector 3 w) 1.0)
  arg0
  )

(defun forward-down-nopitch->inv-matrix ((arg0 matrix) (arg1 vector) (arg2 vector))
  (vector-normalize-copy! (-> arg0 vector 1) arg2 1.0)
  (vector-negate! (-> arg0 vector 1) (-> arg0 vector 1))
  (vector-cross! (the-as vector (-> arg0 vector)) (-> arg0 vector 1) arg1)
  (vector-normalize! (the-as vector (-> arg0 vector)) 1.0)
  (vector-cross!
   (-> arg0 vector 2)
   (the-as vector (-> arg0 vector))
   (-> arg0 vector 1)
   )
  (vector-normalize! (-> arg0 vector 2) 1.0)
  (set! (-> arg0 vector 3 quad) (the-as uint128 0))
  (set! (-> arg0 vector 0 w) 0.0)
  (set! (-> arg0 vector 1 w) 0.0)
  (set! (-> arg0 vector 2 w) 0.0)
  (set! (-> arg0 vector 3 w) 1.0)
  arg0
  )

(defun forward-up-nopitch->inv-matrix ((arg0 matrix) (arg1 vector) (arg2 vector))
  (forward-down-nopitch->inv-matrix arg0 arg1 (vector-negate! (new-stack-vector0) arg2))
  )

(defun forward-up-nopitch->quaternion ((arg0 quaternion) (arg1 vector) (arg2 vector))
  (matrix->quaternion arg0 (forward-up-nopitch->inv-matrix (new-stack-matrix0) arg1 arg2))
  )

(defun forward-up->quaternion ((arg0 quaternion) (arg1 vector) (arg2 vector))
  (matrix->quaternion arg0
                      (forward-down->inv-matrix
                       (new-stack-matrix0)
                       arg1
                       (vector-negate! (new 'stack-no-clear 'vector) arg2)
                       )
                      )
  )

(defun quaternion-from-two-vectors! ((arg0 quaternion) (arg1 vector) (arg2 vector))
  (let* ((s5-0 (vector-cross! (new-stack-vector0) arg1 arg2))
         (f0-0 (vector-length s5-0))
         (f1-1 (vector-dot arg1 arg2))
         )
    (let ((f0-1 (/ (sqrtf (* 0.5 (- 1.0 f1-1))) f0-0)))
      (set! (-> arg0 x) (* (-> s5-0 x) f0-1))
      (set! (-> arg0 y) (* (-> s5-0 y) f0-1))
      (set! (-> arg0 z) (* (-> s5-0 z) f0-1))
      )
    (set! (-> arg0 w) (sqrtf (* 0.5 (+ 1.0 f1-1))))
    )
  arg0
  )

(defun quaternion-from-two-vectors-max-angle! ((arg0 quaternion) (arg1 vector) (arg2 vector) (arg3 float))
  (let* ((s5-0 (vector-cross! (new-stack-vector0) arg1 arg2))
         (f30-0 (vector-length s5-0))
         (f26-0 (vector-dot arg1 arg2))
         (f28-0 (sqrtf (* 0.5 (- 1.0 f26-0))))
         )
    (let ((f0-5 (sin (* 0.5 arg3))))
      (cond
        ((< f0-5 f28-0)
         (set! f28-0 f0-5)
         (set! (-> arg0 w) (cos (* 0.5 arg3)))
         )
        (else
         (set! (-> arg0 w) (sqrtf (* 0.5 (+ 1.0 f26-0))))
         )
        )
      )
    (let ((f0-12 (/ f28-0 f30-0)))
      (set! (-> arg0 x) (* (-> s5-0 x) f0-12))
      (set! (-> arg0 y) (* (-> s5-0 y) f0-12))
      (set! (-> arg0 z) (* (-> s5-0 z) f0-12))
      )
    )
  arg0
  )

(defun matrix-from-two-vectors! ((arg0 matrix) (arg1 vector) (arg2 vector))
  (let* ((a1-3 (vector-normalize! (vector-cross! (new-stack-vector0) arg2 arg1) 1.0))
         (f0-1 (vector-dot arg1 arg2))
         (f1-0 1.0)
         (f2-0 f0-1)
         (f1-2 (sqrtf (- f1-0 (* f2-0 f2-0))))
         )
    (matrix-axis-sin-cos! arg0 a1-3 f1-2 f0-1)
    )
  )

(defun matrix-from-two-vectors-max-angle! ((arg0 matrix) (arg1 vector) (arg2 vector) (arg3 float))
  (let
      ((s4-1 (vector-normalize! (vector-cross! (new-stack-vector0) arg2 arg1) 1.0))
       (f30-0 (vector-dot arg1 arg2))
       (f28-0 (cos arg3))
       )
    (cond
      ((< f30-0 f28-0)
       (matrix-axis-sin-cos! arg0 s4-1 (sin arg3) f28-0)
       )
      (else
       ;; todo looks bad because of inline (square x)
       (let ((t9-5 matrix-axis-sin-cos!)
             (a0-6 arg0)
             (a1-4 s4-1)
             (f0-1 1.0)
             (f1-0 f30-0)
             )
         (t9-5 a0-6 a1-4 (sqrtf (- f0-1 (* f1-0 f1-0))) f30-0)
         )
       )
      )
    )
  )

(defun matrix-from-two-vectors-max-angle-partial! ((arg0 matrix) (arg1 vector) (arg2 vector) (arg3 float) (arg4 float))
  (let* ((s4-1 (vector-normalize! (vector-cross! (new-stack-vector0) arg2 arg1) 1.0))
         (f28-0 (vector-dot arg1 arg2))
         (f30-0 (cos arg3))
         (f0-2 (+ 1.0 (* (+ -1.0 f28-0) arg4)))
         )
    (cond
      ((< f0-2 f30-0)
       (matrix-axis-sin-cos! arg0 s4-1 (sin arg3) f30-0)
       )
      (else
       ;; todo looks bad because of inline (square x)
       (let ((t9-5 matrix-axis-sin-cos!)
             (a0-6 arg0)
             (a1-4 s4-1)
             (f1-3 1.0)
             (f2-1 f0-2)
             )
         (t9-5 a0-6 a1-4 (sqrtf (- f1-3 (* f2-1 f2-1))) f0-2)
         )
       )
      )
    )
  )

(defun matrix-from-two-vectors-partial-linear! ((arg0 matrix) (arg1 vector) (arg2 vector) (arg3 float))
  (let ((gp-1 (vector-normalize! (vector-cross! (new-stack-vector0) arg2 arg1) 1.0))
        (f0-1 (vector-dot arg1 arg2))
        )
    (cond
      ((< 0.9999 (fabs f0-1))
       (matrix-identity! arg0)
       )
      (else
       (let* ((f0-4 (cos (* arg3 (acos f0-1))))
              (t9-5 matrix-axis-sin-cos!)
              (a0-6 arg0)
              (f1-1 1.0)
              (f2-1 f0-4)
              )
         (t9-5 a0-6 gp-1 (sqrtf (- f1-1 (* f2-1 f2-1))) f0-4)
         )
       )
      )
    )
  )

(defun matrix-remove-z-rot ((arg0 matrix) (arg1 matrix))
  (let ((s4-0 (new-stack-vector0)))
    0.0
    0.0
    (let ((s5-0 (new-stack-matrix0)))
      (vector-negate! s4-0 (the-as vector arg1))
      (vector-flatten! s4-0 s4-0 (-> arg0 vector 2))
      (vector-normalize! s4-0 1.0)
      (let ((f30-0 (vector-dot (-> arg0 vector 1) s4-0)))
        (when (< f30-0 0.99999)
          (vector-cross! s4-0 (-> arg0 vector 1) s4-0)
          (let ((f0-4 (vector-length s4-0)))
            (if (< 0.0 (vector-dot s4-0 (-> arg0 vector 2)))
                (set! f0-4 (- f0-4))
                )
            (matrix-axis-sin-cos! s5-0 (-> arg0 vector 2) f0-4 f30-0)
            )
          (matrix*! arg0 arg0 s5-0)
          )
        )
      )
    )
  arg0
  )

(defun matrix-rot-diff! ((arg0 vector) (arg1 matrix) (arg2 matrix))
  (let ((s3-0 (new-stack-quaternion0))
        (s2-0 (new-stack-quaternion0))
        (s5-0 (new-stack-quaternion0))
        )
    0.0
    (matrix->quaternion s3-0 arg1)
    (matrix->quaternion s2-0 arg2)
    (quaternion-conjugate! s5-0 s3-0)
    (quaternion*! s5-0 s2-0 s5-0)
    (quaternion-normalize! s5-0)
    (if (< (-> s5-0 w) 0.0)
        (quaternion-negate! s5-0 s5-0)
        )
    (let ((f30-1 (* 2.0 (acos (-> s5-0 w)))))
      (set! (-> arg0 quad) (-> s5-0 vec quad))
      (vector-negate! arg0 arg0)
      (if (= (vector-normalize-ret-len! arg0 1.0) 0.0)
          (set! (-> arg0 y) 1.0)
          )
      f30-1
      )
    )
  )


(defun quaternion-seek ((arg0 quaternion) (arg1 quaternion) (arg2 quaternion) (arg3 float) (arg4 float))
  (let ((s5-0 (new-stack-matrix0))
        (s4-0 (new-stack-matrix0))
        )
    (quaternion->matrix s5-0 arg1)
    (quaternion->matrix s4-0 arg2)
    (let ((s2-1 (new-stack-quaternion0)))
      (quaternion-from-two-vectors-max-angle!
       s2-1
       (-> s5-0 vector 2)
       (-> s4-0 vector 2)
       arg4
       )
      (quaternion-normalize! (quaternion*! arg0 arg0 s2-1))
      )
    )
  )

(defun vector-deg-seek ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (let ((s4-0 (new-stack-matrix0)))
    (matrix-from-two-vectors-max-angle! s4-0 arg1 arg2 arg3)
    (vector-matrix*! arg0 arg1 s4-0)
    )
  )

(defun vector-deg-slerp ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (cond
    ((>= 0.0 arg3)
     (set! (-> arg0 quad) (-> arg1 quad))
     arg0
     )
    ((>= arg3 1.0)
     (set! (-> arg0 quad) (-> arg2 quad))
     arg0
     )
    (else
     (let ((s1-0 (new-stack-matrix0)))
       (let
           ((s2-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 1.0))
            (a2-3 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg2 1.0))
            )
         (matrix-from-two-vectors-partial-linear! s1-0 s2-0 a2-3 arg3)
         )
       (vector-matrix*! arg0 arg1 s1-0)
       )
     )
    )
  )

(defun vector-vector-deg-slerp! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float) (arg4 vector))
  (local-vars (sv-112 (function float float float float)))
  (cond
    ((>= 0.0 arg3)
     (set! (-> arg0 quad) (-> arg1 quad))
     )
    ((>= arg3 1.0)
     (set! (-> arg0 quad) (-> arg2 quad))
     )
    (else
     (let*
         ((s0-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 1.0))
          (s1-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg2 1.0))
          (s0-1 (forward-up->quaternion (new 'stack-no-clear 'quaternion) s0-0 arg4))
          (a2-5 (forward-up->quaternion (new 'stack-no-clear 'quaternion) s1-0 arg4))
          (a1-6 (quaternion-slerp! (new 'stack-no-clear 'quaternion) s0-1 a2-5 arg3))
          (s2-1 vector-normalize-copy!)
          (s1-1 arg0)
          (s0-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) a1-6))
          )
       (set! sv-112 lerp)
       (let ((s3-1 (vector-length arg1))
             (a1-7 (vector-length arg2))
             )
         (s2-1 s1-1 s0-2 (sv-112 s3-1 a1-7 arg3))
         )
       )
     )
    )
  arg0
  )

(defun normal-of-plane ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
   (init-vf0-vector)
   (.lvf vf3 (&-> arg2 quad))
   (.lvf vf1 (&-> arg1 quad))
   (.lvf vf2 (&-> arg3 quad))
   (.sub.vf vf1 vf3 vf1)
   (.sub.vf vf2 vf3 vf2)
   (.outer.product.vf vf4 vf2 vf1)
   (.mul.vf vf5 vf4 vf4)
   (.add.y.vf vf5 vf5 vf5 :mask #b1)
   (.add.z.vf vf5 vf5 vf5 :mask #b1)
   (.isqrt.vf Q vf0 vf5 :fsf #b11 :ftf #b0)
   (.mov.vf vf4 vf0 :mask #b1000)
   (.wait.vf)
   (.mul.vf vf4 vf4 Q :mask #b111)
   (.nop.vf)
   (.nop.vf)
   (.svf (&-> arg0 quad) vf4)
   arg0
   )
  )

(defun vector-3pt-cross! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> arg1 quad))
    (.lvf vf2 (&-> arg2 quad))
    (.lvf vf3 (&-> arg3 quad))
    (.add.x.vf vf4 vf0 vf0 :mask #b1000)
    (.sub.vf vf2 vf2 vf1)
    (.sub.vf vf3 vf3 vf1)
    (.outer.product.vf vf4 vf2 vf3)
    (.svf (&-> arg0 quad) vf4)
    arg0
    )
  )

;; TODO vector-segment-distance-point!

;; TODO - temporary for lights.gc
(define-extern vector-deg-slerp (function vector vector vector float vector))
;; TODO - temporary for transformq.gc
(define-extern forward-up-nopitch->quaternion (function quaternion vector vector quaternion))
(define-extern forward-up->quaternion (function quaternion vector vector quaternion))
(define-extern vector-flatten! (function vector vector vector vector))

;; TODO
(define-extern vector-3pt-cross! (function vector vector vector vector vector))
(define-extern curve-evaluate! (function vector float int int vector int int))
