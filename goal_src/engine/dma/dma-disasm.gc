;;-*-Lisp-*-
(in-package goal)

;; name: dma-disasm.gc
;; name in dgo: dma-disasm
;; dgos: GAME, ENGINE

(deftype vif-disasm-element (structure)
  ((mask    uint32  :offset-assert 0)
   (tag     uint32  :offset-assert 4)
   (val     uint32  :offset-assert 8)
   (print   uint32  :offset-assert 12)
   (string1 string   :offset-assert 16)
   (string2 string   :offset-assert 20)
   )
  :method-count-assert 9
  :size-assert         #x18
  :flag-assert         #x900000018
  )

(define *vif-disasm-table*
    (new 'static 'boxed-array vif-disasm-element 34
         (new 'static 'vif-disasm-element :mask #x7f :string1 "nop")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x1 :print #x2 :string1 "stcycl")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x2 :print #x1 :string1 "offset" :string2 "offset")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x3 :print #x1 :string1 "base" :string2 "base")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x4 :print #x1 :string1 "itop" :string2 "addr")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x5 :print #x1 :string1 "stmod" :string2 "mode")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x6 :print #x1 :string1 "mskpath3" :string2 "mask")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x7 :print #x1 :string1 "mark" :string2 "mark")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x10 :string1 "flushe")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x11 :string1 "flush")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x13 :string1 "flusha")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x14 :print #x1 :string1 "mscal" :string2 "addr")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x17 :string1 "mscnt")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x15 :print #x1 :string1 "mscalf" :string2 "addr")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x20 :print #x3 :string1 "stmask" :string2 "mask")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x30 :print #x4 :string1 "strow" :string2 "row")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x31 :print #x4 :string1 "stcol" :string2 "col")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x4a :print #x5 :string1 "mpg")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x50 :print #x6 :string1 "direct")
         (new 'static 'vif-disasm-element :mask #x7f :tag #x51 :print #x6 :string1 "directhl")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x60 :val #x10 :print #x7 :string1 "unpack-s-32")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x61 :val #x8 :print #x7 :string1 "unpack-s-16")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x62 :val #x4 :print #x7 :string1 "unpack-s-8")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x64 :val #x8 :print #x7 :string1 "unpack-v2-32")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x65 :val #x4 :print #x7 :string1 "unpack-v2-16")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x66 :val #x2 :print #x7 :string1 "unpack-v2-8")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x68 :val #xc :print #x7 :string1 "unpack-v3-32")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x69 :val #x6 :print #x7 :string1 "unpack-v3-16")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x6a :val #x3 :print #x7 :string1 "unpack-v3-8")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x6c :val #x10 :print #x7 :string1 "unpack-v4-32")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x6d :val #x8 :print #x7 :string1 "unpack-v4-16")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x6e :val #x4 :print #x7 :string1 "unpack-v4-8")
         (new 'static 'vif-disasm-element :mask #x6f :tag #x6f :val #x2 :print #x7 :string1 "unpack-v4-5")
         (new 'static 'vif-disasm-element :print #x8)))
 
(defun disasm-vif-details ((stream symbol) (data (pointer uint8)) (kind int) (count int))
  (local-vars
   (v1-21 uint)
   (v1-26 uint)
   (a3-7 int)
   (i int)
   (s2-1 int)
   (s2-2 int)
   (s2-3 int)
   (s2-4 int)
   (s2-5 int)
   (s2-6 int)
   (data-ptr (pointer uint8))
   (s3-1 (pointer uint8))
   (s3-2 (pointer uint8))
   (s3-3 (pointer uint8))
   (s3-4 (pointer uint8))
   (s3-5 (pointer uint8))
   (s3-6 (pointer uint8))
   (count2 int)
   )
  (set! count2 count)
  (cond
    ((= kind 110)
     (set! data-ptr (&-> data 4))
     (set! i 0)
     (while (< i count2)
       (format stream "  #x~X:    #x~2X #x~2X #x~2X #x~2X~%"
               (+ (+ (shl i 2) 4) (the-as int data))
               (-> (the-as (pointer uint8) (&+ data-ptr (shl i 2))))
               (-> (the-as (pointer uint8) (&+ data-ptr (+ (shl i 2) 1))))
               (-> (the-as (pointer uint8) (&+ data-ptr (+ (shl i 2) 2))))
               (-> (the-as (pointer uint8) (&+ data-ptr (+ (shl i 2) 3))))
               )
       (+! i 1)
       )
     )
    ((= kind 98)
     (set! s3-1 (&-> data 4))
     (set! s2-1 0)
     (while (< s2-1 count2)
       (format stream "  #x~X:    #x~2x~%" (+ (+ s2-1 4) (the-as int data)) count)
       (set! v1-21 (-> (the-as (pointer uint8) (&+ s3-1 (* 3 s2-1)))))
       (set! v1-26 (-> (the-as (pointer uint8) (&+ s3-1 (+ (* 3 s2-1) 1)))))
       (+! s2-1 1)
       )
     )
    ((= kind 108)
     (set! s3-2 (&-> data 4))
     (set! s2-2 0)
     (while (< s2-2 count2)
       (format stream "  #x~X:    #x~8x #x~8x #x~8x #x~8x~%"
               (+ (+ (shl s2-2 4) 4) (the-as int data))
               (-> (the-as (pointer uint32) (&+ s3-2 (shl (shl s2-2 2) 2))))
               (-> (the-as (pointer uint32) (&+ s3-2 (shl (+ (shl s2-2 2) 1) 2))))
               (-> (the-as (pointer uint32) (&+ s3-2 (shl (+ (shl s2-2 2) 2) 2))))
               (-> (the-as (pointer uint32) (&+ s3-2 (shl (+ (shl s2-2 2) 3) 2))))
               )
       (+! s2-2 1)
       )
     )
    ((= kind 109)
     (set! s3-3 (&-> data 4))
     (set! s2-3 0)
     (while
         (< s2-3 count2)
       (format stream "  #x~X:    #x~4x #x~4x #x~4x #x~4x~%"
               (+ (+ (shl s2-3 3) 4) (the-as int data))
               (-> (the-as (pointer uint16) (&+ s3-3 (shl (shl s2-3 2) 1))))
               (-> (the-as (pointer uint16) (&+ s3-3 (shl (+ (shl s2-3 2) 1) 1))))
               (-> (the-as (pointer uint16) (&+ s3-3 (shl (+ (shl s2-3 2) 2) 1))))
               (-> (the-as (pointer uint16) (&+ s3-3 (shl (+ (shl s2-3 2) 3) 1))))
               )
       (+! s2-3 1)
       )
     )
    ((= kind 104)
     (set! s3-4 (&-> data 4))
     (set! s2-4 0)
     (while
         (< s2-4 count2)
       (format stream
               "  #x~X:    #x~8x #x~8x #x~8x~%"
               (+ (+ (* 12 s2-4) 4) (the-as int data))
               (-> (the-as (pointer uint32) (&+ s3-4 (* 12 s2-4))))
               (-> (the-as (pointer uint32) (&+ s3-4 (shl (+ (* 3 s2-4) 1) 2))))
               (-> (the-as (pointer uint32) (&+ s3-4 (shl (+ (* 3 s2-4) 2) 2))))
               )
       (+! s2-4 1)
       )
     )
    ((= kind 105)
     (set! s3-5 (&-> data 4))
     (set! s2-5 0)
     (while
         (< s2-5 count2)
       (format stream
               "  #x~X:    #x~4x #x~4x #x~4x~%"
               (+ (+ (* 6 s2-5) 4) (the-as int data))
               (-> (the-as (pointer uint16) (&+ s3-5 (* 6 s2-5))))
               (-> (the-as (pointer uint16) (&+ s3-5 (shl (+ (* 3 s2-5) 1) 1))))
               (-> (the-as (pointer uint16) (&+ s3-5 (shl (+ (* 3 s2-5) 2) 1))))
               )
       (+! s2-5 1)
       )
     )
    ((= kind 101)
     (set! s3-6 (&-> data 4))
     (set! s2-6 0)
     (while
         (< s2-6 count2)
       (format stream "  #x~X:    #x~4x #x~4x~%"
               (+ (+ (shl s2-6 2) 4) (the-as int data))
               (-> (the-as (pointer uint16) (&+ s3-6 (* 6 s2-6))))
               (-> (the-as (pointer uint16) (&+ s3-6 (shl (+ (* 3 s2-6) 1) 1))))
               )
       (+! s2-6 1)
       )
     )
    (else
     (set! a3-7 kind)
     (format stream
             "  #x~X:    Data format #b~b not yet supported, add it for yourself!~%"
             (&-> data 4)
             a3-7
             )
     )
    )
  #f
  )

(defun disasm-dma-tag ((arg0 uint) (arg1 symbol))
  "Print out a dma-tag"
  (local-vars
   (v1-1 uint)
   (v1-15 int)
   )
  (format arg1 "(dma-tag ")
  
  ;; this is a case used by value, which it doesn't like because the temp v1-1 can't be folded into a single
  ;; expression.  In reality, the game does the following line _after_ the format symbol is loaded,
  ;; but this makes no difference and OpenGOAL doesn't have case, so we have to make do with this.
  (set! v1-1 (shr (shl arg0 33) 61))
  (format arg1 "~s"
          (cond
            ((= v1-1 7) "end")
            ((= v1-1 6) "ret")
            ((= v1-1 5) "call")
            ((= v1-1 4) "refs")
            ((= v1-1 3) "ref")
            ((= v1-1 2) "next")
            ((= v1-1 1) "cnt")
            ((zero? v1-1) "refe")
            (else "*unknown*")
            )
          )

  ;; only print address if nonzero
  (if (> (shr (shl arg0 1) 33) 0)
      (format arg1 " :addr #x~8x" (shr (shl arg0 1) 33))
      )

  ;; only print qwc if nonzero
  (if (> (shr (shl arg0 48) 48) 0)
      (format arg1 " :qwc ~d" (shr (shl arg0 48) 48))
      )
  ;; only print spr if set
  (if (> (shr arg0 63) 0)
      (format arg1 " :spr ~d" (shr arg0 63)))
  ;;(.srl v1-15 arg0 31)
  (set! v1-15 (logand #xffffffff (shr arg0 31)))
  (when (> (the-as uint v1-15) 0)
    (format arg1 " :irq ~d" (logand #xffffffff (shr arg0 31)))
    )
  (if (> (shr (shl arg0 36) 62) 0)
      (format arg1 " :pce ~d" (shr (shl arg0 36) 62))
      )
  (the-as int (format arg1 ")~%"))
  )
