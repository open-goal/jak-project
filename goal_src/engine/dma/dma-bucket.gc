;;-*-Lisp-*-
(in-package goal)

;; name: dma-bucket.gc
;; name in dgo: dma-bucket
;; dgos: GAME, ENGINE

;; A dma-bucket is used to organize dma data.
;; When an object is drawn, it may add data to multiple buckets.
;; When the dma data is transferred, it is transferred bucket by bucket.

;; A dma-bucket is a 16 byte thing that lives in the dma-buffer.
;; buckets live consecutively in the dma-buffer, and can mark the start of a DMA chain
;; location anywhere.

;; The typical process is:
;; - empty buckets are allocated with add-buckets
;; - tags are put somewhere and added to the appropriate bucket with insert-tag, updating last as needed.
;; - buckets are patched to link to each other with dma-buffer-patch-buckets.

;; the idea here is that you can build the buckets in whatever order you want, but the buckets
;; will be DMAd in the bucket allocation order.

;; Each bucket contains:
;;   a tag, (64-bits), to point to the chain of the bucket
;;   last, a pointer to the last tag of this bucket, so that the bucket can be patched to point to the next.

(defun dma-buffer-add-buckets ((dma-buf dma-buffer) (count int))
  "Add count buckets. Each bucket is initialized as empty and won't transfer anything."
  (let ((current-bucket (the-as dma-bucket (-> dma-buf base))))
    (dotimes (i count)
      ;; set the DMA tag to next, with a qwc of zero.
      ;; the address is set to the next bucket.
      ;; By default, this will do no transfer and just move on in the dma-buf.
      ;; Data will be added to the bucket later.
      (set! (-> current-bucket tag)
            (new 'static 'dma-tag
                 :id (dma-tag-id next)
                 :addr (the-as int (&+ (the-as pointer current-bucket) 16))
                 )
            )
      ;; Set the last pointer to point to this tag (this lives in the 8 byte gap)
      (set! (-> current-bucket last) (the-as (pointer dma-tag) current-bucket))
      ;; Advance to next bucket.
      (&+! current-bucket 16)
      )
    ;; update base ptr of dma-buffer to point after the buckets.
    (set! (-> dma-buf base) (the-as pointer current-bucket))
    )
  (none)
  )


(defun dma-buffer-patch-buckets ((bucket dma-bucket) (count int))
  "Patch last pointers in a sequence of buckets.
   Call this after you have added everything to buckets."
  (local-vars (i int))
  (when (nonzero? bucket)
    (set! i 0)
    (while (< i count)
      ;; make last tag of this bucket point to the next bucket.
      (set! (-> bucket last 0)
            (logior (logand (-> bucket last 0) #x80000000ffffffff)
                    (shr (shl (+ (the-as uint bucket) 16) 33) 1)
                    )
            )
      ;; clear last, and move on to the next bucket.
      (set! (-> bucket last) (the (pointer dma-tag) 0))
      (set! bucket (&+ bucket 16))
      (set! i (+ i 1))
      )
    )
  (the-as int bucket)
  )

(defun dma-bucket-insert-tag ((base dma-bucket) (idx int) (tag-start dma-bucket) (tag-end (pointer uint64)))
  "Splice in a tag."
  (local-vars (bucket dma-bucket))
  ;; seek to bucket we want to splice before.
  (set! bucket (&+ base (shl idx 4)))
  ;; append to last tag (kind of a hack here with the types)
  (set! (-> (the dma-bucket (-> bucket last)) next) (the uint tag-start))
  ;; make prev = end of tag so we can add more.
  (set! (-> bucket last) (the (pointer dma-tag) tag-end))
  tag-start
  )
