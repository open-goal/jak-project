;;-*-Lisp-*-
(in-package goal)

;; name: collide-func.gc
;; name in dgo: collide-func
;; dgos: GAME, ENGINE


;; Many of the functions in this file use this "raw-ray-sphere-intersect" function.
;; It takes two arguments by vf registers (vf1, vf2)


(defun raw-ray-sphere-intersect ((arg0 float))
  (local-vars
   (v1-1 float)
   (v1-2 float)
   (v1-4 number)
   (a0-1 float)
   (a0-2 float)
   (a0-3 int)
   (a1-0 float)
   )
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.mov vf3 arg0)       ;; vf3 = radius
    ;; sphere is at the origin, vf1 is source of the ray (o)
    ;; vf2 is the ray's unit vector (u)
    (.mul.vf vf4 vf2 vf2) ;; vf4 = u.^2
    (.mul.vf vf3 vf3 vf3) ;; vf3 = r^2
    (.mul.vf vf6 vf1 vf1) ;; vf6 = o.^2
    (.mul.vf vf5 vf2 vf1) ;; vf5 = u . o
    (.add.y.vf vf4 vf4 vf4 :mask #b1)
    (let ((result (the-as float 0)))
      (.add.x.vf vf6 vf6 vf6 :mask #b10)
      (.sub.x.vf vf6 vf6 vf3 :mask #b100)
      (.add.z.vf vf4 vf4 vf4 :mask #b1)
      (.add.x.vf vf5 vf5 vf5 :mask #b10)
      (let ((v1-0 (the-as float 0)))
        (.add.z.vf vf6 vf6 vf6 :mask #b10)
        (.div.vf Q vf0 vf4 :fsf #b11 :ftf #b0)
        (.add.z.vf vf5 vf5 vf5 :mask #b10)
        (.mov a0-1 vf4)
        (.mul.x.vf vf7 vf6 vf4)
        (.mov a1-0 vf6)
        (.mul.vf vf8 vf5 vf5)
        (format #t "asdf~%")
        (b! (< (the-as int a1-0) 0) cfg-7 :delay (set! a0-2 a0-1))
        (.mul.vf vf4 vf0 Q :mask #b1000)
        (.sub.vf vf9 vf8 vf7)
        (format #t "Floats: ~f ~f~%" a0-2 v1-0)
        (b! (= a0-2 v1-0) cfg-6 :delay (.mov v1-1 vf5))
        )
      (.sqrt.vf Q vf9 :ftf #b1)
      (b! (>= (the-as int v1-1) 0) cfg-6 :delay (.mov v1-2 vf9))
      (b! (< (the-as int v1-2) 0) cfg-6 :delay 1.0)
      (.add.x.vf vf6 vf5 vf4)
      (.mov v1-4 vf6)
      (.mul.vf vf6 vf6 vf6)
      (.mul.vf vf9 vf0 Q :mask #b1000)
      (.sub.vf vf6 vf9 vf6)
      (.add.w.vf vf9 vf5 vf9 :mask #b10)
      (.mov a0-3 vf6)
      (.mul.w.vf vf9 vf9 vf4 :mask #b10)
      (b!
       (< (logand (the-as uint v1-4) (the-as uint a0-3)) 0)
       cfg-6
       :delay
       (.sub.y.vf vf4 vf0 vf9)
       )
      (b! #t cfg-7 :delay (.mov result vf4))
      (label cfg-6)
      (set! result -100000000.0)
      (label cfg-7)
      (the-as float result)
      )
    )
  )

(defmacro pc-port-do-raw-ray-sphere-intersect (rad vf1-val vf2-val)
  `(let ((vf1-storage (new 'stack-no-clear 'vector))
         (vf2-storage (new 'stack-no-clear 'vector))
         )
     (.svf (&-> vf1-storage quad) ,vf1-val)
     (.svf (&-> vf2-storage quad) ,vf2-val)
     (pc-port-raw-ray-sphere-implementation ,rad vf1-storage vf2-storage)
     )
  )


(defun pc-port-raw-ray-sphere-implementation ((rad float) (vf1-val vector) (vf2-val vector))
  (local-vars
   (v1-1 int)
   (v1-2 int)
   (v1-4 int)
   (a0-1 float)
   (a0-2 float)
   (a0-3 float)
   (a1-0 int)
   )
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> vf1-val quad)) 
    (.lvf vf2 (&-> vf2-val quad)) 
    (.mov vf3 rad)
    (.mul.vf vf4 vf2 vf2)
    (.mul.vf vf3 vf3 vf3)
    (.mul.vf vf6 vf1 vf1)
    (.mul.vf vf5 vf2 vf1)
    (.add.y.vf vf4 vf4 vf4 :mask #b1)
    (let ((result (the-as float 0)))
      (.add.x.vf vf6 vf6 vf6 :mask #b10)
      (.sub.x.vf vf6 vf6 vf3 :mask #b100)
      (.add.z.vf vf4 vf4 vf4 :mask #b1)
      (.add.x.vf vf5 vf5 vf5 :mask #b10)
      (let ((v1-0 (the-as float 0)))
        (.add.z.vf vf6 vf6 vf6 :mask #b10)
        (.div.vf Q vf0 vf4 :fsf #b11 :ftf #b0)
        (.add.z.vf vf5 vf5 vf5 :mask #b10)
        (.mov a0-1 vf4)
        (.mul.x.vf vf7 vf6 vf4)
        (.mov a1-0 vf6)
        (.mul.vf vf8 vf5 vf5)
        (print-vf vf6)
        (b! (< (the-as int a1-0) 0) cfg-7 :delay (set! a0-2 a0-1)) ;; in the sphere
        (.mul.vf vf4 vf0 Q :mask #b1000)
        (.sub.vf vf9 vf8 vf7)
        ;;(format #t "floats ~f ~f~%" a0-2 v1-0)
        (b! (= a0-2 v1-0) cfg-6 :delay (.mov v1-1 vf5)) ;; bad direction
        )
      (.sqrt.vf Q vf9 :ftf #b1)
      (b! (>= (the-as int v1-1) 0) cfg-6 :delay (.mov v1-2 vf9)) ;; bad sqrt
      (b! (< (the-as int v1-2) 0) cfg-6 :delay 1.0)
      (.add.x.vf vf6 vf5 vf4)
      (.mov v1-4 vf6)
      (.mul.vf vf6 vf6 vf6)
      (.mul.vf vf9 vf0 Q :mask #b1000)
      (.sub.vf vf6 vf9 vf6)
      (.add.w.vf vf9 vf5 vf9 :mask #b10)
      (.mov a0-3 vf6)
      (.mul.w.vf vf9 vf9 vf4 :mask #b10)
      ;; bad direction
      (b! (< (logand (the-as uint v1-4) (the-as uint a0-3)) 0)
       cfg-6
       :delay (.sub.y.vf vf4 vf0 vf9)
       )
      (b! #t cfg-7 :delay (.mov result vf4))
      (label cfg-6)
      (set! result -100000000.0)
      (label cfg-7)
      (the-as float result)
      )
    )
  )


(defun ray-sphere-intersect ((ray-origin vector) (ray-dir vector) (sph-origin vector) (radius float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
    (.lvf vf1 (&-> ray-origin quad))
    (.lvf vf2 (&-> sph-origin quad))
    (.sub.vf vf1 vf1 vf2)
    (.lvf vf2 (&-> ray-dir quad))
    ;;(raw-ray-sphere-intersect radius)
    (pc-port-do-raw-ray-sphere-intersect radius vf1 vf2)
    )
  )
