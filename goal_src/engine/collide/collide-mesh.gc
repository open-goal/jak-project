;;-*-Lisp-*-
(in-package goal)

;; name: collide-mesh.gc
;; name in dgo: collide-mesh
;; dgos: GAME, ENGINE

(defmethod asize-of collide-mesh ((obj collide-mesh))
  "Compute the size in memory of a collide-mesh. Somehow this only counts num-tris and not verts."
  (the-as int (+ (-> collide-mesh size) (* (+ (-> obj num-tris) -1) 8)))
  )

(defmethod mem-usage collide-mesh ((obj collide-mesh) (arg0 memory-usage-block) (arg1 int))
  "Compute the memory usage of a collide-mesh."
  (set! (-> arg0 length) (max 79 (-> arg0 length)))
  (set! (-> arg0 data 78 name) "collide-mesh")
  (+! (-> arg0 data 78 count) 1)
  (let ((v1-6 (asize-of obj)))
    (+! (-> arg0 data 78 used) v1-6)
    (+! (-> arg0 data 78 total) (logand -16 (+ v1-6 15)))
    )
  (set! (-> arg0 length) (max 79 (-> arg0 length)))
  (set! (-> arg0 data 78 name) "collide-mesh")
  (+! (-> arg0 data 78 count) 1)
  (let ((v1-16 (* (-> obj num-verts) 16)))
    (+! (-> arg0 data 78 used) v1-16)
    (+! (-> arg0 data 78 total) (logand -16 (+ v1-16 15)))
    )
  (the-as collide-mesh 0)
  )

(defmethod debug-draw-tris collide-mesh ((obj collide-mesh) (arg0 process-drawable) (arg1 int))
  "Draw a collide-mesh."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (the-as object (-> obj tris)))
          (s4-0 (-> arg0 node-list data arg1 bone transform))
          )
      (countdown (s3-0 (-> obj num-tris))
        (let ((a2-1 (new 'stack-no-clear 'vector))
              (a3-0 (new 'stack-no-clear 'vector))
              (t0-0 (new 'stack-no-clear 'vector))
              )
          (.lvf vf4 (&-> s4-0 vector 0 quad))
          (.lvf vf5 (&-> s4-0 vector 1 quad))
          (.lvf vf6 (&-> s4-0 vector 2 quad))
          (.lvf vf7 (&-> s4-0 vector 3 quad))
          (.lvf vf1 (&-> (-> obj vertex-data (-> (the-as collide-mesh-tri s5-0) vertex-index 0)) quad))
          (.lvf vf2 (&-> (-> obj vertex-data (-> (the-as collide-mesh-tri s5-0) vertex-index 1)) quad))
          (.lvf vf3 (&-> (-> obj vertex-data (-> (the-as collide-mesh-tri s5-0) vertex-index 2)) quad))
          (let ((t1-0 (copy-and-set-field (-> *pat-mode-info* (-> (the-as collide-mesh-tri s5-0) pat mode) color) a 16)))
            (.mul.w.vf acc vf7 vf0)
            (.add.mul.x.vf acc vf4 vf1 acc)
            (.add.mul.y.vf acc vf5 vf1 acc)
            (.add.mul.z.vf vf1 vf6 vf1 acc)
            (.mul.w.vf acc vf7 vf0)
            (.add.mul.x.vf acc vf4 vf2 acc)
            (.add.mul.y.vf acc vf5 vf2 acc)
            (.add.mul.z.vf vf2 vf6 vf2 acc)
            (.mul.w.vf acc vf7 vf0)
            (.add.mul.x.vf acc vf4 vf3 acc)
            (.add.mul.y.vf acc vf5 vf3 acc)
            (.add.mul.z.vf vf3 vf6 vf3 acc)
            (.svf (&-> a2-1 quad) vf1)
            (.svf (&-> a3-0 quad) vf2)
            (.svf (&-> t0-0 quad) vf3)
            (add-debug-flat-triangle #t (bucket-id debug-no-zbuf) a2-1 a3-0 t0-0 t1-0)
            )
          )
        (set! s5-0 (-> (the-as (inline-array collide-mesh-tri) s5-0) 1))
        )
      )
    0
    (none)
    )
  )

(deftype sopt-work (structure)
  ((intersect     vector         :inline :offset-assert   0)
   (sphere-bbox4w bounding-box4w :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

(defmethod-mips2c "(method 12 collide-mesh)" 12 collide-mesh)


(deftype spat-work (structure)
  ((intersect     vector         :inline :offset-assert   0)
   (sphere-bbox4w bounding-box4w :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

(defmethod-mips2c "(method 11 collide-mesh)" 11 collide-mesh)

(defmethod-mips2c "(method 14 collide-mesh)" 14 collide-mesh)
(defmethod-mips2c "(method 15 collide-mesh)" 15 collide-mesh)

(defmethod allocate! collide-mesh-cache ((obj collide-mesh-cache) (arg0 int))
  (local-vars (a1-2 int) (a2-2 int))
  (let* ((v1-0 (+ arg0 15))
         (a1-1 (-> obj used-size))
         (v1-1 (/ v1-0 16))
         (a3-0 (-> obj data))
         (a2-0 (-> obj max-size))
         (v1-2 (* v1-1 16))
         (a3-1 (&+ a3-0 a1-1))
         )
    (let ((t1-0 (- a2-0 (the-as uint v1-2)))
          (t0-0 (-> obj id))
          )
      (b! (< (the-as int t1-0) 0) cfg-6 :delay (set! a1-2 (the-as int (+ a1-1 v1-2))))
      (b! (>= (the-as int (- a2-0 (the-as uint a1-2))) 0) cfg-5 :delay (set! a2-2 (the-as int (+ t0-0 1))))
      )
    (b! (zero? (the-as uint a2-2)) cfg-4 :likely-delay (set! a2-2 1))
    (label cfg-4)
    (set! a1-2 v1-2)
    (set! a3-1 (-> obj data))
    (set! (-> obj id) (the-as uint a2-2))
    (label cfg-5)
    (set! (-> obj used-size) (the-as uint a1-2))
    (let ((v0-0 a3-1))
      (b! #t cfg-7 :delay (nop!))
      (label cfg-6)
      (format 0 "ERROR: Attempted to allocate something bigger than the entire mesh cache!~%")
      (set! v0-0 (the-as (pointer uint8) #f))
      (label cfg-7)
      (the-as int v0-0)
      )
    )
  )

(defmethod populate-cache! collide-mesh ((obj collide-mesh) (arg0 collide-mesh-cache-tri) (arg1 matrix))
  (local-vars (t0-2 uint))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    (let ((t0-0 (scratchpad-object int))
          (v1-0 (-> obj num-verts))
          )
      (nop!)
      (let ((a3-0 (-> obj vertex-data)))
        (b! (zero? v1-0) cfg-3 :delay (.lvf vf1 (&-> arg1 vector 0 quad)))
        (nop!)
        (.lvf vf2 (&-> arg1 vector 1 quad))
        (let ((t0-1 (+ t0-0 -64)))
          (.lvf vf3 (&-> arg1 vector 2 quad))
          (nop!)
          (.lvf vf4 (&-> arg1 vector 3 quad))
          (nop!)
          (.lvf vf5 (&-> a3-0 0 quad))
          (nop!)
          (.lvf vf6 (&-> a3-0 1 quad))
          (nop!)
          (.lvf vf7 (&-> a3-0 2 quad))
          (nop!)
          (.lvf vf8 (&-> a3-0 3 quad))
          (label cfg-2)
          (.mul.w.vf acc vf4 vf0)
          (set! a3-0 (the-as (inline-array vector) (-> a3-0 4)))
          (.add.mul.x.vf acc vf1 vf5 acc)
          (+! t0-1 64)
          (.add.mul.y.vf acc vf2 vf5 acc)
          (nop!)
          (.add.mul.z.vf vf9 vf3 vf5 acc)
          (nop!)
          (.mul.w.vf acc vf4 vf0)
          (.lvf vf5 (&-> a3-0 0 quad))
          (.add.mul.x.vf acc vf1 vf6 acc)
          (nop!)
          (.add.mul.y.vf acc vf2 vf6 acc)
          (nop!)
          (.add.mul.z.vf vf10 vf3 vf6 acc)
          (nop!)
          (.mul.w.vf acc vf4 vf0)
          (.lvf vf6 (&-> a3-0 1 quad))
          (.add.mul.x.vf acc vf1 vf7 acc)
          (nop!)
          (.add.mul.y.vf acc vf2 vf7 acc)
          (nop!)
          (.add.mul.z.vf vf11 vf3 vf7 acc)
          (nop!)
          (.mul.w.vf acc vf4 vf0)
          (.lvf vf7 (&-> a3-0 2 quad))
          (.add.mul.x.vf acc vf1 vf8 acc)
          (nop!)
          (.add.mul.y.vf acc vf2 vf8 acc)
          (nop!)
          (.add.mul.z.vf vf12 vf3 vf8 acc)
          (nop!)
          (nop!)
          (.lvf vf8 (&-> a3-0 3 quad))
          (+! v1-0 -4)
          (.svf t0-1 vf9)
          (nop!)
          (.svf (+ t0-1 16) vf10)
          (nop!)
          (.svf (+ t0-1 32) vf11)
          (b! (> (the-as int v1-0) 0) cfg-2 :delay (.svf (+ t0-1 48) vf12))
          )
        )
      )
    (label cfg-3)
    (let ((v1-1 (the-as collide-mesh-tri (-> obj tris))))
      (nop!)
      (let ((a2-1 (scratchpad-object int))
            (a0-1 (-> obj num-tris))
            )
        (b! (zero? a0-1) cfg-6 :delay (set! t0-2 (-> v1-1 vertex-index 0)))
        (let* ((a1-1 (&+  arg0 -96))
               (a3-1 (-> v1-1 vertex-index 1))
               (t0-3 (* t0-2 16))
               (t2-0 (-> v1-1 vertex-index 2))
               (t1-0 (* a3-1 16))
               (a3-2 (-> v1-1 pat))
               )
          (let* ((t2-1 (* t2-0 16))
                 (t0-4 (+ t0-3 a2-1))
                 (t1-1 (+ t1-0 a2-1))
                 (t2-2 (+ t2-1 a2-1))
                 )
            (label cfg-5)
            (+! a0-1 -1)
            (.lvf vf1 t0-4)
            (&+! v1-1 8)
            (.lvf vf2 t1-1)
            (&+! a1-1 96)
            (.lvf vf3 t2-2)
            (.sub.vf vf4 vf2 vf1)
            (.svf (&-> a1-1 vertex 0 quad) vf1)
            (.min.vf vf8 vf1 vf2)
            (.svf (&-> a1-1 vertex 1 quad) vf2)
            (.sub.vf vf5 vf3 vf1)
            (.svf (&-> a1-1 vertex 2 quad) vf3)
            (.max.vf vf9 vf1 vf2)
            (let ((t1-2 (-> v1-1 vertex-index 0)))
              (.outer.product.a.vf acc vf4 vf5)
              (let ((t2-3 (-> v1-1 vertex-index 1)))
                (.outer.product.b.vf vf6 vf5 vf4 acc)
                (let ((t0-5 (-> v1-1 vertex-index 2)))
                  (.mul.vf vf7 vf6 vf6)
                  (nop!)
                  (.min.vf vf8 vf8 vf3)
                  (let ((t1-3 (* t1-2 16)))
                    (.max.vf vf9 vf9 vf3)
                    (let ((t2-4 (* t2-3 16)))
                      (.mul.x.vf acc vf0 vf7 :mask #b1000)
                      (let ((t3-0 (* t0-5 16)))
                        (.add.mul.y.vf acc vf0 vf7 acc :mask #b1000)
                        (set! t0-4 (+ t1-3 a2-1))
                        (.add.mul.z.vf vf7 vf0 vf7 acc :mask #b1000)
                        (set! t1-1 (+ t2-4 a2-1))
                        (.isqrt.vf Q vf0 vf7 :fsf #b11 :ftf #b11)
                        (set! t2-2 (+ t3-0 a2-1))
                        )
                      )
                    )
                  )
                )
              )
            )
          (.ftoi.vf vf8 vf8)
          (nop!)
          (.ftoi.vf vf9 vf9)
          (nop!)
          (nop!)
          (.svf (&-> a1-1 bbox4w min quad) vf8)
          (.wait.vf)
          (.svf (&-> a1-1 bbox4w max quad) vf9)
          (.mul.vf vf6 vf6 Q :mask #b111)
          (nop!)
          (nop!)
          (.svf (&-> a1-1 normal quad) vf6)
          (nop!)
          (set! (-> a1-1 normal w) (the-as float a3-2))
          (b! (nonzero? a0-1) cfg-5 :delay (set! a3-2 (-> v1-1 pat)))
          )
        )
      )
    (label cfg-6)
    0
    (none)
    )
  )


(defmethod overlap-test collide-mesh ((obj collide-mesh) (arg0 collide-mesh-cache-tri) (arg1 vector))
  (local-vars
    (zero uint128)
    (v1-0 uint128)
    (a0-1 uint128)
    (a1-2 uint128)
    (a1-3 uint128)
    (a1-4 uint128)
    (a1-7 uint)
    (a2-1 uint128)
    (a2-2 uint128)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (set! zero (the-as uint128 0))
    (let ((s5-0 (new 'stack-no-clear 'matrix))
          (s4-0 arg0)
          )
      (.lvf vf2 (&-> arg1 quad))
      (let ((s3-0 (-> obj num-tris)))
        (.sub.w.vf vf5 vf2 vf2)
        (.add.w.vf vf6 vf2 vf2)
        (.ftoi.vf vf5 vf5)
        (.ftoi.vf vf6 vf6)
        (.mov v1-0 vf5)
        (.svf (&-> s5-0 vector 1 quad) vf5)
        (.mov a0-1 vf6)
        (.svf (&-> s5-0 vector 2 quad) vf6)
        (label cfg-1)
        (b! (zero? s3-0) cfg-7 :delay (set! a2-1 (-> s4-0 bbox4w min quad)))
        (+! s3-0 -1)
        )
      (let ((a1-1 (-> s4-0 bbox4w max quad)))
        (.pcgtw a2-2 a2-1 a0-1)
        (.pcgtw a1-2 v1-0 a1-1)
        )
      (.por a1-3 a2-2 a1-2)
      (nop!)
      (.ppach a1-4 zero a1-3)
      (let ((a1-5 (shl (the-as int a1-4) 16)))
        (nop!)
        (b! (nonzero? a1-5) cfg-1 :likely-delay (set! s4-0 (&+ s4-0 96)))
        )
      (closest-pt-in-triangle
        (the-as vector (-> s5-0 vector))
        arg1
        (the-as matrix (-> s4-0 vertex))
        (-> s4-0 normal)
        )
      (.lvf vf1 (&-> s5-0 vector 0 quad))
      (.lvf vf2 (&-> arg1 quad))
      (set! v1-0 (-> s5-0 vector 1 quad))
      (set! a0-1 (-> s5-0 vector 2 quad))
      (.sub.vf vf3 vf2 vf1)
      (.mul.w.vf vf4 vf2 vf2 :mask #b1000)
      (.mul.vf vf3 vf3 vf3)
      (.mul.x.vf acc vf0 vf3 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf3 acc :mask #b1000)
      (.add.mul.z.vf vf3 vf0 vf3 acc :mask #b1000)
      (.sub.w.vf vf3 vf3 vf4 :mask #b1000)
      (.add.w.vf vf3 vf0 vf3 :mask #b10)
      (.mov a1-7 vf3)
      (b! (>= (the-as int a1-7) 0) cfg-1 :delay (set! s4-0 (&+ s4-0 96)))
      )
    (let ((v0-1 #t))
      (b! #t cfg-8 :delay (nop!))
      (the-as none 0)
      (label cfg-7)
      (set! v0-1 #f)
      (label cfg-8)
      v0-1
      )
    )
  )