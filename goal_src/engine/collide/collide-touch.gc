;;-*-Lisp-*-
(in-package goal)

;; name: collide-touch.gc
;; name in dgo: collide-touch
;; dgos: GAME, ENGINE

;; DECOMP BEGINS

(defmethod get-size touching-prims-entry-pool ((obj touching-prims-entry-pool))
  (let ((v0-0 0))
    (let ((v1-0 (-> obj head)))
      (while v1-0
        (+! v0-0 1)
        (set! v1-0 (-> v1-0 next))
        (nop!)
        (nop!)
        (nop!)
        )
      )
    v0-0
    )
  )

(defmethod alloc-node touching-prims-entry-pool ((obj touching-prims-entry-pool))
  (let ((gp-0 (-> obj head)))
    (cond
      (gp-0
        (let ((v1-0 (-> gp-0 next)))
          (set! (-> obj head) v1-0)
          (if v1-0
              (set! (-> v1-0 prev) #f)
              )
          )
        (set! (-> gp-0 allocated?) #t)
        (set! (-> gp-0 next) #f)
        (set! (-> gp-0 prev) #f)
        )
      (else
        (format 0 "ERROR: touching-prims-entry-pool::alloc-node() failed!~%")
        )
      )
    gp-0
    )
  )

(defmethod free-node touching-prims-entry-pool ((obj touching-prims-entry-pool) (arg0 touching-prims-entry))
  (when (-> arg0 allocated?)
    (set! (-> arg0 allocated?) #f)
    (let ((v1-1 (-> obj head)))
      (set! (-> arg0 next) v1-1)
      (set! (-> arg0 prev) #f)
      (set! (-> obj head) arg0)
      (when v1-1
        (set! (-> v1-1 prev) arg0)
        arg0
        )
      )
    )
  )

(defmethod free-entry-list touching-shapes-entry ((obj touching-shapes-entry))
  (when (-> obj cshape1)
    (set! (-> obj cshape1) #f)
    (let ((gp-0 (-> obj head)))
      (when gp-0
        (set! (-> obj head) #f)
        (let ((s5-0 *touching-prims-entry-pool*))
          (while gp-0
            (let ((a1-0 gp-0))
              (set! gp-0 (-> a1-0 next))
              (free-node s5-0 a1-0)
              )
            )
          )
        #f
        )
      )
    )
  )

(defmethod dummy-14 touching-list ((obj touching-list))
  (let ((s5-0 (the-as object (-> obj touching-shapes))))
    (countdown (s4-0 (-> obj num-touching-shapes))
      (free-entry-list (the-as touching-shapes-entry s5-0))
      (set! s5-0 (&+ (the-as touching-shapes-entry s5-0) 16))
      )
    )
  (set! (-> obj num-touching-shapes) 0)
  (set! (-> obj resolve-u) 0)
  0
  (none)
  )

(defmethod get-shapes-entry touching-list ((obj touching-list) (arg0 collide-shape) (arg1 collide-shape))
  (let ((v0-0 (the-as object (-> obj touching-shapes))))
    (let ((v1-0 (the-as object #f)))
      (countdown (a3-0 (-> obj num-touching-shapes))
        (let ((t0-0 (-> (the-as touching-shapes-entry v0-0) cshape1)))
          (set! v1-0 (cond
                       (t0-0
                         (if (or (and (= t0-0 arg0) (= (-> (the-as touching-shapes-entry v0-0) cshape2) arg1))
                                 (and (= t0-0 arg1) (= (-> (the-as touching-shapes-entry v0-0) cshape2) arg0))
                                 )
                             (return (the-as touching-shapes-entry v0-0))
                             )
                         v1-0
                         )
                       (else
                         v0-0
                         )
                       )
                )
          )
        (set! v0-0 (&+ (the-as touching-shapes-entry v0-0) 16))
        )
      (cond
        (v1-0
          (set! v0-0 v1-0)
          )
        (else
          (when (>= (-> obj num-touching-shapes) 32)
            (format 0 "ERROR: touching-list::get-shapes-entry() failed!~%")
            (return (the-as touching-shapes-entry #f))
            )
          (+! (-> obj num-touching-shapes) 1)
          )
        )
      )
    (set! (-> (the-as touching-shapes-entry v0-0) cshape1) arg0)
    (set! (-> (the-as touching-shapes-entry v0-0) cshape2) arg1)
    (set! (-> (the-as touching-shapes-entry v0-0) head) #f)
    (set! (-> (the-as touching-shapes-entry v0-0) resolve-u) 1)
    (set! (-> obj resolve-u) 1)
    (the-as touching-shapes-entry v0-0)
    )
  )

(deftype add-prims-touching-work (structure)
  ((tri1 collide-tri-result  :offset-assert   0)
   (tri2 collide-tri-result  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


;; WARN: Expression building failed: Function (method 9 touching-list) has a return type of none, but the expression builder found a return statement.
(defmethod add-touching-prims touching-list ((obj touching-list)
                                             (arg0 collide-shape-prim)
                                             (arg1 collide-shape-prim)
                                             (arg2 float)
                                             (arg3 collide-tri-result)
                                             (arg4 collide-tri-result)
                                             )
  (let ((gp-0 (new 'stack-no-clear 'add-prims-touching-work)))
    (set! (-> gp-0 tri1) arg3)
    (set! (-> gp-0 tri2) arg4)
    (let ((s2-0 (get-shapes-entry obj (-> arg0 cshape) (-> arg1 cshape))))
      (when s2-0
        (when (= (-> s2-0 cshape1) (-> arg1 cshape))
          (let ((v1-4 arg0))
            (set! arg0 arg1)
            (set! arg1 v1-4)
            )
          )
        (let ((s0-0 (-> s2-0 head)))
          (while s0-0
            (when (and (= (-> s0-0 prim1 cprim) arg0) (= (-> s0-0 prim2 cprim) arg1))
              (when (< arg2 (-> s0-0 u))
                (-> s0-0 u)
                (let ((v1-12 (-> s0-0 prim1))
                      (a1-2 (-> gp-0 tri1))
                      )
                  (cond
                    (a1-2
                      (set! (-> v1-12 has-tri?) #t)
                      (mem-copy! (the-as pointer (-> v1-12 tri)) (the-as pointer a1-2) 84)
                      )
                    (else
                      (set! (-> v1-12 has-tri?) #f)
                      )
                    )
                  )
                (let ((v1-15 (-> s0-0 prim2))
                      (a1-3 (-> gp-0 tri2))
                      )
                  (cond
                    (a1-3
                      (set! (-> v1-15 has-tri?) #t)
                      (mem-copy! (the-as pointer (-> v1-15 tri)) (the-as pointer a1-3) 84)
                      )
                    (else
                      (set! (-> v1-15 has-tri?) #f)
                      )
                    )
                  )
                )
              (return 0)
              )
            (set! s0-0 (-> s0-0 next))
            )
          )
        (let ((s0-1 (alloc-node *touching-prims-entry-pool*)))
          (when s0-1
            (let ((v1-22 (-> s2-0 head)))
              (set! (-> s0-1 next) v1-22)
              (set! (-> s0-1 prev) #f)
              (set! (-> s2-0 head) s0-1)
              (if v1-22
                  (set! (-> v1-22 prev) s0-1)
                  )
              )
            (set! (-> s0-1 u) arg2)
            (when (>= arg2 0.0)
              (set! (-> s2-0 resolve-u) 1)
              (set! (-> obj resolve-u) 1)
              )
            (let ((v1-26 (-> s0-1 prim1))
                  (a1-4 (-> gp-0 tri1))
                  )
              (set! (-> v1-26 cprim) arg0)
              (cond
                (a1-4
                  (set! (-> v1-26 has-tri?) #t)
                  (mem-copy! (the-as pointer (-> v1-26 tri)) (the-as pointer a1-4) 84)
                  )
                (else
                  (set! (-> v1-26 has-tri?) #f)
                  )
                )
              )
            (let ((v1-29 (-> s0-1 prim2))
                  (a1-5 (-> gp-0 tri2))
                  )
              (set! (-> v1-29 cprim) arg1)
              (cond
                (a1-5
                  (set! (-> v1-29 has-tri?) #t)
                  (mem-copy! (the-as pointer (-> v1-29 tri)) (the-as pointer a1-5) 84)
                  )
                (else
                  (set! (-> v1-29 has-tri?) #f)
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod dummy-11 touching-list ((obj touching-list) (arg0 float))
  (when (nonzero? (-> obj resolve-u))
    (set! (-> obj resolve-u) 0)
    (let ((s5-0 (the-as object (-> obj touching-shapes))))
      (countdown (s4-0 (-> obj num-touching-shapes))
        (when (nonzero? (-> (the-as touching-shapes-entry s5-0) resolve-u))
          (set! (-> (the-as touching-shapes-entry s5-0) resolve-u) 0)
          (when (-> (the-as touching-shapes-entry s5-0) cshape1)
            (let ((s3-0 (-> (the-as touching-shapes-entry s5-0) head)))
              (while s3-0
                (let ((f0-0 (-> s3-0 u)))
                  (set! s3-0 (cond
                               ((>= f0-0 0.0)
                                (cond
                                  ((>= arg0 f0-0)
                                   (set! (-> s3-0 u) -1.0)
                                   (set! s3-0 (-> s3-0 next))
                                   )
                                  (else
                                    (let ((a1-1 s3-0))
                                      (let ((v1-7 (-> s3-0 next)))
                                        (let ((a0-1 (-> s3-0 prev)))
                                          (if a0-1
                                              (set! (-> a0-1 next) v1-7)
                                              (set! (-> (the-as touching-shapes-entry s5-0) head) v1-7)
                                              )
                                          (if v1-7
                                              (set! (-> v1-7 prev) a0-1)
                                              )
                                          )
                                        (set! s3-0 v1-7)
                                        )
                                      (free-node *touching-prims-entry-pool* a1-1)
                                      )
                                    )
                                  )
                                s3-0
                                )
                               (else
                                 (-> s3-0 next)
                                 )
                               )
                        )
                  )
                )
              )
            (if (not (-> (the-as touching-shapes-entry s5-0) head))
                (set! (-> (the-as touching-shapes-entry s5-0) cshape1) #f)
                )
            )
          )
        (set! s5-0 (&+ (the-as touching-shapes-entry s5-0) 16))
        )
      )
    )
  0
  (none)
  )

(defmethod dummy-12 touching-list ((obj touching-list))
  (let ((gp-0 (the-as object (-> obj touching-shapes))))
    (countdown (s5-0 (-> obj num-touching-shapes))
      (let ((s4-0 (-> (the-as touching-shapes-entry gp-0) cshape1)))
        (when s4-0
          (let ((s3-0 (-> (the-as touching-shapes-entry gp-0) cshape2)))
            (when (= (-> s3-0 process type) target)
              (let ((v1-2 s4-0))
                (set! s4-0 s3-0)
                (set! s3-0 v1-2)
                )
              )
            (let ((v1-4 (-> s4-0 event-self)))
              (when v1-4
                (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> a1-0 from) (-> s3-0 process))
                  (set! (-> a1-0 num-params) 1)
                  (set! (-> a1-0 message) (the-as symbol v1-4))
                  (set! (-> a1-0 param 0) (the-as uint gp-0))
                  (send-event-function (-> s4-0 process) a1-0)
                  )
                )
              )
            (let ((v1-5 (-> s4-0 event-other)))
              (when v1-5
                (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> a1-1 from) (-> s4-0 process))
                  (set! (-> a1-1 num-params) 1)
                  (set! (-> a1-1 message) (the-as symbol v1-5))
                  (set! (-> a1-1 param 0) (the-as uint gp-0))
                  (send-event-function (-> s3-0 process) a1-1)
                  )
                )
              )
            (let ((v1-6 (-> s3-0 event-self)))
              (when v1-6
                (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> a1-2 from) (-> s4-0 process))
                  (set! (-> a1-2 num-params) 1)
                  (set! (-> a1-2 message) (the-as symbol v1-6))
                  (set! (-> a1-2 param 0) (the-as uint gp-0))
                  (send-event-function (-> s3-0 process) a1-2)
                  )
                )
              )
            (let ((v1-7 (-> s3-0 event-other)))
              (when v1-7
                (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> a1-3 from) (-> s3-0 process))
                  (set! (-> a1-3 num-params) 1)
                  (set! (-> a1-3 message) (the-as symbol v1-7))
                  (set! (-> a1-3 param 0) (the-as uint gp-0))
                  (send-event-function (-> s4-0 process) a1-3)
                  )
                )
              )
            )
          )
        )
      (set! gp-0 (&+ (the-as touching-shapes-entry gp-0) 16))
      )
    )
  0
  (none)
  )

(defmethod prims-touching? touching-shapes-entry ((obj touching-shapes-entry) (arg0 collide-shape-moving) (arg1 uint))
  (cond
    ((= (-> obj cshape1) arg0)
     (let ((v1-1 (-> obj head)))
       (while v1-1
         (if (logtest? (-> v1-1 prim1 cprim prim-id) arg1)
             (return v1-1)
             )
         (set! v1-1 (-> v1-1 next))
         )
       )
     )
    ((= (-> obj cshape2) arg0)
     (let ((v1-4 (-> obj head)))
       (while v1-4
         (if (logtest? (-> v1-4 prim2 cprim prim-id) arg1)
             (return v1-4)
             )
         (set! v1-4 (-> v1-4 next))
         )
       )
     )
    (else
      (format 0 "ERROR: touching-shapes-entry::prims-touching? : Bogus cshape value!~%")
      )
    )
  (the-as touching-prims-entry #f)
  )

(defmethod prims-touching-action? touching-shapes-entry ((obj touching-shapes-entry) (arg0 collide-shape) (arg1 collide-action) (arg2 collide-action))
  (cond
    ((= (-> obj cshape1) arg0)
     (let ((v1-1 (-> obj head)))
       (while v1-1
         (let ((a0-1 (-> v1-1 prim1 cprim)))
           (if (and (logtest? arg1 (-> a0-1 prim-core action)) (zero? (logand arg2 (-> a0-1 prim-core action))))
               (return v1-1)
               )
           )
         (set! v1-1 (-> v1-1 next))
         )
       )
     )
    ((= (-> obj cshape2) arg0)
     (let ((v1-4 (-> obj head)))
       (while v1-4
         (let ((a0-5 (-> v1-4 prim2 cprim)))
           (if (and (logtest? arg1 (-> a0-5 prim-core action)) (zero? (logand arg2 (-> a0-5 prim-core action))))
               (return v1-4)
               )
           )
         (set! v1-4 (-> v1-4 next))
         )
       )
     )
    (else
      (format 0 "ERROR: touching-shapes-entry::prims-touching-action? : Bogus cshape value!~%")
      )
    )
  (the-as touching-prims-entry #f)
  )

(defmethod get-touched-shape touching-shapes-entry ((obj touching-shapes-entry) (arg0 collide-shape))
  (cond
    ((= (-> obj cshape1) arg0)
     (return (-> obj cshape2))
     )
    ((= (-> obj cshape2) arg0)
     (return (-> obj cshape1))
     )
    )
  (the-as collide-shape #f)
  )

(defmethod get-touched-prim touching-prims-entry ((obj touching-prims-entry) (arg0 trsqv) (arg1 touching-prims-entry))
  (cond
    ((= (-> arg1 next) arg0)
     (return (-> obj prim1 cprim))
     )
    ((= (-> arg1 prev) arg0)
     (return (-> obj prim2 cprim))
     )
    )
  (the-as collide-shape-prim #f)
  )

(defmethod get-touched-tri touching-prims-entry ((obj touching-prims-entry) (arg0 touching-prims-entry) (arg1 touching-prims-entry))
  (let ((v0-0 (the-as collide-tri-result #f)))
    (cond
      ((= (-> arg1 next) arg0)
       (let ((v1-2 (-> obj prim1)))
         (if (-> v1-2 has-tri?)
             (set! v0-0 (-> v1-2 tri))
             )
         )
       )
      ((= (-> arg1 prev) arg0)
       (let ((v1-5 (-> obj prim2)))
         (if (-> v1-5 has-tri?)
             (set! v0-0 (-> v1-5 tri))
             )
         )
       )
      )
    v0-0
    )
  )

(defmethod dummy-11 touching-prims-entry ((obj touching-prims-entry) (arg0 vector))
  (let* ((s4-0 (-> obj prim1 cprim))
         (s3-0 (-> obj prim2 cprim))
         (gp-1 (vector-!
                 (new 'stack-no-clear 'vector)
                 (the-as vector (-> s3-0 prim-core))
                 (the-as vector (-> s4-0 prim-core))
                 )
               )
         )
    (let ((f1-2 (- (- (vector-length gp-1) (-> s3-0 prim-core world-sphere w)) (-> s4-0 prim-core world-sphere w))))
      (vector-normalize! gp-1 (+ (-> s4-0 prim-core world-sphere w) (* 0.5 f1-2)))
      )
    (vector+! arg0 gp-1 (the-as vector (-> s4-0 prim-core)))
    )
  arg0
  )




