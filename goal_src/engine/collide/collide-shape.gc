;;-*-Lisp-*-
(in-package goal)

;; name: collide-shape.gc
;; name in dgo: collide-shape
;; dgos: GAME, ENGINE

;; TODO - for misty-teetertotter | rigid-body
(define-extern default-collision-reaction (function collide-shape-moving collide-shape-intersect vector vector none)) ;; TODO - not completely confirmed

;; DECOMP BEGINS

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod should-push-away-test collide-shape-prim ()
  (format
   0
   "ERROR: collide-shape-prim::should-push-away-test was called illegally!~%"
   )
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod
  collide-with-collide-cache-prim-mesh
  collide-shape-prim
  ((obj collide-shape-prim)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (format
   0
   "ERROR: Unsupported prim type in collide-shape-prim::collide-with-collide-cache-prim-mesh!~%"
   )
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod
  collide-with-collide-cache-prim-mesh
  collide-shape-prim-mesh
  ((obj collide-shape-prim-mesh)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (format
   0
   "ERROR: collide-shape-prim-mesh vs. collide-cache-prim mesh is not currently supported!~%"
   )
  (none)
  )

(defmethod
  collide-with-collide-cache-prim-mesh
  collide-shape-prim-group
  ((obj collide-shape-prim-group)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (let ((s3-0 (-> arg1 prim-core collide-as)))
   (dotimes (s2-0 (-> obj num-prims))
    (let ((a0-1 (-> obj prims s2-0)))
     (if (logtest? (-> a0-1 collide-with) s3-0)
      (collide-with-collide-cache-prim-mesh a0-1 arg0 arg1)
      )
     )
    )
   )
  (none)
  )

(defmethod
  collide-with-collide-cache-prim-sphere
  collide-shape-prim
  ((obj collide-shape-prim)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (format
   0
   "ERROR: Unsupported prim type in collide-shape-prim::collide-with-collide-cache-prim-sphere!~%"
   )
  (none)
  )

(defmethod
  collide-with-collide-cache-prim-sphere
  collide-shape-prim-sphere
  ((obj collide-shape-prim-sphere)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (local-vars (v1-4 int) (a3-2 uint))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
   (let* ((s5-0 (new 'stack-no-clear 'collide-mesh-cache-tri))
          (f0-1
           (dummy-10
            arg1
            s5-0
            (-> obj prim-core)
            (-> arg0 move-vec)
            (-> arg0 best-u)
            (the-as int (-> obj prim-core action))
            )
           )
          )
    (when (>= f0-1 0.0)
     (let ((v1-3 0)
           (a1-2 (-> obj prim-core action))
           )
      (nop!)
      (let ((a2-2 (-> arg1 prim-core action)))
       (nop!)
       (let ((a0-2 (-> arg1 prim-core offense))
             (a1-3 (logand a1-2 a2-2))
             (a2-3 (-> arg1 prim))
             )
        (let ((a3-1 (logand a1-3 1))
              (a1-4 (-> obj prim-core offense))
              )
         (b! (zero? a3-1) cfg-5 :delay (set! a3-2 (-> s5-0 bbox4w max data 0)))
         (b! (= a0-2 v1-3) cfg-5 :delay (set! v1-4 (- a1-4 a0-2)))
         )
        (b! (> v1-4 0) cfg-5 :delay (.lvf vf1 (&-> s5-0 normal quad)))
        (.lvf vf2 (&-> s5-0 bbox4w min quad))
        (.lvf vf3 (&-> s5-0 vertex 0 quad))
        (.lvf vf4 (&-> s5-0 vertex 1 quad))
        (.lvf vf5 (&-> s5-0 vertex 2 quad))
        (set! (-> arg0 best-u) f0-1)
        (set! (-> arg0 best-to-prim) (the-as collide-shape-prim a2-3))
        (set! (-> arg0 best-from-prim) obj)
        (set! (-> arg0 best-tri pat) (the-as pat-surface a3-2))
        (.svf (&-> arg0 best-tri intersect quad) vf1)
        (.svf (&-> arg0 best-tri normal quad) vf2)
        (.svf (&-> arg0 best-tri vertex 0 quad) vf3)
        (.svf (&-> arg0 best-tri vertex 1 quad) vf4)
        (.svf (&-> arg0 best-tri vertex 2 quad) vf5)
        (label cfg-5)
        (dummy-9
         *touching-list*
         obj
         (the-as collide-shape-prim a2-3)
         f0-1
         (the-as collide-shape #f)
         s5-0
         )
        )
       )
      )
     )
    )
   0
   (none)
   )
  )

(defmethod
  collide-with-collide-cache-prim-sphere
  collide-shape-prim-mesh
  ((obj collide-shape-prim-mesh)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (format
   0
   "ERROR: collide-shape-prim-mesh vs. collide-cache-prim sphere is not currently supported!~%"
   )
  (none)
  )

(defmethod
  collide-with-collide-cache-prim-sphere
  collide-shape-prim-group
  ((obj collide-shape-prim-group)
   (arg0 collide-shape-intersect)
   (arg1 collide-cache-prim)
   )
  (let ((s3-0 (-> arg1 prim-core collide-as)))
   (dotimes (s2-0 (-> obj num-prims))
    (let ((a0-1 (-> obj prims s2-0)))
     (if (logtest? (-> a0-1 collide-with) s3-0)
      (collide-with-collide-cache-prim-sphere a0-1 arg0 arg1)
      )
     )
    )
   )
  (none)
  )

(defun
  find-ground-point
  ((arg0 control-info) (arg1 vector) (arg2 float) (arg3 float))
  (local-vars (sv-176 int) (sv-192 int))
  (let ((f30-1 (if (< 819.2 (vector-xz-length (-> arg0 transv)))
                (vector-y-angle (-> arg0 transv))
                (y-angle arg0)
                )
         )
        (s2-0 (-> arg0 trans))
        (s1-0 (new 'stack-no-clear 'vector))
        (s0-0 (new 'stack-no-clear 'collide-mesh-cache-tri))
        )
   (let ((a1-1 (new 'stack-no-clear 'bounding-box)))
    (set! (-> arg1 w) 0.0)
    (dotimes (v1-1 3)
     (set! (-> a1-1 min data v1-1) (- (-> s2-0 data v1-1) arg3))
     (set! (-> a1-1 max data v1-1) (+ (-> s2-0 data v1-1) arg3))
     )
    (set! (-> a1-1 min y) (+ -40960.0 (-> s2-0 y)))
    (set! (-> a1-1 max y) (+ 20480.0 (-> s2-0 y)))
    (dummy-13
     *collide-cache*
     a1-1
     (-> arg0 root-prim collide-with)
     (-> arg0 process)
     (the-as uint 1)
     )
    )
   (set! sv-176 0)
   (while (< sv-176 8)
    (let ((f28-0 (+ f30-1 (if (zero? (logand sv-176 1))
                           (* 8192.0 (the float (/ sv-176 2)))
                           (* -8192.0 (the float (/ sv-176 2)))
                           )
                  )
           )
          )
     (set! sv-192 0)
     (let ((f26-0 arg3))
      (set-vector! s1-0 0.0 0.0 arg3 1.0)
      (vector-rotate-y! s1-0 s1-0 f28-0)
      (if
       (>=
        (dummy-18
         *collide-cache*
         (vector+!
          (new 'stack-no-clear 'vector)
          s2-0
          (new 'static 'vector :y 20480.0 :w 1.0)
          )
         s1-0
         2048.0
         (the-as int (-> arg0 root-prim collide-with))
         s0-0
         1
         )
        0.0
        )
       (set!
        f26-0
        (+ -6144.0 (vector-vector-xz-distance s2-0 (-> s0-0 normal)))
        )
       )
      (let ((f24-0 arg2))
       (while (>= f26-0 f24-0)
        (set-vector! s1-0 0.0 0.0 f24-0 1.0)
        (vector-rotate-y! s1-0 s1-0 f28-0)
        (vector+! s1-0 s2-0 s1-0)
        (set! (-> s1-0 y) (+ 20480.0 (-> s2-0 y)))
        (when
         (>=
          (dummy-18
           *collide-cache*
           s1-0
           (new 'static 'vector :y -251658240.0 :w 1.0)
           10240.0
           (the-as int (-> arg0 root-prim collide-with))
           s0-0
           1
           )
          0.0
          )
         (cond
          ((and
            (zero? (shr (shl (-> s0-0 bbox4w max data 0) 58) 61))
            (zero? (shr (shl (-> s0-0 bbox4w max data 0) 44) 58))
            (< 0.7 (the-as float (-> s0-0 bbox4w min data 1)))
            )
           (set! (-> arg1 quad) (-> s0-0 normal quad))
           (set! sv-192 (+ sv-192 1))
           (if (>= sv-192 2)
            (return arg1)
            )
           )
          ((and
            (= (shr (shl (-> s0-0 bbox4w max data 0) 58) 61) 1)
            (< (+ 4096.0 (-> s2-0 y)) (-> s0-0 normal y))
            )
           (goto cfg-35)
           )
          )
         )
        (set! f24-0 (+ 4096.0 f24-0))
        )
       )
      )
     )
    (label cfg-35)
    (set! sv-176 (+ sv-176 1))
    )
   )
  (the-as vector #f)
  )

(defun target-attack-up ((arg0 target) (arg1 symbol) (arg2 symbol))
  (with-pp
   (let
    ((s4-0
      (find-ground-point
       (-> arg0 control)
       (new 'stack-no-clear 'vector)
       8192.0
       40960.0
       )
      )
     )
    (set! s4-0 (cond
                (s4-0
                 (empty)
                 s4-0
                 )
                (else
                 (-> arg0 control unknown-vector54)
                 )
                )
     )
    (let*
     ((s2-1
       (vector-! (new 'stack-no-clear 'vector) s4-0 (-> arg0 control trans))
       )
      (f30-1 (fmax 8192.0 (fmin 40960.0 (vector-xz-length s2-1))))
      )
     (cond
      ((<
        (fabs
         (vector-dot
          (-> arg0 control dynam gravity-normal)
          (vector-! (new 'stack-no-clear 'vector) s4-0 (-> arg0 control trans))
          )
         )
        40960.0
        )
       (vector-xz-normalize! s2-1 f30-1)
       (let ((s1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> s1-0 from) pp)
        (set! (-> s1-0 num-params) 2)
        (set! (-> s1-0 message) arg1)
        (set! (-> s1-0 param 0) (the-as uint #f))
        (let ((s3-1 (new 'static 'attack-info :mask #x8a2)))
         (set! (-> s3-1 mode) arg2)
         (set! (-> s3-1 vector quad) (-> s2-1 quad))
         (set!
          (-> s3-1 shove-up)
          (+
           (lerp-scale 4096.0 16384.0 f30-1 4096.0 40960.0)
           (fmax 0.0 (- (-> s4-0 y) (-> arg0 control trans y)))
           )
          )
         (set! (-> s3-1 angle) 'up)
         (set! (-> s1-0 param 1) (the-as uint s3-1))
         )
        (send-event-function arg0 s1-0)
        )
       )
      (else
       (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-6 from) pp)
        (set! (-> a1-6 num-params) 2)
        (set! (-> a1-6 message) arg1)
        (set! (-> a1-6 param 0) (the-as uint #f))
        (let ((v1-12 (new 'static 'attack-info :mask #xca2)))
         (set! (-> v1-12 mode) arg2)
         (set!
          (-> v1-12 vector quad)
          (->
           (new 'static 'attack-info
            :trans (new 'static 'vector :y 40960.0 :w 1.0)
            :speed (the-as float #x1)
            )
           trans
           quad
           )
          )
         (set! (-> v1-12 shove-up) 40960.0)
         (set! (-> v1-12 angle) 'up)
         (set! (-> v1-12 control) 1.0)
         (set! (-> a1-6 param 1) (the-as uint v1-12))
         )
        (send-event-function arg0 a1-6)
        )
       )
      )
     )
    )
   (none)
   )
  )

(defmethod
  dummy-56
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 pat-surface))
  (with-pp
   (set! (-> obj cur-pat) arg0)
   (set! (-> obj poly-pat) arg0)
   (case (-> arg0 material) 
    (((pat-material ice))
      (set! (-> obj surf) *ice-surface*)
      )
    (((pat-material quicksand))
     (set! (-> obj surf) *quicksand-surface*)
     )
    (((pat-material tube))
     (set! (-> obj surf) *no-walk-surface*)
     )
    (((pat-material rotate))
     (set! (-> obj surf) *rotate-surface*)
     )
    (else
     (set! (-> obj surf) *standard-ground-surface*)
     )
    )
   (if (logtest? (-> obj root-prim prim-core action) 512)
    (set! (-> obj surf) *race-track-surface*)
    )
   (when (nonzero? (-> arg0 event))
    (case (-> arg0 event) 
     (((pat-event deadly))
       (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-3 from) pp)
        (set! (-> a1-3 num-params) 2)
        (set! (-> a1-3 message) 'attack)
        (set! (-> a1-3 param 0) (the-as uint #f))
        (let ((v1-19 (new 'static 'attack-info :mask #xa0)))
         (set! (-> v1-19 mode) 'deadly)
         (set! (-> v1-19 shove-up) 12288.0)
         (set! (-> a1-3 param 1) (the-as uint v1-19))
         )
        (send-event-function (-> obj process) a1-3)
        )
       )
     (((pat-event burn))
      (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
       (set! (-> a1-6 from) pp)
       (set! (-> a1-6 num-params) 2)
       (set! (-> a1-6 message) 'attack)
       (set! (-> a1-6 param 0) (the-as uint #f))
       (let ((v1-23 (new 'static 'attack-info :mask #xa0)))
        (set! (-> v1-23 mode) 'burn)
        (set! (-> v1-23 shove-up) 12288.0)
        (set! (-> a1-6 param 1) (the-as uint v1-23))
        )
       (send-event-function (-> obj process) a1-6)
       )
      )
     (((pat-event deadlyup))
      (target-attack-up
       (the-as target (-> obj process))
       'attack-or-shove
       'deadlyup
       )
      )
     (((pat-event burnup))
      (if
       (zero?
        (logand
         (->
          (the-as target (-> obj process))
          control
          root-prim
          prim-core
          action
          )
         512
         )
        )
       (target-attack-up
        (the-as target (-> obj process))
        'attack-or-shove
        'burnup
        )
       )
      )
     (((pat-event melt))
      (let ((a1-15 (new 'stack-no-clear 'event-message-block)))
       (set! (-> a1-15 from) pp)
       (set! (-> a1-15 num-params) 2)
       (set! (-> a1-15 message) 'attack-invinc)
       (set! (-> a1-15 param 0) (the-as uint #f))
       (let ((a2-8 (new 'static 'attack-info :mask #x20)))
        (set! (-> a2-8 mode) 'melt)
        (set! (-> a1-15 param 1) (the-as uint a2-8))
        )
       (send-event-function (-> obj process) a1-15)
       )
      )
     (((pat-event endlessfall))
      (let ((a1-17 (new 'stack-no-clear 'event-message-block)))
       (set! (-> a1-17 from) pp)
       (set! (-> a1-17 num-params) 2)
       (set! (-> a1-17 message) 'attack-invinc)
       (set! (-> a1-17 param 0) (the-as uint #f))
       (let ((a2-9 (new 'static 'attack-info :mask #x20)))
        (set! (-> a2-9 mode) 'endlessfall)
        (set! (-> a1-17 param 1) (the-as uint a2-9))
        )
       (send-event-function (-> obj process) a1-17)
       )
      )
     )
    )
   0
   (none)
   )
  )

(defun
  default-collision-reaction
  ((arg0 collide-shape-moving)
   (arg1 collide-shape-intersect)
   (arg2 vector)
   (arg3 vector)
   )
  (local-vars
   (sv-64 vector)
   (sv-68 vector)
   (sv-72 vector)
   (sv-80 int)
   (sv-128 symbol)
   )
  (set! sv-64 (new-stack-vector0))
  (set! sv-68 (new-stack-vector0))
  (set! sv-72 (new 'stack-no-clear 'vector))
  (set! sv-80 0)
  (set! (-> sv-72 quad) (-> arg3 quad))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
   (vector-float*! a1-1 (-> arg1 move-vec) (-> arg1 best-u))
   (TODO-RENAME-28 arg0 a1-1)
   )
  (dummy-56 arg0 (-> arg1 best-tri pat))
  (vector-!
   sv-64
   (the-as vector (-> arg1 best-from-prim prim-core))
   (-> arg1 best-tri intersect)
   )
  (set! (-> sv-64 w) 1.0)
  (vector-normalize! sv-64 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-64 (-> arg1 best-tri normal)))
  (let ((v1-16 (-> sv-64 quad)))
   (set! (-> sv-68 quad) v1-16)
   )
  (if (= (-> arg1 best-u) 0.0)
   (TODO-RENAME-28 arg0 sv-68)
   )
  (set! (-> arg0 surface-normal quad) (-> sv-68 quad))
  (set! (-> arg0 poly-normal quad) (-> arg1 best-tri normal quad))
  (set!
   (-> arg0 surface-angle)
   (vector-dot sv-68 (-> arg0 dynam gravity-normal))
   )
  (set!
   (-> arg0 poly-angle)
   (vector-dot (-> arg0 poly-normal) (-> arg0 dynam gravity-normal))
   )
  (set!
   (-> arg0 touch-angle)
   (vector-dot
    sv-68
    (vector-normalize! (vector-negate! (new-stack-vector0) sv-72) 1.0)
    )
   )
  (if (< (-> arg0 poly-angle) -0.2)
   (set! sv-80 (logior sv-80 16))
   )
  (set!
   sv-128
   (<
    (fabs (-> arg0 surface-angle))
    (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)
    )
   )
  (when (zero? (logand (-> arg0 prev-status) 1))
   (set!
    (-> arg0 ground-impact-vel)
    (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal)))
    )
   (when (not sv-128)
    (let ((f30-0 (- 1.0 (-> arg0 surf impact-fric))))
     (when (< f30-0 1.0)
      (let ((s3-1 (new-stack-vector0))
            (f28-0 (vector-dot (-> arg0 dynam gravity-normal) sv-72))
            )
       0.0
       (vector-!
        s3-1
        sv-72
        (vector-float*! s3-1 (-> arg0 dynam gravity-normal) f28-0)
        )
       (let* ((f0-22 (vector-length s3-1))
              (f1-4 f0-22)
              )
        (if (< f28-0 0.0)
         (set! f28-0 (* f28-0 f30-0))
         )
        (vector+!
         sv-72
         (vector-float*! sv-72 (-> arg0 dynam gravity-normal) f28-0)
         (vector-float*! s3-1 s3-1 (/ f0-22 f1-4))
         )
        )
       )
      )
     )
    )
   )
  (set! sv-80 (logior sv-80 4))
  (if (-> arg1 best-to-prim)
   (set! sv-80 (logior sv-80 32))
   )
  (cond
   (sv-128
    (set! sv-80 (logior sv-80 8))
    (set! (-> arg0 cur-pat mode) 1)
    )
   (else
    (set! sv-80 (logior sv-80 1))
    (set! (-> arg0 local-normal quad) (-> sv-68 quad))
    )
   )
  (vector-reflect-flat! arg2 sv-72 sv-68)
  (when (and (not sv-128) (>= (-> arg0 coverage) 0.9))
   (set! sv-80 (logior sv-80 2))
   (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
   (when (!= (-> arg0 poly-pat mode) (pat-mode wall))
    (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
    (set! (-> arg0 ground-touch-point quad) (-> arg1 best-tri intersect quad))
    )
   )
  (logior! (-> arg0 status) sv-80)
  sv-80
  (none)
  )

(defun
  simple-collision-reaction
  ((arg0 collide-shape-moving) (arg1 collide-shape-intersect))
  (let ((s5-0 0))
   (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-1 (-> arg1 move-vec) (-> arg1 best-u))
    (TODO-RENAME-28 arg0 a1-1)
    )
   (let ((f0-2 (vector-dot (-> arg0 transv) (-> arg1 best-tri normal)))
         (v1-6 (new 'stack-no-clear 'vector))
         )
    (vector-float*! v1-6 (-> arg1 best-tri normal) (* 1.5 f0-2))
    (vector-! (-> arg0 transv) (-> arg0 transv) v1-6)
    )
   (let ((v0-1 (logior s5-0 7)))
    (logior! (-> arg0 status) v0-1)
    )
   )
  (none)
  )

(defmethod
  dummy-63
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 vector) (arg1 vector) (arg2 float))
  (local-vars (sv-192 int))
  (let ((s5-0 (new 'stack 'collide-shape-intersect))
        (s2-0 (new 'stack-no-clear 'vector))
        )
   (vector-float*! s2-0 arg1 (* arg2 (-> *display* seconds-per-frame)))
   (init! s5-0 s2-0)
   (let* ((s1-1 (-> obj root-prim))
          (v1-4 *collide-cache*)
          (s0-0 (the-as collide-cache-prim (-> v1-4 prims)))
          )
    (set! sv-192 (-> v1-4 num-prims))
    (while (nonzero? sv-192)
     (set! sv-192 (+ sv-192 -1))
     (when (logtest? (-> s1-1 collide-with) (-> s0-0 prim-core collide-as))
      (if (>= (-> s0-0 prim-core prim-type) 0)
       (collide-with-collide-cache-prim-mesh s1-1 s5-0 s0-0)
       (collide-with-collide-cache-prim-sphere s1-1 s5-0 s0-0)
       )
      )
     (set! s0-0 (-> (the-as (inline-array collide-cache-prim) s0-0) 1))
     )
    )
   (let ((f30-0 (-> s5-0 best-u)))
    (cond
     ((>= f30-0 0.0)
      (let ((s2-1 (new 'stack-no-clear 'vector)))
       (if *display-collision-marks*
        (set! (-> s2-1 quad) (-> arg1 quad))
        )
       (set!
        (-> obj prev-status)
        (the-as uint ((-> obj reaction) obj s5-0 arg0 arg1))
        )
       (when *display-collision-marks*
        (let
         ((t1-0 (-> *pat-mode-info* (-> s5-0 best-tri pat mode) hilite-color)))
         (add-debug-outline-triangle
          #t
          (bucket-id debug-draw1)
          (the-as vector (-> s5-0 best-tri))
          (-> s5-0 best-tri vertex 1)
          (-> s5-0 best-tri vertex 2)
          t1-0
          )
         )
        (add-debug-vector
         #t
         (bucket-id debug-draw1)
         (-> s5-0 best-tri intersect)
         s2-1
         (meters 0.00007324219)
         (new 'static 'rgba :r #xff :g #xa0 :a #x80)
         )
        (add-debug-vector
         #t
         (bucket-id debug-draw1)
         (-> s5-0 best-tri intersect)
         arg0
         (meters 0.00007324219)
         (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
         )
        (if (= (-> obj process type) target)
         (add-debug-vector
          #t
          (bucket-id debug-draw1)
          (-> s5-0 best-tri intersect)
          (-> obj surface-normal)
          (meters 0.5)
          (-> *pat-mode-info* (-> obj cur-pat mode) hilite-color)
          )
         )
        )
       )
      (return f30-0)
      )
     (else
      (set! (-> obj reaction-flag) (the-as uint 0))
      ((-> obj no-reaction) obj s5-0 arg0 arg1)
      (set! (-> obj prev-status) (the-as uint 0))
      (TODO-RENAME-28 obj s2-0)
      (set! (-> arg0 quad) (-> arg1 quad))
      (return 1.0)
      )
     )
    )
   )
  (the-as none 0)
  (the-as float 1.0)
  )

(defmethod dummy-37 collide-shape ((obj collide-shape) (arg0 vector))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (init-vf0-vector)
   (let ((t9-0 (method-of-object obj TODO-RENAME-28))
         (v1-1 (new 'stack-no-clear 'vector))
         )
    (.lvf vf1 (&-> arg0 quad))
    (let ((f0-0 (-> *display* seconds-per-frame)))
     (.mov at-0 f0-0)
     )
    (.mov vf2 at-0)
    (.mov.vf vf1 vf0 :mask #b1000)
    (.mul.x.vf vf1 vf1 vf2 :mask #b111)
    (.svf (&-> v1-1 quad) vf1)
    (t9-0 obj v1-1)
    )
   (none)
   )
  )

(defmethod
  dummy-37
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 vector))
  (dummy-47 obj)
  (set! (-> obj trans-old 2 quad) (-> obj trans-old 1 quad))
  (set! (-> obj trans-old 1 quad) (-> obj trans-old 0 quad))
  (set! (-> obj trans-old 0 quad) (-> obj trans quad))
  (set! (-> obj prev-status) (-> obj status))
  (set! (-> obj status) (logand -16128 (-> obj status)))
  (set! (-> obj local-normal quad) (-> obj dynam gravity-normal quad))
  (set! (-> obj surface-normal quad) (-> obj dynam gravity-normal quad))
  (set! (-> obj poly-normal quad) (-> obj dynam gravity-normal quad))
  (set! (-> obj coverage) 0.0)
  (set! (-> obj touch-angle) 0.0)
  (let ((f30-0 1.0)
        (s4-0 0)
        )
   (while
    (and
     (< 0.05 f30-0)
     (and
      (< s4-0 (the-as int (-> obj max-iteration-count)))
      (not (and (= (-> arg0 x) 0.0) (= (-> arg0 y) 0.0) (= (-> arg0 z) 0.0)))
      )
     )
    (let ((f28-0 (dummy-63 obj arg0 arg0 f30-0)))
     (dummy-11 *touching-list* f28-0)
     (set! f30-0 (- f30-0 (* f28-0 f30-0)))
     )
    (+! s4-0 1)
    )
   )
  0
  (none)
  )

(defmethod dummy-37 control-info ((obj control-info) (arg0 vector))
  (stopwatch-start (-> *collide-stats* total-target))
  (when (< 1638400.0 (vector-length arg0))
   (format
    0
    "WARNING: target vel is ~M m/s, reseting to zero.~%"
    (vector-length arg0)
    )
   (vector-reset! arg0)
   )
  (set! (-> obj unknown-vector15 quad) (-> obj unknown-vector14 quad))
  (vector-matrix*!
   (-> obj unknown-vector14)
   (-> obj unknown-vector13)
   (-> obj unknown-matrix02)
   )
  (vector-!
   (-> obj unknown-vector16)
   (-> obj unknown-vector14)
   (-> obj unknown-vector15)
   )
  (let
   ((a1-6
     (vector-!
      (new 'stack-no-clear 'vector)
      (-> obj unknown-vector11)
      (-> obj unknown-vector14)
      )
     )
    )
   (vector-seek!
    (-> obj unknown-vector12)
    a1-6
    (* 16384.0 (-> *display* seconds-per-frame))
    )
   )
  (let
   ((s3-1
     (vector+float*! (new-stack-vector0) arg0 (-> obj unknown-vector16) 60.0)
     )
    (s4-1 (new 'stack-no-clear 'vector))
    )
   (set! (-> s4-1 quad) (-> arg0 quad))
   (let ((t9-7 (method-of-type collide-shape-moving dummy-37)))
    (t9-7 obj s3-1)
    )
   (let ((s1-0 (new-stack-vector0)))
    (set! (-> s1-0 quad) (-> s4-1 quad))
    (let ((s2-1 (new-stack-vector0)))
     (set! (-> s2-1 quad) (-> s3-1 quad))
     (let ((s0-0 (new-stack-vector0)))
      (let ((f0-4 (vector-dot (-> obj dynam gravity-normal) s1-0)))
       0.0
       (vector-!
        s0-0
        s1-0
        (vector-float*! s0-0 (-> obj dynam gravity-normal) f0-4)
        )
       )
      (let* ((f0-5 (vector-length s0-0))
             (f1-2 f0-5)
             (f2-0 0.0)
             )
       (vector+!
        s1-0
        (vector-float*! s1-0 (-> obj dynam gravity-normal) f2-0)
        (vector-float*! s0-0 s0-0 (/ f0-5 f1-2))
        )
       )
      )
     (let ((s0-1 (new-stack-vector0)))
      (let ((f0-8 (vector-dot (-> obj dynam gravity-normal) s2-1)))
       0.0
       (vector-!
        s0-1
        s2-1
        (vector-float*! s0-1 (-> obj dynam gravity-normal) f0-8)
        )
       )
      (let* ((f0-9 (vector-length s0-1))
             (f1-4 f0-9)
             (f2-1 0.0)
             )
       (vector+!
        s2-1
        (vector-float*! s2-1 (-> obj dynam gravity-normal) f2-1)
        (vector-float*! s0-1 s0-1 (/ f0-9 f1-4))
        )
       )
      )
     (vector-normalize! s1-0 1.0)
     (vector-normalize! s2-1 1.0)
     (let ((f30-1 (vector-dot s1-0 s2-1)))
      (cond
       ((and
         (!= (vector-length (-> obj unknown-vector01)) 0.0)
         (if (logtest? (-> obj status) 8)
          (< f30-1 0.9999)
          (< f30-1 0.95)
          )
         )
        (set!
         (-> obj unknown-float70)
         (seek
          (-> obj unknown-float70)
          1.0
          (* 4.0 (-> *display* seconds-per-frame))
          )
         )
        (set!
         (-> obj unknown-float71)
         (seek
          (-> obj unknown-float71)
          (if (= (-> obj unknown-surface00 mode) 'air)
           1.0
           0.0
           )
          (* 4.0 (-> *display* seconds-per-frame))
          )
         )
        (logior! (-> obj status) 512)
        )
       (else
        (set!
         (-> obj unknown-float70)
         (seek
          (-> obj unknown-float70)
          0.0
          (* 2.0 (-> *display* seconds-per-frame))
          )
         )
        (set!
         (-> obj unknown-float71)
         (seek
          (-> obj unknown-float71)
          0.0
          (* 2.0 (-> *display* seconds-per-frame))
          )
         )
        )
       )
      )
     )
    )
   (if (logtest? (-> obj status) 1)
    (set! (-> arg0 quad) (-> s3-1 quad))
    (vector--float*! arg0 s3-1 (-> obj unknown-vector16) 60.0)
    )
   (if
    (and
     (logtest? (-> obj status) 1)
     (and
      (zero? (logand (-> obj status) 520))
      (< (vector-length (-> obj unknown-vector61)) (vector-length s4-1))
      )
     )
    (set! (-> obj unknown-vector61 quad) (-> s4-1 quad))
    )
   )
  (let
   ((s5-1
     (vector-normalize-copy!
      (new 'stack-no-clear 'vector)
      (the-as vector (&-> obj unknown-vector120))
      1.0
      )
     )
    (f0-32 (vector-length (the-as vector (&-> obj unknown-vector120))))
    )
   (set! (-> obj unknown-float140) (if (= f0-32 0.0)
                                    0.0
                                    (fmax
                                     0.0
                                     (/ (vector-dot (-> obj transv) s5-1) f0-32)
                                     )
                                    )
    )
   )
  (stopwatch-stop (-> *collide-stats* total-target))
  0
  (none)
  )

(defmethod
  TODO-RENAME-61
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 vector) (arg1 vector) (arg2 vector))
  (TODO-RENAME-30 obj arg0)
  (set! (-> arg1 y) 0.0)
  (logior! (-> obj status) 7)
  (set! (-> obj poly-normal quad) (-> arg2 quad))
  (set! (-> obj surface-normal quad) (-> arg2 quad))
  (set! (-> obj local-normal quad) (-> arg2 quad))
  (set! (-> obj ground-poly-normal quad) (-> arg2 quad))
  (set!
   (-> obj ground-impact-vel)
   (- (vector-dot arg1 (-> obj dynam gravity-normal)))
   )
  (set! (-> obj ground-touch-point quad) (-> arg0 quad))
  0
  (none)
  )

(defmethod
  dummy-57
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 vector))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (init-vf0-vector)
   (dummy-47 obj)
   (set! (-> obj trans-old 2 quad) (-> obj trans-old 1 quad))
   (set! (-> obj trans-old 1 quad) (-> obj trans-old 0 quad))
   (set! (-> obj trans-old 0 quad) (-> obj trans quad))
   (set! (-> obj prev-status) (-> obj status))
   (set! (-> obj status) (logand -16128 (-> obj status)))
   (set! (-> obj local-normal quad) (-> obj dynam gravity-normal quad))
   (set! (-> obj surface-normal quad) (-> obj dynam gravity-normal quad))
   (set! (-> obj poly-normal quad) (-> obj dynam gravity-normal quad))
   (set! (-> obj coverage) 0.0)
   (set! (-> obj touch-angle) 0.0)
   (let* ((a0-12 obj)
          (t9-1 (method-of-object a0-12 TODO-RENAME-28))
          (a1-1 (new 'stack-no-clear 'vector))
          )
    (.lvf vf1 (&-> arg0 quad))
    (let ((f0-2 (-> *display* seconds-per-frame)))
     (.mov at-0 f0-2)
     )
    (.mov vf2 at-0)
    (.mov.vf vf1 vf0 :mask #b1000)
    (.mul.x.vf vf1 vf1 vf2 :mask #b111)
    (.svf (&-> a1-1 quad) vf1)
    (t9-1 a0-12 a1-1)
    )
   (set! (-> obj shadow-pos quad) (-> obj trans quad))
   0
   (none)
   )
  )

(defmethod
  dummy-58
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 vector))
  (dummy-57 obj arg0)
  (let ((a1-1 (new 'stack-no-clear 'touching-shapes-entry)))
   (set! (-> a1-1 cshape1) (the-as collide-shape 1))
   (set! (-> a1-1 cshape2) (the-as collide-shape *touching-list*))
   (when (dummy-40 obj a1-1)
    (TODO-RENAME-30 obj (the-as vector (-> obj trans-old)))
    (return #t)
    )
   )
  #f
  )

(defmethod
  dummy-64
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 collide-tri-result) (arg1 vector))
  (TODO-RENAME-30 obj arg1)
  (logior! (-> obj status) 7)
  (let ((v1-4 (-> arg0 normal)))
   (set! (-> obj poly-normal quad) (-> v1-4 quad))
   (set! (-> obj surface-normal quad) (-> v1-4 quad))
   (set! (-> obj local-normal quad) (-> v1-4 quad))
   (set! (-> obj ground-poly-normal quad) (-> v1-4 quad))
   )
  (set! (-> obj poly-pat) (-> arg0 pat))
  (set! (-> obj cur-pat) (-> arg0 pat))
  (set! (-> obj ground-pat) (-> arg0 pat))
  (set! (-> obj ground-touch-point quad) (-> arg1 quad))
  0
  (none)
  )

;; WARN: Stack slot offset 128 signed mismatch
(defmethod
  dummy-59
  collide-shape-moving
  ((obj collide-shape-moving)
   (arg0 vector)
   (arg1 uint)
   (arg2 float)
   (arg3 symbol)
   (arg4 symbol)
   (arg5 symbol)
   )
  (local-vars (sv-128 float) (sv-144 collide-mesh-cache-tri))
  (set! sv-128 arg2)
  (let ((s5-0 arg3))
   (let ((s3-0 arg4)
         (s1-0 arg5)
         )
    (if *debug-segment*
     (add-frame
      (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
      'draw
      (new 'static 'rgba :r #x40 :b #x40 :a #x80)
      )
     )
    (dummy-57 obj arg0)
    (let ((s0-0 (-> obj shadow-pos)))
     (set! (-> s0-0 quad) (-> obj trans quad))
     (set! sv-144 (new 'stack-no-clear 'collide-mesh-cache-tri))
     (+! (-> s0-0 y) sv-128)
     0.0
     (let ((f0-4 (if s1-0
                  (misty-ambush-height-probe s0-0 81920.0)
                  (dummy-10
                   *collide-cache*
                   s0-0
                   (new 'static 'vector :y -81920.0 :w 1.0)
                   40.96
                   (the-as int arg1)
                   (-> obj process)
                   sv-144
                   1
                   )
                  )
            )
           )
      (cond
       ((>= f0-4 0.0)
        (let ((a2-3 (new 'static 'vector :y -81920.0 :w 1.0)))
         (vector+float*! s0-0 s0-0 a2-3 f0-4)
         )
        (when (>= (-> s0-0 y) (-> obj trans y))
         (dummy-64 obj (the-as collide-tri-result sv-144) s0-0)
         (set!
          (-> obj ground-impact-vel)
          (- (vector-dot arg0 (-> obj dynam gravity-normal)))
          )
         (set! (-> arg0 y) 0.0)
         )
        )
       (s3-0
        (set! (-> obj trans y) (-> obj trans-old 0 y))
        )
       )
      )
     )
    )
   (when (logtest? (-> obj root-prim collide-with) 30)
    (let ((a1-7 (new 'stack-no-clear 'touching-shapes-entry)))
     (set! (-> a1-7 cshape1) (the-as collide-shape 1))
     (set! (-> a1-7 cshape2) (the-as collide-shape *touching-list*))
     (when (dummy-40 obj a1-7)
      (if s5-0
       (TODO-RENAME-30 obj (the-as vector (-> obj trans-old)))
       )
      )
     )
    )
   )
  (if *debug-segment*
   (add-frame
    (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
    'draw
    (new 'static 'rgba :g #xff :a #x80)
    )
   )
  0
  (none)
  )

(defmethod
  dummy-60
  collide-shape-moving
  ((obj collide-shape-moving)
   (arg0 float)
   (arg1 float)
   (arg2 symbol)
   (arg3 uint)
   )
  (if *debug-segment*
   (add-frame
    (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
    'draw
    (new 'static 'rgba :r #x40 :b #x40 :a #x80)
    )
   )
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'collide-tri-result))
        )
   (let ((f30-0 (+ arg0 arg1)))
    (set! (-> s4-0 quad) (-> obj trans quad))
    (+! (-> s4-0 y) arg0)
    0.0
    (let
     ((f0-4
       (fill-and-probe-using-y-probe
        *collide-cache*
        s4-0
        f30-0
        arg3
        (-> obj process)
        s3-0
        (the-as uint 1)
        )
       )
      )
     (when (< f0-4 0.0)
      (if arg2
       (format
        0
        "WARNING: move-to-ground: (~f ~f) failed to locate ground [~S type ~S]~%"
        (* 0.00024414062 (-> s4-0 y))
        (* 0.00024414062 f30-0)
        (-> obj process name)
        (-> obj process type symbol)
        )
       )
      (return #f)
      )
     (set! (-> s4-0 y) (- (-> s4-0 y) (* f0-4 f30-0)))
     )
    )
   (set! (-> obj shadow-pos quad) (-> s4-0 quad))
   (dummy-64 obj s3-0 s4-0)
   )
  (if *debug-segment*
   (add-frame
    (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
    'draw
    (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
    )
   )
  #t
  )

(defmethod
  dummy-62
  collide-shape-moving
  ((obj collide-shape-moving) (arg0 vector) (arg1 float))
  (let* ((s4-0 (vector-negate! (new-stack-vector0) (-> obj dynam gravity)))
         (a2-1 (-> obj local-normal))
         (a2-2 (vector-reflect-flat! (new-stack-vector0) s4-0 a2-1))
         )
   (vector--float*! arg0 s4-0 a2-2 (cond
                                    ((logtest? (-> obj status) 1)
                                     (empty)
                                     arg1
                                     )
                                    (else
                                     0.0
                                     )
                                    )
    )
   )
  arg0
  )

(defmethod dummy-33 collide-shape ((obj collide-shape) (arg0 vector) (arg1 uint))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (init-vf0-vector)
   (let ((a0-1 (new 'stack-no-clear 'vector)))
    (let ((v1-0 a0-1))
     (.lvf vf1 (&-> arg0 quad))
     (let ((f0-0 (-> *display* seconds-per-frame)))
      (.mov at-0 f0-0)
      )
     (.mov vf2 at-0)
     (.mov.vf vf1 vf0 :mask #b1000)
     (.mul.x.vf vf1 vf1 vf2 :mask #b111)
     (.svf (&-> v1-0 quad) vf1)
     )
    (let ((f0-2 (+ (vector-length a0-1) (if (= (-> obj process type) target)
                                         4096.0
                                         0.0
                                         )
                 )
           )
          )
     (dummy-32 obj f0-2 arg1)
     )
    )
   (dummy-37 obj arg0)
   (none)
   )
  )

(defmethod dummy-32 collide-shape ((obj collide-shape) (arg0 object) (arg1 uint))
  (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
   (cond
    ((dummy-36 obj s5-0 (the-as float arg0) arg1)
     (dummy-13
      *collide-cache*
      s5-0
      arg1
      (-> obj process)
      (the-as uint (-> obj pat-ignore-mask))
      )
     (if (and *display-collide-cache* (= (-> obj process type) target))
      (dummy-9 *collide-cache*)
      )
     )
    (else
     (initialize *collide-cache*)
     )
    )
   )
  (none)
  )

(defmethod
  dummy-36
  collide-shape
  ((obj collide-shape) (arg0 bounding-box) (arg1 float) (arg2 uint))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
   (init-vf0-vector)
   (let ((v1-0 (new 'static 'vector :x 4.096))
         (a0-1 (-> obj root-prim))
         )
    (cond
     ((logtest? (-> a0-1 collide-with) arg2)
      (.mov vf31 arg1)
      (.lvf vf1 (&-> v1-0 quad))
      (.add.x.vf vf31 vf31 vf1 :mask #b1)
      (cond
       ((dummy-20 a0-1 arg2)
        (.mov.vf vf29 vf0 :mask #b1000)
        (.mov.vf vf30 vf0 :mask #b1000)
        (.svf (&-> arg0 min quad) vf29)
        (.svf (&-> arg0 max quad) vf30)
        (return #t)
        )
       (else
        (return #f)
        )
       )
      (the-as none 0)
      )
     (else
      (return #f)
      )
     )
    )
   (the-as symbol 0)
   )
  )

;; WARN: Bad vector register dependency: vf31
(defmethod dummy-20 collide-shape-prim ((obj collide-shape-prim) (arg0 uint))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
   (.lvf vf1 (&-> obj prim-core world-sphere quad))
   (.add.w.vf vf2 vf31 vf1 :mask #b1)
   (.add.x.vf vf30 vf1 vf2 :mask #b111)
   (.sub.x.vf vf29 vf1 vf2 :mask #b111)
   #t
   )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod dummy-34 collide-shape ((obj collide-shape) (arg0 uint))
  (dummy-10 (-> obj root-prim) arg0)
  )

(defmethod dummy-10 collide-shape-prim ((obj collide-shape-prim) (arg0 uint))
  (if (= (-> obj prim-id) arg0)
   (return obj)
   )
  (the-as collide-shape-prim #f)
  )

(defmethod
  dummy-10
  collide-shape-prim-group
  ((obj collide-shape-prim-group) (arg0 uint))
  (if (= (-> obj prim-id) arg0)
   (return obj)
   )
  (countdown (s4-0 (-> obj num-prims))
   (let ((a0-1 (-> obj prims s4-0)))
    (cond
     ((= (-> a0-1 type) collide-shape-prim-group)
      (let ((a0-2 (dummy-10 a0-1 arg0)))
       (if a0-2
        (return a0-2)
        )
       )
      )
     (else
      (if (= (-> a0-1 prim-id) arg0)
       (return a0-1)
       )
      )
     )
    )
   )
  (the-as collide-shape-prim #f)
  )

(defun-debug collide-shape-draw-debug-marks ()
  (add-debug-sphere
   (or *display-collision-marks* *display-target-marks*)
   (bucket-id debug-draw0)
   (target-pos 0)
   819.2
   (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
   )
  (when *display-collision-marks*
   (let ((v1-4 (-> *collide-player-list* alive-list next0)))
    *collide-player-list*
    (let ((gp-1 (-> v1-4 next0)))
     (while (!= v1-4 (-> *collide-player-list* alive-list-end))
      (let ((s5-1 (-> (the-as connection v1-4) param1)))
       (if
        (or
         (and (not *display-actor-anim*) (not *display-process-anim*))
         (or
          (= (-> (the-as collide-shape s5-1) process) *target*)
          (name=
           *display-actor-anim*
           (-> (the-as collide-shape s5-1) process name)
           )
          (=
           (ppointer->process *display-process-anim*)
           (-> (the-as collide-shape s5-1) process)
           )
          )
         )
        (dummy-31 (the-as collide-shape s5-1))
        )
       )
      (set! v1-4 gp-1)
      *collide-player-list*
      (set! gp-1 (-> gp-1 next0))
      )
     )
    )
   (let ((v1-19 (-> *collide-hit-by-player-list* alive-list next0)))
    *collide-hit-by-player-list*
    (let ((gp-2 (-> v1-19 next0)))
     (while (!= v1-19 (-> *collide-hit-by-player-list* alive-list-end))
      (let ((s5-2 (-> (the-as connection v1-19) param1)))
       (if
        (or
         (and (not *display-actor-anim*) (not *display-process-anim*))
         (or
          (= (-> (the-as collide-shape s5-2) process) *target*)
          (name=
           *display-actor-anim*
           (-> (the-as collide-shape s5-2) process name)
           )
          (=
           (ppointer->process *display-process-anim*)
           (-> (the-as collide-shape s5-2) process)
           )
          )
         )
        (dummy-31 (the-as collide-shape s5-2))
        )
       )
      (set! v1-19 gp-2)
      *collide-hit-by-player-list*
      (set! gp-2 (-> gp-2 next0))
      )
     )
    )
   (let ((v1-34 (-> *collide-usually-hit-by-player-list* alive-list next0)))
    *collide-usually-hit-by-player-list*
    (let ((gp-3 (-> v1-34 next0)))
     (while (!= v1-34 (-> *collide-usually-hit-by-player-list* alive-list-end))
      (let ((s5-3 (-> (the-as connection v1-34) param1)))
       (if
        (or
         (and (not *display-actor-anim*) (not *display-process-anim*))
         (or
          (= (-> (the-as collide-shape s5-3) process) *target*)
          (name=
           *display-actor-anim*
           (-> (the-as collide-shape s5-3) process name)
           )
          (=
           (ppointer->process *display-process-anim*)
           (-> (the-as collide-shape s5-3) process)
           )
          )
         )
        (dummy-31 (the-as collide-shape s5-3))
        )
       )
      (set! v1-34 gp-3)
      *collide-usually-hit-by-player-list*
      (set! gp-3 (-> gp-3 next0))
      )
     )
    )
   (let ((v1-49 (-> *collide-hit-by-others-list* alive-list next0)))
    *collide-hit-by-others-list*
    (let ((gp-4 (-> v1-49 next0)))
     (while (!= v1-49 (-> *collide-hit-by-others-list* alive-list-end))
      (let ((s5-4 (-> (the-as connection v1-49) param1)))
       (if
        (or
         (and (not *display-actor-anim*) (not *display-process-anim*))
         (or
          (= (-> (the-as collide-shape s5-4) process) *target*)
          (name=
           *display-actor-anim*
           (-> (the-as collide-shape s5-4) process name)
           )
          (=
           (ppointer->process *display-process-anim*)
           (-> (the-as collide-shape s5-4) process)
           )
          )
         )
        (dummy-31 (the-as collide-shape s5-4))
        )
       )
      (set! v1-49 gp-4)
      *collide-hit-by-others-list*
      (set! gp-4 (-> gp-4 next0))
      )
     )
    )
   )
  0
  (none)
  )

(defmethod dummy-31 collide-shape ((obj collide-shape))
  (if (sphere-in-view-frustum? (the-as sphere (-> obj root-prim prim-core)))
   (debug-draw-world-sphere (-> obj root-prim))
   )
  (none)
  )

(define *col-timer* (new 'global 'stopwatch))

(define *frame-timer* (new 'global 'stopwatch))

(define *col-timer-enable* #t)

(defun debug-report-col-stats ()
  (when *col-timer-enable*
   (stopwatch-end *frame-timer*)
   (format *stdcon* "col stats:~%")
   (format
    *stdcon*
    " col       ~F ms~%"
    (* 1000.0 (stopwatch-elapsed-seconds *col-timer*))
    )
   (format
    *stdcon*
    " frame     ~F ms~%"
    (* 1000.0 (stopwatch-elapsed-seconds *frame-timer*))
    )
   (stopwatch-init *col-timer*)
   (stopwatch-init *frame-timer*)
   (stopwatch-begin *frame-timer*)
   )
  )

(defmethod dummy-47 collide-shape ((obj collide-shape))
  (dummy-25 (-> obj root-prim) (-> obj process))
  #f
  )

(defmethod
  dummy-25
  collide-shape-prim
  ((obj collide-shape-prim) (arg0 process-drawable))
  (local-vars (a0-2 float) (a0-4 float) (a0-6 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
   (init-vf0-vector)
   (let ((a1-1 (-> arg0 node-list))
         (v1-0 (-> obj cshape))
         (a0-1 (-> obj transform-index))
         )
    (cond
     ((nonzero? a1-1)
      (cond
       ((>= a0-1 0)
        (let ((v1-4 (-> a1-1 data a0-1 bone transform)))
         (.lvf vf5 (&-> v1-4 vector 3 quad))
         (.lvf vf1 (&-> obj local-sphere quad))
         (.lvf vf2 (&-> v1-4 vector 0 quad))
         (.mul.w.vf acc vf5 vf0)
         (.div.vf Q vf0 vf5 :fsf #b11 :ftf #b11)
         (.lvf vf3 (&-> v1-4 vector 1 quad))
         (.add.mul.x.vf acc vf2 vf1 acc)
         (.lvf vf4 (&-> v1-4 vector 2 quad))
         )
        (.add.mul.y.vf acc vf3 vf1 acc)
        (.add.mul.z.vf vf1 vf4 vf1 acc :mask #b111)
        (.mul.vf vf1 vf1 Q :mask #b111)
        (.svf (&-> obj prim-core world-sphere quad) vf1)
        (.mov a0-2 vf1)
        )
       (else
        (when (= a0-1 -2)
         (.lvf vf1 (&-> obj local-sphere quad))
         (.lvf vf2 (&-> v1-0 trans quad))
         (.add.vf vf1 vf1 vf2 :mask #b111)
         (.svf (&-> obj prim-core world-sphere quad) vf1)
         (.mov a0-4 vf1)
         )
        )
       )
      )
     (else
      (when (!= a0-1 -1)
       (.lvf vf1 (&-> obj local-sphere quad))
       (.lvf vf2 (&-> v1-0 trans quad))
       (.add.vf vf1 vf1 vf2 :mask #b111)
       (.svf (&-> obj prim-core world-sphere quad) vf1)
       (.mov a0-6 vf1)
       )
      )
     )
    )
   (when (= (-> obj type) collide-shape-prim-group)
    (countdown (s4-0 (-> (the-as collide-shape-prim-group obj) num-prims))
     (dummy-25 (-> (the-as collide-shape-prim-group obj) prims s4-0) arg0)
     )
    #f
    )
   )
  )

(defmethod TODO-RENAME-28 collide-shape ((obj collide-shape) (arg0 vector))
  (vector+! (-> obj trans) (-> obj trans) arg0)
  (dummy-9 (-> obj root-prim) arg0)
  (none)
  )

(defmethod dummy-9 collide-shape-prim ((obj collide-shape-prim) (arg0 vector))
  (vector+!
   (the-as vector (-> obj prim-core))
   (the-as vector (-> obj prim-core))
   arg0
   )
  (let ((f0-0 (-> obj local-sphere w)))
   (set! (-> obj prim-core world-sphere w) f0-0)
   (the-as object f0-0)
   )
  )

(defmethod
  dummy-9
  collide-shape-prim-group
  ((obj collide-shape-prim-group) (arg0 vector))
  (vector+!
   (the-as vector (-> obj prim-core))
   (the-as vector (-> obj prim-core))
   arg0
   )
  (set! (-> obj prim-core world-sphere w) (-> obj local-sphere w))
  (countdown (s4-0 (-> obj num-prims))
   (let ((a0-2 (-> obj prims s4-0)))
    (cond
     ((= (-> a0-2 type) collide-shape-prim-group)
      (dummy-9 a0-2 arg0)
      )
     (else
      (vector+!
       (the-as vector (-> a0-2 prim-core))
       (the-as vector (-> a0-2 prim-core))
       arg0
       )
      (set! (-> a0-2 prim-core world-sphere w) (-> a0-2 local-sphere w))
      )
     )
    )
   )
  (the-as object #f)
  )

(defmethod TODO-RENAME-30 collide-shape ((obj collide-shape) (arg0 vector))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
   (vector-! v1-0 arg0 (-> obj trans))
   (TODO-RENAME-28 obj v1-0)
   )
  (none)
  )

(defmethod
  set-root-prim!
  collide-shape
  ((obj collide-shape) (arg0 collide-shape-prim))
  (set! (-> obj root-prim) arg0)
  arg0
  )

(defmethod
  set-collide-with!
  collide-shape-prim
  ((obj collide-shape-prim) (arg0 handle))
  (set! (-> obj collide-with) (the-as uint arg0))
  0
  (none)
  )

(defmethod
  set-collide-with!
  collide-shape-prim-group
  ((obj collide-shape-prim-group) (arg0 handle))
  (set! (-> obj collide-with) (the-as uint arg0))
  (dotimes (s4-0 (-> obj num-prims))
   (set-collide-with! (-> obj prims s4-0) arg0)
   )
  0
  (none)
  )

(defmethod
  set-collide-as!
  collide-shape-prim
  ((obj collide-shape-prim) (arg0 handle))
  (set! (-> obj prim-core collide-as) (the-as uint arg0))
  0
  (none)
  )

(defmethod
  set-collide-as!
  collide-shape-prim-group
  ((obj collide-shape-prim-group) (arg0 handle))
  (set! (-> obj prim-core collide-as) (the-as uint arg0))
  (dotimes (s4-0 (-> obj num-prims))
   (set-collide-as! (-> obj prims s4-0) arg0)
   )
  0
  (none)
  )

(defmethod
  set-root-prim-collide-with!
  collide-shape
  ((obj collide-shape) (arg0 handle))
  (set-collide-with! (-> obj root-prim) arg0)
  0
  (none)
  )

(defmethod
  set-root-prim-collide-as!
  collide-shape
  ((obj collide-shape) (arg0 handle))
  (set-collide-as! (-> obj root-prim) arg0)
  0
  (none)
  )

(defmethod
  append-prim
  collide-shape-prim-group
  ((obj collide-shape-prim-group) (arg0 collide-shape-prim))
  (let ((v1-0 (-> obj num-prims)))
   (cond
    ((>= v1-0 (-> obj allocated-prims))
     (format
      0
      "collide-shape-prim-group::append-prim : Exceeded max # of prims!~%"
      )
     )
    (else
     (set! (-> obj prims v1-0) arg0)
     (set! (-> obj num-prims) (+ v1-0 1))
     )
    )
   )
  (none)
  )

(defmethod find-collision-meshes collide-shape ((obj collide-shape))
  (let ((s5-0 0))
   (let ((v1-1 (-> obj process draw)))
    (when (and (nonzero? v1-1) (-> v1-1 jgeo))
     (let
      ((a1-1
        (res-lump-struct (-> v1-1 jgeo extra) 'collide-mesh-group structure)
        )
       )
      (if a1-1
       (set!
        s5-0
        (num-mesh (-> obj root-prim) (the-as collide-shape-prim a1-1))
        )
       )
      )
     )
    )
   (if (nonzero? s5-0)
    (format
     0
     "ERROR: Failed to find collision meshes for ~D prim(s) in ~A!~%"
     s5-0
     (-> obj process name)
     )
    )
   )
  (dummy-47 obj)
  )

(defmethod
  num-mesh
  collide-shape-prim
  ((obj collide-shape-prim) (arg0 collide-shape-prim))
  (local-vars (v0-0 int))
  (return 0)
  v0-0
  )

(defmethod
  num-mesh
  collide-shape-prim-mesh
  ((obj collide-shape-prim-mesh) (arg0 collide-shape-prim))
  (let ((s4-0 (-> obj mesh-id)))
   (cond
    ((and (>= s4-0 0) (< s4-0 (length arg0)))
     (set!
      (-> obj mesh)
      (the-as collide-mesh (-> arg0 prim-core world-sphere data s4-0))
      )
     (return 0)
     )
    (else
     (set! (-> obj mesh) #f)
     (return 1)
     )
    )
   )
  (the-as int 0)
  )

(defmethod
  num-mesh
  collide-shape-prim-group
  ((obj collide-shape-prim-group) (arg0 collide-shape-prim))
  (let ((gp-0 0))
   (countdown (s3-0 (-> obj num-prims))
    (+! gp-0 (num-mesh (-> obj prims s3-0) arg0))
    )
   gp-0
   )
  )

(defmethod
  init!
  collide-shape-intersect
  ((obj collide-shape-intersect) (arg0 vector))
  (set! (-> obj move-vec quad) (-> arg0 quad))
  (set! (-> obj best-u) -100000000.0)
  (set! (-> obj best-from-prim) #f)
  (set! (-> obj best-to-prim) #f)
  #f
  )

(defmethod debug-draw-world-sphere collide-shape-prim ((obj collide-shape-prim))
  (add-debug-sphere
   #t
   (bucket-id debug-draw0)
   (the-as vector (-> obj prim-core))
   (-> obj local-sphere w)
   (new 'static 'rgba :r #xff :g #xff :b #xff :a #x40)
   )
  )

(defmethod
  debug-draw-world-sphere
  collide-shape-prim-sphere
  ((obj collide-shape-prim-sphere))
  (add-debug-sphere
   #t
   (bucket-id debug-draw0)
   (the-as vector (-> obj prim-core))
   (-> obj local-sphere w)
   (the-as rgba (cond
                 ((and
                   (zero? (-> obj prim-core collide-as))
                   (zero? (-> obj collide-with))
                   )
                  #x40808080
                  )
                 ((logtest? (-> obj prim-core action) 1)
                  #x4000ffff
                  )
                 (else
                  #x400080ff
                  )
                 )
    )
   )
  )

(defmethod
  debug-draw-world-sphere
  collide-shape-prim-mesh
  ((obj collide-shape-prim-mesh))
  (add-debug-sphere
   #t
   (bucket-id debug-draw0)
   (the-as vector (-> obj prim-core))
   (-> obj local-sphere w)
   (new 'static 'rgba :b #xff :a #x40)
   )
  )

(defmethod
  debug-draw-world-sphere
  collide-shape-prim-group
  ((obj collide-shape-prim-group))
  (add-debug-sphere
   #t
   (bucket-id debug-draw0)
   (the-as vector (-> obj prim-core))
   (-> obj local-sphere w)
   (new 'static 'rgba :g #xff :a #x10)
   )
  (countdown (s5-0 (-> obj num-prims))
   (debug-draw-world-sphere (-> obj prims s5-0))
   )
  #f
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod overlaps-others-test collide-shape-prim ((obj collide-shape-prim))
  (format
   0
   "ERROR: Unsupported call to collide-shape-prim::overlaps-others-test!~%"
   )
  #f
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod clear-collide-with-as collide-shape ((obj collide-shape))
  (set! (-> obj root-prim collide-with) (the-as uint 0))
  (set! (-> obj root-prim prim-core collide-as) (the-as uint 0))
  0
  (none)
  )

(defmethod backup-collide-with-as collide-shape ((obj collide-shape))
  (set! (-> obj backup-collide-with) (-> obj root-prim collide-with))
  (set! (-> obj backup-collide-as) (-> obj root-prim prim-core collide-as))
  0
  (none)
  )

(defmethod restore-collide-with-as collide-shape ((obj collide-shape))
  (set! (-> obj root-prim collide-with) (-> obj backup-collide-with))
  (set! (-> obj root-prim prim-core collide-as) (-> obj backup-collide-as))
  0
  (none)
  )

(defmethod
  dummy-53
  collide-shape
  ((obj collide-shape) (arg0 int) (arg1 int) (arg2 int))
  (let ((s3-0 (-> obj root-prim)))
   (if (logtest? (-> s3-0 prim-id) arg0)
    (set!
     (-> s3-0 prim-core collide-as)
     (logior (logclear (-> s3-0 prim-core collide-as) arg1) arg2)
     )
    )
   (let
    ((v1-7
      (if
       (and
        (nonzero? s3-0)
        (type-type? (-> s3-0 type) collide-shape-prim-group)
        )
       s3-0
       )
      )
     )
    (when v1-7
     (dotimes (a0-4 (-> (the-as collide-shape-prim-group v1-7) num-prims))
      (let
       ((a1-4
         (->
          (the-as collide-shape-prim-group (+ (* a0-4 4) (the-as int v1-7)))
          prims
          0
          )
         )
        )
       (if (logtest? (-> a1-4 prim-id) arg0)
        (set!
         (-> a1-4 prim-core collide-as)
         (logior (logclear (-> a1-4 prim-core collide-as) arg1) arg2)
         )
        )
       )
      )
     )
    )
   )
  0
  (none)
  )

(defmethod dummy-54 collide-shape ((obj collide-shape) (arg0 int) (arg1 int))
  (let ((s4-0 (-> obj root-prim)))
   (if (logtest? (-> s4-0 prim-id) arg0)
    (set! (-> s4-0 prim-core offense) arg1)
    )
   (let
    ((v1-5
      (if
       (and
        (nonzero? s4-0)
        (type-type? (-> s4-0 type) collide-shape-prim-group)
        )
       s4-0
       )
      )
     )
    (when v1-5
     (dotimes (a0-3 (-> (the-as collide-shape-prim-group v1-5) num-prims))
      (let
       ((a1-4
         (->
          (the-as collide-shape-prim-group (+ (* a0-3 4) (the-as int v1-5)))
          prims
          0
          )
         )
        )
       (if (logtest? (-> a1-4 prim-id) arg0)
        (set! (-> a1-4 prim-core offense) arg1)
        )
       )
      )
     )
    )
   )
  0
  (none)
  )

(defmethod
  dummy-55
  collide-shape
  ((obj collide-shape)
   (arg0 process)
   (arg1 touching-shapes-entry)
   (arg2 float)
   (arg3 float)
   (arg4 float)
   )
  (local-vars (sv-144 process))
  (with-pp
   (when arg1
    (let ((s1-0 (-> arg1 head)))
     (set! sv-144 arg0)
     (let
      ((s5-0
        (if
         (and (nonzero? sv-144) (type-type? (-> sv-144 type) process-drawable))
         sv-144
         )
        )
       )
      (when (and s1-0 s5-0)
       (let
        ((s0-1 (get-touched-prim s1-0 obj (the-as touching-prims-entry arg1))))
        (get-touched-prim
         s1-0
         (-> (the-as process-drawable s5-0) root)
         (the-as touching-prims-entry arg1)
         )
        (let* ((v1-8 (dummy-11 s1-0 (new 'stack-no-clear 'vector)))
               (s1-2
                (vector-!
                 (new 'stack-no-clear 'vector)
                 v1-8
                 (the-as vector (-> s0-1 prim-core))
                 )
                )
               )
         (vector-normalize! s1-2 1.0)
         (when (< arg2 (-> s1-2 y))
          (let ((s2-1 (new 'stack-no-clear 'vector)))
           (set!
            (-> s2-1 quad)
            (-> (the-as process-drawable s5-0) root transv quad)
            )
           (let
            ((f30-0
              (vector-xz-length (-> (the-as process-drawable s5-0) root transv))
              )
             )
            (if (= f30-0 0.0)
             (set!
              (-> s2-1 quad)
              (->
               (vector-z-quaternion!
                s2-1
                (-> (the-as process-drawable s5-0) root quat)
                )
               quad
               )
              )
             )
            (vector-xz-normalize! s2-1 (fmax f30-0 arg4))
            )
           (set! (-> s2-1 y) arg3)
           (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-8 from) pp)
            (set! (-> a1-8 num-params) 2)
            (set! (-> a1-8 message) 'shove)
            (set! (-> a1-8 param 0) (the-as uint arg1))
            (let ((v1-18 (new 'static 'attack-info :mask #x802)))
             (set! (-> v1-18 vector quad) (-> s2-1 quad))
             (set! (-> v1-18 angle) 'jump)
             (set! (-> a1-8 param 1) (the-as uint v1-18))
             )
            (send-event-function s5-0 a1-8)
            )
           )
          )
         )
        )
       )
      )
     )
    )
   (none)
   )
  )

(defmethod
  dummy-41
  collide-shape
  ((obj collide-shape) (arg0 attack-info) (arg1 float))
  (set! (-> arg0 shove-up) arg1)
  (let* ((s3-0 (-> obj process path))
         (s2-0 (-> s3-0 curve num-cverts))
         (s4-0 (target-pos 0))
         (s1-0 (new 'stack-no-clear 'vector))
         (s5-0 (new 'stack-no-clear 'vector))
         )
   (let ((f30-0 -1.0))
    (dotimes (s0-0 s2-0)
     (eval-path-curve-div! s3-0 s1-0 (the float s0-0) 'interp)
     (let ((f0-3 (vector-vector-distance-squared s4-0 s1-0)))
      (when (or (< f30-0 0.0) (< f0-3 f30-0))
       (set! f30-0 f0-3)
       (set! (-> s5-0 quad) (-> s1-0 quad))
       )
      )
     )
    )
   (vector-! (-> arg0 vector) s5-0 s4-0)
   )
  )




