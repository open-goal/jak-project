;;-*-Lisp-*-
(in-package goal)

;; name: collide-shape.gc
;; name in dgo: collide-shape
;; dgos: GAME, ENGINE

;; TODO - for misty-teetertotter | rigid-body
(define-extern default-collision-reaction (function collide-shape-moving collide-shape-intersect vector vector none)) ;; TODO - not completely confirmed

;; DECOMP BEGINS

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod should-push-away-test collide-shape-prim ()
  (format 0 "ERROR: collide-shape-prim::should-push-away-test was called illegally!~%")
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod collide-with-collide-cache-prim-mesh collide-shape-prim ((obj collide-shape-prim) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (format 0 "ERROR: Unsupported prim type in collide-shape-prim::collide-with-collide-cache-prim-mesh!~%")
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod collide-with-collide-cache-prim-mesh collide-shape-prim-mesh ((obj collide-shape-prim-mesh) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (format 0 "ERROR: collide-shape-prim-mesh vs. collide-cache-prim mesh is not currently supported!~%")
  (none)
  )

(defmethod collide-with-collide-cache-prim-mesh collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (let ((s3-0 (-> arg1 prim-core collide-as)))
    (dotimes (s2-0 (-> obj num-prims))
      (let ((a0-1 (-> obj prims s2-0)))
        (if (logtest? (-> a0-1 collide-with) s3-0)
            (collide-with-collide-cache-prim-mesh a0-1 arg0 arg1)
            )
        )
      )
    )
  (none)
  )

(defmethod collide-with-collide-cache-prim-sphere collide-shape-prim ((obj collide-shape-prim) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (format 0 "ERROR: Unsupported prim type in collide-shape-prim::collide-with-collide-cache-prim-sphere!~%")
  (none)
  )

(defmethod collide-with-collide-cache-prim-sphere collide-shape-prim-sphere ((obj collide-shape-prim-sphere) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (local-vars (v1-4 int) (a3-2 uint))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (let* ((s5-0 (new 'stack-no-clear 'collide-mesh-cache-tri))
           (f0-1 (dummy-10
                   arg1
                   s5-0
                   (-> obj prim-core)
                   (-> arg0 move-vec)
                   (-> arg0 best-u)
                   (the-as int (-> obj prim-core action))
                   )
                 )
           )
      (when (>= f0-1 0.0)
        (let ((v1-3 0)
              (a1-2 (-> obj prim-core action))
              )
          (nop!)
          (let ((a2-2 (-> arg1 prim-core action)))
            (nop!)
            (let ((a0-2 (-> arg1 prim-core offense))
                  (a1-3 (logand a1-2 a2-2))
                  (a2-3 (-> arg1 prim))
                  )
              (let ((a3-1 (logand a1-3 1))
                    (a1-4 (-> obj prim-core offense))
                    )
                (b! (zero? a3-1) cfg-5 :delay (set! a3-2 (-> s5-0 bbox4w max data 0)))
                (b! (= a0-2 v1-3) cfg-5 :delay (set! v1-4 (- a1-4 a0-2)))
                )
              (b! (> v1-4 0) cfg-5 :delay (.lvf vf1 (&-> s5-0 normal quad)))
              (.lvf vf2 (&-> s5-0 bbox4w min quad))
              (.lvf vf3 (&-> s5-0 vertex 0 quad))
              (.lvf vf4 (&-> s5-0 vertex 1 quad))
              (.lvf vf5 (&-> s5-0 vertex 2 quad))
              (set! (-> arg0 best-u) f0-1)
              (set! (-> arg0 best-to-prim) (the-as collide-shape-prim a2-3))
              (set! (-> arg0 best-from-prim) obj)
              (set! (-> arg0 best-tri pat) (the-as pat-surface a3-2))
              (.svf (&-> arg0 best-tri intersect quad) vf1)
              (.svf (&-> arg0 best-tri normal quad) vf2)
              (.svf (&-> arg0 best-tri vertex 0 quad) vf3)
              (.svf (&-> arg0 best-tri vertex 1 quad) vf4)
              (.svf (&-> arg0 best-tri vertex 2 quad) vf5)
              (label cfg-5)
              (dummy-9 *touching-list* obj (the-as collide-shape-prim a2-3) f0-1 (the-as collide-shape #f) s5-0)
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod collide-with-collide-cache-prim-sphere collide-shape-prim-mesh ((obj collide-shape-prim-mesh) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (format 0 "ERROR: collide-shape-prim-mesh vs. collide-cache-prim sphere is not currently supported!~%")
  (none)
  )

(defmethod collide-with-collide-cache-prim-sphere collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 collide-shape-intersect) (arg1 collide-cache-prim))
  (let ((s3-0 (-> arg1 prim-core collide-as)))
    (dotimes (s2-0 (-> obj num-prims))
      (let ((a0-1 (-> obj prims s2-0)))
        (if (logtest? (-> a0-1 collide-with) s3-0)
            (collide-with-collide-cache-prim-sphere a0-1 arg0 arg1)
            )
        )
      )
    )
  (none)
  )

(defun find-ground-point ((arg0 control-info) (arg1 vector) (arg2 float) (arg3 float))
  (local-vars (sv-176 int) (sv-192 int))
  (let ((f30-1 (if (< 819.2 (vector-xz-length (-> arg0 transv)))
                   (vector-y-angle (-> arg0 transv))
                   (y-angle arg0)
                   )
               )
        (s2-0 (-> arg0 trans))
        (s1-0 (new 'stack-no-clear 'vector))
        (s0-0 (new 'stack-no-clear 'collide-mesh-cache-tri))
        )
    (let ((a1-1 (new 'stack-no-clear 'bounding-box)))
      (set! (-> arg1 w) 0.0)
      (dotimes (v1-1 3)
        (set! (-> a1-1 min data v1-1) (- (-> s2-0 data v1-1) arg3))
        (set! (-> a1-1 max data v1-1) (+ (-> s2-0 data v1-1) arg3))
        )
      (set! (-> a1-1 min y) (+ -40960.0 (-> s2-0 y)))
      (set! (-> a1-1 max y) (+ 20480.0 (-> s2-0 y)))
      (dummy-13 *collide-cache* a1-1 (-> arg0 root-prim collide-with) (-> arg0 process) (the-as uint 1))
      )
    (set! sv-176 0)
    (while (< sv-176 8)
      (let ((f28-0 (+ f30-1 (if (zero? (logand sv-176 1))
                                (* 8192.0 (the float (/ sv-176 2)))
                                (* -8192.0 (the float (/ sv-176 2)))
                                )
                      )
                   )
            )
        (set! sv-192 0)
        (let ((f26-0 arg3))
          (set-vector! s1-0 0.0 0.0 arg3 1.0)
          (vector-rotate-y! s1-0 s1-0 f28-0)
          (if (>= (dummy-18
                        *collide-cache*
                        (vector+! (new 'stack-no-clear 'vector) s2-0 (new 'static 'vector :y 20480.0 :w 1.0))
                        s1-0
                        2048.0
                        (the-as int (-> arg0 root-prim collide-with))
                        s0-0
                        1
                        )
                    0.0
                    )
              (set! f26-0 (+ -6144.0 (vector-vector-xz-distance s2-0 (-> s0-0 normal))))
              )
          (let ((f24-0 arg2))
            (while (>= f26-0 f24-0)
              (set-vector! s1-0 0.0 0.0 f24-0 1.0)
              (vector-rotate-y! s1-0 s1-0 f28-0)
              (vector+! s1-0 s2-0 s1-0)
              (set! (-> s1-0 y) (+ 20480.0 (-> s2-0 y)))
              (when (>= (dummy-18
                            *collide-cache*
                            s1-0
                            (new 'static 'vector :y -251658240.0 :w 1.0)
                            10240.0
                            (the-as int (-> arg0 root-prim collide-with))
                            s0-0
                            1
                            )
                        0.0
                        )
                (cond
                  ((and
                     (zero? (shr (shl (-> s0-0 bbox4w max data 0) 58) 61))
                     (zero? (shr (shl (-> s0-0 bbox4w max data 0) 44) 58))
                     (< 0.7 (the-as float (-> s0-0 bbox4w min data 1)))
                     )
                   (set! (-> arg1 quad) (-> s0-0 normal quad))
                   (set! sv-192 (+ sv-192 1))
                   (if (>= sv-192 2)
                       (return arg1)
                       )
                   )
                  ((and (= (shr (shl (-> s0-0 bbox4w max data 0) 58) 61) 1) (< (+ 4096.0 (-> s2-0 y)) (-> s0-0 normal y)))
                   (goto cfg-35)
                   )
                  )
                )
              (set! f24-0 (+ 4096.0 f24-0))
              )
            )
          )
        )
      (label cfg-35)
      (set! sv-176 (+ sv-176 1))
      )
    )
  (the-as vector #f)
  )

(defun target-attack-up ((arg0 target) (arg1 symbol) (arg2 symbol))
  (with-pp
    (let ((s4-0 (find-ground-point (-> arg0 control) (new 'stack-no-clear 'vector) 8192.0 40960.0)))
      (set! s4-0 (cond
                   (s4-0
                     (empty)
                     s4-0
                     )
                   (else
                     (-> arg0 control unknown-vector54)
                     )
                   )
            )
      (let* ((s2-1 (vector-! (new 'stack-no-clear 'vector) s4-0 (-> arg0 control trans)))
             (f30-1 (fmax 8192.0 (fmin 40960.0 (vector-xz-length s2-1))))
             )
        (cond
          ((< (fabs (vector-dot
                       (-> arg0 control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) s4-0 (-> arg0 control trans))
                       )
                     )
              40960.0
              )
           (vector-xz-normalize! s2-1 f30-1)
           (let ((s1-0 (new 'stack-no-clear 'event-message-block)))
             (set! (-> s1-0 from) pp)
             (set! (-> s1-0 num-params) 2)
             (set! (-> s1-0 message) arg1)
             (set! (-> s1-0 param 0) (the-as uint #f))
             (let ((s3-1 (new 'static 'attack-info :mask #x8a2)))
               (set! (-> s3-1 mode) arg2)
               (set! (-> s3-1 vector quad) (-> s2-1 quad))
               (set! (-> s3-1 shove-up)
                     (+ (lerp-scale 4096.0 16384.0 f30-1 4096.0 40960.0) (fmax 0.0 (- (-> s4-0 y) (-> arg0 control trans y))))
                     )
               (set! (-> s3-1 angle) 'up)
               (set! (-> s1-0 param 1) (the-as uint s3-1))
               )
             (send-event-function arg0 s1-0)
             )
           )
          (else
            (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-6 from) pp)
              (set! (-> a1-6 num-params) 2)
              (set! (-> a1-6 message) arg1)
              (set! (-> a1-6 param 0) (the-as uint #f))
              (let ((v1-12 (new 'static 'attack-info :mask #xca2)))
                (set! (-> v1-12 mode) arg2)
                (set! (-> v1-12 vector quad)
                      (-> (new 'static 'attack-info :trans (new 'static 'vector :y 40960.0 :w 1.0) :speed (the-as float #x1))
                          trans
                          quad
                          )
                      )
                (set! (-> v1-12 shove-up) 40960.0)
                (set! (-> v1-12 angle) 'up)
                (set! (-> v1-12 control) 1.0)
                (set! (-> a1-6 param 1) (the-as uint v1-12))
                )
              (send-event-function arg0 a1-6)
              )
            )
          )
        )
      )
    (none)
    )
  )

(defmethod dummy-56 collide-shape-moving ((obj collide-shape-moving) (arg0 pat-surface))
  (with-pp
    (set! (-> obj cur-pat) arg0)
    (set! (-> obj poly-pat) arg0)
    (case (-> arg0 material)
      (((pat-material ice))
       (set! (-> obj surf) *ice-surface*)
       )
      (((pat-material quicksand))
       (set! (-> obj surf) *quicksand-surface*)
       )
      (((pat-material tube))
       (set! (-> obj surf) *no-walk-surface*)
       )
      (((pat-material rotate))
       (set! (-> obj surf) *rotate-surface*)
       )
      (else
        (set! (-> obj surf) *standard-ground-surface*)
        )
      )
    (if (logtest? (-> obj root-prim prim-core action) 512)
        (set! (-> obj surf) *race-track-surface*)
        )
    (when (nonzero? (-> arg0 event))
      (case (-> arg0 event)
        (((pat-event deadly))
         (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-3 from) pp)
           (set! (-> a1-3 num-params) 2)
           (set! (-> a1-3 message) 'attack)
           (set! (-> a1-3 param 0) (the-as uint #f))
           (let ((v1-19 (new 'static 'attack-info :mask #xa0)))
             (set! (-> v1-19 mode) 'deadly)
             (set! (-> v1-19 shove-up) 12288.0)
             (set! (-> a1-3 param 1) (the-as uint v1-19))
             )
           (send-event-function (-> obj process) a1-3)
           )
         )
        (((pat-event burn))
         (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-6 from) pp)
           (set! (-> a1-6 num-params) 2)
           (set! (-> a1-6 message) 'attack)
           (set! (-> a1-6 param 0) (the-as uint #f))
           (let ((v1-23 (new 'static 'attack-info :mask #xa0)))
             (set! (-> v1-23 mode) 'burn)
             (set! (-> v1-23 shove-up) 12288.0)
             (set! (-> a1-6 param 1) (the-as uint v1-23))
             )
           (send-event-function (-> obj process) a1-6)
           )
         )
        (((pat-event deadlyup))
         (target-attack-up (the-as target (-> obj process)) 'attack-or-shove 'deadlyup)
         )
        (((pat-event burnup))
         (if (zero? (logand (-> (the-as target (-> obj process)) control root-prim prim-core action) 512))
             (target-attack-up (the-as target (-> obj process)) 'attack-or-shove 'burnup)
             )
         )
        (((pat-event melt))
         (let ((a1-15 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-15 from) pp)
           (set! (-> a1-15 num-params) 2)
           (set! (-> a1-15 message) 'attack-invinc)
           (set! (-> a1-15 param 0) (the-as uint #f))
           (let ((a2-8 (new 'static 'attack-info :mask #x20)))
             (set! (-> a2-8 mode) 'melt)
             (set! (-> a1-15 param 1) (the-as uint a2-8))
             )
           (send-event-function (-> obj process) a1-15)
           )
         )
        (((pat-event endlessfall))
         (let ((a1-17 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-17 from) pp)
           (set! (-> a1-17 num-params) 2)
           (set! (-> a1-17 message) 'attack-invinc)
           (set! (-> a1-17 param 0) (the-as uint #f))
           (let ((a2-9 (new 'static 'attack-info :mask #x20)))
             (set! (-> a2-9 mode) 'endlessfall)
             (set! (-> a1-17 param 1) (the-as uint a2-9))
             )
           (send-event-function (-> obj process) a1-17)
           )
         )
        )
      )
    0
    (none)
    )
  )

(defun default-collision-reaction ((arg0 collide-shape-moving) (arg1 collide-shape-intersect) (arg2 vector) (arg3 vector))
  (local-vars (sv-64 vector) (sv-68 vector) (sv-72 vector) (sv-80 int) (sv-128 symbol))
  (set! sv-64 (new-stack-vector0))
  (set! sv-68 (new-stack-vector0))
  (set! sv-72 (new 'stack-no-clear 'vector))
  (set! sv-80 0)
  (set! (-> sv-72 quad) (-> arg3 quad))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-1 (-> arg1 move-vec) (-> arg1 best-u))
    (TODO-RENAME-28 arg0 a1-1)
    )
  (dummy-56 arg0 (-> arg1 best-tri pat))
  (vector-! sv-64 (the-as vector (-> arg1 best-from-prim prim-core)) (-> arg1 best-tri intersect))
  (set! (-> sv-64 w) 1.0)
  (vector-normalize! sv-64 1.0)
  (set! (-> arg0 coverage) (vector-dot sv-64 (-> arg1 best-tri normal)))
  (let ((v1-16 (-> sv-64 quad)))
    (set! (-> sv-68 quad) v1-16)
    )
  (if (= (-> arg1 best-u) 0.0)
      (TODO-RENAME-28 arg0 sv-68)
      )
  (set! (-> arg0 surface-normal quad) (-> sv-68 quad))
  (set! (-> arg0 poly-normal quad) (-> arg1 best-tri normal quad))
  (set! (-> arg0 surface-angle) (vector-dot sv-68 (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 poly-angle) (vector-dot (-> arg0 poly-normal) (-> arg0 dynam gravity-normal)))
  (set! (-> arg0 touch-angle)
        (vector-dot sv-68 (vector-normalize! (vector-negate! (new-stack-vector0) sv-72) 1.0))
        )
  (if (< (-> arg0 poly-angle) -0.2)
      (set! sv-80 (logior sv-80 16))
      )
  (set! sv-128 (< (fabs (-> arg0 surface-angle)) (-> *pat-mode-info* (-> arg0 cur-pat mode) wall-angle)))
  (when (zero? (logand (-> arg0 prev-status) 1))
    (set! (-> arg0 ground-impact-vel) (- (vector-dot (-> arg0 transv) (-> arg0 dynam gravity-normal))))
    (when (not sv-128)
      (let ((f30-0 (- 1.0 (-> arg0 surf impact-fric))))
        (when (< f30-0 1.0)
          (let ((s3-1 (new-stack-vector0))
                (f28-0 (vector-dot (-> arg0 dynam gravity-normal) sv-72))
                )
            0.0
            (vector-! s3-1 sv-72 (vector-float*! s3-1 (-> arg0 dynam gravity-normal) f28-0))
            (let* ((f0-22 (vector-length s3-1))
                   (f1-4 f0-22)
                   )
              (if (< f28-0 0.0)
                  (set! f28-0 (* f28-0 f30-0))
                  )
              (vector+!
                sv-72
                (vector-float*! sv-72 (-> arg0 dynam gravity-normal) f28-0)
                (vector-float*! s3-1 s3-1 (/ f0-22 f1-4))
                )
              )
            )
          )
        )
      )
    )
  (set! sv-80 (logior sv-80 4))
  (if (-> arg1 best-to-prim)
      (set! sv-80 (logior sv-80 32))
      )
  (cond
    (sv-128
      (set! sv-80 (logior sv-80 8))
      (set! (-> arg0 cur-pat mode) 1)
      )
    (else
      (set! sv-80 (logior sv-80 1))
      (set! (-> arg0 local-normal quad) (-> sv-68 quad))
      )
    )
  (vector-reflect-flat! arg2 sv-72 sv-68)
  (when (and (not sv-128) (>= (-> arg0 coverage) 0.9))
    (set! sv-80 (logior sv-80 2))
    (set! (-> arg0 ground-poly-normal quad) (-> arg0 poly-normal quad))
    (when (!= (-> arg0 poly-pat mode) (pat-mode wall))
      (set! (-> arg0 ground-pat) (-> arg0 poly-pat))
      (set! (-> arg0 ground-touch-point quad) (-> arg1 best-tri intersect quad))
      )
    )
  (logior! (-> arg0 status) sv-80)
  sv-80
  (none)
  )

(defun simple-collision-reaction ((arg0 collide-shape-moving) (arg1 collide-shape-intersect))
  (let ((s5-0 0))
    (let ((a1-1 (new 'stack-no-clear 'vector)))
      (vector-float*! a1-1 (-> arg1 move-vec) (-> arg1 best-u))
      (TODO-RENAME-28 arg0 a1-1)
      )
    (let ((f0-2 (vector-dot (-> arg0 transv) (-> arg1 best-tri normal)))
          (v1-6 (new 'stack-no-clear 'vector))
          )
      (vector-float*! v1-6 (-> arg1 best-tri normal) (* 1.5 f0-2))
      (vector-! (-> arg0 transv) (-> arg0 transv) v1-6)
      )
    (let ((v0-1 (logior s5-0 7)))
      (logior! (-> arg0 status) v0-1)
      )
    )
  (none)
  )

(defmethod dummy-63 collide-shape-moving ((obj collide-shape-moving) (arg0 vector) (arg1 vector) (arg2 float))
  (local-vars (sv-192 int))
  (let ((s5-0 (new 'stack 'collide-shape-intersect))
        (s2-0 (new 'stack-no-clear 'vector))
        )
    (vector-float*! s2-0 arg1 (* arg2 (-> *display* seconds-per-frame)))
    (init! s5-0 s2-0)
    (let* ((s1-1 (-> obj root-prim))
           (v1-4 *collide-cache*)
           (s0-0 (the-as collide-cache-prim (-> v1-4 prims)))
           )
      (set! sv-192 (-> v1-4 num-prims))
      (while (nonzero? sv-192)
        (set! sv-192 (+ sv-192 -1))
        (when (logtest? (-> s1-1 collide-with) (-> s0-0 prim-core collide-as))
          (if (>= (-> s0-0 prim-core prim-type) 0)
              (collide-with-collide-cache-prim-mesh s1-1 s5-0 s0-0)
              (collide-with-collide-cache-prim-sphere s1-1 s5-0 s0-0)
              )
          )
        (set! s0-0 (-> (the-as (inline-array collide-cache-prim) s0-0) 1))
        )
      )
    (let ((f30-0 (-> s5-0 best-u)))
      (cond
        ((>= f30-0 0.0)
         (let ((s2-1 (new 'stack-no-clear 'vector)))
           (if *display-collision-marks*
               (set! (-> s2-1 quad) (-> arg1 quad))
               )
           (set! (-> obj prev-status) (the-as uint ((-> obj reaction) obj s5-0 arg0 arg1)))
           (when *display-collision-marks*
             (let ((t1-0 (-> *pat-mode-info* (-> s5-0 best-tri pat mode) hilite-color)))
               (add-debug-outline-triangle
                 #t
                 (bucket-id debug-draw1)
                 (the-as vector (-> s5-0 best-tri))
                 (-> s5-0 best-tri vertex 1)
                 (-> s5-0 best-tri vertex 2)
                 t1-0
                 )
               )
             (add-debug-vector
               #t
               (bucket-id debug-draw1)
               (-> s5-0 best-tri intersect)
               s2-1
               (meters 0.00007324219)
               (new 'static 'rgba :r #xff :g #xa0 :a #x80)
               )
             (add-debug-vector
               #t
               (bucket-id debug-draw1)
               (-> s5-0 best-tri intersect)
               arg0
               (meters 0.00007324219)
               (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
               )
             (if (= (-> obj process type) target)
                 (add-debug-vector
                   #t
                   (bucket-id debug-draw1)
                   (-> s5-0 best-tri intersect)
                   (-> obj surface-normal)
                   (meters 0.5)
                   (-> *pat-mode-info* (-> obj cur-pat mode) hilite-color)
                   )
                 )
             )
           )
         (return f30-0)
         )
        (else
          (set! (-> obj reaction-flag) (the-as uint 0))
          ((-> obj no-reaction) obj s5-0 arg0 arg1)
          (set! (-> obj prev-status) (the-as uint 0))
          (TODO-RENAME-28 obj s2-0)
          (set! (-> arg0 quad) (-> arg1 quad))
          (return 1.0)
          )
        )
      )
    )
  (the-as none 0)
  (the-as float 1.0)
  )

(defmethod dummy-37 collide-shape ((obj collide-shape) (arg0 vector))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((t9-0 (method-of-object obj TODO-RENAME-28))
          (v1-1 (new 'stack-no-clear 'vector))
          )
      (.lvf vf1 (&-> arg0 quad))
      (let ((f0-0 (-> *display* seconds-per-frame)))
        (.mov at-0 f0-0)
        )
      (.mov vf2 at-0)
      (.mov.vf vf1 vf0 :mask #b1000)
      (.mul.x.vf vf1 vf1 vf2 :mask #b111)
      (.svf (&-> v1-1 quad) vf1)
      (t9-0 obj v1-1)
      )
    (none)
    )
  )

(defmethod dummy-37 collide-shape-moving ((obj collide-shape-moving) (arg0 vector))
  (dummy-47 obj)
  (set! (-> obj trans-old 2 quad) (-> obj trans-old 1 quad))
  (set! (-> obj trans-old 1 quad) (-> obj trans-old 0 quad))
  (set! (-> obj trans-old 0 quad) (-> obj trans quad))
  (set! (-> obj prev-status) (-> obj status))
  (set! (-> obj status) (logand -16128 (-> obj status)))
  (set! (-> obj local-normal quad) (-> obj dynam gravity-normal quad))
  (set! (-> obj surface-normal quad) (-> obj dynam gravity-normal quad))
  (set! (-> obj poly-normal quad) (-> obj dynam gravity-normal quad))
  (set! (-> obj coverage) 0.0)
  (set! (-> obj touch-angle) 0.0)
  (let ((f30-0 1.0)
        (s4-0 0)
        )
    (while (and (< 0.05 f30-0) (and
                                 (< s4-0 (the-as int (-> obj max-iteration-count)))
                                 (not (and (= (-> arg0 x) 0.0) (= (-> arg0 y) 0.0) (= (-> arg0 z) 0.0)))
                                 )
                )
      (let ((f28-0 (dummy-63 obj arg0 arg0 f30-0)))
        (dummy-11 *touching-list* f28-0)
        (set! f30-0 (- f30-0 (* f28-0 f30-0)))
        )
      (+! s4-0 1)
      )
    )
  0
  (none)
  )

(defmethod dummy-37 control-info ((obj control-info) (arg0 vector))
  (stopwatch-start (-> *collide-stats* total-target))
  (when (< 1638400.0 (vector-length arg0))
    (format 0 "WARNING: target vel is ~M m/s, reseting to zero.~%" (vector-length arg0))
    (vector-reset! arg0)
    )
  (set! (-> obj unknown-vector15 quad) (-> obj unknown-vector14 quad))
  (vector-matrix*! (-> obj unknown-vector14) (-> obj unknown-vector13) (-> obj unknown-matrix02))
  (vector-! (-> obj unknown-vector16) (-> obj unknown-vector14) (-> obj unknown-vector15))
  (let ((a1-6 (vector-! (new 'stack-no-clear 'vector) (-> obj unknown-vector11) (-> obj unknown-vector14))))
    (vector-seek! (-> obj unknown-vector12) a1-6 (* 16384.0 (-> *display* seconds-per-frame)))
    )
  (let ((s3-1 (vector+float*! (new-stack-vector0) arg0 (-> obj unknown-vector16) 60.0))
        (s4-1 (new 'stack-no-clear 'vector))
        )
    (set! (-> s4-1 quad) (-> arg0 quad))
    (let ((t9-7 (method-of-type collide-shape-moving dummy-37)))
      (t9-7 obj s3-1)
      )
    (let ((s1-0 (new-stack-vector0)))
      (set! (-> s1-0 quad) (-> s4-1 quad))
      (let ((s2-1 (new-stack-vector0)))
        (set! (-> s2-1 quad) (-> s3-1 quad))
        (let ((s0-0 (new-stack-vector0)))
          (let ((f0-4 (vector-dot (-> obj dynam gravity-normal) s1-0)))
            0.0
            (vector-! s0-0 s1-0 (vector-float*! s0-0 (-> obj dynam gravity-normal) f0-4))
            )
          (let* ((f0-5 (vector-length s0-0))
                 (f1-2 f0-5)
                 (f2-0 0.0)
                 )
            (vector+!
              s1-0
              (vector-float*! s1-0 (-> obj dynam gravity-normal) f2-0)
              (vector-float*! s0-0 s0-0 (/ f0-5 f1-2))
              )
            )
          )
        (let ((s0-1 (new-stack-vector0)))
          (let ((f0-8 (vector-dot (-> obj dynam gravity-normal) s2-1)))
            0.0
            (vector-! s0-1 s2-1 (vector-float*! s0-1 (-> obj dynam gravity-normal) f0-8))
            )
          (let* ((f0-9 (vector-length s0-1))
                 (f1-4 f0-9)
                 (f2-1 0.0)
                 )
            (vector+!
              s2-1
              (vector-float*! s2-1 (-> obj dynam gravity-normal) f2-1)
              (vector-float*! s0-1 s0-1 (/ f0-9 f1-4))
              )
            )
          )
        (vector-normalize! s1-0 1.0)
        (vector-normalize! s2-1 1.0)
        (let ((f30-1 (vector-dot s1-0 s2-1)))
          (cond
            ((and (!= (vector-length (-> obj unknown-vector01)) 0.0) (if (logtest? (-> obj status) 8)
                                                                         (< f30-1 0.9999)
                                                                         (< f30-1 0.95)
                                                                         )
                  )
             (set! (-> obj unknown-float70) (seek (-> obj unknown-float70) 1.0 (* 4.0 (-> *display* seconds-per-frame))))
             (set! (-> obj unknown-float71) (seek
                                              (-> obj unknown-float71)
                                              (if (= (-> obj unknown-surface00 mode) 'air)
                                                  1.0
                                                  0.0
                                                  )
                                              (* 4.0 (-> *display* seconds-per-frame))
                                              )
                   )
             (logior! (-> obj status) 512)
             )
            (else
              (set! (-> obj unknown-float70) (seek (-> obj unknown-float70) 0.0 (* 2.0 (-> *display* seconds-per-frame))))
              (set! (-> obj unknown-float71) (seek (-> obj unknown-float71) 0.0 (* 2.0 (-> *display* seconds-per-frame))))
              )
            )
          )
        )
      )
    (if (logtest? (-> obj status) 1)
        (set! (-> arg0 quad) (-> s3-1 quad))
        (vector--float*! arg0 s3-1 (-> obj unknown-vector16) 60.0)
        )
    (if (and
            (logtest? (-> obj status) 1)
            (and (zero? (logand (-> obj status) 520)) (< (vector-length (-> obj unknown-vector61)) (vector-length s4-1)))
            )
        (set! (-> obj unknown-vector61 quad) (-> s4-1 quad))
        )
    )
  (let ((s5-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> obj unknown-vector120) 1.0))
        (f0-32 (vector-length (-> obj unknown-vector120)))
        )
    (set! (-> obj unknown-float140) (if (= f0-32 0.0)
                                        0.0
                                        (fmax 0.0 (/ (vector-dot (-> obj transv) s5-1) f0-32))
                                        )
          )
    )
  (stopwatch-stop (-> *collide-stats* total-target))
  0
  (none)
  )

(defmethod TODO-RENAME-61 collide-shape-moving ((obj collide-shape-moving) (arg0 vector) (arg1 vector) (arg2 vector))
  (TODO-RENAME-30 obj arg0)
  (set! (-> arg1 y) 0.0)
  (logior! (-> obj status) 7)
  (set! (-> obj poly-normal quad) (-> arg2 quad))
  (set! (-> obj surface-normal quad) (-> arg2 quad))
  (set! (-> obj local-normal quad) (-> arg2 quad))
  (set! (-> obj ground-poly-normal quad) (-> arg2 quad))
  (set! (-> obj ground-impact-vel) (- (vector-dot arg1 (-> obj dynam gravity-normal))))
  (set! (-> obj ground-touch-point quad) (-> arg0 quad))
  0
  (none)
  )

(defmethod dummy-57 collide-shape-moving ((obj collide-shape-moving) (arg0 vector))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (dummy-47 obj)
    (set! (-> obj trans-old 2 quad) (-> obj trans-old 1 quad))
    (set! (-> obj trans-old 1 quad) (-> obj trans-old 0 quad))
    (set! (-> obj trans-old 0 quad) (-> obj trans quad))
    (set! (-> obj prev-status) (-> obj status))
    (set! (-> obj status) (logand -16128 (-> obj status)))
    (set! (-> obj local-normal quad) (-> obj dynam gravity-normal quad))
    (set! (-> obj surface-normal quad) (-> obj dynam gravity-normal quad))
    (set! (-> obj poly-normal quad) (-> obj dynam gravity-normal quad))
    (set! (-> obj coverage) 0.0)
    (set! (-> obj touch-angle) 0.0)
    (let* ((a0-12 obj)
           (t9-1 (method-of-object a0-12 TODO-RENAME-28))
           (a1-1 (new 'stack-no-clear 'vector))
           )
      (.lvf vf1 (&-> arg0 quad))
      (let ((f0-2 (-> *display* seconds-per-frame)))
        (.mov at-0 f0-2)
        )
      (.mov vf2 at-0)
      (.mov.vf vf1 vf0 :mask #b1000)
      (.mul.x.vf vf1 vf1 vf2 :mask #b111)
      (.svf (&-> a1-1 quad) vf1)
      (t9-1 a0-12 a1-1)
      )
    (set! (-> obj shadow-pos quad) (-> obj trans quad))
    0
    (none)
    )
  )

(defmethod dummy-58 collide-shape-moving ((obj collide-shape-moving) (arg0 vector))
  (dummy-57 obj arg0)
  (let ((a1-1 (new 'stack-no-clear 'touching-shapes-entry)))
    (set! (-> a1-1 cshape1) (the-as collide-shape 1))
    (set! (-> a1-1 cshape2) (the-as collide-shape *touching-list*))
    (when (dummy-40 obj a1-1)
      (TODO-RENAME-30 obj (the-as vector (-> obj trans-old)))
      (return #t)
      )
    )
  #f
  )

(defmethod dummy-64 collide-shape-moving ((obj collide-shape-moving) (arg0 collide-tri-result) (arg1 vector))
  (TODO-RENAME-30 obj arg1)
  (logior! (-> obj status) 7)
  (let ((v1-4 (-> arg0 normal)))
    (set! (-> obj poly-normal quad) (-> v1-4 quad))
    (set! (-> obj surface-normal quad) (-> v1-4 quad))
    (set! (-> obj local-normal quad) (-> v1-4 quad))
    (set! (-> obj ground-poly-normal quad) (-> v1-4 quad))
    )
  (set! (-> obj poly-pat) (-> arg0 pat))
  (set! (-> obj cur-pat) (-> arg0 pat))
  (set! (-> obj ground-pat) (-> arg0 pat))
  (set! (-> obj ground-touch-point quad) (-> arg1 quad))
  0
  (none)
  )

;; WARN: Stack slot offset 128 signed mismatch
(defmethod dummy-59 collide-shape-moving ((obj collide-shape-moving) (arg0 vector) (arg1 uint) (arg2 float) (arg3 symbol) (arg4 symbol) (arg5 symbol))
  (local-vars (sv-128 float) (sv-144 collide-tri-result))
  (set! sv-128 arg2)
  (let ((s5-0 arg3))
    (let ((s3-0 arg4)
          (s1-0 arg5)
          )
      (if *debug-segment*
          (add-frame
            (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
            'draw
            (new 'static 'rgba :r #x40 :b #x40 :a #x80)
            )
          )
      (dummy-57 obj arg0)
      (let ((s0-0 (-> obj shadow-pos)))
        (set! (-> s0-0 quad) (-> obj trans quad))
        (set! sv-144 (new 'stack-no-clear 'collide-tri-result))
        (+! (-> s0-0 y) sv-128)
        0.0
        (let ((f0-4 (if s1-0
                        (misty-ambush-height-probe s0-0 81920.0)
                        (dummy-10
                          *collide-cache*
                          s0-0
                          (new 'static 'vector :y -81920.0 :w 1.0)
                          40.96
                          (the-as int arg1)
                          (-> obj process)
                          sv-144
                          1
                          )
                        )
                    )
              )
          (cond
            ((>= f0-4 0.0)
             (let ((a2-3 (new 'static 'vector :y -81920.0 :w 1.0)))
               (vector+float*! s0-0 s0-0 a2-3 f0-4)
               )
             (when (>= (-> s0-0 y) (-> obj trans y))
               (dummy-64 obj sv-144 s0-0)
               (set! (-> obj ground-impact-vel) (- (vector-dot arg0 (-> obj dynam gravity-normal))))
               (set! (-> arg0 y) 0.0)
               )
             )
            (s3-0
              (set! (-> obj trans y) (-> obj trans-old 0 y))
              )
            )
          )
        )
      )
    (when (logtest? (-> obj root-prim collide-with) 30)
      (let ((a1-7 (new 'stack-no-clear 'touching-shapes-entry)))
        (set! (-> a1-7 cshape1) (the-as collide-shape 1))
        (set! (-> a1-7 cshape2) (the-as collide-shape *touching-list*))
        (when (dummy-40 obj a1-7)
          (if s5-0
              (TODO-RENAME-30 obj (the-as vector (-> obj trans-old)))
              )
          )
        )
      )
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :g #xff :a #x80)
        )
      )
  0
  (none)
  )

(defmethod dummy-60 collide-shape-moving ((obj collide-shape-moving) (arg0 float) (arg1 float) (arg2 symbol) (arg3 uint))
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #x40 :b #x40 :a #x80)
        )
      )
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'collide-tri-result))
        )
    (let ((f30-0 (+ arg0 arg1)))
      (set! (-> s4-0 quad) (-> obj trans quad))
      (+! (-> s4-0 y) arg0)
      0.0
      (let ((f0-4 (fill-and-probe-using-y-probe *collide-cache* s4-0 f30-0 arg3 (-> obj process) s3-0 (the-as uint 1))))
        (when (< f0-4 0.0)
          (if arg2
              (format
                0
                "WARNING: move-to-ground: (~f ~f) failed to locate ground [~S type ~S]~%"
                (* 0.00024414062 (-> s4-0 y))
                (* 0.00024414062 f30-0)
                (-> obj process name)
                (-> obj process type symbol)
                )
              )
          (return #f)
          )
        (set! (-> s4-0 y) (- (-> s4-0 y) (* f0-4 f30-0)))
        )
      )
    (set! (-> obj shadow-pos quad) (-> s4-0 quad))
    (dummy-64 obj s3-0 s4-0)
    )
  (if *debug-segment*
      (add-frame
        (-> *display* frames (-> *display* on-screen) frame profile-bar 0)
        'draw
        (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
        )
      )
  #t
  )

(defmethod dummy-62 collide-shape-moving ((obj collide-shape-moving) (arg0 vector) (arg1 float))
  (let* ((s4-0 (vector-negate! (new-stack-vector0) (-> obj dynam gravity)))
         (a2-1 (-> obj local-normal))
         (a2-2 (vector-reflect-flat! (new-stack-vector0) s4-0 a2-1))
         )
    (vector--float*! arg0 s4-0 a2-2 (cond
                                      ((logtest? (-> obj status) 1)
                                       (empty)
                                       arg1
                                       )
                                      (else
                                        0.0
                                        )
                                      )
                     )
    )
  arg0
  )

(defmethod dummy-33 collide-shape ((obj collide-shape) (arg0 vector) (arg1 uint))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a0-1 (new 'stack-no-clear 'vector)))
      (let ((v1-0 a0-1))
        (.lvf vf1 (&-> arg0 quad))
        (let ((f0-0 (-> *display* seconds-per-frame)))
          (.mov at-0 f0-0)
          )
        (.mov vf2 at-0)
        (.mov.vf vf1 vf0 :mask #b1000)
        (.mul.x.vf vf1 vf1 vf2 :mask #b111)
        (.svf (&-> v1-0 quad) vf1)
        )
      (let ((f0-2 (+ (vector-length a0-1) (if (= (-> obj process type) target)
                                              4096.0
                                              0.0
                                              )
                     )
                  )
            )
        (dummy-32 obj f0-2 arg1)
        )
      )
    (dummy-37 obj arg0)
    (none)
    )
  )

(defmethod dummy-32 collide-shape ((obj collide-shape) (arg0 object) (arg1 uint))
  (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
    (cond
      ((dummy-36 obj s5-0 (the-as float arg0) arg1)
       (dummy-13 *collide-cache* s5-0 arg1 (-> obj process) (the-as uint (-> obj pat-ignore-mask)))
       (if (and *display-collide-cache* (= (-> obj process type) target))
           (dummy-9 *collide-cache*)
           )
       )
      (else
        (initialize *collide-cache*)
        )
      )
    )
  (none)
  )

(defmethod dummy-36 collide-shape ((obj collide-shape) (arg0 bounding-box) (arg1 float) (arg2 uint))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 (new 'static 'vector :x 4.096))
          (a0-1 (-> obj root-prim))
          )
      (cond
        ((logtest? (-> a0-1 collide-with) arg2)
         (.mov vf31 arg1)
         (.lvf vf1 (&-> v1-0 quad))
         (.add.x.vf vf31 vf31 vf1 :mask #b1)
         (cond
           ((dummy-20 a0-1 arg2)
            (.mov.vf vf29 vf0 :mask #b1000)
            (.mov.vf vf30 vf0 :mask #b1000)
            (.svf (&-> arg0 min quad) vf29)
            (.svf (&-> arg0 max quad) vf30)
            (return #t)
            )
           (else
             (return #f)
             )
           )
         (the-as none 0)
         )
        (else
          (return #f)
          )
        )
      )
    (the-as symbol 0)
    )
  )

;; WARN: Bad vector register dependency: vf31
(defmethod dummy-20 collide-shape-prim ((obj collide-shape-prim) (arg0 uint))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf29 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         )
    (.lvf vf1 (&-> obj prim-core world-sphere quad))
    (.add.w.vf vf2 vf31 vf1 :mask #b1)
    (.add.x.vf vf30 vf1 vf2 :mask #b111)
    (.sub.x.vf vf29 vf1 vf2 :mask #b111)
    #t
    )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; WARN: Bad vector register dependency: vf29
;; WARN: Bad vector register dependency: vf30
;; WARN: Bad vector register dependency: vf31
;; WARN: Expression building failed: In (method 29 collide-shape-prim-group): Could not match ArrayFieldAccess (stride power of 2) values: (+ v1-0 (the-as int obj))
; (defmethod dummy-29 collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 uint))
;   (local-vars
;     (v0-0 none)
;     (v0-1 int)
;     (v1-0 int)
;     (v1-1 int)
;     (v1-2 uint)
;     (v1-3 uint)
;     (v1-5 type)
;     (v1-6 type)
;     (v1-8 float)
;     (a0-1 collide-shape-prim)
;     (a1-1 type)
;     (a1-2 uint)
;     (s3-0 int)
;     (s4-0 int)
;     (t9-0 (function collide-shape-prim-group uint none))
;     )
;   (rlet ((vf1 :class vf)
;          (vf2 :class vf)
;          (vf29 :class vf)
;          (vf3 :class vf)
;          (vf30 :class vf)
;          (vf31 :class vf)
;          (vf4 :class vf)
;          )
;     (set! s4-0 (-> obj num-prims))
;     (set! s3-0 0)
;     (label cfg-1)
;     ((b! (= s3-0 s4-0) L214 (set! v1-0 (sll s3-0 2))) (set! v1-0 (sll s3-0 2)))
;     (when (begin
;             (set! v1-1 (+ v1-0 (the-as int obj)))
;             (set! a0-1 (dynamic-array-field-access v1-1 prims PLACEHOLDER))
;             (set! v1-2 (-> a0-1 collide-with))
;             (set! v1-3 (logand v1-2 arg0))
;             (nonzero? v1-3)
;             )
;       (cond
;         ((begin (set! v1-5 collide-shape-prim-group) (set! a1-1 (-> a0-1 type)) (= a1-1 v1-5))
;          (set! v1-6 (-> (the-as collide-shape-prim-group a0-1) type))
;          (set! t9-0 (method-of-type v1-6 dummy-29))
;          (set! a1-2 arg0)
;          (call! a0-1 a1-2)
;          (set! v1-7 v0-0)
;          )
;         (else
;           (.lvf vf1 (&-> a0-1 prim-core world-sphere quad))
;           (.add.w.vf vf2 vf31 vf1 :mask #b1)
;           (.add.x.vf vf4 vf1 vf2 :mask #b111)
;           (.sub.x.vf vf3 vf1 vf2 :mask #b111)
;           (.min.vf vf29 vf29 vf3)
;           (.max.vf vf30 vf30 vf4)
;           (.mov v1-8 vf30)
;           )
;         )
;       )
;     ((b! #t L211 (set! s3-0 (+ s3-0 1))) (set! s3-0 (+ s3-0 1)))
;     (label cfg-7)
;     (set! v0-1 0)
;     (ret-none)
;     )
;   )

(defmethod dummy-34 collide-shape ((obj collide-shape) (arg0 uint))
  (dummy-10 (-> obj root-prim) arg0)
  )

(defmethod dummy-10 collide-shape-prim ((obj collide-shape-prim) (arg0 uint))
  (if (= (-> obj prim-id) arg0)
      (return obj)
      )
  (the-as collide-shape-prim #f)
  )

(defmethod dummy-10 collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 uint))
  (if (= (-> obj prim-id) arg0)
      (return obj)
      )
  (countdown (s4-0 (-> obj num-prims))
    (let ((a0-1 (-> obj prims s4-0)))
      (cond
        ((= (-> a0-1 type) collide-shape-prim-group)
         (let ((a0-2 (dummy-10 a0-1 arg0)))
           (if a0-2
               (return a0-2)
               )
           )
         )
        (else
          (if (= (-> a0-1 prim-id) arg0)
              (return a0-1)
              )
          )
        )
      )
    )
  (the-as collide-shape-prim #f)
  )

(defun-debug collide-shape-draw-debug-marks ()
  (add-debug-sphere
    (or *display-collision-marks* *display-target-marks*)
    (bucket-id debug-draw0)
    (target-pos 0)
    819.2
    (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
    )
  (when *display-collision-marks*
    (let ((v1-4 (-> *collide-player-list* alive-list next0)))
      *collide-player-list*
      (let ((gp-1 (-> v1-4 next0)))
        (while (!= v1-4 (-> *collide-player-list* alive-list-end))
          (let ((s5-1 (-> (the-as connection v1-4) param1)))
            (if (or
                    (and (not *display-actor-anim*) (not *display-process-anim*))
                    (or
                      (= (-> (the-as collide-shape s5-1) process) *target*)
                      (name= *display-actor-anim* (-> (the-as collide-shape s5-1) process name))
                      (= (ppointer->process *display-process-anim*) (-> (the-as collide-shape s5-1) process))
                      )
                    )
                (dummy-31 (the-as collide-shape s5-1))
                )
            )
          (set! v1-4 gp-1)
          *collide-player-list*
          (set! gp-1 (-> gp-1 next0))
          )
        )
      )
    (let ((v1-19 (-> *collide-hit-by-player-list* alive-list next0)))
      *collide-hit-by-player-list*
      (let ((gp-2 (-> v1-19 next0)))
        (while (!= v1-19 (-> *collide-hit-by-player-list* alive-list-end))
          (let ((s5-2 (-> (the-as connection v1-19) param1)))
            (if (or
                    (and (not *display-actor-anim*) (not *display-process-anim*))
                    (or
                      (= (-> (the-as collide-shape s5-2) process) *target*)
                      (name= *display-actor-anim* (-> (the-as collide-shape s5-2) process name))
                      (= (ppointer->process *display-process-anim*) (-> (the-as collide-shape s5-2) process))
                      )
                    )
                (dummy-31 (the-as collide-shape s5-2))
                )
            )
          (set! v1-19 gp-2)
          *collide-hit-by-player-list*
          (set! gp-2 (-> gp-2 next0))
          )
        )
      )
    (let ((v1-34 (-> *collide-usually-hit-by-player-list* alive-list next0)))
      *collide-usually-hit-by-player-list*
      (let ((gp-3 (-> v1-34 next0)))
        (while (!= v1-34 (-> *collide-usually-hit-by-player-list* alive-list-end))
          (let ((s5-3 (-> (the-as connection v1-34) param1)))
            (if (or
                    (and (not *display-actor-anim*) (not *display-process-anim*))
                    (or
                      (= (-> (the-as collide-shape s5-3) process) *target*)
                      (name= *display-actor-anim* (-> (the-as collide-shape s5-3) process name))
                      (= (ppointer->process *display-process-anim*) (-> (the-as collide-shape s5-3) process))
                      )
                    )
                (dummy-31 (the-as collide-shape s5-3))
                )
            )
          (set! v1-34 gp-3)
          *collide-usually-hit-by-player-list*
          (set! gp-3 (-> gp-3 next0))
          )
        )
      )
    (let ((v1-49 (-> *collide-hit-by-others-list* alive-list next0)))
      *collide-hit-by-others-list*
      (let ((gp-4 (-> v1-49 next0)))
        (while (!= v1-49 (-> *collide-hit-by-others-list* alive-list-end))
          (let ((s5-4 (-> (the-as connection v1-49) param1)))
            (if (or
                    (and (not *display-actor-anim*) (not *display-process-anim*))
                    (or
                      (= (-> (the-as collide-shape s5-4) process) *target*)
                      (name= *display-actor-anim* (-> (the-as collide-shape s5-4) process name))
                      (= (ppointer->process *display-process-anim*) (-> (the-as collide-shape s5-4) process))
                      )
                    )
                (dummy-31 (the-as collide-shape s5-4))
                )
            )
          (set! v1-49 gp-4)
          *collide-hit-by-others-list*
          (set! gp-4 (-> gp-4 next0))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod dummy-31 collide-shape ((obj collide-shape))
  (if (sphere-in-view-frustum? (the-as sphere (-> obj root-prim prim-core)))
      (debug-draw-world-sphere (-> obj root-prim))
      )
  (none)
  )

(define *col-timer* (new 'global 'stopwatch))

(define *frame-timer* (new 'global 'stopwatch))

(define *col-timer-enable* #t)

(defun debug-report-col-stats ()
  (when *col-timer-enable*
    (stopwatch-end *frame-timer*)
    (format *stdcon* "col stats:~%")
    (format *stdcon* " col       ~F ms~%" (* 1000.0 (stopwatch-elapsed-seconds *col-timer*)))
    (format *stdcon* " frame     ~F ms~%" (* 1000.0 (stopwatch-elapsed-seconds *frame-timer*)))
    (stopwatch-init *col-timer*)
    (stopwatch-init *frame-timer*)
    (stopwatch-begin *frame-timer*)
    )
  )

(defmethod dummy-47 collide-shape ((obj collide-shape))
  (dummy-25 (-> obj root-prim) (-> obj process))
  #f
  )

(defmethod dummy-25 collide-shape-prim ((obj collide-shape-prim) (arg0 process-drawable))
  (local-vars (a0-2 float) (a0-4 float) (a0-6 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (-> arg0 node-list))
          (v1-0 (-> obj cshape))
          (a0-1 (-> obj transform-index))
          )
      (cond
        ((nonzero? a1-1)
         (cond
           ((>= a0-1 0)
            (let ((v1-4 (-> a1-1 data a0-1 bone transform)))
              (.lvf vf5 (&-> v1-4 vector 3 quad))
              (.lvf vf1 (&-> obj local-sphere quad))
              (.lvf vf2 (&-> v1-4 vector 0 quad))
              (.mul.w.vf acc vf5 vf0)
              (.div.vf Q vf0 vf5 :fsf #b11 :ftf #b11)
              (.lvf vf3 (&-> v1-4 vector 1 quad))
              (.add.mul.x.vf acc vf2 vf1 acc)
              (.lvf vf4 (&-> v1-4 vector 2 quad))
              )
            (.add.mul.y.vf acc vf3 vf1 acc)
            (.add.mul.z.vf vf1 vf4 vf1 acc :mask #b111)
            (.mul.vf vf1 vf1 Q :mask #b111)
            (.svf (&-> obj prim-core world-sphere quad) vf1)
            (.mov a0-2 vf1)
            )
           (else
             (when (= a0-1 -2)
               (.lvf vf1 (&-> obj local-sphere quad))
               (.lvf vf2 (&-> v1-0 trans quad))
               (.add.vf vf1 vf1 vf2 :mask #b111)
               (.svf (&-> obj prim-core world-sphere quad) vf1)
               (.mov a0-4 vf1)
               )
             )
           )
         )
        (else
          (when (!= a0-1 -1)
            (.lvf vf1 (&-> obj local-sphere quad))
            (.lvf vf2 (&-> v1-0 trans quad))
            (.add.vf vf1 vf1 vf2 :mask #b111)
            (.svf (&-> obj prim-core world-sphere quad) vf1)
            (.mov a0-6 vf1)
            )
          )
        )
      )
    (when (= (-> obj type) collide-shape-prim-group)
      (countdown (s4-0 (-> (the-as collide-shape-prim-group obj) num-prims))
        (dummy-25 (-> (the-as collide-shape-prim-group obj) prims s4-0) arg0)
        )
      #f
      )
    )
  )

(defmethod TODO-RENAME-28 collide-shape ((obj collide-shape) (arg0 vector))
  (vector+! (-> obj trans) (-> obj trans) arg0)
  (dummy-9 (-> obj root-prim) arg0)
  (none)
  )

(defmethod dummy-9 collide-shape-prim ((obj collide-shape-prim) (arg0 vector))
  (vector+! (the-as vector (-> obj prim-core)) (the-as vector (-> obj prim-core)) arg0)
  (let ((f0-0 (-> obj local-sphere w)))
    (set! (-> obj prim-core world-sphere w) f0-0)
    (the-as object f0-0)
    )
  )

(defmethod dummy-9 collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 vector))
  (vector+! (the-as vector (-> obj prim-core)) (the-as vector (-> obj prim-core)) arg0)
  (set! (-> obj prim-core world-sphere w) (-> obj local-sphere w))
  (countdown (s4-0 (-> obj num-prims))
    (let ((a0-2 (-> obj prims s4-0)))
      (cond
        ((= (-> a0-2 type) collide-shape-prim-group)
         (dummy-9 a0-2 arg0)
         )
        (else
          (vector+! (the-as vector (-> a0-2 prim-core)) (the-as vector (-> a0-2 prim-core)) arg0)
          (set! (-> a0-2 prim-core world-sphere w) (-> a0-2 local-sphere w))
          )
        )
      )
    )
  (the-as object #f)
  )

(defmethod TODO-RENAME-30 collide-shape ((obj collide-shape) (arg0 vector))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (vector-! v1-0 arg0 (-> obj trans))
    (TODO-RENAME-28 obj v1-0)
    )
  (none)
  )

(defmethod set-root-prim! collide-shape ((obj collide-shape) (arg0 collide-shape-prim))
  (set! (-> obj root-prim) arg0)
  arg0
  )

(defmethod set-collide-with! collide-shape-prim ((obj collide-shape-prim) (arg0 handle))
  (set! (-> obj collide-with) (the-as uint arg0))
  0
  (none)
  )

(defmethod set-collide-with! collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 handle))
  (set! (-> obj collide-with) (the-as uint arg0))
  (dotimes (s4-0 (-> obj num-prims))
    (set-collide-with! (-> obj prims s4-0) arg0)
    )
  0
  (none)
  )

(defmethod set-collide-as! collide-shape-prim ((obj collide-shape-prim) (arg0 handle))
  (set! (-> obj prim-core collide-as) (the-as uint arg0))
  0
  (none)
  )

(defmethod set-collide-as! collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 handle))
  (set! (-> obj prim-core collide-as) (the-as uint arg0))
  (dotimes (s4-0 (-> obj num-prims))
    (set-collide-as! (-> obj prims s4-0) arg0)
    )
  0
  (none)
  )

(defmethod set-root-prim-collide-with! collide-shape ((obj collide-shape) (arg0 handle))
  (set-collide-with! (-> obj root-prim) arg0)
  0
  (none)
  )

(defmethod set-root-prim-collide-as! collide-shape ((obj collide-shape) (arg0 handle))
  (set-collide-as! (-> obj root-prim) arg0)
  0
  (none)
  )

(defmethod append-prim collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 collide-shape-prim))
  (let ((v1-0 (-> obj num-prims)))
    (cond
      ((>= v1-0 (-> obj allocated-prims))
       (format 0 "collide-shape-prim-group::append-prim : Exceeded max # of prims!~%")
       )
      (else
        (set! (-> obj prims v1-0) arg0)
        (set! (-> obj num-prims) (+ v1-0 1))
        )
      )
    )
  (none)
  )

(defmethod find-collision-meshes collide-shape ((obj collide-shape))
  (let ((s5-0 0))
    (let ((v1-1 (-> obj process draw)))
      (when (and (nonzero? v1-1) (-> v1-1 jgeo))
        (let ((a1-1 (res-lump-struct (-> v1-1 jgeo extra) 'collide-mesh-group structure)))
          (if a1-1
              (set! s5-0 (num-mesh (-> obj root-prim) (the-as collide-shape-prim a1-1)))
              )
          )
        )
      )
    (if (nonzero? s5-0)
        (format 0 "ERROR: Failed to find collision meshes for ~D prim(s) in ~A!~%" s5-0 (-> obj process name))
        )
    )
  (dummy-47 obj)
  )

(defmethod num-mesh collide-shape-prim ((obj collide-shape-prim) (arg0 collide-shape-prim))
  (local-vars (v0-0 int))
  (return 0)
  v0-0
  )

(defmethod num-mesh collide-shape-prim-mesh ((obj collide-shape-prim-mesh) (arg0 collide-shape-prim))
  (let ((s4-0 (-> obj mesh-id)))
    (cond
      ((and (>= s4-0 0) (< s4-0 (length arg0)))
       (set! (-> obj mesh) (the-as collide-mesh (-> arg0 prim-core world-sphere data s4-0)))
       (return 0)
       )
      (else
        (set! (-> obj mesh) #f)
        (return 1)
        )
      )
    )
  (the-as int 0)
  )

(defmethod num-mesh collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 collide-shape-prim))
  (let ((gp-0 0))
    (countdown (s3-0 (-> obj num-prims))
      (+! gp-0 (num-mesh (-> obj prims s3-0) arg0))
      )
    gp-0
    )
  )

;; WARN: Expression building failed: In (method 28 collide-shape-prim-mesh): Unhandled branch delay in BranchElement::push_to_stack: (bl! (zero? (the-as uint v0-5)) L148 (no-delay!))
; (defmethod change-mesh collide-shape-prim-mesh ((obj collide-shape-prim-mesh) (arg0 int))
;   (local-vars
;     (v0-5 int)
;     (v0-6 object)
;     (v1-3 draw-control)
;     (v1-8 int)
;     (v1-9 int)
;     (v1-10 uint)
;     (v1-11 collide-mesh-cache)
;     (a0-6 uint)
;     (a0-7 int)
;     (a1-2 string)
;     (s4-0 structure)
;     (t9-2 (function _varargs_ object))
;     )
;   (when (!= (-> obj mesh-id) arg0)
;     (when (and (nonzero? v1-3) (-> v1-3 jgeo))
;       (when s4-0
;         (cond
;           ((and (>= arg0 0) (< arg0 (length (the-as collide-shape-prim-group s4-0))))
;            (set! v1-8 (* arg0 4))
;            (set! v1-9 (+ (* arg0 4) (the-as int s4-0)))
;            (set! v1-10 (l.wu (+ (* arg0 4) (the-as int s4-0) 12)))
;            (set! (-> obj mesh) (the-as collide-mesh v1-10))
;            (set! (-> obj mesh-id) arg0)
;            (set! v1-11 *collide-mesh-cache*)
;            (set! a0-6 (-> v1-11 id))
;            (set! (-> v1-11 used-size) (the-as uint 0))
;            (set! v0-5 (the-as int (+ a0-6 1)))
;            (bl! (zero? (the-as uint v0-5)) L148 (no-delay!))
;            (set! v0-5 1)
;            (label cfg-12)
;            (set! (-> v1-11 id) (the-as uint v0-5))
;            )
;           (else
;             (set! t9-2 format)
;             (set! a0-7 0)
;             (set! a1-2 L402)
;             (call! a0-7 a1-2)
;             )
;           )
;         )
;       )
;     )
;   (ret-none)
;   )

(defmethod init! collide-shape-intersect ((obj collide-shape-intersect) (arg0 vector))
  (set! (-> obj move-vec quad) (-> arg0 quad))
  (set! (-> obj best-u) -100000000.0)
  (set! (-> obj best-from-prim) #f)
  (set! (-> obj best-to-prim) #f)
  #f
  )

(defmethod debug-draw-world-sphere collide-shape-prim ((obj collide-shape-prim))
  (add-debug-sphere
    #t
    (bucket-id debug-draw0)
    (the-as vector (-> obj prim-core))
    (-> obj local-sphere w)
    (new 'static 'rgba :r #xff :g #xff :b #xff :a #x40)
    )
  )

(defmethod debug-draw-world-sphere collide-shape-prim-sphere ((obj collide-shape-prim-sphere))
  (add-debug-sphere
    #t
    (bucket-id debug-draw0)
    (the-as vector (-> obj prim-core))
    (-> obj local-sphere w)
    (the-as rgba (cond
                   ((and (zero? (-> obj prim-core collide-as)) (zero? (-> obj collide-with)))
                    #x40808080
                    )
                   ((logtest? (-> obj prim-core action) 1)
                    #x4000ffff
                    )
                   (else
                     #x400080ff
                     )
                   )
            )
    )
  )

(defmethod debug-draw-world-sphere collide-shape-prim-mesh ((obj collide-shape-prim-mesh))
  (add-debug-sphere
    #t
    (bucket-id debug-draw0)
    (the-as vector (-> obj prim-core))
    (-> obj local-sphere w)
    (new 'static 'rgba :b #xff :a #x40)
    )
  )

(defmethod debug-draw-world-sphere collide-shape-prim-group ((obj collide-shape-prim-group))
  (add-debug-sphere
    #t
    (bucket-id debug-draw0)
    (the-as vector (-> obj prim-core))
    (-> obj local-sphere w)
    (new 'static 'rgba :g #xff :a #x10)
    )
  (countdown (s5-0 (-> obj num-prims))
    (debug-draw-world-sphere (-> obj prims s5-0))
    )
  #f
  )

;; WARN: Expression building failed: In (method 45 collide-shape): Unhandled branch delay in BranchElement::push_to_stack: (bl! (zero? (the-as uint a0-2)) L93 (no-delay!))
; (defmethod dummy-45 collide-shape ((obj collide-shape))
;   (local-vars
;     (at-0 int)
;     (at-1 int)
;     (at-2 int)
;     (at-3 int)
;     (v0-0 none)
;     (v0-1 none)
;     (v0-2 vector)
;     (v0-3 none)
;     (v0-4 none)
;     (v0-5 symbol)
;     (v0-6 none)
;     (v0-7 none)
;     (v0-8 vector)
;     (v0-9 none)
;     (v0-10 none)
;     (v0-11 none)
;     (v0-12 none)
;     (v0-13 vector)
;     (v0-14 none)
;     (v0-15 none)
;     (v0-16 none)
;     (v0-17 none)
;     (v0-18 vector)
;     (v0-19 none)
;     (v0-20 none)
;     (v1-0 collide-mesh-cache)
;     (v1-1 collide-shape-prim)
;     (v1-2 uint)
;     (v1-4 engine)
;     (v1-5 connectable)
;     (v1-6 collide-shape-prim)
;     (v1-7 uint)
;     (v1-8 uint)
;     (v1-10 process-drawable)
;     (v1-12 type)
;     (v1-13 none)
;     (v1-14 none)
;     (v1-16 type)
;     (v1-17 collide-shape-prim)
;     (v1-19 vector)
;     (v1-20 float)
;     (v1-21 vector)
;     (v1-22 vector)
;     (v1-23 vector)
;     (v1-24 type)
;     (v1-26 symbol)
;     (v1-27 type)
;     (v1-28 none)
;     (v1-30 collide-shape-prim)
;     (v1-34 uint)
;     (v1-35 uint)
;     (v1-37 engine)
;     (v1-38 connectable)
;     (v1-39 collide-shape-prim)
;     (v1-40 uint)
;     (v1-41 uint)
;     (v1-43 process-drawable)
;     (v1-45 type)
;     (v1-46 none)
;     (v1-47 none)
;     (v1-49 type)
;     (v1-50 collide-shape-prim)
;     (v1-52 vector)
;     (v1-53 float)
;     (v1-54 vector)
;     (v1-55 vector)
;     (v1-56 vector)
;     (v1-57 type)
;     (v1-59 symbol)
;     (v1-60 type)
;     (v1-61 none)
;     (v1-63 collide-shape-prim)
;     (v1-67 uint)
;     (v1-69 engine)
;     (v1-70 connectable)
;     (v1-71 collide-shape-prim)
;     (v1-72 uint)
;     (v1-73 uint)
;     (v1-75 process-drawable)
;     (v1-77 type)
;     (v1-78 none)
;     (v1-79 none)
;     (v1-81 type)
;     (v1-82 collide-shape-prim)
;     (v1-84 vector)
;     (v1-85 float)
;     (v1-86 vector)
;     (v1-87 vector)
;     (v1-88 vector)
;     (v1-89 type)
;     (v1-91 symbol)
;     (v1-92 type)
;     (v1-93 none)
;     (v1-95 collide-shape-prim)
;     (v1-99 uint)
;     (v1-100 engine)
;     (v1-101 connectable)
;     (v1-102 collide-shape-prim)
;     (v1-103 uint)
;     (v1-104 uint)
;     (v1-106 process-drawable)
;     (v1-108 type)
;     (v1-109 none)
;     (v1-110 none)
;     (v1-112 type)
;     (v1-113 collide-shape-prim)
;     (v1-115 vector)
;     (v1-116 float)
;     (v1-117 vector)
;     (v1-118 vector)
;     (v1-119 vector)
;     (v1-120 type)
;     (v1-122 symbol)
;     (v1-123 type)
;     (v1-124 none)
;     (v1-126 collide-shape-prim)
;     (a0-1 uint)
;     (a0-2 int)
;     (a0-3 engine)
;     (a0-4 connectable)
;     (a0-5 process-drawable)
;     (a0-6 collide-shape)
;     (a0-7 collide-shape-moving)
;     (a0-8 vector)
;     (a0-14 vector)
;     (a0-15 vector)
;     (a0-16 vector)
;     (a0-17 display)
;     (a0-18 collide-shape-moving)
;     (a0-19 symbol)
;     (a0-20 collide-shape)
;     (a0-21 engine)
;     (a0-22 connectable)
;     (a0-23 engine)
;     (a0-24 connectable)
;     (a0-25 engine)
;     (a0-26 connectable)
;     (a0-27 process-drawable)
;     (a0-28 collide-shape)
;     (a0-29 collide-shape-moving)
;     (a0-30 vector)
;     (a0-36 vector)
;     (a0-37 vector)
;     (a0-38 vector)
;     (a0-39 display)
;     (a0-40 collide-shape-moving)
;     (a0-41 symbol)
;     (a0-42 collide-shape)
;     (a0-43 engine)
;     (a0-44 connectable)
;     (a0-45 engine)
;     (a0-46 connectable)
;     (a0-47 engine)
;     (a0-48 connectable)
;     (a0-49 process-drawable)
;     (a0-50 collide-shape)
;     (a0-51 collide-shape-moving)
;     (a0-52 vector)
;     (a0-58 vector)
;     (a0-59 vector)
;     (a0-60 vector)
;     (a0-61 display)
;     (a0-62 collide-shape-moving)
;     (a0-63 symbol)
;     (a0-64 collide-shape)
;     (a0-65 engine)
;     (a0-66 connectable)
;     (a0-67 engine)
;     (a0-68 connectable)
;     (a0-69 engine)
;     (a0-70 connectable)
;     (a0-71 process-drawable)
;     (a0-72 collide-shape)
;     (a0-73 collide-shape-moving)
;     (a0-74 vector)
;     (a0-80 vector)
;     (a0-81 vector)
;     (a0-82 vector)
;     (a0-83 display)
;     (a0-84 collide-shape-moving)
;     (a0-85 symbol)
;     (a0-86 collide-shape)
;     (a0-87 engine)
;     (a0-88 connectable)
;     (a0-89 engine)
;     (a0-90 connectable)
;     (a1-0 collide-shape-moving)
;     (a1-1 float)
;     (a1-2 vector)
;     (a1-3 uint128)
;     (a1-4 float)
;     (a1-5 vector)
;     (a1-6 collide-shape-moving)
;     (a1-7 collide-shape-moving)
;     (a1-8 float)
;     (a1-9 vector)
;     (a1-10 uint128)
;     (a1-11 float)
;     (a1-12 vector)
;     (a1-13 collide-shape-moving)
;     (a1-14 collide-shape-moving)
;     (a1-15 float)
;     (a1-16 vector)
;     (a1-17 uint128)
;     (a1-18 float)
;     (a1-19 vector)
;     (a1-20 collide-shape-moving)
;     (a1-21 collide-shape-moving)
;     (a1-22 float)
;     (a1-23 vector)
;     (a1-24 uint128)
;     (a1-25 float)
;     (a1-26 vector)
;     (a1-27 collide-shape-moving)
;     (a2-0 collide-work)
;     (a2-1 uint)
;     (a2-2 collide-work)
;     (a2-3 collide-work)
;     (a2-4 uint)
;     (a2-5 collide-work)
;     (a2-6 collide-work)
;     (a2-7 uint)
;     (a2-8 collide-work)
;     (a2-9 collide-work)
;     (a2-10 uint)
;     (a2-11 collide-work)
;     (s0-0 uint)
;     (s0-1 uint)
;     (s0-2 uint)
;     (s0-3 uint)
;     (s1-0 vector)
;     (s1-1 vector)
;     (s1-2 vector)
;     (s1-3 vector)
;     (s2-0 collide-work)
;     (s2-1 collide-work)
;     (s2-2 collide-work)
;     (s2-3 collide-work)
;     (s3-0 collide-shape-moving)
;     (s3-1 collide-shape-moving)
;     (s3-2 collide-shape-moving)
;     (s3-3 collide-shape-moving)
;     (s4-0 connectable)
;     (s4-1 connectable)
;     (s4-2 connectable)
;     (s4-3 connectable)
;     (s5-0 uint)
;     (s5-1 int)
;     (s5-2 int)
;     (s5-3 int)
;     (s5-4 int)
;     (t9-0 (function collide-shape collide-shape collide-work none))
;     (t9-1 (function collide-shape-moving object uint none))
;     (t9-2 (function vector float vector))
;     (t9-3 (function collide-shape-moving vector none))
;     (t9-4 (function collide-shape collide-shape collide-work none))
;     (t9-5 (function collide-shape collide-shape collide-work none))
;     (t9-6 (function collide-shape-moving object uint none))
;     (t9-7 (function vector float vector))
;     (t9-8 (function collide-shape-moving vector none))
;     (t9-9 (function collide-shape collide-shape collide-work none))
;     (t9-10 (function collide-shape collide-shape collide-work none))
;     (t9-11 (function collide-shape-moving object uint none))
;     (t9-12 (function vector float vector))
;     (t9-13 (function collide-shape-moving vector none))
;     (t9-14 (function collide-shape collide-shape collide-work none))
;     (t9-15 (function collide-shape collide-shape collide-work none))
;     (t9-16 (function collide-shape-moving object uint none))
;     (t9-17 (function vector float vector))
;     (t9-18 (function collide-shape-moving vector none))
;     (t9-19 (function collide-shape collide-shape collide-work none))
;     (f0-0 float)
;     (f0-1 float)
;     (f0-2 float)
;     (f0-3 float)
;     (f0-4 float)
;     (f0-5 float)
;     (f0-6 float)
;     (f0-7 float)
;     (f0-8 float)
;     (f0-9 float)
;     (f0-10 float)
;     (f0-11 float)
;     (f0-12 float)
;     (f0-13 float)
;     (f0-14 float)
;     (f0-15 float)
;     (f0-16 float)
;     (f0-17 float)
;     (f0-18 float)
;     (f0-19 float)
;     (f0-20 float)
;     (f0-21 float)
;     (f0-22 float)
;     (f0-23 float)
;     (f0-24 float)
;     (f0-25 float)
;     (f0-26 float)
;     (f0-27 float)
;     (f1-0 float)
;     (f1-1 float)
;     (f1-2 float)
;     (f1-3 float)
;     (f1-4 float)
;     (f1-5 float)
;     (f1-6 float)
;     (f1-7 float)
;     (f1-8 float)
;     (f1-9 float)
;     (f1-10 float)
;     (f1-11 float)
;     (f2-0 float)
;     (f2-1 float)
;     (f2-2 float)
;     (f2-3 float)
;     )
;   (rlet ((vf0 :class vf)
;          (vf1 :class vf)
;          (vf2 :class vf)
;          (vf3 :class vf)
;          (vf4 :class vf)
;          (vf5 :class vf)
;          )
;     (init-vf0-vector)
;     (when (begin
;             (when (begin
;                     (set! v1-0 *collide-mesh-cache*)
;                     (set! a0-1 (-> v1-0 id))
;                     (set! (-> v1-0 used-size) (the-as uint 0))
;                     (set! a0-2 (the-as int (+ a0-1 1)))
;                     (bl! (zero? (the-as uint a0-2)) L93 (no-delay!))
;                     (set! a0-2 1)
;                     (label cfg-2)
;                     (set! (-> v1-0 id) (the-as uint a0-2))
;                     (set! v1-1 (-> obj root-prim))
;                     (set! s5-0 (-> v1-1 collide-with))
;                     (set! v1-2 (logand s5-0 16))
;                     (nonzero? v1-2)
;                     )
;               (set! v1-4 *collide-player-list*)
;               (set! v1-5 (-> v1-4 alive-list next0))
;               (set! a0-3 *collide-player-list*)
;               (set! a0-4 v1-5)
;               (set! s4-0 (-> a0-4 next0))
;               (while (begin (set! a0-23 *collide-player-list*) (set! a0-24 (-> a0-23 alive-list-end)) (!= v1-5 a0-24))
;                 (when (begin
;                         (set! s3-0 (the-as collide-shape-moving (-> (the-as connection v1-5) param1)))
;                         (set! v1-6 (-> s3-0 root-prim))
;                         (set! v1-7 (-> v1-6 prim-core collide-as))
;                         (set! v1-8 (logand s5-0 v1-7))
;                         (nonzero? v1-8)
;                         )
;                   (when (begin (set! v1-10 (-> s3-0 process)) (set! a0-5 (-> obj process)) (!= a0-5 v1-10))
;                     (when (begin
;                             (and
;                               (begin
;                                 (set! s2-0 (new 'stack-no-clear 'collide-work))
;                                 (set! a0-6 obj)
;                                 (set! v1-12 (-> a0-6 type))
;                                 (set! t9-0 (method-of-type v1-12 dummy-42))
;                                 (set! a1-0 s3-0)
;                                 (set! a2-0 s2-0)
;                                 (set! v0-0 (call! a0-6 a1-0 a2-0))
;                                 (set! v1-13 v0-0)
;                                 v1-13
;                                 )
;                               (begin
;                                 (set! f0-0 -81.92)
;                                 (set! f1-0 (-> s2-0 collide-sphere-neg-r x))
;                                 (set! v1-14 (the-as none (>=.s f0-0 f1-0)))
;                                 )
;                               )
;                             v1-14
;                             )
;                       (set! a0-7 s3-0)
;                       (set! v1-16 (-> a0-7 type))
;                       (set! t9-1 (method-of-type v1-16 dummy-32))
;                       (set! a1-1 8192.0)
;                       (set! v1-17 (-> s3-0 root-prim))
;                       (set! a2-1 (-> v1-17 collide-with))
;                       (call! a0-7 a1-1 a2-1)
;                       (set! v1-18 v0-1)
;                       (set! s5-1 3)
;                       (until (begin
;                                (cond
;                                  ((begin
;                                     (set! s1-0 (new 'stack-no-clear 'vector))
;                                     (set! v1-19 (new 'stack-no-clear 'vector))
;                                     (set! a0-8 v1-19)
;                                     (set! a1-2 (-> s3-0 trans))
;                                     (set! a1-3 (-> a1-2 quad))
;                                     (set! (-> a0-8 quad) a1-3)
;                                     (set! f0-1 2867.2)
;                                     (set! f1-1 (-> v1-19 y))
;                                     (set! f1-2 (+.s f0-1 f1-1))
;                                     (set! f0-2 5734.4)
;                                     (set! f2-0 (+.s f0-2 f1-2))
;                                     (set! f0-3 (-> s2-0 inv-mat vector 1 y))
;                                     (<.s f0-3 f1-2)
;                                     )
;                                   (set! f0-3 f1-2)
;                                   (set! a0-10 (fpr->gpr f0-3))
;                                   )
;                                  ((<.s f2-0 f0-3)
;                                   (set! f0-3 f2-0)
;                                   (set! a0-12 (fpr->gpr f0-3))
;                                   )
;                                  )
;                                (set! (-> v1-19 y) f0-3)
;                                (set! a0-13 (fpr->gpr f0-3))
;                                (.lvf vf4 (&-> v1-19 quad))
;                                (.lvf vf3 (&-> s2-0 inv-mat vector 1 quad))
;                                (.lvf vf5 (&-> s2-0 inv-mat vector 2 quad))
;                                (.sub.vf vf2 vf4 vf3)
;                                (.mul.vf vf1 vf5 vf2)
;                                (.add.x.vf vf1 vf1 vf1 :mask #b10)
;                                (.add.z.vf vf1 vf1 vf1 :mask #b10)
;                                (.mov v1-20 vf1)
;                                (bl! (<0.si v1-20) L99 (no-delay!))
;                                (.sub.vf vf2 vf0 vf2)
;                                (or
;                                  (begin
;                                    (label cfg-18)
;                                    (.svf (&-> s1-0 quad) vf2)
;                                    (set! t9-2 vector-normalize!)
;                                    (set! a0-14 s1-0)
;                                    (set! a1-4 1.0)
;                                    (call! a0-14 a1-4)
;                                    (set! v1-21 s1-0)
;                                    (set! a0-15 s1-0)
;                                    (set! f0-4 (-> s2-0 collide-sphere-neg-r x))
;                                    (set! f0-5 (neg.s f0-4))
;                                    (set! v1-22 (vector-float*!2 v1-21 a0-15 f0-5))
;                                    (set! v1-23 s1-0)
;                                    (set! a0-16 s1-0)
;                                    (.lvf vf1 (&-> a0-16 quad))
;                                    (set! a0-17 *display*)
;                                    (set! f0-6 (-> a0-17 frames-per-second))
;                                    (.mov at-0 f0-6)
;                                    (.mov vf2 at-0)
;                                    (.mov.vf vf1 vf0 :mask #b1000)
;                                    (.mul.x.vf vf1 vf1 vf2 :mask #b111)
;                                    (.svf (&-> v1-23 quad) vf1)
;                                    (set! s0-0 (-> s3-0 status))
;                                    (set! a0-18 s3-0)
;                                    (set! v1-24 (-> a0-18 type))
;                                    (set! t9-3 (method-of-type v1-24 dummy-37))
;                                    (set! a1-5 s1-0)
;                                    (call! a0-18 a1-5)
;                                    (set! v1-25 v0-3)
;                                    (set! (-> s3-0 status) s0-0)
;                                    (set! s5-1 (+ s5-1 -1))
;                                    (set! a0-19 (<=0.si s5-1))
;                                    a0-19
;                                    )
;                                  (begin
;                                    (set! a0-20 obj)
;                                    (set! v1-27 (-> a0-20 type))
;                                    (set! t9-4 (method-of-type v1-27 dummy-42))
;                                    (set! a1-6 s3-0)
;                                    (set! a2-2 s2-0)
;                                    (set! v0-4 (call! a0-20 a1-6 a2-2))
;                                    (set! v1-28 v0-4)
;                                    (set! v1-26 (not v1-28))
;                                    )
;                                  )
;                                v1-26
;                                )
;                         (empty)
;                         )
;                       (set! v1-30 (-> obj root-prim))
;                       (set! s5-0 (-> v1-30 collide-with))
;                       (set! v1-31 s5-0)
;                       )
;                     )
;                   )
;                 (set! v1-5 s4-0)
;                 (set! a0-21 *collide-player-list*)
;                 (set! a0-22 (-> s4-0 next0))
;                 (set! s4-0 a0-22)
;                 )
;               )
;             (set! v1-34 (logand s5-0 14))
;             (nonzero? v1-34)
;             )
;       (when (begin
;               (when (begin
;                       (when (begin (set! v1-35 (logand s5-0 2)) (nonzero? v1-35))
;                         (set! v1-37 *collide-hit-by-player-list*)
;                         (set! v1-38 (-> v1-37 alive-list next0))
;                         (set! a0-25 *collide-hit-by-player-list*)
;                         (set! a0-26 v1-38)
;                         (set! s4-1 (-> a0-26 next0))
;                         (while (begin (set! a0-45 *collide-hit-by-player-list*) (set! a0-46 (-> a0-45 alive-list-end)) (!= v1-38 a0-46))
;                           (when (begin
;                                   (set! s3-1 (the-as collide-shape-moving (-> (the-as connection v1-38) param1)))
;                                   (set! v1-39 (-> s3-1 root-prim))
;                                   (set! v1-40 (-> v1-39 prim-core collide-as))
;                                   (set! v1-41 (logand s5-0 v1-40))
;                                   (nonzero? v1-41)
;                                   )
;                             (when (begin (set! v1-43 (-> s3-1 process)) (set! a0-27 (-> obj process)) (!= a0-27 v1-43))
;                               (when (begin
;                                       (and
;                                         (begin
;                                           (set! s2-1 (new 'stack-no-clear 'collide-work))
;                                           (set! a0-28 obj)
;                                           (set! v1-45 (-> a0-28 type))
;                                           (set! t9-5 (method-of-type v1-45 dummy-42))
;                                           (set! a1-7 s3-1)
;                                           (set! a2-3 s2-1)
;                                           (set! v0-6 (call! a0-28 a1-7 a2-3))
;                                           (set! v1-46 v0-6)
;                                           v1-46
;                                           )
;                                         (begin
;                                           (set! f0-7 -81.92)
;                                           (set! f1-3 (-> s2-1 collide-sphere-neg-r x))
;                                           (set! v1-47 (the-as none (>=.s f0-7 f1-3)))
;                                           )
;                                         )
;                                       v1-47
;                                       )
;                                 (set! a0-29 s3-1)
;                                 (set! v1-49 (-> a0-29 type))
;                                 (set! t9-6 (method-of-type v1-49 dummy-32))
;                                 (set! a1-8 8192.0)
;                                 (set! v1-50 (-> s3-1 root-prim))
;                                 (set! a2-4 (-> v1-50 collide-with))
;                                 (call! a0-29 a1-8 a2-4)
;                                 (set! v1-51 v0-7)
;                                 (set! s5-2 3)
;                                 (until (begin
;                                          (cond
;                                            ((begin
;                                               (set! s1-1 (new 'stack-no-clear 'vector))
;                                               (set! v1-52 (new 'stack-no-clear 'vector))
;                                               (set! a0-30 v1-52)
;                                               (set! a1-9 (-> s3-1 trans))
;                                               (set! a1-10 (-> a1-9 quad))
;                                               (set! (-> a0-30 quad) a1-10)
;                                               (set! f0-8 2867.2)
;                                               (set! f1-4 (-> v1-52 y))
;                                               (set! f1-5 (+.s f0-8 f1-4))
;                                               (set! f0-9 5734.4)
;                                               (set! f2-1 (+.s f0-9 f1-5))
;                                               (set! f0-10 (-> s2-1 inv-mat vector 1 y))
;                                               (<.s f0-10 f1-5)
;                                               )
;                                             (set! f0-10 f1-5)
;                                             (set! a0-32 (fpr->gpr f0-10))
;                                             )
;                                            ((<.s f2-1 f0-10)
;                                             (set! f0-10 f2-1)
;                                             (set! a0-34 (fpr->gpr f0-10))
;                                             )
;                                            )
;                                          (set! (-> v1-52 y) f0-10)
;                                          (set! a0-35 (fpr->gpr f0-10))
;                                          (.lvf vf4 (&-> v1-52 quad))
;                                          (.lvf vf3 (&-> s2-1 inv-mat vector 1 quad))
;                                          (.lvf vf5 (&-> s2-1 inv-mat vector 2 quad))
;                                          (.sub.vf vf2 vf4 vf3)
;                                          (.mul.vf vf1 vf5 vf2)
;                                          (.add.x.vf vf1 vf1 vf1 :mask #b10)
;                                          (.add.z.vf vf1 vf1 vf1 :mask #b10)
;                                          (.mov v1-53 vf1)
;                                          (bl! (<0.si v1-53) L109 (no-delay!))
;                                          (.sub.vf vf2 vf0 vf2)
;                                          (or
;                                            (begin
;                                              (label cfg-44)
;                                              (.svf (&-> s1-1 quad) vf2)
;                                              (set! t9-7 vector-normalize!)
;                                              (set! a0-36 s1-1)
;                                              (set! a1-11 1.0)
;                                              (call! a0-36 a1-11)
;                                              (set! v1-54 s1-1)
;                                              (set! a0-37 s1-1)
;                                              (set! f0-11 (-> s2-1 collide-sphere-neg-r x))
;                                              (set! f0-12 (neg.s f0-11))
;                                              (set! v1-55 (vector-float*!2 v1-54 a0-37 f0-12))
;                                              (set! v1-56 s1-1)
;                                              (set! a0-38 s1-1)
;                                              (.lvf vf1 (&-> a0-38 quad))
;                                              (set! a0-39 *display*)
;                                              (set! f0-13 (-> a0-39 frames-per-second))
;                                              (.mov at-1 f0-13)
;                                              (.mov vf2 at-1)
;                                              (.mov.vf vf1 vf0 :mask #b1000)
;                                              (.mul.x.vf vf1 vf1 vf2 :mask #b111)
;                                              (.svf (&-> v1-56 quad) vf1)
;                                              (set! s0-1 (-> s3-1 status))
;                                              (set! a0-40 s3-1)
;                                              (set! v1-57 (-> a0-40 type))
;                                              (set! t9-8 (method-of-type v1-57 dummy-37))
;                                              (set! a1-12 s1-1)
;                                              (call! a0-40 a1-12)
;                                              (set! v1-58 v0-9)
;                                              (set! (-> s3-1 status) s0-1)
;                                              (set! s5-2 (+ s5-2 -1))
;                                              (set! a0-41 (<=0.si s5-2))
;                                              a0-41
;                                              )
;                                            (begin
;                                              (set! a0-42 obj)
;                                              (set! v1-60 (-> a0-42 type))
;                                              (set! t9-9 (method-of-type v1-60 dummy-42))
;                                              (set! a1-13 s3-1)
;                                              (set! a2-5 s2-1)
;                                              (set! v0-10 (call! a0-42 a1-13 a2-5))
;                                              (set! v1-61 v0-10)
;                                              (set! v1-59 (not v1-61))
;                                              )
;                                            )
;                                          v1-59
;                                          )
;                                   (empty)
;                                   )
;                                 (set! v1-63 (-> obj root-prim))
;                                 (set! s5-0 (-> v1-63 collide-with))
;                                 (set! v1-64 s5-0)
;                                 )
;                               )
;                             )
;                           (set! v1-38 s4-1)
;                           (set! a0-43 *collide-hit-by-player-list*)
;                           (set! a0-44 (-> s4-1 next0))
;                           (set! s4-1 a0-44)
;                           )
;                         )
;                       (set! v1-67 (logand s5-0 4))
;                       (nonzero? v1-67)
;                       )
;                 (set! v1-69 *collide-usually-hit-by-player-list*)
;                 (set! v1-70 (-> v1-69 alive-list next0))
;                 (set! a0-47 *collide-usually-hit-by-player-list*)
;                 (set! a0-48 v1-70)
;                 (set! s4-2 (-> a0-48 next0))
;                 (while (begin
;                          (set! a0-67 *collide-usually-hit-by-player-list*)
;                          (set! a0-68 (-> a0-67 alive-list-end))
;                          (!= v1-70 a0-68)
;                          )
;                   (when (begin
;                           (set! s3-2 (the-as collide-shape-moving (-> (the-as connection v1-70) param1)))
;                           (set! v1-71 (-> s3-2 root-prim))
;                           (set! v1-72 (-> v1-71 prim-core collide-as))
;                           (set! v1-73 (logand s5-0 v1-72))
;                           (nonzero? v1-73)
;                           )
;                     (when (begin (set! v1-75 (-> s3-2 process)) (set! a0-49 (-> obj process)) (!= a0-49 v1-75))
;                       (when (begin
;                               (and
;                                 (begin
;                                   (set! s2-2 (new 'stack-no-clear 'collide-work))
;                                   (set! a0-50 obj)
;                                   (set! v1-77 (-> a0-50 type))
;                                   (set! t9-10 (method-of-type v1-77 dummy-42))
;                                   (set! a1-14 s3-2)
;                                   (set! a2-6 s2-2)
;                                   (set! v0-11 (call! a0-50 a1-14 a2-6))
;                                   (set! v1-78 v0-11)
;                                   v1-78
;                                   )
;                                 (begin
;                                   (set! f0-14 -81.92)
;                                   (set! f1-6 (-> s2-2 collide-sphere-neg-r x))
;                                   (set! v1-79 (the-as none (>=.s f0-14 f1-6)))
;                                   )
;                                 )
;                               v1-79
;                               )
;                         (set! a0-51 s3-2)
;                         (set! v1-81 (-> a0-51 type))
;                         (set! t9-11 (method-of-type v1-81 dummy-32))
;                         (set! a1-15 8192.0)
;                         (set! v1-82 (-> s3-2 root-prim))
;                         (set! a2-7 (-> v1-82 collide-with))
;                         (call! a0-51 a1-15 a2-7)
;                         (set! v1-83 v0-12)
;                         (set! s5-3 3)
;                         (until (begin
;                                  (cond
;                                    ((begin
;                                       (set! s1-2 (new 'stack-no-clear 'vector))
;                                       (set! v1-84 (new 'stack-no-clear 'vector))
;                                       (set! a0-52 v1-84)
;                                       (set! a1-16 (-> s3-2 trans))
;                                       (set! a1-17 (-> a1-16 quad))
;                                       (set! (-> a0-52 quad) a1-17)
;                                       (set! f0-15 2867.2)
;                                       (set! f1-7 (-> v1-84 y))
;                                       (set! f1-8 (+.s f0-15 f1-7))
;                                       (set! f0-16 5734.4)
;                                       (set! f2-2 (+.s f0-16 f1-8))
;                                       (set! f0-17 (-> s2-2 inv-mat vector 1 y))
;                                       (<.s f0-17 f1-8)
;                                       )
;                                     (set! f0-17 f1-8)
;                                     (set! a0-54 (fpr->gpr f0-17))
;                                     )
;                                    ((<.s f2-2 f0-17)
;                                     (set! f0-17 f2-2)
;                                     (set! a0-56 (fpr->gpr f0-17))
;                                     )
;                                    )
;                                  (set! (-> v1-84 y) f0-17)
;                                  (set! a0-57 (fpr->gpr f0-17))
;                                  (.lvf vf4 (&-> v1-84 quad))
;                                  (.lvf vf3 (&-> s2-2 inv-mat vector 1 quad))
;                                  (.lvf vf5 (&-> s2-2 inv-mat vector 2 quad))
;                                  (.sub.vf vf2 vf4 vf3)
;                                  (.mul.vf vf1 vf5 vf2)
;                                  (.add.x.vf vf1 vf1 vf1 :mask #b10)
;                                  (.add.z.vf vf1 vf1 vf1 :mask #b10)
;                                  (.mov v1-85 vf1)
;                                  (bl! (<0.si v1-85) L119 (no-delay!))
;                                  (.sub.vf vf2 vf0 vf2)
;                                  (or
;                                    (begin
;                                      (label cfg-69)
;                                      (.svf (&-> s1-2 quad) vf2)
;                                      (set! t9-12 vector-normalize!)
;                                      (set! a0-58 s1-2)
;                                      (set! a1-18 1.0)
;                                      (call! a0-58 a1-18)
;                                      (set! v1-86 s1-2)
;                                      (set! a0-59 s1-2)
;                                      (set! f0-18 (-> s2-2 collide-sphere-neg-r x))
;                                      (set! f0-19 (neg.s f0-18))
;                                      (set! v1-87 (vector-float*!2 v1-86 a0-59 f0-19))
;                                      (set! v1-88 s1-2)
;                                      (set! a0-60 s1-2)
;                                      (.lvf vf1 (&-> a0-60 quad))
;                                      (set! a0-61 *display*)
;                                      (set! f0-20 (-> a0-61 frames-per-second))
;                                      (.mov at-2 f0-20)
;                                      (.mov vf2 at-2)
;                                      (.mov.vf vf1 vf0 :mask #b1000)
;                                      (.mul.x.vf vf1 vf1 vf2 :mask #b111)
;                                      (.svf (&-> v1-88 quad) vf1)
;                                      (set! s0-2 (-> s3-2 status))
;                                      (set! a0-62 s3-2)
;                                      (set! v1-89 (-> a0-62 type))
;                                      (set! t9-13 (method-of-type v1-89 dummy-37))
;                                      (set! a1-19 s1-2)
;                                      (call! a0-62 a1-19)
;                                      (set! v1-90 v0-14)
;                                      (set! (-> s3-2 status) s0-2)
;                                      (set! s5-3 (+ s5-3 -1))
;                                      (set! a0-63 (<=0.si s5-3))
;                                      a0-63
;                                      )
;                                    (begin
;                                      (set! a0-64 obj)
;                                      (set! v1-92 (-> a0-64 type))
;                                      (set! t9-14 (method-of-type v1-92 dummy-42))
;                                      (set! a1-20 s3-2)
;                                      (set! a2-8 s2-2)
;                                      (set! v0-15 (call! a0-64 a1-20 a2-8))
;                                      (set! v1-93 v0-15)
;                                      (set! v1-91 (not v1-93))
;                                      )
;                                    )
;                                  v1-91
;                                  )
;                           (empty)
;                           )
;                         (set! v1-95 (-> obj root-prim))
;                         (set! s5-0 (-> v1-95 collide-with))
;                         (set! v1-96 s5-0)
;                         )
;                       )
;                     )
;                   (set! v1-70 s4-2)
;                   (set! a0-65 *collide-usually-hit-by-player-list*)
;                   (set! a0-66 (-> s4-2 next0))
;                   (set! s4-2 a0-66)
;                   )
;                 )
;               (set! v1-99 (logand s5-0 8))
;               (nonzero? v1-99)
;               )
;         (set! v1-100 *collide-hit-by-others-list*)
;         (set! v1-101 (-> v1-100 alive-list next0))
;         (set! a0-69 *collide-hit-by-others-list*)
;         (set! a0-70 v1-101)
;         (set! s4-3 (-> a0-70 next0))
;         (while (begin (set! a0-89 *collide-hit-by-others-list*) (set! a0-90 (-> a0-89 alive-list-end)) (!= v1-101 a0-90))
;           (when (begin
;                   (set! s3-3 (the-as collide-shape-moving (-> (the-as connection v1-101) param1)))
;                   (set! v1-102 (-> s3-3 root-prim))
;                   (set! v1-103 (-> v1-102 prim-core collide-as))
;                   (set! v1-104 (logand s5-0 v1-103))
;                   (nonzero? v1-104)
;                   )
;             (when (begin (set! v1-106 (-> s3-3 process)) (set! a0-71 (-> obj process)) (!= a0-71 v1-106))
;               (when (begin
;                       (and
;                         (begin
;                           (set! s2-3 (new 'stack-no-clear 'collide-work))
;                           (set! a0-72 obj)
;                           (set! v1-108 (-> a0-72 type))
;                           (set! t9-15 (method-of-type v1-108 dummy-42))
;                           (set! a1-21 s3-3)
;                           (set! a2-9 s2-3)
;                           (set! v0-16 (call! a0-72 a1-21 a2-9))
;                           (set! v1-109 v0-16)
;                           v1-109
;                           )
;                         (begin
;                           (set! f0-21 -81.92)
;                           (set! f1-9 (-> s2-3 collide-sphere-neg-r x))
;                           (set! v1-110 (the-as none (>=.s f0-21 f1-9)))
;                           )
;                         )
;                       v1-110
;                       )
;                 (set! a0-73 s3-3)
;                 (set! v1-112 (-> a0-73 type))
;                 (set! t9-16 (method-of-type v1-112 dummy-32))
;                 (set! a1-22 8192.0)
;                 (set! v1-113 (-> s3-3 root-prim))
;                 (set! a2-10 (-> v1-113 collide-with))
;                 (call! a0-73 a1-22 a2-10)
;                 (set! v1-114 v0-17)
;                 (set! s5-4 3)
;                 (until (begin
;                          (cond
;                            ((begin
;                               (set! s1-3 (new 'stack-no-clear 'vector))
;                               (set! v1-115 (new 'stack-no-clear 'vector))
;                               (set! a0-74 v1-115)
;                               (set! a1-23 (-> s3-3 trans))
;                               (set! a1-24 (-> a1-23 quad))
;                               (set! (-> a0-74 quad) a1-24)
;                               (set! f0-22 2867.2)
;                               (set! f1-10 (-> v1-115 y))
;                               (set! f1-11 (+.s f0-22 f1-10))
;                               (set! f0-23 5734.4)
;                               (set! f2-3 (+.s f0-23 f1-11))
;                               (set! f0-24 (-> s2-3 inv-mat vector 1 y))
;                               (<.s f0-24 f1-11)
;                               )
;                             (set! f0-24 f1-11)
;                             (set! a0-76 (fpr->gpr f0-24))
;                             )
;                            ((<.s f2-3 f0-24)
;                             (set! f0-24 f2-3)
;                             (set! a0-78 (fpr->gpr f0-24))
;                             )
;                            )
;                          (set! (-> v1-115 y) f0-24)
;                          (set! a0-79 (fpr->gpr f0-24))
;                          (.lvf vf4 (&-> v1-115 quad))
;                          (.lvf vf3 (&-> s2-3 inv-mat vector 1 quad))
;                          (.lvf vf5 (&-> s2-3 inv-mat vector 2 quad))
;                          (.sub.vf vf2 vf4 vf3)
;                          (.mul.vf vf1 vf5 vf2)
;                          (.add.x.vf vf1 vf1 vf1 :mask #b10)
;                          (.add.z.vf vf1 vf1 vf1 :mask #b10)
;                          (.mov v1-116 vf1)
;                          (bl! (<0.si v1-116) L129 (no-delay!))
;                          (.sub.vf vf2 vf0 vf2)
;                          (or
;                            (begin
;                              (label cfg-94)
;                              (.svf (&-> s1-3 quad) vf2)
;                              (set! t9-17 vector-normalize!)
;                              (set! a0-80 s1-3)
;                              (set! a1-25 1.0)
;                              (call! a0-80 a1-25)
;                              (set! v1-117 s1-3)
;                              (set! a0-81 s1-3)
;                              (set! f0-25 (-> s2-3 collide-sphere-neg-r x))
;                              (set! f0-26 (neg.s f0-25))
;                              (set! v1-118 (vector-float*!2 v1-117 a0-81 f0-26))
;                              (set! v1-119 s1-3)
;                              (set! a0-82 s1-3)
;                              (.lvf vf1 (&-> a0-82 quad))
;                              (set! a0-83 *display*)
;                              (set! f0-27 (-> a0-83 frames-per-second))
;                              (.mov at-3 f0-27)
;                              (.mov vf2 at-3)
;                              (.mov.vf vf1 vf0 :mask #b1000)
;                              (.mul.x.vf vf1 vf1 vf2 :mask #b111)
;                              (.svf (&-> v1-119 quad) vf1)
;                              (set! s0-3 (-> s3-3 status))
;                              (set! a0-84 s3-3)
;                              (set! v1-120 (-> a0-84 type))
;                              (set! t9-18 (method-of-type v1-120 dummy-37))
;                              (set! a1-26 s1-3)
;                              (call! a0-84 a1-26)
;                              (set! v1-121 v0-19)
;                              (set! (-> s3-3 status) s0-3)
;                              (set! s5-4 (+ s5-4 -1))
;                              (set! a0-85 (<=0.si s5-4))
;                              a0-85
;                              )
;                            (begin
;                              (set! a0-86 obj)
;                              (set! v1-123 (-> a0-86 type))
;                              (set! t9-19 (method-of-type v1-123 dummy-42))
;                              (set! a1-27 s3-3)
;                              (set! a2-11 s2-3)
;                              (set! v0-20 (call! a0-86 a1-27 a2-11))
;                              (set! v1-124 v0-20)
;                              (set! v1-122 (not v1-124))
;                              )
;                            )
;                          v1-122
;                          )
;                   (empty)
;                   )
;                 (set! v1-126 (-> obj root-prim))
;                 (set! s5-0 (-> v1-126 collide-with))
;                 (set! v1-127 s5-0)
;                 )
;               )
;             )
;           (set! v1-101 s4-3)
;           (set! a0-87 *collide-hit-by-others-list*)
;           (set! a0-88 (-> s4-3 next0))
;           (set! s4-3 a0-88)
;           )
;         (set! v0-5 #f)
;         )
;       )
;     (ret-value v0-5)
;     )
;   )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod overlaps-others-test collide-shape-prim ((obj collide-shape-prim))
  (format 0 "ERROR: Unsupported call to collide-shape-prim::overlaps-others-test!~%")
  #f
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod clear-collide-with-as collide-shape ((obj collide-shape))
  (set! (-> obj root-prim collide-with) (the-as uint 0))
  (set! (-> obj root-prim prim-core collide-as) (the-as uint 0))
  0
  (none)
  )

(defmethod backup-collide-with-as collide-shape ((obj collide-shape))
  (set! (-> obj backup-collide-with) (-> obj root-prim collide-with))
  (set! (-> obj backup-collide-as) (-> obj root-prim prim-core collide-as))
  0
  (none)
  )

(defmethod restore-collide-with-as collide-shape ((obj collide-shape))
  (set! (-> obj root-prim collide-with) (-> obj backup-collide-with))
  (set! (-> obj root-prim prim-core collide-as) (-> obj backup-collide-as))
  0
  (none)
  )

(defmethod dummy-53 collide-shape ((obj collide-shape) (arg0 int) (arg1 int) (arg2 int))
  (let ((s3-0 (-> obj root-prim)))
    (if (logtest? (-> s3-0 prim-id) arg0)
        (set! (-> s3-0 prim-core collide-as) (logior (logclear (-> s3-0 prim-core collide-as) arg1) arg2))
        )
    (let ((v1-7 (if (and (nonzero? s3-0) (type-type? (-> s3-0 type) collide-shape-prim-group))
                    s3-0
                    )
                )
          )
      (when v1-7
        (dotimes (a0-4 (-> (the-as collide-shape-prim-group v1-7) num-prims))
          (let ((a1-4 (-> (the-as collide-shape-prim-group (+ (* a0-4 4) (the-as int v1-7))) prims 0)))
            (if (logtest? (-> a1-4 prim-id) arg0)
                (set! (-> a1-4 prim-core collide-as) (logior (logclear (-> a1-4 prim-core collide-as) arg1) arg2))
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod dummy-54 collide-shape ((obj collide-shape) (arg0 int) (arg1 int))
  (let ((s4-0 (-> obj root-prim)))
    (if (logtest? (-> s4-0 prim-id) arg0)
        (set! (-> s4-0 prim-core offense) arg1)
        )
    (let ((v1-5 (if (and (nonzero? s4-0) (type-type? (-> s4-0 type) collide-shape-prim-group))
                    s4-0
                    )
                )
          )
      (when v1-5
        (dotimes (a0-3 (-> (the-as collide-shape-prim-group v1-5) num-prims))
          (let ((a1-4 (-> (the-as collide-shape-prim-group (+ (* a0-3 4) (the-as int v1-5))) prims 0)))
            (if (logtest? (-> a1-4 prim-id) arg0)
                (set! (-> a1-4 prim-core offense) arg1)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod dummy-55 collide-shape ((obj collide-shape) (arg0 process) (arg1 touching-shapes-entry) (arg2 float) (arg3 float) (arg4 float))
  (local-vars (sv-144 process))
  (with-pp
    (when arg1
      (let ((s1-0 (-> arg1 head)))
        (set! sv-144 arg0)
        (let ((s5-0 (if (and (nonzero? sv-144) (type-type? (-> sv-144 type) process-drawable))
                        sv-144
                        )
                    )
              )
          (when (and s1-0 s5-0)
            (let ((s0-1 (get-touched-prim s1-0 obj (the-as touching-prims-entry arg1))))
              (get-touched-prim s1-0 (-> (the-as process-drawable s5-0) root) (the-as touching-prims-entry arg1))
              (let* ((v1-8 (dummy-11 s1-0 (new 'stack-no-clear 'vector)))
                     (s1-2 (vector-! (new 'stack-no-clear 'vector) v1-8 (the-as vector (-> s0-1 prim-core))))
                     )
                (vector-normalize! s1-2 1.0)
                (when (< arg2 (-> s1-2 y))
                  (let ((s2-1 (new 'stack-no-clear 'vector)))
                    (set! (-> s2-1 quad) (-> (the-as process-drawable s5-0) root transv quad))
                    (let ((f30-0 (vector-xz-length (-> (the-as process-drawable s5-0) root transv))))
                      (if (= f30-0 0.0)
                          (set! (-> s2-1 quad) (-> (vector-z-quaternion! s2-1 (-> (the-as process-drawable s5-0) root quat)) quad))
                          )
                      (vector-xz-normalize! s2-1 (fmax f30-0 arg4))
                      )
                    (set! (-> s2-1 y) arg3)
                    (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
                      (set! (-> a1-8 from) pp)
                      (set! (-> a1-8 num-params) 2)
                      (set! (-> a1-8 message) 'shove)
                      (set! (-> a1-8 param 0) (the-as uint arg1))
                      (let ((v1-18 (new 'static 'attack-info :mask #x802)))
                        (set! (-> v1-18 vector quad) (-> s2-1 quad))
                        (set! (-> v1-18 angle) 'jump)
                        (set! (-> a1-8 param 1) (the-as uint v1-18))
                        )
                      (send-event-function s5-0 a1-8)
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (none)
    )
  )

(defmethod dummy-41 collide-shape ((obj collide-shape) (arg0 attack-info) (arg1 float))
  (set! (-> arg0 shove-up) arg1)
  (let* ((s3-0 (-> obj process path))
         (s2-0 (-> s3-0 curve num-cverts))
         (s4-0 (target-pos 0))
         (s1-0 (new 'stack-no-clear 'vector))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (let ((f30-0 -1.0))
      (dotimes (s0-0 s2-0)
        (eval-path-curve-div! s3-0 s1-0 (the float s0-0) 'interp)
        (let ((f0-3 (vector-vector-distance-squared s4-0 s1-0)))
          (when (or (< f30-0 0.0) (< f0-3 f30-0))
            (set! f30-0 f0-3)
            (set! (-> s5-0 quad) (-> s1-0 quad))
            )
          )
        )
      )
    (vector-! (-> arg0 vector) s5-0 s4-0)
    )
  )




