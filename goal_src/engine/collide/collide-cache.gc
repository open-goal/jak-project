;;-*-Lisp-*-
(in-package goal)

;; name: collide-cache.gc
;; name in dgo: collide-cache
;; dgos: GAME, ENGINE

(defmethod debug-draw collide-cache ((obj collide-cache))
  "Debug draw all the things in the collide cache!"
  (let ((gp-0 (the-as collide-cache-tri (-> obj tris))))
    (countdown (s4-0 (-> obj num-tris))
      (let ((t1-0 (copy-and-set-field (-> *pat-mode-info* (-> gp-0 pat mode) color) a 64)))
        (add-debug-flat-triangle
          #t
          (bucket-id debug-draw1)
          (the-as vector (-> gp-0 vertex))
          (-> gp-0 vertex 1)
          (-> gp-0 vertex 2)
          t1-0
          )
        )
      (&+! gp-0 64)
      )
    )
  (let ((gp-1 (the-as collide-cache-prim (-> obj prims))))
    (countdown (s5-1 (-> obj num-prims))
      (when (= (-> gp-1 prim-core prim-type) -1)
        (let ((t0-1
                (copy-and-set-field
                  (-> *pat-mode-info* (-> (the-as collide-shape-prim-sphere (-> gp-1 prim)) pat mode) color)
                  a
                  64
                  )
                )
              )
          (add-debug-sphere
            #t
            (bucket-id debug-draw1)
            (the-as vector (-> gp-1 prim-core))
            (-> gp-1 prim-core world-sphere w)
            t0-1
            )
          )
        )
      (&+! gp-1 48)
      )
    )
  0
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;;;;
;; Setup
;;;;;;;;;;;;;;;;;;;;;;;;

(define *already-printed-exeeded-max-cache-tris* #f)

(defmethod initialize collide-cache ((obj collide-cache))
  "Clear the collide-cache."
  (set! (-> obj num-tris) 0)
  (set! (-> obj num-prims) 0)
  (set! (-> obj proc) #f)
  (set! *already-printed-exeeded-max-cache-tris* #f)
  (none)
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fill using Bounding Box
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; As is typcial of ND, this is complicated.
;; We have 3 stages for loading the background mesh.
;; 1). We acquire mesh fragments. This can be with bsp methods or collide probe.
;; 2). We upload these meshes to VU0 data memory and unpack.
;; 3). We run the unpack function which downloads them with vlqi and puts the spad.
;; 4). We run the filter by box function to download only tris in the box into the cache.

(defmethod-mips2c "(method 26 collide-cache)" 26 collide-cache)
(defmethod-mips2c "(method 32 collide-cache)" 32 collide-cache)
(def-mips2c __pc-upload-collide-frag (function object object object none))


(defmethod fill-from-background collide-cache ((obj collide-cache)
                                               (bsp-find-mesh-func (function bsp-header int collide-list none))
                                               (import-mesh-func (function collide-cache object none))
                                               )
  "This terrible function fills the collide cache with background tris from a bounding box."
  
  (local-vars (r0-0 none) (a0-4 int) (a0-6 int))
  
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Step 1: Build Collide List
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
  ;; this is a list of fragments that we will look at.
  
  
  (set! (-> *collide-list* num-items) 0)
  (cond
    ((= bsp-find-mesh-func (method-of-type bsp-header collide-ray))
     ;; for collide-ray (actually line-sphere), we have a fancy version.
     (dotimes (s4-1 (-> *level* length))
       (let ((a0-2 (-> *level* level s4-1)))
         (when (= (-> a0-2 status) 'active)
           (reset! (-> *perf-stats* data 14))
           (collide-probe-make-list a0-2 *collide-list*)
           (read! (-> *perf-stats* data 14))
           )
         )
       )
     )
    (else
      ;; for the othes, we don't have a fancy version, so use the versio provided by the user.
      (dotimes (s3-0 (-> *level* length))
        (let ((v1-21 (-> *level* level s3-0)))
          (if (= (-> v1-21 status) 'active)
              (bsp-find-mesh-func (-> v1-21 bsp) 0 *collide-list*)
              )
          )
        )
      )
    )
  
  (when (> (-> *collide-list* num-items) 0)
    (format *stdcon* "got ~D~%" (-> *collide-list* num-items))
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Step 2: Upload to VU0 Data
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; in classic ND style, this is double buffered.
    ;; we'll undo this.
    (dotimes (i (-> *collide-list* num-items))
      (let ((frag (-> *collide-list* items i)))

          ;; to VU0 memory
          (__pc-upload-collide-frag (-> frag mesh packed-data) (-> frag mesh vertex-data-qwc) (-> frag mesh vertex-count))
          ;; from VU0 memory to scratchpad
          (unpack-background-collide-mesh obj (-> frag mesh) (-> frag inst) 0)
          ;; from scratchpad to collide-cache memory.
          (import-mesh-func obj (-> frag mesh))
          
        
        )
      )
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Fake it as a prim
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    
    ;; The old system can actually read out lists of prims.
    ;; Note that this assumes the cache has been emptied and we're the first to fill it here.
    
    (let ((a0-28 (-> obj num-tris)))
      (when (> a0-28 0)
        (let ((v1-55 (-> obj prims))
              (a1-17 *collide-shape-prim-backgnd*)
              )
          (set! (-> v1-55 0 num-tris) (the-as uint a0-28))
          (set! (-> v1-55 0 prim) a1-17)
          (set! (-> obj num-prims) 1)
          (set! (-> v1-55 0 first-tri) (the-as uint 0))
          (set! (-> v1-55 0 ccache) obj)
          (set! (-> v1-55 0 prim-core world-sphere quad) (-> a1-17 prim-core world-sphere quad))
          (set! (-> v1-55 0 prim-core quad 1) (-> a1-17 prim-core quad 1))
          )
        )
      )
    
    (format *stdcon* "~d tris~%" (-> obj num-tris))
    )
  0
  (none)
  )

(defmethod fill-from-water collide-cache ((obj collide-cache) (arg0 water-control))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (when (= (-> obj num-prims) 100)
      (if (= *cheat-mode* 'debug)
          (format 0 "ERROR: Exceeded max number of collide-cache prims!~%")
          )
      (return #f)
      )
    (when (< 460 (+ (-> obj num-tris) 2))
      (when (not *already-printed-exeeded-max-cache-tris*)
        (set! *already-printed-exeeded-max-cache-tris* #t)
        (if (= *cheat-mode* 'debug)
            (format *stdcon* "Exceeded collide cache max # of tris!~%")
            )
        )
      (return #f)
      )
    (if (not
          (and (logtest? (-> arg0 flags) 2) (logtest? (-> arg0 flags) 144) (zero? (logand #x10000 (-> arg0 flags))))
          )
        (return #f)
        )
    (let ((v1-28 (cond
                   ((logtest? (-> *target* control root-prim prim-core action) (collide-action ca-9))
                    (+ -819.2 (-> arg0 height))
                    )
                   ((logtest? (-> arg0 flags) 16)
                    (- (-> arg0 height) (-> arg0 swim-height))
                    )
                   (else
                     (- (-> arg0 base-height) (-> arg0 bottom-height))
                     )
                   )
                 )
          )
      (.lvf vf1 (&-> obj collide-box min quad))
      (.lvf vf3 (&-> obj collide-box max quad))
      (let ((a1-6 (-> obj num-prims-u))
            (a2-8 (the-as (inline-array collide-cache-tri) (-> obj tris (-> obj num-tris))))
            )
        (.mov vf5 v1-28)
        (.add.x.vf vf1 vf0 vf5 :mask #b10)
        (set! (-> a2-8 0 extra-quad) (the-as uint128 0))
        (set! (-> a2-8 0 prim-index) a1-6)
        (.add.x.vf vf3 vf0 vf5 :mask #b10)
        (set! (-> a2-8 1 extra-quad) (the-as uint128 0))
        (set! (-> a2-8 1 prim-index) a1-6)
        (.mov.vf vf2 vf1)
        (.mov.vf vf4 vf1)
        (.add.z.vf vf2 vf0 vf3 :mask #b100)
        (.add.x.vf vf4 vf0 vf3 :mask #b1)
        (.svf (&-> a2-8 0 vertex 0 quad) vf1)
        (.svf (&-> a2-8 0 vertex 1 quad) vf2)
        (.svf (&-> a2-8 0 vertex 2 quad) vf3)
        (set! (-> a2-8 0 pat) (new 'static 'pat-surface :material (pat-material waterbottom)))
        (.svf (&-> a2-8 1 vertex 0 quad) vf1)
        (.svf (&-> a2-8 1 vertex 1 quad) vf3)
        (.svf (&-> a2-8 1 vertex 2 quad) vf4)
        (set! (-> a2-8 1 pat) (new 'static 'pat-surface :material (pat-material waterbottom)))
        )
      )
    (let ((v1-33 *collide-shape-prim-water*)
          (a1-10 (-> obj prims (-> obj num-prims)))
          )
      (set! (-> a1-10 first-tri) (the-as uint (-> obj num-tris)))
      (set! (-> a1-10 num-tris) (the-as uint 2))
      (set! (-> a1-10 prim) v1-33)
      (set! (-> a1-10 ccache) obj)
      (set! (-> a1-10 prim-core world-sphere quad) (-> v1-33 prim-core world-sphere quad))
      (set! (-> a1-10 prim-core quad 1) (-> v1-33 prim-core quad 1))
      )
    (+! (-> obj num-prims) 1)
    (+! (-> obj num-tris) 2)
    (none)
    )
  )

(defmethod fill-using-bounding-box collide-cache ((obj collide-cache) (arg0 bounding-box) (arg1 collide-kind) (arg2 process-drawable) (arg3 pat-surface))
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 (new 'static 'vector :x 0.5)))
      (nop!)
      (.lvf vf1 (&-> arg0 min quad))
      (nop!)
      (.lvf vf2 (&-> arg0 max quad))
      (nop!)
      (set! (-> obj proc) arg2)
      (.mov.vf vf1 vf0 :mask #b1000)
      (let ((a0-1 *collide-work*))
        (.mov.vf vf2 vf0 :mask #b1000)
        (set! (-> obj ignore-mask) arg3)
        (.ftoi.vf vf3 vf1)
        (.lvf vf6 (&-> v1-0 quad))
        (.ftoi.vf vf4 vf2)
        (set! (-> obj num-tris) 0)
        (.add.vf vf5 vf2 vf1 :mask #b111)
        (.svf (&-> obj collide-box min quad) vf1)
        (.mul.x.vf vf5 vf5 vf6 :mask #b111)
        (.svf (&-> obj collide-box max quad) vf2)
        (.sub.vf vf7 vf5 vf1 :mask #b111)
        (.sub.vf vf5 vf5 vf5 :mask #b1000)
        (.mul.vf vf7 vf7 vf7 :mask #b111)
        (.svf (&-> obj collide-box4w min quad) vf3)
        (.add.y.vf vf7 vf7 vf7 :mask #b1)
        (.svf (&-> obj collide-box4w max quad) vf4)
        (.add.z.vf vf7 vf7 vf7 :mask #b1)
        (.svf (&-> a0-1 collide-box4w min quad) vf3)
        (.sqrt.vf Q vf7 :ftf #b0)
        (.svf (&-> a0-1 collide-box4w max quad) vf4)
        (set! *already-printed-exeeded-max-cache-tris* #f)
        (nop!)
        (.wait.vf)
        (set! (-> obj num-prims) 0)
        (.sub.vf vf5 vf5 Q :mask #b1000)
        (set! (-> obj collide-with) arg1)
        (nop!)
        (.svf (&-> a0-1 collide-sphere-neg-r quad) vf5)
        )
      )
    0
    (if (logtest? arg1 (collide-kind background))
        (fill-from-background
          obj
          (method-of-type bsp-header collide-with-box)
          (method-of-type collide-cache load-mesh-from-spad-in-box)
          )
        )
    (if (logtest? arg1 (collide-kind water))
        (fill-from-water obj (-> arg2 water))
        )
    (if (logtest? arg1 (collide-kind cak-1 cak-2 cak-3 target))
        (fill-from-foreground-using-spheres obj)
        )
    0
    (none)
    )
  )

(defun collide-cache-using-box-test ((arg0 vector))
  (local-vars (v1-1 int))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (init-vf0-vector)
   (nop!)
   (.max.w.vf vf3 vf0 vf0)
   (let ((v1-0 *collide-work*))
    (nop!)
    (.lvf vf1 (&-> arg0 quad))
    (nop!)
    (.lvf vf2 (&-> v1-0 collide-sphere-neg-r quad))
    )
   (.sub.vf vf1 vf1 vf2)
   (nop!)
   (.mul.vf vf1 vf1 vf1)
   (nop!)
   (.mul.x.vf acc vf3 vf1)
   (nop!)
   (.add.mul.y.vf acc vf3 vf1 acc)
   (nop!)
   (.add.mul.z.vf acc vf3 vf1 acc)
   (nop!)
   (.sub.mul.w.vf vf1 vf3 vf1 acc)
   (nop!)
   (.mov v1-1 vf1)
   (<= (the-as int v1-1) 0)
   )
  )

(defmethod collide-with-box collide-fragment ((obj collide-fragment) (arg0 int) (arg1 collide-list))
  (let ((s3-0 *collide-work*))
    (dotimes (s2-0 arg0)
      (when (and (collide-cache-using-box-test (-> obj bsphere))
                 (drawable-sphere-box-intersect? obj (-> s3-0 collide-box4w))
                 )
        (let ((v1-5 (-> arg1 items (-> arg1 num-items))))
          (set! (-> v1-5 mesh) (-> obj mesh))
          (set! (-> v1-5 inst) #f)
          )
        (+! (-> arg1 num-items) 1)
        )
      (&+! obj 32)
      )
    )
  0
  (none)
  )

(defmethod collide-with-box instance-tie ((obj instance-tie) (arg0 int) (arg1 collide-list))
  (dotimes (s3-0 arg0)
    (when (and (zero? (logand (-> obj flags) 1))
               (collide-cache-using-box-test (-> obj bsphere))
               (drawable-sphere-box-intersect? obj (-> *collide-work* collide-box4w))
               )
      (let ((s2-0 (-> obj bucket-ptr collide-frag)))
        (when (nonzero? s2-0)
          (let ((s1-0 (the-as object (-> s2-0 data))))
            (dotimes (s0-0 (-> s2-0 length))
              (when (instance-sphere-box-intersect? (the-as collide-fragment s1-0) obj (-> *collide-work* collide-box4w))
                (let ((v1-12 (-> arg1 items (-> arg1 num-items))))
                  (set! (-> v1-12 mesh) (-> (the-as collide-fragment s1-0) mesh))
                  (set! (-> v1-12 inst) obj)
                  )
                (+! (-> arg1 num-items) 1)
                )
              (set! s1-0 (-> (the-as (inline-array collide-fragment) s1-0) 1))
              )
            )
          )
        )
      )
    (&+! obj 64)
    )
  0
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;
;; Line Sphere Test
;;;;;;;;;;;;;;;;;;;;;

;; In this mode, we collide a line of spheres.
;; The first pass sets up a non-axis-aligned bounding box in *collide-work*
;; The box is stored as an axis-aligned box, and an inv-rot to transform from world to aligned-box coordinates.


(defun collide-cache-using-line-sphere-test ((arg0 vector))
  "Check if the input sphere is in the rotated bounding box volume of the current
   line-sphere query."
  (local-vars
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (a0-1 uint128)
    (a1-2 uint128)
    (a2-0 uint128)
    (zero uint128)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (set! zero (the uint128 0))
    (let ((a1-0 *collide-work*))
      (.lvf vf5 (&-> arg0 quad))
      (.lvf vf4 (&-> a1-0 inv-mat vector 3 quad))
      (.lvf vf1 (&-> a1-0 inv-mat vector 0 quad))
      (.mul.w.vf acc vf4 vf0)
      (.lvf vf2 (&-> a1-0 inv-mat vector 1 quad))
      (.add.mul.x.vf acc vf1 vf5 acc)
      (.lvf vf3 (&-> a1-0 inv-mat vector 2 quad))
      (.add.mul.y.vf acc vf2 vf5 acc)
      (let ((v1-0 (-> a1-0 collide-box4w min quad)))
        (.add.mul.z.vf vf10 vf3 vf5 acc)
        (let ((a1-1 (-> a1-0 collide-box4w max quad)))
          (.sub.w.vf vf6 vf10 vf5 :mask #b111)
          (.add.w.vf vf7 vf10 vf5 :mask #b111)
          (.ftoi.vf vf8 vf6)
          (.ftoi.vf vf9 vf7)
          (.mov a2-0 vf8)
          (.mov a0-1 vf9)
          (.pcgtw a1-2 a2-0 a1-1)
          )
        (.pcgtw v1-1 v1-0 a0-1)
        )
      )
    (.por v1-2 a1-2 v1-1)
    (.ppach v1-3 zero v1-2)
    (let ((v1-4 (shl (the-as int v1-3) 16)))
      (nop!)
      (zero? v1-4)
      )
    )
  )


(defun make-collide-list-using-line-sphere-inst-test ((arg0 collide-fragment) (arg1 instance-tie))
  "Check if a collide-fragment at a given instance is in the rotated bounding box volume
   of the current line-sphere query."
  (local-vars (v1-1 uint128) (v1-2 uint128) (v1-3 uint128) (v1-4 uint128) (a1-2 uint128) (a2-1 uint128)
    (a3-1 uint128) (a3-3 uint128) (a3-4 uint128) (t0-1 uint128) (t0-2 uint128) (t1-0 uint128) (t2-1 uint128)
    (t2-2 uint128) (zero uint128))
  (rlet ((acc :class vf) (vf0 :class vf) (vf1 :class vf) (vf10 :class vf) (vf11 :class vf) (vf12 :class vf)
         (vf13 :class vf) (vf14 :class vf) (vf15 :class vf) (vf2 :class vf) (vf3 :class vf) (vf4 :class vf)
         (vf5 :class vf) (vf6 :class vf) (vf7 :class vf) (vf8 :class vf) (vf9 :class vf))
    (init-vf0-vector)
    (set! zero (the uint128 0))
    (let ((v1-0 *collide-work*))
      (let ((a2-0 (-> arg1 max-scale)))
        (let ((a3-0 (the-as uint128 (-> arg1 origin vector4h 3 long))))
          (let ((t2-0 (the-as uint128 (-> arg1 origin vector4h 0 long))))
            (.pextlh a3-1 a3-0 zero)
            (let ((t0-0 (the-as uint128 (-> arg1 origin vector4h 1 long))))
              (.pw.sra t1-0 a3-1 10)
              (let ((a3-2 (the-as uint128 (-> arg1 origin vector4h 2 long))))
                (.pextlh t2-1 t2-0 zero)
                (.pw.sra t2-2 t2-1 16)
                (.pextlh t0-1 t0-0 zero)
                (.mov vf4 t1-0)
                (.pw.sra t0-2 t0-1 16)
                (.mov vf1 t2-2)
                (.pextlh a3-3 a3-2 zero)
                )
              )
            )
          )
        (.mov vf2 t0-2)
        (.pw.sra a3-4 a3-3 16)
        (.lvf vf5 (&-> arg1 bsphere quad))
        (.mov vf3 a3-4)
        (.mov vf6 a2-0)
        )
      (.itof.vf vf4 vf4)
      (vitof12.xyzw vf1 vf1)
      (vitof12.xyzw vf2 vf2)
      (vitof12.xyzw vf3 vf3)
      (.add.vf vf4 vf4 vf5 :mask #b111)
      (.lvf vf5 (&-> arg0 bsphere quad))
      (vitof12.xyzw vf6 vf6)
      (.mul.x.vf acc vf1 vf5)
      (.add.mul.y.vf acc vf2 vf5 acc)
      (.add.mul.z.vf acc vf3 vf5 acc)
      (.add.mul.w.vf vf11 vf4 vf0 acc)
      (.lvf vf7 (&-> v1-0 inv-mat vector 0 quad))
      (.lvf vf8 (&-> v1-0 inv-mat vector 1 quad))
      (.lvf vf9 (&-> v1-0 inv-mat vector 2 quad))
      (.lvf vf10 (&-> v1-0 inv-mat vector 3 quad))
      (.mul.x.vf acc vf7 vf11)
      (let ((a0-1 (-> v1-0 collide-box4w min quad)))
        (.add.mul.y.vf acc vf8 vf11 acc)
        (let ((a1-1 (-> v1-0 collide-box4w max quad)))
          (.add.mul.z.vf acc vf9 vf11 acc)
          (.add.mul.w.vf vf11 vf10 vf0 acc)
          (.mul.w.vf vf15 vf6 vf5 :mask #b1)
          (.add.x.vf vf12 vf11 vf15 :mask #b111)
          (.sub.x.vf vf11 vf11 vf15 :mask #b111)
          (.ftoi.vf vf14 vf12)
          (.ftoi.vf vf13 vf11)
          (.mov v1-1 vf14)
          (.mov a2-1 vf13)
          (.pcgtw a1-2 a2-1 a1-1)
          )
        (.pcgtw v1-2 a0-1 v1-1)
        )
      )
    (.por v1-3 a1-2 v1-2)
    (.ppach v1-4 zero v1-3)
    (let ((v1-5 (shl (the-as int v1-4) 16)))
      (nop!)
      (zero? v1-5)
      )
    )
  )


(defmethod collide-ray collide-fragment ((obj collide-fragment) (arg0 int) (arg1 collide-list))
  "Inline-array function to do line-sphere with non-instanced fragments.
   If the bsphere of the mesh is in the non-aligned bounding box, the mesh will be added
   to the given collide-list.
   Note: collide-probe is the faster implementation of this."
  *collide-work*
  
  ;; just iterate over all and check their bsphere.
  (dotimes (s3-0 arg0)
    (when (collide-cache-using-line-sphere-test (-> obj bsphere))
      (let ((v1-5 (-> arg1 items (-> arg1 num-items))))
        (set! (-> v1-5 mesh) (-> obj mesh))
        (set! (-> v1-5 inst) #f) ;; non-instanced.
        )
      (+! (-> arg1 num-items) 1)
      )
    (&+! obj 32)
    )
  0
  (none)
  )


(defmethod collide-ray instance-tie ((obj instance-tie) (arg0 int) (arg1 collide-list))
  "Inline-array function to do line-sphere with TIE instances.
  If the bsphere of the mesh is in the non-aligned bounding box, the mesh will be added
  to the given collide-list.
  Note: collide-probe is the faster implementation of this."
  
  ;; loop over instance-ties
  (dotimes (s3-0 arg0)
    ;; first check the instance-tie's bsphere
    (when (and (zero? (logand (-> obj flags) 1)) (collide-cache-using-line-sphere-test (-> obj bsphere)))
      ;; now, find the collide-frag
      (let ((s2-0 (-> obj bucket-ptr collide-frag)))
        (when (nonzero? s2-0)
          (let ((s1-0 (the-as object (-> s2-0 data))))
            ;; and check each mesh in the collide-frag
            (dotimes (s0-0 (-> s2-0 length))
              (when (make-collide-list-using-line-sphere-inst-test (the-as collide-fragment s1-0) obj)
                (let ((v1-10 (-> arg1 items (-> arg1 num-items))))
                  (set! (-> v1-10 mesh) (-> (the-as collide-fragment s1-0) mesh))
                  (set! (-> v1-10 inst) obj)
                  )
                (+! (-> arg1 num-items) 1)
                )
              (set! s1-0 (-> (the-as (inline-array collide-fragment) s1-0) 1))
              )
            )
          )
        )
      )
    (&+! obj 64)
    )
  0
  (none)
  )