;;-*-Lisp-*-
(in-package goal)

;; name: collide-edge-grab.gc
;; name in dgo: collide-edge-grab
;; dgos: GAME, ENGINE

(define-extern *rotate-surface* surface) ;; unknown type
(define-extern *no-walk-surface* surface) ;; unknown type

;; DECOMP BEGINS

(defmethod find-edge-grabs! target ((obj target) (arg0 collide-cache))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (let ((gp-0 *collide-edge-work*))
      (set! (-> gp-0 num-verts) (the-as uint 0))
      (set! (-> gp-0 num-edges) (the-as uint 0))
      (set! (-> gp-0 num-tris) (the-as uint 0))
      (let ((v1-0 (-> obj control)))
        (set! (-> gp-0 ccache) arg0)
        (.lvf vf1 (&-> gp-0 local-cache-fill-box min quad))
        (.lvf vf2 (&-> gp-0 local-cache-fill-box max quad))
        (set! (-> gp-0 cshape) v1-0)
        (.lvf vf3 (&-> v1-0 trans quad))
        )
      (.add.vf vf1 vf1 vf3 :mask #b111)
      (.add.vf vf2 vf2 vf3 :mask #b111)
      (.svf (&-> gp-0 cache-fill-box min quad) vf1)
      (.svf (&-> gp-0 cache-fill-box max quad) vf2)
      (.lvf vf4 (&-> gp-0 local-within-reach-box min quad))
      (.lvf vf5 (&-> gp-0 local-within-reach-box max quad))
      (.add.vf vf4 vf4 vf3 :mask #b111)
      (.add.vf vf5 vf5 vf3 :mask #b111)
      (.ftoi.vf vf6 vf4)
      (.ftoi.vf vf7 vf5)
      (.svf (&-> gp-0 within-reach-box min quad) vf4)
      (.svf (&-> gp-0 within-reach-box max quad) vf5)
      (.svf (&-> gp-0 within-reach-box4w min quad) vf6)
      (.svf (&-> gp-0 within-reach-box4w max quad) vf7)
      (fill-using-bounding-box
        arg0
        (-> gp-0 cache-fill-box)
        (-> obj control root-prim collide-with)
        obj
        (new 'static 'pat-surface :skip #x1 :noentity #x1)
        )
      (find-grabbable-tris! gp-0)
      (when (nonzero? (-> gp-0 num-tris))
        (dummy-15 gp-0)
        (when (nonzero? (-> gp-0 num-edges))
          (set! (-> gp-0 search-pt quad) (-> *target* control unknown-vector90 quad))
          (when (!= (-> *cpad-list* cpads (-> *target* control unknown-cpad-info00 number) stick0-speed) 0.0)
            (set! (-> gp-0 search-dir-vec quad) (-> *target* control unknown-vector20 quad))
            (dummy-9 gp-0 (-> gp-0 hold-list))
            (when (dummy-18 gp-0 (-> gp-0 hold-list) *edge-grab-info*)
              (send-event *target* 'edge-grab)
              (return (the-as object #f))
              )
            )
          (vector-z-quaternion! (-> gp-0 search-dir-vec) (-> *target* control unknown-quaternion00))
          (dummy-9 gp-0 (-> gp-0 hold-list))
          (if (dummy-18 gp-0 (-> gp-0 hold-list) *edge-grab-info*)
              (send-event *target* 'edge-grab)
              )
          0
          )
        )
      )
    0
    )
  )

(defmethod dummy-9 collide-edge-work ((obj collide-edge-work) (arg0 collide-edge-hold-list))
  (set! (-> arg0 num-allocs) (the-as uint 0))
  (set! (-> arg0 num-attempts) (the-as uint 0))
  (set! (-> arg0 head) #f)
  (let ((s4-0 (the-as object (-> arg0 items)))
        (s3-0 (the-as object (-> obj edges)))
        )
    (countdown (s2-0 (-> obj num-edges))
      (when (not (-> (the-as collide-edge-edge s3-0) ignore))
        (dummy-13 obj (the-as collide-edge-hold-item s3-0) (-> (the-as collide-edge-hold-item s4-0) center-pt))
        (when (dummy-17 obj)
          (dummy-10 arg0 (the-as collide-edge-hold-item s4-0))
          (+! (-> arg0 num-allocs) 1)
          (when (= (-> arg0 num-allocs) 32)
            (format 0 "ERROR: Reached limit of edge grab hold items!~%")
            (return #f)
            )
          (set! s4-0 (-> (the-as (inline-array collide-edge-hold-item) s4-0) 1))
          )
        )
      (set! s3-0 (-> (the-as (inline-array collide-edge-edge) s3-0) 1))
      )
    )
  #f
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(deftype pbhp-stack-vars (structure)
  ((edge        collide-edge-edge         :offset-assert   0)
   (allocated   basic                     :offset-assert   4)
   (neg-hold-pt vector            :inline :offset-assert  16)
   (split-vec   vector            :inline :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )


;; ERROR: function was not converted to expressions. Cannot decompile.

;; WARN: Type Propagation failed: Failed type prop at op 155 ((set! a2 (l.wu a1))): Could not get type of load: (set! a2 (l.wu a1)). 

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod dummy-14 collide-edge-work ((obj collide-edge-work) (arg0 vector) (arg1 vector) (arg2 int))
  (let ((f30-0 -1.0))
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (dotimes (s1-0 (the-as int (-> obj num-edges)))
        (let ((v1-3 (-> obj edges s1-0)))
          (when (not (-> v1-3 ignore))
            (when (= (-> v1-3 etri ctri prim-index) arg2)
              (let ((f0-0 (vector-segment-distance-point! arg1 (-> v1-3 vertex-ptr 0 0) (-> v1-3 vertex-ptr 1 0) s2-0)))
                (when (or (< f30-0 0.0) (< f0-0 f30-0))
                  (set! f30-0 f0-0)
                  (set! (-> arg0 quad) (-> s2-0 quad))
                  )
                )
              )
            )
          )
        )
      )
    f30-0
    )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod dummy-10 edge-grab-info ((obj edge-grab-info))
  (add-debug-line
    #t
    (bucket-id debug-draw1)
    (the-as vector (-> obj world-vertex))
    (-> obj world-vertex 1)
    (new 'static 'rgba :r #xff :a #x60)
    #f
    (the-as rgba -1)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-draw1)
    (-> obj center-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x80)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-draw1)
    (-> obj left-hand-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x60)
    )
  (add-debug-sphere
    #t
    (bucket-id debug-draw1)
    (-> obj right-hand-hold)
    204.8
    (new 'static 'rgba :r #xff :g #xff :a #x60)
    )
  (add-debug-outline-triangle
    #t
    (bucket-id debug-draw1)
    (the-as vector (-> obj tri-vertex))
    (-> obj world-vertex 4)
    (-> obj world-vertex 5)
    (new 'static 'rgba :r #xff :a #x30)
    )
  (the-as symbol (cond
                   ((nonzero? (-> obj actor-cshape-prim-offset))
                    (if (handle->process (-> obj actor-handle))
                        (format *stdcon* "grab: ~A~%" (-> obj actor-handle process 0 name))
                        (format *stdcon* "grab: invalid handle~%")
                        )
                    )
                   (else
                     (format *stdcon* "grab: ground~%")
                     )
                   )
          )
  )

(defmethod debug-draw-edges collide-edge-work ((obj collide-edge-work))
  (let ((gp-0 0))
    (dotimes (s4-0 (the-as int (-> obj num-edges)))
      (let* ((s3-0 (-> obj edges s4-0))
             (a2-0 (-> s3-0 vertex-ptr 0 0))
             (a3-0 (-> s3-0 vertex-ptr 1 0))
             (s2-0 (new 'stack-no-clear 'vector))
             )
        (vector+! s2-0 a2-0 a3-0)
        (vector-float*! s2-0 s2-0 0.5)
        (cond
          ((-> s3-0 ignore)
           (add-debug-line
             #t
             (bucket-id debug-draw1)
             a2-0
             a3-0
             (new 'static 'rgba :r #x7f :g #x7f :b #x7f :a #x50)
             #f
             (the-as rgba -1)
             )
           (+! gp-0 1)
           )
          (else
            (add-debug-line
              #t
              (bucket-id debug-draw1)
              a2-0
              a3-0
              (new 'static 'rgba :r #xff :g #xff :b #xff :a #x60)
              #f
              (the-as rgba -1)
              )
            (add-debug-vector
              #t
              (bucket-id debug-draw1)
              s2-0
              (-> s3-0 outward)
              (meters 0.3)
              (new 'static 'rgba :r #xff :a #x80)
              )
            )
          )
        )
      )
    (format *stdcon* "found ~D edges (and ~D ignored)~%" (- (-> obj num-edges) (the-as uint gp-0)) gp-0)
    )
  )

(defmethod debug-draw-sphere collide-edge-work ((obj collide-edge-work))
  (dotimes (s5-0 (the-as int (-> obj num-verts)))
    (let ((a2-0 (-> obj verts s5-0)))
      (add-debug-sphere #t (bucket-id debug-draw1) a2-0 819.2 (new 'static 'rgba :r #xff :g #xff :a #x80))
      )
    )
  #f
  )

(defmethod debug-draw collide-edge-hold-list ((obj collide-edge-hold-list))
  (let ((s4-0 (-> obj head))
        (s5-0 0)
        )
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s2-0 #t)
          )
      (set! (-> s3-0 quad) (-> *target* control unknown-vector90 quad))
      (while s4-0
        (+! s5-0 1)
        (set! (-> s3-0 y) (-> s4-0 center-pt y))
        (add-debug-sphere #t (bucket-id debug-draw1) s3-0 409.6 (new 'static 'rgba :a #x80))
        (cond
          (s2-0
            (set! s2-0 #f)
            (add-debug-sphere
              #t
              (bucket-id debug-draw1)
              (-> s4-0 center-pt)
              614.4
              (new 'static 'rgba :r #xff :g #xff :a #x80)
              )
            (add-debug-sphere #t (bucket-id debug-draw1) (-> s4-0 outward-pt) 409.6 (new 'static 'rgba :r #xff :a #x80))
            )
          (else
            (add-debug-sphere
              #t
              (bucket-id debug-draw1)
              (-> s4-0 center-pt)
              614.4
              (new 'static 'rgba :r #x7f :g #x7f :a #x40)
              )
            (add-debug-sphere #t (bucket-id debug-draw1) (-> s4-0 outward-pt) 409.6 (new 'static 'rgba :r #x7f :a #x40))
            )
          )
        (set! s4-0 (-> s4-0 next))
        )
      )
    (format *stdcon* "hold list has ~D item(s)~%" s5-0)
    )
  (dotimes (s5-1 (the-as int (-> obj num-attempts)))
    (add-debug-sphere
      #t
      (bucket-id debug-draw1)
      (the-as vector (-> obj attempts s5-1))
      409.6
      (new 'static 'rgba :a #x40)
      )
    )
  (format *stdcon* "hold list has ~D attempt(s)~%" (-> obj num-attempts))
  )

(defmethod dummy-11 collide-edge-work ((obj collide-edge-work))
  (dotimes (s5-0 (the-as int (-> obj num-tris)))
    (let* ((v1-3 (-> obj tris s5-0 ctri))
           (t1-0 (copy-and-set-field (-> *pat-mode-info* (-> v1-3 pat mode) color) a 64))
           )
      (add-debug-outline-triangle
        #t
        (bucket-id debug-draw1)
        (the-as vector (-> v1-3 vertex))
        (-> v1-3 vertex 1)
        (-> v1-3 vertex 2)
        t1-0
        )
      )
    )
  (none)
  )

(let ((v1-1
        (new 'static 'surface
          :name '*rotate-surface*
          :turnv 1.0
          :turnvv 1.0
          :tiltv 1.0
          :tiltvv 1.0
          :transv-max 1.0
          :target-speed 1.0
          :seek0 153600.0
          :seek90 153600.0
          :seek180 256000.0
          :fric 153600.0
          :nonlin-fric-dist 5120.0
          :slip-factor 1.0
          :slope-down-factor 10240.0
          :slope-slip-angle 8192.0
          :impact-fric 1.0
          :bend-factor 0.8
          :bend-speed 4.0
          :alignv 1.0
          :slope-up-traction 1.0
          :align-speed 1.0
          :flags #x4000
          )
        )
      )
  (set! *rotate-surface* v1-1)
  (set! (-> v1-1 mult-hook)
        (the-as
          (function surface surface surface int none)
          (lambda ((arg0 surface) (arg1 object) (arg2 object) (arg3 int)) (when (= arg3 1)
                                                                            (let ((f0-0 151756.8))
                                                                              (set! (-> arg0 fric) f0-0)
                                                                              f0-0
                                                                              )
                                                                            )
                  )
          )
        )
  (set! (-> v1-1 touch-hook) nothing)
  (set! (-> v1-1 active-hook) nothing)
  )

(let ((v1-2 (new 'static 'surface
              :name '*no-walk-surface*
              :turnv 0.5
              :turnvv 1.0
              :tiltv 1.0
              :tiltvv 1.0
              :transv-max 0.7
              :target-speed 0.7
              :seek0 24576.0
              :seek90 24576.0
              :seek180 24576.0
              :fric 23756.8
              :nonlin-fric-dist 4091904.0
              :slope-slip-angle 16384.0
              :bend-speed 4.0
              :alignv 0.5
              :slope-up-traction 0.9
              :align-speed 1.0
              :flags #x28
              )
            )
      )
  (set! *no-walk-surface* v1-2)
  (set! (-> v1-2 mult-hook) (the-as (function surface surface surface int none) nothing))
  (set! (-> v1-2 touch-hook) nothing)
  (set! (-> v1-2 active-hook) nothing)
  )




