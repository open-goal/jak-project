;;-*-Lisp-*-
(in-package goal)

;; name: vu1-macros.gc
;; name in dgo: vu1-macros
;; dgos: GAME, ENGINE

;; this file has no code!

(defmacro vu-clip (vfr cf)
  "Returns the result of VCLIP.
   NOTE: this implementation is pretty inefficient.
   If this ends up used a lot, it's probably worth rewriting.
   "
  `(let ((vec (new 'stack 'vector))
         (flag ,cf)
         )
     (.svf vec ,vfr)
     (let* ((w-plus (fabs (-> vec w)))
            (w-minus (- 0.0 w-plus))
            )
       ;; CF = CF << 6
       (set! flag (logand #xffffff (shl flag 6)))

       (when (> (-> vec x) w-plus)
         (logior! flag 1)
         )
       (when (< (-> vec x) w-minus)
         (logior! flag 2)
         )
       (when (> (-> vec y) w-plus)
         (logior! flag 4)
         )
       (when (< (-> vec y) w-minus)
         (logior! flag 8)
         )
       (when (> (-> vec z) w-plus)
         (logior! flag 16)
         )
       (when (< (-> vec z) w-minus)
         (logior! flag 32)
         )
       )
     flag
     )
  )


(defmacro vftoi4.xyzw (dst src)
  "convert to 28.4 integer. This does the multiply while the number is still
   a float. This will have issues for very large floats, but it seems like this
   is how PCSX2 does it as well, so maybe it's right?
   NOTE: this is the only version of the instruction used in Jak 1, so we
   don't need to worry about masks."

  `(begin
    (rlet ((temp :class vf))
      (set! temp 16.0)
      (.mul.x.vf temp ,src temp)
      (.ftoi.vf ,dst temp)
      )
    )
  )
