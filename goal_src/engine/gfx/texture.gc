;;-*-Lisp-*-
(in-package goal)

;; name: texture.gc
;; name in dgo: texture
;; dgos: GAME, ENGINE

;; Texture System:
;;  texture-page is what is stored on the DVD.  Each tpage file contains a single texture-page.
;;  each texture-page has between 1 and 3 segments containing the actual texture data to load into vram
;;  Data is loaded into VRAM by segment. You must load the whole segment, and you cannot split up a segment.
;;  Each segment contains a number of textures.
;; The "texture" objects are just a record that tells you where the texture is within the segment.
;; This is the "dest", specified as a vram word (32-bit) index, relative to the start of the texture page data.

;; Generally, "dest" refers to a location in vram, specified in 32-bit words.
;; block-data is a pointer to EE memory containing texture data.

;; There is a single "texture-pool" which is responsible for managing the vram.
;; It can allocate vram.
;; It also can allocate "texture-pool-segment"s, which is just a chunk of vram that has a "pointer + size"

;; There are three main units to describe VRAM:
;;  words: 32-bit words, interally this is how the GS addresses things.
;;  blocks: 256 bytes, or 64 words. Some things in the GS must be block aligned, like transfers of textures.
;;  KB: kilobytes, used only for diagnostic printing. 2^10 bytes (1024)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; texture-page basics
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; texture-page = metadata about all the textures.
;; the texture-page doesn't "own" the texture objects or the texture data.

(defmethod print texture-page ((obj texture-page))
  "Print a short description of a texture page."
  (format #t "#<texture-page ~S :length ~D :dest #x~X :size ~DK @ #x~X>"
          (-> obj name)
          (-> obj length) ;; number of textures.
          (shr (-> obj segment 0 dest) 6) ;; destination (vram words -> blocks)
          (shr (-> obj size) 8) ;; size (vram words -> kilobytes)
          obj
          )
  obj
  )

(defmethod length texture-page ((obj texture-page))
  "Get the number of textures in a texture page"
  (-> obj length)
  )

(defmethod asize-of texture-page ((obj texture-page))
  "Get the size in memory of a texture page object, not including the actual texture objects or texture data"
  (the-as int (+ (-> obj type size) (the-as uint (shl (-> obj length) 2))))
  )

(defmethod mem-usage texture-page ((obj texture-page) (arg0 memory-usage-block))
  "Update the mem-usage for a texture."

  ;; some setup for texture memory usage.
  (set! (-> arg0 length) (max (+ 1 (mem-usage-id-int texture)) (-> arg0 length)))
  (set! (-> arg0 data (mem-usage-id texture) name) "texture")

  ;; count will hold the number of textures.
  (set! (-> arg0 data (mem-usage-id texture) count)
        (+ (-> arg0 data (mem-usage-id texture) count) (-> obj length)))

  ;; The size is set to size of texture-page object + size of texture objects - size of texture data.
  ;; this makes the size of the texture come out negative... which matches what you see in game, but doesn't
  ;; make sense to me yet. The texture data _shouldn't_ count toward mem-usage, but why is it negative?
  (let ((v1-7 (- (asize-of obj) (the-as int (shl (-> obj size) 2)))))
    ;; add 64-bytes for each entry, the size of texture.
    (dotimes (a0-6 (-> obj length))
      (if (-> obj data a0-6)
          (+! v1-7 64)
          )
      )
    ;; update used and total.
    (set! (-> arg0 data (mem-usage-id texture) used) (+ (-> arg0 data (mem-usage-id texture) used) v1-7))
    ;; total assumes 16-byte alignment.
    (set! (-> arg0 data (mem-usage-id texture) total)
          (+ (-> arg0 data (mem-usage-id texture) total) (logand -16 (+ v1-7 15)))
          )
    )
  obj
  )


;;;;;;;;;;;;;;;;;;;;;;
;; Texture Data Load
;;;;;;;;;;;;;;;;;;;;;;

;; functions for loading texture data.
;; these assume the GS is set up and ready to receive IMAGE data.

(defun texture-bpp ((arg0 gs-psm))
  "Get the number of bits per pixel for the given texture format"
  (let ((v1-0 arg0))
    (cond
      ((= v1-0 (gs-psm mt8)) 8)
      ((= v1-0 (gs-psm mt4)) 4)
      (else
       (if (or (= v1-0 (gs-psm ct16))
               (= v1-0 (gs-psm ct16s))
               (= v1-0 (gs-psm mz16))
               (= v1-0 (gs-psm mz16s))
               )
           16
           32
           )
       )
      )
    )
  )

(defun texture-qwc ((w int) (h int) (tex-format gs-psm))
  "Get the number of quadwords in a texture. Round up."
  (let ((v1-0 (texture-bpp tex-format)))
   (sar (+ (* (* w h) v1-0) 127) 7)
   )
  )

(defun physical-address ((arg0 pointer))
  "Convert a pointer to a physical address than can be used for DMA"
  (the-as pointer (logand #xfffffff (the-as int arg0)))
  )

(defun dma-buffer-add-ref-texture ((buf dma-buffer) (data pointer) (tex-w int) (tex-h int) (tex-format gs-psm))
  "Add texture data to a dma buffer.  You must first set up the GS transfer in the correct destination.
   This just sets IMAGE mode and sends data."

  ;; get pointer and size (quadwords)
  (let ((data-ptr (physical-address data))
        (qwc (texture-qwc tex-w tex-h tex-format))
        )
    ;; do transfers until its all gone.
    (while (> qwc 0)
      ;; only #x7fff quadwords/transfer is allowed.
      (let ((qwc-this-time (min #x7fff qwc)))
        ;; is this the last transfer?
        (let ((eop (if (= qwc qwc-this-time) 1 0)))
          ;; set up dma/vif for a single giftag
          (let* ((a2-2 buf)
                 (setup-dma (the-as dma-packet (-> a2-2 base)))
                 )
            (set! (-> setup-dma dma)
                  (new 'static 'dma-tag :qwc #x1 :id (dma-tag-id cnt))
                  )
            (set! (-> setup-dma vif0) (new 'static 'vif-tag))
            (set! (-> setup-dma vif1)
                  (new 'static 'vif-tag :imm #x1 :cmd (vif-cmd direct) :msk #x1)
                  )
            (set! (-> a2-2 base) (&+ (the-as pointer setup-dma) 16))
            )

          ;; set up IMAGE mode!
          (let* ((a2-3 buf)
                 (setup-dif (the-as gs-gif-tag (-> a2-3 base)))
                 )
            (set! (-> setup-dif tag) (new 'static 'gif-tag64 :flg #x2 :eop eop :nloop qwc-this-time))
            (set! (-> setup-dif regs) (new 'static 'gif-tag-regs))
            (set! (-> a2-3 base) (&+ (the-as pointer setup-dif) 16))
            )
          )

        ;; and send the data.
        (let* ((a1-9 buf)
               (data-dma (the-as dma-packet (-> a1-9 base)))
               )
          (set! (-> data-dma dma)
                (new 'static 'dma-tag
                     :id (dma-tag-id ref)
                     :addr (the-as int data-ptr)
                     :qwc qwc-this-time
                     )
                )
          (set! (-> data-dma vif0) (new 'static 'vif-tag))
          (set! (-> data-dma vif1)
                (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1 :imm qwc-this-time)
                )
          (set! (-> a1-9 base) (&+ (the-as pointer data-dma) 16))
          )

        ;; seek to next data.
        (&+! data-ptr (shl qwc-this-time 4))
        (set! qwc (- qwc qwc-this-time))
        )
      )
    )
  (none)
  )

(defmethod print texture ((obj texture))
  "Print out texture object, describing the texture format."
  (format #t "#<texture ~20S psm: ~6S  ~4D x ~4D  num-mips: ~D :size ~4DK "
          (-> obj name)
          (psm->string (-> obj psm))
          (-> obj w)
          (-> obj h)
          (-> obj num-mips)
          (shr (-> obj size) 8) ;; (vram words -> kb)
          )
  ;; print each level
  (dotimes (s5-1 (the-as int (-> obj num-mips)))
    (format #t " #x~X/~X" (-> obj dest s5-1) (-> obj width s5-1))
    )
  ;; for < 16 bpp textures, there is a color look-up table.
  (if (< (texture-bpp (-> obj psm)) 16)
      (format #t " :clut #x~X/1" (-> obj clutdest))
      )
  (format #t " @ #x~X>" obj)
  obj
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Unused and partially broken texture format utils
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define ct32-24-block-table
    (new 'static 'boxed-array int32
         32 0 1 4 5 16 17 20 21 2 3 6 7 18 19 22 23 8 9 12 13 24 25 28 29 10 11 14 15 26 27 30 31))

(define mz32-24-block-table
    (new 'static 'boxed-array int32
         32 16 17 20 21 0 1 4 5 18 19 22 23 2 3 6 7 24 25 28 29 8 9 12 13 26 27 30 31 10 11 14 15))

(define ct16-block-table
    (new 'static 'boxed-array int32
         32 0 2 8 10 1 3 9 11 4 6 12 14 5 7 13 15 16 18 24 26 17 19 25 27 20 22 28 30 21 23 29 31))

(define ct16s-block-table
    (new 'static 'boxed-array int32
         32 0 2 16 18 1 3 17 19 8 10 24 26 9 11 25 27 4 6 20 22 5 7 21 23 12 14 28 30 13 15 29 31))

(define mz16-block-table
    (new 'static 'boxed-array int32
         32 16 18 24 26 17 19 25 27 20 22 28 30 21 23 29 31 0 2 8 10 1 3 9 11 4 6 12 14 5 7 13 15))

(define mz16s-block-table
    (new 'static 'boxed-array int32
         32 16 18 0 2 17 19 1 3 24 26 8 10 25 27 9 11 20 22 4 6 21 23 5 7 28 30 12 14 29 31 13 15))

(define mt8-block-table
    (new 'static 'boxed-array int32
         32 0 1 4 5 16 17 20 21 2 3 6 7 18 19 22 23 8 9 12 13 24 25 28 29 10 11 14 15 26 27 30 31))

(define mt4-block-table
    (new 'static 'boxed-array int32
         32 0 2 8 10 1 3 9 11 4 6 12 14 5 7 13 15 16 18 24 26 17 19 25 27 20 22 28 30 21 23 29 31))

(defun gs-find-block ((bx int) (by int) (tex-format gs-psm))
  "Block index lookup."
  (cond
    ((zero? tex-format)
     (-> ct32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm ct24))
     (-> ct32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm ct16))
     (-> ct16-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm ct16s))
     (-> ct16s-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm mz32))
     (-> mz32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm mz24))
     (-> mz32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm mz16))
     (-> mz16-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm mz16s))
     (-> mz16s-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm mt8))
     (-> mt8-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm mt4))
     (-> mt4-block-table (+ bx (shl by 2)))
     )
    (else
     0
     )
    )
  )

(defun gs-page-width ((arg0 gs-psm))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0)
            (= v1-0 (gs-psm ct24))
            (= v1-0 (gs-psm ct16))
            (= v1-0 (gs-psm ct16s))
            )
        64
        (cond
          ((or (= v1-0 (gs-psm mt8)) (= v1-0 (gs-psm mt4)))
           128
           )
          (else
           (format #t "Warning: Unknown block width for psm ~D~%" arg0)
           1
           )
          )
        )
    )
  )

(defun gs-page-height ((arg0 gs-psm))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0) (= v1-0 (gs-psm ct24)))
        32
        (cond
          ((or (= v1-0 (gs-psm ct16)) (= v1-0 (gs-psm ct16s)))
           64
           )
          ((= v1-0 (gs-psm mt8))
           64
           )
          ((= v1-0 (gs-psm mt4))
           128
           )
          (else
           (format #t "Warning: Unknown block width for psm ~D~%" arg0)
           1
           )
          )
        )
    )
  )

(defun gs-block-width ((arg0 gs-psm))
  (let ((v1-0 arg0))
   (if (or (zero? v1-0) (= v1-0 (gs-psm ct24)))
    8
    (cond
     ((or (= v1-0 (gs-psm ct16)) (= v1-0 (gs-psm ct16s)) (= v1-0 (gs-psm mt8)))
      16
      )
     ((= v1-0 (gs-psm mt4))
      32
      )
     (else
      (format #t "Warning: Unknown block width for psm ~D~%" arg0)
      1
      )
     )
    )
   )
  )

(defun gs-block-height ((arg0 gs-psm))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0)
            (= v1-0 (gs-psm ct24))
            (= v1-0 (gs-psm ct16))
            (= v1-0 (gs-psm ct16s))
            )
        8
        (cond
          ((or (= v1-0 (gs-psm mt8)) (= v1-0 (gs-psm mt4)))
           16
           )
          (else
           (format #t "Warning: Unknown block width for psm ~D~%" arg0)
           1
           )
          )
        )
    )
  )

(defun gs-largest-block ((tex-width int) (tex-height int) (tex-format gs-psm))
  "Determine the largest block occupied by the given texture"
  (let* ((block-width (gs-block-width tex-format))
         (block-height (gs-block-height tex-format))
         ;; round up to neaest block.
         (real-width
          (* (/ (+ (+ block-width -1) tex-width) block-width) block-width)
           )
         (real-height
          (* (/ (+ (+ block-height -1) tex-height) block-height) block-height)
           )
         ;; and now convert to actual blocks
         (width-blocks (/ real-width block-width))
         (height-blocks (/ real-height block-height))
         (max-block 0)
         )
    ;; loop over each block...
    (dotimes (x width-blocks)
      (dotimes (y height-blocks)
        ;; and see where it is.
        (set! max-block (max max-block (gs-find-block x y tex-format)))
        )
      )
    max-block
    )
  )

(defun gs-blocks-used ((tex-width int) (tex-height int) (tex-format gs-psm))
  "This function doesn't make much sense...  It's unused so maybe it's just wrong?"
  (let* ((page-width (gs-page-width tex-format))
         (page-height (gs-page-height tex-format))
         (real-width
          (* (/ (+ (+ page-width -1) tex-width) page-width) page-width)
           )
         (real-height
          (* (/ (+ (+ page-height -1) tex-height) page-height) page-height)
           )
         (width-blocks (/ real-width page-width))
         (height-blocks (/ real-height page-height))
         ;; past here, it doesn't make much sense to me.
         (a0-9 (- tex-width (* (+ width-blocks -1) page-width)))
         (a1-7 (- tex-height (* (+ height-blocks -1) page-height)))
         )
    (if (or (< a0-9 page-width) (< a1-7 page-height))
        (+
         (+ (gs-largest-block a0-9 a1-7 tex-format) 1)
         (shl (+ (* width-blocks height-blocks) -1) 5)
         )
        (shl (* height-blocks width-blocks) 5)
        )
    )
  )
;;;;;;;;;;;;;; end of weird gs functions that are unused.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Texture Pool
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod new texture-pool ((allocation symbol) (type-to-make type))
  "Allocate and Initialize a texture-pool"
  (initialize!
   (object-new allocation type-to-make (the-as int (-> type-to-make size)))
   )
  )

(defmethod allocate-vram-words! texture-pool ((obj texture-pool) (word-count int))
  "Allocate words in vram. Returns the index of the first word."
  (let ((v0-0 (-> obj cur)))
    (set! (-> obj cur) (+ (-> obj cur) word-count))
    v0-0
    )
  )


(defmethod lookup-common-tpage-id texture-pool ((obj texture-pool) (arg0 int))
  "There are a set of 'common' texture pages. This maps common tpage id's to common tpage index between 0 and 19.
   If the texture page is not 'common', returns -1."
  (let ((v1-0 arg0))
   (cond
    ((= v1-0 1032) 0)
    ((= v1-0 1119) 1)
    ((= v1-0 1478) 2)
    ((= v1-0 1485) 3)
    ((= v1-0 1486) 4)
    ((= v1-0 1487) 5)
    (else
     (cond
      ((or (= v1-0 635) (= v1-0 1609)) 6)
      ((= v1-0 636) 7)
      ((= v1-0 637) 8)
      ((= v1-0 752) 9)
      ((= v1-0 1598) 10)
      ((= v1-0 1599) 11)
      ((= v1-0 1600) 12)
      ((= v1-0 1601) 13)
      ((= v1-0 1602) 14)
      ((= v1-0 1603) 15)
      ((= v1-0 1604) 16)
      ((= v1-0 1605) 17)
      ((= v1-0 1606) 18)
      ((= v1-0 1607) 19)
      (else -1)
      )
     )
    )
   )
  )

(defmethod initialize! texture-pool ((obj texture-pool))
  "Initialize (or maybe reinitialize) a texture pool."
  ;; reset allocator
  (set! (-> obj cur) 0)
  ;; this seems like it should be set to the top of vram, not the bottom?
  (set! (-> obj top) (-> obj cur))
  ;; by default, use the default allocator.
  (set! (-> obj allocate-func) texture-page-default-allocate)
  ;; allocate the stuff we always want (font, sky, etc)
  (allocate-defaults! obj)
  (set! (-> obj font-palette) (allocate-vram-words! obj 64))

  ;; clear out common pages.
  (dotimes (v1-6 32)
    (set! (-> obj common-page v1-6) (the-as texture-page 0))
    )
  (set! (-> obj common-page-mask) 0)

  ;; clear ids.
  (dotimes (v1-9 160)
    (set! (-> obj ids v1-9) (the-as uint 0))
    )
  obj
  )

(defmethod get-leftover-block-count texture-page ((obj texture-page) (segment-count int) (additional-size int))
  "This _almost_ returns how many blocks are used in the last page.
   It uses 64 blocks per 'page', but GS pages are actually 32 blocks.
   Might be unused?"
  (let ((v1-0 additional-size))
   (dotimes (a2-1 segment-count)
    (+! v1-0 (the-as int (-> obj segment a2-1 size)))
    )
   ;; the sar 6 gets us blocks, but
   ;; not sure why we have this logand 63 here.
   (logand (sar v1-0 6) 63)
   )
  )

(defmethod print-usage texture-pool ((obj texture-pool))
  "Print out VRAM usage."
  (format #t "--------------------~%")
  (format #t "texture pool ~DK - ~DK (~DK used, ~DK free)~%"
   (sar (-> obj top) 8) ;; vram words to kb
   (sar (-> obj cur) 8) ;; vram words to kb
   (sar (- (-> obj cur) (-> obj top)) 8)
   (sar (- #xfa000 (-> obj cur)) 8)
   )
  (format #t "--------------------~%")
  obj
  )

(defmethod allocate-segment! texture-pool ((obj texture-pool) (segment texture-pool-segment) (size int))
  "Allocate a segment of the given size. The segment is an output here, containing size/dest."
  (set! (-> segment size) (the-as uint size))
  (set! (-> segment dest) (the-as uint (allocate-vram-words! obj size)))
  segment
  )

(defmethod allocate-defaults! texture-pool ((obj texture-pool))
  "Allocate default segments"
  ;; allocate the "common" segment
  (allocate-segment! obj (-> obj segment-common) #x1c000) ;; ~0.5 MB
  ;; what is the near segment for?
  (allocate-segment! obj (-> obj segment-near) #x62000) ;; ~1.6 MB
  ;; allocate special "global" textures.
  (set! *sky-base-vram-word* (allocate-vram-words! obj #x7000))
  (set! *sky-base-block* (sar *sky-base-vram-word* 6))
  (set! *sky-base-page* (sar *sky-base-vram-word* 11))
  (set! *eyes-base-vram-word* (+ *sky-base-vram-word* 6144))
  (set! *eyes-base-block* (sar *eyes-base-vram-word* 6))
  (set! *eyes-base-page* (sar *eyes-base-vram-word* 11))
  (set! *ocean-base-vram-word* (+ *sky-base-vram-word* 6144))
  (set! *ocean-base-block* (sar *ocean-base-vram-word* 6))
  (set! *ocean-base-page* (sar *ocean-base-vram-word* 11))
  (set! *depth-cue-base-vram-word* (+ *sky-base-vram-word* 6144))
  (set! *depth-cue-base-block* (sar *depth-cue-base-vram-word* 6))
  (set! *depth-cue-base-page* (sar *depth-cue-base-vram-word* 11))
  (none)
  )
