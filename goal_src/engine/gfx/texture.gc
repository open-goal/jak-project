;;-*-Lisp-*-
(in-package goal)

;; name: texture.gc
;; name in dgo: texture
;; dgos: GAME, ENGINE

(defmethod print texture-page ((obj texture-page))
  "Print a texture page."
  (format #t "#<texture-page ~S :length ~D :dest #x~X :size ~DK @ #x~X>"
          (-> obj name)
          (-> obj length)
          (shr (-> obj segment 0 dest) 6)
          (shr (-> obj size) 8)
          obj
          )
  obj
  )

(defmethod length texture-page ((obj texture-page))
  "Get the length (number of entires) in a texture page"
  (-> obj length)
  )

(defmethod asize-of texture-page ((obj texture-page))
  "Get the size in memory of a texture page"
  (the-as int (+ (-> obj type size) (the-as uint (shl (-> obj length) 2))))
  )

(defmethod mem-usage texture-page ((obj texture-page) (arg0 memory-usage-block))
  "Update the mem-usage for a texture."
  (set! (-> arg0 length) (max 80 (-> arg0 length)))
  (set! (-> arg0 data 79 name) "texture")
  ;; it seems like each "count" is worth 4 bytes, so we can subtract off length * 4.
  (set! (-> arg0 data 79 count) (+ (-> arg0 data 79 count) (-> obj length)))
  (let ((v1-7 (- (asize-of obj) (the-as int (shl (-> obj size) 2)))))
    ;; add 64-bytes for each entry.
    (dotimes (a0-6 (-> obj length))
      (if (-> obj data a0-6)
          (+! v1-7 64)
          )
      )
    ;; update used and total.
    (set! (-> arg0 data 79 used) (+ (-> arg0 data 79 used) v1-7))
    ;; total assumes 16-byte alignment.
    (set! (-> arg0 data 79 total)
          (+ (-> arg0 data 79 total) (logand -16 (+ v1-7 15)))
          )
    )
  obj
  )

(defun texture-bpp ((arg0 gs-psm))
  "Get the number of bits per pixel for the given texture format"
  (let ((v1-0 arg0))
    (cond
      ((= v1-0 (gs-psm mt8)) 8)
      ((= v1-0 (gs-psm mt4)) 4)
      (else
       (if (or (= v1-0 (gs-psm ct16))
               (= v1-0 (gs-psm ct16s))
               (= v1-0 (gs-psm mz16))
               (= v1-0 (gs-psm mz16s))
               )
           16
           32
           )
       )
      )
    )
  )

(defun texture-qwc ((w int) (h int) (tex-format gs-psm))
  "Get the number of quadwords in a texture. Round up."
  (let ((v1-0 (texture-bpp tex-format)))
   (sar (+ (* (* w h) v1-0) 127) 7)
   )
  )

(defun physical-address ((arg0 pointer))
  "Convert a pointer to a physical address than can be used for DMA"
  (the-as pointer (logand #xfffffff (the-as int arg0)))
  )

(defun dma-buffer-add-ref-texture ((buf dma-buffer) (data pointer) (tex-w int) (tex-h int) (tex-format gs-psm))
  "Add texture data to a dma buffer"

  ;; get pointer and size (quadwords)
  (let ((data-ptr (physical-address data))
        (qwc (texture-qwc tex-w tex-h tex-format))
        )
    ;; do transfers until its all gone.
    (while (> qwc 0)
      ;; only #x7fff quadwords/transfer is allowed.
      (let ((qwc-this-time (min #x7fff qwc)))
        ;; is this the last transfer?
        (let ((eop (if (= qwc qwc-this-time) 1 0)))
          ;; set up dma/vif for a single giftag
          (let* ((a2-2 buf)
                 (setup-dma (the-as dma-packet (-> a2-2 base)))
                 )
            (set! (-> setup-dma dma)
                  (new 'static 'dma-tag :qwc #x1 :id (dma-tag-id cnt))
                  )
            (set! (-> setup-dma vif0) (new 'static 'vif-tag))
            (set! (-> setup-dma vif1)
                  (new 'static 'vif-tag :imm #x1 :cmd (vif-cmd direct) :msk #x1)
                  )
            (set! (-> a2-2 base) (&+ (the-as pointer setup-dma) 16))
            )

          ;; set up IMAGE mode!
          (let* ((a2-3 buf)
                 (setup-dif (the-as gs-gif-tag (-> a2-3 base)))
                 )
            (set! (-> setup-dif tag) (new 'static 'gif-tag64 :flg #x2 :eop eop :nloop qwc-this-time))
            (set! (-> setup-dif regs) (new 'static 'gif-tag-regs))
            (set! (-> a2-3 base) (&+ (the-as pointer setup-dif) 16))
            )
          )

        ;; and send the data.
        (let* ((a1-9 buf)
               (data-dma (the-as dma-packet (-> a1-9 base)))
               )
          (set! (-> data-dma dma)
                (new 'static 'dma-tag
                     :id (dma-tag-id ref)
                     :addr (the-as int data-ptr)
                     :qwc qwc-this-time
                     )
                )
          (set! (-> data-dma vif0) (new 'static 'vif-tag))
          (set! (-> data-dma vif1)
                (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1 :imm qwc-this-time)
                )
          (set! (-> a1-9 base) (&+ (the-as pointer data-dma) 16))
          )

        ;; seek to next data.
        (&+! data-ptr (shl qwc-this-time 4))
        (set! qwc (- qwc qwc-this-time))
        )
      )
    )
  (none)
  )

(defmethod print texture ((obj texture))
  (format #t "#<texture ~20S psm: ~6S  ~4D x ~4D  num-mips: ~D :size ~4DK "
          (-> obj name)
          (psm->string (the-as gs-psm (-> obj psm)))
          (-> obj w)
          (-> obj h)
          (-> obj num-mips)
          (shr (-> obj size) 8)
          )
  (dotimes (s5-1 (the-as int (-> obj num-mips)))
    (format #t " #x~X/~X" (-> obj dest s5-1) (-> obj width s5-1))
    )
  (if (< (texture-bpp (the-as gs-psm (-> obj psm))) 16)
      (format #t " :clut #x~X/1" (-> obj clutdest))
      )
  (format #t " @ #x~X>" obj)
  obj
  )

(define ct32-24-block-table
    (new 'static 'boxed-array int32
         32 0 1 4 5 16 17 20 21 2 3 6 7 18 19 22 23 8 9 12 13 24 25 28 29 10 11 14 15 26 27 30 31))

(define mz32-24-block-table
    (new 'static 'boxed-array int32
         32 16 17 20 21 0 1 4 5 18 19 22 23 2 3 6 7 24 25 28 29 8 9 12 13 26 27 30 31 10 11 14 15))

(define ct16-block-table
    (new 'static 'boxed-array int32
         32 0 2 8 10 1 3 9 11 4 6 12 14 5 7 13 15 16 18 24 26 17 19 25 27 20 22 28 30 21 23 29 31))

(define ct16s-block-table
    (new 'static 'boxed-array int32
         32 0 2 16 18 1 3 17 19 8 10 24 26 9 11 25 27 4 6 20 22 5 7 21 23 12 14 28 30 13 15 29 31))
  

(define mz16-block-table
    (new 'static 'boxed-array int32
         32 16 18 24 26 17 19 25 27 20 22 28 30 21 23 29 31 0 2 8 10 1 3 9 11 4 6 12 14 5 7 13 15))

(define mz16s-block-table
    (new 'static 'boxed-array int32
         32 16 18 0 2 17 19 1 3 24 26 8 10 25 27 9 11 20 22 4 6 21 23 5 7 28 30 12 14 29 31 13 15))

(define mt8-block-table
    (new 'static 'boxed-array int32
         32 0 1 4 5 16 17 20 21 2 3 6 7 18 19 22 23 8 9 12 13 24 25 28 29 10 11 14 15 26 27 30 31))

(define mt4-block-table
    (new 'static 'boxed-array int32
         32 0 2 8 10 1 3 9 11 4 6 12 14 5 7 13 15 16 18 24 26 17 19 25 27 20 22 28 30 21 23 29 31))

(defun gs-find-block ((bx int) (by int) (tex-format gs-psm))
  "Block index lookup."
  (cond
    ((zero? tex-format)
     (-> ct32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm ct24))
     (-> ct32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm ct16))
     (-> ct16-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm ct16s))
     (-> ct16s-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm mz32))
     (-> mz32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm mz24))
     (-> mz32-24-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm mz16))
     (-> mz16-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm mz16s))
     (-> mz16s-block-table (+ bx (shl by 2)))
     )
    ((= tex-format (gs-psm mt8))
     (-> mt8-block-table (+ bx (shl by 3)))
     )
    ((= tex-format (gs-psm mt4))
     (-> mt4-block-table (+ bx (shl by 2)))
     )
    (else
     0
     )
    )
  )

(defun gs-page-width ((arg0 gs-psm))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0)
            (= v1-0 (gs-psm ct24))
            (= v1-0 (gs-psm ct16))
            (= v1-0 (gs-psm ct16s))
            )
        64
        (cond
          ((or (= v1-0 (gs-psm mt8)) (= v1-0 (gs-psm mt4)))
           128
           )
          (else
           (format #t "Warning: Unknown block width for psm ~D~%" arg0)
           1
           )
          )
        )
    )
  )

(defun gs-page-height ((arg0 gs-psm))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0) (= v1-0 (gs-psm ct24)))
        32
        (cond
          ((or (= v1-0 (gs-psm ct16)) (= v1-0 (gs-psm ct16s)))
           64
           )
          ((= v1-0 (gs-psm mt8))
           64
           )
          ((= v1-0 (gs-psm mt4))
           128
           )
          (else
           (format #t "Warning: Unknown block width for psm ~D~%" arg0)
           1
           )
          )
        )
    )
  )

(defun gs-block-width ((arg0 gs-psm))
  (let ((v1-0 arg0))
   (if (or (zero? v1-0) (= v1-0 (gs-psm ct24)))
    8
    (cond
     ((or (= v1-0 (gs-psm ct16)) (= v1-0 (gs-psm ct16s)) (= v1-0 (gs-psm mt8)))
      16
      )
     ((= v1-0 (gs-psm mt4))
      32
      )
     (else
      (format #t "Warning: Unknown block width for psm ~D~%" arg0)
      1
      )
     )
    )
   )
  )

(defun gs-block-height ((arg0 gs-psm))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0)
            (= v1-0 (gs-psm ct24))
            (= v1-0 (gs-psm ct16))
            (= v1-0 (gs-psm ct16s))
            )
        8
        (cond
          ((or (= v1-0 (gs-psm mt8)) (= v1-0 (gs-psm mt4)))
           16
           )
          (else
           (format #t "Warning: Unknown block width for psm ~D~%" arg0)
           1
           )
          )
        )
    )
  )

(defun gs-largest-block ((tex-width int) (tex-height int) (tex-format gs-psm))
  "Determine the largest block occupied by the given texture"
  (let* ((block-width (gs-block-width tex-format))
         (block-height (gs-block-height tex-format))
         ;; round up to neaest block.
         (real-width
          (* (/ (+ (+ block-width -1) tex-width) block-width) block-width)
           )
         (real-height
          (* (/ (+ (+ block-height -1) tex-height) block-height) block-height)
           )
         ;; and now convert to actual blocks
         (width-blocks (/ real-width block-width))
         (height-blocks (/ real-height block-height))
         (max-block 0)
         )
    ;; loop over each block...
    (dotimes (x width-blocks)
      (dotimes (y height-blocks)
        ;; and see where it is.
        (set! max-block (max max-block (gs-find-block x y tex-format)))
        )
      )
    max-block
    )
  )

(defun gs-blocks-used ((tex-width int) (tex-height int) (tex-format gs-psm))
  "This function doesn't make much sense...  It's unused so maybe it's just wrong?"
  (let* ((page-width (gs-page-width tex-format))
         (page-height (gs-page-height tex-format))
         (real-width
          (* (/ (+ (+ page-width -1) tex-width) page-width) page-width)
           )
         (real-height
          (* (/ (+ (+ page-height -1) tex-height) page-height) page-height)
           )
         (width-blocks (/ real-width page-width))
         (height-blocks (/ real-height page-height))
         (a0-9 (- tex-width (* (+ width-blocks -1) page-width)))
         (a1-7 (- tex-height (* (+ height-blocks -1) page-height)))
         )
    (if (or (< a0-9 page-width) (< a1-7 page-height))
        (+
         (+ (gs-largest-block a0-9 a1-7 tex-format) 1)
         (shl (+ (* width-blocks height-blocks) -1) 5)
         )
        (shl (* height-blocks width-blocks) 5)
        )
    )
  )


(defmethod new texture-pool ((allocation symbol) (type-to-make type))
  "Allocate and Initialize a texture-pool"
  (initialize!
   (object-new allocation type-to-make (the-as int (-> type-to-make size)))
   )
  )

(defmethod allocate! texture-pool ((obj texture-pool) (arg0 int))
  "Allocate arg0 ids. Returns the first."
  (let ((v0-0 (-> obj cur)))
   (set! (-> obj cur) (+ (-> obj cur) arg0))
   v0-0
   )
  )

(defmethod lookup-tpage-id texture-pool ((obj texture-pool) (arg0 int))
  "Convert a tpage file name to an id. If it fails, return -1."
  (let ((v1-0 arg0))
   (cond
    ((= v1-0 1032) 0)
    ((= v1-0 1119) 1)
    ((= v1-0 1478) 2)
    ((= v1-0 1485) 3)
    ((= v1-0 1486) 4)
    ((= v1-0 1487) 5)
    (else
     (cond
      ((or (= v1-0 635) (= v1-0 1609)) 6)
      ((= v1-0 636) 7)
      ((= v1-0 637) 8)
      ((= v1-0 752) 9)
      ((= v1-0 1598) 10)
      ((= v1-0 1599) 11)
      ((= v1-0 1600) 12)
      ((= v1-0 1601) 13)
      ((= v1-0 1602) 14)
      ((= v1-0 1603) 15)
      ((= v1-0 1604) 16)
      ((= v1-0 1605) 17)
      ((= v1-0 1606) 18)
      ((= v1-0 1607) 19)
      (else -1)
      )
     )
    )
   )
  )
