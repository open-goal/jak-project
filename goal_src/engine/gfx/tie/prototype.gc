;;-*-Lisp-*-
(in-package goal)

;; name: prototype.gc
;; name in dgo: prototype
;; dgos: GAME, ENGINE

;; shared code for the tie and shrub prototypes

(defmethod login prototype-array-tie ((obj prototype-array-tie))
  (dotimes (s5-0 (-> obj length))
    (let ((s4-0 (-> obj array-data s5-0)))
      (dotimes (s3-0 4)
        (let ((a0-1 (-> s4-0 geometry s3-0)))
          (if (nonzero? a0-1)
              (login a0-1)
              )
          )
        )
      (let ((s4-1 (-> s4-0 envmap-shader)))
        (when (nonzero? s4-1)
          (adgif-shader-login-no-remap s4-1)
          (set! (-> s4-1 tex1) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
          (set! (-> s4-1 clamp) (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
          (set! (-> s4-1 alpha) (new 'static 'gs-alpha :b #x2 :c #x1 :d #x1))
          (set! (-> s4-1 prims 1) (gs-reg64 tex0-1))
          (set! (-> s4-1 prims 3) (gs-reg64 tex1-1))
          (set! (-> s4-1 prims 5) (gs-reg64 miptbp1-1))
          (set! (-> s4-1 clamp-reg) (gs-reg64 clamp-1))
          (set! (-> s4-1 prims 9) (gs-reg64 alpha-1))
          )
        )
      )
    )
  (none)
  )

(defmethod login prototype-inline-array-shrub ((obj prototype-inline-array-shrub))
  (dotimes (s5-0 (-> obj length))
    (let ((s4-0 (-> obj data s5-0)))
      (dotimes (s3-0 4)
        (let ((a0-1 (-> s4-0 geometry s3-0)))
          (if (nonzero? a0-1)
              (login a0-1)
              )
          )
        )
      )
    )
  obj
  )

(defmethod mem-usage prototype-array-tie ((obj prototype-array-tie) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 1 (-> arg0 length)))
  (set! (-> arg0 data 0 name) (symbol->string 'drawable-group))
  (+! (-> arg0 data 0 count) 1)
  (let ((v1-8 (asize-of obj)))
    (+! (-> arg0 data 0 used) v1-8)
    (+! (-> arg0 data 0 total) (logand -16 (+ v1-8 15)))
    )
  (dotimes (s3-0 (-> obj length))
    (mem-usage (-> obj array-data s3-0) arg0 arg1)
    )
  obj
  )

(defmethod mem-usage prototype-bucket-tie ((obj prototype-bucket-tie) (arg0 memory-usage-block) (arg1 int))
  (dotimes (s3-0 4)
    (let ((a0-1 (-> obj geometry s3-0)))
      (if (nonzero? a0-1)
          (mem-usage a0-1 arg0 (logior arg1 1))
          )
      )
    )
  (set! (-> arg0 length) (max 81 (-> arg0 length)))
  (set! (-> arg0 data 80 name) "string")
  (+! (-> arg0 data 80 count) 1)
  (let ((v1-13 ((method-of-type string asize-of) (the-as string (-> obj name)))))
    (+! (-> arg0 data 80 used) v1-13)
    (+! (-> arg0 data 80 total) (logand -16 (+ v1-13 15)))
    )
  (when (nonzero? (-> obj tie-colors))
    (set! (-> arg0 length) (max 17 (-> arg0 length)))
    (set! (-> arg0 data 16 name) "tie-pal")
    (+! (-> arg0 data 16 count) 1)
    (let ((v1-25 (asize-of (-> obj tie-colors))))
      (+! (-> arg0 data 16 used) v1-25)
      (+! (-> arg0 data 16 total) (logand -16 (+ v1-25 15)))
      )
    )
  (if (nonzero? (-> obj collide-frag))
      (mem-usage (-> obj collide-frag) arg0 (logior arg1 1))
      )
  obj
  )

(defmethod mem-usage prototype-inline-array-shrub ((obj prototype-inline-array-shrub) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 1 (-> arg0 length)))
  (set! (-> arg0 data 0 name) (symbol->string 'drawable-group))
  (+! (-> arg0 data 0 count) 1)
  (let ((v1-8 (asize-of obj)))
    (+! (-> arg0 data 0 used) v1-8)
    (+! (-> arg0 data 0 total) (logand -16 (+ v1-8 15)))
    )
  (dotimes (s3-0 (-> obj length))
    (mem-usage (-> obj data s3-0) arg0 arg1)
    )
  obj
  )

(defmethod mem-usage prototype-bucket-shrub ((obj prototype-bucket-shrub) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 25 (-> arg0 length)))
  (set! (-> arg0 data 24 name) "prototype-bucket-shrub")
  (+! (-> arg0 data 24 count) 1)
  (let ((v1-5 112))
    (+! (-> arg0 data 24 used) v1-5)
    (+! (-> arg0 data 24 total) (logand -16 (+ v1-5 15)))
    )
  (dotimes (s3-0 4)
    (let ((a0-5 (-> obj geometry s3-0)))
      (if (nonzero? a0-5)
          (mem-usage a0-5 arg0 (logior arg1 1))
          )
      )
    )
  (set! (-> arg0 length) (max 81 (-> arg0 length)))
  (set! (-> arg0 data 80 name) "string")
  (+! (-> arg0 data 80 count) 1)
  (let ((v1-22 ((method-of-type string asize-of) (the-as string (-> obj name)))))
    (+! (-> arg0 data 80 used) v1-22)
    (+! (-> arg0 data 80 total) (logand -16 (+ v1-22 15)))
    )
  obj
  )




