;;-*-Lisp-*-
(in-package goal)

;; name: loader.gc
;; name in dgo: loader
;; dgos: GAME, ENGINE


(defmethod inspect load-dir ((obj load-dir))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tlevel: ~A~%" (-> obj unknown))
  (format #t "~Tallocated-length: ~D~%" (-> obj string-array allocated-length))
  (format #t "~Tlength: ~D~%" (-> obj string-array length))
  (dotimes (i (-> obj string-array length))
    (format #t "~T  [~D] ~S ~A  (~D bytes)~%"
              i (-> obj string-array i) (-> obj data-array i) (mem-size (-> obj data-array i) #f 0))
    )
  obj
  )

(defmethod mem-usage load-dir ((obj load-dir) (arg0 memory-usage-block) (arg1 int))
  "Get the memory usage data of a load-dir"

  (set! (-> arg0 length) (max 82 (-> arg0 length)))
  (set! (-> arg0 data 81 name) "array")
  (set! (-> arg0 data 81 count) (+ (-> arg0 data 81 count) 1))
  (let ((v1-6 (asize-of obj)))
   (set! (-> arg0 data 81 used) (+ (-> arg0 data 81 used) v1-6))
   (set!
    (-> arg0 data 81 total)
    (+ (-> arg0 data 81 total) (logand -16 (+ v1-6 15)))
    )
   )
  (set! (-> arg0 length) (max 82 (-> arg0 length)))
  (set! (-> arg0 data 81 name) "array")
  (set! (-> arg0 data 81 count) (-> arg0 data 81 count))
  (let ((v1-15 (asize-of (-> obj string-array))))
   (set! (-> arg0 data 81 used) (+ (-> arg0 data 81 used) v1-15))
   (set!
    (-> arg0 data 81 total)
    (+ (-> arg0 data 81 total) (logand -16 (+ v1-15 15)))
    )
   )
  (set! (-> arg0 length) (max 82 (-> arg0 length)))
  (set! (-> arg0 data 81 name) "array")
  (set! (-> arg0 data 81 count) (-> arg0 data 81 count))
  (let ((v1-24 (asize-of (-> obj data-array))))
   (set! (-> arg0 data 81 used) (+ (-> arg0 data 81 used) v1-24))
   (set!
    (-> arg0 data 81 total)
    (+ (-> arg0 data 81 total) (logand -16 (+ v1-24 15)))
    )
   )
  (dotimes (s3-0 (-> obj data-array length))
   (mem-usage (-> obj data-array s3-0) arg0 arg1)
   )
  (the-as load-dir #f)
  )

(defmethod dummy-9 load-dir-art-group ((obj load-dir-art-group) (arg0 string) (arg1 symbol) (arg2 kheap) (arg3 int))


  (let ((s5-0 (-> obj string-array)))
   (dotimes (s3-0 (-> s5-0 length))
    (when (string= arg0 (-> s5-0 s3-0))
     (when arg1
      (let ((v1-4 (art-group-load-check arg0 arg2 arg3)))
       (if v1-4
        (set! (-> obj art-group-array s3-0) v1-4)
        )
       )
      )
     (return (-> obj art-group-array s3-0))
     )
    )
   (let ((v0-2 (art-group-load-check arg0 arg2 arg3)))
    (when v0-2
     (set! (-> s5-0 (-> s5-0 length)) arg0)
     (set! (-> obj art-group-array (-> s5-0 length)) v0-2)
     (set! (-> s5-0 length) (+ (-> s5-0 length) 1))
     (set!
      (-> obj art-group-array length)
      (+ (-> obj art-group-array length) 1)
      )
     )
    v0-2
    )
   )
  )

(defmethod dummy-10 load-dir-art-group ((obj load-dir-art-group) (arg0 art-group))


  (let ((s4-0 (-> obj string-array)))
   (dotimes (s3-0 (-> s4-0 length))
    (when (string= (-> arg0 name) (-> s4-0 s3-0))
      (set! (-> obj art-group-array s3-0) arg0)
      (return (-> obj art-group-array s3-0))
      )
    )
   (set! (-> s4-0 (-> s4-0 length)) (-> arg0 name))
   (set! (-> obj art-group-array (-> s4-0 length)) arg0)
   (set! (-> s4-0 length) (+ (-> s4-0 length) 1))
   )
  (set! (-> obj art-group-array length) (+ (-> obj art-group-array length) 1))
  arg0
  )

;; drawable-load
;; art-load
;; art-group-load-check

(defmethod want-file external-art-buffer ((obj external-art-buffer) (arg0 symbol) (arg1 int) (arg2 handle) (arg3 float))
  "Request a new file to be loaded into this buffer."

  (set! (-> obj pending-load-file) (the-as string arg0))
  (set! (-> obj pending-load-file-part) arg1)
  (set! (-> obj pending-load-file-owner) arg2)
  (set! (-> obj pending-load-file-priority) arg3)
  0
  )

(defmethod unlock! external-art-buffer ((obj external-art-buffer))
  "Unlock this buffer."

  (declare (inline))
  (set! (-> obj locked?) #f)
  #f
  )

(defmethod inactive? external-art-buffer ((obj external-art-buffer))
  "Is this buffer inactive?"

  (declare (inline))
  (!= (-> obj status) 'active)
  )

(defmethod file-status external-art-buffer ((obj external-art-buffer) (name string) (part int))
  "Get the status of a file in the buffer. #f = file is not present."

  (when (and (name= (-> obj pending-load-file) name)
             (= (-> obj pending-load-file-part) part)
             )
    ;; the file is at least wanting to load
    (if (and (name= (-> obj load-file) name) (= (-> obj load-file-part) part))
      (-> obj status) ;; file is loaded
      'pending        ;; file is not loaded yet?
      )
    )
  )

(defmethod link-art! art-group ((obj art-group))
  "Links the elements of this art-group."

  ;; this check seems superfluous
  (when obj
   (countdown (s5-0 (-> obj length))
    (let* ((art-elt (-> obj data s5-0))
           (janim (if (and (nonzero? art-elt) (type-type? (-> art-elt type) art-joint-anim))
                              (the-as art-joint-anim art-elt)
                              ))
           (success #f)
           )
        (when janim
          ;; a countdown with a label right at the start
          (let ((s3-1 3))
           (while (begin
                   (label cfg-22)
                   (nonzero? s3-1)
                   )
            (+! s3-1 -1)
            (let ((janim-group (art-group-get-by-name (-> *level* level s3-1) (-> janim master-art-group-name))))
                (when janim-group
                  (cond
                    ((and (< (-> janim master-art-group-index) (-> janim-group length))
                          (not (-> janim-group data (-> janim master-art-group-index)))
                          )
                     (set! (-> janim-group data (-> janim master-art-group-index)) janim)
                     (set! success #t)
                     )
                    (else
                     (countdown (a0-14 (-> janim-group length))
                       (when (not (-> janim-group data a0-14))
                         (set! (-> janim-group data a0-14) janim)
                         (set! success #t)
                         (goto cfg-22)
                         )
                       )
                     )
                    )
                  )
                )
            )
           )
          (if (not success)
            (format 0 "ERROR: ~A could not find a master slot to link for ~A.~%" (-> obj name) janim)
            )
          )
        )
    )
   )
  obj
  )

(defmethod unlink-art! art-group ((obj art-group))
  "Unlinks the elements of this art-group."

  (when obj
    (countdown (s5-0 (-> obj length))
      (let* ((art-elt (-> obj data s5-0))
             (janim (if (and (nonzero? art-elt) (type-type? (-> art-elt type) art-joint-anim))
                               (the-as art-joint-anim art-elt)
                               ))
             (success #f)
             )
          (when janim
            (let ((s2-0 3))
              (while (begin
                      (label cfg-16)
                      (nonzero? s2-0)
                      )
                (+! s2-0 -1)
                (let ((janim-group (art-group-get-by-name (-> *level* level s2-0) (-> janim master-art-group-name))))
                  (when janim-group
                    (countdown (a0-5 (-> janim-group length))
                      (when (= janim (-> janim-group data a0-5))
                        (set! (-> janim-group data a0-5) #f)
                        (set! success #t)
                        (goto cfg-16)
                        )
                      )
                    )
                  )
                )
              )
            (if (not success)
              (format 0 "ERROR: ~A could not find a master slot to unlink for ~A.~%" (-> obj name) janim)
              )
            )
          )
      )
    )
  0
  )

(defmethod link external-art-buffer ((obj external-art-buffer) (ag art-group))
  "Link the art-group and set it to this buffer's art group."

  (when ag
    (link-art! ag)
    (set! (-> obj art-group) ag)
    )
  ag
  )

(defmethod unlink external-art-buffer ((obj external-art-buffer) (ag art-group))
  "Unlink the art-group and remove this buffer's art group."

  (when ag
    (unlink-art! ag)
    (set! (-> obj art-group) #f)
    )
  0
  )

;; (method 10 external-art-buffer)

(defmethod first-using-status external-art-control ((obj external-art-control) (arg0 string) (arg1 int))
  "Get the status of the first buffer that's in use. #f = none are in use"

  (dotimes (i 2)
    (swhen ((v1-3 (file-status (-> obj buffer i) arg0 arg1)))
      (return bc)
      )
    )
  #f
  )

(defmethod update external-art-control ((obj external-art-control) (debug-print symbol))
  "Update this external-art-control. This validates the spool buffers, sorts the spools, and does some other things.
   If debug-print, also prints some text to the display console"

  (if (nonzero? (-> obj reserve-buffer-count))
    (dummy-11 obj "reserved" 0 *dproc* (if (-> obj reserve-buffer)
                                          -110.0
                                          -0.5)
                                        )
   )
  (dotimes (v1-5 2)
    (set! (-> obj buffer v1-5 frame-lock) #f) ;; I don't know what this is
    )
  (dotimes (v1-8 3)
    (set! (-> obj rec v1-8 buf2) #f)
    )
  (dotimes (s4-0 2)
   (let ((s3-0 (-> obj rec s4-0)))
    (when (-> s3-0 name)
     (dotimes (s2-0 2)
      (when (and (file-status (-> obj buffer s2-0) (-> s3-0 name) (-> s3-0 parts))
                 (not (-> obj buffer s2-0 frame-lock))
                 )
        (set! (-> obj buffer s2-0 frame-lock) #t)
        (set! (-> s3-0 buf2) (-> obj buffer s2-0))
        (set! (-> obj buffer s2-0 pending-load-file-owner) (-> s3-0 owner))
        (set! (-> obj buffer s2-0 load-file-owner) (-> s3-0 owner))
        (set! (-> obj buffer s2-0 pending-load-file-priority) (-> s3-0 priority))
        (set! (-> obj buffer s2-0 load-file-priority) (-> s3-0 priority))
        (goto cfg-24) ;; buffer found, move on.
        )
      )
     )
    )
   (label cfg-24)
   )

  (dotimes (s4-1 2)
   (let ((s3-1 (-> obj rec s4-1)))
    (when (and (-> s3-1 name) (not (-> s3-1 buf2)))
     (if (and (not *preload-spool-anims*) (>= (-> s3-1 priority) 0.0))
       ;; not in use, move on
       (goto cfg-46)
       )
     (dotimes (s2-1 2)
       (when (not (-> obj buffer s2-1 frame-lock))
         (set! (-> obj buffer s2-1 frame-lock) #t)
         (want-file (-> obj buffer s2-1) (-> s3-1 name) (-> s3-1 parts) (-> s3-1 owner) (-> s3-1 priority))
         (set! (-> s3-1 index) (the-as int (-> obj buffer s2-1)))
         (goto cfg-46)
         )
       )
     )
    )
   (label cfg-46)
   )

  ;; I have never seen this enabled
  (when (not (-> obj reserve-buffer))
   (let ((s4-2 (-> obj rec 0 buf1)))
    (if (and s4-2
             (-> s4-2 locked?)
             (not (string= (-> s4-2 pending-load-file) "reserved"))
             (not (string= (-> s4-2 other pending-load-file) "reserved"))
             )
     (want-file (-> s4-2 other) (the-as string #f) -1 (the-as handle #f) 100000000.0)
     )
    )
   )

  (dotimes (s4-3 2)
   (dummy-10 (-> obj buffer s4-3))
   )

  ;; sort spool anims.
  (let ((s4-4 (the-as spool-anim #f)))
   (countdown (s3-2 3)
    (if (and (-> obj rec s3-2 name)
             (not (name= (-> obj rec s3-2 name) (-> obj active-stream)))
             )
      (set! s4-4 (-> obj rec))
      )
    )
   (if (and (-> obj preload-stream name)
            (or (not s4-4) (< (-> obj preload-stream priority) (-> s4-4 priority)))
            )
     (set! s4-4 (-> obj preload-stream))
     )
   (cond
    (s4-4
     (mem-copy! (&-> (-> obj last-preload-stream) type) (&-> s4-4 type) (size-of spool-anim))
     (str-play-queue (-> s4-4 name))
     )
    (else
     (set! (-> obj last-preload-stream name) #f)
     (set! (-> obj last-preload-stream owner) (the-as handle #f))
     )
    )
   )

  (when (and debug-print *display-art-control*)
    (dotimes (s5-1 3)
      (format *stdcon* "rec ~d ~S ~D ~f ~A~%" s5-1 (-> obj rec s5-1 name) (-> obj rec s5-1 parts) (-> obj rec s5-1 priority) (handle->name (-> obj rec s5-1 owner)))
      )
    (dotimes (s5-2 2)
      (format *stdcon* "buf ~d ~C ~S ~D ~A ~A~%" s5-2 (if (-> obj buffer s5-2 locked?) #\l #\\s) (-> obj buffer s5-2 pending-load-file) (-> obj buffer s5-2 pending-load-file-part) (-> obj buffer s5-2 status) (handle->name (-> obj buffer s5-2 pending-load-file-owner)))
      )
    (format *stdcon* " a: ~S~%" (-> obj active-stream))
    (format *stdcon* " p: ~S  ~A~%" (-> obj preload-stream name) (handle->name (-> obj preload-stream owner)))
    (format *stdcon* " q: ~S  ~A~%" (-> obj last-preload-stream name) (handle->name (-> obj last-preload-stream owner)))
    )
  0
  )

(defmethod none-reserved? external-art-control ((obj external-art-control))
  "are there any reserved buffers?"
  (declare (inline))
  (zero? (-> obj reserve-buffer-count))
  )

(defmethod reserve-alloc external-art-control ((obj external-art-control))
  "Reserve a buffer!"

  (set! (-> obj reserve-buffer-count) 1)
  (if (-> obj reserve-buffer)
   (-> obj reserve-buffer heap)
   )
  )

(defmethod reserve-free external-art-control ((obj external-art-control) (arg0 kheap))
  "Free the reserved buffer!"

  (cond
   ((none-reserved? obj)
    (format 0 "ERROR: illegal attempt to free a buffer #x~X which had not been reserved (none reserved).~%" arg0)
    )
   ((not (-> obj reserve-buffer))
    (set! (-> obj reserve-buffer-count) 0)
    )
   ((= (-> obj reserve-buffer heap) arg0)
    (want-file (-> obj reserve-buffer) (the-as string #f) -1 (the-as handle #f) 100000000.0)
    (dummy-10 (-> obj reserve-buffer))
    (set! (-> obj reserve-buffer-count) 0)
    )
   (else
    (format 0 "ERROR: illegal attempt to free a buffer #x~X which had not been reserved (buffer unknown).~%" arg0)
    )
   )
  0
  )

;; start loading a spooled anim if we think one is about to be used, e.g. when approaching a fuel cell or npc
;; (some processes may want to wait for the stream to be preloaded, which won't happen with this disabled)
(define *preload-spool-anims* #t)

