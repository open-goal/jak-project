;;-*-Lisp-*-
(in-package goal)

;; name: decomp.gc
;; name in dgo: decomp
;; dgos: GAME, ENGINE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; decompression functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun unpack-comp-rle ((out (pointer int8)) (in (pointer int8)))
  "Unpack run-length-encoded data. Has sections of repeated values, then normally copied."
  (local-vars (current-input int) (copy-length int))
  (nop!)
  (while #t
    (while #t
      
      ;; read the input and see what kind it is, based on number.
      (set! current-input (-> in 0))
      (set! in (&-> in 1))
      (b! (<= current-input 0) cfg-5 :delay (nop!))
      
      ;; it's a repated value, loop to copy it.
      (let ((repeated-value (-> in 0)))
        (set! in (&-> in 1))
        (label cfg-3)
        (set! (-> out 0) repeated-value)
        )
      (set! out (&-> out 1))
      (b! (> current-input 0) cfg-3 :delay (set! current-input (+ current-input -1)))
      )
    
    (label cfg-5)
    ;; check for end
    (b! (zero? current-input) cfg-8 :delay (set! copy-length (- current-input)))
    
    ;; copy
    (label cfg-6)
    (let ((src-val (-> in 0)))
      (set! in (&-> in 1))
      (set! (-> out 0) src-val)
      )
    (+! copy-length -1)
    (b! (> copy-length 0) cfg-6 :delay (set! out (&-> out 1)))
    )
  (label cfg-8)
  0
  (none)
  )


(deftype huf-dictionary-node (structure)
  ((zero uint16  :offset-assert   0)
   (one  uint16  :offset-assert   2)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )

(defun unpack-comp-huf ((dst (pointer uint8)) (src (pointer uint8)) (arg2 uint) (dict huf-dictionary-node))
  "Unpack data compressed with huffman encoding."
  (local-vars (t1-1 uint) (t3-2 object))
  (let ((t1-0 (-> dict zero))
        (a2-1 (+ arg2 -1028))
        (t2-0 (-> dict one))
        )
    (nop!)
    (label cfg-1)
    (let ((v1-4 128))
      (nop!)
      (let ((t0-0 (-> src 0)))
        (set! src (&-> src 1))
        (label cfg-2)
        (let ((t3-0 (logand t0-0 v1-4)))
          (.sra v1-4 v1-4 1)
          (b! (zero? t3-0) cfg-4 :delay (set! t1-1 t1-0))
          )
        )
      (nop!)
      (set! t1-1 t2-0)
      (label cfg-4)
      (let ((t2-1 (+ t1-1 -256)))
        (let ((t3-1 (* t1-1 4)))
          (b! (< (the-as int t2-1) 0) cfg-8 :delay (set! t3-2 (+ t3-1 a2-1)))
          )
        (b! (zero? t2-1) cfg-10
            :delay (set! t1-0 (-> (the-as (pointer uint16) t3-2) 0))
            )
        )
      (b! (nonzero? v1-4) cfg-2
          :delay (set! t2-0 (-> (the-as (pointer uint16) t3-2) 1))
          )
      (b! #t cfg-1 :delay (nop!))
      (label cfg-8)
      (set! (-> dst 0) t1-1)
      (set! dst (&-> dst 1))
      (nop!)
      (set! t1-0 (-> dict zero))
      (b! (nonzero? v1-4) cfg-2 :delay (set! t2-0 (-> dict one)))
      )
    )
  (b! #t cfg-1 :delay (nop!))
  (label cfg-10)
  (nop!)
  (nop!)
  0
  (none)
  )

(defmethod update-vis! level ((obj level) (vis-info level-vis-info) (arg1 uint) (arg2 uint))
  (local-vars (t0-3 uint128) (vis-buffer object))
  
  (let* ((cam-leaf-idx (-> vis-info from-bsp current-leaf-idx))   ;; current bsp leaf of camera
         (curr-vis-str (-> vis-info current-vis-string))          ;; currently loaded vis-string.
         (desired-vis-str (-> vis-info vis-string cam-leaf-idx))  ;; vis-string ptr for what we want.
         )
    ;; oops
    0
    (+ 16 #x70000000)
    (+ 2064 #x70000000)
    
    ;; wait on ramdisk load, or do nothing because we already have the right stuff.
    (when (= curr-vis-str desired-vis-str)
      ;; we match. but are we loading?
      (cond
        ((logtest? (vis-info-flag waiting-for-load) (-> vis-info flags))
         (if (check-busy *ramdisk-rpc*)
             ;; loading, and ramdisk not done, return #f, we don't have vis.
             (return #f)
             )
         ;; we are done loading. Jump to code that sets it up.
         (logclear! (-> vis-info flags) (vis-info-flag waiting-for-load))
         (set! vis-buffer (-> obj vis-buffer))
         (b! #t cfg-27 :delay (nop!))
         )
        (else
          ;; matched, and loaded!
          (return #t)
          )
        )
      )
    
    ;; wait for any pending load to finish.
    (when (logtest? (vis-info-flag waiting-for-load) (-> vis-info flags))
      (if (check-busy *ramdisk-rpc*)
          (return #f)
          )
      (logclear! (-> vis-info flags) (vis-info-flag waiting-for-load))
      )
    
    ;; not sure what this does yet.
    (set! (-> vis-info current-vis-string) desired-vis-str)
    (b! (logtest? #x20000000 (-> vis-info flags)) cfg-15)
    (set! vis-buffer (the-as (pointer uint8) (+ arg2 desired-vis-str)))
    (b! #t cfg-27 :delay (nop!))
    (label cfg-15)
    
    ;; start a ramdisk load.
    (let ((vis-load-result (vis-load obj)))
      (b! (nonzero? vis-load-result) cfg-21)
      (let* ((dest-bits (-> vis-info vis-bits))
             (len (-> obj bsp visible-list-length))
             (bsp-bits (the-as (pointer uinteger) (-> obj bsp all-visible-list)))
             (len-qw (/ (+ len 15) 16))
             )
        (dotimes (a2-1 len-qw)
          (set!
            (-> (the-as (pointer uint128) dest-bits) 0)
            (-> (the-as (pointer uint128) bsp-bits) 0)
            )
          (&+! dest-bits 16)
          (set! bsp-bits (&-> (the-as (pointer uint16) bsp-bits) 8))
          )
        )
      (let ((result #f))
        (b! #t cfg-55 :delay (nop!))
        (the-as none 0)
        (label cfg-21)
        (when (check-busy *ramdisk-rpc*)
          (set! (-> vis-info current-vis-string) (the-as uint -1))
          (set! (-> obj all-visible?) 'loading)
          (if (= *cheat-mode* 'debug)
              (format *stdcon* "Ramdisk loading~%")
              )
          (return #f)
          )
        (set! (-> vis-info flags) (logior (-> vis-info flags) #x40000000))
        (ramdisk-load
          (the-as int vis-load-result)
          desired-vis-str
          (the-as uint 2048)
          (-> obj vis-buffer)
          )
        (set! result #f)
        (b! #t cfg-55 :delay (nop!))
        
        
        ;; setup loaded
        (label cfg-27)
        (let ((lower-flag-bits (the-as int (logand #x1fffffff (-> vis-info flags))))
              (spad-start (the-as object (+ 16 #x70000000)))
              (spad-end (+ 2064 #x70000000))
              (list-len (-> obj bsp visible-list-length))
              )
          (when (zero? (the-as vis-info-flag lower-flag-bits))
            (let ((list-qwc (/ (+ list-len 15) 16)))
              (dotimes (a0-28 list-qwc)
                (set!
                  (-> (the-as (pointer uint128) spad-start) a0-28)
                  (the-as uint128 0)
                  )
                )
              )
            (mem-copy!
              (the-as pointer spad-start)
              (the-as pointer vis-buffer)
              list-len
              )
            )
          (while (nonzero? lower-flag-bits)
            (case (logand lower-flag-bits 7) 
                  ((1)
                   (let ((v1-55 (/ (+ list-len 15) 16)))
                     (dotimes (a0-32 v1-55)
                       (set! (-> (the-as (pointer uint128) spad-start) a0-32) (the-as uint128 0))
                       )
                     )
                   (dummy-16
                     (-> obj bsp drawable-trees)
                     (the-as int spad-start)
                     (the-as object vis-buffer)
                     )
                   )
                  ((2)
                   (unpack-comp-rle
                     (the-as (pointer int8) spad-start)
                     (the-as (pointer int8) vis-buffer)
                     )
                   )
                  ((3)
                   (unpack-comp-huf
                     (the-as (pointer uint8) spad-start)
                     (the-as (pointer uint8) vis-buffer)
                     (-> vis-info dictionary)
                     (the-as huf-dictionary-node
                             (+ (-> vis-info dictionary) (-> vis-info dictionary-length) -4)
                             )
                     )
                   )
                  )
            (set! vis-buffer (the-as (pointer uint8) (the-as int spad-start)))
            (set! spad-start spad-end)
            (set! spad-end (the-as int vis-buffer))
            (.sra lower-flag-bits lower-flag-bits 3)
            )
          (let ((s2-1 (the-as object vis-buffer))
                (s1-1 (the-as (pointer uinteger) (-> obj bsp all-visible-list)))
                (v1-67 #f)
                )
            (dotimes (s0-1 list-len)
              (when (!= (logand (-> (the-as (pointer uint8) s2-1) 0)
                                (-> (the-as (pointer uint8) s1-1) 0)
                                )
                        (-> (the-as (pointer uint8) s2-1) 0)
                        )
                (format #t "ERROR: illegal vis bits set [byte ~X] ~X -> ~X~%"
                        s0-1
                        (-> (the-as (pointer uint8) s2-1) 0)
                        (-> (the-as (pointer uint8) s1-1) 0)
                        )
                (set! v1-67 #t)
                )
              (set! s2-1 (&-> (the-as (pointer uint8) s2-1) 1))
              (set! s1-1 (&+ (the-as (pointer uint16) s1-1) 1))
              )
            (when v1-67
              (format #t "src = #x~x dest = #x~x  ~s  ~s~%"
                      (the-as object vis-buffer)
                      (-> vis-info vis-bits)
                      (-> vis-info level)
                      (-> vis-info from-level)
                      )
              (format #t "leaf-index = ~d~%" (-> vis-info from-bsp current-leaf-idx))
              0
              )
            )
          (let ((v1-71 (the-as object vis-buffer))
                (a0-47 (-> vis-info vis-bits))
                (a1-22 (the-as (pointer uinteger) (-> obj bsp all-visible-list)))
                (a2-11 (/ (+ list-len 15) 16))
                )
            (dotimes (a3-8 a2-11)
              (let ((t0-2 (-> (the-as (pointer uint128) v1-71) 0))
                    (t1-1 (-> (the-as (pointer uint128) a1-22) 0))
                    )
                (.pand t0-3 t0-2 t1-1)
                )
              (set! (-> (the-as (pointer uint128) a0-47) 0) t0-3)
              (&+! a0-47 16)
              (set! v1-71 (&-> (the-as (pointer uint16) v1-71) 8))
              (set! a1-22 (&-> (the-as (pointer uint16) a1-22) 8))
              )
            )
          )
        (set! result #t)
        (label cfg-55)
        result
        )
      )
    )
  )