;;-*-Lisp-*-
(in-package goal)

;; name: matrix-h.gc
;; name in dgo: matrix-h
;; dgos: GAME, ENGINE

;; A 4x4 matrix, stored in row-major order
;; some, but not all, functions assume that a matrix is an affine transform.
;; others assume that the rotation has no scale or shear (and that its inverse is its transpose)
(deftype matrix (structure)
  ((vector vector 4 :inline :offset-assert 0)
   (quad   uint128 4  :offset 0)
   (data   float 16 :offset 0) ;; moved so the decompiler looks at vector first.
   )
  :method-count-assert 10
  :size-assert         #x40
  :flag-assert         #xa00000040
  (:methods
   (transform-vectors! (_type_ (inline-array vector) (inline-array vector) int) none 9)
   )
  )

;; A 3x3 matrix, stored in row-major order.
;; NOTE: the rows each have an extra 4-bytes of padding
;;  so this is really a 3x4 matrix.
;; this type is rarely used
(deftype matrix3 (structure)
  ((data   float 12 :offset-assert 0)
   (vector vector 3  :inline :offset 0)
   (quad   uint128 3  :offset 0)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )

;; a matrix stored using 16-bit integers.
;; note that these usually have different scaling for the 4th row which
;; contains the translation in an affine transform.
;; so you generally should not unpack these to floats without knowing where they came from
;; and how they were originally packed (for example, in tie/shrub)
(deftype matrix4h (structure)
  ((data     int16 16 :offset-assert 0)
   (vector4h vector4h 4 :inline :offset 0)
   (long     int64 4  :offset 0)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )

(defun matrix-copy! ((dst matrix) (src matrix))
  "Copy src to dst"
  (let ((v1-0 (-> src vector 0 quad))
        (a2-0 (-> src vector 1 quad))
        (a3-0 (-> src vector 2 quad))
        (a1-1 (-> src vector 3 quad))
        )
    (set! (-> dst vector 0 quad) v1-0)
    (set! (-> dst vector 1 quad) a2-0)
    (set! (-> dst vector 2 quad) a3-0)
    (set! (-> dst vector 3 quad) a1-1)
    )
  dst
  )

(defmacro new-stack-matrix0 ()
  "Get a new matrix on the stack that's set to zero."
  `(let ((mat (new 'stack-no-clear 'matrix)))
     (set! (-> mat quad 0) (the-as uint128 0))
     (set! (-> mat quad 1) (the-as uint128 0))
     (set! (-> mat quad 2) (the-as uint128 0))
     (set! (-> mat quad 3) (the-as uint128 0))
     mat
     )
  )
