;;-*-Lisp-*-
(in-package goal)

;; name: vector.gc
;; name in dgo: vector
;; dgos: GAME, ENGINE

(defun vector-cross! ((arg0 vector) (arg1 vector) (arg2 vector))
  "Compute the cross product."
  (rlet ((acc :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (.lvf vf1 (&-> arg1 quad))
    (.lvf vf2 (&-> arg2 quad))
    (.outer.product.vf vf3 vf1 vf2)
    (.svf (&-> arg0 quad) vf3)
    arg0
    )
  )

(defun vector+float! ((arg0 vector) (arg1 vector) (arg2 float))
  "Add float to each component of vector. The w component is set to 1"
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.mov vf6 arg2)
   (.lvf vf4 (&-> arg1 quad))
   (.add.x.vf vf5 vf0 vf0 :mask #b1000)
   (.add.x.vf vf5 vf4 vf6 :mask #b111)
   (.svf (&-> arg0 quad) vf5)
   arg0
   )
  )

(defun vector*! ((arg0 vector) (arg1 vector) (arg2 vector))
  "Elementwise product. Set w = 1"
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf4 (&-> arg1 quad))
   (.lvf vf5 (&-> arg2 quad))
   (.add.x.vf vf6 vf0 vf0 :mask #b1000)
   (.mul.vf vf6 vf4 vf5 :mask #b111)
   (.svf (&-> arg0 quad) vf6)
   arg0
   )
  )

(defun vector+*! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  "set arg0 = arg1 + (arg3 * arg2). The w component will be set to 1"
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.mov vf7 arg3)
   (.lvf vf5 (&-> arg2 quad))
   (.lvf vf4 (&-> arg1 quad))
   (.add.x.vf vf6 vf0 vf0 :mask #b1000)
   (.mul.x.vf acc vf5 vf7 :mask #b111)
   ;; acts as just an add.
   (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
   (.svf (&-> arg0 quad) vf6)
   arg0
   )
  )

(defun vector-*! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  "Set arg0 = arg1 - (arg3 * arg2). The w component will be set to 1."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.mov vf7 arg3)
   (.lvf vf5 (&-> arg2 quad))
   (.lvf vf4 (&-> arg1 quad))
   (.add.x.vf vf6 vf0 vf0 :mask #b1000)
   (.mul.w.vf acc vf4 vf0 :mask #b111)
   (.sub.mul.x.vf vf6 vf5 vf7 acc :mask #b111)
   (.svf (&-> arg0 quad) vf6)
   arg0
   )
  )

(defun vector/! ((arg0 vector) (arg1 vector) (arg2 vector))
  "Set arg0 = arg1 / arg2. The w component will be set to 1. 
   The implementation is kind of crazy."
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
    (.lvf vf5 (&-> arg2 quad))
    ;; get started on the first divide ASAP.
    ;; do this before loading the second value.
    ;; q = 1 / arg2.y
    (.div.vf Q vf0 vf5 :fsf #b11 :ftf #b1)
    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
    (.lvf vf4 (&-> arg1 quad))
    ;; use FPU to divide x while VU0 is dividing y.
    (let ((v1-0 (/ (-> arg1 data 0) (-> arg2 data 0))))
      (.wait.vf)
     
      (.mul.vf vf6 vf4 Q :mask #b10)
      (.nop.vf)
      (.nop.vf)
      (.div.vf Q vf0 vf5 :fsf #b11 :ftf #b10)
      (.mov vf7 v1-0)
      )
    (.add.x.vf vf6 vf0 vf7 :mask #b1)
    (.wait.vf)
    (.mul.vf vf6 vf4 Q :mask #b100)
    (.nop.vf)
    (.nop.vf)
    (.svf (&-> arg0 quad) vf6)
    arg0
    )
  )

(defun vector-float*! ((arg0 vector) (arg1 vector) (arg2 float))
  "Multiply all values in a vector by arg2. Set w to 1."
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 quad))
   (.mov vf2 arg2)
   (.add.x.vf vf1 vf0 vf0 :mask #b1000)
   (.mul.x.vf vf1 vf1 vf2 :mask #b111)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-average! ((arg0 vector) (arg1 vector) (arg2 vector))
  "Set arg0 to the average of arg1 and arg2. Set w to 1."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (let ((v1-0 #x3f000000))
    (.lvf vf1 (&-> arg1 quad))
    (.lvf vf2 (&-> arg2 quad))
    (.mov vf3 v1-0)
    )
   (.add.x.vf vf4 vf0 vf0 :mask #b1000)
   (.mul.x.vf acc vf1 vf3)
   (.add.mul.x.vf vf4 vf2 vf3 acc :mask #b111)
   (.svf (&-> arg0 quad) vf4)
   arg0
   )
  )

(defun vector+float*! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  "Set arg0 = arg1 + (arg2 * arg3). The w component will be set to 1.
   Is this different at all from vector+*! ? The implementation is slightly different
   but I think it comes out to the same thing."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf2 (&-> arg2 quad))
   (.lvf vf1 (&-> arg1 quad))
   (.mov vf3 arg3)
   (.add.x.vf vf4 vf0 vf0 :mask #b1000)
   (.mul.x.vf acc vf2 vf3)
   (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
   (.svf (&-> arg0 quad) vf4)
   arg0
   )
  )

(defun vector--float*! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  "Set arg0 = arg1 - (arg2 * arg3). The w component will be set to 1
   Is this different from vector-*!"
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf2 (&-> arg2 quad))
   (.lvf vf1 (&-> arg1 quad))
   (.mov vf3 arg3)
   (.add.x.vf vf4 vf0 vf0 :mask #b1000)
   (.mul.w.vf acc vf1 vf0)
   (.sub.mul.x.vf vf4 vf2 vf3 acc :mask #b111)
   (.svf (&-> arg0 quad) vf4)
   arg0
   )
  )

(defun vector-float/! ((arg0 vector) (arg1 vector) (arg2 float))
  "Divide all components by arg2. The w component will be set to 1."
  (rlet ((Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.mov vf3 arg2)
   (.div.vf Q vf0 vf3 :fsf #b11 :ftf #b0)
   (.lvf vf1 (&-> arg1 quad))
   (.add.x.vf vf4 vf0 vf0 :mask #b1000)
   (.wait.vf)
   (.mul.vf vf4 vf1 Q :mask #b111)
   (.nop.vf)
   (.nop.vf)
   (.svf (&-> arg0 quad) vf4)
   arg0
   )
  )


(defun vector-negate! ((arg0 vector) (arg1 vector))
  "Negate xyz, set w to 1"
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 quad))
   (.sub.vf vf4 vf0 vf1 :mask #b111)
   (.add.x.vf vf4 vf0 vf0 :mask #b1000)
   (.svf (&-> arg0 quad) vf4)
   arg0
   )
  )

(defun vector-negate-in-place! ((arg0 vector))
  "Negate xyz. Doesn't touch w."
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.sub.vf vf1 vf0 vf1 :mask #b111)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector= ((arg0 vector) (arg1 vector))
  "Are the two vectors equal? Does not compare the w component.
   The implementation is cool."
  
  ;; (label L91)
  ;;   (set! v0-0 #t)
  ;;   (set! v1-0 #xffff)
  (let* ((v1-0 #xffff)
         ;;   (set! a0-1 (l.q a0-0))
         (a0-1 (-> arg0 quad))
         ;;   (set! v1-1 (sll v1-0 48))
         (v1-1 (shl v1-0 48))
         ;;   (set! a1-1 (l.q a1-0))
         (a1-1 (-> arg1 quad))
         (a0-2 (the uint128 0))
         (r0 (the uint128 0))
         )
    ;;   (.pceqw a0-2 a0-1 a1-1)
    (.pceqw a0-2 a0-1 a1-1)
    ;;   (.ppach a0-3 r0-0 a0-2)
    (.ppach a0-2 r0 a0-2)
    ;;   (set! v1-2 (logior a0-3 v1-1))
    (set! v1-1 (logior (the int a0-2) v1-1))
    ;;   (set! v1-3 (+ v1-2 1))
    ;; will overflow the 64-bit integer if xyz is equal.
    (set! v1-1 (+ v1-1 1))
    (zero? v1-1)
    )
          
  ;;   (b! (zero? v1-3) L92 (nop!))
  ;;   (set! v0-0 #f)
  ;; (label L92)
  ;;   (ret-value v0-0)
  
  )

(defun vector-delta ((arg0 vector) (arg1 vector))
  "Sum of the elementwise absolute value of differences"
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.lvf vf2 (&-> arg1 quad))
   (.sub.vf vf1 vf2 vf1)
   (.abs.vf vf1 vf1)
   (.mul.x.vf acc vf0 vf1 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf1 acc :mask #b1000)
   (.add.mul.z.vf vf3 vf0 vf1 acc :mask #b1000)
   (.add.w.vf vf3 vf0 vf3 :mask #b1)
   (.mov v0-0 vf3)
   v0-0
   )
  )

(defun vector-seek! ((arg0 vector) (arg1 vector) (arg2 float))
  "Seek arg0 toward arg1. The arg0 is both read and written.
   arg2 is saturated to (0, 1)"
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.mov vf4 arg2)
   (.lvf vf1 (&-> arg1 quad))
   (.lvf vf2 (&-> arg0 quad))
   (.add.x.vf vf1 vf0 vf0 :mask #b1000)
   (.sub.x.vf vf5 vf0 vf4 :mask #b1)
   (.sub.vf vf3 vf1 vf2 :mask #b111)
   (.min.x.vf vf3 vf3 vf4 :mask #b111)
   (.max.x.vf vf3 vf3 vf5 :mask #b111)
   (.add.vf vf1 vf2 vf3 :mask #b111)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-seek-2d-xz-smooth! ((arg0 vector) (arg1 vector) (arg2 float) (arg3 float))
  (let ((f0-1 (- (-> arg1 data 0) (-> arg0 data 0)))
        (f2-1 (- (-> arg1 data 2) (-> arg0 data 2)))
        )
   (if (or (!= f0-1 0.0) (!= f2-1 0.0))
    (let* ((f1-5 (* f0-1 arg3))
           (f0-3 (* f2-1 arg3))
           (f2-4 (sqrtf (+ (* f1-5 f1-5) (* f0-3 f0-3))))
           )
     (cond
      ((>= arg2 f2-4)
       (set! (-> arg0 data 0) (+ (-> arg0 data 0) f1-5))
       (let ((f0-4 (+ (-> arg0 data 2) f0-3)))
        (set! (-> arg0 data 2) f0-4)
        )
       )
      (else
       (let ((f2-6 (/ arg2 f2-4)))
        (set! (-> arg0 data 0) (+ (-> arg0 data 0) (* f2-6 f1-5)))
        (let ((f0-6 (+ (-> arg0 data 2) (* f2-6 f0-3))))
         (set! (-> arg0 data 2) f0-6)
         )
        )
       )
      )
     )
    )
   )
  arg0
  )

(defun vector-seek-2d-yz-smooth! ((arg0 vector) (arg1 vector) (arg2 float) (arg3 float))
  (let ((f0-1 (- (-> arg1 data 1) (-> arg0 data 1)))
        (f2-1 (- (-> arg1 data 2) (-> arg0 data 2)))
        )
   (if (or (!= f0-1 0.0) (!= f2-1 0.0))
    (let* ((f1-5 (* f0-1 arg3))
           (f0-3 (* f2-1 arg3))
           (f2-4 (sqrtf (+ (* f1-5 f1-5) (* f0-3 f0-3))))
           )
     (cond
      ((>= arg2 f2-4)
       (set! (-> arg0 data 1) (+ (-> arg0 data 1) f1-5))
       (let ((f0-4 (+ (-> arg0 data 2) f0-3)))
        (set! (-> arg0 data 2) f0-4)
        )
       )
      (else
       (let ((f2-6 (/ arg2 f2-4)))
        (set! (-> arg0 data 1) (+ (-> arg0 data 1) (* f2-6 f1-5)))
        (let ((f0-6 (+ (-> arg0 data 2) (* f2-6 f0-3))))
         (set! (-> arg0 data 2) f0-6)
         )
        )
       )
      )
     )
    )
   )
  arg0
  )

(defun vector-seek-3d-smooth! ((arg0 vector) (arg1 vector) (arg2 float) (arg3 float))
  (let ((f0-1 (- (-> arg1 data 0) (-> arg0 data 0)))
        (f1-2 (- (-> arg1 data 1) (-> arg0 data 1)))
        (f3-1 (- (-> arg1 data 2) (-> arg0 data 2)))
        )
   (if (or (!= f0-1 0.0) (!= f1-2 0.0) (!= f3-1 0.0))
    (let* ((f2-6 (* f0-1 arg3))
           (f1-3 (* f1-2 arg3))
           (f0-4 (* f3-1 arg3))
           (f3-5 (sqrtf (+ (+ (* f2-6 f2-6) (* f1-3 f1-3)) (* f0-4 f0-4))))
           )
     (cond
      ((>= arg2 f3-5)
       (set! (-> arg0 data 0) (+ (-> arg0 data 0) f2-6))
       (set! (-> arg0 data 1) (+ (-> arg0 data 1) f1-3))
       (let ((f0-5 (+ (-> arg0 data 2) f0-4)))
        (set! (-> arg0 data 2) f0-5)
        )
       )
      (else
       (let ((f3-7 (/ arg2 f3-5)))
        (set! (-> arg0 data 0) (+ (-> arg0 data 0) (* f3-7 f2-6)))
        (set! (-> arg0 data 1) (+ (-> arg0 data 1) (* f3-7 f1-3)))
        (let ((f0-7 (+ (-> arg0 data 2) (* f3-7 f0-4))))
         (set! (-> arg0 data 2) f0-7)
         )
        )
       )
      )
     )
    )
   )
  arg0
  )

(defun seek-with-smooth ((arg0 float) (arg1 float) (arg2 float) (arg3 float) (arg4 float))
  (let ((f0-1 (- arg1 arg0)))
   (if (>= arg4 (fabs f0-1))
    arg1
    (let ((f0-2 (* f0-1 arg3)))
     (let ((f1-4 (- arg2)))
      (cond
       ((< f0-2 f1-4)
        (set! f0-2 f1-4)
        )
       ((< arg2 f0-2)
        (set! f0-2 arg2)
        )
       )
      )
     (+ f0-2 arg0)
     )
    )
   )
  )

(defun vector-identity! ((arg0 vector))
  (set! (-> arg0 data 0) 1.0)
  (set! (-> arg0 data 1) 1.0)
  (set! (-> arg0 data 2) 1.0)
  (set! (-> arg0 data 3) 1.0)
  arg0
  )

(defun vector-seconds ((arg0 vector) (arg1 vector))
  (set! (-> arg0 data 0) (* 300.0 (-> arg1 data 0)))
  (set! (-> arg0 data 1) (* 300.0 (-> arg1 data 1)))
  (set! (-> arg0 data 2) (* 300.0 (-> arg1 data 2)))
  arg0
  )

(defun vector-seconds! ((arg0 vector))
  (set! (-> arg0 data 0) (* 300.0 (-> arg0 data 0)))
  (set! (-> arg0 data 1) (* 300.0 (-> arg0 data 1)))
  (set! (-> arg0 data 2) (* 300.0 (-> arg0 data 2)))
  arg0
  )

(defun vector-v! ((arg0 vector))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
    (let ((v1-0 arg0))
      (let ((a1-0 arg0)
            (f0-0 (-> *display* seconds-per-frame))
            )
        (.lvf vf1 (&-> a1-0 quad))
        (let ((a1-1 f0-0))
          (.mov vf2 a1-1)
          )
        )
      (.add.x.vf vf1 vf0 vf0 :mask #b1000)
      (.mul.x.vf vf1 vf1 vf2 :mask #b111)
      (.svf (&-> v1-0 quad) vf1)
      )
    arg0
    )
  )

(defun vector-v+! ((arg0 vector) (arg1 vector) (arg2 vector))
  (vector+float*! arg0 arg1 arg2 (-> *display* seconds-per-frame))
  arg0
  )

(defun vector-v*float+! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (vector+float*! arg0 arg1 arg2 (* arg3 (-> *display* seconds-per-frame)))
  arg0
  )

(defun vector-v++! ((arg0 vector) (arg1 vector))
  (vector+float*! arg0 arg0 arg1 (-> *display* seconds-per-frame))
  arg0
  )

(defun vector-v*float! ((arg0 vector) (arg1 float) (arg2 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (let ((v0-0 arg0))
    (let ((v1-0 arg1)
          (f0-1 (* arg2 (-> *display* seconds-per-frame)))
          )
     (.lvf vf1 v1-0)
     (let ((v1-1 f0-1))
      (.mov vf2 v1-1)
      )
     )
    (.add.x.vf vf1 vf0 vf0 :mask #b1000)
    (.mul.x.vf vf1 vf1 vf2 :mask #b111)
    (.svf (&-> v0-0 quad) vf1)
    v0-0
    )
   )
  )

(defun vector-v*float++! ((arg0 vector) (arg1 vector) (arg2 float))
  (vector+float*! arg0 arg0 arg1 (* arg2 (-> *display* seconds-per-frame)))
  arg0
  )

(defun vector-to-ups! ((arg0 vector) (arg1 vector))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 quad))
   (let ((f0-0 (-> *display* frames-per-second)))
    (.mov at-0 f0-0)
    )
   (.mov vf2 at-0)
   (.mov.vf vf1 vf0 :mask #b1000)
   (.mul.x.vf vf1 vf1 vf2 :mask #b111)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-from-ups! ((arg0 vector) (arg1 vector))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 quad))
   (let ((f0-0 (-> *display* seconds-per-frame)))
    (.mov at-0 f0-0)
    )
   (.mov vf2 at-0)
   (.mov.vf vf1 vf0 :mask #b1000)
   (.mul.x.vf vf1 vf1 vf2 :mask #b111)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-length ((arg0 vector))
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.mul.vf vf1 vf1 vf1)
   (.mul.x.vf acc vf0 vf1 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf1 acc :mask #b1000)
   (.add.mul.z.vf vf1 vf0 vf1 acc :mask #b1000)
   (.sqrt.vf Q vf1 :ftf #b11)
   (.add.w.vf vf1 vf0 vf0 :mask #b1)
   (.wait.vf)
   (.mul.vf vf1 vf1 Q :mask #b1)
   (.nop.vf)
   (.nop.vf)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun vector-length-squared ((arg0 vector))
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.add.w.vf vf2 vf0 vf0 :mask #b1)
   (.mul.vf vf1 vf1 vf1)
   (.mul.x.vf acc vf2 vf1 :mask #b1)
   (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
   (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun vector-xz-length-squared ((arg0 vector))
  (+
   (* (-> arg0 data 0) (-> arg0 data 0))
   (* (-> arg0 data 2) (-> arg0 data 2))
   )
  )

(defun vector-xz-length ((arg0 vector))
  (sqrtf
   (+
    (* (-> arg0 data 0) (-> arg0 data 0))
    (* (-> arg0 data 2) (-> arg0 data 2))
    )
   )
  )

(defun vector-vector-distance ((arg0 vector) (arg1 vector))
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf2 (&-> arg0 quad))
   (.lvf vf3 (&-> arg1 quad))
   (.sub.vf vf1 vf3 vf2)
   (.mul.vf vf1 vf1 vf1)
   (.mul.x.vf acc vf0 vf1 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf1 acc :mask #b1000)
   (.add.mul.z.vf vf1 vf0 vf1 acc :mask #b1000)
   (.sqrt.vf Q vf1 :ftf #b11)
   (.add.w.vf vf1 vf0 vf0 :mask #b1)
   (.wait.vf)
   (.mul.vf vf1 vf1 Q :mask #b1)
   (.nop.vf)
   (.nop.vf)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun vector-vector-distance-squared ((arg0 vector) (arg1 vector))
  (local-vars (v0-0 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf2 (&-> arg0 quad))
   (.lvf vf3 (&-> arg1 quad))
   (.sub.vf vf1 vf3 vf2)
   (.mul.vf vf1 vf1 vf1)
   (.add.y.vf vf1 vf1 vf1 :mask #b1)
   (.add.z.vf vf1 vf1 vf1 :mask #b1)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun vector-vector-xz-distance ((arg0 vector) (arg1 vector))
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf2 (&-> arg0 quad))
   (.lvf vf3 (&-> arg1 quad))
   (.sub.vf vf1 vf3 vf2)
   (.mul.vf vf1 vf1 vf1)
   (.mul.x.vf acc vf0 vf1 :mask #b1000)
   (.add.mul.z.vf vf1 vf0 vf1 acc :mask #b1000)
   (.sqrt.vf Q vf1 :ftf #b11)
   (.add.w.vf vf1 vf0 vf0 :mask #b1)
   (.wait.vf)
   (.mul.vf vf1 vf1 Q :mask #b1)
   (.nop.vf)
   (.nop.vf)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun vector-vector-xz-distance-squared ((arg0 vector) (arg1 vector))
  (local-vars (v0-0 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf2 (&-> arg0 quad))
   (.lvf vf3 (&-> arg1 quad))
   (.sub.vf vf1 vf3 vf2)
   (.mul.vf vf1 vf1 vf1)
   (.add.z.vf vf1 vf1 vf1 :mask #b1)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun vector-normalize! ((arg0 vector) (arg1 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.mul.vf vf2 vf1 vf1 :mask #b111)
   (let ((v1-0 arg1))
    (.mov vf3 v1-0)
    )
   (.mul.x.vf acc vf0 vf2 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
   (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
   (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
   (.wait.vf)
   (.mul.vf vf1 vf1 Q :mask #b111)
   (.nop.vf)
   (.nop.vf)
   (.nop.vf)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-normalize-ret-len! ((arg0 vector) (arg1 float))
  (local-vars (v1-1 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.mul.vf vf2 vf1 vf1 :mask #b111)
   (let ((v1-0 arg1))
    (.mov vf3 v1-0)
    )
   (.mul.x.vf acc vf0 vf2 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
   (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
   (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
   (.add.w.vf vf2 vf0 vf2 :mask #b1)
   (.mov v1-1 vf2)
   (let ((v0-0 (sqrtf v1-1)))
    (.wait.vf)
    (.mul.vf vf1 vf1 Q :mask #b111)
    (.nop.vf)
    (.nop.vf)
    (.nop.vf)
    (.svf (&-> arg0 quad) vf1)
    v0-0
    )
   )
  )

(defun vector-normalize-copy! ((arg0 vector) (arg1 vector) (arg2 float))
  (let ((f0-0 (vector-length arg1)))
   (if (= f0-0 0.0)
    (set! (-> arg0 quad) (-> arg1 quad))
    (let ((v1-1 (/ arg2 f0-0)))
     (set! (-> arg0 data 0) (* (-> arg1 data 0) v1-1))
     (set! (-> arg0 data 1) (* (-> arg1 data 1) v1-1))
     (let ((f0-7 (* (-> arg1 data 2) v1-1)))
      (set! (-> arg0 data 2) f0-7)
      )
     )
    )
   )
  (set! (-> arg0 data 3) 1.0)
  arg0
  )

(defun vector-xz-normalize! ((arg0 vector) (arg1 float))
  (let ((f0-0 (vector-xz-length arg0)))
   (if (!= f0-0 0.0)
    (let ((v1-1 (/ arg1 f0-0)))
     (set! (-> arg0 data 0) (* (-> arg0 data 0) v1-1))
     (let ((f0-5 (* (-> arg0 data 2) v1-1)))
      (set! (-> arg0 data 2) f0-5)
      )
     )
    )
   )
  arg0
  )

(defun vector-length-max! ((arg0 vector) (arg1 float))
  (let ((f0-0 (vector-length arg0)))
   (when (not (or (= f0-0 0.0) (< f0-0 arg1)))
    (set! f0-0 (/ f0-0 arg1))
    (when (!= f0-0 0.0)
     (set! (-> arg0 data 0) (/ (-> arg0 data 0) f0-0))
     (set! (-> arg0 data 1) (/ (-> arg0 data 1) f0-0))
     (let ((f0-1 (/ (-> arg0 data 2) f0-0)))
      (set! (-> arg0 data 2) f0-1)
      )
     )
    )
   )
  arg0
  )

(defun vector-xz-length-max! ((arg0 vector) (arg1 float))
  (let ((f0-0 (vector-xz-length arg0)))
   (when (not (or (= f0-0 0.0) (< f0-0 arg1)))
    (set! f0-0 (/ f0-0 arg1))
    (when (!= f0-0 0.0)
     (set! (-> arg0 data 0) (/ (-> arg0 data 0) f0-0))
     (let ((f0-1 (/ (-> arg0 data 2) f0-0)))
      (set! (-> arg0 data 2) f0-1)
      )
     )
    )
   )
  arg0
  )

(defun vector-rotate-around-y! ((arg0 vector) (arg1 vector) (arg2 float))
  (let ((f26-0 (-> arg1 data 2))
        (f30-0 (-> arg1 data 0))
        (f28-0 (cos arg2))
        (f0-0 (sin arg2))
        )
   (set! (-> arg0 quad) (-> arg1 quad))
   (set! (-> arg0 data 2) (- (* f26-0 f28-0) (* f30-0 f0-0)))
   (set! (-> arg0 data 0) (+ (* f26-0 f0-0) (* f30-0 f28-0)))
   )
  arg0
  )

(defun rotate-y<-vector+vector ((arg0 vector) (arg1 vector))
  (atan
   (- (-> arg1 data 0) (-> arg0 data 0))
   (- (-> arg1 data 2) (-> arg0 data 2))
   )
  )

(defun vector-cvt.w.s! ((arg0 vector) (arg1 vector))
  (rlet ((vf1 :class vf))
   (.lvf vf1 (&-> arg1 quad))
   (.ftoi.vf vf1 vf1)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-cvt.s.w! ((arg0 vector) (arg1 vector))
  (rlet ((vf1 :class vf))
   (.lvf vf1 (&-> arg1 quad))
   (.itof.vf vf1 vf1)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun rot-zxy-from-vector! ((arg0 vector) (arg1 vector))
  (let* ((f28-0 (-> arg1 data 2))
         (f30-0 (-> arg1 data 0))
         (f0-0 (atan f30-0 f28-0))
         )
   (set! (-> arg0 data 1) f0-0)
   (let* ((f26-0 (- f0-0))
          (f0-4 (- (* f28-0 (cos f26-0)) (* f30-0 (sin f26-0))))
          (f0-5 (atan (- (-> arg1 data 1)) f0-4))
          )
    (set! (-> arg0 data 0) f0-5)
    )
   )
  (set! (-> arg0 data 2) 0.0)
  arg0
  )

(defun rot-zyx-from-vector! ((arg0 vector) (arg1 vector))
  (let* ((f28-0 (-> arg1 data 2))
         (f30-0 (- (-> arg1 data 1)))
         (f0-1 (atan f30-0 f28-0))
         )
   (set! (-> arg0 data 0) f0-1)
   (let* ((f26-0 (- f0-1))
          (f0-5 (- (* f28-0 (cos f26-0)) (* f30-0 (sin f26-0))))
          (f0-6 (atan (-> arg1 data 0) f0-5))
          )
    (set! (-> arg0 data 1) f0-6)
    )
   )
  (set! (-> arg0 data 2) 0.0)
  arg0
  )

;; definition for function vector-lerp!
(defun vector-lerp! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 quad))
   (.lvf vf2 (&-> arg2 quad))
   (.mov vf4 arg3)
   (.add.x.vf vf3 vf0 vf0 :mask #b1000)
   (.sub.vf vf2 vf2 vf1)
   (.mul.x.vf vf2 vf2 vf4)
   (.add.vf vf3 vf1 vf2 :mask #b111)
   (.svf (&-> arg0 quad) vf3)
   arg0
   )
  )

;; definition for function vector-lerp-clamp!
;; Used lq/sq
(defun
  vector-lerp-clamp!
  ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (cond
    ((>= 0.0 arg3)
     (set! (-> arg0 quad) (-> arg1 quad))
     )
    ((>= arg3 1.0)
     (set! (-> arg0 quad) (-> arg2 quad))
     )
    (else
     (let ((v1-2 arg0))
      (let ((f0-2 arg3))
       (.lvf vf1 (&-> arg1 quad))
       (.lvf vf2 (&-> arg2 quad))
       (let ((a1-1 f0-2))
        (.mov vf4 a1-1)
        )
       )
      (.add.x.vf vf3 vf0 vf0 :mask #b1000)
      (.sub.vf vf2 vf2 vf1)
      (.mul.x.vf vf2 vf2 vf4)
      (.add.vf vf3 vf1 vf2 :mask #b111)
      (.svf (&-> v1-2 quad) vf3)
      )
     )
    )
   arg0
   )
  )

;; definition for function vector4-lerp!
(defun vector4-lerp! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf1 (&-> arg1 quad))
   (.lvf vf2 (&-> arg2 quad))
   (.mov vf4 arg3)
   (.sub.vf vf2 vf2 vf1)
   (.mul.x.vf vf2 vf2 vf4)
   (.add.vf vf3 vf1 vf2)
   (.svf (&-> arg0 quad) vf3)
   arg0
   )
  )

;; definition for function vector4-lerp-clamp!
;; Used lq/sq
(defun
  vector4-lerp-clamp!
  ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (cond
    ((>= 0.0 arg3)
     (set! (-> arg0 quad) (-> arg1 quad))
     )
    ((>= arg3 1.0)
     (set! (-> arg0 quad) (-> arg2 quad))
     )
    (else
     (let ((v1-2 arg0))
      (let ((f0-2 arg3))
       (.lvf vf1 (&-> arg1 quad))
       (.lvf vf2 (&-> arg2 quad))
       (let ((a1-1 f0-2))
        (.mov vf4 a1-1)
        )
       )
      (.sub.vf vf2 vf2 vf1)
      (.mul.x.vf vf2 vf2 vf4)
      (.add.vf vf3 vf1 vf2)
      (.svf (&-> v1-2 quad) vf3)
      )
     )
    )
   arg0
   )
  )

(defun vector-degi ((arg0 vector) (arg1 vector))
  (local-vars (v1-0 float) (v1-1 uint128))
  (rlet ((vf1 :class vf))
   (.lvf vf1 (&-> arg1 quad))
   (.ftoi.vf vf1 vf1)
   (.mov v1-0 vf1)
   (.pw.sll v1-1 v1-0 16)
   (set! (-> arg0 quad) (the-as uint128 v1-1))
   arg0
   )
  )

(defun vector-degf ((arg0 vector) (arg1 vector))
  (local-vars (v1-1 uint128))
  (rlet ((vf1 :class vf))
   (let ((v1-0 (-> arg1 quad)))
    (.pw.sra v1-1 v1-0 16)
    )
   (.mov vf1 v1-1)
   (.itof.vf vf1 vf1)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

(defun vector-degmod ((arg0 vector) (arg1 vector))
  (local-vars (v1-0 float) (v1-1 uint128) (v1-2 uint128))
  (rlet ((vf1 :class vf))
   (.lvf vf1 (&-> arg1 quad))
   (.ftoi.vf vf1 vf1)
   (.mov v1-0 vf1)
   (.pw.sll v1-1 v1-0 16)
   (.pw.sra v1-2 v1-1 16)
   (.mov vf1 v1-2)
   (.itof.vf vf1 vf1)
   (.svf (&-> arg0 quad) vf1)
   arg0
   )
  )

;; todo: vector-deg-diff

(defun vector-deg-lerp-clamp! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 float))
  (cond
   ((>= 0.0 arg3)
    (let ((v1-0 arg0))
     (set! (-> v1-0 quad) (-> arg1 quad))
     )
    )
   ((>= arg3 1.0)
    (let ((v1-1 arg0))
     (set! (-> v1-1 quad) (-> arg2 quad))
     )
    )
   (else
    (set!
     (-> arg0 data 0)
     (deg-lerp-clamp (-> arg1 data 0) (-> arg2 data 0) arg3)
     )
    (set!
     (-> arg0 data 1)
     (deg-lerp-clamp (-> arg1 data 1) (-> arg2 data 1) arg3)
     )
    (set!
     (-> arg0 data 2)
     (deg-lerp-clamp (-> arg1 data 2) (-> arg2 data 2) arg3)
     )
    (let ((f0-11 1.0))
     (set! (-> arg0 data 3) f0-11)
     )
    )
   )
  arg0
  )

(defun vector3s-copy! ((arg0 vector) (arg1 vector))
  (let ((v1-0 "Copy a vector3s"))
   )
  (set! (-> arg0 data 0) (-> arg1 data 0))
  (set! (-> arg0 data 1) (-> arg1 data 1))
  (set! (-> arg0 data 2) (-> arg1 data 2))
  arg0
  )

(defun vector3s+! ((arg0 vector) (arg1 vector) (arg2 vector))
  (let ((v1-0 "Add 2 vectors3."))
   )
  (set! (-> arg0 data 0) (+ (-> arg1 data 0) (-> arg2 data 0)))
  (set! (-> arg0 data 1) (+ (-> arg1 data 1) (-> arg2 data 1)))
  (set! (-> arg0 data 2) (+ (-> arg1 data 2) (-> arg2 data 2)))
  arg0
  )

(defun vector3s*float! ((arg0 vector) (arg1 vector) (arg2 float))
  (let ((v1-0 "mult vectors3 by float"))
   )
  (set! (-> arg0 data 0) (* (-> arg1 data 0) arg2))
  (set! (-> arg0 data 1) (* (-> arg1 data 1) arg2))
  (set! (-> arg0 data 2) (* (-> arg1 data 2) arg2))
  arg0
  )

(defun vector3s-! ((arg0 vector) (arg1 vector) (arg2 vector))
  (let ((v1-0 "Subtract 2 vectors3: c = (a - b)."))
   )
  (set! (-> arg0 data 0) (- (-> arg1 data 0) (-> arg2 data 0)))
  (set! (-> arg0 data 1) (- (-> arg1 data 1) (-> arg2 data 1)))
  (set! (-> arg0 data 2) (- (-> arg1 data 2) (-> arg2 data 2)))
  arg0
  )

(defun spheres-overlap? ((arg0 vector) (arg1 vector))
  (local-vars (v1-0 float) (a0-1 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 quad))
   (.lvf vf2 (&-> arg1 quad))
   (.sub.vf vf3 vf1 vf2 :mask #b111)
   (.mul.vf vf3 vf3 vf3 :mask #b111)
   (.add.w.vf vf4 vf1 vf2 :mask #b1000)
   (.mul.w.vf vf4 vf4 vf4 :mask #b1000)
   (.add.y.vf vf3 vf3 vf3 :mask #b1)
   (.add.z.vf vf3 vf3 vf3 :mask #b1)
   (.add.w.vf vf4 vf0 vf4 :mask #b1)
   (.mov a0-1 vf4)
   (.mov v1-0 vf3)
   (>= a0-1 v1-0)
   )
  )

(defun sphere<-vector! ((arg0 sphere) (arg1 vector))
  (let ((f0-0 (-> arg0 data 3)))
   (set! (-> arg0 quad) (-> arg1 quad))
   (set! (-> arg0 data 3) f0-0)
   )
  arg0
  )

(defun sphere<-vector+r! ((arg0 sphere) (arg1 vector) (arg2 float))
  (set! (-> arg0 quad) (-> arg1 quad))
  (set! (-> arg0 data 3) arg2)
  arg0
  )

(defun rand-vu-sphere-point! ((arg0 vector) (arg1 sphere))
  (let ((s4-0 arg0))
   (set! (-> s4-0 data 0) (rand-vu-float-range -1.0 1.0))
   (set! (-> s4-0 data 1) (rand-vu-float-range -1.0 1.0))
   (set! (-> s4-0 data 2) (rand-vu-float-range -1.0 1.0))
   (set! (-> s4-0 data 3) 1.0)
   )
  (vector-normalize! arg0 (rand-vu-float-range 0.0 (the-as float arg1)))
  )
