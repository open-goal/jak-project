;;-*-Lisp-*-
(in-package goal)

;; name: quaternion.gc
;; name in dgo: quaternion
;; dgos: GAME, ENGINE

(defmethod inspect quaternion ((obj quaternion))
  "Print a quaternion. Prints the values and axis-angle"
  (format #t "[~8x] quaternion~%" obj)
  (format #t "~T[~F] [~F] [~F] [~F]~%"
          (-> obj x)
          (-> obj y)
          (-> obj z)
          (-> obj w)
          )
  (let ((f0-5 (/ 1.0 (sqrtf
                      (+ (* (-> obj x) (-> obj x))
                         (* (-> obj y) (-> obj y))
                         (* (-> obj z) (-> obj z))
                         )
                      )
                 )
          )
        )
    (format #t "~Taxis: ~F ~F ~F"
            (* f0-5 (-> obj x))
            (* f0-5 (-> obj y))
            (* f0-5 (-> obj z))
            )
    )
  (let ((f0-9 (* 2.0 (acos (-> obj w)))))
    (format #t "~T~Tangle: (deg ~R)~%" f0-9)
    )
  obj
  )

(defun quaternion-axis-angle! ((quat quaternion) (x float) (y float) (z float) (angle float))
  "Construct a quaternion from an axis and angle. The axis should be normalized."
  (let* ((f28-0 (* 0.5 angle))
         (f30-0 (sin f28-0))
         (f0-1 (cos f28-0))
         )
   (set! (-> quat x) (* x f30-0))
   (set! (-> quat y) (* y f30-0))
   (set! (-> quat z) (* z f30-0))
   (set! (-> quat w) f0-1)
   )
  quat
  )

(defun quaternion-vector-angle! ((quat quaternion) (axis vector) (angle float))
  "Construct a quaternion from an axis and angle. The axis should be normalized."
  (let* ((f28-0 (* 0.5 angle))
         (f30-0 (sin f28-0))
         (f0-1 (cos f28-0))
         )
   (set! (-> quat x) (* (-> axis data 0) f30-0))
   (set! (-> quat y) (* (-> axis data 1) f30-0))
   (set! (-> quat z) (* (-> axis data 2) f30-0))
   (set! (-> quat w) f0-1)
   )
  quat
  )

(defun vector-angle<-quaternion! ((arg0 vector) (arg1 quaternion))
  "Convert the quaternion arg1 to axis-angle form and store in arg0 (angle goes in w)"
  (let* ((f0-0 1.0)
         (f1-0 1.0)
         (f2-0 (-> arg1 w))
         (f30-0 (/ f0-0 (sqrtf (- f1-0 (* f2-0 f2-0)))))
         (f0-3 (* 2.0 (acos-rad (-> arg1 w))))
         )
   (set! (-> arg0 data 0) (* (-> arg1 x) f30-0))
   (set! (-> arg0 data 1) (* (-> arg1 y) f30-0))
   (set! (-> arg0 data 2) (* (-> arg1 z) f30-0))
   (set! (-> arg0 data 3) f0-3)
   )
  arg0
  )

(defun quaternion-zero! ((arg0 quaternion))
  "Set quaternion to all 0's"
  (set! (-> arg0 vec quad) (the-as uint128 0))
  arg0
  )

(defun quaternion-identity! ((arg0 quaternion))
  "Set quaternion to 0,0,0,1 (identity)"
  (set! (-> arg0 vec quad) (the-as uint128 0))
  (set! (-> arg0 w) 1.0)
  arg0
  )

(defun quaternion-i! ((arg0 quaternion))
  "Create unit i quaternion"
  (set! (-> arg0 vec quad) (the-as uint128 0))
  (set! (-> arg0 x) 1.0)
  arg0
  )

(defun quaternion-j! ((arg0 quaternion))
  "Create unit j quaternion."
  (set! (-> arg0 vec quad) (the-as uint128 0))
  (set! (-> arg0 y) 1.0)
  arg0
  )

(defun quaternion-k! ((arg0 quaternion))
  "Create unit k quaternion"
  (set! (-> arg0 vec quad) (the-as uint128 0))
  (set! (-> arg0 z) 1.0)
  arg0
  )

(defun quaternion-copy! ((arg0 quaternion) (arg1 quaternion))
  "Set arg0 = arg1"
  (set! (-> arg0 vec quad) (-> arg1 vec quad))
  arg0
  )

(defun quaternion-set! ((arg0 quaternion) (arg1 float) (arg2 float) (arg3 float) (arg4 float))
  "Set arg0 = [arg1, arg2, arg3, arg4]"
  (set! (-> arg0 x) arg1)
  (set! (-> arg0 y) arg2)
  (set! (-> arg0 z) arg3)
  (set! (-> arg0 w) arg4)
  arg0
  )

(defun quaternion+! ((arg0 quaternion) (arg1 quaternion) (arg2 quaternion))
  "Add quaternions as vectors."
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf1 (&-> arg1 vec quad))
   (.lvf vf2 (&-> arg2 vec quad))
   (.add.vf vf1 vf1 vf2)
   (.svf (&-> arg0 vec quad) vf1)
   arg0
   )
  )

(defun quaternion-! ((arg0 quaternion) (arg1 quaternion) (arg2 quaternion))
  "Subtract quaternions as vectors."
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf1 (&-> arg1 vec quad))
   (.lvf vf2 (&-> arg2 vec quad))
   (.sub.vf vf1 vf1 vf2)
   (.svf (&-> arg0 vec quad) vf1)
   arg0
   )
  )

(defun quaternion-negate! ((arg0 quaternion) (arg1 quaternion))
  "Set arg0 = -arg1."
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf1 (&-> arg1 vec quad))
   ;;(.sub.vf vf2 vf2 vf2)
   (.xor.vf vf2 vf2 vf2)
   (.sub.vf vf1 vf2 vf1)
   (.svf (&-> arg0 vec quad) vf1)
   arg0
   )
  )

(defun quaternion-conjugate! ((arg0 quaternion) (arg1 quaternion))
  "Set arg0 to the conjugate of arg1 (negate only ijk).
   If arg1 is normalized, this is equivalent to the inverse
   NOTE: this gives you the inverse rotation."
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf1 (&-> arg1 vec quad))
   ;;(.sub.vf vf2 vf2 vf2)
   (.xor.vf vf2 vf2 vf2)
   (.sub.vf vf2 vf2 vf1 :mask #b111)
   (.add.vf vf2 vf2 vf1 :mask #b1000)
   (.svf (&-> arg0 vec quad) vf2)
   arg0
   )
  )

(defun quaternion-float*! ((arg0 quaternion) (arg1 quaternion) (arg2 float))
  "Multiply each element"
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf1 (&-> arg1 vec quad))
   (.mov vf2 arg2)
   (.mul.x.vf vf1 vf1 vf2)
   (.svf (&-> arg0 vec quad) vf1)
   arg0
   )
  )

(defun quaternion-float/! ((arg0 quaternion) (arg1 quaternion) (arg2 float))
  "Divide each element"
  (let ((f0-1 (/ 1.0 arg2)))
   (quaternion-float*! arg0 arg1 f0-1)
   )
  arg0
  )

(defun quaternion-norm2 ((arg0 quaternion))
  "Get the squared norm of a quaternion"
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 vec quad))
   (.mul.vf vf1 vf1 vf1)
   (.add.z.vf acc vf1 vf1 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf1 acc :mask #b1000)
   (.add.mul.x.vf vf1 vf0 vf1 acc :mask #b1000)
   (.add.w.vf vf1 vf0 vf1)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun quaternion-norm ((arg0 quaternion))
  "Get the norm of a quaternion."
  (local-vars (v1-1 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 vec quad))
   (.mul.vf vf1 vf1 vf1)
   (.add.z.vf acc vf1 vf1 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf1 acc :mask #b1000)
   (.add.mul.x.vf vf1 vf0 vf1 acc :mask #b1000)
   (.add.w.vf vf1 vf0 vf1)
   (.mov v1-1 vf1)
   (sqrtf v1-1)
   )
  )

(defun quaternion-normalize! ((arg0 quaternion))
  "Normalize a quaternion"
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 vec quad))
   (.mul.vf vf2 vf1 vf1)
   (.add.z.vf acc vf2 vf2 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
   (.add.mul.x.vf vf2 vf0 vf2 acc :mask #b1000)
   (.isqrt.vf Q vf0 vf2 :fsf #b11 :ftf #b11)
   ;;(.wait.vf)
   (.mul.vf vf2 vf1 Q)
   ;;(.nop.vf)
   ;;(.nop.vf)
   (.svf (&-> arg0 vec quad) vf2)
   arg0
   )
  )

(defun quaternion-inverse! ((arg0 quaternion) (arg1 quaternion))
  "Invert a quaternion. The inverse will satisfy q * q^-1 = identity, even if q is not normalized.
   If your quaternion is normalized, it is faster/more accurate to do quaternion-conjugate!"
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 vec quad))
   (.mul.vf vf2 vf1 vf1)
   (.sub.vf vf3 vf3 vf3)
   (.add.z.vf acc vf2 vf2 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
   (.add.mul.x.vf vf2 vf0 vf2 acc :mask #b1000)
   (.sub.vf vf3 vf3 vf1 :mask #b111)
   (.div.vf Q vf0 vf2 :fsf #b11 :ftf #b11)
   (.add.vf vf3 vf3 vf1 :mask #b1000)
   (.wait.vf)
   (.mul.vf vf3 vf3 Q)
   (.nop.vf)
   (.nop.vf)
   (.svf (&-> arg0 vec quad) vf3)
   arg0
   )
  )

(defun quaternion-dot ((arg0 quaternion) (arg1 quaternion))
  "Treat quaternions as vectors and take the dot product."
  (local-vars (v0-0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg0 vec quad))
   (.lvf vf2 (&-> arg1 vec quad))
   (.mul.vf vf1 vf1 vf2)
   (.add.z.vf acc vf1 vf1 :mask #b1000)
   (.add.mul.y.vf acc vf0 vf1 acc :mask #b1000)
   (.add.mul.x.vf vf1 vf0 vf1 acc :mask #b1000)
   (.add.w.vf vf1 vf0 vf1)
   (.mov v0-0 vf1)
   v0-0
   )
  )

(defun quaternion*! ((arg0 quaternion) (arg1 quaternion) (arg2 quaternion))
  "Real quaternion multiplication"
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
   (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
   (.lvf vf1 (&-> arg1 vec quad))
   (.lvf vf2 (&-> arg2 vec quad))
   (.sub.vf vf4 vf0 vf0 :mask #b1000)
   (.mul.vf vf3 vf1 vf2)
   (.outer.product.vf vf4 vf1 vf2)
   (.mul.w.vf acc vf1 vf2)
   (.add.mul.w.vf acc vf2 vf1 acc)
   (.sub.mul.w.vf acc vf0 vf3 acc :mask #b1000)
   (.sub.mul.z.vf acc vf0 vf3 acc :mask #b1000)
   (.sub.mul.y.vf acc vf0 vf3 acc :mask #b1000)
   (.sub.mul.x.vf acc vf0 vf3 acc :mask #b1000)
   (.add.mul.w.vf vf1 vf4 vf0 acc)
   (.svf (&-> arg0 vec quad) vf1)
   arg0
   )
  )

(defun quaternion-right-mult-matrix! ((arg0 matrix) (arg1 quaternion))
  "Place quaternion coefficients into a matrix. 
   You can convert a quaternion to a matrix by taking the product of this
   right-mult and left-mult matrix, but this method is not used.
   Instead, quaternion->matrix is a more efficient implementation."
  (let ((f3-0 (-> arg1 x))
        (f2-0 (-> arg1 y))
        (f1-0 (-> arg1 z))
        (f0-0 (-> arg1 w))
        )
   (set! (-> arg0 data 0) f0-0)
   (set! (-> arg0 data 1) f1-0)
   (set! (-> arg0 data 2) (- f2-0))
   (set! (-> arg0 data 3) f3-0)
   (set! (-> arg0 data 4) (- f1-0))
   (set! (-> arg0 data 5) f0-0)
   (set! (-> arg0 data 6) f3-0)
   (set! (-> arg0 data 7) f2-0)
   (set! (-> arg0 data 8) f2-0)
   (set! (-> arg0 data 9) (- f3-0))
   (set! (-> arg0 data 10) f0-0)
   (set! (-> arg0 data 11) f1-0)
   (set! (-> arg0 data 12) (- f3-0))
   (set! (-> arg0 data 13) (- f2-0))
   (set! (-> arg0 data 14) (- f1-0))
   (set! (-> arg0 data 15) f0-0)
   )
  arg0
  )

(defun quaternion-left-mult-matrix! ((arg0 matrix) (arg1 quaternion))
  "Place quaternion coefficients into a matrix. Unused."
  (let ((f2-0 (-> arg1 x))
        (f1-0 (-> arg1 y))
        (f0-0 (-> arg1 z))
        )
   (let ((f3-0 (-> arg1 w)))
    (set! (-> arg0 data 0) f2-0)
    (set! (-> arg0 data 1) f3-0)
    (set! (-> arg0 data 2) (- f0-0))
    (set! (-> arg0 data 3) f1-0)
    (set! (-> arg0 data 4) f1-0)
    (set! (-> arg0 data 5) f0-0)
    (set! (-> arg0 data 6) f3-0)
    (set! (-> arg0 data 7) (- f3-0))
    (set! (-> arg0 data 8) f0-0)
    (set! (-> arg0 data 9) (- f1-0))
    (set! (-> arg0 data 10) f2-0)
    (set! (-> arg0 data 11) f3-0)
    (set! (-> arg0 data 12) f3-0)
    )
   (set! (-> arg0 data 13) (- f2-0))
   (set! (-> arg0 data 14) (- f1-0))
   (set! (-> arg0 data 15) (- f0-0))
   )
  arg0
  )

(defun quaternion->matrix ((arg0 matrix) (arg1 quaternion))
  "Convert quaternion to matrix."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (.lvf vf0 (new 'static 'vector :x 0.0 :y 0.0 :z 0.0 :w 1.0))
    (.lvf vf1 (&-> arg1 vec quad))
    (.add.vf vf5 vf1 vf1)
    (.add.w.vf vf2 vf0 vf1 :mask #b1)
    (.add.z.vf vf2 vf0 vf1 :mask #b10)
    (.sub.y.vf vf2 vf0 vf1 :mask #b100)
    (.sub.w.vf vf2 vf0 vf0 :mask #b1000)
    (.sub.z.vf vf3 vf0 vf1 :mask #b1)
    (.add.w.vf vf3 vf0 vf1 :mask #b10)
    (.add.x.vf vf3 vf0 vf1 :mask #b100)
    (.sub.w.vf vf3 vf0 vf0 :mask #b1000)
    (.add.y.vf vf4 vf0 vf1 :mask #b1)
    (.sub.x.vf vf4 vf0 vf1 :mask #b10)
    (.add.w.vf vf4 vf0 vf1 :mask #b100)
    (.sub.w.vf vf4 vf0 vf0 :mask #b1000)
    (.outer.product.vf vf2 vf5 vf2)
    (.outer.product.vf vf3 vf5 vf3)
    (.outer.product.vf vf4 vf5 vf4)
    (.add.w.vf vf2 vf2 vf0 :mask #b1)
    (.add.w.vf vf3 vf3 vf0 :mask #b10)
    (.add.w.vf vf4 vf4 vf0 :mask #b100)
    (.svf (&-> arg0 vector 3 quad) vf0)
    (.svf (&-> arg0 vector 0 quad) vf2)
    (.svf (&-> arg0 vector 1 quad) vf3)
    (.svf (&-> arg0 vector 2 quad) vf4)
    arg0
    )
  )

(defun matrix->quaternion ((arg0 quaternion) (arg1 matrix))
  (let ((f0-2 (+ (+ (-> arg1 data 0) (-> arg1 data 5)) (-> arg1 data 10))))
    (if (< 0.0 f0-2)
        (let ((f0-4 (sqrtf (+ 1.0 f0-2))))
          (set! (-> arg0 w) (* 0.5 f0-4))
          (let ((f0-5 (/ 0.5 f0-4)))
            (set! (-> arg0 x) (* f0-5 (- (-> arg1 data 6) (-> arg1 data 9))))
            (set! (-> arg0 y) (* f0-5 (- (-> arg1 data 8) (-> arg1 data 2))))
            (let ((f0-6 (* f0-5 (- (-> arg1 data 1) (-> arg1 data 4)))))
              (set! (-> arg0 z) f0-6)
              (let ((v1-0 f0-6))
                )
              )
            )
          )
        (let ((a2-0 0)
              (a3-0 1)
              (v1-1 2)
              )
          (when (< (-> arg1 data 0) (-> arg1 data 5))
            (set! a2-0 1)
            (set! a3-0 2)
            (set! v1-1 0)
            (let ((t0-1 v1-1))
              )
            )
          (when
              (<
               (->
                (the-as
                 (pointer float)
                 (+ (+ (shl a2-0 2) (shl a2-0 4)) (the-as int arg1))
                 )
                )
               (-> arg1 data 10)
               )
            (set! a2-0 2)
            (set! a3-0 0)
            (set! v1-1 1)
            (let ((t0-6 v1-1))
              )
            )
          (let
              ((f0-12
                (sqrtf
                 (+
                  (-
                   1.0
                   (+
                    (->
                     (the-as
                      (pointer float)
                      (+ (+ (shl a3-0 2) (shl a3-0 4)) (the-as int arg1))
                      )
                     )
                    (->
                     (the-as
                      (pointer float)
                      (+ (+ (shl v1-1 2) (shl v1-1 4)) (the-as int arg1))
                      )
                     )
                    )
                   )
                  (->
                   (the-as
                    (pointer float)
                    (+ (+ (shl a2-0 2) (shl a2-0 4)) (the-as int arg1))
                    )
                   )
                  )
                 )
                 )
               )
            (set! (-> arg0 data a2-0) (* 0.5 f0-12))
            (when (!= f0-12 0.0)
              (set! f0-12 (/ 0.5 f0-12))
              (let ((t0-19 f0-12))
                )
              )
            (set!
             (-> arg0 w)
             (*
              (-
               (->
                (the-as
                 (pointer float)
                 (+ (+ (shl v1-1 2) (shl a3-0 4)) (the-as int arg1))
                 )
                )
               (->
                (the-as
                 (pointer float)
                 (+ (+ (shl a3-0 2) (shl v1-1 4)) (the-as int arg1))
                 )
                )
               )
              f0-12
              )
             )
            (set!
             (-> arg0 data a3-0)
             (*
              (+
               (->
                (the-as
                 (pointer float)
                 (+ (+ (shl a3-0 2) (shl a2-0 4)) (the-as int arg1))
                 )
                )
               (->
                (the-as
                 (pointer float)
                 (+ (+ (shl a2-0 2) (shl a3-0 4)) (the-as int arg1))
                 )
                )
               )
              f0-12
              )
             )
            (let
                ((f0-13
                  (*
                   (+
                    (->
                     (the-as
                      (pointer float)
                      (+ (+ (shl v1-1 2) (shl a2-0 4)) (the-as int arg1))
                      )
                     )
                    (->
                     (the-as
                      (pointer float)
                      (+ (+ (shl a2-0 2) (shl v1-1 4)) (the-as int arg1))
                      )
                     )
                    )
                   f0-12
                   )
                   )
                 )
              (set! (-> arg0 data v1-1) f0-13)
              (let ((v1-4 f0-13))
                )
              )
            )
          )
        )
    )
  arg0
  )
