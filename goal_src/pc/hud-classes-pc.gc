;;-*-Lisp-*-
(in-package goal)

#|

  Code for extra HUD elements in the PC port.

 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defconstant HUD_ICON_COUNT 6)
(defconstant HUD_PART_PC_AMOUNT 1)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; hud processes and parts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; a pc hud element
(deftype hud-pc (hud)
  ()
  )

;; hud element for battles
(deftype hud-battle-enemy (hud)
  ((want-skel   symbol)
   
   (last-battle    handle)
   (battle-entity  entity)
   (battle-max   int32)
   (battle-alive int32)
   (battle-mode  symbol)
   
   (has-icons   symbol)
   (kicked  symbol)
   )
  (:methods
    (make-enemy-icon (_type_ int symbol) int)
    (kill-enemy-icons (_type_) int)
    )
  )


;; all pc hud elements
(deftype hud-parts-pc (structure)
  ((battle-enemy  (pointer hud-battle-enemy))
   
   (parts  (pointer hud-pc)  HUD_PART_PC_AMOUNT  :offset 0)
   )
  )



;;;----------------------------------------------
;;  globals
;;;----------------------------------------------


;; all of the pc hud elements
(define *hud-parts-pc* (new 'static 'hud-parts-pc
                            :battle-enemy #f
                            ))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  hud macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defmacro hud-pc-make-icon (obj max &key skel
                                    &key x
                                    &key y
                                    &key z
                                    &key scale-x
                                    &key scale-y
                                    &key (entity #f)
                                    )
  `(when (< (-> ,obj nb-of-icons) ,max)
    (let ((icon-idx (-> ,obj nb-of-icons)))
      (set! (-> ,obj icons icon-idx) (new 'static 'hud-icon))
      (let ((new-manipy (manipy-spawn (new 'static 'vector :w 1.0) ,entity ,skel #f
                          :to ,obj
                          :stack *scratch-memory-top*
                          )))
        (when new-manipy
          (set! (-> (-> new-manipy) draw dma-add-func) dma-add-process-drawable-hud)
          (set-vector! (-> (-> new-manipy) root trans) 0.0 0.0 0.0 1.0)
          (set-vector! (-> (-> new-manipy) root scale) ,scale-x ,scale-y ,scale-x 1.0)
          (when #f
            (send-event (ppointer->process new-manipy) 'trans-hook #f)
            )
          )
        (set! (-> ,obj icons icon-idx icon) new-manipy)
        (when new-manipy
          (logior! (-> new-manipy 0 mask) (process-mask pause))
          (logclear! (-> new-manipy 0 mask) (process-mask menu progress))
          (set! (-> (-> new-manipy) root trans z) ,z)
          (set! (-> ,obj icons icon-idx icon-x) ,x)
          (set! (-> ,obj icons icon-idx icon-y) ,y)
          (set! (-> ,obj icons icon-idx icon-z) 0)
          (set! (-> ,obj icons icon-idx scale-x) ,scale-x)
          (set! (-> ,obj icons icon-idx scale-y) ,scale-y)
          )
        )
      )
    (+! (-> ,obj nb-of-icons) 1)
    )
  )

(defmacro hud-pc-replace-icon (obj idx &key skel
                                       &key z
                                       &key (entity #f)
                                       )
  `(let ((new-manipy (manipy-spawn (new 'static 'vector :w 1.0) ,entity ,skel #f
                        :to ,obj
                        :stack *scratch-memory-top*
                        )))
      (when new-manipy
        (set! (-> (-> new-manipy) draw dma-add-func) dma-add-process-drawable-hud)
        (set-vector! (-> (-> new-manipy) root trans) 0.0 0.0 0.0 1.0)
        (set-vector! (-> (-> new-manipy) root scale) (-> ,obj icons ,idx scale-x) (-> ,obj icons ,idx scale-y) (-> ,obj icons ,idx scale-x) 1.0)
        (when #f
          (send-event (ppointer->process new-manipy) 'trans-hook #f)
          )
        )
      (set! (-> ,obj icons ,idx icon) new-manipy)
      (when new-manipy
        (logior! (-> new-manipy 0 mask) (process-mask pause))
        (logclear! (-> new-manipy 0 mask) (process-mask menu progress))
        (set! (-> (-> new-manipy) root trans z) ,z)
        )
      )
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  hud methods
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defmethod deactivate hud-pc ((obj hud-pc))
  (dotimes (i HUD_PART_PC_AMOUNT)
    (if (and (-> *hud-parts-pc* parts i) (= (ppointer->process (-> *hud-parts-pc* parts i)) obj))
        (set! (-> *hud-parts-pc* parts i) (the (pointer hud-pc) #f))
        )
    )
  ((method-of-type hud deactivate) obj)
  (none)
  )


(defmethod kill-enemy-icons hud-battle-enemy ((obj hud-battle-enemy))
  "kill all hud icons"
  
  (when (-> obj has-icons)
    (dotimes (i (-> obj nb-of-icons))
      (when (and (nonzero? (-> obj icons i)) (nonzero? (-> obj icons i icon)) (-> obj icons i icon))
          (deactivate (ppointer->process (-> obj icons i icon)))
          (set! (-> obj icons i icon) #f)
          (hud-pc-replace-icon obj i :skel *fuelcell-naked-sg* :z (meters 0.5))
          )
      )
    
    (false! (-> obj has-icons))
    )
  0)

(defmethod make-enemy-icon hud-battle-enemy ((obj hud-battle-enemy) (idx int) (skel-sym symbol))
  "make a new icon for the hud"
    
  ;; make new manipy
  (hud-pc-replace-icon obj 0 :skel (-> skel-sym value) :entity (-> obj battle-entity) :z (meters 0.5))
  
  (true! (-> obj has-icons))

  0)


(defmethod hud-update hud-battle-enemy ((obj hud-battle-enemy))

  (when (not (-> *pc-settings* extra-hud?))
      (kill-enemy-icons obj)
      (return #f))

  (let ((battle (the battlecontroller #f)))
      ;; default params
      (set! (-> obj battle-entity) #f)
      (set! (-> obj battle-mode) 'dead)
      
      ;; find an entity for a battlecontroller, check current level
      (awhen (level-get-target-inside *level*)
        (case (-> it name)
          (('swamp)
            (set! (-> obj battle-entity) (entity-by-name "swamp-battlecontroller-1"))
            (set! (-> obj want-skel) '*babak-sg*)
            )
          (('misty)
            (set! (-> obj battle-entity) (entity-by-name "misty-battlecontroller-1"))
            (set! (-> obj want-skel) '*babak-sg*)
            )
          (('citadel)
            (set! (-> obj battle-entity) (entity-by-name "citb-battlecontroller-1"))
            (set! (-> obj want-skel) '*citb-bunny-sg*)
            (set! (-> obj battle-mode) 'alive)
            )
          )
        )
      
      ;; have an entity, grab its process
      (if (-> obj battle-entity)
          (set! battle (the battlecontroller (-> obj battle-entity extra process))))
      
      (cond
        ;; check if we have a battle process
        (battle
          ;; if its a different process, panic and restart the whole sequence. it's OK
          (when (!= (handle->process (-> obj last-battle)) battle)
              (set! (-> obj last-battle) (process->handle battle))
              (kill-enemy-icons obj)
              (send-event obj 'hide-quick)
              )
          
          ;; wait until battle is active
          (when (= 'battlecontroller-active (-> battle next-state name))
            ;; get battle stats
            (let ((alive-count 0))
              (with-children (child battle)
                  (1+! alive-count))
              (set! (-> obj value) (- (-> battle spawn-count) alive-count))
              (set! (-> obj battle-max) (-> battle max-spawn-count))
              (set! (-> obj battle-alive) alive-count)
              )
            
            ;; do stuff depending on our current state
            (case (-> obj next-state name)
              (('hud-hidden)
               ;; we're hidden, so let's make our new icons and see if we are allowed to show
               ;; if we have icons, show!
               (when (-> obj has-icons)
                 (set! (-> obj kicked) #f)
                 (send-event obj 'show)
                 )
               ;; no icons, make new ones but keep them hidden for now
               (when (and (not (-> obj has-icons)) (-> obj want-skel) (not *progress-process*))
                 (make-enemy-icon obj 0 (-> obj want-skel))
                 (let ((icon0 (ppointer->process (-> obj icons 0 icon))))
                   (case (-> obj want-skel)
                     (('*babak-sg*)
                      (send-event icon0 'art-joint-anim "babak-idle" (seconds 0.05))
                      (send-event icon0 'rot-quat (quaternion-axis-angle! (new-stack-quaternion0) 0.0 1.0 0.15 (degrees 210)))
                      )
                     (('*citb-bunny-sg*)
                      (send-event icon0 'art-joint-anim "citb-bunny-idle" (seconds 0.05))
                      (send-event icon0 'rot-quat (quaternion-axis-angle! (new-stack-quaternion0) 0.0 1.0 0.15 (degrees 210)))
                      )
                     )
                   (send-event icon0 'draw #f)
                   )
                 )
               )
              (else
               ;; we want to be shown!
               
               ;; progress is open, let's leave.
               (when (and (not (-> obj kicked)) (= *master-mode* 'progress))
                   (true! (-> obj kicked))
                   (kill-enemy-icons obj)
                   (send-event obj 'hide-quick)
                   )
               
               ;; set the trigger time so we don't automatically go away
               (set! (-> obj trigger-time) (current-time))
               )
              )
            )
          )
        (else
          ;; no battle. kill everything we have.
          (when (-> obj has-icons)
            (kill-enemy-icons obj)
            (set! (-> obj last-battle) INVALID_HANDLE)
            (send-event obj 'hide-quick)
            )
          )
        )
      )
  0
  (none)
  )


(defmethod draw-hud hud-battle-enemy ((obj hud-battle-enemy))
  (let ((t9-0 (method-of-type hud draw-hud)))
    (t9-0 obj)
    )
  (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf))
                               (bucket-id debug))
    (let ((str-x (+ (-> obj text-x) (* (-> obj x-sgn) (-> obj offset))))
          (str-y (/ (* (+ (-> obj text-y) (* (-> obj y-sgn) (-> obj offset)) (-> obj y-offset))
                       (the int (-> *video-parms* relative-y-scale)))
                    2))
          )
        
        (case (-> obj battle-mode)
          (('dead)
           (draw-string-xy (string-format "~D/~D" (-> obj value) (-> obj battle-max))
                           buf str-x str-y (font-color white) (font-flags shadow kerning large))
           )
          (('alive)
           (draw-string-xy (string-format "~D" (-> obj battle-alive))
                           buf str-x str-y (font-color white) (font-flags shadow kerning large))
           )
          )
        )
      )
  0
  (none)
  )


(defmethod init-particles! hud-battle-enemy ((obj hud-battle-enemy) (arg0 int))
  (hud-pc-make-icon obj HUD_ICON_COUNT :skel *fuelcell-naked-sg*
                                       :x (the int (* 0.84 512)) :y (the int (* 0.52 448)) :z (meters 0.5)
                                       :scale-x 0.004 :scale-y (* -0.004 (/ 512.0 448.0)))
  (set! (-> obj text-x) (the int (* 0.78 512)))
  (set! (-> obj text-y) (the int (* 0.5 448)))
  (set! (-> obj x-sgn) 1)
  (set! (-> obj y-sgn) 0)
  (set! (-> obj increment-on-event) #t)
  (set-pos-and-scale obj (= (get-aspect-ratio) 'aspect16x9) (= (get-video-mode) 'pal))
  
  (set! (-> obj last-battle) INVALID_HANDLE)
  (set! (-> obj want-skel) #f)
  (set! (-> obj battle-max) 0)
  
  (set! (-> obj kicked) #f)
  (set! (-> obj has-icons) #f)
  0
  (none)
  )




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  hud helper funcs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun deactivate-hud-pc ()
  "kill the pc hud"

  (dotimes (i HUD_PART_PC_AMOUNT)
    (if (-> *hud-parts-pc* parts i)
        (deactivate (ppointer->process (-> *hud-parts-pc* parts i))))
    )
  0)

(defun activate-hud-pc ((tree process-tree))
  "make the pc hud"
  
  (deactivate-hud-pc)
  
  (set! (-> *hud-parts-pc* battle-enemy) (process-spawn hud-battle-enemy :init hud-init-by-other 0
                                                      :from *pc-dead-pool* :to tree
                                                      :stack-size PC_PROC_DEFAULT_STACK_SIZE))
  0)


(activate-hud-pc *display-pool*)





