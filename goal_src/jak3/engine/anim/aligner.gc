;;-*-Lisp-*-
(in-package goal)

;; name: aligner.gc
;; name in dgo: aligner
;; dgos: GAME

;; DECOMP BEGINS

;; ERROR: Unsupported inline assembly instruction kind - [lw ra, return-from-thread(s7)]
;; ERROR: Unsupported inline assembly instruction kind - [jr ra]
(defmethod compute-alignment! ((this align-control))
  (local-vars (a0-10 symbol) (s7-0 none) (ra-0 int))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (update-anim-data (-> this process skel))
    (let ((s5-0 (-> this process skel active-channels)))
      (dotimes (s4-0 (the-as int s5-0))
        (let* ((a0-4 (-> this process skel channel s4-0))
               (v1-7 (-> a0-4 frame-group))
               )
          (case (-> a0-4 command)
            (((joint-control-command stack) (joint-control-command stack1))
             )
            (else
              (when (!= (-> v1-7 type) art-joint-anim)
                (go process-drawable-art-error "align joint-anim")
                ;; og:preserve-this
                ;; (.lw ra-0 return-from-thread s7-0)
                ;; (.jr ra-0)
                (abandon-thread)
                (nop!)
                0
                )
              )
            )
          )
        )
      )
    (let* ((a0-9 (-> this process skel root-channel 0))
           (v1-18 (-> a0-9 frame-group))
           (f0-0 (-> a0-9 frame-num))
           )
      (= (-> a0-9 num-func) num-func-loop!)
      (cond
        ((or (not v1-18) (!= (-> this frame-group) v1-18))
         (set! a0-10 #t)
         )
        ((= (-> a0-9 num-func) num-func-loop!)
         (set! a0-10 (< (* (-> a0-9 param 0) (- f0-0 (-> this frame-num))) 0.0))
         )
        (else
          (set! a0-10 (= f0-0 0.0))
          )
        )
      (if a0-10
          (logior! (-> this flags) (align-flags disabled))
          (logclear! (-> this flags) (align-flags disabled))
          )
      (set! (-> this frame-group) v1-18)
      (set! (-> this frame-num) f0-0)
      )
    (mem-copy! (the-as pointer (-> this transform 1)) (the-as pointer (-> this transform)) 48)
    (quaternion-copy! (the-as quaternion (-> this transform 1 rot)) (-> this align quat))
    (set! (-> this transform 1 scale quad) (-> this align scale quad))
    (let* ((a2-5 (-> this matrix 1))
           (a3-0 (-> this matrix))
           (v1-21 (-> a3-0 0 rvec quad))
           (a0-19 (-> a3-0 0 uvec quad))
           (a1-13 (-> a3-0 0 fvec quad))
           (a3-1 (-> a3-0 0 trans quad))
           )
      (set! (-> a2-5 rvec quad) v1-21)
      (set! (-> a2-5 uvec quad) a0-19)
      (set! (-> a2-5 fvec quad) a1-13)
      (set! (-> a2-5 trans quad) a3-1)
      )
    (let ((s5-1 (-> this process node-list data 1)))
      (cspace<-matrix-no-push-joint! s5-1 (-> this process skel))
      (let* ((v1-25 (-> this matrix))
             (a3-2 (-> s5-1 bone transform))
             (a0-22 (-> a3-2 rvec quad))
             (a1-15 (-> a3-2 uvec quad))
             (a2-6 (-> a3-2 fvec quad))
             (a3-3 (-> a3-2 trans quad))
             )
        (set! (-> v1-25 0 rvec quad) a0-22)
        (set! (-> v1-25 0 uvec quad) a1-15)
        (set! (-> v1-25 0 fvec quad) a2-6)
        (set! (-> v1-25 0 trans quad) a3-3)
        )
      (let ((v1-26 (-> this transform)))
        (let ((a0-24 (-> s5-1 bone transform trans))
              (a1-18 (-> this process root scale))
              )
          (.lvf vf4 (&-> a0-24 quad))
          (.lvf vf5 (&-> a1-18 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.vf vf6 vf4 vf5 :mask #b111)
        (.svf (&-> v1-26 0 trans quad) vf6)
        )
      )
    (vector-!
      (the-as vector (-> this delta))
      (the-as vector (-> this transform))
      (the-as vector (-> this transform 1))
      )
    (set-vector!
      (-> this align scale)
      (vector-length (the-as vector (-> this matrix)))
      (vector-length (-> this matrix 0 uvec))
      (vector-length (-> this matrix 0 fvec))
      1.0
      )
    (vector-! (-> this delta scale) (-> this align scale) (-> this transform 1 scale))
    (let ((a2-7 (matrix-inv-scale! (new 'stack-no-clear 'matrix) (-> this align scale))))
      (quaternion-normalize!
        (matrix->quaternion (-> this align quat) (matrix*! a2-7 (the-as matrix (-> this matrix)) a2-7))
        )
      )
    (let ((a1-27 (quaternion-inverse! (new 'stack-no-clear 'quaternion) (the-as quaternion (-> this transform 1 rot))))
          )
      (quaternion-normalize! (quaternion*! (-> this delta quat) a1-27 (-> this align quat)))
      )
    (-> this delta)
    )
  )

;; WARN: Return type mismatch (inline-array transform) vs transform.
(defmethod first-transform ((this align-control))
  (the-as transform (-> this transform))
  )

(defmethod second-transform ((this align-control))
  (-> this transform 1)
  )

(defmethod align! ((this align-control) (arg0 align-opts) (arg1 float) (arg2 float) (arg3 float))
  (when (not (logtest? (-> this flags) (align-flags disabled)))
    (let* ((a0-1 (-> this process))
           (t9-0 (method-of-object a0-1 apply-alignment))
           (v1-4 (-> this delta))
           (t1-0 (new 'stack-no-clear 'vector))
           )
      (set! (-> t1-0 x) arg1)
      (set! (-> t1-0 y) arg2)
      (set! (-> t1-0 z) arg3)
      (set! (-> t1-0 w) 1.0)
      (t9-0 a0-1 arg0 v1-4 t1-0)
      )
    )
  (-> this process root)
  )

(defmethod set-and-limit-velocity ((this trsqv) (arg0 int) (arg1 vector) (arg2 float))
  (with-pp
    (let ((a0-1 (-> this transv)))
      (when (logtest? arg0 4)
        (set! (-> a0-1 x) (-> arg1 x))
        (set! (-> a0-1 z) (-> arg1 z))
        (let* ((v1-2 arg1)
               (f0-8
                 (fmin
                   (* (sqrtf (+ (* (-> v1-2 x) (-> v1-2 x)) (* (-> v1-2 z) (-> v1-2 z)))) (-> pp clock frames-per-second))
                   arg2
                   )
                 )
               )
          (vector-xz-normalize! a0-1 f0-8)
          )
        )
      )
    this
    )
  )

(defmethod align-vel-and-quat-only! ((this align-control) (arg0 align-opts) (arg1 vector) (arg2 int) (arg3 float) (arg4 float))
  (with-pp
    (when (not (logtest? (-> this flags) (align-flags disabled)))
      (let ((s5-0 (-> this delta)))
        (let ((a0-1 (-> this process root transv)))
          (if (logtest? arg0 (align-opts adjust-y-vel))
              (set! (-> a0-1 y) (* (-> s5-0 trans y) arg3 (-> pp clock frames-per-second)))
              )
          (when (logtest? arg0 (align-opts adjust-xz-vel))
            (set! (-> a0-1 x) (-> arg1 x))
            (set! (-> a0-1 z) (-> arg1 z))
            (let* ((v1-11 arg1)
                   (f0-9 (sqrtf (+ (* (-> v1-11 x) (-> v1-11 x)) (* (-> v1-11 z) (-> v1-11 z)))))
                   (v1-13 (-> s5-0 trans))
                   (f0-11 (* (fmin f0-9 (* (sqrtf (+ (* (-> v1-13 x) (-> v1-13 x)) (* (-> v1-13 z) (-> v1-13 z)))) arg4))
                             (-> pp clock frames-per-second)
                             )
                          )
                   (t9-0 vector-xz-normalize!)
                   )
              (set! (-> this last-speed) f0-11)
              (t9-0 a0-1 f0-11)
              )
            )
          )
        (if (logtest? arg0 (align-opts adjust-quat))
            (quaternion-normalize! (quaternion*! (-> this process root quat) (-> this process root quat) (-> s5-0 quat)))
            )
        )
      )
    (-> this process root)
    )
  )
