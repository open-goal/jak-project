;;-*-Lisp-*-
(in-package goal)

;; name: enemy.gc
;; name in dgo: enemy
;; dgos: GAME

;; DECOMP BEGINS

(defmethod copy-enemy-info! ((this enemy-info) (arg0 enemy-info))
  (mem-copy! (&-> this type) (&-> arg0 type) 420)
  0
  (none)
  )

(define *enemy-dummy-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #x28))
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -4096.0)
                                           )
                               )
  )

(defmethod relocate ((this enemy) (offset int))
  (if (nonzero? (-> this neck))
      (&+! (-> this neck) offset)
      )
  (call-parent-method this offset)
  )

(defmethod rnd-float ((this enemy))
  (rand-vu)
  )

(defmethod rnd-float-range ((this enemy) (arg0 float) (arg1 float))
  (+ arg0 (* (rand-vu) (- arg1 arg0)))
  )

(defmethod rnd-int ((this enemy) (arg0 int))
  (the int (* (rand-vu) (the float arg0)))
  )

(defmethod set-reaction-time! ((this enemy) (arg0 time-frame) (arg1 time-frame))
  (+ arg0 (the int (* (rand-vu) (the float (+ (- 1 arg0) arg1)))))
  )

(defmethod rnd-chance? ((this enemy) (arg0 float))
  (>= arg0 (rand-vu))
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod enemy-method-131 ((this enemy) (arg0 int) (arg1 int))
  (let ((v1-0 0)
        (s5-0 0)
        )
    (let ((a2-1 1))
      (while (nonzero? arg0)
        (+! arg0 -1)
        (if (not (logtest? arg1 a2-1))
            (+! v1-0 1)
            )
        (set! a2-1 (* a2-1 2))
        )
      )
    (when (> v1-0 0)
      (let ((v1-1 (rnd-int this v1-0))
            (a0-1 1)
            )
        (until #f
          (while (logtest? arg1 a0-1)
            (nop!)
            (nop!)
            (+! s5-0 1)
            (set! a0-1 (* a0-1 2))
            )
          (if (zero? v1-1)
              (goto cfg-14)
              )
          (+! v1-1 -1)
          (+! s5-0 1)
          (set! a0-1 (* a0-1 2))
          )
        )
      #f
      )
    (label cfg-14)
    s5-0
    )
  )

(defmethod enemy-method-134 ((this enemy) (arg0 float))
  (let* ((v1-5 (-> *display* frames (-> *display* last-screen) run-time))
         (f1-2 (fmax 0.0 (fmin 1.0 (* 0.001 (+ -7000.0 (the float v1-5))))))
         )
    (>= (+ arg0 (* f1-2 (- 1.0 arg0))) (rand-vu))
    )
  )

(defmethod coin-flip? ((this enemy))
  (zero? (rnd-int this 2))
  )

;; WARN: disable def twice: 40. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod run-logic? ((this enemy))
  "Should this process be run? Checked by execute-process-tree."
  (cond
    ((logtest? (-> this mask) (process-mask actor-pause))
     (let ((gp-0 (-> this draw)))
       (or (and (nonzero? gp-0)
                (>= (+ (-> *ACTOR-bank* pause-dist) (-> this root pause-adjust-distance))
                    (vector-vector-distance (-> this root trans) (camera-pos))
                    )
                (or (logtest? (-> gp-0 status) (draw-control-status on-screen))
                    (not (and (-> this next-state) (= (-> this next-state name) 'idle)))
                    )
                )
           (and (nonzero? (-> this skel)) (!= (-> this skel root-channel 0) (-> this skel channel)))
           (and (nonzero? gp-0) (logtest? (-> gp-0 status) (draw-control-status uninited)))
           )
       )
     )
    (else
      #t
      )
    )
  )

(defmethod can-collide-with-focus? ((this enemy) (arg0 process-focusable))
  (and arg0 (!= this arg0) (collide-spec-match? (-> this focus) arg0))
  )

;; WARN: Return type mismatch int vs search-info-flag.
(defmethod process-mask->search-info-flag ((this enemy))
  (let ((v1-0 (-> this enemy-flags))
        (v0-0 0)
        )
    (when (and (!= (-> this hit-points) 0.0)
               (logtest? (-> this enemy-flags) (enemy-flag vulnerable))
               (logtest? (enemy-flag trackable) (-> this enemy-flags))
               )
      (if (logtest? (process-mask enemy) (-> this mask))
          (set! v0-0 (logior v0-0 16))
          )
      (if (logtest? v1-0 (enemy-flag attackable))
          (set! v0-0 (logior v0-0 8))
          )
      )
    (the-as search-info-flag v0-0)
    )
  )

(defmethod get-trans ((this enemy) (arg0 int))
  "Get the `trans` for this process."
  (let ((s4-0 (-> this root)))
    (cond
      ((zero? arg0)
       (-> s4-0 trans)
       )
      ((and (= arg0 1) (type? s4-0 collide-shape-moving))
       (-> s4-0 gspot-pos)
       )
      ((= arg0 2)
       (vector<-cspace! (new 'static 'vector) (-> this node-list data (-> this enemy-info look-at-joint)))
       )
      ((= arg0 3)
       (let ((v0-0 (vector<-cspace! (new 'static 'vector) (-> this node-list data (-> this enemy-info bullseye-joint)))))
         (set! (-> v0-0 w) (-> this root root-prim prim-core world-sphere w))
         v0-0
         )
       )
      (else
        ((method-of-type process-focusable get-trans) this arg0)
        )
      )
    )
  )

(defmethod get-penetrated-by ((this enemy))
  (penetrated-by-all&hit-points->penetrated-by (-> this penetrated-by-all) (the int (-> this hit-points)))
  )

;; WARN: Return type mismatch float vs meters.
(defmethod get-water-height ((this enemy))
  (the-as meters (-> this water-surface-height))
  )

;; WARN: Return type mismatch enemy-flag vs object.
(defmethod check-water ((this enemy))
  (let ((s4-0 (-> this root)))
    (when (>= (-> this water-max-height) (-> s4-0 trans y))
      (let ((s5-0 (new 'stack-no-clear 'water-info)))
        (water-info-init! s4-0 s5-0 (collide-action solid semi-solid))
        (let ((s3-0 (-> s5-0 flags)))
          (when (logtest? (water-flag touch-water) s3-0)
            (set! (-> this water-surface-height) (-> s5-0 trans y))
            (when (not (focus-test? this touch-water under-water))
              (let ((v1-9 (new 'stack-no-clear 'vector)))
                (set! (-> v1-9 quad) (-> this root trans quad))
                (set! (-> v1-9 y) (+ 409.6 (-> s5-0 trans y)))
                (cond
                  ((logtest? (-> *part-group-id-table* 192 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> v1-9 quad))
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 192))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> v1-9 quad))
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 192))
                    )
                  )
                )
              (cond
                ((logtest? s3-0 (water-flag dark-eco))
                 (sound-play "eco-splash")
                 (send-event this 'instant-death)
                 )
                (else
                  (play-damage-sound this 2)
                  )
                )
              )
            (logior! (-> this focus-status) (focus-status touch-water))
            (let* ((v1-46 (-> s4-0 root-prim prim-core))
                   (f0-6 (+ (-> v1-46 world-sphere y) (-> v1-46 world-sphere w)))
                   )
              (if (focus-test? this under-water)
                  (set! f0-6 (+ -819.2 f0-6))
                  )
              (if (< f0-6 (-> s5-0 trans y))
                  (logior! (-> this focus-status) (focus-status under-water))
                  (logclear! (-> this focus-status) (focus-status under-water))
                  )
              )
            (return (the-as object #f))
            )
          )
        )
      )
    )
  (logclear! (-> this focus-status) (focus-status touch-water under-water))
  (let ((v0-11 (logclear (-> this enemy-flags) (enemy-flag checking-water))))
    (set! (-> this enemy-flags) v0-11)
    v0-11
    )
  )

(defmethod enemy-common-post ((this enemy))
  (if (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status on-screen)))
      (set-time! (-> this last-draw-time))
      )
  (update-focus this)
  (when *target*
    (if *target*
        (look-at!
          (-> *target* neck)
          (the-as vector (-> this root root-prim prim-core))
          (if (logtest? (-> this enemy-flags) (enemy-flag cam-attack-mode))
              'attacking
              )
          this
          )
        )
    )
  (when (nonzero? (-> this neck))
    (when (logtest? (-> this enemy-flags) (enemy-flag look-at-focus))
      (let ((a0-7 (handle->process (-> this focus handle))))
        (if a0-7
            (target-set! (-> this neck) (get-trans (the-as process-focusable a0-7) 2))
            )
        )
      )
    )
  (when (and (logtest? (-> this enemy-flags) (enemy-flag auto-reset-penetrate))
             (time-elapsed? (-> this auto-reset-penetrate-time) (seconds 0.1))
             )
    (logclear! (-> this enemy-flags) (enemy-flag auto-reset-penetrate))
    (set! (-> this root penetrated-by) (get-penetrated-by this))
    (let ((v1-43 0))
      (if (logtest? (penetrate knocked) (-> this root penetrate-using))
          (set! v1-43 (logior (shl 2 32) v1-43))
          )
      (set! (-> this root penetrate-using) (the-as penetrate v1-43))
      )
    )
  (if (logtest? (-> this enemy-flags) (enemy-flag victory))
      (check-victory this)
      )
  (if (logtest? (enemy-flag check-water checking-water) (-> this enemy-flags))
      (check-water this)
      )
  (if (and *debug-segment* (-> this enemy-info debug-draw-neck) (nonzero? (-> this neck)))
      (joint-mod-debug-draw (-> this neck))
      )
  (ja-post)
  0
  (none)
  )

;; WARN: Return type mismatch enemy-flag vs none.
(defmethod check-victory ((this enemy))
  (if (or (time-elapsed? (-> this hit-focus-time) (seconds 2))
          (and (handle->process (-> this focus handle))
               (not (logtest? (-> (the-as process-focusable (handle->process (-> this focus handle))) focus-status)
                              (focus-status disable dead ignore grabbed)
                              )
                    )
               )
          )
      (logclear! (-> this enemy-flags) (enemy-flag victory))
      )
  (none)
  )

;; WARN: Return type mismatch int vs penetrate.
(defun get-penetrate-using-from-attack-event ((arg0 process-drawable) (arg1 event-message-block))
  (let ((v1-0 (the-as object (-> arg1 param 1))))
    (if (logtest? (attack-mask penetrate-using) (-> (the-as attack-info v1-0) mask))
        (return (the-as penetrate (-> (the-as attack-info v1-0) penetrate-using)))
        )
    )
  (let* ((gp-0 arg0)
         (v1-3 (if (type? gp-0 process-drawable)
                   gp-0
                   )
               )
         )
    (when v1-3
      (let* ((gp-1 (-> v1-3 root))
             (v1-4 (if (type? gp-1 collide-shape)
                       gp-1
                       )
                   )
             )
        (if v1-4
            (return
              (the-as penetrate (logior (-> (the-as collide-shape v1-4) penetrate-using) (penetrate generic-attack)))
              )
            )
        )
      )
    )
  (the-as penetrate 2)
  )

;; WARN: Return type mismatch process vs process-focusable.
(defmethod get-focus! ((this enemy))
  (let ((v0-0 (handle->process (-> this focus handle))))
    (if (and v0-0
             (not (and v0-0
                       (not (logtest? (-> (the-as process-focusable v0-0) focus-status) (focus-status disable dead ignore grabbed)))
                       )
                  )
             )
        (set! v0-0 (the-as process #f))
        )
    (the-as process-focusable v0-0)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod enemy-method-70 ((this enemy) (arg0 process-focusable) (arg1 enemy-aware))
  (if arg1
      (enemy-focus-method-13 (-> this focus) arg0 arg1)
      (try-update-focus (-> this focus) arg0 this)
      )
  (none)
  )

(defmethod enemy-method-69 ((this enemy))
  (when (not (logtest? (enemy-flag lock-focus) (-> this enemy-flags)))
    (let* ((s4-0 (handle->process (-> this incoming attacker-handle)))
           (s5-0 (if (type? s4-0 process-focusable)
                     s4-0
                     )
                 )
           )
      (when (can-collide-with-focus? this (the-as process-focusable s5-0))
        (enemy-method-70 this (the-as process-focusable s5-0) (the-as enemy-aware #f))
        (logior! (-> this focus flags) (enemy-flag look-at-focus))
        )
      )
    )
  0
  (none)
  )

(defmethod send-attack-to-all-tshapes ((this enemy) (arg0 process-focusable) (arg1 event-message-block))
  (let ((s4-0 (the-as touching-shapes-entry (-> arg1 param 0))))
    (when (and s4-0
               (and (logtest? (-> this incoming penetrate-using) (penetrate board))
                    (not (logtest? (-> this incoming penetrate-using) (penetrate spin)))
                    )
               (begin
                 (let ((s3-0 (-> s4-0 head)))
                   (while s3-0
                     (let ((s2-0 (get-touched-prim s3-0 (-> arg0 root) s4-0)))
                       (get-touched-prim s3-0 (-> this root) s4-0)
                       (when (logtest? (-> s2-0 prim-core action) (collide-action solid semi-solid deadly))
                         (let* ((a0-5 this)
                                (t9-2 (method-of-object a0-5 send-attack))
                                (a1-3 arg0)
                                (a2-3 s4-0)
                                (v1-13 *game-info*)
                                (a3-1 (+ (-> v1-13 attack-id) 1))
                                )
                           (set! (-> v1-13 attack-id) a3-1)
                           (if (t9-2 a0-5 a1-3 a2-3 a3-1)
                               (return 0)
                               )
                           )
                         )
                       )
                     (set! s3-0 (-> s3-0 next))
                     )
                   )
                 #f
                 )
               )
      )
    )
  0
  )

(defmethod go-dormant ((this enemy))
  (let ((v1-1 (-> this root root-prim)))
    (set! (-> v1-1 prim-core collide-as) (collide-spec))
    (set! (-> v1-1 prim-core collide-with) (collide-spec))
    )
  0
  (logior! (-> this draw status) (draw-control-status no-draw))
  (logior! (-> this focus-status) (focus-status disable))
  (go (method-of-object this dormant))
  )

(defmethod go-dormant-aware ((this enemy))
  (let ((v1-1 (-> this root root-prim)))
    (set! (-> v1-1 prim-core collide-as) (collide-spec))
    (set! (-> v1-1 prim-core collide-with) (collide-spec))
    )
  0
  (logior! (-> this draw status) (draw-control-status no-draw))
  (logior! (-> this focus-status) (focus-status disable))
  (go (method-of-object this dormant-aware))
  )

(defmethod go-idle ((this enemy))
  (go (method-of-object this idle))
  )

(defmethod go-stare ((this enemy))
  (go (method-of-object this stare))
  )

(defmethod go-stare2 ((this enemy))
  (go (method-of-object this stare))
  )

(defmethod go-hostile ((this enemy))
  (go (method-of-object this hostile))
  )

(defmethod have-more-than-10-joints? ((this enemy))
  (and (nonzero? (-> this node-list)) (-> this node-list) (< 10 (-> this node-list length)))
  )

(defmethod enemy-method-150 ((this enemy))
  #t
  )

(defmethod go-gun-dark-2-stretch ((this enemy))
  (if (not (and (-> this next-state) (= (-> this next-state name) 'gun-dark-2-stretch)))
      (go (method-of-object this gun-dark-2-stretch))
      )
  )

(defmethod go-ambush-delay ((this enemy))
  (if (< 0.0 (res-lump-float (-> this entity) 'ambush-delay))
      (go (method-of-object this ambush-delay))
      (go (method-of-object this ambush))
      )
  )

(defmethod go-flee ((this enemy))
  (go (method-of-object this flee))
  )

(defmethod go-directed ((this enemy))
  (go (method-of-object this directed))
  )

(defmethod go-best-state ((this enemy))
  (let ((s5-0 (-> this focus aware)))
    (cond
      ((and (= s5-0 (enemy-aware ea3)) (get-focus! this))
       (go-hostile this)
       )
      ((<= (the-as int s5-0) 0)
       (go-idle this)
       )
      ((>= 1 (the-as int s5-0))
       (go (method-of-object this active))
       )
      ((= s5-0 (enemy-aware ea4))
       (go-flee this)
       )
      (else
        (go-stare this)
        )
      )
    )
  )

(defmethod go-directed2 ((this enemy))
  (if (logtest? (enemy-flag directed) (-> this enemy-flags))
      (go-directed this)
      (go-best-state this)
      )
  )

(defmethod go-die ((this enemy))
  (if (-> this enemy-info use-die-falling)
      (go (method-of-object this die-falling))
      (go (method-of-object this die))
      )
  )

(defmethod play-damage-sound ((this enemy) (arg0 int))
  (let ((name (static-sound-name "")))
    (let ((v1-0 arg0))
      (cond
        ((zero? v1-0)
         (set! name (-> this enemy-info sound-hit))
         )
        ((= v1-0 1)
         (set! name (-> this enemy-info sound-die))
         )
        ((= v1-0 2)
         (sound-play "splash")
         )
        )
      )
    (if (nonzero? (the-as uint name))
        (sound-play-by-name (the-as sound-name name) (new-sound-id) 1024 0 0 (sound-group) #t)
        )
    )
  )

(defmethod enemy-method-103 ((this enemy) (arg0 vector) (arg1 float))
  (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s5-0 quad) (-> arg0 quad))
    (set! (-> s4-0 y) 0.0)
    (vector-normalize! s4-0 1.0)
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)
    (>= (vector-dot s4-0 s5-0) (cos arg1))
    )
  )

(defmethod enemy-method-104 ((this enemy) (arg0 vector) (arg1 float))
  (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> this root trans))))
    (enemy-method-103 this v1-1 arg1)
    )
  )

(defmethod enemy-method-105 ((this enemy) (arg0 float) (arg1 symbol))
  (let ((a0-2 (handle->process (-> this focus handle))))
    (cond
      (a0-2
        (let ((s4-1
                (vector-! (new 'stack-no-clear 'vector) (get-trans (the-as process-focusable a0-2) 0) (-> this root trans))
                )
              )
          (enemy-method-103 this s4-1 arg0)
          )
        )
      (else
        arg1
        )
      )
    )
  )

(defmethod send-attack ((this enemy) (arg0 process) (arg1 touching-shapes-entry) (arg2 uint))
  (let ((a0-1 (-> this enemy-info attack-damage)))
    (if (and (logtest? (-> *game-info* secrets) (game-secrets hero-mode)) (= a0-1 1))
        (set! a0-1 2)
        )
    (when (send-event
            arg0
            'attack
            arg1
            (static-attack-info :mask (vehicle-impulse-factor) ((id arg2)
                                                                (damage (the float a0-1))
                                                                (vehicle-damage-factor 1.0)
                                                                (vehicle-impulse-factor 1.0)
                                                                (shove-back (-> this enemy-info attack-shove-back))
                                                                (shove-up (-> this enemy-info attack-shove-up))
                                                                (mode (-> this enemy-info attack-mode))
                                                                (knock (if (-> this enemy-info knocked-off)
                                                                           (knocked-type knocked-off)
                                                                           (knocked-type none)
                                                                           )
                                                                       )
                                                                )
                                )
            )
      (on-attack this (the-as process-focusable arg0))
      #t
      )
    )
  )

;; WARN: Return type mismatch enemy-flag vs none.
(defmethod on-attack ((this enemy) (arg0 process-focusable))
  (when (logtest? (process-mask target bot) (-> arg0 mask))
    (set! (-> this root penetrated-by) (the-as penetrate -1))
    (reset-penetrate! this)
    )
  (let ((s5-0 (if (type? arg0 process-focusable)
                  arg0
                  )
              )
        )
    (when (can-collide-with-focus? this s5-0)
      (let ((v1-10 (handle->process (-> this focus handle))))
        (when (or (= s5-0 v1-10) (and (not (logtest? (enemy-flag lock-focus) (-> this enemy-flags)))
                                      (or (not v1-10) (not (logtest? (-> this focus flags) (enemy-flag look-at-focus))))
                                      )
                  )
          (enemy-method-70 this s5-0 (the-as enemy-aware #f))
          (set-time! (-> this hit-focus-time))
          (logior! (-> this enemy-flags) (enemy-flag victory))
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod reset-penetrate! ((this enemy))
  (logior! (-> this enemy-flags) (enemy-flag auto-reset-penetrate))
  (set-time! (-> this auto-reset-penetrate-time))
  (none)
  )

(defmethod get-knockback-dir! ((this enemy) (arg0 vector))
  (set! (-> arg0 quad) (-> this incoming attack-direction quad))
  (let ((v1-1 arg0))
    (when (= (+ (* (-> v1-1 x) (-> v1-1 x)) (* (-> v1-1 z) (-> v1-1 z))) 0.0)
      (vector-z-quaternion! arg0 (-> this root quat))
      (vector-negate-in-place! arg0)
      )
    )
  (set! (-> arg0 y) 0.0)
  (vector-xz-normalize! arg0 1.0)
  )

;; WARN: Return type mismatch int vs knocked-type.
(defmethod penetrate->knocked-type ((this enemy) (arg0 penetrate))
  (the-as knocked-type (cond
                         ((logtest? arg0 (penetrate vehicle))
                          7
                          )
                         ((logtest? (penetrate jak-blue-shot) arg0)
                          6
                          )
                         ((logtest? (penetrate jak-yellow-shot enemy-yellow-shot) arg0)
                          4
                          )
                         ((logtest? (penetrate jak-red-shot) arg0)
                          5
                          )
                         ((logtest? (penetrate dark-bomb dark-smack) arg0)
                          3
                          )
                         ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg0)
                          2
                          )
                         ((logtest? arg0 (penetrate mech-punch))
                          1
                          )
                         (else
                           0
                           )
                         )
          )
  )

(defmethod get-incoming-attack! ((this enemy)
                                (arg0 process-drawable)
                                (arg1 event-message-block)
                                (arg2 penetrate)
                                (arg3 attack-info)
                                (arg4 touching-shapes-entry)
                                )
  (set! (-> this incoming penetrate-using) arg2)
  (set! (-> this incoming attack-id) (-> arg3 id))
  (let ((v1-3 (if (logtest? (attack-mask knock) (-> arg3 mask))
                  (-> arg3 knock)
                  (penetrate->knocked-type this arg2)
                  )
              )
        )
    (set! (-> this incoming knocked-type) v1-3)
    (let ((a0-4 (current-time)))
      (cond
        ((!= v1-3 (knocked-type blue-shot))
         (set! (-> this incoming blue-juggle-count) (the-as uint 0))
         0
         )
        ((time-elapsed? (-> this incoming attack-time) (seconds 1))
         (set! (-> this incoming blue-juggle-count) (the-as uint 1))
         )
        (else
          (+! (-> this incoming blue-juggle-count) 1)
          )
        )
      (set! (-> this incoming attack-time) a0-4)
      )
    (cond
      ((= v1-3 (knocked-type vehicle))
       (set! (-> this incoming attack-direction quad) (-> arg3 vector quad))
       )
      (else
        (let ((s2-0 (new 'stack-no-clear 'attack-info)))
          (attack-info-method-9 arg3 s2-0 arg0 this)
          (set! (-> this incoming attacker-pos quad) (-> s2-0 intersection quad))
          (set! (-> this incoming attack-direction quad) (-> s2-0 attacker-velocity quad))
          )
        )
      )
    )
  (set! (-> this incoming intensity) (-> arg3 control))
  (set! (-> this incoming attacker-handle) (process->handle (find-offending-pfoc this arg0 arg3)))
  (cond
    (arg4
      (let ((a1-12 (-> arg4 head)))
        (get-intersect-point (-> this incoming attack-position) a1-12 (-> this root) arg4)
        )
      )
    (else
      (vector-! (-> this incoming attack-position) (-> this root trans) (-> this incoming attack-direction))
      )
    )
  0
  (none)
  )

(defmethod set-look-at-mode! ((this enemy) (arg0 int))
  (case arg0
    ((1)
     (logclear! (-> this enemy-flags) (enemy-flag look-at-move-dest))
     (logior! (-> this enemy-flags) (enemy-flag look-at-focus))
     )
    ((2)
     (logclear! (-> this enemy-flags) (enemy-flag look-at-focus))
     (logior! (-> this enemy-flags) (enemy-flag look-at-move-dest))
     )
    )
  (if (nonzero? (-> this neck))
      (mode-set! (-> this neck) (joint-mod-mode look-at))
      )
  0
  (none)
  )

(defmethod stop-look-at! ((this enemy))
  (when (nonzero? (-> this neck))
    (logclear! (-> this enemy-flags) (enemy-flag look-at-focus look-at-move-dest))
    (shut-down (-> this neck))
    )
  0
  (none)
  )

(defmethod set-ground-pat! ((this enemy) (arg0 collide-query) (arg1 collide-spec) (arg2 float) (arg3 float) (arg4 float) (arg5 process))
  (when (find-ground (-> this root) arg0 arg1 arg2 arg3 arg4 arg5)
    (let ((v0-1 (-> arg0 best-other-tri pat)))
      (set! (-> this root ground-pat) v0-1)
      v0-1
      )
    )
  )

(defmethod enemy-above-ground? ((this enemy) (arg0 collide-query) (arg1 vector) (arg2 collide-spec) (arg3 float) (arg4 float) (arg5 float))
  (above-ground? (-> this root) arg0 arg1 arg2 arg3 arg4 arg5)
  )

(defmethod try-locate-ground ((this enemy) (arg0 meters) (arg1 meters) (arg2 symbol) (arg3 collide-spec))
  (let ((s4-0 (new 'stack-no-clear 'collide-query)))
    (cond
      ((set-ground-pat! this s4-0 arg3 arg0 arg1 1024.0 (the-as process #f))
       (let ((s5-1 (-> this root)))
         (let ((s3-0 (new 'stack-no-clear 'vector)))
           (set! (-> s3-0 quad) (-> this root trans quad))
           (set! (-> s3-0 y) (-> s4-0 best-other-tri intersect y))
           (move-to-point! s5-1 s3-0)
           (let ((a0-3 (-> s4-0 best-other-tri normal))
                 (v1-8 (-> s4-0 best-other-tri pat))
                 )
             (set! (-> s5-1 ground-touch-point quad) (-> s3-0 quad))
             (set! (-> s5-1 poly-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 surface-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 local-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 ground-poly-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 poly-pat) v1-8)
             (set! (-> s5-1 cur-pat) v1-8)
             (set! (-> s5-1 ground-pat) v1-8)
             )
           )
         (logior! (-> s5-1 status) (collide-status on-surface on-ground touch-surface))
         )
       #t
       )
      (else
        (let ((v1-11 (-> this root)))
          (logclear! (-> v1-11 status) (collide-status
                                         on-surface
                                         on-ground
                                         touch-surface
                                         touch-wall
                                         touch-ceiling
                                         touch-actor
                                         on-special-surface
                                         touch-edge
                                         blocked
                                         on-water
                                         impact-surface
                                         touch-background
                                         stuck
                                         glance
                                         )
                     )
          (when (not (logtest? (-> v1-11 root-prim prim-core action) (collide-action no-normal-reset)))
            (let ((a0-12 (-> v1-11 dynam gravity-normal)))
              (set! (-> v1-11 local-normal quad) (-> a0-12 quad))
              (set! (-> v1-11 surface-normal quad) (-> a0-12 quad))
              (set! (-> v1-11 poly-normal quad) (-> a0-12 quad))
              )
            (set! (-> v1-11 coverage) 0.0)
            (set! (-> v1-11 touch-angle) 0.0)
            )
          )
        (if arg2
            (format 0 "WARNING: enemy::move-to-ground: failed to locate ground for ~S!~%" (-> this name))
            )
        #f
        )
      )
    )
  )

(defmethod move-above-ground! ((this enemy) (arg0 vector) (arg1 move-above-ground-params))
  (let ((gp-0 (-> this root)))
    (set! (-> arg1 on-ground?) #f)
    (set! (-> arg1 do-move?) #t)
    (set! (-> arg1 old-gspot-pos quad) (-> gp-0 gspot-pos quad))
    (set! (-> arg1 old-gspot-normal quad) (-> gp-0 gspot-normal quad))
    (set! (-> gp-0 trans-old-old-old quad) (-> gp-0 trans-old-old quad))
    (set! (-> gp-0 trans-old-old quad) (-> gp-0 trans-old quad))
    (set! (-> gp-0 trans-old quad) (-> gp-0 trans quad))
    (set! (-> gp-0 prev-status) (-> gp-0 status))
    (vector-v+! (-> gp-0 trans) (-> gp-0 trans) arg0)
    (set! (-> arg1 new-pos quad) (-> gp-0 trans quad))
    (let ((s2-0 (new 'stack-no-clear 'collide-query)))
      (cond
        ((set-ground-pat! this s2-0 (-> arg1 gnd-collide-with) (-> arg1 popup) 81920.0 1024.0 (the-as process #f))
         (when (>= (-> gp-0 gspot-pos y) (-> arg1 new-pos y))
           (set! (-> arg1 on-ground?) #t)
           (set! (-> arg1 pat) (-> s2-0 best-other-tri pat))
           (set! (-> arg1 new-pos y) (-> s2-0 best-other-tri intersect y))
           (set! (-> gp-0 ground-impact-vel) (- (vector-dot arg0 (-> gp-0 dynam gravity-normal))))
           (set! (-> arg0 y) 0.0)
           )
         )
        (else
          (if (-> arg1 hover-if-no-ground?)
              (set! (-> arg1 new-pos y) (-> gp-0 trans-old y))
              )
          )
        )
      )
    (set! (-> gp-0 trans quad) (-> gp-0 trans-old quad))
    (move-to-point! gp-0 (-> arg1 new-pos))
    (when (logtest? (logand (-> arg1 overlaps-params collide-with-filter)
                            (collide-spec hit-by-player-list hit-by-others-list player-list)
                            )
                    (-> gp-0 root-prim prim-core collide-with)
                    )
      (when (find-overlapping-shapes gp-0 (-> arg1 overlaps-params))
        (when (-> arg1 dont-move-if-overlaps?)
          (set! (-> arg1 do-move?) #f)
          (move-to-point! gp-0 (-> gp-0 trans-old))
          (set! (-> gp-0 gspot-pos quad) (-> arg1 old-gspot-pos quad))
          (set! (-> gp-0 gspot-normal quad) (-> arg1 old-gspot-normal quad))
          )
        )
      )
    (when (-> arg1 do-move?)
      (cond
        ((-> arg1 on-ground?)
         (let ((a1-6 (-> gp-0 gspot-pos))
               (a0-21 (-> gp-0 gspot-normal))
               (v1-39 (-> arg1 pat))
               )
           (set! (-> gp-0 ground-touch-point quad) (-> a1-6 quad))
           (set! (-> gp-0 poly-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 surface-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 local-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 ground-poly-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 poly-pat) v1-39)
           (set! (-> gp-0 cur-pat) v1-39)
           (set! (-> gp-0 ground-pat) v1-39)
           )
         (logior! (-> gp-0 status) (collide-status on-surface on-ground touch-surface))
         )
        (else
          (logclear! (-> gp-0 status) (collide-status
                                        on-surface
                                        on-ground
                                        touch-surface
                                        touch-wall
                                        touch-ceiling
                                        touch-actor
                                        on-special-surface
                                        touch-edge
                                        blocked
                                        on-water
                                        impact-surface
                                        touch-background
                                        stuck
                                        glance
                                        )
                     )
          (when (not (logtest? (-> gp-0 root-prim prim-core action) (collide-action no-normal-reset)))
            (let ((v1-49 (-> gp-0 dynam gravity-normal)))
              (set! (-> gp-0 local-normal quad) (-> v1-49 quad))
              (set! (-> gp-0 surface-normal quad) (-> v1-49 quad))
              (set! (-> gp-0 poly-normal quad) (-> v1-49 quad))
              )
            (set! (-> gp-0 coverage) 0.0)
            (set! (-> gp-0 touch-angle) 0.0)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod apply-friction ((this enemy))
  (let ((v1-0 (-> this root)))
    (when (logtest? (-> v1-0 status) (collide-status touch-surface))
      (let ((f0-1 (fmax 0.0 (+ 1.0 (* 60.0 (seconds-per-frame) (+ -1.0 (-> this enemy-info friction)))))))
        (vector-float*! (-> v1-0 transv) (-> v1-0 transv) f0-1)
        )
      0
      )
    )
  0
  (none)
  )

(defmethod init-enemy-collision! ((this enemy))
  0
  (none)
  )

(defmethod init-enemy! ((this enemy))
  0
  (none)
  )

(defmethod go-idle2 ((this enemy))
  (go (method-of-object this idle))
  )

(defmethod init-enemy-info! ((this enemy) (arg0 enemy-info))
  (set! (-> this enemy-info) arg0)
  (when (and (!= (-> this enemy-info neck-joint) -1) (zero? (-> this neck)))
    (set! (-> this neck)
          (new 'process 'joint-mod (joint-mod-mode flex-blend) this (-> this enemy-info neck-joint))
          )
    (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> this neck up) (the-as uint 1))
    (set! (-> this neck nose) (the-as uint 2))
    (set! (-> this neck ear) (the-as uint 0))
    (set! (-> this neck max-dist) 102400.0)
    (set! (-> this neck ignore-angle) 16384.0)
    )
  0
  (none)
  )

(defmethod init-enemy-defaults! ((this enemy) (arg0 enemy-info))
  (local-vars (sv-16 res-tag))
  (when (coin-flip? this)
    (let ((a0-2 (-> this node-list data 2)))
      (set! (-> a0-2 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint-flip-z!))
      (set! (-> a0-2 param1) #f)
      (set! (-> a0-2 param2) #f)
      )
    (logior! (-> this enemy-flags) (enemy-flag drawn-mirrored))
    )
  (logior! (-> this mask) (process-mask enemy))
  (logior! (-> this mask) (process-mask actor-pause))
  (logior! (-> this enemy-flags) (enemy-flag actor-pause-backup))
  (init-enemy-info! this arg0)
  (set! (-> this ragdoll-proc) (the-as handle #f))
  (let ((a1-2 (-> this enemy-info idle-anim-script)))
    (if a1-2
        (init! (-> this idle-anim-player) a1-2)
        )
    )
  (if (-> this draw shadow)
      (set! (-> this draw shadow-ctrl) (new
                                         'process
                                         'shadow-control
                                         (-> this enemy-info shadow-min-y)
                                         (-> this enemy-info shadow-max-y)
                                         (-> this enemy-info shadow-locus-dist)
                                         (the-as vector #f)
                                         (shadow-flags shdf00 shdf04)
                                         245760.0
                                         )
            )
      (set! (-> this draw shadow-ctrl) *enemy-dummy-shadow-control*)
      )
  (set! (-> this water-max-height) 8192.0)
  (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
      (set! (-> this hit-points) (* 2.0 (-> this enemy-info default-hit-points)))
      (set! (-> this hit-points) (-> this enemy-info default-hit-points))
      )
  (let* ((v1-37 *game-info*)
         (a0-10 (+ (-> v1-37 attack-id) 1))
         )
    (set! (-> v1-37 attack-id) a0-10)
    (set! (-> this attack-id) a0-10)
    )
  (let* ((v1-38 *game-info*)
         (a0-12 (+ (-> v1-38 attack-id) 1))
         )
    (set! (-> v1-38 attack-id) a0-12)
    (set! (-> this persistent-attack-id) a0-12)
    )
  (set! (-> this incoming attacker-handle) (the-as handle #f))
  (set! (-> this gnd-collide-with) (-> this enemy-info gnd-collide-with))
  (set! (-> this fact) (new 'process 'fact-info-enemy this (the-as (pointer float) (-> arg0 fact-defaults))))
  (let ((cspec (if (logtest? (enemy-option multi-focus) (-> this fact enemy-options))
                   (the-as collide-spec (collide-spec jak bot player-list jak-vehicle))
                   (the-as collide-spec (collide-spec jak player-list jak-vehicle))
                   )
               )
        )
    (reset-to-collide-spec (-> this focus) (the-as collide-spec cspec))
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-47 (res-lump-data (-> this entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (cond
      ((and v1-47 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) v1-47)
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this on-notice) (res-lump-struct (-> this entity) 'on-notice pair))
  (set! (-> this on-active) (res-lump-struct (-> this entity) 'on-active pair))
  (set! (-> this on-hostile) (res-lump-struct (-> this entity) 'on-hostile pair))
  (set! (-> this on-death) (res-lump-struct (-> this entity) 'on-death pair))
  (if (-> this on-notice)
      (logior! (-> this enemy-flags) (enemy-flag enable-on-notice))
      )
  (if (-> this on-active)
      (logior! (-> this enemy-flags) (enemy-flag enable-on-active))
      )
  (if (-> this on-hostile)
      (logior! (-> this enemy-flags) (enemy-flag enable-on-hostile))
      )
  (let ((s4-0 (-> this root)))
    (set! (-> this penetrated-by-all) (-> s4-0 penetrated-by))
    (set! (-> s4-0 penetrated-by) (get-penetrated-by this))
    (set! (-> s4-0 event-self) 'touched)
    )
  (set! (-> this penetrate-flinch) (-> arg0 penetrate-flinch))
  (set! (-> this penetrate-knocked) (-> arg0 penetrate-knocked))
  (set! (-> this reaction-time) (set-reaction-time! this (seconds 0.1) (seconds 0.6)))
  (let* ((v1-77 (-> this enemy-flags))
         (a0-28 (-> this fact enemy-options))
         (v1-78
           (logior (enemy-flag vulnerable vulnerable-backup use-notice-distance attackable-backup trackable trackable-backup)
                   v1-77
                   )
           )
         )
    (if (logtest? (enemy-option multi-focus) a0-28)
        (set! v1-78 (logior (enemy-flag multi-focus) v1-78))
        )
    (if (logtest? (enemy-option has-trigger) a0-28)
        (set! v1-78 (logior (enemy-flag use-trigger) v1-78))
        )
    (set! (-> this enemy-flags) v1-78)
    )
  (if (and (should-move-to-ground? this)
           (not (logtest? (enemy-flag no-initial-move-to-ground) (-> this enemy-flags)))
           (not (logtest? (enemy-option ambush) (-> this fact enemy-options)))
           )
      (try-locate-ground this (meters 10) (meters 10) #t (-> this gnd-collide-with))
      )
  (if (zero? (-> this draw light-index))
      (set! (-> this draw light-index) (the-as uint 10))
      )
  0
  (none)
  )

(defmethod enemy-method-152 ((this enemy))
  1.0
  )

(defmethod get-gem-pool-idx ((this enemy))
  (-> *setting-control* user-current gem-pool-index)
  )

(defbehavior enemy-setup-gem enemy ()
  (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag has-gem))))
  (when (> (-> self enemy-info gem-joint) 0)
    (let ((gp-0 (get-gem-pool-idx self)))
      (when (gems-available? gp-0)
        (if (or (and (zero? gp-0)
                     (-> self entity)
                     (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status save))))
                     )
                (and (nonzero? gp-0) (let* ((v1-14 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                                            (v1-15 (the-as number (logior #x3f800000 v1-14)))
                                            )
                                       (< (+ -1.0 (the-as float v1-15)) (enemy-method-152 self))
                                       )
                     )
                )
            (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag has-gem) (-> self enemy-flags))))
            )
        )
      )
    (cond
      ((logtest? (enemy-flag has-gem) (-> self enemy-flags))
       (setup-masks
         (-> self draw)
         (the-as int (-> self enemy-info gem-seg))
         (the-as int (-> self enemy-info gem-no-seg))
         )
       (add-connection *part-engine* self (-> self enemy-info gem-joint) self 464 (-> self enemy-info gem-offset))
       )
      (else
        (setup-masks
          (-> self draw)
          (the-as int (-> self enemy-info gem-seg))
          (the-as int (-> self enemy-info gem-no-seg))
          )
        )
      )
    )
  )

(defbehavior enemy-init-by-other enemy ((arg0 process-drawable) (arg1 enemy-init-by-other-params))
  (let ((a1-1 (-> arg1 entity)))
    (if a1-1
        (process-entity-set! self a1-1)
        )
    )
  (when (-> arg1 art-level)
    (let ((v1-5 (level-get *level* (-> arg1 art-level))))
      (if v1-5
          (set! (-> self level) v1-5)
          )
      )
    )
  (if (-> arg1 directed?)
      (logior! (-> self enemy-flags) (enemy-flag directed))
      )
  (if (-> arg1 no-initial-move-to-ground?)
      (set! (-> self enemy-flags)
            (the-as enemy-flag (logior (enemy-flag no-initial-move-to-ground) (-> self enemy-flags)))
            )
      )
  (init-enemy-collision! self)
  (set! (-> self root trans quad) (-> arg1 trans quad))
  (quaternion-copy! (-> self root quat) (-> arg1 quat))
  (vector-identity! (-> self root scale))
  (init-enemy! self)
  (enemy-setup-gem)
  (process-entity-status! self (entity-perm-status subtask-complete) #f)
  (let ((v1-24 (-> self fact enemy-options)))
    (cond
      (*debug-view-anims*
        (go-virtual view-anims)
        )
      ((logtest? (enemy-option dormant) v1-24)
       (go-dormant self)
       )
      ((logtest? (enemy-flag directed) (-> self enemy-flags))
       (go-directed self)
       )
      ((logtest? (enemy-option dormant-aware) v1-24)
       (go-dormant-aware self)
       )
      ((logtest? (enemy-option ambush) (-> self fact enemy-options))
       (go-ambush-delay self)
       )
      (else
        (go-idle2 self)
        )
      )
    )
  )

(defmethod init-from-entity! ((this enemy) (arg0 entity-actor))
  (let ((a1-2 (res-lump-struct arg0 'art-level symbol)))
    (when a1-2
      (let ((a0-3 (level-get *level* a1-2)))
        (if a0-3
            (set! (-> this level) a0-3)
            )
        )
      )
    )
  (init-enemy-collision! this)
  (process-drawable-from-entity! this arg0)
  (init-enemy! this)
  (enemy-setup-gem)
  (let ((v1-10 (-> this fact enemy-options)))
    (cond
      ((logtest? (enemy-option spawner) v1-10)
       (process-entity-status! this (entity-perm-status dead) #t)
       (go (method-of-object this die-fast))
       )
      (*debug-view-anims*
        (go (method-of-object this view-anims))
        )
      ((logtest? (enemy-option dormant) v1-10)
       (go-dormant this)
       )
      ((logtest? (enemy-option dormant-aware) v1-10)
       (go-dormant-aware this)
       )
      (else
        (go-idle2 this)
        )
      )
    )
  )

(defmethod is-pfoc-in-mesh? ((this enemy) (arg0 process-focusable) (arg1 vector))
  #t
  )

(defmethod enemy-method-108 ((this enemy) (arg0 process-focusable))
  #f
  )

(defmethod reset-to-collide-spec ((this enemy-focus) (arg0 collide-spec))
  "Reset this focus with the given [[collide-spec]]."
  (let ((t9-0 (method-of-type focus reset-to-collide-spec)))
    (t9-0 this arg0)
    )
  (set! (-> this aware) (enemy-aware ea0))
  0
  (none)
  )

(defmethod update-focus ((this enemy))
  (let ((gp-0 (-> this focus)))
    (let ((a1-0 (handle->process (-> gp-0 handle))))
      (when a1-0
        (let ((v1-4 (-> this enemy-flags)))
          (cond
            ((and a1-0 (not (logtest? (-> (the-as process-focusable a1-0) focus-status) (focus-status disable dead))))
             (when (and (logtest? (enemy-flag multi-focus) v1-4)
                        (not (logtest? (enemy-flag lock-focus) v1-4))
                        (not (logtest? (-> gp-0 flags) (enemy-flag look-at-focus)))
                        )
               (find-best-focus this)
               (return (the-as process #f))
               )
             (let ((v1-14
                     (get-enemy-aware this (update-awareness! this (the-as process-focusable a1-0) (the-as enemy-best-focus #f)))
                     )
                   )
               (set! (-> gp-0 aware) v1-14)
               (if (>= 1 (the-as int v1-14))
                   (logclear! (-> gp-0 flags) (enemy-flag look-at-focus))
                   )
               )
             (return (the-as process #f))
             )
            (else
              (clear-focused gp-0)
              )
            )
          )
        )
      )
    (if (!= (-> gp-0 handle) #f)
        (clear-focused gp-0)
        )
    )
  (if (not (logtest? (enemy-flag lock-focus) (-> this enemy-flags)))
      (find-best-focus this)
      )
  )

(defmethod find-best-focus ((this enemy))
  (let ((s4-0 (-> this focus collide-with))
        (gp-0 (new 'stack-no-clear 'enemy-best-focus))
        )
    (set! (-> gp-0 proc) #f)
    (set! (-> gp-0 rating) 409600000.0)
    (set! (-> gp-0 aware) (enemy-aware ea0))
    (when (logtest? s4-0 (collide-spec player-list))
      (let ((v1-4 (-> *collide-player-list* alive-list next0)))
        *collide-player-list*
        (let ((s3-0 (-> v1-4 next0)))
          (while (!= v1-4 (-> *collide-player-list* alive-list-end))
            (let ((v1-5 (the-as collide-shape (-> (the-as connection v1-4) param1))))
              (when (logtest? s4-0 (-> v1-5 root-prim prim-core collide-as))
                (let* ((s2-0 (-> v1-5 process))
                       (a1-1 (if (type? s2-0 process-focusable)
                                 s2-0
                                 )
                             )
                       )
                  (if (and a1-1
                           (and a1-1 (not (logtest? (-> (the-as process-focusable a1-1) focus-status) (focus-status disable dead))))
                           (!= this a1-1)
                           )
                      (update-awareness! this (the-as process-focusable a1-1) gp-0)
                      )
                  )
                )
              )
            (set! v1-4 s3-0)
            *collide-player-list*
            (set! s3-0 (-> s3-0 next0))
            )
          )
        )
      )
    (when (logtest? s4-0 (collide-spec hit-by-player-list hit-by-others-list))
      (when (logtest? s4-0 (collide-spec hit-by-player-list))
        (let ((v1-19 (-> *collide-hit-by-player-list* alive-list next0)))
          *collide-hit-by-player-list*
          (let ((s3-1 (-> v1-19 next0)))
            (while (!= v1-19 (-> *collide-hit-by-player-list* alive-list-end))
              (let ((v1-20 (the-as collide-shape (-> (the-as connection v1-19) param1))))
                (when (logtest? s4-0 (-> v1-20 root-prim prim-core collide-as))
                  (let* ((s2-1 (-> v1-20 process))
                         (a1-3 (if (type? s2-1 process-focusable)
                                   s2-1
                                   )
                               )
                         )
                    (if (and a1-3
                             (and a1-3 (not (logtest? (-> (the-as process-focusable a1-3) focus-status) (focus-status disable dead))))
                             (!= this a1-3)
                             )
                        (update-awareness! this (the-as process-focusable a1-3) gp-0)
                        )
                    )
                  )
                )
              (set! v1-19 s3-1)
              *collide-hit-by-player-list*
              (set! s3-1 (-> s3-1 next0))
              )
            )
          )
        )
      (when (logtest? s4-0 (collide-spec hit-by-others-list))
        (let ((v1-32 (-> *collide-hit-by-others-list* alive-list next0)))
          *collide-hit-by-others-list*
          (let ((s3-2 (-> v1-32 next0)))
            (while (!= v1-32 (-> *collide-hit-by-others-list* alive-list-end))
              (let ((v1-33 (the-as collide-shape (-> (the-as connection v1-32) param1))))
                (when (logtest? s4-0 (-> v1-33 root-prim prim-core collide-as))
                  (let* ((s2-2 (-> v1-33 process))
                         (a1-5 (if (type? s2-2 process-focusable)
                                   s2-2
                                   )
                               )
                         )
                    (if (and a1-5
                             (and a1-5 (not (logtest? (-> (the-as process-focusable a1-5) focus-status) (focus-status disable dead))))
                             (!= this a1-5)
                             )
                        (update-awareness! this (the-as process-focusable a1-5) gp-0)
                        )
                    )
                  )
                )
              (set! v1-32 s3-2)
              *collide-hit-by-others-list*
              (set! s3-2 (-> s3-2 next0))
              )
            )
          )
        )
      )
    (let ((s4-1 (-> gp-0 proc)))
      (when s4-1
        (enemy-method-70 this (the-as process-focusable s4-1) (get-enemy-aware this (-> gp-0 aware)))
        s4-1
        )
      )
    )
  )

;; WARN: Return type mismatch int vs enemy-aware.
(defmethod update-awareness! ((this enemy) (arg0 process-focusable) (arg1 enemy-best-focus))
  (let ((f30-0 (vector-vector-distance (get-trans arg0 0) (-> this root trans)))
        (s3-1 #f)
        (s2-0 #f)
        )
    (cond
      ((< f30-0 (-> this enemy-info proximity-notice-distance))
       (set! s3-1 #t)
       (set! s2-0 (is-pfoc-in-mesh? this arg0 (the-as vector #f)))
       )
      (else
        (let ((f0-1 (the-as float (-> this enemy-info notice-distance))))
          (if (< 1 (the-as int (-> this focus aware)))
              (set! f0-1 (+ (the-as meters f0-1) (-> this enemy-info notice-distance-delta)))
              )
          (when (or (< f30-0 f0-1) (not (logtest? (-> this enemy-flags) (enemy-flag use-notice-distance))))
            (set! s2-0 (is-pfoc-in-mesh? this arg0 (the-as vector #f)))
            (if s2-0
                (set! s3-1 #t)
                )
            )
          )
        )
      )
    (let ((aware (cond
                   (s3-1
                     (cond
                       ((enemy-method-108 this arg0)
                        (the-as enemy-aware (enemy-aware ea4))
                        )
                       (s2-0
                         (the-as enemy-aware (enemy-aware ea3))
                         )
                       (else
                         (the-as enemy-aware (enemy-aware ea2))
                         )
                       )
                     )
                   ((< f30-0 (-> this fact idle-distance))
                    (the-as enemy-aware (enemy-aware ea1))
                    )
                   (else
                     (the-as enemy-aware (enemy-aware ea0))
                     )
                   )
                 )
          )
      (when (and (> (the-as int aware) 0) (logtest? (enemy-flag use-trigger) (-> this enemy-flags)))
        (cond
          ((logtest? (enemy-option idle-til-trigger) (-> this fact enemy-options))
           (if (not (enemy-method-141 this f30-0))
               (set! aware (enemy-aware ea0))
               )
           )
          (else
            (if (and (< 1 (the-as int aware)) (not (enemy-method-141 this f30-0)))
                (set! aware (enemy-aware ea1))
                )
            )
          )
        )
      (when arg1
        (when (and (>= (the-as int aware) (the-as int (-> arg1 aware))) (< f30-0 (-> arg1 rating)))
          (set! (-> arg1 aware) (the-as enemy-aware aware))
          (set! (-> arg1 rating) f30-0)
          (set! (-> arg1 proc) arg0)
          )
        )
      (the-as enemy-aware aware)
      )
    )
  )

(defmethod enemy-method-141 ((this enemy) (arg0 float))
  (let* ((v1-0 (-> this fact))
         (a2-0 (-> v1-0 trig-mask-count))
         (a3-0 (-> v1-0 trig-mask))
         )
    (dotimes (t0-0 a2-0)
      (let ((t1-1 (the-as int (-> a3-0 t0-0))))
        (if (and (logtest? (the-as uint t1-1) 1) (>= (-> v1-0 trig-dist) arg0))
            (set! t1-1 (the-as int (logand -2 (the-as uint t1-1))))
            )
        (when (logtest? (the-as uint t1-1) 2)
          (let ((t2-8 (-> v1-0 trig-actor-group 0)))
            (countdown (t3-0 (-> t2-8 length))
              (let ((t5-0 (-> t2-8 data t3-0 actor)))
                (when (and t5-0 (logtest? (-> t5-0 extra perm status) (entity-perm-status subtask-complete)))
                  (set! t1-1 (the-as int (logand -3 (the-as uint t1-1))))
                  (goto cfg-17)
                  )
                )
              )
            )
          )
        (label cfg-17)
        (when (zero? t1-1)
          (logclear! (-> this enemy-flags) (enemy-flag use-trigger))
          (return #t)
          )
        )
      )
    )
  #f
  )

;; WARN: Return type mismatch int vs enemy-aware.
(defmethod get-enemy-aware ((this enemy) (arg0 enemy-aware))
  (let ((v1-1 (< 1 (the-as int arg0))))
    (cond
      (v1-1
        (when (not (logtest? (-> this enemy-flags) (enemy-flag notice)))
          (logior! (-> this enemy-flags) (enemy-flag notice))
          (set-time! (-> this notice-time))
          )
        (if (and (not (logtest? (-> this enemy-flags) (enemy-flag alert)))
                 (not (time-elapsed? (-> this notice-time) (-> this reaction-time)))
                 )
            (set! v1-1 #f)
            )
        )
      (else
        (logclear! (-> this enemy-flags) (enemy-flag notice))
        )
      )
    (the-as enemy-aware (cond
                          (v1-1
                            (the-as int arg0)
                            )
                          ((or (= arg0 (enemy-aware ea0)) (time-elapsed? (-> this last-draw-time) (seconds 2)))
                           0
                           )
                          (else
                            1
                            )
                          )
            )
    )
  )

(defmethod event-handler ((this enemy) (proc process) (argc int) (msg symbol) (block event-message-block))
  (local-vars (s5-6 rgbaf) (sv-640 event-message-block) (sv-656 process) (sv-672 event-message-block))
  (cond
    ((= msg 'go-gun-dark-2-stretch)
     (go-gun-dark-2-stretch this)
     )
    ((= msg 'go-gun-dark-3-nuke)
     (on-dying this)
     (send-event (ppointer->process (-> this parent)) 'child-die)
     (mark-as-dead this)
     (cleanup-for-death this)
     (go (method-of-object this die-fast))
     )
    ((= msg 'combo)
     (and (not (logtest? (enemy-flag dislike-combo) (-> this enemy-flags))) (!= (-> this hit-points) 0.0))
     )
    ((= msg 'touch)
     (enemy-touch-handler this proc block)
     )
    ((= msg 'touched)
     (when (logtest? (-> this enemy-flags) (enemy-flag auto-reset-penetrate))
       (let* ((s3-1 proc)
              (v1-27 (if (type? s3-1 process-drawable)
                         s3-1
                         )
                     )
              )
         (when v1-27
           (let* ((s3-2 (-> (the-as process-drawable v1-27) root))
                  (a1-5 (if (type? s3-2 collide-shape)
                            s3-2
                            )
                        )
                  (s3-3 (-> block param 0))
                  )
             (if (and a1-5
                      s3-3
                      ((method-of-type touching-shapes-entry prims-touching-action?)
                       (the-as touching-shapes-entry s3-3)
                       (the-as collide-shape a1-5)
                       (collide-action solid)
                       (collide-action)
                       )
                      ((method-of-type touching-shapes-entry prims-touching-action?)
                       (the-as touching-shapes-entry s3-3)
                       (-> this root)
                       (collide-action solid)
                       (collide-action)
                       )
                      )
                 (set-time! (-> this auto-reset-penetrate-time))
                 )
             )
           )
         )
       )
     (send-attack-on-jump-or-knocked this proc block)
     )
    ((= msg 'attack-invinc)
     (case (-> (the-as attack-info (-> block param 1)) mode)
       (('endlessfall)
        (let ((v1-39 (-> this root root-prim)))
          (set! (-> v1-39 prim-core collide-as) (collide-spec))
          (set! (-> v1-39 prim-core collide-with) (collide-spec))
          )
        0
        (go-die this)
        )
       )
     )
    ((= msg 'attack-no-avoid)
     (let* ((s2-0 (-> block param 1))
            (s3-4 this)
            (s1-0 (method-of-object s3-4 get-incoming-attack!))
            (s0-0 proc)
            )
       (set! sv-640 block)
       (let ((a3-3 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block))
             (t1-0 (-> block param 0))
             )
         (s1-0
           s3-4
           (the-as process-drawable s0-0)
           sv-640
           a3-3
           (the-as attack-info s2-0)
           (the-as touching-shapes-entry t1-0)
           )
         )
       )
     (damage-enemy! this proc block)
     )
    ((= msg 'attack)
     (let ((s2-1 (the-as object (-> block param 1))))
       (when (!= (-> (the-as attack-info s2-1) id) (-> this incoming attack-id))
         (cond
           ((and (logtest? (-> this enemy-flags) (enemy-flag vulnerable))
                 (not (logtest? (-> this focus-status) (focus-status grabbed)))
                 )
            (let* ((s1-1 this)
                   (s0-1 (method-of-object s1-1 get-incoming-attack!))
                   )
              (set! sv-656 proc)
              (set! sv-672 block)
              (let ((a3-4 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block))
                    (t1-1 (-> block param 0))
                    )
                (s0-1
                  s1-1
                  (the-as process-drawable sv-656)
                  sv-672
                  a3-4
                  (the-as attack-info s2-1)
                  (the-as touching-shapes-entry t1-1)
                  )
                )
              )
            (send-event (ppointer->process (-> this parent)) 'child-hit)
            (let ((f0-1 0.0))
              (if (not *debug-unkillable*)
                  (set! f0-1 (damage-enemy! this proc block))
                  )
              (let ((s2-2 (penetrate->next-state this proc block f0-1)))
                (when s2-2
                  (logclear! (-> this enemy-flags) (enemy-flag use-trigger))
                  (send-attack-to-all-tshapes this (the-as process-focusable proc) block)
                  (let ((a1-17 (new 'stack-no-clear 'event-message-block)))
                    (set! (-> a1-17 from) (process->ppointer proc))
                    (set! (-> a1-17 num-params) argc)
                    (set! (-> a1-17 message) s2-2)
                    (set! (-> a1-17 param 0) (-> block param 0))
                    (set! (-> a1-17 param 1) (-> block param 1))
                    (set! (-> a1-17 param 2) (-> block param 2))
                    (set! (-> a1-17 param 3) (-> block param 3))
                    (set! (-> a1-17 param 4) (-> block param 4))
                    (set! (-> a1-17 param 5) (-> block param 5))
                    (send-event-function this a1-17)
                    )
                  #t
                  )
                )
              )
            )
           (else
             (set! (-> this incoming attack-id) (-> (the-as attack-info s2-1) id))
             (enemy-touch-handler this proc block)
             )
           )
         )
       )
     )
    ((= msg 'impact-impulse)
     (let* ((s4-1 (the-as object (-> block param 0)))
            (s3-5 (if (type? proc process-focusable)
                      proc
                      )
                  )
            (f30-1 (* (-> (the-as rigid-body-impact s4-1) impulse) (get-inv-mass this)))
            )
       (when (and s3-5 (< 20480.0 f30-1))
         (let ((s5-1 (new 'stack-no-clear 'attack-info)))
           (let ((v1-85 (process->handle s3-5)))
             (let ((a0-41 s5-1))
               (set! (-> a0-41 mode) 'impact)
               (set! (-> a0-41 penetrate-using) (penetrate vehicle))
               (set! (-> a0-41 mask) (attack-mask mode penetrate-using))
               )
             (cond
               ((and (= v1-85 (-> this incoming attacker-handle))
                     (not (time-elapsed? (-> this incoming attack-time) (seconds 0.1)))
                     )
                (set! (-> s5-1 id) (-> this incoming attack-id))
                )
               (else
                 (let* ((a0-48 *game-info*)
                        (a1-26 (+ (-> a0-48 attack-id) 1))
                        )
                   (set! (-> a0-48 attack-id) a1-26)
                   (set! (-> s5-1 id) a1-26)
                   )
                 )
               )
             (logior! (-> s5-1 mask) (attack-mask id))
             (set! (-> s5-1 attacker) (the-as handle v1-85))
             )
           (logior! (-> s5-1 mask) (attack-mask attacker))
           (let ((v1-89 (scale-impact-vel-y!
                          this
                          (new 'stack-no-clear 'vector)
                          (vector-negate! (new 'stack-no-clear 'vector) (-> (the-as rigid-body-impact s4-1) velocity))
                          f30-1
                          )
                        )
                 )
             (set! (-> s5-1 attacker-velocity quad) (-> v1-89 quad))
             (set! (-> s5-1 vector quad) (-> v1-89 quad))
             )
           (logior! (-> s5-1 mask) (attack-mask attacker-velocity))
           (logior! (-> s5-1 mask) (attack-mask vector))
           (set! (-> s5-1 intersection quad) (-> (the-as rigid-body-impact s4-1) point quad))
           (logior! (-> s5-1 mask) (attack-mask intersection))
           (set! (-> s5-1 damage) (lerp-damage this f30-1))
           (logior! (-> s5-1 mask) (attack-mask damage))
           (when (< 0.0 (-> s5-1 damage))
             (format
               0
               "Sending impact-impulse attack with ~f damage (~m impulse,  ~m attacker-velocity)~%"
               (-> s5-1 damage)
               f30-1
               (vector-length (-> s5-1 attacker-velocity))
               )
             (send-event this 'attack #f s5-1)
             (when (= (-> this hit-points) 0.0)
               (logior! (-> this root penetrated-by) (penetrate vehicle))
               #t
               )
             )
           )
         )
       )
     )
    ((= msg 'hit-flinch)
     (when (= (-> this hit-points) 0.0)
       (logclear! (-> this mask) (process-mask actor-pause))
       (logclear! (-> this focus-status) (focus-status dangerous))
       (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance))
       (logior! (-> this enemy-flags) (enemy-flag alert))
       (logior! (-> this focus-status) (focus-status hit))
       (if (= (-> this hit-points) 0.0)
           (logior! (-> this focus-status) (focus-status dead))
           )
       (logclear! (-> this enemy-flags) (enemy-flag lock-focus))
       (enemy-method-69 this)
       (logior! (-> this enemy-flags) (enemy-flag lock-focus))
       (process-contact-action proc)
       (send-event proc 'get-attack-count 1)
       (freeze-hit-begin)
       (go-die this)
       )
     #t
     )
    ((= msg 'hit-knocked)
     (logclear! (-> this mask) (process-mask actor-pause))
     (logclear! (-> this focus-status) (focus-status dangerous))
     (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance))
     (logior! (-> this enemy-flags) (enemy-flag alert))
     (logior! (-> this focus-status) (focus-status hit))
     (if (= (-> this hit-points) 0.0)
         (logior! (-> this focus-status) (focus-status dead))
         )
     (logclear! (-> this enemy-flags) (enemy-flag lock-focus))
     (enemy-method-69 this)
     (logior! (-> this enemy-flags) (enemy-flag lock-focus))
     (process-contact-action proc)
     (send-event proc 'get-attack-count 1)
     (freeze-hit-begin)
     (when (= (-> this hit-points) 0.0)
       (case (-> this incoming knocked-type)
         (((knocked-type yellow-shot) (knocked-type blue-shot))
          (set! (-> this incoming knocked-type) (knocked-type none))
          0
          )
         )
       )
     (go (method-of-object this knocked))
     )
    ((= msg 'hit)
     (logclear! (-> this mask) (process-mask actor-pause))
     (logclear! (-> this focus-status) (focus-status dangerous))
     (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance))
     (logior! (-> this enemy-flags) (enemy-flag alert))
     (logior! (-> this focus-status) (focus-status hit))
     (if (= (-> this hit-points) 0.0)
         (logior! (-> this focus-status) (focus-status dead))
         )
     (logclear! (-> this enemy-flags) (enemy-flag lock-focus))
     (enemy-method-69 this)
     (logior! (-> this enemy-flags) (enemy-flag lock-focus))
     (process-contact-action proc)
     (send-event proc 'get-attack-count 1)
     (freeze-hit-begin)
     (if (= (-> this hit-points) 0.0)
         (go-die this)
         (go (method-of-object this hit))
         )
     )
    ((= msg 'cue-chase)
     (when (and (< 0.0 (-> this hit-points))
                (zero? (-> this fated-time))
                (not (logtest? (-> this focus-status) (focus-status grabbed)))
                )
       (let ((v1-202 (logtest? (enemy-flag directed) (-> this enemy-flags))))
         (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance directed directed-ready use-trigger))
         (logior! (-> this enemy-flags) (enemy-flag chase-startup))
         (logclear! (-> this mask) (process-mask actor-pause))
         (cond
           (v1-202
             (if (logtest? (enemy-option ambush) (-> this fact enemy-options))
                 (go-ambush-delay this)
                 (go-hostile this)
                 )
             )
           ((and (-> this next-state) (let ((v1-213 (-> this next-state name)))
                                        (or (= v1-213 'dormant) (= v1-213 'dormant-aware))
                                        )
                 )
            (if (logtest? (enemy-option ambush) (-> this fact enemy-options))
                (go-ambush-delay this)
                (go (method-of-object this notice))
                )
            )
           )
         )
       #t
       )
     )
    ((= msg 'cue-wake)
     (when (and (< 0.0 (-> this hit-points))
                (zero? (-> this fated-time))
                (not (logtest? (-> this focus-status) (focus-status grabbed)))
                )
       (logclear! (-> this enemy-flags) (enemy-flag directed directed-ready use-trigger))
       (if (logtest? (enemy-option ambush) (-> this fact enemy-options))
           (go-ambush-delay this)
           (go-best-state this)
           )
       #t
       )
     )
    ((= msg 'jump)
     (when (and (< 0.0 (-> this hit-points))
                (zero? (-> this fated-time))
                (not (logtest? (-> this focus-status) (focus-status grabbed)))
                )
       (logclear! (-> this mask) (process-mask actor-pause))
       (set! (-> this jump-why) (-> block param 0))
       (set! (-> this event-param-point quad) (-> (the-as vector (-> block param 1)) quad))
       (go (method-of-object this jump))
       )
     )
    ((= msg 'birth-pickup)
     (if (not (-> *setting-control* user-current gun-special-mode))
         (drop-pickup (-> this fact) #t *entity-pool* (-> this fact) 0 #f)
         )
     )
    ((= msg 'death-start)
     (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag death-start) (-> this enemy-flags))))
     (send-event (ppointer->process (-> this parent)) 'child-die)
     (when (< (-> *event-queue* length) (-> *event-queue* allocated-length))
       (let ((v1-269 (-> *event-queue* data (-> *event-queue* length))))
         (+! (-> *event-queue* length) 1)
         (set! (-> v1-269 from-handle) (process->handle self))
         (set! (-> v1-269 to-handle) (process->handle this))
         (set! (-> v1-269 num-params) 0)
         (set! (-> v1-269 message) 'birth-pickup)
         )
       )
     (let ((s5-2 (-> this on-death)))
       (if s5-2
           (script-eval s5-2 :vector (-> this root trans))
           )
       )
     )
    ((= msg 'death-end)
     (if (-> this skel effect)
         (logior! (-> this skel effect flags) (effect-control-flag ecf2))
         )
     (logior! (-> this draw status) (draw-control-status no-draw))
     (logclear! (-> this enemy-flags) (enemy-flag vulnerable vulnerable-backup))
     (logclear! (-> this focus-status) (focus-status dangerous))
     (set! (-> this enemy-flags) (logclear (-> this enemy-flags) (enemy-flag dangerous-backup)))
     )
    ((= msg 'instant-death)
     (when (and (< 0.0 (-> this hit-points)) (zero? (-> this fated-time)))
       (set! (-> this hit-points) 0.0)
       (set! (-> this root penetrated-by) (get-penetrated-by this))
       (let ((s5-3 (get-knockback-dir! this (new 'stack-no-clear 'vector))))
         (vector-z-quaternion! s5-3 (-> this root quat))
         (vector-float*! s5-3 s5-3 -1.0)
         (vector-normalize! s5-3 1.0)
         )
       (logclear! (-> this mask) (process-mask actor-pause))
       (logclear! (-> this focus-status) (focus-status dangerous))
       (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance))
       (logior! (-> this enemy-flags) (enemy-flag alert))
       (logior! (-> this focus-status) (focus-status hit))
       (if (= (-> this hit-points) 0.0)
           (logior! (-> this focus-status) (focus-status dead))
           )
       (logclear! (-> this enemy-flags) (enemy-flag lock-focus))
       (enemy-method-69 this)
       (logior! (-> this enemy-flags) (enemy-flag lock-focus))
       (go-die this)
       )
     )
    ((= msg 'die-fast)
     (logior! (-> this draw status) (draw-control-status no-draw))
     (on-dying this)
     (send-event (ppointer->process (-> this parent)) 'child-die)
     (let ((s5-4 (-> this on-death)))
       (if s5-4
           (script-eval s5-4 :vector (-> this root trans))
           )
       )
     (cleanup-for-death this)
     (go (method-of-object this die-fast))
     )
    ((= msg 'victory)
     (if (and (-> this enemy-info use-victory)
              (not (and (-> this next-state) (= (-> this next-state name) 'victory)))
              (and (< 0.0 (-> this hit-points))
                   (zero? (-> this fated-time))
                   (not (logtest? (-> this focus-status) (focus-status grabbed)))
                   )
              )
         (go (method-of-object this victory))
         )
     )
    ((= msg 'nav-control)
     (if (nonzero? (-> this nav))
         (-> this nav)
         )
     )
    ((= msg 'push-trans)
     (move-by-vector! (-> this root) (the-as vector (-> block param 0)))
     )
    ((= msg 'move-trans)
     (move-to-point! (-> this root) (the-as vector (-> block param 0)))
     )
    ((= msg 'shadow)
     (cond
       ((-> block param 0)
        (let ((v1-371 (-> this draw shadow-ctrl)))
          (logclear! (-> v1-371 settings flags) (shadow-flags disable-draw))
          )
        0
        )
       (else
         (let ((v1-374 (-> this draw shadow-ctrl)))
           (logior! (-> v1-374 settings flags) (shadow-flags disable-draw))
           )
         0
         )
       )
     )
    ((= msg 'color-effect)
     (case (-> block param 0)
       (('dark)
        (let ((f30-2 (rand-vu-float-range 0.2 1.0)))
          (set-vector! (-> this draw color-mult) (lerp 1.0 1.0 f30-2) (lerp 1.0 0.0 f30-2) (lerp 1.0 1.0 f30-2) 1.0)
          (set! s5-6 (-> this draw color-emissive))
          (set! (-> s5-6 x) (lerp 0.0 0.3 f30-2))
          (set! (-> s5-6 y) (lerp 0.0 0.0 f30-2))
          (set! (-> s5-6 z) (lerp 0.0 0.3 f30-2))
          )
        (set! (-> s5-6 w) 1.0)
        s5-6
        )
       ((#f)
        (set-vector! (-> this draw color-mult) 1.0 1.0 1.0 1.0)
        (set! s5-6 (-> this draw color-emissive))
        (set! (-> s5-6 quad) (the-as uint128 0))
        s5-6
        )
       )
     )
    ((= msg 'enable-envmap)
     (cond
       ((-> block param 0)
        (logclear! (-> this draw global-effect) (draw-control-global-effect disable-envmap))
        #t
        )
       (else
         (logior! (-> this draw global-effect) (draw-control-global-effect disable-envmap))
         #t
         )
       )
     )
    )
  )

(defmethod lerp-damage ((this enemy) (arg0 float))
  (lerp-scale 0.0 (-> this enemy-info default-hit-points) arg0 20480.0 122880.0)
  )

(defmethod scale-impact-vel-y! ((this enemy) (arg0 vector) (arg1 vector) (arg2 float))
  (set! (-> arg0 quad) (-> arg1 quad))
  (vector-normalize! arg0 arg2)
  (set! (-> arg0 y) (lerp-scale
                      (-> this enemy-info knocked-hard-vy-lo)
                      (-> this enemy-info knocked-hard-vy-hi)
                      arg2
                      20480.0
                      204800.0
                      )
        )
  (vector-normalize! arg0 arg2)
  arg0
  )

(defmethod get-damage-from-attack ((this enemy) (arg0 object) (arg1 event-message-block))
  (let ((v1-0 (the-as object (-> arg1 param 1))))
    (if (logtest? (attack-mask damage) (-> (the-as attack-info v1-0) mask))
        (-> (the-as attack-info v1-0) damage)
        (penetrate-using->damage (-> this incoming penetrate-using))
        )
    )
  )

(defmethod enemy-method-63 ((this enemy) (arg0 float))
  (let ((f0-1 (fmax 0.0 (fmin arg0 (-> this hit-points)))))
    (cond
      ((and (= (-> this incoming knocked-type) (knocked-type blue-shot)) (= f0-1 (-> this hit-points)) (< 0.0 f0-1))
       (cond
         ((zero? (-> this fated-time))
          (set-time! (-> this fated-time))
          (+ -1.0 f0-1)
          )
         ((not (time-elapsed? (-> this fated-time) (seconds 1)))
          (+ -1.0 f0-1)
          )
         (else
           f0-1
           )
         )
       )
      (else
        f0-1
        )
      )
    )
  )

(defmethod penetrate->next-state ((this enemy) (arg0 process) (arg1 event-message-block) (arg2 float))
  (let ((gp-0 (-> this incoming penetrate-using)))
    (cond
      ((and (logtest? (penetrate jak-dark-blackhole) gp-0) #t)
       'go-gun-dark-2-stretch
       )
      ((and (logtest? (penetrate jak-dark-nuke) (-> this incoming penetrate-using)) (enemy-method-150 this))
       'go-gun-dark-3-nuke
       )
      ((logtest? gp-0 (-> this penetrate-flinch))
       'hit-flinch
       )
      ((logtest? gp-0 (-> this penetrate-knocked))
       'hit-knocked
       )
      (else
        'hit
        )
      )
    )
  )

(defmethod damage-enemy! ((this enemy) (arg0 object) (arg1 event-message-block))
  (let* ((f0-0 (get-damage-from-attack this arg0 arg1))
         (f30-0 (enemy-method-63 this f0-0))
         )
    (set! (-> this hit-points) (- (-> this hit-points) f30-0))
    (if (not (logtest? (-> this enemy-flags) (enemy-flag auto-reset-penetrate)))
        (set! (-> this root penetrated-by) (get-penetrated-by this))
        )
    f30-0
    )
  )

(defmethod find-offending-pfoc ((this enemy) (arg0 process) (arg1 attack-info))
  (find-offending-process-focusable arg0 arg1)
  )

(defmethod enemy-touch-handler ((this enemy) (arg0 process) (arg1 event-message-block))
  (let* ((s4-0 (-> arg1 param 0))
         (s2-0 arg0)
         (s3-0 (if (type? s2-0 process-focusable)
                   s2-0
                   )
               )
         )
    (when (and s4-0 s3-0)
      (cond
        ((and (focus-test? this dangerous)
              (and s3-0
                   (not (logtest? (-> (the-as process-focusable s3-0) focus-status) (focus-status disable dead ignore grabbed)))
                   )
              ((method-of-type touching-shapes-entry prims-touching-action?)
               (the-as touching-shapes-entry s4-0)
               (-> this root)
               (collide-action deadly)
               (collide-action)
               )
              )
         (let ((a3-2 (if ((method-of-type touching-shapes-entry prims-touching-action?)
                          (the-as touching-shapes-entry s4-0)
                          (-> this root)
                          (collide-action persistent-attack)
                          (collide-action)
                          )
                         (-> this persistent-attack-id)
                         (-> this attack-id)
                         )
                     )
               )
           (send-attack this arg0 (the-as touching-shapes-entry s4-0) a3-2)
           )
         )
        ((and ((method-of-type touching-shapes-entry prims-touching-action?)
               (the-as touching-shapes-entry s4-0)
               (-> this root)
               (collide-action no-standon)
               (collide-action)
               )
              (not (logtest? (-> this root penetrated-by)
                             (-> (the-as collide-shape (-> (the-as process-drawable s3-0) root)) penetrate-using)
                             )
                   )
              )
         (if (send-shoves (-> this root) arg0 (the-as touching-shapes-entry s4-0) 0.7 6144.0 16384.0)
             (send-event this 'bouncing-off arg0)
             )
         )
        )
      )
    )
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod send-attack-on-jump-or-knocked ((this enemy) (arg0 process) (arg1 event-message-block))
  (let ((s4-0 (-> arg1 param 0)))
    (when s4-0
      (when (or (and (and (-> this next-state) (= (-> this next-state name) 'knocked))
                     (logtest? (process-mask crate) (-> arg0 mask))
                     )
                (and (and (-> this next-state) (= (-> this next-state name) 'jump))
                     (logtest? (process-mask target sidekick crate bot) (-> arg0 mask))
                     )
                )
        (when ((method-of-type touching-shapes-entry prims-touching-action?)
               (the-as touching-shapes-entry s4-0)
               (-> this root)
               (collide-action solid semi-solid deadly)
               (collide-action)
               )
          (let ((a3-2 (if ((method-of-type touching-shapes-entry prims-touching-action?)
                           (the-as touching-shapes-entry s4-0)
                           (-> this root)
                           (collide-action persistent-attack)
                           (collide-action)
                           )
                          (-> this persistent-attack-id)
                          (-> this attack-id)
                          )
                      )
                )
            (send-attack this arg0 (the-as touching-shapes-entry s4-0) a3-2)
            )
          )
        )
      )
    )
  )

(defbehavior enemy-event-handler enemy ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (event-handler self arg0 arg1 arg2 arg3)
  )

(defbehavior enemy-simple-post enemy ()
  (enemy-common-post self)
  (update-transforms (-> self root))
  0
  (none)
  )

(defbehavior enemy-falling-post enemy ()
  (let ((gp-0 (-> self root)))
    (cond
      ((focus-test? self under-water)
       (accelerate-fall! self (-> gp-0 transv))
       )
      (else
        (let ((a1-1 (new-stack-vector0)))
          (vector-v++! (-> gp-0 transv) (compute-acc-due-to-gravity gp-0 a1-1 (-> self enemy-info slip-factor)))
          )
        )
      )
    (let ((a2-1 (new 'stack-no-clear 'collide-query)))
      (set! (-> a2-1 collide-with) (-> gp-0 root-prim prim-core collide-with))
      (set! (-> a2-1 ignore-process0) self)
      (set! (-> a2-1 ignore-process1) #f)
      (set! (-> a2-1 ignore-pat) (logior (new 'static 'pat-surface :noendlessfall #x1) (-> gp-0 pat-ignore-mask)))
      (set! (-> a2-1 action-mask) (collide-action solid))
      (fill-cache-integrate-and-collide gp-0 (-> gp-0 transv) a2-1 (meters 0))
      )
    )
  (apply-friction self)
  (enemy-common-post self)
  (none)
  )

(defmethod accelerate-fall! ((this enemy) (arg0 vector))
  (let* ((f2-0 0.8)
         (f0-1 (fmax 0.0 (+ 1.0 (* 60.0 (seconds-per-frame) (+ -1.0 f2-0)))))
         )
    (vector-float*! arg0 arg0 f0-1)
    )
  (set! (-> arg0 y) (+ (-> arg0 y) (* -204800.0 (seconds-per-frame))))
  )

(defbehavior enemy-die-falling-post enemy ()
  (let ((gp-0 (-> self root)))
    (if (focus-test? self under-water)
        (accelerate-fall! self (-> gp-0 transv))
        (vector-v++! (-> gp-0 transv) (compute-acc-due-to-gravity gp-0 (new-stack-vector0) 0.0))
        )
    (let ((s4-1 (new 'stack-no-clear 'collide-query))
          (s5-1 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-1 quad) (-> gp-0 trans quad))
      (vector-v++! s5-1 (-> gp-0 transv))
      (when (find-ground
              gp-0
              s4-1
              (-> self enemy-info recover-gnd-collide-with)
              8192.0
              81920.0
              1024.0
              (the-as process #f)
              )
        (when (>= (-> gp-0 gspot-pos y) (-> s5-1 y))
          (set! (-> s5-1 y) (-> gp-0 gspot-pos y))
          (vector-reset! (-> gp-0 transv))
          )
        )
      (move-to-point! gp-0 s5-1)
      )
    )
  (enemy-common-post self)
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod enemy-method-91 ((this enemy) (arg0 enemy-jump-info))
  #f
  )

(defmethod init-jump-info! ((this enemy) (arg0 enemy-jump-info))
  (set! (-> arg0 flags) (enemy-jump-flags ejf0))
  (set! (-> arg0 anim-speed) (rnd-float-range this 0.9 1.1))
  (set! (-> arg0 hang-time) 0)
  (set! (-> arg0 dest-pos quad) (-> this event-param-point quad))
  (set! (-> arg0 start-pos quad) (-> this root trans quad))
  (let ((s4-0 (new 'stack-no-clear 'collide-query)))
    (if (enemy-above-ground? this s4-0 (-> arg0 dest-pos) (-> this gnd-collide-with) 8192.0 81920.0 1024.0)
        (set! (-> arg0 dest-pos y) (-> s4-0 best-other-tri intersect y))
        )
    )
  (setup-jump! this arg0)
  (none)
  )

(defmethod setup-jump! ((this enemy) (arg0 enemy-jump-info))
  (let* ((f0-0 (vector-vector-xz-distance (-> arg0 start-pos) (-> arg0 dest-pos)))
         (f0-2 (fmax (-> this enemy-info jump-height-min) (* (-> this enemy-info jump-height-factor) f0-0)))
         )
    (setup-from-to-height! (-> arg0 traj) (-> arg0 start-pos) (-> arg0 dest-pos) f0-2 -4.551111)
    )
  (none)
  )

(defmethod on-ground? ((this enemy) (arg0 enemy-jump-info))
  (let ((gp-0 (-> this root)))
    (when (< (-> gp-0 transv y) 0.0)
      (let ((a1-1 (new 'stack-no-clear 'collide-query)))
        (find-ground (-> this root) a1-1 (-> this gnd-collide-with) 8192.0 81920.0 1024.0 (the-as process #f))
        )
      (>= (+ 409.6 (-> gp-0 gspot-pos y)) (-> gp-0 trans y))
      )
    )
  )

(defmethod move-to-gspot! ((this enemy))
  (let* ((v1-0 (-> this root))
         (f0-0 (-> v1-0 gspot-pos y))
         )
    (if (< (-> v1-0 trans y) f0-0)
        (set! (-> v1-0 trans y) f0-0)
        )
    )
  (set! (-> this root transv y) 0.0)
  )

(defmethod enemy-method-101 ((this enemy) (arg0 int) (arg1 enemy-jump-info))
  0
  (none)
  )

(defmethod in-jump-handler ((this enemy) (arg0 int) (arg1 enemy-jump-info))
  (case arg0
    ((2 3)
     (let ((f30-0 (the float (-> arg1 hang-time))))
       (let ((a1-3 (compute-trans-at-time (-> arg1 traj) f30-0 (new 'stack-no-clear 'vector))))
         (move-to-point! (-> this root) a1-3)
         )
       (let ((s5-1 (-> this root transv)))
         (compute-transv-at-time (-> arg1 traj) f30-0 s5-1)
         (vector-float*! s5-1 s5-1 300.0)
         )
       )
     )
    )
  0
  (none)
  )

(defmethod jump-wind-up-anim ((this enemy) (arg0 enemy-jump-info))
  (let ((a0-1 (-> this skel root-channel 0)))
    (set! (-> a0-1 param 0) 1.0)
    (joint-control-channel-group! a0-1 (the-as art-joint-anim #f) num-func-loop!)
    )
  (ja-channel-push! 1 (seconds 0.1))
  (let ((a1-3 (-> this draw art-group data (-> this enemy-info jump-wind-up-anim)))
        (a0-5 (-> this skel root-channel 0))
        )
    (set! (-> a0-5 frame-group) (the-as art-joint-anim a1-3))
    (set! (-> a0-5 param 0) (the float (+ (-> (the-as art-joint-anim a1-3) frames num-frames) -1)))
    (set! (-> a0-5 param 1) (-> arg0 anim-speed))
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group! a0-5 (the-as art-joint-anim a1-3) num-func-seek!)
    )
  #t
  )

(defmethod jump-in-air-anim ((this enemy) (arg0 enemy-jump-info))
  (let ((s5-0 (-> this draw art-group data (-> this enemy-info jump-in-air-anim))))
    (let ((v1-6 (if (> (-> this skel active-channels) 0)
                    (-> this skel root-channel 0 frame-group)
                    )
                )
          )
      (cond
        ((and v1-6 (= v1-6 (-> this draw art-group data (-> this enemy-info jump-wind-up-anim))))
         (ja-channel-push! 1 0)
         )
        (else
          (let ((a0-10 (-> this skel root-channel 0)))
            (set! (-> a0-10 param 0) 1.0)
            (joint-control-channel-group! a0-10 (the-as art-joint-anim #f) num-func-loop!)
            )
          (ja-channel-push! 1 (seconds 0.1))
          )
        )
      )
    (let ((a0-12 (-> this skel root-channel 0)))
      (set! (-> a0-12 frame-group) (the-as art-joint-anim s5-0))
      (set! (-> a0-12 param 0) (the float (+ (-> (the-as art-joint-anim s5-0) frames num-frames) -1)))
      (set! (-> a0-12 param 1) (-> arg0 anim-speed))
      (set! (-> a0-12 frame-num) 0.0)
      (joint-control-channel-group! a0-12 (the-as art-joint-anim s5-0) num-func-seek!)
      )
    )
  #t
  )

(defmethod jump-land-anim ((this enemy) (arg0 enemy-jump-info))
  (let ((a0-1 (-> this skel root-channel 0)))
    (set! (-> a0-1 param 0) 1.0)
    (joint-control-channel-group! a0-1 (the-as art-joint-anim #f) num-func-loop!)
    )
  (ja-channel-push! 1 (seconds 0.075))
  (let ((a1-3 (-> this draw art-group data (-> this enemy-info jump-land-anim)))
        (a0-5 (-> this skel root-channel 0))
        )
    (set! (-> a0-5 frame-group) (the-as art-joint-anim a1-3))
    (set! (-> a0-5 param 0) (the float (+ (-> (the-as art-joint-anim a1-3) frames num-frames) -1)))
    (set! (-> a0-5 param 1) (-> arg0 anim-speed))
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group! a0-5 (the-as art-joint-anim a1-3) num-func-seek!)
    )
  #t
  )

(defmethod jump-anim-handler ((this enemy) (arg0 int) (arg1 enemy-jump-info))
  (local-vars (s5-0 symbol))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (not (jump-wind-up-anim this arg1))
       )
      ((= v1-0 1)
       (set! s5-0 (ja-done? 0))
       (let ((a0-4 (-> this skel root-channel 0)))
         (set! (-> a0-4 param 0) (the float (+ (-> a0-4 frame-group frames num-frames) -1)))
         (set! (-> a0-4 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      ((= v1-0 2)
       (jump-in-air-anim this arg1)
       #f
       )
      ((= v1-0 3)
       (set! s5-0 (ja-done? 0))
       (let ((a0-9 (-> this skel root-channel 0)))
         (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group frames num-frames) -1)))
         (set! (-> a0-9 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      ((= v1-0 4)
       (not (jump-land-anim this arg1))
       )
      ((= v1-0 5)
       (set! s5-0 (ja-done? 0))
       (let ((a0-14 (-> this skel root-channel 0)))
         (set! (-> a0-14 param 0) (the float (+ (-> a0-14 frame-group frames num-frames) -1)))
         (set! (-> a0-14 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-14 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      (else
        #t
        )
      )
    )
  )

(defmethod enemy-method-109 ((this enemy))
  #f
  )

(defmethod enemy-method-50 ((this enemy) (arg0 int))
  0
  (none)
  )

(if #t
    (set! *shockwave-knock-scalar* (new 'static 'curve2d-fast
                                     :xs (new 'static 'vector :y -0.3 :z -1.0 :w -2.0)
                                     :ys (new 'static 'vector :x 0.5 :y 1.0 :z 1.5 :w 2.5)
                                     :one-over-x-deltas (new 'static 'vector :x 1.6666666 :y 0.71428573 :z 1.0 :w 1.0)
                                     )
          )
    )

(defmethod knocked-handler ((this enemy) (arg0 vector))
  (local-vars (v0-22 number))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf29 :class vf)
         )
    (init-vf0-vector)
    (get-knockback-dir! this arg0)
    (let ((s5-0 (-> this enemy-info)))
      (case (-> this incoming knocked-type)
        (((knocked-type explode-or-darkjak))
         (let ((f30-0 (rnd-float-range this 0.0 1.0)))
           (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-hard-vxz-lo) (-> s5-0 knocked-hard-vxz-hi) f30-0))
           (set! (-> arg0 y) (lerp (-> s5-0 knocked-hard-vy-lo) (-> s5-0 knocked-hard-vy-hi) f30-0))
           )
         )
        (((knocked-type mech-punch))
         (let ((f30-1 (rnd-float-range this 0.0 1.0)))
           (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-medium-vxz-lo) (-> s5-0 knocked-medium-vxz-hi) f30-1))
           (set! (-> arg0 y) (lerp (-> s5-0 knocked-medium-vy-lo) (-> s5-0 knocked-medium-vy-hi) f30-1))
           )
         )
        (((knocked-type dark-shot))
         (let ((f30-2 (rnd-float-range this 0.0 1.0)))
           (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-huge-vxz-lo) (-> s5-0 knocked-huge-vxz-hi) f30-2))
           (set! (-> arg0 y) (lerp (-> s5-0 knocked-huge-vy-lo) (-> s5-0 knocked-huge-vy-hi) f30-2))
           )
         )
        (((knocked-type yellow-shot))
         (vector-rotate90-around-y! arg0 arg0)
         (let ((v1-9 (new 'stack-no-clear 'vector)))
           (vector-! v1-9 (-> this incoming attacker-pos) (-> this root trans))
           (set! (-> v1-9 y) 0.0)
           (if (< 0.0 (vector-dot v1-9 arg0))
               (vector-negate! arg0 arg0)
               )
           )
         (let ((f30-3 (rnd-float-range this 0.0 1.0)))
           (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-yellow-vxz-lo) (-> s5-0 knocked-yellow-vxz-hi) f30-3))
           (set! (-> arg0 y) (lerp (-> s5-0 knocked-yellow-vy-lo) (-> s5-0 knocked-yellow-vy-hi) f30-3))
           )
         )
        (((knocked-type red-shot))
         (let ((f30-4 0.0))
           (cond
             ((logtest? (penetrate jak-red-shockwave) (-> this incoming penetrate-using))
              (format 0 "Intensity ~f (handle ~d)~%" f30-4 (process->handle this))
              )
             (else
               (let* ((f1-2 (vector-vector-xz-distance-squared (target-pos 0) (-> this root trans)))
                      (f0-26 1.0)
                      (f2-0 61440.0)
                      (f1-3 (fmin f1-2 (* f2-0 f2-0)))
                      (f2-3 61440.0)
                      )
                 (set! f30-4 (* (- f0-26 (/ f1-3 (* f2-3 f2-3))) (rnd-float-range this 0.8 1.0)))
                 )
               )
             )
           (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-red-vxz-lo) (-> s5-0 knocked-red-vxz-hi) f30-4))
           (set! (-> arg0 y) (lerp (-> s5-0 knocked-red-vy-lo) (-> s5-0 knocked-red-vy-hi) f30-4))
           )
         (when (logtest? (penetrate jak-red-shockwave) (-> this incoming penetrate-using))
           (let ((a0-31 *shockwave-knock-scalar*)
                 (f0-34 (-> this incoming intensity))
                 (a1-23 (new 'stack-no-clear 'vector))
                 (v1-33 (new 'stack-no-clear 'vector))
                 )
             (let ((a2-18 f0-34))
               (.mov vf27 a2-18)
               )
             (.lvf vf24 (&-> a0-31 xs quad))
             (.lvf vf25 (&-> a0-31 ys quad))
             (.lvf vf26 (&-> a0-31 one-over-x-deltas quad))
             (.min.w.vf vf27 vf27 vf0)
             (.max.x.vf vf27 vf27 vf0)
             (.add.x.vf vf28 vf24 vf27)
             (.mul.w.vf acc vf25 vf0)
             (.add.mul.vf vf29 vf28 vf26 acc)
             (.svf (&-> a1-23 quad) vf28)
             (.svf (&-> v1-33 quad) vf29)
             (let ((a0-32 (-> a1-23 z))
                   (a1-24 (-> a1-23 y))
                   )
               (b! (>= (the-as int a0-32) 0) cfg-23 :delay (set! v0-22 (-> v1-33 z)))
               (b! (>= (the-as int a1-24) 0) cfg-23 :delay (set! v0-22 (-> v1-33 y)))
               )
             (set! v0-22 (-> v1-33 x))
             )
           (label cfg-23)
           (let ((f0-35 (the-as float v0-22)))
             (vector-float*! arg0 arg0 f0-35)
             )
           )
         )
        (((knocked-type blue-shot))
         (let* ((f1-5 (vector-vector-xz-distance-squared (target-pos 0) (-> this root trans)))
                (f0-36 1.0)
                (f2-6 122880.0)
                (f1-6 (fmin f1-5 (* f2-6 f2-6)))
                (f2-9 122880.0)
                (f30-7 (* (- f0-36 (/ f1-6 (* f2-9 f2-9))) (rnd-float-range this 0.8 1.0)))
                )
           (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-blue-vxz-lo) (-> s5-0 knocked-blue-vxz-hi) f30-7))
           (cond
             ((or (>= (the-as uint 4) (-> this incoming blue-juggle-count)) (handle->process (-> this ragdoll-proc)))
              (set! (-> arg0 y) (lerp (-> s5-0 knocked-blue-vy-lo) (-> s5-0 knocked-blue-vy-hi) f30-7))
              )
             (else
               (if (zero? (rnd-int this 3))
                   (set! (-> arg0 y) 40960.0)
                   )
               )
             )
           )
         )
        (((knocked-type vehicle))
         (let ((v0-4 (the-as object arg0)))
           (set! (-> (the-as vector v0-4) quad) (-> this incoming attack-direction quad))
           v0-4
           )
         )
        (else
          (let ((f30-8 (rnd-float-range this 0.0 1.0)))
            (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-soft-vxz-lo) (-> s5-0 knocked-soft-vxz-hi) f30-8))
            (set! (-> arg0 y) (lerp (-> s5-0 knocked-soft-vy-lo) (-> s5-0 knocked-soft-vy-hi) f30-8))
            )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch float vs degrees.
(defmethod get-knockback-angle ((this enemy))
  (let ((f30-0 (quaternion-y-angle (-> this root quat))))
    (case (-> this incoming knocked-type)
      (((knocked-type yellow-shot) (knocked-type blue-shot))
       (let ((a0-5 (handle->process (-> this focus handle))))
         (when a0-5
           (let ((v1-9 (get-trans (the-as process-focusable a0-5) 0)))
             (set! f30-0 (atan (- (-> v1-9 x) (-> this root trans x)) (- (-> v1-9 z) (-> this root trans z))))
             )
           )
         )
       )
      (else
        (let* ((v1-13 (-> this root transv))
               (f28-0 (atan (-> v1-13 x) (-> v1-13 z)))
               (f1-2 (deg- f30-0 f28-0))
               (f2-0 (fabs f1-2))
               (f0-6 (-> this enemy-info knocked-seek-ry-clamp))
               )
          (when (and (< f0-6 f2-0) (< f2-0 (- 32768.0 f0-6)))
            (set! f30-0 (+ (cond
                             ((< f2-0 16384.0)
                              (if (>= f1-2 0.0)
                                  f0-6
                                  (- f0-6)
                                  )
                              )
                             ((>= f1-2 0.0)
                              (- 32768.0 f0-6)
                              )
                             (else
                               (+ -32768.0 f0-6)
                               )
                             )
                           f28-0
                           )
                  )
            (if (< f30-0 0.0)
                (set! f30-0 (+ 65536.0 f30-0))
                )
            )
          )
        )
      )
    (the-as degrees f30-0)
    )
  )

(defmethod knocked-anim ((this enemy) (arg0 enemy-knocked-info))
  (ja-channel-push! 1 0)
  (let ((a1-2 (-> this draw art-group data (-> this enemy-info knocked-anim)))
        (a0-4 (-> this skel root-channel 0))
        )
    (set! (-> a0-4 frame-group) (the-as art-joint-anim a1-2))
    (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim a1-2) frames num-frames) -1)))
    (set! (-> a0-4 param 1) (-> arg0 anim-speed))
    (set! (-> a0-4 frame-num) 0.0)
    (joint-control-channel-group! a0-4 (the-as art-joint-anim a1-2) num-func-seek!)
    )
  #t
  )

(defmethod knocked-land-anim ((this enemy) (arg0 enemy-knocked-info))
  (let ((v1-4 (-> this draw art-group data (-> this enemy-info knocked-land-anim)))
        (a0-3 (-> this skel root-channel 0))
        )
    (set! (-> a0-3 frame-group) (the-as art-joint-anim v1-4))
    (set! (-> a0-3 param 0) (the float (+ (-> (the-as art-joint-anim v1-4) frames num-frames) -1)))
    (set! (-> a0-3 param 1) (-> arg0 anim-speed))
    (set! (-> a0-3 frame-num) 0.0)
    (joint-control-channel-group! a0-3 (the-as art-joint-anim v1-4) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-88 ((this enemy) (arg0 enemy-knocked-info))
  (let ((gp-0 (-> this root)))
    (or (>= (-> arg0 on-surface-count) 3)
        (and (logtest? (-> gp-0 status) (collide-status on-ground)) (>= 16384.0 (-> gp-0 transv y)))
        (and (>= (-> arg0 move-count) 3)
             (let ((f0-1 40.96))
               (>= (* f0-1 f0-1) (vector-vector-distance-squared (-> gp-0 trans-old) (-> gp-0 trans-old-old)))
               )
             (let ((f0-4 40.96))
               (>= (* f0-4 f0-4) (vector-vector-distance-squared (-> gp-0 trans-old-old) (-> gp-0 trans-old-old-old)))
               )
             )
        )
    )
  )

(defmethod within-gspot-range? ((this enemy))
  (let ((gp-0 (-> this root))
        (a1-0 (new 'stack-no-clear 'collide-query))
        )
    (if (or (< 0.0 (-> this root transv y)) (begin
                                              (find-ground
                                                gp-0
                                                a1-0
                                                (-> this enemy-info recover-gnd-collide-with)
                                                8192.0
                                                81920.0
                                                1024.0
                                                (the-as process #f)
                                                )
                                              (let ((f0-2 (- (-> gp-0 trans y) (-> gp-0 gspot-pos y))))
                                                (and (>= f0-2 -1228.8) (>= 6144.0 f0-2))
                                                )
                                              )
            )
        #f
        #t
        )
    )
  )

(defmethod enemy-method-90 ((this enemy) (arg0 ragdoll-proc))
  (let* ((s4-0 (-> arg0 ragdoll))
         (s2-0 (-> s4-0 ragdoll-joints))
         (s1-0
           (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) (-> s4-0 orient-tform) (-> s4-0 orient-tform w))
           )
         (s3-0 (new 'stack-no-clear 'matrix))
         (s5-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> this root quat)))
         )
    (quaternion-normalize! (quaternion*! s1-0 (the-as quaternion (-> s2-0 0)) s1-0))
    (quaternion->matrix s3-0 s1-0)
    (if (logtest? (-> s4-0 ragdoll-flags) (ragdoll-flag mirror))
        (matrix*! s3-0 s3-0 (-> s4-0 mirror))
        )
    (vector-flatten! (-> s5-0 fvec) (-> s3-0 uvec) (-> s5-0 uvec))
    (vector-normalize! (-> s5-0 fvec) 1.0)
    (vector-cross! (-> s5-0 rvec) (-> s5-0 uvec) (-> s5-0 fvec))
    (matrix->quaternion (-> this root quat) s5-0)
    )
  0
  (none)
  )

(defmethod knocked-anim-handler ((this enemy) (arg0 int) (arg1 enemy-knocked-info))
  (local-vars (s5-0 symbol))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (knocked-anim this arg1)
       (set! s5-0 #f)
       )
      ((= v1-0 1)
       (set! s5-0 (ja-done? 0))
       (let ((a0-4 (-> this skel root-channel 0)))
         (set! (-> a0-4 param 0) (the float (+ (-> a0-4 frame-group frames num-frames) -1)))
         (set! (-> a0-4 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-seek!)
         )
       )
      ((= v1-0 2)
       (freeze-hit-end)
       (set! s5-0 (not (knocked-land-anim this arg1)))
       (set! (-> this incoming blue-juggle-count) (the-as uint 0))
       )
      ((= v1-0 3)
       (set! s5-0 (ja-done? 0))
       (let ((a0-9 (-> this skel root-channel 0)))
         (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group frames num-frames) -1)))
         (set! (-> a0-9 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
         )
       )
      ((= v1-0 4)
       (vector-reset! (-> this root transv))
       (set! s5-0 #t)
       )
      (else
        (set! s5-0 #t)
        )
      )
    )
  s5-0
  )

(defbehavior ja-group-index? enemy ((arg0 int))
  (ja-group? (-> self draw art-group data arg0))
  )

(defmethod enemy-method-123 ((this enemy))
  #t
  )

(defmethod ragdoll-spawn! ((this enemy) (arg0 symbol) (arg1 symbol))
  (local-vars (s2-0 process))
  (with-pp
    (when (and (enemy-method-123 this) (-> this enemy-info ragdoll-info))
      (let ((s3-0 (handle->process (-> this ragdoll-proc))))
        (cond
          (s3-0
            (set! s2-0 s3-0)
            )
          (else
            (set! (-> this ragdoll-proc)
                  (ppointer->handle
                    (process-spawn
                      ragdoll-proc
                      (-> this enemy-info ragdoll-info)
                      :name "ragdoll-proc"
                      :to this
                      :stack-size #x5000
                      )
                    )
                  )
            (set! s2-0 (handle->process (-> this ragdoll-proc)))
            (when (not s2-0)
              (format 0 "deactivated ~A because a ragdoll allocate failed~%" (-> this name))
              (deactivate this)
              )
            (set! (-> this enemy-flags)
                  (the-as enemy-flag (logior (enemy-flag auto-death-phase-out) (-> this enemy-flags)))
                  )
            )
          )
        (when (and (-> this draw) (-> this draw shadow-ctrl))
          (let ((v1-29 (-> this draw shadow-ctrl)))
            (logior! (-> v1-29 settings flags) (shadow-flags disable-draw))
            )
          0
          )
        (if (-> (the-as ragdoll-proc s2-0) ragdoll)
            (logior! (-> (the-as ragdoll-proc s2-0) ragdoll ragdoll-flags) (ragdoll-flag rf3 rf4))
            )
        (let ((s1-0 (new 'stack-no-clear 'vector)))
          (vector-float*! s1-0 (-> this root transv) (seconds-per-frame))
          (if s3-0
              (ragdoll-proc-method-15 (the-as ragdoll-proc s2-0) arg1 (the-as vector #f) #f)
              (ragdoll-proc-method-15 (the-as ragdoll-proc s2-0) arg1 (the-as vector #f) #t)
              )
          (if arg0
              (ragdoll-method-23
                (-> (the-as ragdoll-proc s2-0) ragdoll)
                (-> this incoming attack-position)
                s1-0
                (-> this enemy-info ragdoll-rotate-velocity-mult)
                #t
                )
              )
          (vector-float*! s1-0 s1-0 (/ 1.0 (-> pp clock time-adjust-ratio)))
          (let ((v0-1 (-> (the-as ragdoll-proc s2-0) ragdoll ragdoll-joints 0 velocity)))
            (set! (-> v0-1 quad) (-> s1-0 quad))
            v0-1
            )
          )
        )
      )
    )
  )

(defmethod deactivate-ragdoll! ((this enemy))
  (when (and (enemy-method-123 this) (-> this enemy-info ragdoll-info))
    (let ((a0-3 (handle->process (-> this ragdoll-proc))))
      (when a0-3
        (when (and (-> this draw) (-> this draw shadow-ctrl))
          (let ((v1-14 (-> this draw shadow-ctrl)))
            (logclear! (-> v1-14 settings flags) (shadow-flags disable-draw))
            )
          0
          )
        (deactivate a0-3)
        )
      )
    )
  0
  (none)
  )

(defmethod ragdoll-settled? ((this enemy))
  (let ((s5-0 (handle->process (-> this ragdoll-proc))))
    (or (not s5-0)
        (or (ragdoll-proc-method-19 (the-as ragdoll-proc s5-0))
            (and (time-elapsed? (-> this state-time) (seconds 0.1))
                 (let ((f0-1 (if (= (-> this hit-points) 0.0)
                                 4096.0
                                 49152.0
                                 )
                             )
                       (f1-2 (if (= (-> this hit-points) 0.0)
                                 364.0889
                                 16384.0
                                 )
                             )
                       )
                   (and (and (< (vector-length (-> (the-as ragdoll-proc s5-0) ragdoll ragdoll-joints 0 velocity))
                                (* f0-1 (seconds-per-frame))
                                )
                             (< (cos (* f1-2 (seconds-per-frame))) (-> (the-as ragdoll-proc s5-0) ragdoll rotate-vel w))
                             )
                        (and (not (enemy-method-109 this)) (not (within-gspot-range? this)))
                        )
                   )
                 )
            )
        )
    )
  )

(defmethod disable-ragdoll ((this enemy))
  (let ((s5-0 (handle->process (-> this ragdoll-proc))))
    (when s5-0
      (disable-for-duration (the-as ragdoll-proc s5-0) (-> this enemy-info ragdoll-blend-out-time))
      (logclear! (-> (the-as ragdoll-proc s5-0) ragdoll ragdoll-flags) (ragdoll-flag rf9))
      (enemy-method-90 this (the-as ragdoll-proc s5-0))
      )
    )
  0
  (none)
  )

(defmethod should-move-to-ground? ((this enemy))
  (-> this enemy-info move-to-ground)
  )
