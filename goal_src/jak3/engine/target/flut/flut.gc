;;-*-Lisp-*-
(in-package goal)

;; name: flut.gc
;; name in dgo: flut
;; dgos: WWD, DESLIZ, VOCA

;; DECOMP BEGINS

(define *flut-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #xa))
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 81920.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -2867.2)
                                           )
                               )
  )

(define *flut-color-table* (the-as (array rgbaf) (new 'static 'boxed-array :type vector
                                                   (new 'static 'vector :x 1.0 :y 1.0 :z 0.8 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 1.0 :z 0.7 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 1.0 :z 0.6 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 1.0 :z 0.5 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 1.0 :z 0.4 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 0.9 :z 0.5 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 0.8 :z 0.6 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 0.8 :z 0.5 :w 1.0)
                                                   (new 'static 'vector :x 1.0 :y 0.8 :z 0.4 :w 1.0)
                                                   (new 'static 'vector :x 0.9 :y 0.9 :z 1.0 :w 1.0)
                                                   (new 'static 'vector :x 0.8 :y 0.9 :z 1.0 :w 1.0)
                                                   (new 'static 'vector :x 0.8 :y 1.0 :z 1.0 :w 1.0)
                                                   (new 'static 'vector :x 0.8 :y 1.0 :z 0.8 :w 1.0)
                                                   )
                                                 )
        )

(defmethod spawn-part-and-sound! ((this flut))
  (if (nonzero? (-> this part))
      (spawn (-> this part) (-> this root trans))
      )
  (if (nonzero? (-> this sound))
      (update! (-> this sound))
      )
  0
  (none)
  )

(defmethod deactivate ((this flut))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (when (-> this count-lock)
    (set! (-> this count-lock) #f)
    (+! (-> *game-info* flut-count) -1)
    )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defbehavior flut-color-from-index flut ((arg0 int))
  (set! (-> self draw color-mult quad) (-> *flut-color-table* (mod arg0 (-> *flut-color-table* length)) quad))
  0
  (none)
  )

(defun flut-random-color-index ()
  (rand-vu-int-range 0 (-> *flut-color-table* length))
  )

(defmethod flut-method-33 ((this flut))
  (let ((gp-0 (the-as (array collide-shape) (new 'stack 'boxed-array collide-shape 32))))
    (let ((a1-2 (sphere<-vector+r! (new 'stack-no-clear 'sphere) (-> this root trans) 16384.0)))
      (+! (-> a1-2 y) 12288.0)
      (set! (-> gp-0 length) (fill-actor-list-for-box *actor-hash* a1-2 (-> gp-0 data) (-> gp-0 allocated-length)))
      )
    (let* ((s5-1 (-> gp-0 length))
           (s4-0 0)
           (v1-7 (-> gp-0 s4-0))
           )
      (while (< s4-0 s5-1)
        (if (type? (-> v1-7 process) flut)
            (return #f)
            )
        (+! s4-0 1)
        (set! v1-7 (-> gp-0 s4-0))
        )
      )
    )
  #t
  )

(defstate wait-for-start (flut)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (send-event proc 'target-flut-get-off 90)
       (send-event proc 'shove #f (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                                      (damage 2.0)
                                                                                      (vehicle-damage-factor 1.0)
                                                                                      (vehicle-impulse-factor 1.0)
                                                                                      (shove-back (meters 3))
                                                                                      (shove-up (meters 1))
                                                                                      )
                                                      )
                   )
       #f
       )
      (('attack)
       (cond
         ((and (-> self next-state) (= (-> self next-state name) 'wait-for-start))
          #f
          )
         ((= (-> self mode) 'normal)
          (send-event proc 'shove #f (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                                         (damage 2.0)
                                                                                         (vehicle-damage-factor 1.0)
                                                                                         (vehicle-impulse-factor 1.0)
                                                                                         (shove-back (meters 3))
                                                                                         (shove-up (meters 1))
                                                                                         )
                                                         )
                      )
          (go-virtual die)
          )
         (else
           (send-event proc 'target-flut-get-off 90)
           (send-event proc 'shove #f (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                                          (damage 2.0)
                                                                                          (vehicle-damage-factor 1.0)
                                                                                          (vehicle-impulse-factor 1.0)
                                                                                          (shove-back (meters 3))
                                                                                          (shove-up (meters 1))
                                                                                          )
                                                          )
                       )
           )
         )
       )
      (('touch)
       (send-event proc 'target-flut-get-off 90)
       (send-shoves (-> self root) proc (the-as touching-shapes-entry (-> block param 0)) 0.7 6144.0 16384.0)
       #f
       )
      (('trans)
       (vector+! (the-as vector (-> block param 0)) (-> self root trans) (-> self extra-trans))
       )
      (('shadow)
       (cond
         ((-> block param 0)
          (let ((v0-2 (the-as object (-> self shadow-backup))))
            (set! (-> self draw shadow) (the-as shadow-geo v0-2))
            v0-2
            )
          )
         (else
           (set! (-> self draw shadow) #f)
           #f
           )
         )
       )
      )
    )
  :exit (behavior ()
    (set! (-> self root root-prim prim-core action) (collide-action))
    (set! (-> self root penetrated-by) (the-as penetrate -1))
    (set-vector! (-> self root root-prim local-sphere) 0.0 5734.4 0.0 7372.8)
    )
  :code (behavior ()
    (ja-channel-set! 0)
    (while (or (>= (-> *game-info* flut-count) 10)
               (and (sphere-in-view-frustum? (sphere<-vector+r! (new 'stack 'sphere) (-> self root trans) 8192.0))
                    (and (< (vector-vector-distance (-> self root trans) (camera-pos)) 409600.0)
                         *target*
                         (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                         )
                    )
               (not (flut-method-33 self))
               )
      (suspend)
      )
    (go-virtual idle)
    )
  )

(defstate idle (flut)
  :virtual #t
  :event (-> (method-of-type flut wait-for-start) event)
  :enter (behavior ()
    (set! (-> self nav-sphere-handle) (the-as handle #f))
    (let ((s5-0 (find-nearest-nav-mesh (-> self root trans) 8192.0)))
      (when s5-0
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector-z-quaternion! gp-0 (-> self root quat))
          (vector-normalize! gp-0 5120.0)
          (vector+! gp-0 gp-0 (-> self root trans))
          (set! (-> self nav-sphere-handle)
                (ppointer->handle
                  (process-spawn simple-nav-sphere #x46266666 gp-0 s5-0 -1 :name "simple-nav-sphere" :to self)
                  )
                )
          )
        )
      )
    )
  :exit (behavior ()
    (send-event (handle->process (-> self nav-sphere-handle)) 'die-fast)
    ((-> (method-of-type flut wait-for-start) exit))
    )
  :code (behavior ()
    (when (not (-> self count-lock))
      (set! (-> self count-lock) #t)
      (+! (-> *game-info* flut-count) 1)
      )
    (if (not (-> self minimap))
        (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 11) (the-as int #f) (the-as vector #t) 0))
        )
    (change-parent self *entity-pool*)
    (ja-channel-set! 1)
    (ja :group! (-> self draw art-group data 3))
    (set! (-> self root root-prim prim-core action) (collide-action solid can-ride no-standon))
    (set! (-> self root penetrated-by) (penetrate))
    0.0
    (let ((f30-0 20480.0))
      (until #f
        (when (and (logtest? (-> self draw status) (draw-control-status on-screen))
                   (time-elapsed? (-> self probe-time) (seconds 1))
                   )
          (move-to-ground
            (-> self root)
            8192.0
            40960.0
            #t
            (collide-spec backgnd obstacle hit-by-player-list hit-by-others-list pusher)
            )
          (set-time! (-> self probe-time))
          )
        (when (and (and *target* (and (>= f30-0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                                      (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                      )
                        )
                   (not (focus-test? *target* grabbed in-head pole flut light board dark))
                   (can-display-query? self "flut" -99.0)
                   (-> *setting-control* user-current pilot)
                   (-> *target* current-level)
                   )
          (let ((gp-0
                  (new 'stack 'font-context *font-default-matrix* 32 320 0.0 (font-color default) (font-flags shadow kerning))
                  )
                )
            (let ((v1-43 gp-0))
              (set! (-> v1-43 width) (the float 340))
              )
            (let ((v1-44 gp-0))
              (set! (-> v1-44 height) (the float 80))
              )
            (let ((v1-45 gp-0)
                  (a0-21 (-> *setting-control* user-default language))
                  )
              (set! (-> v1-45 scale) (if (or (= a0-21 (language-enum korean)) (= a0-21 (language-enum russian)))
                                         0.9
                                         0.7
                                         )
                    )
              )
            (set! (-> gp-0 flags) (font-flags shadow kerning large))
            (print-game-text
              (lookup-text! *common-text* (text-id text-0083) #f)
              gp-0
              #f
              44
              (bucket-id hud-draw-hud-alpha)
              )
            )
          (if (and (cpad-pressed? 0 triangle)
                   (send-event *target* 'change-mode 'flut self (-> self mode) (-> self color-index))
                   )
              (go-virtual pickup (method-of-object self wait-for-return))
              )
          )
        (if *target*
            (look-at!
              (-> *target* neck)
              (vector+!
                (new 'stack-no-clear 'vector)
                (the-as vector (-> self root root-prim prim-core))
                (new 'static 'vector :y 2048.0 :w 1.0)
                )
              'nothing-special
              self
              )
            )
        (spawn-part-and-sound! self)
        (suspend)
        (ja :num! (loop!))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate pickup (flut)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('draw)
       (ja-channel-set! 1)
       (ja :group! (-> self draw art-group data 3))
       (set! (-> self root root-prim prim-core action) (collide-action solid can-ride no-standon))
       (set! (-> self root penetrated-by) (penetrate))
       (transform-post)
       )
      (('trans)
       (vector+! (the-as vector (-> block param 0)) (-> self root trans) (-> self extra-trans))
       )
      (('touch 'attack 'bonk)
       #f
       )
      (('shadow)
       (cond
         ((-> block param 0)
          (let ((v0-1 (the-as object (-> self shadow-backup))))
            (set! (-> self draw shadow) (the-as shadow-geo v0-1))
            v0-1
            )
          )
         (else
           (set! (-> self draw shadow) #f)
           #f
           )
         )
       )
      )
    )
  :enter (behavior ((arg0 (state flut)))
    (talker-spawn-func (-> *talker-speech* 86) *entity-pool* (target-pos 0) (the-as region #f))
    (let ((t9-2 (-> arg0 enter)))
      (if t9-2
          (t9-2)
          )
      )
    )
  :code (behavior ((arg0 (state flut)))
    (when (-> self count-lock)
      (set! (-> self count-lock) #f)
      (+! (-> *game-info* flut-count) -1)
      )
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (ja-channel-set! 0)
    (ja-post)
    (when (not (and (-> self entity) (= (-> self entity extra process) self)))
      (let ((s5-0 (current-time)))
        (until (time-elapsed? s5-0 (seconds 0.1))
          (spawn-part-and-sound! self)
          (suspend)
          )
        )
      (deactivate self)
      )
    (while (zero? (ja-group-size))
      (if (or (not *target*) (or (< 24576.0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                                 (focus-test? *target* teleporting)
                                 )
              )
          (go arg0)
          )
      (spawn-part-and-sound! self)
      (suspend)
      )
    (while (and *target* (focus-test? *target* flut))
      (spawn-part-and-sound! self)
      (suspend)
      )
    (let ((s5-1 (current-time)))
      (until (time-elapsed? s5-1 (seconds 1))
        (spawn-part-and-sound! self)
        (suspend)
        )
      )
    (go arg0)
    )
  )

(defstate wait-for-return (flut)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trans)
       (vector+! (the-as vector (-> block param 0)) (-> self root trans) (-> self extra-trans))
       )
      (('shadow)
       (cond
         ((-> block param 0)
          (let ((v0-1 (the-as structure (-> self shadow-backup))))
            (set! (-> self draw shadow) (the-as shadow-geo v0-1))
            v0-1
            )
          )
         (else
           (set! (-> self draw shadow) #f)
           (the-as structure #f)
           )
         )
       )
      )
    )
  :code (behavior ()
    (ja-channel-set! 0)
    (ja-post)
    (when (type? (-> self root) collide-shape)
      (let ((v1-2 (-> self root root-prim)))
        (set! (-> v1-2 prim-core collide-as) (collide-spec))
        (set! (-> v1-2 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (sleep-code)
    )
  )

(defstate die (flut)
  :virtual #t
  :enter (-> (method-of-type flut idle) enter)
  :exit (-> (method-of-type flut idle) exit)
  :code (behavior ()
    (change-parent self *entity-pool*)
    (when (-> self count-lock)
      (set! (-> self count-lock) #f)
      (+! (-> *game-info* flut-count) -1)
      )
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (if (-> self skel effect)
        (logior! (-> self skel effect flags) (effect-control-flag ecf1))
        )
    (when (logtest? (-> self flags) (flut-flag ff3))
      (set! (-> self root dynam gravity-max) 40960.0)
      (set! (-> self root dynam gravity-length) 20480.0)
      (vector-float*!
        (-> self root dynam gravity)
        (-> self root dynam gravity-normal)
        (the-as float (-> self root dynam gravity-length))
        )
      )
    (cond
      ((logtest? (-> self flags) (flut-flag ff1))
       (set! (-> self root root-prim prim-core action) (collide-action))
       (set! (-> self root penetrated-by) (the-as penetrate -1))
       )
      (else
        (set-vector! (-> self root root-prim local-sphere) 0.0 1638.4 0.0 1638.4)
        (set! (-> self root root-prim prim-core action) (collide-action solid can-ride no-standon))
        (logior!
          (-> self root root-prim prim-core collide-with)
          (collide-spec backgnd crate obstacle hit-by-others-list pusher)
          )
        (set! (-> self root penetrated-by) (penetrate))
        0
        )
      )
    (ja-channel-set! 1)
    (cond
      ((logtest? (-> self flags) (flut-flag ff3))
       (ja-no-eval :group! (-> self draw art-group data 29)
                   :num! (seek! (ja-aframe 65.0 0))
                   :frame-num (ja-aframe 60.0 0)
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 65.0 0)))
         )
       )
      (else
        (ja-no-eval :group! (-> self draw art-group data 28)
                    :num! (seek! (ja-aframe 38.0 0))
                    :frame-num (ja-aframe 25.0 0)
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! (ja-aframe 38.0 0)))
          )
        )
      )
    (do-effect (-> self skel effect) "death-default" 0.0 -1)
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (while (nonzero? (-> self draw death-timer))
      (suspend)
      )
    (ja-channel-set! 0)
    (ja-post)
    (if (and (-> self entity) (= (-> self entity extra process) self))
        (go-virtual wait-for-start)
        )
    )
  :post (behavior ()
    (vector-v++! (-> self root transv) (compute-acc-due-to-gravity (-> self root) (new-stack-vector0) 0.0))
    (if (< (-> self root dynam gravity-max) (vector-length (-> self root transv)))
        (vector-normalize! (-> self root transv) (-> self root dynam gravity-max))
        )
    (let ((v1-12 (-> self root))
          (a2-1 (new 'stack-no-clear 'collide-query))
          )
      (set! (-> a2-1 collide-with) (collide-spec backgnd crate obstacle pusher))
      (set! (-> a2-1 ignore-process0) self)
      (set! (-> a2-1 ignore-process1) #f)
      (set! (-> a2-1 ignore-pat) (-> v1-12 pat-ignore-mask))
      (set! (-> a2-1 action-mask) (collide-action solid))
      (fill-cache-integrate-and-collide v1-12 (-> v1-12 transv) a2-1 (meters 0))
      )
    (transform-post)
    )
  )

(defbehavior flut-init flut ((arg0 entity-actor) (arg1 transformq) (arg2 handle) (arg3 flut-flag) (arg4 symbol))
  (let ((s1-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s1-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s1-0 reaction) cshape-reaction-default)
    (set! (-> s1-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s1-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle obstacle-for-jak))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid can-ride no-standon))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 5734.4 0.0 7372.8)
      (set! (-> s1-0 total-prims) (the-as uint 1))
      (set! (-> s1-0 root-prim) v1-6)
      )
    (set! (-> s1-0 nav-radius) (* 0.75 (-> s1-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s1-0 root-prim)))
      (set! (-> s1-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s1-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> self root) s1-0)
    )
  (set! (-> self count-lock) #f)
  (set! (-> self rider) arg2)
  (set! (-> self flags) arg3)
  (set! (-> self mode) arg4)
  (set! (-> self minimap) #f)
  (when arg0
    (process-entity-set! self arg0)
    (if (logtest? (-> self entity extra kill-mask) (task-mask ctywide))
        (ctywide-entity-hack)
        )
    (process-drawable-from-entity! self arg0)
    (set-yaw-angle-clear-roll-pitch! (-> self root) (res-lump-float arg0 'rotoffset))
    )
  (when arg1
    (set! (-> self root trans quad) (-> arg1 trans quad))
    (quaternion-copy! (-> self root quat) (-> arg1 quat))
    )
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-flut" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self shadow-backup) (-> self draw shadow))
  (set! (-> self draw shadow-ctrl) *flut-shadow-control*)
  (let ((v1-33 (-> self node-list data)))
    (set! (-> v1-33 0 param0) (the-as (function cspace transformq none) cspace<-transformq+trans!))
    (set! (-> v1-33 0 param1) (the-as basic (-> self root trans)))
    (set! (-> v1-33 0 param2) (the-as basic (-> self extra-trans)))
    )
  (set! (-> self condition) (res-lump-value arg0 'index int :time -1000000000.0))
  (set! (-> self fact)
        (new 'process 'fact-info self (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (if (not (logtest? arg3 (flut-flag ff0)))
      (setup-masks (-> self draw) 0 2)
      )
  (set! (-> self nav-sphere-handle) (the-as handle #f))
  (set! (-> self color-index) (mod (the-as int (sar (the-as int arg3) 32)) (-> *flut-color-table* length)))
  (flut-color-from-index (-> self color-index))
  (when (logtest? (-> self flags) (flut-flag ff1))
    (set! (-> self root root-prim prim-core action) (collide-action))
    (set! (-> self root penetrated-by) (the-as penetrate -1))
    )
  (if (and (-> self entity) (not (logtest? arg3 (flut-flag ff2))))
      (move-to-ground
        (-> self root)
        8192.0
        40960.0
        #t
        (collide-spec backgnd obstacle hit-by-player-list hit-by-others-list pusher)
        )
      )
  (set! (-> self sound)
        (new 'process 'ambient-sound (static-sound-spec "zoom-teleport" :group 0 :fo-max 30) (-> self root trans) 0.0)
        )
  (set! (-> self draw light-index) (the-as uint 30))
  (logior! (-> self mask) (process-mask crate))
  (cond
    ((logtest? arg3 (flut-flag ff2))
     (go-virtual die)
     )
    ((handle->process arg2)
     (go-virtual idle)
     )
    (else
      (go-virtual wait-for-start)
      )
    )
  )

(defmethod init-from-entity! ((this flut) (arg0 entity-actor))
  (flut-init
    arg0
    (the-as transformq #f)
    (the-as handle #f)
    (the-as flut-flag (+ (shl (flut-random-color-index) 32) 1))
    'normal
    )
  )
