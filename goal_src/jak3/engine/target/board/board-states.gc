;;-*-Lisp-*-
(in-package goal)

;; name: board-states.gc
;; name in dgo: board-states
;; dgos: GAME

;; DECOMP BEGINS

(defun vector-vector-angle ((arg0 vector) (arg1 vector))
  (let ((s4-0 (new 'stack-no-clear 'matrix))
        (gp-0 (new 'stack-no-clear 'matrix))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (forward-up-nopitch->inv-matrix gp-0 (new 'static 'vector :z 1.0 :w 1.0) arg1)
    (matrix-transpose! s4-0 gp-0)
    (vector-matrix*! s3-0 arg0 s4-0)
    (vector-y-angle s3-0)
    )
  )

;; WARN: Return type mismatch float vs none.
(defbehavior target-board-anim-trans target ()
  (let ((f26-0
          (deg-
            (quaternion-vector-y-angle (-> self control dir-targ) (-> self control local-normal))
            (quaternion-vector-y-angle (-> self control quat-for-control) (-> self control local-normal))
            )
          )
        (f28-0
          (* (deg-
               (quaternion-vector-y-angle (-> self control quat-for-control) (-> self control local-normal))
               (quaternion-vector-y-angle (-> self control last-quat-for-control) (-> self control local-normal))
               )
             (-> self clock frames-per-second)
             )
          )
        (f30-0 (-> self board turn-anim-targ))
        )
    (let ((f0-1 (lerp-scale 1.0 -1.0 f28-0 -32768.0 32768.0)))
      (if (or (< (fabs f0-1) 0.1) (< (-> self control turn-to-magnitude) 0.3))
          (seek! (-> self board turn-anim-mag) 0.0 (* 8.0 (seconds-per-frame)))
          (seek! (-> self board turn-anim-mag) f0-1 (* 2.0 (seconds-per-frame)))
          )
      )
    (set! (-> self board turn-anim-targ) (+ (lerp-scale
                                              (/ (-> *TARGET_BOARD-bank* turn-frames) 2)
                                              (/ (-> *TARGET_BOARD-bank* turn-frames) -2)
                                              f26-0
                                              -5461.3335
                                              5461.3335
                                              )
                                            (lerp-scale
                                              (* 0.3 (-> *TARGET_BOARD-bank* turn-frames))
                                              (* -0.3 (-> *TARGET_BOARD-bank* turn-frames))
                                              f28-0
                                              -32768.0
                                              32768.0
                                              )
                                            (lerp-scale
                                              (/ (-> *TARGET_BOARD-bank* turn-frames) 5)
                                              (/ (-> *TARGET_BOARD-bank* turn-frames) -5)
                                              (-> self board turn-anim-mag)
                                              1.0
                                              -1.0
                                              )
                                            )
          )
    (when (and (or (< (* f30-0 (-> self board turn-anim-targ)) 0.0) (= f30-0 0.0))
               (and (< (/ (-> *TARGET_BOARD-bank* turn-frames) 5) (fabs (- f30-0 (-> self board turn-anim-targ))))
                    (>= (current-time) (-> self control turn-lockout-end-time))
                    )
               )
      (let ((v1-50 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-50 command) (sound-command set-param))
        (set! (-> v1-50 id) (-> self board turn-sound-id))
        (set! (-> v1-50 params volume) -4)
        (set! (-> v1-50 auto-time) 120)
        (set! (-> v1-50 auto-from) 2)
        (set! (-> v1-50 params mask) (the-as uint 17))
        (-> v1-50 id)
        )
      (set! (-> self board turn-sound-id) (sound-play "board-turn"))
      )
    )
  (set! (-> self board turn-anim-duck-vel) (* 0.98 (-> self board turn-anim-duck-vel)))
  (+! (-> self board turn-anim-duck-vel) (* -8.0 (seconds-per-frame)))
  (when (and (board-on-ground?) (time-elapsed? (-> self board unk-time-frame01) (seconds 0.2)))
    (if (logtest? (-> self control status) (collide-status impact-surface))
        (+! (-> self board turn-anim-duck-vel) (lerp-scale 0.0 15.0 (-> self control normal-impact-vel) 0.0 81920.0))
        )
    (let ((f0-38 (vector-dot (the-as vector (-> self board up-vector)) (-> self board up-vector 1))))
      (if (< f0-38 1.0)
          (+! (-> self board turn-anim-duck-vel) (* (lerp-scale 400.0 0.0 f0-38 0.6 1.0) (seconds-per-frame)))
          )
      )
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-board-spin-check target ()
  (when (and (or (cpad-pressed? (-> self control cpad number) r1)
                 (and (cpad-hold? (-> self control cpad number) r1)
                      (time-elapsed? (-> self board spin-check-time) (seconds 0.3))
                      )
                 )
             (and (not (and (and (-> self next-state)
                                 (let ((v1-24 (-> self next-state name)))
                                   (or (= v1-24 'target-board-trickx) (= v1-24 'target-board-tricky) (= v1-24 'target-board-hold))
                                   )
                                 )
                            (not (time-elapsed? (-> self board spin-start-time) (seconds 0.5)))
                            )
                       )
                  (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
                  (= (-> self ext-anim) (target-anim board))
                  )
             )
    (set-time! (-> self board spin-start-time))
    (set! (-> self board spin-start-dir quad) (-> self node-list data 3 bone transform fvec quad))
    (vector-flatten! (-> self control turn-to-alt-heading) (-> self control c-R-w fvec) *up-vector*)
    (vector-normalize! (-> self control turn-to-alt-heading) 1.0)
    (rot->dir-targ! (-> self control))
    (set! (-> self board rotyv-max) (lerp-scale
                                      218453.33
                                      91022.22
                                      (the float (- (current-time) (-> self control last-time-on-surface)))
                                      0.0
                                      300.0
                                      )
          )
    (set! (-> self board rotyv) 0.0)
    (set! (-> self board roty) 0.0)
    (set! (-> self board roty-cum) 0.0)
    (set! (-> self board unk-deg00) 0.0)
    (set! (-> self board spin-sound-id) (new 'static 'sound-id))
    (set! (-> self control mod-surface) *board-spin-mods*)
    )
  (cond
    ((and (cpad-hold? (-> self control cpad number) r1)
          (or (= (-> self control mod-surface name) 'spin)
              (not (time-elapsed? (-> self board spin-time) (seconds 0.05)))
              )
          (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
          (= (-> self ext-anim) (target-anim board))
          )
     (set! (-> self board turn-anim-tilt?) #f)
     (set! (-> self control mod-surface) *board-spin-mods*)
     (set-time! (-> self board spin-time))
     (let ((gp-0 (new 'stack-no-clear 'vector)))
       (set! (-> gp-0 x) (* -0.0078125 (+ -128.0 (the float (-> self control cpad leftx)))))
       (set! (-> gp-0 y) 0.0)
       (set! (-> gp-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
       (set! (-> gp-0 w) 0.0)
       (let ((f28-0 (analog-input (the int (* 128.0 (-> gp-0 x))) 0.0 64.0 110.0 2184533.2))
             (f30-0 (analog-input (the int (* 128.0 (-> gp-0 z))) 0.0 96.0 110.0 1.0))
             )
         (if (and (zero? (-> self board spin-sound-id)) (< 5461.3335 (fabs (-> self board rotyv))))
             (set! (-> self board spin-sound-id) (sound-play "board-spin-loop"))
             )
         (if (and (< (* 0.9 (fabs (-> self board spin-control))) (fabs f28-0))
                  (>= (* (-> self board spin-control) f28-0) 0.0)
                  )
             (set! (-> self board spin-control) f28-0)
             )
         (if (not (-> self control danger-mode))
             (target-danger-set! 'board-spin #f)
             )
         (+! (-> self board rotyv) (* (-> self board spin-control) (seconds-per-frame)))
         (when (and (< (fabs f28-0) 1092266.6)
                    (< (fabs (-> self board spin-control)) 1092266.6)
                    (< (* 0.9 (fabs (-> self board flip-control))) (fabs f30-0))
                    (>= (* (-> self board flip-control) f30-0) 0.0)
                    (not (board-on-ground?))
                    (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                    (>= (target-height-above-ground) 4096.0)
                    )
           (set! (-> self board flip-control) f30-0)
           (go
             target-board-flip
             (-> *TARGET_BOARD-bank* jump-height-min)
             (-> *TARGET_BOARD-bank* jump-height-max)
             (if (focus-test? self halfpipe)
                 'halfpipe
                 )
             )
           )
         )
       )
     )
    (else
      (set! (-> self control mod-surface) (-> self board mods-backup))
      )
    )
  (set-time! (-> self board spin-check-time))
  (cond
    ((and (or (cpad-pressed? (-> self control cpad number) l1)
              (< (-> self control last-time-on-surface) (-> self board duck-start-time))
              )
          (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
          (= (-> self ext-anim) (target-anim board))
          )
     (set! (-> self board turn-anim-tilt?) #f)
     (set! (-> self control mod-surface) *board-spin-mods*)
     (set-time! (-> self board unk-time000))
     (let ((gp-2 (new 'stack-no-clear 'vector)))
       (set! (-> gp-2 x) (* -0.0078125 (+ -128.0 (the float (-> self control cpad leftx)))))
       (set! (-> gp-2 y) 0.0)
       (set! (-> gp-2 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
       (set! (-> gp-2 w) 0.0)
       (let ((f30-1 (analog-input (the int (* 128.0 (-> gp-2 x))) 0.0 64.0 110.0 1.0))
             (f28-1 (analog-input (the int (* 128.0 (-> gp-2 z))) 0.0 96.0 110.0 1.0))
             )
         (when (and (< (fabs f30-1) 0.5)
                    (< (fabs (-> self board unk-float005)) 0.5)
                    (= (-> self board unk-float006) 0.0)
                    (< (* 0.9 (fabs (-> self board unk-float006))) (fabs f28-1))
                    (>= (* (-> self board unk-float006) f28-1) 0.0)
                    (and (not (board-on-ground?))
                         (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                         (and (>= (target-height-above-ground) 4096.0)
                              (< (seconds 0.165) (target-time-to-ground))
                              (time-elapsed? (-> self board tricky-exit-time) (seconds 0.05))
                              (< (-> self board tricky-exit-time) (-> self board duck-start-time))
                              )
                         )
                    )
           (set! (-> self board unk-float006) f28-1)
           (go
             target-board-tricky
             (-> *TARGET_BOARD-bank* tricky-jump-height-min)
             (-> *TARGET_BOARD-bank* tricky-jump-height-max)
             (if (focus-test? self halfpipe)
                 'halfpipe
                 )
             )
           )
         (when (and (< (fabs f28-1) 0.5)
                    (< (fabs (-> self board unk-float006)) 0.5)
                    (= (-> self board unk-float005) 0.0)
                    (< (* 0.9 (fabs (-> self board unk-float005))) (fabs f30-1))
                    (>= (* (-> self board unk-float005) f30-1) 0.0)
                    (and (not (board-on-ground?))
                         (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                         (and (>= (target-height-above-ground) 4096.0)
                              (< (seconds 0.165) (target-time-to-ground))
                              (time-elapsed? (-> self board tricky-exit-time) (seconds 0.05))
                              )
                         )
                    )
           (set! (-> self board unk-float005) f30-1)
           (go
             target-board-trickx
             (-> *TARGET_BOARD-bank* trickx-jump-height-min)
             (-> *TARGET_BOARD-bank* trickx-jump-height-max)
             (if (focus-test? self halfpipe)
                 'halfpipe
                 )
             )
           )
         )
       )
     )
    ((and (or (cpad-pressed? (-> self control cpad number) l2)
              (< (-> self control last-time-on-surface) (-> self board l2-start-time))
              )
          (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
          (= (-> self ext-anim) (target-anim board))
          )
     (set! (-> self board turn-anim-tilt?) #f)
     (set! (-> self control mod-surface) *board-spin-mods*)
     (set-time! (-> self board unk-time001))
     (let ((gp-5 (new 'stack-no-clear 'vector)))
       (set! (-> gp-5 x) (* -0.0078125 (+ -128.0 (the float (-> self control cpad leftx)))))
       (set! (-> gp-5 y) 0.0)
       (set! (-> gp-5 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
       (set! (-> gp-5 w) 0.0)
       (let ((f30-2 (analog-input (the int (* 128.0 (-> gp-5 x))) 0.0 64.0 110.0 1.0))
             (f28-2 (analog-input (the int (* 128.0 (-> gp-5 z))) 0.0 96.0 110.0 1.0))
             )
         (when (and (< (fabs f30-2) 0.5)
                    (< (fabs (-> self board unk-float005)) 0.5)
                    (= (-> self board unk-float006) 0.0)
                    (< (* 0.9 (fabs (-> self board unk-float006))) (fabs f28-2))
                    (>= (* (-> self board unk-float006) f28-2) 0.0)
                    (and (not (board-on-ground?))
                         (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                         (and (>= (target-height-above-ground) 4096.0)
                              (< (seconds 0.165) (target-time-to-ground))
                              (time-elapsed? (-> self board hold-exit-time) (seconds 0.05))
                              (< (-> self board hold-exit-time) (-> self board l2-start-time))
                              )
                         )
                    )
           (set! (-> self board unk-float006) f28-2)
           (go
             target-board-hold
             (-> *TARGET_BOARD-bank* trickz-jump-height-min)
             (-> *TARGET_BOARD-bank* trickz-jump-height-max)
             (if (focus-test? self halfpipe)
                 'halfpipe
                 )
             )
           )
         (when (and (< (fabs f28-2) 0.5)
                    (< (fabs (-> self board unk-float006)) 0.5)
                    (= (-> self board unk-float005) 0.0)
                    (< (* 0.9 (fabs (-> self board unk-float005))) (fabs f30-2))
                    (>= (* (-> self board unk-float005) f30-2) 0.0)
                    (and (not (board-on-ground?))
                         (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                         (and (>= (target-height-above-ground) 4096.0)
                              (< (seconds 0.165) (target-time-to-ground))
                              (time-elapsed? (-> self board hold-exit-time) (seconds 0.05))
                              )
                         )
                    )
           (set! (-> self board unk-float005) f30-2)
           (go
             target-board-hold
             (-> *TARGET_BOARD-bank* trickz-jump-height-min)
             (-> *TARGET_BOARD-bank* trickz-jump-height-max)
             (if (focus-test? self halfpipe)
                 'halfpipe
                 )
             )
           )
         )
       )
     )
    )
  (none)
  )

(defbehavior target-board-halfpipe-trans target ()
  (when (and (focus-test? self halfpipe) *camera*)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (let ((s5-0 (camera-master-method-15 *camera* (new 'stack-no-clear 'vector))))
        (vector-flatten! gp-0 (-> self control edge-grab-across-edge-dir) (-> *camera* local-down))
        (when (< (vector-dot gp-0 s5-0) 0.0)
          (let* ((v1-11 (camera-master-method-14 *camera* (new 'stack-no-clear 'vector)))
                 (f0-3 (vector-dot (-> self control edge-grab-edge-dir) v1-11))
                 (s4-1 (vector-float*! (new 'stack-no-clear 'vector) (-> self control edge-grab-edge-dir) f0-3))
                 )
            (vector-flatten! s4-1 s4-1 (-> *camera* local-down))
            (if (< 0.0 (vector-dot s4-1 s5-0))
                (vector-negate! gp-0 s4-1)
                )
            )
          )
        )
      (vector-normalize! gp-0 8192.0)
      (+! (-> gp-0 y) 40960.0)
      (vector+! gp-0 gp-0 (get-trans self 6))
      (vector-! gp-0 gp-0 (get-trans self 0))
      (send-event *camera* 'relative-position gp-0)
      )
    (set-setting! 'matrix-blend-max-angle 'abs (degrees 12.000001) 0)
    (set-setting! 'matrix-blend-max-partial 'abs 0.5 0)
    )
  0
  (none)
  )

(defbehavior target-board-resolve-points target ()
  (when (= (-> self board main mode) (joint-mod-mode rotate))
    (let ((f0-1 (fabs (-> self board roty-cum))))
      (cond
        ((>= f0-1 191146.67)
         (add-to-trick-list (-> self board) (board-tricks board-spin) 4000.0)
         )
        ((>= f0-1 126520.89)
         (add-to-trick-list (-> self board) (board-tricks board-spin) 2000.0)
         )
        ((>= f0-1 49152.0)
         (add-to-trick-list (-> self board) (board-tricks board-spin) 500.0)
         )
        )
      )
    )
  (set! (-> self board roty-cum) 0.0)
  (set! (-> self board flip-count) 0)
  (if (time-elapsed? (-> self board in-air-time) (seconds 0.2))
      (flush-trick-list (-> self board))
      )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior target-board-ground-check target ()
  (when (board-on-ground?)
    (when (!= (-> self board roty-cum) 0.0)
      (let ((f30-0 (fabs (-> self board roty-cum)))
            (f28-0 (vector-y-angle (-> self control transv)))
            (f0-2 (y-angle (-> self control)))
            )
        (if (not (time-elapsed? (-> self board halfpipe-time) (seconds 0.1)))
            (set! f28-0 (+ 32768.0 f28-0))
            )
        (let ((f0-5 (fabs (deg-diff f0-2 f28-0))))
          (when (and (>= f30-0 41870.223) (>= 32768.0 f0-5))
            (cond
              ((>= f30-0 191146.67)
               (add-to-trick-list (-> self board) (board-tricks board-boost) 2000.0)
               )
              ((>= f30-0 126520.89)
               (add-to-trick-list (-> self board) (board-tricks board-boost) 1000.0)
               )
              (else
                (add-to-trick-list (-> self board) (board-tricks board-boost) 500.0)
                )
              )
            (let ((f30-1 (lerp-scale 20480.0 40960.0 f30-0 49152.0 182044.44)))
              (vector+float*!
                (-> self control transv)
                (-> self control transv)
                (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control transv) 1.0)
                f30-1
                )
              )
            (if (< (vector-length (-> self control transv)) 114688.0)
                (vector-normalize! (-> self control transv) 114688.0)
                )
            (when (not (logtest? (-> self control old-status) (collide-status on-surface)))
              (let ((gp-2 (new 'stack-no-clear 'vector)))
                (set! (-> gp-2 quad) (-> self control trans quad))
                (+! (-> gp-2 y) 2048.0)
                (cond
                  ((logtest? (-> *part-group-id-table* 189 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> gp-2 quad))
                   (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 189))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> gp-2 quad))
                    (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 189))
                    )
                  )
                (let ((s5-3 (process-spawn
                              manipy
                              :init manipy-init
                              gp-2
                              (-> self entity)
                              (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer level) #f))
                              #f
                              0
                              :name "manipy"
                              :to self
                              :stack-size #x20000
                              )
                            )
                      )
                  (when s5-3
                    (quaternion-copy! (-> (the-as process-drawable (-> s5-3 0)) root quat) (-> self control quat-for-control))
                    (send-event (ppointer->process s5-3) 'anim-mode 'play1)
                    (send-event (ppointer->process s5-3) 'anim "idle")
                    (send-event (ppointer->process s5-3) 'speed 1.5)
                    (set-vector! (-> (the-as process-drawable (-> s5-3 0)) root scale) 0.2 0.4 0.2 1.0)
                    )
                  )
                )
              (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3))
              (sound-play "board-boost")
              )
            )
          )
        )
      )
    (target-board-resolve-points)
    )
  (set! (-> self board turn-anim-tilt?) #t)
  (none)
  )

(defbehavior target-board-halfpipe-check target ()
  (local-vars (v0-3 collide-action))
  (let ((gp-0 (vector-flatten!
                (new-stack-vector0)
                (-> self control dynam gravity-normal)
                (-> self control ground-contact-normal)
                )
              )
        )
    (vector-normalize! gp-0 1.0)
    (cond
      ((and (board-on-ground?)
            (= (-> self control ground-pat mode) (pat-mode halfpipe))
            (< 0.0 (vector-dot (-> self control transv) gp-0))
            (and (< (-> self control surface-angle) 0.3) (zero? (-> self board halfpipe-side-time)))
            )
       (set-time! (-> self board halfpipe-side-time))
       (set! v0-3 (logior (-> self control root-prim prim-core action) (collide-action no-normal-reset)))
       (set! (-> self control root-prim prim-core action) v0-3)
       v0-3
       )
      (else
        (if (and (not (board-on-ground?))
                 (nonzero? (-> self board halfpipe-side-time))
                 (time-elapsed? (-> self board halfpipe-side-time) (seconds 0.05))
                 )
            (go target-board-halfpipe)
            )
        (when (time-elapsed? (-> self board halfpipe-side-time) (seconds 0.2))
          (set! (-> self board halfpipe-side-time) 0)
          (set! v0-3 (logclear (-> self control root-prim prim-core action) (collide-action no-normal-reset)))
          (set! (-> self control root-prim prim-core action) v0-3)
          v0-3
          )
        )
      )
    )
  )

(defbehavior target-board-jump-trans target ()
  (when (and (!= (-> self state-time) (current-time)) (jump-hit-ground-stuck?))
    (set-time! (-> self board jump-land-time))
    (go target-board-hit-ground)
    )
  (if (time-elapsed? (-> self state-time) (seconds 0.1))
      (target-board-smack-surface?)
      )
  (if (and (cpad-pressed? (-> self control cpad number) x)
           (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 12288.0)
           (and (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                (not (logtest? (water-flag touch-water) (-> self water flags)))
                (not (logtest? (-> self target-flags) (target-flags prevent-jump)))
                (not (and (-> self next-state) (= (-> self next-state name) 'target-board-wall-kick)))
                (= (-> self ext-anim) (target-anim board))
                )
           )
      (go target-board-jump-kick)
      )
  (target-board-spin-check)
  (none)
  )

(defstate target-board-start (target)
  :event target-board-handler
  :exit target-board-exit
  :code (behavior ((arg0 handle))
    (target-board-init)
    (remove-exit)
    (go target-board-get-on)
    )
  :post target-post
  )

(defstate target-board-stance (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('lip)
       (when (and (= (-> self control ground-pat mode) (pat-mode halfpipe))
                  (< (-> self control poly-angle) 0.5)
                  (let ((s5-0 (vector-flatten!
                                (new-stack-vector0)
                                (-> self control dynam gravity-normal)
                                (-> self control ground-contact-normal)
                                )
                              )
                        )
                    (vector-normalize! s5-0 1.0)
                    (< 0.0 (vector-dot (-> self control transv) s5-0))
                    )
                  )
         (set-time! (-> self board halfpipe-lip-time))
         (set-time! (-> self board halfpipe-side-time))
         (set! (-> self board halfpipe-lip-event) (the-as symbol (-> block param 0)))
         (let ((v0-2 (the-as object (logior (-> self control root-prim prim-core action) (collide-action no-normal-reset))))
               )
           (set! (-> self control root-prim prim-core action) (the-as collide-action v0-2))
           v0-2
           )
         )
       )
      (('jump)
       (sound-play "board-launch")
       (go
         target-board-jump
         (the-as meters (-> block param 0))
         (the-as meters (-> block param 1))
         (the-as symbol (-> block param 2))
         )
       )
      (else
        (target-board-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *board-walk-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    )
  :exit (behavior ()
    (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                           (or (= v1-3 'target-board-stance) (= v1-3 'target-board-duck-stance))
                                           )
                    )
               )
      (set! (-> self board halfpipe-side-time) 0)
      0
      )
    (logclear! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (set! (-> self board turn-anim-tilt?) #f)
    (when (not (and (-> self next-state)
                    (let ((v1-13 (-> self next-state name)))
                      (or (= v1-13 'target-board-stance) (= v1-13 'target-board-duck-stance) (= v1-13 'target-board-ride-edge))
                      )
                    )
               )
      (set! (-> self board turn-anim-frame) 0.0)
      (set! (-> self board turn-anim-mag) 0.0)
      (set! (-> self board turn-anim-vel) 0.0)
      (set! (-> self board turn-anim-duck) 0.0)
      )
    (target-board-exit)
    )
  :trans (behavior ()
    (if (and (cpad-hold? (-> self control cpad number) l1)
             (not (logtest? (-> self target-flags) (target-flags prevent-duck)))
             (not (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout)))
             )
        (go target-board-duck-stance)
        )
      ;; og:preserve-this - High FPS Fix
      (when (and (recently-pressed? x)
               (can-jump? 'board)
               )
      (let ((gp-0 (vector-flatten!
                    (new-stack-vector0)
                    (-> self control dynam gravity-normal)
                    (-> self control ground-contact-normal)
                    )
                  )
            )
        (vector-normalize! gp-0 1.0)
        (cond
          ((and (not (time-elapsed? (-> self board halfpipe-jump-time) (seconds 0.5)))
                (= (-> self control ground-pat mode) (pat-mode halfpipe))
                )
           )
          ((and (= (-> self control ground-pat mode) (pat-mode halfpipe))
                (< 0.0 (vector-dot (-> self control transv) gp-0))
                (< (-> self control surface-angle) 0.5)
                )
           (set-time! (-> self board halfpipe-jump-time))
           (vector-float*!
             (-> self control transv)
             (-> self control transv)
             (+ 1.0 (/ (-> *setting-control* user-current halfpipe-jump-mult) 2))
             )
           )
          (else
            (flush-trick-list (-> self board))
            (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
            )
          )
        )
      )
    (if (cpad-pressed? (-> self control cpad number) r1)
        (set-time! (-> self board spin-ground-press-time))
        )
    (when (and (can-feet? #t)
               (and (cpad-pressed? (-> self control cpad number) triangle) (< (target-height-above-ground) 8192.0))
               )
      (cond
        ((= (-> self ext-anim) (target-anim board))
         (go target-board-turn-around)
         )
        ((not (time-elapsed? (-> self board spin-ground-press-time) (seconds 0.3)))
         (set-time! (-> self board spin-ground-start-time))
         )
        )
      )
    (target-board-halfpipe-check)
    (if (target-board-smack-surface?)
        0
        )
    (target-board-anim-trans)
    (cond
      ((board-on-ground?)
       (target-board-ground-check)
       (set! (-> self control mod-surface) *board-walk-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       )
      ((and (time-elapsed? (-> self control last-time-on-surface) (seconds 0.1))
            (or (= (-> self control mod-surface name) 'spin) (< 4096.0 (target-height-above-ground)))
            )
       (set! (-> self control mod-surface) *board-jump-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       (target-board-spin-check)
       )
      (else
        (set! (-> self control mod-surface) *board-air-mods*)
        (set! (-> self board mods-backup) (-> self control mod-surface))
        )
      )
    )
  :code (behavior ()
    (let ((gp-0 (-> self board stance-info)))
      (let ((f30-0 0.0))
        (let ((s5-0 30)
              (v1-3 (ja-group))
              )
          (when (not (and (and v1-3 (= v1-3 jakb-board-turn-left-ja)) (= (ja-group-size) 4)))
            (let ((v1-10 (ja-group)))
              (cond
                ((and v1-10 (= v1-10 jakb-board-get-on-ja))
                 (ja-channel-set! 1)
                 (ja-no-eval :group! jakb-board-get-on-land-ja :num! (seek! max 1.8) :frame-num 0.0)
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! max 1.8))
                   )
                 (suspend)
                 (set! (-> self board turn-anim-duck) 1.0)
                 (set! (-> self board turn-anim-duck-vel) 15.0)
                 )
                ((let ((v1-45 (ja-group)))
                   (and v1-45 (= v1-45 jakb-board-turn-around-ja))
                   )
                 (set! s5-0 60)
                 )
                )
              )
            (ja-channel-push! 4 (the-as time-frame s5-0))
            (set! f30-0 (ja-frame-num 0))
            )
          )
        (ground-tween-initialize
          gp-0
          (the-as uint 0)
          (the-as uint jakb-board-turn-ja)
          (the-as uint jakb-board-turn-up-ja)
          (the-as uint jakb-board-turn-down-ja)
          (the-as uint jakb-board-turn-right-ja)
          (the-as uint jakb-board-turn-left-ja)
          f30-0
          )
        )
      (ja :chan 3 :group! jakb-board-duck-turn-ja)
      (until #f
        (target-board-turn-anim 0)
        (let ((f0-10 (* 1.6 (-> self control ctrl-slope-z)))
              (f1-2 (* 1.6 (-> self control ctrl-slope-x)))
              )
          (cond
            ((not (-> self board turn-anim-tilt?))
             (set! f0-10 0.0)
             (set! f1-2 0.0)
             )
            ((= (-> self control ground-pat mode) (pat-mode halfpipe))
             (set! f0-10 0.0)
             )
            )
          (ground-tween-update gp-0 f0-10 f1-2 0.1)
          )
        (ja :chan 1 :num! (chan 0))
        (ja :chan 2 :num! (chan 0))
        (cond
          ((>= (-> self board turn-anim-duck) 0.0)
           (let ((a0-31 (-> self skel root-channel 3)))
             (let ((f0-14 (-> self board turn-anim-duck)))
               (set! (-> a0-31 frame-interp 1) f0-14)
               (set! (-> a0-31 frame-interp 0) f0-14)
               )
             (set! (-> a0-31 frame-group) (the-as art-joint-anim jakb-board-duck-turn-ja))
             (set! (-> a0-31 param 0) 0.0)
             (joint-control-channel-group-eval! a0-31 (the-as art-joint-anim jakb-board-duck-turn-ja) num-func-chan)
             )
           )
          (else
            (let ((a0-32 (-> self skel root-channel 3)))
              (let ((f0-17 (- (-> self board turn-anim-duck))))
                (set! (-> a0-32 frame-interp 1) f0-17)
                (set! (-> a0-32 frame-interp 0) f0-17)
                )
              (set! (-> a0-32 frame-group) (the-as art-joint-anim jakb-board-air-turn-ja))
              (set! (-> a0-32 param 0) 0.0)
              (joint-control-channel-group-eval! a0-32 (the-as art-joint-anim jakb-board-air-turn-ja) num-func-chan)
              )
            )
          )
        (suspend)
        (can-play-stance-amibent?)
        )
      )
    #f
    )
  :post target-board-post
  )

(defstate target-board-duck-stance (target)
  :event (-> target-board-stance event)
  :enter (behavior ()
    (set! (-> self control mod-surface) *board-duck-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    )
  :exit (behavior ()
    (set! (-> self board turn-anim-duck-vel) -8.0)
    ((-> target-board-stance exit))
    )
  :trans (behavior ()
    (if (and (or (not (cpad-hold? (-> self control cpad number) l1))
                 (logtest? (-> self target-flags) (target-flags prevent-duck))
                 (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout))
                 )
             (can-exit-duck? self)
             )
        (go target-board-stance)
        )
      ;; og:preserve-this - High FPS Fix
      (when (and (recently-pressed? x)
               (can-jump? 'board)
               )
      (let ((gp-0 (vector-flatten!
                    (new-stack-vector0)
                    (-> self control dynam gravity-normal)
                    (-> self control ground-contact-normal)
                    )
                  )
            )
        (vector-normalize! gp-0 1.0)
        (cond
          ((and (not (time-elapsed? (-> self board halfpipe-jump-time) (seconds 0.5)))
                (= (-> self control ground-pat mode) (pat-mode halfpipe))
                )
           )
          ((and (= (-> self control ground-pat mode) (pat-mode halfpipe))
                (< 0.0 (vector-dot (-> self control transv) gp-0))
                (< (-> self control surface-angle) 0.5)
                )
           (let ((f30-0 (if (cpad-hold? (-> self control cpad number) l1)
                            (* (-> self board charge-progress) (-> *TARGET_BOARD-bank* charge-jump-height))
                            0.0
                            )
                        )
                 )
             (sound-play "board-launch")
             (when (!= (-> self board charge-progress) 0.0)
               (if (logtest? (-> *part-group-id-table* 191 flags) (sp-group-flag sp13))
                   (part-tracker-spawn
                     part-tracker-subsampler
                     :to self
                     :group (-> *part-group-id-table* 191)
                     :mat-joint (-> self node-list data 0 bone transform)
                     )
                   (part-tracker-spawn
                     part-tracker
                     :to self
                     :group (-> *part-group-id-table* 191)
                     :mat-joint (-> self node-list data 0 bone transform)
                     )
                   )
               )
             (set-time! (-> self board halfpipe-jump-time))
             (set! (-> self board charge-progress) 0.0)
             (sound-stop (-> self board charge-sound-id))
             (vector-float*!
               (-> self control transv)
               (-> self control transv)
               (+ 1.0 f30-0 (/ (-> *setting-control* user-current halfpipe-jump-mult) 2))
               )
             )
           )
          (else
            (flush-trick-list (-> self board))
            (deg-diff (vector-y-angle (-> self control c-R-w fvec)) (vector-y-angle (-> self control to-target-pt-xz)))
            (go
              target-board-jump
              (-> *TARGET_BOARD-bank* duck-jump-height-min)
              (-> *TARGET_BOARD-bank* duck-jump-height-max)
              (the-as symbol *board-duck-jump-mods*)
              )
            )
          )
        )
      )
    (if (cpad-pressed? (-> self control cpad number) r1)
        (set-time! (-> self board spin-ground-press-time))
        )
    (if (and (cpad-hold? (-> self control cpad number) r1)
             (can-feet? #t)
             (not (time-elapsed? (-> self board spin-ground-press-time) (seconds 0.3)))
             (board-turn-around?)
             )
        (set-time! (-> self board spin-ground-start-time))
        )
    (target-board-halfpipe-check)
    (if (target-board-smack-surface?)
        0
        )
    (target-board-anim-trans)
    (set! (-> self board turn-anim-duck-vel) 8.0)
    (cond
      ((board-on-ground?)
       (target-board-ground-check)
       (set! (-> self control mod-surface) *board-duck-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       )
      ((and (time-elapsed? (-> self control last-time-on-surface) (seconds 0.1))
            (or (= (-> self control mod-surface name) 'spin) (< 4096.0 (target-height-above-ground)))
            )
       (set! (-> self control mod-surface) *board-duck-jump-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       (target-board-spin-check)
       )
      (else
        (set! (-> self control mod-surface) *board-air-mods*)
        (set! (-> self board mods-backup) (-> self control mod-surface))
        )
      )
    )
  :code (-> target-board-stance code)
  :post target-board-post
  )

(defstate target-board-jump (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'edge-grab) (not (time-elapsed? (-> self state-time) (seconds 0.1))))
        (return #f)
        )
    (target-board-handler proc argc message block)
    )
  :enter (behavior ((arg0 meters) (arg1 meters) (arg2 symbol))
    (local-vars
      (sv-144 (function vector entity-actor skeleton-group vector manipy-options none :behavior manipy))
      (sv-160 entity-actor)
      )
    (if (= arg2 'hit)
        (set! arg2 #f)
        )
    (when (not (time-elapsed? (-> self board ride-time) (seconds 0.5)))
      (set! arg2 (the-as symbol *board-ride-jump-mods*))
      (let ((s2-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control transv) 1.0)))
        (forward-up-nopitch->quaternion
          (-> self control dir-targ)
          s2-0
          (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
          )
        (set! (-> self control turn-lockout-end-time)
              (+ (current-time) (the int (lerp-scale 225.0 0.0 (vector-dot s2-0 (-> self control c-R-w fvec)) -1.0 1.0)))
              )
        )
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set-time! (-> self state-time))
    (let ((f30-0 0.0))
      (when (and (cpad-hold? (-> self control cpad number) l1) (!= (-> self board charge-progress) 0.0))
        (+! f30-0 (* (-> self board charge-progress) (-> *TARGET_BOARD-bank* charge-jump-height)))
        (sound-play "board-launch")
        (if (logtest? (-> *part-group-id-table* 191 flags) (sp-group-flag sp13))
            (part-tracker-spawn
              part-tracker-subsampler
              :to self
              :group (-> *part-group-id-table* 191)
              :mat-joint (-> self node-list data 0 bone transform)
              )
            (part-tracker-spawn
              part-tracker
              :to self
              :group (-> *part-group-id-table* 191)
              :mat-joint (-> self node-list data 0 bone transform)
              )
            )
        )
      (set! (-> self board charge-progress) 0.0)
      (sound-stop (-> self board charge-sound-id))
      (cond
        ((and (< 0.0 (-> self board shock-offsetv))
              (not (time-elapsed? (-> self board jump-land-time) (seconds 0.5)))
              (time-elapsed? (-> self board ride-time) (seconds 0.5))
              )
         (let ((s3-5 (new 'stack-no-clear 'vector)))
           (set! (-> s3-5 quad) (-> self control trans quad))
           (+! (-> s3-5 y) 2048.0)
           (cond
             ((logtest? (-> *part-group-id-table* 190 flags) (sp-group-flag sp13))
              (set! (-> *launch-matrix* trans quad) (-> s3-5 quad))
              (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 190))
              )
             (else
               (set! (-> *launch-matrix* trans quad) (-> s3-5 quad))
               (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 190))
               )
             )
           (let* ((s1-1 (get-process *default-dead-pool* manipy #x20000 1))
                  (s2-4
                    (when s1-1
                      (let ((t9-20 (method-of-type manipy activate)))
                        (t9-20 (the-as manipy s1-1) self "manipy" (the-as pointer #x70004000))
                        )
                      (let ((s2-5 run-function-in-process)
                            (s0-1 s1-1)
                            )
                        (set! sv-144 manipy-init)
                        (set! sv-160 (-> self entity))
                        (let ((t0-2 (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer level) #f)))
                              (t1-1 #f)
                              (t2-1 0)
                              )
                          ((the-as (function object object object object object object object none) s2-5)
                           s0-1
                           sv-144
                           s3-5
                           sv-160
                           t0-2
                           t1-1
                           t2-1
                           )
                          )
                        )
                      (-> s1-1 ppointer)
                      )
                    )
                  )
             (when s2-4
               (quaternion-copy! (-> (the-as process-drawable (-> s2-4 0)) root quat) (-> self control quat-for-control))
               (send-event (ppointer->process s2-4) 'anim-mode 'play1)
               (send-event (ppointer->process s2-4) 'anim "idle")
               (send-event (ppointer->process s2-4) 'speed 1.5)
               (set-vector! (-> (the-as process-drawable (-> s2-4 0)) root scale) 0.2 0.4 0.2 1.0)
               )
             )
           )
         (set! f30-0 (+ 8192.0 f30-0))
         (add-to-trick-list (-> self board) (board-tricks board-quick-jump) 0.0)
         (sound-play "board-q-jump")
         )
        (else
          (if (= (the-as object arg2) *board-duck-jump-mods*)
              (add-to-trick-list (-> self board) (board-tricks board-duck-jump) 0.0)
              (add-to-trick-list (-> self board) (board-tricks board-jump) 0.0)
              )
          (set! (-> self board jump-sound-id) (sound-play "board-jump"))
          )
        )
      (init-var-jump
        (+ arg0 f30-0)
        (+ arg1 f30-0)
        #t
        #f
        (-> self control transv)
        (if (time-elapsed? (-> self board last-jump-time) (seconds 0.1))
            2.0
            0.0
            )
        )
      )
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! arg2 (cond
                 ((the-as object arg2)
                  (empty)
                  arg2
                  )
                 (else
                   (the-as symbol *board-jump-mods*)
                   )
                 )
          )
    (set! (-> self control mod-surface) (the-as surface arg2))
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self board shock-offsetv) 0.0)
    (set! (-> self control unknown-float36)
          (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
          )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :exit target-board-exit
  :trans (behavior ()
    (target-board-jump-trans)
    (set! (-> self control unknown-float36)
          (fmax
            (-> self control unknown-float36)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))) ;; og:preserve-this abutton indexing
            )
          )
    (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (set! (-> self board shock-offset) (* 0.8 (-> self board shock-offset)))
    )
  :code (behavior ((arg0 meters) (arg1 meters) (arg2 symbol))
    (cond
      ((= arg2 'hit)
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! jakb-board-hit-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       (ja-channel-push! 1 (seconds 0.05))
       )
      ((and (= (-> self ext-anim) (target-anim board)) (>= (the-as float (-> self control unknown-word04)) 20480.0))
       (ja-channel-push! 1 (seconds 0.05))
       (ja :group! jakb-board-jump-high-ja :num! min)
       (suspend)
       (until (ja-done? 0)
         (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
               (f0-11 (- 25.0 (ja-aframe-num 0)))
               (gp-1 (-> self skel root-channel 0))
               )
           (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
           (let ((v1-49 (and (< 0.0 f30-0) (< 0.0 f0-11))))
             (set! (-> gp-1 param 1)
                   (cond
                     (v1-49
                       (fmin (fmin 1.5 f0-11) (/ (* 5.0 f0-11) (the float (time-to-apex f30-0 -245760.0))))
                       )
                     ((< (seconds 0.165) (target-time-to-ground))
                      1.5
                      )
                     (else
                       0.8
                       )
                     )
                   )
             )
           (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
           )
         (suspend)
         )
       (ja-channel-push! 1 (seconds 0.05))
       )
      (else
        (ja-channel-push! 1 (seconds 0.05))
        (ja :group! jakb-board-jump-ja :num! min)
        (suspend)
        (until (ja-done? 0)
          (let ((f30-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                (f0-20 (- 10.0 (ja-aframe-num 0)))
                (gp-3 (-> self skel root-channel 0))
                )
            (set! (-> gp-3 param 0) (the float (+ (-> gp-3 frame-group frames num-frames) -1)))
            (let ((v1-74 (and (< 0.0 f30-1) (< 0.0 f0-20))))
              (set! (-> gp-3 param 1)
                    (cond
                      (v1-74
                        (fmin (fmin 1.5 f0-20) (/ (* 5.0 f0-20) (the float (time-to-apex f30-1 -245760.0))))
                        )
                      ((< (seconds 0.165) (target-time-to-ground))
                       0.5
                       )
                      (else
                        0.25
                        )
                      )
                    )
              )
            (joint-control-channel-group-eval! gp-3 (the-as art-joint-anim #f) num-func-seek!)
            )
          (suspend)
          )
        (ja-channel-push! 1 (seconds 0.05))
        )
      )
    (ja :group! jakb-board-jump-loop-ja)
    (until #f
      (suspend)
      (ja :num! (loop!))
      )
    #f
    )
  :post target-board-post
  )

(defstate target-board-halfpipe (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('edge-grab)
       (format
         #t
         "halfpipe found edge ~m~%"
         (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
         )
       (set! (-> self control unknown-word04) (the-as uint #t))
       (let ((v1-6 *edge-grab-info*))
         (vector-normalize!
           (vector-!
             (-> self control edge-grab-edge-dir)
             (the-as vector (-> v1-6 world-vertex))
             (-> v1-6 world-vertex 1)
             )
           1.0
           )
         )
       (vector-cross!
         (-> self control edge-grab-across-edge-dir)
         (-> self control edge-grab-edge-dir)
         (-> self control dynam gravity-normal)
         )
       (let ((v1-11 (new-stack-vector0)))
         (let ((f0-2 (vector-dot (-> self control edge-grab-across-edge-dir) (-> self control transv))))
           0.0
           (vector-!
             v1-11
             (-> self control transv)
             (vector-float*! v1-11 (-> self control edge-grab-across-edge-dir) f0-2)
             )
           )
         (let* ((f0-3 (vector-length v1-11))
                (f1-1 f0-3)
                (f2-0 -2048.0)
                )
           (vector+!
             (-> self control transv)
             (vector-float*! (-> self control transv) (-> self control edge-grab-across-edge-dir) f2-0)
             (vector-float*! v1-11 v1-11 (/ f0-3 f1-1))
             )
           )
         )
       )
      (('ramp)
       (when (not (-> self control did-move-to-pole-or-max-jump-height))
         (let ((v0-3 (the-as object #t)))
           (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float v0-3))
           v0-3
           )
         )
       )
      (('grenade)
       (if (and (< (the-as float (-> block param 0))
                   (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
                   )
                (= (-> self ext-anim) (target-anim board))
                )
           (go target-board-grenade (process->handle proc))
           )
       )
      (else
        (target-board-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self focus-status) (focus-status halfpipe))
    (set-time! (-> self state-time))
    (logior! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (set! (-> self control mod-surface) *board-halfpipe-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control sliding-start-time) 0)
    (when (< (vector-dot (-> self control c-R-w uvec) (-> self control dynam gravity-normal)) 0.7)
      (vector-matrix*! (-> self control transv-ctrl) (-> self control transv) (-> self control w-R-c))
      (set! (-> self control transv-ctrl y) 0.0)
      (vector-matrix*! (-> self control transv) (-> self control transv-ctrl) (-> self control c-R-w))
      )
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float #f))
    (target-method-28 *target* *collide-cache* *collide-edge-board-halfpipe-spec*)
    (when (not (-> self control unknown-spool-anim00))
      (let ((gp-0 (vector-flatten!
                    (-> self control edge-grab-across-edge-dir)
                    (-> self control dynam gravity-normal)
                    (-> self control ground-contact-normal)
                    )
                  )
            )
        (set! (-> gp-0 y) 0.0)
        (vector-normalize! gp-0 1.0)
        (vector-rotate-y! (-> self control edge-grab-edge-dir) (-> self control edge-grab-across-edge-dir) 16384.0)
        (let ((v1-40 (new-stack-vector0)))
          (let ((f0-5 (vector-dot gp-0 (-> self control transv))))
            0.0
            (vector-! v1-40 (-> self control transv) (vector-float*! v1-40 gp-0 f0-5))
            )
          (let* ((f0-6 (vector-length v1-40))
                 (f1-2 f0-6)
                 (f2-0 -2048.0)
                 )
            (vector+!
              (-> self control transv)
              (vector-float*! (-> self control transv) gp-0 f2-0)
              (vector-float*! v1-40 v1-40 (/ f0-6 f1-2))
              )
            )
          )
        )
      )
    (if (or (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 20480.0)
            (< (vector-dot
                 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control transv) 1.0)
                 )
               0.3
               )
            )
        (go target-board-turn-to (-> self control transv) (seconds 0.5))
        )
    )
  :exit (behavior ()
    (if (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                         (or (= v1-3 'target-board-flip)
                                             (= v1-3 'target-board-hold)
                                             (= v1-3 'target-board-trickx)
                                             (= v1-3 'target-board-tricky)
                                             (= v1-3 'target-board-grenade)
                                             (= v1-3 'target-board-falling)
                                             )
                                         )
                  )
             )
        (logclear! (-> self focus-status) (focus-status halfpipe))
        )
    (send-event *camera* 'relative-position #f)
    (remove-setting! 'matrix-blend-max-angle)
    (remove-setting! 'matrix-blend-max-partial)
    (logclear! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (target-board-exit)
    )
  :trans (behavior ()
    (when (and (or (= (the-as int (-> self control did-move-to-pole-or-max-jump-height)) #t)
                   (and (not (time-elapsed? (-> self board halfpipe-lip-time) (seconds 0.1)))
                        (= (-> self board halfpipe-lip-event) 'lipramp)
                        )
                   )
               (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
               )
      (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float 'done))
      (let ((v1-16 (new-stack-vector0))
            (f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            )
        0.0
        (vector-! v1-16 (-> self control transv) (vector-float*! v1-16 (-> self control dynam gravity-normal) f0-2))
        (let* ((f1-4 (vector-length v1-16))
               (f2-0 f1-4)
               )
          (if (!= f1-4 0.0)
              (set! f1-4 0.0)
              )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
            (vector-float*! v1-16 v1-16 (/ f1-4 f2-0))
            )
          )
        )
      )
    (set-time! (-> self board halfpipe-time))
    (if (= (-> self control gspot-pat-surfce mode) (pat-mode halfpipe))
        (set-time! (-> self board halfpipe-gspot-time))
        )
    (when (jump-hit-ground-stuck?)
      (vector-float*! (-> self control transv) (-> self control transv) 1.5)
      (go target-board-turn-to (-> self control transv) (seconds 0.5))
      )
    (when (and (cpad-pressed? (-> self control cpad number) x)
               (time-elapsed? (-> self board halfpipe-jump-time) (seconds 0.6))
               (not (time-elapsed? (-> self state-time) (-> *TARGET-bank* ground-timeout)))
               (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
               )
      (set-time! (-> self board halfpipe-jump-time))
      (vector-float*!
        (-> self control transv)
        (-> self control transv)
        (+ 1.0 (/ (-> *setting-control* user-current halfpipe-jump-mult) 2))
        )
      )
    (target-board-spin-check)
    (cond
      ((> (-> self control sliding-start-time) 0)
       (cond
         ((< 0.7 (-> self control turn-to-magnitude))
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (set! (-> gp-0 quad) (-> self control edge-grab-across-edge-dir quad))
            (set! (-> gp-0 y) 0.0)
            (vector-normalize! gp-0 1.0)
            (if (< 0.7 (vector-dot (-> self control to-target-pt-xz) gp-0))
                (+! (-> self control sliding-start-time) (- (current-time) (-> self clock old-frame-counter)))
                (set! (-> self control sliding-start-time) 1)
                )
            )
          )
         (else
           (set! (-> self control sliding-start-time) 1)
           )
         )
       )
      ((and (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
            (< (-> self board halfpipe-lip-time) (+ (-> self state-time) (seconds -0.2)))
            )
       (set! (-> self control sliding-start-time) 1)
       )
      )
    (when (or (>= (-> self control sliding-start-time) (seconds 0.05))
              (and (time-elapsed? (-> self board halfpipe-gspot-time) (seconds 0.5))
                   (< (-> self board halfpipe-lip-time) (+ (-> self state-time) (seconds -0.2)))
                   )
              )
      (+! (-> self control transv x) (* 20480.0 (-> self control edge-grab-across-edge-dir x)))
      (+! (-> self control transv z) (* 20480.0 (-> self control edge-grab-across-edge-dir z)))
      (go target-board-stance)
      )
    (target-board-halfpipe-trans)
    )
  :code (behavior ()
    (cond
      ((not (time-elapsed? (-> self board halfpipe-jump-time) (seconds 0.5)))
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! jakb-board-jump-ja :num! (seek! (ja-aframe 8.0 0) 0.5) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 8.0 0) 0.5))
         )
       (ja-no-eval :group! jakb-board-jump-ja :num! (seek! (ja-aframe 10.0 0) 0.2) :frame-num (ja-aframe 8.0 0))
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 10.0 0) 0.2))
         )
       (ja-no-eval :group! jakb-board-jump-ja :num! (seek! (ja-aframe 12.0 0) 0.1) :frame-num (ja-aframe 10.0 0))
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 12.0 0) 0.1))
         )
       (sleep-code)
       )
      (else
        ((the-as (function none) (-> target-board-stance code)))
        )
      )
    )
  :post target-board-post
  )

(defstate target-board-falling (target)
  :event target-board-handler
  :enter (behavior ()
    (if (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2) (not *pause-lock*))
        (set! (-> self control mod-surface) *board-air-mods*)
        (set! (-> self control mod-surface) *board-jump-mods*)
        )
    (set! (-> self board mods-backup) (-> self control mod-surface))
    )
  :exit (-> target-board-halfpipe exit)
  :trans (behavior ()
    (target-board-jump-trans)
    (if (focus-test? self halfpipe)
        (target-board-halfpipe-trans)
        )
    (when (and (= *cheat-mode* 'debug) (and (cpad-hold? (-> self control cpad number) r2) (not *pause-lock*)))
      (set! (-> self control mod-surface) *board-air-mods*)
      (set! (-> self board mods-backup) (-> self control mod-surface))
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 jakb-board-jump-loop-ja))
         )
        ((let ((v1-8 (ja-group)))
           (and v1-8 (= v1-8 jakb-board-noseflip-ja))
           )
         (ja-no-eval :num! (seek!))
         (ja-channel-push! 1 (seconds 0.5))
         )
        ((let ((v1-22 (ja-group)))
           (and v1-22 (or (= v1-22 jakb-board-flip-backward-ja)
                          (= v1-22 jakb-board-flip-backward-loop-ja)
                          (= v1-22 jakb-board-flip-forward-ja)
                          (= v1-22 jakb-board-flip-forward-loop-ja)
                          )
                )
           )
         (ja-no-eval :num! (seek!))
         (ja-channel-push! 1 (seconds 0.2))
         )
        (else
          (let ((v1-36 (ja-group)))
            (cond
              ((and v1-36 (= v1-36 jakb-board-spin-ja))
               (ja-no-eval :num! (seek!))
               (ja-channel-push! 1 (seconds 0.1))
               )
              (else
                (ja-channel-push! 1 (seconds 0.5))
                )
              )
            )
          )
        )
      )
    (cond
      ((focus-test? self halfpipe)
       (ja :group! jakb-board-duck-turn-ja :num! (identity (ja-aframe 0.0 0)))
       (loop
         (suspend)
         (ja-blend-eval)
         )
       )
      (else
        (ja :group! jakb-board-jump-loop-ja)
        (loop
          (suspend)
          (ja-blend-eval)
          (ja :num! (loop!))
          )
        )
      )
    )
  :post target-board-post
  )

(defstate target-board-jump-kick (target)
  :event target-board-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *board-jump-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (sound-play "board-k-jump")
    )
  :exit target-board-exit
  :trans (behavior ()
    (if (jump-hit-ground-stuck?)
        (go target-board-hit-ground)
        )
    (target-board-smack-surface?)
    (cond
      ((not (time-elapsed? (-> self board smack-surface-time) (seconds 0.2)))
       (go target-board-wall-kick (-> self board smack-normal) (-> self board smack-speed))
       )
      ((not (time-elapsed? (-> self board glance-time) (seconds 0.2)))
       (go
         target-board-wall-kick
         (vector-normalize-copy! (-> self control unknown-vector38) (-> self board glance-out-transv) 1.0)
         (-> self board glance-speed)
         )
       )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-board-jump-kick-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 1 (seconds 2))
    (ja :group! jakb-board-jump-loop-ja)
    (until #f
      (suspend)
      (ja :num! (loop!))
      )
    #f
    )
  :post target-board-post
  )

(defstate target-board-wall-kick (target)
  :event target-board-handler
  :enter (behavior ((arg0 vector) (arg1 float))
    (sound-play "board-kick")
    (set! (-> self control transv quad) (-> arg0 quad))
    (vector-xz-normalize! (-> self control transv) (* 0.8 arg1))
    (set! (-> self control unknown-word04) (the-as uint (fmax 81920.0 (* 0.8 arg1))))
    (set! (-> self control unknown-vector38 quad) (-> arg0 quad))
    (set! (-> self control transv y) 0.0)
    (vector-turn-to (vector-negate! (new 'stack-no-clear 'vector) (-> self control transv)))
    (set! (-> self control transv y) (- (sqrtf (* 24576.0 (-> self control dynam gravity-length)))
                                        (* 0.008333334 (- (-> self control dynam gravity-length)))
                                        )
          )
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *board-wall-kick-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self board smack-surface-time) 0)
    0
    )
  :exit target-board-exit
  :trans target-board-jump-trans
  :code (behavior ((arg0 vector) (arg1 float))
    (ja-no-eval :group! jakb-board-jump-kickoff-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (if (and (jump-hit-ground-stuck?) (< 31.0 (ja-aframe-num 0)))
          (go target-board-hit-ground)
          )
      (let ((v1-21 (-> self control unknown-vector38)))
        (set! (-> self control transv x) (-> v1-21 x))
        (set! (-> self control transv z) (-> v1-21 z))
        )
      (vector-xz-normalize! (-> self control transv) (the-as float (-> self control unknown-word04)))
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      (suspend)
      (ja :num! (seek!))
      )
    enter-state
    (go target-board-falling)
    )
  :post target-board-post
  )

(defstate target-board-flip (target)
  :event (-> target-board-jump event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self control unknown-word04) (the-as uint arg2))
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control transv)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ))
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set-time! (-> self state-time))
    (cond
      ((= arg2 'halfpipe)
       (logior! (-> self focus-status) (focus-status halfpipe))
       (target-board-halfpipe-trans)
       )
      (else
        (init-var-jump arg0 arg1 #t #f (-> self control transv) 1.0)
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (set! (-> self control unknown-float36)
              (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
              )
        )
      )
    (set! (-> self control mod-surface) *board-flip-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((v1-25 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-25 command) (sound-command set-param))
      (set! (-> v1-25 id) (-> self board jump-sound-id))
      (set! (-> v1-25 params volume) -4)
      (set! (-> v1-25 auto-time) 72)
      (set! (-> v1-25 auto-from) 2)
      (set! (-> v1-25 params mask) (the-as uint 17))
      (-> v1-25 id)
      )
    (set! (-> self control unknown-sound-id00) (sound-play "board-flip"))
    (target-start-attack)
    (target-danger-set! 'board-spin #f)
    )
  :exit (behavior ()
    (target-danger-set! 'harmless #f)
    (set! (-> self board flip-control) 0.0)
    (add-to-trick-list
      (-> self board)
      (board-tricks board-flip)
      (+ (* 500.0 (the float (-> self board flip-count))) (if (>= (-> self board flip-count) 2)
                                                              2000.0
                                                              0.0
                                                              )
         )
      )
    (let ((v1-9 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-9 command) (sound-command set-param))
      (set! (-> v1-9 id) (-> self control unknown-sound-id00))
      (set! (-> v1-9 params volume) -4)
      (set! (-> v1-9 auto-time) 24)
      (set! (-> v1-9 auto-from) 2)
      (set! (-> v1-9 params mask) (the-as uint 17))
      (-> v1-9 id)
      )
    ((-> target-board-halfpipe exit))
    )
  :trans (behavior ()
    (cond
      ((= (-> self control unknown-spool-anim00) 'halfpipe)
       (target-board-halfpipe-trans)
       )
      (else
        (set! (-> self control unknown-float36)
              (fmax
                (-> self control unknown-float36)
                (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))) ;; og:preserve-this abutton indexing
                )
              )
        (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((gp-0 (>= (-> self board flip-control) 0.0)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 x) 0.0)
        (set! (-> s5-0 y) 0.0)
        (set! (-> s5-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
        (set! (-> s5-0 w) 1.0)
        (let ((f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
              (s4-0 0)
              )
          (while (not (and (or (not (cpad-hold? (-> self control cpad number) r1))
                               (or (= f0-9 0.0) (jump-hit-ground-stuck?) (< (target-time-to-ground) (seconds 0.5)))
                               )
                           (nonzero? s4-0)
                           )
                      )
            (cond
              (gp-0
                (cond
                  ((zero? s4-0)
                   (ja-channel-push! 1 (seconds 0.1))
                   (ja-no-eval :group! jakb-board-flip-forward-ja :num! (seek! (ja-aframe 15.0 0)) :frame-num 0.0)
                   (until (ja-done? 0)
                     (suspend)
                     (ja :num! (seek! (ja-aframe 15.0 0)))
                     )
                   )
                  (else
                    (ja-no-eval :group! jakb-board-flip-forward-loop-ja :num! (seek!) :frame-num 0.0)
                    (until (ja-done? 0)
                      (suspend)
                      (ja :num! (seek!))
                      )
                    )
                  )
                )
              ((zero? s4-0)
               (ja-channel-push! 1 (seconds 0.1))
               (ja-no-eval :group! jakb-board-flip-backward-ja :num! (seek! (ja-aframe 10.0 0)) :frame-num 0.0)
               (until (ja-done? 0)
                 (suspend)
                 (ja :num! (seek! (ja-aframe 10.0 0)))
                 )
               )
              (else
                (ja-no-eval :group! jakb-board-flip-backward-loop-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
              )
            (+! (-> self board flip-count) 1)
            (set! f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
            (+! s4-0 1)
            )
          )
        )
      (cond
        (gp-0
          (ja-no-eval :group! jakb-board-flip-forward-ja :num! (seek!) :frame-num (ja-aframe 15.0 0))
          (until (ja-done? 0)
            (if (jump-hit-ground-stuck?)
                (go target-board-hit-ground)
                )
            (suspend)
            (ja :num! (seek!))
            )
          )
        (else
          (ja-no-eval :group! jakb-board-flip-backward-ja :num! (seek!) :frame-num (ja-aframe 10.0 0))
          (until (ja-done? 0)
            (if (jump-hit-ground-stuck?)
                (go target-board-hit-ground)
                )
            (suspend)
            (ja :num! (seek!))
            )
          )
        )
      )
    (go target-board-falling)
    )
  :post target-board-post
  )

(defstate target-board-hold (target)
  :event (-> target-board-jump event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self control unknown-word04) (the-as uint arg2))
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control transv)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ))
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set-time! (-> self state-time))
    (set-time! (-> self board hold-start-time))
    (cond
      ((= arg2 'halfpipe)
       (logior! (-> self focus-status) (focus-status halfpipe))
       (target-board-halfpipe-trans)
       )
      (else
        (init-var-jump arg0 arg1 #t #f (-> self control transv) 1.0)
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (set! (-> self control unknown-float36)
              (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
              )
        )
      )
    (set! (-> self control mod-surface) *board-flip-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control dynam gravity-length) 147456.0)
    )
  :exit (behavior ()
    (set! (-> self board unk-float006) 0.0)
    (set-time! (-> self board hold-exit-time))
    (let ((v1-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-3 command) (sound-command set-param))
      (set! (-> v1-3 id) (-> self board trick-sound-id))
      (set! (-> v1-3 params volume) -4)
      (set! (-> v1-3 auto-time) 24)
      (set! (-> v1-3 auto-from) 2)
      (set! (-> v1-3 params mask) (the-as uint 17))
      (-> v1-3 id)
      )
    (let ((v1-7 (ja-group)))
      (if (and v1-7 (= v1-7 jakb-board-noseflip-ja))
          (sound-play "board-boots")
          )
      )
    ((-> target-board-halfpipe exit))
    )
  :trans (behavior ()
    (target-board-spin-check)
    (cond
      ((= (-> self control unknown-spool-anim00) 'halfpipe)
       (target-board-halfpipe-trans)
       )
      (else
        (set! (-> self control unknown-float36)
              (fmax
                (-> self control unknown-float36)
                (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))) ;; og:preserve-this abutton indexing
                )
              )
        (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 x) (* -0.0078125 (+ -128.0 (the float (-> self control cpad leftx)))))
      (set! (-> gp-0 y) 0.0)
      (set! (-> gp-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
      (set! (-> gp-0 w) 1.0)
      (let ((f30-0 (analog-input (the int (* 128.0 (-> gp-0 x))) 0.0 96.0 110.0 1.0))
            (f28-0 (analog-input (the int (* 128.0 (-> gp-0 z))) 0.0 96.0 110.0 1.0))
            )
        (while (not (or (not (cpad-hold? (-> self control cpad number) l2))
                        (jump-hit-ground-stuck?)
                        (< (target-time-to-ground) (seconds 0.3))
                        )
                    )
          (cond
            ((and (< f30-0 0.0) (< (fabs f28-0) (fabs f30-0)))
             (let ((v1-17 (ja-group)))
               (cond
                 ((and v1-17 (= v1-17 jakb-board-method-cross-loop-ja))
                  (ja :num! (loop!))
                  )
                 (else
                   (add-to-trick-list (-> self board) (board-tricks board-method-cross) 500.0)
                   (set! (-> self board trick-sound-id) (sound-play "board-method"))
                   (ja-channel-push! 1 (seconds 0.08))
                   (ja-no-eval :group! jakb-board-method-cross-ja :num! (seek!) :frame-num 0.0)
                   (until (ja-done? 0)
                     (suspend)
                     (ja :num! (seek!))
                     )
                   (ja :group! jakb-board-method-cross-loop-ja :num! min)
                   )
                 )
               )
             )
            ((and (< f28-0 0.0) (< (fabs f30-0) (fabs f28-0)))
             (let ((v1-61 (ja-group)))
               (cond
                 ((and v1-61 (= v1-61 jakb-board-backgrab-loop-ja))
                  (ja :num! (loop!))
                  )
                 (else
                   (add-to-trick-list (-> self board) (board-tricks board-backgrab) 500.0)
                   (set! (-> self board trick-sound-id) (sound-play "board-method"))
                   (ja-channel-push! 1 (seconds 0.08))
                   (ja-no-eval :group! jakb-board-backgrab-ja :num! (seek!) :frame-num 0.0)
                   (until (ja-done? 0)
                     (suspend)
                     (ja :num! (seek!))
                     )
                   (ja :group! jakb-board-backgrab-loop-ja :num! min)
                   )
                 )
               )
             )
            ((and (< 0.0 f28-0) (< (fabs f30-0) (fabs f28-0)))
             (let ((v1-105 (ja-group)))
               (cond
                 ((and v1-105 (= v1-105 jakb-board-airwalk-loop-ja))
                  (ja :num! (loop!))
                  )
                 (else
                   (add-to-trick-list (-> self board) (board-tricks board-airwalk) 500.0)
                   (set! (-> self board trick-sound-id) (sound-play "board-method"))
                   (ja-channel-push! 1 (seconds 0.08))
                   (ja-no-eval :group! jakb-board-airwalk-ja :num! (seek!) :frame-num 0.0)
                   (until (ja-done? 0)
                     (suspend)
                     (ja :num! (seek!))
                     )
                   (ja :group! jakb-board-airwalk-loop-ja :num! min)
                   )
                 )
               )
             )
            (else
              (let ((v1-147 (ja-group)))
                (cond
                  ((and v1-147 (= v1-147 jakb-board-method-loop-ja))
                   (ja :num! (loop!))
                   )
                  (else
                    (add-to-trick-list (-> self board) (board-tricks board-method) 500.0)
                    (set! (-> self board trick-sound-id) (sound-play "board-method"))
                    (ja-channel-push! 1 (seconds 0.08))
                    (ja-no-eval :group! jakb-board-method-ja :num! (seek!) :frame-num 0.0)
                    (until (ja-done? 0)
                      (suspend)
                      (ja :num! (seek!))
                      )
                    (ja :group! jakb-board-method-loop-ja :num! min)
                    )
                  )
                )
              )
            )
          (suspend)
          )
        )
      )
    (let ((v1-200 (ja-group)))
      (cond
        ((and v1-200 (= v1-200 jakb-board-method-loop-ja))
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! jakb-board-method-end-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        ((let ((v1-230 (ja-group)))
           (and v1-230 (= v1-230 jakb-board-method-cross-loop-ja))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! jakb-board-method-cross-end-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        ((let ((v1-260 (ja-group)))
           (and v1-260 (= v1-260 jakb-board-backgrab-loop-ja))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! jakb-board-backgrab-end-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        ((let ((v1-290 (ja-group)))
           (and v1-290 (= v1-290 jakb-board-airwalk-loop-ja))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! jakb-board-airwalk-end-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        )
      )
    (let ((v1-318 (new-stack-vector0))
          (f0-83 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-!
        v1-318
        (-> self control transv)
        (vector-float*! v1-318 (-> self control dynam gravity-normal) f0-83)
        )
      (let* ((f1-11 (vector-length v1-318))
             (f2-4 f1-11)
             )
        (if (< 0.0 f0-83)
            (set! f0-83 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-83)
          (vector-float*! v1-318 v1-318 (/ f1-11 f2-4))
          )
        )
      )
    (go target-board-falling)
    )
  :post target-board-post
  )

(defstate target-board-tricky (target)
  :event (-> target-board-jump event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self control unknown-word04) (the-as uint arg2))
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control transv)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ))
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set-time! (-> self state-time))
    (set-time! (-> self board tricky-time))
    (cond
      ((= arg2 'halfpipe)
       (logior! (-> self focus-status) (focus-status halfpipe))
       (target-board-halfpipe-trans)
       )
      (else
        (init-var-jump arg0 arg1 #t #f (-> self control transv) 1.0)
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (set! (-> self control unknown-float36)
              (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
              )
        )
      )
    (set! (-> self control mod-surface) *board-flip-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control dynam gravity-length) 147456.0)
    )
  :exit (behavior ()
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    (set! (-> self board unk-float006) 0.0)
    (set-time! (-> self board tricky-exit-time))
    (let ((v1-10 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-10 command) (sound-command set-param))
      (set! (-> v1-10 id) (-> self board trick-sound-id))
      (set! (-> v1-10 params volume) -4)
      (set! (-> v1-10 auto-time) 24)
      (set! (-> v1-10 auto-from) 2)
      (set! (-> v1-10 params mask) (the-as uint 17))
      (-> v1-10 id)
      )
    (let ((v1-14 (ja-group)))
      (if (and v1-14 (= v1-14 jakb-board-noseflip-ja))
          (sound-play "board-boots")
          )
      )
    ((-> target-board-halfpipe exit))
    )
  :trans (behavior ()
    (target-board-spin-check)
    (cond
      ((= (-> self control unknown-spool-anim00) 'halfpipe)
       (target-board-halfpipe-trans)
       )
      (else
        (set! (-> self control unknown-float36)
              (fmax
                (-> self control unknown-float36)
                (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))) ;; og:preserve-this abutton indexing
                )
              )
        (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (set! (-> v1-0 x) 0.0)
      (set! (-> v1-0 y) 0.0)
      (set! (-> v1-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
      (set! (-> v1-0 w) 1.0)
      (let ((f30-0 (analog-input (the int (* 128.0 (-> v1-0 z))) 0.0 96.0 110.0 1.0)))
        (while (not (or (not (cpad-hold? (-> self control cpad number) l1))
                        (jump-hit-ground-stuck?)
                        (< (target-time-to-ground) (seconds 0.3))
                        )
                    )
          (cond
            ((< f30-0 0.0)
             (add-to-trick-list (-> self board) (board-tricks board-kickspin) 500.0)
             (set! (-> self board trick-sound-id) (sound-play "board-method"))
             (ja-channel-push! 1 (seconds 0.08))
             (ja-no-eval :group! jakb-board-kickspin-a-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek!))
               )
             (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
             (ja-no-eval :group! jakb-board-kickspin-b-ja :num! (seek! max 1.05) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek! max 1.05))
               )
             (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
             (ja-no-eval :group! jakb-board-kickspin-c-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek!))
               )
             )
            ((let ((v1-92 (ja-group)))
               (and v1-92 (= v1-92 jakb-board-nosegrab-loop-ja))
               )
             (ja :num! (loop!))
             )
            ((< 40960.0 (target-height-above-ground))
             (add-to-trick-list (-> self board) (board-tricks board-nosegrab) 500.0)
             (set! (-> self board trick-sound-id) (sound-play "board-nosegrab"))
             (ja-channel-push! 1 (seconds 0.08))
             (ja-no-eval :group! jakb-board-nosegrab-ja :num! (seek!) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek!))
               )
             (ja :group! jakb-board-nosegrab-loop-ja :num! min)
             )
            (else
              (add-to-trick-list (-> self board) (board-tricks board-noseflip) 500.0)
              (set! (-> self board trick-sound-id) (sound-play "board-noseflip"))
              (ja-channel-push! 1 (seconds 0.08))
              (ja-no-eval :group! jakb-board-noseflip-ja :num! (seek! (ja-aframe 20.0 0)) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! (ja-aframe 20.0 0)))
                )
              (goto cfg-40)
              )
            )
          (suspend)
          )
        )
      )
    (label cfg-40)
    (let ((v1-168 (ja-group)))
      (when (and v1-168 (= v1-168 jakb-board-nosegrab-loop-ja))
        (ja-channel-push! 1 (seconds 0.08))
        (ja-no-eval :group! jakb-board-nosegrab-end-ja :num! (seek! max 1.5) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max 1.5))
          )
        )
      )
    (let ((v1-196 (new-stack-vector0))
          (f0-53 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-!
        v1-196
        (-> self control transv)
        (vector-float*! v1-196 (-> self control dynam gravity-normal) f0-53)
        )
      (let* ((f1-5 (vector-length v1-196))
             (f2-2 f1-5)
             )
        (if (< 0.0 f0-53)
            (set! f0-53 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-53)
          (vector-float*! v1-196 v1-196 (/ f1-5 f2-2))
          )
        )
      )
    (go target-board-falling)
    )
  :post target-board-post
  )

(defstate target-board-trickx (target)
  :event (-> target-board-jump event)
  :enter (-> target-board-tricky enter)
  :exit (behavior ()
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    (sound-play "board-boots")
    ((-> target-board-tricky exit))
    )
  :trans (behavior ()
    (target-board-spin-check)
    (when (!= (-> self control unknown-spool-anim00) 'halfpipe)
      (set! (-> self control unknown-float36)
            (fmax
              (-> self control unknown-float36)
              (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))) ;; og:preserve-this abutton indexing
              )
            )
      (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
      )
    (when (jump-hit-ground-stuck?)
      (set-time! (-> self board jump-land-time))
      (go target-board-hit-ground)
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((gp-0 (>= (-> self board unk-float005) 0.0))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 x) 0.0)
      (set! (-> s5-0 y) 0.0)
      (set! (-> s5-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
      (set! (-> s5-0 w) 1.0)
      (let ((f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
            (s4-0 0)
            )
        (while (not (and (or (not (cpad-hold? (-> self control cpad number) r1))
                             (or (= f0-9 0.0) (jump-hit-ground-stuck?) (< (target-time-to-ground) (seconds 0.5)))
                             )
                         (nonzero? s4-0)
                         )
                    )
          (cond
            (gp-0
              (add-to-trick-list (-> self board) (board-tricks board-kickflip) 500.0)
              (set! (-> self board trick-sound-id) (sound-play "board-kickflip"))
              (ja-channel-push! 1 (seconds 0.07))
              (ja-no-eval :group! jakb-board-kickflip-a-ja :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
              (ja-no-eval :group! jakb-board-kickflip-b-ja :num! (seek! max 1.05) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! max 1.05))
                )
              (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
              (ja-no-eval :group! jakb-board-kickflip-c-ja :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              )
            (else
              (add-to-trick-list (-> self board) (board-tricks board-board-spin) 500.0)
              (set! (-> self board trick-sound-id) (sound-play "board-boardspin"))
              (ja-channel-push! 1 (seconds 0.05))
              (ja-no-eval :group! jakb-board-spin-ja :num! (seek! max 0.95) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! max 0.95))
                )
              )
            )
          (+! (-> self board trickx-count) 1)
          (set! f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
          (+! s4-0 1)
          )
        )
      )
    (go target-board-falling)
    )
  :post target-board-post
  )

(defstate target-board-hit-ground (target)
  :event target-board-handler
  :enter (behavior ()
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (if (= (-> self control ground-pat mode) (pat-mode halfpipe))
        (go target-board-turn-to (-> self control transv) (seconds 0.5))
        )
    )
  :exit target-board-exit
  :trans (behavior ()
    (if (and (cpad-hold? (-> self control cpad number) l1)
             (not (logtest? (-> self target-flags) (target-flags prevent-duck)))
             )
        (go target-board-duck-stance)
        )
    ;; og:preserve-this - High FPS Fix
    (when (and (recently-pressed? x)
               (can-jump? 'board)
               )
      (flush-trick-list (-> self board))
      (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
      )
    (if (target-board-smack-surface?)
        0
        )
    )
  :code (behavior ()
    (set! (-> self control mod-surface) *board-walk-mods*)
    (let ((v1-3 (ja-group)))
      (cond
        ((and v1-3 (or (= v1-3 jakb-board-method-end-ja) (= v1-3 jakb-board-nosegrab-end-ja)))
         (ja-no-eval :num! (seek! max 1.5))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-18 (ja-group)))
           (and v1-18 (= v1-18 jakb-board-method-loop-ja))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! jakb-board-method-end-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        ((let ((v1-48 (ja-group)))
           (and v1-48 (= v1-48 jakb-board-nosegrab-loop-ja))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! jakb-board-nosegrab-end-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        )
      )
    (go target-board-stance)
    )
  :post target-board-post
  )

(defstate target-board-turn-to (target)
  :event target-board-handler
  :enter (behavior ((arg0 vector) (arg1 time-frame))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (when (not (or (= (-> self control dynam gravity-length) 245760.0)
                   (not (time-elapsed? (-> self board ride-time) (seconds 0.2)))
                   )
               )
      (let ((v1-11 (new-stack-vector0))
            (f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            )
        0.0
        (vector-! v1-11 (-> self control transv) (vector-float*! v1-11 (-> self control dynam gravity-normal) f0-2))
        (let* ((f1-3 (vector-length v1-11))
               (f2-0 f1-3)
               )
          (if (< f0-2 0.0)
              (set! f0-2 (* 5.0 f0-2))
              )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
            (vector-float*! v1-11 v1-11 (/ f1-3 f2-0))
            )
          )
        )
      )
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *board-turn-to-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control sliding-start-time) arg1)
    (vector-normalize-copy! (-> self control unknown-vector38) arg0 1.0)
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control unknown-vector38)
      (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
      )
    (set! (-> self control turn-lockout-end-time) (+ (current-time) arg1))
    )
  :exit target-board-exit
  :trans (behavior ()
    ;; og:preserve-this - High FPS Fix
    (when (and (recently-pressed? x)
               (can-jump? 'board)
               )
      (flush-trick-list (-> self board))
      (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
      )
    (if (time-elapsed? (-> self state-time) (-> self control sliding-start-time))
        (go target-board-stance)
        )
    (target-board-anim-trans)
    (when (board-on-ground?)
      (let ((gp-0 (-> self board turn-anim-tilt?)))
        (target-board-ground-check)
        (set! (-> self board turn-anim-tilt?) gp-0)
        )
      )
    (set! (-> self board turn-anim-targ) (* 10.0 (-> self board turn-anim-targ)))
    )
  :code (-> target-board-stance code)
  :post target-board-post
  )

(defstate target-board-turn-around (target)
  :event target-board-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self control mod-surface) *turn-around-mods*)
    (set! (-> self control bend-target) 1.0)
    )
  :exit (behavior ()
    (set-forward-vel 0.0)
    (set! (-> self control ctrl-xz-vel) 0.0)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (set! (-> self control bend-target) 0.0)
    (target-board-exit)
    )
  :trans (behavior ()
    ;; og:preserve-this - High FPS Fix
    (when (and (recently-pressed? x)
               (can-jump? 'board)
               )
      (flush-trick-list (-> self board))
      (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
      )
    (target-board-anim-trans)
    (when (board-on-ground?)
      (let ((gp-0 (-> self board turn-anim-tilt?)))
        (target-board-ground-check)
        (set! (-> self board turn-anim-tilt?) gp-0)
        )
      )
    (set! (-> self board turn-anim-targ) (* 10.0 (-> self board turn-anim-targ)))
    )
  :code (behavior ()
    (let ((f30-0 (-> self control ctrl-xz-vel))
          (gp-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control)))
          )
      (ja-channel-push! 1 (seconds 0.04))
      (ja :group! jakb-board-turn-around-ja :num! min)
      (quaternion-rotate-y! (-> self control dir-targ) (-> self control quat-for-control) 32768.0)
      (compute-alignment! (-> self align))
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 1.25))
        (compute-alignment! (-> self align))
        (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
        (set! (-> self control ctrl-xz-vel)
              (* f30-0 (* (/ (-> self clock frames-per-second) (meters 10)) (-> self align delta trans z)))
              )
        (vector-float*! (-> self control transv) gp-0 (-> self control ctrl-xz-vel))
        (let ((v1-31 (new-stack-vector0))
              (f1-2 (vector-dot (-> self control standard-dynamics gravity-normal) (-> self control transv)))
              )
          0.0
          (vector-!
            v1-31
            (-> self control transv)
            (vector-float*! v1-31 (-> self control standard-dynamics gravity-normal) f1-2)
            )
          (let* ((f2-0 (vector-length v1-31))
                 (f0-12 f2-0)
                 (f1-4 (fmax -8192.0 (fmin 8192.0 f1-2)))
                 (f2-1 (fmin 368640.0 f2-0))
                 )
            (vector+!
              (-> self control transv)
              (vector-float*! (-> self control transv) (-> self control standard-dynamics gravity-normal) f1-4)
              (vector-float*! v1-31 v1-31 (/ f2-1 f0-12))
              )
            )
          )
        )
      )
    (remove-exit)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (set! (-> self control bend-target) 0.0)
    (go target-board-stance)
    )
  :post target-board-post
  )

(defstate target-board-ride-edge (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('edge-grab 'push-transv 'push-trans)
       #f
       )
      (('end-mode)
       (case (-> block param 0)
         (('ride)
          (when (-> block param 1)
            (let ((v1-7 (/ (- (current-time) (-> self board ride-start-time)) 300)))
              (if (> v1-7 0)
                  (add-to-trick-list (-> self board) (board-tricks board-rail) (* 100.0 (the float v1-7)))
                  )
              )
            )
          (when (< 32768.0 (-> self control ctrl-xz-vel))
            (forward-up-nopitch->quaternion
              (-> self control dir-targ)
              (-> self control transv)
              (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ))
              )
            (set-quaternion! (-> self control) (-> self control dir-targ))
            )
          (go target-board-turn-to (-> self control transv) (seconds 0.2))
          )
         (('board)
          (go target-board-get-off (process->handle proc) #f)
          )
         )
       )
      (else
        (target-board-handler proc argc message block)
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set-time! (-> self state-time))
    (let ((v1-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-2 command) (sound-command set-param))
      (set! (-> v1-2 id) (-> self board charge-sound-id))
      (set! (-> v1-2 params volume) -4)
      (set! (-> v1-2 auto-time) 24)
      (set! (-> v1-2 auto-from) 2)
      (set! (-> v1-2 params mask) (the-as uint 17))
      (-> v1-2 id)
      )
    (logior! (-> self focus-status) (focus-status rail))
    (logior! (-> self control root-prim prim-core action) (collide-action can-ride))
    (set! (-> self control mod-surface) *board-ride-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((v1-14 (-> self control transv-ctrl)))
      (set! (-> self board ride-speed) (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
      )
    (set! (-> self board ride-lean-targ) 0.0)
    (set! (-> self board ride-lean) 0.0)
    (set! (-> self board ride-leanv) 0.0)
    (set! (-> self board ride-tilt-targ) 0.0)
    (set! (-> self board ride-tilt) 0.0)
    (set! (-> self board ride-tiltv) 0.0)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self board spin-control) 0.0)
    (set! (-> self board flip-control) 0.0)
    (set! (-> self board flip-count) 0)
    (set! (-> self board unk-float005) 0.0)
    (set! (-> self board unk-float006) 0.0)
    (set! (-> self control unknown-word04) (the-as uint #t))
    (set! (-> self control unknown-word04) (the-as uint 1000))
    (target-board-compute-edge)
    (let ((f0-17 (vector-dot (-> self control c-R-w fvec) (-> self control edge-grab-edge-dir))))
      (cond
        ((< 0.7 f0-17)
         (set! (-> self board ride-mode) (the-as uint 0))
         (set! (-> self board ride-rot) 0.0)
         )
        ((< f0-17 -0.7)
         (set! (-> self board ride-mode) (the-as uint 1))
         (set! (-> self board ride-rot) 32768.0)
         )
        (else
          (let ((f0-21 (vector-dot (the-as vector (-> self control c-R-w)) (-> self control edge-grab-edge-dir))))
            (cond
              ((< 0.7 f0-21)
               (set! (-> self board ride-mode) (the-as uint 2))
               (set! (-> self board ride-rot) -16384.0)
               )
              (else
                (set! (-> self board ride-mode) (the-as uint 3))
                (set! (-> self board ride-rot) 16384.0)
                )
              )
            )
          )
        )
      )
    (let ((f0-24 0.0))
      (if arg0
          (set! f0-24 (+ 250.0 f0-24))
          )
      (if (and (!= (-> self board ride-rot-old) -1.0) (!= (-> self board ride-rot) (-> self board ride-rot-old)))
          (set! f0-24 (+ 500.0 f0-24))
          )
      (add-to-trick-list (-> self board) (board-tricks board-rail-jump) f0-24)
      )
    )
  :exit (behavior ()
    (logclear! (-> self control status) (collide-status probe-hit))
    (let ((v1-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-2 command) (sound-command set-param))
      (set! (-> v1-2 id) (-> self board ride-sound-id))
      (set! (-> v1-2 params volume) -4)
      (set! (-> v1-2 auto-time) 24)
      (set! (-> v1-2 auto-from) 2)
      (set! (-> v1-2 params mask) (the-as uint 17))
      (-> v1-2 id)
      )
    ((-> target-board-stance exit))
    (set! (-> self neck flex-blend) 1.0)
    (logclear! (-> self focus-status) (focus-status rail))
    (logclear! (-> self control root-prim prim-core action) (collide-action can-ride))
    (set! (-> self board ride-rot-old) (-> self board ride-rot))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self control trans quad))
      (let ((s5-0 (new 'stack-no-clear 'collide-query)))
        (if (find-ground
              (-> self control)
              s5-0
              (logclear (-> self control root-prim prim-core collide-with) (collide-spec water))
              8192.0
              81920.0
              1024.0
              (the-as process #f)
              )
            (set! (-> self control gspot-pat-surfce) (-> s5-0 best-other-tri pat))
            )
        )
      (if (< (-> self control trans y) (-> self control gspot-pos y))
          (set! (-> gp-0 quad) (-> self control gspot-pos quad))
          )
      (move-to-point!
        (-> self control)
        (vector+! (new 'stack-no-clear 'vector) gp-0 (new 'static 'vector :y 204.8 :w 1.0))
        )
      )
    )
  :trans (behavior ()
    ;; og:preserve-this - High FPS Fix
    (when (and (recently-pressed? x)
               (can-jump? 'board)
               )
      (let ((v1-15 (/ (- (current-time) (-> self board ride-start-time)) 300)))
        (if (> v1-15 0)
            (add-to-trick-list (-> self board) (board-tricks board-rail) (* 100.0 (the float v1-15)))
            )
        )
      (+! (-> self control trans y) 1228.8)
      (go
        target-board-jump
        (-> *TARGET_BOARD-bank* jump-height-min)
        (-> *TARGET_BOARD-bank* jump-height-max)
        (the-as symbol *board-ride-jump-mods*)
        )
      )
    (if (cpad-pressed? (-> self control cpad number) square)
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    (if (-> self control unknown-spool-anim00)
        (set-time! (-> self board ride-button-time))
        )
    (set! (-> self board turn-anim-targ) (* (-> self board ride-lean) (- (-> *TARGET_BOARD-bank* turn-frames))))
    (cond
      ((= (-> self board ride-speed) 0.0)
       (let ((v1-43 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
         (set! (-> v1-43 command) (sound-command set-param))
         (set! (-> v1-43 id) (-> self board ride-sound-id))
         (set! (-> v1-43 params volume) -4)
         (set! (-> v1-43 auto-time) 24)
         (set! (-> v1-43 auto-from) 2)
         (set! (-> v1-43 params mask) (the-as uint 17))
         (-> v1-43 id)
         )
       )
      (else
        (let ((f30-1
                (* (lerp-scale 0.7 1.0 (fabs (-> self board ride-lean)) 0.0 1.0)
                   (lerp-scale 0.8 1.0 (fabs (-> self board ride-speed)) 0.0 (/ (-> self control mod-surface transv-max) 2))
                   )
                )
              (f28-1
                (+ (lerp-scale 0.0 0.05 (fabs (-> self board ride-lean)) 0.0 1.0)
                   (lerp-scale -0.05 0.0 (fabs (-> self board ride-speed)) 0.0 (* 0.3 (-> self control mod-surface transv-max)))
                   )
                )
              )
          (if (!= (-> self control unknown-word04) (-> self control ground-pat material))
              (sound-stop (-> self board ride-sound-id))
              )
          (let* ((v1-65 (-> self control ground-pat material))
                 (name (if (or (= v1-65 (pat-material wood)) (= v1-65 (pat-material crwood)) (= v1-65 (pat-material hdwood)))
                           (the-as sound-name (static-sound-name "board-rail-wood"))
                           (the-as sound-name (static-sound-name "board-rail-mtl"))
                           )
                       )
                 )
            (sound-play-by-name
              name
              (-> self board ride-sound-id)
              (the int (* 1024.0 f30-1))
              (the int (* 1524.0 f28-1))
              0
              (sound-group)
              #t
              )
            )
          )
        (set! (-> self control unknown-word04) (the-as uint (-> self control ground-pat material)))
        )
      )
    (when (< 4096.0 (-> self board ride-speed))
      (let ((gp-1 (vector+float*! (new 'stack-no-clear 'vector) (-> self control trans) (-> self board ride-dir) -4096.0))
            )
        (set! (-> *part-id-table* 670 init-specs 1 initial-valuef)
              (lerp-scale 0.1 2.0 (fabs (-> self board ride-speed)) 0.0 (* 0.3 (-> self control mod-surface transv-max)))
              )
        (launch-particles (-> *part-id-table* 670) gp-1)
        )
      )
    )
  :code (behavior ((arg0 symbol))
    (let* ((v1-1 (-> self board ride-mode))
           (gp-0 (cond
                   ((zero? v1-1)
                    jakb-board-ride-turn-front-ja
                    )
                   ((= v1-1 1)
                    jakb-board-ride-turn-back-ja
                    )
                   ((= v1-1 2)
                    jakb-board-ride-turn-left-ja
                    )
                   ((= v1-1 3)
                    jakb-board-ride-turn-right-ja
                    )
                   (else
                     (the-as art-element #f)
                     )
                   )
                 )
           )
      (when (!= (ja-group) gp-0)
        (ja-channel-push! 1 (seconds 0.1))
        (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim gp-0))
        )
      )
    (until #f
      (ja :num-func num-func-identity
          :frame-num (ja-aframe
            (fmax -5.0 (fmin 5.0 (+ (* 3.0 (-> self board ride-lean))
                                    (* 0.5 (sin (* 145.63556 (the float (- (current-time) (-> self state-time))))))
                                    )
                             )
                  )
            0
            )
          )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (target-board-ride-post)
    )
  )

(defstate target-board-grenade (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('target)
       (handle->process (-> self control unknown-handle02))
       )
      (else
        (target-board-handler proc argc message block)
        )
      )
    )
  :enter (behavior ((arg0 handle))
    (logior! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self control unknown-handle02) arg0)
    (set-time! (-> self state-time))
    (logior! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (set! (-> self control mod-surface) *board-halfpipe-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((v1-12 (new-stack-vector0))
          (f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-12 (-> self control transv) (vector-float*! v1-12 (-> self control dynam gravity-normal) f0-1))
      (let* ((f1-2 (vector-length v1-12))
             (f2-0 f1-2)
             )
        (if (and (!= f1-2 0.0) (< 2.0 (/ f0-1 f1-2)))
            (set! f1-2 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-1)
          (vector-float*! v1-12 v1-12 (/ f1-2 f2-0))
          )
        )
      )
    )
  :exit (behavior ()
    (send-event (handle->process (-> self control unknown-handle02)) 'exit)
    ((-> target-board-halfpipe exit))
    )
  :trans (behavior ()
    (set-time! (-> self board halfpipe-time))
    (if (= (-> self control gspot-pat-surfce mode) (pat-mode halfpipe))
        (set-time! (-> self board halfpipe-gspot-time))
        )
    (if (not (time-elapsed? (-> self state-time) (seconds 1)))
        (vector+float*!
          (-> self control transv)
          (-> self control transv)
          (-> self control dynam gravity-normal)
          (* 122880.0 (seconds-per-frame))
          )
        )
    (when (jump-hit-ground-stuck?)
      (vector-float*! (-> self control transv) (-> self control transv) 1.5)
      (go target-board-turn-to (-> self control transv) (seconds 0.5))
      )
    (when (time-elapsed? (-> self board halfpipe-gspot-time) (seconds 0.5))
      (+! (-> self control transv x) (* 20480.0 (-> self control edge-grab-across-edge-dir x)))
      (+! (-> self control transv z) (* 20480.0 (-> self control edge-grab-across-edge-dir z)))
      (go target-board-stance)
      )
    )
  :code (behavior ((arg0 handle))
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! jakb-board-grenade-ja :num! (seek! (ja-aframe 19.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 19.0 0)))
      )
    (let ((a1-5 (joint-node jakb-lod0-jg extra))
          (gp-2 (new 'stack-no-clear 'projectile-init-by-other-params))
          )
      (let ((a0-7 (handle->process arg0)))
        (set! (-> gp-2 ent) (if a0-7
                                (-> a0-7 entity)
                                )
              )
        )
      (set! (-> gp-2 charge) 0.1)
      (set! (-> gp-2 options) (projectile-options))
      (logclear! (-> gp-2 options) (projectile-options po14 po15 po16))
      (set! (-> gp-2 notify-handle) (the-as handle #f))
      (set! (-> gp-2 owner-handle) (the-as handle #f))
      (set! (-> gp-2 target-handle) (the-as handle #f))
      (set! (-> gp-2 target-pos quad) (the-as uint128 0))
      (set! (-> gp-2 ignore-handle) (process->handle self))
      (let* ((v1-27 *game-info*)
             (a0-14 (+ (-> v1-27 attack-id) 1))
             )
        (set! (-> v1-27 attack-id) a0-14)
        (set! (-> gp-2 attack-id) a0-14)
        )
      (set! (-> gp-2 timeout) (seconds 4))
      (vector<-cspace! (-> gp-2 pos) a1-5)
      (set! (-> gp-2 vel quad) (-> *zero-vector* quad))
      (spawn-projectile grenade gp-2 self *default-dead-pool*)
      )
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (sleep-code)
    )
  :post target-board-post
  )

(defstate target-board-get-on (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack 'attack-or-shove 'attack-invinc)
       (target-attacked
         message
         (the-as attack-info (-> block param 1))
         proc
         (the-as touching-shapes-entry (-> block param 0))
         target-hit
         )
       )
      (else
        (target-generic-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self board shock-offsetv) 0.0)
    (set-time! (-> self state-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control mod-surface) *board-jump-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((a0-5 (target-time-to-ground)))
      (cond
        ((logtest? (water-flag touch-water) (-> self water flags))
         (let ((v1-10 (new-stack-vector0)))
           (let ((f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-10 (-> self control transv) (vector-float*! v1-10 (-> self control dynam gravity-normal) f0-2))
             )
           (let* ((f0-3 (vector-length v1-10))
                  (f1-1 f0-3)
                  (f2-2
                    (+ (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                       (* 0.33 (-> self control dynam gravity-length))
                       )
                    )
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
               (vector-float*! v1-10 v1-10 (/ f0-3 f1-1))
               )
             )
           )
         (set! (-> self control unknown-word04) (the-as uint #t))
         )
        ((< a0-5 (seconds 0.25))
         (let ((v1-12 (new-stack-vector0)))
           (let ((f0-6 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-12 (-> self control transv) (vector-float*! v1-12 (-> self control dynam gravity-normal) f0-6))
             )
           (let* ((f0-7 (vector-length v1-12))
                  (f1-3 f0-7)
                  (f2-5
                    (+ (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                       (* 0.0016666667 (the float (- (seconds 0.66) a0-5)) (-> self control dynam gravity-length))
                       )
                    )
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-5)
               (vector-float*! v1-12 v1-12 (/ f0-7 f1-3))
               )
             )
           )
         (set! (-> self control unknown-word04) (the-as uint #t))
         )
        (else
          (let ((v1-14 (new-stack-vector0)))
            (let ((f0-10 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
              0.0
              (vector-! v1-14 (-> self control transv) (vector-float*! v1-14 (-> self control dynam gravity-normal) f0-10))
              )
            (let* ((f0-11 (vector-length v1-14))
                   (f1-5 f0-11)
                   (f2-7 (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))))
                   )
              (vector+!
                (-> self control transv)
                (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-7)
                (vector-float*! v1-14 v1-14 (/ f0-11 f1-5))
                )
              )
            )
          (set! (-> self control unknown-word04) (the-as uint #f))
          )
        )
      )
    (let ((v1-17 (new-stack-vector0))
          (f0-14 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-17 (-> self control transv) (vector-float*! v1-17 (-> self control dynam gravity-normal) f0-14))
      (let* ((f2-8 (vector-length v1-17))
             (f1-8 f2-8)
             )
        (if (< 81920.0 f2-8)
            (set! f2-8 81920.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-14)
          (vector-float*! v1-17 v1-17 (/ f2-8 f1-8))
          )
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :exit target-board-exit
  :code (behavior ()
    (send-event (ppointer->process (-> self board board)) 'open)
    (ja-channel-push! 1 (the-as time-frame (if (-> self control unknown-spool-anim00)
                                               9
                                               60
                                               )
                                )
                      )
    (let ((f30-1 (if (-> self control unknown-spool-anim00)
                     1.25
                     (fmax 1.0 (fmin 2.0 (/ 249.99 (the float (target-time-to-ground)))))
                     )
                 )
          )
      (ja-no-eval :group! jakb-board-get-on-ja :num! (seek! max f30-1) :frame-num 0.0)
      (until (ja-done? 0)
        (when (logtest? (-> self control status) (collide-status on-surface))
          (set! (-> self board turn-anim-duck-vel) 0.0)
          (goto cfg-19)
          )
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (set! (-> self board turn-anim-duck-vel) 15.0)
    (while (not (jump-hit-ground-stuck?))
      (suspend)
      )
    (label cfg-19)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    (logior! (-> self control status) (collide-status on-surface))
    (go target-board-hit-ground)
    )
  :post target-board-post
  )

(defstate target-board-get-off (target)
  :event (-> target-board-get-on event)
  :enter (behavior ((arg0 handle) (arg1 symbol))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self board shock-offsetv) 0.0)
    (set-time! (-> self state-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control mod-surface) (new 'static 'surface
                                          :name 'jump
                                          :turnv 131072.0
                                          :turnvf 30.0
                                          :turnvv 18204.445
                                          :turnvvf 30.0
                                          :tiltv 131072.0
                                          :tiltvf 30.0
                                          :tiltvv 262144.0
                                          :tiltvvf 15.0
                                          :transv-max 65536.0
                                          :target-speed 65536.0
                                          :seek0 0.3
                                          :seek90 0.3
                                          :seek180 0.3
                                          :fric 0.05
                                          :nonlin-fric-dist 1.0
                                          :slip-factor 1.0
                                          :slide-factor 1.0
                                          :slope-up-factor 1.0
                                          :slope-down-factor 1.0
                                          :slope-slip-angle 1.0
                                          :impact-fric 1.0
                                          :bend-factor 1.0
                                          :bend-speed 1.0
                                          :alignv 1.0
                                          :slope-up-traction 1.0
                                          :align-speed 1.0
                                          :mode 'air
                                          :flags (surface-flag check-edge air)
                                          )
          )
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (let ((a0-6 (target-time-to-ground)))
      (cond
        ((< a0-6 (seconds 0.207))
         (let ((v1-12 (new-stack-vector0)))
           (let ((f0-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-12 (-> self control transv) (vector-float*! v1-12 (-> self control dynam gravity-normal) f0-3))
             )
           (let* ((f0-4 (vector-length v1-12))
                  (f1-1 f0-4)
                  (f2-2
                    (+ (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                       (* 0.0016666667 (the float (- (seconds 0.66) a0-6)) (-> self control dynam gravity-length))
                       )
                    )
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
               (vector-float*! v1-12 v1-12 (/ f0-4 f1-1))
               )
             )
           )
         (set! (-> self control unknown-word04) (the-as uint #t))
         )
        (else
          (let ((v1-14 (new-stack-vector0)))
            (let ((f0-7 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
              0.0
              (vector-! v1-14 (-> self control transv) (vector-float*! v1-14 (-> self control dynam gravity-normal) f0-7))
              )
            (let* ((f0-8 (vector-length v1-14))
                   (f1-3 f0-8)
                   (f2-4 (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))))
                   )
              (vector+!
                (-> self control transv)
                (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-4)
                (vector-float*! v1-14 v1-14 (/ f0-8 f1-3))
                )
              )
            )
          (set! (-> self control unknown-word04) (the-as uint #f))
          )
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    )
  :exit target-board-exit
  :code (behavior ((arg0 handle) (arg1 symbol))
    (local-vars (v1-117 symbol) (a0-36 int))
    (let ((f30-0 1.5151515))
      (let ((v1-1 arg1))
        (cond
          ((= v1-1 'hit)
           (ja-channel-push! 1 (seconds 0.1))
           (ja-no-eval :group! jakb-board-hit-get-off-ja :num! (seek! (ja-aframe 24.0 0) 2.5) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek! (ja-aframe 24.0 0) 2.5))
             )
           )
          ((-> self control unknown-spool-anim00)
           (ja-channel-push! 1 (seconds 0.1))
           (ja-no-eval :group! jakb-board-get-off-pre-ja :num! (seek! max f30-0) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek! max f30-0))
             )
           (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
           (ja-no-eval :group! jakb-board-get-off-ja :num! (seek! (ja-aframe 24.0 0) f30-0) :frame-num 0.0)
           (until (ja-done? 0)
             (if (and (jump-hit-ground-stuck?) (>= (ja-aframe-num 0) 14.0))
                 (go target-falling #f)
                 )
             (suspend)
             (ja :num! (seek! (ja-aframe 24.0 0) f30-0))
             )
           )
          (else
            (set! f30-0 (fmax 0.5 (fmin 2.0 (/ 150.0 (the float (target-time-to-ground))))))
            (ja-channel-push! 1 (seconds 0.1))
            (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
            (ja-no-eval :group! jakb-board-get-off-ja
                        :num! (seek! (ja-aframe 24.0 0) f30-0)
                        :frame-num (ja-aframe 11.0 0)
                        )
            (until (ja-done? 0)
              (if (and (jump-hit-ground-stuck?) (>= (ja-aframe-num 0) 14.0))
                  (go target-falling #f)
                  )
              (suspend)
              (ja :num! (seek! (ja-aframe 24.0 0) f30-0))
              )
            )
          )
        )
      (send-event (ppointer->process (-> self board board)) 'close)
      (logclear! (-> self focus-status) (focus-status board))
      (set! (-> self control pat-ignore-mask)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :board #x1)
            )
      (ja-no-eval :num! (seek! max f30-0))
      )
    (while (let ((t9-36 ja-done?))
             (set! a0-36 0)
             (not (t9-36 a0-36))
             )
      (if (jump-hit-ground-stuck?)
          (go target-falling #f)
          )
      (suspend)
      (ja-eval)
      )
    (set! (-> self board turn-anim-duck-vel) 15.0)
    (if (and (board-on-ground?)
             (let ((v1-115 #x100000))
               (set! a0-36 (the-as int (-> self water flags)))
               (not (or (logtest? v1-115 (the-as water-flag a0-36))
                        (begin
                          (let ((v1-118 #t))
                            (set! a0-36 (the-as int (logand (-> self control status) (collide-status on-water))))
                            (set! a0-36 a0-36)
                            (cmove-#f-zero v1-117 (the-as collide-status a0-36) v1-118)
                            )
                          v1-117
                          )
                        )
                    )
               )
             )
        (go target-hit-ground (the-as symbol a0-36))
        (go target-falling (if (= arg1 'hit)
                               'hit
                               )
            )
        )
    )
  :post (behavior ()
    (set! (-> self control bend-speed) 0.0)
    (set! (-> self control bend-target) 0.0)
    (vector-seek! (-> self control draw-offset) *null-vector* (* 16384.0 (seconds-per-frame)))
    (target-post)
    (target-board-effect)
    )
  )

(defstate target-board-grab (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (cond
      ((and (= message 'query) (= (-> block param 0) 'mode))
       (-> self state name)
       )
      (else
        (case message
          (('end-mode)
           (case (-> block param 0)
             (('grab)
              (go target-board-stance)
              )
             (('board)
              (go target-grab 'stance)
              )
             )
           )
          (('clone-anim)
           (go target-board-clone-anim (process->handle (the-as process (-> block param 0))))
           )
          (('change-mode)
           (case (-> block param 0)
             (('normal)
              (go target-grab 'stance)
              )
             )
           )
          (else
            (target-generic-event-handler proc argc message block)
            )
          )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self target-flags) (target-flags tf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self board stick-off) #t)
    (let ((v1-9 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-9 command) (sound-command set-param))
      (set! (-> v1-9 id) (-> self board charge-sound-id))
      (set! (-> v1-9 params volume) -4)
      (set! (-> v1-9 auto-time) 24)
      (set! (-> v1-9 auto-from) 2)
      (set! (-> v1-9 params mask) (the-as uint 17))
      (-> v1-9 id)
      )
    )
  :exit (behavior ()
    (set! (-> self board stick-off) #f)
    (logclear! (-> self target-flags) (target-flags tf2))
    (logclear! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self water flags) (water-flag jump-out))
    (target-board-exit)
    )
  :code (behavior ((arg0 symbol))
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 jakb-board-stance-ja)))
        (ja-channel-push! 1 (seconds 0.1))
        (ja :group! jakb-board-stance-ja :num! (identity (ja-aframe 0.0 0)))
        )
      )
    (until #f
      (set-forward-vel 0.0)
      (suspend)
      )
    #f
    )
  :post target-board-post
  )

(defstate target-board-clone-anim (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'trans) (= (-> block param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-board-grab event) proc argc message block)
    )
  :enter (-> target-clone-anim enter)
  :exit (behavior ()
    (set! (-> self control draw-offset y) (the-as float (-> self control unknown-word04)))
    (set! (-> self control cspace-offset y) (-> self control draw-offset y))
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    ((-> target-clone-anim exit))
    ((-> target-board-start exit))
    (vector-reset! (-> self control transv))
    )
  :code (behavior ((arg0 handle))
    (set! (-> self control unknown-word04) (the-as uint (-> self control draw-offset y)))
    (set! (-> self control draw-offset y) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
    (clone-anim arg0 #t "")
    (go target-board-stance)
    )
  :post target-no-ja-move-post
  )

(defstate target-board-hit (target)
  :event target-board-handler
  :exit (behavior ()
    (when (not (and (-> self next-state)
                    (let ((v1-3 (-> self next-state name)))
                      (or (= v1-3 'target-death) (= v1-3 'target-board-get-off) (= v1-3 'target-board-hit))
                      )
                    )
               )
      (logclear! (-> self focus-status) (focus-status dead hit))
      (logclear! (-> self target-flags) (target-flags disable-attacks))
      )
    (let ((gp-1 (focus-test? self hit)))
      (target-exit)
      (if gp-1
          (logior! (-> self focus-status) (focus-status hit))
          )
      )
    (logior! (-> self target-flags) (target-flags lleg-no-ik rleg-no-ik))
    (target-board-exit)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (set-time! (-> self control time-of-last-debug-heal))
        (pickup-collectable! (-> self fact) (pickup-type health) 100.0 (the-as handle #f))
        (go target-board-stance)
        )
      )
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flag jump-out))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (let ((v1-4 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-4 command) (sound-command set-param))
      (set! (-> v1-4 id) (-> self board charge-sound-id))
      (set! (-> v1-4 params volume) -4)
      (set! (-> v1-4 auto-time) 24)
      (set! (-> v1-4 auto-from) 2)
      (set! (-> v1-4 params mask) (the-as uint 17))
      (-> v1-4 id)
      )
    (set-time! (-> self state-time))
    (let ((gp-0 (-> self attack-info)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((v1-8 gp-0))
          (set! (-> v1-8 attacker) (the-as handle #f))
          (set! (-> v1-8 mode) 'generic)
          (set! (-> v1-8 shove-back) 6144.0)
          (set! (-> v1-8 shove-up) 4915.2)
          (set! (-> v1-8 angle) #f)
          (set! (-> v1-8 trans quad) (-> self control trans quad))
          (set! (-> v1-8 control) 0.0)
          (set! (-> v1-8 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
          (set! (-> v1-8 speed) 1.0)
          (set! (-> v1-8 damage) (-> *FACT-bank* health-default-inc))
          (set! (-> v1-8 knock) (knocked-type none))
          )
        (case arg0
          (('shove)
           (let ((v1-11 gp-0))
             (set! (-> v1-11 shove-back) (-> *TARGET-bank* smack-surface-dist))
             (set! (-> v1-11 shove-up) (-> *TARGET-bank* smack-surface-height))
             (set! (-> v1-11 angle) 'shove)
             )
           )
          )
        (combine! gp-0 arg1 self)
        (when (not (logtest? (-> gp-0 mask) (attack-mask vector)))
          (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-for-control))
          (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
          (set! (-> gp-0 vector y) (-> gp-0 shove-up))
          )
        (set! (-> s5-0 quad) (-> gp-0 vector quad))
        (let ((f0-12 (vector-dot
                       (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                       )
                     )
              )
          (if (not (-> self attack-info angle))
              (set! (-> self attack-info angle) (if (>= 0.0 f0-12)
                                                    'front
                                                    'back
                                                    )
                    )
              )
          )
        (cond
          ((= arg0 'attack)
           (logior! (-> self focus-status) (focus-status hit))
           (set-time! (-> self game hit-time))
           (case (-> gp-0 mode)
             (('endlessfall)
              (cond
                ((= (-> self game mode) 'debug)
                 (let ((s4-1 (new-stack-vector0)))
                   (set! (-> s4-1 quad) (-> self control last-trans-on-ground quad))
                   (ja-channel-set! 0)
                   (suspend-for (seconds 1)
                     )
                   (move-to-point! (-> self control) s4-1)
                   )
                 (set! (-> self control camera-pos quad) (-> self control trans quad))
                 (send-event *camera* 'teleport)
                 (go target-stance)
                 )
                (else
                  (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
                  (go target-death (-> gp-0 mode))
                  )
                )
              )
             (('drown-death
                'sharkey
                'lava
                'fry
                'slime
                'dark-eco-pool
                'melt
                'instant-death
                'crush
                'death
                'grenade
                'big-explosion
                'bot
                'tentacle
                )
              (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
              (if (= (-> self game mode) 'play)
                  (go target-death (-> gp-0 mode))
                  )
              )
             (('death)
              (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
              )
             (else
               (pickup-collectable! (-> self fact) (pickup-type health) (- (-> gp-0 damage)) (the-as handle #f))
               )
             )
           (target-hit-effect gp-0)
           )
          (else
            (case (-> gp-0 mode)
              (('burn 'burnup)
               (sound-play "get-burned")
               )
              )
            )
          )
        (when (not (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health))))
          (when (= (-> gp-0 knock) (knocked-type knocked-off))
            (set-quaternion! (-> self control) (-> self control dir-targ))
            (set-forward-vel (* -3.0 (-> gp-0 shove-back)))
            (go target-board-get-off (the-as handle #f) 'hit)
            )
          (if (= (-> gp-0 control) 1.0)
              (go target-board-jump (-> gp-0 shove-up) (-> gp-0 shove-up) 'hit)
              )
          )
        (set! (-> self control mod-surface) *smack-mods*)
        (let ((v1-90 (ja-group)))
          (when (not (and v1-90 (or (= v1-90 jakb-board-hit-ja) (= v1-90 jakb-board-hit-forward-ja))))
            (ja-channel-push! 1 (seconds 0.075))
            (if (or (= (-> gp-0 mode) 'shock) (= (-> gp-0 mode) 'shock-red) (= (-> gp-0 mode) 'shockup))
                (ja :group! jakb-board-hit-elec-ja :num! min)
                (ja :group! jakb-board-hit-ja :num! min)
                )
            )
          )
        (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-board-falling-anim-trans (-> gp-0 speed))
        )
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
          (go target-death (-> gp-0 mode))
          )
      )
    enter-state
    (go target-board-hit-ground)
    )
  :post (behavior ()
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (vector-float*!
      (-> self control dynam gravity)
      (-> self control dynam gravity-normal)
      (the-as float (-> self control dynam gravity-length))
      )
    (target-post)
    (target-board-effect)
    (case (-> self attack-info mode)
      (('shock 'shock-red 'shockup)
       (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
         (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
         (send-event self 'color-effect 'shock (seconds 0.2))
         (process-drawable-shock-effect
           self
           (-> *lightning-spec-id-table* 1)
           lightning-probe-callback
           (-> *part-id-table* 160)
           0
           0
           40960.0
           )
         )
       )
      )
    (target-board-joint-points)
    )
  )
