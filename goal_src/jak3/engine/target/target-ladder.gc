;;-*-Lisp-*-
(in-package goal)

;; name: target-ladder.gc
;; name in dgo: target-ladder
;; dgos: HALFPIPE, SED, WWD, VOCA

;; +++ladder-options
(defenum ladder-options
  :type uint32
  :bitfield #t
  (lo0 0)
  (lo1 1)
  (lo2 2)
  (nodraw 3)
  )
;; ---ladder-options


;; DECOMP BEGINS

(deftype ladder-info (basic)
  ((ladder     handle)
   (flip       degrees)
   (interp     float)
   (start-mat  matrix  :inline)
   )
  )


(let ((v1-2 (copy *walk-mods* 'global)))
  (set! (-> v1-2 name) 'ladder)
  (set! (-> v1-2 flags) (surface-flag turn-when-centered turn-to-alt gun-hide))
  (set! (-> v1-2 bend-factor) 1.0)
  (set! (-> v1-2 bend-speed) 1.0)
  (set! (-> v1-2 tiltv) 262144.0)
  (set! (-> v1-2 tiltvf) 30.0)
  (set! (-> v1-2 tiltvv) 1048576.0)
  (set! (-> v1-2 tiltvvf) 30.0)
  (set! *ladder-mods* v1-2)
  )

(defstate target-ladder (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'query) (= (-> block param 0) 'mode))
        'target-ladder
        (target-standard-event-handler proc argc message block)
        )
    )
  :exit (behavior ()
    (when (not (and (-> self next-state) (begin (-> self next-state name) (state-type? (-> self next-state) 'target-ladder)))
               )
      (target-collide-set! 'normal 0.0)
      (logclear! (-> self focus-status) (focus-status pole))
      (set! (-> self ladder ladder) (the-as handle #f))
      (logclear! (-> self target-flags) (target-flags lleg-still rleg-still lleg-no-ik rleg-no-ik))
      )
    )
  :trans (behavior ()
    (local-vars (gp-0 symbol))
    (b! (not (cpad-pressed? (-> self control cpad number) x)) cfg-2 :delay (empty-form))
    (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons x))
    (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons x))
    (go target-ladder-jump-off)
    (b! #t cfg-41 :delay (nop!))
    (label cfg-2)
    (cond
      ((and (cpad-hold? (-> self control cpad number) circle)
            (not (and (-> self next-state) (let ((v1-26 (-> self next-state name)))
                                             (or (= v1-26 'target-ladder-slide-down) (= v1-26 'target-ladder-switch))
                                             )
                      )
                 )
            (!= (send-event (handle->process (-> self ladder ladder)) 'move 0) 0.0)
            )
       (go target-ladder-slide-down)
       )
      ((and (cpad-pressed? (-> self control cpad number) square)
            (not (and (-> self next-state) (let ((v1-49 (-> self next-state name)))
                                             (or (= v1-49 'target-ladder-slide-down) (= v1-49 'target-ladder-switch))
                                             )
                      )
                 )
            (begin
              (let ((gp-1 #t)
                    (a1-7 (new 'stack-no-clear 'event-message-block))
                    )
                (set! (-> a1-7 from) (process->ppointer self))
                (set! (-> a1-7 num-params) 0)
                (set! (-> a1-7 message) 'options)
                (let ((v1-57
                        (the-as int (logand (the-as int (send-event-function (handle->process (-> self ladder ladder)) a1-7)) 3))
                        )
                      )
                  (cmove-#f-nonzero gp-0 v1-57 gp-1)
                  )
                )
              gp-0
              )
            )
       (go target-ladder-switch)
       )
      )
    (label cfg-41)
    )
  :code nothing
  :post (behavior ()
    (let ((gp-0 (handle->process (-> self ladder ladder))))
      (seek! (-> self ladder interp) 1.0 (* 10.0 (seconds-per-frame)))
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer self))
        (set! (-> a1-2 num-params) 1)
        (set! (-> a1-2 message) 'matrix)
        (set! (-> a1-2 param 0) (the-as uint (new 'stack-no-clear 'matrix)))
        (let ((gp-1 (the-as matrix (send-event-function gp-0 a1-2))))
          (if (= (-> self ladder flip) -1.0)
              (set! (-> self ladder flip)
                    (if (< (vector-dot (-> gp-1 fvec) (vector-! (new 'stack-no-clear 'vector) (-> gp-1 trans) (-> self control trans)))
                           0.0
                           )
                        32768.0
                        0.0
                        )
                    )
              )
          (cond
            (gp-1
              (set! (-> self control bend-amount) 1.0)
              (let ((s4-0 (new 'stack-no-clear 'matrix)))
                (let ((a1-5 (matrix-rotate-y! (new 'stack-no-clear 'matrix) (-> self ladder flip))))
                  (matrix*! s4-0 a1-5 gp-1)
                  )
                (let ((s5-0 (new 'static 'vector :w 1.0))
                      (gp-2 (matrix-lerp! (new 'stack-no-clear 'matrix) (-> self ladder start-mat) s4-0 (-> self ladder interp)))
                      )
                  (set! (-> s5-0 z) (* -1597.44 (-> self ladder interp)))
                  (vector-matrix*! (-> self control trans) s5-0 gp-2)
                  (set! (-> self control turn-to-alt-heading quad) (-> gp-2 fvec quad))
                  (set! (-> self control local-normal quad) (-> gp-2 uvec quad))
                  (set! (-> self control bent-gravity-normal quad) (-> gp-2 uvec quad))
                  (set! (-> self control gspot-normal quad) (-> gp-2 uvec quad))
                  )
                )
              (update-transforms (-> self control))
              )
            (else
              (go target-falling #f)
              )
            )
          )
        )
      )
    (target-no-move-post)
    )
  )

(defstate target-ladder-start (target)
  :parent target-ladder
  :enter (behavior ((arg0 handle))
    (when (zero? (-> self ladder))
      (set! (-> self ladder) (new 'process 'ladder-info))
      (set! (-> self ladder ladder) (the-as handle #f))
      )
    (set! (-> self ladder ladder) arg0)
    (set! (-> self ladder flip) -1.0)
    (set! (-> self ladder interp) 0.0)
    (let* ((v1-10 (-> self ladder start-mat))
           (a3-0 (-> self node-list data 0 bone transform))
           (a0-4 (-> a3-0 rvec quad))
           (a1-1 (-> a3-0 uvec quad))
           (a2-0 (-> a3-0 fvec quad))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-10 rvec quad) a0-4)
      (set! (-> v1-10 uvec quad) a1-1)
      (set! (-> v1-10 fvec quad) a2-0)
      (set! (-> v1-10 trans quad) a3-1)
      )
    (set! (-> self control bend-target) 1.0)
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *ladder-mods*)
    (logior! (-> self target-flags) (target-flags lleg-still rleg-still lleg-no-ik rleg-no-ik))
    (target-collide-set! 'pole 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    )
  :code (behavior ((arg0 handle))
    (cond
      ((time-elapsed? (-> self control last-time-on-surface) (seconds 0.05))
       (ja-channel-push! 1 (seconds 0.065))
       (ja-no-eval :group! jakb-ladder-jump-on-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      (else
        (ja-channel-push! 1 (seconds 0.25))
        (ja-no-eval :group! jakb-ladder-get-on-ja :num! (seek! max 4.0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max 4.0))
          )
        )
      )
    (go target-ladder-stance)
    )
  :post (behavior ()
    (send-event (handle->process (-> self ladder ladder)) 'stance)
    (let ((v1-8 (-> self state parent)))
      (when v1-8
        (let ((t9-1 (-> v1-8 post)))
          (if t9-1
              ((the-as (function none) t9-1))
              )
          )
        )
      )
    )
  )

(defstate target-ladder-stance (target)
  :parent target-ladder
  :trans (behavior ()
    (let ((a0-0 (-> self state parent)))
      (when a0-0
        (let ((t9-0 (-> a0-0 trans)))
          (if t9-0
              (t9-0)
              )
          )
        )
      )
    (if (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
        (go target-ladder-walk-up)
        )
    (can-play-stance-amibent?)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (or (= v1-2 jakb-ladder-up-to-stance-ja) (= v1-2 jakb-ladder-slide-stop-ja)))
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-16 (ja-group)))
           (and v1-16 (or (= v1-16 jakb-ladder-slide-start-ja) (= v1-16 jakb-ladder-slide-loop-ja)))
           )
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! jakb-ladder-slide-stop-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         )
        (else
          (let ((v1-45 (ja-group)))
            (cond
              ((and v1-45 (or (= v1-45 jakb-ladder-stance-to-up-ja) (= v1-45 jakb-ladder-stance-to-down-ja)))
               (ja-no-eval :num! (seek! 0.0))
               (while (not (ja-done? 0))
                 (suspend)
                 (ja-eval)
                 )
               )
              (else
                (ja-channel-push! 1 (seconds 0.25))
                )
              )
            )
          )
        )
      )
    (until #f
      (ja-no-eval :group! jakb-ladder-stance-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (-> target-ladder-start post)
  )

(defstate target-ladder-walk-up (target)
  :parent target-ladder
  :trans (behavior ()
    (local-vars (gp-0 symbol))
    (let ((a0-0 (-> self state parent)))
      (when a0-0
        (let ((t9-0 (-> a0-0 trans)))
          (if t9-0
              (t9-0)
              )
          )
        )
      )
    (cond
      ((and (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
            (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-0 from) (process->ppointer self))
              (set! (-> a1-0 num-params) 1)
              (set! (-> a1-0 message) 'move)
              (set! (-> a1-0 param 0) (the-as uint 0))
              (let* ((f0-1 (the-as float (send-event-function (handle->process (-> self ladder ladder)) a1-0)))
                     (f0-2 (- f0-1 (* (the float (the int (/ f0-1 0.5))) 0.5)))
                     )
                (or (< 0.4 f0-2) (< f0-2 0.01))
                )
              )
            )
       (go target-ladder-stance)
       )
      ((= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
       )
      ((< (the-as uint 128) (-> self control cpad lefty))
       (go target-ladder-walk-down)
       )
      ((let ((a1-1 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-1 from) (process->ppointer self))
         (set! (-> a1-1 num-params) 1)
         (set! (-> a1-1 message) 'pos)
         (set! (-> a1-1 param 0) (the-as uint (new 'stack-no-clear 'vector)))
         (and (= (send-event-function (handle->process (-> self ladder ladder)) a1-1) 1.0)
              (begin
                (let ((gp-1 #t)
                      (a1-2 (new 'stack-no-clear 'event-message-block))
                      )
                  (set! (-> a1-2 from) (process->ppointer self))
                  (set! (-> a1-2 num-params) 0)
                  (set! (-> a1-2 message) 'options)
                  (let ((v1-56
                          (the-as int (logand (the-as int (send-event-function (handle->process (-> self ladder ladder)) a1-2)) 4))
                          )
                        )
                    (cmove-#f-nonzero gp-0 v1-56 gp-1)
                    )
                  )
                gp-0
                )
              )
         )
       (go
         target-edge-grab-jump
         (-> *TARGET-bank* edge-grab-jump-height-min)
         (-> *TARGET-bank* edge-grab-jump-height-max)
         'ladder
         )
       )
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 jakb-ladder-up-to-stance-ja))
         (ja-no-eval :num! (seek! 0.0))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-13 (ja-group)))
           (and v1-13 (= v1-13 jakb-ladder-stance-to-up-ja))
           )
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! jakb-ladder-up-ja)
    (until #f
      (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-3 from) (process->ppointer self))
        (set! (-> a1-3 num-params) 1)
        (set! (-> a1-3 message) 'move)
        (set! (-> a1-3 param 0)
              (the-as
                uint
                (* (-> *TARGET-bank* ladder-walk-up-speed) (fmax 0.4 (-> self control cpad stick0-speed)) (seconds-per-frame))
                )
              )
        (let ((f0-8 (the-as float (send-event-function (handle->process (-> self ladder ladder)) a1-3)))
              (a0-20 (-> self skel root-channel 0))
              )
          (let ((f0-9 (- f0-8 (* (the float (the int (/ f0-8 1.0))) 1.0)))
                (v1-49 (ja-group))
                )
            (set! (-> a0-20 param 0) (* f0-9 (the float (+ (-> v1-49 frames num-frames) -1))))
            )
          (set! (-> a0-20 param 1) 1000.0)
          (joint-control-channel-group-eval! a0-20 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (suspend)
      )
    #f
    )
  )

(defstate target-ladder-walk-down (target)
  :parent target-ladder
  :trans (behavior ()
    (let ((a0-0 (-> self state parent)))
      (when a0-0
        (let ((t9-0 (-> a0-0 trans)))
          (if t9-0
              (t9-0)
              )
          )
        )
      )
    (cond
      ((and (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
            (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-0 from) (process->ppointer self))
              (set! (-> a1-0 num-params) 1)
              (set! (-> a1-0 message) 'move)
              (set! (-> a1-0 param 0) (the-as uint 0))
              (let* ((f0-1 (the-as float (send-event-function (handle->process (-> self ladder ladder)) a1-0)))
                     (f0-2 (- f0-1 (* (the float (the int (/ f0-1 0.5))) 0.5)))
                     )
                (or (< 0.49 f0-2) (< f0-2 0.1))
                )
              )
            )
       (go target-ladder-stance)
       )
      ((= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
       )
      ((< (-> self control cpad lefty) (the-as uint 128))
       (go target-ladder-walk-up)
       )
      ((= (the-as float (send-event (handle->process (-> self ladder ladder)) 'pos (new 'stack-no-clear 'vector)))
          0.0
          )
       (go target-stance)
       )
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (and v1-2 (= v1-2 jakb-ladder-stance-to-down-ja))
        (ja-no-eval :num! (seek!))
        (while (not (ja-done? 0))
          (suspend)
          (ja-eval)
          )
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! jakb-ladder-down-ja)
    (until #f
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer self))
        (set! (-> a1-2 num-params) 1)
        (set! (-> a1-2 message) 'move)
        (set! (-> a1-2 param 0) (the-as uint (* (- (-> *TARGET-bank* ladder-walk-down-speed))
                                                (fmax 0.4 (-> self control cpad stick0-speed))
                                                (seconds-per-frame)
                                                )
                                        )
              )
        (let ((f0-7 (the-as float (send-event-function (handle->process (-> self ladder ladder)) a1-2)))
              (a0-14 (-> self skel root-channel 0))
              )
          (let ((f0-9 (- 1.0 (- f0-7 (* (the float (the int (/ f0-7 1.0))) 1.0))))
                (v1-39 (ja-group))
                )
            (set! (-> a0-14 param 0) (* f0-9 (the float (+ (-> v1-39 frames num-frames) -1))))
            )
          (set! (-> a0-14 param 1) 1000.0)
          (joint-control-channel-group-eval! a0-14 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      (suspend)
      )
    #f
    )
  )

(defstate target-ladder-slide-down (target)
  :parent target-ladder
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self control unknown-sound-id00) (new-sound-id))
    )
  :exit (behavior ()
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self control unknown-sound-id00))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 24)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (let ((v1-3 (-> self prev-state parent)))
      (when v1-3
        (let ((t9-1 (-> v1-3 exit)))
          (if t9-1
              (t9-1)
              )
          )
        )
      )
    )
  :trans (behavior ()
    (let ((a0-0 (-> self state parent)))
      (when a0-0
        (let ((t9-0 (-> a0-0 trans)))
          (if t9-0
              (t9-0)
              )
          )
        )
      )
    (if (and (not (cpad-hold? (-> self control cpad number) circle))
             (time-elapsed? (-> self state-time) (seconds 0.25))
             )
        (go target-ladder-stance)
        )
    (set! (-> self control unknown-sound-id00)
          (sound-play "ladder-slide" :id (-> self control unknown-sound-id00))
          )
    )
  :code (behavior ()
    (set! (-> self control unknown-word04) (the-as uint 0.0))
    (let ((v1-3 (ja-group)))
      (cond
        ((and v1-3 (= v1-3 jakb-ladder-slide-start-ja))
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-17 (ja-group)))
           (and v1-17 (= v1-17 jakb-ladder-slide-loop-ja))
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja-no-eval :group! jakb-ladder-slide-start-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
        )
      )
    (ja :group! jakb-ladder-slide-loop-ja)
    (until #f
      (ja :num! (loop!))
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (set! (-> self control unknown-word04)
          (the-as uint (seek
                         (the-as float (-> self control unknown-word04))
                         (- (-> *TARGET-bank* ladder-slide-speed))
                         (* 2.0 (seconds-per-frame) (-> *TARGET-bank* ladder-slide-speed))
                         )
                  )
          )
    (if (= (the-as float (send-event
                           (handle->process (-> self ladder ladder))
                           'move
                           (* (the-as float (-> self control unknown-word04)) (seconds-per-frame))
                           )
                   )
           0.0
           )
        (go target-ladder-stance)
        )
    (let ((v1-21 (-> self state parent)))
      (when v1-21
        (let ((t9-3 (-> v1-21 post)))
          (if t9-3
              ((the-as (function none) t9-3))
              )
          )
        )
      )
    )
  )

(defstate target-ladder-switch (target)
  :parent target-ladder
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let ((f30-0 (-> self ladder flip)))
      (ja-no-eval :group! jakb-ladder-switch-ja :num! (seek! max 1.25) :frame-num 0.0)
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (set! (-> self ladder flip)
              (the float (sar (shl (the int (lerp-scale f30-0 (+ 32768.0 f30-0) (ja-aframe-num 0) 0.0 30.0)) 48) 48))
              )
        (suspend)
        (ja :num! (seek! max 1.25))
        )
      (set! (-> self ladder flip) (the float (sar (shl (the int (+ 32768.0 f30-0)) 48) 48)))
      )
    (go target-ladder-stance)
    )
  :post (-> target-ladder-start post)
  )

(defstate target-ladder-jump-off (target)
  :parent target-ladder
  :trans #f
  :code (behavior ()
    (set! (-> self control mod-surface) *turn-around-mods*)
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! jakb-ladder-jump-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      (suspend)
      (ja :num! (seek!))
      )
    (rot->dir-targ! (-> self control))
    (set-forward-vel 16384.0)
    (go target-jump-forward (-> *TARGET-bank* jump-height-max) (-> *TARGET-bank* jump-height-max) #f)
    )
  )
