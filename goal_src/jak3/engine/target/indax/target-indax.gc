;;-*-Lisp-*-
(in-package goal)

;; name: target-indax.gc
;; name in dgo: target-indax
;; dgos: FACC, HALFPIPE, VOCA

;; DECOMP BEGINS

(defpartgroup group-indax-lava-death
  :id 233
  :duration (seconds 0.25)
  :linger-duration (seconds 2)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 1008) (sp-item 1009) (sp-item 1010) (sp-item 1011))
  )

(defpart 1011
  :init-specs ((:texture (hotdot level-default-sprite))
    (:num 8.0 16.0)
    (:scale-x (meters 0.2) (meters 0.5))
    (:scale-y :copy scale-x)
    (:r 256.0)
    (:g 0.0 128.0)
    (:b 0.0)
    (:a 128.0 128.0)
    (:vel-y (meters 0.013333334) (meters 0.04))
    (:scalevel-x (meters -0.0023333333))
    (:scalevel-y :copy scalevel-x)
    (:accel-y (meters -0.0013333333))
    (:timer (seconds 1.5))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-3))
    (:conerot-x (degrees 0) (degrees 60))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 1))
    )
  )

(defpart 1008
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 5.0)
    (:x (meters 0) (meters 0.5))
    (:y (meters 0) (meters 3))
    (:scale-x (meters 1) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 0.0 128.0)
    (:b 0.0)
    (:a 32.0 64.0)
    (:vel-y (meters 0.053333335) (meters 0.053333335))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.6) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -1.7066667)
    (:friction 0.98)
    (:timer (seconds 0.25))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:conerot-x (degrees 0) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 1009
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 32.0)
    (:x (meters 0.5) (meters 2))
    (:y (meters 0.5) (meters 0.5))
    (:scale-x (meters 1) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 0.0 128.0)
    (:b 0.0)
    (:a 32.0 64.0)
    (:vel-y (meters 0) (meters 0.0016666667))
    (:scalevel-x (meters 0.006666667))
    (:rotvel-z (degrees -0.6) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -2.8444443)
    (:friction 0.98)
    (:timer (seconds 0.25))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:conerot-x (degrees 90))
    (:conerot-y (degrees 0) (degrees 360))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 1010
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 8.0)
    (:x (meters -0.6) (meters 1.2))
    (:y (meters 0) (meters 1))
    (:z (meters -0.6) (meters 1.2))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.013333334) (meters 0.013333334))
    (:scalevel-x (meters 0.005))
    (:rotvel-z (degrees -0.6) (degrees 1.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.56666666)
    (:fade-g -0.56666666)
    (:fade-b -0.56666666)
    (:fade-a 0.24)
    (:friction 0.97)
    (:timer (seconds 1.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-13))
    (:next-time (seconds 0.167) (seconds 0.165))
    (:next-launcher 1012)
    (:conerot-x (degrees 0) (degrees 30))
    (:conerot-y (degrees 0) (degrees 3600))
    )
  )

(defpart 1012
  :init-specs ((:fade-a -0.08))
  )

(let ((v1-7 (copy *walk-mods* 'loading-level)))
  (set! (-> v1-7 flags) (surface-flag gun-off gun-fast-exit))
  (set! (-> v1-7 target-speed) 32768.0)
  (set! (-> v1-7 transv-max) 32768.0)
  (set! *indax-walk-mods* v1-7)
  )

(let ((v1-9 (copy *jump-mods* 'loading-level)))
  (set! (-> v1-9 target-speed) 32768.0)
  (set! (-> v1-9 transv-max) 32768.0)
  (set! *indax-jump-mods* v1-9)
  )

(let ((v1-11 (copy *double-jump-mods* 'loading-level)))
  (set! (-> v1-11 target-speed) 32768.0)
  (set! (-> v1-11 transv-max) 32768.0)
  (set! *indax-double-jump-mods* v1-11)
  )

(let ((v1-13 (copy *jump-mods* 'loading-level)))
  (set! (-> v1-13 target-speed) 49152.0)
  (set! (-> v1-13 transv-max) 49152.0)
  (set! (-> v1-13 seek0) 0.7)
  (set! (-> v1-13 seek90) 0.7)
  (set! (-> v1-13 seek180) 0.7)
  (set! *indax-bounce-mods* v1-13)
  )

(defbehavior target-indax-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (cond
    ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
     'indax
     )
    (else
      (case arg2
        (('end-mode)
         (case (-> arg3 param 0)
           (('indax)
            (if (-> self manipy)
                (go target-indax-get-off)
                (go target-stance)
                )
            )
           )
         )
        (('change-mode)
         (case (-> arg3 param 0)
           (('grab)
            (when (not (focus-test? self dead))
              (if (not (-> arg3 param 1))
                  #t
                  (go target-indax-grab 'stance)
                  )
              )
            )
           (('normal)
            (go target-stance)
            )
           (('falling)
            (go target-indax-falling #f)
            )
           (('hang)
            (if (not (logtest? (target-flags tf26) (-> self target-flags)))
                (go target-indax-hang-stance)
                )
            )
           (('tube)
            (if (and (logtest? (-> self control status) (collide-status on-surface))
                     (not (or (logtest? (water-flag touch-water) (-> self water flags))
                              (logtest? (-> self control status) (collide-status on-water))
                              )
                          )
                     )
                (go target-tube-start (process->handle (the-as process (-> arg3 param 1))))
                )
            )
           )
         )
        (('trip)
         (if (not (or (focus-test? self dead hit grabbed)
                      (and (-> self next-state) (= (-> self next-state name) 'target-indax-trip))
                      )
                  )
             (go target-indax-trip)
             )
         )
        (('swim 'slide 'edge-grab)
         #f
         )
        (('clone-anim)
         (go target-clone-anim (process->handle (the-as process (-> arg3 param 0))))
         )
        (('attack 'attack-or-shove 'attack-invinc)
         (target-attacked
           arg2
           (the-as attack-info (-> arg3 param 1))
           arg0
           (the-as touching-shapes-entry (-> arg3 param 0))
           target-indax-hit
           )
         )
        (('shove)
         (when (not (and (-> self next-state) (let ((v1-42 (-> self next-state name)))
                                                (or (= v1-42 'target-indax-hit) (= v1-42 'target-hit))
                                                )
                         )
                    )
           (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 168)
           (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
             (set! (-> self attack-info-rec attacker) (process->handle arg0))
             (logior! (-> self attack-info-rec mask) (attack-mask attacker))
             )
           (go target-indax-hit 'shove (-> self attack-info-rec))
           )
         )
        (else
          (target-standard-event-handler arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defbehavior target-indax-dangerous-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (cond
       ((< 0.0 (-> self fact shield-level))
        (let ((s4-1 (-> self control penetrate-using)))
          (set! (-> self control penetrate-using) (penetrate touch shield))
          (let ((v0-0 (the-as object (target-send-attack
                                       arg0
                                       'shield
                                       (the-as touching-shapes-entry (-> arg3 param 0))
                                       (the-as int (-> self fact shield-attack-id))
                                       0
                                       (-> self control penetrate-using)
                                       )
                              )
                      )
                )
            (set! (-> self control penetrate-using) s4-1)
            v0-0
            )
          )
        )
       (((method-of-type touching-shapes-entry prims-touching?)
         (the-as touching-shapes-entry (-> arg3 param 0))
         (-> self control)
         (the-as uint 1920)
         )
        (target-send-attack
          arg0
          (-> self control danger-mode)
          (the-as touching-shapes-entry (-> arg3 param 0))
          (the-as int (-> self control target-attack-id))
          (the-as int (-> self control attack-count))
          (-> self control penetrate-using)
          )
        )
       (else
         (target-indax-handler arg0 arg1 arg2 arg3)
         )
       )
     )
    (('attack 'attack-or-shove 'attack-invinc)
     (target-attacked
       arg2
       (the-as attack-info (-> arg3 param 1))
       arg0
       (the-as touching-shapes-entry (-> arg3 param 0))
       target-indax-hit
       )
     )
    (else
      (target-indax-handler arg0 arg1 arg2 arg3)
      )
    )
  )

(defbehavior target-indax-jump-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((s2-0 (new 'stack-no-clear 'vector)))
    (cond
      ((and (= arg2 'touched)
            ((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry (-> arg3 param 0))
             (-> self control)
             (the-as uint 6)
             )
            (< (* 16384.0 (-> self clock time-adjust-ratio))
               (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control transv) (-> self control last-transv))
                 )
               )
            (begin
              (vector-normalize!
                (vector-!
                  s2-0
                  (the-as vector (-> self control collision-spheres 0 prim-core))
                  (-> self control actor-contact-pt)
                  )
                1.0
                )
              (< 0.01 (-> s2-0 y))
              )
            )
       (if (< 0.75 (-> s2-0 y))
           (send-event
             arg0
             'bonk
             (-> arg3 param 0)
             (fmax
               (-> self control ground-impact-vel)
               (- (vector-dot (-> self control transv) (-> self control dynam gravity-normal)))
               )
             )
           )
       (target-indax-handler arg0 arg1 arg2 arg3)
       )
      ((= arg2 'jump)
       (sound-play "dax-jump-long")
       (sound-play "dax-woohoo")
       (go
         target-indax-jump
         (the-as float (-> arg3 param 0))
         (the-as float (-> arg3 param 1))
         (the-as surface (-> arg3 param 2))
         )
       )
      (else
        (target-indax-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  )

(defbehavior target-indax-reset target ()
  (set! (-> self control reaction) target-collision-reaction)
  (logior! (-> self focus-status) (focus-status indax))
  (set! (-> self control bend-target) 0.0)
  (target-collide-set! 'indax 0.0)
  (remove-setting! 'string-max-length)
  (remove-setting! 'string-min-length)
  (remove-setting! 'string-max-height)
  (remove-setting! 'string-min-height)
  (remove-setting! 'fov)
  (remove-setting! 'head-offset)
  (remove-setting! 'foot-offset)
  (remove-setting! 'target-height)
  (set-setting! 'string-max-length 'low (meters 6) 0)
  (set-setting! 'string-max-height 'low (meters 1) 0)
  (set-setting! 'head-offset 'abs (meters 1) 0)
  0
  (none)
  )

(defbehavior target-indax-init target ()
  (logior! (-> self control current-surface flags) (surface-flag gun-fast-exit))
  (target-gun-end-mode #t)
  (target-exit)
  (logior! (-> self game features) (game-feature sidekick))
  (target-sidekick-setup #t)
  (logior! (-> self skel effect flags) (effect-control-flag ecf2))
  (when (zero? (-> self indax))
    (set! (-> self indax) (new 'process 'indax-info))
    (set! (-> self indax pad) (the-as object #f))
    )
  (set! (-> self control transv quad) (the-as uint128 0))
  (set! (-> self control ctrl-xz-vel) 0.0)
  (set! (-> self fact health) (-> self fact health-max))
  (set-time! (-> self indax indax-start-time))
  (set! (-> self indax art-group-backup) (-> self draw art-group))
  (set! (-> self draw art-group) (-> self sidekick 0 draw art-group))
  (logior! (-> self draw status) (draw-control-status no-draw-bounds2))
  (send-event (ppointer->process (-> self sidekick)) 'matrix 'indax)
  (target-indax-reset)
  (cloth-post)
  (set! (-> self major-mode-exit-hook) target-indax-exit)
  (set! (-> self major-mode-event-hook) target-indax-handler)
  (set! (-> self major-mode-exit-hook) target-indax-reset)
  (set! (-> self indax pad) (add-setting! 'mode-sound-bank 'modeidax 0.0 0))
  (remove-exit)
  0
  (none)
  )

(defbehavior target-indax-exit target ()
  (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                         (or (= v1-3 'target-indax-stance)
                                             (= v1-3 'target-indax-walk)
                                             (= v1-3 'target-indax-jump)
                                             (= v1-3 'target-indax-double-jump)
                                             (= v1-3 'target-indax-falling)
                                             (= v1-3 'target-indax-hit-ground)
                                             (= v1-3 'target-indax-attack)
                                             (= v1-3 'target-indax-attack-air)
                                             (= v1-3 'target-indax-running-attack)
                                             (= v1-3 'target-indax-trip)
                                             (= v1-3 'target-indax-hit)
                                             (= v1-3 'target-indax-death)
                                             (= v1-3 'target-indax-get-off)
                                             (= v1-3 'target-indax-grab)
                                             (state-type? (-> self next-state) 'target-indax-hang)
                                             (state-type? (-> self next-state) 'target-tube)
                                             )
                                         )
                  )
             )
    (setting-control-method-14 *setting-control* (-> self indax pad))
    (set! (-> self indax pad) (the-as object #f))
    (logclear! (-> self focus-status) (focus-status indax))
    (logclear! (-> self control root-prim prim-core action) (collide-action stuck-wall-escape))
    (set! (-> self control mod-surface) *walk-mods*)
    (logclear! (-> self target-flags) (target-flags tf6))
    (target-collide-set! 'normal 0.0)
    (logclear! (-> self skel effect flags) (effect-control-flag ecf2))
    (set! (-> self draw art-group) (-> self indax art-group-backup))
    (logclear! (-> self draw status) (draw-control-status no-draw-bounds2))
    (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
    (if (not (focus-test? self dead))
        (set! (-> self fact health) (-> self fact health-max))
        )
    (let ((v1-33 (-> self manipy)))
      (when v1-33
        (deactivate (-> v1-33 0))
        (set! (-> self manipy) (the-as (pointer manipy) #f))
        )
      )
    (when (and (-> self next-state) (= (-> self next-state name) 'target-duck-stance))
      (ja-channel-set! 1)
      (ja :group! daxter-edge-grab-swing-left-ja :num! min)
      )
    (set! (-> self major-mode-exit-hook) #f)
    (set! (-> self sub-mode-exit-hook) #f)
    (set! (-> self major-mode-event-hook) #f)
    (remove-setting! 'string-max-length)
    (remove-setting! 'string-min-length)
    (remove-setting! 'string-max-height)
    (remove-setting! 'string-min-height)
    (remove-setting! 'fov)
    (remove-setting! 'head-offset)
    (target-exit)
    )
  (none)
  )

(defbehavior target-indax-real-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (if (< (-> self control force-turn-to-strength) 0.0)
            (set! (-> self control force-turn-to-strength) (- 1.0 (-> self control cpad stick0-speed)))
            )
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (let ((f28-0 (debounce-speed
                         (-> self control pad-magnitude)
                         (-> self control last-pad-magnitude)
                         (-> self control pad-xz-dir)
                         (-> self control last-pad-xz-dir)
                         )
                       )
                )
            (when (!= (-> self control force-turn-to-strength) 0.0)
              (let ((f0-12 (fmin 1.0 (-> self control force-turn-to-strength))))
                (set! (-> self control force-turn-to-strength) f0-12)
                (let ((a1-3 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (if (= f28-0 0.0)
                                  *zero-vector*
                                  s5-0
                                  )
                              f28-0
                              )
                            )
                      (a2-2 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (-> self control force-turn-to-direction)
                              (-> self control force-turn-to-speed)
                              )
                            )
                      )
                  (vector-lerp! s5-0 a1-3 a2-2 f0-12)
                  )
                )
              (set! f28-0 (vector-length s5-0))
              (vector-normalize! s5-0 1.0)
              )
            (turn-to-vector s5-0 f28-0)
            )
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (let ((a2-3 (new 'stack-no-clear 'collide-query)))
          (let ((v1-31 (-> self control)))
            (set! (-> a2-3 collide-with) (-> v1-31 root-prim prim-core collide-with))
            (set! (-> a2-3 ignore-process0) self)
            (set! (-> a2-3 ignore-process1) #f)
            (set! (-> a2-3 ignore-pat) (-> v1-31 pat-ignore-mask))
            )
          (set! (-> a2-3 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-3 (meters 1))
          )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (logclear! (-> self draw status) (draw-control-status no-draw-temp uninited))
  (evaluate-joint-control self)
  (joint-points)
  ;; og:preserve-this TODO crashes, do we need this? seems to work fine without
  ; (let* ((v1-46 (-> self node-list data))
  ;        (t9-20 (-> v1-46 0 param0))
  ;        )
  ;   (when t9-20
  ;     (let ((a0-18 v1-46)
  ;           (a1-8 (-> v1-46 0 param1))
  ;           )
  ;       (-> v1-46 0 param2)
  ;       (t9-20 (the-as cspace a0-18) (the-as transformq a1-8))
  ;       )
  ;     )
  ;   )
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-indax-post target ()
  (target-indax-real-post)
  (none)
  )

(defstate target-indax-start (target)
  :event target-standard-event-handler
  :code (behavior ((arg0 handle) (arg1 object))
    (when (not arg1)
      (set! (-> self control mod-surface) *empty-mods*)
      (set! (-> self neck flex-blend) 0.0)
      (set-forward-vel 0.0)
      (let ((s4-0 0))
        (while (or (not (logtest? (-> self control status) (collide-status on-surface))) (nonzero? (-> self ext-anim)))
          (target-falling-anim-trans)
          (+! s4-0 (- (current-time) (-> self clock old-frame-counter)))
          (if (>= s4-0 300)
              (go target-falling #f)
              )
          (suspend)
          )
        )
      (ja-channel-push! 1 (seconds 0.04))
      (ja-no-eval :group! daxter-falling-to-edge-grab-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (set! (-> self manipy)
            (the-as
              (pointer manipy)
              (external-target-spawn (-> self control trans) (-> self control quat) self #f (manipy-options mo0))
              )
            )
      (move-by-vector! (-> self control) (new 'static 'vector :y 4505.6 :w 1.0))
      (target-indax-init)
      (set-forward-vel 32768.0)
      (go target-indax-jump 12288.0 12288.0 *forward-jump-mods*)
      )
    (target-indax-init)
    (if (= arg1 'hang)
        (go target-indax-hang-stance)
        (go target-indax-stance)
        )
    )
  :post target-no-stick-post
  )

(defstate target-indax-stance (target)
  :event target-indax-handler
  :enter (behavior ()
    ((-> target-stance enter))
    (set! (-> self control mod-surface) *indax-walk-mods*)
    )
  :exit (behavior ()
    ((-> target-stance exit))
    (target-indax-exit)
    )
  :trans (behavior ()
    ((-> self state-hook))
    (when (move-legs?)
      (set! (-> self control bend-target) 0.0)
      (logclear! (-> self target-flags) (target-flags lleg-still rleg-still))
      (remove-exit)
      (go target-indax-walk)
      )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? x)
             (can-jump? #f)
             )
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? square)
             (can-hands? #t)
             )
        (go target-indax-running-attack)
        )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? circle)
             (can-feet? #t)
             )
        (go target-indax-attack)
        )
    (fall-test target-indax-falling (-> *TARGET-bank* fall-height))
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 daxter-indax-attack-spin-ja))
         (ja-no-eval :group! daxter-indax-attack-spin-end-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (ja-channel-push! 1 (seconds 0.05))
         )
        ((let ((v1-32 (ja-group)))
           (and v1-32 (= v1-32 daxter-indax-running-attack-ja))
           )
         (ja-no-eval :group! daxter-indax-running-attack-end-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (ja-channel-push! 1 (seconds 0.05))
         )
        ((let ((v1-62 (ja-group)))
           (and (and v1-62 (= v1-62 daxter-indax-run-ja))
                (< (-> self skel root-channel 2 frame-interp (-> self skel active-frame-interp)) 0.5)
                )
           )
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! daxter-indax-run-to-stance-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.05))
          )
        )
      )
    (until #f
      (ja-no-eval :group! daxter-indax-stance-ja :num! (seek! max 1.5) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 1.5))
        )
      )
    #f
    )
  :post target-indax-post
  )

(defstate target-indax-walk (target)
  :event target-indax-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self control mod-surface) *indax-walk-mods*)
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-state-hook-exit)
    (target-indax-exit)
    )
  :trans (behavior ()
    ((-> self state-hook))
    (when (not (move-legs?))
      (target-effect-exit)
      (remove-exit)
      (go target-indax-stance)
      )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? x)
             (can-jump? #f)
             )
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? square)
             (can-hands? #t)
             )
        (go target-indax-running-attack)
        )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? circle)
             (can-feet? #t)
             )
        (go target-indax-attack)
        )
    (fall-test target-indax-falling (-> *TARGET-bank* fall-height))
    )
  :code (behavior ()
    (let ((f26-0 0.0)
          (f28-0 0.0)
          (f30-0 0.0)
          )
      (current-time)
      (let ((v1-4 (ja-group)))
        (cond
          ((and v1-4 (or (= v1-4 daxter-indax-walk-ja) (= v1-4 daxter-indax-run-ja)))
           (set! f26-0 (ja-frame-num 0))
           )
          ((let ((v1-10 (ja-group)))
             (and (or (and v1-10 (= v1-10 daxter-indax-jump-loop-ja))
                      (let ((v1-16 (ja-group)))
                        (and (and v1-16 (= v1-16 daxter-indax-jump-ja)) (< 15.0 (ja-aframe-num 0)))
                        )
                      )
                  (< 12288.0 (-> self control ctrl-xz-vel))
                  )
             )
           (ja-channel-push! 1 (seconds 0.01))
           (ja-no-eval :group! daxter-indax-run-squash-ja :num! (seek! max 2.0) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek! max 2.0))
             )
           (ja-channel-push! 3 (seconds 0.05))
           )
          (else
            (ja-channel-push! 3 (seconds 0.05))
            )
          )
        )
      (ja-no-eval :group! daxter-indax-run-ja :num! (identity f26-0) :dist 13107.2)
      (ja-no-eval :chan 1 :group! daxter-indax-run-look-back-ja :num! (identity f26-0) :dist 12697.6)
      (let ((a0-25 (-> self skel root-channel 2)))
        (let ((f0-12 (- 1.0 f28-0)))
          (set! (-> a0-25 frame-interp 1) f0-12)
          (set! (-> a0-25 frame-interp 0) f0-12)
          )
        (set! (-> a0-25 dist) 5939.2)
        (set! (-> a0-25 frame-group) (the-as art-joint-anim daxter-indax-walk-ja))
        (set! (-> a0-25 param 0) 1.0)
        (set! (-> a0-25 frame-num) f26-0)
        (joint-control-channel-group! a0-25 (the-as art-joint-anim daxter-indax-walk-ja) num-func-loop!)
        )
      (until #f
        (suspend)
        (let ((f0-16 (lerp-scale 0.0 1.0 (-> self control ctrl-xz-vel) 16384.0 32768.0)))
          (set! f28-0 (seek f28-0 f0-16 (* 4.0 (seconds-per-frame))))
          )
        (ja :chan 1 :frame-interp0 f30-0 :frame-interp1 f30-0)
        (let ((v1-81 (-> self skel root-channel 2))
              (f0-20 (- 1.0 f28-0))
              )
          (set! (-> v1-81 frame-interp 1) f0-20)
          (set! (-> v1-81 frame-interp 0) f0-20)
          )
        (let ((v1-84 (-> self skel effect))
              (a0-31 (cond
                       ((< 0.5 f28-0)
                        (if (< 0.5 f30-0)
                            1
                            0
                            )
                        )
                       (else
                         2
                         )
                       )
                     )
              )
          (set! (-> v1-84 channel-offset) a0-31)
          )
        0
        (let* ((f0-24 (* (current-cycle-distance (-> self skel)) (-> self control scale x)))
               (f0-26 (/ (* 60.0 (-> self control ctrl-xz-vel)) (* 60.0 f0-24)))
               )
          (ja :num! (loop! f0-26))
          )
        (ja :chan 1 :num! (chan 0))
        (ja :chan 2 :num! (chan 0))
        )
      )
    #f
    )
  :post target-indax-post
  )

(defstate target-indax-falling (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'change-mode)
             (= (-> block param 0) 'hang)
             (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 0.0)
             )
        #f
        (target-indax-jump-event-handler proc argc message block)
        )
    )
  :enter (behavior ((arg0 symbol))
    ((-> target-falling enter) arg0)
    (set! (-> self control mod-surface) *indax-jump-mods*)
    )
  :exit target-indax-exit
  :trans (behavior ()
    (set! (-> self control unknown-float36)
          (fmax
            (-> self control unknown-float36)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton (abutton-idx x)))) ;; og:preserve-this abutton indexing
            )
          )
    (case (-> self control unknown-spool-anim00)
      (('tube)
       )
      (else
        (if (logtest? (-> self control status) (collide-status on-surface))
            (go target-indax-hit-ground #f)
            )
        (if (and (cpad-pressed? (-> self control cpad number) circle) (can-feet? #f))
            (go target-indax-attack-air #f)
            )
        )
      )
    (let ((f0-3 (fmax 0.0 (fmin 1.0 (* 0.000048828126 (+ -10240.0 (-> self control ctrl-xz-vel)))))))
      (if (< (-> self control unknown-float35) f0-3)
          (seek! (-> self control unknown-float35) f0-3 (* 4.0 (seconds-per-frame)))
          )
      )
    (case (-> self control unknown-spool-anim00)
      (('tube)
       (if (and (or (< (-> self control trans y) (-> self control unknown-float0000))
                    (time-elapsed? (-> self state-time) (seconds 3))
                    )
                (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
                )
           (send-event
             self
             'attack-invinc
             #f
             (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                 (damage 2.0)
                                                                 (vehicle-damage-factor 1.0)
                                                                 (vehicle-impulse-factor 1.0)
                                                                 (mode 'endlessfall)
                                                                 )
                                 )
             )
           )
       )
      )
    )
  :code (behavior ((arg0 symbol))
    (let ((a1-0 75))
      (let ((v1-2 (ja-group)))
        (cond
          ((and v1-2 (or (= v1-2 daxter-indax-jump-ja) (= v1-2 daxter-indax-jump-loop-ja)))
           )
          (else
            (let ((v1-8 (ja-group)))
              (cond
                ((and v1-8 (= v1-8 daxter-indax-attack-spin-air-ja))
                 (set! a1-0 30)
                 (set! (-> self control unknown-float35) 0.0)
                 )
                (else
                  (set! (-> self control unknown-float35) 0.0)
                  )
                )
              )
            )
          )
        )
      (ja-channel-push! 1 (the-as time-frame a1-0))
      )
    (ja-no-eval :group! daxter-indax-jump-loop-ja :num! (loop!) :frame-num 0.0)
    (until #f
      (seek! (-> self control unknown-float35) 0.0 (* 10.0 (seconds-per-frame)))
      (suspend)
      (ja-blend-eval)
      (ja :num! (loop!))
      )
    #f
    )
  :post target-indax-post
  )

(defstate target-indax-jump (target)
  :event target-indax-jump-event-handler
  :enter (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (let ((t9-0 (-> target-jump enter)))
      (set! arg2 (cond
                   (arg2
                     (empty)
                     arg2
                     )
                   (else
                     *indax-jump-mods*
                     )
                   )
            )
      (t9-0 arg0 arg1 arg2)
      )
    (set! (-> self control unknown-float35) 0.0)
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-exit)
    (target-indax-exit)
    )
  :trans (behavior ()
    ((-> target-indax-falling trans))
    (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (if (and (cpad-pressed? (-> self control cpad number) x)
             (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 12288.0)
             (and (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                  (not (logtest? (water-flag touch-water) (-> self water flags)))
                  (not (logtest? (target-flags prevent-jump prevent-double-jump) (-> self target-flags)))
                  )
             )
        (go
          target-indax-double-jump
          (-> *TARGET-bank* indax-double-jump-height-min)
          (-> *TARGET-bank* indax-double-jump-height-max)
          )
        )
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (ja-channel-push! 2 (seconds 0.02))
    (ja :group! daxter-indax-jump-ja :num! min)
    (ja :chan 1 :group! daxter-indax-jump-forward-ja :num! (chan 0))
    (suspend)
    (until (ja-done? 0)
      (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            (f0-4 (- 10.0 (ja-aframe-num 0)))
            (gp-1 (-> self skel root-channel 0))
            )
        (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
        (let ((v1-26 (and (< 0.0 f30-0) (< 0.0 f0-4))))
          (set! (-> gp-1 param 1)
                (if v1-26
                    (fmin (fmin 3.0 f0-4) (/ (* 10.0 f0-4) (the float (time-to-apex f30-0 -245760.0))))
                    1.0
                    )
                )
          )
        (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      (let ((a0-8 (-> self skel root-channel 1)))
        (let ((f0-10 (-> self control unknown-float35)))
          (set! (-> a0-8 frame-interp 1) f0-10)
          (set! (-> a0-8 frame-interp 0) f0-10)
          )
        (set! (-> a0-8 param 0) 0.0)
        (joint-control-channel-group-eval! a0-8 (the-as art-joint-anim #f) num-func-chan)
        )
      (let ((v1-36 (-> self skel effect)))
        (set! (-> v1-36 channel-offset) (if (< 0.5 (-> self control unknown-float35))
                                            1
                                            0
                                            )
              )
        )
      0
      (suspend)
      )
    (go target-indax-falling #f)
    )
  :post target-indax-post
  )

(defstate target-indax-double-jump (target)
  :event target-indax-jump-event-handler
  :enter (behavior ((arg0 float) (arg1 float))
    (set-time! (-> self state-time))
    (init-var-jump arg0 arg1 #t #t (-> self control transv) 2.0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (if (!= (-> self control mod-surface) *slide-jump-mods*)
        (set! (-> self control mod-surface) *indax-double-jump-mods*)
        )
    (let ((v1-10 (ja-group)))
      (cond
        ((and v1-10 (or (= v1-10 daxter-indax-jump-ja) (= v1-10 daxter-indax-jump-loop-ja)))
         )
        (else
          (set! (-> self control unknown-float35) 0.0)
          )
        )
      )
    )
  :exit (-> target-indax-jump exit)
  :trans (behavior ()
    ((-> target-indax-falling trans))
    (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    )
  :code (behavior ((arg0 float) (arg1 float))
    (sound-play "dax-jump-double")
    (let ((v1-3 (ja-group)))
      (cond
        ((and (and v1-3 (= v1-3 daxter-indax-jump-ja)) (< 0.6 (-> self control unknown-float35)))
         (ja-channel-push! 2 (seconds 0.04))
         (ja-no-eval :group! daxter-indax-jump-ja :num! (seek!) :frame-num (ja-aframe 1.0 0))
         (ja :chan 1 :group! daxter-indax-jump-forward-ja :num! (chan 0))
         )
        (else
          (ja-channel-push! 2 (seconds 0.05))
          (ja-no-eval :group! daxter-indax-jump-ja :num! (seek!) :frame-num (ja-aframe 5.0 0))
          (ja :chan 1 :group! daxter-indax-jump-forward-ja :num! (chan 0))
          )
        )
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      (let ((a0-16 (-> self skel root-channel 1)))
        (let ((f0-14 (-> self control unknown-float35)))
          (set! (-> a0-16 frame-interp 1) f0-14)
          (set! (-> a0-16 frame-interp 0) f0-14)
          )
        (set! (-> a0-16 param 0) 0.0)
        (joint-control-channel-group-eval! a0-16 (the-as art-joint-anim #f) num-func-chan)
        )
      (let ((v1-68 (-> self skel effect))
            (a0-19 (if (< 0.5 (-> self control unknown-float35))
                       1
                       0
                       )
                   )
            )
        (set! (-> v1-68 channel-offset) a0-19)
        )
      0
      )
    (go target-indax-falling #f)
    )
  :post target-post
  )

(defstate target-indax-hit-ground (target)
  :event target-indax-handler
  :enter (behavior ((arg0 symbol))
    ((-> target-hit-ground enter) arg0)
    (set! (-> self control mod-surface) *indax-walk-mods*)
    )
  :exit target-indax-exit
  :trans (behavior ()
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? x)
             (can-jump? #f)
             )
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
    (if (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
        (go target-indax-walk)
        )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? square)
             (can-hands? #t)
             )
        (go target-indax-running-attack)
        )
    ;; og:preserve-this - High FPS Fix
    (if (and (recently-pressed? circle)
             (can-feet? #t)
             )
        (go target-indax-attack)
        )
    (fall-test target-indax-falling (-> *TARGET-bank* fall-height))
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! daxter-indax-jump-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go target-indax-stance)
    )
  :post target-indax-post
  )

(defstate target-indax-trip (target)
  :event target-indax-jump-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (sound-play "dax-jump" :vol 70)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    )
  :exit (behavior ()
    (target-exit)
    (target-indax-exit)
    )
  :code (behavior ()
    (set! (-> self control mod-surface) *indax-bounce-mods*)
    (ja-channel-push! 1 (seconds 0.02))
    (ja-no-eval :group! daxter-indax-trip-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-y-vel adjust-xz-vel) 1.0 1.0 2.0)
      (suspend)
      (ja :num! (seek!))
      )
    (while (not (logtest? (-> self control status) (collide-status on-surface)))
      (suspend)
      )
    (ja-no-eval :group! daxter-indax-trip-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    )
  :post target-no-stick-post
  )

(defstate target-indax-attack (target)
  :event target-indax-dangerous-event-handler
  :enter (-> target-attack enter)
  :exit (behavior ()
    ((-> target-attack exit))
    (target-indax-exit)
    )
  :code (behavior ()
    (let ((gp-0 daxter-indax-attack-spin-ja))
      (quaternion-rotate-y! (-> self control quat-for-control) (-> self control quat-for-control) -1365.3334)
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! gp-0 :num! (seek! max (-> self control current-surface align-speed)) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
     ;; og:preserve-this - High FPS Fix
    (when (and (recently-pressed? x)
                 (can-jump? #f)
                 )
        (set-quaternion! (-> self control) (-> self control dir-targ))
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
      (suspend)
      (ja :num! (seek! max (-> self control current-surface align-speed)))
      )
    (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
    (if (< 11.4 (ja-aframe-num 0))
        (ja :num-func num-func-identity :frame-num max)
        )
    (go target-indax-stance)
    )
  :post target-indax-post
  )

(defstate target-indax-attack-air (target)
  :event target-indax-dangerous-event-handler
  :enter (-> target-attack-air enter)
  :exit (behavior ()
    ((-> target-attack-air exit))
    (target-indax-exit)
    )
  :code (behavior ((arg0 symbol))
    (let ((gp-0 daxter-indax-attack-spin-air-ja))
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! gp-0 :num! (seek! max (-> self control current-surface align-speed)) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      ;; og:preserve-this - High FPS Fix
    (when (and (recently-pressed? x)
                 (can-jump? #f)
                 )
        (set-quaternion! (-> self control) (-> self control dir-targ))
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
      (suspend)
      (ja :num! (seek! max (-> self control current-surface align-speed)))
      )
    (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
    (go target-indax-falling #f)
    )
  :post target-indax-post
  )

(defstate target-indax-running-attack (target)
  :event target-indax-dangerous-event-handler
  :enter (-> target-running-attack enter)
  :exit (behavior ()
    ((-> target-running-attack enter))
    (target-indax-exit)
    )
  :code (behavior ()
    (set! (-> self control dynam gravity-max) 368640.0)
    (set! (-> self control dynam gravity-length) 368640.0)
    (let ((gp-0 daxter-indax-running-attack-ja))
      (ja-channel-push! 1 (seconds 0.02))
      (ja-no-eval :group! gp-0 :num! (seek!))
      )
    (target-start-attack)
    (target-danger-set! 'punch #f)
    (let ((f26-0 (the-as number 0.0))
          (f30-0 1.0)
          (gp-1 0)
          (f28-0 1.0)
          )
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (when (not (ja-min? 0))
          (cond
            ((and (>= (ja-aframe-num 0) 20.0)
                  (and (and (not (logtest? (-> self control status) (collide-status on-surface)))
                            (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout))
                            (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                            (>= (target-height-above-ground) (-> *TARGET-bank* fall-height))
                            )
                       (time-elapsed? (-> self control sliding-start-time) (seconds 0.04))
                       )
                  )
             (go target-indax-falling #f)
             )
            ((< (the-as float f26-0) 0.0)
             (set! f26-0 (seek (the-as float f26-0) -0.04096 (* 491520.0 (seconds-per-frame))))
             (set-forward-vel (the-as float f26-0))
             )
            ((and (nonzero? (-> self control unknown-time-frame18))
                  (time-elapsed? (-> self control unknown-time-frame18) (seconds 0.04))
                  )
             (set-forward-vel 0.0)
             )
            ((and (not (cpad-hold? (-> self control cpad number) square))
                  (time-elapsed? (-> self control unknown-combo-tracker00 move-start-time) (seconds 0.05))
                  )
             (if (= (-> self control ground-pat material) (pat-material ice))
                 (set-forward-vel (fmax 32768.0 (* 0.8 (-> self control ctrl-xz-vel))))
                 (set-forward-vel (* 0.8 (-> self control ctrl-xz-vel)))
                 )
             )
            ((ja-done? 0)
             (set-forward-vel (the-as float f26-0))
             )
            (else
              (set! f26-0
                    (* (target-align-vel-z-adjust (-> self align delta trans z)) (-> self clock frames-per-second) f30-0)
                    )
              (set-forward-vel (the-as float f26-0))
              )
            )
          )
        (let ((s5-0 (new-stack-vector0)))
          (vector-matrix*! s5-0 (-> self control transv) (-> self control w-R-c))
          (set! (-> s5-0 y) 0.0)
          (vector-matrix*! (-> self control align-xz-vel) s5-0 (-> self control c-R-w))
          )
        (when (!= (the-as float (-> self control unknown-word04)) 0.0)
          (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
          (set! f26-0 (-> self control unknown-word04))
          (set! (-> self control unknown-word04) (the-as uint 0.0))
          )
        (suspend)
        (ja :num! (seek! max (* (-> self control current-surface align-speed) f28-0)))
        (if (time-elapsed? (-> self state-time) (seconds 0.1))
            (set! (-> *run-attack-mods* turnvv) 0.0)
            )
        (if (< 2 gp-1)
            (set! f30-0 (* f30-0 (fmin 1.0 (-> self control zx-vel-frac))))
            )
        (+! gp-1 1)
        )
      )
    (if (and (not (logtest? (-> self control status) (collide-status on-surface)))
             (time-elapsed? (-> self control last-time-on-surface) (-> *TARGET-bank* ground-timeout))
             (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
             (>= (target-height-above-ground) (-> *TARGET-bank* fall-height))
             )
        (go target-indax-falling #f)
        )
    (go target-indax-stance)
    )
  :post target-post
  )

(defstate target-indax-get-off (target)
  :event target-standard-event-handler
  :exit target-indax-exit
  :trans (behavior ()
    (let* ((gp-0 (ppointer->process (-> self manipy)))
           (v1-2 (if (type? gp-0 manipy)
                     gp-0
                     )
                 )
           )
      (cond
        ((not (the-as manipy v1-2))
         (ja-channel-set! 0)
         (go target-falling #f)
         )
        (else
          (set! (-> self control unknown-word04) (the-as uint (-> v1-2 root trans y)))
          (vector+! (-> self control unknown-vector38) (-> v1-2 root trans) (new 'static 'vector :y 4505.6 :w 1.0))
          (set! (-> self control unknown-vector40 quad) (-> v1-2 root quat quad))
          )
        )
      )
    )
  :code (behavior ()
    (sound-play "dax-jump" :vol 70)
    (logior! (-> self target-flags) (target-flags tf6))
    (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
    (let ((gp-1 daxter-indax-jump-ja))
      (ja-channel-push! 1 (seconds 0.05))
      (set! (-> self control mod-surface) *empty-mods*)
      (set! (-> self neck flex-blend) 0.0)
      (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
      (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
      (ja :group! gp-1 :num! (seek!) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 0.0 10.0))))
        (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 0.0 10.0)))
          (vector-lerp!
            (-> self control trans)
            (-> self control unknown-vector37)
            (-> self control unknown-vector38)
            f30-0
            )
          (set! (-> self control trans y)
                (+ (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                   (* 6144.0 (sin (lerp-scale 0.0 32768.0 (ja-aframe-num 0) 0.0 20.0)))
                   )
                )
          )
        (quaternion-slerp!
          (-> self control quat-for-control)
          (the-as quaternion (-> self control unknown-vector39))
          (the-as quaternion (-> self control unknown-vector40))
          f30-0
          )
        )
      (rot->dir-targ! (-> self control))
      (suspend)
      (set! (-> self alt-cam-pos quad) (-> self control trans quad))
      (set! (-> self alt-cam-pos y) (the-as float (-> self control unknown-word04)))
      (ja :num! (seek!))
      )
    (do-effect (-> self skel effect) "effect-land" 0.0 -1)
    (let ((a1-11 (new 'stack-no-clear 'vector)))
      (set! (-> a1-11 quad) (-> self control trans quad))
      (set! (-> a1-11 y) (the-as float (-> self control unknown-word04)))
      (move-to-point! (-> self control) a1-11)
      )
    (ja-channel-set! 0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (go target-duck-stance #f)
    )
  :post target-no-move-post
  )

;; WARN: Return type mismatch float vs none.
(defbehavior target-indax-hit-setup-anim target ((arg0 attack-info))
  (case (-> arg0 angle)
    (('back)
     (let ((v1-3 (ja-group)))
       (when (not (and v1-3 (= v1-3 daxter-indax-hit-back-ja)))
         (ja-channel-push! 1 (seconds 0.075))
         (ja :group! daxter-indax-hit-back-ja :num! min)
         )
       )
     )
    (else
      (let ((v1-12 (ja-group)))
        (when (not (and v1-12 (= v1-12 daxter-indax-hit-front-ja)))
          (ja-channel-push! 1 (seconds 0.075))
          (ja :group! daxter-indax-hit-front-ja :num! min)
          )
        )
      )
    )
  (none)
  )

(defstate target-indax-hit (target)
  :event target-indax-handler
  :exit (behavior ()
    ((-> target-hit exit))
    ((-> target-indax-hang exit))
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (pickup-collectable! (-> self fact) (pickup-type health) 100.0 (the-as handle #f))
        (go target-indax-stance)
        )
      )
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flag jump-out))
    (set-time! (-> self state-time))
    (set! (-> self neck flex-blend) 0.0)
    (let ((gp-0 (-> self attack-info)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((v1-5 gp-0))
          (set! (-> v1-5 attacker) (the-as handle #f))
          (set! (-> v1-5 mode) 'generic)
          (set! (-> v1-5 shove-back) 6144.0)
          (set! (-> v1-5 shove-up) 4915.2)
          (set! (-> v1-5 angle) #f)
          (set! (-> v1-5 trans quad) (-> self control trans quad))
          (set! (-> v1-5 control) 0.0)
          (set! (-> v1-5 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
          (set! (-> v1-5 damage) (-> *FACT-bank* health-default-inc))
          )
        (case arg0
          (('shove)
           (let ((v1-8 gp-0))
             (set! (-> v1-8 shove-back) (-> *TARGET-bank* smack-surface-dist))
             (set! (-> v1-8 shove-up) (-> *TARGET-bank* smack-surface-height))
             (set! (-> v1-8 angle) 'shove)
             )
           )
          )
        (combine! gp-0 arg1 self)
        (when (not (logtest? (-> gp-0 mask) (attack-mask vector)))
          (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-for-control))
          (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
          (set! (-> gp-0 vector y) (-> gp-0 shove-up))
          )
        (set! (-> s5-0 quad) (-> gp-0 vector quad))
        (let ((f0-12 (vector-dot
                       (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                       )
                     )
              )
          (if (not (-> self attack-info angle))
              (set! (-> self attack-info angle) (if (>= 0.0 f0-12)
                                                    'front
                                                    'back
                                                    )
                    )
              )
          )
        (cond
          ((= arg0 'attack)
           (logior! (-> self focus-status) (focus-status hit))
           (set-time! (-> self game hit-time))
           (case (-> gp-0 mode)
             (('endlessfall)
              (cond
                ((= (-> self game mode) 'debug)
                 (let ((s4-1 (new-stack-vector0)))
                   (set! (-> s4-1 quad) (-> self control last-trans-on-ground quad))
                   (ja-channel-set! 0)
                   (suspend-for (seconds 1))
                   (move-to-point! (-> self control) s4-1)
                   )
                 (set! (-> self control camera-pos quad) (-> self control trans quad))
                 (send-event *camera* 'teleport)
                 (go target-indax-stance)
                 )
                (else
                  (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
                  (go target-indax-death (-> gp-0 mode))
                  )
                )
              )
             (('instant-death 'smush 'tomb-spider 'ice 'bot 'death)
              (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
              (if (= (-> self game mode) 'play)
                  (go target-indax-death (-> gp-0 mode))
                  )
              )
             (('shock)
              (pickup-collectable! (-> self fact) (pickup-type health) (- (-> gp-0 damage)) (the-as handle #f))
              (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
                  (go target-indax-death (if (logtest? (target-flags tf26) (-> self target-flags))
                                             'endlessfall
                                             (-> gp-0 mode)
                                             )
                      )
                  )
              )
             (('lava 'melt 'fry 'slime)
              (when (= (-> self game mode) 'play)
                (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
                (go target-indax-death (-> gp-0 mode))
                )
              )
             (else
               (pickup-collectable! (-> self fact) (pickup-type health) (- (-> gp-0 damage)) (the-as handle #f))
               )
             )
           (target-hit-effect gp-0)
           )
          (else
            (case (-> gp-0 mode)
              (('burn 'burnup)
               (sound-play "dax-get-burned")
               )
              )
            )
          )
        (set! (-> self control mod-surface) *smack-mods*)
        (cond
          ((logtest? (target-flags tf26) (-> self target-flags))
           (ja-channel-push! 1 (seconds 0.1))
           (ja-no-eval :group! daxter-indax-hang-get-on-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (set-forward-vel 0.0)
             (suspend)
             (ja :num! (seek!))
             )
           (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
               (go target-indax-death 'endlessfall)
               )
           (go target-indax-hang-stance)
           )
          (else
            (target-indax-hit-setup-anim gp-0)
            (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-falling-anim-trans 1.0)
            )
          )
        )
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact health)))
          (go target-indax-death (-> gp-0 mode))
          )
      )
    (go target-indax-hit-ground #f)
    )
  :post target-indax-post
  )

(defstate target-indax-death (target)
  :event (-> target-death event)
  :exit (behavior ()
    ((-> target-death exit))
    (target-indax-exit)
    )
  :trans (-> target-indax-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self 0)
    (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (let ((s5-0 (-> self child)))
      (while s5-0
        (send-event (ppointer->process s5-0) 'notice 'die)
        (set! s5-0 (-> s5-0 0 brother))
        )
      )
    (set! (-> self death-resetter continue) #f)
    (set! (-> self death-resetter node) (game-task-node none))
    (set! (-> self death-resetter reset-mode) 'life)
    (set! (-> self death-resetter execute) #f)
    (cond
      ((or (= arg0 'none) (= arg0 'instant-death))
       )
      ((= arg0 'endlessfall)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds175" -99.0 0)
             )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (logior! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noendlessfall #x1))
       (logclear! (-> self water flags) (water-flag swim-ground))
       (set! (-> self post-hook) target-no-move-post)
       (let ((f30-0 (if (rand-vu-percent? 0.2)
                        0.0
                        55.0
                        )
                    )
             )
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! daxter-indax-death-fall-ja :num! (seek!) :frame-num (ja-aframe f30-0 0))
         )
       (until (ja-done? 0)
         (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
           (let ((v1-60 (process->ppointer self)))
             (set! (-> a1-9 from) v1-60)
             )
           (set! (-> a1-9 num-params) 2)
           (set! (-> a1-9 message) 'joystick)
           (set! (-> a1-9 param 0) (the-as uint 0))
           (set! (-> a1-9 param 1) (the-as uint -1082130432))
           (send-event-function *camera* a1-9)
           )
         (vector-reset! (-> self control transv))
         (suspend)
         (ja :num! (seek!))
         )
       (remove-setting! 'mode-name)
       )
      ((= arg0 'smush)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
             )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (set! (-> self control mod-surface) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (ja-no-eval :group! daxter-indax-death-squashed-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      ((= arg0 'tomb-spider)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
             )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (set! (-> self control mod-surface) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (cond
         ((rand-vu-percent? 0.5)
          (ja-no-eval :group! daxter-indax-death-eaten-ja :num! (seek!) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
         (else
           (ja-no-eval :group! daxter-indax-death-kill-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
         )
       )
      ((= arg0 'ice)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
             )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (set! (-> self control mod-surface) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (ja-no-eval :group! daxter-indax-death-freeze-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (target-death-anim-trans)
         (suspend)
         (ja :num! (seek!))
         )
       )
      ((= arg0 'shock)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
             )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (set! (-> self control mod-surface) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (ja-no-eval :group! daxter-indax-death-shock-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (target-death-anim-trans)
         (suspend)
         (ja :num! (seek!))
         )
       )
      ((or (= arg0 'lava) (= arg0 'melt) (= arg0 'fry) (= arg0 'slime))
       (sound-play "death-melt")
       (cond
         ((logtest? (-> *part-group-id-table* 233 flags) (sp-group-flag sp13))
          (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
          (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 233))
          )
         (else
           (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
           (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 233))
           )
         )
       (let ((v1-266 (-> self control root-prim)))
         (set! (-> v1-266 prim-core collide-as) (collide-spec))
         (set! (-> v1-266 prim-core collide-with) (collide-spec))
         )
       0
       (set! (-> self post-hook) target-no-ja-move-post)
       (ja-channel-set! 0)
       (ja-post)
       (suspend-for (seconds 2))
       )
      ((= arg0 'bot)
       (set! (-> self post-hook) target-no-move-post)
       (while (not (-> self control unknown-spool-anim00))
         (suspend)
         )
       )
      (else
        (set! (-> self control unknown-sound-id00)
              (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
              )
        (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
        (set! (-> self control mod-surface) *neutral-mods*)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! daxter-indax-death-kill-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (initialize! (-> self game) 'life (the-as game-save #f) (the-as string #f) (the-as resetter-spec #f))
    (set-time! (-> self state-time))
    (sleep-code)
    )
  :post target-no-stick-post
  )

(defstate target-indax-grab (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (cond
      ((and (= message 'query) (= (-> block param 0) 'mode))
       (-> self state name)
       )
      (else
        (case message
          (('end-mode)
           (case (-> block param 0)
             (('grab)
              (go target-indax-stance)
              )
             (('indax)
              (go target-grab 'stance)
              )
             )
           )
          (('clone-anim)
           (go target-clone-anim (process->handle (the-as process (-> block param 0))))
           )
          (('change-mode)
           (case (-> block param 0)
             (('normal)
              (go target-grab 'stance)
              )
             )
           )
          (('anim)
           (let ((v0-0 (the-as object (-> block param 0))))
             (set! (-> self control unknown-word04) (the-as uint v0-0))
             v0-0
             )
           )
          (else
            (target-generic-event-handler proc argc message block)
            )
          )
        )
      )
    )
  :enter (-> target-grab enter)
  :exit (behavior ()
    (target-indax-exit)
    ((-> target-grab exit))
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-push! 1 (seconds 0.05))
    (until #f
      (ja-no-eval :group! daxter-indax-stance-ja :num! (seek! max 1.5) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 1.5))
        )
      )
    #f
    )
  :post (-> target-grab post)
  )
