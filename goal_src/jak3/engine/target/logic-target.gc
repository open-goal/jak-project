;;-*-Lisp-*-
(in-package goal)

;; name: logic-target.gc
;; name in dgo: logic-target
;; dgos: GAME

;; DECOMP BEGINS

(defbehavior build-conversions target ((arg0 vector))
  (when (!= (-> self control prev-surf) (-> self control surf))
    (set! (-> self control prev-surf) (-> self control surf))
    (set-time! (-> self control time-of-last-surface-change))
    )
  (surface-mult! (-> self control current-surface) (-> self control mod-surface) (-> self control surf))
  (when (and (and (= (-> self fact eco-type) 3) (>= (-> self fact eco-level) 1.0))
             (or (= (-> self control mod-surface name) 'run) (= (-> self control mod-surface name) 'jump))
             )
    (+! (-> self control current-surface target-speed) 20480.0)
    (+! (-> self control current-surface transv-max) 20480.0)
    )
  (when (and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
             (or (= (-> self control mod-surface name) 'run)
                 (= (-> self control mod-surface name) 'jump)
                 (= (-> self control mod-surface name) 'attack)
                 )
             )
    (set! (-> self control current-surface target-speed)
          (* 1.2 (-> self darkjak-giant-interp) (-> self control current-surface target-speed))
          )
    (set! (-> self control current-surface transv-max)
          (* 1.2 (-> self darkjak-giant-interp) (-> self control current-surface transv-max))
          )
    )
  (let ((f0-11 (-> *setting-control* user-current speed-mult)))
    (set! (-> self control current-surface target-speed) (* (-> self control current-surface target-speed) f0-11))
    (set! (-> self control current-surface transv-max) (* (-> self control current-surface transv-max) f0-11))
    )
  (let ((s5-0 (new-stack-vector0)))
    (vector-z-quaternion! s5-0 (-> self control quat-for-control))
    (when (logtest? (-> self control mod-surface flags) (surface-flag xz-local))
      (vector-flatten! s5-0 s5-0 (-> self control dynam gravity-normal))
      (vector-normalize! s5-0 1.0)
      )
    (forward-up-nopitch->inv-matrix (-> self control c-R-w) s5-0 (-> self control local-normal))
    )
  (matrix-transpose! (-> self control w-R-c) (-> self control c-R-w))
  (vector-matrix*! (-> self control transv-ctrl) arg0 (-> self control w-R-c))
  (set! (-> self control last-gravity-normal quad) (-> self control gravity-normal quad))
  (let ((v0-7 (-> self control gravity-normal)))
    (set! (-> v0-7 quad) (-> self control dynam gravity-normal quad))
    v0-7
    )
  )

(defbehavior vector-turn-to target ((arg0 vector))
  (forward-up-nopitch->quaternion
    (-> self control dir-targ)
    (vector-normalize-copy! (new 'stack-no-clear 'vector) arg0 1.0)
    (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (build-conversions (-> self control transv))
  )

;; WARN: Return type mismatch collide-status vs none.
(defbehavior reverse-conversions target ((arg0 vector))
  (let ((v1-1 (-> self control transv-ctrl)))
    (set! (-> self control ctrl-xz-vel) (sqrtf (+ (* (-> v1-1 x) (-> v1-1 x)) (* (-> v1-1 z) (-> v1-1 z)))))
    )
  (vector-matrix*! arg0 (-> self control transv-ctrl) (-> self control c-R-w))
  (set! (-> self control old-status) (-> self control status))
  (none)
  )

(defun-debug draw-history ((arg0 control-info))
  (when (nonzero? *display-collide-history*)
    (when (cpad-pressed? 0 l3)
      (set! (-> arg0 history-length) (logand (+ (-> arg0 history-length) 1) 3))
      (if (cpad-hold? 0 l2)
          (set! (-> arg0 history-length) (the-as uint 1000))
          )
      )
    (let* ((v1-15 (-> arg0 history-length))
           (gp-0 (cond
                   ((zero? v1-15)
                    465
                    )
                   ((= v1-15 1)
                    469
                    )
                   ((= v1-15 2)
                    473
                    )
                   ((= v1-15 3)
                    913
                    )
                   (else
                     384
                     )
                   )
                 )
           (a0-5 (new 'stack 'history-iterator (the-as uint 1800)))
           )
      (set! (-> a0-5 out) #t)
      (set! (-> a0-5 owner) (the-as uint 2))
      (set! (-> a0-5 channel-mask) (the-as uint gp-0))
      (history-draw a0-5)
      )
    )
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defun-debug target-history-print ((arg0 history-iterator))
  (local-vars
    (sv-16 object)
    (sv-24 int)
    (sv-32 collide-status)
    (sv-40 number)
    (sv-44 vector)
    (sv-48 vector)
    (sv-52 vector)
    (sv-56 vector)
    (sv-60 vector)
    (sv-64 vector)
    (sv-68 number)
    (sv-72 history-elt)
    (sv-80 time-frame)
    (sv-88 uint)
    )
  (set! sv-16 (-> arg0 out))
  (set! sv-24 0)
  (set! sv-32 (collide-status))
  (set! sv-40 0)
  (set! sv-44 *zero-vector*)
  (set! sv-48 *zero-vector*)
  (set! sv-52 *zero-vector*)
  (set! sv-56 *zero-vector*)
  (set! sv-60 *zero-vector*)
  (set! sv-64 *zero-vector*)
  (set! sv-68 0)
  (until #f
    (set! sv-72 (update-entries! arg0))
    (if (not sv-72)
        (return #f)
        )
    (set! sv-80 (frame-counter-delta arg0 sv-72))
    (set! sv-88 (-> sv-72 record-id))
    (when (!= sv-24 sv-88)
      (set! sv-24 (the-as int sv-88))
      (format
        (-> arg0 out)
        "~6D ~8S #x~8X "
        sv-80
        (if (logtest? sv-32 (collide-status no-touch))
            "air"
            (-> *pat-mode-info* (shr (shl (the-as int sv-68) 54) 61) name)
            )
        sv-32
        )
      (format
        (-> arg0 out)
        "~C~C~C~C~C~C"
        (if (not (logtest? (the-as int sv-40) 1))
            103
            87
            )
        (if (not (logtest? (the-as int sv-40) 2))
            103
            87
            )
        (cond
          ((logtest? (the-as int sv-40) 2048)
           71
           )
          ((not (logtest? (the-as int sv-40) 4))
           103
           )
          (else
            87
            )
          )
        (cond
          ((logtest? (the-as int sv-40) 512)
           66
           )
          ((logtest? (the-as int sv-40) 8)
           76
           )
          (else
            99
            )
          )
        (if (not (logtest? (the-as int sv-40) 16))
            110
            66
            )
        (if (not (logtest? (the-as int sv-40) 32))
            103
            65
            )
        )
      (format
        (-> arg0 out)
        "~C~C "
        (cond
          ((logtest? #x10000 (the-as int sv-40))
           80
           )
          ((logtest? (the-as int sv-40) #x8000)
           85
           )
          ((logtest? (the-as int sv-40) 64)
           78
           )
          (else
            95
            )
          )
        (cond
          ((logtest? (the-as int sv-40) 1024)
           76
           )
          ((logtest? (the-as int sv-40) 256)
           67
           )
          ((logtest? (the-as int sv-40) 128)
           108
           )
          (else
            95
            )
          )
        )
      (format (-> arg0 out) "trans: ~6,,2m ~6,,2m ~6,,2m  " (-> sv-44 x) (-> sv-44 y) (-> sv-44 z))
      (format (-> arg0 out) "int: ~6,,2m ~6,,2m ~6,,2m " (-> sv-56 x) (-> sv-56 y) (-> sv-56 z))
      (format (-> arg0 out) "vel: ~6,,2m ~6,,2m ~6,,2m " (-> sv-48 x) (-> sv-48 y) (-> sv-48 z))
      (format (-> arg0 out) "vel-out: ~6,,2m ~6,,2m ~6,,2m " (-> sv-52 x) (-> sv-52 y) (-> sv-52 z))
      (format (-> arg0 out) "normal: ~6,,2f ~6,,2f ~6,,2f " (-> sv-60 x) (-> sv-60 y) (-> sv-60 z))
      (format (-> arg0 out) "local: ~6,,2f ~6,,2f ~6,,2f " (-> sv-64 x) (-> sv-64 y) (-> sv-64 z))
      (format (-> arg0 out) "~%")
      )
    (case (-> sv-72 channel)
      (((history-channel trans))
       (set! sv-44 (-> sv-72 vector))
       )
      (((history-channel transv-in))
       (set! sv-48 (-> sv-72 vector))
       )
      (((history-channel transv-out))
       (set! sv-52 (-> sv-72 vector))
       )
      (((history-channel intersect))
       (set! sv-56 (-> sv-72 vector))
       )
      (((history-channel pat))
       (set! sv-68 (-> sv-72 vector x))
       )
      (((history-channel collide-status))
       (set! sv-32 (-> sv-72 collide-status))
       (set! sv-40 (-> sv-72 vector z))
       )
      (((history-channel surface-normal))
       (set! sv-60 (-> sv-72 vector))
       )
      (((history-channel local-normal))
       (set! sv-64 (-> sv-72 vector))
       )
      )
    )
  #f
  )

(defun-debug target-print-stats ((arg0 target) (arg1 symbol))
  (local-vars
    (sv-64 int)
    (sv-72 int)
    (sv-80 art-joint-anim-manager)
    (sv-96 string)
    (sv-112 string)
    (sv-128 string)
    (sv-144 string)
    (sv-160 string)
    (sv-176 string)
    (sv-192 string)
    (sv-208 string)
    (sv-224 string)
    (sv-240 string)
    (sv-256 string)
    (sv-272 string)
    (sv-288 string)
    (sv-304 string)
    )
  (with-pp
    (let ((s5-0 pp))
      (set! pp arg0)
      (when (and *display-ground-stats* arg0)
        (let ((s3-0 format)
              (s2-0 arg1)
              (s1-0 "~0kpoly:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-0 (-> arg0 control poly-pat))
              )
          (set! sv-96 (pat-mode->string (-> arg0 control poly-pat)))
          (set! sv-112 (pat-material->string (-> arg0 control poly-pat)))
          (let ((t1-0 (pat-event->string (-> arg0 control poly-pat))))
            (s3-0 s2-0 s1-0 s0-0 sv-96 sv-112 t1-0)
            )
          )
        (let ((s3-1 format)
              (s2-1 arg1)
              (s1-1 "~0kgrnd:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-1 (-> arg0 control ground-pat))
              )
          (set! sv-128 (pat-mode->string (-> arg0 control ground-pat)))
          (set! sv-144 (pat-material->string (-> arg0 control ground-pat)))
          (let ((t1-1 (pat-event->string (-> arg0 control ground-pat))))
            (s3-1 s2-1 s1-1 s0-1 sv-128 sv-144 t1-1)
            )
          )
        (let ((s3-2 format)
              (s2-2 arg1)
              (s1-2 "~0kwall:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-2 (-> arg0 control wall-contact-pat))
              )
          (set! sv-160 (pat-mode->string (-> arg0 control wall-contact-pat)))
          (set! sv-176 (pat-material->string (-> arg0 control wall-contact-pat)))
          (let ((t1-2 (pat-event->string (-> arg0 control wall-contact-pat))))
            (s3-2 s2-2 s1-2 s0-2 sv-160 sv-176 t1-2)
            )
          )
        (let ((s3-3 format)
              (s2-3 arg1)
              (s1-3 "~0kgspt:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-3 (-> arg0 control gspot-pat-surfce))
              )
          (set! sv-192 (pat-mode->string (-> arg0 control gspot-pat-surfce)))
          (set! sv-208 (pat-material->string (-> arg0 control gspot-pat-surfce)))
          (let ((t1-3 (pat-event->string (-> arg0 control gspot-pat-surfce))))
            (s3-3 s2-3 s1-3 s0-3 sv-192 sv-208 t1-3)
            )
          )
        )
      (when (and *stats-target* arg0)
        (format
          arg1
          "~0ks: ~M ~X/~X ~A ~A ~A~%"
          (-> arg0 control ctrl-xz-vel)
          (-> arg0 control status)
          (-> arg0 control prev-status)
          (if (-> arg0 state)
              (-> arg0 state name)
              )
          (-> arg0 control surf name)
          (-> arg0 control mod-surface name)
          )
        (let ((s3-4 (-> arg0 focus-status)))
          (if (= (logand s3-4 (focus-status pole)) (focus-status pole))
              (format arg1 "pole ")
              )
          (if (= (logand s3-4 (focus-status dead)) (focus-status dead))
              (format arg1 "dead ")
              )
          (if (= (logand (focus-status gun) s3-4) (focus-status gun))
              (format arg1 "gun ")
              )
          (if (= (logand (focus-status pilot) s3-4) (focus-status pilot))
              (format arg1 "racer ")
              )
          (if (= (logand (focus-status mech) s3-4) (focus-status mech))
              (format arg1 "mech ")
              )
          (if (= (logand (focus-status shooting) s3-4) (focus-status shooting))
              (format arg1 "shooting ")
              )
          (if (= (logand (focus-status halfpipe) s3-4) (focus-status halfpipe))
              (format arg1 "halfpipe ")
              )
          (if (= (logand (focus-status light) s3-4) (focus-status light))
              (format arg1 "light ")
              )
          (if (= (logand s3-4 (focus-status in-head)) (focus-status in-head))
              (format arg1 "in-head ")
              )
          (if (= (logand s3-4 (focus-status grabbed)) (focus-status grabbed))
              (format arg1 "grabbed ")
              )
          (if (= (logand s3-4 (focus-status ignore)) (focus-status ignore))
              (format arg1 "ignore ")
              )
          (if (= (logand s3-4 (focus-status under-water)) (focus-status under-water))
              (format arg1 "under-water ")
              )
          (if (= (logand s3-4 (focus-status disable)) (focus-status disable))
              (format arg1 "disable ")
              )
          (if (= (logand s3-4 (focus-status hit)) (focus-status hit))
              (format arg1 "hit ")
              )
          (if (= (logand s3-4 (focus-status inactive)) (focus-status inactive))
              (format arg1 "inactive ")
              )
          (if (= (logand (focus-status invulnerable) s3-4) (shl #x8000 16))
              (format arg1 "invulnerable ")
              )
          (if (= (logand s3-4 (focus-status dangerous)) (focus-status dangerous))
              (format arg1 "dangerous ")
              )
          (if (= (logand (focus-status gun-no-target) s3-4) (shl 4 32))
              (format arg1 "gun-no-target ")
              )
          (if (= (logand (focus-status teleporting) s3-4) (focus-status teleporting))
              (format arg1 "teleporting ")
              )
          (if (= (logand (focus-status indax) s3-4) (focus-status indax))
              (format arg1 "indax ")
              )
          (if (= (logand (focus-status turret) s3-4) (shl 1 32))
              (format arg1 "turret ")
              )
          (if (= (logand (focus-status tube) s3-4) (focus-status tube))
              (format arg1 "tube ")
              )
          (if (= (logand (focus-status pilot) s3-4) (focus-status pilot))
              (format arg1 "pilot ")
              )
          (if (= (logand s3-4 (focus-status edge-grab)) (focus-status edge-grab))
              (format arg1 "edge-grab ")
              )
          (if (= (logand (focus-status dark) s3-4) (focus-status dark))
              (format arg1 "dark ")
              )
          (if (= (logand (focus-status arrestable) s3-4) (focus-status arrestable))
              (format arg1 "arrestable ")
              )
          (if (= (logand (focus-status rail) s3-4) (focus-status rail))
              (format arg1 "rail ")
              )
          (if (= (logand s3-4 (focus-status pilot-riding)) (focus-status pilot-riding))
              (format arg1 "pilot-riding ")
              )
          (if (= (logand (focus-status board) s3-4) (focus-status board))
              (format arg1 "board ")
              )
          (if (= (logand s3-4 (focus-status on-water)) (focus-status on-water))
              (format arg1 "on-water ")
              )
          (if (= (logand s3-4 (focus-status in-air)) (focus-status in-air))
              (format arg1 "in-air ")
              )
          (if (= (logand (focus-status no-gravity) s3-4) (shl 2 32))
              (format arg1 "no-gravity ")
              )
          (if (= (logand (focus-status carry) s3-4) (focus-status carry))
              (format arg1 "carry ")
              )
          (if (= (logand s3-4 (focus-status flut)) (focus-status flut))
              (format arg1 "flut ")
              )
          (if (= (logand s3-4 (focus-status touch-water)) (focus-status touch-water))
              (format arg1 "touch-water ")
              )
          (if (= (logand (focus-status super) s3-4) (focus-status super))
              (format arg1 "super ")
              )
          )
        (if (logtest? (-> arg0 target-flags) (target-flags tinvuln1))
            (format arg1 "tinvul1 ")
            )
        (if (logtest? (target-flags tinvuln2) (-> arg0 target-flags))
            (format arg1 "tinvul2 ")
            )
        (if (logtest? (target-flags disable-attacks) (-> arg0 target-flags))
            (format arg1 "disable-attacks ")
            )
        (if (logtest? (target-flags invisible) (-> arg0 target-flags))
            (format arg1 "invisible ")
            )
        (if (logtest? (target-flags lleg-still) (-> arg0 target-flags))
            (format arg1 "lleg-still ")
            )
        (if (logtest? (target-flags rleg-still) (-> arg0 target-flags))
            (format arg1 "rleg-still ")
            )
        (if (logtest? (target-flags lleg-no-ik) (-> arg0 target-flags))
            (format arg1 "lleg-no-ik ")
            )
        (if (logtest? (target-flags rleg-no-ik) (-> arg0 target-flags))
            (format arg1 "rleg-no-ik ")
            )
        (format arg1 "~%")
        (format
          arg1
          "~0k~9S ~9S ~9S ~9S ~9S ~9S~%"
          (if (logtest? (-> arg0 control status) (collide-status on-surface))
              "on-surface"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status on-ground))
              "on-ground"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status touch-surface))
              "t-surface"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status touch-wall))
              "t-wall"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status touch-actor))
              "t-act"
              ""
              )
          (cond
            ((logtest? (-> arg0 control status) (collide-status touch-ceiling))
             "t-ceil"
             )
            ((logtest? (-> arg0 control status) (collide-status on-water))
             "on-water"
             )
            (else
              ""
              )
            )
          )
        (when (logtest? (-> arg0 water flags) (water-flag active))
          (format
            arg1
            "water at ~M ~5S ~5S ~5S ~5S "
            (-> arg0 water height)
            (if (logtest? (water-flag touch-water) (-> arg0 water flags))
                "water"
                ""
                )
            (if (logtest? (water-flag wading) (-> arg0 water flags))
                "wade"
                ""
                )
            (if (logtest? (water-flag swimming) (-> arg0 water flags))
                "swim"
                ""
                )
            (if (logtest? (-> arg0 water flags) (water-flag under-water))
                "under"
                ""
                )
            )
          (format arg1 "~2S~%" (if (logtest? (-> arg0 water flags) (water-flag swim-ground))
                                   "sg"
                                   ""
                                   )
                  )
          )
        (format
          arg1
          "~0kan:~,,3f su:~,,3f ti:~,,3f to:~,,3f pa:~,,3f~%"
          (-> arg0 control surface-angle)
          (-> arg0 control local-slope-z)
          (-> arg0 control local-slope-x)
          (-> arg0 control touch-angle)
          (-> arg0 control poly-angle)
          )
        (let ((v1-175 (-> arg0 control trans)))
          (format arg1 "pos: ~6,,2m ~6,,2m ~6,,2m  " (-> v1-175 x) (-> v1-175 y) (-> v1-175 z))
          )
        (let ((s3-5 format)
              (s2-4 arg1)
              (s1-4 "~0kpol:~X/~S/~S/~S~%")
              (s0-4 (-> arg0 control poly-pat))
              )
          (set! sv-224 (pat-mode->string (-> arg0 control poly-pat)))
          (set! sv-240 (pat-material->string (-> arg0 control poly-pat)))
          (let ((t1-10 (pat-event->string (-> arg0 control poly-pat))))
            (s3-5 s2-4 s1-4 s0-4 sv-224 sv-240 t1-10)
            )
          )
        (let ((s3-6 format)
              (s2-5 arg1)
              (s1-5 "~0kcur:~X/~S/~S/~S   ")
              (s0-5 (-> arg0 control cur-pat))
              )
          (set! sv-256 (pat-mode->string (-> arg0 control cur-pat)))
          (set! sv-272 (pat-material->string (-> arg0 control cur-pat)))
          (let ((t1-11 (pat-event->string (-> arg0 control cur-pat))))
            (s3-6 s2-5 s1-5 s0-5 sv-256 sv-272 t1-11)
            )
          )
        (let ((s3-7 format)
              (s2-6 arg1)
              (s1-6 "~0kgnd:~X/~S/~S/~S~%")
              (s0-6 (-> arg0 control ground-pat))
              )
          (set! sv-288 (pat-mode->string (-> arg0 control ground-pat)))
          (set! sv-304 (pat-material->string (-> arg0 control ground-pat)))
          (let ((t1-12 (pat-event->string (-> arg0 control ground-pat))))
            (s3-7 s2-6 s1-6 s0-6 sv-288 sv-304 t1-12)
            )
          )
        (let ((t9-79 format)
              (a0-147 arg1)
              (a1-59 "~0kvel: x:~M  y:~M  z:~M   yv:~M  xzv:~M~%")
              (a2-13 (-> arg0 control transv x))
              (a3-14 (-> arg0 control transv y))
              (t0-14 (-> arg0 control transv z))
              (t1-14 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv)))
              (v1-195 (new-stack-vector0))
              )
          (let ((f0-15 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv))))
            0.0
            (vector-!
              v1-195
              (-> arg0 control transv)
              (vector-float*! v1-195 (-> arg0 control dynam gravity-normal) f0-15)
              )
            )
          (let ((f0-16 (vector-length v1-195)))
            f0-16
            (t9-79 a0-147 a1-59 a2-13 a3-14 t0-14 t1-14 f0-16)
            )
          )
        (format
          arg1
          "~0ky:~,,2M t:~d cy: ~,,2M my: ~,,2M impv:~,,2M "
          (-> arg0 control last-trans-any-surf y)
          (- (current-time) (-> arg0 control last-time-on-surface))
          (- (-> arg0 control trans y) (-> arg0 control last-trans-any-surf y))
          (- (-> arg0 control highest-jump-mark y) (-> arg0 control last-trans-leaving-surf y))
          (-> arg0 control ground-impact-vel)
          )
        (let* ((t9-81 format)
               (a0-149 arg1)
               (a1-61 "~0k~Tcd: ~,,2M md:~,,2M~%")
               (v1-206 (vector-! (new-stack-vector0) (-> arg0 control trans) (-> arg0 control last-trans-any-surf)))
               (a2-17 (sqrtf (+ (* (-> v1-206 x) (-> v1-206 x)) (* (-> v1-206 z) (-> v1-206 z)))))
               (v1-208
                 (vector-! (new-stack-vector0) (-> arg0 control highest-jump-mark) (-> arg0 control last-trans-leaving-surf))
                 )
               )
          (t9-81 a0-149 a1-61 a2-17 (sqrtf (+ (* (-> v1-208 x) (-> v1-208 x)) (* (-> v1-208 z) (-> v1-208 z)))))
          )
        (format
          arg1
          "~0kbend b:~F t:~F s:~F~%"
          (-> arg0 control bend-amount)
          (-> arg0 control bend-target)
          (-> arg0 control bend-speed)
          )
        (set! sv-64 0)
        (set! sv-72 0)
        (set! sv-80 *anim-manager*)
        (countdown (s3-8 (-> sv-80 free-index))
          (when (= (-> sv-80 slot s3-8 time-stamp) (-> *display* base-clock frame-counter))
            (set! sv-72 (+ sv-72 1))
            (set! sv-64 (+ sv-64 (used-bytes-for-slot sv-80 s3-8)))
            )
          )
        (format
          arg1
          "anim cache ~d anims ~dK total, ~d ~dK active~%"
          (-> sv-80 free-index)
          (sar (&- (-> sv-80 heap current) (the-as uint (-> sv-80 heap base))) 10)
          sv-72
          (sar sv-64 10)
          )
        (debug-print-channels (-> arg0 skel) arg1)
        )
      (draw-history (-> arg0 control))
      (set! pp s5-0)
      )
    #f
    )
  )

(defbehavior read-pad target ((arg0 vector))
  (when (!= (-> self control time-of-last-pad-read) (-> *display* real-clock frame-counter))
    (set! (-> self control last-pad-xz-dir quad) (-> self control pad-xz-dir quad))
    (set! (-> self control last-pad-magnitude) (-> self control pad-magnitude))
    (set! (-> self control time-of-last-pad-read) (-> *display* real-clock frame-counter))
    )
  (set! (-> arg0 x) (sin (-> self control cpad stick0-dir)))
  (set! (-> arg0 y) 0.0)
  (set! (-> arg0 z) (cos (-> self control cpad stick0-dir)))
  (set! (-> arg0 w) 0.0)
  (set! (-> self control pad-xz-dir quad) (-> arg0 quad))
  (set! (-> self control pad-magnitude) (-> self control cpad stick0-speed))
  (when (< (-> self control update-cam-R-w-start-time) (current-time))
    (let* ((s5-0 (-> self control cam-R-w))
           (a2-0 (matrix-local->world #t #f))
           (v1-24 (-> a2-0 rvec quad))
           (a0-14 (-> a2-0 uvec quad))
           (a1-1 (-> a2-0 fvec quad))
           (a2-1 (-> a2-0 trans quad))
           )
      (set! (-> s5-0 rvec quad) v1-24)
      (set! (-> s5-0 uvec quad) a0-14)
      (set! (-> s5-0 fvec quad) a1-1)
      (set! (-> s5-0 trans quad) a2-1)
      )
    )
  (vector-matrix*! arg0 arg0 (-> self control cam-R-w))
  )

(defbehavior set-pad target ((arg0 vector))
  (set! (-> self control pad-magnitude) (vector-length arg0))
  (vector-matrix*! (-> self control pad-xz-dir) arg0 (matrix-world->local #t #f))
  arg0
  )

(defun warp-vector-into-surface! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 matrix))
  (let ((t9-0 matrix-from-two-vectors!)
        (a0-1 (new 'stack-no-clear 'matrix))
        )
    (set! (-> a0-1 rvec quad) (the-as uint128 0))
    (set! (-> a0-1 uvec quad) (the-as uint128 0))
    (set! (-> a0-1 fvec quad) (the-as uint128 0))
    (set! (-> a0-1 trans quad) (the-as uint128 0))
    (let ((a2-1 (t9-0 a0-1 (-> arg3 uvec) arg2)))
      (vector-matrix*! arg0 arg1 a2-1)
      )
    )
  )

(defbehavior vector<-pad-in-surface! target ((arg0 vector) (arg1 symbol))
  (let ((a1-1 (read-pad (new-stack-vector0))))
    (warp-vector-into-surface! arg0 a1-1 (-> self control local-normal) (-> self control cam-R-w))
    )
  (if arg1
      (vector-float*! arg0 arg0 (-> self control pad-magnitude))
      )
  arg0
  )

;; WARN: Return type mismatch vector vs none.
(defun vector<-pad-in-matrix! ((arg0 vector) (arg1 cpad-info) (arg2 matrix))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (s5-0 (matrix-local->world #t #f))
        )
    (set! (-> gp-0 x) (* -0.0078125 (+ -128.0 (the float (-> arg1 leftx)))))
    (set! (-> gp-0 y) 0.0)
    (set! (-> gp-0 z) (* -0.0078125 (+ -128.0 (the float (-> arg1 lefty)))))
    (set! (-> gp-0 w) 0.0)
    (let ((f30-0 (vector-length gp-0)))
      (vector-matrix*! gp-0 gp-0 s5-0)
      (warp-vector-into-surface! arg0 gp-0 (-> arg2 uvec) s5-0)
      (vector-matrix*! arg0 arg0 arg2)
      (vector-normalize! arg0 f30-0)
      )
    )
  (none)
  )

(defbehavior local-pad-angle target ()
  (let ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f)))
    (vector-dot
      (vector-normalize! a0-1 1.0)
      (vector-z-quaternion! (new-stack-vector0) (-> self control quat-for-control))
      )
    )
  )

;; WARN: disable def twice: 93. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defbehavior turn-around? target ()
  (let* ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f))
         (gp-0 (vector-normalize! a0-1 1.0))
         (t9-2 vector-normalize!)
         (a0-2 (new-stack-vector0))
         )
    (set! (-> a0-2 quad) (-> self control transv quad))
    (let ((f0-1 (vector-dot gp-0 (t9-2 a0-2 1.0)))
          (a1-3 (-> self control transv-history))
          (f2-0 -1000.0)
          (f1-0 0.0)
          (a0-3 -1)
          (v1-7 (new 'static 'array time-frame 1 (seconds 0)))
          )
      (countdown (a2-0 15)
        (let ((a3-2 (-> a1-3 a2-0 quad)))
          (set! (-> a1-3 (+ a2-0 1) quad) a3-2)
          )
        )
      (set! (-> a1-3 0 quad) (-> self control transv quad))
      (set! (-> a1-3 0 w) (-> self control ctrl-xz-vel))
      (dotimes (a2-6 16)
        (+! f1-0 (-> a1-3 a2-6 w))
        (when (< f2-0 (-> a1-3 a2-6 w))
          (set! a0-3 a2-6)
          (set! f2-0 (-> a1-3 a2-6 w))
          )
        )
      (let ((f1-1 (* 0.0625 f1-0)))
        (set! (-> self control idx-of-fastest-xz-vel) a0-3)
        (set! (-> self control average-xz-vel) f1-1)
        (if (logtest? (-> self control current-surface flags) (surface-flag no-turn-around))
            (set-time! (-> v1-7 0))
            )
        (if (logtest? (target-flags tf26) (-> self target-flags))
            (and (>= (the-as uint (- (current-time) (-> v1-7 0))) (the-as uint 300))
                 (< f0-1 0.0)
                 (< (* 0.8 (-> self control current-surface target-speed)) f1-1)
                 (and (< 0.7 (-> self control pad-magnitude)) (time-elapsed? (-> self control time-of-last-lc) (seconds 0.3)))
                 )
            (and (>= (the-as uint (- (current-time) (-> v1-7 0))) (the-as uint 300))
                 (= (-> self ext-anim) (target-anim default))
                 (< f0-1 0.0)
                 (< (* 0.8 (-> self control current-surface target-speed)) f1-1)
                 (< 0.7 (-> self control pad-magnitude))
                 (time-elapsed? (-> self control last-time-touching-actor) (seconds 0.3))
                 (time-elapsed? (-> self control time-of-last-lc) (seconds 0.3))
                 (logtest? (-> self control status) (collide-status on-surface))
                 (and (< 0.7 (-> self control surface-angle)) #t)
                 )
            )
        )
      )
    )
  )

(defbehavior wall-hide? target ()
  (when (and (= (-> self ext-anim) (target-anim default))
             (< 0.7 (-> self control pad-magnitude))
             (< 0.7 (-> self control blocked-factor))
             (and (< (-> self control ctrl-xz-vel) 8192.0)
                  (logtest? (-> self control status) (collide-status touch-wall))
                  (not (logtest? (-> self control status) (collide-status touch-actor)))
                  (or (= (-> self control wall-contact-pat event) (pat-event hide))
                      (let ((a0-2 (level-get-target-inside *level*)))
                        (and a0-2 (logtest? (-> a0-2 info level-flags) (level-flags lf0)))
                        )
                      )
                  )
             )
    (if (time-elapsed? (-> self control time-of-last-wall-hide-first-check-pass) (seconds 0.1))
        (set-time! (-> self control time-of-first-wall-hide-first-check-pass))
        )
    (set-time! (-> self control time-of-last-wall-hide-first-check-pass))
    (when (time-elapsed? (-> self control time-of-first-wall-hide-first-check-pass) (seconds 0.5))
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (let ((v1-35 (-> gp-0 bbox))
              (a0-13 (-> self control trans))
              (a1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-0 x) 8192.0)
          (set! (-> a1-0 y) 10240.0)
          (set! (-> a1-0 z) 8192.0)
          (set! (-> a1-0 w) 1.0)
          (vector-! (the-as vector v1-35) a0-13 a1-0)
          )
        (let ((v1-37 (-> gp-0 bbox max))
              (a0-15 (-> self control trans))
              (a1-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-1 x) 8192.0)
          (set! (-> a1-1 y) 10240.0)
          (set! (-> a1-1 z) 8192.0)
          (set! (-> a1-1 w) 1.0)
          (vector+! v1-37 a0-15 a1-1)
          )
        (set! (-> gp-0 collide-with) (-> self control root-prim prim-core collide-with))
        (set! (-> gp-0 ignore-process0) self)
        (set! (-> gp-0 ignore-process1) #f)
        (set! (-> gp-0 ignore-pat) (-> self control pat-ignore-mask))
        ((method-of-object *collide-cache* collide-cache-method-12))
        (dotimes (s5-0 3)
          (set! (-> gp-0 start-pos quad) (-> self control collision-spheres s5-0 prim-core world-sphere quad))
          (vector-float*! (-> gp-0 move-dist) (-> self control wall-contact-normal) -8192.0)
          (let ((v1-49 gp-0))
            (set! (-> v1-49 radius) 4.096)
            (set! (-> v1-49 collide-with) (-> gp-0 collide-with))
            (set! (-> v1-49 ignore-process0) #f)
            (set! (-> v1-49 ignore-process1) #f)
            (set! (-> v1-49 ignore-pat)
                  (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                  )
            (set! (-> v1-49 action-mask) (collide-action solid))
            )
          (cond
            ((and (>= (probe-using-line-sphere *collide-cache* gp-0) 0.0)
                  (< 0.8 (vector-dot (-> gp-0 best-other-tri normal) (-> self control wall-contact-normal)))
                  )
             )
            (else
              (return #f)
              )
            )
          )
        )
      #t
      )
    )
  )

(defbehavior target-log-trans target ()
  (let ((v1-1 (-> self control trans-log-idx)))
    (set-time! (-> self control trans-log-times v1-1))
    (set! (-> self control trans-log-trans v1-1 quad) (-> self control trans quad))
    (set! (-> self control trans-log-idx) (logand (+ v1-1 1) 127))
    )
  0
  (none)
  )

(defbehavior target-move-dist target ((arg0 time-frame))
  (let ((s5-0 (new-stack-vector0))
        (f30-0 0.0)
        (gp-0 0)
        )
    (let ((s4-0 (-> self control)))
      (let* ((v1-0 127)
             (a1-2 (logand (+ (-> s4-0 trans-log-idx) v1-0) 127))
             )
        (while (and (not (time-elapsed? (-> s4-0 trans-log-times a1-2) arg0)) (> v1-0 0))
          (vector+! s5-0 s5-0 (-> s4-0 trans-log-trans a1-2))
          (+! gp-0 1)
          (+! v1-0 -1)
          (set! a1-2 (logand (+ a1-2 v1-0) 127))
          )
        )
      (vector-float/! s5-0 s5-0 (the float gp-0))
      (let ((s3-0 (- 128 gp-0)))
        (while (< s3-0 128)
          (let ((v1-5 (logand (+ (-> s4-0 trans-log-idx) s3-0) 127)))
            (+! f30-0 (vector-vector-distance s5-0 (-> s4-0 trans-log-trans v1-5)))
            )
          (+! s3-0 1)
          )
        )
      )
    (/ f30-0 (the float gp-0))
    )
  )

(defbehavior turn-to-vector target ((arg0 vector) (arg1 float))
  (let ((gp-0 (new-stack-vector0)))
    (warp-vector-into-surface! gp-0 arg0 (-> self control local-normal) (-> self control cam-R-w))
    (set! (-> self control last-turn-to-magnitude) (-> self control turn-to-magnitude))
    (set! (-> self control last-turn-to-angle) (-> self control turn-to-angle))
    (set! (-> self control last-to-target-pt-xz quad) (-> self control to-target-pt-xz quad))
    (set! (-> self control last-turn-to-target quad) (-> self control turn-to-target quad))
    (vector-float*! (-> self control turn-to-target) gp-0 arg1)
    (if (< 0.0 arg1)
        (warp-vector-into-surface! (-> self control to-target-pt-xz) arg0 *up-vector* (-> self control cam-R-w))
        )
    (dotimes (v1-17 7)
      (set! (-> self control turn-history-ctrl (+ v1-17 1) quad) (-> self control turn-history-ctrl v1-17 quad))
      )
    (set! (-> self control turn-history-ctrl 0 quad)
          (-> (vector-matrix*! gp-0 gp-0 (-> self control w-R-c)) quad)
          )
    (let ((f0-6 (atan (-> gp-0 x) (-> gp-0 z))))
      (set! (-> self control turn-to-magnitude) arg1)
      (set! (-> self control turn-to-angle) f0-6)
      )
    (let ((f0-8 (* arg1 (-> self control current-surface target-speed))))
      (set! (-> self control target-transv quad) (-> (vector-normalize! gp-0 f0-8) quad))
      )
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control target-transv) (-> self control c-R-w))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "target"
      (the-as rgba (new 'static 'rgba :r #xff :g #xff :a #x80))
      )
    )
  )

(defbehavior target-bend-vel-turn target ((arg0 vector))
  (cond
    ((= (-> self control current-surface vel-turn) 0.0)
     )
    ((< (-> self control current-surface vel-turn) 0.0)
     (let* ((v1-5 arg0)
            (f0-6 (sqrtf (+ (* (-> v1-5 x) (-> v1-5 x)) (* (-> v1-5 z) (-> v1-5 z)))))
            )
       (set-vector! arg0 0.0 (-> arg0 y) f0-6 1.0)
       )
     )
    (else
      (let ((f0-10 (atan (-> arg0 x) (-> arg0 z))))
        (vector-rotate-y! arg0 arg0 (fmin
                                      (* 0.03 (-> self clock time-adjust-ratio) (- f0-10))
                                      (* (-> self control current-surface vel-turn) (seconds-per-frame))
                                      )
                          )
        )
      )
    )
  arg0
  )

(defbehavior target-add-slide-factor target ((arg0 vector))
  (let* ((a1-2 (vector-flatten!
                 (new 'stack-no-clear 'vector)
                 (vector-negate! (new-stack-vector0) (-> self control dynam gravity-normal))
                 (-> self control local-normal)
                 )
               )
         (s4-1 (vector-matrix*! (new 'stack-no-clear 'vector) a1-2 (-> self control w-R-c)))
         (s5-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-1 1.0))
         )
    (vector+float*! arg0 arg0 s4-1 (-> self control current-surface slide-factor))
    (let ((a1-5 (-> self control low-coverage-tangent)))
      (when (not (or (= (- 1.0 (-> self control current-surface slope-up-traction)) 0.0) (< (vector-length s4-1) 0.1)))
        (let* ((a0-7 (vector-matrix*! (new 'stack-no-clear 'vector) a1-5 (-> self control w-R-c)))
               (v1-15 (new-stack-vector0))
               (f0-5 (vector-dot a0-7 arg0))
               )
          0.0
          (vector-! v1-15 arg0 (vector-float*! v1-15 a0-7 f0-5))
          (let* ((f1-5 (vector-length v1-15))
                 (f2-0 f1-5)
                 )
            (if (< f0-5 0.0)
                (set! f0-5 (* f0-5 (-> self control current-surface slope-up-traction)))
                )
            (let ((f0-6 (+ f0-5 (-> self control current-surface slope-down-factor))))
              (vector+! arg0 (vector-float*! arg0 a0-7 f0-6) (vector-float*! v1-15 v1-15 (/ f1-5 f2-0)))
              )
            )
          )
        )
      )
    (let ((t9-5 vector-xz-normalize!)
          (a0-10 (new-stack-vector0))
          )
      (set! (-> a0-10 quad) (-> arg0 quad))
      (let ((v1-18 (t9-5 a0-10 1.0)))
        (set! (-> v1-18 y) 0.0)
        (let* ((f0-10 (vector-dot s5-1 v1-18))
               (v1-20 arg0)
               (f1-10 (sqrtf (+ (* (-> v1-20 x) (-> v1-20 x)) (* (-> v1-20 z) (-> v1-20 z)))))
               )
          (if (>= f0-10 0.0)
              (vector-xz-normalize! arg0 (fmax 0.0 (+ f1-10 (* f0-10 (-> self control current-surface slope-down-factor)))))
              (vector-xz-normalize!
                arg0
                (fmax 0.0 (- f1-10 (* (- f0-10) (-> self control current-surface slope-up-factor))))
                )
              )
          )
        )
      )
    )
  arg0
  )

(defbehavior add-thrust target ()
  (let ((s5-0 (-> self control target-transv))
        (gp-0 (-> self control transv-ctrl))
        )
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> self control target-transv quad))
      (target-bend-vel-turn gp-0)
      (target-add-slide-factor s5-0)
      (let ((t9-2 vector-xz-normalize!)
            (a0-2 (new-stack-vector0))
            )
        (set! (-> a0-2 quad) (-> s5-0 quad))
        (let ((s3-0 (t9-2 a0-2 1.0)))
          (let ((t9-3 vector-xz-normalize!)
                (a0-3 (new-stack-vector0))
                )
            (set! (-> a0-3 quad) (-> gp-0 quad))
            (let ((v1-9 (t9-3 a0-3 1.0)))
              (set! (-> s3-0 y) 0.0)
              (set! (-> v1-9 y) 0.0)
              )
            )
          (let* ((f0-2 (-> s3-0 z))
                 (v1-10 gp-0)
                 (f1-4 (sqrtf (+ (* (-> v1-10 x) (-> v1-10 x)) (* (-> v1-10 z) (-> v1-10 z)))))
                 (v1-12 s5-0)
                 (f30-0
                   (cond
                     ((>= f1-4 (sqrtf (+ (* (-> v1-12 x) (-> v1-12 x)) (* (-> v1-12 z) (-> v1-12 z)))))
                      (let ((f0-3 (-> self control current-surface fric))
                            (f1-5 1.0)
                            (v1-17 gp-0)
                            )
                        (* f0-3 (fmax f1-5 (/ (sqrtf (+ (* (-> v1-17 x) (-> v1-17 x)) (* (-> v1-17 z) (-> v1-17 z))))
                                              (-> self control current-surface nonlin-fric-dist)
                                              )
                                      )
                           )
                        )
                      )
                     ((>= f0-2 0.0)
                      (+ (* f0-2 (-> self control current-surface seek0)) (* (- 1.0 f0-2) (-> self control current-surface seek90)))
                      )
                     (else
                       (+ (* (fabs f0-2) (-> self control current-surface seek180))
                          (* (+ 1.0 f0-2) (-> self control current-surface seek90))
                          )
                       )
                     )
                   )
                 )
            (let* ((s2-0 (-> self control btransv))
                   (s3-1 (vector-matrix*! (new 'stack-no-clear 'vector) s2-0 (-> self control w-R-c)))
                   )
              (if (< (-> s4-0 x) 0.0)
                  (set! (-> s3-1 x) (fmax (fmin 0.0 (-> s3-1 x)) (-> s4-0 x)))
                  (set! (-> s3-1 x) (fmax 0.0 (fmin (-> s3-1 x) (-> s4-0 x))))
                  )
              (if (< (-> s4-0 y) 0.0)
                  (set! (-> s3-1 y) (fmax (fmin 0.0 (-> s3-1 y)) (-> s4-0 y)))
                  (set! (-> s3-1 y) (fmax 0.0 (fmin (-> s3-1 y) (-> s4-0 y))))
                  )
              (if (< (-> s4-0 z) 0.0)
                  (set! (-> s3-1 z) (fmax (fmin 0.0 (-> s3-1 z)) (-> s4-0 z)))
                  (set! (-> s3-1 z) (fmax 0.0 (fmin (-> s3-1 z) (-> s4-0 z))))
                  )
              (if (< 0.2 (-> self control blocked-factor))
                  (vector-seek! s3-1 s4-0 (* 122880.0 (seconds-per-frame)))
                  )
              (vector-matrix*! s2-0 s3-1 (-> self control c-R-w))
              (let ((f28-0 (vector-vector-xz-distance s3-1 s4-0)))
                (when (and (not (logtest? (-> self control status) (collide-status touch-surface)))
                           (let ((v1-51 gp-0))
                             (< (sqrtf (+ (* (-> v1-51 x) (-> v1-51 x)) (* (-> v1-51 z) (-> v1-51 z))))
                                (sqrtf (+ (* (-> s3-1 x) (-> s3-1 x)) (* (-> s3-1 z) (-> s3-1 z))))
                                )
                             )
                           )
                  (let ((f0-37 (lerp-scale 163840.0 0.0 f28-0 0.0 20480.0)))
                    (if (and (< f28-0 20480.0) (< (-> s4-0 z) 0.0))
                        (set! f0-37 (* 2.0 f0-37))
                        )
                    (+! f30-0 f0-37)
                    )
                  )
                )
              )
            (if (and (not (logtest? (-> self control status) (collide-status touch-wall)))
                     (logtest? (-> self control old-status) (collide-status touch-wall))
                     (logtest? (-> self control mod-surface flags) (surface-flag air))
                     (< 0.0 (-> gp-0 y))
                     (< 0.0 (vector-dot
                              (-> self control dynam gravity-normal)
                              (vector-!
                                (new 'stack-no-clear 'vector)
                                (the-as vector (-> self control collision-spheres 1 prim-core))
                                (-> self control wall-contact-pt)
                                )
                              )
                        )
                     )
                (set-time! (-> self control time-of-last-clear-wall-in-jump))
                )
            (if (not (time-elapsed? (-> self control time-of-last-clear-wall-in-jump) (seconds 0.2)))
                (set! f30-0 (+ 204800.0 f30-0))
                )
            (if (and (not (logtest? (-> self control status) (collide-status touch-wall)))
                     (and (logtest? (-> self control old-status) (collide-status touch-wall))
                          (logtest? (-> self control mod-surface flags) (surface-flag air))
                          (< 0.0 (-> gp-0 y))
                          (< (-> gp-0 z) 0.0)
                          )
                     )
                (set! (-> gp-0 z) 0.0)
                )
            (let ((s4-2 (vector-! (new-stack-vector0) s5-0 gp-0)))
              (let ((f0-45 (* f30-0 (seconds-per-frame))))
                (set! (-> s4-2 y) 0.0)
                (let ((v1-104 s4-2))
                  (if (< f0-45 (sqrtf (+ (* (-> v1-104 x) (-> v1-104 x)) (* (-> v1-104 z) (-> v1-104 z)))))
                      (vector-xz-normalize! s4-2 f0-45)
                      )
                  )
                )
              (vector+! gp-0 gp-0 s4-2)
              )
            )
          )
        )
      )
    (set! (-> self control velocity-after-thrust) (vector-length gp-0))
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control transv-ctrl) (-> self control c-R-w))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "ltransv"
      (the-as rgba (new 'static 'rgba :g #xff :a #x80))
      )
    (set! (-> gp-1 quad) (-> self control btransv quad))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "btransv"
      (the-as rgba (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80))
      )
    )
  )

(defbehavior add-gravity target ()
  (let ((s5-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (compute-acc-due-to-gravity (-> self control) s5-0 (-> self control current-surface slip-factor))
    (vector-matrix*! gp-0 s5-0 (-> self control w-R-c))
    (vector-v++! (-> self control transv-ctrl) gp-0)
    )
  (let* ((a0-4
           (vector-matrix*! (new 'stack-no-clear 'vector) (-> self control dynam gravity-normal) (-> self control w-R-c))
           )
         (v1-9 (new-stack-vector0))
         (f0-2 (vector-dot a0-4 (-> self control transv-ctrl)))
         )
    0.0
    (vector-! v1-9 (-> self control transv-ctrl) (vector-float*! v1-9 a0-4 f0-2))
    (let* ((f1-2 (vector-length v1-9))
           (f2-0 f1-2)
           )
      (if (< f1-2 0.00004096)
          (set! f1-2 0.0)
          )
      (if (< f0-2 (- (-> self control dynam gravity-max)))
          (set! f0-2 (- (-> self control dynam gravity-max)))
          )
      (vector+!
        (-> self control transv-ctrl)
        (vector-float*! (-> self control transv-ctrl) a0-4 f0-2)
        (vector-float*! v1-9 v1-9 (/ f1-2 f2-0))
        )
      )
    )
  )

(defbehavior target-compute-slopes target ((arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (s4-0 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control)))
        (s3-0 (new 'stack-no-clear 'matrix))
        (s5-0 (vector-flatten!
                (new 'stack-no-clear 'vector)
                (-> self control dynam gravity-normal)
                (-> self control local-normal)
                )
              )
        )
    (forward-up-nopitch->inv-matrix s3-0 (-> self control c-R-w fvec) arg0)
    (set-vector! gp-0 0.0 0.0 1.0 1.0)
    (vector-matrix*! gp-0 gp-0 s3-0)
    (set! (-> self control surface-slope-z) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control local-slope-z) (- (vector-dot (-> self control local-normal) gp-0)))
    (set! (-> self control gspot-slope-z) (- (vector-dot (-> self control gspot-normal) gp-0)))
    (set! (-> self control ctrl-slope-z) (- (vector-dot s4-0 gp-0)))
    (set-vector! gp-0 1.0 0.0 0.0 1.0)
    (vector-matrix*! gp-0 gp-0 s3-0)
    (set! (-> self control surface-slope-x) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control local-slope-x) (- (vector-dot (-> self control local-normal) gp-0)))
    (set! (-> self control gspot-slope-x) (- (vector-dot (-> self control gspot-normal) gp-0)))
    (set! (-> self control ctrl-slope-x) (- (vector-dot s4-0 gp-0)))
    (set-vector! gp-0 1.0 0.0 0.0 1.0)
    (vector-matrix*! gp-0 gp-0 (-> self control c-R-w))
    (set! (-> self control ctrl-slope-heading) (vector-dot gp-0 s5-0))
    )
  0
  )

(defbehavior do-rotations1 target ()
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    0.0
    (-> self control current-surface tiltv)
    150
    (the int (-> self control current-surface tiltvf))
    0.0
    )
  )

(define *strafe-mode* #f)

(defbehavior do-rotations2 target ()
  (if *strafe-mode*
      (return 0)
      )
  (let ((gp-0 (vector-z-quaternion! (new-stack-vector0) (-> self control dir-targ)))
        (s5-0
          (cond
            ((logtest? (surface-flag turn-to-alt) (-> self control current-surface flags))
             (-> self control turn-to-alt-heading)
             )
            ((and (or (not (logtest? (logior (-> self control status) (-> self control old-status))
                                     (collide-status on-surface touch-surface)
                                     )
                           )
                      (not (time-elapsed? (-> self control last-time-touching-actor) (seconds 0.5)))
                      (not (and (-> self next-state) (let ((v1-18 (-> self next-state name)))
                                                       (or (= v1-18 'target-walk) (= v1-18 'target-gun-walk))
                                                       )
                                )
                           )
                      (not (time-elapsed? (-> self state-time) (seconds 0.5)))
                      (not (time-elapsed? (-> self control time-of-last-lc) (seconds 0.5)))
                      (logtest? (-> self control current-surface flags) (surface-flag turn-to-pad))
                      (!= (-> self control force-turn-to-strength) 0.0)
                      )
                  (not (logtest? (-> self control current-surface flags) (surface-flag turn-to-vel)))
                  )
             (-> self control to-target-pt-xz)
             )
            (else
              (-> self control transv)
              )
            )
          )
        )
    (let* ((s3-0 (-> self control bent-gravity-normal))
           (s4-0 (forward-up-nopitch->quaternion (new-stack-quaternion0) gp-0 s3-0))
           (s3-1 (forward-up-nopitch->quaternion (new-stack-quaternion0) s5-0 s3-0))
           (f0-2 (acos (vector-dot gp-0 s5-0)))
           (f1-2 (* (-> self control current-surface turnvv) (seconds-per-frame)))
           )
      (quaternion-slerp!
        (-> self control dir-targ)
        s4-0
        s3-1
        (cond
          ((and (or (>= 0.0 (-> self control turn-to-magnitude)) (< (current-time) (-> self control turn-lockout-end-time)))
                (not (logtest? (-> self control current-surface flags) (surface-flag turn-when-centered)))
                )
           0.0
           )
          ((< f0-2 f1-2)
           1.0
           )
          (else
            (/ f1-2 f0-2)
            )
          )
        )
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      (-> self control trans)
      gp-0
      (meters 2)
      (the-as rgba (new 'static 'rgba :r #xff :g #xff :a #x80))
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      (-> self control trans)
      s5-0
      (meters 2)
      (the-as rgba (new 'static 'rgba :r #xff :g #x80 :a #x80))
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control c-R-w fvec)
    (meters 2)
    (the-as rgba (new 'static 'rgba :r #xff :b #xff :a #x80))
    )
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    (-> self control current-surface turnv)
    0.0
    (the int (-> self control current-surface turnvf))
    150
    (-> self control turn-go-the-long-way)
    )
  (if (and (!= (-> self control turn-go-the-long-way) 0.0)
           (< (fabs
                (deg-diff
                  (quaternion-y-angle (-> self control quat-for-control))
                  (quaternion-y-angle (-> self control dir-targ))
                  )
                )
              182.04445
              )
           )
      (set! (-> self control turn-go-the-long-way) 0.0)
      )
  (quaternion-slerp!
    (-> self control quat)
    (-> self control quat-for-control)
    (-> self control override-quat)
    (-> self control override-quat-alpha)
    )
  (target-compute-slopes (-> self control dynam gravity-normal))
  )

(defun leg-ik-callback ((arg0 joint-mod-ik) (arg1 object) (arg2 object) (arg3 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg3 quad))
      (let ((f0-1 (- (-> arg3 y) (-> (target-pos 0) y))))
        (if (< 1228.8 f0-1)
            (set! f0-1 1228.8)
            )
        (if (< f0-1 409.6)
            (set! f0-1 409.6)
            )
        (+! (-> arg0 user-position y) f0-1)
        )
      (let* ((f0-4
               (vector-dot (-> arg0 user-normal) (vector-! (new 'stack-no-clear 'vector) arg3 (-> arg0 user-position)))
               )
             (f30-1 (lerp-scale 1.0 0.0 f0-4 0.0 2048.0))
             (s3-0 (new 'stack-no-clear 'vector))
             )
        (let ((v1-13 s5-0))
          (let ((a0-4 (-> arg0 user-normal)))
            (let ((a1-4 4096.0))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.lvf vf4 (&-> v1-13 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s3-0 quad) vf6)
        (vector-float*! (new 'stack-no-clear 'vector) (-> arg0 user-normal) -8192.0)
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          0.0
          (let ((f0-8 (intersect-ray-plane s3-0 (-> arg0 user-normal) (-> arg0 user-position) (-> arg0 user-normal)))
                (a0-7 s4-1)
                )
            (let ((v1-16 (-> arg0 user-normal)))
              (let ((a1-7 f0-8))
                (.mov vf7 a1-7)
                )
              (.lvf vf5 (&-> v1-16 quad))
              )
            (.lvf vf4 (&-> s3-0 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-7 quad) vf6)
            )
          (let ((a1-8 s4-1))
            (let ((v1-17 s4-1))
              (let ((a0-8 (-> arg0 user-normal)))
                (let ((a2-6
                        (- (vector-dot (-> arg0 user-normal) (vector-! (new 'stack-no-clear 'vector) s4-1 (-> arg0 user-position))))
                        )
                      )
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-8 quad))
                )
              (.lvf vf4 (&-> v1-17 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-8 quad) vf6)
            )
          (let ((a1-9 s5-0))
            (let ((v1-18 s5-0))
              (let ((a0-10 (vector-! (new 'stack-no-clear 'vector) s4-1 s5-0)))
                (let ((a2-9 (fmin 1.0 (* (-> arg0 user-blend) f30-1))))
                  (.mov vf7 a2-9)
                  )
                (.lvf vf5 (&-> a0-10 quad))
                )
              (.lvf vf4 (&-> v1-18 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-9 quad) vf6)
            )
          )
        )
      (set-ik-target! arg0 s5-0)
      )
    (none)
    )
  )

(defbehavior target-update-ik target ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-query)))
      (let ((v1-0 (-> gp-0 bbox))
            (a0-1 (-> self control trans))
            (a1-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-0 x) 8192.0)
        (set! (-> a1-0 y) 6144.0)
        (set! (-> a1-0 z) 8192.0)
        (set! (-> a1-0 w) 1.0)
        (vector-! (the-as vector v1-0) a0-1 a1-0)
        )
      (let ((v1-2 (-> gp-0 bbox max))
            (a0-3 (-> self control trans))
            (a1-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-1 x) 8192.0)
        (set! (-> a1-1 y) 6144.0)
        (set! (-> a1-1 z) 8192.0)
        (set! (-> a1-1 w) 1.0)
        (vector+! v1-2 a0-3 a1-1)
        )
      (set! (-> gp-0 collide-with) (-> self control root-prim prim-core collide-with))
      (set! (-> gp-0 ignore-process0) self)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat) (-> self control pat-ignore-mask))
      ((method-of-object *collide-cache* collide-cache-method-12))
      (dotimes (s5-0 2)
        (let ((a1-4 (not (or (logtest? (target-flags lleg-no-ik rleg-no-ik) (-> self target-flags))
                             (and (logtest? (-> self control mod-surface flags) (surface-flag air))
                                  (not (logtest? (-> self control status) (collide-status on-surface)))
                                  )
                             (focus-test? self edge-grab pole flut pilot mech)
                             )
                         )
                    )
              )
          (enable-set! (-> self leg-ik s5-0) a1-4)
          )
        (set! (-> self foot s5-0 twist-max quad) (-> self control ground-contact-normal quad))
        (set! (-> self foot s5-0 trans quad) (-> self control gspot-pos quad))
        (vector-y-quaternion! (-> self foot s5-0 target) (-> self control quat-for-control))
        (set! (-> self foot s5-0 flex-blend) (if (if (zero? s5-0)
                                                     (logtest? (target-flags lleg-no-ik) (-> self target-flags))
                                                     (logtest? (target-flags rleg-no-ik) (-> self target-flags))
                                                     )
                                                 0.0
                                                 1.0
                                                 )
              )
        (-> self leg-ik s5-0 shoulder-matrix-no-ik)
        (let ((v1-51 (-> self leg-ik s5-0 elbow-matrix-no-ik))
              (s2-0 (new 'stack-no-clear 'vector))
              (s1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s1-0 quad) (-> *y-vector* quad))
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (new 'stack-no-clear 'vector)
            (new 'stack-no-clear 'vector)
            (let ((s4-0 (new 'stack-no-clear 'vector)))
              (let ((a2-8 s2-0))
                (let ((a0-27 (-> v1-51 trans)))
                  (let ((a1-8 (-> v1-51 uvec)))
                    (let ((a3-3 (-> self leg-ik s5-0 hand-dist)))
                      (.mov vf7 a3-3)
                      )
                    (.lvf vf5 (&-> a1-8 quad))
                    )
                  (.lvf vf4 (&-> a0-27 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a2-8 quad) vf6)
                )
              (let ((a1-9 s2-0))
                (let ((a0-28 (-> v1-51 trans)))
                  (let ((v1-52 (-> v1-51 uvec)))
                    (let ((a2-12 (-> self leg-ik s5-0 hand-dist)))
                      (.mov vf7 a2-12)
                      )
                    (.lvf vf5 (&-> v1-52 quad))
                    )
                  (.lvf vf4 (&-> a0-28 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-9 quad) vf6)
                )
              (let ((f0-13 (lerp-scale 1.0 0.0 (- (-> s2-0 y) (-> self control gspot-pos y)) 819.2 2048.0)))
                (seek! (-> self leg-ik s5-0 user-blend) f0-13 (* 4.0 (seconds-per-frame)))
                )
              (let ((a1-12 (-> gp-0 start-pos)))
                (let ((v1-63 s2-0))
                  (let ((a0-31 s1-0))
                    (let ((a2-16 4096.0))
                      (.mov vf7 a2-16)
                      )
                    (.lvf vf5 (&-> a0-31 quad))
                    )
                  (.lvf vf4 (&-> v1-63 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-12 quad) vf6)
                )
              (vector-float*! (-> gp-0 move-dist) s1-0 -8192.0)
              (let ((v1-66 gp-0))
                (set! (-> v1-66 radius) 4.096)
                (set! (-> v1-66 collide-with) (-> gp-0 collide-with))
                (set! (-> v1-66 ignore-process0) #f)
                (set! (-> v1-66 ignore-process1) #f)
                (set! (-> v1-66 ignore-pat)
                      (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                      )
                (set! (-> v1-66 action-mask) (collide-action solid))
                )
              (let ((f30-0 (probe-using-line-sphere *collide-cache* gp-0)))
                (cond
                  ((and (>= f30-0 0.0) (< 0.5 (-> gp-0 best-other-tri normal y)))
                   (set! (-> s4-0 quad) (-> gp-0 best-other-tri normal quad))
                   (when (< 8192.0 (vector-vector-angle-safe *y-vector* s4-0))
                     (let* ((a1-17 (vector-normalize! (vector-cross! (new 'stack-no-clear 'vector) *y-vector* s4-0) 1.0))
                            (a2-18 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) a1-17 8192.0))
                            )
                       (vector-orient-by-quat! s4-0 *y-vector* a2-18)
                       )
                     )
                   (let ((a1-19 s3-0))
                     (let ((v1-77 (-> gp-0 start-pos)))
                       (let ((a0-45 (-> gp-0 move-dist)))
                         (let ((a2-19 f30-0))
                           (.mov vf7 a2-19)
                           )
                         (.lvf vf5 (&-> a0-45 quad))
                         )
                       (.lvf vf4 (&-> v1-77 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> a1-19 quad) vf6)
                     )
                   (set! (-> self leg-ik s5-0 user-position quad) (-> s3-0 quad))
                   (set! (-> self leg-ik s5-0 user-normal quad) (-> s4-0 quad))
                   (set! (-> self foot s5-0 twist-max quad) (-> s4-0 quad))
                   )
                  (else
                    (set! (-> self leg-ik s5-0 user-position quad) (-> s2-0 quad))
                    (set! (-> self leg-ik s5-0 user-normal quad) (-> *y-vector* quad))
                    (set! (-> self foot s5-0 twist-max quad) (-> *y-vector* quad))
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defbehavior pre-collide-setup target ()
  (if (>= (current-time) (-> self control additional-decaying-velocity-decay-start-time))
      (vector-normalize!
        (-> self control additional-decaying-velocity)
        (seek (vector-length (-> self control additional-decaying-velocity)) 0.0 (* 40960.0 (seconds-per-frame)))
        )
      )
  (cond
    ((logtest? (-> self control old-status) (collide-status on-surface))
     (if (>= (+ (current-time) (seconds -0.035)) (-> self control additional-decaying-velocity-end-time))
         (vector-reset! (-> self control additional-decaying-velocity))
         )
     )
    (else
      (let ((f30-0 (vector-length (-> self control additional-decaying-velocity))))
        (let* ((v1-22
                 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control additional-decaying-velocity) 1.0)
                 )
               (f0-3 (vector-dot (-> self control transv) v1-22))
               )
          (if (< f0-3 0.0)
              (set! f30-0 (seek f30-0 0.0 (* -1.0 (seconds-per-frame) f0-3)))
              )
          )
        (let ((f0-7 (seek f30-0 0.0 (* 28672.0 (seconds-per-frame)))))
          (vector-normalize! (-> self control additional-decaying-velocity) f0-7)
          )
        )
      )
    )
  (set! (-> self control collide-extra-velocity quad) (-> self control additional-decaying-velocity quad))
  (set! (-> self control pre-collide-local-normal quad) (-> self control local-normal quad))
  0
  (none)
  )

(defbehavior level-setup target ()
  (let ((gp-0 (-> self current-level)))
    (set! (-> self current-level) (level-get-target-inside *level*))
    (if (-> self current-level)
        (+! (-> self game task-in-times (-> self current-level info task-level))
            (- (current-time) (-> self clock old-frame-counter))
            )
        )
    (if (and (-> self current-level) (or (not gp-0) (!= (-> gp-0 name) (-> self current-level name))))
        (send-event self 'level-enter (-> self current-level name))
        )
    )
  0
  (none)
  )

(defbehavior flag-setup target ()
  (cond
    ((= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
     (if (zero? (-> self control time-between-zero-inputs))
         (set! (-> self control time-between-zero-inputs) (- (current-time) (-> self control time-of-last-zero-input)))
         )
     (set-time! (-> self control time-of-last-zero-input))
     (quaternion-copy! (-> self control last-nonzero-input-dir-targ) (-> self control dir-targ))
     )
    (else
      (set-time! (-> self control time-of-last-nonzero-input))
      (set! (-> self control time-between-zero-inputs) 0)
      0
      )
    )
  (level-setup)
  (set! (-> self control last-transv quad) (-> self control transv quad))
  (quaternion-copy! (-> self control last-quat-for-control) (-> self control quat-for-control))
  ((-> self control current-surface active-hook))
  (cond
    ((logtest? (-> self control status) (collide-status on-surface))
     (set-time! (-> self control last-time-on-surface))
     (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
     (if (and (>= (-> self control coverage) 1.0)
              (not (logtest? (-> self control status) (collide-status touch-actor on-water)))
              (logtest? (-> self control status) (collide-status on-ground))
              )
         (set! (-> self control last-trans-on-ground quad) (-> self control trans quad))
         )
     ((-> self control current-surface touch-hook))
     )
    (else
      (let ((v1-49 (-> self control trans)))
        (when (logtest? (-> self control old-status) (collide-status on-surface))
          (set! (-> self control last-trans-leaving-surf quad) (-> self control last-trans-any-surf quad))
          (set! (-> self control highest-jump-mark quad) (-> self control last-trans-any-surf quad))
          )
        (set! (-> self control highest-jump-mark x) (-> v1-49 x))
        (set! (-> self control highest-jump-mark z) (-> v1-49 z))
        (if (< (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control highest-jump-mark) v1-49)
                 )
               0.0
               )
            (set! (-> self control highest-jump-mark y) (-> v1-49 y))
            )
        )
      )
    )
  (when (and (cpad-pressed? (-> self control cpad number) r3)
             (zero? (-> self control remaining-ctrl-iterations))
             (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask movie)))
             (not *pause-lock*)
             )
    (if (and (= (-> self cam-user-mode) 'normal)
             (logtest? (-> self control mod-surface flags) (surface-flag look-around))
             (not (focus-test? self edge-grab pole flut tube light board pilot dark))
             (-> *setting-control* user-current allow-look-around)
             (time-elapsed? (the-as int (-> self no-look-around-wait)) (seconds 0.05))
             (not (and (= (-> self control ground-pat material) (pat-material ice)) (< 4096.0 (-> self control ctrl-xz-vel)))
                  )
             )
        (send-event self 'change-mode 'look-around)
        )
    )
  (if (!= (not (logtest? (logand (game-feature sidekick) (-> *setting-control* user-current features))
                         (-> self game features)
                         )
               )
          (not (-> self sidekick))
          )
      (target-sidekick-setup
        (logtest? (logand (game-feature sidekick) (-> *setting-control* user-current features))
                  (-> self game features)
                  )
        )
      )
  (if (and (!= (not (logtest? (game-feature board) (-> self game features))) (not (-> self board board)))
           (not (logtest? (focus-status board) (-> self focus-status)))
           )
      (target-board-setup (logtest? (game-feature board) (-> self game features)))
      )
  (if (want-to-board?)
      (send-event self 'change-mode 'board #f)
      )
  (when (!= (not (-> *setting-control* user-current mirror)) (not (-> self mirror)))
    (cond
      ((-> self mirror)
       (deactivate (-> self mirror 0))
       (set! (-> self mirror) (the-as (pointer process-drawable) #f))
       )
      (else
        (let ((gp-1 (process-spawn
                      manipy
                      :init manipy-init
                      (-> self control trans)
                      (-> self entity)
                      (target-skel-group)
                      #f
                      2
                      :name "manipy"
                      :to self
                      :stack-size #x20000
                      )
                    )
              )
          (send-event (ppointer->process gp-1) 'anim-mode 'mirror)
          (send-event (ppointer->process gp-1) 'mirror #t)
          (set! (-> self mirror) (the-as (pointer process-drawable) gp-1))
          )
        )
      )
    )
  (when (and (= *cheat-mode* 'debug)
             (cpad-hold? (-> self control cpad number) r2)
             (cpad-hold? (-> self control cpad number) l2)
             (not *pause-lock*)
             (not (focus-test? self grabbed in-head pilot teleporting))
             (not (and (-> self next-state)
                       (let ((v1-163 (-> self next-state name)))
                         (or (= v1-163 'target-darkjak-get-on) (= v1-163 'target-lightjak-get-on) (= v1-163 'target-float))
                         )
                       )
                  )
             (= (-> self pending-ext-geo) (-> self ext-geo))
             )
    (send-event *camera* 'reset-follow)
    (set-time! (-> self control time-of-last-debug-float))
    (cond
      ((focus-test? self mech indax)
       (if (not (and (-> self next-state) (let ((v1-176 (-> self next-state name)))
                                            (or (= v1-176 'target-falling)
                                                (= v1-176 'target-board-falling)
                                                (= v1-176 'target-gun-falling)
                                                (= v1-176 'target-mech-falling)
                                                (= v1-176 'target-mech-carry-falling)
                                                (= v1-176 'target-carry-falling)
                                                (= v1-176 'target-indax-falling)
                                                )
                                            )
                     )
                )
           (send-event self 'change-mode 'falling)
           )
       (set! (-> self control additional-decaying-velocity-end-time) 0)
       (vector-reset! (-> self control additional-decaying-velocity))
       (let ((v1-186 (new-stack-vector0)))
         (let ((f0-9 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
           0.0
           (vector-! v1-186 (-> self control transv) (vector-float*! v1-186 (-> self control dynam gravity-normal) f0-9))
           )
         (let* ((f0-10 (vector-length v1-186))
                (f1-5 f0-10)
                (f2-0 0.0)
                )
           (vector+!
             (-> self control transv)
             (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
             (vector-float*! v1-186 v1-186 (/ f0-10 f1-5))
             )
           )
         )
       (let ((a1-44 (new 'stack-no-clear 'vector)))
         (set! (-> a1-44 quad) (-> self control trans quad))
         (let ((v1-190 (new-stack-vector0))
               (f0-13 (vector-dot (-> self control dynam gravity-normal) a1-44))
               )
           0.0
           (vector-! v1-190 a1-44 (vector-float*! v1-190 (-> self control dynam gravity-normal) f0-13))
           (let* ((f1-8 (vector-length v1-190))
                  (f2-1 f1-8)
                  (f0-14 (+ 512.0 f0-13))
                  )
             (vector+!
               a1-44
               (vector-float*! a1-44 (-> self control dynam gravity-normal) f0-14)
               (vector-float*! v1-190 v1-190 (/ f1-8 f2-1))
               )
             )
           )
         (move-to-point! (-> self control) a1-44)
         )
       (set! (-> self control surf) *standard-ground-surface*)
       )
      (else
        (go target-float)
        )
      )
    )
  (let ((f0-17 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
    (if (and (or (logtest? (-> self control current-surface flags) (surface-flag check-edge))
                 (and (and (-> self next-state) (let ((v1-208 (-> self next-state name)))
                                                  (or (= v1-208 'target-walk) (= v1-208 'target-gun-walk))
                                                  )
                           )
                      (not (logtest? (-> self control status) (collide-status on-surface)))
                      )
                 )
             (and (< f0-17 0.0)
                  (and (or (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2))) *pause-lock*)
                       (not (focus-test? self flut pilot mech indax))
                       (not (logtest? (-> self target-flags) (target-flags prevent-jump)))
                       #t
                       )
                  )
             )
        (logior! (-> self control root-prim prim-core action) (collide-action check-edge))
        (logclear! (-> self control root-prim prim-core action) (collide-action check-edge))
        )
    )
  (let ((v1-226 (-> self current-level)))
    (if (and (or (time-elapsed? (-> self control last-time-on-surface) (seconds 2)) (focus-test? self pilot))
             (and v1-226
                  (< (-> self control trans y) (-> v1-226 info bottom-height))
                  (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
                  )
             )
        (send-event
          self
          'attack-invinc
          #f
          (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                              (damage 2.0)
                                                              (vehicle-damage-factor 1.0)
                                                              (vehicle-impulse-factor 1.0)
                                                              (mode 'endlessfall)
                                                              )
                              )
          )
        )
    )
  (set! (-> self control bend-speed) (if (logtest? (-> self control status) (collide-status on-surface))
                                         32.0
                                         2.0
                                         )
        )
  (let ((v1-245 (-> *setting-control* user-current beard)))
    (when (!= (-> self beard?) v1-245)
      (cond
        (v1-245
          (setup-masks (-> self draw) 4 0)
          (set! (-> self beard?) #t)
          )
        (else
          (setup-masks (-> self draw) 0 4)
          (set! (-> self beard?) #f)
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior post-flag-setup target ()
  (if (logtest? (-> self control status) (collide-status touch-wall touch-actor))
      (set-time! (-> self control last-time-touching-actor))
      )
  (when (logtest? (-> self target-flags) (target-flags tinvuln1))
    (if (< (logand (-> *display* frame-clock integral-frame-counter) 3) 1)
        (logior! (-> self draw status) (draw-control-status no-draw-bounds))
        (logclear! (-> self draw status) (draw-control-status no-draw-bounds))
        )
    (if (time-elapsed? (-> self control invul1-on-time) (-> self control invul1-off-time))
        (target-timed-invulnerable-off self 1)
        )
    )
  (when (logtest? (target-flags tinvuln2) (-> self target-flags))
    (if (time-elapsed? (-> self control invul2-on-time) (-> self control invul2-off-time))
        (target-timed-invulnerable-off self 2)
        )
    )
  (set! (-> self control jump-kind) #f)
  (target-gun-joint-pre)
  ((-> self pre-joint-hook))
  (target-log-trans)
  (seek!
    (-> self hair 0 twist-max z)
    (lerp-scale 0.0 1820.4445 (vector-length (-> self control transv)) 0.0 122880.0)
    (* 65536.0 (seconds-per-frame))
    )
  (seek!
    (-> self hair 0 twist-speed-x)
    (lerp-scale 0.5 4.0 (vector-length (-> self control transv)) 0.0 122880.0)
    (* 10.0 (seconds-per-frame))
    )
  (let ((f0-9 (+ (-> self hair 0 twist z) (* (-> self hair 0 twist-speed-x) (seconds-per-frame)))))
    (set! (-> self hair 0 twist z) (- f0-9 (* (the float (the int (/ f0-9 1.0))) 1.0)))
    )
  (if (and (focus-test? self pilot) (nonzero? (-> self pilot)) (= (-> self pilot stance) 1))
      (seek!
        (-> self hair 0 twist-max w)
        (lerp-scale 0.0 9102.223 (vector-length (-> self control transv)) 0.0 122880.0)
        (* 65536.0 (seconds-per-frame))
        )
      (seek! (-> self hair 0 twist-max w) 0.0 (* 65536.0 (seconds-per-frame)))
      )
  (trs-set!
    (-> self hair 0)
    (the-as vector #f)
    (quaternion-rotate-x!
      (new 'stack-no-clear 'quaternion)
      (the-as quaternion *null-vector*)
      (+ (-> self hair 0 twist-max w) (* (sin (* 32768.0 (-> self hair 0 twist z))) (-> self hair 0 twist-max z)))
      )
    (the-as vector #f)
    )
  (seek!
    (-> self hair 1 twist-max z)
    (lerp-scale 0.0 5461.3335 (vector-length (-> self control transv)) 4096.0 122880.0)
    (* 65536.0 (seconds-per-frame))
    )
  (seek!
    (-> self hair 1 twist-speed-x)
    (lerp-scale 1.0 8.0 (vector-length (-> self control transv)) 4096.0 122880.0)
    (* 10.0 (seconds-per-frame))
    )
  (let ((f0-33 (+ (-> self hair 1 twist z) (* (-> self hair 1 twist-speed-x) (seconds-per-frame)))))
    (set! (-> self hair 1 twist z) (- f0-33 (* (the float (the int (/ f0-33 1.0))) 1.0)))
    )
  (trs-set!
    (-> self hair 1)
    (the-as vector #f)
    (quaternion-rotate-x!
      (new 'stack-no-clear 'quaternion)
      (the-as quaternion *null-vector*)
      (* (sin (* 32768.0 (-> self hair 1 twist z))) (-> self hair 1 twist-max z))
      )
    (the-as vector #f)
    )
  (target-update-ik)
  0
  (none)
  )

(defbehavior bend-gravity target ()
  (if (and (logtest? (-> self control root-prim prim-core action) (collide-action no-normal-reset))
           (not (logtest? (-> self control status) (collide-status on-surface)))
           )
      (return #f)
      )
  (let ((f0-1
          (if (and (logtest? (-> self control status) (collide-status touch-wall))
                   (not (logtest? (-> self control status) (collide-status on-surface)))
                   )
              0.0
              (-> self control bend-target)
              )
          )
        )
    (seek! (-> self control bend-amount) f0-1 (* (-> self control bend-speed) (seconds-per-frame)))
    )
  (set! (-> self control dynam gravity-normal quad) (-> self control standard-dynamics gravity-normal quad))
  (vector-float*!
    (-> self control dynam gravity)
    (-> self control dynam gravity-normal)
    (the-as float (-> self control dynam gravity-length))
    )
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (new 'stack-no-clear 'vector)
    (let ((f30-0 (-> self control current-surface tiltvv))
          (gp-0 (-> self control gspot-normal))
          )
      (vector-deg-slerp s5-0 (-> self control standard-dynamics gravity-normal) gp-0 (-> self control bend-amount))
      (let ((a2-3
              (matrix-from-two-vectors-smooth!
                (new 'stack-no-clear 'matrix)
                (-> self control bent-gravity-normal)
                s5-0
                f30-0
                (the int (-> self control current-surface tiltvvf))
                )
              )
            )
        (vector-matrix*! (-> self control bent-gravity-normal) (-> self control bent-gravity-normal) a2-3)
        )
      (vector-normalize! (-> self control bent-gravity-normal) 1.0)
      (add-debug-vector
        *display-target-marks*
        (bucket-id debug-no-zbuf1)
        (-> self control trans)
        gp-0
        (meters 2)
        (new 'static 'rgba :b #xff :a #x80)
        )
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control local-normal)
    (meters 2)
    (the-as rgba (new 'static 'rgba :r #xff :a #x80))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control standard-dynamics gravity-normal)
    (meters 2.5)
    (the-as rgba (new 'static 'rgba :r #xff :a #x80))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control dynam gravity-normal)
    (meters 3)
    (the-as rgba (new 'static 'rgba :r #xff :b #xff :a #x80))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control bent-gravity-normal)
    (meters 3)
    (the-as rgba (new 'static 'rgba :r #xff :b #xff :a #x80))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
    (meters 3)
    (the-as rgba (new 'static 'rgba :r #xff :a #x80))
    )
  )

(defbehavior target-compute-edge target ()
  (let ((s5-0 *edge-grab-info*))
    (cond
      ((-> s5-0 pilot-edge-grab?)
       (set! (-> self control ground-pat) (new 'static 'pat-surface :material (pat-material metal)))
       (cond
         ((send-event (handle->process (-> s5-0 pilot-edge-grab handle)) 'pilot-edge-grab s5-0)
          (let ((a0-7 (handle->process (-> s5-0 pilot-edge-grab handle))))
            (set! (-> s5-0 center-hold-old quad) (-> s5-0 center-hold quad))
            (let ((gp-0 (new 'stack-no-clear 'bone)))
              (let* ((v1-13 (-> gp-0 transform))
                     (a3-0 (-> (the-as process-drawable a0-7) node-list data 0 bone transform))
                     (a0-12 (-> a3-0 rvec quad))
                     (a1-4 (-> a3-0 uvec quad))
                     (a2-1 (-> a3-0 fvec quad))
                     (a3-1 (-> a3-0 trans quad))
                     )
                (set! (-> v1-13 rvec quad) a0-12)
                (set! (-> v1-13 uvec quad) a1-4)
                (set! (-> v1-13 fvec quad) a2-1)
                (set! (-> v1-13 trans quad) a3-1)
                )
              (vector-matrix*! (-> gp-0 scale) (the-as vector (-> s5-0 pilot-edge-grab)) (-> gp-0 transform))
              (vector-rotate*! (the-as vector (&+ gp-0 80)) (-> s5-0 pilot-edge-grab local-dir) (-> gp-0 transform))
              (set! (-> s5-0 center-hold quad) (-> gp-0 scale quad))
              (set! (-> self control edge-grab-edge-dir quad) (-> (&+ gp-0 80) transform rvec quad))
              )
            )
          )
         (else
           (send-event self 'end-mode 'edge-grab)
           )
         )
       )
      (else
        (if (not (edge-grab-info-method-9 s5-0))
            (send-event self 'end-mode 'edge-grab)
            )
        (if *display-edge-collision-marks*
            ((method-of-type edge-grab-info edge-grab-info-method-10))
            )
        (set! (-> self control ground-pat) (-> s5-0 edge-tri-pat))
        (vector-normalize!
          (vector-!
            (-> self control edge-grab-edge-dir)
            (the-as vector (-> s5-0 world-vertex))
            (-> s5-0 world-vertex 1)
            )
          1.0
          )
        )
      )
    (let ((gp-2 (vector-cross!
                  (-> self control edge-grab-across-edge-dir)
                  (-> self control edge-grab-edge-dir)
                  (-> self control dynam gravity-normal)
                  )
                )
          )
      (let ((s4-1 (vector-! (new-stack-vector0) (-> s5-0 center-hold) (-> self control midpoint-of-hands))))
        (set! (-> self control hand-to-edge-dist) (vector-length s4-1))
        (cond
          ((and (< 1228.8 (-> self control hand-to-edge-dist))
                (time-elapsed? (-> self control last-successful-compute-edge-time) (seconds 0.2))
                )
           (cond
             ((-> s5-0 pilot-edge-grab?)
              (case (-> s5-0 pilot-edge-grab?)
                (('target-jump)
                 (seek! (-> s5-0 pilot-grab-interp) 1.0 (* 2.0 (seconds-per-frame)))
                 )
                (else
                  (seek! (-> s5-0 pilot-grab-interp) 1.0 (* 1.5 (seconds-per-frame)))
                  )
                )
              (let* ((f0-11 (fmin 1.0 (* 1.5 (-> s5-0 pilot-grab-interp))))
                     (s3-1 (vector-lerp!
                             (new 'stack-no-clear 'vector)
                             (-> s5-0 pilot-start-grab-pos)
                             (vector-! (new 'stack-no-clear 'vector) (-> s5-0 center-hold) (-> self control ctrl-to-hands-offset))
                             (smooth-step f0-11)
                             )
                           )
                     )
                (set! (-> s3-1 y) (+ (lerp
                                       (-> s5-0 pilot-start-grab-pos y)
                                       (- (-> s5-0 center-hold y) (-> self control ctrl-to-hands-offset y))
                                       (smooth-step (-> s5-0 pilot-grab-interp))
                                       )
                                     (cond
                                       ((= (-> s5-0 pilot-edge-grab?) 'target-jump)
                                        (let ((f1-6 (-> s5-0 pilot-grab-interp)))
                                          (* 8192.0 (- 1.0 f1-6) f1-6)
                                          )
                                        )
                                       ((>= (-> s5-0 pilot-grab-interp) 0.5)
                                        (let ((f1-10 (* 2.0 (+ -0.5 (-> s5-0 pilot-grab-interp)))))
                                          (* 8192.0 (- 1.0 f1-10) f1-10)
                                          )
                                        )
                                       (else
                                         (let ((f1-13 (* 2.0 (-> s5-0 pilot-grab-interp))))
                                           (* 32768.0 (- 1.0 f1-13) f1-13)
                                           )
                                         )
                                       )
                                     )
                      )
                (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
                (set-time! (-> self control rider-time))
                (vector+! s3-1 s3-1 (-> self control cspace-offset))
                (move-to-point! (-> self control) s3-1)
                )
              (set! (-> self control hand-to-edge-dist) 0.0)
              (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
              )
             (else
               (vector-normalize! s4-1 1638.4)
               (let ((a1-20 (vector+! (new 'stack-no-clear 'vector) s4-1 (-> self control cspace-offset))))
                 (move-by-vector! (-> self control) a1-20)
                 )
               (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
               (set-time! (-> self control rider-time))
               (if (and (time-elapsed? (-> self control edge-grab-start-time) (seconds 0.5))
                        (time-elapsed? (-> self control last-successful-compute-edge-time) (seconds 0.5))
                        )
                   (send-event self 'end-mode 'edge-grab)
                   )
               )
             )
           )
          (else
            (let ((a1-23 (new 'stack-no-clear 'vector)))
              (vector-! a1-23 (-> s5-0 center-hold) (-> self control ctrl-to-hands-offset))
              (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
              (set-time! (-> self control rider-time))
              (vector+! a1-23 a1-23 (-> self control cspace-offset))
              (move-to-point! (-> self control) a1-23)
              )
            (set! (-> self control hand-to-edge-dist) 0.0)
            (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
            (set-time! (-> self control last-successful-compute-edge-time))
            )
          )
        )
      (forward-up-nopitch->quaternion (-> self control dir-targ) gp-2 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (update-anim-data (-> self skel))
  (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
  (none)
  )

(defbehavior target-compute-edge-rider target ()
  (let ((gp-0 *edge-grab-info*))
    (cond
      ((-> gp-0 pilot-edge-grab?)
       (set! (-> self control ground-pat) (new 'static 'pat-surface :material (pat-material metal)))
       (cond
         ((send-event (handle->process (-> gp-0 pilot-edge-grab handle)) 'pilot-edge-grab gp-0)
          (let ((a0-7 (handle->process (-> gp-0 pilot-edge-grab handle))))
            (set! (-> gp-0 center-hold-old quad) (-> gp-0 center-hold quad))
            (let ((s5-0 (new 'stack-no-clear 'bone)))
              (let* ((v1-13 (-> s5-0 transform))
                     (a3-0 (-> (the-as process-drawable a0-7) node-list data 0 bone transform))
                     (a0-12 (-> a3-0 rvec quad))
                     (a1-4 (-> a3-0 uvec quad))
                     (a2-1 (-> a3-0 fvec quad))
                     (a3-1 (-> a3-0 trans quad))
                     )
                (set! (-> v1-13 rvec quad) a0-12)
                (set! (-> v1-13 uvec quad) a1-4)
                (set! (-> v1-13 fvec quad) a2-1)
                (set! (-> v1-13 trans quad) a3-1)
                )
              (vector-matrix*! (-> s5-0 scale) (the-as vector (-> gp-0 pilot-edge-grab)) (-> s5-0 transform))
              (vector-rotate*! (the-as vector (&+ s5-0 80)) (-> gp-0 pilot-edge-grab local-dir) (-> s5-0 transform))
              (set! (-> gp-0 center-hold quad) (-> s5-0 scale quad))
              (set! (-> self control edge-grab-edge-dir quad) (-> (&+ s5-0 80) transform rvec quad))
              )
            )
          )
         (else
           (send-event self 'end-mode 'edge-grab)
           )
         )
       )
      (else
        (if (not (edge-grab-info-method-9 gp-0))
            (send-event self 'end-mode 'edge-grab)
            )
        (if *display-edge-collision-marks*
            ((method-of-type edge-grab-info edge-grab-info-method-10))
            )
        (vector-normalize!
          (vector-!
            (-> self control edge-grab-edge-dir)
            (the-as vector (-> gp-0 world-vertex))
            (-> gp-0 world-vertex 1)
            )
          1.0
          )
        )
      )
    (vector-cross!
      (-> self control edge-grab-across-edge-dir)
      (-> self control edge-grab-edge-dir)
      (-> self control dynam gravity-normal)
      )
    (let ((a1-15 (vector-! (new-stack-vector0) (-> gp-0 center-hold) (-> gp-0 center-hold-old))))
      (vector-float*! (-> self control rider-last-move) a1-15 (-> self clock frames-per-second))
      (set-time! (-> self control rider-time))
      (move-by-vector! (-> self control) a1-15)
      )
    )
  (set! (-> self control hand-to-edge-dist) 0.0)
  (update-anim-data (-> self skel))
  (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
  (none)
  )

(defbehavior target-compute-pole target ()
  (let* ((s2-0 (the-as swingpole (handle->process (-> self control anim-handle))))
         (gp-0 (-> s2-0 dir))
         )
    (set! (-> self control edge-grab-edge-dir quad) (-> gp-0 quad))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (let* ((s1-0 (get-trans s2-0))
             (s4-1 (vector+float*! (new 'stack-no-clear 'vector) s1-0 gp-0 (the-as float (-> s2-0 edge-length))))
             (s3-1 (vector+float*! (new 'stack-no-clear 'vector) s1-0 gp-0 (- (-> s2-0 edge-length))))
             )
        (let ((v1-9 (new 'stack-no-clear 'vector)))
          (vector+! v1-9 s4-1 s3-1)
          (vector-float*! v1-9 v1-9 0.5)
          (+! (-> v1-9 y) -6144.0)
          (send-event *camera* 'ease-in 0.5 v1-9)
          )
        (vector-segment-distance-point! (-> self control midpoint-of-hands) s4-1 s3-1 s5-0)
        (if (not (time-elapsed? (-> self state-time) (seconds 0.05)))
            (set! (-> self control hand-to-edge-dist)
                  (fmax 0.0 (fmin 1.0 (/ (vector-vector-distance s4-1 s5-0) (* 2.0 (-> s2-0 edge-length)))))
                  )
            (vector-lerp! s5-0 s4-1 s3-1 (-> self control hand-to-edge-dist))
            )
        (when *display-edge-collision-marks*
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            s1-0
            (-> s2-0 dir)
            (meters 3)
            (the-as rgba (new 'static 'rgba :r #xff :b #xff :a #x80))
            )
          (add-debug-sphere
            #t
            (bucket-id bucket583)
            (-> self control midpoint-of-hands)
            (meters 0.2)
            (the-as rgba (new 'static 'rgba :r #xff :a #x80))
            )
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf1)
            s4-1
            (meters 0.2)
            (the-as rgba (new 'static 'rgba :g #xff :a #x80))
            )
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf1)
            s3-1
            (meters 0.2)
            (the-as rgba (new 'static 'rgba :g #xff :b #x40 :a #x80))
            )
          (add-debug-sphere #t (bucket-id debug-no-zbuf1) s5-0 (meters 0.2) (new 'static 'rgba :b #xff :a #x80))
          )
        )
      (let ((a0-27 (vector-! (new-stack-vector0) s5-0 (-> self control midpoint-of-hands))))
        (cond
          ((and (< 2457.6 (vector-length a0-27)) (not (-> self control did-move-to-pole-or-max-jump-height)))
           (move-by-vector! (-> self control) (vector-normalize! a0-27 2457.6))
           )
          (else
            (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float #t))
            (move-to-point!
              (-> self control)
              (vector-! (new 'stack-no-clear 'vector) s5-0 (-> self control ctrl-to-hands-offset))
              )
            (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
            )
          )
        )
      )
    (let ((s5-3 (vector-cross! (-> self control edge-grab-across-edge-dir) gp-0 (-> self control dynam gravity-normal)))
          )
      (if (>= 0.0
              (vector-dot s5-3 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control)))
              )
          (vector-negate! s5-3 s5-3)
          )
      (forward-up-nopitch->quaternion (-> self control dir-targ) s5-3 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (update-anim-data (-> self skel))
  (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
  (update-transforms (-> self control))
  (none)
  )

(defbehavior target-calc-camera-pos target ()
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (cond
      ((and (and (-> self next-state) (= (-> self next-state name) 'target-clone-anim))
            (and (not (logtest? (-> self draw status) (draw-control-status no-draw)))
                 (begin
                   (vector<-cspace! s5-0 (joint-node jakb-lod0-jg main))
                   (+! (-> s5-0 y) -5896.192)
                   (< (fabs (- (-> s5-0 y) (-> self control trans y))) 8192.0)
                   )
                 )
            )
       (set! (-> self control camera-pos quad) (-> s5-0 quad))
       )
      ((logtest? (target-flags tf26) (-> self target-flags))
       (vector+! (-> self control camera-pos) (-> self control trans) (new 'static 'vector :y -8192.0 :w 1.0))
       )
      ((focus-test? self board pilot mech indax)
       (set! (-> self control camera-pos quad) (-> self control trans quad))
       )
      ((or (logtest? (-> self control status) (collide-status on-water))
           (let ((v1-28 (-> self water flags)))
             (and (logtest? (water-flag touch-water) v1-28)
                  (logtest? (water-flag under-water swimming) v1-28)
                  (not (logtest? (focus-status mech) (-> self focus-status)))
                  )
             )
           )
       (vector<-cspace! s5-0 (the-as cspace (-> self node-list data)))
       (if (not (and (logtest? (-> self water flags) (water-flag under-water))
                     (not (logtest? (-> self water flags) (water-flag swim-ground)))
                     )
                )
           (set! (-> s5-0 y) (- (-> self water surface-height) (-> self water swim-height)))
           )
       (vector<-cspace! gp-0 (joint-node jakb-lod0-jg chest))
       (cond
         ((>= (+ (current-time) (seconds -2)) (-> self control unknown-time-frame26))
          (set! (-> self control camera-pos quad) (-> s5-0 quad))
          )
         ((not (and (logtest? (-> self water flags) (water-flag under-water))
                    (not (logtest? (-> self water flags) (water-flag swim-ground)))
                    )
               )
          (vector-lerp!
            (-> self control camera-pos)
            gp-0
            s5-0
            (* 0.0016666667 (the float (- (current-time) (-> self control unknown-time-frame26))))
            )
          )
         (else
           (vector-lerp!
             (-> self control camera-pos)
             s5-0
             gp-0
             (fmax 0.0 (fmin 1.0 (* 0.0011111111 (the float (- (current-time) (-> self control unknown-time-frame27))))))
             )
           )
         )
       (-> self control camera-pos)
       )
      ((and (or (logtest? (water-flag touch-water) (-> self water flags))
                (logtest? (-> self control status) (collide-status on-water))
                )
            (logtest? (-> self water flags) (water-flag mud))
            )
       (vector<-cspace! (-> self control camera-pos) (the-as cspace (-> self node-list data)))
       (set! (-> self control camera-pos y) (-> self water base-height))
       )
      ((focus-test? self tube)
       (set! (-> self control camera-pos quad) (-> self control gspot-pos quad))
       )
      ((logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp))
       (set! (-> self control camera-pos quad) (-> self control trans quad))
       )
      (else
        (vector<-cspace! (-> self control camera-pos) (the-as cspace (-> self node-list data)))
        )
      )
    )
  0
  (none)
  )

(defbehavior joint-points target ()
  (let ((f0-1 (* 0.00078125 (the float (-> self neck look-at-count)))))
    (if (!= f0-1 0.0)
        (set! f0-1 (+ 0.12 f0-1))
        )
    (cond
      ((>= f0-1 (-> self excitement))
       (seek! (-> self excitement) f0-1 (* 6.0 (seconds-per-frame)))
       )
      ((focus-test? self dead ignore hit)
       )
      (else
        (seek! (-> self excitement) f0-1 (* 0.25 (seconds-per-frame)))
        )
      )
    )
  (set-setting! 'sound-excitement 'add (-> self excitement) 0)
  (let ((v1-17 (-> self neck)))
    (set! (-> v1-17 blend) 0.0)
    )
  (set! (-> self neck look-at-count) (the-as uint 0))
  (if (and (logtest? (-> self control current-surface flags) (surface-flag duck))
           (< 0.5 (-> self control duck-gun-tube-transision))
           (not (using-gun? self))
           )
      (set! (-> self neck base-nose) (the-as uint 1))
      (set! (-> self neck base-nose) (the-as uint 2))
      )
  (let ((v1-29 (-> self upper-body)))
    (set! (-> v1-29 blend) 0.0)
    )
  (cond
    ((focus-test? self tube pilot indax)
     )
    ((logtest? (water-flag wading) (-> self water flags))
     (let ((f30-0 (- (- (-> self control trans y) (- (-> self water height) (-> self water wade-height))))))
       (set! (-> *wade-surface* alignv)
             (lerp-scale 1.0 0.5 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))
             )
       (set! (-> *wade-surface* align-speed) (-> *wade-surface* alignv))
       (let ((f0-20 (lerp-scale 0.8 0.6 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))))
         (set! (-> *wade-surface* target-speed) f0-20)
         (set! (-> *wade-surface* transv-max) f0-20)
         )
       )
     (set! (-> self control surf) *wade-surface*)
     )
    ((logtest? (water-flag swimming) (-> self water flags))
     (set! (-> self control surf) *swim-surface*)
     )
    ((and (logtest? (water-flag touch-water) (-> self water flags))
          (logtest? (-> self water flags) (water-flag mud))
          )
     (set! (-> self control surf) *quicksand-surface*)
     )
    )
  (let ((a2-5
          (matrix<-no-trans-transformq! (-> self control ctrl-orientation) (the-as transformq (-> self control trans)))
          )
        )
    (vector-matrix*! (-> self control ctrl-to-head-offset) (-> *TARGET-bank* head-offset) a2-5)
    )
  (vector<-cspace!
    (the-as vector (&-> (-> self control) sidekick-root bone))
    (-> self control sidekick-root parent)
    )
  (let ((gp-0 (new-stack-vector0))
        (s5-0 (new-stack-vector0))
        )
    (vector<-cspace! gp-0 (-> self control lhand-cspace))
    (vector<-cspace! s5-0 (-> self control rhand-cspace))
    (vector-average! (-> self control midpoint-of-hands) gp-0 s5-0)
    )
  (vector-! (-> self control ctrl-to-hands-offset) (-> self control midpoint-of-hands) (-> self control trans))
  (update-from-cspace (-> self control impact-ctrl))
  (cond
    ((focus-test? self edge-grab)
     (target-compute-edge)
     )
    ((focus-test? self pole)
     (target-compute-pole)
     )
    )
  (target-calc-camera-pos)
  (set! (-> self control tongue-counter) 0)
  (cond
    ((focus-test? self indax)
     )
    (else
      (target-gun-joint-points)
      (target-board-joint-points)
      )
    )
  0
  (none)
  )

(defbehavior do-target-gspot target ()
  (cond
    ((and (logtest? (-> self control status) (collide-status on-surface))
          (!= (-> self control mod-surface mode) 'swim)
          (!= (-> self control mod-surface mode) 'dive)
          (not (and (-> self next-state) (= (-> self next-state name) 'target-flop)))
          (not (logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp no-draw-bounds)))
          )
     (set! (-> self control gspot-pos quad) (-> self control trans quad))
     (set! (-> self control gspot-normal quad) (-> self control ground-poly-normal quad))
     (set! (-> self control gspot-pat-surfce) (-> self control ground-pat))
     )
    (else
      (let* ((gp-0 (new 'stack-no-clear 'collide-query))
             (a0-15 (-> self control))
             (t9-0 (method-of-object a0-15 find-ground))
             (a1-0 gp-0)
             (a2-1 (if (focus-test? self pilot)
                       #x64383f7d
                       (the-as int (logclear (-> self control root-prim prim-core collide-with) (collide-spec water)))
                       )
                   )
             (a3-0 8192.0)
             (t0-0 81920.0)
             (t1-0 1024.0)
             )
        (cond
          ((nonzero? (-> self pilot))
           (handle->process (-> self pilot vehicle))
           )
          (else
            )
          )
        (if (t9-0 a0-15 a1-0 (the-as collide-spec a2-1) a3-0 t0-0 t1-0)
            (set! (-> self control gspot-pat-surfce) (-> gp-0 best-other-tri pat))
            )
        )
      )
    )
  0
  (none)
  )

(defbehavior target-real-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (if (< (-> self control force-turn-to-strength) 0.0)
            (set! (-> self control force-turn-to-strength) (- 1.0 (-> self control cpad stick0-speed)))
            )
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (let ((f28-0 (debounce-speed
                         (-> self control pad-magnitude)
                         (-> self control last-pad-magnitude)
                         (-> self control pad-xz-dir)
                         (-> self control last-pad-xz-dir)
                         )
                       )
                )
            (when (!= (-> self control force-turn-to-strength) 0.0)
              (let ((f0-12 (fmin 1.0 (-> self control force-turn-to-strength))))
                (set! (-> self control force-turn-to-strength) f0-12)
                (let ((a1-3 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (if (= f28-0 0.0)
                                  *zero-vector*
                                  s5-0
                                  )
                              f28-0
                              )
                            )
                      (a2-2 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (-> self control force-turn-to-direction)
                              (-> self control force-turn-to-speed)
                              )
                            )
                      )
                  (vector-lerp! s5-0 a1-3 a2-2 f0-12)
                  )
                )
              (set! f28-0 (vector-length s5-0))
              (vector-normalize! s5-0 1.0)
              )
            (turn-to-vector s5-0 f28-0)
            )
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (set! (-> self control reaction) target-collision-reaction)
        (let ((a2-3 (new 'stack-no-clear 'collide-query)))
          (let ((v1-32 (-> self control)))
            (set! (-> a2-3 collide-with) (-> v1-32 root-prim prim-core collide-with))
            (set! (-> a2-3 ignore-process0) self)
            (set! (-> a2-3 ignore-process1) #f)
            (set! (-> a2-3 ignore-pat) (-> v1-32 pat-ignore-mask))
            )
          (set! (-> a2-3 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-3 (meters 1))
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (target-method-28 *target* *collide-cache* *collide-edge-spec*)
            )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (ja-post)
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-post target ()
  (target-real-post)
  (none)
  )

(defbehavior target-swim-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (turn-to-vector s5-0 (-> self control pad-magnitude))
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (let ((a2-0 (new 'stack-no-clear 'collide-query)))
          (let ((v1-10 (-> self control)))
            (set! (-> a2-0 collide-with) (-> v1-10 root-prim prim-core collide-with))
            (set! (-> a2-0 ignore-process0) self)
            (set! (-> a2-0 ignore-process1) #f)
            (set! (-> a2-0 ignore-pat) (-> v1-10 pat-ignore-mask))
            )
          (set! (-> a2-0 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-0 (meters 1))
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (target-method-28 *target* *collide-cache* *collide-edge-spec*)
            )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (ja-post)
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-stick-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (turn-to-vector s5-0 0.0)
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (let ((a2-0 (new 'stack-no-clear 'collide-query)))
          (let ((v1-9 (-> self control)))
            (set! (-> a2-0 collide-with) (-> v1-9 root-prim prim-core collide-with))
            (set! (-> a2-0 ignore-process0) self)
            (set! (-> a2-0 ignore-process1) #f)
            (set! (-> a2-0 ignore-pat) (-> v1-9 pat-ignore-mask))
            )
          (set! (-> a2-0 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-0 (meters 1))
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (target-method-28 *target* *collide-cache* *collide-edge-spec*)
            )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (ja-post)
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-move-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (vector-!
          (-> self control cspace-offset)
          (-> self control draw-offset)
          (-> self control anim-collide-offset-world)
          )
        (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a1-3 options) (overlaps-others-options oo0))
          (set! (-> a1-3 collide-with-filter) (the-as collide-spec -1))
          (set! (-> a1-3 tlist) *touching-list*)
          (find-overlapping-shapes (-> self control) a1-3)
          )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (ja-post)
  (joint-points)
  (when *debug-segment*
    (let ((gp-2 (-> self control)))
      (+! (-> gp-2 history-idx) 1)
      (let ((v1-25 (clear-record-tags! *history* (history-channel transv) (-> gp-2 history-idx) (the-as uint 2))))
        (set! (-> v1-25 origin quad) (-> gp-2 trans quad))
        (set! (-> v1-25 vector quad) (-> gp-2 transv quad))
        )
      (set! (-> (clear-record-tags! *history* (history-channel trans) (-> gp-2 history-idx) (the-as uint 2)) vector quad)
            (-> gp-2 trans quad)
            )
      (let ((v1-31 (clear-record-tags! *history* (history-channel collide-status) (-> gp-2 history-idx) (the-as uint 2)))
            )
        (set! (-> v1-31 collide-status) (logior (-> gp-2 status) (collide-status no-touch)))
        (set! (-> v1-31 vector z) (the-as float (-> gp-2 reaction-flag)))
        )
      )
    )
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-ja-move-post target ()
  (vector-!
    (-> self control cspace-offset)
    (-> self control draw-offset)
    (-> self control anim-collide-offset-world)
    )
  (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
    (set! (-> a1-2 options) (overlaps-others-options oo0))
    (set! (-> a1-2 collide-with-filter) (the-as collide-spec -1))
    (set! (-> a1-2 tlist) *touching-list*)
    (find-overlapping-shapes (-> self control) a1-2)
    )
  (target-calc-camera-pos)
  (do-target-gspot)
  (target-powerup-process)
  (target-board-joint-points)
  (none)
  )

(defbehavior reset-target-state target ((arg0 symbol))
  (when arg0
    (vector-identity! (-> self control scale))
    (quaternion-identity! (-> self control quat))
    (quaternion-identity! (-> self control quat-for-control))
    (quaternion-identity! (-> self control dir-targ))
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control camera-pos quad) (-> self control trans quad))
    )
  (target-exit)
  (target-timed-invulnerable-off self 0)
  (target-timed-invulnerable-off self 2)
  (set! (-> self control status) (collide-status))
  (set! (-> self control standard-dynamics) *standard-dynamics*)
  (set! (-> self control surf) *standard-ground-surface*)
  (set! (-> self control bent-gravity-normal quad) (-> self control standard-dynamics gravity-normal quad))
  (quaternion-identity! (-> self control override-quat))
  (set! (-> self control override-quat-alpha) 0.0)
  (set-time! (-> self control last-time-on-surface))
  (set! (-> self control bend-amount) 0.0)
  (set! (-> self control bend-speed) 32.0)
  (set! (-> self cam-user-mode) 'normal)
  (set! (-> self control anim-handle) (the-as handle #f))
  (set! (-> self control actor-contact-handle) (the-as handle #f))
  (set! (-> self control yellow-eco-last-use-time) 0)
  (buzz-stop! 0)
  self
  )

(defmethod target-init! ((this target) (arg0 continue-point) (arg1 symbol))
  (local-vars (s1-0 int) (s2-0 int) (s3-0 int) (s4-0 int) (sv-16 collide-shape-prim-group))
  (set! (-> *setting-control* user-default kg-primary-target) (process->handle this))
  (set! (-> *setting-control* user-default ff-primary-target) (process->handle this))
  (set! (-> *setting-control* user-default mh-primary-target) (process->handle this))
  (set! (-> *setting-control* user-default sound-ear) (process->handle this))
  (set! (-> this tobot?) arg1)
  (set! (-> this tobot-recorder) #f)
  (set! (-> this mode-cache) #f)
  (set! (-> this color-effect) #f)
  (set! (-> this major-mode-exit-hook) #f)
  (set! (-> this major-mode-event-hook) #f)
  (set! (-> this sub-mode-exit-hook) #f)
  (set! (-> this cloth) #t)
  (set! (-> this game) *game-info*)
  (set! (-> this ext-geo-control) *target-geo-control*)
  (set! (-> this pending-ext-geo)
        (if (and (logtest? (game-feature feature56) (-> this game features))
                 (not (logtest? (game-secrets commentary) (-> *game-info* secrets)))
                 )
            (target-geo jakc)
            (target-geo jakb)
            )
        )
  (set! (-> this ext-geo) (target-geo uninitialized))
  (set! (-> this ext-anim-control) *target-anim-control*)
  (set! (-> this pending-ext-anim) (target-anim default))
  (set! (-> this ext-anim) (target-anim uninitialized))
  (set-setting! 'allow-pause #f 0.0 0)
  (set-setting! 'allow-progress #f 0.0 0)
  (set! (-> *setting-control* cam-default mode-name) 'cam-string)
  (apply-settings *setting-control*)
  (if (not arg0)
      (set! arg0 (get-current-continue-forced *game-info*))
      )
  (set-continue! *game-info* arg0 #f)
  (stack-size-set! (-> this main-thread) 2048)
  (logior! (-> this mask) (process-mask target))
  (set! (-> this state-hook) (the-as (function none :behavior target) nothing))
  (set! (-> this scarf-interp-old) -1.0)
  (set! (-> this goggles-interp-old) -1.0)
  (set! (-> this darkjak-interp-old) -1.0)
  (cond
    ((= (-> this tobot?) 'tobot)
     (set! s4-0 #x80000)
     (set! s3-0 #x64303f7f)
     (set! s2-0 #x80000)
     (set! s1-0 #x6430377e)
     )
    (else
      (set! s4-0 2)
      (set! s3-0 #x64383f7d)
      (set! s2-0 2)
      (set! s1-0 #x6438377c)
      )
    )
  (let ((s0-0 (new 'process 'control-info this (collide-list-enum hit-by-others))))
    (set! (-> s0-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s0-0 reaction) target-collision-reaction)
    (set! (-> s0-0 no-reaction) target-collision-no-reaction)
    (set! sv-16 (new 'process 'collide-shape-prim-group s0-0 (the-as uint 9) 1))
    (set! (-> s0-0 total-prims) (the-as uint 10))
    (set! (-> sv-16 prim-core action) (collide-action solid can-ride))
    (set-vector! (-> sv-16 local-sphere) 0.0 0.0 0.0 4096.0)
    (set! (-> s0-0 root-prim) sv-16)
    (set! (-> sv-16 prim-core collide-as) (the-as collide-spec s4-0))
    (set! (-> sv-16 prim-core collide-with) (the-as collide-spec s3-0))
    (let ((v0-9 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 6))))
      (set! (-> v0-9 prim-core action) (collide-action solid can-ride))
      (set-vector! (-> v0-9 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 0) v0-9)
      (set! (-> v0-9 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-9 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-10 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 10))))
      (set! (-> v0-10 prim-core action) (collide-action solid))
      (set-vector! (-> v0-10 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 1) v0-10)
      (set! (-> v0-10 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-10 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-11 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 18))))
      (set! (-> v0-11 prim-core action) (collide-action solid))
      (set-vector! (-> v0-11 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 2) v0-11)
      (set! (-> v0-11 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-11 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-12 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 34))))
      (set! (-> v0-12 prim-core action) (collide-action solid))
      (set-vector! (-> v0-12 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 3) v0-12)
      (set! (-> v0-12 prim-core collide-as) (collide-spec))
      (set! (-> v0-12 prim-core collide-with) (collide-spec))
      )
    (let ((v0-13 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 0))))
      (set! (-> v0-13 prim-core action) (collide-action semi-solid))
      (set! (-> v0-13 transform-index) 6)
      (set-vector! (-> v0-13 local-sphere) 0.0 0.0 0.0 2048.0)
      (set! (-> s0-0 collision-spheres 4) v0-13)
      (set! (-> v0-13 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-13 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-14 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 128))))
      (set! (-> v0-14 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-14 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 6) v0-14)
      )
    (let ((v0-15 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 256))))
      (set! (-> v0-15 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-15 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 7) v0-15)
      )
    (let ((v0-16 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 512))))
      (set! (-> v0-16 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-16 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 8) v0-16)
      )
    (let ((v0-17 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 1024))))
      (set! (-> v0-17 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-17 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 9) v0-17)
      )
    (set! (-> s0-0 nav-radius) (* 0.75 (-> s0-0 root-prim local-sphere w)))
    (let ((v1-93 (-> s0-0 root-prim)))
      (set! (-> s0-0 backup-collide-as) (-> v1-93 prim-core collide-as))
      (set! (-> s0-0 backup-collide-with) (-> v1-93 prim-core collide-with))
      )
    (set! (-> s0-0 event-priority) (the-as uint 9))
    (set! (-> this control) s0-0)
    )
  (let ((v1-96 (-> this control)))
    (set! (-> v1-96 default-collide-as-all) (the-as collide-spec s4-0))
    (set! (-> v1-96 default-collide-with-all) (the-as collide-spec s3-0))
    (set! (-> v1-96 default-collide-as-fgnd) (the-as collide-spec s2-0))
    (set! (-> v1-96 default-collide-with-fgnd) (the-as collide-spec s1-0))
    (set! (-> v1-96 max-iteration-count) (the-as uint 8))
    (set! (-> v1-96 event-self) 'touched)
    )
  (move-to-point! (-> this control) (-> arg0 trans))
  (set! (-> this control camera-pos quad) (-> arg0 trans quad))
  (set! (-> this focus-search) (new 'process 'boxed-array collide-shape 128))
  (set! (-> this focus-search length) 0)
  (set! (-> this handle-search) (new 'process 'boxed-array handle 128))
  (set! (-> this handle-search length) 0)
  (set! (-> this control cpad) (-> *cpad-list* cpads 0))
  (set! (-> this control current-surface) (new 'process 'surface))
  (set! (-> this control current-surface name) 'current)
  (set! (-> this control current-surface active-hook) nothing)
  (set! (-> this control current-surface touch-hook) nothing)
  (set! (-> this control send-attack-dest) (the-as handle #f))
  (dotimes (v1-112 8)
    (set! (-> this attack-info-old v1-112 attacker) (the-as handle #f))
    )
  (set! (-> this notify) (the-as handle #f))
  (set! (-> this mirror) (the-as (pointer process-drawable) #f))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-jchar" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logior! (-> this skel effect flags) (effect-control-flag ecf0 ecf1))
  (let ((v1-122 (-> this node-list data)))
    (set! (-> v1-122 0 param0) (the-as (function cspace transformq none) cspace<-transformq+trans!))
    (set! (-> v1-122 0 param1) (the-as basic (-> this control trans)))
    (set! (-> v1-122 0 param2) (the-as basic (-> this control cspace-offset)))
    )
  (set! (-> this skel override) (new 'process 'boxed-array float 54))
  (set! (-> this draw light-index) (the-as uint 30))
  (set! (-> this beard?) #t)
  (set! (-> this draw lod-set max-lod) 0)
  (logior! (-> this skel status) (joint-control-status sync-math blend-shape eye-anim))
  (set! (-> this draw shadow-ctrl) *target-shadow-control*)
  (set! (-> this shadow-backup) (-> this draw shadow))
  (set! (-> this carry)
        (new 'process 'carry-info this 52 (new 'static 'vector :w 1.0) (new 'static 'vector :z 1.0 :w 1.0) 12743.111)
        )
  (set! (-> this control lhand-cspace) (-> this node-list data 21))
  (set! (-> this control rhand-cspace) (-> this node-list data 30))
  (set! (-> this control rhand-cspace) (-> this node-list data 30))
  (set! (-> this control sidekick-root parent) (-> this node-list data 34))
  (set! (-> this neck) (new 'process 'joint-mod (joint-mod-mode look-at) this 8))
  (set! (-> this neck parented-scale?) #t)
  (set! (-> this neck base-joint) (the-as uint 6))
  (set! (-> this neck ignore-angle) 16384.0)
  (set! (-> this head) (new 'process 'joint-mod (joint-mod-mode flex-blend) this 7))
  (set! (-> this head parented-scale?) #t)
  (set! (-> this upper-body) (new 'process 'joint-mod (joint-mod-mode joint-set*-world) this 4))
  (set! (-> this upper-body parented-scale?) #t)
  (set! (-> this horns) (new 'process 'joint-mod (joint-mod-mode joint-set) this 15))
  (set! (-> this horns parented-scale?) #t)
  (set! (-> this horns track-mode) (track-mode no-trans no-rotate))
  (set! (-> this hair 0) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 9))
  (set! (-> this hair 0 parented-scale?) #t)
  (set! (-> this hair 1) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 10))
  (set! (-> this hair 1 parented-scale?) #t)
  (set! (-> this arm-ik 0) (new 'process 'joint-mod-ik this 18 1228.8))
  (set! (-> this arm-ik 1) (new 'process 'joint-mod-ik this 27 -1228.8))
  (set! (-> this arm-ik 1 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> this arm-ik 1 elbow-rotation-axis) (the-as uint 0))
  (set! (-> this leg-ik 0) (new 'process 'joint-mod-ik this 40 1687.552))
  (set! (-> this leg-ik 0 callback)
        (the-as (function joint-mod-ik matrix matrix vector object) leg-ik-callback)
        )
  (set! (-> this leg-ik 0 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> this leg-ik 0 elbow-rotation-axis) (the-as uint 0))
  (logior! (-> this leg-ik 0 flags) (joint-mod-ik-flags elbow-trans-neg))
  (set! (-> this leg-ik 1) (new 'process 'joint-mod-ik this 46 -1687.552))
  (set! (-> this leg-ik 1 callback)
        (the-as (function joint-mod-ik matrix matrix vector object) leg-ik-callback)
        )
  (set! (-> this leg-ik 1 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> this leg-ik 1 elbow-rotation-axis) (the-as uint 0))
  (set! (-> this foot 0) (new 'process 'joint-mod (joint-mod-mode gun-look-at) this 41))
  (set! (-> this foot 1) (new 'process 'joint-mod (joint-mod-mode gun-look-at) this 47))
  (set! (-> this fact) (new
                         'process
                         'fact-info-target
                         this
                         (pickup-type eco-pill-random)
                         (-> *FACT-bank* default-eco-pill-green-inc)
                         )
        )
  (target-gun-setup (logtest? (-> this game features) (game-feature gun)))
  (target-board-setup (logtest? (game-feature board) (-> this game features)))
  (target-sidekick-setup (logtest? (game-feature sidekick) (-> this game features)))
  (target-darkjak-setup (logtest? (game-feature darkjak) (-> this game features)))
  (target-lightjak-setup (logtest? (game-feature lightjak) (-> this game features)))
  (target-collide-set! 'normal 0.0)
  (let ((v1-192 (-> this control root-prim)))
    (set! (-> this control backup-collide-as) (-> v1-192 prim-core collide-as))
    (set! (-> this control backup-collide-with) (-> v1-192 prim-core collide-with))
    )
  (set! (-> this sound) (new 'process 'ambient-sound "none" (-> this control trans) 0.0))
  (set! (-> this control unknown-sound-id04) (new-sound-id))
  (set! (-> this control bubbles-sound) (new-sound-id))
  (set! (-> this control board-jump-and-swim-sound) (new-sound-id))
  (if (and *debug-segment* (!= (-> this tobot?) 'tobot))
      (add-connection *debug-engine* this target-print-stats this *stdcon0* #f)
      )
  (activate-hud this)
  (set! (-> this fp-hud) (the-as handle #f))
  (set! (-> this burn-proc) (the-as handle #f))
  (set! (-> this water) (new 'process 'water-control this 10 0.0 8192.0 2048.0))
  (set! (-> this water flags) (water-flag swim-ground part-splash part-drip part-rings part-water find-water))
  (reset-target-state #t)
  (set! (-> this control last-trans-any-surf quad) (-> this control trans quad))
  (+! (-> this control last-trans-any-surf y) -819200.0)
  (set! (-> this align) (new 'process 'align-control this))
  (set! (-> this manipy) (the-as (pointer manipy) #f))
  (set! (-> this event-hook) target-generic-event-handler)
  (set! (-> this current-level) #f)
  (level-setup)
  (set! (-> this pre-joint-hook) (the-as (function none :behavior target) nothing))
  (set-time! (-> this init-time))
  (set! (-> this spool-anim) (the-as spool-anim #t))
  (set-time! (-> this ambient-time))
  (let ((v1-220 *edge-grab-info*))
    (set! (-> v1-220 pilot-edge-grab?) #f)
    (set! (-> v1-220 pilot-edge-grab handle) (the-as handle #f))
    (set! (-> v1-220 actor-handle) (the-as handle #f))
    )
  (set! (-> this control unknown-handle000) (the-as handle #f))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-init target ((arg0 continue-point))
  (target-init! self arg0 #f)
  (set! (-> self event-hook) (-> target-continue event))
  (logior! (-> self focus-status) (focus-status teleporting))
  (go target-continue arg0)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior tobot-init target ((arg0 symbol))
  (target-init! self (the-as continue-point #f) 'tobot)
  (set! (-> self name) "tobot")
  (set! (-> self tobot-recorder) (the-as basic arg0))
  (send-event *target* 'tobot 'tobot)
  (go tobot-stance)
  (none)
  )

(defmethod deactivate ((this target))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (kill-persister *setting-control* (the-as engine-pers 'bg-a-speed) 'bg-a-speed)
  (if (nonzero? (-> this darkjak))
      (sound-stop (-> this darkjak tone))
      )
  (if (nonzero? (-> this lightjak))
      (sound-stop (the-as sound-id (-> this lightjak tone)))
      )
  (if (nonzero? (-> this gun))
      (sound-stop (-> this gun blue-whine-sound-id))
      )
  (when (nonzero? (-> this board))
    (sound-stop (-> this board wind-sound-id))
    (sound-stop (-> this board engine-sound-id))
    (sound-stop (-> this board bank-sound-id))
    (sound-stop (-> this board ride-sound-id))
    (sound-stop (-> this board spin-sound-id))
    )
  (set! (-> *setting-control* cam-default mode-name) #f)
  (set-zero! *camera-smush-control*)
  (set! (-> *setting-control* user-default kg-primary-target) (the-as handle #f))
  (set! (-> *setting-control* user-default ff-primary-target) (the-as handle #f))
  (set! (-> *setting-control* user-default mh-primary-target) (the-as handle #f))
  (set! (-> *setting-control* user-default sound-ear) (the-as handle #f))
  (call-parent-method this)
  (none)
  )

(defun stop ((arg0 symbol))
  (when *target*
    (kill-by-name "target" *active-pool*)
    (set! *target* #f)
    )
  (set! (-> *game-info* mode) arg0)
  0
  )

(defun start ((arg0 symbol) (arg1 continue-point))
  (let ((v1-0 arg0))
    (set! (-> *level* play?) (if (= v1-0 'play)
                                 #t
                                 (-> *setting-control* user-default border-mode)
                                 )
          )
    )
  (set! (-> *setting-control* user-default border-mode) #f)
  (set! (-> *setting-control* user-default region-mode) #f)
  (apply-settings *setting-control*)
  (stop arg0)
  (let ((v1-8 (process-spawn
                target
                :init target-init
                arg1
                :name "target"
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                )
              )
        )
    (if v1-8
        (set! *target* (the-as target (-> v1-8 0 self)))
        (set! *target* #f)
        )
    )
  *target*
  )

;; WARN: Return type mismatch (pointer process) vs target.
(defun tobot-start ((arg0 symbol))
  (the-as target (process-spawn
                   target
                   :init tobot-init
                   arg0
                   :name "target"
                   :from *target-dead-pool*
                   :to *target-pool*
                   :stack *kernel-dram-stack*
                   )
          )
  )

(defun tobot-stop ()
  (kill-by-name "tobot" *active-pool*)
  0
  )

(kmemopen global "target-geo")

(define *target-geo-control* (new
                               'global
                               'external-art-buffer
                               0
                               (lambda ((arg0 external-art-buffer))
                                 (let ((gp-0 (-> arg0 heap)))
                                   (set! (-> gp-0 base) (kmalloc global #x26000 (kmalloc-flags) "heap"))
                                   (set! (-> gp-0 current) (-> gp-0 base))
                                   (set! (-> gp-0 top-base) (&+ (-> gp-0 base) #x26000))
                                   (set! (-> gp-0 top) (-> gp-0 top-base))
                                   )
                                 0
                                 (none)
                                 )
                               #t
                               )
        )

(let ((gp-0 *target-geo-control*))
  ((-> gp-0 init-heap) gp-0)
  (set! (-> gp-0 status) 'inactive)
  )

(kmemclose)

(kmemopen global "target-anim")

(define *target-anim-control* (new
                                'global
                                'external-art-buffer
                                0
                                (lambda ((arg0 external-art-buffer))
                                  (let ((gp-0 (-> arg0 heap)))
                                    (set! (-> gp-0 base) (kmalloc global #x4d000 (kmalloc-flags) "heap"))
                                    (set! (-> gp-0 current) (-> gp-0 base))
                                    (set! (-> gp-0 top-base) (&+ (-> gp-0 base) #x4d000))
                                    (set! (-> gp-0 top) (-> gp-0 top-base))
                                    )
                                  0
                                  (none)
                                  )
                                #t
                                )
        )

(let ((gp-1 *target-anim-control*))
  ((-> gp-1 init-heap) gp-1)
  (set! (-> gp-1 status) 'inactive)
  )

(kmemclose)
