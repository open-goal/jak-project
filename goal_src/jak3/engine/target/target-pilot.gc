;;-*-Lisp-*-
(in-package goal)

;; name: target-pilot.gc
;; name in dgo: target-pilot
;; dgos: HGA, LPATK, RAILA, LFACCAR, CWI, WASALL, LFACTORY, COMBA

(deftype cquery-with-5vec (structure)
  "target-pilot-post"
  ((cquery collide-query :inline)
   (vec    vector 5 :inline)
   )
  )

(define-extern h-warf type)

;; DECOMP BEGINS

(define *pilot-mods* (new 'static 'surface :name 'empty :seek0 1.0 :seek90 1.0 :seek180 1.0 :fric 1.0))

;; WARN: disable def twice: 203. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defbehavior target-pilot-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (cond
    ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
     'pilot
     )
    (else
      (case arg2
        (('end-mode)
         (case (-> arg3 param 0)
           (('pilot)
            (let ((v1-5 (-> self pilot)))
              (when (nonzero? v1-5)
                (let ((a0-7 (handle->process (-> v1-5 vehicle))))
                  (if a0-7
                      (put-rider-in-seat (the-as vehicle a0-7) (-> v1-5 seat-index) (the-as process #f))
                      )
                  )
                )
              )
            (go target-pilot-get-off (process->handle arg0))
            )
           (('fldax)
            (when (and (-> self next-state) (= (-> self next-state name) 'target-pilot-daxter-perch))
              (let ((v0-0 (the-as object #t)))
                (set! (-> self control unknown-word04) (the-as uint v0-0))
                v0-0
                )
              )
            )
           (('gun)
            (target-gun-end-mode #t)
            )
           )
         )
        (('change-mode)
         (case (-> arg3 param 0)
           (('grab)
            (when (not (focus-test? self dead))
              (if (not (-> arg3 param 1))
                  #t
                  (go target-pilot-grab)
                  )
              )
            )
           (('flut)
            (go
              target-flut-start
              (process->handle (the-as process (-> arg3 param 1)))
              (the-as symbol (if (>= arg1 2)
                                 (-> arg3 param 2)
                                 'normal
                                 )
                      )
              (if (>= arg1 4)
                  (the-as int (-> arg3 param 3))
                  -1
                  )
              )
            )
           (('normal)
            (go target-pilot-get-off (process->handle arg0))
            )
           (('gun)
            (when (logtest? (-> self game features) (game-feature gun))
              (let ((gp-1 (-> arg3 param 2)))
                (cond
                  ((using-gun? self)
                   (when (nonzero? gp-1)
                     (set! (-> self gun using-gun-type) (the-as pickup-type gp-1))
                     gp-1
                     )
                   )
                  (else
                    (target-gun-init (the-as pickup-type gp-1))
                    )
                  )
                )
              )
            )
           (('fldax)
            (if (and (-> self next-state) (let ((v1-33 (-> self next-state name)))
                                            (or (= v1-33 'target-pilot-stance) (= v1-33 'target-pilot-impact))
                                            )
                     )
                (go target-pilot-daxter-perch)
                )
            )
           )
         )
        (('swim)
         #f
         )
        (('clone-anim)
         (go target-pilot-clone-anim (process->handle (the-as process (-> arg3 param 0))))
         )
        (('get-vehicle)
         (if (nonzero? (-> self pilot))
             (handle->process (-> self pilot vehicle))
             )
         )
        (('kill-vehicle)
         (if (nonzero? (-> self pilot))
             (send-event (handle->process (-> self pilot vehicle)) 'go-die)
             )
         )
        (('attack 'attack-or-shove 'attack-invinc)
         (set-vector! (-> self draw color-mult) 0.25 0.25 0.25 1.0)
         (target-attacked
           arg2
           (the-as attack-info (-> arg3 param 1))
           arg0
           (the-as touching-shapes-entry (-> arg3 param 0))
           target-pilot-hit
           )
         )
        (('vehicle-hit)
         (speech-control-method-12 *speech-control* self (if (-> self pilot as-daxter?)
                                                             (speech-type race-daxter-hit)
                                                             (speech-type race-jak-hit)
                                                             )
                                   )
         )
        (('vehicle-got-hit)
         (speech-control-method-12 *speech-control* self (if (-> self pilot as-daxter?)
                                                             (speech-type race-daxter-got-hit)
                                                             (speech-type race-jak-got-hit)
                                                             )
                                   )
         )
        (else
          (target-standard-event-handler arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defbehavior target-pilot-pidax-enter target ()
  (set! (-> self pilot art-group-backup) (-> self draw art-group))
  (set! (-> self draw art-group) (-> self sidekick 0 draw art-group))
  (logior! (-> self draw status) (draw-control-status no-draw-bounds2))
  (send-event (ppointer->process (-> self sidekick)) 'matrix 'indax)
  )

(defbehavior target-pilot-pidax-exit target ()
  (ja-channel-set! 0)
  (set! (-> self draw art-group) (-> self pilot art-group-backup))
  (logclear! (-> self draw status) (draw-control-status no-draw-bounds2))
  (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
  )

;; WARN: Return type mismatch none vs object.
(defbehavior target-pilot-exit target ()
  (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                         (or (= v1-3 'target-pilot-stance)
                                             (= v1-3 'target-pilot-impact)
                                             (= v1-3 'target-pilot-daxter-perch)
                                             (= v1-3 'target-pilot-get-off)
                                             (= v1-3 'target-pilot-grab)
                                             (= v1-3 'target-pilot-clone-anim)
                                             (= v1-3 'target-pilot-hit)
                                             (= v1-3 'target-pilot-death)
                                             )
                                         )
                  )
             )
    (let ((v1-4 (-> self manipy)))
      (when v1-4
        (deactivate (-> v1-4 0))
        (set! (-> self manipy) (the-as (pointer manipy) #f))
        )
      )
    (process-drawable-set-riding self #f)
    (when (-> self pilot as-daxter?)
      (format 0 "Pidax exit~%")
      (target-pilot-pidax-exit)
      )
    (let ((gp-0 (-> self pilot)))
      (when (nonzero? gp-0)
        (set! (-> self control nav-radius) (-> gp-0 backup-nav-radius))
        (let ((s5-0 (handle->process (-> gp-0 vehicle))))
          (when s5-0
            (send-event *traffic-manager* 'player-exit-vehicle (-> (the-as vehicle s5-0) info object-type))
            (remove-riders (the-as vehicle s5-0) (the-as handle self))
            (send-event s5-0 'player-get-off)
            (when (nonzero? (-> gp-0 hud-health))
              (send-event (handle->process (-> gp-0 hud-health)) 'hide-and-die)
              (set! (-> gp-0 hud-health) (new 'static 'handle))
              0
              )
            (when (nonzero? (-> gp-0 hud-turbo))
              (send-event (handle->process (-> gp-0 hud-turbo)) 'hide-and-die)
              (set! (-> gp-0 hud-turbo) (new 'static 'handle))
              0
              )
            )
          )
        )
      )
    (set! (-> self neck flex-blend) 1.0)
    (let ((v1-49 (-> self control root-prim)))
      (set! (-> v1-49 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-49 prim-core collide-with) (-> self control backup-collide-with))
      )
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    (logclear! (-> self control root-prim prim-core action) (collide-action stuck-wall-escape))
    (set! (-> self control mod-surface) *walk-mods*)
    (logclear! (-> self target-flags) (target-flags tf6))
    (remove-setting! 'cloth)
    (remove-setting! 'armor)
    (enable-set! (-> self arm-ik 0) #f)
    (enable-set! (-> self arm-ik 1) #f)
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (let ((v1-74 (-> self node-list data)))
      (set! (-> v1-74 0 param0) (the-as (function cspace transformq none) cspace<-transformq+trans!))
      (set! (-> v1-74 0 param1) (the-as basic (-> self control trans)))
      (set! (-> v1-74 0 param2) (the-as basic (-> self control cspace-offset)))
      )
    (target-collide-set! 'normal 0.0)
    (set! (-> self control reaction) target-collision-reaction)
    (vector-identity! (-> self draw color-mult))
    (set! (-> self control cspace-offset quad) (the-as uint128 0))
    (logior! (-> self water flags) (water-flag find-water))
    (target-exit)
    )
  )

;; WARN: Return type mismatch water-flag vs object.
(defbehavior target-pilot-init target ((arg0 handle) (arg1 symbol))
  (target-exit)
  (target-lightjak-end-mode #f)
  (target-darkjak-end-mode #f)
  (if (zero? (-> self pilot))
      (set! (-> self pilot) (new 'process 'pilot-info))
      )
  (let ((s5-0 (-> self pilot)))
    (set! (-> s5-0 backup-nav-radius) (-> self control nav-radius))
    (set! (-> s5-0 gun?) #t)
    (set! (-> s5-0 enable-cam-side-shift) #f)
    (set! (-> s5-0 as-daxter?) arg1)
    (set! (-> s5-0 entity) #f)
    (set! (-> s5-0 cam-side-shift) 0.0)
    (if (-> self pilot as-daxter?)
        (target-pilot-pidax-enter)
        )
    (cond
      ((handle->process arg0)
       (set! (-> s5-0 vehicle) arg0)
       )
      (else
        (break!)
        0
        )
      )
    (let ((s4-1 (handle->process (-> s5-0 vehicle))))
      (when s4-1
        (send-event *traffic-manager* 'player-enter-vehicle (-> (the-as vehicle s4-1) info object-type))
        (set! (-> self game current-vehicle) (-> (the-as vehicle s4-1) info vehicle-type))
        (set! (-> s5-0 entity) (-> (the-as vehicle s4-1) entity))
        (set! (-> s5-0 gun?) (logtest? (-> (the-as vehicle s4-1) info flags) 32))
        (set! (-> s5-0 enable-cam-side-shift) (logtest? (-> (the-as vehicle s4-1) info flags) 128))
        (if (logtest? (-> (the-as vehicle s4-1) info flags) 256)
            (set! (-> s5-0 hud-health) (process->handle (hud-vehicle-health-spawn (the-as vehicle s4-1))))
            )
        (if (logtest? (-> (the-as vehicle s4-1) info flags) 512)
            (set! (-> s5-0 hud-turbo) (process->handle (hud-vehicle-turbo-spawn (the-as vehicle s4-1))))
            )
        (set! (-> s5-0 left-right-bias) (-> (the-as vehicle s4-1) info handling player-turn-anim-bias))
        (set! (-> s5-0 left-right-min) (-> (the-as vehicle s4-1) info handling player-turn-anim-min))
        (set! (-> s5-0 left-right-max) (-> (the-as vehicle s4-1) info handling player-turn-anim-max))
        (send-event
          (ppointer->process (-> (the-as vehicle s4-1) parent))
          'player-got-on-vehicle-child
          (the-as vehicle s4-1)
          )
        (set! (-> s5-0 stance) (vehicle-method-70 (the-as vehicle s4-1)))
        (let ((s3-0 (vehicle-method-65 (the-as vehicle s4-1))))
          (dotimes (s2-0 s3-0)
            (let ((a0-35 (get-rider-in-seat (the-as vehicle s4-1) s2-0)))
              (if (and a0-35 (send-event a0-35 'knocked-off))
                  (put-rider-in-seat (the-as vehicle s4-1) s2-0 (the-as process #f))
                  )
              )
            )
          )
        (let ((v1-68 (get-best-seat (the-as vehicle s4-1) (-> self control trans) (vehicle-seat-flag vsf0) 1)))
          (set! (-> s5-0 seat-index) (max 0 v1-68))
          )
        (cond
          ((-> s5-0 as-daxter?)
           (set! (-> s5-0 left-right-accel-factor) 0.0000012207031)
           (set! (-> s5-0 front-back-accel-factor) 0.0000012207031)
           (set! (-> s5-0 up-down-accel-factor) 0.00000061035155)
           )
          ((zero? (-> s5-0 stance))
           (set! (-> s5-0 left-right-accel-factor) 0.0000012207031)
           (set! (-> s5-0 front-back-accel-factor) 0.0000012207031)
           (set! (-> s5-0 up-down-accel-factor) 0.00000051879886)
           )
          (else
            (set! (-> s5-0 left-right-accel-factor) 0.0000012207031)
            (set! (-> s5-0 front-back-accel-factor) 0.0000012207031)
            (set! (-> s5-0 up-down-accel-factor) 0.00000061035155)
            )
          )
        (set! (-> s5-0 left-right-accel-factor)
              (* (-> s5-0 left-right-accel-factor) (-> (the-as vehicle s4-1) info handling pilot-x-accel-factor))
              )
        (set! (-> s5-0 up-down-accel-factor)
              (* (-> s5-0 up-down-accel-factor) (-> (the-as vehicle s4-1) info handling pilot-y-accel-factor))
              )
        (set! (-> s5-0 front-back-accel-factor)
              (* (-> s5-0 front-back-accel-factor) (-> (the-as vehicle s4-1) info handling pilot-z-accel-factor))
              )
        )
      )
    (when (not (-> s5-0 gun?))
      (if arg1
          (logior! (-> self control current-surface flags) (surface-flag gun-fast-exit))
          )
      (target-gun-end-mode arg1)
      )
    )
  (set! (-> self board latch?) #f)
  (set! (-> self control reaction) target-collision-reaction)
  (set! (-> self control transv quad) (the-as uint128 0))
  (set! (-> self control ctrl-xz-vel) 0.0)
  (logior! (-> self focus-status) (focus-status pilot))
  (set! (-> self control bend-target) 0.0)
  (let ((v1-102 (-> self node-list data)))
    (set! (-> v1-102 0 param0) (the-as (function cspace transformq none) cspace<-transformq+world-trans!))
    (set! (-> v1-102 0 param1) (the-as basic (-> self control trans)))
    (set! (-> v1-102 0 param2) (the-as basic (-> self control cspace-offset)))
    )
  (let ((v1-104 (-> self control root-prim)))
    (set! (-> v1-104 prim-core collide-as) (collide-spec))
    (set! (-> v1-104 prim-core collide-with) (collide-spec))
    )
  0
  (set! (-> self control root-prim prim-core collide-as) (collide-spec jak-vehicle))
  (set! (-> self control root-prim prim-core collide-with)
        (collide-spec hit-by-player-list hit-by-others-list player-list collectable)
        )
  (set! (-> self neck flex-blend) 0.0)
  (set! (-> self control status) (collide-status))
  (let ((v0-16 (logclear (-> self water flags) (water-flag active find-water))))
    (set! (-> self water flags) v0-16)
    v0-16
    )
  )

(defbehavior pilot-on-ground? target ()
  (logtest? (-> self control status) (collide-status on-surface))
  )

(defbehavior target-pilot-post target ()
  (local-vars (a0-45 int) (a0-47 int))
  (let* ((v1-1 (-> *perf-stats* data 17))
         (a0-0 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-0) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-0)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (vector-!
          (-> self control cspace-offset)
          (-> self control draw-offset)
          (-> self control anim-collide-offset-world)
          )
        (let ((a1-5 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a1-5 options) (overlaps-others-options oo0))
          (set! (-> a1-5 collide-with-filter) (the-as collide-spec -1))
          (set! (-> a1-5 tlist) *touching-list*)
          (find-overlapping-shapes (-> self control) a1-5)
          )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (let* ((gp-2 (-> self pilot))
         (s5-0 (handle->process (-> gp-2 vehicle)))
         )
    (when s5-0
      (vehicle-method-66 (the-as vehicle s5-0) (-> self control trans) (-> gp-2 seat-index))
      (set! (-> self control transv quad) (-> (the-as vehicle s5-0) root transv quad))
      (quaternion-copy! (-> self control quat) (-> (the-as vehicle s5-0) root quat))
      (quaternion-copy! (-> self control quat-for-control) (-> self control quat))
      (quaternion-copy! (-> self control dir-targ) (-> self control quat))
      (let ((s4-0 (-> self alt-cam-pos)))
        (when (not (focus-test? self dead))
          (let ((s3-0 (new 'stack-no-clear 'cquery-with-5vec)))
            (set! (-> s3-0 vec 2 x) 0.0)
            (set! (-> s3-0 vec 2 y) 20480.0)
            (let ((a0-18 (-> self node-list data 0 bone transform)))
              (set! (-> s3-0 vec 1 quad) (-> a0-18 fvec quad))
              )
            (set! (-> s3-0 vec 1 y) 0.0)
            (vector-rotate90-around-y! (-> s3-0 vec 1) (-> s3-0 vec 1))
            (vector-normalize! (-> s3-0 vec 1) 1.0)
            (set! (-> s3-0 vec 0 quad) (-> self control trans quad))
            (when (-> gp-2 enable-cam-side-shift)
              (dotimes (s2-0 2)
                (let ((v1-48 (-> s3-0 cquery)))
                  (set! (-> v1-48 radius) 2048.0)
                  (set! (-> v1-48 collide-with) (collide-spec backgnd))
                  (set! (-> v1-48 ignore-process0) #f)
                  (set! (-> v1-48 ignore-process1) #f)
                  (set! (-> v1-48 ignore-pat)
                        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                        )
                  (set! (-> v1-48 action-mask) (collide-action solid))
                  )
                (set! (-> s3-0 cquery start-pos quad) (-> s3-0 vec 0 quad))
                (vector-float*! (-> s3-0 cquery move-dist) (-> s3-0 vec 1) (-> s3-0 vec 2 y))
                (let ((f0-10 (fill-and-probe-using-line-sphere *collide-cache* (-> s3-0 cquery))))
                  (when (and (>= f0-10 0.0) (= (-> s3-0 cquery best-other-tri pat mode) (pat-mode wall)))
                    (+! (-> s3-0 vec 2 x) (* -1.0 (-> s3-0 vec 2 y) (- 1.0 f0-10)))
                    0
                    )
                  )
                (set! (-> s3-0 vec 2 y) (* -1.0 (-> s3-0 vec 2 y)))
                )
              (set! (-> s3-0 vec 2 x)
                    (* (-> s3-0 vec 2 x) (fmax 0.25 (fmin 1.0 (* 0.000008138021 (vector-length (-> self control transv))))))
                    )
              (seek! (-> gp-2 cam-side-shift) (-> s3-0 vec 2 x) (* 16384.0 (seconds-per-frame)))
              )
            (set! (-> s4-0 x) (+ (-> s3-0 vec 0 x) (* (-> gp-2 cam-side-shift) (-> s3-0 vec 1 x))))
            (set! (-> s4-0 z) (+ (-> s3-0 vec 0 z) (* (-> gp-2 cam-side-shift) (-> s3-0 vec 1 z))))
            (if (type? s5-0 h-warf)
                (set! (-> s4-0 y) (-> s3-0 vec 0 y))
                (set! (-> s4-0 y) (fmax (fmin (-> s4-0 y) (+ 2048.0 (-> s3-0 vec 0 y))) (+ -2048.0 (-> s3-0 vec 0 y))))
                )
            )
          0
          )
        )
      (let ((s4-1 (new 'stack-no-clear 'matrix)))
        (vehicle-method-113 (the-as vehicle s5-0) (-> s4-1 rvec) (-> gp-2 seat-index) 0)
        (vehicle-method-113 (the-as vehicle s5-0) (-> s4-1 uvec) (-> gp-2 seat-index) 1)
        (enable-set! (-> self arm-ik 0) #t)
        (enable-set! (-> self arm-ik 1) #t)
        (set-ik-target! (-> self arm-ik 0) (-> s4-1 rvec))
        (set-ik-target! (-> self arm-ik 1) (-> s4-1 uvec))
        )
      )
    )
  (ja-post)
  (joint-points)
  (update-transforms (-> self control))
  (do-target-gspot)
  (target-powerup-process)
  (let ((v1-95 (-> *perf-stats* data 17)))
    (b! (zero? (-> v1-95 ctrl)) cfg-31 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-45 pcr0)
    (+! (-> v1-95 accum0) a0-45)
    (.mfpc a0-47 pcr1)
    (+! (-> v1-95 accum1) a0-47)
    )
  (label cfg-31)
  0
  0
  (none)
  )
