;;-*-Lisp-*-
(in-package goal)

;; name: pilot-states.gc
;; name in dgo: pilot-states
;; dgos: HGA, LPATK, RAILA, LFACCAR, CWI, WASALL, LFACTORY, COMBA

;; DECOMP BEGINS

(defstate target-pilot-start (target)
  :event target-pilot-handler
  :exit target-pilot-exit
  :code (behavior ((arg0 handle) (arg1 symbol) (arg2 symbol))
    (target-pilot-init arg0 arg2)
    (suspend)
    (remove-exit)
    (if arg1
        (go target-pilot-stance)
        (go target-pilot-get-on)
        )
    )
  :post target-post
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior target-pilot-bike-anim-loop target ()
  (ja-channel-push! 3 (seconds 0.1))
  (ja :group! jakb-pilot-bike-turn-back-ja)
  (ja :chan 1 :group! jakb-pilot-bike-turn-front-ja)
  (ja :chan 2 :group! jakb-pilot-bike-up-down-ja)
  (until #f
    (let ((gp-0 (-> self pilot)))
      (let ((f30-0 (* 5.0 (- 1.0 (-> gp-0 left-right-interp)))))
        (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
        (let ((f0-3 (fmax 0.0 (fmin 1.0 (* 0.5 (+ 1.0 (* 1.42 (+ -0.3 (-> gp-0 front-back-interp)))))))))
          (ja :chan 1
              :frame-interp0 f0-3
              :frame-interp1 f0-3
              :num-func num-func-identity
              :frame-num (ja-aframe f30-0 1)
              )
          )
        )
      (let ((f0-6 (* 5.0 (- 1.0 (-> gp-0 up-down-interp))))
            (s5-2 (-> self skel root-channel 2))
            )
        (let ((f1-7 (fabs (-> gp-0 up-down-interp))))
          (set! (-> s5-2 frame-interp 1) f1-7)
          (set! (-> s5-2 frame-interp 0) f1-7)
          )
        (set! (-> s5-2 num-func) num-func-identity)
        (set! (-> s5-2 frame-num) (ja-aframe f0-6 2))
        )
      )
    (can-play-stance-amibent?)
    (suspend)
    )
  #f
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior target-pilot-car-anim-loop target ()
  (ja-channel-push! 3 (seconds 0.1))
  (ja :group! jakb-pilot-car-turn-back-ja)
  (ja :chan 1 :group! jakb-pilot-car-turn-front-ja)
  (ja :chan 2 :group! jakb-pilot-car-up-down-ja)
  (until #f
    (let ((gp-0 (-> self pilot)))
      (let ((f30-0 (* 5.0 (+ 1.0 (-> gp-0 left-right-interp)))))
        (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
        (let ((s5-1 (-> self skel root-channel 1)))
          (let ((f0-3 (* 0.5 (+ 1.0 (-> gp-0 front-back-interp)))))
            (set! (-> s5-1 frame-interp 1) f0-3)
            (set! (-> s5-1 frame-interp 0) f0-3)
            )
          (set! (-> s5-1 num-func) num-func-identity)
          (set! (-> s5-1 frame-num) (ja-aframe f30-0 1))
          )
        )
      (let ((f0-6 (* 10.0 (- 1.0 (-> gp-0 up-down-interp))))
            (s5-2 (-> self skel root-channel 2))
            )
        (let ((f1-7 (fabs (-> gp-0 up-down-interp))))
          (set! (-> s5-2 frame-interp 1) f1-7)
          (set! (-> s5-2 frame-interp 0) f1-7)
          )
        (set! (-> s5-2 num-func) num-func-identity)
        (set! (-> s5-2 frame-num) (ja-aframe f0-6 2))
        )
      )
    (can-play-stance-amibent?)
    (suspend)
    )
  #f
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior target-pilot-wcar-anim-loop target ()
  (ja-channel-push! 3 (seconds 0.1))
  (ja :group! jakb-pilot-wcar-turn-back-ja)
  (ja :chan 1 :group! jakb-pilot-wcar-turn-front-ja)
  (ja :chan 2 :group! jakb-pilot-car-up-down-ja)
  (until #f
    (let ((gp-0 (-> self pilot)))
      (let ((f30-0 (* 5.0 (+ 1.0 (-> gp-0 left-right-interp)))))
        (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
        (let ((s5-1 (-> self skel root-channel 1)))
          (let ((f0-3 (* 0.5 (+ 1.0 (-> gp-0 front-back-interp)))))
            (set! (-> s5-1 frame-interp 1) f0-3)
            (set! (-> s5-1 frame-interp 0) f0-3)
            )
          (set! (-> s5-1 num-func) num-func-identity)
          (set! (-> s5-1 frame-num) (ja-aframe f30-0 1))
          )
        )
      (let ((f0-6 (* 10.0 (- 1.0 (-> gp-0 up-down-interp))))
            (s5-2 (-> self skel root-channel 2))
            )
        (let ((f1-7 (fabs (-> gp-0 up-down-interp))))
          (set! (-> s5-2 frame-interp 1) f1-7)
          (set! (-> s5-2 frame-interp 0) f1-7)
          )
        (set! (-> s5-2 num-func) num-func-identity)
        (set! (-> s5-2 frame-num) (ja-aframe f0-6 2))
        )
      )
    (can-play-stance-amibent?)
    (suspend)
    )
  #f
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior target-pilot-glider-anim-loop target ()
  (ja-channel-push! 2 (seconds 0.1))
  (ja :group! jakb-pilot-glider-turn-back-ja)
  (ja :chan 1 :group! jakb-pilot-glider-turn-front-ja)
  (until #f
    (let* ((gp-0 (-> self pilot))
           (f30-0 (* 5.0 (- 1.0 (-> gp-0 left-right-interp))))
           )
      (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
      (let ((s5-1 (-> self skel root-channel 1)))
        (let ((f0-3 (* 0.5 (+ 1.0 (-> gp-0 front-back-interp)))))
          (set! (-> s5-1 frame-interp 1) f0-3)
          (set! (-> s5-1 frame-interp 0) f0-3)
          )
        (set! (-> s5-1 num-func) num-func-identity)
        (set! (-> s5-1 frame-num) (ja-aframe f30-0 1))
        )
      )
    (can-play-stance-amibent?)
    (suspend)
    )
  #f
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior target-daxter-pilot-car-anim-loop target ()
  (ja-channel-push! 3 (seconds 0.1))
  (ja :group! jakb-wings-lightjak-stance-ja)
  (ja :chan 1 :group! jakb-wings-lightjak-get-on-land-ja)
  (ja :chan 2 :group! jakb-wings-lightjak-swoop-fall-loop-ja)
  (until #f
    (when (or (-> self pilot jumping?) (let ((v1-14 (ja-group)))
                                         (and v1-14 (= v1-14 jakb-wings-lightjak-swoop1-ja))
                                         )
              )
      (let ((v1-20 (ja-group)))
        (if (not (and v1-20 (= v1-20 jakb-wings-lightjak-swoop1-ja)))
            (ja-channel-push! 1 (seconds 0.1))
            )
        )
      (ja :group! jakb-wings-lightjak-swoop1-ja :num! (seek!))
      (when (ja-done? 0)
        (ja-channel-push! 3 (seconds 0.3))
        (ja :group! jakb-wings-lightjak-stance-ja)
        (ja :chan 1 :group! jakb-wings-lightjak-get-on-land-ja)
        (ja :chan 2 :group! jakb-wings-lightjak-swoop-fall-loop-ja)
        (set! (-> self pilot jumping?) #f)
        )
      )
    (when (and (not (-> self pilot jumping?)) (let ((v1-57 (ja-group)))
                                                (not (and v1-57 (= v1-57 jakb-wings-lightjak-swoop1-ja)))
                                                )
               )
      (let ((gp-0 (-> self pilot)))
        (let ((f30-0 (* 5.0 (+ 1.0 (-> gp-0 left-right-interp)))))
          (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
          (let ((s5-1 (-> self skel root-channel 1)))
            (let ((f0-6 (* 0.5 (+ 1.0 (-> gp-0 front-back-interp)))))
              (set! (-> s5-1 frame-interp 1) f0-6)
              (set! (-> s5-1 frame-interp 0) f0-6)
              )
            (set! (-> s5-1 num-func) num-func-identity)
            (set! (-> s5-1 frame-num) (ja-aframe f30-0 1))
            )
          )
        (let* ((f30-1 (* 10.0 (- 1.0 (-> gp-0 up-down-interp))))
               (f0-9 (ja-aframe-num 2))
               (f28-0 (-> self skel root-channel 2 frame-interp 0))
               (f30-2 (seek f0-9 f30-1 (* 30.0 (seconds-per-frame))))
               (f0-16 (seek f28-0 (fabs (-> gp-0 up-down-interp)) (* 4.0 (seconds-per-frame))))
               )
          (ja :chan 2
              :frame-interp0 f0-16
              :frame-interp1 f0-16
              :num-func num-func-identity
              :frame-num (ja-aframe f30-2 2)
              )
          )
        )
      )
    (can-play-stance-amibent?)
    (suspend)
    )
  #f
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-pilot-trans target ()
  (let ((gp-0 (-> self pilot)))
    (process-drawable-set-riding self #t)
    ;; og:preserve-this
    (let* ((v1-0 (-> gp-0 vehicle))
           (a0-1 v1-0)
           (s5-0 (the vehicle (handle->process v1-0)))
           )
      (cond
        ((not s5-0)
         (ja-channel-set! 0)
         (go target-falling #f)
         )
        (#t
          (let ((s4-0 (new 'stack-no-clear 'inline-array 'vector 10)))
            (set! (-> gp-0 accel-array 7 quad) (-> gp-0 accel-array 6 quad))
            (set! (-> gp-0 accel-array 6 quad) (-> gp-0 accel-array 5 quad))
            (set! (-> gp-0 accel-array 5 quad) (-> gp-0 accel-array 4 quad))
            (set! (-> gp-0 accel-array 4 quad) (-> gp-0 accel-array 3 quad))
            (set! (-> gp-0 accel-array 3 quad) (-> gp-0 accel-array 2 quad))
            (set! (-> gp-0 accel-array 2 quad) (-> gp-0 accel-array 1 quad))
            (set! (-> gp-0 accel-array 1 quad) (-> gp-0 accel-array 0 quad))
            (get-linear-accel! s5-0 (the-as vector (-> gp-0 accel-array)))
            (vector-reset! (-> s4-0 0))
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (the-as vector (-> gp-0 accel-array)) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 1) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 2) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 3) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 4) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 5) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 6) 1.0)
            (vector+float*! (-> s4-0 0) (-> s4-0 0) (-> gp-0 accel-array 7) 1.0)
            (vector-float*! (-> s4-0 0) (-> s4-0 0) 0.5)
            (matrix-transpose! (the-as matrix (-> s4-0 1)) (-> self node-list data 0 bone transform))
            (vector-rotate*! (-> gp-0 local-accel) (-> s4-0 0) (the-as matrix (-> s4-0 1)))
            )
          (copy-vehicle-controls! s5-0 (-> gp-0 controls))
          (let ((f30-0 (* 182.04445 (* 0.6 (the float (current-time)))))
                (s5-1 (-> gp-0 local-accel))
                )
            (let ((f1-6
                    (+ (-> gp-0 controls steering)
                       (-> gp-0 left-right-bias)
                       (* 0.03 (sin f30-0))
                       (* -1.0 (-> s5-1 x) (-> gp-0 left-right-accel-factor))
                       )
                    )
                  )
              (set! (-> gp-0 left-right-interp)
                    (fmax
                      (fmin
                        (+ (-> gp-0 left-right-interp) (* 8.0 (- f1-6 (-> gp-0 left-right-interp)) (seconds-per-frame)))
                        (-> gp-0 left-right-max)
                        )
                      (-> gp-0 left-right-min)
                      )
                    )
              )
            (let ((f3-1
                    (+ (-> gp-0 controls lean-z) (* 0.03 (cos f30-0)) (* -1.0 (-> s5-1 z) (-> gp-0 front-back-accel-factor)))
                    )
                  )
              (set! (-> gp-0 front-back-interp)
                    (fmax
                      -1.0
                      (fmin 1.0 (+ (-> gp-0 front-back-interp) (* 8.0 (- f3-1 (-> gp-0 front-back-interp)) (seconds-per-frame))))
                      )
                    )
              )
            (let ((f3-5 (+ (* 0.03 (cos f30-0)) (* -1.0 (-> s5-1 y) (-> gp-0 up-down-accel-factor)))))
              (set! (-> gp-0 up-down-interp)
                    (fmax
                      -1.0
                      (fmin 1.0 (+ (-> gp-0 up-down-interp) (* 8.0 (- f3-5 (-> gp-0 up-down-interp)) (seconds-per-frame))))
                      )
                    )
              )
            )
          (when (and (-> self next-state) (= (-> self next-state name) 'target-pilot-stance))
            (let* ((v1-65 (-> gp-0 accel-array))
                   (f0-30 (+ (* (-> v1-65 0 x) (-> v1-65 0 x)) (* (-> v1-65 0 z) (-> v1-65 0 z))))
                   )
              (if (or (and (-> self pilot as-daxter?) (let ((f1-25 1024000.0))
                                                        (< (* f1-25 f1-25) f0-30)
                                                        )
                           )
                      (let ((f1-28 2048000.0))
                        (< (* f1-28 f1-28) f0-30)
                        )
                      )
                  (go target-pilot-impact)
                  )
              )
            )
          )
        (else
          (go target-pilot-get-off (the-as handle a0-1))
          )
        )
      )
    )
  (none)
  )

(defbehavior target-pilot-signal-ready target ()
  (when (not (focus-test? self pilot-riding))
    (logior! (-> self focus-status) (focus-status pilot-riding))
    (let ((gp-0 (handle->process (-> self pilot vehicle))))
      (when gp-0
        (if (logtest? #x80000 (-> (the-as vehicle gp-0) info flags))
            (set-setting! 'cloth #f 0.0 0)
            )
        (if (logtest? #x100000 (-> (the-as vehicle gp-0) info flags))
            (set-setting! 'armor #f 0.0 0)
            )
        (send-event gp-0 'pilot-on (-> self pilot seat-index))
        )
      )
    )
  )

(defstate target-pilot-stance (target)
  :event target-pilot-handler
  :exit target-pilot-exit
  :trans (behavior ()
    (target-pilot-trans)
    )
  :code (behavior ()
    (local-vars (v1-9 uint))
    (target-pilot-signal-ready)
    (logior! (-> self target-flags) (target-flags tf6))
    (set! (-> self control mod-surface) *pilot-mods*)
    (logior! (-> self control status) (collide-status on-surface on-ground))
    (cond
      ((-> self pilot as-daxter?)
       (target-daxter-pilot-car-anim-loop)
       )
      ((begin (set! v1-9 (-> self pilot stance)) (zero? v1-9))
       (target-pilot-bike-anim-loop)
       )
      ((= v1-9 1)
       (target-pilot-car-anim-loop)
       )
      ((= v1-9 2)
       (target-pilot-wcar-anim-loop)
       )
      ((= v1-9 3)
       (target-pilot-glider-anim-loop)
       )
      (else
        (until #f
          (suspend)
          )
        #f
        )
      )
    )
  :post (behavior ()
    (target-pilot-post)
    )
  )

(defstate target-pilot-impact (target)
  :event target-pilot-handler
  :exit target-pilot-exit
  :trans target-pilot-trans
  :code (behavior ()
    (local-vars (v1-1 float) (v1-196 int))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (-> self pilot)))
        (.lvf vf1 (&-> (-> gp-0 local-accel) quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov v1-1 vf1)
        (let ((f0-0 v1-1)
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s5-0 quad) (-> gp-0 local-accel quad))
          (set! (-> s5-0 x) (* 4.0 (-> s5-0 x)))
          (vector-float*! s5-0 s5-0 (/ 1.0 (sqrtf f0-0)))
          (let ((s4-0 (cond
                        ((< 0.707 (-> s5-0 x))
                         5
                         )
                        ((< (-> s5-0 x) -0.707)
                         4
                         )
                        ((< 0.707 (-> s5-0 y))
                         3
                         )
                        ((< (-> s5-0 y) -0.707)
                         2
                         )
                        ((< 0.707 (-> s5-0 z))
                         1
                         )
                        ((< (-> s5-0 z) -0.707)
                         0
                         )
                        (else
                          6
                          )
                        )
                      )
                )
            (cond
              ((-> self pilot as-daxter?)
               (ja-channel-push! 1 (seconds 0.05))
               (when (and (not (or (= s4-0 4) (= s4-0 5))) (!= s4-0 6))
                 (if (< 0.0 (-> s5-0 x))
                     (set! s4-0 5)
                     (set! s4-0 4)
                     )
                 )
               (cond
                 ((= s4-0 4)
                  (ja-no-eval :group! jakb-wings-lightjak-swoop-land-ja :num! (seek!) :frame-num 0.0)
                  (until (ja-done? 0)
                    (suspend)
                    (ja :num! (seek!))
                    )
                  )
                 ((= s4-0 5)
                  (ja-no-eval :group! jakb-shield-shield-lod0-jg :num! (seek!) :frame-num 0.0)
                  (until (ja-done? 0)
                    (suspend)
                    (ja :num! (seek!))
                    )
                  )
                 )
               )
              (else
                (let ((v1-73 (-> self pilot stance)))
                  (cond
                    ((zero? v1-73)
                     (ja-channel-push! 1 (seconds 0.05))
                     (let ((v1-74 s4-0))
                       (cond
                         ((= v1-74 4)
                          (ja-no-eval :group! jakb-pilot-bike-smack-left-ja :num! (seek!) :frame-num 0.0)
                          (until (ja-done? 0)
                            (suspend)
                            (ja :num! (seek!))
                            )
                          )
                         ((= v1-74 5)
                          (ja-no-eval :group! jakb-pilot-bike-smack-right-ja :num! (seek!) :frame-num 0.0)
                          (until (ja-done? 0)
                            (suspend)
                            (ja :num! (seek!))
                            )
                          )
                         ((zero? v1-74)
                          (ja-no-eval :group! jakb-pilot-bike-smack-front-ja :num! (seek!) :frame-num (ja-aframe 0.0 0))
                          (until (ja-done? 0)
                            (suspend)
                            (ja :num! (seek!))
                            )
                          )
                         ((= v1-74 1)
                          (ja-no-eval :group! jakb-pilot-bike-smack-back-ja :num! (seek!) :frame-num (ja-aframe 0.0 0))
                          (until (ja-done? 0)
                            (suspend)
                            (ja :num! (seek!))
                            )
                          )
                         (else
                           (ja-no-eval :group! jakb-pilot-bike-smack-shock-ja :num! (seek!) :frame-num (ja-aframe 0.0 0))
                           (until (ja-done? 0)
                             (suspend)
                             (ja :num! (seek!))
                             )
                           )
                         )
                       )
                     )
                    ((= v1-73 3)
                     (suspend)
                     0
                     )
                    ((begin (ja-channel-push! 1 (seconds 0.05)) (set! v1-196 s4-0) (= v1-196 4))
                     (ja-no-eval :group! jakb-pilot-car-smack-left-ja :num! (seek!) :frame-num 0.0)
                     (until (ja-done? 0)
                       (suspend)
                       (ja :num! (seek!))
                       )
                     )
                    ((= v1-196 5)
                     (ja-no-eval :group! jakb-pilot-car-smack-right-ja :num! (seek!) :frame-num 0.0)
                     (until (ja-done? 0)
                       (suspend)
                       (ja :num! (seek!))
                       )
                     )
                    ((zero? v1-196)
                     (ja-no-eval :group! jakb-pilot-car-smack-front-ja :num! (seek! max 1.3) :frame-num (ja-aframe 4.0 0))
                     (until (ja-done? 0)
                       (suspend)
                       (ja :num! (seek! max 1.3))
                       )
                     )
                    ((= v1-196 1)
                     (ja-no-eval :group! jakb-pilot-car-smack-back-ja :num! (seek!) :frame-num (ja-aframe 2.0 0))
                     (until (ja-done? 0)
                       (suspend)
                       (ja :num! (seek!))
                       )
                     )
                    (else
                      (ja-no-eval :group! jakb-pilot-car-smack-shock-ja :num! (seek!) :frame-num (ja-aframe 0.0 0))
                      (until (ja-done? 0)
                        (suspend)
                        (ja :num! (seek!))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (.svf (&-> (-> gp-0 accel-array) 0 quad) vf0)
        )
      (go target-pilot-stance)
      )
    )
  :post target-pilot-post
  )

(defstate target-pilot-daxter-perch (target)
  :event target-pilot-handler
  :exit target-pilot-exit
  :trans target-pilot-trans
  :code (behavior ()
    (set! (-> self control unknown-word04) (the-as uint #f))
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! jakb-pilot-wcar-snake-in-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (loop
      (ja-no-eval :group! jakb-pilot-wcar-snake-loop-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (if (-> self control unknown-spool-anim00)
            (goto cfg-11)
            )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (label cfg-11)
    (ja-no-eval :group! jakb-pilot-wcar-snake-out-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go target-pilot-stance)
    )
  :post target-pilot-post
  )

(let ((v1-12 (copy *empty-mods* 'loading-level)))
  (set! (-> v1-12 flags) (surface-flag))
  (set! *pilot-get-on-mods* v1-12)
  )

(defstate target-pilot-get-on (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('end-mode)
       (let ((v1-1 (-> block param 0))
             (a0-1 'pilot)
             )
         (when (= v1-1 a0-1)
           (cond
             ((focus-test? self pilot-riding)
              (go target-pilot-get-off (the-as handle a0-1))
              )
             (else
               (ja-channel-set! 0)
               (go target-falling #f)
               )
             )
           )
         )
       )
      (else
        (target-standard-event-handler proc argc message block)
        )
      )
    )
  :exit target-pilot-exit
  :trans (behavior ()
    (let* ((s5-0 (handle->process (-> self pilot vehicle)))
           (t9-0 type?)
           (a0-3 s5-0)
           (gp-0 (if (t9-0 a0-3 vehicle)
                     s5-0
                     )
                 )
           )
      (cond
        ((not gp-0)
         (ja-channel-set! 0)
         (go target-falling #f)
         )
        ((focus-test? (the-as process-focusable gp-0) dead)
         (go target-pilot-get-off (the-as handle a0-3))
         )
        (else
          (vehicle-method-66 (the-as vehicle gp-0) (-> self control unknown-vector38) (-> self pilot seat-index))
          (set! (-> self control unknown-vector40 quad) (-> (the-as vehicle gp-0) root quat quad))
          )
        )
      )
    )
  :code (behavior ()
    (logior! (-> self focus-status) (focus-status pilot))
    (logior! (-> self target-flags) (target-flags tf6))
    (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
    (sound-play "jump")
    (let ((gp-1 (if (zero? (-> self pilot stance))
                    jakb-pilot-bike-get-on-ja
                    jakb-pilot-car-get-on-ja
                    )
                )
          )
      (ja-channel-set! 1)
      (set! (-> self control mod-surface) *pilot-get-on-mods*)
      (send-event (ppointer->process (-> self manipy)) 'draw #t)
      (set! (-> self neck flex-blend) 0.0)
      (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
      (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
      (ja :group! gp-1 :num! (seek!) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 0.0 10.0))))
        (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 0.0 10.0)))
          (vector-lerp!
            (-> self control trans)
            (-> self control unknown-vector37)
            (-> self control unknown-vector38)
            f30-0
            )
          (set! (-> self control trans y)
                (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                )
          )
        (quaternion-slerp!
          (-> self control quat-for-control)
          (the-as quaternion (-> self control unknown-vector39))
          (the-as quaternion (-> self control unknown-vector40))
          f30-0
          )
        )
      (rot->dir-targ! (-> self control))
      (if (>= (ja-aframe-num 0) 20.5)
          (target-pilot-signal-ready)
          )
      (suspend)
      (let ((a1-8 (handle->process (-> self pilot vehicle))))
        (if a1-8
            (set! (-> self alt-cam-pos quad) (-> (the-as vehicle a1-8) rbody position quad))
            )
        )
      (ja :num! (seek!))
      )
    (go target-pilot-stance)
    )
  :post target-no-move-post
  )

(let ((v1-15 (copy *forward-jump-mods* 'loading-level)))
  (set! (-> v1-15 fric) 0.0)
  (set! (-> v1-15 nonlin-fric-dist) 0.0)
  (set! (-> v1-15 turnv) 0.0)
  (set! (-> v1-15 turnvv) 0.0)
  (set! (-> v1-15 tiltv) 131072.0)
  (set! (-> v1-15 tiltvf) 30.0)
  (set! (-> v1-15 mult-hook)
        (the-as
          (function surface surface surface int none)
          (lambda :behavior target
            ((arg0 surface) (arg1 surface) (arg2 surface) (arg3 int))
            (case arg3
              ((1)
               (persist-with-delay *setting-control* 'rapid-tracking (seconds 0.05) 'rapid-tracking #f 0.0 0)
               )
              )
            )
          )
        )
  (set! *pilot-get-off-mods* v1-15)
  )

(defstate target-pilot-get-off (target)
  :event target-standard-event-handler
  :exit target-pilot-exit
  :trans (behavior ()
    (let ((gp-0 (handle->process (-> self pilot vehicle))))
      (when (not (if (type? gp-0 vehicle)
                     gp-0
                     )
                 )
        (ja-channel-set! 0)
        (go target-falling #f)
        )
      )
    )
  :code (behavior ((arg0 handle))
    (local-vars (f30-0 float))
    (let ((v1-1 (-> self control root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self control backup-collide-with))
      )
    (logclear! (-> self focus-status) (focus-status pilot-riding))
    (set! (-> self control mod-surface) *pilot-get-off-mods*)
    (rot->dir-targ! (-> self control))
    (send-event *camera* 'set-dist #f #f)
    (set! (-> self neck flex-blend) 0.0)
    (persist-with-delay *setting-control* 'mode-name (seconds 0.05) 'mode-name 'cam-decel 0.0 0)
    (persist-with-delay *setting-control* 'interp-time (seconds 0.05) 'interp-time 'hi 0.0 0)
    (persist-with-delay *setting-control* 'interp-time (seconds 0.1) 'interp-time 'lo 300.0 0)
    (persist-with-delay
      *setting-control*
      'immediate-string-min-max
      (seconds 0.05)
      'immediate-string-min-max
      #f
      0.0
      0
      )
    0.0
    (let ((gp-0 (cond
                  ((zero? (-> self pilot stance))
                   (set! f30-0 7.2)
                   jakb-pilot-bike-get-off-ja
                   )
                  (else
                    (set! f30-0 15.2)
                    jakb-pilot-car-get-off-ja
                    )
                  )
                )
          )
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! gp-0 :num! (seek! (ja-aframe f30-0 0) 2.0) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe f30-0 0) 2.0))
      )
    (let ((v1-37 (camera-matrix))
          (gp-2 (new 'stack-no-clear 'matrix))
          )
      (set! (-> gp-2 rvec quad) (-> v1-37 rvec quad))
      (set! (-> gp-2 uvec quad) (-> v1-37 fvec quad))
      (set! (-> gp-2 uvec y) 0.0)
      (vector-normalize! (-> gp-2 uvec) 1.0)
      (vector-reset! (-> gp-2 fvec))
      (vector+float*!
        (-> gp-2 fvec)
        (-> gp-2 fvec)
        (-> gp-2 rvec)
        (* 16384.0 (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0))
        )
      (vector+float*!
        (-> gp-2 fvec)
        (-> gp-2 fvec)
        (-> gp-2 uvec)
        (* 16384.0 (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 48.0 110.0 -1.0))
        )
      (vector+! (-> self control transv) (-> self control transv) (-> gp-2 fvec))
      )
    (let* ((f0-12 (vector-normalize-ret-len! (-> self control transv) 1.0))
           (f0-13 (fmin 122880.0 f0-12))
           )
      (vector-float*! (-> self control transv) (-> self control transv) f0-13)
      )
    (go target-jump 10240.0 10240.0 *pilot-get-off-mods*)
    )
  :post target-pilot-post
  )

(defstate target-pilot-grab (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (cond
      ((and (= message 'query) (= (-> block param 0) 'mode))
       (-> self state name)
       )
      (else
        (case message
          (('end-mode)
           (case (-> block param 0)
             (('grab)
              (go target-pilot-stance)
              )
             (('gun)
              (target-gun-end-mode #t)
              )
             )
           )
          (('clone-anim)
           (go target-pilot-clone-anim (process->handle (the-as process (-> block param 0))))
           )
          (('vehicle-crash)
           (go target-grab 'stance)
           )
          (else
            (target-generic-event-handler proc argc message block)
            )
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self target-flags) (target-flags tf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    )
  :exit (behavior ()
    (logclear! (-> self target-flags) (target-flags tf2))
    (logclear! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self water flags) (water-flag jump-out))
    ((-> target-pilot-start exit))
    )
  :code (behavior ()
    (until #f
      (set-forward-vel 0.0)
      (suspend)
      )
    #f
    )
  :post target-pilot-post
  )

(defstate target-pilot-clone-anim (target)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (= message 'trans) (= (-> block param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-pilot-grab event) proc argc message block)
    )
  :enter (-> target-clone-anim enter)
  :exit (behavior ()
    (set! (-> self control draw-offset y) (the-as float (-> self control unknown-word04)))
    (set! (-> self control cspace-offset y) (-> self control draw-offset y))
    (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
    ((-> target-clone-anim exit))
    ((-> target-pilot-start exit))
    (vector-reset! (-> self control transv))
    )
  :code (behavior ((arg0 handle))
    (set! (-> self control unknown-word04) (the-as uint (-> self control draw-offset y)))
    (set! (-> self control draw-offset y) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
    (clone-anim arg0 #t "")
    (go target-pilot-stance)
    )
  :post (behavior ()
    (vector+! (-> self pilot pilot-trans) (-> self control trans) (-> self control cspace-offset))
    (quaternion-copy! (the-as quaternion (-> self pilot pilot-quat)) (-> self control quat))
    (set! (-> self pilot pilot-scale quad) (-> self control scale quad))
    (target-no-ja-move-post)
    )
  )

(defstate target-pilot-edge-grab (target)
  :event (-> target-edge-grab event)
  :enter (behavior ((arg0 pilot-edge-grab-info))
    (set! (-> self control status) (collide-status))
    (let ((gp-0 *edge-grab-info*))
      (mem-copy! (the-as pointer (-> gp-0 pilot-edge-grab)) (the-as pointer arg0) 40)
      (set! (-> gp-0 pilot-grab-interp) 0.0)
      (set! (-> gp-0 pilot-start-grab-pos quad) (-> self control trans quad))
      (set! (-> gp-0 actor-handle) (-> arg0 handle))
      ((-> target-edge-grab enter))
      (let* ((s5-1 (handle->process (-> gp-0 actor-handle)))
             (a0-9 (if (type? s5-1 process-focusable)
                       s5-1
                       )
                   )
             )
        (set! (-> gp-0 pilot-edge-grab?)
              (if (and a0-9
                       (< 24576.0 (fabs (- (-> (get-trans (the-as process-focusable a0-9) 0) y) (-> self control trans y))))
                       )
                  'target-double-jump
                  'target-jump
                  )
              )
        )
      )
    )
  :exit (-> target-edge-grab exit)
  :trans (-> target-edge-grab trans)
  :code (-> target-edge-grab code)
  :post target-no-move-post
  )

(defstate target-pilot-hit (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (if (not (and (-> self next-state) (= (-> self next-state name) 'target-death)))
        (logclear! (-> self focus-status) (focus-status dead hit))
        )
    ((-> target-pilot-start exit))
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (local-vars (sv-16 attack-info))
    (set-time! (-> self state-time))
    (set! (-> self neck flex-blend) 0.0)
    (set! sv-16 (-> self attack-info))
    (let ((v1-4 sv-16))
      (set! (-> v1-4 attacker) (the-as handle #f))
      (set! (-> v1-4 mode) 'generic)
      (set! (-> v1-4 shove-back) 6144.0)
      (set! (-> v1-4 shove-up) 4915.2)
      (set! (-> v1-4 angle) #f)
      (set! (-> v1-4 trans quad) (-> self control trans quad))
      (set! (-> v1-4 control) 0.0)
      (set! (-> v1-4 invinc-time) (-> *TARGET-bank* hit-invulnerable-timeout))
      (set! (-> v1-4 damage) (-> *FACT-bank* health-default-inc))
      )
    (combine! sv-16 arg1 self)
    (pickup-collectable! (-> self fact) (pickup-type health) -1000.0 (the-as handle #f))
    (go target-pilot-death (-> sv-16 mode))
    )
  :post target-no-stick-post
  )

(defstate target-pilot-death (target)
  :event (-> target-death event)
  :exit (behavior ()
    ((-> target-pilot-start exit))
    ((-> target-death exit))
    )
  :code (behavior ((arg0 symbol))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self 0)
    (let ((s5-0 (-> self child)))
      (while s5-0
        (send-event (ppointer->process s5-0) 'notice 'die)
        (set! s5-0 (-> s5-0 0 brother))
        )
      )
    (set! (-> self death-resetter continue) #f)
    (set! (-> self death-resetter node) (game-task-node none))
    (set! (-> self death-resetter reset-mode) 'life)
    (set! (-> self death-resetter execute) #f)
    (case arg0
      (('bot)
       (set-setting! 'process-mask 'set 0.0 (process-mask platform projectile death))
       )
      (('endlessfall 'instant-death 'lava 'dark-eco-pool 'melt 'explode 'grenade 'drown-death)
       (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
       )
      (else
        (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
        (when (using-gun? self)
          (send-event (ppointer->process (-> self gun gun)) 'notice 'die)
          (target-gun-end-mode #f)
          )
        )
      )
    (set-setting! 'mode-name 'cam-fixed 0.0 0)
    (set-setting! 'interp-time 'abs 0.0 0)
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (case arg0
      (('melt 'grenade 'explode)
       (let ((s5-1 (current-time)))
         (until (time-elapsed? s5-1 (seconds 0.2))
           (suspend)
           )
         )
       (case arg0
         (('dark-eco-pool)
          (sound-play "death-darkeco")
          (cond
            ((logtest? (-> *part-group-id-table* 62 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
             (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 62))
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
              (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 62))
              )
            )
          )
         (('grenade 'explode)
          (sound-play "explosion")
          (cond
            ((logtest? (-> *part-group-id-table* 65 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
             (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 65))
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
              (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 65))
              )
            )
          )
         (('lava 'melt)
          (sound-play "death-melt")
          (cond
            ((logtest? (-> *part-group-id-table* 64 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
             (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 64))
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> self control trans quad))
              (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 64))
              )
            )
          )
         )
       (let ((v1-158 (-> self control root-prim)))
         (set! (-> v1-158 prim-core collide-as) (collide-spec))
         (set! (-> v1-158 prim-core collide-with) (collide-spec))
         )
       0
       (ja-channel-set! 0)
       (let ((s5-11 (current-time)))
         (until (time-elapsed? s5-11 (seconds 1.8))
           (suspend)
           )
         )
       )
      (('endlessfall)
       (sound-play "death-fall")
       (if (not (-> self pilot as-daxter?))
           (set! (-> self control unknown-sound-id00)
                 (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "jakfall" -99.0 0)
                 )
           )
       (sound-params-set! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2 -1.0)
       (logclear! (-> self water flags) (water-flag swim-ground))
       (let ((f0-5 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (set! (-> self control unknown-word04) (the-as uint f0-5))
         (let ((v1-179 (new-stack-vector0)))
           (let ((f1-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-179 (-> self control transv) (vector-float*! v1-179 (-> self control dynam gravity-normal) f1-3))
             )
           (let* ((f1-4 (vector-length v1-179))
                  (f2-1 f1-4)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-5)
               (vector-float*! v1-179 v1-179 (/ f1-4 f2-1))
               )
             )
           )
         )
       (let ((s5-13 (current-time)))
         (until (time-elapsed? s5-13 (seconds 0.5))
           (suspend)
           )
         )
       )
      (('drown-death)
       (logclear! (-> self water flags) (water-flag swim-ground))
       (let ((f0-8 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (set! (-> self control unknown-word04) (the-as uint f0-8))
         (let ((v1-190 (new-stack-vector0)))
           (let ((f1-8 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-190 (-> self control transv) (vector-float*! v1-190 (-> self control dynam gravity-normal) f1-8))
             )
           (let* ((f1-9 (vector-length v1-190))
                  (f2-3 f1-9)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-8)
               (vector-float*! v1-190 v1-190 (/ f1-9 f2-3))
               )
             )
           )
         )
       (let ((s5-14 (current-time)))
         (until (time-elapsed? s5-14 (seconds 2))
           (suspend)
           )
         )
       )
      (('bot)
       (set! (-> self trans-hook) #f)
       (while (not (-> self control unknown-spool-anim00))
         (set-forward-vel 0.0)
         (suspend)
         )
       )
      (('big-explosion)
       (let ((s5-15 (current-time)))
         (until (time-elapsed? s5-15 (seconds 2))
           (suspend)
           )
         )
       )
      (else
        )
      )
    (target-death-reset arg0 #f)
    )
  :post target-pilot-post
  )
