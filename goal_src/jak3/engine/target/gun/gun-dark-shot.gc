;;-*-Lisp-*-
(in-package goal)

;; name: gun-dark-shot.gc
;; name in dgo: gun-dark-shot
;; dgos: GAME

(define-extern sparticle-lightning-2d-spline-align-plus-rotz (function object sparticle-cpuinfo sprite-vec-data-2d object none))
(define-extern missile-bot type)
(define-extern market-object type)
(define-extern fruit-stand type)

;; DECOMP BEGINS

(set! (-> *lightning-spec-id-table* 15) (new 'static 'lightning-spec
                                          :name "lightning-dark-shot-attack"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 1.0
                                          :fade-time 30.0
                                          :texture (new 'static 'texture-id :index #x8f :page #x4)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 8192.0
                                          :merge-factor 0.6
                                          :merge-count 2
                                          :radius 3276.8
                                          :duration 45.0
                                          :duration-rand 60.0
                                          :sound (static-sound-spec "stretched-zap" :group 0)
                                          )
      )

(set! (-> *lightning-spec-id-table* 16) (new 'static 'lightning-spec
                                          :name "lightning-dark-shot-attack-thick"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 1.0
                                          :fade-time 30.0
                                          :texture (new 'static 'texture-id :index #x3f :page #x4)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 8192.0
                                          :merge-factor 0.6
                                          :merge-count 2
                                          :radius 3276.8
                                          :duration 60.0
                                          :sound (static-sound-spec "stretched-zap" :group 0)
                                          )
      )

(defpartgroup group-lightning-dark-shot-tip-hit
  :id 183
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 10)
  :parts ((sp-item 664))
  )

(defpart 664
  :init-specs ((:texture (lightning-anim-01 level-default-sprite))
    (:birth-func 'birth-func-texture-group)
    (:num 2.0 3.0)
    (:scale-x (meters 0.1) (meters 0.1))
    (:rot-z (degrees 90))
    (:scale-y :copy scale-x)
    (:r 0.0 64.0)
    (:g 64.0 64.0)
    (:b 255.0)
    (:a 255.0)
    (:vel-z (meters 0.016666668) (meters 0.006666667))
    (:scalevel-x (meters 0.006666667) (meters 0.006666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -1.7)
    (:friction 0.99)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata :data (new 'static 'boxed-array :type int32 20 1 0 #x405700 #x405800 #x405900))
    (:func 'sparticle-lightning-2d-spline-align-plus-rotz)
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 665
  :init-specs ((:texture (glow-hotdot level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 1) (meters 4))
    (:rot-x (degrees 11.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0 64.0)
    (:g 64.0 64.0)
    (:b 255.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    (:conerot-x (degrees 0) (degrees 3600))
    (:conerot-y (degrees 0) (degrees 3600))
    (:conerot-z (degrees 0) (degrees 3600))
    (:conerot-radius (meters -0.1) (meters 0.5))
    )
  )

;; WARN: Return type mismatch float vs none.
(defun sparticle-lightning-2d-spline-align-plus-rotz ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-2d) (arg3 object))
  (sparticle-2d-spline-align-instant arg0 arg1 arg2)
  (+! (-> arg2 flag-rot-sy z) (-> *part-id-table* 664 init-specs 4 initial-valuef))
  (none)
  )

(deftype gun-dark-shot (projectile)
  ((blast-radius   float)
   (core-position  vector  :inline)
   (core-velocity  vector  :inline)
   (spin-vector    vector  :inline)
   (track-target   handle)
   (size-t         float)
   (result-array   handle  16)
   (result-count   int8)
   (charge-sound   sound-id)
   (fire-sound     sound-id)
   (trail-sound    sound-id)
   (explode-sound  sound-id)
   (start-pilot?   symbol)
   (spread-timer   time-frame)
   )
  (:state-methods
    startup
    fizzle
    )
  )


(defbehavior gun-fire-dark-1 target ()
  (set-last-fire-time 35)
  (let ((s5-0 (-> self gun))
        (gp-0 (new 'stack-no-clear 'projectile-init-by-other-params))
        )
    (set! (-> gp-0 ent) (-> self entity))
    (set! (-> gp-0 charge) (-> s5-0 fire-charge))
    (set! (-> gp-0 options) (projectile-options))
    (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
    (set! (-> gp-0 pos quad) (-> s5-0 fire-point quad))
    (set! (-> gp-0 vel quad) (-> s5-0 fire-dir-out quad))
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 target-handle) (the-as handle #f))
    (set! (-> gp-0 target-pos quad) (the-as uint128 0))
    (set! (-> gp-0 ignore-handle) (process->handle (send-event self 'get-vehicle)))
    (let* ((v1-11 *game-info*)
           (a0-13 (+ (-> v1-11 attack-id) 1))
           )
      (set! (-> v1-11 attack-id) a0-13)
      (set! (-> gp-0 attack-id) a0-13)
      )
    (set! (-> gp-0 timeout) (seconds 4))
    (let ((v0-2 (spawn-projectile gun-dark-shot gp-0 (ppointer->process (-> s5-0 gun)) *default-dead-pool*)))
      (if v0-2
          (set! (-> self gun charge-active?) (ppointer->handle v0-2))
          )
      v0-2
      )
    )
  )

(defskelgroup skel-gun-dark-3-sphere gun gun-nuke-sphere-lod0-jg gun-nuke-sphere-idle-ja
              ((gun-nuke-sphere-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              :texture-level 10
              :sort 4
              )

(deftype gun-dark-3-sphere (process-drawable)
  ((alpha-val  float)
   )
  (:state-methods
    active
    )
  )


(deftype gun-dark-3-sphere-init-params (structure)
  ((pos        vector  :inline)
   (size-x     float)
   (size-y     float)
   (alpha-val  float)
   )
  )


(defbehavior gun-dark-3-sphere-init-by-other gun-dark-3-sphere ((arg0 gun-dark-3-sphere-init-params))
  (set! (-> self root) (new 'process 'trsqv))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-dark-3-sphere" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (quaternion-identity! (-> self root quat))
  (set-vector!
    (-> self root scale)
    (* 0.00024414062 (-> arg0 size-x))
    (* 0.00024414062 (-> arg0 size-y))
    1.0
    1.0
    )
  (go-virtual active)
  )

(defstate active (gun-dark-3-sphere)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('set-pos-and-size)
       (let ((v1-2 (the-as gun-dark-3-sphere-init-params (-> block param 0))))
         (set! (-> self root trans quad) (-> v1-2 pos quad))
         (set-vector!
           (-> self root scale)
           (* 0.00024414062 (-> v1-2 size-x))
           (* 0.00024414062 (-> v1-2 size-y))
           1.0
           1.0
           )
         (vector-float*! (-> self root scale) (-> self root scale) 1.7)
         (set! (-> self alpha-val) (-> v1-2 alpha-val))
         )
       )
      )
    #t
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (ja-channel-push! 1 0)
    (ja :group! gun-nuke-sphere-fade-ja :num! zero)
    (set! (-> self alpha-val) 1.0)
    )
  :trans (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (math-camera-pos))))
        (set! (-> s5-1 y) 0.0)
        (vector-normalize! s5-1 1.0)
        (vector-float*! s5-1 s5-1 -1.0)
        (matrix-fu-compose gp-0 s5-1 *up-vector*)
        )
      (matrix->quat gp-0 (-> self root quat))
      )
    (ja :group! gun-nuke-sphere-fade-ja :num! (identity (- 1.0 (-> self alpha-val))))
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    )
  )

(defskelgroup skel-gun-dark-3-nuke gun gun-nuke-lod0-jg gun-nuke-idle-ja
              ((gun-nuke-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              :texture-level 10
              )

(deftype last-active-nuke-info (structure)
  ((last-active-nuke  handle)
   )
  )


(define *last-active-nuke* (new 'static 'last-active-nuke-info))

(set! (-> *last-active-nuke* last-active-nuke) (the-as handle #f))

(deftype gun-dark-3-nuke (projectile)
  ((flash-time                  time-frame)
   (blur-time                   time-frame)
   (spawned-mushroom-cloud?     symbol)
   (strip                       prim-strip)
   (mushroom-top-pos            vector  :inline)
   (warp                        handle)
   (initial-velocity            vector  :inline)
   (start-y                     float)
   (y-vel-adjust                float)
   (launch-speed                float)
   (launch-sin-region-start     float)
   (launch-sin-region-end       float)
   (launch-stay-state-time      time-frame)
   (launch-next-state           (state gun-dark-3-nuke))
   (launch-impact-state         (state gun-dark-3-nuke))
   (launch-y-scale              float)
   (launch-height-t             float)
   (expected-height             float)
   (total-fly-time              time-frame)
   (num-dying-vehicles          uint8)
   (num-dying-guards            uint8)
   (num-dying-civilians         uint8)
   (last-death-sound-play-time  time-frame)
   (blur-curve                  curve2d-piecewise)
   (fade-curve                  curve-color-piecewise)
   (num-blur-segments           uint8)
   (shook-camera?               symbol)
   (hit-wall?                   symbol)
   (killed-everything?          symbol  :offset 696)
   (explode-sound               sound-id)
   (explode-wall-sound          sound-id)
   (played-trail?               symbol)
   (smoke-trail                 sparticle-subsampler)
   (killed-objects              handle  64)
   (num-killed-objects          int32)
   (last-kill-time              time-frame)
   )
  (:state-methods
    undefined
    launching-base-state
    launch-0
    launch-1
    launch-2
    launch-3
    impact-small
    impact-dud
    impact-embedded
    wait-for-alive
    )
  (:methods
    (set-launch-height! (_type_) none)
    (do-blur-effect (_type_) none)
    (do-white-screen-effect (_type_) none)
    (count-casualties (_type_) none)
    (send-attack! (_type_ process-focusable) none)
    (play-death-sounds (_type_) none)
    (do-camera-shake (_type_) none)
    (do-vibration (_type_) none)
    (check-for-impact (_type_) none)
    )
  )


;; WARN: Return type mismatch matrix vs none.
(defmethod projectile-method-25 ((this gun-dark-3-nuke))
  (when (not (logtest? (-> this draw status) (draw-control-status no-draw)))
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (matrix-f-u-compose s5-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) *up-vector*)
      (set! (-> s5-0 trans quad) (-> this root trans quad))
      (spawn-from-mat (-> this part) s5-0)
      (init-with-mat! (-> this smoke-trail) s5-0)
      )
    )
  (none)
  )

(defun gun-dark-reaction ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (set! (-> arg2 quad) (-> arg3 quad))
  (cond
    ((logtest? (-> arg0 status) (collide-status touch-wall))
     (send-event (-> arg0 process) 'impact-small)
     )
    ((let ((f0-1 (vector-dot (vector-normalize-copy! (new 'stack-no-clear 'vector) arg3 1.0) (-> arg0 surface-normal))))
       (< -0.3 f0-1)
       )
     (let ((v1-9 (new 'stack-no-clear 'vector)))
       (set! (-> v1-9 quad) (-> arg0 trans quad))
       (+ 1228.8 (-> v1-9 y))
       )
     (vector-flatten! arg2 arg3 (-> arg0 surface-normal))
     (send-event (-> arg0 process) 'slide-now (-> arg0 surface-normal))
     )
    (else
      (send-event (-> arg0 process) 'impact)
      )
    )
  (-> arg0 status)
  )

(defmethod setup-collision! ((this gun-dark-3-nuke))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) gun-dark-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 40.96)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set-collide-with! (-> this root) (collide-spec backgnd obstacle pusher impenetrable-obj))
  (set-collide-as! (-> this root) (collide-spec projectile))
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  (none)
  )

(defmethod init-proj-settings! ((this gun-dark-3-nuke))
  (with-pp
    (set! (-> *last-active-nuke* last-active-nuke) (process->handle this))
    (set! (-> this attack-mode) 'eco-dark)
    (initialize-skeleton
      this
      (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-dark-3-nuke" (the-as (pointer level) #f)))
      (the-as pair 0)
      )
    (set! (-> this spawned-mushroom-cloud?) #f)
    (set! (-> this strip)
          (new 'process 'prim-strip 4 (new 'static 'texture-id :index #x1f :page #x5) (the-as string #f))
          )
    (set! (-> this played-trail?) #f)
    (set! (-> this part) (create-launch-control (-> *part-group-id-table* 112) this))
    pp
    (set! (-> this smoke-trail)
          (new 'process 'sparticle-subsampler *sp-particle-system-2d* (-> *part-id-table* 388) 8.0)
          )
    (set-setting! 'allow-progress #f 0.0 0)
    (set! (-> this explode-sound)
          (add-process *gui-control* this (gui-channel gun) (gui-action queue) "pg3nxplo" -99.0 0)
          )
    (set! (-> this explode-wall-sound)
          (add-process *gui-control* this (gui-channel gun) (gui-action queue) "pg3wxplo" -99.0 0)
          )
    (let* ((v1-19 *game-info*)
           (a0-15 (+ (-> v1-19 attack-id) 1))
           )
      (set! (-> v1-19 attack-id) a0-15)
      (set! (-> this attack-id) a0-15)
      )
    (set! (-> this initial-velocity quad) (-> this root transv quad))
    (set! (-> this start-y) (-> this root trans y))
    (set! (-> this launch-impact-state) (method-of-object this impact-dud))
    (set! (-> this y-vel-adjust) 0.0)
    (set! (-> this warp) (the-as handle #f))
    (set! (-> this shook-camera?) #f)
    (set-vector! (-> this root scale) 2.5 2.5 2.5 1.0)
    (set! (-> this killed-everything?) #f)
    (let ((t9-8 (method-of-type projectile init-proj-settings!)))
      (t9-8 this)
      )
    (logior! (-> this options) (projectile-options po4))
    (set! (-> this total-fly-time) 0)
    0
    (none)
    )
  )

(defmethod relocate ((this gun-dark-3-nuke) (offset int))
  (if (nonzero? (-> this strip))
      (&+! (-> this strip) offset)
      )
  (if (nonzero? (-> this smoke-trail))
      (&+! (-> this smoke-trail) offset)
      )
  (call-parent-method this offset)
  )

;; WARN: Return type mismatch symbol vs object.
(defbehavior nuke-move gun-dark-3-nuke ()
  (let ((gp-0 (-> self root)))
    (set! (-> self pre-move-transv quad) (-> gp-0 transv quad))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> gp-0 trans quad))
      ((-> self move) self)
      (projectile-method-39 self)
      (set! (-> self old-dist (-> self old-dist-count)) (* 0.0625 (vector-vector-distance s5-0 (-> gp-0 trans))))
      )
    )
  (set! (-> self old-dist-count) (logand (+ (-> self old-dist-count) 1) 15))
  (let ((f0-2 0.0))
    (countdown (v1-12 16)
      (+! f0-2 (-> self old-dist v1-12))
      )
    )
  #f
  )

;; WARN: Return type mismatch float vs none.
(defmethod set-launch-height! ((this gun-dark-3-nuke))
  (set! (-> this launch-height-t)
        (/ (the float (- (current-time) (-> this state-time))) (the float (-> this launch-stay-state-time)))
        )
  (set! (-> this launch-height-t) (fmax 0.0 (fmin 1.0 (-> this launch-height-t))))
  (none)
  )

(defmethod proj-event-handler ((this gun-dark-3-nuke) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact)
     (go (-> this launch-impact-state))
     )
    (('impact-small)
     (go (method-of-object this impact-embedded))
     )
    (('slide-now)
     (let ((a2-1 (-> arg3 param 0))
           (s5-1 (new 'stack-no-clear 'vector))
           )
       (vector-flatten! s5-1 (-> this initial-velocity) (the-as vector a2-1))
       (set! (-> this y-vel-adjust) (-> s5-1 y))
       )
     (set! (-> this start-y) (+ (-> this start-y) (* (-> this y-vel-adjust) (seconds-per-frame))))
     )
    (else
      (call-parent-method this arg0 arg1 arg2 arg3)
      )
    )
  )

(defstate launching-base-state (gun-dark-3-nuke)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (proj-event-handler self proc argc message block)
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self root transv y) 0.0)
    )
  :trans (behavior ()
    (if *scene-player*
        (go empty-state)
        )
    (when (and (not (-> self played-trail?)) (>= (+ (current-time) (seconds -0.3)) (-> self total-fly-time)))
      (sound-play "purple-3-trail" :position (-> self root trans))
      (set! (-> self played-trail?) #t)
      )
    (when (time-elapsed? (-> self state-time) (-> self launch-stay-state-time))
      (set! (-> self start-y) (-> self root trans y))
      (go (-> self launch-next-state))
      )
    (+! (-> self start-y) (* (-> self y-vel-adjust) (seconds-per-frame)))
    (let ((f0-3 (-> self launch-height-t)))
      0.0
      0.0
      (let ((f0-4 (lerp (-> self launch-sin-region-start) (-> self launch-sin-region-end) f0-3)))
        0.0
        (let ((f30-1 (+ (- (* (sin (* 182.04445 f0-4)) (-> self launch-y-scale))
                           (* (sin (* 182.04445 (-> self launch-sin-region-start))) (-> self launch-y-scale))
                           )
                        (-> self start-y)
                        )
                     )
              )
          (set! (-> self expected-height) f30-1)
          (vector-normalize-copy! (-> self root transv) (-> self initial-velocity) (-> self launch-speed))
          (set! (-> self root transv y) (- f30-1 (-> self root trans y)))
          )
        )
      )
    (set! (-> self root transv y) (/ (-> self root transv y) (seconds-per-frame)))
    (let ((t9-8 nuke-move))
      (-> self launch-impact-state)
      (t9-8)
      )
    (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
    (let ((gp-1 (new 'stack-no-clear 'matrix)))
      (let ((a1-5 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self root transv) 1.0)))
        (matrix-f-compose gp-1 a1-5)
        )
      (matrix->quaternion (-> self root quat) gp-1)
      )
    (+! (-> self total-fly-time) (- (current-time) (-> self clock old-frame-counter)))
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    (projectile-method-25 self)
    )
  )

(defstate launch-0 (gun-dark-3-nuke)
  :virtual #t
  :parent (gun-dark-3-nuke launching-base-state)
  :enter (behavior ()
    (set! (-> self launch-impact-state) (method-of-object self impact-embedded))
    (set! (-> self launch-y-scale) 0.0)
    (set! (-> self launch-stay-state-time) (seconds 0.2))
    (set! (-> self launch-next-state) (method-of-object self launch-1))
    (let ((v1-6 (-> self state parent)))
      (when v1-6
        (let ((t9-0 (-> v1-6 enter)))
          (if t9-0
              ((the-as (function none) t9-0))
              )
          )
        )
      )
    )
  :trans (behavior ()
    (set-launch-height! self)
    (set! (-> self launch-speed) 32768.0)
    (let ((v1-4 (-> self state parent)))
      (when v1-4
        (let ((t9-1 (-> v1-4 trans)))
          (if t9-1
              (t9-1)
              )
          )
        )
      )
    )
  )

(defstate launch-1 (gun-dark-3-nuke)
  :virtual #t
  :parent (gun-dark-3-nuke launching-base-state)
  :enter (behavior ()
    (set! (-> self launch-y-scale) 0.0)
    (set! (-> self launch-stay-state-time) (seconds 0.4))
    (set! (-> self launch-next-state) (method-of-object self launch-2))
    (let ((v1-4 (-> self state parent)))
      (when v1-4
        (let ((t9-0 (-> v1-4 enter)))
          (if t9-0
              ((the-as (function none) t9-0))
              )
          )
        )
      )
    )
  :trans (behavior ()
    (set-launch-height! self)
    (let ((f0-1 (* 0.008333334 (the float (- (current-time) (-> self state-time))))))
      (set! (-> self launch-speed) (lerp 61440.0 204800.0 f0-1))
      )
    (let ((v1-8 (-> self state parent)))
      (when v1-8
        (let ((t9-2 (-> v1-8 trans)))
          (if t9-2
              (t9-2)
              )
          )
        )
      )
    )
  )

(defstate launch-2 (gun-dark-3-nuke)
  :virtual #t
  :parent (gun-dark-3-nuke launching-base-state)
  :enter (behavior ()
    (set! (-> self launch-sin-region-start) 0.0)
    (set! (-> self launch-sin-region-end) 270.0)
    (set! (-> self launch-stay-state-time) (seconds 0.5))
    (set! (-> self launch-next-state) (method-of-object self launch-3))
    (set! (-> self launch-y-scale) 34816.0)
    (let ((v1-6 (-> self state parent)))
      (when v1-6
        (let ((t9-0 (-> v1-6 enter)))
          (if t9-0
              ((the-as (function none) t9-0))
              )
          )
        )
      )
    )
  :trans (behavior ()
    (let ((f30-0 (* 0.006666667 (the float (- (current-time) (-> self state-time))))))
      (if (< 0.7 f30-0)
          (set! (-> self launch-impact-state) (method-of-object self impact))
          )
      (set! (-> self launch-speed) (lerp 204800.0 552960.0 f30-0))
      (set! (-> self launch-height-t) (* f30-0 f30-0))
      )
    (let ((v1-10 (-> self state parent)))
      (when v1-10
        (let ((t9-1 (-> v1-10 trans)))
          (if t9-1
              (t9-1)
              )
          )
        )
      )
    )
  )

(defstate launch-3 (gun-dark-3-nuke)
  :virtual #t
  :parent (gun-dark-3-nuke launching-base-state)
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (let ((t9-0 nuke-move))
      (-> self launch-impact-state)
      (t9-0)
      )
    (if (time-elapsed? (-> self state-time) (seconds 4))
        (go-virtual die)
        )
    )
  )

(defmethod send-attack! ((this gun-dark-3-nuke) (arg0 process-focusable))
  (let* ((s3-0 (get-trans arg0 3))
         (v1-2 (get-trans arg0 1))
         (s5-1 (vector-! (new 'stack-no-clear 'vector) s3-0 (-> this root trans)))
         )
    (+! (-> v1-2 y) 409.6)
    (let ((v1-5 (cond
                  ((logtest? (-> *part-group-id-table* 115 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> v1-2 quad))
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 115))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> v1-2 quad))
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 115))
                    )
                  )
                )
          )
      (send-event (ppointer->process v1-5) 'clock this)
      )
    (send-event
      arg0
      'attack
      #f
      (static-attack-info :mask (vehicle-impulse-factor) ((id (-> this attack-id))
                                                          (damage 32.0)
                                                          (vehicle-damage-factor 1.0)
                                                          (vehicle-impulse-factor 1.0)
                                                          (mode 'eco-dark)
                                                          (attacker-velocity s5-1)
                                                          (penetrate-using (penetrate explode jak-dark-nuke))
                                                          )
                          )
      )
    )
  0
  (none)
  )

(defmethod count-casualties ((this gun-dark-3-nuke))
  (local-vars (sv-1568 vector))
  (set! (-> this num-dying-vehicles) (the-as uint 0))
  (set! (-> this num-dying-guards) (the-as uint 0))
  (set! (-> this num-dying-civilians) (the-as uint 0))
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s5-0 64)
        )
    (set! (-> s4-0 quad) (-> this root trans quad))
    (set! (-> s4-0 w) 1228800.0)
    (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 384)))
      (countdown (s2-0 (fill-actor-list-for-box *actor-hash* s4-0 s3-0 384))
        (let* ((s1-0 (-> s3-0 s2-0))
               (v1-5 (if (type? s1-0 collide-shape)
                         s1-0
                         )
                     )
               )
          (when v1-5
            (let* ((s0-0 (-> v1-5 process))
                   (s1-1 (if (type? s0-0 process-focusable)
                             s0-0
                             )
                         )
                   )
              (when s1-1
                (when (and (!= *target* s1-1)
                           (not (focus-test? (the-as process-focusable s1-1) disable dead inactive))
                           (or (logtest? (process-mask enemy guard vehicle civilian) (-> s1-1 mask))
                               (and (logtest? (process-mask crate) (-> s1-1 mask)) (let ((s0-1 vector-vector-xz-distance))
                                                                                     (set! sv-1568 (-> s1-1 root trans))
                                                                                     (let ((a1-3 (camera-pos)))
                                                                                       (< (s0-1 sv-1568 a1-3) 204800.0)
                                                                                       )
                                                                                     )
                                    )
                               )
                           )
                  (when (> s5-0 0)
                    (+! s5-0 -1)
                    (send-attack! this (the-as process-focusable s1-1))
                    (cond
                      ((logtest? (process-mask civilian) (-> s1-1 mask))
                       (+! (-> this num-dying-civilians) 1)
                       )
                      ((logtest? (process-mask guard) (-> s1-1 mask))
                       (+! (-> this num-dying-guards) 1)
                       )
                      ((logtest? (process-mask vehicle) (-> s1-1 mask))
                       (+! (-> this num-dying-vehicles) 1)
                       )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (let* ((s2-1 *target*)
           (s3-1 (if (type? s2-1 process-focusable)
                     s2-1
                     )
                 )
           )
      (when (and s3-1 (< (vector-vector-distance (get-trans s3-1 0) s4-0) (-> s4-0 w)))
        (when (and (!= *target* s3-1)
                   (not (focus-test? s3-1 disable dead inactive))
                   (or (logtest? (process-mask enemy guard vehicle civilian) (-> s3-1 mask))
                       (and (logtest? (process-mask crate) (-> s3-1 mask))
                            (< (vector-vector-xz-distance (-> s3-1 control trans) (camera-pos)) 204800.0)
                            )
                       )
                   )
          (when (> s5-0 0)
            (+ s5-0 -1)
            (send-attack! this s3-1)
            (cond
              ((logtest? (process-mask civilian) (-> s3-1 mask))
               (+! (-> this num-dying-civilians) 1)
               )
              ((logtest? (process-mask guard) (-> s3-1 mask))
               (+! (-> this num-dying-guards) 1)
               )
              ((logtest? (process-mask vehicle) (-> s3-1 mask))
               (+! (-> this num-dying-vehicles) 1)
               )
              )
            )
          )
        )
      )
    )
  (set! (-> this num-dying-vehicles) (the-as uint (min 4 (the-as int (-> this num-dying-vehicles)))))
  (set! (-> this num-dying-guards) (the-as uint (min 6 (the-as int (-> this num-dying-vehicles)))))
  (set! (-> this num-dying-civilians) (the-as uint (min 6 (the-as int (-> this num-dying-vehicles)))))
  0
  (none)
  )

(defmethod do-blur-effect ((this gun-dark-3-nuke))
  (when (= (process->handle this) (-> *last-active-nuke* last-active-nuke))
    0.0
    (let* ((f0-3 (/ (the float (- (current-time) (-> this state-time))) (the float (-> this blur-time))))
           (f0-4 (curve2d-method-9 (-> this blur-curve) f0-3 3))
           (f0-5 (- 1.0 f0-4))
           )
      (blit-displays-work-method-17
        *blit-displays-work*
        (-> this root trans)
        (the-as int (-> this num-blur-segments))
        (fmin 1.0 f0-5)
        #f
        )
      )
    (set! (-> *display* force-sync) (the-as uint 2))
    )
  (none)
  )

(defmethod do-white-screen-effect ((this gun-dark-3-nuke))
  (when (= (process->handle this) (-> *last-active-nuke* last-active-nuke))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      0.0
      0.0
      (let ((f0-4 (/ (the float (- (current-time) (-> this state-time))) (the float (-> this flash-time)))))
        (curve-color-method-9 (-> this fade-curve) f0-4 (the-as rgbaf gp-0) 3)
        )
      (set! (-> gp-0 x) (* 255.0 (-> gp-0 x)))
      (set! (-> gp-0 y) (* 255.0 (-> gp-0 y)))
      (set! (-> gp-0 z) (* 255.0 (-> gp-0 z)))
      (set! (-> gp-0 w) (* 128.0 (-> gp-0 w)))
      (setup *screen-filter* gp-0 gp-0 0.0 (bucket-id tex-hud-pris2) #x3fffff #x33001 #t)
      )
    )
  (none)
  )

(defstate impact-dud (gun-dark-3-nuke)
  :virtual #t
  :code (behavior ()
    (if *scene-player*
        (go empty-state)
        )
    (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-0 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-0 spawn-quat))
      (set! (-> gp-0 radius) 0.0)
      (set! (-> gp-0 scale) 1.0)
      (set! (-> gp-0 group) (-> *part-group-id-table* 104))
      (set! (-> gp-0 collide-with) (collide-spec))
      (set! (-> gp-0 damage) 2.0)
      (set! (-> gp-0 damage-scale) 1.0)
      (set! (-> gp-0 vehicle-damage-factor) 1.0)
      (set! (-> gp-0 vehicle-impulse-factor) 1.0)
      (set! (-> gp-0 ignore-proc) (process->handle #f))
      (explosion-spawn gp-0 self)
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-20 (-> self root root-prim)))
      (set! (-> v1-20 prim-core collide-as) (collide-spec))
      (set! (-> v1-20 prim-core collide-with) (collide-spec))
      )
    0
    (ja-post)
    (while (-> self child)
      (suspend)
      )
    )
  )

(defmethod projectile-method-40 ((this gun-dark-3-nuke))
  256
  )

(defstate impact-embedded (gun-dark-3-nuke)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self root transv quad) (the-as uint128 0))
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (if *scene-player*
        (go empty-state)
        )
    (if (time-elapsed? (-> self state-time) (seconds 1.4))
        (go-virtual impact-small)
        )
    )
  :code (behavior ()
    (until (time-elapsed? (-> self state-time) (seconds 0.3))
      (suspend)
      )
    (sound-play "beep")
    (until (time-elapsed? (-> self state-time) (seconds 0.5))
      (suspend)
      )
    (sound-play "beep")
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (ja-post)
    (projectile-method-25 self)
    )
  )

;; WARN: Return type mismatch uint vs none.
(defmethod play-death-sounds ((this gun-dark-3-nuke))
  (when (and (not (time-elapsed? (-> this state-time) (seconds 1.5)))
             (time-elapsed? (-> this last-death-sound-play-time) (seconds 0.1))
             )
    (set-time! (-> this last-death-sound-play-time))
    (let* ((v1-11 (+ (-> this num-dying-vehicles) (-> this num-dying-guards) (-> this num-dying-civilians)))
           (v1-12 (rand-vu-int-range 0 (the-as int (+ v1-11 -1))))
           )
      (when (> v1-12 0)
        (cond
          ((< v1-12 (the-as int (-> this num-dying-vehicles)))
           (sound-play-by-spec (static-sound-spec "vehicle-explode" :group 0) (new-sound-id) (the-as vector #t))
           (sound-play-by-spec (static-sound-spec "vehicle-explo-b" :group 0) (new-sound-id) (the-as vector #t))
           (+! (-> this num-dying-vehicles) -1)
           )
          ((< v1-12 (the-as int (+ (-> this num-dying-guards) (-> this num-dying-vehicles))))
           (sound-play "guard-die")
           (+! (-> this num-dying-guards) -1)
           )
          (else
            (sound-play "guard-hit")
            (+! (-> this num-dying-civilians) -1)
            )
          )
        )
      )
    )
  (none)
  )

(defstate impact-small (gun-dark-3-nuke)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self draw status) (draw-control-status no-draw))
    (case (get-status *gui-control* (-> self explode-wall-sound))
      (((gui-status ready))
       (set-action!
         *gui-control*
         (gui-action play)
         (-> self explode-wall-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       )
      (else
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self explode-wall-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        (sound-play "explosion" :pitch 2.5)
        )
      )
    (case (get-status *gui-control* (-> self explode-sound))
      (((gui-status ready))
       (set-action!
         *gui-control*
         (gui-action stop)
         (-> self explode-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       )
      )
    (set-setting! 'music-volume 'abs 0.0 0)
    (let ((v1-21 (-> self root root-prim)))
      (set! (-> v1-21 prim-core collide-as) (collide-spec))
      (set! (-> v1-21 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self last-death-sound-play-time) 0)
    (set! (-> self flash-time) *gun-dark-3-nuke-fade-time-small*)
    (set! (-> self blur-time) *gun-dark-3-nuke-blur-time-small*)
    (set! (-> self blur-curve) *gun-dark-3-nuke-blur-curve-small*)
    (set! (-> self fade-curve) *gun-dark-3-nuke-fade-curve-small*)
    (set! (-> self num-blur-segments) *gun-dark-3-nuke-blur-segs-small*)
    )
  :exit (behavior ()
    (when (= (process->handle self) (-> *last-active-nuke* last-active-nuke))
      (disable *screen-filter*)
      (blit-displays-work-method-17 *blit-displays-work* (-> self root trans) 0 1.0 #f)
      )
    )
  :trans (behavior ()
    (if *scene-player*
        (go empty-state)
        )
    (do-blur-effect self)
    (do-white-screen-effect self)
    (if (time-elapsed? (-> self state-time) (seconds 1))
        (do-camera-shake self)
        )
    (when (not (-> self spawned-mushroom-cloud?))
      (let ((v1-23
              (cond
                ((logtest? (-> *part-group-id-table* 114 flags) (sp-group-flag sp13))
                 (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                 (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 114))
                 )
                (else
                  (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                  (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 114))
                  )
                )
              )
            )
        (send-event (ppointer->process v1-23) 'clock self)
        )
      (set! (-> self spawned-mushroom-cloud?) #t)
      )
    (if (and (time-elapsed? (-> self state-time) (seconds 0.3))
             (not (time-elapsed? (-> self state-time) (seconds 6)))
             )
        (set-setting! 'nuke-active? #t 0.0 0)
        (remove-setting! 'nuke-active?)
        )
    (when (and (time-elapsed? (-> self state-time) (seconds 0.3))
               (and (not (time-elapsed? (-> self state-time) (seconds 6)))
                    (time-elapsed? (-> self last-kill-time) (seconds 0.1))
                    (not (-> self killed-everything?))
                    )
               )
      (count-casualties self)
      (set! (-> self killed-everything?) #t)
      (set-time! (-> self last-kill-time))
      )
    (play-death-sounds self)
    (ja-post)
    )
  :code (behavior ()
    (until (time-elapsed? (-> self state-time) (seconds 8))
      (suspend)
      )
    )
  )

(defstate wait-for-alive (gun-dark-3-nuke)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (remove-setting! 'allow-progress)
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (if *scene-player*
        (go empty-state)
        )
    (let ((f0-1 (* 0.00066666666 (the float (- (current-time) (-> self clock old-frame-counter))))))
      (set-setting! 'music-volume 'abs f0-1 0)
      )
    )
  :code (behavior ()
    (until (time-elapsed? (-> self state-time) (seconds 5))
      (suspend)
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod check-for-impact ((this gun-dark-3-nuke))
  (let ((a1-0 (new 'stack-no-clear 'collide-query)))
    (vector+float*! (-> a1-0 start-pos) (-> this root trans) *up-vector* 2048.0)
    (set-vector! (-> a1-0 move-dist) 0.0 49152.0 0.0 1.0)
    (let ((v1-3 a1-0))
      (set! (-> v1-3 radius) 40.96)
      (set! (-> v1-3 collide-with) (collide-spec backgnd))
      (set! (-> v1-3 ignore-process0) #f)
      (set! (-> v1-3 ignore-process1) #f)
      (set! (-> v1-3 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-3 action-mask) (collide-action solid))
      )
    (if (>= (fill-and-probe-using-line-sphere *collide-cache* a1-0) 0.0)
        (go (method-of-object this impact-small))
        )
    )
  (none)
  )

(defmethod do-vibration ((this gun-dark-3-nuke))
  (buzz-stop! 0)
  (let* ((f1-2 (* 0.00055555557 (the float (- (current-time) (-> this state-time)))))
         (f0-2 (fmax 0.0 (fmin 1.0 f1-2)))
         )
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 (the int (* 255.0 (- 1.0 f0-2))) (seconds 1))
    )
  (none)
  )

(defstate impact (gun-dark-3-nuke)
  :virtual #t
  :enter (behavior ()
    (check-for-impact self)
    (set-setting! 'music-volume 'abs 0.0 0)
    (case (get-status *gui-control* (-> self explode-wall-sound))
      (((gui-status ready))
       (set-action!
         *gui-control*
         (gui-action stop)
         (-> self explode-wall-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       )
      )
    (case (get-status *gui-control* (-> self explode-sound))
      (((gui-status ready))
       (set-action!
         *gui-control*
         (gui-action play)
         (-> self explode-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       )
      (else
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self explode-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        (sound-play "explosion" :pitch 2.5)
        )
      )
    (set-time! (-> self state-time))
    (logior! (-> self draw status) (draw-control-status no-draw))
    (vector+float*! (-> self mushroom-top-pos) (-> self root trans) *up-vector* 20480.0)
    (let ((v1-25 (-> self root root-prim)))
      (set! (-> v1-25 prim-core collide-as) (collide-spec))
      (set! (-> v1-25 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self flash-time) *gun-dark-3-nuke-fade-time*)
    (set! (-> self blur-time) *gun-dark-3-nuke-blur-time*)
    (set! (-> self blur-curve) *gun-dark-3-nuke-blur-curve*)
    (set! (-> self fade-curve) *gun-dark-3-nuke-fade-curve*)
    (set! (-> self num-blur-segments) *gun-dark-3-nuke-blur-segs*)
    )
  :exit (behavior ()
    (when (= (process->handle self) (-> *last-active-nuke* last-active-nuke))
      (disable *screen-filter*)
      (blit-displays-work-method-17 *blit-displays-work* (-> self root trans) 0 1.0 #f)
      )
    )
  :trans (behavior ()
    (if *scene-player*
        (go empty-state)
        )
    (do-blur-effect self)
    (do-white-screen-effect self)
    (do-vibration self)
    (if (time-elapsed? (-> self state-time) (seconds 1))
        (do-camera-shake self)
        )
    (set! (-> self strip num-verts) (the-as uint 0))
    (when (time-elapsed? (-> self state-time) (seconds 0.035))
      (when (not (-> self spawned-mushroom-cloud?))
        (let ((v1-30
                (cond
                  ((logtest? (-> *part-group-id-table* 110 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 110))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 110))
                    )
                  )
                )
              )
          (send-event (ppointer->process v1-30) 'clock self)
          )
        (let ((v1-61
                (cond
                  ((logtest? (-> *part-group-id-table* 111 flags) (sp-group-flag sp13))
                   (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 111))
                   )
                  (else
                    (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 111))
                    )
                  )
                )
              )
          (send-event (ppointer->process v1-61) 'clock self)
          )
        (let ((gp-4 (new 'stack-no-clear 'gun-dark-3-sphere-init-params)))
          (set! (-> gp-4 pos quad) (-> self root trans quad))
          (set! (-> gp-4 size-x) 1.0)
          (set! (-> gp-4 size-y) 1.0)
          (set! (-> self warp)
                (ppointer->handle (process-spawn gun-dark-3-sphere gp-4 :name "gun-dark-3-sphere" :to self))
                )
          )
        (set! (-> self spawned-mushroom-cloud?) #t)
        )
      (if (and (time-elapsed? (-> self state-time) (seconds 0.3))
               (not (time-elapsed? (-> self state-time) (seconds 6)))
               )
          (set-setting! 'nuke-active? #t 0.0 0)
          (remove-setting! 'nuke-active?)
          )
      (when (and (time-elapsed? (-> self state-time) (seconds 0.3))
                 (and (not (time-elapsed? (-> self state-time) (seconds 7)))
                      (time-elapsed? (-> self last-kill-time) (seconds 0.1))
                      (not (-> self killed-everything?))
                      )
                 )
        (count-casualties self)
        (set! (-> self killed-everything?) #t)
        (set-time! (-> self last-kill-time))
        )
      (play-death-sounds self)
      (+! (-> self mushroom-top-pos y) (* *gun-dark-3-mushroom-speed* (seconds-per-frame)))
      (let ((f26-0 (/ (the float (- (current-time) (-> self state-time))) (the float *gun-dark-3-mushroom-size-time*))))
        0.0
        0.0
        (let ((f30-0 1.0)
              (f28-0 (curve2d-method-9 *gun-dark-3-nuke-mushroom-size-curve-x* f26-0 3))
              (f26-1 (curve2d-method-9 *gun-dark-3-nuke-mushroom-size-curve-y* f26-0 3))
              )
          (when (time-elapsed? (-> self state-time) (seconds 5))
            (let ((f30-1 (* 0.00066666666 (the float (+ (- (seconds -5) (-> self state-time)) (current-time))))))
              0.0
              (let ((f24-0 (* f30-1 f30-1)))
                (set! f28-0 (* f28-0 (lerp 1.0 1.3 f24-0)))
                (set! f26-1 (* f26-1 (lerp 1.0 1.3 f24-0)))
                )
              (set! f30-0 (lerp 1.0 0.0 f30-1))
              )
            )
          (let ((v1-144 (new 'stack-no-clear 'gun-dark-3-sphere-init-params)))
            (set! (-> v1-144 pos quad) (-> self mushroom-top-pos quad))
            (set! (-> v1-144 size-x) f28-0)
            (set! (-> v1-144 size-y) f26-1)
            (set! (-> v1-144 alpha-val) (* f30-0 f30-0))
            (send-event (handle->process (-> self warp)) 'set-pos-and-size v1-144)
            )
          (let ((gp-6 (vector-float*! (new 'stack-no-clear 'vector) *up-vector* f26-1))
                (s5-1 (new 'stack-no-clear 'vector))
                )
            (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) (-> self mushroom-top-pos) (math-camera-pos))))
              (set! (-> s4-1 y) 0.0)
              (vector-cross! s5-1 *up-vector* s4-1)
              )
            (vector-normalize! s5-1 f28-0)
            (dotimes (v1-152 4)
              (if (> (logand v1-152 1) 0)
                  (vector-float*! gp-6 gp-6 -1.0)
                  )
              (when (= v1-152 2)
                (vector-float*! gp-6 gp-6 -1.0)
                (vector-float*! s5-1 s5-1 -1.0)
                )
              (vector+! (the-as vector (+ (the-as uint (-> self strip data 0 pos)) (* v1-152 32))) s5-1 gp-6)
              (vector+!
                (the-as vector (+ (the-as uint (-> self strip data 0 pos)) (* v1-152 32)))
                (the-as vector (+ (the-as uint (-> self strip data 0 pos)) (* v1-152 32)))
                (-> self mushroom-top-pos)
                )
              (set! (-> self strip data v1-152 stq z) 0.0)
              (set! (-> self strip data v1-152 col) *color-gray*)
              (set! (-> self strip data v1-152 col a) (the int (* 127.0 f30-0)))
              (set! (-> self strip data v1-152 col g) (the int (* 127.0 f30-0)))
              (set! (-> self strip data v1-152 col b) (the int (* 127.0 f30-0)))
              )
            )
          )
        )
      (set! (-> self strip alpha) (new 'static 'gs-alpha :b #x1 :d #x1))
      (set! (-> self strip adnops 0 cmds) (gs-reg64 test-1))
      (set! (-> self strip data0) (new 'static 'gs-test
                                    :ate #x1
                                    :atst (gs-atest greater-equal)
                                    :aref #x32
                                    :afail #x1
                                    :zte #x1
                                    :ztst (gs-ztest greater-equal)
                                    )
            )
      (set! (-> self strip data 0 stq x) 1.0)
      (set! (-> self strip data 0 stq y) 1.0)
      (set! (-> self strip data 1 stq x) 1.0)
      (set! (-> self strip data 1 stq y) 0.0)
      (set! (-> self strip data 3 stq x) 0.0)
      (set! (-> self strip data 3 stq y) 0.0)
      (set! (-> self strip data 2 stq x) 0.0)
      (set! (-> self strip data 2 stq y) 1.0)
      (set! (-> self strip num-verts) (the-as uint 4))
      )
    (ja-post)
    )
  :code (behavior ()
    (until (time-elapsed? (-> self state-time) (seconds 10))
      (suspend)
      )
    (go-virtual wait-for-alive)
    )
  )

(defmethod projectile-method-32 ((this gun-dark-3-nuke))
  (if (not (do-fire-backcheck (-> this root trans) (-> this root transv)))
      (go (method-of-object this impact-dud))
      (go (method-of-object this launch-0))
      )
  0
  (none)
  )

(defbehavior target-gun-can-fire-dark? target ((arg0 pickup-type))
  (case arg0
    (((pickup-type gun-dark-2))
     (time-elapsed? (get-last-fire-time 36) (seconds 2))
     )
    (((pickup-type gun-dark-3))
     (time-elapsed? (get-last-fire-time 37) (seconds 9))
     )
    (else
      #t
      )
    )
  )

;; WARN: Return type mismatch int vs (pointer process).
(defbehavior gun-fire-dark-3 target ()
  (let ((gp-0 (-> self gun))
        (s5-0 (new 'stack-no-clear 'projectile-init-by-other-params))
        )
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> self gun fire-dir-out quad))
      (set-last-fire-time 37)
      (sound-play "purple-3-shot" :position (-> gp-0 fire-point))
      (set! (-> s5-0 ent) (-> self entity))
      (set! (-> s5-0 charge) 1.0)
      (set! (-> s5-0 options) (projectile-options))
      (logclear! (-> s5-0 options) (projectile-options po14 po15 po16))
      (set! (-> s5-0 pos quad) (-> gp-0 fire-point quad))
      (set! (-> s5-0 vel quad) (-> (vector-float*! (new 'stack-no-clear 'vector) s4-0 81920.0) quad))
      )
    (set! (-> s5-0 notify-handle) (the-as handle #f))
    (set! (-> s5-0 owner-handle) (the-as handle #f))
    (set! (-> s5-0 target-handle) (the-as handle #f))
    (set! (-> s5-0 target-pos quad) (the-as uint128 0))
    (set! (-> s5-0 ignore-handle) (process->handle (send-event self 'get-vehicle)))
    (let* ((v1-17 *game-info*)
           (a0-17 (+ (-> v1-17 attack-id) 1))
           )
      (set! (-> v1-17 attack-id) a0-17)
      (set! (-> s5-0 attack-id) a0-17)
      )
    (set! (-> s5-0 timeout) (seconds 4))
    (let ((v0-7 (ppointer->handle (process-spawn
                                    gun-dark-3-nuke
                                    :init projectile-init-by-other
                                    s5-0
                                    :name "projectile"
                                    :to (ppointer->process (-> gp-0 gun))
                                    :stack *kernel-dram-stack*
                                    )
                                  )
                )
          )
      (set! (-> gp-0 gun 0 extra) (the-as handle v0-7))
      (the-as (pointer process) v0-7)
      )
    )
  )

(defmethod init-proj-settings! ((this gun-dark-shot))
  (+! (-> *game-info* shots-fired 3) 1.0)
  (set! (-> this attack-mode) 'eco-dark)
  (vector-normalize! (-> this root transv) (+ 225280.0 (* 225280.0 (-> this charge-level))))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 94) this))
  (set! (-> this blast-radius) 40960.0)
  (if (logtest? (game-secrets gun-upgrade-dark-1) (-> *game-info* secrets))
      (set! (-> this blast-radius) 81920.0)
      )
  (set! (-> this size-t) 0.0)
  (set! (-> this notify-handle) (process->handle this))
  (set! (-> this charge-sound) (new-sound-id))
  (set! (-> this fire-sound) (new-sound-id))
  (set! (-> this trail-sound) (new-sound-id))
  (set! (-> this explode-sound)
        (add-process *gui-control* this (gui-channel gun) (gui-action queue) "pmkrxplo" -99.0 0)
        )
  (sound-params-set! *gui-control* (-> this explode-sound) #t 50 150 11 -1.0)
  (set! (-> this start-pilot?) (the-as symbol (and *target* (focus-test? *target* pilot))))
  (set! (-> this damage) 16.0)
  (set! (-> this vehicle-damage-factor) 1.0)
  (set! (-> this vehicle-impulse-factor) 2.0)
  (when (logtest? (game-secrets gun-upgrade-dark-1) (-> *game-info* secrets))
    (set! (-> this vehicle-damage-factor) 6.0)
    (set! (-> this vehicle-impulse-factor) 6.0)
    )
  ((method-of-type projectile init-proj-settings!) this)
  0
  (none)
  )

(defmethod projectile-method-25 ((this gun-dark-shot))
  (cond
    ((and (and (-> this next-state) (= (-> this next-state name) 'startup))
          (and *target* (focus-test? *target* in-head))
          )
     (kill-particles (-> this part))
     )
    (else
      (set! (-> *part-id-table* 260 init-specs 2 initial-valuef) (lerp 409.6 9216.0 (-> this size-t)))
      (set! (-> *part-id-table* 260 init-specs 8 initial-valuef) (lerp 0.0 32.0 (-> this size-t)))
      (set! (-> *part-id-table* 261 init-specs 2 initial-valuef) (lerp 409.6 32768.0 (-> this size-t)))
      (set! (-> *part-id-table* 261 init-specs 8 initial-valuef) (lerp 0.0 16.0 (-> this size-t)))
      (set! (-> *part-id-table* 259 init-specs 2 initial-valuef) (lerp 409.6 8192.0 (-> this size-t)))
      (set! (-> *part-id-table* 258 init-specs 1 initial-valuef) (lerp 0.1 1.0 (-> this size-t)))
      (set! (-> *part-id-table* 258 init-specs 2 initial-valuef) (lerp 409.6 3686.4 (-> this size-t)))
      (spawn (-> this part) (-> this root trans))
      )
    )
  (ja-post)
  (none)
  )

(defmethod projectile-method-32 ((this gun-dark-shot))
  (go (method-of-object this startup))
  0
  (none)
  )

(defstate startup (gun-dark-shot)
  :virtual #t
  :exit (behavior ()
    (send-event (ppointer->process (-> self parent)) 'release)
    (set! (-> self size-t) 1.0)
    (let ((v1-6 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-6 command) (sound-command set-param))
      (set! (-> v1-6 id) (-> self charge-sound))
      (set! (-> v1-6 params volume) -4)
      (set! (-> v1-6 auto-time) 24)
      (set! (-> v1-6 auto-from) 2)
      (set! (-> v1-6 params mask) (the-as uint 17))
      (-> v1-6 id)
      )
    )
  :code (behavior ()
    (set-time! (-> self state-time))
    (until #f
      (cond
        ((or (and *target*
                  (focus-test? *target* dead grabbed under-water pole flut board mech dark carry indax teleporting)
                  )
             (and *target* (not (logtest? (focus-status in-head gun) (-> *target* focus-status))))
             (and *target* (!= (-> self start-pilot?) (focus-test? *target* pilot)))
             (not (-> *setting-control* user-current gun))
             )
         (adjust-player-ammo 1.0 (pickup-type ammo-dark))
         (go-virtual dissipate)
         )
        ((or (not (time-elapsed? (-> self state-time) (seconds 0.3))) (cpad-hold? 0 r1))
         (set! (-> self size-t) (fmin 1.0 (* 0.016666668 (the float (- (current-time) (-> self state-time))))))
         (let ((t9-2 vector<-cspace!)
               (a0-14 (-> self root trans))
               (v1-28 (-> self parent))
               )
           (t9-2 a0-14 (-> (the-as process-focusable (if v1-28
                                                         (the-as process-focusable (-> v1-28 0 self))
                                                         )
                                   )
                           node-list
                           data
                           13
                           )
                 )
           )
         )
        ((and (logtest? (projectile-options po17) (-> self options)) (made-impact? self))
         (go-virtual impact)
         )
        (else
          (go-virtual moving)
          )
        )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (sound-play "pmkr-charge" :id (-> self charge-sound) :position (-> self root trans))
    (projectile-method-25 self)
    )
  )

(defstate moving (gun-dark-shot)
  :virtual #t
  :enter (behavior ()
    (if *target*
        (set! (-> self track-target) (-> *target* gun track-target 0 handle))
        )
    (let ((t9-0 (-> (method-of-type projectile moving) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self core-position quad) (-> self root trans quad))
    (let ((v1-10 (-> self core-velocity))
          (a0-3 (-> self parent))
          )
      (set! (-> v1-10 quad) (-> (the-as process-focusable (if a0-3
                                                              (the-as process-focusable (-> a0-3 0 self))
                                                              )
                                        )
                                node-list
                                data
                                13
                                bone
                                transform
                                fvec
                                quad
                                )
            )
      )
    (when (and *target* (focus-test? *target* in-head))
      (set! (-> self core-position quad) (-> (camera-pos) quad))
      (set! (-> self core-velocity quad) (-> (camera-matrix) fvec quad))
      )
    (set-vector! (-> self spin-vector) (-> self core-velocity z) 0.0 (- (-> self core-velocity x)) 1.0)
    (let ((f0-5 (vector-length (-> self spin-vector))))
      (if (< f0-5 1.0)
          (set-vector! (-> self spin-vector) 1.0 0.0 0.0 1.0)
          (vector-float*! (-> self spin-vector) (-> self spin-vector) (/ 1.0 f0-5))
          )
      )
    (set-time! (-> self state-time))
    (let ((v1-35 (cond
                   ((logtest? (-> *part-group-id-table* 92 flags) (sp-group-flag sp13))
                    (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                    (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 92))
                    )
                   (else
                     (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
                     (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 92))
                     )
                   )
                 )
          )
      (send-event (ppointer->process v1-35) 'clock self)
      )
    (draw-beam (-> *part-id-table* 250) (-> self root trans) (-> self core-velocity) #f)
    )
  :trans (behavior ()
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (let ((s5-0 (new 'stack-no-clear 'matrix)))
          (let ((s4-0 (new 'stack-no-clear 'vector)))
            (vector-normalize-copy! s4-0 (-> self core-velocity) 1.0)
            (let* ((s3-0 (handle->process (-> self track-target)))
                   (s2-0 (if (type? s3-0 process-drawable)
                             s3-0
                             )
                         )
                   )
              (when s2-0
                (let ((s3-1 (new 'stack-no-clear 'vector)))
                  (set! (-> s3-1 quad) (-> (the-as process-focusable s2-0) root trans quad))
                  (let ((a0-6 (if (type? s2-0 process-focusable)
                                  s2-0
                                  )
                              )
                        )
                    (if a0-6
                        (set! (-> s3-1 quad) (-> (get-trans (the-as process-focusable a0-6) 3) quad))
                        )
                    )
                  (let* ((s2-3 (vector-! (new 'stack-no-clear 'vector) s3-1 (-> self core-position)))
                         (f0-0 (vector-normalize-ret-len! s2-3 1.0))
                         (f0-1 (lerp-scale 182.04445 8192.0 f0-0 61440.0 4096.0))
                         (s3-2 (new 'stack-no-clear 'matrix))
                         )
                    (matrix-from-two-vectors-max-angle! s3-2 s4-0 s2-3 f0-1)
                    (vector-matrix*! (-> self core-velocity) (-> self core-velocity) s3-2)
                    )
                  )
                )
              )
            (+! (-> self spin-vector x) (-> s4-0 z))
            (set! (-> self spin-vector z) (- (-> self spin-vector z) (-> s4-0 x)))
            (vector-flatten! (-> self spin-vector) (-> self spin-vector) s4-0)
            (matrix-axis-angle! s5-0 s4-0 (* 2002.4889 (-> self clock time-adjust-ratio)))
            (vector-matrix*! (-> self spin-vector) (-> self spin-vector) s5-0)
            (let ((f0-9 (the float (- (current-time) (-> self state-time))))
                  (f30-0 0.0)
                  )
              (cond
                ((< 450.0 f0-9)
                 (go-virtual impact)
                 )
                ((< f0-9 90.0)
                 (set! f30-0 (lerp-scale 0.0 4096.0 f0-9 0.0 90.0))
                 )
                (else
                  (set! f30-0 (lerp-scale 4096.0 1228.8 f0-9 30.0 300.0))
                  )
                )
              (let ((f30-1 (* 0.5 f30-0)))
                (vector-normalize! (-> self spin-vector) f30-1)
                (vector-normalize! (-> self core-velocity) 7372.8)
                (set! (-> s5-0 fvec quad) (-> s4-0 quad))
                (set! (-> s5-0 uvec quad) (-> self spin-vector quad))
                (vector-float*! (-> s5-0 uvec) (-> s5-0 uvec) (/ 1.0 f30-1))
                )
              )
            )
          (vector-cross! (-> s5-0 rvec) (-> s5-0 uvec) (-> s5-0 fvec))
          (matrix->quaternion (-> self root quat) s5-0)
          )
        (vector+! (-> self core-position) (-> self core-position) (-> self core-velocity))
        (vector+! gp-0 (-> self core-position) (-> self spin-vector))
        (vector-! (-> self root transv) gp-0 (-> self root trans))
        )
      (let ((v1-39 (-> self root transv)))
        (.lvf vf1 (&-> (-> self root transv) quad))
        (let ((f0-13 (-> self clock frames-per-second)))
          (.mov at-0 f0-13)
          )
        (.mov vf2 at-0)
        (.mov.vf vf1 vf0 :mask #b1000)
        (.mul.x.vf vf1 vf1 vf2 :mask #b111)
        (.svf (&-> v1-39 quad) vf1)
        )
      (projectile-move-fill-line-sphere self)
      (if (logtest? (-> self root status) (collide-status touch-surface))
          (go-virtual impact)
          )
      (sound-play "pmkr-fire" :id (-> self fire-sound) :position (-> self root trans))
      (sound-play "pmkr-trail" :id (-> self trail-sound) :position (-> self root trans))
      )
    )
  )

;; WARN: Check prologue - tricky store of a0
(defun process-drawable-shock-effect-bullseye ((arg0 process-focusable)
                                      (arg1 process-focusable)
                                      (arg2 lightning-spec)
                                      (arg3 (function lightning-tracker none))
                                      (arg4 sparticle-launcher)
                                      (arg5 sparticle-launcher)
                                      (arg6 sparticle-launcher)
                                      )
  (local-vars (sv-16 process) (sv-32 lightning-spec) (sv-48 process-focusable))
  (set! sv-48 arg0)
  (let ((s0-0 arg1))
    (set! sv-32 arg2)
    (let ((gp-0 arg4)
          (s1-0 arg5)
          (s3-0 arg6)
          (s4-0 (get-trans sv-48 3))
          (s5-0 (get-trans s0-0 3))
          )
      (set! sv-16 (get-process *default-dead-pool* lightning-tracker #x4000 0))
      (let ((s2-0 (when sv-16
                    (let ((t9-3 (method-of-type lightning-tracker activate)))
                      (t9-3 (the-as lightning-tracker sv-16) s0-0 "lightning-tracker" (the-as pointer #x70004000))
                      )
                    (let ((t9-4 run-function-in-process)
                          (a0-5 sv-16)
                          (a1-5 lightning-tracker-init)
                          (a3-3 0)
                          (t0-1 lightning-probe-callback)
                          (t2-1 256)
                          (t3-0 256)
                          )
                      ((the-as (function object object object object object object object object none) t9-4)
                       a0-5
                       a1-5
                       sv-32
                       a3-3
                       t0-1
                       sv-48
                       t2-1
                       t3-0
                       )
                      )
                    (-> sv-16 ppointer)
                    )
                  )
            )
        (when s1-0
          (let ((t9-5 sp-launch-particles-var)
                (a0-6 *sp-particle-system-2d*)
                (a2-4 *launch-matrix*)
                )
            (set! (-> a2-4 trans quad) (-> s4-0 quad))
            (t9-5 a0-6 s1-0 a2-4 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        (when s3-0
          (let ((t9-6 sp-launch-particles-var)
                (a0-7 *sp-particle-system-2d*)
                (a2-5 *launch-matrix*)
                )
            (set! (-> a2-5 trans quad) (-> s4-0 quad))
            (t9-6 a0-7 s3-0 a2-5 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        (when (and gp-0 s2-0)
          (let ((v1-13 (get-field-spec-by-id gp-0 (sp-field-id spt-timer))))
            (if v1-13
                (set! (-> v1-13 initial-valuef) (the-as float (-> (the-as lightning-tracker (-> s2-0 0)) duration)))
                )
            )
          (let ((t9-8 sp-launch-particles-var)
                (a0-12 *sp-particle-system-2d*)
                (a1-13 gp-0)
                (a2-6 *launch-matrix*)
                )
            (set! (-> a2-6 trans quad) (-> s4-0 quad))
            (t9-8 a0-12 a1-13 a2-6 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          (let ((t9-9 sp-launch-particles-var)
                (a0-13 *sp-particle-system-2d*)
                (a2-7 *launch-matrix*)
                )
            (set! (-> a2-7 trans quad) (-> s5-0 quad))
            (t9-9 a0-13 gp-0 a2-7 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate fizzle (gun-dark-shot)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 1))
        (deactivate self)
        )
    (process-drawable-shock-effect-replace
      self
      (-> *lightning-spec-id-table* 15)
      lightning-probe-callback
      256
      0
      40960.0
      )
    (launch-particles (-> *part-id-table* 255) (-> self root trans))
    (launch-particles (-> *part-id-table* 257) (-> self root trans))
    (let ((gp-0 (-> *part-id-table* 665)))
      (when gp-0
        (let ((v1-13 (get-field-spec-by-id gp-0 (sp-field-id spt-timer))))
          (if v1-13
              (set! (-> v1-13 initial-valuef) (the-as float #xf))
              )
          )
        (let ((t9-5 sp-launch-particles-var)
              (a0-8 *sp-particle-system-2d*)
              (a2-3 *launch-matrix*)
              )
          (set! (-> a2-3 trans quad) (-> self root trans quad))
          (t9-5 a0-8 gp-0 a2-3 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
          )
        )
      )
    )
  :code sleep-code
  )

;; WARN: Return type mismatch object vs none.
(defbehavior gun-dark-shot-init-fizzle gun-dark-shot ((arg0 vector))
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-projectile)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec backgnd crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set-vector! (-> v1-6 local-sphere) 0.0 5324.8 0.0 5324.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> self root) s5-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (let ((v1-16 (-> self root root-prim)))
    (set! (-> v1-16 prim-core collide-as) (collide-spec))
    (set! (-> v1-16 prim-core collide-with) (collide-spec))
    )
  0
  (logclear! (-> self mask) (process-mask actor-pause))
  (go-virtual fizzle)
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod do-camera-shake ((this gun-dark-3-nuke))
  (when (not (-> this shook-camera?))
    (activate! *camera-smush-control* 1228.8 45 1275 1.0 0.9 (-> *display* camera-clock))
    (set! (-> this shook-camera?) #t)
    )
  (none)
  )

(defmethod projectile-method-40 ((this gun-dark-shot))
  512
  )

(defstate impact (gun-dark-shot)
  :virtual #t
  :enter (behavior ()
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 153 (seconds 0.2))
    (let ((t9-1 (-> (method-of-type projectile impact) enter)))
      (if t9-1
          (t9-1)
          )
      )
    (set! (-> self result-count) 0)
    (set! (-> self spread-timer) 0)
    (if (not (time-elapsed? (-> self spawn-time) (seconds 0.1)))
        (send-event (ppointer->process (-> self parent)) 'release)
        )
    (sound-stop (-> self trail-sound))
    (case (get-status *gui-control* (-> self explode-sound))
      (((gui-status ready))
       (set-action!
         *gui-control*
         (gui-action play)
         (-> self explode-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       )
      (else
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self explode-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        (sound-play "explosion" :pitch 2.5)
        )
      )
    (let ((v1-23 (-> self root root-prim)))
      (set! (-> v1-23 prim-core collide-as) (collide-spec))
      (set! (-> v1-23 prim-core collide-with) (collide-spec))
      )
    0
    (cond
      ((logtest? (-> *part-group-id-table* 93 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 93))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 93))
        )
      )
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> self root trans quad))
      (let ((gp-3 (the-as (array float) (new 'stack 'boxed-array float 16)))
            (a1-13 (new 'stack-no-clear 'event-message-block))
            )
        (set! (-> a1-13 from) (process->ppointer self))
        (set! (-> a1-13 num-params) 0)
        (set! (-> a1-13 message) 'get-vehicle)
        (let ((s5-1 (send-event-function *target* a1-13)))
          (set! (-> s4-0 w) (-> self blast-radius))
          (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 384)))
            (countdown (s2-0 (fill-actor-list-for-box *actor-hash* s4-0 s3-0 384))
              (let* ((s1-0 (-> s3-0 s2-0))
                     (v1-66 (if (type? s1-0 collide-shape)
                                s1-0
                                )
                            )
                     )
                (when v1-66
                  (let* ((s0-0 (-> v1-66 process))
                         (s1-1 (if (type? s0-0 process-focusable)
                                   s0-0
                                   )
                               )
                         )
                    (when s1-1
                      (when (and (nonzero? (-> (the-as process-focusable s1-1) root root-prim prim-core collide-as))
                                 (logtest? (process-mask crate enemy guard vehicle civilian kg-robot metalhead) (-> s1-1 mask))
                                 (not (focus-test? (the-as process-focusable s1-1) disable dead ignore))
                                 (!= s1-1 s5-1)
                                 )
                        (let* ((s0-1 (get-trans (the-as process-focusable s1-1) 3))
                               (f0-2 (vector-vector-distance-squared (-> self root trans) s0-1))
                               (f1-0 (-> s0-1 w))
                               (f0-3 (- f0-2 (* f1-0 f1-0)))
                               (v1-80 (+ (-> self result-count) -1))
                               )
                          (while (and (>= v1-80 0) (< f0-3 (-> gp-3 v1-80)))
                            (when (< v1-80 15)
                              (set! (-> gp-3 (+ v1-80 1)) (-> gp-3 v1-80))
                              (set! (-> self result-array (+ v1-80 1)) (-> self result-array v1-80))
                              )
                            (+! v1-80 -1)
                            )
                          (when (< v1-80 15)
                            (let ((v1-81 (+ v1-80 1)))
                              (if (< (-> self result-count) 16)
                                  (+! (-> self result-count) 1)
                                  )
                              (set! (-> gp-3 v1-81) f0-3)
                              (set! (-> self result-array v1-81) (process->handle s1-1))
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          (let* ((s2-1 *target*)
                 (s3-1 (if (type? s2-1 process-focusable)
                           s2-1
                           )
                       )
                 )
            (when (and s3-1 (< (vector-vector-distance (get-trans s3-1 0) s4-0) (-> s4-0 w)))
              (when (and (nonzero? (-> s3-1 control root-prim prim-core collide-as))
                         (logtest? (process-mask crate enemy guard vehicle civilian kg-robot metalhead) (-> s3-1 mask))
                         (not (focus-test? s3-1 disable dead ignore))
                         (!= s3-1 s5-1)
                         )
                (let* ((s5-2 (get-trans s3-1 3))
                       (f0-5 (vector-vector-distance-squared (-> self root trans) s5-2))
                       (f1-6 (-> s5-2 w))
                       (f0-6 (- f0-5 (* f1-6 f1-6)))
                       (v1-101 (+ (-> self result-count) -1))
                       )
                  (while (and (>= v1-101 0) (< f0-6 (-> gp-3 v1-101)))
                    (when (< v1-101 15)
                      (set! (-> gp-3 (+ v1-101 1)) (-> gp-3 v1-101))
                      (set! (-> self result-array (+ v1-101 1)) (-> self result-array v1-101))
                      )
                    (+! v1-101 -1)
                    )
                  (when (< v1-101 15)
                    (let ((v1-102 (+ v1-101 1)))
                      (if (< (-> self result-count) 16)
                          (+! (-> self result-count) 1)
                          )
                      (set! (-> gp-3 v1-102) f0-6)
                      (set! (-> self result-array v1-102) (process->handle s3-1))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (zero? (-> self result-count))
        (go-virtual fizzle)
        )
    (let ((gp-4 (handle->process (-> self result-array 0))))
      (deal-damage! self gp-4 (the-as event-message-block #f))
      (let ((s5-3 gp-4))
        (if (or (if (type? s5-3 crate)
                    s5-3
                    )
                (let ((s5-4 gp-4))
                  (if (type? s5-4 market-object)
                      s5-4
                      )
                  )
                (if (type? gp-4 fruit-stand)
                    gp-4
                    )
                )
            (process-spawn gun-dark-shot :init gun-dark-shot-init-fizzle (-> self root trans) :name "gun-dark-shot")
            )
        )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type projectile impact) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (when (and (> (-> self result-count) 0) (time-elapsed? (-> self spread-timer) (seconds 0.1)))
      (set-time! (-> self spread-timer))
      (+! (-> self result-count) -1)
      (while (and (>= (-> self result-count) 0) (not (handle->process (-> self result-array (-> self result-count)))))
        (+! (-> self result-count) -1)
        )
      (when (>= (-> self result-count) 0)
        (let ((s5-0 (handle->process (-> self result-array (-> self result-count)))))
          (if s5-0
              (process-spawn-function
                process
                (lambda :behavior process
                  ((arg0 handle) (arg1 float))
                  (let* ((s3-0 (ppointer->process (-> self parent)))
                         (s5-0 (if (type? s3-0 process-focusable)
                                   s3-0
                                   )
                               )
                         (s2-0 0)
                         (s1-0 (current-time))
                         (s3-1 #f)
                         )
                    (+! (-> self clock ref-count) -1)
                    (+! (-> s5-0 clock ref-count) 1)
                    (set! (-> self clock) (-> s5-0 clock))
                    (while (and (nonzero? (-> (the-as process-focusable s5-0) skel))
                                (or (focus-test? (the-as process-focusable s5-0) dead hit)
                                    (and (-> (the-as process-focusable s5-0) next-state)
                                         (= (-> (the-as process-focusable s5-0) next-state name) 'knocked)
                                         )
                                    (not (time-elapsed? s1-0 (seconds 0.35)))
                                    )
                                (not (time-elapsed? s1-0 (seconds 5)))
                                (not (logtest? (-> (the-as process-focusable s5-0) draw status) (draw-control-status no-draw no-draw-temp)))
                                (or (not (and (-> (the-as process-focusable s5-0) next-state)
                                              (= (-> (the-as process-focusable s5-0) next-state name) 'fizzle)
                                              )
                                         )
                                    (not (type? s5-0 missile-bot))
                                    )
                                )
                      (when (time-elapsed? (the-as time-frame s2-0) (seconds 0.05))
                        (set! s2-0 (the-as int (current-time)))
                        (let ((a0-5 (handle->process arg0)))
                          (if a0-5
                              (process-drawable-shock-effect-bullseye
                                (the-as process-focusable a0-5)
                                (the-as process-focusable s5-0)
                                (-> *lightning-spec-id-table* 16)
                                lightning-probe-callback
                                (-> *part-id-table* 665)
                                (-> *part-id-table* 255)
                                (-> *part-id-table* 257)
                                )
                              )
                          )
                        (process-drawable-shock-effect-replace
                          (the-as process-drawable s5-0)
                          (-> *lightning-spec-id-table* 15)
                          lightning-probe-callback
                          0
                          0
                          40960.0
                          )
                        )
                      (suspend)
                      (let ((s5-1 (ppointer->process (-> self parent))))
                        (set! s5-0 (if (type? s5-1 process-focusable)
                                       s5-1
                                       )
                              )
                        )
                      (when (and (not s3-1) (time-elapsed? s1-0 (seconds 0.1)) (!= s5-0 (handle->process arg0)))
                        (set! s3-1 #t)
                        (send-event
                          s5-0
                          'attack
                          #f
                          (static-attack-info
                            :mask (vehicle-impulse-factor)
                            ((id (new-attack-id)) (damage 16.0) (vehicle-damage-factor arg1) (vehicle-impulse-factor 1.0) (mode 'explode))
                            )
                          )
                        )
                      )
                    (+! (-> *game-info* shots-hit 3) 1.0)
                    (when (and (not s3-1) (!= s5-0 (handle->process arg0)))
                      #t
                      (send-event
                        s5-0
                        'attack
                        #f
                        (static-attack-info
                          :mask (vehicle-impulse-factor)
                          ((id (new-attack-id)) (damage 16.0) (vehicle-damage-factor arg1) (vehicle-impulse-factor 1.0) (mode 'explode))
                          )
                        )
                      )
                    )
                  )
                (-> self result-array 0)
                (-> self vehicle-damage-factor)
                :to s5-0
                )
              )
          )
        )
      )
    (if (or (time-elapsed? (-> self spread-timer) (seconds 10))
            (and (not (-> self child))
                 (= (get-status *gui-control* (-> self explode-sound)) (gui-status unknown))
                 (< (-> self result-count) 0)
                 )
            )
        (deactivate self)
        )
    )
  :code sleep-code
  )

(deftype gravity-spinner (process)
  ((cached-damage           float)
   (end-time                time-frame)
   (time-subtract           time-frame)
   (parent-hand             handle)
   (rotation-accel          vector  :inline)
   (original-sphere-offset  sphere  :inline)
   (obj-radius              float)
   (was-hit-previously?     symbol)
   (ground-height           float)
   (next-ground-probe-time  time-frame)
   )
  (:state-methods
    zero-g
    zero-g-vehicle
    )
  (:methods
    (gravity-spinner-method-16 (_type_ vector vector) none)
    (update-rotation (_type_ symbol) none)
    (gravity-spinner-method-18 (_type_ process) float)
    (handle-impact (_type_ symbol) vector)
    (probe-ground (_type_) none)
    (get-float-speed (_type_) float)
    (gravity-spinner-method-22 (_type_) none)
    (spawn-part (_type_) none)
    (rotate! (_type_ quaternion) none)
    )
  )


(defmethod relocate ((this gravity-spinner) (offset int))
  (call-parent-method this offset)
  )

(defmethod deactivate ((this gravity-spinner))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (call-parent-method this)
  (none)
  )

(defmethod gravity-spinner-method-18 ((this gravity-spinner) (arg0 process))
  1.0
  )

(defmethod spawn-part ((this gravity-spinner))
  (when (zero? (mod (the-as int (rand-uint31-gen *random-generator*)) 5))
    (let* ((s5-0 (handle->process (-> this parent-hand)))
           (gp-1 (if (type? s5-0 process-focusable)
                     s5-0
                     )
                 )
           )
      (when gp-1
        (when (and (-> (the-as process-focusable gp-1) node-list) (nonzero? (-> (the-as process-focusable gp-1) node-list)))
          (let* ((v1-12
                   (+ (mod
                        (the-as int (rand-uint31-gen *random-generator*))
                        (+ (-> (the-as process-focusable gp-1) node-list length) -2)
                        )
                      2
                      )
                   )
                 (v1-15
                   (vector<-cspace! (new 'stack-no-clear 'vector) (-> (the-as process-focusable gp-1) node-list data v1-12))
                   )
                 (t9-4 sp-launch-particles-var)
                 (a0-9 *sp-particle-system-2d*)
                 (a1-5 (-> *part-id-table* 398))
                 (a2-0 *launch-matrix*)
                 )
            (set! (-> a2-0 trans quad) (-> v1-15 quad))
            (t9-4 a0-9 a1-5 a2-0 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod gravity-spinner-method-22 ((this gravity-spinner))
  (local-vars (a1-11 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (let* ((gp-0 (handle->process (-> this parent-hand)))
           (s3-0 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           )
      (when s3-0
        (let* ((gp-1 (-> (the-as process-focusable s3-0) root))
               (s5-0 (-> gp-1 root-prim))
               (s4-0 (-> gp-1 process node-list))
               (v1-5 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> (the-as process-focusable s3-0) root quat)))
               )
          (set! (-> v1-5 trans quad) (-> (the-as process-focusable s3-0) root trans quad))
          (when (nonzero? s4-0)
            (countdown (a0-7 (-> gp-1 total-prims))
              (when (and (= (-> s5-0 transform-index) -2) (!= s5-0 (-> gp-1 root-prim)))
                (.lvf vf5 (&-> v1-5 trans quad))
                (.lvf vf1 (&-> s5-0 local-sphere quad))
                (.lvf vf2 (&-> v1-5 rvec quad))
                (.mul.w.vf acc vf5 vf0)
                (.div.vf Q vf0 vf5 :fsf #b11 :ftf #b11)
                (.lvf vf3 (&-> v1-5 uvec quad))
                (.add.mul.x.vf acc vf2 vf1 acc)
                (.lvf vf4 (&-> v1-5 fvec quad))
                (.add.mul.y.vf acc vf3 vf1 acc)
                (.add.mul.z.vf vf1 vf4 vf1 acc :mask #b111)
                (.mul.vf vf1 vf1 Q :mask #b111)
                (.svf (&-> s5-0 prim-core world-sphere quad) vf1)
                (.mov a1-11 vf1)
                )
              (&+! s5-0 80)
              )
            )
          )
        )
      )
    (none)
    )
  )

(defmethod get-float-speed ((this gravity-spinner))
  (let* ((s4-0 (handle->process (-> this parent-hand)))
         (s5-0 (if (type? s4-0 process-focusable)
                   s4-0
                   )
               )
         )
    (when s5-0
      (let ((f0-2 (- (- (-> (get-trans (the-as process-focusable s5-0) 3) y)
                        (-> (the-as process-focusable s5-0) root root-prim local-sphere w)
                        )
                     (-> this ground-height)
                     )
                  )
            )
        (cond
          ((< f0-2 4096.0)
           (* 10.0 (seconds-per-frame) (- 4096.0 f0-2))
           )
          ((< 14336.0 f0-2)
           (let* ((f0-5 (+ -14336.0 f0-2))
                  (f0-7 (* f0-5 f0-5))
                  (f0-9 (* 0.00008138021 (- f0-7)))
                  (f0-10 (fmax -61440.0 f0-9))
                  )
             (* 10.0 (seconds-per-frame) f0-10)
             )
           )
          (else
            0.0
            )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch float vs none.
(defmethod probe-ground ((this gravity-spinner))
  (let* ((s4-0 (handle->process (-> this parent-hand)))
         (s5-0 (if (type? s4-0 process-focusable)
                   s4-0
                   )
               )
         )
    (when s5-0
      (let ((s4-1 (get-trans (the-as process-focusable s5-0) 3))
            (s3-0 (new 'stack-no-clear 'collide-query))
            )
        0.0
        (vector+float*! (-> s3-0 start-pos) s4-1 *up-vector* 24576.0)
        (set! (-> s3-0 move-dist quad) (the-as uint128 0))
        (set! (-> s3-0 move-dist y) -81920.0)
        (let ((v1-8 s3-0))
          (set! (-> v1-8 radius) 40.96)
          (set! (-> v1-8 collide-with) (collide-spec backgnd))
          (set! (-> v1-8 ignore-process0) #f)
          (set! (-> v1-8 ignore-process1) #f)
          (set! (-> v1-8 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-8 action-mask) (collide-action solid))
          )
        (set! (-> this ground-height)
              (if (>= (fill-and-probe-using-line-sphere *collide-cache* s3-0) 0.0)
                  (-> s3-0 best-other-tri intersect y)
                  (fmin
                    (- (-> s4-1 y) (-> (the-as process-focusable s5-0) root root-prim local-sphere w))
                    (-> (target-pos 0) y)
                    )
                  )
              )
        )
      )
    )
  (none)
  )

(define *gravity-origin-pos* (new 'static 'vector))

(defbehavior gravity-spinner-init-by-other gravity-spinner ((arg0 handle) (arg1 object) (arg2 time-frame))
  (stack-size-set! (-> self main-thread) 512)
  (set! (-> self parent-hand) arg0)
  (set! (-> self time-subtract) arg2)
  (set! (-> self cached-damage) 0.0)
  (set! (-> self was-hit-previously?) #f)
  (let* ((s5-1 (handle->process (-> self parent-hand)))
         (gp-1 (if (type? s5-1 process-focusable)
                   s5-1
                   )
               )
         )
    (when gp-1
      (set! (-> self original-sphere-offset quad)
            (-> (the-as process-focusable gp-1) root root-prim local-sphere quad)
            )
      (set! (-> *gravity-origin-pos* quad) (-> (get-trans (the-as process-focusable gp-1) 3) quad))
      (iterate-prims
        (-> (the-as process-focusable gp-1) root)
        (lambda :behavior gravity-spinner
          ((arg0 collide-shape-prim))
          (case (-> arg0 prim-core prim-type)
            ((-1)
             (set! (-> self obj-radius)
                   (fmax
                     (-> self obj-radius)
                     (+ (vector-vector-distance (the-as vector (-> arg0 prim-core)) *gravity-origin-pos*)
                        (-> arg0 prim-core world-sphere w)
                        )
                     )
                   )
             )
            )
          (none)
          )
        )
      (set! (-> self obj-radius)
            (fmin (-> self obj-radius) (-> (the-as process-focusable gp-1) root root-prim local-sphere w))
            )
      (when (not (logtest? (process-mask vehicle) (-> gp-1 mask)))
        (set! (-> self obj-radius) (* 0.75 (-> self obj-radius)))
        (set! (-> (the-as process-focusable gp-1) root root-prim local-sphere w) (-> self obj-radius))
        (set! (-> (the-as process-focusable gp-1) root root-prim prim-core world-sphere w) (-> self obj-radius))
        )
      (let* ((v1-23 (get-trans (the-as process-focusable gp-1) 3))
             (s5-4 (vector-! (new 'stack-no-clear 'vector) v1-23 (the-as vector arg1)))
             (s4-1 (new 'stack-no-clear 'vector))
             )
        (set! (-> s4-1 quad) (-> v1-23 quad))
        (let* ((f0-8 (- (-> s5-4 y)))
               (f0-9 (if (< f0-8 0.0)
                         (fmax f0-8 (-> (the-as process-focusable gp-1) root root-prim local-sphere w))
                         (fmin f0-8 (-> (the-as process-focusable gp-1) root root-prim local-sphere w))
                         )
                     )
               )
          (+! (-> s4-1 y) f0-9)
          )
        (vector+!
          s5-4
          s5-4
          (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> (the-as process-focusable gp-1) root transv) 1.0)
          )
        (let ((a0-17 s5-4))
          (set! (-> a0-17 quad) (-> s5-4 quad))
          (set! (-> a0-17 y) 0.0)
          (vector-normalize! a0-17 1.0)
          )
        (let* ((s3-1 vector-rotate-around-axis!)
               (s2-2 s5-4)
               (s1-0 s5-4)
               (f30-0 -1820.4445)
               (f28-0 3640.889)
               (v1-39 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-40 (the-as number (logior #x3f800000 v1-39)))
               )
          (s3-1 s2-2 (the-as quaternion s1-0) (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-40)))) *up-vector*)
          )
        (let ((f0-18 (* 0.000061035156 (-> self obj-radius))))
          0.0
          (let* ((f30-1 (lerp 1.0 0.2 f0-18))
                 (s3-2 s5-4)
                 (s2-3 s5-4)
                 (f28-1 12288.0)
                 (f26-0 8192.0)
                 (v1-46 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                 (v1-47 (the-as number (logior #x3f800000 v1-46)))
                 )
            (vector-float*! s3-2 s2-3 (* f30-1 (+ f28-1 (* f26-0 (+ -1.0 (the-as float v1-47))))))
            )
          )
        (gravity-spinner-method-16 self s4-1 s5-4)
        )
      (if (logtest? (process-mask vehicle) (-> gp-1 mask))
          (go-virtual zero-g-vehicle)
          (go-virtual zero-g)
          )
      )
    )
  )

(defmethod handle-impact ((this gravity-spinner) (arg0 symbol))
  (local-vars
    (sv-144 sphere)
    (sv-148 process)
    (sv-152 vector)
    (sv-156 float)
    (sv-160 float)
    (sv-164 vector)
    (sv-168 symbol)
    (sv-172 float)
    (sv-1728 vector)
    (sv-1732 vector)
    (sv-1736 float)
    (sv-2304 vector)
    (sv-2308 vector)
    (sv-2312 float)
    )
  (let* ((s3-0 (handle->process (-> this parent-hand)))
         (s5-0 (if (type? s3-0 process-focusable)
                   s3-0
                   )
               )
         )
    (when s5-0
      (set! sv-144 (new 'stack 'sphere))
      (set! sv-148 (the-as process (send-event *target* 'get-vehicle)))
      (let ((v1-7 (new 'stack-no-clear 'vector)))
        (set! (-> v1-7 quad) (-> (the-as process-focusable s5-0) root transv quad))
        (set! sv-152 v1-7)
        )
      (set! sv-156 (the-as float 0.0))
      (set! sv-160 (the-as float 102400.0))
      (set! sv-164 (new 'stack-no-clear 'vector))
      (set! sv-168 (the-as symbol #f))
      (set! sv-172 (the-as float 40960000.0))
      (if arg0
          (set! sv-160 (the-as float 163840.0))
          )
      (set! sv-156 (vector-normalize-ret-len! sv-152 1.0))
      (set! (-> sv-144 quad) (-> (get-trans (the-as process-focusable s5-0) 3) quad))
      (set! (-> sv-144 r) sv-160)
      (let ((s3-2 (new 'stack-no-clear 'array 'collide-shape 384)))
        (countdown (s2-0 (fill-actor-list-for-box *actor-hash* sv-144 s3-2 384))
          (let* ((s1-0 (-> s3-2 s2-0))
                 (a0-15 (if (type? s1-0 collide-shape)
                            s1-0
                            )
                        )
                 )
            (when a0-15
              (let* ((s1-1 (-> a0-15 process))
                     (a0-17 (if (type? s1-1 process-focusable)
                                s1-1
                                )
                            )
                     )
                (when a0-17
                  (when (and (!= s5-0 a0-17)
                             (not (focus-test? (the-as process-focusable a0-17) disable dead inactive gun-no-target))
                             (logtest? (process-mask enemy guard civilian) (-> a0-17 mask))
                             (not (focus-test? (the-as process-focusable a0-17) no-gravity))
                             (!= a0-17 sv-148)
                             )
                    (set! sv-1728 (get-trans (the-as process-focusable a0-17) 3))
                    (set! sv-1732 (new 'stack-no-clear 'vector))
                    (set! sv-1736 (the-as float 0.0))
                    (vector-! sv-1732 sv-1728 (the-as vector sv-144))
                    (set! sv-1736 (vector-normalize-ret-len! sv-1732 1.0))
                    (when (and (>= sv-160 sv-1736) (< sv-1736 sv-172) (< sv-1736 (* 4.5 sv-156)))
                      (let ((f30-0 (vector-dot sv-152 sv-1732))
                            (f0-12 0.707)
                            )
                        (if arg0
                            (set! f0-12 0.5)
                            )
                        (when (< f0-12 f30-0)
                          (let ((a1-19 (new 'stack 'collide-query)))
                            (set! (-> a1-19 start-pos quad) (-> sv-144 quad))
                            (vector-! (-> a1-19 move-dist) sv-1728 (-> a1-19 start-pos))
                            (let ((v1-53 a1-19))
                              (set! (-> v1-53 radius) (* 0.8 (-> (the-as process-focusable s5-0) root root-prim prim-core world-sphere w)))
                              (set! (-> v1-53 collide-with) (collide-spec backgnd obstacle))
                              (set! (-> v1-53 ignore-process0) #f)
                              (set! (-> v1-53 ignore-process1) #f)
                              (set! (-> v1-53 ignore-pat)
                                    (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                                    )
                              (set! (-> v1-53 action-mask) (collide-action solid))
                              )
                            (when (< (fill-and-probe-using-line-sphere *collide-cache* a1-19) 0.0)
                              (set! sv-172 (* sv-1736 (* f30-0 f30-0)))
                              (set! sv-168 #t)
                              (let ((f0-18 sv-156))
                                (when arg0
                                  (set! f0-18 (fmin (fmax sv-156 (* 1.5 sv-1736)) (* 3.0 sv-156)))
                                  (if (-> this was-hit-previously?)
                                      (set! f0-18 (fmin f0-18 (* 2.0 sv-156)))
                                      )
                                  )
                                (vector-normalize-copy! sv-164 sv-1732 f0-18)
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (let* ((s2-1 *target*)
             (s3-3 (if (type? s2-1 process-focusable)
                       s2-1
                       )
                   )
             )
        (when (and s3-3 (< (vector-vector-distance (get-trans s3-3 0) sv-144) (-> sv-144 r)))
          (when (and (!= s5-0 s3-3)
                     (not (focus-test? s3-3 disable dead inactive gun-no-target))
                     (logtest? (process-mask enemy guard civilian) (-> s3-3 mask))
                     (not (focus-test? s3-3 no-gravity))
                     (!= s3-3 sv-148)
                     )
            (set! sv-2304 (get-trans s3-3 3))
            (set! sv-2308 (new 'stack-no-clear 'vector))
            (set! sv-2312 (the-as float 0.0))
            (vector-! sv-2308 sv-2304 (the-as vector sv-144))
            (set! sv-2312 (vector-normalize-ret-len! sv-2308 1.0))
            (when (and (>= sv-160 sv-2312) (< sv-2312 sv-172) (< sv-2312 (* 4.5 sv-156)))
              (let ((f30-1 (vector-dot sv-152 sv-2308))
                    (f0-28 0.707)
                    )
                (if arg0
                    (set! f0-28 0.5)
                    )
                (when (< f0-28 f30-1)
                  (let ((a1-29 (new 'stack 'collide-query)))
                    (set! (-> a1-29 start-pos quad) (-> sv-144 quad))
                    (vector-! (-> a1-29 move-dist) sv-2304 (-> a1-29 start-pos))
                    (let ((v1-103 a1-29))
                      (set! (-> v1-103 radius) (* 0.8 (-> (the-as process-focusable s5-0) root root-prim prim-core world-sphere w)))
                      (set! (-> v1-103 collide-with) (collide-spec backgnd obstacle))
                      (set! (-> v1-103 ignore-process0) #f)
                      (set! (-> v1-103 ignore-process1) #f)
                      (set! (-> v1-103 ignore-pat)
                            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                            )
                      (set! (-> v1-103 action-mask) (collide-action solid))
                      )
                    (when (< (fill-and-probe-using-line-sphere *collide-cache* a1-29) 0.0)
                      (set! sv-172 (* sv-2312 (* f30-1 f30-1)))
                      (set! sv-168 #t)
                      (let ((f0-34 sv-156))
                        (when arg0
                          (set! f0-34 (fmin (fmax sv-156 (* 1.5 sv-2312)) (* 3.0 sv-156)))
                          (if (-> this was-hit-previously?)
                              (set! f0-34 (fmin f0-34 (* 2.0 sv-156)))
                              )
                          )
                        (vector-normalize-copy! sv-164 sv-2308 f0-34)
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (when sv-168
        (let ((v0-1 (-> (the-as process-focusable s5-0) root transv)))
          (set! (-> v0-1 quad) (-> sv-164 quad))
          v0-1
          )
        )
      )
    )
  )

(defmethod gravity-spinner-method-16 ((this gravity-spinner) (arg0 vector) (arg1 vector))
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 float))
  (let* ((s2-0 (handle->process (-> this parent-hand)))
         (s4-0 (if (type? s2-0 process-focusable)
                   s2-0
                   )
               )
         )
    (when s4-0
      (set! sv-48 (vector-! (new 'stack-no-clear 'vector) arg0 (get-trans (the-as process-focusable s4-0) 3)))
      (set! sv-52 (new 'stack-no-clear 'vector))
      (let ((f30-0 1.0)
            (f0-0 (gravity-spinner-method-18 this s4-0))
            (f1-1 (fmin 12288.0 (-> (the-as process-focusable s4-0) root root-prim prim-core world-sphere w)))
            )
        (set! sv-56 (/ f30-0 (* f0-0 (* f1-1 f1-1))))
        )
      (vector-cross! sv-52 sv-48 arg1)
      (vector+float*! (-> this rotation-accel) (-> this rotation-accel) sv-52 sv-56)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch quaternion vs none.
(defmethod rotate! ((this gravity-spinner) (arg0 quaternion))
  (let* ((s4-0 (handle->process (-> this parent-hand)))
         (s5-0 (if (type? s4-0 process-focusable)
                   s4-0
                   )
               )
         )
    (when s5-0
      (let* ((s4-1 (get-trans (the-as process-focusable s5-0) 3))
             (s3-1 (vector-! (new 'stack-no-clear 'vector) (-> (the-as process-focusable s5-0) root trans) s4-1))
             )
        (let ((s2-0 (new 'stack-no-clear 'matrix)))
          (quaternion->matrix s2-0 arg0)
          (vector-matrix*! s3-1 s3-1 s2-0)
          )
        (set! (-> (the-as process-focusable s5-0) root root-prim local-sphere x) (- (-> s3-1 x)))
        (set! (-> (the-as process-focusable s5-0) root root-prim local-sphere y) (- (-> s3-1 y)))
        (set! (-> (the-as process-focusable s5-0) root root-prim local-sphere z) (- (-> s3-1 z)))
        (vector+! (-> (the-as process-focusable s5-0) root trans) s4-1 s3-1)
        )
      (quaternion*!
        (-> (the-as process-focusable s5-0) root quat)
        arg0
        (-> (the-as process-focusable s5-0) root quat)
        )
      (quaternion-normalize! (-> (the-as process-focusable s5-0) root quat))
      )
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod update-rotation ((this gravity-spinner) (arg0 symbol))
  (cond
    ((< (current-time) (+ (-> this end-time) (seconds -0.2)))
     (let ((s5-1 (new 'stack-no-clear 'vector)))
       (set! (-> s5-1 quad) (-> this rotation-accel quad))
       0.0
       (let* ((f0-1 (vector-normalize-ret-len! s5-1 1.0))
              (f0-2 (* 182.04445 f0-1))
              (f0-3 (* 360.0 f0-2))
              (f0-4 (* 0.2 f0-3))
              (f30-0 (fmin 116508.445 f0-4))
              (s4-0 (handle->process (-> this parent-hand)))
              )
         (if (if (type? s4-0 process-focusable)
                 s4-0
                 )
             (rotate! this (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) s5-1 (* f30-0 (seconds-per-frame))))
             )
         )
       )
     (if (< 0.2 (vector-length (-> this rotation-accel)))
         (vector-float*! (-> this rotation-accel) (-> this rotation-accel) (- 1.0 (* 0.2 (seconds-per-frame))))
         )
     )
    (else
      (let* ((s3-1 (handle->process (-> this parent-hand)))
             (s4-2 (if (type? s3-1 process-focusable)
                       s3-1
                       )
                   )
             )
        (when s4-2
          (let ((s2-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> (the-as process-focusable s4-2) root quat)))
                (s3-2 (new 'stack-no-clear 'quaternion))
                (f30-1 (* 4.0 (seconds-per-frame)))
                )
            (let ((a0-18 s2-0))
              (set! (-> a0-18 quad) (-> s2-0 quad))
              (set! (-> a0-18 y) 0.0)
              (vector-normalize! a0-18 1.0)
              )
            (quaternion-look-at! s3-2 s2-0 *up-vector*)
            (let ((s2-1 (quaternion-copy! (new 'stack-no-clear 'quaternion) (-> (the-as process-focusable s4-2) root quat))))
              (if arg0
                  (quaternion-copy! s2-1 s3-2)
                  (quaternion-slerp! s2-1 s2-1 s3-2 f30-1)
                  )
              (let ((a1-16
                      (quaternion*!
                        (new 'stack-no-clear 'quaternion)
                        s2-1
                        (quaternion-inverse! (new 'stack-no-clear 'quaternion) (-> (the-as process-focusable s4-2) root quat))
                        )
                      )
                    )
                (rotate! this a1-16)
                )
              )
            )
          )
        )
      )
    )
  (none)
  )

(defstate zero-g-vehicle (gravity-spinner)
  :virtual #t
  :enter (behavior ()
    (let* ((gp-0 (current-time))
           (f30-0 300.0)
           (f28-0 6.0)
           (f26-0 2.0)
           (v1-5 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-6 (the-as number (logior #x3f800000 v1-5)))
           )
      (set! (-> self end-time)
            (+ gp-0
               (the int
                    (* f30-0
                       (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-6))))
                       (if (logtest? (game-secrets gun-upgrade-dark-2) (-> *game-info* secrets))
                           1.5
                           1.0
                           )
                       )
                    )
               )
            )
      )
    (set! (-> self end-time) (- (-> self end-time) (-> self time-subtract)))
    (set! (-> self end-time) (the-as time-frame (max (-> self end-time) (+ (current-time) (seconds 2)))))
    (send-event
      (handle->process (-> self parent-hand))
      'attack
      #f
      (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                          (damage 0.0)
                                                          (vehicle-damage-factor 1.0)
                                                          (vehicle-impulse-factor 1.0)
                                                          (mode 'eco-dark)
                                                          (attacker-velocity *zero-vector*)
                                                          (penetrate-using (penetrate explode jak-dark-blackhole))
                                                          )
                          )
      )
    )
  :code (behavior ()
    (until (< (-> self end-time) (current-time))
      (suspend)
      )
    (let* ((f0-1 (+ 0.5 (* 0.0625 (-> self cached-damage))))
           (f0-2 (fmin 0.9 f0-1))
           )
      (send-event (handle->process (-> self parent-hand)) 'gun-dark-2-off f0-2)
      )
    (let ((gp-0 (handle->process (-> self parent-hand))))
      (if (if (type? gp-0 process-focusable)
              gp-0
              )
          (send-event
            (handle->process (-> self parent-hand))
            'attack
            #f
            (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                (damage 0.0)
                                                                (vehicle-damage-factor 1.0)
                                                                (vehicle-impulse-factor 1.0)
                                                                (penetrate-using (penetrate vehicle))
                                                                (vector *zero-vector*)
                                                                (attacker-velocity *zero-vector*)
                                                                (mode 'gravity-end)
                                                                )
                                )
            )
          )
      )
    )
  )

;; WARN: Return type mismatch int vs object.
(defbehavior zero-g-wait-for-land gravity-spinner ()
  (let ((gp-0 (current-time)))
    (until (time-elapsed? gp-0 (seconds 1.5))
      (let* ((s4-0 (handle->process (-> self parent-hand)))
             (s5-0 (if (type? s4-0 process-focusable)
                       s4-0
                       )
                   )
             )
        (cond
          ((and s5-0
                (not (logtest? (-> (the-as process-focusable s5-0) focus-status) (focus-status disable dead inactive)))
                )
           (if (or (< (- (-> (get-trans (the-as process-focusable s5-0) 3) y)
                         (-> (the-as process-focusable s5-0) root root-prim local-sphere w)
                         )
                      (-> self ground-height)
                      )
                   (let ((s4-1 (-> (the-as process-focusable s5-0) root)))
                     (and (if (type? s4-1 collide-shape-moving)
                              s4-1
                              )
                          (logtest? (-> (the-as collide-shape-moving (-> (the-as process-focusable s5-0) root)) status)
                                    (collide-status on-surface touch-surface)
                                    )
                          )
                     )
                   )
               (return (the-as object 0))
               )
           (when (not (logtest? (process-mask vehicle) (-> (the-as process-focusable s5-0) mask)))
             (let ((s4-2 (new 'stack 'sphere)))
               (vector-lerp!
                 s4-2
                 (-> (the-as process-focusable s5-0) root root-prim local-sphere)
                 (-> self original-sphere-offset)
                 (* 3.0 (seconds-per-frame))
                 )
               (set! (-> s4-2 r) (lerp
                                   (-> (the-as process-focusable s5-0) root root-prim local-sphere w)
                                   (-> self original-sphere-offset r)
                                   (* 3.0 (seconds-per-frame))
                                   )
                     )
               (set! (-> (the-as process-focusable s5-0) root root-prim local-sphere quad) (-> s4-2 quad))
               )
             (if (>= (+ (current-time) (seconds -1)) gp-0)
                 (set! (-> (the-as process-focusable s5-0) root root-prim local-sphere quad)
                       (-> self original-sphere-offset quad)
                       )
                 )
             )
           )
          (else
            (return (the-as object 0))
            )
          )
        )
      (suspend)
      )
    )
  (the-as int #f)
  )

(define *zero-g-fake-attack-vec* (new 'static 'vector :y -0.001 :w 1.0))

(defstate zero-g (gravity-spinner)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (sv-32 vector) (sv-36 float) (sv-40 uint) (sv-48 uint))
    (case message
      (('get-float-speed)
       (get-float-speed self)
       )
      (('update-rotation)
       (update-rotation self #f)
       )
      (('impact)
       (handle-impact self #f)
       (let ((s5-1 (handle->process (-> self parent-hand))))
         (when (if (type? s5-1 process-focusable)
                   s5-1
                   )
           (let ((f0-0 (vector-length (the-as vector (-> block param 1)))))
             0.0
             (when (< 40960.0 f0-0)
               (let ((f30-0 (* 0.000024414063 f0-0)))
                 (format 0 "Receving impact damage ~f~%" f30-0)
                 (+! (-> self cached-damage) f30-0)
                 )
               )
             )
           )
         )
       (gravity-spinner-method-16 self (the-as vector (-> block param 0)) (the-as vector (-> block param 1)))
       )
      (('is-gravity)
       #t
       )
      (('attack-forward)
       (if (!= proc (handle->process (-> self parent-hand)))
           (return 0)
           )
       (set! sv-32 (vector-normalize-copy! (new 'stack-no-clear 'vector) (the-as vector (-> block param 0)) 1.0))
       (set! sv-36 (the-as float 0.0))
       (set! sv-40 (-> block param 2))
       (set! sv-48 (-> block param 3))
       (set! sv-36 (if (logtest? (attack-mask damage) (-> (the-as attack-info sv-40) mask))
                       (-> (the-as attack-info sv-40) damage)
                       (penetrate-using->damage (the-as penetrate sv-48))
                       )
             )
       (vector-float*! sv-32 sv-32 (fmin 184320.0 (vector-length (the-as vector (-> block param 4)))))
       (if (!= sv-48 1024)
           (vector-float*! sv-32 sv-32 (* 2.0 sv-36))
           )
       (set! (-> sv-32 y) (* 0.15 (-> sv-32 y)))
       (+! (-> self cached-damage) sv-36)
       (let ((s4-0 (if (type? proc process-focusable)
                       proc
                       )
                   )
             )
         (when s4-0
           (vector-float*! sv-32 sv-32 (fmax 0.5 (gravity-spinner-method-18 self s4-0)))
           (vector+float*!
             (-> (the-as process-drawable s4-0) root transv)
             (-> (the-as process-drawable s4-0) root transv)
             sv-32
             1.0
             )
           (let ((f0-17 (vector-normalize-ret-len! (-> (the-as process-drawable s4-0) root transv) 1.0)))
             (vector-float*!
               (-> (the-as process-drawable s4-0) root transv)
               (-> (the-as process-drawable s4-0) root transv)
               (fmin 143360.0 f0-17)
               )
             )
           (handle-impact self #t)
           (gravity-spinner-method-16 self (the-as vector (-> block param 5)) sv-32)
           )
         )
       (when (< 0.0 sv-36)
         (let ((v0-0 (the-as object #t)))
           (set! (-> self was-hit-previously?) (the-as symbol v0-0))
           v0-0
           )
         )
       )
      )
    )
  :enter (behavior ()
    (let* ((gp-0 (current-time))
           (f30-0 300.0)
           (f28-0 7.0)
           (f26-0 2.0)
           (v1-5 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-6 (the-as number (logior #x3f800000 v1-5)))
           )
      (set! (-> self end-time)
            (+ gp-0
               (the int
                    (* f30-0
                       (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-6))))
                       (if (logtest? (game-secrets gun-upgrade-dark-2) (-> *game-info* secrets))
                           1.5
                           1.0
                           )
                       )
                    )
               )
            )
      )
    (set! (-> self end-time) (- (-> self end-time) (-> self time-subtract)))
    (set! (-> self end-time) (the-as time-frame (max (-> self end-time) (+ (current-time) (seconds 2)))))
    (send-event
      (handle->process (-> self parent-hand))
      'attack
      #f
      (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                          (damage 0.0)
                                                          (vehicle-damage-factor 1.0)
                                                          (vehicle-impulse-factor 1.0)
                                                          (mode 'eco-dark)
                                                          (attacker (process->handle *target*))
                                                          (attacker-velocity *zero-vector*)
                                                          (penetrate-using (penetrate explode jak-dark-blackhole))
                                                          )
                          )
      )
    )
  :code (behavior ()
    (until (< (-> self end-time) (current-time))
      (when (< (-> self next-ground-probe-time) (current-time))
        (probe-ground self)
        (set! (-> self next-ground-probe-time)
              (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 61) 60 (current-time)))
              )
        )
      (suspend)
      )
    (send-event (handle->process (-> self parent-hand)) 'gun-dark-2-off)
    (let* ((s5-0 (handle->process (-> self parent-hand)))
           (gp-0 (if (type? s5-0 process-focusable)
                     s5-0
                     )
                 )
           )
      (when gp-0
        (update-rotation self #t)
        (quaternion-normalize! (-> (the-as process-focusable gp-0) root quat))
        (send-event
          (handle->process (-> self parent-hand))
          'attack
          #f
          (static-attack-info
            :mask (vehicle-impulse-factor)
            ((id (new-attack-id))
             (damage 0.2)
             (vehicle-damage-factor 1.0)
             (vehicle-impulse-factor 1.0)
             (penetrate-using (penetrate vehicle))
             (vector (-> (the-as process-focusable gp-0) root transv))
             (attacker-velocity (-> (the-as process-focusable gp-0) root transv))
             (mode 'gravity-end)
             (attacker (process->handle *target*))
             )
            )
          )
        (let ((f0-5
                (- (- (-> (get-trans (the-as process-focusable gp-0) 3) y)
                      (-> (the-as process-focusable gp-0) root root-prim local-sphere w)
                      )
                   (-> self ground-height)
                   )
                )
              )
          0.0
          (set! (-> self cached-damage) (* 2.0 (-> self cached-damage)))
          (let* ((f0-6 (* 0.00012207031 f0-5))
                 (f0-7 (fmax 1.0 f0-6))
                 )
            (+! (-> self cached-damage) f0-7)
            )
          )
        (let* ((gp-1 (-> (the-as process-focusable gp-0) root))
               (v1-37 (if (type? gp-1 collide-shape-moving)
                          gp-1
                          )
                      )
               )
          (if v1-37
              (logclear! (-> (the-as collide-shape-moving v1-37) status) (collide-status on-surface touch-surface))
              )
          )
        )
      )
    (probe-ground self)
    (zero-g-wait-for-land)
    (send-event
      (handle->process (-> self parent-hand))
      'attack
      #f
      (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                          (damage (-> self cached-damage))
                                                          (vehicle-damage-factor 1.0)
                                                          (vehicle-impulse-factor 1.0)
                                                          (penetrate-using (penetrate vehicle))
                                                          (vector *zero-g-fake-attack-vec*)
                                                          (attacker-velocity *zero-g-fake-attack-vec*)
                                                          (mode 'eco-dark)
                                                          (attacker (process->handle *target*))
                                                          )
                          )
      )
    (let* ((s5-1 (handle->process (-> self parent-hand)))
           (gp-2 (if (type? s5-1 process-focusable)
                     s5-1
                     )
                 )
           )
      (when gp-2
        (set! (-> (the-as process-focusable gp-2) root root-prim local-sphere quad)
              (-> self original-sphere-offset quad)
              )
        (let ((s5-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> (the-as process-focusable gp-2) root quat))))
          (new 'stack-no-clear 'vector)
          (let ((a0-67 s5-2))
            (set! (-> a0-67 quad) (-> s5-2 quad))
            (set! (-> a0-67 y) 0.0)
            (vector-normalize! a0-67 1.0)
            )
          (quaternion-look-at! (-> (the-as process-focusable gp-2) root quat) s5-2 *up-vector*)
          )
        )
      )
    )
  :post (behavior ()
    (spawn-part self)
    (if (>= (-> self end-time) (current-time))
        (gravity-spinner-method-22 self)
        )
    )
  )

(defskelgroup skel-gun-dark-2-ring gun gun-dark-2-ring-lod0-jg gun-dark-2-ring-idle-ja
              ((gun-dark-2-ring-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0.5 84)
              :longest-edge (meters 80)
              :shadow gun-dark-2-ring-shadow-mg
              )

(define *gun-gravity-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #x9a))
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 163840.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -163840.0)
                                           :shadow-type 2
                                           )
                               )
  )

(deftype gravity-ring (process-drawable)
  ((start-pos       vector               :inline)
   (jmod-outer      joint-mod-add-local  :inline)
   (jmod-inner      joint-mod-add-local  :inline)
   (ring-scale-t    float)
   (current-radius  float)
   (max-radius      float)
   (reverse?        symbol)
   (total-time      float)
   (ring-width      float)
   (stop-time       time-frame)
   )
  (:state-methods
    expand
    )
  (:methods
    (gravity-ring-method-21 (_type_) none)
    )
  )


(defbehavior gravity-ring-init-by-other gravity-ring ((arg0 vector) (arg1 symbol) (arg2 float) (arg3 float) (arg4 float) (arg5 time-frame))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-identity! (-> self root quat))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-dark-2-ring" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self draw shadow-ctrl) *gun-gravity-shadow-control*)
  (init (-> self jmod-inner) self (the-as uint 4) (joint-mod-base-flags attached scale))
  (init (-> self jmod-outer) self (the-as uint 3) (joint-mod-base-flags attached scale))
  (let ((v1-13 (-> self draw shadow-ctrl)))
    (logclear! (-> v1-13 settings flags) (shadow-flags disable-draw))
    )
  0
  (logclear! (-> self draw status) (draw-control-status no-draw))
  (set! (-> self total-time) arg3)
  (set! (-> self reverse?) arg1)
  (set! (-> self max-radius) arg2)
  (set! (-> self ring-width) arg4)
  (+! (-> self root trans y) (-> self max-radius))
  (ja-post)
  (setup-masks (-> self draw) 0 1)
  (set-time! (-> self state-time))
  (set! (-> self stop-time) arg5)
  (go-virtual expand)
  )

(defstate expand (gravity-ring)
  :virtual #t
  :trans (behavior ()
    (gravity-ring-method-21 self)
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    )
  )

;; WARN: Return type mismatch float vs none.
(defmethod gravity-ring-method-21 ((this gravity-ring))
  (let* ((a0-1 *time-of-day-context*)
         (v1-0 (-> a0-1 light-group))
         (s4-0 (-> v1-0 0 ambi color))
         (s5-0 (new 'stack-no-clear 'vector))
         )
    (-> a0-1 current-prt-color)
    (-> a0-1 current-env-color)
    (vector4-lerp! s5-0 (-> v1-0 0 dir0 color) (-> v1-0 0 dir1 color) (-> v1-0 0 dir1 extra x))
    (fmax (fmax (-> s4-0 x) (-> s4-0 y)) (-> s4-0 z))
    (fmax (fmax (-> s5-0 x) (-> s5-0 y)) (-> s5-0 z))
    (let* ((f0-10 (+ (* 0.2 (-> s4-0 x)) (* 0.75 (-> s4-0 y)) (* 0.05 (-> s4-0 z))))
           (f1-12 (+ (* 0.2 (-> s5-0 x)) (* 0.75 (-> s5-0 y)) (* 0.05 (-> s5-0 z))))
           (f0-12 (* 0.5 (+ f0-10 f1-12)))
           (f30-0 (lerp-scale-clamp 0.0 1.0 f0-12 0.0 1.0))
           (s5-1 (new 'stack 'rgbaf))
           (s3-0 (new 'stack 'rgbaf))
           (s4-1 0)
           )
      (cond
        ((or (= (status-of-level-and-borrows *level* 'desert #f) 'active)
             (= (status-of-level-and-borrows *level* 'waswide #f) 'active)
             (= (status-of-level-and-borrows *level* 'wasdoors #f) 'active)
             )
         (set-vector! s5-1 0.85 1.1 1.1 0.25)
         )
        (else
          (set-vector! s5-1 0.4 2.0 2.0 0.25)
          (set-vector! s3-0 0.7 1.15 1.15 0.25)
          (vector-lerp! s5-1 s5-1 s3-0 f30-0)
          )
        )
      (set! (-> s5-1 w) 0.25)
      (let ((t1-0
              (logior (logand (logior (logand (logior (logand (logior (logand s4-1 -256) (shr (shl (the int (* 127.5 (-> s5-1 x))) 56) 56)) -65281)
                                                      (shr (shl (the int (* 127.5 (-> s5-1 y))) 56) 48)
                                                      )
                                              -16711681
                                              )
                                      (shr (shl (the int (* 127.5 (-> s5-1 z))) 56) 40)
                                      )
                              (the-as uint #xffffffff00ffffff)
                              )
                      (shr (shl (the int (* 127.5 (-> s5-1 w))) 56) 32)
                      )
              )
            )
        (set-setting! 'highlight-color #f 0.0 t1-0)
        )
      )
    )
  (let* ((f0-38 (-> this total-time))
         (f24-0 (/ (* 0.0033333334 (the float (- (current-time) (-> this state-time)))) f0-38))
         )
    0.0
    (let ((f30-1 (-> this ring-width))
          (f22-0 1.0)
          )
      1.0
      (let ((f26-0 1.1)
            (f28-0 0.5)
            )
        (set! (-> this max-radius) 102400.0)
        (if (-> this reverse?)
            (set! f24-0 (- 1.0 f24-0))
            )
        (if (time-elapsed? (-> this state-time) (the int (* 1800.0 f0-38)))
            (set! f28-0
                  (lerp
                    f28-0
                    0.0
                    (fmax 0.0 (fmin 1.0 (- (* 0.0033333334 (the float (- (current-time) (-> this state-time)))) (* 6.0 f0-38))))
                    )
                  )
            )
        (if (= f28-0 0.0)
            (go empty-state)
            )
        (let ((f26-1
                (+ (-> this ring-scale-t)
                   (* (cond
                        ((time-elapsed? (-> this stop-time) (the int (* 300.0 f26-0)))
                         (let ((f1-27 1.0))
                           (lerp
                             0.5
                             0.05
                             (fmax 0.0 (fmin 1.0 (/ (- (* 0.0033333334 (the float (- (current-time) (-> this stop-time)))) f26-0) f1-27)))
                             )
                           )
                         )
                        ((>= f22-0 f24-0)
                         (lerp 2.3 0.4 (/ f24-0 f22-0))
                         )
                        (else
                          0.4
                          )
                        )
                      (seconds-per-frame)
                      )
                   )
                )
              )
          (let ((f24-1 (* 0.00024414062 (* (-> this max-radius) f26-1))))
            0.0
            0.0
            0.0
            (let* ((f0-56 f26-1)
                   (f0-57 (* f0-56 f0-56))
                   (f1-33 (fmax (lerp f30-1 0.0 f0-57) f28-0))
                   (f0-60 (fmax 0.0 (- f24-1 f1-33)))
                   )
              (set-vector! (-> this jmod-outer transform scale) f24-1 1.0 f24-1 1.0)
              (set-vector! (-> this jmod-inner transform scale) f0-60 1.0 f0-60 1.0)
              )
            )
          (set! (-> this ring-scale-t) f26-1)
          )
        )
      )
    )
  (none)
  )

(deftype gun-gravity (process-drawable)
  ((current-radius  float)
   (max-radius      float)
   (lowest-y        float)
   (start-pos       vector  :inline)
   (total-time      float)
   (ring-closest    handle)
   (ring-furthest   handle)
   (gravity-sound   sound-id)
   )
  (:state-methods
    expand
    )
  (:methods
    (gun-gravity-method-21 (_type_) none)
    (gun-gravity-method-22 (_type_ symbol) none)
    (spawn-gravity-spinner (_type_ process) (pointer gravity-spinner))
    (gun-gravity-method-24 (_type_) none)
    )
  )


(defbehavior gun-gravity-init-by-other gun-gravity ((arg0 vector) (arg1 vector))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (let ((s4-0 (new 'stack-no-clear 'collide-query)))
    0.0
    (vector+float*! (-> s4-0 start-pos) (-> self root trans) *up-vector* 24576.0)
    (set! (-> s4-0 move-dist quad) (the-as uint128 0))
    (set! (-> s4-0 move-dist y) -81920.0)
    (let ((v1-7 s4-0))
      (set! (-> v1-7 radius) 40.96)
      (set! (-> v1-7 collide-with) (collide-spec backgnd pusher))
      (set! (-> v1-7 ignore-process0) #f)
      (set! (-> v1-7 ignore-process1) #f)
      (set! (-> v1-7 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-7 action-mask) (collide-action solid))
      )
    (if (>= (fill-and-probe-using-line-sphere *collide-cache* s4-0) 0.0)
        (set! (-> self root trans y) (-> s4-0 best-other-tri intersect y))
        )
    )
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 153 (seconds 0.2))
  (let ((s4-1 quaternion-look-at!)
        (s3-0 (-> self root quat))
        (a0-12 (new 'stack-no-clear 'vector))
        )
    (set! (-> a0-12 quad) (-> arg1 quad))
    (set! (-> a0-12 y) 0.0)
    (s4-1 s3-0 (vector-normalize! a0-12 1.0) *up-vector*)
    )
  (set! (-> self max-radius) 122880.0)
  (set! (-> self total-time) 1.0)
  (if (logtest? (game-secrets gun-upgrade-dark-2) (-> *game-info* secrets))
      (set! (-> self total-time) (* 1.5 (-> self total-time)))
      )
  (set! (-> self start-pos quad) (-> arg0 quad))
  (set! (-> self ring-closest) (the-as handle #f))
  (set! (-> self ring-furthest) (the-as handle #f))
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 118) self))
  (set! (-> self gravity-sound) (new-sound-id))
  (go-virtual expand)
  )

(defmethod deactivate ((this gun-gravity))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this gravity-sound))
  (call-parent-method this)
  (none)
  )

(defstate expand (gun-gravity)
  :virtual #t
  :enter (behavior ()
    (set! (-> self lowest-y) (-> self root trans y))
    (set-time! (-> self state-time))
    (sound-play "grav-gun" :id (-> self gravity-sound) :position (-> self root trans))
    )
  :trans (behavior ()
    (cond
      ((not (time-elapsed? (-> self state-time) (the int (* 300.0 (-> self total-time)))))
       (let* ((f0-4 (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
              (f1-3 (-> self total-time))
              (f0-6 (/ (- f0-4 (* (the float (the int (/ f0-4 f1-3))) f1-3)) (-> self total-time)))
              )
         (set! (-> self current-radius) (* (-> self max-radius) f0-6))
         )
       (gun-gravity-method-22 self #f)
       )
      (else
        (if (not (time-elapsed? (-> self state-time) (the int (* 2025.0 (-> self total-time)))))
            (gun-gravity-method-22 self #t)
            )
        )
      )
    (cond
      ((not (time-elapsed? (-> self state-time) (the int (* 2025.0 (-> self total-time)))))
       (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> self root trans))))
         0.0
         (let ((gp-0 (new 'stack-no-clear 'vector)))
           (let ((f0-16 (fmin (vector-normalize-ret-len! s5-1 1.0) (-> self current-radius))))
             (vector+float*! gp-0 (-> self root trans) s5-1 f0-16)
             )
           (sound-play "grav-gun" :id (-> self gravity-sound) :position gp-0)
           )
         )
       (dotimes (gp-1 6)
         (let* ((s5-2 vector-rotate-around-y!)
                (s4-0 (new 'stack-no-clear 'vector))
                (s3-0 *x-vector*)
                (f30-0 65536.0)
                (v1-27 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                (v1-28 (the-as number (logior #x3f800000 v1-27)))
                (s4-1 (s5-2 s4-0 s3-0 (* f30-0 (+ -1.0 (the-as float v1-28)))))
                (s5-3 (new 'stack-no-clear 'vector))
                )
           0.0
           0.0
           (let* ((f30-1 (-> self current-radius))
                  (f28-0 (fmax 0.0 (+ -40960.0 (-> self current-radius))))
                  (s3-1 s5-3)
                  (s2-0 (-> self root trans))
                  (v1-33 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                  (v1-34 (the-as number (logior #x3f800000 v1-33)))
                  )
             (vector+float*! s3-1 s2-0 s4-1 (+ f28-0 (* (+ -1.0 (the-as float v1-34)) (- f30-1 f28-0))))
             )
           (let ((s4-2 (new 'stack-no-clear 'collide-query)))
             0.0
             (vector+float*! (-> s4-2 start-pos) s5-3 *up-vector* 24576.0)
             (set! (-> s4-2 move-dist quad) (the-as uint128 0))
             (set! (-> s4-2 move-dist y) -81920.0)
             (let ((v1-40 s4-2))
               (set! (-> v1-40 radius) 40.96)
               (set! (-> v1-40 collide-with) (collide-spec backgnd pusher))
               (set! (-> v1-40 ignore-process0) #f)
               (set! (-> v1-40 ignore-process1) #f)
               (set! (-> v1-40 ignore-pat)
                     (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                     )
               (set! (-> v1-40 action-mask) (collide-action solid))
               )
             (when (>= (fill-and-probe-using-line-sphere *collide-cache* s4-2) 0.0)
               (let ((f30-2 (-> s4-2 best-other-tri intersect y))
                     (a1-7 (matrix-identity! (new 'stack-no-clear 'matrix)))
                     )
                 (set! (-> a1-7 trans quad) (-> s4-2 start-pos quad))
                 (set! (-> a1-7 trans y) f30-2)
                 (spawn-from-mat (-> self part) a1-7)
                 )
               )
             )
           )
         )
       )
      (else
        (sound-stop (-> self gravity-sound))
        )
      )
    )
  :code (behavior ()
    (let ((f30-0 4.0)
          (gp-0 (current-time))
          )
      (until #f
        (dotimes (s5-0 5)
          (let ((v1-7 (ppointer->handle (process-spawn
                                          gravity-ring
                                          (-> self root trans)
                                          #f
                                          (-> self max-radius)
                                          (-> self total-time)
                                          f30-0
                                          gp-0
                                          :name "gravity-ring"
                                          :to self
                                          )
                                        )
                      )
                (a0-6 s5-0)
                )
            (cond
              ((zero? a0-6)
               (set! (-> self ring-furthest) (the-as handle v1-7))
               )
              ((= a0-6 4)
               (set! (-> self ring-closest) (the-as handle v1-7))
               )
              )
            )
          (set! f30-0 (+ -0.6 f30-0))
          (let ((s4-1 (current-time)))
            (until (time-elapsed? s4-1 (seconds 0.15))
              (suspend)
              )
            )
          )
        (let ((s5-1 (current-time)))
          (until (time-elapsed? s5-1 (seconds 13.5))
            (suspend)
            )
          )
        (go empty-state)
        (set! f30-0 4.0)
        )
      )
    #f
    )
  )

;; WARN: Return type mismatch (pointer process) vs (pointer gravity-spinner).
(defmethod spawn-gravity-spinner ((this gun-gravity) (arg0 process))
  (process-spawn
    gravity-spinner
    (process->handle arg0)
    (-> this root trans)
    (- (current-time) (-> this state-time))
    :name "gravity-spinner"
    :to arg0
    )
  )

;; WARN: Return type mismatch (pointer gravity-spinner) vs none.
(defmethod gun-gravity-method-22 ((this gun-gravity) (arg0 symbol))
  (local-vars (v1-29 symbol) (v1-49 symbol))
  (with-pp
    (let ((s5-0 (new 'stack-no-clear 'vector))
          (a1-1 (new 'stack-no-clear 'event-message-block))
          )
      (set! (-> a1-1 from) (process->ppointer pp))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'get-vehicle)
      (let ((s4-0 (the-as process (send-event-function *target* a1-1)))
            (f30-0 0.0)
            (f28-0 (-> this current-radius))
            )
        (set! (-> s5-0 quad) (-> this root trans quad))
        (when arg0
          (let ((v1-5 (handle->process (-> this ring-closest))))
            (if v1-5
                (set! f30-0 (* (-> (the-as gravity-ring v1-5) max-radius) (-> (the-as gravity-ring v1-5) ring-scale-t)))
                )
            )
          (let ((v1-8 (handle->process (-> this ring-furthest))))
            (if v1-8
                (set! f28-0 (* (-> (the-as gravity-ring v1-8) max-radius) (-> (the-as gravity-ring v1-8) ring-scale-t)))
                )
            )
          (set! f28-0 (* 0.85 f28-0))
          (set! f30-0 (* 0.85 f30-0))
          (set! (-> this current-radius) (* 0.5 (+ f30-0 f28-0)))
          )
        (set! (-> s5-0 w) f28-0)
        (let ((s3-1 (new 'stack-no-clear 'array 'collide-shape 384)))
          (countdown (s2-0 (fill-actor-list-for-box *actor-hash* s5-0 s3-1 384))
            (let* ((s1-0 (-> s3-1 s2-0))
                   (v1-17 (if (type? s1-0 collide-shape)
                              s1-0
                              )
                          )
                   )
              (when v1-17
                (let* ((s0-0 (-> v1-17 process))
                       (s1-1 (if (type? s0-0 process-focusable)
                                 s0-0
                                 )
                             )
                       )
                  (when s1-1
                    (when (and (!= *target* s1-1)
                               (not (focus-test? (the-as process-focusable s1-1) disable dead inactive))
                               (logtest? (process-mask crate enemy guard vehicle civilian) (-> s1-1 mask))
                               (!= s4-0 s1-1)
                               )
                      (let ((f0-6 (vector-vector-distance (get-trans (the-as process-focusable s1-1) 3) s5-0)))
                        (when (and (>= f28-0 f0-6) (>= f0-6 f30-0))
                          (let ((v1-27 (-> s1-1 child)))
                            (while v1-27
                              (when (= (-> v1-27 0 type) gravity-spinner)
                                (set! v1-29 #t)
                                (goto cfg-47)
                                )
                              (set! v1-27 (-> v1-27 0 brother))
                              )
                            )
                          (set! v1-29 #f)
                          (label cfg-47)
                          (if (not v1-29)
                              (spawn-gravity-spinner this s1-1)
                              )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (let* ((s2-1 *target*)
               (s3-2 (if (type? s2-1 process-focusable)
                         s2-1
                         )
                     )
               )
          (when (and s3-2 (< (vector-vector-distance (get-trans s3-2 0) s5-0) (-> s5-0 w)))
            (when (and (!= *target* s3-2)
                       (not (focus-test? s3-2 disable dead inactive))
                       (logtest? (process-mask crate enemy guard vehicle civilian) (-> s3-2 mask))
                       (!= s4-0 s3-2)
                       )
              (let ((f0-8 (vector-vector-distance (get-trans s3-2 3) s5-0)))
                (when (and (>= f28-0 f0-8) (>= f0-8 f30-0))
                  (let ((v1-47 (-> s3-2 child)))
                    (while v1-47
                      (when (= (-> v1-47 0 type) gravity-spinner)
                        (set! v1-49 #t)
                        (goto cfg-79)
                        )
                      (set! v1-47 (-> v1-47 0 brother))
                      )
                    )
                  (set! v1-49 #f)
                  (label cfg-79)
                  (if (not v1-49)
                      (spawn-gravity-spinner this s3-2)
                      )
                  )
                )
              )
            )
          )
        )
      )
    (none)
    )
  )

(defbehavior gun-fire-dark-2 target ()
  (set-last-fire-time 36)
  (cond
    ((logtest? (-> *part-group-id-table* 120 flags) (sp-group-flag sp13))
     (set! (-> *launch-matrix* trans quad) (-> self gun fire-point quad))
     (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 120))
     )
    (else
      (set! (-> *launch-matrix* trans quad) (-> self gun fire-point quad))
      (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 120))
      )
    )
  (process-spawn
    gun-gravity
    (-> self gun fire-point)
    (-> self gun fire-dir-out)
    :name "gun-gravity"
    :to (ppointer->process (-> self gun gun))
    )
  )

(defbehavior target-gun-fire-dark target ((arg0 pickup-type))
  (case arg0
    (((pickup-type gun-dark-1))
     (gun-fire-dark-1)
     )
    (((pickup-type gun-dark-2))
     (gun-fire-dark-2)
     )
    (((pickup-type gun-dark-3))
     (gun-fire-dark-3)
     )
    )
  )
