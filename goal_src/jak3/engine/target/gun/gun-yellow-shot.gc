;;-*-Lisp-*-
(in-package goal)

;; name: gun-yellow-shot.gc
;; name in dgo: gun-yellow-shot
;; dgos: GAME

;; DECOMP BEGINS

(deftype gun-yellow-shot (projectile)
  ((hit-actor?         symbol)
   (tail-pos           vector  :inline)
   (hit-pos            vector  :inline)
   (last-hit-time      time-frame)
   (snd-whoosh         sound-id)
   (muzzle-flash-part  sparticle-launcher)
   (main-shot-part     sparticle-launcher)
   (shot-aim-part      sparticle-launcher)
   (shot-ring-part     sparticle-launcher)
   )
  (:methods
    (draw-main-shot (_type_ vector vector) none)
    (gun-yellow-shot-method-42 (_type_ float float matrix) none)
    (spawn-particles (_type_ vector) none)
    )
  )


(deftype gun-yellow-2-proc-ignore (structure)
  ((hand  handle)
   (time  time-frame)
   )
  :pack-me
  )


(deftype gun-yellow-shot-2 (gun-yellow-shot)
  ((last-collide-time        time-frame)
   (snd-trail                sound-id)
   (hit-yet?                 symbol)
   (actor-deflect?           symbol)
   (max-actor-deflect-count  int32)
   (last-hit-enemy           handle)
   (delay-attack             time-frame)
   (delay-norm               vector                    :inline)
   (enemy-hit-count          int32)
   (ignore-list              gun-yellow-2-proc-ignore  6 :inline)
   (last-attack-time         time-frame)
   )
  (:methods
    (on-impact (_type_ handle) object)
    (handle-impact (_type_ handle) object)
    (is-in-ignore-list? (_type_ handle) symbol)
    (add-to-ignore-list! (_type_ handle) int)
    )
  )


(deftype gun-yellow-shot-3 (gun-yellow-shot)
  ()
  )


(deftype gun-yellow-3-saucer (projectile-bounce)
  ((total-float-time        time-frame)
   (firing?                 symbol  :offset 568)
   (asleep?                 symbol)
   (first-fire-time         time-frame)
   (activated?              symbol)
   (collided-with-surface?  symbol)
   (last-deflect-time       time-frame)
   (last-fire-time          time-frame)
   (spawn-part              sparticle-launch-control)
   (last-blink-time         time-frame)
   (finished?               symbol)
   (initial-fire-dir        vector  :inline)
   (initial-fire-pos        vector  :inline)
   (last-deduct-ammo-time   time-frame)
   (total-ammo-drained      float)
   (total-ammo-to-drain     float)
   (total-fire-time         time-frame)
   (snd-hum                 sound-id)
   (snd-shoot               sound-id)
   )
  (:state-methods
    undefined
    navigating
    spinning
    impact-explode
    falling-down
    burnt-husk
    )
  (:methods
    (start-firing (_type_) none)
    (init-antigrav (_type_) none)
    (find-targets (_type_) int)
    (spawn-shot (_type_ vector) (pointer gun-yellow-shot-3))
    )
  (:states
    gun-yellow-3-saucer-base-state
    )
  )


(defmethod relocate ((this gun-yellow-3-saucer) (offset int))
  (call-parent-method this offset)
  )

(deftype target-quality-info-saucer (structure)
  ((targ   handle)
   (value  float)
   )
  )


;; WARN: Return type mismatch (pointer process) vs (pointer gun-yellow-shot-3).
(defmethod spawn-shot ((this gun-yellow-3-saucer) (arg0 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 x) (rand-vu-float-range -1.0 1.0))
    (set! (-> s5-0 y) (rand-vu-float-range -1.0 1.0))
    (set! (-> s5-0 z) (rand-vu-float-range -1.0 1.0))
    (set! (-> s5-0 w) 1.0)
    (vector+float*! arg0 arg0 s5-0 4096.0)
    )
  (let ((s5-2 (vector-! (new 'stack-no-clear 'vector) arg0 (-> this root trans)))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (vector-normalize! s5-2 1.0)
    (set! (-> s3-0 quad) (-> s5-2 quad))
    (set! (-> s3-0 y) 0.0)
    (vector-normalize! s3-0 1228.8)
    (vector+! s3-0 (-> this root trans) s3-0)
    (+! (-> s3-0 y) -819.2)
    (let ((s4-1 (new 'stack-no-clear 'projectile-init-by-other-params)))
      (set! (-> s4-1 ent) (-> this entity))
      (set! (-> s4-1 charge) 1.0)
      (set! (-> s4-1 options) (projectile-options))
      (logclear! (-> s4-1 options) (projectile-options po14 po15 po16))
      (set! (-> s4-1 pos quad) (-> s3-0 quad))
      (set! (-> s4-1 notify-handle) (the-as handle #f))
      (set! (-> s4-1 owner-handle) (the-as handle #f))
      (set! (-> s4-1 target-handle) (the-as handle #f))
      (set! (-> s4-1 target-pos quad) (the-as uint128 0))
      (set! (-> s4-1 ignore-handle) (process->handle (send-event *target* 'get-vehicle)))
      (let* ((v1-20 *game-info*)
             (a0-20 (+ (-> v1-20 attack-id) 1))
             )
        (set! (-> v1-20 attack-id) a0-20)
        (set! (-> s4-1 attack-id) a0-20)
        )
      (set! (-> s4-1 timeout) (seconds 4))
      (vector-float*! (-> s4-1 vel) s5-2 819200.0)
      (the-as (pointer gun-yellow-shot-3) (spawn-projectile gun-yellow-shot-3 s4-1 this *default-dead-pool*))
      )
    )
  )

(defmethod projectile-method-32 ((this gun-yellow-3-saucer))
  (if (not (do-fire-backcheck (-> this root trans) (-> this root transv)))
      (go (method-of-object this impact-explode))
      (call-parent-method this)
      )
  0
  (none)
  )

(defmethod find-targets ((this gun-yellow-3-saucer))
  (local-vars
    (sv-16 int)
    (sv-1072 vector)
    (sv-1076 (inline-array target-quality-info-saucer))
    (sv-1080 int)
    (sv-1088 float)
    (sv-3792 (pointer int8))
    (sv-3800 int)
    (sv-3808 float)
    (sv-3812 symbol)
    )
  (if (not (-> this firing?))
      (return 0)
      )
  (sound-play "yellow3-shot" :id (-> this snd-shoot))
  (if (not (time-elapsed? (-> this last-fire-time) (seconds 0.05)))
      (return 0)
      )
  (set-time! (-> this last-fire-time))
  (when (and (time-elapsed? (-> this last-deduct-ammo-time) (seconds 0.1)) (< (-> this total-ammo-drained) 50.0))
    (+! (-> this total-ammo-drained) (adjust-player-ammo-over-time
                                       (the-as int (- (current-time) (-> this last-deduct-ammo-time)))
                                       (/ 50.0 (* 0.0033333334 (the float (-> this total-fire-time))))
                                       (pickup-type ammo-yellow)
                                       (- 50.0 (-> this total-ammo-drained))
                                       )
        )
    (set-time! (-> this last-deduct-ammo-time))
    )
  (set! sv-16 2)
  (set! sv-1072 (new 'stack-no-clear 'vector))
  (set! sv-1076 (new 'stack-no-clear 'inline-array 'target-quality-info-saucer 66))
  (set! sv-1080 0)
  (set! sv-1088 (the-as float 0.0))
  (set! (-> sv-1072 quad) (-> this root trans quad))
  (set! (-> sv-1072 w) 143360.0)
  (let ((s5-0 (new 'stack-no-clear 'array 'collide-shape 384)))
    (countdown (s4-0 (fill-actor-list-for-box *actor-hash* sv-1072 s5-0 384))
      (let* ((s3-0 (-> s5-0 s4-0))
             (v1-34 (if (type? s3-0 collide-shape)
                        s3-0
                        )
                    )
             )
        (when v1-34
          (let* ((s2-0 (-> v1-34 process))
                 (s3-1 (if (type? s2-0 process-focusable)
                           s2-0
                           )
                       )
                 )
            (when s3-1
              (when (and (!= *target* s3-1)
                         (not (focus-test? (the-as process-focusable s3-1) disable dead inactive gun-no-target))
                         (pc-check-focus-fix (the-as process-focusable s3-1)) ;; og:preserve-this
                         (or (logtest? (process-mask enemy vehicle civilian) (-> s3-1 mask))
                             (and (logtest? (process-mask guard) (-> s3-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                             )
                         )
                (let ((s2-1 (new 'stack-no-clear 'collide-query)))
                  (set! (-> s2-1 start-pos quad) (-> this root trans quad))
                  (vector-! (-> s2-1 move-dist) (get-trans (the-as process-focusable s3-1) 3) (-> this root trans))
                  (let ((v1-47 s2-1))
                    (set! (-> v1-47 radius) 40.96)
                    (set! (-> v1-47 collide-with) (collide-spec backgnd))
                    (set! (-> v1-47 ignore-process0) #f)
                    (set! (-> v1-47 ignore-process1) #f)
                    (set! (-> v1-47 ignore-pat)
                          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                          )
                    (set! (-> v1-47 action-mask) (collide-action solid))
                    )
                  (when (< (fill-and-probe-using-line-sphere *collide-cache* s2-1) 0.0)
                    (set! (-> sv-1076 sv-1080 targ) (process->handle s3-1))
                    (let ((f0-11 1.0))
                      (if (and (nonzero? (-> s3-1 draw)) (logtest? (-> s3-1 draw status) (draw-control-status on-screen)))
                          (set! f0-11 (+ 2.0 f0-11))
                          )
                      (if (logtest? (process-mask enemy guard) (-> s3-1 mask))
                          (set! f0-11 (+ 28.0 f0-11))
                          )
                      (if (logtest? (process-mask vehicle civilian) (-> s3-1 mask))
                          (set! f0-11 (* 0.25 f0-11))
                          )
                      (set! (-> sv-1076 sv-1080 value) f0-11)
                      (set! sv-1088 (+ sv-1088 f0-11))
                      )
                    (set! sv-1080 (+ sv-1080 1))
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  ;; og:preserve-this *snip* there was dead code here!
  (set! sv-3792 (new 'stack-no-clear 'array 'int8 100))
  (set! sv-3800 0)
  (set! sv-3808 (the-as float 0.0))
  (set! sv-3812 (the-as symbol #f))
  (when (> sv-1080 0)
    (dotimes (s5-2 sv-16)
      (let ((f0-20 (rand-vu-float-range 0.0 sv-1088)))
        (dotimes (v1-127 sv-1080)
          (set! sv-3808 (+ sv-3808 (-> sv-1076 v1-127 value)))
          (when (< f0-20 sv-3808)
            (dotimes (a0-82 sv-3800)
              (when (= (-> sv-3792 a0-82) v1-127)
                0
                (goto cfg-91)
                )
              )
            (set! (-> sv-3792 sv-3800) v1-127)
            (set! sv-3800 (+ sv-3800 1))
            0
            (goto cfg-94)
            )
          (label cfg-91)
          )
        )
      (label cfg-94)
      )
    )
  (dotimes (s5-3 sv-3800)
    (let* ((s4-4 (handle->process (-> sv-1076 (-> sv-3792 s5-3) targ)))
           (a0-95 (if (type? s4-4 process-focusable)
                      s4-4
                      )
                  )
           (s4-5 this)
           (s3-4 (method-of-object s4-5 spawn-shot))
           (s2-2 (new 'stack-no-clear 'vector))
           )
      (set! (-> s2-2 quad) (-> (get-trans (the-as process-focusable a0-95) 0) quad))
      (s3-4 s4-5 s2-2)
      )
    )
  (let ((s5-4 sv-3800)
        (s4-6 (+ sv-16 -1))
        )
    (while (>= s4-6 s5-4)
      (let ((s3-5 (new 'stack-no-clear 'vector)))
        (set! (-> s3-5 x) (rand-vu-float-range -1.0 1.0))
        (set! (-> s3-5 y) (rand-vu-float-range -0.85 -0.3))
        (set! (-> s3-5 z) (rand-vu-float-range -1.0 1.0))
        (vector+float*! s3-5 (-> this root trans) s3-5 40960.0)
        (spawn-shot this s3-5)
        )
      (+! s5-4 1)
      )
    )
  (the-as int #f)
  )

(defskelgroup skel-gun-yellow-3-saucer gun gun-saucer-lod0-jg gun-saucer-idle-ja
              ((gun-saucer-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4096)
              :texture-level 10
              :sort 1
              )

(defmethod setup-collision! ((this gun-yellow-3-saucer))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) projectile-bounce-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 1638.4)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set-collide-with!
    (-> this root)
    (collide-spec backgnd crate vehicle-sphere hit-by-others-list pusher impenetrable-obj shield)
    )
  (set-collide-as! (-> this root) (collide-spec projectile))
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod init-proj-settings! ((this gun-yellow-3-saucer))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-yellow-3-saucer" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (set! (-> this move) projectile-move-fill-line-sphere)
  (set! (-> this total-float-time) (seconds 0.05))
  (quaternion-identity! (-> this root quat))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 95) this))
  (set! (-> this asleep?) #t)
  (set! (-> this firing?) #f)
  (set! (-> this first-fire-time) 0)
  (set! (-> this timeout) (seconds 30))
  (set! (-> this activated?) #f)
  (set! (-> this collided-with-surface?) #f)
  (set! (-> this last-blink-time) 0)
  (set! (-> this finished?) #f)
  (set! (-> this snd-hum) (new-sound-id))
  (set! (-> this snd-shoot) (new-sound-id))
  (set! (-> this total-ammo-to-drain) 50.0)
  (set! (-> this total-fire-time) (seconds 4))
  (when (logtest? (game-secrets gun-upgrade-yellow-3) (-> *game-info* secrets))
    (set! (-> this total-ammo-to-drain) 50.0)
    (set! (-> this total-fire-time) (seconds 6))
    )
  (set-vector! (-> this root scale) 3.5 3.5 3.5 1.0)
  (none)
  )

(defmethod deactivate ((this gun-yellow-3-saucer))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this snd-hum))
  (sound-stop (-> this snd-shoot))
  (if (nonzero? (-> this spawn-part))
      (kill-particles (-> this spawn-part))
      )
  (call-parent-method this)
  (none)
  )

(deftype gun-yellow-3-event-msg (structure)
  ((activated?  symbol)
   (finished?   symbol)
   )
  )


;; WARN: Return type mismatch time-frame vs none.
(defmethod start-firing ((this gun-yellow-3-saucer))
  (set-time! (-> this first-fire-time))
  (set! (-> this firing?) #t)
  (set! (-> this last-fire-time) 0)
  (set-time! (-> this last-deduct-ammo-time))
  (none)
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod init-antigrav ((this gun-yellow-3-saucer))
  (set! (-> this asleep?) #f)
  (set! (-> this root dynam gravity y) 0.0)
  (set! (-> this root dynam gravity-length) 0.0)
  (set! (-> this root dynam gravity-max) 0.0)
  (set-time! (-> this last-blink-time))
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod projectile-method-25 ((this gun-yellow-3-saucer))
  (if (nonzero? (-> this part))
      (spawn (-> this part) (-> this root trans))
      )
  (when (and (nonzero? (-> this part)) (not (-> this finished?)))
    )
  (let ((v1-14 (if (< (mod (- (current-time) (-> this last-blink-time)) 300) 150)
                   60
                   128
                   )
               )
        )
    (set! (-> *part-id-table* 279 init-specs 4 initial-valuef) (the float v1-14))
    (set! (-> *part-id-table* 280 init-specs 5 initial-valuef) (the float v1-14))
    (set! (-> *part-id-table* 281 init-specs 5 initial-valuef) (the float v1-14))
    (set! (-> *part-id-table* 279 init-specs 5 initial-valuef) (the float v1-14))
    (set! (-> *part-id-table* 280 init-specs 6 initial-valuef) (the float v1-14))
    (set! (-> *part-id-table* 281 init-specs 6 initial-valuef) (the float v1-14))
    )
  (none)
  )

(defmethod projectile-bounce-method-42 ((this gun-yellow-3-saucer))
  (projectile-method-25 this)
  (none)
  )

(defstate gun-yellow-3-saucer-base-state (gun-yellow-3-saucer)
  :event projectile-event-handler
  :trans (behavior ()
    (if (and (-> self firing?)
             (not (and (-> self next-state) (let ((v1-5 (-> self next-state name)))
                                              (or (= v1-5 'falling-down) (= v1-5 'impact-explode))
                                              )
                       )
                  )
             (or (< (get-remaining-player-ammo (pickup-type ammo-yellow)) 1.0)
                 (time-elapsed? (-> self first-fire-time) (-> self total-fire-time))
                 )
             )
        (go-virtual falling-down)
        )
    )
  :code sleep-code
  :post (behavior ()
    (projectile-method-25 self)
    (ja-post)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod projectile-bounce-method-43 ((this gun-yellow-3-saucer))
  (set! (-> this collided-with-surface?) #t)
  (none)
  )

(defun saucer-land-move ((arg0 gun-yellow-3-saucer))
  (seek-toward-heading-vec! (-> arg0 root) (-> arg0 root transv) 131072.0 (seconds 0.1))
  (new 'stack-no-clear 'vector)
  (let ((a2-1 (quaternion-identity! (new 'stack-no-clear 'quaternion))))
    (fmin 1.0 (* 0.006666667 (the float (- (current-time) (-> arg0 state-time)))))
    (quaternion-smooth-seek! (-> arg0 root quat) (-> arg0 root quat) a2-1 (* 3.5 (seconds-per-frame)))
    )
  (projectile-move-fill-all-dirs arg0)
  (none)
  )

(defstate sitting (gun-yellow-3-saucer)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (until (time-elapsed? (-> self state-time) (seconds 1))
      (suspend)
      )
    (go-virtual burnt-husk)
    )
  )

(defstate burnt-husk (gun-yellow-3-saucer)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (cond
      ((logtest? (-> *part-group-id-table* 97 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 97))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 97))
        )
      )
    (let ((gp-2 sound-play-by-name)
          (name (static-sound-name "yellow3-zap"))
          (a1-6 (new-sound-id))
          (a2-10 1024)
          (a3-4 0)
          )
      (gp-2 (the-as sound-name name) a1-6 a2-10 a3-4 0 (sound-group) #t)
      (set! (-> self draw color-mult quad) (the-as uint128 0))
      (set! (-> self draw color-mult x) 0.15)
      (set! (-> self draw color-mult y) 0.15)
      (set! (-> self draw color-mult z) 0.15)
      (set! (-> self draw color-emissive quad) (the-as uint128 0))
      (let ((gp-3 (new 'stack-no-clear 'matrix)))
        (matrix-u-compose
          gp-3
          (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
          (the-as vector a2-10)
          (the-as vector a3-4)
          )
        (set! (-> gp-3 trans quad) (-> self root trans quad))
        (let ((gp-4
                (ppointer->handle
                  (if (logtest? (-> *part-group-id-table* 96 flags) (sp-group-flag sp13))
                      (part-tracker-spawn
                        part-tracker-subsampler
                        :to (-> self parent 0)
                        :group (-> *part-group-id-table* 96)
                        :mat-joint gp-3
                        )
                      (part-tracker-spawn part-tracker :to (-> self parent 0) :group (-> *part-group-id-table* 96) :mat-joint gp-3)
                      )
                  )
                )
              )
          (process-spawn-function
            process
            (lambda :behavior process
              ((arg0 handle))
              (let ((s5-0 (current-time)))
                (until (time-elapsed? s5-0 (seconds 0.2))
                  (suspend)
                  )
                )
              (send-event (handle->process arg0) 'die)
              )
            gp-4
            :to self
            )
          )
        )
      )
    )
  :trans (behavior ()
    (let* ((f1-2 (* 0.016666668 (the float (- (current-time) (-> self state-time)))))
           (f0-2 (fmax 0.0 (fmin 1.0 f1-2)))
           )
      (set-vector! (-> self root scale) 3.5 (lerp 3.5 0.0 f0-2) 3.5 1.0)
      )
    )
  :code (behavior ()
    (until (time-elapsed? (-> self state-time) (seconds 0.2))
      (suspend)
      )
    (when (type? (-> self root) collide-shape)
      (let ((v1-6 (-> self root root-prim)))
        (set! (-> v1-6 prim-core collide-as) (collide-spec))
        (set! (-> v1-6 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (deactivate self)
    )
  :post ja-post
  )

(defstate falling-down (gun-yellow-3-saucer)
  :virtual #t
  :parent gun-yellow-3-saucer-base-state
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self finished?) #t)
    (set! (-> self move) projectile-bounce-move)
    (set! (-> self root dynam gravity y) 184320.0)
    (set! (-> self root dynam gravity-length) 184320.0)
    (set! (-> self root dynam gravity-max) 184320.0)
    (set! (-> self root transv quad) (the-as uint128 0))
    (set-time! (-> self state-time))
    (set! (-> self activated?) #t)
    (sound-stop (-> self snd-shoot))
    )
  :exit (behavior ()
    (set! (-> self move) saucer-land-move)
    (sound-stop (-> self snd-hum))
    )
  :trans (behavior ()
    (if (not (time-elapsed? (-> self state-time) (seconds 0.4)))
        (sound-play-by-name
          (static-sound-name "yellow3-fire")
          (-> self snd-hum)
          1024
          (the int (* 1524.0 (lerp 0.0 -0.5 (* 0.008333334 (the float (- (current-time) (-> self state-time)))))))
          0
          (sound-group)
          #t
          )
        (sound-stop (-> self snd-hum))
        )
    ((-> (method-of-type projectile moving) trans))
    (when (logtest? (-> self root status) (collide-status touch-surface))
      (sound-play "yellow3-bounce")
      (set! (-> self move) saucer-land-move)
      )
    (let ((v1-19 gun-yellow-3-saucer-base-state))
      (when v1-19
        (let ((t9-6 (-> v1-19 trans)))
          (if t9-6
              (t9-6)
              )
          )
        )
      )
    )
  )

(defstate impact-explode (gun-yellow-3-saucer)
  :virtual #t
  :event projectile-event-handler
  :enter (behavior ()
    (set! (-> self activated?) #t)
    (sound-stop (-> self snd-hum))
    )
  :code (behavior ()
    (set! (-> self firing?) #t)
    (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-0 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-0 spawn-quat))
      (set! (-> gp-0 radius) 0.0)
      (set! (-> gp-0 scale) 1.0)
      (set! (-> gp-0 group) (-> *part-group-id-table* 104))
      (set! (-> gp-0 collide-with) (collide-spec))
      (set! (-> gp-0 damage) 2.0)
      (set! (-> gp-0 damage-scale) 1.0)
      (set! (-> gp-0 vehicle-damage-factor) 1.0)
      (set! (-> gp-0 vehicle-impulse-factor) 1.0)
      (set! (-> gp-0 ignore-proc) (process->handle #f))
      (explosion-spawn gp-0 self)
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (deactivate self)
    )
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod proj-event-handler ((this gun-yellow-3-saucer) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('activate)
     (go (method-of-object this spinning))
     )
    (('query)
     (let ((v1-3 (the-as gun-yellow-3-event-msg (-> arg3 param 0))))
       (set! (-> v1-3 activated?) (-> this activated?))
       (set! (-> v1-3 finished?) (-> this finished?))
       )
     )
    (else
      (call-parent-method this arg0 arg1 arg2 arg3)
      )
    )
  #t
  )

;; WARN: Return type mismatch object vs none.
(defmethod projectile-method-39 ((this gun-yellow-3-saucer))
  (when (logtest? (-> this root status) (collide-status touch-surface))
    (if (-> this asleep?)
        (go (method-of-object this impact-explode))
        (call-parent-method this)
        )
    )
  (none)
  )

(defstate moving (gun-yellow-3-saucer)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (-> self total-float-time))
             (not (and (-> self next-state) (= (-> self next-state name) 'navigating)))
             )
        (go-virtual navigating)
        )
    (sound-play "yellow3-fire" :id (-> self snd-hum))
    (quaternion-rotate-local-y! (-> self root quat) (-> self root quat) (* 131072.0 (seconds-per-frame)))
    (let ((a0-7 gun-yellow-3-saucer-base-state))
      (when a0-7
        (let ((t9-3 (-> a0-7 trans)))
          (if t9-3
              (t9-3)
              )
          )
        )
      )
    (let ((t9-5 (-> (find-parent-state) trans)))
      (if t9-5
          (t9-5)
          )
      )
    (ja-post)
    )
  )

(defstate navigating (gun-yellow-3-saucer)
  :virtual #t
  :parent gun-yellow-3-saucer-base-state
  :enter (behavior ()
    (init-antigrav self)
    (set-time! (-> self state-time))
    (set! (-> self last-deflect-time) 0)
    0
    )
  :trans (behavior ()
    (sound-play "yellow3-fire" :id (-> self snd-hum))
    (let ((f0-1 (fmin 1.0 (* 0.033333335 (the float (- (current-time) (-> self state-time)))))))
      0.0
      (let ((f0-2 (lerp 409600.0 40960.0 f0-1)))
        (vector-normalize! (-> self root transv) f0-2)
        )
      )
    (let ((f0-4 (fmin 1.0 (* 0.004761905 (the float (- (current-time) (-> self state-time)))))))
      (set! (-> self root transv y) (lerp (-> self root transv y) 0.0 f0-4))
      )
    (when (time-elapsed? (-> self last-deflect-time) (seconds 0.5))
      (let ((v1-19 (-> self root))
            (gp-0 (new 'stack-no-clear 'collide-query))
            )
        (-> v1-19 root-prim)
        (set! (-> gp-0 start-pos quad) (-> v1-19 trans quad))
        (vector-normalize-copy! (-> gp-0 move-dist) (-> v1-19 transv) 40960.0)
        (let ((v1-20 gp-0))
          (set! (-> v1-20 radius) 0.01)
          (set! (-> v1-20 collide-with) (collide-spec backgnd))
          (set! (-> v1-20 ignore-process0) #f)
          (set! (-> v1-20 ignore-process1) #f)
          (set! (-> v1-20 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-20 action-mask) (collide-action solid))
          )
        (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
          (when (and (>= f0-7 0.0) (< f0-7 1.0))
            (let ((s5-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> gp-0 best-other-tri normal) 1.0))
                  (gp-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self root transv) 1.0))
                  )
              0.0
              (set! (-> s5-0 y) 0.0)
              (vector-normalize! s5-0 1.0)
              (vector-dot s5-0 gp-1)
              (cond
                (#f
                  (vector-float*! (-> self root transv) (-> self root transv) -1.0)
                  )
                (else
                  (vector-reflect! gp-1 gp-1 s5-0)
                  (set! (-> gp-1 y) 0.0)
                  (vector-normalize-copy! (-> self root transv) gp-1 32768.0)
                  (set-time! (-> self last-deflect-time))
                  )
                )
              )
            )
          )
        )
      )
    (when (not (-> self firing?))
      (cond
        ((time-elapsed? (-> self state-time) (seconds 1))
         (start-firing self)
         )
        (else
          )
        )
      )
    (find-targets self)
    ((-> self move) self)
    (projectile-method-39 self)
    (quaternion-rotate-local-y! (-> self root quat) (-> self root quat) (* 131072.0 (seconds-per-frame)))
    (let ((v1-52 gun-yellow-3-saucer-base-state))
      (when v1-52
        (let ((t9-16 (-> v1-52 trans)))
          (if t9-16
              (t9-16)
              )
          )
        )
      )
    )
  )

(defstate spinning (gun-yellow-3-saucer)
  :virtual #t
  :parent gun-yellow-3-saucer-base-state
  :enter (behavior ()
    (set! (-> self activated?) #t)
    (if (-> self asleep?)
        (init-antigrav self)
        )
    (if (not (-> self firing?))
        (start-firing self)
        )
    (quaternion-identity! (-> self root quat))
    )
  :exit (behavior ()
    (let ((f0-0 (get-remaining-player-ammo (pickup-type ammo-yellow))))
      0.0
      (when (< 1.0 f0-0)
        (let* ((f0-1 (fmin f0-0 (- 50.0 (-> self total-ammo-drained))))
               (f0-2 (fmax 0.0 f0-1))
               )
          (adjust-player-ammo (- f0-2) (pickup-type ammo-yellow))
          )
        (truncate-player-ammo (pickup-type ammo-yellow))
        )
      )
    )
  :trans (behavior ()
    (sound-play "yellow3-fire" :id (-> self snd-hum))
    (quaternion-rotate-local-y! (-> self root quat) (-> self root quat) (* 131072.0 (seconds-per-frame)))
    (find-targets self)
    (let ((v1-7 gun-yellow-3-saucer-base-state))
      (when v1-7
        (let ((t9-3 (-> v1-7 trans)))
          (if t9-3
              (t9-3)
              )
          )
        )
      )
    )
  )

(defbehavior gun-fire-yellow-3 target ()
  (let ((gp-0 (-> self gun)))
    (let ((s5-0 (-> self gun fire-dir-out))
          (s4-0 (-> self gun fire-point))
          (f30-0 409600.0)
          )
      (talker-spawn-func (-> *talker-speech* 364) *entity-pool* (target-pos 0) (the-as region #f))
      (set! (-> s5-0 y) 0.6)
      (vector-normalize! s5-0 1.0)
      (when (handle->process (-> gp-0 gun 0 extra))
        (let ((s3-1 (new 'stack-no-clear 'gun-yellow-3-event-msg)))
          (send-event (handle->process (-> gp-0 gun 0 extra)) 'query s3-1)
          (when (not (-> s3-1 activated?))
            (send-event (handle->process (-> gp-0 gun 0 extra)) 'activate)
            (return 0)
            )
          )
        )
      (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 229 (seconds 0.2))
      (let ((s3-2 (new 'stack-no-clear 'projectile-init-by-other-params)))
        (set! (-> s3-2 ent) (-> self entity))
        (set! (-> s3-2 charge) 1.0)
        (set! (-> s3-2 options) (projectile-options po13))
        (logclear! (-> s3-2 options) (projectile-options po14 po15 po16))
        (set! (-> s3-2 pos quad) (-> s4-0 quad))
        (set! (-> s3-2 vel quad) (-> (vector-float*! (new 'stack-no-clear 'vector) s5-0 f30-0) quad))
        (set! (-> s3-2 notify-handle) (the-as handle #f))
        (set! (-> s3-2 owner-handle) (the-as handle #f))
        (set! (-> s3-2 target-handle) (the-as handle #f))
        (set! (-> s3-2 target-pos quad) (the-as uint128 0))
        (set! (-> s3-2 ignore-handle) (process->handle (send-event self 'get-vehicle)))
        (let* ((v1-45 *game-info*)
               (a0-30 (+ (-> v1-45 attack-id) 1))
               )
          (set! (-> v1-45 attack-id) a0-30)
          (set! (-> s3-2 attack-id) a0-30)
          )
        (set! (-> s3-2 timeout) (seconds 4))
        (set! (-> gp-0 gun 0 extra)
              (ppointer->handle
                (spawn-projectile gun-yellow-3-saucer s3-2 (ppointer->process (-> gp-0 gun)) *default-dead-pool*)
                )
              )
        )
      )
    (let ((s4-1 (new 'stack-no-clear 'vector)))
      (set! (-> s4-1 quad) (-> self gun fire-dir-out quad))
      (set! (-> s4-1 y) 0.0)
      (vector-normalize! s4-1 1.0)
      (draw-beam (-> *part-id-table* 297) (-> gp-0 fire-point) s4-1 #f)
      (let ((s5-1 (new 'stack-no-clear 'matrix)))
        (matrix-f-compose s5-1 s4-1)
        (set! (-> s5-1 trans quad) (-> gp-0 fire-point quad))
        (let ((v1-62
                (if (logtest? (-> *part-group-id-table* 100 flags) (sp-group-flag sp13))
                    (part-tracker-spawn
                      part-tracker-subsampler
                      :to *entity-pool*
                      :group (-> *part-group-id-table* 100)
                      :mat-joint s5-1
                      )
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 100) :mat-joint s5-1)
                    )
                )
              )
          (send-event (ppointer->process v1-62) 'clock self)
          )
        )
      )
    )
  )

;; WARN: Return type mismatch (pointer process) vs (pointer gun-yellow-shot-2).
(defbehavior gun-fire-yellow-2 target ()
  (let ((s5-0 (-> self gun))
        (gp-0 (new 'stack-no-clear 'projectile-init-by-other-params))
        )
    (set! (-> gp-0 ent) (-> self entity))
    (set! (-> gp-0 charge) 1.0)
    (set! (-> gp-0 options) (projectile-options po17))
    (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
    (set! (-> gp-0 pos quad) (-> s5-0 fire-point quad))
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 target-handle) (the-as handle #f))
    (set! (-> gp-0 target-pos quad) (the-as uint128 0))
    (set! (-> gp-0 ignore-handle) (process->handle (send-event self 'get-vehicle)))
    (let* ((v1-12 *game-info*)
           (a0-10 (+ (-> v1-12 attack-id) 1))
           )
      (set! (-> v1-12 attack-id) a0-10)
      (set! (-> gp-0 attack-id) a0-10)
      )
    (set! (-> gp-0 timeout) (seconds 4))
    (vector-float*! (-> gp-0 vel) (-> s5-0 fire-dir-out) 819200.0)
    (the-as
      (pointer gun-yellow-shot-2)
      (spawn-projectile gun-yellow-shot-2 gp-0 (ppointer->process (-> s5-0 gun)) *default-dead-pool*)
      )
    )
  )

;; WARN: Return type mismatch (pointer process) vs (pointer gun-yellow-shot).
(defbehavior gun-fire-yellow-1 target ()
  (let ((s5-0 (-> self gun))
        (gp-0 (new 'stack-no-clear 'projectile-init-by-other-params))
        )
    (set! (-> gp-0 ent) (-> self entity))
    (set! (-> gp-0 charge) 1.0)
    (set! (-> gp-0 options) (projectile-options po17))
    (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
    (set! (-> gp-0 pos quad) (-> s5-0 fire-point quad))
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 target-handle) (the-as handle #f))
    (set! (-> gp-0 target-pos quad) (the-as uint128 0))
    (set! (-> gp-0 ignore-handle) (process->handle (send-event self 'get-vehicle)))
    (let* ((v1-12 *game-info*)
           (a0-10 (+ (-> v1-12 attack-id) 1))
           )
      (set! (-> v1-12 attack-id) a0-10)
      (set! (-> gp-0 attack-id) a0-10)
      )
    (set! (-> gp-0 timeout) (seconds 4))
    (vector-float*! (-> gp-0 vel) (-> s5-0 fire-dir-out) 819200.0)
    (the-as
      (pointer gun-yellow-shot)
      (spawn-projectile gun-yellow-shot gp-0 (ppointer->process (-> s5-0 gun)) *default-dead-pool*)
      )
    )
  )

;; WARN: disable def twice: 51. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defbehavior target-gun-can-fire-yellow? target ((arg0 pickup-type))
  (case arg0
    (((pickup-type gun-yellow-3))
     (cond
       ((handle->process (-> self gun gun 0 extra))
        (let ((gp-0 (new 'stack-no-clear 'gun-yellow-3-event-msg)))
          (set! (-> gp-0 finished?) #t)
          (set! (-> gp-0 activated?) #f)
          (send-event (handle->process (-> self gun gun 0 extra)) 'query gp-0)
          (or (-> gp-0 finished?) (not (-> gp-0 activated?)))
          )
        )
       (else
         #t
         )
       )
     )
    (else
      #t
      )
    )
  )

;; WARN: Return type mismatch object vs (pointer process).
(defbehavior target-gun-fire-yellow target ((arg0 pickup-type))
  (the-as (pointer process) (case arg0
                              (((pickup-type gun-yellow-1))
                               (gun-fire-yellow-1)
                               )
                              (((pickup-type gun-yellow-2))
                               (gun-fire-yellow-2)
                               )
                              (((pickup-type gun-yellow-3))
                               (gun-fire-yellow-3)
                               )
                              )
          )
  )

(defun someone-fire-yellow ((arg0 process-drawable) (arg1 vector) (arg2 vector))
  (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (set! (-> gp-0 ent) (-> arg0 entity))
    (set! (-> gp-0 charge) 1.0)
    (set! (-> gp-0 options) (projectile-options po13 po17))
    (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
    (set! (-> gp-0 pos quad) (-> arg1 quad))
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 target-handle) (the-as handle #f))
    (set! (-> gp-0 target-pos quad) (the-as uint128 0))
    (set! (-> gp-0 ignore-handle) (process->handle arg0))
    (let* ((v1-10 *game-info*)
           (a0-9 (+ (-> v1-10 attack-id) 1))
           )
      (set! (-> v1-10 attack-id) a0-9)
      (set! (-> gp-0 attack-id) a0-9)
      )
    (set! (-> gp-0 timeout) (seconds 4))
    (vector-normalize-copy! (-> gp-0 vel) arg2 819200.0)
    (spawn-projectile gun-yellow-shot-2 gp-0 arg0 *default-dead-pool*)
    )
  )

(defmethod projectile-method-24 ((this gun-yellow-shot))
  (draw-beam (-> this muzzle-flash-part) (-> this tail-pos) (-> this starting-dir) #f)
  0
  (none)
  )

(defmethod projectile-method-25 ((this gun-yellow-shot))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s4-0 (-> this root trans))
           (a1-0 (-> this tail-pos))
           (gp-1 (vector-! (new 'stack-no-clear 'vector) s4-0 a1-0))
           )
      (let ((f30-0 (vector-length gp-1)))
        (let ((s3-0 (new 'stack-no-clear 'vector)))
          (let ((v1-4 a1-0))
            (let ((a0-2 gp-1))
              (let ((a2-1 0.8))
                (.mov vf7 a2-1)
                )
              (.lvf vf5 (&-> a0-2 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> s3-0 quad) vf6)
          (draw-main-shot this a1-0 gp-1)
          (vector-normalize! gp-1 1.0)
          (spawn-particles this s3-0)
          )
        (let ((s3-1 (new 'stack-no-clear 'matrix))
              (f30-1 (fmin 1.0 (* 0.000015258789 f30-0)))
              (f28-0 (-> *part-id-table* 267 init-specs 3 initial-valuef))
              )
          (forward-up->inv-matrix s3-1 gp-1 *up-vector*)
          (set! (-> s3-1 trans quad) (-> s4-0 quad))
          (gun-yellow-shot-method-42 this f30-1 f28-0 s3-1)
          )
        )
      (let ((f0-3 (vector-dot gp-1 (-> (camera-matrix) fvec))))
        (when (< 0.0 f0-3)
          (let ((f2-0 (* f0-3 f0-3))
                (f0-4 (-> *part-id-table* 266 init-specs 8 initial-valuef))
                (f1-3 (-> *part-id-table* 266 init-specs 8 random-rangef))
                )
            (set! (-> *part-id-table* 266 init-specs 8 initial-valuef) (* f0-4 f2-0))
            (set! (-> *part-id-table* 266 init-specs 8 random-rangef) (* f1-3 f2-0))
            (set! (-> *part-id-table* 266 init-specs 8 initial-valuef) f0-4)
            (set! (-> *part-id-table* 266 init-specs 8 random-rangef) f1-3)
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod deal-damage! ((this gun-yellow-shot) (arg0 process) (arg1 event-message-block))
  (if (and (logtest? (process-mask guard) (-> arg0 mask))
           (not (-> *setting-control* user-current gun-target-guards?))
           )
      (set! (-> this damage) 0.0)
      )
  (let ((t9-0 (method-of-type projectile deal-damage!)))
    (when (t9-0 this arg0 arg1)
      (+! (-> *game-info* shots-hit 0) 1.0)
      (set! (-> this hit-actor?) #t)
      #t
      )
    )
  )

(defmethod projectile-method-26 ((this gun-yellow-shot))
  (let ((v1-8
          (cond
            ((-> this hit-actor?)
             (cond
               ((logtest? (-> *part-group-id-table* 102 flags) (sp-group-flag sp13))
                (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
                (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 102))
                )
               (else
                 (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
                 (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 102))
                 )
               )
             )
            ((logtest? (-> *part-group-id-table* 101 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
             (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 101))
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
              (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 101))
              )
            )
          )
        )
    (send-event (ppointer->process v1-8) 'clock this)
    )
  0
  (none)
  )

;; WARN: Return type mismatch sound-id vs none.
(defmethod play-impact-sound ((this gun-yellow-shot) (arg0 projectile-options))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (sound-play "yellow-shot-fir")
       )
      ((= v1-0 (projectile-options po0))
       (sound-play "yellow-gun-burn")
       )
      ((= v1-0 (projectile-options po1))
       (sound-play "yellow-shot-fiz")
       )
      (else
        (sound-play "yellow-shot-std" :id (-> this sound-id) :position (-> this root trans))
        )
      )
    )
  (none)
  )

(defmethod play-impact-sound ((this gun-yellow-shot-3) (arg0 projectile-options))
  0
  (none)
  )

(defmethod play-impact-sound ((this gun-yellow-shot-2) (arg0 projectile-options))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (sound-play "yellow2-fire")
       )
      ((= v1-0 (projectile-options po0))
       (sound-play "yellow2-burn")
       )
      ((= v1-0 (projectile-options po1))
       )
      ((not (-> this hit-yet?))
       (sound-play-by-name
         (static-sound-name "yellow2-trail")
         (-> this snd-trail)
         1024
         (the int
              (* 1524.0
                 (lerp 1.0 0.1 (fmax 0.0 (fmin 1.0 (* 0.011111111 (the float (- (current-time) (-> this last-hit-time)))))))
                 )
              )
         0
         (sound-group)
         #t
         )
       )
      (else
        (sound-play-by-name
          (static-sound-name "yellow2-trail")
          (-> this snd-trail)
          1024
          (the int (* 1524.0 (doppler-pitch-shift (-> this root trans) (-> this root transv))))
          0
          (sound-group)
          #t
          )
        )
      )
    )
  0
  (none)
  )

(defmethod made-impact? ((this gun-yellow-shot))
  (let ((v1-0 (-> this root))
        (t1-0 (new 'stack-no-clear 'collide-query))
        )
    (let ((a0-1 t1-0))
      (set! (-> a0-1 radius) (-> v1-0 root-prim prim-core world-sphere w))
      (set! (-> a0-1 collide-with) (-> v1-0 root-prim prim-core collide-with))
      (set! (-> a0-1 ignore-process0) this)
      (set! (-> a0-1 ignore-process1) (handle->process (-> this ignore-handle)))
      (set! (-> a0-1 ignore-pat) (-> v1-0 pat-ignore-mask))
      (set! (-> a0-1 action-mask) (collide-action solid))
      )
    (when (fill-and-try-snap-to-surface v1-0 (-> v1-0 transv) -10240.0 12697.6 -4096.0 t1-0)
      (if (logtest? (-> this root status) (collide-status touch-actor))
          (set! (-> this hit-actor?) #t)
          )
      #t
      )
    )
  )

(defun gun-yellow-shot-move ((arg0 gun-yellow-shot))
  (projectile-move-fill-line-sphere arg0)
  (let ((s5-0 (-> arg0 root)))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (vector-! s4-0 (-> arg0 tail-pos) (-> s5-0 trans))
      (let ((f0-0 (vector-length s4-0)))
        (when (< 65536.0 f0-0)
          (vector-normalize! s4-0 65536.0)
          (vector+! (-> arg0 tail-pos) (-> s5-0 trans) s4-0)
          )
        )
      )
    (when (logtest? (-> s5-0 status) (collide-status touch-surface))
      (if (logtest? (-> arg0 root status) (collide-status touch-actor))
          (set! (-> arg0 hit-actor?) #t)
          )
      (let ((v1-14 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> arg0 tail-pos) (-> s5-0 trans)) 2048.0))
            (a1-5 (-> arg0 hit-pos))
            )
        (set! (-> a1-5 quad) (-> s5-0 trans quad))
        (vector+! a1-5 a1-5 v1-14)
        (move-to-point! (-> arg0 root) a1-5)
        )
      (go (method-of-object arg0 impact))
      )
    )
  0
  (none)
  )

(define *last-hit-deflect-target-handle* (the-as (pointer process) #f))

;; WARN: Return type mismatch symbol vs none.
(defbehavior gun-yellow-shot-do-deflect gun-yellow-shot-2 ((arg0 gun-yellow-shot-2) (arg1 vector) (arg2 vector) (arg3 vector))
  (local-vars
    (sv-32 vector)
    (sv-36 gun-yellow-shot-2)
    (sv-40 process)
    (sv-80 vector)
    (sv-84 vector)
    (sv-112 vector)
    (sv-116 number)
    (sv-120 int)
    (sv-128 symbol)
    (sv-136 handle)
    (sv-1680 vector)
    (sv-1712 vector)
    (sv-1716 float)
    (sv-1720 float)
    (sv-1724 vector)
    (sv-1744 vector)
    (sv-1748 float)
    (sv-1752 float)
    )
  (let ((f0-1 (vector-dot arg2 arg3)))
    (set! sv-32 (vector-float*! (new 'stack-no-clear 'vector) arg3 (* -2.0 f0-1)))
    )
  (vector+! arg1 arg2 sv-32)
  (if (< 0.2 (-> arg1 y))
      (set! (-> arg1 y) (fmax 0.2 (-> arg2 y)))
      )
  (let ((s4-0 arg0))
    (set! sv-36 s4-0)
    (set! sv-40 (handle->process (-> sv-36 last-hit-enemy)))
    (when (and (time-elapsed? (-> sv-36 last-collide-time) (seconds 0.05)) (rand-vu-percent? 0.75))
      (set! sv-80 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 204800.0))
      (set! sv-84 (new 'stack-no-clear 'vector))
      (set! (-> sv-84 quad) (-> s4-0 root trans quad))
      (vector+! sv-84 sv-84 sv-80)
      (set! (-> sv-84 w) 409600.0)
      (set! (-> sv-80 y) 0.0)
      (vector-normalize! sv-80 1.0)
      (set! sv-112 (vector+! (new 'stack-no-clear 'vector) (-> s4-0 root trans) arg1))
      (set! sv-116 409600000000000000000000.0)
      (set! sv-120 -55041728)
      (set! sv-128 (the-as symbol #f))
      (set! sv-136 (the-as handle #f))
      (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 384)))
        (countdown (s2-0 (fill-actor-list-for-box *actor-hash* sv-84 s3-0 384))
          (let* ((s1-0 (-> s3-0 s2-0))
                 (v1-31 (if (type? s1-0 collide-shape)
                            s1-0
                            )
                        )
                 )
            (when v1-31
              (let* ((s0-0 (-> v1-31 process))
                     (s1-1 (if (type? s0-0 process-focusable)
                               s0-0
                               )
                           )
                     )
                (when s1-1
                  (when (and (!= s4-0 s1-1)
                             (!= s1-1 sv-40)
                             (not (focus-test? (the-as process-focusable s1-1) disable dead inactive gun-no-target))
                             (or (logtest? (process-mask enemy civilian) (-> s1-1 mask))
                                 (and (logtest? (process-mask guard) (-> s1-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                                 )
                             )
                    (when (or (not sv-128)
                              (logtest? (process-mask enemy guard) (-> s1-1 mask))
                              (not (is-in-ignore-list? sv-36 (process->handle s1-1)))
                              )
                      (set! sv-1680 (get-trans (the-as process-focusable s1-1) 3))
                      (set! sv-1712 (vector-! (new 'stack-no-clear 'vector) sv-1680 (-> s4-0 root trans)))
                      (set! sv-1716 (the-as float 0.0))
                      (set! (-> sv-1712 y) 0.0)
                      (set! sv-1720 (vector-normalize-ret-len! sv-1712 1.0))
                      (set! sv-1716 (vector-dot sv-1712 sv-80))
                      (when (or (< (the float sv-120) sv-1716) (and (< 0.707 sv-1716) (= sv-136 *last-hit-deflect-target-handle*)))
                        (set! sv-116 sv-1720)
                        (set! sv-120 (the int sv-1716))
                        (set! (-> sv-112 quad) (-> sv-1680 quad))
                        (set! sv-128 (logtest? (process-mask enemy) (-> s1-1 mask)))
                        (set! sv-136 (process->handle s1-1))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (let* ((s2-1 *target*)
             (s3-1 (if (type? s2-1 process-focusable)
                       s2-1
                       )
                   )
             )
        (when (and s3-1 (< (vector-vector-distance (get-trans s3-1 0) sv-84) (-> sv-84 w)))
          (when (and (!= s4-0 s3-1)
                     (!= s3-1 sv-40)
                     (not (focus-test? s3-1 disable dead inactive gun-no-target))
                     (or (logtest? (process-mask enemy civilian) (-> s3-1 mask))
                         (and (logtest? (process-mask guard) (-> s3-1 mask)) (-> *setting-control* user-current gun-target-guards?))
                         )
                     )
            (when (or (not sv-128)
                      (logtest? (process-mask enemy guard) (-> s3-1 mask))
                      (not (is-in-ignore-list? sv-36 (process->handle s3-1)))
                      )
              (set! sv-1724 (get-trans s3-1 3))
              (set! sv-1744 (vector-! (new 'stack-no-clear 'vector) sv-1724 (-> s4-0 root trans)))
              (set! sv-1748 (the-as float 0.0))
              (set! (-> sv-1744 y) 0.0)
              (set! sv-1752 (vector-normalize-ret-len! sv-1744 1.0))
              (set! sv-1748 (vector-dot sv-1744 sv-80))
              (when (or (< (the float sv-120) sv-1748) (and (< 0.707 sv-1748) (= sv-136 *last-hit-deflect-target-handle*)))
                (set! sv-116 sv-1752)
                (set! sv-120 (the int sv-1748))
                (set! (-> sv-112 quad) (-> sv-1724 quad))
                (set! sv-128 (logtest? (process-mask enemy) (-> s3-1 mask)))
                (set! sv-136 (process->handle s3-1))
                )
              )
            )
          )
        )
      (vector-! arg1 sv-112 (-> s4-0 root trans))
      (set! *last-hit-deflect-target-handle* (the-as (pointer process) sv-136))
      )
    )
  (vector-normalize! arg1 546133.3)
  (cond
    ((time-elapsed? (-> arg0 last-hit-time) (seconds 0.3))
     )
    ((time-elapsed? (-> arg0 last-hit-time) (seconds 0.05))
     )
    )
  (sound-play "yellow2-ricco")
  (set-time! (-> arg0 last-hit-time))
  (set! (-> arg0 hit-yet?) #t)
  (none)
  )

(defun gun-yellow-deflect-reaction ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (let ((s3-0 (the-as handle #f)))
    (when (and (nonzero? (-> arg1 best-other-tri collide-ptr))
               (-> arg1 best-other-tri collide-ptr)
               (let ((s1-0 (-> arg1 best-other-tri collide-ptr)))
                 (if (type? s1-0 collide-shape-prim)
                     s1-0
                     )
                 )
               )
      (let* ((s2-1 (-> arg1 best-other-tri collide-ptr))
             (a0-4 (if (type? s2-1 collide-shape-prim)
                       s2-1
                       )
                   )
             (v1-4 a0-4)
             )
        (when v1-4
          (set! s3-0 (process->handle (-> (the-as collide-shape-prim a0-4) cshape process)))
          (when (and (logtest? (collide-spec obstacle pusher) (-> (the-as collide-shape-prim v1-4) prim-core collide-as))
                     (not (logtest? (collide-spec civilian enemy vehicle-sphere vehicle-mesh-probeable)
                                    (-> (the-as collide-shape-prim v1-4) prim-core collide-as)
                                    )
                          )
                     )
            (let ((v1-7 (-> arg0 process)))
              (set! (-> (the-as gun-yellow-shot-2 v1-7) actor-deflect?) #t)
              )
            (set! s3-0 (the-as handle #f))
            )
          )
        )
      )
    (let ((s2-2 (the-as gun-yellow-shot-2 (-> arg0 process))))
      (on-impact s2-2 s3-0)
      (set! (-> s2-2 delay-attack) 0)
      )
    )
  0
  (gun-yellow-shot-do-deflect (the-as gun-yellow-shot-2 (-> arg0 process)) arg2 arg3 (-> arg0 surface-normal))
  (-> arg0 status)
  )

(defmethod setup-collision! ((this gun-yellow-shot))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction)
          (the-as (function control-info collide-query vector vector collide-status) cshape-reaction-just-move)
          )
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate jak-yellow-shot))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec projectile))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-13 prim-core collide-with)
            (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 819.2)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-15 prim-core collide-with)
            (collide-spec bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 4096.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 1))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  0
  (none)
  )

(defmethod deal-damage! ((this gun-yellow-shot-2) (arg0 process) (arg1 event-message-block))
  (if (> (-> this max-actor-deflect-count) 0)
      ((method-of-type projectile deal-damage!) this arg0 arg1)
      )
  )

(defun gun-yellow-shot-2-move ((arg0 gun-yellow-shot-2))
  (with-pp
    (projectile-move-fill-line-sphere arg0)
    (let ((s5-0 (-> arg0 root)))
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (vector-! s4-0 (-> arg0 tail-pos) (-> s5-0 trans))
        (let ((f0-0 (vector-length s4-0)))
          (when (< 65536.0 f0-0)
            (vector-normalize! s4-0 65536.0)
            (vector+! (-> arg0 tail-pos) (-> s5-0 trans) s4-0)
            )
          )
        )
      (when (not (handle->process (-> arg0 last-hit-enemy)))
        (set! (-> arg0 delay-attack) 0)
        0
        )
      (if (and (> (-> arg0 delay-attack) 0) (time-elapsed? (-> arg0 delay-attack) (seconds 0.1)))
          (logior! (-> s5-0 status) (collide-status touch-actor))
          )
      (when (or (logtest? (-> s5-0 status) (collide-status touch-surface))
                (logtest? (-> s5-0 status) (collide-status touch-actor))
                )
        (let ((s2-0 #f)
              (s3-0 #f)
              (s4-1 (the-as object #f))
              )
          (when (logtest? (-> s5-0 status) (collide-status touch-actor))
            (cond
              ((-> arg0 actor-deflect?)
               (set! (-> arg0 actor-deflect?) #f)
               )
              ((> (-> arg0 max-actor-deflect-count) 0)
               (let ((a0-16 (handle->process (-> arg0 last-hit-enemy))))
                 (when a0-16
                   (set! s2-0 #t)
                   (let ((a1-5 (new 'stack-no-clear 'event-message-block)))
                     (set! (-> a1-5 from) (process->ppointer pp))
                     (set! (-> a1-5 num-params) 0)
                     (set! (-> a1-5 message) 'prevent-bounce?)
                     (set! s4-1 (send-event-function a0-16 a1-5))
                     )
                   )
                 )
               )
              (else
                (set! s4-1 #t)
                )
              )
            )
          (when s2-0
            (when (> (-> arg0 delay-attack) 0)
              )
            (handle-impact arg0 (-> arg0 last-hit-enemy))
            )
          (if (and (> (-> arg0 delay-attack) 0) (and (time-elapsed? (-> arg0 delay-attack) (seconds 0.1)) s2-0 (not s4-1)))
              (set! s3-0 #t)
              )
          (when s3-0
            (let ((t9-4 gun-yellow-shot-do-deflect)
                  (a0-23 arg0)
                  (a1-7 (-> arg0 root transv))
                  (a2-1 (new 'stack-no-clear 'vector))
                  )
              (set! (-> a2-1 quad) (-> arg0 root transv quad))
              (t9-4 a0-23 a1-7 a2-1 (-> arg0 delay-norm))
              )
            )
          (set! (-> arg0 hit-actor?) (the-as symbol s4-1))
          )
        (set! (-> arg0 delay-attack) 0)
        (let ((v1-57 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> arg0 tail-pos) (-> s5-0 trans)) 2048.0))
              (a1-10 (-> arg0 hit-pos))
              )
          (set! (-> a1-10 quad) (-> s5-0 trans quad))
          (vector+! a1-10 a1-10 v1-57)
          (move-to-point! (-> arg0 root) a1-10)
          )
        (cond
          ((-> arg0 hit-actor?)
           (go (method-of-object arg0 impact))
           )
          (else
            (set-time! (-> arg0 last-collide-time))
            (launch-particles (-> *part-id-table* 272) (-> arg0 hit-pos))
            (launch-particles (-> *part-id-table* 273) (-> arg0 hit-pos))
            (let ((a0-32 (new 'stack-no-clear 'vector)))
              (set! (-> a0-32 quad) (-> arg0 root transv quad))
              (vector-normalize! a0-32 65536.0)
              )
            (vector+! (-> arg0 tail-pos) (-> arg0 root trans) (-> arg0 root transv))
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod init-proj-settings! ((this gun-yellow-shot))
  (+! (-> *game-info* shots-fired 0) 1.0)
  (set! (-> this hit-actor?) #f)
  (set! (-> this tail-pos quad) (-> this root trans quad))
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.1))
  (set! (-> this attack-mode) 'eco-yellow)
  (set! (-> this max-speed) 819200.0)
  (set! (-> this move) gun-yellow-shot-move)
  (set! (-> this timeout) (seconds 3))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this damage) 2.0)
  (if (logtest? (game-secrets gun-upgrade-yellow-1) (-> *game-info* secrets))
      (set! (-> this damage) 3.0)
      )
  (logior! (-> this options) (projectile-options po13))
  (set! (-> this muzzle-flash-part) (-> *part-id-table* 268))
  (set! (-> this main-shot-part) (-> *part-id-table* 264))
  (set! (-> this shot-aim-part) (-> *part-id-table* 267))
  (set! (-> this shot-ring-part) (-> *part-id-table* 266))
  0
  (none)
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defmethod init-proj-settings! ((this gun-yellow-shot-2))
  (call-parent-method this)
  (set! (-> this actor-deflect?) #f)
  (set! (-> this last-hit-enemy) (the-as handle #f))
  (set! (-> this damage) 1.5)
  (if (logtest? (game-secrets gun-upgrade-yellow-2) (-> *game-info* secrets))
      (set! (-> this damage) 2.0)
      )
  (set! (-> this snd-trail) (new-sound-id))
  (set! (-> this hit-yet?) #f)
  (sound-play "yellow2-trail" :id (-> this snd-trail) :pitch 1)
  (set! (-> this last-collide-time) 0)
  (set! (-> this move) gun-yellow-shot-2-move)
  (set! (-> this snd-whoosh) (new-sound-id))
  (dotimes (v1-9 6)
    (set! (-> this ignore-list v1-9 hand) (the-as handle #f))
    )
  (set! (-> this max-actor-deflect-count) 4)
  (set! (-> this timeout) (seconds 3))
  (when (logtest? (game-secrets gun-upgrade-yellow-2) (-> *game-info* secrets))
    (set! (-> this max-actor-deflect-count) 7)
    (set! (-> this timeout) (seconds 5))
    )
  (set! (-> this muzzle-flash-part) (-> *part-id-table* 274))
  (sound-play "yellow2-shot" :pitch 1)
  (let ((s5-1 (new 'stack-no-clear 'light-trail-tracker-spawn-params)))
    (set! (-> s5-1 tracked-obj) (process->handle this))
    (set! (-> s5-1 appearance) *yellow-shot-2-trail*)
    (set! (-> s5-1 max-num-crumbs) (the int (* 0.25 (the float (-> s5-1 appearance max-age)))))
    (set! (-> s5-1 track-immediately?) #t)
    (let* ((v1-34 (estimate-light-trail-mem-usage
                    (the-as uint (-> s5-1 max-num-crumbs))
                    (the-as uint (= (-> s5-1 appearance lie-mode) 3))
                    )
                  )
           (gp-1 (get-process *default-dead-pool* light-trail-tracker-projectile (+ v1-34 8192) 1))
           )
      (when gp-1
        (let ((t9-9 (method-of-type process activate)))
          (t9-9 gp-1 *target* "light-trail" (the-as pointer #x70004000))
          )
        (run-now-in-process gp-1 light-trail-tracker-init-by-other s5-1)
        (-> gp-1 ppointer)
        )
      )
    )
  (none)
  )

(defmethod add-to-ignore-list! ((this gun-yellow-shot-2) (arg0 handle))
  (when (and arg0 (not (is-in-ignore-list? this arg0)))
    (dotimes (v1-3 6)
      (when (not (handle->process (-> this ignore-list v1-3 hand)))
        (set! (-> this ignore-list v1-3 hand) arg0)
        (set-time! (-> this ignore-list v1-3 time))
        (return 0)
        )
      )
    (the-as int #f)
    )
  )

(defmethod is-in-ignore-list? ((this gun-yellow-shot-2) (arg0 handle))
  (if (not arg0)
      (return #f)
      )
  (dotimes (v1-2 6)
    (if (and (-> this ignore-list v1-2 hand) (time-elapsed? (-> this ignore-list v1-2 time) (seconds 0.15)))
        (set! (-> this ignore-list v1-2 hand) (the-as handle #f))
        )
    )
  (dotimes (v1-5 6)
    (if (= arg0 (-> this ignore-list v1-5 hand))
        (return #t)
        )
    )
  #f
  )

;; WARN: Return type mismatch int vs object.
(defmethod handle-impact ((this gun-yellow-shot-2) (arg0 handle))
  (when (> (-> this max-actor-deflect-count) 0)
    (let ((s5-0 (handle->process arg0)))
      (when s5-0
        (if (and (logtest? (process-mask guard) (-> s5-0 mask))
                 (not (-> *setting-control* user-current gun-target-guards?))
                 )
            (set! (-> this damage) 0.0)
            )
        (when (time-elapsed? (-> this last-attack-time) (seconds 0.25))
          (let* ((v1-15 *game-info*)
                 (a0-7 (+ (-> v1-15 attack-id) 1))
                 )
            (set! (-> v1-15 attack-id) a0-7)
            (set! (-> this attack-id) a0-7)
            )
          )
        (when (deal-damage! this s5-0 (the-as event-message-block #f))
          (set-time! (-> this last-attack-time))
          (+! (-> this enemy-hit-count) 1)
          (when (and (< 1 (-> this enemy-hit-count)) (< (-> this enemy-hit-count) 4))
            (adjust-player-ammo -1.0 (pickup-type ammo-yellow))
            (when (>= 0.0 (get-remaining-player-ammo (pickup-type ammo-yellow)))
              (set! (-> this timeout) 0)
              0
              )
            )
          (let ((v1-28 (-> this notify-handle)))
            (send-event (handle->process v1-28) 'notify 'attack s5-0)
            )
          (if (>= (-> this enemy-hit-count) 1)
              (set! (-> this damage) 1.0)
              )
          (cond
            ((logtest? (-> *part-group-id-table* 102 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
             (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 102))
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
              (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 102))
              )
            )
          (let ((v0-0 (+ (-> this max-actor-deflect-count) -1)))
            (set! (-> this max-actor-deflect-count) v0-0)
            v0-0
            )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch int vs object.
(defmethod on-impact ((this gun-yellow-shot-2) (arg0 handle))
  (let ((a1-1 (-> this last-hit-enemy)))
    (set! (-> this last-hit-enemy) arg0)
    (if (and (!= a1-1 arg0) (> (-> this delay-attack) 0))
        (handle-impact this a1-1)
        )
    )
  (set! (-> this delay-attack) 0)
  (add-to-ignore-list! this arg0)
  )

(defmethod handle-proj-hit! ((this gun-yellow-shot-2) (arg0 process) (arg1 event-message-block))
  (cond
    ((-> this hit-actor?)
     (call-parent-method this arg0 arg1)
     )
    (else
      (let ((s4-1 (the-as object (-> arg1 param 0))))
        (when (and (!= arg0 (handle->process (-> this last-hit-enemy)))
                   (!= arg0 (send-event *target* 'get-vehicle))
                   (not (is-in-ignore-list? this (process->handle arg0)))
                   )
          (new 'stack-no-clear 'vector)
          (let ((s3-0 (-> this delay-norm))
                (s1-0 (-> (the-as touching-shapes-entry s4-1) head))
                (s2-0 (new 'stack-no-clear 'vector))
                )
            (get-intersect-point s2-0 s1-0 (-> this root) (the-as touching-shapes-entry s4-1))
            (let ((v1-16
                    (get-touched-prim
                      s1-0
                      ((method-of-type touching-shapes-entry get-touched-shape) (the-as touching-shapes-entry s4-1) (-> this root))
                      (the-as touching-shapes-entry s4-1)
                      )
                    )
                  )
              (when v1-16
                (vector-! s3-0 s2-0 (the-as vector (-> v1-16 prim-core)))
                (vector-normalize! s3-0 1.0)
                (on-impact this (process->handle arg0))
                (set-time! (-> this delay-attack))
                )
              )
            )
          )
        )
      #t
      )
    )
  )

(defstate impact (gun-yellow-shot-2)
  :virtual #t
  :enter (behavior ()
    (sound-stop (-> self snd-trail))
    (let ((t9-2 (-> (find-parent-state) enter)))
      (if t9-2
          (t9-2)
          )
      )
    )
  )

;; WARN: Return type mismatch sparticle-launcher vs none.
(defmethod init-proj-settings! ((this gun-yellow-shot-3))
  (+! (-> *game-info* shots-fired 0) 1.0)
  (set! (-> this hit-actor?) #f)
  (set! (-> this tail-pos quad) (-> this root trans quad))
  (let ((f0-2 (vector-vector-xz-distance (target-pos 0) (-> this root trans))))
    (cpad-set-buzz!
      (-> *cpad-list* cpads 0)
      1
      (the int (* 255.0 (lerp-scale-clamp 0.5 0.0 f0-2 40960.0 245760.0)))
      (seconds 0.1)
      )
    )
  (set! (-> this attack-mode) 'eco-yellow)
  (set! (-> this max-speed) 819200.0)
  (set! (-> this move) gun-yellow-shot-move)
  (set! (-> this timeout) (seconds 3))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this damage) 2.0)
  (when (logtest? (game-feature feature22) (-> *game-info* features))
    (set! (-> this damage) (* 2.0 (-> this damage)))
    (set! (-> this vehicle-impulse-factor) (* 0.5 (-> this vehicle-impulse-factor)))
    )
  (logior! (-> this options) (projectile-options po13))
  (set! (-> this muzzle-flash-part) (-> *part-id-table* 275))
  (set! (-> this main-shot-part) (-> *part-id-table* 276))
  (set! (-> this shot-aim-part) (-> *part-id-table* 278))
  (set! (-> this shot-ring-part) (-> *part-id-table* 266))
  (none)
  )

(defmethod setup-collision! ((this gun-yellow-shot-2))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) gun-yellow-deflect-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec projectile))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-12 prim-core collide-with)
            (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 819.2)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-14 prim-core collide-with)
            (collide-spec bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
            )
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 4096.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 1))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  0
  (none)
  )

(defmethod draw-main-shot ((this gun-yellow-shot) (arg0 vector) (arg1 vector))
  (let ((f30-0 (-> *part-id-table* 264 init-specs 4 initial-valuef)))
    (set! (-> *part-id-table* 264 init-specs 4 initial-valuef) (fmin f30-0 (vector-length arg1)))
    (draw-beam (-> this main-shot-part) arg0 arg1 #f)
    (set! (-> *part-id-table* 264 init-specs 4 initial-valuef) f30-0)
    )
  0
  (none)
  )

(defmethod draw-main-shot ((this gun-yellow-shot-2) (arg0 vector) (arg1 vector))
  0
  (none)
  )

(defmethod deactivate ((this gun-yellow-shot-2))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this snd-trail))
  (call-parent-method this)
  (none)
  )

(defmethod draw-main-shot ((this gun-yellow-shot-3) (arg0 vector) (arg1 vector))
  (let ((f30-0 (-> *part-id-table* 276 init-specs 4 initial-valuef)))
    (set! (-> *part-id-table* 276 init-specs 4 initial-valuef) (fmin f30-0 (vector-length arg1)))
    (draw-beam (-> this main-shot-part) arg0 arg1 #f)
    (set! (-> *part-id-table* 276 init-specs 4 initial-valuef) f30-0)
    )
  0
  (none)
  )

(defmethod gun-yellow-shot-method-42 ((this gun-yellow-shot) (arg0 float) (arg1 float) (arg2 matrix))
  (set! (-> *part-id-table* 267 init-specs 3 initial-valuef) (* arg0 arg1))
  (launch-particles (-> *part-id-table* 267) arg2 :origin-is-matrix #t)
  (set! (-> *part-id-table* 267 init-specs 3 initial-valuef) arg1)
  0
  (none)
  )

(defmethod gun-yellow-shot-method-42 ((this gun-yellow-shot-2) (arg0 float) (arg1 float) (arg2 matrix))
  0
  (none)
  )

(defmethod gun-yellow-shot-method-42 ((this gun-yellow-shot-3) (arg0 float) (arg1 float) (arg2 matrix))
  (set! (-> *part-id-table* 278 init-specs 3 initial-valuef) (* arg0 arg1))
  (set! (-> *part-id-table* 278 init-specs 3 initial-valuef) arg1)
  0
  (none)
  )

(defmethod projectile-method-25 ((this gun-yellow-shot-2))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s5-0 (-> this root trans))
           (a1-0 (-> this tail-pos))
           (s4-1 (vector-! (new 'stack-no-clear 'vector) s5-0 a1-0))
           (f30-0 (vector-length s4-1))
           )
      (let ((s3-0 (new 'stack-no-clear 'vector)))
        (let ((v1-4 a1-0))
          (let ((a0-2 s4-1))
            (let ((a2-1 0.8))
              (.mov vf7 a2-1)
              )
            (.lvf vf5 (&-> a0-2 quad))
            )
          (.lvf vf4 (&-> v1-4 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s3-0 quad) vf6)
        (draw-main-shot this a1-0 s4-1)
        (vector-normalize! s4-1 1.0)
        (launch-particles (-> *part-id-table* 270) s3-0)
        )
      (let ((s3-1 (new 'stack-no-clear 'matrix))
            (f30-1 (fmin 1.0 (* 0.000015258789 f30-0)))
            (f28-0 (-> *part-id-table* 267 init-specs 3 initial-valuef))
            )
        (forward-up->inv-matrix s3-1 s4-1 *up-vector*)
        (set! (-> s3-1 trans quad) (-> s5-0 quad))
        (gun-yellow-shot-method-42 this f30-1 f28-0 s3-1)
        )
      )
    0
    (none)
    )
  )

(defmethod spawn-particles ((this gun-yellow-shot) (arg0 vector))
  (launch-particles (-> *part-id-table* 265) arg0)
  0
  (none)
  )

(defmethod spawn-particles ((this gun-yellow-shot-2) (arg0 vector))
  (launch-particles (-> *part-id-table* 270) arg0)
  0
  (none)
  )

(defmethod spawn-particles ((this gun-yellow-shot-3) (arg0 vector))
  0
  (none)
  )

(defmethod projectile-method-26 ((this gun-yellow-shot-3))
  (let ((v1-8
          (cond
            ((-> this hit-actor?)
             (cond
               ((logtest? (-> *part-group-id-table* 99 flags) (sp-group-flag sp13))
                (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
                (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 99))
                )
               (else
                 (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
                 (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 99))
                 )
               )
             )
            ((logtest? (-> *part-group-id-table* 98 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
             (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 98))
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
              (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 98))
              )
            )
          )
        )
    (send-event (ppointer->process v1-8) 'clock this)
    )
  0
  (none)
  )
