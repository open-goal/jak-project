;;-*-Lisp-*-
(in-package goal)

;; name: gun-util.gc
;; name in dgo: gun-util
;; dgos: GAME

(defmacro pc-check-focus-fix (focusable)
  `(#if PC_PORT (or (not (-> *pc-settings* fix-projectile-focus)) (logtest? (collide-action solid) (-> ,focusable root root-prim prim-core action))) #t))

;; DECOMP BEGINS

(deftype gun-eject (projectile-bounce)
  ()
  )


(defmethod init-proj-settings! ((this gun-eject))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (let ((v1-5 (-> this skel root-channel 0)))
    (set! (-> v1-5 frame-group) (-> this parent 0 skel channel 0 frame-group))
    )
  (let ((t9-3 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-3 this)
    )
  (quaternion-copy! (-> this root quat) (-> this parent 0 root quat))
  (set! (-> this timeout) (seconds 4))
  (set! (-> this root root-prim local-sphere w) 3276.8)
  (logclear! (-> this mask) (process-mask projectile))
  0
  (none)
  )

(deftype gun-mag-yellow (projectile-bounce)
  ()
  )


(defmethod init-proj-settings! ((this gun-mag-yellow))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ammo-yellow" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (set! (-> this timeout) (seconds 4))
  (sound-play "dark-shot-fire")
  0
  (none)
  )

(deftype gun-mag-red (projectile-bounce)
  ()
  )


(defmethod init-proj-settings! ((this gun-mag-red))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ammo-red" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (set! (-> this timeout) (seconds 4))
  (sound-play "dark-shot-fire")
  0
  (none)
  )

(deftype gun-mag-blue (projectile-bounce)
  ()
  )


(defmethod init-proj-settings! ((this gun-mag-blue))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ammo-blue" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (set! (-> this timeout) (seconds 4))
  (sound-play "dark-shot-fire")
  0
  (none)
  )

(deftype gun-mag-dark (projectile-bounce)
  ()
  )


(defmethod init-proj-settings! ((this gun-mag-dark))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ammo-dark" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (set! (-> this timeout) (seconds 4))
  (sound-play "dark-shot-fire")
  0
  (none)
  )

(define *beam-info* (new 'static 'beam-info))

(defun birth-func-setup-beam ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (local-vars (a0-2 float) (a0-3 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a0-1 arg2)
          (v1-0 *particle-quat*)
          )
      (cond
        ((< (-> v1-0 w) 0.0)
         (.lvf vf1 (&-> a0-1 conerot quad))
         (.lvf vf2 (&-> v1-0 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> a0-1 conerot quad) vf1)
         (.mov a0-2 vf1)
         )
        (else
          (.lvf vf1 (&-> a0-1 conerot quad))
          (.lvf vf2 (&-> v1-0 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> a0-1 conerot quad) vf1)
          (.mov a0-3 vf1)
          )
        )
      )
    (set! (-> arg2 conerot w) (-> *beam-info* y-scale))
    0
    (none)
    )
  )

(defun birth-func-laser-pointer ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (local-vars (a0-2 float) (a0-3 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a0-1 arg2)
          (v1-0 *particle-quat*)
          )
      (cond
        ((< (-> v1-0 w) 0.0)
         (.lvf vf1 (&-> a0-1 conerot quad))
         (.lvf vf2 (&-> v1-0 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> a0-1 conerot quad) vf1)
         (.mov a0-2 vf1)
         )
        (else
          (.lvf vf1 (&-> a0-1 conerot quad))
          (.lvf vf2 (&-> v1-0 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> a0-1 conerot quad) vf1)
          (.mov a0-3 vf1)
          )
        )
      )
    (set! (-> arg2 conerot w) (-> *beam-info* y-scale))
    (set! (-> arg1 user1-int16) (the-as uint (logand (/ (-> *display* base-clock frame-counter) 10) 31)))
    0
    (none)
    )
  )

(defun draw-beam ((arg0 sparticle-launcher) (arg1 vector) (arg2 vector) (arg3 symbol))
  (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 2)))
    (set! (-> s5-0 1 quad) (-> arg2 quad))
    (let ((v1-2 (get-field-spec-by-id arg0 (sp-field-id spt-scale-y))))
      (when v1-2
        (let ((f30-0 (-> v1-2 initial-valuef)))
          (if arg3
              (set! f30-0 (fmin f30-0 (vector-length arg2)))
              )
          (vector-normalize! (-> s5-0 1) f30-0)
          (set! (-> *beam-info* y-scale) f30-0)
          )
        )
      )
    (vector+! (-> s5-0 0) arg1 (-> s5-0 1))
    (when (line-in-view-frustum? arg1 (-> s5-0 0))
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (vector+float*! s3-1 arg1 (-> s5-0 1) 0.5)
        (vector-normalize! (-> s5-0 1) 1.0)
        (forward-up->quaternion *particle-quat* (-> s5-0 1) *y-vector*)
        (let ((t9-5 sp-launch-particles-var)
              (a0-12 *sp-particle-system-3d*)
              (a1-9 arg0)
              (a2-2 *launch-matrix*)
              )
          (set! (-> a2-2 trans quad) (-> s3-1 quad))
          (t9-5 a0-12 a1-9 a2-2 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
          )
        (dotimes (s5-1 2)
          (quaternion-rotate-local-z! *particle-quat* *particle-quat* 10922.667)
          (let ((t9-7 sp-launch-particles-var)
                (a0-14 *sp-particle-system-3d*)
                (a1-11 arg0)
                (a2-4 *launch-matrix*)
                )
            (set! (-> a2-4 trans quad) (-> s3-1 quad))
            (t9-7 a0-14 a1-11 a2-4 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch process-drawable vs gun.
(defmethod relocate ((this gun) (offset int))
  (dotimes (v1-0 2)
    (if (nonzero? (-> this barrel v1-0))
        (&+! (-> this barrel v1-0) offset)
        )
    )
  (dotimes (v1-3 4)
    (if (nonzero? (-> this mag v1-3))
        (&+! (-> this mag v1-3) offset)
        )
    )
  (the-as gun ((method-of-type process-drawable relocate) this offset))
  )

;; WARN: Return type mismatch prim-strip vs gun-info.
(defmethod relocate ((this gun-info) (offset int))
  (the-as gun-info (when (nonzero? (-> this strip))
                     (let ((v0-0 (&+ (-> this strip) offset)))
                       (set! (-> this strip) v0-0)
                       v0-0
                       )
                     )
          )
  )

(defbehavior gun-post gun ()
  (let ((gp-0 (ppointer->process (-> self parent))))
    (let ((s5-0 self))
      (set! self (the-as gun gp-0))
      (target-gun-compute-pos)
      (set! self s5-0)
      )
    (set! (-> self root trans quad) (-> (the-as target gp-0) gun gun-pos trans quad))
    (let ((v1-6 (-> (the-as target gp-0) gun gun-pos quat quad)))
      (set! (-> self root quat quad) v1-6)
      )
    (set! (-> self root scale quad) (-> (the-as target gp-0) gun gun-pos scale quad))
    (when (-> self read-scale)
      (let ((s5-1 (new 'stack-no-clear 'vector))
            (s4-0 (new 'stack-no-clear 'vector))
            )
        (matrix->scale (-> (the-as target gp-0) node-list data 36 bone transform) s5-1)
        (vector-float*! s5-1 s5-1 0.71428573)
        (if (< 0.0 (-> (the-as target gp-0) gun gun-daxter))
            (matrix->scale (-> (the-as target gp-0) sidekick 0 node-list data 28 bone transform) s4-0)
            )
        (vector-lerp! (-> self root scale) s5-1 s4-0 (-> (the-as target gp-0) gun gun-daxter))
        )
      )
    (set! (-> self draw light-index) (-> (the-as target gp-0) draw light-index))
    (let ((v1-28 (-> (the-as target gp-0) draw color-mult quad)))
      (set! (-> self draw color-mult quad) v1-28)
      )
    (let ((v1-30 (-> (the-as target gp-0) draw color-emissive quad)))
      (set! (-> self draw color-emissive quad) v1-30)
      )
    (set! (-> self draw force-fade) (-> (the-as target gp-0) draw force-fade))
    (set! (-> self draw global-effect) (-> (the-as target gp-0) draw global-effect))
    (set! (-> self draw death-vertex-skip) (-> self parent 0 draw death-vertex-skip))
    (set! (-> self draw death-effect) (-> self parent 0 draw death-effect))
    (set! (-> self draw death-timer) (-> self parent 0 draw death-timer))
    (set! (-> self draw death-timer-org) (-> self parent 0 draw death-timer-org))
    (set! (-> self draw death-draw-overlap) (-> self parent 0 draw death-draw-overlap))
    (let ((v1-57 (-> (the-as target gp-0) draw shadow-ctrl settings shadow-dir quad)))
      (set! (-> self draw shadow-ctrl settings shadow-dir quad) v1-57)
      )
    (cond
      ((logtest? (-> (the-as target gp-0) draw shadow-ctrl settings flags) (shadow-flags disable-draw))
       (let ((v1-63 (-> self draw shadow-ctrl)))
         (logior! (-> v1-63 settings flags) (shadow-flags disable-draw))
         )
       0
       )
      (else
        (let ((v1-66 (-> self draw shadow-ctrl)))
          (logclear! (-> v1-66 settings flags) (shadow-flags disable-draw))
          )
        0
        )
      )
    (twist-set! (-> self barrel 0) (the-as float #f) (the-as float #f) (-> (the-as target gp-0) gun fire-spin))
    (twist-set!
      (-> self barrel 1)
      (the-as float #f)
      (the-as float #f)
      (if (= (-> self gun-type) (pickup-type gun-blue-2))
          (-> (the-as target gp-0) gun fire-spin)
          0.0
          )
      )
    (if (or (logtest? (-> (the-as target gp-0) draw status)
                      (draw-control-status no-draw no-draw-temp no-draw-bounds no-draw-bounds2)
                      )
            (or (logtest? (-> (the-as target gp-0) target-effect) (target-effect te0))
                (zero? (-> (the-as target gp-0) skel active-channels))
                )
            )
        (logior! (-> self draw status) (draw-control-status no-draw))
        (logclear! (-> self draw status) (draw-control-status no-draw))
        )
    (if (logtest? (-> (the-as target gp-0) draw status) (draw-control-status force-fade))
        (logior! (-> self draw status) (draw-control-status force-fade))
        (logclear! (-> self draw status) (draw-control-status force-fade))
        )
    (if (logtest? (-> (the-as target gp-0) target-effect) (target-effect te0 te1 te2))
        (logior! (-> self draw global-effect) (draw-control-global-effect no-textures))
        (logclear! (-> self draw global-effect) (draw-control-global-effect no-textures))
        )
    (if (logtest? (-> (the-as target gp-0) target-effect) (target-effect te3 te4 te5))
        (logior! (-> self draw global-effect) (draw-control-global-effect rim-lights))
        (logclear! (-> self draw global-effect) (draw-control-global-effect rim-lights))
        )
    )
  (dotimes (gp-1 4)
    (cond
      ((= (-> self parent 0 game gun-ammo gp-1) 0.0)
       (when (!= (-> self mag-scale gp-1) 0.0)
         (let ((s5-2 (new 'stack-no-clear 'projectile-init-by-other-params)))
           (let ((s3-0 (new 'stack-no-clear 'vector))
                 (s4-1 (new 'stack-no-clear 'vector))
                 )
             (vector<-cspace! s3-0 (-> self mag gp-1 joint))
             (vector-normalize-copy! s4-1 (-> self mag gp-1 joint bone transform uvec) 40960.0)
             (+! (-> s4-1 y) 81920.0)
             (set! (-> s5-2 ent) (-> self entity))
             (set! (-> s5-2 charge) 1.0)
             (set! (-> s5-2 options) (projectile-options))
             (logclear! (-> s5-2 options) (projectile-options po14 po15 po16))
             (set! (-> s5-2 pos quad) (-> s3-0 quad))
             (set! (-> s5-2 vel quad) (-> s4-1 quad))
             )
           (set! (-> s5-2 notify-handle) (the-as handle #f))
           (set! (-> s5-2 owner-handle) (the-as handle #f))
           (set! (-> s5-2 target-handle) (the-as handle #f))
           (set! (-> s5-2 target-pos quad) (the-as uint128 0))
           (set! (-> s5-2 ignore-handle) (process->handle self))
           (let* ((v1-133 *game-info*)
                  (a0-59 (+ (-> v1-133 attack-id) 1))
                  )
             (set! (-> v1-133 attack-id) a0-59)
             (set! (-> s5-2 attack-id) a0-59)
             )
           (set! (-> s5-2 timeout) (seconds 4))
           (let ((t9-8 spawn-projectile)
                 (v1-135 gp-1)
                 )
             (t9-8
               (cond
                 ((zero? v1-135)
                  gun-mag-yellow
                  )
                 ((= v1-135 1)
                  gun-mag-red
                  )
                 ((= v1-135 2)
                  gun-mag-blue
                  )
                 (else
                   gun-mag-dark
                   )
                 )
               s5-2
               self
               *default-dead-pool*
               )
             )
           )
         )
       (set! (-> self mag-scale gp-1) 0.0)
       (trs-set! (-> self mag gp-1) (the-as vector #f) (the-as quaternion #f) *zero-vector*)
       )
      (else
        (seek! (-> self mag-scale gp-1) 1.0 (* 8.0 (seconds-per-frame)))
        (let* ((f30-0 (-> self mag-scale gp-1))
               (s5-3 (-> self mag gp-1))
               (s4-2 (method-of-object s5-3 trs-set!))
               (s3-1 #f)
               (s2-0 #f)
               (s1-0 (new 'stack-no-clear 'vector))
               )
          (set! (-> s1-0 x) (lerp-scale 0.1 1.0 f30-0 0.4 1.0))
          (set! (-> s1-0 y) (lerp-scale 0.0 1.0 f30-0 0.0 0.4))
          (set! (-> s1-0 z) (lerp-scale 0.1 1.0 f30-0 0.4 1.0))
          (set! (-> s1-0 w) 1.0)
          (s4-2 s5-3 (the-as vector s3-1) (the-as quaternion s2-0) s1-0)
          )
        )
      )
    )
  (ja-post)
  (if *display-sidekick-stats*
      (debug-print-channels (-> self skel) (the-as symbol *stdcon*))
      )
  0
  (none)
  )

(defstate hidden (gun)
  :virtual #t
  :trans (behavior ()
    (if (not (focus-test? (ppointer->process (-> self parent)) in-head))
        (go-virtual idle)
        )
    )
  :code (behavior ()
    (ja-channel-set! 0)
    (ja-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defstate idle (gun)
  :virtual #t
  :trans (behavior ()
    (set! (-> self gun-type) (-> self parent 0 game gun-type))
    (let ((a0-0 (ppointer->process (-> self parent))))
      (cond
        ((focus-test? a0-0 in-head)
         (go-virtual hidden)
         )
        ((nonzero? (-> self parent 0 gun gun-type))
         (go-virtual use (the-as symbol a0-0))
         )
        )
      )
    )
  :code (behavior ()
    (set! (-> self draw shadow) #f)
    (ja-channel-set! 1)
    (set! (-> self read-scale) #f)
    (until #f
      (ja-no-eval :group! gun-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post gun-post
  )

(defstate use (gun)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notice)
       (case (-> block param 0)
         (('die)
          (if (-> *setting-control* user-current gun-eject)
              (go-virtual die)
              )
          )
         )
       )
      (('release)
       (send-event (ppointer->process (-> self parent)) 'release)
       )
      (('eject-point)
       (vector<-cspace! (the-as vector (-> block param 0)) (joint-node gun-lod0-jg backCover))
       )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set-time! (-> self state-time))
    (set! (-> self draw shadow) (-> self shadow-backup))
    (logior! (-> self skel status) (joint-control-status sync-math))
    )
  :exit (behavior ()
    (logclear! (-> self skel status) (joint-control-status sync-math))
    )
  :trans (behavior ()
    (local-vars (a0-14 object))
    (let ((v1-0 (ppointer->process (-> self parent))))
      (cond
        ((focus-test? (ppointer->process (-> self parent)) in-head)
         (go-virtual hidden)
         )
        ((and (= (-> self parent 0 gun gun-type) (pickup-type none))
              (or (not (-> v1-0 skel top-anim frame-group)) (!= (-> v1-0 skel top-anim interp) 1.0))
              )
         (go-virtual idle)
         )
        ((begin
           (set! a0-14 (!= (-> self parent 0 game gun-type) (-> self gun-type)))
           (and (the-as symbol a0-14) (let ((v1-16 (-> self state-time)))
                                        (set! a0-14 (current-time))
                                        (!= v1-16 (the-as time-frame a0-14))
                                        )
                )
           )
         (go-virtual use (the-as symbol a0-14))
         )
        )
      )
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-push! 1 (seconds 0.1))
    (gun->eco (-> self gun-type))
    (let ((gp-0 (-> self gun-type)))
      (gun->eco (-> self parent 0 game gun-type))
      (let ((v1-8 (-> self parent 0 game gun-type)))
        (set! (-> self gun-type) v1-8)
        (cond
          ((and (= gp-0 (pickup-type gun-red-1)) (= v1-8 (pickup-type gun-red-2)))
           (ja-no-eval :group! gun-gun-red1-red2-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
          ((and (= gp-0 (pickup-type gun-yellow-2)) (= v1-8 (pickup-type gun-yellow-3)))
           (ja-no-eval :group! gun-gun-yellow2-yellow3-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
          ((and (= gp-0 (pickup-type gun-blue-1)) (= v1-8 (pickup-type gun-blue-2)))
           (ja-no-eval :group! gun-gun-blue1-blue2-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
          ((and (= gp-0 (pickup-type gun-dark-1)) (= v1-8 (pickup-type gun-dark-2)))
           (ja-no-eval :group! gun-gun-dark1-dark2-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
          ((and (= gp-0 (pickup-type gun-dark-2)) (= v1-8 (pickup-type gun-dark-3)))
           (ja-no-eval :group! gun-gun-dark2-dark3-ja :num! (seek!) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
          )
        )
      )
    (let* ((v1-131 (-> self gun-type))
           (gp-1 (cond
                   ((= v1-131 (pickup-type gun-yellow-1))
                    gun-idle-yellow-ja
                    )
                   ((= v1-131 (pickup-type gun-yellow-2))
                    gun-idle-yellow2-ja
                    )
                   ((= v1-131 (pickup-type gun-yellow-3))
                    gun-idle-yellow3-ja
                    )
                   ((= v1-131 (pickup-type gun-red-1))
                    gun-idle-red-ja
                    )
                   ((= v1-131 (pickup-type gun-red-2))
                    gun-idle-red2-ja
                    )
                   ((= v1-131 (pickup-type gun-red-3))
                    gun-idle-red3-ja
                    )
                   ((= v1-131 (pickup-type gun-blue-1))
                    gun-idle-blue-ja
                    )
                   ((= v1-131 (pickup-type gun-blue-2))
                    gun-idle-blue2-ja
                    )
                   ((= v1-131 (pickup-type gun-blue-3))
                    gun-idle-blue3-ja
                    )
                   ((= v1-131 (pickup-type gun-dark-2))
                    gun-idle-dark2-ja
                    )
                   ((= v1-131 (pickup-type gun-dark-3))
                    gun-idle-dark3-ja
                    )
                   (else
                     gun-idle-dark-ja
                     )
                   )
                 )
           (s5-0 '(("jakb-gun-yellow-fire" . "gun-yellow-fire")
                   ("jakb-gun-yellow-fire-low" . "gun-yellow-fire-low")
                   ("jakb-pilot-gun-yellow-fire" . "gun-yellow-fire")
                   ("jakb-gun-red-fire" . "gun-red-fire")
                   ("jakb-pilot-gun-red-fire" . "gun-red-fire")
                   ("jakb-gun-blue-fire" . "gun-blue-fire")
                   ("jakb-pilot-gun-blue-fire" . "gun-blue-fire")
                   ("jakb-gun-blue-fire-single" . "gun-blue-fire-single")
                   ("jakb-pilot-gun-blue-fire-single" . "gun-blue-fire-single")
                   ("jakb-gun-dark-fire" . "gun-dark-fire")
                   ("jakb-pilot-gun-dark-fire" . "gun-dark-fire")
                   ("jakb-gun-red-fire-2" . "gun-red-fire-2")
                   ("jakb-gun-yellow-fire-3" . "gun-yellow-fire-3")
                   ("jakb-gun-blue-fire-2" . "gun-blue-fire-2")
                   )
                 )
           (s4-0 (ppointer->process (-> self parent)))
           )
      (until #f
        (let* ((v1-160 (-> s4-0 skel top-anim frame-group))
               (s3-0 (if v1-160
                         (-> v1-160 name)
                         )
                     )
               (s2-0 (nassoc s3-0 s5-0))
               (s1-0 (if s2-0
                         (-> (the-as pair s2-0) cdr)
                         )
                     )
               )
          (cond
            ((string= (the-as string s1-0) "gun-red-fire")
             (case (-> self gun-type)
               (((pickup-type gun-red-3))
                (set! s1-0 "gun-red-fire-3")
                )
               )
             )
            ((or (string= (the-as string s1-0) "gun-yellow-fire") (string= (the-as string s1-0) "gun-yellow-fire-low"))
             (case (-> self gun-type)
               (((pickup-type gun-yellow-2))
                (set! s1-0 "gun-yellow-fire-2")
                )
               (((pickup-type gun-yellow-3))
                (set! s1-0 "gun-yellow-fire-3")
                )
               )
             )
            ((string= (the-as string s1-0) "gun-blue-fire")
             (case (-> self gun-type)
               (((pickup-type gun-blue-3))
                (set! s1-0 "gun-blue-fire-3")
                )
               )
             )
            ((string= (the-as string s1-0) "gun-blue-fire-single")
             (case (-> self gun-type)
               (((pickup-type gun-blue-3))
                (set! s1-0 "gun-blue-fire-3-single")
                )
               )
             )
            ((string= (the-as string s1-0) "gun-dark-fire")
             (case (-> self gun-type)
               (((pickup-type gun-red-2))
                (set! s1-0 "gun-red-fire-2")
                )
               (((pickup-type gun-dark-2))
                (set! s1-0 "gun-dark-fire-2")
                )
               (((pickup-type gun-dark-3))
                (set! s1-0 "gun-dark-fire-3")
                )
               )
             )
            )
          (let ((a1-27 (if s1-0
                           (get-art-by-name (-> self draw art-group) (the-as string s1-0) art-joint-anim)
                           )
                       )
                )
            (cond
              (s2-0
                (ja :group! a1-27 :num! (identity (-> s4-0 skel top-anim frame-num)))
                (set! (-> self read-scale) #f)
                )
              ((nmember s3-0 '("jakb-gun-attack-butt"
                                "jakb-gun-attack-butt-end"
                                "jakb-gun-attack-butt-blue"
                                "jakb-gun-attack-butt-blue-end"
                                "jakb-gun-attack-from-stance"
                                "jakb-gun-attack-from-stance-end"
                                "jakb-gun-attack-from-stance-blue"
                                "jakb-gun-attack-from-stance-blue-end"
                                "jakb-pilot-gun-red-yellow"
                                )
                        )
               (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim gp-1))
               (set! (-> self read-scale) #t)
               )
              ((and (= (-> s4-0 skel top-anim interp) 1.0)
                    (begin
                      (set! s2-0 (nassoc s3-0 '(("jakb-gun-yellow-takeout" . "gun-red-yellow")
                                                ("jakb-gun-blue-takeout" . "gun-red-blue")
                                                ("jakb-gun-dark-takeout" . "gun-red-dark")
                                                ("jakb-gun-red-takeout" . "gun-idle-red")
                                                ("jakb-pilot-gun-yellow-takeout" . "gun-red-yellow")
                                                ("jakb-pilot-gun-blue-takeout" . "gun-red-blue")
                                                ("jakb-pilot-gun-dark-takeout" . "gun-red-dark")
                                                ("jakb-pilot-gun-red-takeout" . "gun-idle-red")
                                                )
                                         )
                            )
                      s2-0
                      )
                    )
               (let ((s1-1
                       (if s2-0
                           (get-art-by-name (-> self draw art-group) (the-as string (-> (the-as pair s2-0) cdr)) art-joint-anim)
                           )
                       )
                     )
                 (set! (-> self read-scale) #t)
                 (let* ((v1-208 (-> s4-0 skel top-anim frame-group))
                        (f30-0 (+ (* (-> s4-0 skel top-anim frame-num) (-> v1-208 artist-step)) (-> v1-208 artist-base)))
                        )
                   (cond
                     ((string= s3-0 "jakb-gun-blue-takeout")
                      (if (>= f30-0 (-> s1-1 artist-base))
                          (ja :group! s1-1 :num! (identity (ja-aframe f30-0 0)))
                          (ja :group! gun-idle-ja)
                          )
                      )
                     ((or (string= s3-0 "jakb-gun-dark-takeout") (string= s3-0 "jakb-pilot-gun-dark-takeout"))
                      (if (>= f30-0 -40.0)
                          (ja :group! s1-1 :num! (identity (+ 40.0 (ja-aframe f30-0 0))))
                          (ja :group! s1-1 :num! min)
                          )
                      )
                     ((>= f30-0 -40.0)
                      (ja :group! s1-1 :num! (identity (ja-aframe f30-0 0)))
                      )
                     (else
                       (ja :group! gun-idle-ja)
                       )
                     )
                   )
                 )
               )
              (else
                (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim gp-1))
                (set! (-> self read-scale) #f)
                )
              )
            )
          )
        (suspend)
        0
        )
      )
    #f
    )
  :post (behavior ()
    (gun-post)
    (let ((gp-0 (ppointer->process (-> self parent))))
      (let ((s5-0
              (and (-> (the-as target gp-0) skel top-anim frame-group)
                   (not (or (focus-test? (the-as target gp-0) pilot)
                            (string= (-> (the-as target gp-0) skel top-anim frame-group name) "jakb-gun-attack-from-stance-end")
                            (string= (-> (the-as target gp-0) skel top-anim frame-group name) "jakb-gun-attack-from-stance")
                            (string= (-> (the-as target gp-0) skel top-anim frame-group name) "jakb-gun-dark-fire")
                            (string= (-> (the-as target gp-0) skel top-anim frame-group name) "jakb-gun-stance-dark")
                            (string= (-> (the-as target gp-0) skel top-anim frame-group name) "jakb-gun-attack-from-stance-blue-end")
                            )
                        )
                   )
              )
            )
        (vector<-cspace! (-> (the-as target gp-0) gun fire-point) (joint-node gun-lod0-jg muzzle))
        (set! (-> (the-as target gp-0) gun unk-vec quad) (-> (the-as target gp-0) gun fire-dir quad))
        (cond
          ((and (handle->process (-> (the-as target gp-0) gun track-target 0 handle))
                (logtest? (surface-flag gun-direct) (-> (the-as target gp-0) control current-surface flags))
                )
           (vector-!
             (-> (the-as target gp-0) gun fire-dir)
             (-> (the-as target gp-0) gun track-trans)
             (-> (the-as target gp-0) gun fire-point)
             )
           (vector-normalize! (-> (the-as target gp-0) gun fire-dir) 1.0)
           (set! (-> (the-as target gp-0) gun fire-dir-out quad) (-> (the-as target gp-0) gun fire-dir quad))
           )
          (else
            (vector-normalize-copy!
              (-> (the-as target gp-0) gun fire-dir)
              (-> self node-list data 13 bone transform fvec)
              1.0
              )
            (if s5-0
                (set! (-> (the-as target gp-0) gun fire-dir-out quad)
                      (-> (the-as target gp-0) node-list data 4 bone transform fvec quad)
                      )
                )
            (vector-rotate-y!
              (-> (the-as target gp-0) gun fire-dir-out)
              (-> (the-as target gp-0) gun fire-dir)
              (-> (the-as target gp-0) gun fire-dir-rot)
              )
            )
          )
        (vector<-cspace! (-> (the-as target gp-0) gun laser-point) (joint-node gun-lod0-jg laser))
        (set! (-> (the-as target gp-0) gun unk-vec00 quad) (-> (the-as target gp-0) gun laser-dir quad))
        (set! (-> (the-as target gp-0) gun laser-dir quad) (-> (the-as target gp-0) gun fire-dir-out quad))
        (if s5-0
            (set! (-> (the-as target gp-0) gun laser-dir quad)
                  (-> (the-as target gp-0) node-list data 4 bone transform fvec quad)
                  )
            )
        )
      (let ((s5-1 self))
        (set! self (the-as gun gp-0))
        (target-gun-check)
        (set! self s5-1)
        )
      )
    )
  )

(defstate die (gun)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('reset)
       (go-virtual idle)
       )
      )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> s4-0 quad) (-> self root trans quad))
        (vector-float*!
          s5-0
          (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self parent 0 control quat))
          -20480.0
          )
        (+! (-> s5-0 y) 81920.0)
        (set! (-> gp-0 ent) (-> self entity))
        (set! (-> gp-0 charge) 1.0)
        (set! (-> gp-0 options) (projectile-options))
        (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
        (set! (-> gp-0 pos quad) (-> s4-0 quad))
        (set! (-> gp-0 vel quad) (-> s5-0 quad))
        )
      (set! (-> gp-0 notify-handle) (the-as handle #f))
      (set! (-> gp-0 owner-handle) (the-as handle #f))
      (set! (-> gp-0 target-handle) (the-as handle #f))
      (set! (-> gp-0 target-pos quad) (the-as uint128 0))
      (set! (-> gp-0 ignore-handle) (process->handle self))
      (let* ((v1-16 *game-info*)
             (a0-13 (+ (-> v1-16 attack-id) 1))
             )
        (set! (-> v1-16 attack-id) a0-13)
        (set! (-> gp-0 attack-id) a0-13)
        )
      (set! (-> gp-0 timeout) (seconds 4))
      (spawn-projectile gun-eject gp-0 self *default-dead-pool*)
      )
    (ja-channel-set! 0)
    (ja-post)
    (while (logtest? (-> self parent 0 focus-status) (focus-status dead))
      (suspend)
      )
    (go-virtual idle)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior gun-init gun ()
  (change-to-last-brother self)
  (set! (-> self root) (new 'process 'trsqv))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((v1-5 (-> *target-shadow-control* settings shadow-dir quad)))
    (set! (-> *gun-shadow-control* settings shadow-dir quad) v1-5)
    )
  (set! (-> self draw shadow-ctrl) *gun-shadow-control*)
  (set! (-> self shadow-backup) (-> self draw shadow))
  (set! (-> self barrel 0) (new 'process 'joint-mod (joint-mod-mode rotate) self 8))
  (set! (-> self barrel 1) (new 'process 'joint-mod (joint-mod-mode rotate) self 10))
  (set! (-> self read-scale) #f)
  (set! (-> self extra) (the-as handle #f))
  (set! (-> self mag 0) (new 'process 'joint-mod (joint-mod-mode joint-set*) self 38))
  (set! (-> self mag 1) (new 'process 'joint-mod (joint-mod-mode joint-set*) self 36))
  (set! (-> self mag 2) (new 'process 'joint-mod (joint-mod-mode joint-set*) self 37))
  (set! (-> self mag 3) (new 'process 'joint-mod (joint-mod-mode joint-set*) self 39))
  (dotimes (v1-15 4)
    (set! (-> self mag-scale v1-15) (if (= (-> self parent 0 game gun-ammo v1-15) 0.0)
                                        0.0
                                        1.0
                                        )
          )
    )
  (go-virtual idle)
  (none)
  )

(defmethod gun-info-method-9 ((this gun-info))
  (when (and (-> this laser-active?)
             (-> this active?)
             (not (logtest? (-> this gun 0 draw status) (draw-control-status no-draw)))
             #t
             )
    (let ((s5-0 (-> this laser-point))
          (s4-0 (new 'stack-no-clear 'collide-query))
          (s3-0 (-> this laser-dir))
          (f30-0 (rotate-y<-vector+vector (-> this laser-dir) (-> this unk-vec00)))
          )
      (vector+float*! (-> s4-0 start-pos) s5-0 s3-0 -8192.0)
      (vector-float*! (-> s4-0 move-dist) s3-0 163840.0)
      (let ((v1-13 s4-0))
        (set! (-> v1-13 radius) (-> this track-beam-size))
        (set! (-> v1-13 collide-with)
              (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list pusher shield)
              )
        (set! (-> v1-13 ignore-process0) (ppointer->process (-> this process)))
        (set! (-> v1-13 ignore-process1) #f)
        (set! (-> v1-13 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> v1-13 action-mask) (collide-action solid semi-solid))
        )
      (let ((f0-3 (fill-and-probe-using-line-sphere *collide-cache* s4-0)))
        (cond
          ((>= f0-3 0.0)
           (vector+float*! (-> s4-0 start-pos) (-> s4-0 start-pos) (-> s4-0 move-dist) f0-3)
           (vector+float*! (-> s4-0 start-pos) (-> s4-0 start-pos) s3-0 (-> this track-beam-size))
           (let* ((s2-0 (-> s4-0 best-other-tri collide-ptr))
                  (s0-0 (if (type? s2-0 collide-shape-prim)
                            (the-as collide-shape-prim s2-0)
                            )
                        )
                  (s1-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s5-0 (-> s4-0 start-pos)) 1638.4))
                  (s2-1 (new 'stack-no-clear 'vector))
                  )
             (set! (-> s2-1 quad) (-> s4-0 start-pos quad))
             (cond
               ((and s0-0
                     (or (logtest? (process-mask enemy guard) (-> s0-0 cshape process mask))
                         (= (handle->process (-> this track-target 0 handle)) (-> s0-0 cshape process))
                         )
                     (>= (-> this fire-range) (vector-vector-distance s2-1 s5-0))
                     )
                (vector+! s2-1 s2-1 s1-0)
                (launch-particles (-> *part-id-table* 211) s2-1)
                (launch-particles (-> *part-id-table* 210) s2-1)
                )
               (else
                 (vector+! s2-1 s2-1 s1-0)
                 (launch-particles (-> *part-id-table* 212) s2-1)
                 )
               )
             )
           )
          (else
            (vector+! (-> s4-0 start-pos) (-> s4-0 start-pos) (-> s4-0 move-dist))
            )
          )
        )
      (set! (-> this laser-hit-point quad) (-> s4-0 start-pos quad))
      (let ((s1-3 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (camera-pos) s5-0) 1.0))
            (t9-10 vector-normalize!)
            (a0-37 (new 'stack-no-clear 'vector))
            )
        (set! (-> a0-37 quad) (-> s3-0 quad))
        (let ((s2-3 (t9-10 a0-37 1.0))
              (s3-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> s3-1 quad) (-> s5-0 quad))
          (let ((v1-47 (vector-normalize-copy! (new 'stack-no-clear 'vector) s2-3 327.68))
                (f28-1 (vector-dot s1-3 s2-3))
                )
            (when (< 0.0 f28-1)
              (vector+! s3-1 s3-1 v1-47)
              (set! (-> *part-id-table* 209 init-specs 13 initial-valuef) f28-1)
              (launch-particles (-> *part-id-table* 209) s3-1)
              (set! (-> *part-id-table* 208 init-specs 13 initial-valuef) f28-1)
              (launch-particles (-> *part-id-table* 208) s3-1)
              )
            )
          )
        )
      (let* ((s3-2 (-> *part-id-table* 207))
             (s2-4 (get-field-spec-by-id s3-2 (sp-field-id spt-timer)))
             (s1-5 (vector-! (new 'stack-no-clear 'vector) (-> s4-0 start-pos) s5-0))
             (s4-1 (if (< 182.04445 f30-0)
                       3
                       1
                       )
                   )
             (f30-1 (-> s2-4 initial-valuef))
             (f28-2 (vector-vector-distance (camera-pos) s5-0))
             (s0-2 (get-field-spec-by-id s3-2 (sp-field-id spt-scale-x)))
             (f0-13 (cond
                      ((< f28-2 122.88)
                       0.0
                       )
                      ((< 65536.0 f28-2)
                       1.0
                       )
                      (else
                        (* 0.000015287453 (+ -122.88 f28-2))
                        )
                      )
                    )
             (f28-3 (-> s0-2 initial-valuef))
             (f26-0 (-> s0-2 random-rangef))
             )
        (set! (-> s0-2 initial-valuef) (* f28-3 f0-13))
        (set! (-> s0-2 random-rangef) (* f26-0 f0-13))
        (set! (-> s2-4 initial-valuef) (the float s4-1))
        (draw-beam s3-2 s5-0 s1-5 #t)
        (set! (-> s2-4 initial-valuef) f30-1)
        (set! (-> s0-2 initial-valuef) f28-3)
        (set! (-> s0-2 random-rangef) f26-0)
        )
      )
    )
  (-> this laser-dir)
  )

(defun do-fire-backcheck ((arg0 vector) (arg1 vector))
  (let* ((v1-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 1.0))
         (a0-3 (vector+float*! (new 'stack-no-clear 'vector) arg0 v1-0 -7372.8))
         (gp-1 (new 'stack-no-clear 'collide-query))
         )
    (set! (-> gp-1 start-pos quad) (-> a0-3 quad))
    (vector-float*! (-> gp-1 move-dist) v1-0 40960.0)
    (let ((v1-1 gp-1))
      (set! (-> v1-1 radius) 40.96)
      (set! (-> v1-1 collide-with) (collide-spec backgnd hit-by-others-list pusher impenetrable-obj))
      (set! (-> v1-1 ignore-process0) #f)
      (set! (-> v1-1 ignore-process1) #f)
      (set! (-> v1-1 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-1 action-mask) (collide-action solid))
      )
    (let ((f0-3 (fill-and-probe-using-line-sphere *collide-cache* gp-1)))
      (when (>= f0-3 0.0)
        (if (< (* (vector-length (-> gp-1 move-dist)) f0-3) 8192.0)
            (return #f)
            )
        )
      )
    )
  #t
  )

(defun get-remaining-player-ammo ((arg0 pickup-type))
  0.0
  (if (or (logtest? (target-flags tf16) (-> *target* target-flags))
          (logtest? (game-secrets endless-ammo) (-> *target* game secrets))
          )
      1000.0
      (the-as float (send-event *target* 'query 'pickup arg0))
      )
  )

;; WARN: Return type mismatch object vs float.
(defun adjust-player-ammo ((arg0 float) (arg1 pickup-type))
  (if (and *target*
           (and (focus-test? *target* light) (nonzero? (-> *target* lightjak)))
           (not (logtest? (-> *target* lightjak stage) (lightjak-stage ls1)))
           )
      (pickup-collectable! (-> *target* fact) (pickup-type eco-pill-light) -1.0 (the-as handle #f))
      )
  (the-as float (send-event *target* 'get-pickup arg1 arg0))
  )

(defun adjust-player-ammo-over-time ((arg0 int) (arg1 float) (arg2 pickup-type) (arg3 float))
  (let* ((f0-2 (* 0.0033333334 (the float arg0) arg1))
         (f30-0 (fmin (fmax 0.0 f0-2) arg3))
         )
    (adjust-player-ammo (- f30-0) arg2)
    f30-0
    )
  )

;; WARN: Return type mismatch float vs none.
(defun truncate-player-ammo ((arg0 pickup-type))
  (let* ((f0-0 (get-remaining-player-ammo arg0))
         (f0-1 (- f0-0 (the float (the int f0-0))))
         )
    (adjust-player-ammo (- f0-1) arg0)
    )
  (none)
  )

(deftype last-gun-fire-time (structure)
  ((last-fire-times  time-frame  12)
   )
  )


(define *last-gun-fire-time* (new 'static 'last-gun-fire-time))

(defun compute-gun-fire-time-index ((arg0 int))
  (max 0 (min 11 (+ arg0 -26)))
  )

(defun get-last-fire-time ((arg0 int))
  (-> *last-gun-fire-time* last-fire-times (compute-gun-fire-time-index arg0))
  )

(defun set-last-fire-time ((arg0 int))
  (set-time! (-> *last-gun-fire-time* last-fire-times (compute-gun-fire-time-index arg0)))
  0
  (none)
  )
