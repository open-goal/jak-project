;;-*-Lisp-*-
(in-package goal)

;; name: hud.gc
;; name in dgo: hud
;; dgos: GAME

;; DECOMP BEGINS

(defmethod check-ready-and-maybe-show ((this hud) (arg0 symbol))
  (case (get-status *gui-control* (-> this gui-id))
    (((gui-status ready) (gui-status active))
     (if arg0
         (set-action!
           *gui-control*
           (gui-action play)
           (-> this gui-id)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         )
     #t
     )
    (else
      #f
      )
    )
  )

(deftype hud-sprite-work (structure)
  ((adgif-tmpl   dma-gif-packet  :inline)
   (sprite-tmpl  dma-gif-packet  :inline)
   (draw-tmpl    dma-gif-packet  :inline)
   (box-tmpl     dma-gif-packet  :inline)
   (box2-tmpl    dma-gif-packet  :inline)
   (mask-tmpl    dma-gif-packet  :inline)
   (line-tmpl    dma-gif-packet  :inline)
   (scan-tmpl    dma-gif-packet  :inline)
   (line-color   gs-rgbaq)
   (scan-colors  vector4w        32 :inline)
   (scanline     uint32)
   )
  )


(define *hud-sprite-work* (new 'static 'hud-sprite-work
                            :adgif-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x1000000000008005 #xe)
                              )
                            :sprite-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x502b400000008001 #x52521)
                              )
                            :draw-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #xd :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #xd :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #xc02a400000008001 #x521521521521)
                              )
                            :box-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #x7 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #x7 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x6021400000008001 #x555551)
                              )
                            :box2-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x5022400000008001 #x55551)
                              )
                            :mask-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x5022400000008001 #x55551)
                              )
                            :line-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #x5 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #x5 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x2020c00000008002 #x5555)
                              )
                            :scan-tmpl (new 'static 'dma-gif-packet
                              :dma-vif (new 'static 'dma-packet
                                :dma (new 'static 'dma-tag :qwc #xa1 :id (dma-tag-id cnt))
                                :vif1 (new 'static 'vif-tag :imm #xa1 :cmd (vif-cmd direct) :msk #x1)
                                )
                              :gif (new 'static 'array uint64 2 #x5020c00000008020 #x55551)
                              )
                            :line-color (new 'static 'gs-rgbaq :r #x80 :g #x80 :b #x80 :a #x80 :q 1.0)
                            :scan-colors (new 'static 'inline-array vector4w 32
                              (new 'static 'vector4w :x 1 :y 1)
                              (new 'static 'vector4w :x 2 :y 1 :z 1)
                              (new 'static 'vector4w :x 3 :y 2 :z 1)
                              (new 'static 'vector4w :x 6 :y 4 :z 2)
                              (new 'static 'vector4w :x 8 :y 6 :z 2)
                              (new 'static 'vector4w :x 12 :y 10 :z 4)
                              (new 'static 'vector4w :x 12 :y 10 :z 4)
                              (new 'static 'vector4w :x 12 :y 10 :z 4)
                              (new 'static 'vector4w :x 16 :y 14 :z 6)
                              (new 'static 'vector4w :x 16 :y 14 :z 6)
                              (new 'static 'vector4w :x 16 :y 14 :z 6)
                              (new 'static 'vector4w :x 16 :y 14 :z 6)
                              (new 'static 'vector4w :x 22 :y 20 :z 10)
                              (new 'static 'vector4w :x 22 :y 20 :z 10)
                              (new 'static 'vector4w :x 22 :y 20 :z 10)
                              (new 'static 'vector4w :x 22 :y 20 :z 10)
                              (new 'static 'vector4w :x 28 :y 26 :z 12)
                              (new 'static 'vector4w :x 28 :y 26 :z 12)
                              (new 'static 'vector4w :x 28 :y 26 :z 12)
                              (new 'static 'vector4w :x 28 :y 26 :z 12)
                              (new 'static 'vector4w :x 40 :y 34 :z 18)
                              (new 'static 'vector4w :x 40 :y 34 :z 18)
                              (new 'static 'vector4w :x 40 :y 34 :z 18)
                              (new 'static 'vector4w :x 40 :y 34 :z 18)
                              (new 'static 'vector4w :x 54 :y 42 :z 26)
                              (new 'static 'vector4w :x 54 :y 42 :z 26)
                              (new 'static 'vector4w :x 54 :y 42 :z 26)
                              (new 'static 'vector4w :x 54 :y 42 :z 26)
                              (new 'static 'vector4w :x 72 :y 48 :z 34)
                              (new 'static 'vector4w :x 72 :y 48 :z 34)
                              (new 'static 'vector4w :x 90 :y 56 :z 44)
                              (new 'static 'vector4w :x #x7e :y 64 :z 64)
                              )
                            :scanline #x60
                            )
        )

(defmethod draw-scan-and-line ((this hud-box) (arg0 dma-buffer) (arg1 float))
  (let ((v1-0 *hud-sprite-work*))
    (set! (-> v1-0 line-color a) (the int (* 3.0 arg1)))
    (let ((a2-1 (the int (* 64.0 arg1))))
      (dotimes (a3-4 15)
        (set! (-> v1-0 scan-colors a3-4 w) a2-1)
        )
      )
    (let* ((a2-6 (* (+ (the int (-> this box min x)) 1792) 16))
           (a3-7 (* (+ (the int (-> this box max x)) 1792) 16))
           (t0-9 (* (+ (the int (-> this box min y)) 1840) 16))
           (t2-0 (the int (- (-> this box max y) (-> this box min y))))
           (t1-0 (/ t2-0 4))
           )
      (dma-buffer-add-gs-set arg0
                             (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                             (alpha-1 (new 'static 'gs-alpha :b #x2 :d #x1))
                             )
      ;; og:preserve-this divide by zero guard
      (set! (-> v1-0 scanline) (mod-0-guard (+ (-> v1-0 scanline) 6) (the-as uint t2-0)))
      (let ((t3-6 (the-as (inline-array vector4w) (-> arg0 base))))
        (set! (-> t3-6 0 quad) (-> v1-0 scan-tmpl dma-vif quad))
        (set! (-> t3-6 1 quad) (-> v1-0 scan-tmpl quad 1))
        )
      (&+! (-> arg0 base) 32)
      (let ((a0-2 (+ (the int (-> this box min y)) 1840)))
        (dotimes (t3-9 32)
          (let ((t4-8 (the-as object (-> arg0 base)))
                ;; og:preserve-this divide by zero guard
                (t5-13 (* (+ a0-2 (mod-0-guard (+ (-> v1-0 scanline) (* t3-9 2)) (the-as uint t2-0))) 16))
                (t6-6 (* (+ a0-2 (mod-0-guard (the-as uint (+ (* t3-9 2) 1 (-> v1-0 scanline))) (the-as uint t2-0))) 16))
                )
            (set! (-> (the-as (pointer uint128) t4-8)) (-> v1-0 scan-colors t3-9 quad))
            (let ((t7-4 (the-as (inline-array vector4w) (-> (the-as (inline-array vector4w) t4-8) 1))))
              (set! (-> t7-4 0 x) a2-6)
              (set! (-> t7-4 0 y) t5-13)
              (set! (-> t7-4 0 z) 0)
              (set! (-> t7-4 0 w) 0)
              )
            (let ((t7-5 (the-as (inline-array vector4w) (-> (the-as (inline-array vector4w) t4-8) 2))))
              (set! (-> t7-5 0 x) a3-7)
              (set! (-> t7-5 0 y) t5-13)
              (set! (-> t7-5 0 z) 0)
              (set! (-> t7-5 0 w) 0)
              )
            (let ((t5-14 (the-as (inline-array vector4w) (-> (the-as (inline-array vector4w) t4-8) 3))))
              (set! (-> t5-14 0 x) a2-6)
              (set! (-> t5-14 0 y) t6-6)
              (set! (-> t5-14 0 z) 0)
              (set! (-> t5-14 0 w) 0)
              )
            (let ((t4-9 (the-as (inline-array vector4w) (-> (the-as (inline-array vector4w) t4-8) 4))))
              (set! (-> t4-9 0 x) a3-7)
              (set! (-> t4-9 0 y) t6-6)
              (set! (-> t4-9 0 z) 0)
              (set! (-> t4-9 0 w) 0)
              )
            )
          (set! (-> arg0 base) (the-as pointer (-> (the-as (inline-array vector4w) (-> arg0 base)) 5)))
          )
        )
      (dma-buffer-add-gs-set arg0 (alpha-1 (new 'static 'gs-alpha :a #x2 :d #x1)) (rgbaq (-> v1-0 line-color)))
      (dotimes (a0-8 t1-0)
        (let ((t2-7 (the-as object (-> arg0 base))))
          (set! (-> (the-as (inline-array vector4w) t2-7) 0 quad) (-> v1-0 line-tmpl dma-vif quad))
          (set! (-> (the-as (inline-array vector4w) t2-7) 1 quad) (-> v1-0 line-tmpl quad 1))
          (set-vector! (-> (the-as (inline-array vector4w) t2-7) 2) a2-6 t0-9 #xffffff 0)
          (set-vector! (-> (the-as (inline-array vector4w) t2-7) 3) a3-7 t0-9 #xffffff 0)
          (set-vector! (-> (the-as (inline-array vector4w) t2-7) 4) a2-6 (+ t0-9 16) #xffffff 0)
          (set-vector! (-> (the-as (inline-array vector4w) t2-7) 5) a3-7 (+ t0-9 16) #xffffff 0)
          )
        (&+! (-> arg0 base) 96)
        (+! t0-9 64)
        )
      )
    )
  0
  )

(defmethod draw ((this hud-sprite) (arg0 dma-buffer) (arg1 level) (arg2 symbol))
  (local-vars
    (v1-9 uint128)
    (a1-5 int)
    (a2-13 int)
    (a3-2 int)
    (t0-0 int)
    (t1-0 int)
    (t2-0 int)
    (t3-0 int)
    (t4-0 int)
    )
  (set! arg2 (or (not (get-screen-copied *blit-displays-work*)) arg2))
  (when arg2
    (let ((s4-1 *hud-sprite-work*)
          (s3-0 (the-as object (-> this tid)))
          (f28-0 0.0)
          (f30-0 1.0)
          )
      (when (!= (-> this angle) 0.0)
        (set! f28-0 (sin (-> this angle)))
        (set! f30-0 (cos (-> this angle)))
        )
      (when (the-as texture-id s3-0)
        (when arg1
          (let ((v1-8 (-> arg1 texture-mask 8 mask quad))
                (a0-4 (-> (the-as texture s3-0) masks data 0 mask quad))
                )
            (.por v1-9 v1-8 a0-4)
            )
          (set! (-> arg1 texture-mask 8 mask quad) v1-9)
          )
        (let ((s2-1 (the-as object (-> arg0 base))))
          (set! (-> (the-as (inline-array vector4w) s2-1) 0 quad) (-> s4-1 adgif-tmpl dma-vif quad))
          (set! (-> (the-as (inline-array vector4w) s2-1) 1 quad) (-> s4-1 adgif-tmpl quad 1))
          (adgif-shader<-texture-simple! (the-as adgif-shader (&+ (the-as pointer s2-1) 32)) (the-as texture s3-0))
          (cond
            ((logtest? (-> this flags) (hud-sprite-flags hsf4))
             (set! (-> (the-as (pointer uint64) (&+ (the-as pointer s2-1) 32)) 8) (the-as uint 72))
             )
            ((logtest? (-> this flags) (hud-sprite-flags hsf5))
             (set! (-> (the-as (pointer uint64) (&+ (the-as pointer s2-1) 32)) 8) (the-as uint 66))
             )
            )
          )
        (&+! (-> arg0 base) 112)
        (let ((v1-22 (the-as object (-> arg0 base)))
              (a1-2
                (the int
                     (* f30-0 (the float (-> (the-as texture s3-0) w)) (-> this scale-x) (-> *video-params* relative-x-scale))
                     )
                )
              (a3-1 (the int (* -1.0 (-> this scale-x) (the float (-> (the-as texture s3-0) w)) f28-0)))
              (t5-0
                (the int
                     (* f28-0 (the float (-> (the-as texture s3-0) h)) (-> this scale-y) (-> *video-params* relative-x-scale))
                     )
                )
              (t6-0 (the int (* f30-0 (the float (-> (the-as texture s3-0) h)) (-> this scale-y))))
              (a0-16 (if (nonzero? (-> this pos z))
                         (-> this pos z)
                         #xffffff
                         )
                     )
              )
          0
          0
          0
          0
          0
          0
          0
          0
          (cond
            ((logtest? (-> this flags) (hud-sprite-flags hsf2))
             (set! t2-0 (+ (-> this pos x) 1792))
             (set! t3-0 (+ (-> this pos y) 1840))
             (set! a2-13 (- t2-0 a1-2))
             (set! t4-0 (- t3-0 a3-1))
             (set! t0-0 (+ (- t2-0 a1-2) t5-0))
             (set! t1-0 (+ (- t3-0 a3-1) t6-0))
             (set! a1-5 (+ t2-0 t5-0))
             (set! a3-2 (+ t3-0 t6-0))
             )
            ((logtest? (-> this flags) (hud-sprite-flags hsf3))
             (set! a2-13 (+ (- 1792 (the int (* 0.5 (the float (+ a1-2 t5-0))))) (-> this pos x)))
             (set! t4-0 (+ (- 1840 (the int (* 0.5 (the float (+ a3-1 t6-0))))) (-> this pos y)))
             (set! t2-0 (+ a2-13 a1-2))
             (set! t3-0 (+ t4-0 a3-1))
             (set! t0-0 (+ a2-13 t5-0))
             (set! t1-0 (+ t4-0 t6-0))
             (set! a1-5 (+ a2-13 a1-2 t5-0))
             (set! a3-2 (+ t4-0 a3-1 t6-0))
             )
            (else
              (set! a2-13 (+ (-> this pos x) 1792))
              (set! t4-0 (+ (-> this pos y) 1840))
              (set! t2-0 (+ a2-13 a1-2))
              (set! t3-0 (+ t4-0 a3-1))
              (set! t0-0 (+ a2-13 t5-0))
              (set! t1-0 (+ t4-0 t6-0))
              (set! a1-5 (+ a2-13 a1-2 t5-0))
              (set! a3-2 (+ t4-0 a3-1 t6-0))
              )
            )
          (set! (-> (the-as (inline-array vector4w) v1-22) 0 quad) (-> s4-1 draw-tmpl dma-vif quad))
          (set! (-> (the-as (inline-array vector4w) v1-22) 1 quad) (-> s4-1 draw-tmpl quad 1))
          (set! (-> (the-as (inline-array vector4w) v1-22) 2 quad) (-> this color quad))
          (set! (-> (the-as (inline-array vector4w) v1-22) 5 quad) (-> this color quad))
          (set! (-> (the-as (inline-array vector4w) v1-22) 8 quad) (-> this color quad))
          (set! (-> (the-as (inline-array vector4w) v1-22) 11 quad) (-> this color quad))
          (let ((f0-31 (if (logtest? (-> this flags) (hud-sprite-flags hsf0))
                           1.0
                           0.0
                           )
                       )
                (f1-13 (if (logtest? (-> this flags) (hud-sprite-flags hsf1))
                           1.0
                           0.0
                           )
                       )
                )
            (let ((t5-16 (the-as (inline-array vector) (&+ (the-as pointer v1-22) 48))))
              (set! (-> t5-16 0 x) f0-31)
              (set! (-> t5-16 0 y) f1-13)
              (set! (-> t5-16 0 z) 1.0)
              (set! (-> t5-16 0 w) 0.0)
              )
            (let ((t5-17 (the-as object (&+ (the-as pointer v1-22) 96))))
              (set! (-> (the-as (inline-array vector) t5-17) 0 x) (- 1.0 f0-31))
              (set! (-> (the-as (inline-array vector) t5-17) 0 y) f1-13)
              (set! (-> (the-as (inline-array vector) t5-17) 0 z) 1.0)
              (set! (-> (the-as (inline-array vector) t5-17) 0 w) 0.0)
              )
            (let ((t5-18 (the-as (inline-array vector) (&+ (the-as pointer v1-22) 144))))
              (set! (-> t5-18 0 x) f0-31)
              (set! (-> t5-18 0 y) (- 1.0 f1-13))
              (set! (-> t5-18 0 z) 1.0)
              (set! (-> t5-18 0 w) 0.0)
              )
            (let ((t5-19 (the-as object (&+ (the-as pointer v1-22) 192))))
              (set! (-> (the-as (inline-array vector) t5-19) 0 x) (- 1.0 f0-31))
              (set! (-> (the-as (inline-array vector) t5-19) 0 y) (- 1.0 f1-13))
              (set! (-> (the-as (inline-array vector) t5-19) 0 z) 1.0)
              (set! (-> (the-as (inline-array vector) t5-19) 0 w) 0.0)
              )
            )
          (let ((t5-20 (the-as object (&+ (the-as pointer v1-22) 64))))
            (set! (-> (the-as (inline-array vector4w) t5-20) 0 x) (* a2-13 16))
            (set! (-> (the-as (inline-array vector4w) t5-20) 0 y) (* t4-0 16))
            (set! (-> (the-as (inline-array vector4w) t5-20) 0 z) a0-16)
            (set! (-> (the-as (inline-array vector4w) t5-20) 0 w) #x10000)
            )
          (let ((a2-22 (the-as object (&+ (the-as pointer v1-22) 112))))
            (set! (-> (the-as (inline-array vector4w) a2-22) 0 x) (* t2-0 16))
            (set! (-> (the-as (inline-array vector4w) a2-22) 0 y) (* t3-0 16))
            (set! (-> (the-as (inline-array vector4w) a2-22) 0 z) a0-16)
            (set! (-> (the-as (inline-array vector4w) a2-22) 0 w) #x10000)
            )
          (let ((a2-23 (the-as object (&+ (the-as pointer v1-22) 160))))
            (set! (-> (the-as (inline-array vector4w) a2-23) 0 x) (* t0-0 16))
            (set! (-> (the-as (inline-array vector4w) a2-23) 0 y) (* t1-0 16))
            (set! (-> (the-as (inline-array vector4w) a2-23) 0 z) a0-16)
            (set! (-> (the-as (inline-array vector4w) a2-23) 0 w) #x10000)
            )
          (let ((v1-23 (the-as object (&+ (the-as pointer v1-22) 208))))
            (set! (-> (the-as (inline-array vector4w) v1-23) 0 x) (* a1-5 16))
            (set! (-> (the-as (inline-array vector4w) v1-23) 0 y) (* a3-2 16))
            (set! (-> (the-as (inline-array vector4w) v1-23) 0 z) a0-16)
            (set! (-> (the-as (inline-array vector4w) v1-23) 0 w) #x10000)
            )
          )
        (&+! (-> arg0 base) 224)
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs object.
;; og:preserve-this
;; (defmethod hud-sprite-method-10 ((this hud-sprite) (arg0 dma-buffer) (arg1 level) (arg2 int) (arg3 int) (arg4 int) (arg5 int))
;;   (local-vars
;;     (a0-4 uint128)
;;     (a1-14 int)
;;     (a2-1 int)
;;     (a3-1 int)
;;     (t0-3 int)
;;     (t1-3 int)
;;     (t2-1 int)
;;     (t3-0 int)
;;     (t6-0 int)
;;     (sv-16 level)
;;     (sv-32 hud-sprite-work)
;;     )
;;   (set! sv-16 arg1)
;;   (let ((s1-0 arg2)
;;         (s2-0 arg3)
;;         (s3-0 arg4)
;;         (s4-0 arg5)
;;         )
;;     (set! sv-32 *hud-sprite-work*)
;;     (let ((s0-0 (the-as object (-> this tid)))
;;           (f28-0 0.0)
;;           (f30-0 1.0)
;;           )
;;       (when (!= (-> this angle) 0.0)
;;         (set! f28-0 (sin (-> this angle)))
;;         (set! f30-0 (cos (-> this angle)))
;;         )
;;       (when (the-as texture-id s0-0)
;;         (when sv-16
;;           (let ((v1-8 (-> sv-16 texture-mask 8 mask quad))
;;                 (a0-3 (-> (the-as texture s0-0) masks data 0 mask quad))
;;                 )
;;             (.por a0-4 v1-8 a0-3)
;;             )
;;           (set! (-> sv-16 texture-mask 8 mask quad) a0-4)
;;           )
;;         (let ((v1-10 (the-as object (-> arg0 base))))
;;           (set! (-> (the-as (inline-array vector4w) v1-10) 0 quad) (-> sv-32 adgif-tmpl dma-vif quad))
;;           (set! (-> (the-as (inline-array vector4w) v1-10) 1 quad) (-> sv-32 adgif-tmpl quad 1))
;;           (adgif-shader<-texture-simple!
;;             (the-as adgif-shader (-> (the-as (inline-array vector4w) v1-10) 2))
;;             (the-as texture s0-0)
;;             )
;;           )
;;         (&+! (-> arg0 base) 112)
;;         (let ((v1-13 (the-as object (-> arg0 base)))
;;               (t1-1 (the int (* f30-0 (the float s1-0) (-> this scale-x) (-> *video-params* relative-x-scale))))
;;               (t0-1 (the int (* -1.0 (-> this scale-x) (the float s1-0) f28-0)))
;;               (t5-0 (the int (* f28-0 (the float s2-0) (-> this scale-y) (-> *video-params* relative-x-scale))))
;;               (t4-0 (the int (* f30-0 (the float s2-0) (-> this scale-y))))
;;               (a0-14 (if (nonzero? (-> this pos z))
;;                          (-> this pos z)
;;                          #xffffff
;;                          )
;;                      )
;;               )
;;           0
;;           0
;;           0
;;           0
;;           0
;;           0
;;           0
;;           0
;;           (cond
;;             ((logtest? (-> this flags) (hud-sprite-flags hsf2))
;;              (set! a3-1 (+ (-> this pos x) 1792))
;;              (set! t2-1 (+ (-> this pos y) 1840))
;;              (set! a1-14 (- a3-1 t1-1))
;;              (set! a2-1 (- t2-1 t0-1))
;;              (set! t3-0 (+ (- a3-1 t1-1) t5-0))
;;              (set! t6-0 (+ (- t2-1 t0-1) t4-0))
;;              (set! t1-3 (+ a3-1 t5-0))
;;              (set! t0-3 (+ t2-1 t4-0))
;;              )
;;             ((logtest? (-> this flags) (hud-sprite-flags hsf3))
;;              (set! a1-14 (+ (- 1792 (the int (* 0.5 (the float (+ t1-1 t5-0))))) (-> this pos x)))
;;              (set! a2-1 (+ (- 1840 (the int (* 0.5 (the float (+ t0-1 t4-0))))) (-> this pos y)))
;;              (set! a3-1 (+ (the int (* 0.5 (the float (+ t1-1 t5-0)))) 1792 (-> this pos x)))
;;              (set! t2-1 (+ (- 1840 (the int (* 0.5 (the float (+ t0-1 t4-0))))) (-> this pos y)))
;;              (set! t3-0 (+ (- 1792 (the int (* 0.5 (the float (+ t1-1 t5-0))))) (-> this pos x)))
;;              (set! t6-0 (+ (the int (* 0.5 (the float (+ t0-1 t4-0)))) 1840 (-> this pos y)))
;;              (set! t1-3 (+ (the int (* 0.5 (the float (+ t1-1 t5-0)))) 1792 (-> this pos x)))
;;              (set! t0-3 (+ (the int (* 0.5 (the float (+ t0-1 t4-0)))) 1840 (-> this pos y)))
;;              )
;;             (else
;;               (set! a1-14 (+ (-> this pos x) 1792))
;;               (set! a2-1 (+ (-> this pos y) 1840))
;;               (set! a3-1 (+ a1-14 t1-1))
;;               (set! t2-1 (+ a2-1 t0-1))
;;               (set! t3-0 (+ a1-14 t5-0))
;;               (set! t6-0 (+ a2-1 t4-0))
;;               (set! t1-3 (+ a1-14 t1-1 t5-0))
;;               (set! t0-3 (+ a2-1 t0-1 t4-0))
;;               )
;;             )
;;           (set! (-> (the-as (inline-array vector4w) v1-13) 0 quad) (-> sv-32 draw-tmpl dma-vif quad))
;;           (set! (-> (the-as (inline-array vector4w) v1-13) 1 quad) (-> sv-32 draw-tmpl quad 1))
;;           (set! (-> (the-as (inline-array vector4w) v1-13) 2 quad) (-> this color quad))
;;           (set! (-> (the-as (inline-array vector4w) v1-13) 5 quad) (-> this color quad))
;;           (set! (-> (the-as (inline-array vector4w) v1-13) 8 quad) (-> this color quad))
;;           (set! (-> (the-as (inline-array vector4w) v1-13) 11 quad) (-> this color quad))
;;           (let* ((t5-3 (-> (the-as texture s0-0) w))
;;                  (t4-13 (-> (the-as texture s0-0) h))
;;                  (f1-27 (/ (the float s1-0) (the float t5-3)))
;;                  (f2-2 (/ (the float s2-0) (the float t4-13)))
;;                  (f0-55 (* (the float s3-0) f1-27))
;;                  (f3-2 (the-as number (* (the float s4-0) f2-2)))
;;                  (f1-28 (+ f0-55 f1-27))
;;                  (f2-3 (+ (the-as float f3-2) f2-2))
;;                  )
;;             (when (logtest? (-> this flags) (hud-sprite-flags hsf0))
;;               (let ((f4-0 f0-55))
;;                 (set! f0-55 f1-28)
;;                 (set! f1-28 f4-0)
;;                 )
;;               )
;;             (when (logtest? (-> this flags) (hud-sprite-flags hsf1))
;;               (set! f2-3 (the-as float f3-2))
;;               (set! f3-2 (gpr->fpr t5-3))
;;               )
;;             (set-vector! (-> (the-as (inline-array vector) v1-13) 3) f0-55 (the-as float f3-2) 1.0 0.0)
;;             (set-vector! (-> (the-as (inline-array vector) v1-13) 6) f1-28 (the-as float f3-2) 1.0 0.0)
;;             (set-vector! (-> (the-as (inline-array vector) v1-13) 9) f0-55 f2-3 1.0 0.0)
;;             (set-vector! (-> (the-as (inline-array vector) v1-13) 12) f1-28 f2-3 1.0 0.0)
;;             )
;;           (set-vector!
;;             (-> (the-as (inline-array vector) v1-13) 4)
;;             (the-as float (* a1-14 16))
;;             (the-as float (* a2-1 16))
;;             (the-as float a0-14)
;;             (the-as float #x10000)
;;             )
;;           (set-vector!
;;             (-> (the-as (inline-array vector) v1-13) 7)
;;             (the-as float (* a3-1 16))
;;             (the-as float (* t2-1 16))
;;             (the-as float a0-14)
;;             (the-as float #x10000)
;;             )
;;           (set-vector!
;;             (-> (the-as (inline-array vector) v1-13) 10)
;;             (the-as float (* t3-0 16))
;;             (the-as float (* t6-0 16))
;;             (the-as float a0-14)
;;             (the-as float #x10000)
;;             )
;;           (set-vector!
;;             (-> (the-as (inline-array vector) v1-13) 13)
;;             (the-as float (* t1-3 16))
;;             (the-as float (* t0-3 16))
;;             (the-as float a0-14)
;;             (the-as float #x10000)
;;             )
;;           )
;;         (&+! (-> arg0 base) 224)
;;         )
;;       )
;;     )
;;   0
;;   )

(defmethod draw-box-prim-only ((this hud-box) (arg0 dma-buffer))
  (dma-buffer-add-gs-set arg0
                         (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                         (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                         )
  (let ((t1-0 *hud-sprite-work*)
        (v1-3 (the-as object (-> arg0 base)))
        (a2-8 (* (+ (the int (-> this box min x)) 1792) 16))
        (t0-0 (* (+ (the int (-> this box max x)) 1792) 16))
        (a3-13 (* (+ (the int (-> this box min y)) 1840) 16))
        )
    (let ((t2-2 (* (+ (the int (-> this box max y)) 1840) 16)))
      (set! (-> (the-as (inline-array vector4w) v1-3) 0 quad) (-> t1-0 box-tmpl dma-vif quad))
      (set! (-> (the-as (inline-array vector4w) v1-3) 1 quad) (-> t1-0 box-tmpl quad 1))
      (set! (-> (the-as (inline-array vector4w) v1-3) 2 quad) (-> this color quad))
      (set-vector! (-> (the-as (inline-array vector4w) v1-3) 3) a2-8 a3-13 #xffffff 0)
      (set-vector! (-> (the-as (inline-array vector4w) v1-3) 4) t0-0 a3-13 #xffffff 0)
      (set-vector! (-> (the-as (inline-array vector4w) v1-3) 5) t0-0 t2-2 #xffffff 0)
      (set-vector! (-> (the-as (inline-array vector4w) v1-3) 6) a2-8 t2-2 #xffffff 0)
      )
    (let ((v1-4 (the-as object (-> (the-as (inline-array vector4w) v1-3) 7))))
      (set! (-> (the-as (inline-array vector4w) v1-4) 0 x) a2-8)
      (set! (-> (the-as vector4w v1-4) y) a3-13)
      (set! (-> (the-as vector4w v1-4) z) #xffffff)
      (set! (-> (the-as vector4w v1-4) w) 0)
      )
    )
  (&+! (-> arg0 base) 128)
  0
  (none)
  )

(defmethod draw-box-alpha-1 ((this hud-box) (arg0 dma-buffer))
  (dma-buffer-add-gs-set arg0
                         (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                         (alpha-1 (new 'static 'gs-alpha :a #x2 :d #x1))
                         )
  (let ((t0-0 *hud-sprite-work*)
        (v1-3 (the-as (inline-array vector4w) (-> arg0 base)))
        (a2-8 (* (+ (the int (-> this box min x)) 1792) 16))
        (a3-11 (* (+ (the int (-> this box max x)) 1792) 16))
        (t2-0 (* (+ (the int (-> this box min y)) 1840) 16))
        (t1-4 (* (+ (the int (-> this box max y)) 1840) 16))
        )
    (set! (-> v1-3 0 quad) (-> t0-0 box2-tmpl dma-vif quad))
    (set! (-> v1-3 1 quad) (-> t0-0 box2-tmpl quad 1))
    (set! (-> v1-3 2 quad) (-> this color quad))
    (set-vector! (-> v1-3 3) a2-8 t2-0 #xffffff 0)
    (set-vector! (-> v1-3 4) a3-11 t2-0 #xffffff 0)
    (set-vector! (-> v1-3 5) a2-8 t1-4 #xffffff 0)
    (set-vector! (-> v1-3 6) a3-11 t1-4 #xffffff 0)
    )
  (&+! (-> arg0 base) 112)
  (dma-buffer-add-gs-set arg0 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)))
  0
  (none)
  )

(defmethod draw-box-alpha-2 ((this hud-box) (arg0 dma-buffer))
  (dma-buffer-add-gs-set arg0
                         (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                         (alpha-1 (new 'static 'gs-alpha :b #x2 :d #x1))
                         )
  (let ((t0-0 *hud-sprite-work*)
        (v1-3 (the-as (inline-array vector4w) (-> arg0 base)))
        (a2-8 (* (+ (the int (-> this box min x)) 1792) 16))
        (a3-11 (* (+ (the int (-> this box max x)) 1792) 16))
        (t2-0 (* (+ (the int (-> this box min y)) 1840) 16))
        (t1-4 (* (+ (the int (-> this box max y)) 1840) 16))
        )
    (set! (-> v1-3 0 quad) (-> t0-0 box2-tmpl dma-vif quad))
    (set! (-> v1-3 1 quad) (-> t0-0 box2-tmpl quad 1))
    (set! (-> v1-3 2 quad) (-> this color quad))
    (set-vector! (-> v1-3 3) a2-8 t2-0 #xffffff 0)
    (set-vector! (-> v1-3 4) a3-11 t2-0 #xffffff 0)
    (set-vector! (-> v1-3 5) a2-8 t1-4 #xffffff 0)
    (set-vector! (-> v1-3 6) a3-11 t1-4 #xffffff 0)
    )
  (&+! (-> arg0 base) 112)
  (dma-buffer-add-gs-set arg0 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)))
  0
  (none)
  )

(defmethod draw-box-alpha-3 ((this hud-box) (arg0 dma-buffer))
  (dma-buffer-add-gs-set arg0
                         (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                         (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                         )
  (let ((t0-0 *hud-sprite-work*)
        (v1-3 (the-as (inline-array vector4w) (-> arg0 base)))
        (a2-8 (* (+ (the int (-> this box min x)) 1792) 16))
        (a3-11 (* (+ (the int (-> this box max x)) 1792) 16))
        (t2-0 (* (+ (the int (-> this box min y)) 1840) 16))
        (t1-4 (* (+ (the int (-> this box max y)) 1840) 16))
        )
    (set! (-> v1-3 0 quad) (-> t0-0 box2-tmpl dma-vif quad))
    (set! (-> v1-3 1 quad) (-> t0-0 box2-tmpl quad 1))
    (set! (-> v1-3 2 quad) (-> this color quad))
    (set-vector! (-> v1-3 3) a2-8 t2-0 #xffffff 0)
    (set-vector! (-> v1-3 4) a3-11 t2-0 #xffffff 0)
    (set-vector! (-> v1-3 5) a2-8 t1-4 #xffffff 0)
    (set-vector! (-> v1-3 6) a3-11 t1-4 #xffffff 0)
    )
  (&+! (-> arg0 base) 112)
  0
  (none)
  )

;; WARN: Return type mismatch process vs hud.
(defmethod relocate ((this hud) (offset int))
  (dotimes (v1-0 14)
    (if (-> this strings v1-0 text)
        (&+! (-> this strings v1-0 text) offset)
        )
    )
  (the-as hud ((method-of-type process relocate) this offset))
  )

(defmethod draw ((this hud))
  (when (not (hidden? this))
    (with-dma-buffer-add-bucket ((s4-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hud-draw-hud-alpha)
                                 )
      (dotimes (s3-0 30)
        (if (and (-> this sprites s3-0 tid) (!= (-> this sprites s3-0 scale-x) 0.0))
            (draw (-> this sprites s3-0) s4-0 (-> this level) #f)
            )
        )
      (let ((s3-1
              (new 'stack 'font-context *font-default-matrix* 0 0 0.0 (font-color default) (font-flags shadow kerning))
              )
            )
        (dotimes (s2-0 14)
          (when (and (-> this strings s2-0 text) (nonzero? (-> this strings s2-0 pos x)))
            (set-vector!
              (-> s3-1 origin)
              (the float (-> this strings s2-0 pos x))
              (the float (-> this strings s2-0 pos y))
              (the float (-> this strings s2-0 pos z))
              1.0
              )
            (set! (-> s3-1 scale) (-> this strings s2-0 scale))
            (set! (-> s3-1 flags) (-> this strings s2-0 flags))
            (set! (-> s3-1 color) (-> this strings s2-0 color))
            (set-context! *font-work* s3-1)
            (draw-string (-> this strings s2-0 text) s4-0 s3-1)
            )
          )
        )
      )
    (dotimes (s5-1 2)
      (when (-> this icons s5-1 icon)
        (set-vector!
          (-> this icons s5-1 icon 0 root scale)
          (* (-> this icons s5-1 scale-x) (-> *video-params* relative-x-scale))
          (-> this icons s5-1 scale-y)
          (* (-> this icons s5-1 scale-x) (-> *video-params* relative-x-scale))
          1.0
          )
        (if (get-horizontal-flip-flag *blit-displays-work*)
            (set! (-> this icons s5-1 icon 0 root trans x) (the float (- 256 (-> this icons s5-1 pos x))))
            (set! (-> this icons s5-1 icon 0 root trans x) (the float (+ (-> this icons s5-1 pos x) -256)))
            )
        (set! (-> this icons s5-1 icon 0 root trans y) (the float (* (+ (-> this icons s5-1 pos y) -208) 2)))
        (set! (-> this icons s5-1 icon 0 root trans z) (the float (-> this icons s5-1 pos z)))
        )
      )
    )
  0
  (none)
  )

(defmethod update-value-callback ((this hud) (arg0 int) (arg1 int))
  0
  (none)
  )

(defmethod update-values! ((this hud))
  (with-pp
    (let ((s5-0 #f))
      (let ((v1-0 #f))
        (dotimes (a0-1 8)
          (when (!= (-> this values a0-1 current) (-> this values a0-1 target))
            (if (= (-> this values a0-1 current) -1)
                (set! v1-0 #t)
                (set! s5-0 #t)
                )
            )
          )
        (set! v1-0 (or s5-0 v1-0))
        (when v1-0
          (dotimes (s4-0 8)
            (cond
              ((and (or (and (logtest? (-> this values s4-0 flags) 1) (< (-> this values s4-0 current) (-> this values s4-0 target)))
                        (and (logtest? (-> this values s4-0 flags) 2) (< (-> this values s4-0 target) (-> this values s4-0 current)))
                        )
                    (!= (-> this values s4-0 current) -1)
                    )
               (when (not (hidden? this))
                 (set! (-> this values s4-0 counter)
                       (the-as uint (seekl
                                      (the-as int (-> this values s4-0 counter))
                                      0
                                      (the-as int (- (current-time) (-> pp clock old-frame-counter)))
                                      )
                               )
                       )
                 (when (and (zero? (-> this values s4-0 counter)) (!= (-> this values s4-0 current) (-> this values s4-0 target)))
                   (let ((v1-42 (abs (- (-> this values s4-0 current) (-> this values s4-0 target))))
                         (s3-0 1)
                         )
                     (cond
                       ((and (logtest? (-> this values s4-0 flags) 8) (>= v1-42 (* (the-as uint 100) (-> this values s4-0 inc-unit))))
                        (set! s3-0 (the-as int (* (the-as uint (the-as int 100)) (-> this values s4-0 inc-unit))))
                        )
                       ((and (logtest? (-> this values s4-0 flags) 4) (>= v1-42 (* (the-as uint 10) (-> this values s4-0 inc-unit))))
                        (set! s3-0 (the-as int (* (the-as uint (the-as int 10)) (-> this values s4-0 inc-unit))))
                        )
                       ((>= v1-42 (the-as int (-> this values s4-0 inc-unit)))
                        (set! s3-0 (the-as int (-> this values s4-0 inc-unit)))
                        )
                       )
                     (update-value-callback this s4-0 (if (< (-> this values s4-0 current) (-> this values s4-0 target))
                                                          s3-0
                                                          (- s3-0)
                                                          )
                                            )
                     (seekl! (-> this values s4-0 current) (-> this values s4-0 target) s3-0)
                     )
                   (set! (-> this values s4-0 counter) (-> this values s4-0 inc-time))
                   )
                 )
               )
              (else
                (set! (-> this values s4-0 current) (-> this values s4-0 target))
                )
              )
            )
          )
        )
      (if (and (not *progress-process*)
               (time-elapsed? (-> this last-hide-time) (seconds 0.05))
               (>= (- (-> *display* base-clock frame-counter) (-> *game-info* letterbox-time)) (seconds 0.1))
               (>= (- (-> *display* base-clock frame-counter) (-> *game-info* blackout-time)) (seconds 0.1))
               (or (not *target*) (not (focus-test? *target* grabbed)) (logtest? (-> this flags) (hud-flags show)))
               (not (logtest? (-> this flags) (hud-flags disable)))
               (not (or (= *master-mode* 'progress) (= *master-mode* 'menu)))
               (or s5-0
                   (cond
                     (*debug-segment*
                       (let ((a0-63 (-> *cpad-list* cpads 0)))
                         (logtest? (logclear (pad-buttons l3) (-> a0-63 button0-abs 0))
                                   (logior (-> a0-63 button0-abs 2) (-> a0-63 button0-abs 1))
                                   )
                         )
                       )
                     (else
                       (cpad-hold? 0 l3)
                       )
                     )
                   (logtest? (-> this flags) (hud-flags show))
                   )
               (check-ready-and-maybe-show this #t)
               )
          (go hud-arriving)
          )
      )
    0
    (none)
    )
  )

(defmethod init-callback ((this hud))
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod event-callback ((this hud) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  #f
  )

(defmethod hud-method-19 ((this hud))
  0
  (none)
  )

(defmethod hud-method-20 ((this hud))
  0
  (none)
  )

(defmethod hud-method-21 ((this hud))
  0
  (none)
  )

(defmethod hud-method-22 ((this hud))
  0
  (none)
  )

(defmethod hidden? ((this hud))
  (and (-> this next-state) (= (-> this next-state name) 'hud-hidden))
  )

;; WARN: Return type mismatch (pointer process) vs (pointer manipy).
(defun hud-create-icon ((arg0 hud) (arg1 int) (arg2 int))
  (let ((s4-0
          (process-spawn
            manipy
            :init manipy-init
            (new 'static 'vector :w 1.0)
            #f
            arg2
            #f
            0
            :name "manipy"
            :to arg0
            :stack-size #x20000
            )
          )
        )
    (the-as
      (pointer manipy)
      (when (and s4-0 (nonzero? (-> (the-as process-drawable (-> s4-0 0)) draw)))
        (set! (-> (the-as manipy (-> s4-0 0)) draw dma-add-func)
              (the-as (function process-drawable draw-control symbol object none) dma-add-process-drawable-hud)
              )
        (logior! (-> s4-0 0 mask) (process-mask freeze pause))
        (logclear! (-> s4-0 0 mask) (process-mask menu progress))
        (send-event (ppointer->process s4-0) 'draw #f)
        (set! (-> arg0 icons arg1 icon) (the-as (pointer manipy) s4-0))
        s4-0
        )
      )
    )
  )

(defmethod alloc-string-if-needed ((this hud) (arg0 int))
  (if (not (-> this strings arg0 text))
      (set! (-> this strings arg0 text) (new 'process 'string 64 (the-as string #f)))
      )
  0
  (none)
  )

(defbehavior hud-hidden-event-handler hud ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-1 object))
  (case arg2
    (('show)
     (if (and (not *progress-process*)
              (!= (-> self last-hide-time) (current-time))
              (check-ready-and-maybe-show self #t)
              )
         (go hud-arriving)
         )
     )
    (('hide)
     (set! v0-1 (current-time))
     (set! (-> self last-hide-time) (the-as time-frame v0-1))
     v0-1
     )
    (('force-hide)
     (set-time! (-> self last-hide-time))
     (set! v0-1 (logclear (-> self flags) (hud-flags show)))
     (set! (-> self flags) (the-as hud-flags v0-1))
     v0-1
     )
    (('force-show)
     (logior! (-> self flags) (hud-flags show))
     (if (and (not *progress-process*)
              (!= (-> self last-hide-time) (current-time))
              (check-ready-and-maybe-show self #t)
              )
         (go hud-arriving)
         )
     )
    (('hide-quick)
     (set! v0-1 (current-time))
     (set! (-> self last-hide-time) (the-as time-frame v0-1))
     v0-1
     )
    (('hide-and-die)
     (set-time! (-> self last-hide-time))
     (logior! (-> self flags) (hud-flags should-die))
     (set! v0-1 (logclear (-> self flags) (hud-flags show)))
     (set! (-> self flags) (the-as hud-flags v0-1))
     v0-1
     )
    (('sync)
     (dotimes (v1-23 8)
       (set! (-> self values v1-23 current) -1)
       )
     #f
     )
    (('disable)
     (set! v0-1 (logior (-> self flags) (hud-flags disable)))
     (set! (-> self flags) (the-as hud-flags v0-1))
     v0-1
     )
    (('enable)
     (set! v0-1 (logclear (-> self flags) (hud-flags disable)))
     (set! (-> self flags) (the-as hud-flags v0-1))
     v0-1
     )
    (('ready)
     (dotimes (v1-27 8)
       (if (and (logtest? (-> self values v1-27 flags) 3)
                (or (zero? (-> self values v1-27 counter)) (= (-> self values v1-27 target) (-> self values v1-27 current)))
                )
           (set! (-> self values v1-27 counter) (if (= (-> arg3 param 0) -1)
                                                    (-> self values v1-27 inc-time)
                                                    (-> arg3 param 0)
                                                    )
                 )
           )
       )
     #f
     )
    (else
      (event-callback self arg0 arg1 arg2 arg3)
      )
    )
  )

(defstate hud-hidden (hud)
  :event hud-hidden-event-handler
  :enter (behavior ()
    (set-action!
      *gui-control*
      (gui-action hidden)
      (-> self gui-id)
      (gui-channel none)
      (gui-action none)
      (the-as string #f)
      (the-as (function gui-connection symbol) #f)
      (the-as process #f)
      )
    (set! (-> self offset) 1.0)
    (let ((gp-0 (-> self child)))
      (while gp-0
        (send-event (ppointer->process gp-0) 'draw #f)
        (set! gp-0 (-> gp-0 0 brother))
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (if (logtest? (-> self flags) (hud-flags should-die))
        (deactivate self)
        )
    (update-values! self)
    )
  )

(defstate hud-arriving (hud)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-1 object))
    (case message
      (('hide-quick)
       (set-time! (-> self last-hide-time))
       (set! (-> self offset) 1.0)
       (update-values! self)
       (go hud-hidden)
       )
      (('force-hide)
       (set-time! (-> self last-hide-time))
       (logclear! (-> self flags) (hud-flags show))
       (go hud-leaving 0.1)
       )
      (('force-show)
       (logior! (-> self flags) (hud-flags show))
       (if (and (not *progress-process*)
                (!= (-> self last-hide-time) (current-time))
                (check-ready-and-maybe-show self #t)
                )
           (go hud-arriving)
           )
       )
      (('hide)
       (set-time! (-> self last-hide-time))
       (go hud-leaving 0.1)
       )
      (('hide-and-die)
       (set-time! (-> self last-hide-time))
       (logior! (-> self flags) (hud-flags should-die))
       (logclear! (-> self flags) (hud-flags show))
       (go hud-leaving 0.1)
       )
      (('show)
       (if (and (not *progress-process*)
                (!= (-> self last-hide-time) (current-time))
                (check-ready-and-maybe-show self #t)
                )
           (go hud-arriving)
           )
       )
      (('sync)
       (dotimes (v1-34 8)
         (set! (-> self values v1-34 current) -1)
         )
       #f
       )
      (('disable)
       (set! v0-1 (logior (-> self flags) (hud-flags disable)))
       (set! (-> self flags) (the-as hud-flags v0-1))
       v0-1
       )
      (('enable)
       (set! v0-1 (logclear (-> self flags) (hud-flags disable)))
       (set! (-> self flags) (the-as hud-flags v0-1))
       v0-1
       )
      (else
        (event-callback self proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self trigger-time))
    (let ((gp-0 (-> self child)))
      (while gp-0
        (send-event (ppointer->process gp-0) 'draw #t)
        (set! gp-0 (-> gp-0 0 brother))
        )
      )
    )
  :code (behavior ()
    (until #f
      (if (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask pause)))
          (seek! (-> self offset) 0.0 (* 0.1 (-> self clock time-adjust-ratio)))
          )
      (if (>= 0.0 (-> self offset))
          (go hud-in)
          )
      (when (= (get-status *gui-control* (-> self gui-id)) (gui-status pending))
        (set! (-> self event-hook) #f)
        (set-time! (-> self last-hide-time))
        (set! (-> self offset) 1.0)
        (update-values! self)
        (go hud-hidden)
        )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (update-values! self)
    (if (not (and (nonzero? *screen-shot-work*)
                  (!= (-> *screen-shot-work* count) -1)
                  (not (-> *screen-shot-work* hud-enable))
                  )
             )
        (draw self)
        )
    )
  )

(defstate hud-in (hud)
  :event (-> hud-arriving event)
  :code (behavior ()
    (set-time! (-> self trigger-time))
    (while (and (not (time-elapsed? (-> self trigger-time) (seconds 2))) (check-ready-and-maybe-show self #f))
      (set! (-> self offset) 0.0)
      (suspend)
      )
    (when (= (get-status *gui-control* (-> self gui-id)) (gui-status pending))
      (set! (-> self event-hook) #f)
      (set-time! (-> self last-hide-time))
      (set! (-> self offset) 1.0)
      (update-values! self)
      (go hud-hidden)
      )
    (go hud-leaving 0.05)
    )
  :post (-> hud-arriving post)
  )

(defstate hud-leaving (hud)
  :event (-> hud-arriving event)
  :code (behavior ((arg0 float))
    (until #f
      (if (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask pause)))
          (seek! (-> self offset) 1.0 (* arg0 (-> self clock time-adjust-ratio)))
          )
      (when (= (get-status *gui-control* (-> self gui-id)) (gui-status pending))
        (set! (-> self event-hook) #f)
        (set-time! (-> self last-hide-time))
        (set! (-> self offset) 1.0)
        (update-values! self)
        (go hud-hidden)
        )
      (if (>= (-> self offset) 1.0)
          (go hud-hidden)
          )
      (suspend)
      )
    #f
    )
  :post (-> hud-arriving post)
  )

(defbehavior hud-init-by-other hud ()
  (add-connection *hud-engine* self #f self (-> self type symbol) #f)
  (set! (-> self mask) (process-mask menu))
  (+! (-> self clock ref-count) -1)
  (+! (-> *display* real-clock ref-count) 1)
  (set! (-> self clock) (-> *display* real-clock))
  (set! (-> self flags) (hud-flags))
  (set-time! (-> self last-hide-time))
  (set! (-> self offset) 1.0)
  (dotimes (v1-16 14)
    (set! (-> self strings v1-16 text) #f)
    (set! (-> self strings v1-16 scale) 1.0)
    (set! (-> self strings v1-16 color) (font-color white))
    (set! (-> self strings v1-16 flags) (font-flags shadow kerning large))
    (set! (-> self strings v1-16 pos x) 0)
    (set! (-> self strings v1-16 pos z) #xfffffff)
    (set! (-> self strings v1-16 pos w) 0)
    )
  (dotimes (v1-19 30)
    (let ((a0-17 (&+ (-> self sprites 0 color-ptr) (* v1-19 64))))
      (set! (-> a0-17 0) 128)
      (set! (-> a0-17 1) 128)
      (set! (-> a0-17 2) 128)
      (set! (-> a0-17 3) 128)
      )
    (set! (-> self sprites v1-19 pos z) #xffffff)
    (set! (-> self sprites v1-19 pos w) 0)
    (set! (-> self sprites v1-19 scale-x) 1.0)
    (set! (-> self sprites v1-19 scale-y) 1.0)
    (set! (-> self sprites v1-19 angle) 0.0)
    (set! (-> self sprites v1-19 flags) (hud-sprite-flags))
    (set! (-> self sprites v1-19 tid) (the-as texture-id #f))
    )
  (dotimes (v1-22 2)
    (set! (-> self icons v1-22 icon) (the-as (pointer manipy) #f))
    (set! (-> self icons v1-22 pos z) 1024)
    (set! (-> self icons v1-22 scale-x) 1.0)
    (set! (-> self icons v1-22 scale-y) 1.0)
    )
  (dotimes (v1-25 8)
    (set! (-> self values v1-25 current) -1)
    (set! (-> self values v1-25 target) 0)
    )
  (init-callback self)
  (set! (-> self event-hook) hud-hidden-event-handler)
  (go hud-hidden)
  )

(defun hide-hud ((arg0 symbol))
  (when *target*
    (let ((v1-3 (-> *hud-engine* alive-list next0)))
      *hud-engine*
      (let ((s5-0 (-> v1-3 next0)))
        (while (!= v1-3 (-> *hud-engine* alive-list-end))
          (if (or (not arg0) (= arg0 (-> (the-as connection v1-3) param2)))
              (send-event (the-as process-tree (-> (the-as connection v1-3) param1)) 'hide)
              )
          (set! v1-3 s5-0)
          *hud-engine*
          (set! s5-0 (-> s5-0 next0))
          )
        )
      )
    )
  0
  (none)
  )

(defun enable-hud ()
  (when *target*
    (let ((v1-3 (-> *hud-engine* alive-list next0)))
      *hud-engine*
      (let ((gp-0 (-> v1-3 next0)))
        (while (!= v1-3 (-> *hud-engine* alive-list-end))
          (send-event (the-as process-tree (-> (the-as connection v1-3) param1)) 'enable)
          (set! v1-3 gp-0)
          *hud-engine*
          (set! gp-0 (-> gp-0 next0))
          )
        )
      )
    )
  0
  (none)
  )

(defun hide-hud-quick ((arg0 symbol))
  (when *target*
    (let ((v1-3 (-> *hud-engine* alive-list next0)))
      *hud-engine*
      (let ((s5-0 (-> v1-3 next0)))
        (while (!= v1-3 (-> *hud-engine* alive-list-end))
          (if (or (not arg0) (= arg0 (-> (the-as connection v1-3) param2)))
              (send-event (the-as process-tree (-> (the-as connection v1-3) param1)) 'hide-quick)
              )
          (set! v1-3 s5-0)
          *hud-engine*
          (set! s5-0 (-> s5-0 next0))
          )
        )
      )
    )
  0
  (none)
  )

(defun show-hud ((arg0 object))
  (when (and *target* (or (not *progress-process*) (gone? (-> *progress-process* 0))))
    (let ((v1-7 (-> *hud-engine* alive-list next0)))
      *hud-engine*
      (let ((s5-0 (-> v1-7 next0)))
        (while (!= v1-7 (-> *hud-engine* alive-list-end))
          (if (or (not arg0) (= arg0 (-> (the-as connection v1-7) param2)))
              (send-event (the-as process-tree (-> (the-as connection v1-7) param1)) 'show)
              )
          (set! v1-7 s5-0)
          *hud-engine*
          (set! s5-0 (-> s5-0 next0))
          )
        )
      )
    )
  0
  (none)
  )

(defun ready-hud ((arg0 symbol) (arg1 int))
  (when (and *target* (or (not *progress-process*) (gone? (-> *progress-process* 0))))
    (let ((v1-7 (-> *hud-engine* alive-list next0)))
      *hud-engine*
      (let ((s4-0 (-> v1-7 next0)))
        (while (!= v1-7 (-> *hud-engine* alive-list-end))
          (if (or (not arg0) (= arg0 (-> (the-as connection v1-7) param2)))
              (send-event (the-as process-tree (-> (the-as connection v1-7) param1)) 'ready arg1)
              )
          (set! v1-7 s4-0)
          *hud-engine*
          (set! s4-0 (-> s4-0 next0))
          )
        )
      )
    )
  0
  (none)
  )

(defun hud-hidden? ()
  (local-vars (gp-0 symbol))
  (cond
    (*target*
      (set! gp-0 #t)
      (let ((v1-2 (-> *hud-engine* alive-list next0)))
        *hud-engine*
        (let ((s5-0 (-> v1-2 next0)))
          (while (!= v1-2 (-> *hud-engine* alive-list-end))
            (if (not (hidden? (the-as hud (-> (the-as connection v1-2) param1))))
                (set! gp-0 #f)
                )
            (set! v1-2 s5-0)
            *hud-engine*
            (set! s5-0 (-> s5-0 next0))
            )
          )
        )
      )
    (else
      (set! gp-0 #t)
      )
    )
  gp-0
  )

(defun set-hud-piece-position! ((arg0 hud-sprite) (arg1 int) (arg2 int))
  (set! (-> arg0 pos x) arg1)
  (set! (-> arg0 pos y) arg2)
  0
  (none)
  )

(defun set-as-offset-from! ((arg0 hud-sprite) (arg1 vector4w) (arg2 int) (arg3 int))
  (set! (-> arg0 pos x) (+ (-> arg1 x) (the int (* (the float arg2) (-> *video-params* relative-x-scale)))))
  (set! (-> arg0 pos y) (+ (-> arg1 y) arg3))
  0
  (none)
  )
