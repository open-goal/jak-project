;;-*-Lisp-*-
(in-package goal)

;; name: progress.gc
;; name in dgo: progress
;; dgos: GAME

(define-extern memcard-unlocked-secrets? (function object symbol game-secrets))
(define-extern *progress-list-level* progress-list-level)

;; DECOMP BEGINS

(kmemopen global "progress-data")

(define *progress-stack* (the-as (pointer uint8) (malloc 'global #x3800)))

(define *progress-process* (the-as (pointer progress) #f))

(define *progress-save-info* (new 'global 'mc-slot-info))

(define *progress-work*
  (new 'static 'progress-work
    :full-screen (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2 :max (new 'static 'vector2 :data (new 'static 'array float 2 512.0 416.0)))
        :color (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2 :max (new 'static 'vector2 :data (new 'static 'array float 2 512.0 416.0)))
        :color (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80)
        )
      )
    :small-screen (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 72.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 329.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 38.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 362.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80)
        )
      )
    :header (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 72.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 117.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 38.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 83.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :body (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 117.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 329.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 83.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 362.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :body-footer (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 117.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 304.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 83.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 337.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :footer (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 304.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 329.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 337.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 362.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :sub-header (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 117.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 145.0))
          )
        :color (new 'static 'vector4w :x #xc0 :y #xc0 :z 96 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 83.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 111.0))
          )
        :color (new 'static 'vector4w :x #xc0 :y #xc0 :z 96 :w #x80)
        )
      )
    :sub-body (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 145.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 329.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 111.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 362.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :sub-body-footer (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 145.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 304.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 111.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 337.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :highscore-0 (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 117.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 165.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 83.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 131.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :highscore-1 (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 165.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 181.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 131.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 147.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :highscore-body (new 'static 'progress-box
      :aspect4x3 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 70.0 181.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 444.0 304.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      :aspect16x9 (new 'static 'hud-box
        :box (new 'static 'bounding-box2
          :min (new 'static 'vector2 :data (new 'static 'array float 2 79.0 147.0))
          :max (new 'static 'vector2 :data (new 'static 'array float 2 434.0 337.0))
          )
        :color (new 'static 'vector4w :x #x80 :y #x80 :z 64 :w #x80)
        )
      )
    :last-slot-saved -1
    :secrets-unlocked #f
    :hero-mode-save #f
    )
  )

(kmemclose)

(defun min-max-wrap-around ((arg0 int) (arg1 int) (arg2 int))
  (let ((v1-2 (+ (- 1 arg1) arg2)))
    (while (< arg0 arg1)
      (+! arg0 v1-2)
      )
    (while (< arg2 arg0)
      (set! arg0 (- arg0 v1-2))
      )
    )
  arg0
  )

(defun progress-intro-start ()
  (set! (-> *game-info* mode) 'play)
  (initialize! *game-info* 'game (the-as game-save #f) "intro-start" (the-as resetter-spec #f))
  (set-master-mode 'game)
  0
  )

;; WARN: Return type mismatch int vs object.
(defmethod init-defaults ((this progress))
  (local-vars (v0-3 int))
  (set! (-> this total-num-tasks) 0)
  (set! (-> this clear-screen) #f)
  (set! (-> this scanlines-alpha) 0.0)
  (set-time! (-> this start-time))
  (set! (-> this which-slot) (-> *progress-work* last-slot-saved))
  (set! (-> this yes-no-choice) #f)
  (set-time! (-> this time-out))
  (set-time! (-> this last-sound))
  (set-time! (-> this last-move))
  (set! (-> this center-x-backup) (-> *setting-control* user-default screenx))
  (set! (-> this center-y-backup) (-> *setting-control* user-default screeny))
  (set! (-> this flip-horizontal) (the-as basic (-> *setting-control* cam-default flip-horizontal)))
  (set! (-> this flip-vertical) (the-as basic (-> *setting-control* cam-default flip-vertical)))
  (set! (-> this progressive-scan) (the-as basic (-> *setting-control* user-default set-video-mode)))
  (set! (-> this aspect-ratio) (the-as basic (get-aspect-ratio)))
  (set! (-> this video-mode) (the-as basic (get-video-mode)))
  (set! (-> this stereo-mode-backup) (-> *setting-control* user-default stereo-mode))
  (set! (-> this vibrations) (the-as basic (-> *setting-control* user-default vibration)))
  (set! (-> this subtitles) (the-as basic (-> *setting-control* user-default subtitle)))
  (set! (-> this language-index) (the-as int (-> *setting-control* user-default language)))
  (set! (-> this subtitle-language-index) (the-as int (-> *setting-control* user-default subtitle-language)))
  (set! (-> this audio-language-index) (the-as int (-> *setting-control* user-default audio-language)))
  (set! (-> (the-as menu-missions-option (-> *missions-options* options 0)) current-index) 0.0)
  (set! (-> (the-as menu-missions-option (-> *missions-options* options 0)) target-index) 0.0)
  (set! (-> *progress-work* secrets-unlocked) #f)
  (set! (-> *progress-work* hero-mode-save) #f)
  (set-setting-by-param *setting-control* 'extra-bank '((force2 menu1)) 0 0)
  (cond
    ((or (nonzero? (-> *setting-control* user-current subtitle-language))
         (nonzero? (-> *setting-control* user-current language))
         (nonzero? (-> *setting-control* user-current audio-language))
         )
     (set! v0-3 11)
     (set! (-> *unlocked-secrets* options length) v0-3)
     )
    (else
      (set! v0-3 12)
      (set! (-> *unlocked-secrets* options length) v0-3)
      )
    )
  v0-3
  )

(deftype hud-ring-cell (process-drawable)
  ((parent         (pointer progress) :override)
   (joint-idx      int32)
   (init-angle     float)
   (graphic-index  int32)
   )
  (:state-methods
    idle
    )
  )


(defun hud-ring-cell-remap ((arg0 hud-ring-cell))
  (let ((v1-0 *hud-ring-graphic-remap*))
    (when (not *cheat-mode*)
      (case *kernel-boot-message*
        (('quote 'kiosk)
         (set! v1-0 *hud-ring-kiosk-graphic-remap*)
         )
        (('quote 'demo)
         (set! v1-0 *hud-ring-demo-graphic-remap*)
         )
        (('quote 'demo-shared)
         (set! v1-0 *hud-ring-demo-shared-graphic-remap*)
         )
        )
      )
    (setup-masks
      (-> arg0 draw)
      (the-as int (-> v1-0 (mod (+ (-> arg0 graphic-index) (-> arg0 parent 0 graphic-index)) (-> v1-0 length))))
      0
      )
    )
  (none)
  )

(defbehavior hud-ring-cell-init-by-other hud-ring-cell ((arg0 int) (arg1 float) (arg2 int))
  (set! (-> self root) (new 'process 'trsqv))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-hud-ring-part" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self joint-idx) arg0)
  (set! (-> self init-angle) arg1)
  (set! (-> self graphic-index) arg2)
  (set! (-> self root trans quad) (-> self parent 0 root trans quad))
  (quaternion-copy! (-> self root quat) (-> self parent 0 root quat))
  (quaternion-normalize! (-> self root quat))
  (set! (-> self root scale quad) (-> self parent 0 root scale quad))
  (let ((gp-1 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *z-vector* (-> self init-angle))))
    (quaternion-normalize! gp-1)
    (quaternion*! (-> self root quat) (-> self root quat) gp-1)
    )
  (quaternion-normalize! (-> self root quat))
  (set-vector! (-> self draw color-mult) 0.8 0.8 0.8 1.0)
  (logior! (-> self draw global-effect) (draw-control-global-effect title-light))
  (logior! (-> self draw status) (draw-control-status hud))
  (setup-masks (-> self draw) 1 0)
  (setup-masks (-> self draw) 0 2046)
  (hud-ring-cell-remap self)
  (go-virtual idle)
  )

(defstate idle (hud-ring-cell)
  :virtual #t
  :code (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    (sleep-code)
    )
  :post (behavior ()
    (vector<-cspace! (-> self root trans) (-> self parent 0 node-list data (-> self joint-idx)))
    (when (-> self parent 0 main-menu)
      (setup-masks (-> self draw) 0 2046)
      (hud-ring-cell-remap self)
      )
    (when (= (-> self init-angle) 0.0)
      (if (= (-> self parent 0 ring-angle) (-> self parent 0 ring-want-angle))
          (set-vector! (-> self draw color-mult) 1.2 1.2 1.2 1.0)
          (set-vector! (-> self draw color-mult) 0.8 0.8 0.8 1.0)
          )
      )
    (let* ((t9-3 quaternion-vector-angle!)
           (a0-11 (new 'stack-no-clear 'quaternion))
           (a1-5 *z-vector*)
           (f0-10 (-> self init-angle))
           (f1-2 (-> self parent 0 ring-angle))
           (gp-0 (t9-3 a0-11 a1-5 (+ f0-10 (- f1-2 (* (the float (the int (/ f1-2 6553.6))) 6553.6)))))
           )
      (quaternion-normalize! gp-0)
      (quaternion-copy! (-> self root quat) (-> self parent 0 root quat))
      (quaternion-normalize! (-> self root quat))
      (quaternion*! (-> self root quat) (-> self root quat) gp-0)
      )
    (quaternion-normalize! (-> self root quat))
    (ja-post)
    )
  )

(defbehavior progress-init-by-other progress ((arg0 symbol))
  (set! (-> self progress-id)
        (the-as uint (add-process *gui-control* self (gui-channel progress) (gui-action play) "progress" -99.0 0))
        )
  (disable-level-text-file-loading)
  (logclear! (-> self mask) (process-mask menu progress actor-pause))
  (add-setting! 'process-mask 'set 0.0 (process-mask progress))
  (+! (-> self clock ref-count) -1)
  (+! (-> *display* real-clock ref-count) 1)
  (set! (-> self clock) (-> *display* real-clock))
  (apply-settings *setting-control*)
  (set-blackout-frames 0)
  (set! *pause-lock* #f)
  (set! (-> self root) (new 'process 'trsqv))
  (matrix->quaternion (-> self root quat) (-> *math-camera* inv-camera-rot))
  (let ((a2-3 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *y-vector* 32768.0)))
    (quaternion*! (-> self root quat) (-> self root quat) a2-3)
    )
  (quaternion-normalize! (-> self root quat))
  (quaternion-copy! (-> self init-quat) (-> self root quat))
  (set-vector! (-> self root scale) 0.09 0.09 0.09 1.0)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-hud-ring" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logior! (-> self draw global-effect) (draw-control-global-effect title-light))
  (logior! (-> self skel status) (joint-control-status sync-math))
  (set! (-> self state-pos) 0)
  (set! (-> self menu-transition) 1.0)
  (set! (-> self anim-frame) 0.0)
  (set! (-> self pos-transition) 1.0)
  (init-defaults self)
  (set-next-state self arg0 0)
  (set! (-> self starting-state) (the-as basic (-> self next)))
  (set! (-> self current) (-> self next))
  (if (= arg0 'main)
      (set! (-> self next) 'none)
      )
  (set! (-> self ring-angle) 0.0)
  (set! (-> self ring-want-angle) 0.0)
  (set! (-> self want-option-index) 0)
  (set! (-> self graphic-index) 0)
  (set! (-> self swing) 0.0)
  (set! (-> self main-menu) #f)
  (set-menu-options self (-> self current))
  (logior! (-> self draw status) (draw-control-status hud))
  (set! (-> self option-index) 0)
  (when (= (-> self current) 'title)
    (mc-get-slot-info 0 *progress-save-info*)
    (let ((v1-54 *progress-save-info*))
      (when (and v1-54 (= (-> v1-54 formatted) 1) (= (-> v1-54 inited) 1))
        (dotimes (a0-34 4)
          (when (= (-> v1-54 file a0-34 present) 1)
            (set! (-> self option-index) 1)
            (set! (-> self next-option-index) 1)
            )
          )
        )
      )
    )
  (let ((f30-0 -6571.804))
    (process-spawn hud-ring-cell 15 (* 0.0 f30-0) 0 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 9 f30-0 1 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 8 (* 2.0 f30-0) 2 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 7 (* 3.0 f30-0) 3 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 6 (* 4.0 f30-0) 4 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 16 (* -5.0 f30-0) 5 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 14 (* -4.0 f30-0) 6 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 13 (* -3.0 f30-0) 7 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 12 (* -2.0 f30-0) 8 :name "hud-ring-cell" :to self)
    (process-spawn hud-ring-cell 11 (* -1.0 f30-0) 9 :name "hud-ring-cell" :to self)
    )
  (clear *stdcon1*)
  (enable-drawing *bigmap*)
  (set-setting! 'scanlines 'abs 0.0 0)
  (go-virtual come-in)
  )

(defun set-ring-position ((arg0 progress))
  (let ((s3-0 (new-stack-vector0))
        (s4-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (+! (-> s3-0 y) -8.0)
    (case (get-aspect-ratio)
      (('aspect4x3)
       (position-in-front-of-screen! s4-0 12288.0 s3-0)
       (position-in-front-of-screen! s5-0 -4096.0 s3-0)
       )
      (else
        (position-in-front-of-screen! s4-0 16384.0 s3-0)
        (position-in-front-of-screen! s5-0 -18022.4 s3-0)
        )
      )
    (vector-! s5-0 s5-0 s4-0)
    (set! (-> arg0 root trans x) (+ (-> s4-0 x) (* (-> arg0 pos-transition) (-> s5-0 x))))
    (set! (-> arg0 root trans y) (+ (-> s4-0 y) (* (-> arg0 pos-transition) (-> s5-0 y))))
    (set! (-> arg0 root trans z) (+ (-> s4-0 z) (* (-> arg0 pos-transition) (-> s5-0 z))))
    )
  )

(defun activate-progress ((arg0 process) (arg1 symbol))
  (when *target*
    (when (progress-allowed?)
      (when *progress-process*
        (deactivate (-> *progress-process* 0))
        (set-menu-mode *blit-displays-work* #t)
        )
      (set! *progress-process*
            (process-spawn progress arg1 :name "progress" :to arg0 :stack (&-> *progress-stack* 14336))
            )
      (set-master-mode 'progress)
      )
    )
  0
  (none)
  )

(defmethod deactivate ((this progress))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (set! (-> *progress-work* hero-mode-save) #f)
  (remove-setting-by-arg0 *setting-control* 'extra-bank)
  (disable-drawing *bigmap*)
  (set-menu-mode *blit-displays-work* #f)
  (set! *progress-process* (the-as (pointer progress) #f))
  (enable-level-text-file-loading)
  (persist-with-delay *setting-control* 'allow-progress (seconds 0.1) 'allow-progress #f 0.0 0)
  (persist-with-delay *setting-control* 'allow-pause (seconds 0.1) 'allow-pause #f 0.0 0)
  (call-parent-method this)
  (none)
  )

(defun deactivate-progress ()
  (if *progress-process*
      (deactivate (-> *progress-process* 0))
      )
  0
  (none)
  )

(defun hide-progress-screen ()
  (if (and *progress-process* (!= (-> *progress-process* 0 starting-state) 'title))
      (set-next-state (-> *progress-process* 0) 'go-away 0)
      )
  0
  (none)
  )

(defmethod gone? ((this progress))
  (and *progress-process*
       (-> *progress-process* 0 next-state)
       (= (-> *progress-process* 0 next-state name) 'gone)
       )
  )

(defun progress-allowed? ()
  (not (or (-> *setting-control* user-current talking)
           (-> *setting-control* user-current movie)
           (movie?)
           (handle->process (-> *game-info* pov-camera-handle))
           (handle->process (-> *game-info* other-camera-handle))
           (< (-> *display* base-clock frame-counter) (-> *game-info* letterbox-time))
           (< (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
           (!= (-> *setting-control* user-current bg-a) 0.0)
           (!= (-> *setting-control* user-current bg-a-force) 0.0)
           (not (-> *setting-control* user-current allow-progress))
           (or (and (handle->process (-> *game-info* auto-save-proc))
                    (not (send-event (handle->process (-> *game-info* auto-save-proc)) 'progress-allowed?))
                    )
               (not *target*)
               (= *cheat-mode* 'camera)
               (= *master-mode* 'freeze)
               *master-exit*
               (not *common-text*)
               (< (memory-free *nk-dead-pool*) #x8000)
               )
           )
       )
  )

(defmethod can-go-back? ((this progress))
  (and (= (-> this menu-transition) 0.0)
       (not (-> this selected-option))
       (!= (-> this current) 'loading)
       (!= (-> this current) 'saving)
       (!= (-> this current) 'formatting)
       (!= (-> this current) 'creating)
       (!= (-> this current) 'error-disc-removed)
       (!= (-> this current) 'error-reading)
       (!= (-> this current) 'card-removed)
       (!= (-> this current) 'error-auto-saving)
       (!= (-> this current) 'title)
       (!= (-> this current) 'insufficient-space)
       (!= (-> this current) 'secrets-insufficient-space)
       (!= (-> this current) 'no-memory-card)
       (!= (-> this current) 'icon-info)
       (!= (-> this current) 'insert-card)
       (!= (-> this current) 'progressive-mode-ok)
       (!= (-> this current) 'video-mode-ok)
       (!= (-> this current) 'progressive-mode-warning)
       (!= (-> this current) 'video-mode-warning)
       (!= (-> this current) 'select-kiosk-start-special)
       (!= (-> this current) 'language-select)
       )
  )

(defmethod get-state-check-card ((this progress) (arg0 symbol))
  (let ((v1-0 *progress-save-info*)
        (v0-0 arg0)
        )
    (when v1-0
      (when (and v1-0 (= (-> this menu-transition) 0.0))
        (case arg0
          (('insufficient-space 'no-memory-card 'unformatted-card)
           (cond
             ((zero? (-> v1-0 handle))
              (set! v0-0 'no-memory-card)
              )
             ((zero? (-> v1-0 formatted))
              (cond
                ((or (zero? (-> this state-pos)) (!= (-> this starting-state) 'title))
                 (set! v0-0 'go-away)
                 )
                (else
                  (if (!= arg0 'unformatted-card)
                      (set! v0-0 'format-card)
                      )
                  )
                )
              )
             ((and (zero? (-> v1-0 inited)) (< (-> v1-0 mem-actual) (-> v1-0 mem-required)))
              (set! v0-0 'insufficient-space)
              )
             ((or (zero? (-> this state-pos)) (!= (-> this starting-state) 'title))
              (set! v0-0 'go-away)
              )
             ((-> *progress-work* hero-mode-save)
              (set! v0-0 'select-save-hero)
              )
             (else
               (set! v0-0 'select-save)
               )
             )
           )
          (('insert-card)
           (if (= (-> v1-0 inited) 1)
               (set! v0-0 'select-load)
               )
           )
          )
        (cond
          ((zero? (-> v1-0 handle))
           (cond
             ((-> *setting-control* user-current auto-save)
              (set! v0-0 'card-removed)
              )
             (else
               (case arg0
                 (('select-load)
                  (set! v0-0 'insert-card)
                  )
                 (('format-card
                    'insufficient-space
                    'unformatted-card
                    'select-save
                    'select-save-title
                    'select-save-hero
                    'create-game
                    'already-exists
                    )
                  (set! v0-0 'no-memory-card)
                  )
                 )
               )
             )
           )
          ((zero? (-> v1-0 formatted))
           (case arg0
             (('select-load)
              (set! v0-0 'insert-card)
              )
             (('select-save 'select-save-title 'select-save-hero)
              (set! v0-0 'format-card)
              )
             )
           )
          ((zero? (-> v1-0 inited))
           (case arg0
             (('select-save 'select-save-title 'select-save-hero)
              (if (>= (-> v1-0 mem-actual) (-> v1-0 mem-required))
                  (set! v0-0 'create-game)
                  (set! v0-0 'insufficient-space)
                  )
              )
             (('select-load)
              (set! v0-0 'insert-card)
              )
             )
           )
          )
        )
      )
    v0-0
    )
  )

(defmethod push-state ((this progress))
  (let ((v1-0 (-> this state-pos)))
    (cond
      ((< v1-0 8)
       (set! (-> this state-array v1-0) (-> this current))
       (set! (-> this option-index-stack v1-0) (-> this option-index))
       (set! (-> this state-pos) (+ v1-0 1))
       )
      (else
        (format #t "ERROR: Can't push any more states on the state-array.~%")
        )
      )
    )
  0
  )

(defmethod pop-state ((this progress))
  (let ((v1-0 (-> this state-pos)))
    (cond
      ((> v1-0 0)
       (let ((a2-0 (+ v1-0 -1)))
         (set! (-> this state-pos) a2-0)
         (set-next-state this (-> this state-array a2-0) (-> this option-index-stack a2-0))
         )
       )
      (else
        (set-next-state this 'go-away 0)
        )
      )
    )
  0
  )

(defmethod set-next-state ((this progress) (arg0 symbol) (arg1 int))
  (set! (-> this clear-screen) #f)
  (when (!= arg0 (-> this current))
    (set! (-> this selected-option) #f)
    (set! (-> this yes-no-choice) #f)
    (set! (-> this next-option-index) arg1)
    (set! (-> this next) arg0)
    (case (-> this next)
      (('select-load 'select-save 'select-save-title 'select-save-hero)
       (set! (-> this next) (get-state-check-card this (-> this next)))
       )
      )
    (let ((v1-7 *progress-work*)
          (a2-1 (-> this which-slot))
          )
      (case (-> this next)
        (('main)
         (set! (-> *progress-work* hero-mode-save) #f)
         )
        (('creating)
         (auto-save-command 'create-file 0 0 this #f)
         )
        (('loading)
         (set! (-> v1-7 last-slot-saved) a2-1)
         (auto-save-command 'restore 0 a2-1 this #f)
         (set! (-> (the-as menu-missions-option (-> *missions-options* options 0)) current-index) 0.0)
         (set! (-> (the-as menu-missions-option (-> *missions-options* options 0)) target-index) 0.0)
         )
        (('saving)
         (set! (-> v1-7 last-slot-saved) a2-1)
         (auto-save-command 'save 0 a2-1 this #f)
         )
        (('formatting)
         (auto-save-command 'format-card 0 0 this #f)
         )
        (('select-save 'select-load)
         (set! (-> this next-option-index) (max 0 (-> v1-7 last-slot-saved)))
         )
        (('card-removed)
         (set! (-> v1-7 last-slot-saved) 0)
         0
         )
        )
      )
    )
  0
  )

(defmethod set-menu-options ((this progress) (arg0 symbol))
  (set! (-> this current-options) #f)
  (case arg0
    (('go-away)
     (go (method-of-object this go-away))
     )
    (('main)
     (set! (-> this current-options) (cond
                                       (*cheat-mode*
                                         *main-options*
                                         )
                                       ((kiosk?)
                                        *main-kiosk-options*
                                        )
                                       ((= *kernel-boot-message* 'demo)
                                        *main-demo-options*
                                        )
                                       ((= *kernel-boot-message* 'demo-shared)
                                        *main-demo-shared-options*
                                        )
                                       (else
                                         *main-options*
                                         )
                                       )
           )
     )
    (('options)
     (set! (-> this current-options) *options-options*)
     )
    (('controls)
     (set! (-> (the-as paged-menu-option (-> *controls-options* options 0)) page-index) 0)
     (set! (-> (the-as paged-menu-option (-> *controls-options* options 0)) prev-page-index) 0)
     (set! (-> this current-options) *controls-options*)
     )
    (('game-options)
     (set! (-> this current-options) (cond
                                       ((demo?)
                                        (if (= (scf-get-territory) 1)
                                            *game-options-demo*
                                            *game-options-demo*
                                            )
                                        )
                                       (else
                                         *game-options*
                                         )
                                       )
           )
     )
    (('graphic-options)
     (set! (-> this current-options)
           (if (or (= (scf-get-territory) 1) (and (= *progress-cheat* 'pal) (cpad-hold? 0 l2) (cpad-hold? 0 r2)))
               *graphic-title-options-pal*
               *graphic-options*
               )
           )
     )
    (('sound-options)
     (set! (-> this current-options) *sound-options*)
     )
    (('picture-options)
     (set! (-> this current-options) *picture-options*)
     )
    (('camera-options)
     (set! (-> this current-options) *camera-options*)
     )
    (('select-load 'select-save)
     (set! (-> this current-options) *load-save-options*)
     )
    (('select-save-title)
     (set! (-> this current-options) *save-options-title*)
     )
    (('select-save-hero)
     (logior! (-> *game-info* purchase-secrets) (game-secrets hero-mode))
     (set! (-> *progress-work* hero-mode-save) #t)
     (set! (-> this current-options) *load-save-options*)
     )
    (('hero-mode-message)
     (set! (-> this current-options) *hero-mode-message-options*)
     )
    (('loading 'saving 'creating 'formatting)
     (set! (-> this current-options) *loading-options*)
     )
    (('unformatted-card 'insufficient-space 'no-memory-card)
     (set! (-> this current-options) *insufficient-space-options*)
     )
    (('secrets-insufficient-space 'secrets-no-memory-card)
     (set! (-> this current-options) *secrets-insufficient-space-options*)
     )
    (('insert-card)
     (set! (-> this current-options) *insert-card-options*)
     )
    (('error-loading 'error-saving 'error-formatting 'error-creating)
     (set! (-> this current-options) *error-loading-options*)
     )
    (('error-auto-saving)
     (set! (-> this current-options) *error-auto-saving-options*)
     )
    (('card-removed)
     (set! (-> this current-options) *card-removed-options*)
     )
    (('error-disc-removed)
     (set! (-> this current-options) *error-disc-removed-options*)
     )
    (('error-reading)
     (set! (-> this current-options) *error-reading-options*)
     )
    (('icon-info)
     (set! (-> this current-options) *icon-info-options*)
     )
    (('format-card)
     (set! (-> this current-options) *format-card-options*)
     )
    (('already-exists)
     (set! (-> this current-options) *already-exists-options*)
     )
    (('create-game)
     (set! (-> this current-options) *create-game-options*)
     )
    (('video-mode-warning)
     (set! (-> this current-options) *video-mode-warning-options*)
     )
    (('video-mode-ok)
     (set! (-> this current-options) *video-mode-ok-options*)
     )
    (('progressive-mode-warning)
     (set! (-> this current-options) *progressive-mode-warning-options*)
     )
    (('progressive-mode-ok)
     (set! (-> this current-options) *progressive-mode-ok-options*)
     )
    (('language-select)
     (set! (-> this current-options) *language-options*)
     )
    (('title)
     (set! (-> this current-options) *title*)
     )
    (('title-options)
     (set! (-> this current-options) *options-options*)
     )
    (('select-start 'select-pre-start 'select-kiosk-start 'select-kiosk-start-special)
     (set! (-> this current-options) *select-start-options*)
     (set! (-> (the-as menu-select-start-option (-> *select-start-options* options 0)) current-index) 0.0)
     (set! (-> (the-as menu-select-start-option (-> *select-start-options* options 0)) target-index) 0.0)
     (set! (-> (the-as menu-select-start-option (-> *select-start-options* options 0)) selected-index) 0)
     0
     )
    (('select-scene)
     (set! (-> this current-options) *select-scene-options*)
     (set! (-> (the-as menu-select-scene-option (-> *select-scene-options* options 0)) current-index) 0.0)
     (set! (-> (the-as menu-select-scene-option (-> *select-scene-options* options 0)) target-index) 0.0)
     (set! (-> (the-as menu-select-scene-option (-> *select-scene-options* options 0)) selected-index) 0)
     0
     )
    (('select-scene-special)
     (set! (-> this starting-state) (the-as basic 'title))
     (set! (-> this state-pos) 0)
     (let ((v1-80 (-> this state-pos)))
       (set! (-> this state-array v1-80) 'title)
       (set! (-> this option-index-stack v1-80) 3)
       (let ((v1-81 (+ v1-80 1)))
         (set! (-> this state-array v1-81) 'unlocked-secrets)
         (set! (-> this option-index-stack v1-81) (-> this option-index))
         (set! (-> this state-pos) (+ v1-81 1))
         )
       )
     (dotimes (s5-1 (-> this state-pos))
       (format #t "select-scene-special: ~S ~D~%" (-> this state-array s5-1) (-> this option-index-stack s5-1))
       )
     (set! (-> this current-options) *select-scene-options*)
     )
    (('inventory)
     (set! (-> this current-options) *inventory*)
     )
    (('bigmap)
     (set! (-> this current-options) *bigmap-options*)
     )
    (('missions)
     (set! (-> this missions-total-spacing) 0.0)
     (set! (-> (the-as menu-missions-option (-> *missions-options* options 0)) current-index) 0.0)
     (set! (-> (the-as menu-missions-option (-> *missions-options* options 0)) target-index) 0.0)
     (set! (-> this current-options) *missions-options*)
     )
    (('highscores)
     (set! (-> this current-options) *highscores-options*)
     )
    (('secret)
     (set! (-> this secret-buying) #f)
     (set! (-> this current-options) *secret-options*)
     )
    (('quit-restart)
     (set! (-> this current-options) *quit-restart-options*)
     )
    (('unlocked-secrets)
     (set! (-> this current-options) *unlocked-secrets*)
     )
    )
  (when (= (-> this current-options) #f)
    (format #t "Didn't find new menu settings!!~%")
    (pop-state this)
    )
  0
  )

(defmethod respond-to-cpad ((this progress))
  (mc-get-slot-info 0 *progress-save-info*)
  (memcard-unlocked-secrets? this #f)
  (when (= (-> this current) 'title)
    (cond
      ((-> *progress-work* secrets-unlocked)
       (set! (-> this current-options) *title-secret*)
       )
      (else
        (set! (-> this current-options) *title*)
        (set! (-> this option-index) (min 2 (-> this option-index)))
        )
      )
    )
  (when (-> this current-options)
    (let ((s5-0 (-> this current-options options)))
      (when (and s5-0 (and (= (-> this menu-transition) 0.0) (< (-> this option-index) (-> s5-0 length))))
        (respond-progress
          (-> s5-0 (-> this option-index))
          this
          (and (= (-> this menu-transition) 0.0) (-> this selected-option))
          )
        (cond
          ((-> this selected-option)
           (cond
             ((cpad-pressed? 0 confirm)
              (sound-play "generic-beep")
              (set! (-> this selected-option) #f)
              )
             ((cpad-pressed? 0 triangle)
              (if (= (-> this current-options) *main-options*)
                  (sound-play "window-contract")
                  (sound-play "generic-beep")
                  )
              (set! (-> this selected-option) #f)
              )
             )
           )
          (else
            (cond
              ((or (cpad-pressed? 0 up l-analog-up)
                   (and (cpad-hold? 0 up l-analog-up) (time-elapsed? (-> this last-move) (seconds 0.175)))
                   )
               (set-time! (-> this last-move))
               (cond
                 ((= (-> this current-options) *main-options*)
                  (sound-play "ring-select")
                  )
                 ((!= (length s5-0) 1)
                  (sound-play "roll-over")
                  )
                 )
               (if (and (= *title* (-> this current-options))
                        (not (-> *progress-work* secrets-unlocked))
                        (zero? (-> this option-index))
                        )
                   (set! (-> this option-index) 3)
                   )
               (cond
                 ((> (-> this want-option-index) 0)
                  (set! (-> this want-option-index) -1)
                  )
                 ((< -2 (-> this want-option-index))
                  (+! (-> this want-option-index) -1)
                  )
                 )
               )
              ((or (cpad-pressed? 0 down l-analog-down)
                   (and (cpad-hold? 0 down l-analog-down) (time-elapsed? (-> this last-move) (seconds 0.175)))
                   )
               (set-time! (-> this last-move))
               (cond
                 ((= (-> this current-options) *main-options*)
                  (sound-play "ring-select")
                  )
                 ((!= (length s5-0) 1)
                  (sound-play "roll-over")
                  )
                 )
               (cond
                 ((< (-> this want-option-index) 0)
                  (set! (-> this want-option-index) 1)
                  )
                 ((< (-> this want-option-index) 2)
                  (+! (-> this want-option-index) 1)
                  )
                 )
               )
              ((cpad-pressed? 0 confirm)
               (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
               (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
               (if (not (-> this clear-screen))
                   (sound-play "generic-beep")
                   )
               (set! (-> this selected-option) #t)
               )
              ((cpad-pressed? 0 triangle)
               (when (can-go-back? this)
                 (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
                 (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
                 (if (= (-> this state-pos) 1)
                     (sound-play "window-contract")
                     (sound-play "generic-beep")
                     )
                 (pop-state this)
                 )
               )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior progress-trans progress ()
  (cond
    ((and (= (-> self next) 'none) (or (= (-> self starting-state) 'main) (= (-> self anim-frame) 1.0)))
     (set! (-> self menu-transition)
           (seek-ease
             (-> self menu-transition)
             0.0
             (/ (-> self clock time-adjust-ratio) 10)
             0.4
             (/ (-> self clock time-adjust-ratio) 100)
             )
           )
     )
    (else
      (seek! (-> self menu-transition) 1.0 (/ (-> self clock time-adjust-ratio) 10))
      (when (and (= (-> self menu-transition) 1.0)
                 (or (and (nonzero? (-> self state-pos)) (= (-> self anim-frame) 1.0))
                     (or (and (zero? (-> self state-pos)) (= (-> self anim-frame) 0.0))
                         (and (!= (-> self starting-state) 'main) (!= (-> self next) 'none))
                         )
                     )
                 )
        (set! (-> self current) (-> self next))
        (set! (-> self next) 'none)
        (set! (-> self option-index) (-> self next-option-index))
        (set! (-> self want-option-index) 0)
        (set-menu-options self (-> self current))
        (set! (-> self scanlines-alpha) 0.0)
        )
      )
    )
  (set! (-> self main-menu)
        (and (zero? (-> self state-pos)) (and (= (-> self menu-transition) 0.0)
                                              (= (-> self next) 'none)
                                              (or (= (-> self state-array 0) 'main) (= (-> self current) 'main))
                                              )
             )
        )
  (when *cheat-mode*
    (when (zero? (-> self state-pos))
      (cond
        ((and (cpad-hold? 0 l2) (cpad-hold? 0 r1))
         (when (= (-> self current-options) *main-options*)
           (set! (-> *progress-work* secrets-unlocked) (the-as basic #t))
           (set! (-> *progress-work* selected-num) 0)
           (set! (-> self current-options) *main-options-debug*)
           )
         )
        ((= (-> self current-options) *main-options-debug*)
         (set! (-> self current-options) *main-options*)
         )
        )
      )
    )
  (if (= (-> self ring-angle) (-> self ring-want-angle))
      (respond-to-cpad self)
      )
  (let ((f30-0 (/ (-> self clock time-adjust-ratio) 200)))
    (cond
      ((= (-> self menu-transition) 1.0)
       (if (and (zero? (-> self state-pos)) (= (-> self starting-state) 'main))
           (seek! (-> self anim-frame) 0.0 (/ (-> self clock time-adjust-ratio) 50))
           (seek! (-> self anim-frame) 1.0 (/ (-> self clock time-adjust-ratio) 50))
           )
       (let ((f0-27 (if (and (zero? (-> self state-pos)) (!= (-> self starting-state) 'title))
                        0.0
                        0.2
                        )
                    )
             )
         (when (= (-> self next) 'bigmap)
           (set! f0-27 0.4)
           (set! f30-0 (/ (-> self clock time-adjust-ratio) 125))
           )
         (seek! (-> self pos-transition) f0-27 f30-0)
         )
       )
      ((zero? (-> self state-pos))
       (if (= (-> self current) 'bigmap)
           (set! f30-0 (/ (-> self clock time-adjust-ratio) 20))
           )
       (if (!= (-> self starting-state) 'title)
           (seek! (-> self pos-transition) 0.0 f30-0)
           )
       )
      )
    )
  (if (!= (-> self starting-state) 'main)
      (set! (-> self pos-transition) 0.2)
      )
  (set-ring-position self)
  (when (= (-> self ring-angle) (-> self ring-want-angle))
    (cond
      ((< (-> self want-option-index) 0)
       (cond
         ((and (= *cheat-mode* #f) (or (demo?) (kiosk?)))
          (if (> (-> self option-index) 0)
              (+! (-> self option-index) -1)
              )
          )
         (else
           (set! (-> self option-index)
                 (min-max-wrap-around (+ (-> self option-index) -1) 0 (+ (length (-> self current-options options)) -1))
                 )
           )
         )
       (set! (-> self graphic-index) (-> self option-index))
       (+! (-> self want-option-index) 1)
       )
      ((> (-> self want-option-index) 0)
       (cond
         ((and (= *cheat-mode* #f) (or (demo?) (kiosk?)))
          (if (< (-> self option-index) (+ (length (-> self current-options options)) -1))
              (+! (-> self option-index) 1)
              )
          )
         (else
           (set! (-> self option-index)
                 (min-max-wrap-around (+ (-> self option-index) 1) 0 (+ (length (-> self current-options options)) -1))
                 )
           )
         )
       (+! (-> self want-option-index) -1)
       )
      )
    )
  (if (= (-> self anim-frame) 0.0)
      (set! (-> self swing) (seek-ease
                              (-> self swing)
                              4.0
                              (/ (-> self clock time-adjust-ratio) 20)
                              0.5
                              (/ (-> self clock time-adjust-ratio) 200)
                              )
            )
      (set! (-> self swing) (seek-ease
                              (-> self swing)
                              0.0
                              (* 0.07 (-> self clock time-adjust-ratio))
                              0.5
                              (* 0.007 (-> self clock time-adjust-ratio))
                              )
            )
      )
  (when (-> self main-menu)
    (set! (-> self ring-want-angle) (ceil (* 182.04445 (* 36.0 (the float (-> self option-index))))))
    (if (and (= (-> self ring-want-angle) 0.0) (< 32768.0 (-> self ring-angle)))
        (set! (-> self ring-want-angle) 65536.0)
        )
    (let ((f0-54 (- (-> self ring-want-angle) (-> self ring-angle))))
      (when (< 32768.0 (fabs f0-54))
        (if (< 0.0 f0-54)
            (+! (-> self ring-angle) 65536.0)
            (+! (-> self ring-angle) -65536.0)
            )
        )
      )
    (seek! (-> self ring-angle) (-> self ring-want-angle) (* 910.2222 (-> self clock time-adjust-ratio)))
    )
  (let ((gp-4 (quaternion-vector-angle!
                (new 'stack-no-clear 'quaternion)
                *x-vector*
                (* 182.04445 (* (-> self swing) (sin (the float (* 40 (current-time))))))
                )
              )
        (s5-4 (quaternion-vector-angle!
                (new 'stack-no-clear 'quaternion)
                *y-vector*
                (* 182.04445 (* (-> self swing) (sin (the float (* 0 (current-time))))))
                )
              )
        )
    (quaternion*! (-> self root quat) (-> self init-quat) gp-4)
    (quaternion*! (-> self root quat) (-> self root quat) s5-4)
    )
  (quaternion-normalize! (-> self root quat))
  (if (= (-> self ring-angle) (-> self ring-want-angle))
      (set! (-> self graphic-index) (-> self option-index))
      )
  (case *kernel-boot-message*
    (('kiosk)
     (if (and (nonzero? (-> self start-time))
              (>= (- (-> *display* real-clock frame-counter) (-> self start-time)) (seconds 60))
              (>= (- (-> *display* real-clock frame-counter) (-> *cpad-list* cpads 0 real-change-time)) (seconds 60))
              (or (can-go-back? self) (= (-> self current) 'select-kiosk-start-special))
              (not (handle->process (-> *game-info* auto-save-proc)))
              )
         (initialize! *game-info* 'game (the-as game-save #f) (the-as string #f) (the-as resetter-spec #f))
         )
     )
    )
  0
  (none)
  )

(defun begin-scan ((arg0 hud-box) (arg1 progress))
  (cond
    ((or (= (-> arg1 current) 'bigmap) (= (-> arg1 next) 'bigmap))
     (set! (-> arg0 box min x) 0.0)
     (set! (-> arg0 box min y) 0.0)
     (set! (-> arg0 box max x) 512.0)
     (set! (-> arg0 box max y) 416.0)
     )
    ((= (get-aspect-ratio) 'aspect16x9)
     (set! (-> arg0 box min x) 79.0)
     (set! (-> arg0 box min y) 38.0)
     (set! (-> arg0 box max x) 434.0)
     (set! (-> arg0 box max y) 362.0)
     )
    (else
      (set! (-> arg0 box min x) 70.0)
      (set! (-> arg0 box min y) 72.0)
      (set! (-> arg0 box max x) 444.0)
      (set! (-> arg0 box max y) 329.0)
      )
    )
  0
  )

(defun end-scan ((arg0 hud-box) (arg1 float))
  (with-dma-buffer-add-bucket ((s5-0 (-> *display* frames (-> *display* on-screen) global-buf))
                               (bucket-id bucket582)
                               )
    (draw-scan-and-line arg0 s5-0 arg1)
    )
  0
  )

(defmethod progress-method-33 ((this progress) (arg0 progress-box))
  (set! (-> this scissor-count) (min 7 (+ (-> this scissor-count) 1)))
  (let ((s5-0 (-> this scissor-stack (-> this scissor-count)))
        (gp-1 (if (= (get-aspect-ratio) 'aspect4x3)
                  (-> arg0 aspect4x3)
                  (-> arg0 aspect16x9)
                  )
              )
        )
    (set! (-> s5-0 quad) (-> (the-as vector gp-1) quad))
    (with-dma-buffer-add-bucket ((v1-12 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hud-draw-hud-alpha)
                                 )
      (dma-buffer-add-gs-set v1-12
                             (scissor-1
                               (new 'static 'gs-scissor
                                 :scax0 (the int (-> (the-as hud-box gp-1) box min x))
                                 :scay0 (the int (-> (the-as hud-box gp-1) box min y))
                                 :scax1 (the int (-> (the-as hud-box gp-1) box max x))
                                 :scay1 (the int (-> (the-as hud-box gp-1) box max y))
                                 )
                               )
                             )
      )
    (with-dma-buffer-add-bucket ((v1-23 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id particles)
                                 )
      (dma-buffer-add-gs-set v1-23
                             (scissor-1
                               (new 'static 'gs-scissor
                                 :scax0 (the int (-> (the-as hud-box gp-1) box min x))
                                 :scay0 (the int (-> (the-as hud-box gp-1) box min y))
                                 :scax1 (the int (-> (the-as hud-box gp-1) box max x))
                                 :scay1 (the int (-> (the-as hud-box gp-1) box max y))
                                 )
                               )
                             )
      )
    (with-dma-buffer-add-bucket ((v1-34 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hud-draw-pris2)
                                 )
      (dma-buffer-add-gs-set v1-34 (scissor-1 (new 'static 'gs-scissor
                                                :scax0 (the int (-> (the-as hud-box gp-1) box min x))
                                                :scay0 (the int (-> (the-as hud-box gp-1) box min y))
                                                :scax1 (the int (-> (the-as hud-box gp-1) box max x))
                                                :scay1 (the int (-> (the-as hud-box gp-1) box max y))
                                                )
                                              )
                             )
      )
    )
  0
  (none)
  )

(defmethod progress-method-34 ((this progress))
  (set! (-> this scissor-count) (max 0 (+ (-> this scissor-count) -1)))
  (let ((gp-0 (-> this scissor-stack (-> this scissor-count))))
    (with-dma-buffer-add-bucket ((v1-10 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hud-draw-hud-alpha)
                                 )
      (dma-buffer-add-gs-set v1-10
                             (scissor-1
                               (new 'static 'gs-scissor
                                 :scax0 (the int (-> gp-0 x))
                                 :scay0 (the int (-> gp-0 y))
                                 :scax1 (the int (-> gp-0 z))
                                 :scay1 (the int (-> gp-0 w))
                                 )
                               )
                             )
      )
    (with-dma-buffer-add-bucket ((v1-21 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id particles)
                                 )
      (dma-buffer-add-gs-set v1-21
                             (scissor-1
                               (new 'static 'gs-scissor
                                 :scax0 (the int (-> gp-0 x))
                                 :scay0 (the int (-> gp-0 y))
                                 :scax1 (the int (-> gp-0 z))
                                 :scay1 (the int (-> gp-0 w))
                                 )
                               )
                             )
      )
    (with-dma-buffer-add-bucket ((v1-32 (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hud-draw-pris2)
                                 )
      (dma-buffer-add-gs-set v1-32 (scissor-1 (new 'static 'gs-scissor
                                                :scax0 (the int (-> gp-0 x))
                                                :scay0 (the int (-> gp-0 y))
                                                :scax1 (the int (-> gp-0 z))
                                                :scay1 (the int (-> gp-0 w))
                                                )
                                              )
                             )
      )
    )
  0
  (none)
  )

(defmethod get-scissor-stack-top ((this progress))
  (-> this scissor-stack (-> this scissor-count))
  )

(defbehavior progress-post progress ()
  (local-vars (sv-208 font-context) (sv-212 int) (sv-216 hud-box) (sv-220 symbol))
  (when (-> self current-options)
    (progress-method-37 self)
    (set! (-> self scissor-count) -1)
    (progress-method-33 self (-> *progress-work* full-screen))
    (let ((gp-0 (-> self current-options options)))
      (let ((s3-0 (-> self current-options y-center))
            (s5-0 (-> self current-options y-space))
            )
        (let ((s2-0 (new 'stack-no-clear 'matrix)))
          (set! (-> s2-0 rvec quad) (the-as uint128 0))
          (set! (-> s2-0 uvec quad) (the-as uint128 0))
          (set! (-> s2-0 fvec quad) (the-as uint128 0))
          (set! (-> s2-0 trans quad) (the-as uint128 0))
          (let ((s4-0 *progress-work*))
            (mem-copy! (the-as pointer s2-0) (the-as pointer *font-default-matrix*) 64)
            (set! sv-208 (new 'stack 'font-context s2-0 0 0 0.0 (font-color default) (font-flags shadow kerning)))
            (set! sv-212 (- s3-0 (/ (* s5-0 (length gp-0)) 2)))
            (set! sv-216 (new 'stack-no-clear 'hud-box))
            (set! sv-220 (and (!= (-> self current) 'main) (or (= (-> self next) 'none) (> (-> self state-pos) 0))))
            (progress-method-33 self (-> s4-0 small-screen))
            (when sv-220
              (begin-scan sv-216 self)
              (let ((f30-0 (fmax 0.0 (* 2.0 (- 0.5 (-> self menu-transition))))))
                (when (not (or (= (-> self current) 'bigmap) (= (-> self next) 'bigmap)))
                  (progress-method-43 self (-> s4-0 small-screen) (* 144.0 f30-0))
                  (progress-method-41 self (-> s4-0 small-screen) (* 128.0 f30-0))
                  )
                )
              )
            )
          )
        (if (or (= (-> self current-options) *title*) (= (-> self current-options) *options-options*))
            (+ s5-0 20)
            )
        )
      (dotimes (s5-1 (length gp-0))
        (set! (-> self current-index) s5-1)
        (let ((v1-43 sv-208))
          (set! (-> v1-43 scale) 0.5)
          )
        (set! (-> sv-208 origin x) 70.0)
        (set! (-> sv-208 origin y) (the float sv-212))
        (let ((v1-48 sv-208))
          (set! (-> v1-48 width) (the float 375))
          )
        (let ((v1-49 sv-208))
          (set! (-> v1-49 height) (the float 30))
          )
        (set! (-> sv-208 flags) (font-flags kerning middle middle-vert large))
        (let ((v1-51 sv-208))
          (set! (-> v1-51 color) (if (and (= s5-1 (-> self option-index)) (= (-> self menu-transition) 0.0))
                                     (font-color font-color-33)
                                     (font-color font-color-32)
                                     )
                )
          )
        (draw-option
          (-> gp-0 s5-1)
          self
          sv-208
          s5-1
          (and (= (-> self menu-transition) 0.0) (-> self selected-option) (= s5-1 (-> self option-index)))
          )
        )
      )
    (if sv-220
        (set! (-> self scanlines-alpha) (seek-ease
                                          (-> self scanlines-alpha)
                                          (- 1.0 (-> self menu-transition))
                                          (/ (-> self clock time-adjust-ratio) 20)
                                          0.3
                                          (/ (-> self clock time-adjust-ratio) 1000)
                                          )
              )
        )
    (progress-method-34 self)
    (end-scan sv-216 (-> self scanlines-alpha))
    )
  (when (and (< 0.8 (-> self anim-frame)) (or (= (-> self current) 'bigmap) (= (-> self next) 'bigmap)))
    (progress-method-33 self (-> *progress-work* full-screen))
    (cond
      ((>= (-> self pos-transition) 0.38)
       (draw! *bigmap* 1792 1840 2304 2256)
       )
      (else
        (let ((s4-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 21)))
              (s3-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 24)))
              (gp-1 (new 'stack-no-clear 'vector4w))
              )
          (set! (-> gp-1 quad) (the-as uint128 0))
          (let ((s5-2 (new 'stack-no-clear 'vector4w)))
            (set! (-> s5-2 quad) (the-as uint128 0))
            (if (and (transform-point-qword! gp-1 s4-1) (transform-point-qword! s5-2 s3-1))
                (draw! *bigmap* (/ (-> s5-2 x) 16) (/ (-> s5-2 y) 16) (/ (-> gp-1 x) 16) (/ (-> gp-1 y) 16))
                )
            )
          )
        )
      )
    (progress-method-34 self)
    )
  (ja-post)
  0
  (none)
  )

(defstate come-in (progress)
  :virtual #t
  :enter (behavior ()
    (set! (-> self pos-transition) 1.0)
    (set! (-> self lock-tick-count) 0)
    0
    )
  :trans (behavior ()
    (let ((f30-0 (if (= (-> self starting-state) 'main)
                     0.0
                     0.2
                     )
                 )
          )
      (when (hud-hidden?)
        (set! (-> self pos-transition) (seek-ease
                                         (-> self pos-transition)
                                         f30-0
                                         (* 0.03 (-> self clock time-adjust-ratio))
                                         0.4
                                         (* 0.003 (-> self clock time-adjust-ratio))
                                         )
              )
        (when (= (-> self lock-tick-count) 1)
          (sound-play "ring-appear")
          (set-menu-mode *blit-displays-work* #t)
          )
        (+! (-> self lock-tick-count) 1)
        )
      (set-ring-position self)
      (when (= (-> self pos-transition) f30-0)
        (set! (-> self start-time) (-> *display* real-clock frame-counter))
        (go-virtual idle)
        )
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      (ja :num-func num-func-identity :frame-num 0.0)
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defstate idle (progress)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notify)
       (cond
         ((= (-> block param 0) 'done)
          (let ((t9-0 format)
                (a0-3 #t)
                (a1-1 "DONE NOTIFY: ~S ~S~%")
                (v1-3 (the-as mc-status-code (-> block param 1)))
                )
            (t9-0
              a0-3
              a1-1
              (cond
                ((= v1-3 (mc-status-code bad-version))
                 "bad-version"
                 )
                ((= v1-3 (mc-status-code no-save))
                 "no-save"
                 )
                ((= v1-3 (mc-status-code no-last))
                 "no-last"
                 )
                ((= v1-3 (mc-status-code no-space))
                 "no-space"
                 )
                ((= v1-3 (mc-status-code internal-error))
                 "internal-error"
                 )
                ((= v1-3 (mc-status-code no-memory))
                 "no-memory"
                 )
                ((= v1-3 (mc-status-code bad-handle))
                 "bad-handle"
                 )
                ((= v1-3 (mc-status-code busy))
                 "busy"
                 )
                ((= v1-3 (mc-status-code write-error))
                 "write-error"
                 )
                ((= v1-3 (mc-status-code read-error))
                 "read-error"
                 )
                ((= v1-3 (mc-status-code no-card))
                 "no-card"
                 )
                ((= v1-3 (mc-status-code no-format))
                 "no-format"
                 )
                ((= v1-3 (mc-status-code ok))
                 "ok"
                 )
                ((= v1-3 (mc-status-code no-process))
                 "no-process"
                 )
                ((= v1-3 (mc-status-code no-auto-save))
                 "no-auto-save"
                 )
                ((= v1-3 (mc-status-code no-file))
                 "no-file"
                 )
                ((= v1-3 (mc-status-code format-failed))
                 "format-failed"
                 )
                ((= v1-3 (mc-status-code new-game))
                 "new-game"
                 )
                (else
                  "*unknown*"
                  )
                )
              (-> self current)
              )
            )
          ;; og:preserve-this patched to next instead of current because we save synchronously
          (case (-> self next)
            (('saving)
             (cond
               ((= (-> self state-array 0) 'title)
                (let ((gp-1 (-> *setting-control* user-default auto-save)))
                  (sound-volume-off)
                  (let ((v0-0 (progress-intro-start)))
                    (set! (-> *setting-control* user-default auto-save) gp-1)
                    v0-0
                    )
                  )
                )
               ((-> *progress-work* hero-mode-save)
                (set-next-state self 'hero-mode-message 0)
                )
               (else
                 (pop-state self)
                 )
               )
             )
            (('formatting)
             (set-next-state self 'creating 0)
             )
            (('creating)
             (cond
               ((= (-> self state-array 0) 'title)
                (set-next-state self 'select-save-title 0)
                )
               ((-> *progress-work* hero-mode-save)
                (set-next-state self 'select-save-hero 0)
                )
               (else
                 (set-next-state self 'select-save 0)
                 )
               )
             )
            )
          )
         ((= (-> block param 0) 'error)
          (let ((t9-9 format)
                (a0-18 #t)
                (a1-7 "ERROR NOTIFY: ~S ~S ~S~%")
                (v1-20 (-> block param 1))
                )
            (t9-9
              a0-18
              a1-7
              (cond
                ((= v1-20 15)
                 "bad-version"
                 )
                ((= v1-20 13)
                 "no-save"
                 )
                ((= v1-20 10)
                 "no-last"
                 )
                ((= v1-20 14)
                 "no-space"
                 )
                ((= v1-20 4)
                 "internal-error"
                 )
                ((= v1-20 8)
                 "no-memory"
                 )
                ((= v1-20 2)
                 "bad-handle"
                 )
                ((zero? v1-20)
                 "busy"
                 )
                ((= v1-20 5)
                 "write-error"
                 )
                ((= v1-20 6)
                 "read-error"
                 )
                ((= v1-20 9)
                 "no-card"
                 )
                ((= v1-20 11)
                 "no-format"
                 )
                ((= v1-20 1)
                 "ok"
                 )
                ((= v1-20 16)
                 "no-process"
                 )
                ((= v1-20 17)
                 "no-auto-save"
                 )
                ((= v1-20 12)
                 "no-file"
                 )
                ((= v1-20 3)
                 "format-failed"
                 )
                ((= v1-20 7)
                 "new-game"
                 )
                (else
                  "*unknown*"
                  )
                )
              (-> self current)
              (-> self next)
              )
            )
          (case (-> block param 1)
            ((14)
             (set-next-state self 'insufficient-space 0)
             )
            (else
              (case (-> self current)
                (('formatting 'format-card)
                 (set-next-state self 'error-formatting 0)
                 )
                (('creating 'create-game)
                 (set-next-state self 'error-creating 0)
                 )
                (('saving 'select-save 'select-save-title 'select-save-hero 'already-exists)
                 (set-next-state self 'error-saving 0)
                 )
                (('loading 'select-load)
                 (set-next-state self 'error-loading 0)
                 )
                )
              )
            )
          )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self menu-transition) 1.0)
    )
  :trans progress-trans
  :code (behavior ()
    (until #f
      (ja :num-func num-func-identity :frame-num (* 12.0 (-> self anim-frame)))
      (suspend)
      )
    #f
    )
  :post progress-post
  )

(defstate go-away (progress)
  :virtual #t
  :enter (behavior ()
    (remove-setting-by-arg0 *setting-control* 'extra-bank)
    (let ((v1-2 *blit-displays-work*))
      (set! (-> v1-2 progress-interp-dest) 0.0)
      (set! (-> v1-2 progress-interp-speed) 0.022222223)
      )
    )
  :trans (behavior ()
    (seek! (-> self anim-frame) 0.0 (/ (-> self clock time-adjust-ratio) 50))
    (cond
      ((= (-> self anim-frame) 0.0)
       (seek! (-> self pos-transition) 1.0 (/ (-> self clock time-adjust-ratio) 50))
       (if (= (-> self pos-transition) 1.0)
           (go-virtual gone)
           )
       )
      (else
        (seek! (-> self pos-transition) 0.0 (/ (-> self clock time-adjust-ratio) 50))
        )
      )
    (set-ring-position self)
    )
  :code (behavior ()
    (let ((gp-0 #f))
      (until #f
        (when (and (not gp-0) (= (-> self anim-frame) 0.0))
          (sound-play "ring-disappear")
          (set! gp-0 #t)
          )
        (ja :num-func num-func-identity :frame-num (* 12.0 (-> self anim-frame)))
        (suspend)
        )
      )
    #f
    )
  :post ja-post
  )

(defstate gone (progress)
  :virtual #t
  :code (behavior ()
    (disable-drawing *bigmap*)
    (set-menu-mode *blit-displays-work* #f)
    (while (or (-> *blit-displays-work* screen-copied) (nonzero? (-> *blit-displays-work* count-down)))
      (suspend)
      )
    (remove-setting! 'process-mask)
    (set-master-mode *last-master-mode*)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    )
  )

(defmethod respond-progress ((this menu-option) (arg0 progress) (arg1 symbol))
  0
  )

(defmethod respond-progress ((this menu-slider-option) (arg0 progress) (arg1 symbol))
  (with-pp
    (when (loaded? *bigmap*)
      (let ((s5-0 (&+ (the-as (pointer float) *setting-control*) (-> this setting-offset)))
            (s3-0 #f)
            )
        (let ((f30-0 (/ (-> pp clock time-adjust-ratio) 50))
              (f28-0 0.0)
              )
          (when (type? this menu-picture-slider-option)
            (set! f30-0 (/ (-> pp clock time-adjust-ratio) 200))
            (set! f28-0 0.25)
            )
          (cond
            ((cpad-hold? 0 left l-analog-left)
             (seek! (-> s5-0 0) f28-0 f30-0)
             (if (!= (-> s5-0 0) 0.0)
                 (set! s3-0 #t)
                 )
             )
            ((cpad-hold? 0 right l-analog-right)
             (seek! (-> s5-0 0) 1.0 f30-0)
             (if (!= (-> s5-0 0) 1.0)
                 (set! s3-0 #t)
                 )
             )
            )
          )
        (when s3-0
          (let ((f30-1 1.0))
            (case (-> this name)
              (((text-id progress-music-volume) (text-id progress-speech-volume))
               (set! f30-1 (-> s5-0 0))
               )
              )
            (when (< (seconds 0.03) (- (current-time) (-> arg0 last-sound)))
              (set-time! (-> arg0 last-sound))
              (sound-play-by-name
                (static-sound-name "menu-slide")
                (new-sound-id)
                (the int (* 1024.0 f30-1))
                0
                0
                (sound-group)
                #t
                )
              )
            )
          )
        )
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
      )
    0
    )
  )

(defmethod respond-progress ((this menu-stereo-mode-sound-option) (arg0 progress) (arg1 symbol))
  (when (loaded? *bigmap*)
    (let ((a0-2 (-> *setting-control* user-default stereo-mode))
          (v1-4 #f)
          )
      (let ((a2-1 2))
        (cond
          (arg1
            (cond
              ((cpad-pressed? 0 left l-analog-left)
               (set! (-> *setting-control* user-default stereo-mode) (min-max-wrap-around (+ a0-2 -1) 0 a2-1))
               (set! v1-4 #t)
               )
              ((cpad-pressed? 0 right l-analog-right)
               (set! (-> *setting-control* user-default stereo-mode) (min-max-wrap-around (+ a0-2 1) 0 a2-1))
               (set! v1-4 #t)
               )
              ((cpad-pressed? 0 triangle)
               (set! (-> *setting-control* user-default stereo-mode) (-> arg0 stereo-mode-backup))
               )
              )
            )
          (else
            (if (cpad-pressed? 0 confirm)
                (set! (-> arg0 stereo-mode-backup) (-> *setting-control* user-default stereo-mode))
                )
            )
          )
        )
      (if v1-4
          (sound-play "generic-beep")
          )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-main-menu-option) (arg0 progress) (arg1 symbol))
  (cond
    ((cpad-pressed? 0 start)
     )
    ((cpad-pressed? 0 confirm)
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
     (when (= (-> arg0 ring-angle) (-> arg0 ring-want-angle))
       (cond
         ((= (-> this name) (text-id progress-exit-demo))
          (case *kernel-boot-message*
            (('demo-shared)
             (set! *master-exit* 'force)
             (set-master-mode 'game)
             )
            (('kiosk 'demo)
             (set! (-> *game-info* mode) 'play)
             (initialize! *game-info* 'game (the-as game-save #f) "title-restart" (the-as resetter-spec #f))
             )
            )
          )
         ((= (-> this name) (text-id progress-demo-return-to-title))
          (case *kernel-boot-message*
            (('kiosk 'demo 'demo-shared)
             (set! (-> *game-info* mode) 'play)
             (initialize! *game-info* 'game (the-as game-save #f) "title-restart" (the-as resetter-spec #f))
             )
            )
          )
         ((or (= (-> this name) (text-id progress-scene-player-act-1))
              (= (-> this name) (text-id progress-scene-player-act-2))
              (= (-> this name) (text-id progress-scene-player-act-3))
              )
          (let ((v1-40 *progress-work*))
            (case (-> this name)
              (((text-id progress-scene-player-act-2))
               (set! (-> v1-40 selected-num) 1)
               )
              (((text-id progress-scene-player-act-3))
               (set! (-> v1-40 selected-num) 2)
               )
              (else
                (set! (-> v1-40 selected-num) 0)
                0
                )
              )
            )
          (sound-play "window-expand")
          (push-state arg0)
          (set-next-state arg0 (-> this next-state) 0)
          )
         ((= (-> this next-state) 'back)
          (pop-state arg0)
          )
         ((= (-> this next-state) 'restart)
          (sound-volume-off)
          (restart-mission)
          (pop-state arg0)
          )
         (else
           (sound-play "window-expand")
           (push-state arg0)
           (set-next-state arg0 (-> this next-state) 0)
           )
         )
       )
     )
    ((not (-> arg0 selected-option))
     (let ((a0-59 (-> arg0 current-options options)))
       (cond
         ((or (cpad-pressed? 0 left l-analog-left)
              (cpad-pressed? 0 l1)
              (and (or (cpad-hold? 0 left l-analog-left) (cpad-hold? 0 l1))
                   (time-elapsed? (-> arg0 last-move) (seconds 0.175))
                   )
              )
          (set-time! (-> arg0 last-move))
          (if (!= (length a0-59) 1)
              (sound-play "ring-select")
              )
          (cond
            ((> (-> arg0 want-option-index) 0)
             (set! (-> arg0 want-option-index) -1)
             )
            ((< -2 (-> arg0 want-option-index))
             (+! (-> arg0 want-option-index) -1)
             )
            )
          )
         ((or (cpad-pressed? 0 right l-analog-right)
              (and (cpad-pressed? 0 r1) (not (logtest? (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons l2))))
              (and (or (cpad-hold? 0 right l-analog-right)
                       (and (cpad-hold? 0 r1) (not (logtest? (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons l2))))
                       )
                   (time-elapsed? (-> arg0 last-move) (seconds 0.175))
                   )
              )
          (set-time! (-> arg0 last-move))
          (if (!= (length a0-59) 1)
              (sound-play "ring-select")
              )
          (cond
            ((< (-> arg0 want-option-index) 0)
             (set! (-> arg0 want-option-index) 1)
             )
            ((< (-> arg0 want-option-index) 2)
             (+! (-> arg0 want-option-index) 1)
             )
            )
          )
         )
       )
     )
    )
  0
  )

(defmethod respond-progress ((this menu-sub-menu-option) (arg0 progress) (arg1 symbol))
  (let ((s4-0 *progress-work*))
    (when (and (not (-> s4-0 secrets-unlocked)) (or (= (-> arg0 current-options) *unlocked-secrets*)
                                                    (= (-> arg0 current-options) *select-scene-options*)
                                                    (= (-> arg0 current-options) *select-start-options*)
                                                    )
               )
      (set! (-> arg0 state-pos) 0)
      (set-next-state arg0 'secrets-insufficient-space 0)
      )
    (when (= (-> this name) (text-id progress-continue-without-save))
      (let ((a1-3 (get-state-check-card arg0 (-> arg0 current))))
        (set-next-state arg0 a1-3 0)
        )
      )
    (when (and (= (-> this name) (text-id progress-secrets))
               (= *title* (-> arg0 current-options))
               (not (-> s4-0 secrets-unlocked))
               (= (-> arg0 option-index) 3)
               )
      (set! (-> arg0 option-index) 0)
      0
      )
    )
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (cond
      ((= (-> this name) (text-id progress-exit-demo))
       (case *kernel-boot-message*
         (('demo-shared)
          (set! *master-exit* 'force)
          (set-master-mode 'game)
          )
         (('demo)
          (set! (-> *game-info* mode) 'play)
          (initialize! *game-info* 'game (the-as game-save #f) "title-restart" (the-as resetter-spec #f))
          )
         )
       )
      ((= (-> this name) (text-id progress-continue-without-save))
       (progress-intro-start)
       )
      ((= (-> this next-state) 'back)
       (pop-state arg0)
       )
      (else
        (sound-play "generic-beep")
        (push-state arg0)
        (set-next-state arg0 (-> this next-state) 0)
        )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-unlocked-sub-menu-option) (arg0 progress) (arg1 symbol))
  (let ((s3-0 (memcard-unlocked-secrets? arg0 #t))
        (s4-0 *progress-work*)
        )
    (when (not (-> s4-0 secrets-unlocked))
      (set! (-> arg0 state-pos) 0)
      (set-next-state arg0 'secrets-insufficient-space 0)
      )
    (when (cpad-pressed? 0 confirm)
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
      (cond
        ((logtest? s3-0 (-> this mask))
         (sound-play "generic-beep")
         (cond
           ((logtest? (-> this mask) 254)
            (set! (-> s4-0 selected-num) (-> this value))
            (push-state arg0)
            (set-next-state arg0 (-> this next-state) 0)
            )
           ((logtest? (-> this mask) 2048)
            (initialize! *game-info* 'game (the-as game-save #f) "title-museum1" (the-as resetter-spec #f))
            (set-master-mode 'game)
            )
           ((logtest? (-> this mask) 4096)
            (initialize! *game-info* 'game (the-as game-save #f) "title-museum2" (the-as resetter-spec #f))
            (set-master-mode 'game)
            )
           ((logtest? (-> this mask) 8192)
            (initialize! *game-info* 'game (the-as game-save #f) "title-museum3" (the-as resetter-spec #f))
            (set-master-mode 'game)
            )
           (#t
             (persist-with-delay *setting-control* 'fail-music-volume (seconds 5) 'music-volume 'abs 0.0 0)
             (persist-with-delay *setting-control* 'fail-sfx-volume (seconds 5) 'sfx-volume 'abs 0.0 0)
             (persist-with-delay *setting-control* 'fail-dialog-volume (seconds 5) 'dialog-volume 'abs 0.0 0)
             (set! (-> *setting-control* user-current sfx-volume) 0.01)
             (set! (-> *setting-control* user-current dialog-volume) 0.01)
             (set! (-> *setting-control* user-current music-volume) 0.01)
             (cond
               ((send-event (handle->process (-> *game-info* controller 0)) 'scrap-book (-> this value))
                (set-next-state arg0 (-> this next-state) 0)
                )
               (else
                 (set! (-> *game-info* demo-state) (the-as uint (+ (-> this value) 200)))
                 (initialize! *game-info* 'game (the-as game-save #f) "title-scrapbook" (the-as resetter-spec #f))
                 )
               )
             )
           )
         )
        (else
          (sound-play "generic-beep" :pitch -0.6)
          )
        )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-memcard-slot-option) (arg0 progress) (arg1 symbol))
  (memcard-unlocked-secrets? arg0 #t)
  (let ((a1-3 (get-state-check-card arg0 (-> arg0 current))))
    (set-next-state arg0 a1-3 0)
    )
  (set! (-> arg0 selected-option) #f)
  (when (loaded? *bigmap*)
    (cond
      ((cpad-pressed? 0 triangle)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (let ((s5-0 #f))
         *progress-save-info*
         (set! (-> arg0 which-slot) (-> arg0 option-index))
         (cond
           ((= (-> arg0 current) 'select-load)
            (when (= (-> *progress-save-info* file (-> arg0 option-index) present) 1)
              (set! s5-0 #t)
              (set-next-state arg0 'loading 0)
              )
            )
           ((and (= (-> arg0 current) 'select-save-hero)
                 (-> *setting-control* user-default auto-save)
                 (= (-> *game-info* auto-save-card) (-> *progress-save-info* handle))
                 (= (-> *game-info* auto-save-which) (-> arg0 which-slot))
                 )
            (sound-play "generic-beep" :pitch -0.6)
            )
           ((= (-> *progress-save-info* file (-> arg0 which-slot) present) 1)
            (set! s5-0 #t)
            (set-next-state arg0 'already-exists 0)
            )
           (else
             (set! s5-0 #t)
             (set-next-state arg0 'saving 0)
             )
           )
         (if s5-0
             (sound-play "generic-beep")
             )
         )
       )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-already-exists-option) (arg0 progress) (arg1 symbol))
  (let ((a1-2 (get-state-check-card arg0 'select-save))
        (gp-0 (the-as object #f))
        )
    (if (!= a1-2 'select-save)
        (set-next-state arg0 a1-2 0)
        )
    (cond
      ((cpad-pressed? 0 left l-analog-left)
       (set! gp-0 (not (-> arg0 yes-no-choice)))
       (set! (-> arg0 yes-no-choice) (the-as basic #t))
       )
      ((cpad-pressed? 0 right l-analog-right)
       (set! gp-0 (-> arg0 yes-no-choice))
       (set! (-> arg0 yes-no-choice) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (cond
         ((-> arg0 yes-no-choice)
          (sound-play "generic-beep")
          (set-next-state arg0 'saving 0)
          )
         ((begin (sound-play "generic-beep") (= (-> arg0 state-array 0) 'title))
          (set-next-state arg0 'select-save-title 0)
          )
         ((-> *progress-work* hero-mode-save)
          (set-next-state arg0 'select-save-hero 0)
          )
         (else
           (set-next-state arg0 'select-save 0)
           )
         )
       )
      )
    (if gp-0
        (sound-play "generic-beep")
        )
    )
  0
  )

(defmethod respond-progress ((this menu-create-game-option) (arg0 progress) (arg1 symbol))
  (let ((s4-0 (&-> arg0 yes-no-choice))
        (gp-0 (the-as object #f))
        )
    (let ((a1-2 (get-state-check-card arg0 'select-save)))
      (if (!= a1-2 'select-save)
          (set-next-state arg0 a1-2 0)
          )
      )
    (cond
      ((cpad-pressed? 0 left l-analog-left)
       (set! gp-0 (not (-> s4-0 0)))
       (set! (-> s4-0 0) (the-as basic #t))
       )
      ((cpad-pressed? 0 right l-analog-right)
       (set! gp-0 (-> s4-0 0))
       (set! (-> s4-0 0) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (cond
         ((-> arg0 yes-no-choice)
          (set-next-state arg0 'creating 0)
          )
         ((= (-> arg0 state-array 0) 'title)
          (sound-play "generic-beep")
          (sound-volume-off)
          (progress-intro-start)
          )
         (else
           (sound-play "generic-beep")
           (pop-state arg0)
           )
         )
       )
      )
    (if gp-0
        (sound-play "generic-beep")
        )
    )
  0
  )

(defmethod respond-progress ((this menu-insufficient-space-option) (arg0 progress) (arg1 symbol))
  (let ((s5-0 (&-> arg0 yes-no-choice))
        (s4-0 (get-state-check-card arg0 'select-save))
        )
    (cond
      ((or (= (-> arg0 starting-state) 'insufficient-space) (= (-> arg0 starting-state) 'no-memory-card))
       (cond
         ((cpad-pressed? 0 left l-analog-left)
          (when (and (not (-> s5-0 0)) (not (-> arg0 clear-screen)))
            (sound-play "generic-beep")
            (set! (-> s5-0 0) (the-as basic #t))
            )
          )
         ((cpad-pressed? 0 right l-analog-right)
          (when (and (-> s5-0 0) (not (-> arg0 clear-screen)))
            (sound-play "generic-beep")
            (set! (-> s5-0 0) #f)
            )
          )
         ((and (cpad-pressed? 0 confirm) (!= (-> arg0 current) 'none))
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
          (set! (-> arg0 clear-screen) #t)
          (cond
            ((-> s5-0 0)
             (sound-play "generic-beep")
             (pop-state arg0)
             )
            ((and (not (-> s5-0 0))
                  (!= (get-state-check-card arg0 'select-save) 'insufficient-space)
                  (!= (get-state-check-card arg0 'select-save) 'no-memory-card)
                  )
             (pop-state arg0)
             )
            (else
              (sound-play "generic-beep")
              (set-time! (-> arg0 last-move))
              (set! (-> arg0 current) 'none)
              (set-next-state arg0 s4-0 0)
              )
            )
          )
         )
       )
      (else
        (let ((a1-9 'select-save))
          'select-save
          (cond
            ((-> *progress-work* hero-mode-save)
             (set! a1-9 'select-save-hero)
             )
            ((and (= (-> arg0 starting-state) 'title)
                  (not (logtest? (-> *game-info* purchase-secrets) (game-secrets hero-mode)))
                  )
             (set! a1-9 'select-save-title)
             )
            )
          (let ((a1-10 (get-state-check-card arg0 a1-9)))
            (set-next-state arg0 a1-10 0)
            )
          )
        (cond
          ((and (cpad-pressed? 0 triangle) (or (= (-> arg0 starting-state) 'title) (= (-> arg0 starting-state) 'main)))
           (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
           (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
           )
          ((cpad-pressed? 0 confirm)
           (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
           (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
           (cond
             ((= (-> arg0 state-array 0) 'title)
              (sound-play "generic-beep")
              (sound-volume-off)
              (progress-intro-start)
              )
             (else
               (sound-play "generic-beep")
               (pop-state arg0)
               )
             )
           )
          )
        )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-secrets-insufficient-space-option) (arg0 progress) (arg1 symbol))
  (&-> arg0 yes-no-choice)
  (cond
    ((cpad-pressed? 0 confirm)
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
     (sound-play "generic-beep")
     (set-next-state arg0 'title 0)
     )
    ((cpad-pressed? 0 triangle)
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
     )
    )
  0
  )

(defmethod respond-progress ((this menu-hero-mode-message-option) (arg0 progress) (arg1 symbol))
  (&-> arg0 yes-no-choice)
  (cond
    ((cpad-pressed? 0 confirm)
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
     (sound-play "generic-beep")
     (pop-state arg0)
     )
    ((cpad-pressed? 0 triangle)
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
     )
    )
  0
  )

(defmethod respond-progress ((this menu-video-mode-warning-option) (arg0 progress) (arg1 symbol))
  (let ((gp-0 (&-> arg0 yes-no-choice)))
    (cond
      ((and (cpad-pressed? 0 left l-analog-left) (not (-> gp-0 0)))
       (sound-play "generic-beep")
       (set! (-> gp-0 0) (the-as basic #t))
       )
      ((and (cpad-pressed? 0 right l-analog-right) (-> gp-0 0))
       (sound-play "generic-beep")
       (set! (-> gp-0 0) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (set! (-> arg0 time-out) 0)
       (cond
         ((-> arg0 yes-no-choice)
          (set! (-> *setting-control* user-default video-mode) (the-as symbol (-> arg0 video-mode)))
          (set-time! (-> arg0 time-out))
          (set-next-state arg0 'video-mode-ok 0)
          )
         (else
           (set! (-> arg0 video-mode) (the-as basic 'pal))
           (pop-state arg0)
           )
         )
       )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-video-mode-ok-option) (arg0 progress) (arg1 symbol))
  (let ((s5-0 (&-> arg0 yes-no-choice)))
    (cond
      ((and (cpad-pressed? 0 left l-analog-left) (not (-> s5-0 0)))
       (sound-play "generic-beep")
       (set! (-> s5-0 0) (the-as basic #t))
       )
      ((and (cpad-pressed? 0 right l-analog-right) (-> s5-0 0))
       (sound-play "generic-beep")
       (set! (-> s5-0 0) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (cond
         ((-> arg0 yes-no-choice)
          (sound-play "generic-beep")
          )
         (else
           (set! (-> arg0 video-mode) (the-as basic 'pal))
           (set! (-> *setting-control* user-default video-mode) (the-as symbol (-> arg0 video-mode)))
           (sound-play "generic-beep")
           )
         )
       (set! (-> arg0 time-out) 0)
       (pop-state arg0)
       )
      )
    )
  (when (and (nonzero? (-> arg0 time-out)) (< (seconds 10) (- (current-time) (-> arg0 time-out))))
    (set! (-> arg0 time-out) 0)
    (set! (-> arg0 video-mode) (the-as basic 'pal))
    (set! (-> *setting-control* user-default video-mode) (the-as symbol (-> arg0 video-mode)))
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-progressive-mode-warning-option) (arg0 progress) (arg1 symbol))
  (let ((s5-0 (&-> arg0 yes-no-choice)))
    (cond
      ((and (cpad-pressed? 0 left l-analog-left) (not (-> s5-0 0)))
       (sound-play "generic-beep")
       (set! (-> arg0 progressive-scan) (the-as basic #t))
       (set! (-> s5-0 0) (the-as basic #t))
       )
      ((and (cpad-pressed? 0 right l-analog-right) (-> s5-0 0))
       (sound-play "generic-beep")
       (set! (-> arg0 progressive-scan) #f)
       (set! (-> s5-0 0) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (set! (-> arg0 time-out) 0)
       (cond
         ((-> arg0 yes-no-choice)
          (sound-play "generic-beep")
          (set-progressive-scan #t)
          (set! (-> arg0 progressive-scan) (the-as basic #t))
          (set-time! (-> arg0 time-out))
          (set-next-state arg0 'progressive-mode-ok 0)
          )
         (else
           (set! (-> arg0 progressive-scan) #f)
           (set-progressive-scan #f)
           (pop-state arg0)
           )
         )
       )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-progressive-mode-ok-option) (arg0 progress) (arg1 symbol))
  (let ((s5-0 (&-> arg0 yes-no-choice)))
    (cond
      ((and (cpad-pressed? 0 left l-analog-left) (not (-> s5-0 0)))
       (sound-play "generic-beep")
       (set! (-> s5-0 0) (the-as basic #t))
       )
      ((and (cpad-pressed? 0 right l-analog-right) (-> s5-0 0))
       (sound-play "generic-beep")
       (set! (-> s5-0 0) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (cond
         ((not (-> arg0 yes-no-choice))
          (set! (-> *setting-control* user-default set-video-mode) #f)
          (set! (-> arg0 progressive-scan) #f)
          (sound-play "generic-beep")
          )
         (else
           (sound-play "generic-beep")
           (set! (-> arg0 progressive-scan) (the-as basic #t))
           )
         )
       (set! (-> arg0 time-out) 0)
       (pop-state arg0)
       )
      )
    )
  (when (and (nonzero? (-> arg0 time-out)) (< (seconds 10) (- (current-time) (-> arg0 time-out))))
    (set! (-> arg0 time-out) 0)
    (set! (-> *setting-control* user-default set-video-mode) #f)
    (set-progressive-scan #f)
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-card-removed-option) (arg0 progress) (arg1 symbol))
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (sound-play "generic-beep")
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-insert-card-option) (arg0 progress) (arg1 symbol))
  *progress-save-info*
  (cond
    ((= (get-state-check-card arg0 'select-load) 'select-load)
     (set-next-state arg0 'select-load 0)
     )
    ((cpad-pressed? 0 confirm)
     (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
     (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
     (sound-play "generic-beep")
     (pop-state arg0)
     )
    )
  0
  )

(defmethod respond-progress ((this menu-error-loading-option) (arg0 progress) (arg1 symbol))
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (sound-play "generic-beep")
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-error-auto-saving-option) (arg0 progress) (arg1 symbol))
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (sound-play "generic-beep")
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-error-disc-removed-option) (arg0 progress) (arg1 symbol))
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (when (is-cd-in?)
      (sound-play "generic-beep")
      (pop-state arg0)
      )
    )
  0
  )

(defmethod respond-progress ((this menu-error-reading-option) (arg0 progress) (arg1 symbol))
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (sound-play "generic-beep")
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-icon-info-option) (arg0 progress) (arg1 symbol))
  (when (cpad-pressed? 0 confirm)
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (sound-play "generic-beep")
    (pop-state arg0)
    )
  0
  )

(defmethod respond-progress ((this menu-format-card-option) (arg0 progress) (arg1 symbol))
  (let ((s4-0 (&-> arg0 yes-no-choice))
        (gp-0 (the-as object #f))
        )
    (let ((a1-2 (get-state-check-card arg0 (-> arg0 current))))
      (set-next-state arg0 a1-2 0)
      )
    (cond
      ((cpad-pressed? 0 left l-analog-left)
       (set! gp-0 (not (-> s4-0 0)))
       (set! (-> s4-0 0) (the-as basic #t))
       )
      ((cpad-pressed? 0 right l-analog-right)
       (set! gp-0 (-> s4-0 0))
       (set! (-> s4-0 0) #f)
       )
      ((cpad-pressed? 0 confirm)
       (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
       (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
       (cond
         ((-> arg0 yes-no-choice)
          (sound-play "generic-beep")
          (set-next-state arg0 'formatting 0)
          )
         ((= (-> arg0 state-array 0) 'title)
          (sound-play "generic-beep")
          (sound-volume-off)
          (progress-intro-start)
          )
         (else
           (sound-play "generic-beep")
           (pop-state arg0)
           )
         )
       )
      )
    (if gp-0
        (sound-play "generic-beep")
        )
    )
  0
  )

;; WARN: disable def twice: 259. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod respond-progress ((this menu-select-start-option) (arg0 progress) (arg1 symbol))
  (let ((gp-0 *progress-work*))
    (when (not (-> gp-0 secrets-unlocked))
      (set! (-> arg0 state-pos) 0)
      (set-next-state arg0 'secrets-insufficient-space 0)
      )
    (set! (-> *progress-list-level* mode) (-> arg0 current))
    (set! (-> *progress-list-level* act) (-> gp-0 selected-num))
    )
  (let ((gp-1 #f))
    (let ((v1-8 (+ (length *progress-list-level*) -1)))
      (the float v1-8)
      (cond
        ((or (cpad-pressed? 0 up l-analog-up)
             (and (cpad-hold? 0 up l-analog-up) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
             )
         (set-time! (-> arg0 last-move))
         (let ((v1-12 (max 0 (+ (-> this selected-index) -1))))
           (if (nonzero? (-> this selected-index))
               (set! gp-1 #t)
               )
           (set! (-> this scroll-speed) 300.0)
           (set! (-> this selected-index) v1-12)
           (set! (-> this target-index) (fmin (-> this target-index) (the float (max 0 (+ v1-12 -1)))))
           )
         )
        ((or (cpad-pressed? 0 down l-analog-down)
             (and (cpad-hold? 0 down l-analog-down) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
             )
         (set-time! (-> arg0 last-move))
         (let ((a0-36 (min (+ (-> this selected-index) 1) v1-8)))
           (if (!= (-> this selected-index) v1-8)
               (set! gp-1 #t)
               )
           (set! (-> this scroll-speed) 300.0)
           (set! (-> this selected-index) a0-36)
           (set! (-> this target-index) (fmax (-> this target-index) (the float (max 0 (+ a0-36 -4)))))
           )
         )
        ((or (cpad-pressed? 0 left l-analog-left)
             (and (cpad-hold? 0 left l-analog-left) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
             )
         (set-time! (-> arg0 last-move))
         (let ((v1-24 (max 0 (+ (-> this selected-index) -5))))
           (if (nonzero? (-> this selected-index))
               (set! gp-1 #t)
               )
           (set! (-> this scroll-speed) 1000.0)
           (set! (-> this selected-index) v1-24)
           (set! (-> this target-index) (fmin (-> this target-index) (the float (max 0 (+ v1-24 -1)))))
           )
         )
        ((or (cpad-pressed? 0 right l-analog-right)
             (and (cpad-hold? 0 right l-analog-right) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
             )
         (set-time! (-> arg0 last-move))
         (let ((a0-69 (min (+ (-> this selected-index) 5) v1-8)))
           (if (!= (-> this selected-index) v1-8)
               (set! gp-1 #t)
               )
           (set! (-> this scroll-speed) 1000.0)
           (set! (-> this selected-index) a0-69)
           (set! (-> this target-index) (fmax (-> this target-index) (the float (max 0 (+ a0-69 -4)))))
           )
         )
        ((cpad-pressed? 0 confirm)
         (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
         (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
         (sound-play "generic-beep")
         (let* ((s5-1 (progress-list-method-9 *progress-list-level* (-> this selected-index)))
                (v1-42 (-> arg0 current))
                (s3-1 (cond
                        ((= v1-42 'select-pre-start)
                         (or (-> s5-1 play-continue) (-> s5-1 pre-play-continue))
                         )
                        ((or (= v1-42 'select-kiosk-start) (= v1-42 'select-kiosk-start-special))
                         (-> s5-1 kiosk-play-continue)
                         )
                        (else
                          (-> s5-1 play-continue)
                          )
                        )
                      )
                )
           (cond
             ((and (or (demo?) (kiosk?))
                   (or (= (-> arg0 current) 'select-kiosk-start) (= (-> arg0 current) 'select-kiosk-start-special))
                   (= (status-of-level-and-borrows *level* 'title #f) 'active)
                   )
              (send-event (handle->process (-> *game-info* controller 0)) 'control-spec (get-play-list-idx s5-1))
              (set-master-mode 'game)
              )
             (else
               (let* ((s2-1 play-task)
                      (a0-104 (get-play-list-idx s5-1))
                      (a1-40 'debug)
                      (v1-64 (-> arg0 current))
                      (s4-2 (s2-1
                              (the-as game-task a0-104)
                              a1-40
                              (cond
                                ((= v1-64 'select-pre-start)
                                 'pre-play
                                 )
                                ((or (= v1-64 'select-kiosk-start) (= v1-64 'select-kiosk-start-special))
                                 'kiosk
                                 )
                                (else
                                  'play
                                  )
                                )
                              )
                            )
                      )
                 (cond
                   ((pair? s3-1)
                    (start 'play (get-continue-by-name *game-info* s4-2))
                    (process-spawn
                      scene-player
                      :init scene-player-init
                      (-> (the-as pair (-> (the-as pair s3-1) cdr)) car)
                      #t
                      s4-2
                      :name "scene-player"
                      )
                    )
                   (else
                     (send-event (handle->process (-> *game-info* controller 0)) 'control-spec (get-play-list-idx s5-1))
                     (start 'play (get-continue-by-name *game-info* s4-2))
                     )
                   )
                 )
               (set-master-mode 'game)
               )
             )
           )
         )
        )
      )
    (if gp-1
        (sound-play "secrets-scroll")
        )
    )
  0
  )

(defmethod respond-progress ((this menu-select-scene-option) (arg0 progress) (arg1 symbol))
  (let* ((s4-0 *progress-work*)
         (v1-0 (-> s4-0 selected-num))
         (s3-0 (cond
                 ((zero? v1-0)
                  *hud-select-scene-act1*
                  )
                 ((= v1-0 1)
                  *hud-select-scene-act2*
                  )
                 ((= v1-0 2)
                  *hud-select-scene-act3*
                  )
                 (else
                   *hud-select-scene-commentary*
                   )
                 )
               )
         )
    (when (not (-> s4-0 secrets-unlocked))
      (set! (-> arg0 state-pos) 0)
      (set-next-state arg0 'secrets-insufficient-space 0)
      )
    (let ((gp-0 #f))
      (let ((v1-7 (+ (length s3-0) -1)))
        (the float v1-7)
        (cond
          ((or (cpad-pressed? 0 up l-analog-up)
               (and (cpad-hold? 0 up l-analog-up) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
               )
           (set-time! (-> arg0 last-move))
           (let ((v1-11 (max 0 (+ (-> this selected-index) -1))))
             (if (nonzero? (-> this selected-index))
                 (set! gp-0 #t)
                 )
             (set! (-> this scroll-speed) 300.0)
             (set! (-> this selected-index) v1-11)
             (set! (-> this target-index) (fmin (-> this target-index) (the float (max 0 (+ v1-11 -1)))))
             )
           )
          ((or (cpad-pressed? 0 down l-analog-down)
               (and (cpad-hold? 0 down l-analog-down) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
               )
           (set-time! (-> arg0 last-move))
           (let ((a0-36 (min (+ (-> this selected-index) 1) v1-7)))
             (if (!= (-> this selected-index) v1-7)
                 (set! gp-0 #t)
                 )
             (set! (-> this scroll-speed) 300.0)
             (set! (-> this selected-index) a0-36)
             (set! (-> this target-index) (fmax (-> this target-index) (the float (max 0 (+ a0-36 -4)))))
             )
           )
          ((or (cpad-pressed? 0 left l-analog-left)
               (and (cpad-hold? 0 left l-analog-left) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
               )
           (set-time! (-> arg0 last-move))
           (let ((v1-23 (max 0 (+ (-> this selected-index) -5))))
             (if (nonzero? (-> this selected-index))
                 (set! gp-0 #t)
                 )
             (set! (-> this scroll-speed) 1000.0)
             (set! (-> this selected-index) v1-23)
             (set! (-> this target-index) (fmin (-> this target-index) (the float (max 0 (+ v1-23 -1)))))
             )
           )
          ((or (cpad-pressed? 0 right l-analog-right)
               (and (cpad-hold? 0 right l-analog-right) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
               )
           (set-time! (-> arg0 last-move))
           (let ((a0-69 (min (+ (-> this selected-index) 5) v1-7)))
             (if (!= (-> this selected-index) v1-7)
                 (set! gp-0 #t)
                 )
             (set! (-> this scroll-speed) 1000.0)
             (set! (-> this selected-index) a0-69)
             (set! (-> this target-index) (fmax (-> this target-index) (the float (max 0 (+ a0-69 -4)))))
             )
           )
          ((cpad-pressed? 0 confirm)
           (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
           (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
           (sound-play "generic-beep")
           (let ((s2-2 *display-profile*))
             (play-clean 'debug)
             (set! *display-profile* s2-2)
             )
           (set! (-> *game-info* mode) 'play)
           (let ((s5-1 (-> s3-0 (-> this selected-index))))
             (set! (-> *game-info* demo-state) (the-as uint 100))
             (let ((v1-46 (-> s4-0 selected-num)))
               (cond
                 ((zero? v1-46)
                  (logior! (-> *game-info* secrets) (game-secrets scene-player-1))
                  )
                 ((= v1-46 1)
                  (logior! (-> *game-info* secrets) (game-secrets scene-player-2))
                  )
                 ((= v1-46 2)
                  (logior! (-> *game-info* secrets) (game-secrets scene-player-3))
                  )
                 ((= v1-46 3)
                  (set! (-> *game-info* demo-state) (the-as uint 101))
                  (logior! (-> *game-info* secrets) (game-secrets title-commentary))
                  )
                 )
               )
             (persist-with-delay *setting-control* 'fail-music-volume (seconds 5) 'music-volume 'abs 0.0 0)
             (persist-with-delay *setting-control* 'fail-sfx-volume (seconds 5) 'sfx-volume 'abs 0.0 0)
             (persist-with-delay *setting-control* 'fail-dialog-volume (seconds 5) 'dialog-volume 'abs 0.0 0)
             (set! (-> *setting-control* user-current sfx-volume) 0.01)
             (set! (-> *setting-control* user-current dialog-volume) 0.01)
             (set! (-> *setting-control* user-current music-volume) 0.01)
             (process-spawn scene-player :init scene-player-init (-> s5-1 info) #t (-> s5-1 continue) :name "scene-player")
             )
           (set-master-mode 'game)
           )
          )
        )
      (if gp-0
          (sound-play "secrets-scroll")
          )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-bigmap-option) (arg0 progress) (arg1 symbol))
  (handle-cpad-input *bigmap*)
  (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
  (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
  0
  )

(defmethod respond-progress ((this menu-missions-option) (arg0 progress) (arg1 symbol))
  (let ((v1-0 #f))
    (let ((f0-1 (the float (+ (-> arg0 total-num-tasks) -1))))
      (cond
        ((or (cpad-pressed? 0 up l-analog-up)
             (and (cpad-hold? 0 up l-analog-up) (= (-> this current-index) (-> this target-index)))
             )
         (if (!= (-> this target-index) 0.0)
             (set! v1-0 #t)
             )
         (set! (-> this scroll-speed) 300.0)
         (set! (-> this target-index) (fmax 0.0 (+ -1.0 (-> this target-index))))
         )
        ((and (not (-> this on-screen))
              (or (cpad-pressed? 0 down l-analog-down)
                  (and (cpad-hold? 0 down l-analog-down) (= (-> this current-index) (-> this target-index)))
                  )
              )
         (if (!= (-> this target-index) f0-1)
             (set! v1-0 #t)
             )
         (set! (-> this scroll-speed) 300.0)
         (set! (-> this target-index) (fmin (+ 1.0 (-> this target-index)) f0-1))
         )
        ((or (cpad-pressed? 0 left l-analog-left)
             (and (cpad-hold? 0 left l-analog-left) (= (-> this current-index) (-> this target-index)))
             )
         (if (!= (-> this target-index) 0.0)
             (set! v1-0 #t)
             )
         (set! (-> this scroll-speed) 1000.0)
         (set! (-> this target-index) (fmax 0.0 (+ -5.0 (-> this target-index))))
         )
        ((and (not (-> this on-screen))
              (or (cpad-pressed? 0 right l-analog-right)
                  (and (cpad-hold? 0 right l-analog-right) (= (-> this current-index) (-> this target-index)))
                  )
              )
         (if (!= (-> this target-index) f0-1)
             (set! v1-0 #t)
             )
         (set! (-> this scroll-speed) 1000.0)
         (set! (-> this target-index) (fmin (+ 5.0 (-> this target-index)) f0-1))
         )
        )
      )
    (if v1-0
        (sound-play "mission-scroll")
        )
    )
  0
  )

(defmethod menu-highscores-option-method-12 ((this menu-highscores-option))
  (let ((v0-0 0))
    (dotimes (v1-0 16)
      (let ((a1-2 (-> this info v1-0)))
        (when (or (zero? (-> a1-2 secret)) (logtest? (-> *game-info* secrets) (-> a1-2 secret)))
          (set! (-> this pages v0-0) (the-as paged-menu-option a1-2))
          (+! v0-0 1)
          )
        )
      )
    (set! (-> this num-pages) v0-0)
    v0-0
    )
  )

(defmethod respond-progress ((this menu-highscores-option) (arg0 progress) (arg1 symbol))
  (let ((f30-0 (the float (menu-highscores-option-method-12 this)))
        (gp-0 #f)
        )
    (let ((f0-1 0.0))
      (let ((f1-0 (-> this target-index)))
        (set! (-> this target-index) (- f1-0 (* (the float (the int (/ f1-0 f30-0))) f30-0)))
        )
      (cond
        ((and (cpad-hold? 0 r1) (= (-> this current-index) (-> this target-index)))
         (set! gp-0 #t)
         (let ((f0-3 (+ 1.0 (-> this target-index))))
           (set! (-> this target-index) (- f0-3 (* (the float (the int (/ f0-3 f30-0))) f30-0)))
           )
         (set! f0-1 182.04445)
         )
        ((and (cpad-hold? 0 l1) (= (-> this current-index) (-> this target-index)))
         (set! gp-0 #t)
         (let ((f0-7 (+ -1.0 f30-0 (-> this target-index))))
           (set! (-> this target-index) (- f0-7 (* (the float (the int (/ f0-7 f30-0))) f30-0)))
           )
         (set! f0-1 -182.04445)
         )
        )
      (let* ((f28-0 (/ 65536.0 f30-0))
             (f1-17 (* 3.0 (seconds-per-frame) f28-0))
             (f0-9 (+ (* (-> this current-index) f28-0) f0-1))
             (f2-10 (* (-> this target-index) f28-0))
             (f0-11 (+ 65536.0 (deg-seek f0-9 f2-10 f1-17)))
             )
        (set! (-> this current-index) (/ (- f0-11 (* (the float (the int (/ f0-11 65536.0))) 65536.0)) f28-0))
        )
      )
    (when (< (fabs (- (-> this current-index) (-> this target-index))) 0.01)
      (let ((f0-17 (-> this target-index)))
        (set! (-> this current-index) (- f0-17 (* (the float (the int (/ f0-17 f30-0))) f30-0)))
        )
      )
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (if gp-0
        (sound-play "score-slide")
        )
    )
  0
  )

(defmethod init-text! ((this controls-page-info))
  (let ((v0-0 0))
    (dotimes (v1-0 (-> this strings length))
      (let ((a1-2 (-> this strings v1-0)))
        (when (or (logtest? (-> *game-info* features) (-> a1-2 feature))
                  (logtest? (-> *game-info* secrets) (-> a1-2 secret))
                  (logtest? (-> *game-info* vehicles) (-> a1-2 vehicle))
                  (and (zero? (-> a1-2 feature)) (zero? (-> a1-2 secret)) (zero? (-> a1-2 vehicle)))
                  )
          (set! (-> this text v0-0) (the-as game-text a1-2))
          (+! v0-0 1)
          )
        )
      )
    (set! (-> this num-text) v0-0)
    v0-0
    )
  )

(defmethod controls-page-info-method-10 ((this controls-page-info))
  (let ((f0-1 (the float (max 0 (+ (init-text! this) -1))))
        (v1-3 #f)
        )
    (set! (-> this target-index) (fmax 0.0 (fmin (-> this target-index) f0-1)))
    (cond
      ((and (not (-> this on-screen))
            (cpad-hold? 0 down l-analog-down)
            (= (-> this current-index) (-> this target-index))
            )
       (if (!= (-> this target-index) f0-1)
           (set! v1-3 #t)
           )
       (set! (-> this target-index) (fmin (+ 1.0 (-> this target-index)) f0-1))
       )
      ((and (cpad-hold? 0 up l-analog-up) (= (-> this current-index) (-> this target-index)))
       (if (!= (-> this target-index) 0.0)
           (set! v1-3 #t)
           )
       (set! (-> this target-index) (fmax 0.0 (+ -1.0 (-> this target-index))))
       )
      )
    (if v1-3
        (sound-play "score-slide")
        )
    )
  0
  (none)
  )

(defmethod menu-controls-option-method-12 ((this menu-controls-option))
  (let ((v0-0 0))
    (dotimes (v1-0 7)
      (let ((a1-2 (-> this info v1-0)))
        (when (or (logtest? (-> *game-info* features) (-> a1-2 feature))
                  (logtest? (-> *game-info* secrets) (-> a1-2 secret))
                  (logtest? (-> *game-info* vehicles) (-> a1-2 vehicle))
                  (and (zero? (-> a1-2 feature)) (zero? (-> a1-2 secret)) (zero? (-> a1-2 vehicle)))
                  )
          (set! (-> this pages v0-0) a1-2)
          (+! v0-0 1)
          )
        )
      )
    (set! (-> this num-pages) v0-0)
    v0-0
    )
  )

(defmethod respond-progress ((this menu-controls-option) (arg0 progress) (arg1 symbol))
  (let ((f30-0 (the float (menu-controls-option-method-12 this)))
        (s4-0 #f)
        )
    (let ((f0-1 0.0))
      (let ((f1-0 (-> this target-index)))
        (set! (-> this target-index) (- f1-0 (* (the float (the int (/ f1-0 f30-0))) f30-0)))
        )
      (cond
        ((and (cpad-hold? 0 r1) (= (-> this current-index) (-> this target-index)))
         (let ((f0-3 (+ 1.0 (-> this target-index))))
           (set! (-> this target-index) (- f0-3 (* (the float (the int (/ f0-3 f30-0))) f30-0)))
           )
         (set! f0-1 182.04445)
         (set! s4-0 #t)
         )
        ((and (cpad-hold? 0 l1) (= (-> this current-index) (-> this target-index)))
         (let ((f0-7 (+ -1.0 f30-0 (-> this target-index))))
           (set! (-> this target-index) (- f0-7 (* (the float (the int (/ f0-7 f30-0))) f30-0)))
           )
         (set! f0-1 -182.04445)
         (set! s4-0 #t)
         )
        )
      (let* ((f28-0 (/ 65536.0 f30-0))
             (f1-17 (* 3.0 (seconds-per-frame) f28-0))
             (f0-9 (+ (* (-> this current-index) f28-0) f0-1))
             (f2-10 (* (-> this target-index) f28-0))
             (f0-11 (+ 65536.0 (deg-seek f0-9 f2-10 f1-17)))
             )
        (set! (-> this current-index) (/ (- f0-11 (* (the float (the int (/ f0-11 65536.0))) 65536.0)) f28-0))
        )
      )
    (when (< (fabs (- (-> this current-index) (-> this target-index))) 0.01)
      (let ((f0-17 (-> this target-index)))
        (set! (-> this current-index) (- f0-17 (* (the float (the int (/ f0-17 f30-0))) f30-0)))
        )
      )
    (if (= (-> this current-index) (-> this target-index))
        (controls-page-info-method-10 (-> this pages (the int (-> this current-index))))
        )
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (if s4-0
        (sound-play "score-slide")
        )
    )
  0
  )

(defmethod respond-progress ((this menu-secret-option) (arg0 progress) (arg1 symbol))
  (let ((gp-0 (the-as object #f)))
    (the float (+ (-> *menu-secrets-array* length) -1))
    (let ((a0-1 (+ (-> *menu-secrets-array* length) -1))
          (v1-5 *menu-secrets-array*)
          (s2-0 (the int (-> *game-info* skill)))
          (s3-0 (-> *menu-secrets-array* (-> this selected-index)))
          )
      (if (or (nonzero? (-> *setting-control* user-current subtitle-language))
              (nonzero? (-> *setting-control* user-current language))
              (nonzero? (-> *setting-control* user-current audio-language))
              )
          (+! a0-1 -1)
          )
      (set! (-> this selected-index) (min (-> this selected-index) a0-1))
      (cond
        ((-> this available-title)
         (when (or (cpad-pressed? 0 confirm) (cpad-pressed? 0 triangle))
           (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
           (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
           (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
           (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
           (set! (-> this available-title) #f)
           )
         )
        ((-> this buy-menu)
         (cond
           ((cpad-pressed? 0 left l-analog-left)
            (set! gp-0 (not (-> arg0 yes-no-choice)))
            (set! (-> arg0 yes-no-choice) (the-as basic #t))
            )
           ((cpad-pressed? 0 right l-analog-right)
            (set! gp-0 (-> arg0 yes-no-choice))
            (set! (-> arg0 yes-no-choice) #f)
            )
           ((cpad-pressed? 0 confirm)
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
            (cond
              ((-> arg0 yes-no-choice)
               (secret-item-option-method-13 s3-0)
               (set! (-> *game-info* skill) (- (-> *game-info* skill) (the float (-> s3-0 cost))))
               (sound-play "upgrade-buy")
               (set! (-> this buy-menu) #f)
               (cond
                 ((= (-> s3-0 secret) (game-secrets hero-mode))
                  (set-next-state arg0 'select-save-hero 0)
                  )
                 ((logtest? (-> s3-0 flags) (secret-item-option-flags sf2))
                  (set! (-> this available-title) #t)
                  )
                 )
               )
              (else
                (sound-play "generic-beep")
                (set! (-> this buy-menu) #f)
                )
              )
            )
           ((cpad-pressed? 0 triangle)
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
            (sound-play "generic-beep")
            (set! (-> this buy-menu) #f)
            )
           )
         )
        (else
          (cond
            ((or (cpad-pressed? 0 up l-analog-up)
                 (and (cpad-hold? 0 up l-analog-up) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
                 )
             (set-time! (-> arg0 last-move))
             (let ((a0-73 (max 1 (+ (-> this selected-index) -1))))
               (if (!= (-> this selected-index) 1)
                   (set! gp-0 #t)
                   )
               (if (logtest? (-> v1-5 a0-73 flags) (secret-item-option-flags sf0))
                   (+! a0-73 -1)
                   )
               (set! (-> this selected-index) a0-73)
               (set! (-> this target-index) (fmin (-> this target-index) (the float (max 0 (+ a0-73 -1)))))
               )
             )
            ((or (cpad-pressed? 0 down l-analog-down)
                 (and (cpad-hold? 0 down l-analog-down) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
                 )
             (set-time! (-> arg0 last-move))
             (let ((a1-51 (min (+ (-> this selected-index) 1) a0-1)))
               (if (!= (-> this selected-index) a0-1)
                   (set! gp-0 #t)
                   )
               (if (logtest? (-> v1-5 a1-51 flags) (secret-item-option-flags sf0))
                   (set! a1-51 (min (+ a1-51 1) a0-1))
                   )
               (set! (-> this selected-index) a1-51)
               (set! (-> this target-index) (fmax (-> this target-index) (the float (max 0 (+ a1-51 -3)))))
               )
             )
            ((or (cpad-pressed? 0 left l-analog-left)
                 (and (cpad-hold? 0 left l-analog-left) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
                 )
             (set-time! (-> arg0 last-move))
             (let ((a0-79 (max 1 (+ (-> this selected-index) -5))))
               (if (!= (-> this selected-index) 1)
                   (set! gp-0 #t)
                   )
               (if (logtest? (-> v1-5 a0-79 flags) (secret-item-option-flags sf0))
                   (+! a0-79 -1)
                   )
               (set! (-> this selected-index) a0-79)
               (set! (-> this target-index) (fmin (-> this target-index) (the float (max 0 (+ a0-79 -1)))))
               )
             )
            ((or (cpad-pressed? 0 right l-analog-right)
                 (and (cpad-hold? 0 right l-analog-right) (time-elapsed? (-> arg0 last-move) (seconds 0.1)))
                 )
             (set-time! (-> arg0 last-move))
             (let ((a1-82 (min (+ (-> this selected-index) 5) a0-1)))
               (if (!= (-> this selected-index) a0-1)
                   (set! gp-0 #t)
                   )
               (if (logtest? (-> v1-5 a1-82 flags) (secret-item-option-flags sf0))
                   (set! a1-82 (min (+ a1-82 1) a0-1))
                   )
               (set! (-> this selected-index) a1-82)
               (set! (-> this target-index) (fmax (-> this target-index) (the float (max 0 (+ a1-82 -3)))))
               )
             )
            ((and (cpad-pressed? 0 confirm) (= (-> this current-index) (-> this target-index)))
             (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
             (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
             (let ((v1-112 (secret-item-option-method-12 s3-0)))
               (cond
                 ((zero? v1-112)
                  (cond
                    ((>= s2-0 (-> s3-0 cost))
                     (sound-play "generic-beep")
                     (set! (-> arg0 yes-no-choice) #f)
                     (set! (-> this buy-menu) #t)
                     )
                    (else
                      (sound-play "generic-beep" :pitch -0.6)
                      )
                    )
                  )
                 ((or (= v1-112 1) (= v1-112 2))
                  (cond
                    ((logtest? (-> s3-0 flags) (secret-item-option-flags sf1))
                     (set! (-> *game-info* secrets)
                           (logclear (logxor (-> *game-info* secrets) (the-as uint (-> s3-0 secret))) (-> s3-0 mask-secrets))
                           )
                     (sound-play "generic-beep")
                     )
                    ((and (= (-> s3-0 secret) 1) (not (logtest? (-> *game-info* secrets) (game-secrets hero-mode))))
                     (set! (-> *progress-work* hero-mode-save) #t)
                     (set-next-state arg0 'select-save-hero 0)
                     )
                    ((logtest? (-> s3-0 flags) (secret-item-option-flags sf2))
                     (set! (-> this available-title) #t)
                     (sound-play "generic-beep")
                     )
                    (else
                      (sound-play "generic-beep" :pitch -0.6)
                      )
                    )
                  )
                 ((or (= v1-112 3) (= v1-112 4) (= v1-112 5))
                  (sound-play "generic-beep" :pitch -0.6)
                  )
                 )
               )
             )
            )
          )
        )
      )
    (if gp-0
        (sound-play "mission-scroll")
        )
    )
  0
  )

(defmethod respond-progress ((this menu-game-option) (arg0 progress) (arg1 symbol))
  (-> arg0 vibrations)
  (-> arg0 subtitles)
  (load-level-text-files (the-as int (-> *setting-control* user-current language)))
  (cond
    (arg1
      (cond
        ((cpad-pressed? 0 left l-analog-left)
         (sound-play "generic-beep")
         (case (-> this menu-option-type)
           ((3)
            (when (not (-> arg0 vibrations))
              (set! (-> *cpad-list* cpads 0 buzz-pause-val 0) (the-as uint 255))
              (set! (-> *cpad-list* cpads 0 buzz-pause-time) (the-as uint 15))
              )
            (set! (-> arg0 vibrations) (the-as basic #t))
            )
           ((4)
            (set! (-> arg0 subtitles) (the-as basic #t))
            )
           ((5)
            (set! (-> arg0 subtitle-language-index) (mod (+ (-> arg0 subtitle-language-index) 9) 10))
            (if (and (= (-> arg0 subtitle-language-index) 7)
                     (or (= (scf-get-territory) 1)
                         (and (!= (scf-get-territory) 3) (not *cheat-mode*) (!= *progress-cheat* 'language))
                         )
                     )
                (+! (-> arg0 subtitle-language-index) -1)
                )
            (if (= (-> arg0 subtitle-language-index) 6)
                (+! (-> arg0 subtitle-language-index) -2)
                )
            )
           ((6)
            (set! (-> arg0 language-index) (mod (+ (-> arg0 language-index) 9) 10))
            (if (and (= (-> arg0 language-index) 7)
                     (or (= (scf-get-territory) 1)
                         (and (!= (scf-get-territory) 3) (not *cheat-mode*) (!= *progress-cheat* 'language))
                         )
                     )
                (+! (-> arg0 language-index) -1)
                )
            (if (= (-> arg0 language-index) 6)
                (+! (-> arg0 language-index) -2)
                )
            )
           ((7)
            (set! (-> arg0 audio-language-index) (mod (+ (-> arg0 audio-language-index) 4) 5))
            )
           )
         )
        ((cpad-pressed? 0 right l-analog-right)
         (sound-play "generic-beep")
         (case (-> this menu-option-type)
           ((3)
            (set! (-> arg0 vibrations) #f)
            )
           ((4)
            (set! (-> arg0 subtitles) #f)
            )
           ((5)
            (set! (-> arg0 subtitle-language-index) (mod (+ (-> arg0 subtitle-language-index) 1) 10))
            (if (= (-> arg0 subtitle-language-index) 5)
                (+! (-> arg0 subtitle-language-index) 2)
                )
            (if (and (= (-> arg0 subtitle-language-index) 7)
                     (or (= (scf-get-territory) 1)
                         (and (!= (scf-get-territory) 3) (not *cheat-mode*) (!= *progress-cheat* 'language))
                         )
                     )
                (+! (-> arg0 subtitle-language-index) 1)
                )
            )
           ((6)
            (set! (-> arg0 language-index) (mod (+ (-> arg0 language-index) 1) 10))
            (if (= (-> arg0 language-index) 5)
                (+! (-> arg0 language-index) 2)
                )
            (if (and (= (-> arg0 language-index) 7)
                     (or (= (scf-get-territory) 1)
                         (and (!= (scf-get-territory) 3) (not *cheat-mode*) (!= *progress-cheat* 'language))
                         )
                     )
                (+! (-> arg0 language-index) 1)
                )
            )
           ((7)
            (set! (-> arg0 audio-language-index) (mod (+ (-> arg0 audio-language-index) 1) 5))
            )
           )
         )
        ((cpad-pressed? 0 confirm)
         (case (-> this menu-option-type)
           ((3)
            (set! (-> *setting-control* user-default vibration) (the-as symbol (-> arg0 vibrations)))
            )
           ((4)
            (set! (-> *setting-control* user-default subtitle) (the-as symbol (-> arg0 subtitles)))
            )
           ((5)
            (set! (-> *setting-control* user-default subtitle-language)
                  (the-as language-enum (-> arg0 subtitle-language-index))
                  )
            )
           ((6)
            (set! (-> *setting-control* user-default language) (the-as language-enum (-> arg0 language-index)))
            (load-level-text-files (-> arg0 language-index))
            )
           ((7)
            (set! (-> *setting-control* user-default audio-language)
                  (the-as language-enum (-> arg0 audio-language-index))
                  )
            )
           )
         (if (or (nonzero? (-> *setting-control* user-default subtitle-language))
                 (nonzero? (-> *setting-control* user-default language))
                 (nonzero? (-> *setting-control* user-default audio-language))
                 )
             (set! (-> *unlocked-secrets* options length) 11)
             (set! (-> *unlocked-secrets* options length) 12)
             )
         )
        )
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons up l-analog-up))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons up l-analog-up))
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons down l-analog-down))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons down l-analog-down))
      )
    (else
      (set! (-> arg0 vibrations) (the-as basic (-> *setting-control* user-default vibration)))
      (set! (-> arg0 subtitles) (the-as basic (-> *setting-control* user-default subtitle)))
      (set! (-> arg0 language-index) (the-as int (-> *setting-control* user-default language)))
      (set! (-> arg0 subtitle-language-index) (the-as int (-> *setting-control* user-default subtitle-language)))
      (set! (-> arg0 audio-language-index) (the-as int (-> *setting-control* user-default audio-language)))
      )
    )
  0
  )

(defmethod respond-progress ((this menu-language-option) (arg0 progress) (arg1 symbol))
  (enable-level-text-file-loading)
  (set! (-> arg0 language-index) (the-as int (-> *setting-control* user-default language)))
  (cond
    ((cpad-pressed? 0 left l-analog-left)
     (sound-play "generic-beep")
     (set! (-> arg0 language-index) (mod (+ (-> arg0 language-index) 9) 10))
     (if (and (= (-> arg0 language-index) 7)
              (or (= (scf-get-territory) 1)
                  (and (!= (scf-get-territory) 3) (not *cheat-mode*) (!= *progress-cheat* 'language))
                  )
              )
         (+! (-> arg0 language-index) -1)
         )
     (if (= (-> arg0 language-index) 6)
         (+! (-> arg0 language-index) -2)
         )
     (set! (-> *setting-control* user-default language) (the-as language-enum (-> arg0 language-index)))
     (load-level-text-files (-> arg0 language-index))
     )
    ((cpad-pressed? 0 right l-analog-right)
     (sound-play "generic-beep")
     (set! (-> arg0 language-index) (mod (+ (-> arg0 language-index) 1) 10))
     (if (= (-> arg0 language-index) 5)
         (+! (-> arg0 language-index) 2)
         )
     (if (and (= (-> arg0 language-index) 7)
              (or (= (scf-get-territory) 1)
                  (and (!= (scf-get-territory) 3) (not *cheat-mode*) (!= *progress-cheat* 'language))
                  )
              )
         (+! (-> arg0 language-index) 1)
         )
     (set! (-> *setting-control* user-default language) (the-as language-enum (-> arg0 language-index)))
     (load-level-text-files (-> arg0 language-index))
     )
    ((cpad-pressed? 0 confirm)
     (set! (-> *setting-control* user-default subtitle-language) (the-as language-enum (-> arg0 language-index)))
     (set! (-> *setting-control* user-default audio-language)
           (the-as language-enum (-> *audio-language-remap* (-> arg0 language-index)))
           )
     (if (or (nonzero? (-> *setting-control* user-default subtitle-language))
             (nonzero? (-> *setting-control* user-default language))
             (nonzero? (-> *setting-control* user-default audio-language))
             )
         (set! (-> *unlocked-secrets* options length) 11)
         (set! (-> *unlocked-secrets* options length) 12)
         )
     (pop-state arg0)
     )
    )
  0
  )

(defmethod respond-progress ((this menu-graphic-option) (arg0 progress) (arg1 symbol))
  (cond
    (arg1
      (case (-> this menu-option-type)
        ((8)
         (let ((v1-1 #f))
           (cond
             ((cpad-hold? 0 left l-analog-left)
              (set! (-> *setting-control* user-default screenx)
                    (min-max-wrap-around (+ (-> *setting-control* user-default screenx) -2) -96 96)
                    )
              (set! v1-1 #t)
              )
             ((cpad-hold? 0 right l-analog-right)
              (set! (-> *setting-control* user-default screenx)
                    (min-max-wrap-around (+ (-> *setting-control* user-default screenx) 2) -96 96)
                    )
              (set! v1-1 #t)
              )
             ((cpad-hold? 0 up l-analog-up)
              (set! (-> *setting-control* user-default screeny)
                    (min-max-wrap-around (+ (-> *setting-control* user-default screeny) -2) -48 48)
                    )
              (set! v1-1 #t)
              )
             ((cpad-hold? 0 down l-analog-down)
              (set! (-> *setting-control* user-default screeny)
                    (min-max-wrap-around (+ (-> *setting-control* user-default screeny) 2) -48 48)
                    )
              (set! v1-1 #t)
              )
             ((cpad-pressed? 0 square)
              (set! (-> *setting-control* user-default screenx) 0)
              (set! (-> *setting-control* user-default screeny) 24)
              )
             ((cpad-pressed? 0 triangle)
              (set! (-> *setting-control* user-default screenx) (-> arg0 center-x-backup))
              (set! (-> *setting-control* user-default screeny) (-> arg0 center-y-backup))
              )
             )
           (when v1-1
             (when (< (seconds 0.1) (- (current-time) (-> arg0 last-sound)))
               (set-time! (-> arg0 last-sound))
               (sound-play "roll-over")
               )
             )
           )
         )
        ((9)
         (cond
           ((cpad-pressed? 0 left l-analog-left)
            (sound-play "generic-beep")
            (set! (-> arg0 aspect-ratio) (the-as basic 'aspect4x3))
            )
           ((cpad-pressed? 0 right l-analog-right)
            (sound-play "generic-beep")
            (set! (-> arg0 aspect-ratio) (the-as basic 'aspect16x9))
            )
           ((cpad-pressed? 0 triangle)
            (set! (-> arg0 aspect-ratio) (the-as basic (get-aspect-ratio)))
            )
           ((cpad-pressed? 0 confirm)
            (set! (-> *setting-control* user-default aspect-ratio) (the-as symbol (-> arg0 aspect-ratio)))
            )
           )
         )
        ((10)
         (cond
           ((cpad-pressed? 0 left l-analog-left)
            (sound-play "generic-beep")
            (set! (-> arg0 progressive-scan) (the-as basic #t))
            )
           ((cpad-pressed? 0 right l-analog-right)
            (sound-play "generic-beep")
            (set! (-> arg0 progressive-scan) #f)
            (set! (-> *setting-control* user-default set-video-mode) #f)
            )
           ((cpad-pressed? 0 triangle)
            (set! (-> arg0 progressive-scan) (the-as basic (-> *setting-control* user-default set-video-mode)))
            )
           ((cpad-pressed? 0 confirm)
            (push-state arg0)
            (set-next-state arg0 'progressive-mode-warning 0)
            )
           )
         )
        ((11)
         (cond
           ((cpad-pressed? 0 left l-analog-left)
            (sound-play "generic-beep")
            (set! (-> arg0 video-mode) (the-as basic 'pal))
            )
           ((cpad-pressed? 0 right l-analog-right)
            (sound-play "generic-beep")
            (set! (-> arg0 video-mode) (the-as basic 'ntsc))
            )
           ((cpad-pressed? 0 triangle)
            (set! (-> arg0 video-mode) (the-as basic (get-video-mode)))
            )
           ((cpad-pressed? 0 confirm)
            (when (!= (-> *setting-control* user-default video-mode) (-> arg0 video-mode))
              (let ((v1-88 (-> arg0 video-mode)))
                (case v1-88
                  (('pal)
                   (set! (-> *setting-control* user-default video-mode) (the-as symbol v1-88))
                   )
                  (('ntsc)
                   (push-state arg0)
                   (set-next-state arg0 'video-mode-warning 0)
                   )
                  )
                )
              )
            )
           )
         )
        )
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons up l-analog-up))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons up l-analog-up))
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons down l-analog-down))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons down l-analog-down))
      )
    (else
      (when (cpad-pressed? 0 confirm)
        (case (-> this menu-option-type)
          ((8)
           (set! (-> arg0 center-x-backup) (-> *setting-control* user-default screenx))
           (set! (-> arg0 center-y-backup) (-> *setting-control* user-default screeny))
           )
          ((9)
           (set! (-> arg0 aspect-ratio) (the-as basic (-> *setting-control* user-default aspect-ratio)))
           )
          ((10)
           (set! (-> arg0 progressive-scan) (the-as basic (-> *setting-control* user-default set-video-mode)))
           )
          ((11)
           (set! (-> arg0 video-mode) (the-as basic (get-video-mode)))
           )
          )
        )
      )
    )
  0
  )

(defmethod respond-progress ((this menu-camera-option) (arg0 progress) (arg1 symbol))
  (cond
    (arg1
      (case (-> this menu-option-type)
        ((12)
         (cond
           ((cpad-pressed? 0 left l-analog-left)
            (set! (-> arg0 flip-horizontal) #f)
            (sound-play "generic-beep")
            )
           ((cpad-pressed? 0 right l-analog-right)
            (set! (-> arg0 flip-horizontal) (the-as basic #t))
            (sound-play "generic-beep")
            )
           ((cpad-pressed? 0 confirm)
            (set! (-> *setting-control* cam-default flip-horizontal) (the-as symbol (-> arg0 flip-horizontal)))
            )
           ((cpad-pressed? 0 triangle)
            (set! (-> arg0 flip-horizontal) (the-as basic (-> *setting-control* cam-current flip-horizontal)))
            )
           )
         )
        ((13)
         (cond
           ((cpad-pressed? 0 left l-analog-left)
            (set! (-> arg0 flip-vertical) #f)
            (sound-play "generic-beep")
            )
           ((cpad-pressed? 0 right l-analog-right)
            (set! (-> arg0 flip-vertical) (the-as basic #t))
            (sound-play "generic-beep")
            )
           ((cpad-pressed? 0 confirm)
            (set! (-> *setting-control* cam-default flip-vertical) (the-as symbol (-> arg0 flip-vertical)))
            )
           ((cpad-pressed? 0 triangle)
            (set! (-> arg0 flip-vertical) (the-as basic (-> *setting-control* cam-current flip-vertical)))
            )
           )
         )
        )
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons up l-analog-up))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons up l-analog-up))
      (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons down l-analog-down))
      (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons down l-analog-down))
      )
    (else
      (cond
        ((cpad-pressed? 0 confirm)
         (set! (-> arg0 flip-horizontal) (the-as basic (-> *setting-control* cam-current flip-horizontal)))
         (set! (-> arg0 flip-vertical) (the-as basic (-> *setting-control* cam-current flip-vertical)))
         )
        ((cpad-pressed? 0 triangle)
         (set! (-> arg0 flip-horizontal) (the-as basic (-> *setting-control* cam-current flip-horizontal)))
         (set! (-> arg0 flip-vertical) (the-as basic (-> *setting-control* cam-current flip-vertical)))
         )
        )
      )
    )
  0
  )

(defmethod item-obtained? ((this inventory-item))
  (or (logtest? (-> *game-info* features) (-> this feature))
      (logtest? (-> *game-info* vehicles) (-> this vehicle))
      (logtest? (-> *game-info* items) (-> this item))
      )
  )

(defmethod have-items? ((this inventory-item-group))
  (let ((gp-0 #f))
    (dotimes (s4-0 (-> this items length))
      (if (item-obtained? (-> this items s4-0))
          (set! gp-0 #t)
          )
      )
    gp-0
    )
  )

(defmethod respond-progress ((this menu-inventory) (arg0 progress) (arg1 symbol))
  (let* ((f30-0 (the float (-> this screens length)))
         (s4-0 (-> this screens (min (the int (-> this current-index)) (-> this screens length))))
         (v1-9 (-> s4-0 groups (-> s4-0 current-index)))
         (gp-0 #f)
         )
    (let ((f28-0 0.0))
      (let ((f0-3 (-> this target-index)))
        (set! (-> this target-index) (- f0-3 (* (the float (the int (/ f0-3 f30-0))) f30-0)))
        )
      (cond
        ((or (cpad-pressed? 0 left l-analog-left)
             (and (cpad-hold? 0 left l-analog-left) (time-elapsed? (-> arg0 last-move) (seconds 0.2)))
             )
         (set-time! (-> arg0 last-move))
         (let ((s3-0 (-> s4-0 current-index))
               (s2-0 (-> v1-9 index-left))
               )
           (let ((s0-0 (-> s4-0 groups s2-0))
                 (s1-0 6)
                 )
             (while (and (not (have-items? s0-0)) (!= s3-0 s2-0) (nonzero? s1-0))
               (set! s2-0 (-> s0-0 index-left))
               (set! s0-0 (-> s4-0 groups s2-0))
               (+! s1-0 -1)
               (if (zero? s1-0)
                   (set! s2-0 s3-0)
                   )
               )
             )
           (when (!= s3-0 s2-0)
             (set! (-> s4-0 current-index) s2-0)
             (sound-play "generic-beep")
             )
           )
         )
        ((or (cpad-pressed? 0 right l-analog-right)
             (and (cpad-hold? 0 right l-analog-right) (time-elapsed? (-> arg0 last-move) (seconds 0.2)))
             )
         (set-time! (-> arg0 last-move))
         (let ((s3-2 (-> s4-0 current-index))
               (s2-1 (-> v1-9 index-right))
               )
           (let ((s0-1 (-> s4-0 groups s2-1))
                 (s1-1 6)
                 )
             (while (and (not (have-items? s0-1)) (!= s3-2 s2-1) (nonzero? s1-1))
               (set! s2-1 (-> s0-1 index-right))
               (set! s0-1 (-> s4-0 groups s2-1))
               (+! s1-1 -1)
               (if (zero? s1-1)
                   (set! s2-1 s3-2)
                   )
               )
             )
           (when (!= s3-2 s2-1)
             (set! (-> s4-0 current-index) s2-1)
             (sound-play "generic-beep")
             )
           )
         )
        ((or (cpad-pressed? 0 up l-analog-up)
             (and (cpad-hold? 0 up l-analog-up) (time-elapsed? (-> arg0 last-move) (seconds 0.2)))
             )
         (set-time! (-> arg0 last-move))
         (let ((s3-4 (-> s4-0 current-index))
               (s2-2 (-> v1-9 index-up))
               )
           (let ((s0-2 (-> s4-0 groups s2-2))
                 (s1-2 6)
                 )
             (while (and (not (have-items? s0-2)) (!= s3-4 s2-2) (nonzero? s1-2))
               (set! s2-2 (-> s0-2 index-up))
               (set! s0-2 (-> s4-0 groups s2-2))
               (+! s1-2 -1)
               (if (zero? s1-2)
                   (set! s2-2 s3-4)
                   )
               )
             )
           (when (!= s3-4 s2-2)
             (set! (-> s4-0 current-index) s2-2)
             (sound-play "generic-beep")
             )
           )
         )
        ((or (cpad-pressed? 0 down l-analog-down)
             (and (cpad-hold? 0 down l-analog-down) (time-elapsed? (-> arg0 last-move) (seconds 0.2)))
             )
         (set-time! (-> arg0 last-move))
         (let ((s3-6 (-> s4-0 current-index))
               (s2-3 (-> v1-9 index-down))
               )
           (let ((s0-3 (-> s4-0 groups s2-3))
                 (s1-3 6)
                 )
             (while (and (not (have-items? s0-3)) (!= s3-6 s2-3) (nonzero? s1-3))
               (set! s2-3 (-> s0-3 index-down))
               (set! s0-3 (-> s4-0 groups s2-3))
               (+! s1-3 -1)
               (if (zero? s1-3)
                   (set! s2-3 s3-6)
                   )
               )
             )
           (when (!= s3-6 s2-3)
             (set! (-> s4-0 current-index) s2-3)
             (sound-play "generic-beep")
             )
           )
         )
        ((and (cpad-hold? 0 r1) (= (-> this current-index) (-> this target-index)))
         (let ((f0-7 (+ 1.0 (-> this target-index))))
           (set! (-> this target-index) (- f0-7 (* (the float (the int (/ f0-7 f30-0))) f30-0)))
           )
         (set! f28-0 182.04445)
         (set! gp-0 #t)
         )
        ((and (cpad-hold? 0 l1) (= (-> this current-index) (-> this target-index)))
         (let ((f0-12 (+ -1.0 f30-0 (-> this target-index))))
           (set! (-> this target-index) (- f0-12 (* (the float (the int (/ f0-12 f30-0))) f30-0)))
           )
         (set! f28-0 -182.04445)
         (set! gp-0 #t)
         )
        )
      (let* ((f26-0 (/ 65536.0 f30-0))
             (f0-17 (* 3.0 (seconds-per-frame) f26-0))
             (f1-19 (+ (* (-> this current-index) f26-0) f28-0))
             (f2-1 (* (-> this target-index) f26-0))
             (f0-19 (+ 65536.0 (deg-seek f1-19 f2-1 f0-17)))
             )
        (set! (-> this current-index) (/ (- f0-19 (* (the float (the int (/ f0-19 65536.0))) 65536.0)) f26-0))
        )
      )
    (when (< (fabs (- (-> this current-index) (-> this target-index))) 0.01)
      (let ((f0-25 (-> this target-index)))
        (set! (-> this current-index) (- f0-25 (* (the float (the int (/ f0-25 f30-0))) f30-0)))
        )
      )
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons up l-analog-up))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons up l-analog-up))
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons down l-analog-down))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons down l-analog-down))
    (if gp-0
        (sound-play "score-slide")
        )
    )
  0
  )

(defmethod respond-progress ((this menu-qr-option) (arg0 progress) (arg1 symbol))
  (let ((s5-0 (&-> arg0 yes-no-choice)))
    (cond
      (arg1
        (cond
          ((and (cpad-pressed? 0 left l-analog-left) (not (-> s5-0 0)))
           (sound-play "generic-beep")
           (set! (-> s5-0 0) (the-as basic #t))
           )
          ((and (cpad-pressed? 0 right l-analog-right) (-> s5-0 0))
           (sound-play "generic-beep")
           (set! (-> s5-0 0) #f)
           )
          ((and (cpad-pressed? 0 confirm) (-> s5-0 0))
           (case (-> this name)
             (((text-id progress-restart-mission))
              (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
              (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
              (restart-mission)
              (set-next-state arg0 'go-away 0)
              )
             (((text-id progress-quit-game))
              (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons confirm))
              (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons confirm))
              (initialize! *game-info* 'game (the-as game-save #f) "title-restart" (the-as resetter-spec #f))
              )
             )
           )
          )
        )
      (else
        (set! (-> s5-0 0) #f)
        )
      )
    )
  0
  )

(define *last-powerup-collect-amount* 0)

;; WARN: Return type mismatch (pointer process) vs none.
(defun spawn-secret-notify-message ((arg0 int))
  (process-spawn-function
    process
    (lambda :behavior process
      ((arg0 int))
      (suspend-for (seconds 2.5)
        )
      (while (or (not (handle-command-list *gui-control* (gui-channel alert) (the-as gui-connection #f)))
                 (= (status-of-level-and-borrows *level* 'title #f) 'active)
                 )
        (suspend)
        )
      (talker-spawn-func (-> *talker-speech* arg0) *entity-pool* (target-pos 0) (the-as region #f))
      (none)
      )
    arg0
    :to *entity-pool*
    )
  (none)
  )

(defun menu-secrets-notify-task-node-close ((arg0 game-task-node))
  (local-vars (v1-3 symbol))
  (set! v1-3
        (and (not (logtest? (-> *game-info* secrets) (game-secrets hero-mode)))
             (begin
               (dotimes (v1-4 (-> *menu-secrets-array* length))
                 (let ((a1-2 (-> *menu-secrets-array* v1-4)))
                   (when (and (= (-> *game-info* sub-task-list (-> a1-2 avail-after)) arg0)
                              (= (logand (-> *game-info* purchase-secrets) (-> a1-2 required-secrets)) (-> a1-2 required-secrets))
                              (not (logtest? (-> a1-2 flags) (secret-item-option-flags sf3)))
                              )
                     (set! v1-3 #t)
                     (goto cfg-14)
                     )
                   )
                 )
               #f
               )
             )
        )
  (label cfg-14)
  (when v1-3
    (set! *last-powerup-collect-amount* (the int (-> *game-info* skill-total)))
    (spawn-secret-notify-message 136)
    )
  0
  (none)
  )

(defun menu-secrets-notify-powerup-collect ()
  (when (>= (-> *game-info* skill-total) 600.0)
    (spawn-secret-notify-message 138)
    (return 0)
    )
  (let ((gp-0 #f)
        (s5-0 #f)
        )
    (dotimes (s4-0 (-> *menu-secrets-array* length))
      (let ((s3-0 (-> *menu-secrets-array* s4-0)))
        (when (zero? (secret-item-option-method-12 s3-0))
          (cond
            ((and (>= (the int (-> *game-info* skill)) (-> s3-0 cost))
                  (< (the int (-> *game-info* skill-high-watermark)) (-> s3-0 cost))
                  (>= (the int (-> *game-info* skill-total)) (+ *last-powerup-collect-amount* 3))
                  )
             (set! s5-0 #t)
             (set! gp-0 #t)
             )
            ((< (-> s3-0 cost) (the int (-> *game-info* skill)))
             (set! gp-0 #t)
             )
            )
          )
        )
      )
    (cond
      (s5-0
        (spawn-secret-notify-message 135)
        (set! *last-powerup-collect-amount* (the int (-> *game-info* skill-total)))
        )
      (gp-0
        (let ((v1-31 (if (< (-> *game-info* skill-total) 25.0)
                         10
                         25
                         )
                     )
              )
          (when (>= (the int (-> *game-info* skill-total)) (+ *last-powerup-collect-amount* v1-31))
            (set! *last-powerup-collect-amount* (the int (-> *game-info* skill-total)))
            (spawn-secret-notify-message 137)
            )
          )
        )
      )
    )
  0
  )
