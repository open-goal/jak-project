;;-*-Lisp-*-
(in-package goal)

;; name: ragdoll.gc
;; name in dgo: ragdoll
;; dgos: GAME

;; DECOMP BEGINS

(defmethod ragdoll-method-18 ((this ragdoll))
  (when *debug-segment*
    (let ((s5-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-7 'ragdoll-setup)
          (s4-0 *color-white*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s3-0 (-> s5-0 data (-> s5-0 count))))
          (let ((s2-0 (-> s5-0 base-time)))
            (set! (-> s3-0 name) v1-7)
            (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
            )
          (set! (-> s3-0 depth) (the-as uint (-> s5-0 depth)))
          (set! (-> s3-0 color) s4-0)
          (set! (-> s5-0 segment (-> s5-0 depth)) s3-0)
          )
        (set! (-> s5-0 count) (min 1023 (+ (-> s5-0 count) 1)))
        (+! (-> s5-0 depth) 1)
        (set! (-> s5-0 max-depth) (max (-> s5-0 max-depth) (-> s5-0 depth)))
        )
      )
    0
    )
  (vector-seek-3d-smooth! (-> this gravity) (-> this gravity-target) 0.05 0.1)
  (quaternion*!
    (the-as quaternion (-> this ragdoll-joints))
    (-> this rotate-vel)
    (the-as quaternion (-> this ragdoll-joints))
    )
  (quaternion-normalize! (the-as quaternion (-> this ragdoll-joints)))
  (set! (-> this stable-joints) 0)
  (when (logtest? (-> this ragdoll-flags) (ragdoll-flag rf0))
    (let ((s4-1 (new 'stack-no-clear 'collide-query))
          (s5-1 (new 'stack-no-clear 'bounding-box))
          )
      (set! (-> s5-1 min quad) (-> this ragdoll-joints 0 position quad))
      (set! (-> s5-1 max quad) (-> s5-1 min quad))
      (dotimes (v1-25 (the-as int (-> this num-joints)))
        (let ((a2-2 (-> this ragdoll-joints v1-25))
              (a0-21 (new 'stack-no-clear 'vector))
              )
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set-vector!
              a1-4
              (+ 2048.0 (-> a2-2 coll-rad))
              (+ 2048.0 (-> a2-2 coll-rad))
              (+ 2048.0 (-> a2-2 coll-rad))
              1.0
              )
            (+! (-> a1-4 x) (fabs (-> a2-2 velocity x)))
            (+! (-> a1-4 y) (fabs (-> a2-2 velocity y)))
            (+! (-> a1-4 z) (fabs (-> a2-2 velocity z)))
            (vector+! a0-21 (-> a2-2 position) a1-4)
            (set! (-> s5-1 max x) (fmax (-> a0-21 x) (-> s5-1 max x)))
            (set! (-> s5-1 max y) (fmax (-> a0-21 y) (-> s5-1 max y)))
            (set! (-> s5-1 max z) (fmax (-> a0-21 z) (-> s5-1 max z)))
            (vector-! a0-21 (-> a2-2 position) a1-4)
            )
          (set! (-> s5-1 min x) (fmin (-> a0-21 x) (-> s5-1 min x)))
          (set! (-> s5-1 min y) (fmin (-> a0-21 y) (-> s5-1 min y)))
          (set! (-> s5-1 min z) (fmin (-> a0-21 z) (-> s5-1 min z)))
          )
        )
      (set! (-> s4-1 collide-with) (the-as collide-spec (-> this bg-collide-with)))
      (set! (-> s4-1 ignore-process0) #f)
      (set! (-> s4-1 ignore-process1) #f)
      (set! (-> s4-1 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> s4-1 action-mask) (collide-action solid))
      (mem-copy! (the-as pointer (-> s4-1 bbox)) (the-as pointer s5-1) 32)
      (fill-using-bounding-box *collide-cache* s4-1)
      (when (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf11)))
        (let ((s4-2 (new 'stack-no-clear 'inline-array 'water-sphere 2)))
          (dotimes (s3-1 2)
            ((method-of-type water-sphere new) (the-as symbol (-> s4-2 s3-1)) water-sphere)
            )
          (get-bounding-sphere s5-1 (the-as vector (-> s4-2 0)))
          (set! (-> s4-2 0 flags) (water-flag))
          (set! (-> s4-2 1 sphere quad) (-> s4-2 0 sphere quad))
          (set! (-> s4-2 1 flags) (water-flag))
          (find-water-with-spheres s4-2 2 (-> this water-info))
          )
        )
      )
    )
  (when *debug-segment*
    (let ((gp-1 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-55 (+ (-> gp-1 depth) -1))
               (s5-2 (-> gp-1 segment v1-55))
               (s4-3 (-> gp-1 base-time))
               )
          (when (>= v1-55 0)
            (set! (-> s5-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-1 depth) -1)
            )
          )
        )
      )
    0
    )
  0
  (none)
  )

(defmethod ragdoll-method-19 ((this ragdoll) (arg0 vector) (arg1 int) (arg2 object) (arg3 matrix))
  (local-vars (v1-22 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (vector-float*! arg0 (-> this gravity) (* 122.88 (-> pp clock time-adjust-ratio)))
      (if (logtest? (-> this ragdoll-joints arg1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
          (vector-float*! arg0 arg0 0.15)
          )
      (cond
        ((logtest? (-> this ragdoll-joints arg1 ragdoll-joint-flags) (ragdoll-joint-flag rjf0))
         (vector+float*!
           arg0
           arg0
           (the-as vector (+ (the-as uint (-> this ragdoll-joints 0 bounce)) (* 192 arg1)))
           0.5
           )
         (vector+float*!
           arg0
           arg0
           (the-as vector (+ (the-as uint (-> this ragdoll-joints 0 velocity)) (* 192 arg1)))
           0.7
           )
         )
        (else
          (vector+float*!
            arg0
            arg0
            (the-as vector (+ (the-as uint (-> this ragdoll-joints 0 velocity)) (* 192 arg1)))
            1.0
            )
          )
        )
      (.lvf vf1 (&-> arg0 quad))
      (.add.w.vf vf2 vf0 vf0 :mask #b1)
      (.mul.vf vf1 vf1 vf1)
      (.mul.x.vf acc vf2 vf1 :mask #b1)
      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
      (.mov v1-22 vf1)
      (let ((f0-6 v1-22)
            (f1-1 16384.0)
            )
        (if (and (zero? arg1)
                 (not (logtest? (-> this ragdoll-joints arg1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2)))
                 )
            (set! f1-1 24576.0)
            )
        (let ((f2-0 f1-1))
          (if (< (* f2-0 f2-0) f0-6)
              (vector-float*! arg0 arg0 (/ f1-1 (sqrtf f0-6)))
              )
          )
        )
      (when (nonzero? (-> this rotate-adj-count))
        (quaternion-slerp! (-> this rotate-vel) (-> this rotate-vel) (-> this rotate-adj) 0.5)
        (quaternion-identity! (-> this rotate-adj))
        (set! (-> this rotate-adj-count) 0)
        0
        )
      (if (< (-> this rotate-vel w) 0.0)
          (quaternion-negate! (-> this rotate-vel) (-> this rotate-vel))
          )
      (when (< (-> this rotate-vel w) (cos 7281.778))
        (let ((a1-4 (vector-normalize! (the-as vector (-> this rotate-vel)) 1.0)))
          (quaternion-vector-angle! (-> this rotate-vel) a1-4 7281.778)
          )
        )
      0
      (none)
      )
    )
  )

(defmethod reset-vec! ((this ragdoll) (arg0 vector))
  (vector-reset! arg0)
  0
  (none)
  )

(defmethod ragdoll-method-21 ((this ragdoll) (arg0 vector) (arg1 vector) (arg2 float))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-! gp-0 arg0 arg1)
    (vector-normalize! gp-0 arg2)
    (vector+! arg0 gp-0 arg1)
    )
  )

(defmethod get-max-angle-for-joint-idx ((this ragdoll) (idx int))
  (-> this ragdoll-joints idx max-angle)
  )

;; WARN: Function (method 23 ragdoll) has a return type of none, but the expression builder found a return statement.
(defmethod ragdoll-method-23 ((this ragdoll) (arg0 vector) (arg1 vector) (arg2 float) (arg3 symbol))
  (with-pp
    (cond
      (arg3
        (logclear! (-> this ragdoll-flags) (ragdoll-flag rf2))
        (set! (-> this allow-destabilize) (the-as uint (+ (current-time) (seconds 0.1))))
        )
      ((< (- (current-time) (the-as int (-> this allow-destabilize))) 0)
       (return #f)
       )
      )
    (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> this ragdoll-joints 0 position) arg0))
          (a0-4 (new 'stack-no-clear 'vector))
          )
      0.0
      (set! (-> a0-4 quad) (-> s5-1 quad))
      (let ((f30-0 (vector-normalize-ret-len! a0-4 1.0)))
        (if (< f30-0 0.1)
            (return #f)
            )
        (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) arg1 (-> this ragdoll-joints 0 velocity)))
              (s1-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> s1-1 quad) (-> s3-1 quad))
          (let ((f28-1 (* arg2 (vector-normalize-ret-len! s1-1 1.0) (/ 1.0 (-> pp clock time-adjust-ratio))))
                (a0-7 (vector+float*! (new 'stack-no-clear 'vector) arg0 s1-1 (vector-dot s5-1 s1-1)))
                )
            0.0
            (let* ((f1-2 (/ (vector-vector-distance a0-7 (-> this ragdoll-joints 0 position)) f30-0))
                   (f26-0 (fmax 0.0 (+ -0.01 f1-2)))
                   )
              (when (< 0.0 f26-0)
                (let ((s4-1 (new 'stack-no-clear 'vector)))
                  0.0
                  (let ((s2-1 (new 'stack-no-clear 'quaternion)))
                    (vector-cross! s4-1 s3-1 s5-1)
                    (vector-normalize! s4-1 1.0)
                    (let* ((f0-13 (* 10430.379 (/ f28-1 f30-0) f26-0))
                           (f0-14 (fmin 9102.223 f0-13))
                           )
                      (quaternion-vector-angle! s2-1 s4-1 f0-14)
                      )
                    (quaternion-normalize! (quaternion*! (-> this rotate-adj) s2-1 (-> this rotate-adj)))
                    )
                  )
                (+! (-> this rotate-adj-count) 1)
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod ragdoll-method-24 ((this ragdoll) (arg0 vector) (arg1 int))
  (local-vars (v1-85 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (when *debug-segment*
      (let ((s3-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-7 'ragdoll-collision)
            (s2-0 *color-white*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s1-0 (-> s3-0 data (-> s3-0 count))))
            (let ((s0-0 (-> s3-0 base-time)))
              (set! (-> s1-0 name) v1-7)
              (set! (-> s1-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-0))))
              )
            (set! (-> s1-0 depth) (the-as uint (-> s3-0 depth)))
            (set! (-> s1-0 color) s2-0)
            (set! (-> s3-0 segment (-> s3-0 depth)) s1-0)
            )
          (set! (-> s3-0 count) (min 1023 (+ (-> s3-0 count) 1)))
          (+! (-> s3-0 depth) 1)
          (set! (-> s3-0 max-depth) (max (-> s3-0 max-depth) (-> s3-0 depth)))
          )
        )
      0
      )
    (let ((s4-1 (-> this ragdoll-joints arg1)))
      (when (and (logtest? (-> this ragdoll-flags) (ragdoll-flag rf0)) (!= (-> s4-1 coll-rad) 0.0))
        (when (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
          (vector-matrix*! arg0 arg0 (-> this mirror))
          (vector-matrix*! (-> s4-1 position) (-> s4-1 position) (-> this mirror))
          )
        (let ((s2-1 (new 'stack-no-clear 'collide-query))
              (s3-2 (vector-! (new 'stack-no-clear 'vector) arg0 (-> s4-1 position)))
              (s1-1 0)
              )
          (logclear! (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf1 rjf3))
          (if (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf0))
              (logior! (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf1))
              )
          (if (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
              (logior! (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf3))
              )
          (logclear! (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf0 rjf2))
          (set! (-> s4-1 original-speed) 0.0)
          (set! (-> arg0 quad) (-> s4-1 position quad))
          (until (or (< 6 s1-1) (begin
                                  (.lvf vf1 (&-> s3-2 quad))
                                  (.add.w.vf vf2 vf0 vf0 :mask #b1)
                                  (.mul.vf vf1 vf1 vf1)
                                  (.mul.x.vf acc vf2 vf1 :mask #b1)
                                  (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                                  (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                                  (.mov v1-85 vf1)
                                  (let ((f0-13 v1-85)
                                        (f1-4 409.6)
                                        )
                                    (< f0-13 (* f1-4 f1-4))
                                    )
                                  )
                     )
            (+! s1-1 1)
            (set! (-> s2-1 start-pos quad) (-> arg0 quad))
            (set! (-> s2-1 move-dist quad) (-> s3-2 quad))
            (let ((v1-49 s2-1))
              (set! (-> v1-49 radius) (-> s4-1 coll-rad))
              (set! (-> v1-49 collide-with) (the-as collide-spec (-> this bg-collide-with)))
              (set! (-> v1-49 ignore-process0) #f)
              (set! (-> v1-49 ignore-process1) #f)
              (set! (-> v1-49 ignore-pat)
                    (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                    )
              (set! (-> v1-49 action-mask) (collide-action solid))
              )
            (set! (-> s2-1 best-other-prim) #f)
            (let ((f30-0 (probe-using-line-sphere *collide-cache* s2-1)))
              (cond
                ((>= f30-0 0.0)
                 (cond
                   ((logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf0))
                    )
                   ((logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf1))
                    (set! (-> s4-1 original-speed) (vector-length s3-2))
                    (ragdoll-method-23 this (-> s4-1 position) *zero-vector* 1.0 #f)
                    )
                   (else
                     (set! (-> s4-1 original-speed) (vector-length s3-2))
                     (ragdoll-method-23 this (-> s4-1 position) *zero-vector* 1.0 #f)
                     )
                   )
                 (set! (-> s4-1 ground-pat) (-> s2-1 best-other-tri pat))
                 (let ((f0-7 (fmin 1.0 f30-0)))
                   (vector+float*! arg0 arg0 s3-2 f0-7)
                   (vector-float*! s3-2 s3-2 (- 1.0 f0-7))
                   )
                 (let ((f0-10 (vector-dot s3-2 (-> s2-1 best-other-tri normal))))
                   (vector--float*! s3-2 s3-2 (-> s2-1 best-other-tri normal) (* 1.2 f0-10))
                   )
                 (logior! (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf0))
                 (vector-float*! (-> s4-1 bounce) (-> s2-1 best-other-tri normal) (-> s4-1 original-speed))
                 )
                (else
                  (vector+! arg0 arg0 s3-2)
                  (goto cfg-34)
                  )
                )
              )
            )
          )
        (label cfg-34)
        (if (and (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf11)))
                 (logtest? (water-flag touch-water) (-> this water-info flags))
                 (< (- (-> arg0 y) (-> s4-1 coll-rad)) (-> this water-info base-height))
                 )
            (logior! (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
            )
        (when (and (nonzero? (-> s4-1 hit-sound))
                   (or (and (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf0))
                            (not (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf1 rjf2)))
                            )
                       (and (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
                            (not (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf3)))
                            )
                       )
                   )
          (let ((v1-107 (the int (lerp-scale 0.0 1024.0 (-> s4-1 original-speed) 409.6 2867.2)))
                (s3-3 (new 'static 'sound-spec))
                )
            (when (nonzero? v1-107)
              (set! (-> s3-3 sound-name) (-> s4-1 hit-sound))
              (set! (-> s3-3 volume) v1-107)
              (set! (-> s3-3 reg 0) (the-as uint 0))
              (if (logtest? (-> s4-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
                  (set! (-> s3-3 reg 0) (the-as uint 127))
                  (set! (-> s3-3 reg 0) (the-as uint (-> s4-1 ground-pat material)))
                  )
              (sound-play-by-spec s3-3 (new-sound-id) (-> s4-1 position))
              )
            )
          )
        (when (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
          (vector-matrix*! arg0 arg0 (-> this mirror))
          (vector-matrix*! (-> s4-1 position) (-> s4-1 position) (-> this mirror))
          )
        )
      )
    (when *debug-segment*
      (let ((gp-1 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-129 (+ (-> gp-1 depth) -1))
                 (s5-1 (-> gp-1 segment v1-129))
                 (s4-2 (-> gp-1 base-time))
                 )
            (when (>= v1-129 0)
              (set! (-> s5-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-2))))
              (+! (-> gp-1 depth) -1)
              )
            )
          )
        )
      0
      )
    0
    (none)
    )
  )

(defmethod enable-ragdoll! ((this ragdoll) (proc process-drawable))
  (let ((s4-0 (-> this ragdoll-joints)))
    (logior! (-> proc skel status) (joint-control-status no-joint-callbacks))
    (do-joint-math (-> proc draw) (-> proc node-list) (-> proc skel))
    (logclear! (-> proc skel status) (joint-control-status no-joint-callbacks))
    (let ((s2-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> proc node-list data (-> s4-0 0 joint-index))))
          (s3-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s3-0 quad) (-> s4-0 0 position quad))
      (if (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
          (vector-matrix*! s3-0 s3-0 (-> this mirror))
          )
      (vector-! s2-0 s3-0 s2-0)
      (vector+! (-> proc root trans) s3-0 s2-0)
      )
    )
  0
  (none)
  )

(defun ragdoll-matrix-interp ((arg0 matrix) (arg1 matrix) (arg2 matrix) (arg3 float))
  (local-vars (sv-208 matrix))
  (set! sv-208 arg1)
  (let ((s5-0 arg2)
        (s4-0 arg3)
        (s1-0 (new 'stack-no-clear 'matrix))
        )
    (dotimes (v1-0 3)
      (set! (-> s1-0 quad v1-0) (the-as uint128 0))
      )
    0.0
    0.0
    0.0
    (let ((s3-0 (new-stack-vector0)))
      0.0
      (let ((s2-0 (new 'stack-no-clear 'matrix)))
        (set! (-> s2-0 rvec quad) (the-as uint128 0))
        (set! (-> s2-0 uvec quad) (the-as uint128 0))
        (set! (-> s2-0 fvec quad) (the-as uint128 0))
        (set! (-> s2-0 trans quad) (the-as uint128 0))
        (let ((s0-0 (new 'stack-no-clear 'matrix)))
          (set! (-> s0-0 rvec quad) (the-as uint128 0))
          (set! (-> s0-0 uvec quad) (the-as uint128 0))
          (set! (-> s0-0 fvec quad) (the-as uint128 0))
          (set! (-> s0-0 trans quad) (the-as uint128 0))
          (vector-normalize-copy! (-> s0-0 rvec) (-> sv-208 rvec) 1.0)
          (vector-normalize-copy! (-> s0-0 uvec) (-> sv-208 uvec) 1.0)
          (vector-normalize-copy! (-> s0-0 fvec) (-> sv-208 fvec) 1.0)
          (set! (-> s0-0 rvec w) 1.0)
          (set! (-> s0-0 uvec w) 1.0)
          (set! (-> s0-0 fvec w) 1.0)
          (set! (-> s0-0 trans w) 1.0)
          (vector-! (-> s1-0 rvec) (-> s0-0 rvec) (-> s5-0 rvec))
          (vector-! (-> s1-0 uvec) (-> s0-0 uvec) (-> s5-0 uvec))
          (vector-! (-> s1-0 fvec) (-> s0-0 fvec) (-> s5-0 fvec))
          (let ((f0-8 (vector-length (-> s1-0 rvec)))
                (f1-0 (vector-length (-> s1-0 uvec)))
                (f2-0 (vector-length (-> s1-0 fvec)))
                )
            (cond
              ((and (< f0-8 f1-0) (< f0-8 f2-0))
               (vector-cross! s3-0 (-> s1-0 uvec) (-> s1-0 fvec))
               )
              ((and (< f1-0 f0-8) (< f1-0 f2-0))
               (vector-cross! s3-0 (-> s1-0 rvec) (-> s1-0 fvec))
               )
              (else
                (vector-cross! s3-0 (-> s1-0 rvec) (-> s1-0 uvec))
                )
              )
            )
          (vector-normalize! s3-0 1.0)
          (let ((f0-11 (fabs (vector-dot (-> s0-0 rvec) s3-0)))
                (f1-3 (fabs (vector-dot (-> s0-0 uvec) s3-0)))
                (f2-3 (fabs (vector-dot (-> s0-0 fvec) s3-0)))
                )
            (cond
              ((and (< f0-11 f1-3) (< f0-11 f2-3))
               (vector-flatten! (-> s1-0 rvec) (-> s0-0 rvec) s3-0)
               (vector-flatten! (-> s1-0 uvec) (-> s5-0 rvec) s3-0)
               )
              ((< f1-3 f2-3)
               (vector-flatten! (-> s1-0 rvec) (-> s0-0 uvec) s3-0)
               (vector-flatten! (-> s1-0 uvec) (-> s5-0 uvec) s3-0)
               )
              (else
                (vector-flatten! (-> s1-0 rvec) (-> s0-0 fvec) s3-0)
                (vector-flatten! (-> s1-0 uvec) (-> s5-0 fvec) s3-0)
                )
              )
            )
          )
        (vector-normalize! (-> s1-0 rvec) 1.0)
        (vector-normalize! (-> s1-0 uvec) 1.0)
        (vector-cross! (-> s1-0 fvec) (-> s1-0 rvec) (-> s1-0 uvec))
        (if (< (vector-dot (-> s1-0 fvec) s3-0) 0.0)
            (vector-negate! s3-0 s3-0)
            )
        (let ((f30-0 (* (acos (vector-dot (-> s1-0 rvec) (-> s1-0 uvec))) (- 1.0 s4-0))))
          (matrix-axis-sin-cos! s2-0 s3-0 (sin f30-0) (cos f30-0))
          )
        (matrix*! arg0 s5-0 s2-0)
        )
      )
    )
  )

(defun ragdoll-joint-callback ((arg0 cspace) (arg1 transformq) (arg2 process-drawable) (arg3 ragdoll-proc))
  (local-vars (sv-240 int) (sv-256 quaternion) (sv-272 vector) (sv-288 matrix))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (when *debug-segment*
      (let ((s2-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
            (v1-7 'ragdoll-callback)
            (s1-0 *color-white*)
            )
        (when (and *dproc* *debug-segment*)
          (let ((s0-0 (-> s2-0 data (-> s2-0 count))))
            (set! sv-240 (-> s2-0 base-time))
            (set! (-> s0-0 name) v1-7)
            (set! (-> s0-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint sv-240))))
            (set! (-> s0-0 depth) (the-as uint (-> s2-0 depth)))
            (set! (-> s0-0 color) s1-0)
            (set! (-> s2-0 segment (-> s2-0 depth)) s0-0)
            )
          (set! (-> s2-0 count) (min 1023 (+ (-> s2-0 count) 1)))
          (+! (-> s2-0 depth) 1)
          (set! (-> s2-0 max-depth) (max (-> s2-0 max-depth) (-> s2-0 depth)))
          )
        )
      0
      )
    (when arg3
      (let ((s3-1 (-> arg3 ragdoll)))
        (when (and s3-1
                   (and (< 0.0 (-> s3-1 flex-blend)) (!= (-> s3-1 ragdoll-joint-remap (+ (-> arg0 joint number) 1)) 255))
                   )
          (let ((s1-1 (-> s3-1 ragdoll-joints (-> s3-1 ragdoll-joint-remap (+ (-> arg0 joint number) 1)))))
            (when s1-1
              (if (and (-> s1-1 old-param0) (!= (-> s1-1 old-param0) ragdoll-other-joint-callback))
                  ((the-as (function cspace transformq none) (-> s1-1 old-param0)) arg0 arg1)
                  (cspace<-parented-transformq-joint! arg0 arg1)
                  )
              (let ((s2-1 (new 'stack-no-clear 'matrix)))
                (set! sv-256
                      (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) (-> s1-1 geo-tform) (-> s1-1 geo-tform w))
                      )
                (quaternion-normalize! (quaternion*! sv-256 (-> s1-1 quat) sv-256))
                (quaternion->matrix s2-1 sv-256)
                (when (logtest? (-> s3-1 ragdoll-flags) (ragdoll-flag rf10))
                  (let ((v1-40 (&+ s1-1 188)))
                    (when (and (!= v1-40 (-> s3-1 ragdoll-joints (-> s3-1 num-joints))) (= (-> v1-40 parent-joint) -1))
                      (let ((s0-3 (vector-! (new 'stack-no-clear 'vector) (-> v1-40 position) (-> s1-1 position))))
                        (set! sv-272 (new 'stack-no-clear 'vector))
                        (set! sv-288 (new 'stack-no-clear 'matrix))
                        (vector-flatten! sv-272 s0-3 (-> s2-1 rvec))
                        (vector-normalize! sv-272 1.0)
                        (matrix-from-two-vectors! sv-288 (-> s2-1 uvec) sv-272)
                        (matrix*! s2-1 s2-1 sv-288)
                        (vector-flatten! sv-272 s0-3 (-> s2-1 fvec))
                        )
                      (vector-normalize! sv-272 1.0)
                      (matrix-from-two-vectors! sv-288 (-> s2-1 uvec) sv-272)
                      (matrix*! s2-1 s2-1 sv-288)
                      )
                    )
                  )
                (set! (-> s2-1 trans quad) (-> s1-1 position quad))
                (set! (-> s2-1 trans w) 1.0)
                (if (logtest? (-> s3-1 ragdoll-flags) (ragdoll-flag mirror))
                    (matrix*! s2-1 s2-1 (-> s3-1 mirror))
                    )
                (cond
                  ((>= (-> s3-1 flex-blend) 1.0)
                   (let ((a2-10 (-> arg0 bone transform))
                         (v1-51 (-> s2-1 rvec quad))
                         (a0-45 (-> s2-1 uvec quad))
                         (a1-20 (-> s2-1 fvec quad))
                         (a3-1 (-> s2-1 trans quad))
                         )
                     (set! (-> a2-10 rvec quad) v1-51)
                     (set! (-> a2-10 uvec quad) a0-45)
                     (set! (-> a2-10 fvec quad) a1-20)
                     (set! (-> a2-10 trans quad) a3-1)
                     )
                   )
                  (else
                    (let ((s1-3 (vector-lerp!
                                  (new 'stack-no-clear 'vector)
                                  (matrix->trans (-> arg0 bone transform) (new 'stack-no-clear 'vector))
                                  (-> s2-1 trans)
                                  (-> s3-1 flex-blend)
                                  )
                                )
                          )
                      (ragdoll-matrix-interp (-> arg0 bone transform) (-> arg0 bone transform) s2-1 (-> s3-1 flex-blend))
                      (set! (-> arg0 bone transform trans quad) (-> s1-3 quad))
                      )
                    (set! (-> arg0 bone transform trans w) 1.0)
                    )
                  )
                )
              (let ((v1-60 (new 'stack-no-clear 'vector)))
                (let ((a0-50 v1-60))
                  (let ((a1-24 (-> s3-1 scale))
                        (a2-14 (-> arg2 root scale))
                        )
                    (.lvf vf4 (&-> a1-24 quad))
                    (.lvf vf5 (&-> a2-14 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.vf vf6 vf4 vf5 :mask #b111)
                  (.svf (&-> a0-50 quad) vf6)
                  )
                (let ((a1-25 v1-60))
                  (let ((a0-51 v1-60)
                        (a2-15 (-> arg1 scale))
                        )
                    (.lvf vf4 (&-> a0-51 quad))
                    (.lvf vf5 (&-> a2-15 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.vf vf6 vf4 vf5 :mask #b111)
                  (.svf (&-> a1-25 quad) vf6)
                  )
                (let ((a0-53 (-> arg0 bone transform)))
                  (let ((a1-27 (-> arg0 bone transform))
                        (a2-16 v1-60)
                        )
                    (.lvf vf4 (&-> a1-27 rvec quad))
                    (.lvf vf5 (&-> a2-16 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.vf vf6 vf4 vf5 :mask #b111)
                  (.svf (&-> a0-53 rvec quad) vf6)
                  )
                (let ((a0-55 (-> arg0 bone transform uvec)))
                  (let ((a1-29 (-> arg0 bone transform uvec))
                        (a2-17 v1-60)
                        )
                    (.lvf vf4 (&-> a1-29 quad))
                    (.lvf vf5 (&-> a2-17 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.vf vf6 vf4 vf5 :mask #b111)
                  (.svf (&-> a0-55 quad) vf6)
                  )
                (let ((a0-57 (-> arg0 bone transform fvec)))
                  (.lvf vf4 (&-> (-> arg0 bone transform fvec) quad))
                  (.lvf vf5 (&-> v1-60 quad))
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.vf vf6 vf4 vf5 :mask #b111)
                  (.svf (&-> a0-57 quad) vf6)
                  )
                )
              (set! (-> arg0 bone transform rvec w) 0.0)
              (set! (-> arg0 bone transform uvec w) 0.0)
              (set! (-> arg0 bone transform fvec w) 0.0)
              )
            )
          )
        )
      )
    (when *debug-segment*
      (let ((gp-1 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
        (when (and *dproc* *debug-segment*)
          (let* ((v1-75 (+ (-> gp-1 depth) -1))
                 (s5-1 (-> gp-1 segment v1-75))
                 (s4-1 (-> gp-1 base-time))
                 )
            (when (>= v1-75 0)
              (set! (-> s5-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
              (+! (-> gp-1 depth) -1)
              )
            )
          )
        )
      0
      )
    (none)
    )
  )

(defbehavior ragdoll-other-joint-callback ragdoll-proc ((arg0 cspace) (arg1 transformq))
  (local-vars (a3-0 process-tree))
  (let ((gp-0 ragdoll-joint-callback)
        (s5-0 arg0)
        (s4-0 arg1)
        (s3-0 self)
        )
    (let ((s2-0 (-> self child)))
      (while s2-0
        (let ((s1-0 (ppointer->process s2-0)))
          (when (type? s1-0 ragdoll-proc)
            (set! a3-0 s1-0)
            (goto cfg-9)
            )
          )
        (set! s2-0 (-> s2-0 0 brother))
        )
      )
    (set! a3-0 (the-as process-tree #f))
    (label cfg-9)
    (gp-0 s5-0 s4-0 (the-as process-drawable s3-0) (the-as ragdoll-proc a3-0))
    )
  (none)
  )

(defun ragdoll-reflect-matrix ((arg0 matrix) (arg1 vector) (arg2 vector))
  (matrix-identity! arg0)
  (let ((s4-1 (vector-float*! (new 'stack-no-clear 'vector) arg1 -2.0)))
    (vector-float*! (-> arg0 rvec) s4-1 (-> arg1 x))
    (vector-float*! (-> arg0 uvec) s4-1 (-> arg1 y))
    (vector-float*! (-> arg0 fvec) s4-1 (-> arg1 z))
    (+! (-> arg0 rvec x) 1.0)
    (+! (-> arg0 uvec y) 1.0)
    (+! (-> arg0 fvec z) 1.0)
    (set! (-> arg0 rvec w) 0.0)
    (set! (-> arg0 uvec w) 0.0)
    (set! (-> arg0 fvec w) 0.0)
    (vector-negate! s4-1 arg2)
    (vector-matrix*! (-> arg0 trans) s4-1 arg0)
    )
  (vector+! (-> arg0 trans) (-> arg0 trans) arg2)
  )

(defmethod ragdoll-method-9 ((this ragdoll) (arg0 matrix) (arg1 process-drawable))
  (cond
    ((= (-> arg1 node-list data 2 param0) cspace<-parented-matrix-joint-flip-z!)
     (logior! (-> this ragdoll-flags) (ragdoll-flag mirror))
     (let ((s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> arg1 node-list data 2)))
           (a1-5 (vector-normalize-copy!
                   (new 'stack-no-clear 'vector)
                   (the-as vector (-> arg1 node-list data 2 bone transform))
                   1.0
                   )
                 )
           )
       (ragdoll-reflect-matrix arg0 a1-5 s4-0)
       )
     )
    (else
      (logclear! (-> this ragdoll-flags) (ragdoll-flag mirror))
      (matrix-identity! arg0)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch ragdoll-flag vs none.
(defmethod ragdoll-method-10 ((this ragdoll) (arg0 process-drawable) (arg1 symbol) (arg2 vector) (arg3 symbol))
  (local-vars (sv-144 vector))
  (with-pp
    (set! (-> this turn-off-start) 0)
    (logclear! (-> this ragdoll-flags) (ragdoll-flag rf2))
    (logior! (-> arg0 skel status) (joint-control-status force-math))
    (do-joint-math (-> arg0 draw) (-> arg0 node-list) (-> arg0 skel))
    (logclear! (-> arg0 skel status) (joint-control-status force-math))
    (ragdoll-method-9 this (-> this mirror) arg0)
    (cond
      ((and arg1 arg3)
       (logior! (-> this ragdoll-flags) (ragdoll-flag rf5))
       (set-time! (-> this copy-velocity-start))
       (set! (-> this flex-blend) 0.0)
       (dotimes (s4-1 (the-as int (-> this num-joints)))
         (let ((s3-1 (-> this ragdoll-joints s4-1)))
           (new 'stack-no-clear 'vector)
           (vector<-cspace! (-> s3-1 position) (-> arg0 node-list data (-> s3-1 joint-index)))
           (if (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
               (vector-matrix*! (-> s3-1 position) (-> s3-1 position) (-> this mirror))
               )
           )
         )
       )
      ((or (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf5)))
           (!= (current-time) (-> this copy-velocity-start))
           )
       (logior! (-> this ragdoll-flags) (ragdoll-flag rf1 rf7 rf9))
       (set! (-> this flex-blend) 1.0)
       (when arg3
         (quaternion-identity! (-> this rotate-vel))
         (quaternion-identity! (-> this rotate-adj))
         (set! (-> this rotate-adj-count) 0)
         0
         )
       (set! (-> this stable-joints) 0)
       (dotimes (s2-1 (the-as int (-> this num-joints)))
         (let ((s1-0 (-> this ragdoll-joints s2-1))
               (s0-0 (new 'stack-no-clear 'vector))
               )
           (when (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf6)))
             (when *debug-segment*
               (when (= (-> arg0 node-list data (-> s1-0 joint-index) param0) ragdoll-other-joint-callback)
                 (break!)
                 0
                 )
               )
             (set! (-> s1-0 old-param0) (-> arg0 node-list data (-> s1-0 joint-index) param0))
             (let ((a0-19 (-> arg0 node-list data (-> s1-0 joint-index))))
               (set! (-> a0-19 param0) ragdoll-other-joint-callback)
               )
             )
           (set! (-> s1-0 ragdoll-joint-flags) (ragdoll-joint-flag))
           (let ((a1-11 (matrix*!
                          (new 'stack-no-clear 'matrix)
                          (-> arg0 node-list data (-> s1-0 joint-index) bone transform)
                          (-> this mirror)
                          )
                        )
                 )
             (matrix->quaternion (-> s1-0 quat) a1-11)
             )
           (let ((a2-6
                   (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) (-> s1-0 geo-tform) (- (-> s1-0 geo-tform w)))
                   )
                 )
             (quaternion*! (-> s1-0 quat) (-> s1-0 quat) a2-6)
             )
           (quaternion-normalize! (-> s1-0 quat))
           (cond
             ((logtest? (-> this ragdoll-flags) (ragdoll-flag rf5))
              (logclear! (-> this ragdoll-flags) (ragdoll-flag rf5))
              (set! sv-144 (vector<-cspace! (new 'stack-no-clear 'vector) (-> arg0 node-list data (-> s1-0 joint-index))))
              (if (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
                  (vector-matrix*! sv-144 sv-144 (-> this mirror))
                  )
              (vector-! (-> s1-0 velocity) sv-144 (-> s1-0 position))
              (vector-float*! (-> s1-0 velocity) (-> s1-0 velocity) (/ 1.0 (-> pp clock time-adjust-ratio)))
              (set! (-> s1-0 position quad) (-> sv-144 quad))
              )
             (else
               (vector<-cspace! (-> s1-0 position) (-> arg0 node-list data (-> s1-0 joint-index)))
               (if (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
                   (vector-matrix*! (-> s1-0 position) (-> s1-0 position) (-> this mirror))
                   )
               (cond
                 (arg2
                   (vector-float*! (-> s1-0 velocity) arg2 (/ 1.0 (-> pp clock time-adjust-ratio)))
                   )
                 ((not arg3)
                  )
                 (else
                   (vector-reset! (-> s1-0 velocity))
                   )
                 )
               )
             )
           (when arg3
             (cond
               ((>= (-> s1-0 parent-joint) 0)
                (vector<-cspace! s0-0 (-> arg0 node-list data (-> s1-0 parent-joint)))
                )
               ((> s2-1 0)
                (vector<-cspace! s0-0 (-> arg0 node-list data (-> this ragdoll-joints (+ s2-1 -1) joint-index)))
                )
               (else
                 (set! (-> s0-0 quad) (-> arg0 root trans quad))
                 )
               )
             (if (logtest? (-> this ragdoll-flags) (ragdoll-flag mirror))
                 (vector-matrix*! s0-0 s0-0 (-> this mirror))
                 )
             (set! (-> s1-0 joint-length) (vector-vector-distance (-> s1-0 position) s0-0))
             (if (zero? s2-1)
                 (vector-! (-> this root-offset) (-> arg0 root trans) (-> s1-0 position))
                 )
             )
           )
         )
       (logior! (-> this ragdoll-flags) (ragdoll-flag rf6))
       )
      )
    (none)
    )
  )

(defmethod turn-off-for-duration! ((this ragdoll) (arg0 time-frame))
  (set-time! (-> this turn-off-start))
  (set! (-> this turn-off-duration) arg0)
  0
  (none)
  )

(defmethod get-parent-joint ((this ragdoll) (arg0 (inline-array ragdoll-joint)))
  (when (< (-> arg0 0 parent-joint) 0)
    (if (!= arg0 (-> this ragdoll-joints))
        (return (-> arg0 -1))
        )
    (return (the-as ragdoll-joint #f))
    )
  (dotimes (v1-7 (the-as int (-> this num-joints)))
    (if (= (-> this ragdoll-joints v1-7 joint-index) (-> arg0 0 parent-joint))
        (return (-> this ragdoll-joints v1-7))
        )
    )
  (the-as ragdoll-joint #f)
  )

(defmethod ragdoll-method-13 ((this ragdoll) (arg0 ragdoll-edit-info) (arg1 ragdoll-joint) (arg2 matrix) (arg3 matrix))
  (when (and (nonzero? arg0) (let ((v1-1 (-> arg0 skel-visible)))
                               (if (or (zero? v1-1) (= v1-1 4))
                                   #t
                                   )
                               )
             )
    (if (or (not (logtest? (-> *display* real-frame-clock integral-frame-counter) 8))
            (!= (-> arg0 analog-func) 4)
            (not (ragdoll-edit-info-method-10 arg0 this (the-as ragdoll-joint (-> arg1 joint-index))))
            )
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> arg3 trans)
          (-> arg2 trans)
          (new 'static 'rgba :r #xff :g #xff :a #x80)
          #f
          (the-as rgba -1)
          )
        )
    (when (or (not (logtest? (-> *display* real-frame-clock integral-frame-counter) 8))
              (nonzero? (-> arg0 analog-func))
              (not (ragdoll-edit-info-method-10 arg0 this (the-as ragdoll-joint (-> arg1 joint-index))))
              )
      (let ((f30-0 0.25))
        (if (and (zero? (-> arg0 analog-func))
                 (ragdoll-edit-info-method-10 arg0 this (the-as ragdoll-joint (-> arg1 joint-index)))
                 )
            (set! f30-0 0.35)
            )
        (add-debug-matrix #t (bucket-id debug-no-zbuf1) arg3 (* 4096.0 f30-0))
        )
      )
    (when (or (not (logtest? (-> *display* real-frame-clock integral-frame-counter) 8))
              (zero? (-> arg0 analog-func))
              (not (ragdoll-edit-info-method-10 arg0 this (the-as ragdoll-joint (-> arg1 joint-index))))
              )
      (let ((f30-1 0.25))
        (if (and (nonzero? (-> arg0 analog-func))
                 (ragdoll-edit-info-method-10 arg0 this (the-as ragdoll-joint (-> arg1 joint-index)))
                 )
            (set! f30-1 0.35)
            )
        (add-debug-matrix #t (bucket-id debug-no-zbuf1) arg2 (* 4096.0 f30-1))
        )
      )
    )
  (when (and (nonzero? arg0)
             (!= (-> arg0 skel-visible) 2)
             (= arg1 (-> this ragdoll-joints))
             (not (logtest? (-> *display* real-frame-clock integral-frame-counter) 8))
             (= (-> arg0 analog-func) 7)
             )
    (let ((s4-1 (new 'stack-no-clear 'matrix)))
      (matrix-axis-angle! s4-1 (-> this orient-tform) (- (-> this orient-tform w)))
      (matrix*! s4-1 s4-1 arg2)
      (set! (-> s4-1 trans quad) (-> arg2 trans quad))
      (add-debug-matrix #t (bucket-id debug-no-zbuf1) s4-1 (meters 2))
      )
    )
  0
  (none)
  )

(defmethod ragdoll-method-14 ((this ragdoll) (arg0 process-drawable) (arg1 ragdoll-joint) (arg2 object) (arg3 matrix))
  (cond
    ((>= (-> arg1 parent-joint) 0)
     (let ((s2-0 (get-parent-joint this (the-as (inline-array ragdoll-joint) arg1)))
           (s3-0 (new 'stack-no-clear 'matrix))
           )
       (cond
         (s2-0
           (quaternion->matrix arg3 (-> s2-0 quat))
           (matrix-axis-angle! s3-0 (-> arg1 pre-tform) (- (-> arg1 pre-tform w)))
           (matrix*! arg3 s3-0 arg3)
           (set! (-> arg3 trans quad) (-> s2-0 position quad))
           )
         (else
           (matrix-axis-angle! s3-0 (-> arg1 pre-tform) (- (-> arg1 pre-tform w)))
           (matrix*! arg3 s3-0 (-> arg0 node-list data (-> arg1 parent-joint) bone transform))
           (vector<-cspace! (-> arg3 trans) (-> arg0 node-list data (-> arg1 parent-joint)))
           )
         )
       )
     )
    ((> (the-as int arg2) 0)
     (let ((s3-1 (new 'stack-no-clear 'matrix))
           (s5-1 (new 'stack-no-clear 'vector))
           )
       (set! (-> s5-1 quad) (-> arg3 trans quad))
       (matrix-axis-angle! s3-1 (-> arg1 pre-tform) (- (-> arg1 pre-tform w)))
       (matrix*! arg3 s3-1 arg3)
       (set! (-> arg3 trans quad) (-> s5-1 quad))
       )
     )
    (else
      (quaternion->matrix arg3 (-> arg0 root quat))
      (set! (-> arg3 trans quad) (-> arg0 root trans quad))
      )
    )
  0
  (none)
  )

(defmethod ragdoll-method-17 ((this ragdoll) (arg0 process-drawable))
  (logclear! (-> this ragdoll-flags) (ragdoll-flag rf1))
  (when (logtest? (-> this ragdoll-flags) (ragdoll-flag rf6))
    (logclear! (-> this ragdoll-flags) (ragdoll-flag rf6))
    (dotimes (v1-7 (the-as int (-> this num-joints)))
      (let* ((a2-5 (-> this ragdoll-joints v1-7))
             (a3-3 (-> arg0 node-list data (-> a2-5 joint-index)))
             )
        (set! (-> a3-3 param0) (the-as (function cspace transformq none) (-> a2-5 old-param0)))
        )
      )
    )
  0
  (none)
  )

(defmethod ragdoll-method-15 ((this ragdoll) (arg0 process-drawable) (arg1 ragdoll-edit-info))
  (local-vars
    (at-0 int)
    (v1-156 float)
    (f0-14 float)
    (sv-320 vector)
    (sv-336 vector)
    (sv-352 (function vector float vector))
    (sv-368 vector)
    (sv-384 vector)
    (sv-400 vector)
    (sv-416 vector)
    (sv-432 vector)
    (sv-448 vector)
    (sv-464 vector)
    (sv-480 vector)
    (sv-496 vector)
    (sv-512 vector)
    (sv-528 vector)
    (sv-544 vector)
    (sv-560 vector)
    )
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf3 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           )
      (init-vf0-vector)
      (when *debug-segment*
        (let ((s3-0 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-7 'ragdoll-overall)
              (s2-0 *color-white*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s1-0 (-> s3-0 data (-> s3-0 count))))
              (let ((s0-0 (-> s3-0 base-time)))
                (set! (-> s1-0 name) v1-7)
                (set! (-> s1-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s0-0))))
                )
              (set! (-> s1-0 depth) (the-as uint (-> s3-0 depth)))
              (set! (-> s1-0 color) s2-0)
              (set! (-> s3-0 segment (-> s3-0 depth)) s1-0)
              )
            (set! (-> s3-0 count) (min 1023 (+ (-> s3-0 count) 1)))
            (+! (-> s3-0 depth) 1)
            (set! (-> s3-0 max-depth) (max (-> s3-0 max-depth) (-> s3-0 depth)))
            )
          )
        0
        )
      (if (logtest? (-> this ragdoll-flags) (ragdoll-flag rf9))
          (ragdoll-method-9 this (-> this mirror) arg0)
          )
      (if (not arg1)
          (set! arg1 (the-as ragdoll-edit-info 0))
          )
      (if (logtest? (-> this ragdoll-flags) (ragdoll-flag rf5))
          (ragdoll-method-10 this arg0 #f (the-as vector #f) #t)
          )
      (cond
        ((or (zero? (the-as object arg1))
             (and (= (-> arg1 single-step) 1) (cpad-pressed? 0 r2))
             (zero? (-> arg1 single-step))
             )
         (if (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf2)))
             (ragdoll-method-18 this)
             )
         )
        ((and (nonzero? (the-as object arg1)) (nonzero? (-> this turn-off-start)) (= (-> arg1 single-step) 1))
         (+! (-> this turn-off-start) (-> arg1 last-frame-dur))
         )
        )
      (let ((f30-0 1.0))
        (when (nonzero? (-> this turn-off-start))
          (set! f30-0
                (fmax
                  0.0
                  (fmin
                    1.0
                    (parameter-ease-sin-clamp
                      (- 1.0 (/ (the float (- (current-time) (-> this turn-off-start))) (the float (-> this turn-off-duration))))
                      )
                    )
                  )
                )
          (if (= f30-0 0.0)
              (ragdoll-method-17 this arg0)
              )
          )
        (set! (-> this flex-blend) f30-0)
        )
      (when (and (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf2)))
                 (not (logtest? (-> this ragdoll-flags) (ragdoll-flag rf5)))
                 )
        (let ((s3-1 (new 'stack-no-clear 'matrix))
              (s2-1 (new 'stack-no-clear 'matrix))
              )
          (new 'stack-no-clear 'vector)
          (dotimes (s1-1 (the-as int (-> this num-joints)))
            (let ((s0-1 (-> this ragdoll-joints s1-1)))
              (set! sv-560 (new 'stack-no-clear 'vector))
              (let ((v1-74 (-> s0-1 position quad)))
                (set! (-> sv-560 quad) v1-74)
                )
              (if (and (logtest? (-> s0-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
                       (not (logtest? (-> s0-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf3)))
                       )
                  (vector-float*! (-> s0-1 velocity) (-> s0-1 velocity) 0.1)
                  )
              (ragdoll-method-14 this arg0 s0-1 s1-1 s2-1)
              (cond
                ((or (zero? (the-as object arg1))
                     (and (= (-> arg1 single-step) 1) (cpad-pressed? 0 r2))
                     (zero? (-> arg1 single-step))
                     )
                 (when (or (zero? (the-as object arg1)) (-> arg1 gravity))
                   (set! sv-320 (new 'stack-no-clear 'vector))
                   (ragdoll-method-19 this sv-320 s1-1 arg0 s2-1)
                   (let ((v1-93 sv-560))
                     (let ((a0-39 sv-560))
                       (.mov.vf vf6 vf0 :mask #b1000)
                       (.lvf vf4 (&-> a0-39 quad))
                       )
                     (.lvf vf5 (&-> sv-320 quad))
                     (.add.vf vf6 vf4 vf5 :mask #b111)
                     (.svf (&-> v1-93 quad) vf6)
                     )
                   )
                 (when (and (< s1-1 (the-as int (+ (-> this num-joints) -1)))
                            (= (-> this ragdoll-joints (+ s1-1 1) parent-joint) -1)
                            )
                   (set! sv-336 (new 'stack-no-clear 'vector))
                   (reset-vec! this sv-336)
                   (let ((v1-104 sv-560))
                     (let ((a0-45 sv-560))
                       (.mov.vf vf6 vf0 :mask #b1000)
                       (.lvf vf4 (&-> a0-45 quad))
                       )
                     (.lvf vf5 (&-> sv-336 quad))
                     (.add.vf vf6 vf4 vf5 :mask #b111)
                     (.svf (&-> v1-104 quad) vf6)
                     )
                   )
                 (when (or (> s1-1 0) (!= (-> s0-1 parent-joint) -1))
                   (ragdoll-method-21 this sv-560 (-> s2-1 trans) (-> s0-1 joint-length))
                   (set! sv-432 (new 'stack-no-clear 'vector))
                   (let ((v1-110 sv-560)
                         (a0-50 (-> s2-1 trans))
                         )
                     (.lvf vf4 (&-> v1-110 quad))
                     (.lvf vf5 (&-> a0-50 quad))
                     )
                   (.mov.vf vf6 vf0 :mask #b1000)
                   (.sub.vf vf6 vf4 vf5 :mask #b111)
                   (.svf (&-> sv-432 quad) vf6)
                   (let ((f30-2 (vector-normalize-ret-len! sv-432 1.0))
                         (f26-0 (vector-dot sv-432 (-> s2-1 uvec)))
                         (f28-1 (get-max-angle-for-joint-idx this s1-1))
                         )
                     (when (< f26-0 (cos f28-1))
                       (vector--float*! sv-432 sv-432 (-> s2-1 uvec) f26-0)
                       (set! sv-352 vector-normalize!)
                       (set! sv-368 sv-432)
                       (let ((a1-15 (sin f28-1)))
                         (sv-352 sv-368 a1-15)
                         )
                       (set! sv-416 sv-432)
                       (set! sv-384 sv-432)
                       (set! sv-400 (-> s2-1 uvec))
                       (let ((f0-9 (cos f28-1)))
                         (.lvf vf2 (&-> sv-400 quad))
                         (.lvf vf1 (&-> sv-384 quad))
                         (let ((v1-123 f0-9))
                           (.mov vf3 v1-123)
                           )
                         )
                       (.add.x.vf vf4 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf2 vf3)
                       (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
                       (.svf (&-> sv-416 quad) vf4)
                       (vector+float*! sv-560 (-> s2-1 trans) sv-432 f30-2)
                       )
                     )
                   )
                 (if (or (zero? (the-as object arg1)) (-> arg1 collision))
                     (ragdoll-method-24 this sv-560 s1-1)
                     )
                 (cond
                   ((or (> s1-1 0) (!= (-> s0-1 parent-joint) -1))
                    (set! sv-448 (new 'stack-no-clear 'vector))
                    (let ((v1-134 (-> s2-1 trans))
                          (a0-63 sv-560)
                          )
                      (.lvf vf4 (&-> v1-134 quad))
                      (.lvf vf5 (&-> a0-63 quad))
                      )
                    (.mov.vf vf6 vf0 :mask #b1000)
                    (.sub.vf vf6 vf4 vf5 :mask #b111)
                    (.svf (&-> sv-448 quad) vf6)
                    (vector-normalize-ret-len! sv-448 1.0)
                    (set! sv-464 (new 'stack-no-clear 'vector))
                    (let ((v1-137 sv-560)
                          (a0-65 (-> s0-1 position))
                          )
                      (.lvf vf4 (&-> v1-137 quad))
                      (.lvf vf5 (&-> a0-65 quad))
                      )
                    (.mov.vf vf6 vf0 :mask #b1000)
                    (.sub.vf vf6 vf4 vf5 :mask #b111)
                    (.svf (&-> sv-464 quad) vf6)
                    (let ((f30-3 (vector-dot sv-448 sv-464)))
                      (vector--float*! sv-464 sv-464 sv-448 f30-3)
                      (cond
                        ((< f30-3 0.0)
                         (set! f0-14 (* f30-3 (-> this compress-vel-parallel)))
                         (vector-float*! sv-464 sv-464 (-> this compress-vel))
                         )
                        (else
                          (set! f0-14 (* f30-3 (-> this stretch-vel-parallel)))
                          (vector-float*! sv-464 sv-464 (-> this stretch-vel))
                          )
                        )
                      )
                    (vector+float*! sv-464 sv-464 sv-448 f0-14)
                    (vector+! sv-560 (-> s0-1 position) sv-464)
                    (let ((f0-16 (-> this momentum)))
                      (if (logtest? (-> s0-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
                          (set! f0-16 0.1)
                          )
                      (let ((t9-20 vector-lerp!)
                            (a0-72 (-> s0-1 velocity))
                            (a1-23 (-> s0-1 velocity))
                            (a3-6 f0-16)
                            )
                        (t9-20 a0-72 a1-23 sv-464 a3-6)
                        )
                      )
                    (let ((a2-12 (vector-! (new 'stack-no-clear 'vector) (-> s2-1 trans) sv-560)))
                      (.lvf vf1 (&-> a2-12 quad))
                      (.add.w.vf vf2 vf0 vf0 :mask #b1)
                      (.mul.vf vf1 vf1 vf1)
                      (.mul.x.vf acc vf2 vf1 :mask #b1)
                      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                      (.mov v1-156 vf1)
                      (let* ((f0-17 v1-156)
                             (f1-6 (* (-> this maximum-stretch) (-> s0-1 joint-length)))
                             (f2-3 f1-6)
                             )
                        (if (< (* f2-3 f2-3) f0-17)
                            (vector--float*! sv-560 (-> s2-1 trans) a2-12 (/ f1-6 (sqrtf f0-17)))
                            )
                        )
                      )
                    )
                   (else
                     (let ((a2-14 (vector-! (new 'stack-no-clear 'vector) sv-560 (-> s0-1 position)))
                           (f0-20 (-> this momentum))
                           )
                       (if (logtest? (-> s0-1 ragdoll-joint-flags) (ragdoll-joint-flag rjf2))
                           (set! f0-20 0.1)
                           )
                       (vector-lerp! (-> s0-1 velocity) (-> s0-1 velocity) a2-14 f0-20)
                       )
                     )
                   )
                 (let ((f0-21 (vector-vector-distance-squared (-> s0-1 position) sv-560))
                       (f1-7 40.96)
                       )
                   (if (< f0-21 (* f1-7 f1-7))
                       (+! (-> this stable-joints) 1)
                       )
                   )
                 (when (and (zero? s1-1) (< (-> s0-1 parent-joint) 0) (logtest? (-> this ragdoll-flags) (ragdoll-flag rf7)))
                   (let ((v1-176 (-> arg0 root transv)))
                     (.lvf vf1 (&-> (vector-! (new 'stack-no-clear 'vector) sv-560 (-> s0-1 position)) quad))
                     (let ((f0-22 (-> pp clock frames-per-second)))
                       (.mov at-0 f0-22)
                       )
                     (.mov vf2 at-0)
                     (.mov.vf vf1 vf0 :mask #b1000)
                     (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                     (.svf (&-> v1-176 quad) vf1)
                     )
                   )
                 (set! (-> s0-1 position quad) (-> sv-560 quad))
                 (cond
                   ((or (> s1-1 0) (!= (-> s0-1 parent-joint) -1))
                    (vector-! (-> s3-1 uvec) sv-560 (-> s2-1 trans))
                    (vector-normalize! (-> s3-1 uvec) 1.0)
                    (vector-cross! (-> s3-1 rvec) (-> s3-1 uvec) (-> s2-1 fvec))
                    (vector-normalize! (-> s3-1 rvec) 1.0)
                    (set! sv-528 (new 'stack-no-clear 'vector))
                    (let ((v1-183 (-> s0-1 old-x))
                          (a0-91 (-> s3-1 rvec))
                          )
                      (.lvf vf1 (&-> v1-183 quad))
                      (.lvf vf2 (&-> a0-91 quad))
                      )
                    (.outer.product.a.vf acc vf1 vf2)
                    (.outer.product.b.vf vf3 vf2 vf1 acc)
                    (.svf (&-> sv-528 quad) vf3)
                    (vector-flatten! sv-528 (-> s0-1 old-x) (-> s3-1 uvec))
                    (vector-normalize! sv-528 1.0)
                    (cond
                      ((and (< (-> s0-1 axial-slop) 65536.0) (< (vector-dot (-> s3-1 rvec) sv-528) (cos (-> s0-1 axial-slop))))
                       (vector-cross! sv-528 sv-528 (-> s3-1 rvec))
                       (vector-cross! sv-528 (-> s3-1 rvec) sv-528)
                       (vector-normalize! sv-528 1.0)
                       (set! sv-496 (-> s3-1 rvec))
                       (set! sv-480 (-> s3-1 rvec))
                       (let ((f0-28 (cos (-> s0-1 axial-slop))))
                         (.lvf vf1 (&-> sv-480 quad))
                         (let ((v1-195 f0-28))
                           (.mov vf2 v1-195)
                           )
                         )
                       (.add.x.vf vf1 vf0 vf0 :mask #b1000)
                       (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                       (.svf (&-> sv-496 quad) vf1)
                       (set! sv-544 (-> s3-1 rvec))
                       (set! sv-512 (-> s3-1 rvec))
                       (let ((f0-30 (sin (-> s0-1 axial-slop))))
                         (.lvf vf2 (&-> sv-528 quad))
                         (.lvf vf1 (&-> sv-512 quad))
                         (let ((v1-201 f0-30))
                           (.mov vf3 v1-201)
                           )
                         )
                       (.add.x.vf vf4 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf2 vf3)
                       (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
                       (.svf (&-> sv-544 quad) vf4)
                       (set! (-> s0-1 old-x quad) (-> s3-1 rvec quad))
                       )
                      (else
                        (set! (-> s3-1 rvec quad) (-> sv-528 quad))
                        (set! (-> s0-1 old-x quad) (-> s3-1 rvec quad))
                        )
                      )
                    (vector-cross! (-> s3-1 fvec) (-> s3-1 rvec) (-> s3-1 uvec))
                    (matrix->quaternion (-> s0-1 quat) s3-1)
                    )
                   (else
                     (quaternion->matrix s3-1 (-> s0-1 quat))
                     )
                   )
                 )
                (else
                  (quaternion->matrix s3-1 (-> s0-1 quat))
                  )
                )
              (set! (-> s3-1 trans quad) (-> sv-560 quad))
              (set! (-> s3-1 rvec w) 0.0)
              (set! (-> s3-1 uvec w) 0.0)
              (set! (-> s3-1 fvec w) 0.0)
              (if (and (zero? s1-1) (< (-> s0-1 parent-joint) 0) (logtest? (-> this ragdoll-flags) (ragdoll-flag rf7)))
                  (set! (-> arg0 root trans quad) (-> s3-1 trans quad))
                  )
              (ragdoll-method-13 this arg1 s0-1 s3-1 s2-1)
              )
            (let* ((a2-19 s2-1)
                   (a3-10 s3-1)
                   (v1-216 (-> a3-10 rvec quad))
                   (a0-119 (-> a3-10 uvec quad))
                   (a1-47 (-> a3-10 fvec quad))
                   (a3-11 (-> a3-10 trans quad))
                   )
              (set! (-> a2-19 rvec quad) v1-216)
              (set! (-> a2-19 uvec quad) a0-119)
              (set! (-> a2-19 fvec quad) a1-47)
              (set! (-> a2-19 trans quad) a3-11)
              )
            )
          )
        (if (and (< (min (the-as int (-> this num-joints)) (max 2 (the int (* 0.9 (the float (-> this num-joints))))))
                    (-> this stable-joints)
                    )
                 (< (cos 18.204445) (-> this rotate-vel w))
                 )
            (logior! (-> this ragdoll-flags) (ragdoll-flag rf2))
            )
        )
      (when *debug-segment*
        (let ((gp-1 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-238 (+ (-> gp-1 depth) -1))
                   (s5-1 (-> gp-1 segment v1-238))
                   (s4-1 (-> gp-1 base-time))
                   )
              (when (>= v1-238 0)
                (set! (-> s5-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
                (+! (-> gp-1 depth) -1)
                )
              )
            )
          )
        0
        )
      0
      (none)
      )
    )
  )

(defmethod ragdoll-setup! ((this ragdoll) (proc process-drawable) (setup ragdoll-setup))
  "Set up this ragdoll with the given [[ragdoll-setup]]."
  (set! (-> this num-joints) (the-as uint (min 60 (-> setup joint-setup length))))
  (if (and (< (-> this num-joints) (the-as uint (-> setup joint-setup length))) (zero? (-> this ragdoll-joints)))
      (format 0 "ERROR<gmj>: too many joints in ragdoll setup~%")
      )
  (dotimes (v1-7 100)
    (set! (-> this ragdoll-joint-remap 0) (the-as uint 255))
    )
  (dotimes (s3-0 (the-as int (-> this num-joints)))
    (let ((s2-0 (-> this ragdoll-joints s3-0)))
      (let ((v1-15 (-> setup joint-setup s3-0)))
        (set! (-> s2-0 joint-type) (-> v1-15 joint-type))
        (set! (-> s2-0 joint-index) (-> v1-15 joint-index))
        (set! (-> s2-0 parent-joint) (-> v1-15 parent-joint))
        (set! (-> s2-0 pre-tform quad) (-> v1-15 pre-tform quad))
        (set! (-> s2-0 geo-tform quad) (-> v1-15 geo-tform quad))
        (set! (-> s2-0 axial-slop) (-> v1-15 axial-slop))
        (set! (-> s2-0 max-angle) (-> v1-15 max-angle))
        (set! (-> s2-0 coll-rad) (-> v1-15 coll-rad))
        (set! (-> s2-0 hit-sound) (-> v1-15 hit-sound))
        )
      (if (< 100 (-> s2-0 joint-index))
          (format 0 "ERROR<gmj>: ~S joint index in ragdoll setup exceeds max of ~D~%" (-> proc name) 100)
          (set! (-> this ragdoll-joint-remap (-> s2-0 joint-index)) (the-as uint s3-0))
          )
      (set! (-> s2-0 parent-index) -1)
      (when (and (nonzero? s3-0) (= (-> s2-0 parent-joint) -1))
        (set! (-> s2-0 parent-index) (+ s3-0 -1))
        (+! (-> this ragdoll-joints (+ s3-0 -1) num-children) 1)
        )
      (when (and (nonzero? s3-0) (>= (-> s2-0 parent-joint) 0))
        (dotimes (v1-35 (+ s3-0 -1))
          (when (= (-> this ragdoll-joints v1-35 joint-index) (-> s2-0 parent-joint))
            (set! (-> s2-0 parent-index) v1-35)
            (+! (-> this ragdoll-joints v1-35 num-children) 1)
            (goto cfg-28)
            )
          )
        )
      (label cfg-28)
      (set! (-> s2-0 num-children) 0)
      )
    0
    )
  (set! (-> this orient-tform quad) (-> setup orient-tform quad))
  (set! (-> this scale quad) (-> setup scale quad))
  (set! (-> this bg-collide-with) (the-as uint (-> setup bg-collide-with)))
  (set-vector! (-> this gravity) 0.0 -1.0 0.0 1.0)
  (set! (-> this gravity-target quad) (-> this gravity quad))
  (set! (-> this stretch-vel) 0.7)
  (set! (-> this stretch-vel-parallel) 0.8)
  (set! (-> this compress-vel) 0.85)
  (set! (-> this compress-vel-parallel) 0.75)
  (set! (-> this momentum) 0.75)
  (set! (-> this maximum-stretch) 1.5)
  (set! (-> this turn-off-start) 0)
  (set! (-> this ragdoll-flags) (ragdoll-flag rf0 rf7 rf9))
  (set! (-> this allow-destabilize) (the-as uint 0))
  0
  (none)
  )

(defmethod ragdoll-proc-method-15 ((this ragdoll-proc) (arg0 symbol) (arg1 vector) (arg2 symbol))
  (if (nonzero? (-> this ragdoll))
      (ragdoll-method-10 (-> this ragdoll) (ppointer->process (-> this parent)) arg0 arg1 arg2)
      )
  0
  (none)
  )

(defmethod disable-for-duration ((this ragdoll-proc) (arg0 time-frame))
  (if (nonzero? (-> this ragdoll))
      (turn-off-for-duration! (-> this ragdoll) arg0)
      )
  0
  (none)
  )

(defmethod ragdoll-proc-method-17 ((this ragdoll-proc) (arg0 ragdoll-edit-info))
  (if (nonzero? (-> this ragdoll))
      (ragdoll-method-15 (-> this ragdoll) (ppointer->process (-> this parent)) arg0)
      )
  0
  (none)
  )

(defmethod ragdoll-proc-method-18 ((this ragdoll-proc) (arg0 ragdoll-edit-info))
  (if (and (nonzero? (-> this ragdoll)) (-> this ragdoll) (nonzero? arg0) arg0)
      (ragdoll-edit-info-method-17 arg0 (-> this ragdoll) (ppointer->process (-> this parent)))
      )
  0
  (none)
  )

(defmethod ragdoll-proc-method-19 ((this ragdoll-proc))
  (if (nonzero? (-> this ragdoll))
      (logtest? (-> this ragdoll ragdoll-flags) (ragdoll-flag rf2))
      #t
      )
  )

(defstate idle (ragdoll-proc)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (when (nonzero? (-> self ragdoll))
         (let ((s5-0 (new 'stack-no-clear 'vector))
               (s4-0 (new 'stack-no-clear 'vector))
               (s3-0 #f)
               (gp-0 (the-as object (-> block param 1)))
               )
           (let ((s2-0 (ppointer->process (-> self parent))))
             (cond
               ((and (logtest? (-> (the-as attack-info gp-0) mask) (attack-mask id))
                     (= (-> (the-as attack-info gp-0) id) (-> self last-attack-id))
                     )
                )
               ((= proc *target*)
                (set! (-> s4-0 quad) (-> (the-as process-drawable proc) root trans quad))
                (vector-! s5-0 (-> s2-0 root trans) (-> (the-as process-drawable proc) root trans))
                (set! s3-0 #t)
                )
               (else
                 (when (and (-> block param 0) (type? (-> s2-0 root) collide-shape))
                   (let* ((a3-1 (the-as object (-> block param 0)))
                          (a1-10 (-> (the-as touching-prims-entry a3-1) u))
                          )
                     (get-intersect-point
                       s5-0
                       (the-as touching-prims-entry a1-10)
                       (the-as collide-shape (-> s2-0 root))
                       (the-as touching-shapes-entry a3-1)
                       )
                     )
                   (set! (-> s4-0 quad) (-> s5-0 quad))
                   (vector-! s5-0 (-> s2-0 root trans) s5-0)
                   (set! s3-0 #t)
                   )
                 (when (logtest? (attack-mask attacker-velocity) (-> (the-as attack-info gp-0) mask))
                   (set! (-> s5-0 quad) (-> (the-as attack-info gp-0) attacker-velocity quad))
                   (when (not s3-0)
                     (vector-! s4-0 (-> self ragdoll ragdoll-joints 0 position) s5-0)
                     (set! s3-0 #t)
                     )
                   )
                 )
               )
             )
           (when s3-0
             (vector-normalize! s5-0 2048.0)
             (ragdoll-method-23 (-> self ragdoll) s4-0 s5-0 1.0 #t)
             (set! (-> s5-0 y) 0.0)
             (vector-normalize! s5-0 409.6)
             (+! (-> s5-0 y) 1024.0)
             (set! (-> self ragdoll ragdoll-joints 0 velocity quad) (-> s5-0 quad))
             (if (logtest? (-> (the-as attack-info gp-0) mask) (attack-mask id))
                 (set! (-> self last-attack-id) (-> (the-as attack-info gp-0) id))
                 )
             #t
             )
           )
         )
       )
      (('notice)
       (if (= (-> block param 0) 'die)
           (deactivate self)
           )
       )
      )
    )
  :trans (behavior ()
    (+! (-> self clock ref-count) -1)
    (+! (-> self parent 0 clock ref-count) 1)
    (set! (-> self clock) (-> self parent 0 clock))
    (when (nonzero? (-> self ragdoll))
      (cond
        ((and (logtest? (-> self ragdoll ragdoll-flags) (ragdoll-flag rf4))
              (or (< 0.0 (-> self ragdoll flex-blend)) (logtest? (-> self ragdoll ragdoll-flags) (ragdoll-flag rf5)))
              )
         (ragdoll-method-15 (-> self ragdoll) (ppointer->process (-> self parent)) (the-as ragdoll-edit-info 0))
         )
        ((and (logtest? (-> self ragdoll ragdoll-flags) (ragdoll-flag rf3))
              (and (= (-> self ragdoll flex-blend) 0.0) (not (logtest? (-> self ragdoll ragdoll-flags) (ragdoll-flag rf5))))
              )
         (deactivate self)
         )
        )
      0
      )
    )
  :code sleep-code
  )

(defmethod deactivate ((this ragdoll-proc))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this ragdoll))
      (ragdoll-method-17 (-> this ragdoll) (ppointer->process (-> this parent)))
      )
  ((method-of-type process deactivate) this)
  (none)
  )

;; WARN: Return type mismatch process vs ragdoll-proc.
(defmethod relocate ((this ragdoll-proc) (offset int))
  (if (nonzero? (-> this ragdoll))
      (&+! (-> this ragdoll) offset)
      )
  (the-as ragdoll-proc ((method-of-type process relocate) this offset))
  )

(defbehavior ragdoll-proc-init-by-other ragdoll-proc ((arg0 ragdoll-setup))
  (set! (-> self last-attack-id) (the-as uint 0))
  (set! (-> self ragdoll) (new 'process 'ragdoll))
  (if (nonzero? (-> self ragdoll))
      (ragdoll-setup! (-> self ragdoll) (ppointer->process (-> self parent)) arg0)
      (format 0 "ERROR<gmj>: didn't have enough memory to allocate ragdoll for ragdoll-proc~%")
      )
  (go-virtual idle)
  )
