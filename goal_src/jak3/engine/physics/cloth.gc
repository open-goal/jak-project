;;-*-Lisp-*-
(in-package goal)

;; name: cloth.gc
;; name in dgo: cloth
;; dgos: GAME

;; DECOMP BEGINS

(defmethod relocate ((this verlet-particle-system) (offset int))
  (if (nonzero? (-> this particles))
      (&+! (-> this particles) offset)
      )
  (call-parent-method this offset)
  )

(defmethod mem-usage ((this art-cloth-geo) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 77 (-> usage length)))
  (set! (-> usage data 76 name) "art-cloth-geo")
  (+! (-> usage data 76 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 76 used) v1-6)
    (+! (-> usage data 76 total) (logand -16 (+ v1-6 15)))
    )
  this
  )

;; WARN: Return type mismatch uint vs int.
(defmethod asize-of ((this art-cloth-geo))
  (the-as int (+ (-> this type size)
                 (* (-> this length) 32)
                 (asize-of (-> this sphere-transforms))
                 (asize-of (-> this disc-transforms))
                 (asize-of (-> this anchor-transforms))
                 )
          )
  )

(defmethod reset! ((this verlet-particle-system))
  "Reset to stationary/default state."
  (set! (-> this accum-force quad) (the-as uint128 0))
  (dotimes (v1-1 (-> this particles length))
    (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this particles data 0 prev-pos)) (* 48 v1-1))))
          (-> this particles data v1-1 pos quad)
          )
    )
  0
  (none)
  )

(defmethod reset! ((this cloth-system))
  "Reset to stationary/default state."
  (reset-locations this)
  (when (> (-> this anchor-points length) 0)
    (let ((v1-6 (vector-!
                  (new 'stack-no-clear 'vector)
                  (the-as vector (-> this anchor-points data))
                  (the-as vector (-> this particles data (-> this anchor-points data 0 particle-index)))
                  )
                )
          )
      (dotimes (a0-4 (-> this particles length))
        (vector+! (the-as vector (-> this particles data a0-4)) (the-as vector (-> this particles data a0-4)) v1-6)
        )
      )
    )
  (dotimes (s5-0 1)
    (run-one-iteration this)
    )
  (call-parent-method this)
  (none)
  )

(defmethod pre-physics-update ((this cloth-system))
  "Callback to update prior to running verlet integration. Can handle movement of the entire system in the world, for example"
  0
  (none)
  )

;; WARN: Return type mismatch cloth-flag vs none.
(defmethod pre-physics-update ((this cloth-on-skeleton))
  "Callback to update prior to running verlet integration. Can handle movement of the entire system in the world, for example"
  (let ((s5-0 (new 'stack-no-clear 'matrix))
        (s4-0 (handle->process (-> this owner)))
        )
    (when s4-0
      (cond
        ((< -1 (-> this base-transform-index))
         (let* ((v1-4 s5-0)
                (a3-0 (-> (the-as process-focusable s4-0) node-list data (-> this base-transform-index) bone transform))
                (a0-8 (-> a3-0 rvec quad))
                (a1-3 (-> a3-0 uvec quad))
                (a2-0 (-> a3-0 fvec quad))
                (a3-1 (-> a3-0 trans quad))
                )
           (set! (-> v1-4 rvec quad) a0-8)
           (set! (-> v1-4 uvec quad) a1-3)
           (set! (-> v1-4 fvec quad) a2-0)
           (set! (-> v1-4 trans quad) a3-1)
           )
         )
        (else
          (quaternion->matrix s5-0 (-> (the-as process-focusable s4-0) root quat))
          (set! (-> s5-0 trans quad) (-> (the-as process-focusable s4-0) root trans quad))
          )
        )
      (vector-normalize! (-> s5-0 fvec) 1.0)
      (vector-normalize! (-> s5-0 uvec) 1.0)
      (vector-normalize! (-> s5-0 rvec) 1.0)
      (vector-float*! (-> s5-0 trans) (-> s5-0 trans) (/ 1.0 (-> s5-0 trans w)))
      (set! (-> s5-0 trans w) 1.0)
      (when (logtest? (cloth-flag local-space local-space-xyz local-space-y) (-> this flags))
        (let ((s4-1 (matrix-identity! (new 'stack-no-clear 'matrix))))
          (if (logtest? (cloth-flag local-space-y) (-> this flags))
              (set! (-> s4-1 trans y) (- (-> s5-0 trans y) (-> this last-owner-mat trans y)))
              (vector-! (-> s4-1 trans) (-> s5-0 trans) (-> this last-owner-mat trans))
              )
          (when (logtest? (cloth-flag local-space) (-> this flags))
            (let ((s3-0 (matrix-identity! (new 'stack-no-clear 'matrix))))
              (vector-float*! (-> s3-0 trans) (-> s5-0 trans) -1.0)
              (matrix*! s4-1 s4-1 s3-0)
              (matrix-4x4-inverse! s3-0 (-> this last-owner-mat))
              (matrix*! s3-0 s3-0 s5-0)
              (set! (-> s3-0 trans quad) (the-as uint128 0))
              (set! (-> s3-0 trans w) 1.0)
              (matrix*! s4-1 s4-1 s3-0)
              (matrix-identity! s3-0)
              (set! (-> s3-0 trans quad) (-> s5-0 trans quad))
              (matrix*! s4-1 s4-1 s3-0)
              )
            )
          (dotimes (s3-1 (-> this particles length))
            (set! (-> this particles data s3-1 pos w) 1.0)
            (vector-matrix*!
              (the-as vector (-> this particles data s3-1))
              (the-as vector (-> this particles data s3-1))
              s4-1
              )
            (set! (-> this particles data s3-1 pos w) 1.0)
            (set! (-> this particles data s3-1 prev-pos w) 1.0)
            (vector-matrix*!
              (the-as vector (+ (the-as uint (-> this particles data 0 prev-pos)) (* 48 s3-1)))
              (the-as vector (+ (the-as uint (-> this particles data 0 prev-pos)) (* 48 s3-1)))
              s4-1
              )
            (set! (-> this particles data s3-1 prev-pos w) 1.0)
            )
          )
        )
      (let ((a2-7 (-> this last-owner-mat))
            (v1-54 (-> s5-0 rvec quad))
            (a0-42 (-> s5-0 uvec quad))
            (a1-23 (-> s5-0 fvec quad))
            (a3-2 (-> s5-0 trans quad))
            )
        (set! (-> a2-7 rvec quad) v1-54)
        (set! (-> a2-7 uvec quad) a0-42)
        (set! (-> a2-7 fvec quad) a1-23)
        (set! (-> a2-7 trans quad) a3-2)
        )
      (logclear! (-> this flags) (cloth-flag local-space local-space-xyz local-space-y))
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod reset! ((this cloth-on-skeleton))
  "Reset to stationary/default state."
  (let ((s5-0 (new 'stack-no-clear 'matrix))
        (s4-0 (handle->process (-> this owner)))
        )
    (when s4-0
      (cond
        ((< -1 (-> this base-transform-index))
         (let* ((v1-5 s5-0)
                (a3-0 (-> (the-as process-focusable s4-0) node-list data (-> this base-transform-index) bone transform))
                (a0-8 (-> a3-0 rvec quad))
                (a1-3 (-> a3-0 uvec quad))
                (a2-0 (-> a3-0 fvec quad))
                (a3-1 (-> a3-0 trans quad))
                )
           (set! (-> v1-5 rvec quad) a0-8)
           (set! (-> v1-5 uvec quad) a1-3)
           (set! (-> v1-5 fvec quad) a2-0)
           (set! (-> v1-5 trans quad) a3-1)
           )
         )
        (else
          (quaternion->matrix s5-0 (-> (the-as process-focusable s4-0) root quat))
          (set! (-> s5-0 trans quad) (-> (the-as process-focusable s4-0) root trans quad))
          )
        )
      (dotimes (s4-1 (-> this particles length))
        (vector-matrix*! (the-as vector (-> this particles data s4-1)) (the-as vector (-> this mesh mesh s4-1)) s5-0)
        (vector-float*!
          (the-as vector (-> this particles data s4-1))
          (the-as vector (-> this particles data s4-1))
          (/ 1.0 (-> this particles data s4-1 pos w))
          )
        (set! (-> this particles data s4-1 pos w) 1.0)
        )
      (let ((v1-24 0)
            (a0-24 (+ (-> this particles length) -1))
            )
        (while (>= a0-24 v1-24)
          (+! v1-24 1)
          )
        )
      (let ((a0-25 (-> s5-0 trans)))
        (set! (-> this last-owner-pos quad) (-> a0-25 quad))
        )
      )
    )
  (set! (-> this accum-force quad) (the-as uint128 0))
  (dotimes (v1-29 (-> this particles length))
    (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this particles data 0 prev-pos)) (* 48 v1-29))))
          (-> this particles data v1-29 pos quad)
          )
    )
  (none)
  )

(defmethod relocate ((this cloth-system) (offset int))
  (if (nonzero? (-> this stick-constraints))
      (&+! (-> this stick-constraints) offset)
      )
  (if (nonzero? (-> this disc-collision-constraints))
      (&+! (-> this disc-collision-constraints) offset)
      )
  (if (nonzero? (-> this collision-constraints))
      (&+! (-> this collision-constraints) offset)
      )
  (if (nonzero? (-> this anchor-points))
      (&+! (-> this anchor-points) offset)
      )
  (if (nonzero? (-> this strip))
      (&+! (-> this strip) offset)
      )
  (if (nonzero? (-> this strip2))
      (&+! (-> this strip2) offset)
      )
  (if (nonzero? (-> this strip3))
      (&+! (-> this strip3) offset)
      )
  (call-parent-method this offset)
  )

(defmethod relocate ((this cloth-on-skeleton) (offset int))
  (call-parent-method this offset)
  )

(defmethod debug-draw ((this verlet-particle-system))
  (dotimes (s5-0 (-> this particles length))
    (let ((s4-0 add-debug-text-3d)
          (s3-0 #t)
          (s2-0 583)
          )
      (format (clear *temp-string*) "~d" s5-0)
      (s4-0
        s3-0
        (the-as bucket-id s2-0)
        *temp-string*
        (the-as vector (-> this particles data s5-0))
        (font-color red)
        (the-as vector2h #f)
        )
      )
    )
  0
  (none)
  )

(defmethod debug-draw ((this cloth-system))
  (dotimes (s5-0 (-> this particles length))
    (let* ((a0-1 (/ s5-0 (-> this cloth-width)))
           (v1-2 (mod s5-0 (-> this cloth-width)))
           (s1-0 (cond
                   ((not (logtest? a0-1 1))
                    (if (or (< v1-2 (/ (-> this cloth-width) 4)) (>= v1-2 (/ (* 3 (-> this cloth-width)) 4)))
                        3
                        4
                        )
                    )
                   ((or (< v1-2 (/ (-> this cloth-width) 4)) (>= v1-2 (/ (* 3 (-> this cloth-width)) 4)))
                    7
                    )
                   (else
                     6
                     )
                   )
                 )
           (s4-0 add-debug-text-3d)
           (s3-0 #t)
           (s2-0 583)
           )
      (format (clear *temp-string*) "~d" s5-0)
      (add-debug-sphere #t (the-as bucket-id s2-0)
                        (-> this particles data s5-0 pos)
                        (meters 0.02)
                        (static-rgba #x80 0 #x80 #x80)
                        )
      ; (s4-0
      ;   s3-0
      ;   (the-as bucket-id s2-0)
      ;   *temp-string*
      ;   (the-as vector (-> this particles data s5-0))
      ;   (the-as font-color s1-0)
      ;   (the-as vector2h #f)
      ;   )
      )
    )
  0
  (none)
  )

(defmethod initialize-cloth-system! ((this cloth-system) (arg0 cloth-params))
  "Set up this cloth system with the given [[cloth-params]]."
  (local-vars (sv-16 int) (sv-20 int) (sv-24 int) (sv-28 int))
  (if (or (zero? (-> this mesh)) (< (-> this mesh length) 4))
      (go process-drawable-art-error "cloth-mesh (art-cloth-geo)")
      )
  (set! (-> this params) arg0)
  (set! (-> this cloth-width) (the-as int (-> arg0 cloth-width)))
  (set! (-> this cloth-height) (/ (the-as int (-> this mesh length)) (-> this cloth-width)))
  (set! (-> this drag) (-> arg0 drag))
  (set! (-> this collision-constraints)
        (new 'process 'collision-sphere-array (the-as int (-> arg0 num-sphere-constraints)))
        )
  (set! (-> this disc-collision-constraints)
        (new 'process 'collision-disc-array (the-as int (-> arg0 num-disc-constraints)))
        )
  (set! (-> this anchor-points) (new 'process 'anchor-point-array (the-as int (-> arg0 num-anchor-points))))
  (set! (-> this wind-constant) (-> arg0 wind-constant))
  (set! (-> this gravity-constant) (-> arg0 gravity-constant))
  (set! (-> this thickness-scalar) (-> arg0 cloth-thickness))
  (set! (-> this flags) (-> arg0 flags))
  (set! (-> this timestep-frequency) (-> arg0 timestep-frequency))
  (set! (-> this secret-disable) (-> arg0 secret-disable))
  (when (<= (-> this mesh cloth-thickness length) 0)
    )
  (if (logtest? (-> this flags) (cloth-flag flip-normals))
      (set! (-> this face-normal-scalar) -1.0)
      (set! (-> this face-normal-scalar) 1.0)
      )
  (set! (-> this particles) (new 'process 'particle-array (* (-> this cloth-width) (-> this cloth-height))))
  (if (not (and (nonzero? (-> this collision-constraints)) (and (nonzero? (-> this disc-collision-constraints))
                                                                (nonzero? (-> this anchor-points))
                                                                (nonzero? (-> this particles))
                                                                )
                )
           )
      (go process-drawable-art-error "cloth-memory")
      )
  (dotimes (v1-38 (-> this particles length))
    (set! (-> this particles data v1-38 pos quad) (-> this mesh mesh v1-38 pt quad))
    (set! (-> this particles data v1-38 mass-scale) 1.0)
    )
  (set! sv-16 (* (+ (-> this cloth-width) -1) (-> this cloth-height)))
  (set! sv-20 (* (+ (-> this cloth-height) -1) (-> this cloth-width)))
  (set! sv-24 (+ (* (+ (-> this cloth-width) -2) 2) 2))
  (let ((v1-52 (* sv-24 (+ (-> this cloth-height) -1)))
        (s4-0 (* (+ (-> this cloth-width) -2) (-> this cloth-height)))
        )
    (set! sv-28 (+ s4-0 (* (-> this cloth-width) (+ (-> this cloth-height) -2))))
    (when (logtest? (-> this flags) (cloth-flag wraps))
      (+! s4-0 (* (-> this cloth-height) 2))
      (set! sv-28 (+ sv-28 (* (-> this cloth-height) 2)))
      )
    (set! sv-28 (max 0 sv-28))
    (let ((s3-1 (max 0 v1-52)))
      (set! (-> this num-xy-constraints) (+ sv-16 sv-20))
      (set! (-> this num-diagonal-constraints) s3-1)
      (if (zero? (-> this stick-constraints))
          (set! (-> this stick-constraints) (new 'process 'stick-constraint-array (+ sv-16 sv-20 s3-1 sv-28)))
          )
      (let ((v1-62 0))
        (dotimes (a0-37 (-> this cloth-height))
          (dotimes (a1-20 (+ (-> this cloth-width) -1))
            (let ((a2-11 (+ a1-20 (* a0-37 (-> this cloth-width))))
                  (a3-2 (-> this stick-constraints data v1-62))
                  )
              (set! (-> a3-2 particle0) (the-as uint a2-11))
              (set! (-> a3-2 particle1) (the-as uint (+ a2-11 1)))
              )
            (+! v1-62 1)
            )
          )
        )
      (let ((v1-65 sv-16))
        (dotimes (a0-38 (+ (-> this cloth-height) -1))
          (dotimes (a1-24 (-> this cloth-width))
            (let ((a2-18 (+ a1-24 (* a0-38 (-> this cloth-width))))
                  (a3-5 (-> this stick-constraints data v1-65))
                  )
              (set! (-> a3-5 particle0) (the-as uint a2-18))
              (set! (-> a3-5 particle1) (the-as uint (+ a2-18 (-> this cloth-width))))
              )
            (+! v1-65 1)
            )
          )
        )
      (let ((v1-69 (+ sv-16 sv-20)))
        (dotimes (a0-40 (+ (-> this cloth-height) -1))
          (dotimes (a1-29 (-> this cloth-width))
            (let ((a2-24 (+ a1-29 (* a0-40 (-> this cloth-width))))
                  (a3-8 (-> this stick-constraints data v1-69))
                  )
              (when (< a1-29 (+ (-> this cloth-width) -1))
                (set! (-> a3-8 particle0) (the-as uint a2-24))
                (set! (-> a3-8 particle1) (the-as uint (+ (-> this cloth-width) 1 a2-24)))
                (+! v1-69 1)
                (set! a3-8 (-> this stick-constraints data v1-69))
                )
              (when (> a1-29 0)
                (set! (-> a3-8 particle0) (the-as uint a2-24))
                (set! (-> a3-8 particle1) (the-as uint (+ (-> this cloth-width) -1 a2-24)))
                (+! v1-69 1)
                (-> this stick-constraints data v1-69)
                )
              )
            )
          )
        )
      (let ((v1-74 (+ sv-16 sv-20 s3-1)))
        (dotimes (a0-42 (-> this cloth-height))
          (dotimes (a1-34 (+ (-> this cloth-width) -2))
            (let ((a2-31 (+ a1-34 (* a0-42 (-> this cloth-width))))
                  (a3-14 (-> this stick-constraints data v1-74))
                  )
              (set! (-> a3-14 particle0) (the-as uint a2-31))
              (set! (-> a3-14 particle1) (the-as uint (+ a2-31 2)))
              )
            (+! v1-74 1)
            )
          )
        (when (logtest? (-> this flags) (cloth-flag wraps))
          (dotimes (a0-48 (-> this cloth-height))
            (let ((a1-40 (+ (* (+ a0-48 1) (-> this cloth-width)) -3))
                  (a2-38 (* a0-48 (-> this cloth-width)))
                  (a3-17 (-> this stick-constraints data v1-74))
                  )
              (set! (-> a3-17 particle0) (the-as uint a1-40))
              (set! (-> a3-17 particle1) (the-as uint a2-38))
              )
            (let ((v1-75 (+ v1-74 1)))
              (-> this stick-constraints data v1-75)
              (let ((a1-46 (+ (* (+ a0-48 1) (-> this cloth-width)) -2))
                    (a2-43 (+ (* a0-48 (-> this cloth-width)) 1))
                    (a3-20 (-> this stick-constraints data v1-75))
                    )
                (set! (-> a3-20 particle0) (the-as uint a1-46))
                (set! (-> a3-20 particle1) (the-as uint a2-43))
                )
              (set! v1-74 (+ v1-75 1))
              )
            (-> this stick-constraints data v1-74)
            )
          )
        )
      (let ((v1-80 (+ sv-16 sv-20 s3-1 s4-0)))
        (dotimes (a0-51 (+ (-> this cloth-height) -2))
          (dotimes (a1-51 (-> this cloth-width))
            (let ((a2-47 (+ a1-51 (* a0-51 (-> this cloth-width))))
                  (a3-23 (-> this stick-constraints data v1-80))
                  )
              (set! (-> a3-23 particle0) (the-as uint a2-47))
              (set! (-> a3-23 particle1) (the-as uint (+ a2-47 (* (-> this cloth-width) 2))))
              )
            (+! v1-80 1)
            )
          )
        )
      )
    )
  (let ((s4-1 (* (if (logtest? (-> this flags) (cloth-flag double-sided))
                     (+ (* (-> this cloth-width) 2) 1)
                     (+ (* 3 (+ (-> this cloth-width) -2)) 6)
                     )
                 (+ (-> this cloth-height) -1)
                 )
              )
        )
    (if (zero? (-> this strip))
        (set! (-> this strip)
              (new 'process 'prim-strip s4-1 (new 'static 'texture-id :index #x3 :page #x1) (-> arg0 tex-name))
              )
        )
    (when (logtest? (-> this flags) (cloth-flag double-sided))
      (when (zero? (-> this strip2))
        (set! (-> this strip2)
              (new 'process 'prim-strip s4-1 (new 'static 'texture-id :index #x3 :page #x1) (-> arg0 tex-name2))
              )
        (set! (-> this strip2 num-verts) (the-as uint 0))
        0
        )
      (when (zero? (-> this strip3))
        (let ((a2-53 (* (+ (* (-> this cloth-width) 2) (* (-> this cloth-height) 2)) 2)))
          (set! (-> this strip3)
                (new 'process 'prim-strip a2-53 (new 'static 'texture-id :index #x3 :page #x1) (-> arg0 tex-name3))
                )
          )
        (set! (-> this strip3 num-verts) (the-as uint 0))
        0
        )
      )
    )
  (set! (-> this strip num-verts) (the-as uint 0))
  0
  (when (logtest? (-> this flags) (cloth-flag autogen-uvs))
    (dotimes (v1-115 (-> this particles length))
      (let ((a1-59 (mod v1-115 (-> this cloth-width)))
            (a0-63 (/ v1-115 (-> this cloth-width)))
            )
        (set! (-> this mesh mesh v1-115 u) (/ (the float a1-59) (the float (+ (-> this cloth-width) -1))))
        (set! (-> this mesh mesh v1-115 v) (- 1.0 (/ (the float a0-63) (the float (+ (-> this cloth-height) -1)))))
        )
      (set! (-> this mesh mesh v1-115 v) (fmax 0.0 (fmin 1.0 (-> this mesh mesh v1-115 v))))
      )
    (dotimes (v1-118 (-> this cloth-width))
      (+ (-> this cloth-height) -1)
      (set! (-> this mesh mesh v1-118 v) 0.99)
      )
    )
  (logior! (-> this flags) (cloth-flag need-reset need-setup))
  (logior! (-> this flags) (cloth-flag active inited))
  (set! (-> this reset-count) 1)
  0
  (none)
  )

(defmethod setup-from-params! ((this cloth-on-skeleton) (arg0 cloth-params) (arg1 handle))
  (if (logtest? (-> this flags) (cloth-flag inited))
      (return 0)
      )
  (set! (-> this owner) arg1)
  (set! (-> this num-iterations) (-> arg0 num-iterations))
  (let ((s4-0 (handle->process (-> this owner))))
    (when (and s4-0 (< -1 (-> arg0 mesh)))
      (set! (-> this mesh)
            (the-as art-cloth-geo (-> (the-as process-focusable s4-0) draw art-group data (-> arg0 mesh)))
            )
      (when (or (not (-> this mesh)) (!= (-> this mesh type) art-cloth-geo))
        (if (logtest? (-> arg0 flags) (cloth-flag suppress-mesh-failure))
            (return 0)
            (go process-drawable-art-error "cloth-mesh (art-cloth-geo)")
            )
        )
      (set! (-> this base-transform-index) (-> arg0 initial-xform))
      (set! (-> arg0 num-anchor-points)
            (the-as uint (max (-> this mesh anchor-transforms length) (the-as int (-> arg0 num-anchor-points))))
            )
      (set! (-> arg0 num-sphere-constraints)
            (the-as uint (max (-> this mesh sphere-transforms length) (the-as int (-> arg0 num-sphere-constraints))))
            )
      (set! (-> arg0 num-disc-constraints)
            (the-as uint (max (-> this mesh disc-transforms length) (the-as int (-> arg0 num-disc-constraints))))
            )
      (set! (-> this ball-collision-radius) (-> arg0 ball-collision-radius))
      (set! (-> this ball-collision-radius) (-> this ball-collision-radius))
      (dotimes (s3-0 (-> this mesh anchor-transforms length))
        (let ((s2-0 (-> this mesh anchor-transforms data s3-0)))
          (when (< (-> s2-0 joint) 0)
            (let ((v1-47
                    (the-as
                      joint
                      (get-art-by-name-method (-> (the-as process-focusable s4-0) draw jgeo) (-> s2-0 joint-name) (the-as type #f))
                      )
                    )
                  )
              (set! (-> s2-0 joint) (if v1-47
                                        (+ (-> v1-47 number) 1)
                                        0
                                        )
                    )
              )
            )
          )
        )
      (dotimes (s3-1 (-> this mesh sphere-transforms length))
        (let ((s2-1 (-> this mesh sphere-transforms data s3-1)))
          (when (< (-> s2-1 joint) 0)
            (let ((v1-61
                    (the-as
                      joint
                      (get-art-by-name-method (-> (the-as process-focusable s4-0) draw jgeo) (-> s2-1 joint-name) (the-as type #f))
                      )
                    )
                  )
              (set! (-> s2-1 joint) (if v1-61
                                        (+ (-> v1-61 number) 1)
                                        0
                                        )
                    )
              )
            )
          )
        )
      (dotimes (s3-2 (-> this mesh disc-transforms length))
        (let ((s2-2 (-> this mesh disc-transforms data s3-2)))
          (when (< (-> s2-2 joint) 0)
            (let ((v1-76 (the-as joint (get-art-by-name-method
                                         (-> (the-as process-focusable s4-0) draw jgeo)
                                         (the-as string (-> s2-2 joint-name))
                                         (the-as type #f)
                                         )
                                 )
                         )
                  )
              (set! (-> s2-2 joint) (if v1-76
                                        (+ (-> v1-76 number) 1)
                                        0
                                        )
                    )
              )
            )
          )
        )
      )
    )
  (initialize-cloth-system! this arg0)
  0
  )

(defmethod run-one-iteration ((this verlet-particle-system))
  "Run one iteration of the system."
  0
  (none)
  )

(defmethod update! ((this verlet-particle-system))
  (with-pp
    (accumulate-external-forces! this)
    (let ((v1-4 (- (current-time) (-> pp clock old-frame-counter))))
      (if (> (-> this timestep-frequency) 0)
          (compute-verlet-step this (* 0.0033333334 (the float (-> this timestep-frequency))))
          (compute-verlet-step this (* 0.0033333334 (the float v1-4)))
          )
      )
    ;; (debug-draw this)
    0
    )
  )

(defmethod update! ((this cloth-system))
  (if (not (logtest? (-> this flags) (cloth-flag active)))
      (return 0)
      )
  (when (logtest? (-> this flags) (cloth-flag need-setup))
    (cond
      ((or (> (-> this reset-count) 0) (logtest? (-> this flags) (cloth-flag no-draw)))
       (reset! this)
       (+! (-> this reset-count) -1)
       (set! (-> this reset-count) (max 0 (-> this reset-count)))
       )
      (else
        (reset! this)
        (logclear! (-> this flags) (cloth-flag need-setup))
        (dotimes (s5-0 (-> this stick-constraints length))
          (let ((s4-0 (-> this stick-constraints data s5-0)))
            0.0
            (let ((f0-1 (vector-vector-distance
                          (the-as vector (-> this particles data (-> s4-0 particle0)))
                          (the-as vector (-> this particles data (-> s4-0 particle1)))
                          )
                        )
                  )
              (set! (-> s4-0 one-over-two-times-constraint-length) (/ 1.0 (* 2.0 f0-1)))
              (set! (-> s4-0 constraint-length-sqd) (* f0-1 f0-1))
              (set! (-> s4-0 constraint-length-half) (* 0.5 f0-1))
              )
            )
          )
        )
      )
    )
  (when (and (logtest? (-> this flags) (cloth-flag need-reset))
             (not (logtest? (-> this flags) (cloth-flag need-setup)))
             )
    (reset! this)
    (if (> (-> this reset-count) 0)
        (+! (-> this reset-count) -1)
        (logclear! (-> this flags) (cloth-flag need-reset))
        )
    )
  (pre-physics-update this)
  (call-parent-method this)
  (reset-locations this)
  (let ((s5-1 (-> this num-iterations)))
    (if (logtest? (cloth-flag riding) (-> this flags))
        (+! s5-1 1)
        )
    (dotimes (s4-1 s5-1)
      (run-one-iteration this)
      )
    )
  (when (and (> (the-as uint (-> this secret-disable)) 0)
             (> (the-as uint (logand (-> *game-info* secrets) (-> this secret-disable))) 0)
             )
    (hide! this)
    (return 0)
    )
  (post-physics-update this)
  0
  )

(defmethod update! ((this cloth-on-skeleton))
  (if (not (logtest? (cloth-flag hidden) (-> this flags)))
      (logclear! (-> this flags) (cloth-flag no-draw))
      )
  (when (and (handle->process (-> this owner)) (= (-> (handle->process (-> this owner)) type) target))
    (let* ((s5-0 (handle->process (-> this owner)))
           (a0-16 (if (type? s5-0 process-focusable)
                      s5-0
                      )
                  )
           )
      (when (and a0-16 (focus-test? (the-as process-focusable a0-16) teleporting))
        (set! (-> this reset-count) 1)
        (logior! (-> this flags) (cloth-flag need-reset no-draw))
        )
      )
    )
  (let ((s5-1 (handle->process (-> this owner))))
    (if (and s5-1
             (nonzero? (-> (the-as process-focusable s5-1) draw))
             (logtest? (-> (the-as process-focusable s5-1) draw status)
                       (draw-control-status no-draw no-draw-temp no-draw-bounds no-draw-bounds2)
                       )
             )
        (logior! (-> this flags) (cloth-flag no-draw))
        )
    (when (and s5-1 (nonzero? (-> (the-as process-focusable s5-1) draw)))
      (let ((s4-0 (-> (the-as process-focusable s5-1) draw)))
        (setup-dma-and-tex (-> this strip) s4-0)
        (when (logtest? (-> this flags) (cloth-flag double-sided))
          (setup-dma-and-tex (-> this strip2) s4-0)
          (setup-dma-and-tex (-> this strip3) s4-0)
          )
        )
      )
    (when (< -1 (-> this base-transform-index))
      (let ((s5-2 (-> (the-as process-focusable s5-1) node-list data 3 bone transform trans)))
        (let ((f0-0 12288.0))
          (when (< (* f0-0 f0-0) (vector-vector-distance-squared (-> this last-owner-pos) s5-2))
            )
          )
        (set! (-> this last-owner-pos quad) (-> s5-2 quad))
        )
      )
    )
  (call-parent-method this)
  )

(defmethod accumulate-external-forces! ((this verlet-particle-system))
  "If this cloth system has the wind flag, calculate the wind force."
  0
  (none)
  )

(defmethod hide! ((this cloth-system))
  (logior! (-> this flags) (cloth-flag no-draw hidden))
  (set! (-> this strip num-verts) (the-as uint 0))
  (when (nonzero? (-> this strip2))
    (set! (-> this strip2 num-verts) (the-as uint 0))
    (set! (-> this strip3 num-verts) (the-as uint 0))
    0
    )
  (none)
  )

(defmethod accumulate-external-forces! ((this cloth-system))
  "If this cloth system has the wind flag, calculate the wind force."
  (if (not (logtest? (-> this flags) (cloth-flag no-gravity)))
      (vector-float*! (-> this accum-force) (new 'static 'vector :y -1.0) (-> this gravity-constant))
      )
  (if (logtest? (-> this flags) (cloth-flag use-momentum))
      (vector+float*! (-> this accum-force) (-> this accum-force) (-> this momentum) 1.0)
      )
  (when (logtest? (-> this flags) (cloth-flag use-wind))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      0.0
      (cond
        ((-> *setting-control* user-current global-wind)
         (vector-float*! s5-0 (the-as vector (-> *setting-control* user-current global-wind)) (-> this wind-constant))
         )
        (else
          (let ((v1-17 s5-0)
                (a1-1 (-> this particles data))
                )
            (vector-float*!
              v1-17
              (-> *wind-work*
                  wind-array
                  (logand (+ (the int (-> a1-1 0 pos x)) (the int (-> a1-1 0 pos z)) (-> *wind-work* wind-time)) 63)
                  )
              (* 2048.0 (-> this wind-constant) (-> *setting-control* user-current ambient-wind-scalar))
              )
            )
          )
        )
      (let* ((f0-11 (vector-normalize-ret-len! s5-0 1.0))
             (f0-12 (fmin 163840.0 f0-11))
             )
        (vector+float*! (-> this accum-force) (-> this accum-force) s5-0 f0-12)
        )
      )
    )
  0
  (none)
  )

(defmethod compute-verlet-step ((this verlet-particle-system) (arg0 float))
  (let ((f0-1 (* arg0 arg0))
        (f1-1 (-> this drag))
        )
    (dotimes (v1-0 (-> this particles length))
      (let ((a2-1 (-> this particles data v1-0))
            (a1-4 (new 'stack-no-clear 'vector))
            )
        (let ((a3-0 (-> this accum-force)))
          (vector-float*! a1-4 (-> a2-1 pos) (- 2.0 f1-1))
          (vector-! a1-4 a1-4 (vector-float*! (new 'stack-no-clear 'vector) (-> a2-1 prev-pos) (- 1.0 f1-1)))
          (vector+float*! a1-4 a1-4 a3-0 f0-1)
          )
        (set! (-> a2-1 prev-pos quad) (-> a2-1 pos quad))
        (set! (-> a2-1 pos quad) (-> a1-4 quad))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; ERROR: Failed load: (set! vf10 (l.vf (+ a2-8 32))) at op 59
(defmethod enforce-constraints-1 ((this cloth-system))
  (local-vars (a1-8 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (set! (-> v1-0 x) 0.5)
      (set! (-> v1-0 y) 0.5)
      (set! (-> v1-0 z) 0.5)
      (set! (-> v1-0 w) 0.5)
      (let ((a1-4 (new 'stack-no-clear 'vector)))
        (set! (-> a1-4 x) 3.0)
        (set! (-> a1-4 y) 3.0)
        (set! (-> a1-4 z) 3.0)
        (set! (-> a1-4 w) 3.0)
        (.max.w.vf vf7 vf0 vf0)
        (.lvf vf8 (&-> v1-0 quad))
        (.lvf vf12 (&-> a1-4 quad))
        )
      )
    (.sub.w.vf vf9 vf0 vf0)
    (dotimes (v1-1 (-> this stick-constraints length))
      (let* ((a1-7 (-> this stick-constraints data v1-1))
             (a2-8 (-> this particles data (-> a1-7 particle0)))
             (a3-5 (-> this particles data (-> a1-7 particle1)))
             )
        (.lvf vf2 (&-> a2-8 pos quad))
        (.lvf vf3 (&-> a3-5 pos quad))
        (.lvf vf6 (&-> a1-7 vec quad))
        (.sub.vf vf4 vf3 vf2)
        (.mul.vf vf5 vf4 vf4)
        (.mul.z.vf acc vf7 vf5)
        (.add.mul.y.vf acc vf7 vf5 acc)
        (.add.mul.x.vf acc vf7 vf5 acc)
        (.add.mul.z.vf vf5 vf7 vf6 acc)
        (.mul.y.vf vf5 vf5 vf6)
        (.div.vf Q vf6 vf5 :fsf #b0 :ftf #b0)
        (.lvf vf10 (&+ a2-8 32))
        (.lvf vf11 (&+ a3-5 32))
        (.max.x.vf vf10 vf0 vf10 :mask #b111)
        (.max.x.vf vf11 vf0 vf11 :mask #b111)
        (.add.vf vf13 vf10 vf11)
        (.sub.vf vf13 vf12 vf13)
        (.mul.vf vf10 vf10 vf13)
        (.mul.vf vf11 vf11 vf13)
        (.wait.vf)
        (.sub.vf vf5 vf8 Q)
        (.mul.vf vf5 vf5 vf4)
        (.mul.vf vf10 vf10 vf5)
        (.add.vf vf2 vf2 vf10)
        (.mul.vf vf11 vf11 vf5)
        (.sub.vf vf3 vf3 vf11)
        (.svf (&-> a2-8 pos quad) vf2)
        (.svf (&-> a3-5 pos quad) vf3)
        )
      (.mov a1-8 vf3)
      )
    (none)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod enforce-constraints-2 ((this cloth-system))
  (dotimes (v1-0 (-> this stick-constraints length))
    (let* ((t0-0 (-> this stick-constraints data v1-0))
           (a1-5 (-> this particles data (-> t0-0 particle0)))
           (a2-6 (-> this particles data (-> t0-0 particle1)))
           (f0-1 (* 2.0 (-> t0-0 constraint-length-half)))
           (a3-4 (vector-! (new 'stack-no-clear 'vector) (-> a2-6 pos) (-> a1-5 pos)))
           )
      0.0
      (let ((f1-2 (* f0-1 f0-1)))
        0.0
        0.0
        (let* ((f1-4 (/ (+ f1-2 (vector-dot a3-4 a3-4)) (* 2.0 f0-1)))
               (f0-3 (/ (- f1-4 f0-1) f1-4))
               )
          (vector-float*! a3-4 a3-4 (* 0.5 f0-3))
          )
        )
      (let ((f1-6 1.0)
            (f0-5 -1.0)
            )
        (cond
          ((< (-> t0-0 particle0) (the-as uint 7))
           (set! f1-6 (* 0.0 f1-6))
           (set! f0-5 (* 2.0 f0-5))
           )
          ((< (-> t0-0 particle1) (the-as uint 7))
           (set! f1-6 (* 2.0 f1-6))
           (set! f0-5 (* 0.0 f0-5))
           )
          )
        (vector+float*! (-> a1-5 pos) (-> a1-5 pos) a3-4 f1-6)
        (vector+float*! (-> a2-6 pos) (-> a2-6 pos) a3-4 f0-5)
        )
      )
    )
  (none)
  )

(defmethod-mips2c "(method 21 cloth-system)" 21 cloth-system)

;; WARN: Return type mismatch symbol vs none.
(defmethod cloth-system-method-23 ((this cloth-system))
  (local-vars
    (sv-32 int)
    (sv-40 int)
    (sv-48 int)
    (sv-56 int)
    (sv-64 matrix)
    (sv-68 verlet-particle)
    (sv-72 verlet-particle)
    (sv-76 verlet-particle)
    (sv-80 verlet-particle)
    (sv-144 vector)
    (sv-148 vector)
    (sv-152 float)
    (sv-156 float)
    (sv-160 vector)
    (sv-164 float)
    (sv-168 float)
    (sv-208 vector)
    (sv-212 float)
    (sv-216 vector)
    )
  (set! sv-32 0)
  (set! sv-40 0)
  (set! sv-48 0)
  (set! sv-56 -1)
  (set! sv-64 (new 'stack-no-clear 'matrix))
  (dotimes (s5-0 (+ (-> this cloth-height) -1))
    (dotimes (s4-0 (+ (-> this cloth-width) -1))
      (set! sv-68 (-> this particles data sv-32))
      (set! sv-72 (-> this particles data (+ sv-32 1)))
      (set! sv-76 (-> this particles data (+ sv-32 (-> this cloth-width))))
      (set! sv-80 (-> this particles data (+ (-> this cloth-width) 1 sv-32)))
      (set! sv-144 (vector-! (new 'stack-no-clear 'vector) (-> sv-80 pos) (-> sv-68 pos)))
      (set! sv-148 (vector-! (new 'stack-no-clear 'vector) (-> sv-72 pos) (-> sv-76 pos)))
      (set! sv-152 (the-as float 0.0))
      (set! sv-156 (the-as float 0.0))
      (set! sv-160 (new 'stack-no-clear 'vector))
      (set! sv-164 (the-as float 0.0))
      (vector-float*! sv-160 (-> sv-72 pos) (-> sv-72 mass-scale))
      (vector+float*! sv-160 sv-160 (-> sv-68 pos) (-> sv-68 mass-scale))
      (vector+float*! sv-160 sv-160 (-> sv-76 pos) (-> sv-76 mass-scale))
      (vector+float*! sv-160 sv-160 (-> sv-80 pos) (-> sv-80 mass-scale))
      (vector-float*! sv-160 sv-160 0.25)
      (set! sv-40 0)
      (set! sv-56 -1)
      (set! (-> sv-64 rvec quad) (the-as uint128 0))
      (dotimes (s3-0 (-> this collision-constraints length))
        (when (!= s3-0 sv-56)
          (let ((v1-39 (-> this collision-constraints data s3-0)))
            (set! sv-164 (the-as float 204.8))
            (set! sv-168 (the-as float 0.0))
            (set! sv-168 (+ (-> v1-39 r) (the-as float sv-164)))
            (set! sv-208 (vector-! (new 'stack-no-clear 'vector) sv-160 (the-as vector v1-39)))
            )
          (set! sv-212 (the-as float 0.0))
          (set! sv-216 (new 'stack-no-clear 'vector))
          (set! sv-212 (vector-dot sv-208 sv-208))
          (when (< sv-212 (* sv-168 sv-168))
            (vector-normalize-copy! sv-216 sv-208 sv-168)
            (vector-! sv-216 sv-216 sv-208)
            (when (and (> sv-40 0) (< (vector-dot sv-216 (the-as vector sv-64)) 0.0))
              )
            (vector+float*! (-> sv-68 pos) (-> sv-68 pos) sv-216 (-> sv-68 mass-scale))
            (vector+float*! (-> sv-72 pos) (-> sv-72 pos) sv-216 (-> sv-72 mass-scale))
            (vector+float*! (-> sv-76 pos) (-> sv-76 pos) sv-216 (-> sv-76 mass-scale))
            (vector+float*! (-> sv-80 pos) (-> sv-80 pos) sv-216 (-> sv-80 mass-scale))
            (vector+! sv-160 sv-160 sv-216)
            (set! sv-40 (+ sv-40 1))
            )
          )
        )
      (set! sv-32 (+ sv-32 1))
      )
    (set! sv-32 (+ sv-32 1))
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod cloth-system-method-22 ((this cloth-system))
  (local-vars
    (v1-25 float)
    (v1-27 float)
    (sv-16 sphere)
    (sv-24 int)
    (sv-32 verlet-particle)
    (sv-36 verlet-particle)
    (sv-40 verlet-particle)
    (sv-44 verlet-particle)
    (sv-96 vector)
    (sv-100 vector)
    (sv-104 float)
    (sv-108 float)
    (sv-112 vector)
    (sv-116 float)
    (sv-120 float)
    (sv-160 float)
    (sv-164 float)
    (sv-168 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (dotimes (s5-0 (-> this collision-constraints length))
      (set! sv-16 (-> this collision-constraints data s5-0))
      (set! sv-24 0)
      (dotimes (s4-0 (+ (-> this cloth-height) -1))
        (dotimes (s3-0 (+ (-> this cloth-width) -1))
          (set! sv-32 (-> this particles data sv-24))
          (set! sv-36 (-> this particles data (+ sv-24 1)))
          (set! sv-40 (-> this particles data (+ sv-24 (-> this cloth-width))))
          (set! sv-44 (-> this particles data (+ (-> this cloth-width) 1 sv-24)))
          (set! sv-96 (vector-! (new 'stack-no-clear 'vector) (-> sv-44 pos) (-> sv-32 pos)))
          (set! sv-100 (vector-! (new 'stack-no-clear 'vector) (-> sv-36 pos) (-> sv-40 pos)))
          (set! sv-104 (the-as float 0.0))
          (set! sv-108 (the-as float 0.0))
          (set! sv-112 (new 'stack-no-clear 'vector))
          (set! sv-116 (the-as float 0.0))
          (.lvf vf1 (&-> sv-96 quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov v1-25 vf1)
          (set! sv-104 v1-25)
          (.lvf vf1 (&-> sv-100 quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov v1-27 vf1)
          (set! sv-108 v1-27)
          (if (< sv-108 sv-104)
              (vector+float*! sv-112 (-> sv-32 pos) sv-96 0.5)
              (vector+float*! sv-112 (-> sv-40 pos) sv-100 0.5)
              )
          (set! sv-116 (the-as float 0.0))
          (set! sv-120 (the-as float 0.0))
          (set! sv-120 (-> sv-16 r))
          (set! sv-160 (the-as float (vector-! (new 'stack-no-clear 'vector) sv-112 (the-as vector sv-16))))
          (set! sv-164 (the-as float 0.0))
          (set! sv-168 (new 'stack-no-clear 'vector))
          (set! sv-164 (vector-dot (the-as vector sv-160) (the-as vector sv-160)))
          (when (< sv-164 (* sv-120 sv-120))
            (vector-normalize-copy! sv-168 (the-as vector sv-160) sv-120)
            (vector-! sv-168 sv-168 (the-as vector sv-160))
            (vector+! (-> sv-32 pos) (-> sv-32 pos) sv-168)
            (vector+! (-> sv-36 pos) (-> sv-36 pos) sv-168)
            (vector+! (-> sv-40 pos) (-> sv-40 pos) sv-168)
            (vector+! (-> sv-44 pos) (-> sv-44 pos) sv-168)
            )
          (set! sv-24 (+ sv-24 1))
          )
        (set! sv-24 (+ sv-24 1))
        )
      )
    (none)
    )
  )

(defmethod run-one-iteration ((this cloth-system))
  "Run one iteration of the system."
  (enforce-constraints-1 this)
  (cloth-system-method-21 this)
  (dotimes (v1-4 0)
    (let* ((a0-6 (-> this disc-collision-constraints data v1-4))
           (a2-0 (-> a0-6 start-particle-index))
           (a3-0 (-> a0-6 end-particle-index))
           (a1-2 (max 0 (min a2-0 (+ (-> this particles length) -1))))
           )
      (if (< a3-0 0)
          (set! a3-0 (+ (-> this particles length) -1))
          )
      (let ((a2-8 (max 0 (min a3-0 (+ (-> this particles length) -1)))))
        (while (>= a2-8 a1-2)
          (let ((a3-7 (-> this particles data a1-2 pos)))
            0.0
            (let ((t1-0 (new 'stack-no-clear 'vector))
                  (t0-7 (new 'stack-no-clear 'vector))
                  )
              (vector-! t1-0 a3-7 (-> a0-6 origin))
              (let ((f0-2 (vector-dot t1-0 (-> a0-6 normal))))
                (when (< 0.0 f0-2)
                  (vector+float*! t0-7 a3-7 (-> a0-6 normal) (* -1.0 f0-2))
                  (if (< (vector-length (vector-! (new 'stack-no-clear 'vector) t0-7 (-> a0-6 origin))) (-> a0-6 radius))
                      (set! (-> a3-7 quad) (-> t0-7 quad))
                      )
                  )
                )
              )
            )
          (+! a1-2 1)
          )
        )
      )
    )
  (dotimes (v1-7 (-> this anchor-points length))
    (set! (-> this particles data (-> this anchor-points data v1-7 particle-index) pos quad)
          (-> this anchor-points data v1-7 anchor-pos quad)
          )
    (set! (-> this particles data (-> this anchor-points data v1-7 particle-index) mass-scale) 0.0)
    )
  (when (logtest? (-> this flags) (cloth-flag wraps))
    (dotimes (v1-13 (-> this cloth-height))
      (let ((a0-19 (-> this particles data (+ (* v1-13 (-> this cloth-width)) -1 (-> this cloth-width))))
            (a1-20 (the-as object (&-> (-> this particles) _data (* (* 48 (-> this cloth-width)) v1-13))))
            )
        (set! (-> a0-19 mass-scale) 0.0)
        (set! (-> a0-19 pos quad) (-> (the-as vector (&-> (the-as vector a1-20) x)) quad))
        (set! (-> a0-19 prev-pos quad) (-> (the-as vector (&-> (the-as vector a1-20) x)) quad))
        )
      )
    )
  (when (logtest? (-> this flags) (cloth-flag check-ground))
    (dotimes (v1-19 (-> this particles length))
      (let ((a0-25 (-> this particles data v1-19)))
        (set! (-> a0-25 pos y) (fmax (-> a0-25 pos y) (-> this ground-constraint)))
        )
      )
    )
  0
  (none)
  )

(defun get-neighboring-faces ((arg0 vector4w) (arg1 int) (arg2 int) (arg3 int) (arg4 int))
  (let ((v0-0 0))
    (when (and (< arg2 (+ arg4 -1)) (< arg1 (+ arg3 -1)))
      (set! (-> arg0 data v0-0) (+ (* arg2 (+ arg3 -1)) arg1))
      (+! v0-0 1)
      )
    (when (and (> arg2 0) (< arg1 (+ arg3 -1)))
      (set! (-> arg0 data v0-0) (+ (* (+ arg2 -1) (+ arg3 -1)) arg1))
      (+! v0-0 1)
      )
    (when (and (> arg2 0) (> arg1 0))
      (set! (-> arg0 data v0-0) (+ arg1 -1 (* (+ arg2 -1) (+ arg3 -1))))
      (+! v0-0 1)
      )
    (when (and (< arg2 (+ arg4 -1)) (> arg1 0))
      (set! (-> arg0 data v0-0) (+ arg1 -1 (* arg2 (+ arg3 -1))))
      (+! v0-0 1)
      )
    v0-0
    )
  )

(kmemopen global "cloth-buffers")

(define *normal-array* (the-as (inline-array vector) (malloc 'global 6400)))

(kmemclose)

(defmethod cloth-system-method-27 ((this cloth-system) (arg0 vector) (arg1 int) (arg2 int) (arg3 current-position-info))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((s3-0 (new 'stack-no-clear 'vector4w)))
      0
      (let ((v1-1 (get-neighboring-faces s3-0 arg1 arg2 (-> this cloth-width) (-> this cloth-height))))
        (set! (-> arg0 quad) (the-as uint128 0))
        (dotimes (a0-3 v1-1)
          (vector+! arg0 arg0 (-> *normal-array* (-> s3-0 data a0-3)))
          )
        )
      )
    (let ((v1-4 arg0))
      (let ((f0-0 1.0))
        (.lvf vf1 (&-> v1-4 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((a0-5 f0-0))
          (.mov vf3 a0-5)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v1-4 quad) vf1)
      )
    (if (-> arg3 face-normal-needs-flip?)
        (vector-float*! arg0 arg0 -1.0)
        )
    (vector-float*! arg0 arg0 (-> this face-normal-scalar))
    arg0
    )
  )

;; WARN: Return type mismatch int vs rgba.
(defun light-vertex ((arg0 current-position-info) (arg1 vector))
  (local-vars (v0-0 uint128) (v0-1 uint128) (v0-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf1 (&-> arg0 lights direction 0 quad))
    (.lvf vf2 (&-> arg0 lights direction 1 quad))
    (.lvf vf3 (&-> arg0 lights direction 2 quad))
    (.lvf vf4 (&-> arg0 lights color 0 quad))
    (.lvf vf5 (&-> arg0 lights color 1 quad))
    (.lvf vf6 (&-> arg0 lights color 2 quad))
    (.lvf vf7 (&-> arg0 lights ambient quad))
    (.lvf vf10 (&-> (-> arg0 scale) quad))
    (.lvf vf11 (&-> (-> arg0 clamp-col) quad))
    (.lvf vf8 (&-> arg1 quad))
    (.mul.x.vf acc vf1 vf8)
    (.add.mul.y.vf acc vf2 vf8 acc)
    (.add.mul.z.vf vf8 vf3 vf8 acc)
    (.max.x.vf vf8 vf8 vf0)
    (.mul.w.vf acc vf7 vf0)
    (.add.mul.x.vf acc vf4 vf8 acc)
    (.add.mul.y.vf acc vf5 vf8 acc)
    (.add.mul.z.vf vf9 vf6 vf8 acc)
    (.mul.x.vf vf9 vf9 vf10)
    (.min.vf vf9 vf9 vf11)
    (.ftoi.vf vf9 vf9)
    (.mov v0-0 vf9)
    (.ppach v0-1 (the-as uint128 0) v0-0)
    (.ppacb v0-2 (the-as uint128 0) v0-1)
    (the-as rgba v0-2)
    )
  )

(defmethod cloth-system-method-28 ((this cloth-system) (arg0 int) (arg1 int) (arg2 current-position-info))
  (local-vars
    (sv-16 verlet-particle)
    (sv-80 vector)
    (sv-84 vector)
    (sv-88 vector)
    (sv-92 symbol)
    (sv-112 vector)
    )
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 (-> this particles data (+ arg0 (* arg1 (-> this cloth-width)))))
    (set! sv-80 (vector-!
                  (new 'stack-no-clear 'vector)
                  (the-as vector (+ (the-as uint (-> this strip data 0 pos))
                                    (* (- (-> arg2 current-vert-index) (the-as uint (-> arg2 cross-index0))) 32)
                                    )
                          )
                  (the-as vector sv-16)
                  )
          )
    (set! sv-84 (vector-!
                  (new 'stack-no-clear 'vector)
                  (the-as vector (+ (the-as uint (-> this strip data 0 pos))
                                    (* (- (-> arg2 current-vert-index) (the-as uint (-> arg2 cross-index1))) 32)
                                    )
                          )
                  (the-as vector sv-16)
                  )
          )
    (set! sv-88 (new 'stack-no-clear 'vector))
    (set! sv-92 (the-as symbol #f))
    (vector-cross! sv-88 sv-80 sv-84)
    (let ((a0-10 (-> arg2 cross-index0)))
      (set! (-> arg2 cross-index0) (-> arg2 cross-index1))
      (set! (-> arg2 cross-index1) a0-10)
      )
    (let ((s2-0 sv-88)
          (s0-0 sv-16)
          (s1-0 (new 'stack-no-clear 'vector))
          )
      (set! sv-112 s1-0)
      (let ((v0-0 (math-camera-pos)))
        (.lvf vf4 (&-> s0-0 pos quad))
        (.lvf vf5 (&-> v0-0 quad))
        )
      (.mov.vf vf6 vf0 :mask #b1000)
      (.sub.vf vf6 vf4 vf5 :mask #b111)
      (.svf (&-> sv-112 quad) vf6)
      (let ((v1-12 (< 0.0 (vector-dot s1-0 s2-0))))
        (when (!= v1-12 (-> arg2 face-normal-needs-flip?))
          (set! (-> arg2 face-normal-needs-flip?) (not (-> arg2 face-normal-needs-flip?)))
          (cloth-system-method-30
            this
            (the-as int (-> arg2 last-2-x-index))
            (the-as int (-> arg2 last-2-y-index))
            arg2
            1
            )
          (cloth-system-method-30 this (the-as int (-> arg2 last-x-index)) (the-as int (-> arg2 last-y-index)) arg2 1)
          )
        )
      )
    (cloth-system-method-30 this arg0 arg1 arg2 0)
    (none)
    )
  )

(defmethod cloth-system-method-31 ((this cloth-system) (arg0 current-position-info))
  (let ((a0-1 (-> arg0 last-normal))
        (s5-0 (+ (-> arg0 current-vert-index) -1))
        )
    (let ((v1-1 (-> arg0 backside-normal)))
      (vector+float*!
        (the-as vector (+ (the-as uint (-> this strip2 data 0 pos)) (* s5-0 32)))
        (the-as vector (+ (the-as uint (-> this strip data 0 pos)) (* s5-0 32)))
        a0-1
        (-> this thickness-scalar)
        )
      (set! (-> this strip2 data s5-0 col) (light-vertex arg0 v1-1))
      )
    (set! (-> this strip2 data s5-0 stq x) (-> this strip data s5-0 stq x))
    (set! (-> this strip2 data s5-0 stq y) (-> this strip data s5-0 stq y))
    )
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod cloth-system-method-32 ((this cloth-system) (arg0 vector) (arg1 int) (arg2 int) (arg3 current-position-info))
  (cond
    ((> (-> this mesh cloth-thickness length) 0)
     (let ((v1-5 (+ arg1 (* arg2 (-> this cloth-width)))))
       0.0
       (let ((f0-4 (* -1.0
                      (-> this mesh thickness-scalar)
                      (-> this face-normal-scalar)
                      (the float (-> this mesh cloth-thickness data v1-5))
                      )
                   )
             )
         (vector-float*! (-> arg3 backside-normal) arg0 -1.0)
         (vector-float*! arg0 arg0 f0-4)
         )
       )
     )
    (else
      (vector-float*! (-> arg3 backside-normal) arg0 -1.0)
      (vector-float*! arg0 arg0 (* 204.8
                                   (/ (the float arg2) (the float (+ (-> this cloth-height) -1)))
                                   (-> this thickness-scalar)
                                   (-> this face-normal-scalar)
                                   )
                      )
      )
    )
  (none)
  )

;; WARN: Return type mismatch uint vs none.
(defmethod cloth-system-method-30 ((this cloth-system) (arg0 int) (arg1 int) (arg2 current-position-info) (arg3 int))
  (let ((s1-0 (+ arg0 (* arg1 (-> this cloth-width)))))
    (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* (-> arg2 current-vert-index) 32)))
              )
          (-> this particles data s1-0 pos quad)
          )
    (set! (-> this strip data (-> arg2 current-vert-index) stq z) (the-as float arg3))
    (let ((s0-0 (new 'stack-no-clear 'vector)))
      (cloth-system-method-27 this s0-0 arg0 arg1 arg2)
      (set! (-> this strip data (-> arg2 current-vert-index) col) (light-vertex arg2 s0-0))
      )
    (set! (-> this strip data (-> arg2 current-vert-index) stq x) (-> this mesh mesh s1-0 u))
    (set! (-> this strip data (-> arg2 current-vert-index) stq y) (-> this mesh mesh s1-0 v))
    )
  (when (zero? arg3)
    (set! (-> arg2 last-2-x-index) (-> arg2 last-x-index))
    (set! (-> arg2 last-2-y-index) (-> arg2 last-y-index))
    (set! (-> arg2 last-x-index) (the-as uint arg0))
    (set! (-> arg2 last-y-index) (the-as uint arg1))
    )
  (+! (-> arg2 current-vert-index) 1)
  (none)
  )

(defmethod cloth-system-method-29 ((this cloth-system) (arg0 int) (arg1 int) (arg2 current-position-info) (arg3 int))
  (let ((s2-0 (+ arg0 (* arg1 (-> this cloth-width)))))
    (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* (-> arg2 current-vert-index) 32)))
              )
          (-> this particles data s2-0 pos quad)
          )
    (set! (-> this strip data (-> arg2 current-vert-index) stq z) (the-as float arg3))
    (let ((s1-0 (-> arg2 last-normal)))
      (cloth-system-method-27 this s1-0 arg0 arg1 arg2)
      (set! (-> this strip data (-> arg2 current-vert-index) col) (light-vertex arg2 s1-0))
      (set! (-> this strip data (-> arg2 current-vert-index) stq x) (-> this mesh mesh s2-0 u))
      (set! (-> this strip data (-> arg2 current-vert-index) stq y) (-> this mesh mesh s2-0 v))
      (cloth-system-method-32 this s1-0 arg0 arg1 arg2)
      )
    )
  (let ((v0-3 (+ (-> arg2 current-vert-index) 1)))
    (set! (-> arg2 current-vert-index) v0-3)
    v0-3
    )
  )

(defmethod cloth-system-method-26 ((this cloth-system))
  (* (+ (-> this cloth-width) -1) (+ (-> this cloth-height) -1))
  (dotimes (v1-3 (+ (-> this cloth-height) -1))
    (dotimes (a1-2 (+ (-> this cloth-width) -1))
      (let* ((a2-0 a1-2)
             (t1-0 (+ (* v1-3 (-> this cloth-width)) a2-0))
             (a2-1 (new 'stack-no-clear 'vector))
             (a3-2 (new 'stack-no-clear 'vector))
             (t0-4 (+ a1-2 (* v1-3 (+ (-> this cloth-width) -1))))
             )
        (vector-!
          a2-1
          (the-as vector (-> this particles data t1-0))
          (the-as vector (-> this particles data (+ (-> this cloth-width) 1 t1-0)))
          )
        (vector-!
          a3-2
          (the-as vector (-> this particles data (+ t1-0 1)))
          (the-as vector (-> this particles data (+ t1-0 (-> this cloth-width))))
          )
        (vector-cross! (-> *normal-array* t0-4) a2-1 a3-2)
        )
      )
    )
  0
  (none)
  )

(defmethod cloth-system-method-33 ((this cloth-system) (lights vu-lights))
  (vu-lights<-light-group! lights (the-as light-group (-> *time-of-day-context* light-group)))
  (none)
  )

(defmethod cloth-system-method-33 ((this cloth-on-skeleton) (lights vu-lights))
  (let ((draw-ctrl (-> (the-as process-focusable (handle->process (-> this owner))) draw)))
    (cond
      ((logtest? (-> draw-ctrl global-effect) (draw-control-global-effect no-textures))
       (logclear! (-> this strip flags) (prim-flags texture-enable))
       (logclear! (-> this strip2 flags) (prim-flags texture-enable))
       (logclear! (-> this strip3 flags) (prim-flags texture-enable))
       )
      (else
        (logior! (-> this strip flags) (prim-flags texture-enable))
        (logior! (-> this strip2 flags) (prim-flags texture-enable))
        (logior! (-> this strip3 flags) (prim-flags texture-enable))
        )
      )
    (calc-vu1-lights lights draw-ctrl #f)
    )
  (none)
  )

(defmethod cloth-system-method-25 ((this cloth-system))
  (local-vars (v0-1 texture-id) (v0-4 texture-id) (a0-72 int) (a0-74 int) (sv-224 int))
  (cond
    ((and (not (logtest? (cloth-flag using-alt-tex) (-> this flags)))
          (and (>= (-> *game-info* skill-total) 600.0) (-> this params alt-tex-name))
          )
     (logior! (-> this flags) (cloth-flag using-alt-tex))
     (set! (-> this strip tex-id) (lookup-texture-id-by-name (-> this params alt-tex-name) (the-as string #f)))
     (set! v0-1
           (when (logtest? (-> this flags) (cloth-flag double-sided))
             (set! (-> this strip2 tex-id) (lookup-texture-id-by-name (-> this params alt-tex-name2) (the-as string #f)))
             (set! v0-1 (lookup-texture-id-by-name (-> this params alt-tex-name3) (the-as string #f)))
             (set! (-> this strip3 tex-id) v0-1)
             v0-1
             )
           )
     )
    ((and (logtest? (cloth-flag using-alt-tex) (-> this flags)) (< (-> *game-info* skill-total) 600.0))
     (logclear! (-> this flags) (cloth-flag using-alt-tex))
     (set! (-> this strip tex-id) (lookup-texture-id-by-name (-> this params tex-name) (the-as string #f)))
     (set! v0-4
           (when (logtest? (-> this flags) (cloth-flag double-sided))
             (set! (-> this strip2 tex-id) (lookup-texture-id-by-name (-> this params tex-name2) (the-as string #f)))
             (set! v0-4 (lookup-texture-id-by-name (-> this params tex-name3) (the-as string #f)))
             (set! (-> this strip3 tex-id) v0-4)
             v0-4
             )
           )
     )
    )
  (when (logtest? (-> this flags) (cloth-flag no-draw))
    (set! (-> this strip num-verts) (the-as uint 0))
    (when (nonzero? (-> this strip2))
      (set! (-> this strip2 num-verts) (the-as uint 0))
      (set! (-> this strip3 num-verts) (the-as uint 0))
      0
      )
    (return 0)
    )
  (set! (-> this strip adnops 0 cmds) (gs-reg64 test-1))
  (set! (-> this strip data0) (new 'static 'gs-test
                                :ate #x1
                                :atst (gs-atest greater-equal)
                                :aref #x26
                                :zte #x1
                                :ztst (gs-ztest greater-equal)
                                )
        )
  (set! (-> this strip2 adnops 0 cmds) (gs-reg64 test-1))
  (set! (-> this strip2 data0) (new 'static 'gs-test
                                 :ate #x1
                                 :atst (gs-atest greater-equal)
                                 :aref #x26
                                 :zte #x1
                                 :ztst (gs-ztest greater-equal)
                                 )
        )
  (set! (-> this strip3 adnops 0 cmds) (gs-reg64 test-1))
  (set! (-> this strip3 data0) (new 'static 'gs-test
                                 :ate #x1
                                 :atst (gs-atest greater-equal)
                                 :aref #x26
                                 :zte #x1
                                 :ztst (gs-ztest greater-equal)
                                 )
        )
  (set! (-> this strip alpha) (new 'static 'gs-alpha))
  (set! (-> this strip2 alpha) (-> this strip alpha))
  (set! (-> this strip3 alpha) (-> this strip alpha))
  (set! (-> this strip clamp) (new 'static 'gs-clamp))
  (set! (-> this strip2 clamp) (new 'static 'gs-clamp))
  (set! (-> this strip3 clamp) (new 'static 'gs-clamp))
  (logior! (-> this strip flags) (prim-flags fog-enable))
  (logior! (-> this strip2 flags) (prim-flags fog-enable))
  (logior! (-> this strip3 flags) (prim-flags fog-enable))
  (cloth-system-method-26 this)
  (let ((s5-0 (new 'stack-no-clear 'current-position-info)))
    (let ((s4-0 0)
          (s3-0 1)
          (s2-0 1)
          (s1-0 -1)
          )
      (set! (-> s5-0 current-vert-index) (the-as uint 0))
      (set! (-> s5-0 face-normal-needs-flip?) #f)
      (cloth-system-method-33 this (-> s5-0 lights))
      (set-vector! (-> s5-0 scale) 128.0 128.0 128.0 128.0)
      (set-vector! (-> s5-0 clamp-col) 255.0 255.0 255.0 128.0)
      (dotimes (s0-0 (+ (-> this cloth-height) -1))
        (set! sv-224 0)
        (while (< sv-224 (-> this cloth-width))
          (set! (-> s5-0 face-normal-needs-flip?) #f)
          (cloth-system-method-29 this s4-0 s3-0 s5-0 0)
          (cloth-system-method-31 this s5-0)
          (cloth-system-method-29 this s4-0 (+ s3-0 s1-0) s5-0 0)
          (cloth-system-method-31 this s5-0)
          (+! s4-0 s2-0)
          (set! sv-224 (+ sv-224 1))
          )
        (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* (-> s5-0 current-vert-index) 32)))
                  )
              (-> (the-as
                    (pointer uint128)
                    (+ (the-as uint (-> this strip data 0 pos)) (* (+ (-> s5-0 current-vert-index) -2) 32))
                    )
                  )
              )
        (set! (-> this strip data (-> s5-0 current-vert-index) stq quad)
              (-> this strip data (+ (-> s5-0 current-vert-index) -2) stq quad)
              )
        (set! (-> this strip data (-> s5-0 current-vert-index) stq z) (the-as float #x1))
        (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip2 data 0 pos)) (* (-> s5-0 current-vert-index) 32)))
                  )
              (-> (the-as
                    (pointer uint128)
                    (+ (the-as uint (-> this strip2 data 0 pos)) (* (+ (-> s5-0 current-vert-index) -2) 32))
                    )
                  )
              )
        (set! (-> this strip2 data (-> s5-0 current-vert-index) stq quad)
              (-> this strip2 data (+ (-> s5-0 current-vert-index) -2) stq quad)
              )
        (set! (-> this strip2 data (-> s5-0 current-vert-index) stq z) (the-as float #x1))
        (+! (-> s5-0 current-vert-index) 1)
        (set! s2-0 (* -1 s2-0))
        (set! s1-0 (* -1 s1-0))
        (+! s4-0 s2-0)
        (if (< s1-0 0)
            (+! s3-0 2)
            )
        )
      )
    (set! (-> this strip num-verts) (-> s5-0 current-vert-index))
    (set! (-> this strip2 num-verts) (-> s5-0 current-vert-index))
    )
  0
  (let ((v1-110 0))
    (let ((a0-67 1))
      (dotimes (a1-27 (-> this cloth-width))
        (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-110 32))))
              (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* a0-67 32))))
              )
        (set! (-> this strip3 data v1-110 stq quad) (-> this strip data a0-67 stq quad))
        (let ((v1-111 (+ v1-110 1)))
          (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-111 32))))
                (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip2 data 0 pos)) (* a0-67 32))))
                )
          (set! (-> this strip3 data v1-111 stq quad) (-> this strip2 data a0-67 stq quad))
          (set! v1-110 (+ v1-111 1))
          )
        (+! a0-67 2)
        )
      )
    (let ((a0-71 (* (-> this cloth-width) 2)))
      (dotimes (a1-28 (+ (-> this cloth-height) -1))
        (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-110 32))))
              (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* a0-71 32))))
              )
        (set! (-> this strip3 data v1-110 stq quad) (-> this strip data a0-71 stq quad))
        (set! (-> this strip3 data v1-110 stq z) 0.0)
        (let ((v1-112 (+ v1-110 1)))
          (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-112 32))))
                (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip2 data 0 pos)) (* a0-71 32))))
                )
          (set! (-> this strip3 data v1-112 stq quad) (-> this strip2 data a0-71 stq quad))
          (set! (-> this strip3 data v1-112 stq z) 0.0)
          (set! v1-110 (+ v1-112 1))
          )
        (if (= (logand a1-28 1) 1)
            (+! a0-71 (* (-> this cloth-width) 4))
            (+! a0-71 2)
            )
        )
      (let ((a1-31 -2))
        (cond
          ((= (logand (-> this cloth-height) 1) 1)
           (set! a0-72 (- a0-71 (* (-> this cloth-width) 4)))
           (set! a1-31 (* -1 a1-31))
           )
          (else
            (set! a0-72 (+ a0-71 a1-31 a1-31))
            )
          )
        (dotimes (a2-44 (-> this cloth-width))
          (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-110 32))))
                (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* a0-72 32))))
                )
          (set! (-> this strip3 data v1-110 stq quad) (-> this strip data a0-72 stq quad))
          (let ((v1-113 (+ v1-110 1)))
            (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-113 32))))
                  (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip2 data 0 pos)) (* a0-72 32))))
                  )
            (set! (-> this strip3 data v1-113 stq quad) (-> this strip2 data a0-72 stq quad))
            (set! v1-110 (+ v1-113 1))
            )
          (+! a0-72 a1-31)
          )
        )
      )
    (if (not (logtest? (-> this cloth-height) 1))
        (set! a0-74 (+ a0-72 2))
        (set! a0-74 (+ a0-72 -2 1))
        )
    (dotimes (a1-38 (+ (-> this cloth-height) -1))
      (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-110 32))))
            (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* a0-74 32))))
            )
      (set! (-> this strip3 data v1-110 stq quad) (-> this strip data a0-74 stq quad))
      (set! (-> this strip3 data v1-110 stq z) 0.0)
      (let ((v1-114 (+ v1-110 1)))
        (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip3 data 0 pos)) (* v1-114 32))))
              (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip2 data 0 pos)) (* a0-74 32))))
              )
        (set! (-> this strip3 data v1-114 stq quad) (-> this strip2 data a0-74 stq quad))
        (set! (-> this strip3 data v1-114 stq z) 0.0)
        (set! v1-110 (+ v1-114 1))
        )
      (if (not (logtest? (- (-> this cloth-height) (+ a1-38 1)) 1))
          (set! a0-74 (- a0-74 (* (-> this cloth-width) 4)))
          (+! a0-74 -2)
          )
      )
    (set! (-> this strip3 num-verts) (the-as uint v1-110))
    )
  0
  )

(defmethod post-physics-update ((this cloth-system))
  (when (logtest? (-> this flags) (cloth-flag no-draw))
    (set! (-> this strip num-verts) (the-as uint 0))
    (when (nonzero? (-> this strip2))
      (set! (-> this strip2 num-verts) (the-as uint 0))
      (set! (-> this strip3 num-verts) (the-as uint 0))
      0
      )
    (return 0)
    )
  (if (logtest? (-> this flags) (cloth-flag double-sided))
      (cloth-system-method-25 this)
      (cloth-system-method-24 this)
      )
  )

(defmethod post-physics-update ((this cloth-on-skeleton))
  (let ((a1-0 (handle->process (-> this owner))))
    (if (and a1-0 (logtest? (-> (the-as process-focusable a1-0) draw status) (draw-control-status on-screen)))
        (call-parent-method this)
        )
    )
  )

(defmethod cloth-system-method-24 ((this cloth-system))
  (local-vars (sv-16 int) (sv-24 int) (sv-32 int) (sv-40 int))
  (cloth-system-method-26 this)
  (set! sv-16 0)
  (set! sv-24 1)
  (set! sv-32 1)
  (set! sv-40 -1)
  (let ((s5-0 (new 'stack-no-clear 'current-position-info)))
    (set! (-> s5-0 current-vert-index) (the-as uint 0))
    (set! (-> s5-0 last-x-index) (the-as uint -1))
    (set! (-> s5-0 last-y-index) (the-as uint -1))
    (set! (-> s5-0 last-2-x-index) (the-as uint -1))
    (set! (-> s5-0 last-2-y-index) (the-as uint -1))
    (set! (-> s5-0 face-normal-needs-flip?) #f)
    (set-vector! (-> s5-0 scale) 128.0 128.0 128.0 128.0)
    (set-vector! (-> s5-0 clamp-col) 255.0 255.0 255.0 128.0)
    (vu-lights<-light-group! (-> s5-0 lights) (the-as light-group (-> *time-of-day-context* light-group)))
    (dotimes (s4-0 (+ (-> this cloth-height) -1))
      (let* ((a0-17 (+ sv-16 (/ (+ sv-32 -1) 2) (* (+ sv-24 (/ (+ sv-40 -1) 2)) (+ (-> this cloth-width) -1))))
             (s3-0 (-> *normal-array* a0-17))
             (s1-0 (-> this particles data (+ sv-16 (* sv-24 (-> this cloth-width)))))
             (s2-0 (new 'stack-no-clear 'vector))
             )
        (vector-! s2-0 (the-as vector s1-0) (math-camera-pos))
        (set! (-> s5-0 face-normal-needs-flip?) (< 0.0 (vector-dot s2-0 s3-0)))
        )
      (cloth-system-method-30 this sv-16 sv-24 s5-0 0)
      (cloth-system-method-30 this sv-16 (+ sv-24 sv-40) s5-0 0)
      (set! (-> s5-0 cross-index0) 2)
      (set! (-> s5-0 cross-index1) 1)
      (set! sv-16 (+ sv-16 sv-32))
      (let ((s3-1 1)
            (s2-1 (+ (-> this cloth-width) -1))
            )
        (while (>= s2-1 s3-1)
          (cloth-system-method-28 this sv-16 sv-24 s5-0)
          (cloth-system-method-28 this sv-16 (+ sv-24 sv-40) s5-0)
          (set! sv-16 (+ sv-16 sv-32))
          (+! s3-1 1)
          )
        )
      (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this strip data 0 pos)) (* (-> s5-0 current-vert-index) 32)))
                )
            (-> (the-as
                  (pointer uint128)
                  (+ (the-as uint (-> this strip data 0 pos)) (* (+ (-> s5-0 current-vert-index) -2) 32))
                  )
                )
            )
      (set! (-> this strip data (-> s5-0 current-vert-index) stq quad)
            (-> this strip data (+ (-> s5-0 current-vert-index) -2) stq quad)
            )
      (set! (-> this strip data (-> s5-0 current-vert-index) stq z) (the-as float #x1))
      (+! (-> s5-0 current-vert-index) 1)
      (set! sv-32 (* -1 sv-32))
      (set! sv-40 (* -1 sv-40))
      (set! sv-16 (+ sv-16 sv-32))
      (if (< sv-40 0)
          (set! sv-24 (+ sv-24 2))
          )
      )
    (set! (-> this strip num-verts) (-> s5-0 current-vert-index))
    )
  0
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod reset-locations ((this cloth-on-skeleton))
  (let ((s5-0 (handle->process (-> this owner))))
    (when (nonzero? (-> this mesh anchor-transforms))
      (dotimes (s4-0 (-> this mesh anchor-transforms length))
        (set! (-> this anchor-points data s4-0 particle-index)
              (the-as uint (-> this mesh anchor-transforms data s4-0 constraint-index))
              )
        (cond
          (s5-0
            (let ((a2-0
                    (-> (the-as process-focusable s5-0)
                        node-list
                        data
                        (-> this mesh anchor-transforms data s4-0 joint)
                        bone
                        transform
                        )
                    )
                  )
              (vector-matrix*!
                (the-as vector (-> this anchor-points data s4-0))
                (the-as vector (-> this mesh anchor-transforms data s4-0))
                a2-0
                )
              )
            (vector-float*!
              (the-as vector (-> this anchor-points data s4-0))
              (the-as vector (-> this anchor-points data s4-0))
              (/ 1.0 (-> this anchor-points data s4-0 anchor-pos w))
              )
            (set! (-> this anchor-points data s4-0 anchor-pos w) 1.0)
            )
          (else
            (set! (-> this anchor-points data s4-0 anchor-pos quad)
                  (-> this mesh anchor-transforms data s4-0 offset quad)
                  )
            )
          )
        )
      )
    (when (nonzero? (-> this mesh sphere-transforms))
      (dotimes (s4-1 (-> this mesh sphere-transforms length))
        (cond
          (s5-0
            (let ((s3-0 (new 'stack-no-clear 'vector)))
              (set! (-> s3-0 quad) (-> this collision-constraints data s4-1 quad))
              (set! (-> s3-0 w) 1.0)
              (vector-matrix*!
                s3-0
                (the-as vector (-> this mesh sphere-transforms data s4-1))
                (-> (the-as process-focusable s5-0)
                    node-list
                    data
                    (-> this mesh sphere-transforms data s4-1 joint)
                    bone
                    transform
                    )
                )
              (vector-float*! s3-0 s3-0 (/ 1.0 (-> s3-0 w)))
              (set! (-> this collision-constraints data s4-1 x) (-> s3-0 x))
              (set! (-> this collision-constraints data s4-1 y) (-> s3-0 y))
              (set! (-> this collision-constraints data s4-1 z) (-> s3-0 z))
              )
            )
          (else
            (set! (-> this collision-constraints data s4-1 quad) (-> this mesh sphere-transforms data s4-1 offset quad))
            )
          )
        (set! (-> this collision-constraints data s4-1 r) (-> this mesh sphere-transforms data s4-1 radius))
        )
      )
    (when (nonzero? (-> this mesh disc-transforms))
      (dotimes (s4-2 (-> this mesh disc-transforms length))
        (cond
          (s5-0
            (vector-matrix*!
              (the-as vector (+ (the-as uint (-> this disc-collision-constraints data 0 origin)) (* 48 s4-2)))
              (the-as vector (-> this mesh disc-transforms data s4-2))
              (-> (the-as process-focusable s5-0)
                  node-list
                  data
                  (-> this mesh disc-transforms data s4-2 joint)
                  bone
                  transform
                  )
              )
            (vector-rotate*!
              (the-as vector (-> this disc-collision-constraints data s4-2))
              (the-as vector (+ (the-as uint (-> this mesh disc-transforms data 0 normal)) (* 48 s4-2)))
              (-> (the-as process-focusable s5-0)
                  node-list
                  data
                  (-> this mesh disc-transforms data s4-2 joint)
                  bone
                  transform
                  )
              )
            )
          (else
            (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> this disc-collision-constraints data 0 origin)) (* 48 s4-2)))
                      )
                  (-> this mesh disc-transforms data s4-2 offset quad)
                  )
            (set! (-> this disc-collision-constraints data s4-2 normal quad)
                  (-> (the-as (pointer uint128) (+ (the-as uint (-> this mesh disc-transforms data 0 normal)) (* 48 s4-2))))
                  )
            )
          )
        (set! (-> this disc-collision-constraints data s4-2 radius) (-> this mesh disc-transforms data s4-2 radius))
        (set! (-> this disc-collision-constraints data s4-2 start-particle-index)
              (-> this mesh disc-transforms data s4-2 start-particle-index)
              )
        (set! (-> this disc-collision-constraints data s4-2 end-particle-index)
              (-> this mesh disc-transforms data s4-2 end-particle-index)
              )
        )
      )
    )
  (none)
  )

(defmethod reset-locations ((this cloth-system))
  0
  (none)
  )

(define *once* #f)

(defmethod debug-draw-spheres ((this cloth-system))
  (dotimes (s5-0 (-> this collision-constraints length))
    (add-debug-sphere
      #t
      (bucket-id debug)
      (-> this collision-constraints data s5-0)
      (-> this collision-constraints data s5-0 r)
      *color-cyan*
      )
    (format *stdcon* "Transform ~d, size ~f~%" s5-0 (* 0.00024414062 (-> this collision-constraints data s5-0 r)))
    )
  (dotimes (s5-1 (-> this disc-collision-constraints length))
    (add-debug-sphere
      #t
      (bucket-id debug)
      (the-as vector (+ (the-as uint (-> this disc-collision-constraints data 0 origin)) (* 48 s5-1)))
      (-> this disc-collision-constraints data s5-1 radius)
      *color-red*
      )
    )
  0
  (none)
  )

(define *cloth-fade-alpha* (new 'static 'gs-alpha :b #x1 :d #x1))

;; WARN: Return type mismatch symbol vs int.
(defmethod cloth-system-method-25 ((this cloth-on-skeleton))
  (call-parent-method this)
  (let ((proc (handle->process (-> this owner))))
    (the-as int (when (and proc (nonzero? (-> (the-as process-drawable proc) draw)))
                  (let ((draw-ctrl (-> (the-as process-focusable proc) draw)))
                    (let ((fade (-> draw-ctrl force-fade)))
                      (when (logtest? (-> draw-ctrl status) (draw-control-status force-fade))
                        (set! (-> this strip data0) (new 'static 'gs-test
                                                      :ate #x1
                                                      :atst (gs-atest greater-equal)
                                                      :aref #x26
                                                      :afail #x1
                                                      :zte #x1
                                                      :ztst (gs-ztest greater-equal)
                                                      )
                              )
                        (set! (-> this strip adnops 0 cmds) (gs-reg64 test-1))
                        (set! (-> this strip alpha) *cloth-fade-alpha*)
                        (dotimes (a0-14 (the-as int (-> this strip num-verts)))
                          (set! (-> this strip data a0-14 col a) fade)
                          )
                        (when (logtest? (-> this flags) (cloth-flag double-sided))
                          (set! (-> this strip2 data0) (new 'static 'gs-test
                                                         :ate #x1
                                                         :atst (gs-atest greater-equal)
                                                         :aref #x26
                                                         :afail #x1
                                                         :zte #x1
                                                         :ztst (gs-ztest greater-equal)
                                                         )
                                )
                          (set! (-> this strip2 adnops 0 cmds) (gs-reg64 test-1))
                          (set! (-> this strip2 alpha) *cloth-fade-alpha*)
                          (set! (-> this strip3 adnops 0 cmds) (gs-reg64 test-1))
                          (set! (-> this strip3 data0) (new 'static 'gs-test
                                                         :ate #x1
                                                         :atst (gs-atest greater-equal)
                                                         :aref #x26
                                                         :afail #x1
                                                         :zte #x1
                                                         :ztst (gs-ztest greater-equal)
                                                         )
                                )
                          (set! (-> this strip3 alpha) *cloth-fade-alpha*)
                          (dotimes (a0-25 (the-as int (-> this strip2 num-verts)))
                            (set! (-> this strip2 data a0-25 col a) fade)
                            )
                          (dotimes (a0-28 (the-as int (-> this strip3 num-verts)))
                            (set! (-> this strip3 data a0-28 col a) fade)
                            )
                          #f
                          )
                        )
                      )
                    )
                  )
            )
    )
  )

(defmethod accumulate-external-forces! ((this cloth-on-skeleton))
  "If this cloth system has the wind flag, calculate the wind force."
  (when (logtest? (-> this flags) (cloth-flag use-parent-momentum))
    (let ((proc (handle->process (-> this owner))))
      (if proc
          (set! (-> this momentum quad) (-> (the-as process-drawable proc) root transv quad))
          )
      )
    )
  (call-parent-method this)
  (none)
  )

;; WARN: Return type mismatch int vs cloth-flag.
(defun symbol->cloth-flags ((arg0 symbol))
  (let ((v1-0 arg0))
    (the-as cloth-flag (cond
                         ((= v1-0 'local-space)
                          #x40000
                          )
                         ((= v1-0 'local-space-xyz)
                          #x80000
                          )
                         ((= v1-0 'local-space-y)
                          #x100000
                          )
                         ((= v1-0 'riding)
                          #x10000
                          )
                         (else
                           0
                           )
                         )
            )
    )
  )

(defmethod cloth-system-cmd-handler ((this cloth-system) (command pair))
  (let ((msg (-> command car)))
    (case msg
      (('scene-reset-frame)
       (if (logtest? (cloth-flag use-old-resets) (-> this flags))
           (logior! (-> this flags) (cloth-flag need-reset))
           (logior! (-> this flags) (cloth-flag local-space))
           )
       )
      (('set-flags 'clear-flags)
       (let ((flags (cloth-flag)))
         (let* ((s3-0 (-> command cdr))
                (a0-9 (-> (the-as pair s3-0) car))
                )
           (while (not (null? s3-0))
             (set! flags (logior (the-as cloth-flag flags) (symbol->cloth-flags (the-as symbol a0-9))))
             (set! s3-0 (-> (the-as pair s3-0) cdr))
             (set! a0-9 (-> (the-as pair s3-0) car))
             )
           )
         (if (= msg 'set-flags)
             (logior! (-> this flags) flags)
             (logclear! (-> this flags) flags)
             )
         )
       )
      (('hide)
       (hide! this)
       )
      (('show)
       (logclear! (-> this flags) (cloth-flag hidden))
       )
      (('wind-strength)
       (set! (-> this wind-constant) (command-get-float (-> (the-as pair (-> command cdr)) car) 0.0))
       )
      (('reset)
       (logior! (-> this flags) (cloth-flag need-reset))
       )
      )
    )
  0
  (none)
  )
