;;-*-Lisp-*-
(in-package goal)

;; name: pov-camera.gc
;; name in dgo: pov-camera
;; dgos: GAME

;; DECOMP BEGINS

(defmethod abort? ((this pov-camera))
  (when (or (and (time-elapsed? (-> this debounce-start-time) (seconds 0.2)) (cpad-pressed? 0 triangle))
            (logtest? (-> this flags) (pov-camera-flag allow-abort))
            )
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
    (when (logtest? (-> this flags) (pov-camera-flag notify-of-abort))
      (send-event (handle->process (-> this notify-handle)) 'notify 'abort-request)
      #t
      )
    )
  )

(defmethod target-grabbed? ((this pov-camera))
  (or (not *target*) (process-grab? *target* #f))
  )

(defmethod target-released? ((this pov-camera))
  (or (not *target*) (process-release? *target*))
  )

(defstate pov-camera-startup (pov-camera)
  :virtual #t
  :code (behavior ()
    (go-virtual pov-camera-start-playing)
    )
  )

(defstate pov-camera-start-playing (pov-camera)
  :virtual #t
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (when (not (logtest? (-> self flags) (pov-camera-flag pcf3)))
      (while (not (target-grabbed? self))
        (suspend)
        )
      )
    (let ((gp-0 0))
      (let ((v1-10 (the-as joint (get-art-by-name-method (-> self draw jgeo) "camera" (the-as type #f)))))
        (if v1-10
            (set! gp-0 (+ (-> v1-10 number) 1))
            )
        )
      (let ((v1-13 (process-spawn othercam self gp-0 #t #t :name "othercam" :to self)))
        (send-event (ppointer->process v1-13) 'mask (-> self mask-to-clear))
        )
      )
    (go-virtual pov-camera-playing)
    )
  )

(defbehavior pov-camera-play-and-reposition pov-camera ((arg0 art-joint-anim) (arg1 vector) (arg2 float))
  (let ((s4-0 #f))
    (ja-no-eval :group! arg0 :num! (seek! max arg2) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((v1-4 (and (not s4-0) (< (the float (+ (-> (ja-group) frames num-frames) -4)) (ja-frame-num 0)))))
        (when v1-4
          (set! s4-0 #t)
          (send-event *camera* 'teleport-to-vector-start-string arg1)
          )
        )
      (suspend)
      (ja :num! (seek! max arg2))
      )
    )
  0
  (none)
  )

(defstate pov-camera-playing (pov-camera)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('abort)
       (when (logtest? (-> self flags) (pov-camera-flag notify-of-abort))
         (logior! (-> self flags) (pov-camera-flag allow-abort))
         (if (= (-> self anim-name type) string)
             (go-virtual pov-camera-abort)
             )
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self debounce-start-time))
    (if (= (-> self anim-name type) string)
        (backup-load-state-and-set-cmds *load-state* (-> self command-list))
        )
    )
  :exit (behavior ()
    (if (= (-> self anim-name type) string)
        (restore-load-state-and-cleanup *load-state*)
        )
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    )
  :code (behavior ()
    (add-setting! 'music-volume 'rel (-> self music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> self sfx-volume-movie) 0)
    (cond
      ((= (-> self anim-name type) string)
       (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (abort? self)
         (suspend)
         (ja :num! (seek!))
         )
       )
      ((= (-> self anim-name type) spool-anim)
       (ja-play-spooled-anim
         (the-as spool-anim (-> self anim-name))
         (the-as art-joint-anim #f)
         (the-as art-joint-anim #f)
         (method-of-object self abort?)
         (spooler-flags blackout-on-stall)
         )
       )
      )
    (go-virtual pov-camera-done-playing)
    )
  :post (behavior ()
    (if (= (-> self anim-name type) string)
        (execute-commands-up-to *load-state* (ja-aframe-num 0))
        )
    (ja-post)
    )
  )

(defstate pov-camera-abort (pov-camera)
  :virtual #t
  :enter (behavior ()
    (logior! (-> self flags) (pov-camera-flag allow-abort))
    )
  :code (behavior ()
    (set-blackout-frames (seconds 0.035))
    (suspend)
    (suspend)
    (go-virtual pov-camera-done-playing)
    )
  )

(defstate pov-camera-done-playing (pov-camera)
  :virtual #t
  :code (behavior ()
    (while (not (target-released? self))
      (suspend)
      )
    (send-event (handle->process (-> self notify-handle)) 'notify 'die)
    (suspend)
    (suspend)
    (cleanup-for-death self)
    (deactivate self)
    )
  )

(defmethod pov-camera-method-28 ((this pov-camera))
  0
  (none)
  )

(defmethod set-stack-size! ((this pov-camera))
  (stack-size-set! (-> this main-thread) 512)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior pov-camera-init-by-other pov-camera ((arg0 vector) (arg1 skeleton-group) (arg2 string) (arg3 pov-camera-flag) (arg4 process-drawable) (arg5 pair))
  (set-stack-size! self)
  (set! (-> *game-info* pov-camera-handle) (process->handle self))
  (set! (-> self flags) arg3)
  (set! (-> self command-list) arg5)
  (set! (-> self music-volume-movie) 100.0)
  (set! (-> self sfx-volume-movie) 100.0)
  (if arg4
      (set! (-> self notify-handle) (process->handle arg4))
      (set! (-> self notify-handle) (the-as handle #f))
      )
  (set-time! (-> self debounce-start-time))
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (when (and (logtest? (-> self flags) (pov-camera-flag inherit-orientation)) arg4)
    (let ((v1-22 (if (type? arg4 process-drawable)
                     arg4
                     )
                 )
          )
      (quaternion-copy! (-> self root quat) (-> v1-22 root quat))
      )
    )
  (initialize-skeleton self arg1 (the-as pair 0))
  (logior! (-> self draw status) (draw-control-status no-draw-bounds))
  (logior! (-> self skel status) (joint-control-status sync-math))
  (set! (-> self anim-name) arg2)
  (cond
    ((= (-> arg2 type) string)
     (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
     (let ((s5-1 (get-art-by-name (-> self draw art-group) arg2 art-joint-anim)))
       (if (not s5-1)
           (go process-drawable-art-error arg2)
           )
       (ja-channel-set! 1)
       (set! (-> self skel root-channel 0 frame-group) s5-1)
       )
     )
    ((= (-> arg2 type) spool-anim)
     )
    )
  (set! (-> self mask-to-clear) (process-mask movie enemy platform projectile))
  (set! (-> self event-hook) (lambda :behavior pov-camera
                               ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
                               (case arg2
                                 (('mask)
                                  (let ((v0-0 (the-as number (-> arg3 param 0))))
                                    (set! (-> self mask-to-clear) (the-as process-mask v0-0))
                                    v0-0
                                    )
                                  )
                                 (('music-movie-volume)
                                  (set! (-> self music-volume-movie) (the-as float (-> arg3 param 0)))
                                  )
                                 (('sfx-movie-volume)
                                  (set! (-> self sfx-volume-movie) (the-as float (-> arg3 param 0)))
                                  )
                                 )
                               )
        )
  (pov-camera-method-28 self)
  (go-virtual pov-camera-startup)
  (none)
  )

(defun othercam-calc ((arg0 float))
  (set! (-> *camera-other-fov* data) (* 2.0 (atan (/ 14.941477 (* 20.3 arg0)) 1.0)))
  )

(defstate othercam-running (othercam)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('die)
       (set! v0-0 #t)
       (set! (-> self die?) (the-as symbol v0-0))
       v0-0
       )
      (('joint)
       (cond
         ((type? (-> block param 0) string)
          (let ((v1-7 (the-as joint (get-art-by-name-method
                                      (-> (the-as process-drawable (-> self hand process 0)) draw jgeo)
                                      (the-as string (-> block param 0))
                                      (the-as type #f)
                                      )
                              )
                      )
                )
            (when v1-7
              (set! v0-0 (+ (-> v1-7 number) 1))
              (set! (-> self cam-joint-index) (the-as int v0-0))
              v0-0
              )
            )
          )
         ((not (logtest? (-> block param 0) 7))
          (set! v0-0 (/ (the-as int (-> block param 0)) 8))
          (set! (-> self cam-joint-index) (the-as int v0-0))
          v0-0
          )
         )
       )
      (('target)
       (set! v0-0 (process->handle (the-as process (-> block param 0))))
       (set! (-> self hand) (the-as handle v0-0))
       v0-0
       )
      (('mask)
       (set! v0-0 (-> block param 0))
       (set! (-> self mask-to-clear) (the-as process-mask v0-0))
       v0-0
       )
      )
    )
  :enter (behavior ()
    (hide-hud-quick #f)
    (case (-> self spooling?)
      (('logo 'scene-player)
       )
      (else
        (add-setting! 'process-mask 'set 0.0 (-> self mask-to-clear))
        (add-setting! 'movie (process->ppointer self) 0.0 0)
        (if (not (-> self border-value))
            (add-setting! 'border-mode (-> self border-value) 0.0 0)
            )
        )
      )
    (set! (-> self had-valid-frame) #f)
    (let ((gp-0 (-> self hand process 0)))
      (vector<-cspace!
        (-> self old-pos)
        (-> (the-as process-drawable gp-0) node-list data (-> self cam-joint-index))
        )
      (let ((v1-20 (-> (the-as process-drawable gp-0) node-list data (-> self cam-joint-index) bone transform)))
        (vector-normalize-copy! (-> self old-mat-z) (-> v1-20 fvec) -1.0)
        )
      )
    (apply-settings *setting-control*)
    )
  :exit (behavior ()
    (remove-setting! 'process-mask)
    (apply-settings *setting-control*)
    )
  :code (behavior ()
    (until #f
      (let ((s2-0 (-> self hand process 0)))
        (when (not s2-0)
          (format #t "ERROR<GMJ>: othercam parent invalid~%")
          (deactivate self)
          )
        (set! (-> *camera-other-root* quad) (-> (the-as process-drawable s2-0) root trans quad))
        (let ((s4-0 (-> (the-as process-drawable s2-0) node-list data (-> self cam-joint-index) bone transform))
              (s3-0 (-> (the-as process-drawable s2-0) node-list data (-> self cam-joint-index) bone scale))
              (gp-0 (new 'stack-no-clear 'vector))
              (s5-0 (new 'stack-no-clear 'vector))
              (s1-0
                (or (!= (-> self spooling?) #t)
                    (logtest? (-> (the-as process-drawable s2-0) skel status) (joint-control-status valid-spooled-frame))
                    )
                )
              )
          (vector<-cspace! s5-0 (-> (the-as process-drawable s2-0) node-list data (-> self cam-joint-index)))
          (vector-normalize-copy! gp-0 (-> s4-0 fvec) -1.0)
          (cond
            ((< (vector-length (-> s4-0 fvec)) 0.1)
             (set-blackout-frames (seconds 0.017))
             (if (not (logtest? (-> (the-as process-drawable s2-0) draw status) (draw-control-status no-draw no-draw-temp)))
                 (format 0 "ERROR: other camera zero matrix!~%")
                 )
             )
            (s1-0
              (when (not (-> self had-valid-frame))
                (set! (-> self had-valid-frame) #t)
                (set! (-> self old-pos quad) (-> s5-0 quad))
                (set! (-> self old-mat-z quad) (-> gp-0 quad))
                )
              (set! (-> *camera-other-trans* quad) (-> s5-0 quad))
              (vector-normalize-copy! (-> *camera-other-matrix* rvec) (-> s4-0 rvec) -1.0)
              (set! (-> *camera-other-matrix* rvec w) 0.0)
              (vector-normalize-copy! (-> *camera-other-matrix* uvec) (-> s4-0 uvec) 1.0)
              (set! (-> *camera-other-matrix* uvec w) 0.0)
              (vector-normalize-copy! (-> *camera-other-matrix* fvec) (-> s4-0 fvec) -1.0)
              (set! (-> *camera-other-matrix* fvec w) 0.0)
              (vector-reset! (-> *camera-other-matrix* trans))
              (set! (-> self fov) (othercam-calc (-> s3-0 x)))
              (set! *camera-look-through-other* 2)
              (set! (-> self old-pos quad) (-> s5-0 quad))
              (set! (-> self old-mat-z quad) (-> gp-0 quad))
              )
            )
          )
        )
      (suspend)
      (let ((a0-27 (-> self hand process 0)))
        (when (or (-> self die?) (and (not (-> self survive-anim-end?)) (ja-anim-done? a0-27)))
          (let ((gp-1 (current-time)))
            (while (and (not (time-elapsed? gp-1 (seconds 60)))
                        (or (and (-> self entity) (not (is-object-visible? (-> self level) (-> self entity extra vis-id))))
                            (< 81920.0 (vector-vector-distance (camera-pos) (-> *math-camera* trans)))
                            )
                        )
              (suspend)
              )
            )
          (deactivate self)
          )
        )
      )
    #f
    )
  )

(defbehavior othercam-init-by-other othercam ((arg0 pov-camera) (arg1 int) (arg2 symbol) (arg3 symbol))
  (set! (-> self spooling?) arg3)
  (case (-> self spooling?)
    (('logo)
     )
    (else
      (set! (-> *game-info* other-camera-handle) (process->handle self))
      )
    )
  (set! (-> self hand) (process->handle arg0))
  (set! (-> self cam-joint-index) arg1)
  (logclear! (-> self mask) (process-mask freeze pause menu actor-pause))
  (set! (-> self border-value) #f)
  (set! (-> self die?) #f)
  (set! (-> self survive-anim-end?) arg2)
  (set! (-> self mask-to-clear) (process-mask movie enemy platform projectile))
  (set! (-> self event-hook) (-> othercam-running event))
  (go othercam-running)
  0
  (none)
  )
