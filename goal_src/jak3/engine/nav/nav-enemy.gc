;;-*-Lisp-*-
(in-package goal)

;; name: nav-enemy.gc
;; name in dgo: nav-enemy
;; dgos: GAME

;; DECOMP BEGINS

(defmethod copy! ((this nav-enemy-info) (arg0 nav-enemy-info))
  (mem-copy! (&-> this type) (&-> arg0 type) 524)
  0
  (none)
  )

(defmethod get-enemy-aware ((this nav-enemy) (arg0 enemy-aware))
  (let* ((t9-0 (method-of-type enemy get-enemy-aware))
         (s5-0 (t9-0 this arg0))
         )
    (if (and (>= 1 (the-as int (-> this focus aware))) (< 1 (the-as int s5-0)))
        (nav-enemy-method-172 this)
        )
    s5-0
    )
  )

(defmethod event-handler ((this nav-enemy) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('nav-mesh-kill)
     (deactivate this)
     #t
     )
    (('nav-mesh-new)
     (set! (-> this water-max-height) (-> this nav state mesh water-max-height))
     #t
     )
    (('change-nav-mesh)
     (let ((a0-6 (nav-mesh-from-res-tag (-> this entity) 'nav-mesh-actor (the-as int (-> arg3 param 0)))))
       (if a0-6
           (change-to a0-6 this)
           )
       )
     )
    (('debug-control-on)
     (go (method-of-object this debug-control))
     )
    (('debug-control-off)
     (go-best-state this)
     )
    (else
      ((method-of-type enemy event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(define *nav-enemy-dummy-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :center (new 'static 'vector :w (the-as float #x28))
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -4096.0)
                                           )
                               )
  )

(defmethod nav-enemy-method-164 ((this nav-enemy))
  (cond
    ((zero? (-> this path))
     (go process-drawable-art-error "no path")
     )
    (else
      (let ((s4-0 (-> this path curve num-cverts)))
        (if (<= s4-0 0)
            (go process-drawable-art-error "no path")
            )
        (let ((s2-0 (rnd-int this s4-0))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (countdown (s3-0 s4-0)
            (get-point-in-path! (-> this path) s5-0 (the float s2-0) 'interp)
            (if (< 4096.0 (vector-vector-xz-distance s5-0 (-> this root trans)))
                (goto cfg-11)
                )
            (set! s2-0 (mod (+ s2-0 1) s4-0))
            )
          (label cfg-11)
          (let ((v1-19 (-> this nav state)))
            (logclear! (-> v1-19 flags) (nav-state-flag directional-mode))
            (logior! (-> v1-19 flags) (nav-state-flag target-poly-dirty))
            (set! (-> v1-19 target-pos quad) (-> s5-0 quad))
            )
          )
        )
      0
      )
    )
  0
  (none)
  )

(defmethod nav-enemy-method-165 ((this nav-enemy) (arg0 vector) (arg1 vector))
  (closest-point-on-mesh (-> this nav) arg0 arg1 (the-as nav-poly #f))
  0
  (none)
  )

(defmethod nav-enemy-method-166 ((this nav-enemy) (arg0 vector) (arg1 vector))
  (let* ((v1-1 (vector+! (new 'stack-no-clear 'vector) (-> this root trans) (-> this root transv)))
         (s2-1 (vector-! (new 'stack-no-clear 'vector) v1-1 arg1))
         (s1-0 (new 'stack-no-clear 'vector))
         (f30-0 0.0)
         (f26-0 7281.778)
         (f24-0 f26-0)
         )
    (set! (-> s2-1 y) 0.0)
    (vector-normalize-copy! s1-0 s2-1 1.0)
    (let ((f28-0 0.0)
          (s3-0 (new 'stack-no-clear 'vector))
          )
      (dotimes (s0-0 7)
        (vector-rotate-y! s2-1 s1-0 f30-0)
        (vector-normalize! s2-1 (-> this enemy-info run-travel-speed))
        (vector+! s2-1 s2-1 (-> this root trans))
        (nav-enemy-method-165 this arg0 s2-1)
        (let ((f0-2 (vector-vector-xz-distance arg1 arg0)))
          (when (< f28-0 f0-2)
            (set! f28-0 f0-2)
            (set! (-> s3-0 quad) (-> arg0 quad))
            )
          )
        (set! f30-0 (cond
                      ((= (logand s0-0 1) 1)
                       (+! f30-0 f24-0)
                       f30-0
                       )
                      (else
                        (- f30-0 f24-0)
                        )
                      )
              )
        (+! f24-0 f26-0)
        )
      (when (and (!= f28-0 0.0) (< 4096.0 (vector-vector-xz-distance (-> this root trans) s3-0)))
        (set! (-> arg0 quad) (-> s3-0 quad))
        arg0
        )
      )
    )
  )

(defmethod nav-enemy-method-167 ((this nav-enemy))
  (let ((v1-2 (handle->process (-> this focus handle))))
    (if v1-2
        (nav-enemy-method-166 this (new 'stack-no-clear 'vector) (get-trans (the-as process-focusable v1-2) 0))
        )
    )
  )

(defmethod enemy-method-109 ((this nav-enemy))
  (let ((gp-0 (-> this root))
        (s3-0 (-> this nav state))
        )
    (do-navigation-to-destination s3-0 (-> gp-0 trans))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (cond
        ((logtest? (-> s3-0 flags) (nav-state-flag in-mesh))
         (set! (-> s5-0 quad) (-> gp-0 trans quad))
         )
        (else
          (if (or (not (closest-point-on-mesh (-> this nav) s5-0 (-> gp-0 trans) (-> s3-0 current-poly)))
                  (let ((f0-0 32768.0))
                    (< (* f0-0 f0-0) (vector-vector-xz-distance-squared s5-0 (-> gp-0 trans)))
                    )
                  (< (- (-> gp-0 trans y) (-> s5-0 y)) -8192.0)
                  )
              (return #t)
              )
          )
        )
      )
    )
  #f
  )

(defmethod enemy-common-post ((this nav-enemy))
  (if (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status on-screen)))
      (set-time! (-> this last-draw-time))
      )
  (update-focus this)
  (when *target*
    (if *target*
        (look-at!
          (-> *target* neck)
          (the-as vector (-> this root root-prim prim-core))
          (if (logtest? (-> this enemy-flags) (enemy-flag cam-attack-mode))
              'attacking
              )
          this
          )
        )
    )
  (when (nonzero? (-> this neck))
    (cond
      ((logtest? (-> this enemy-flags) (enemy-flag look-at-focus))
       (let ((a0-7 (handle->process (-> this focus handle))))
         (if a0-7
             (target-set! (-> this neck) (get-trans (the-as process-focusable a0-7) 2))
             )
         )
       )
      ((logtest? (-> this enemy-flags) (enemy-flag look-at-move-dest))
       (let ((s5-1 (-> this move-dest))
             (v1-39
               (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data (-> this enemy-info neck-joint)))
               )
             (a1-6 (new 'stack-no-clear 'vector))
             )
         (set! (-> a1-6 x) (-> s5-1 x))
         (set! (-> a1-6 y) (-> v1-39 y))
         (set! (-> a1-6 z) (-> s5-1 z))
         (set! (-> a1-6 w) 1.0)
         (target-set! (-> this neck) a1-6)
         )
       )
      )
    )
  (when (and (logtest? (-> this enemy-flags) (enemy-flag auto-reset-penetrate))
             (time-elapsed? (-> this auto-reset-penetrate-time) (seconds 0.1))
             )
    (logclear! (-> this enemy-flags) (enemy-flag auto-reset-penetrate))
    (set! (-> this root penetrated-by) (get-penetrated-by this))
    (let ((v1-54 0))
      (if (logtest? (penetrate knocked) (-> this root penetrate-using))
          (set! v1-54 (logior (shl 2 32) v1-54))
          )
      (set! (-> this root penetrate-using) (the-as penetrate v1-54))
      )
    )
  (if (logtest? (-> this enemy-flags) (enemy-flag victory))
      (check-victory this)
      )
  (if (logtest? (enemy-flag check-water checking-water) (-> this enemy-flags))
      (check-water this)
      )
  (let ((v1-65 (-> this restore-nav-radius-time)))
    (when (nonzero? v1-65)
      (when (>= (current-time) v1-65)
        (set! (-> this restore-nav-radius-time) 0)
        (set! (-> this root nav-radius) (-> this nav-radius-backup))
        )
      )
    )
  (if (and *debug-segment* (-> this enemy-info debug-draw-neck) (nonzero? (-> this neck)))
      (joint-mod-debug-draw (-> this neck))
      )
  (ja-post)
  0
  (none)
  )

(defmethod move-above-ground! ((this nav-enemy) (arg0 vector) (arg1 move-above-ground-params))
  (let ((t9-0 (method-of-type enemy move-above-ground!)))
    (t9-0 this arg0 arg1)
    )
  (do-navigation-to-destination (-> this nav state) (-> this root trans))
  0
  (none)
  )

(defmethod nav-enemy-method-188 ((this nav-enemy))
  (let ((v1-2 (-> this nav state current-poly)))
    (when (and v1-2 (logtest? (-> v1-2 pat) 4) (!= (-> v1-2 link) 255))
      (let ((v1-6 (-> this nav state mesh link-array (-> v1-2 link) dest-mesh)))
        (if v1-6
            (change-to v1-6 this)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod nav-enemy-method-187 ((this nav-enemy))
  (nav-enemy-method-188 this)
  (cond
    ((nav-enemy-method-185 this)
     (let ((s5-0 (-> this nav)))
       (when (logtest? (-> s5-0 state flags) (nav-state-flag at-gap))
         (let ((s4-0 (new 'stack-no-clear 'nav-gap-info)))
           (when (plan-over-pat1-polys-using-route (-> s5-0 state) s4-0)
             (set! (-> this enemy-flags)
                   (the-as enemy-flag (logior (enemy-flag jump-check-blocked) (-> this enemy-flags)))
                   )
             (send-event this 'jump 1 (-> s4-0 dest))
             )
           )
         )
       (cond
         ((logtest? (enemy-flag ef39) (-> this enemy-flags))
          (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag ef39))))
          )
         (else
           (when (not (logtest? (enemy-flag ef43) (-> this enemy-flags)))
             (normalize-heading! this s5-0)
             (nav-enemy-method-161 this s5-0)
             )
           )
         )
       (cond
         ((logtest? (-> s5-0 state flags) (nav-state-flag blocked))
          (if (zero? (-> this blocked-start-time))
              (set-time! (-> this blocked-start-time))
              )
          )
         (else
           (set! (-> this blocked-start-time) 0)
           0
           )
         )
       )
     )
    (else
      (set! (-> this blocked-start-time) 0)
      0
      )
    )
  (enemy-common-post this)
  (update-transforms (-> this root))
  0
  (none)
  )

(defmethod nav-enemy-method-163 ((this nav-enemy))
  (navigate-v1! (-> this nav state))
  0
  (none)
  )

(defmethod normalize-heading! ((this nav-enemy) (arg0 nav-control))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let ((a1-1 (-> arg0 state)))
      (set! (-> s5-0 quad) (-> a1-1 heading quad))
      )
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)
    ;; og:preserve-this modified for PC, see comment near definition in collide-shape-h.gc
    (normalized-heading-to-quaternion! (-> this root quat) s5-0)
    )
  (quaternion-normalize! (-> this root quat))
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod copy-nav-state-vel! ((this nav-enemy) (arg0 vector))
  (set! (-> arg0 quad) (-> this nav state velocity quad))
  (none)
  )

(defmethod nav-enemy-method-161 ((this nav-enemy) (arg0 nav-control))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (copy-nav-state-vel! this s5-0)
    (let ((v1-3 (-> this root transv)))
      (set! (-> v1-3 x) (-> s5-0 x))
      (set! (-> v1-3 z) (-> s5-0 z))
      )
    )
  (cond
    ((should-move-to-ground? this)
     (if (focus-test? this under-water)
         (accelerate-fall! this (-> this root transv))
         (+! (-> this root transv y) (* (-> this enemy-info movement-gravity) (seconds-per-frame)))
         )
     (let ((a2-0 (new 'stack-no-clear 'move-above-ground-params)))
       (let ((v1-17 (-> this enemy-info)))
         (set! (-> a2-0 gnd-collide-with) (-> this gnd-collide-with))
         (set! (-> a2-0 popup) 8192.0)
         (set! (-> a2-0 dont-move-if-overlaps?) #t)
         (set! (-> a2-0 hover-if-no-ground?) (-> v1-17 hover-if-no-ground))
         (set! (-> a2-0 overlaps-params options) (overlaps-others-options oo0 oo2))
         (set! (-> a2-0 overlaps-params collide-with-filter) (-> v1-17 overlaps-others-collide-with-filter))
         )
       (set! (-> a2-0 overlaps-params tlist) *touching-list*)
       (-> a2-0 overlaps-params)
       (move-above-ground! this (-> this root transv) a2-0)
       )
     )
    (else
      (let ((a2-1 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a2-1 options) (overlaps-others-options oo0))
        (set! (-> a2-1 collide-with-filter) (-> this enemy-info overlaps-others-collide-with-filter))
        (set! (-> a2-1 tlist) *touching-list*)
        (integrate-for-enemy-no-mtg (-> this root) (-> this root transv) a2-1)
        )
      )
    )
  0
  (none)
  )

(defmethod nav-enemy-method-181 ((this nav-enemy))
  (if (not (logtest? (enemy-flag ef37) (-> this enemy-flags)))
      (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> this enemy-flags))))
      )
  (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> this enemy-flags))))
  (set! (-> this nav callback-info) (-> this enemy-info callback-info))
  0
  (none)
  )

(defmethod nav-enemy-method-182 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag ef37))))
  (set! (-> this nav callback-info) *null-nav-callback-info*)
  0
  (none)
  )

(defmethod nav-enemy-method-183 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> this enemy-flags))))
  0
  (none)
  )

(defmethod nav-enemy-method-184 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag ef38))))
  0
  (none)
  )

(defmethod nav-enemy-method-185 ((this nav-enemy))
  (logtest? (enemy-flag ef37) (-> this enemy-flags))
  )

(defmethod nav-enemy-method-186 ((this nav-enemy))
  (logtest? (enemy-flag ef38) (-> this enemy-flags))
  )

(defmethod nav-enemy-method-168 ((this nav-enemy) (arg0 vector))
  (let ((v1-0 (-> this nav))
        (a0-1 arg0)
        (a1-1 (new 'stack-no-clear 'nav-poly))
        )
    (vector-! (the-as vector (-> a1-1 vertex)) a0-1 (the-as vector (-> v1-0 state mesh bounds)))
    (set! (-> a1-1 vertex1 x) (-> v1-0 nearest-y-threshold))
    (set! (-> a1-1 data 20) (the-as uint 2))
    (nav-mesh-method-45 (-> v1-0 state mesh) a1-1)
    )
  )

(defmethod nav-enemy-method-169 ((this nav-enemy) (arg0 vector))
  (let ((f1-0 (-> this root trans y))
        (f0-0 (-> arg0 y))
        (v1-1 (-> this fact))
        )
    (and (< f0-0 (+ f1-0 (-> v1-1 notice-top)))
         (and (< (- f1-0 (-> v1-1 notice-bottom)) f0-0)
              (let ((v1-3 (-> this nav))
                    (a0-1 arg0)
                    (a1-1 (new 'stack-no-clear 'nav-poly))
                    )
                (vector-! (the-as vector (-> a1-1 vertex)) a0-1 (the-as vector (-> v1-3 state mesh bounds)))
                (set! (-> a1-1 vertex1 x) (-> v1-3 nearest-y-threshold))
                (set! (-> a1-1 data 20) (the-as uint 2))
                (nav-mesh-method-45 (-> v1-3 state mesh) a1-1)
                )
              )
         )
    )
  )

(defmethod is-notice-point-in-mesh? ((this nav-enemy) (arg0 vector))
  (let ((f1-0 (-> this root trans y))
        (f0-0 (-> arg0 y))
        (v1-1 (-> this fact))
        )
    (and (< f0-0 (+ f1-0 (-> v1-1 notice-top)))
         (and (< (- f1-0 (-> v1-1 notice-bottom)) f0-0)
              (is-in-mesh? (-> this nav) arg0 (-> this enemy-info notice-nav-radius))
              )
         )
    )
  )

(defmethod is-pfoc-in-mesh? ((this nav-enemy) (arg0 process-focusable) (arg1 vector))
  (if (and arg0 (not arg1))
      (set! arg1 (get-trans arg0 1))
      )
  (when arg1
    (let* ((f0-0 (-> arg1 y))
           (v1-4 (-> this root))
           (f1-0 (-> v1-4 trans y))
           (a0-2 (-> this fact))
           )
      (when (and (< f0-0 (+ f1-0 (-> a0-2 notice-top))) (< (- f1-0 (-> a0-2 notice-bottom)) f0-0))
        (let* ((f30-0 (-> this enemy-info notice-nav-radius))
               (f0-1 f30-0)
               )
          (or (>= (* f0-1 f0-1) (vector-vector-xz-distance-squared (-> v1-4 trans) arg1))
              (is-in-mesh? (-> this nav) arg1 f30-0)
              )
          )
        )
      )
    )
  )

(defmethod nav-enemy-method-172 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag ef40))))
  (set-time! (-> this frustration-time))
  (let ((v1-7 (handle->process (-> this focus handle))))
    (if v1-7
        (set! (-> this frustration-point quad) (-> (get-trans (the-as process-focusable v1-7) 1) quad))
        )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod nav-enemy-method-171 ((this nav-enemy))
  (let ((s5-0 (handle->process (-> this focus handle))))
    (cond
      ((or (not s5-0)
           (< 6144.0 (vector-vector-distance (get-trans (the-as process-focusable s5-0) 1) (-> this frustration-point)))
           (< (-> this enemy-info frustration-distance)
              (vector-vector-xz-distance (get-trans (the-as process-focusable s5-0) 0) (-> this root trans))
              )
           )
       (nav-enemy-method-172 this)
       )
      (else
        (when (time-elapsed? (-> this frustration-time) (+ (-> this reaction-time) (-> this enemy-info frustration-time)))
          (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag ef40) (-> this enemy-flags))))
          0
          )
        )
      )
    )
  (none)
  )

(defmethod nav-enemy-method-173 ((this nav-enemy))
  (set! (-> this blocked-start-time) 0)
  0
  (none)
  )

(defmethod nav-enemy-method-174 ((this nav-enemy))
  (let ((v1-0 (-> this blocked-start-time)))
    (and (nonzero? v1-0) (time-elapsed? v1-0 (-> this enemy-info blocked-time)))
    )
  )

(defmethod nav-enemy-method-175 ((this nav-enemy))
  (if (-> this enemy-info use-momentum)
      (logior! (-> this nav flags) (nav-control-flag use-momentum))
      (logclear! (-> this nav flags) (nav-control-flag use-momentum))
      )
  0
  (none)
  )

(defmethod nav-enemy-method-178 ((this nav-enemy))
  (let ((v1-0 (-> this nav)))
    (set! (-> v1-0 target-speed) 0.0)
    )
  0
  (let ((v1-3 (-> this nav state)))
    (set! (-> v1-3 speed) 0.0)
    )
  0
  (let ((v1-5 (-> this nav)))
    (set! (-> v1-5 acceleration) (-> this enemy-info walk-acceleration))
    )
  0
  0
  (none)
  )

(defmethod nav-enemy-method-176 ((this nav-enemy))
  (let ((v1-0 (-> this nav)))
    (set! (-> v1-0 target-speed) (-> this enemy-info walk-travel-speed))
    )
  0
  (let ((v1-2 (-> this nav)))
    (set! (-> v1-2 acceleration) (-> this enemy-info walk-acceleration))
    )
  0
  (let ((v1-4 (-> this nav)))
    (set! (-> v1-4 turning-acceleration) (-> this enemy-info walk-turning-acceleration))
    )
  0
  0
  (none)
  )

(defmethod nav-enemy-method-177 ((this nav-enemy))
  (let ((v1-0 (-> this nav)))
    (set! (-> v1-0 target-speed) (-> this enemy-info run-travel-speed))
    )
  0
  (let ((v1-2 (-> this nav)))
    (set! (-> v1-2 acceleration) (-> this enemy-info run-acceleration))
    )
  0
  (let ((v1-4 (-> this nav)))
    (set! (-> v1-4 turning-acceleration) (-> this enemy-info run-turning-acceleration))
    )
  0
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod init-enemy-info! ((this nav-enemy) (arg0 nav-enemy-info))
  (set! (-> this enemy-info) arg0)
  (set! (-> arg0 callback-info) *default-nav-callback-info*)
  (when (and (!= (-> this enemy-info neck-joint) -1) (zero? (-> this neck)))
    (set! (-> this neck)
          (new 'process 'joint-mod (joint-mod-mode flex-blend) this (-> this enemy-info neck-joint))
          )
    (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> this neck up) (the-as uint 1))
    (set! (-> this neck nose) (the-as uint 2))
    (set! (-> this neck ear) (the-as uint 0))
    (set! (-> this neck max-dist) 102400.0)
    (set! (-> this neck ignore-angle) 16384.0)
    )
  (none)
  )

;; WARN: Return type mismatch int vs object.
(defmethod init-enemy-defaults! ((this nav-enemy) (arg0 nav-enemy-info))
  (local-vars (sv-16 res-tag))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (when (coin-flip? this)
      (let ((a0-2 (-> this node-list data 2)))
        (set! (-> a0-2 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint-flip-z!))
        (set! (-> a0-2 param1) #f)
        (set! (-> a0-2 param2) #f)
        )
      (logior! (-> this enemy-flags) (enemy-flag drawn-mirrored))
      )
    (logior! (-> this mask) (process-mask enemy))
    (logior! (-> this mask) (process-mask actor-pause))
    (logior! (-> this enemy-flags) (enemy-flag actor-pause-backup))
    (set! (-> this nav-radius-backup) (-> this root nav-radius))
    (init-enemy-info! this arg0)
    (set! (-> this enemy-info callback-info) *default-nav-callback-info*)
    (set! (-> this ragdoll-proc) (the-as handle #f))
    (let ((a1-2 (-> this enemy-info idle-anim-script)))
      (if a1-2
          (init! (-> this idle-anim-player) a1-2)
          )
      )
    (if (-> this draw shadow)
        (set! (-> this draw shadow-ctrl) (new
                                           'process
                                           'shadow-control
                                           (-> this enemy-info shadow-min-y)
                                           (-> this enemy-info shadow-max-y)
                                           (-> this enemy-info shadow-locus-dist)
                                           (the-as vector #f)
                                           (shadow-flags shdf00 shdf04)
                                           245760.0
                                           )
              )
        (set! (-> this draw shadow-ctrl) *nav-enemy-dummy-shadow-control*)
        )
    (get-nav-control this (-> arg0 nav-mesh))
    (set! (-> this water-max-height) (-> this nav state mesh water-max-height))
    (let ((v1-32 this))
      (set! (-> v1-32 enemy-flags) (the-as enemy-flag (logclear (-> v1-32 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-32 nav callback-info) *null-nav-callback-info*)
      )
    0
    (let ((v1-35 this))
      (set! (-> v1-35 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-35 enemy-flags))))
      )
    0
    (logior! (-> this nav flags) (nav-control-flag display-marks limit-rotation-rate))
    (logior! (-> this nav flags) (nav-control-flag update-heading-from-facing))
    (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag ef44) (-> this enemy-flags))))
    (let ((v1-46 (-> this nav)))
      (set! (-> v1-46 target-speed) 0.0)
      )
    0
    (let ((v1-48 (-> this nav)))
      (set! (-> v1-48 acceleration) (-> this enemy-info walk-acceleration))
      )
    0
    (let ((v1-50 (-> this nav)))
      (set! (-> v1-50 turning-acceleration) (-> this enemy-info walk-turning-acceleration))
      )
    0
    (let ((v1-52 (-> this nav)))
      (set! (-> v1-52 max-rotation-rate) (-> this enemy-info maximum-rotation-rate))
      )
    0
    (nav-enemy-method-175 this)
    (set! (-> this path) (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f))
    (when (and (zero? (-> this path curve num-cverts)) (-> this entity))
      (set! (-> this path curve num-cverts) 3)
      (set! (-> this path curve cverts) (-> (new 'process 'vector-array 3) data))
      (logclear! (-> this path flags) (path-control-flag not-found))
      (let ((v1-69 (-> this path curve cverts 0)))
        (let ((a0-33 (-> this entity trans)))
          (let ((a1-9 *x-vector*))
            (let ((a2-4 6144.0))
              (.mov vf7 a2-4)
              )
            (.lvf vf5 (&-> a1-9 quad))
            )
          (.lvf vf4 (&-> a0-33 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-69 quad) vf6)
        )
      (let ((v1-72 (-> this path curve cverts 1)))
        (let ((a0-35 (-> this entity trans)))
          (let ((a1-10 *x-vector*))
            (let ((a2-6 -6144.0))
              (.mov vf7 a2-6)
              )
            (.lvf vf5 (&-> a1-10 quad))
            )
          (.lvf vf4 (&-> a0-35 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-72 quad) vf6)
        )
      (let ((v1-75 (-> this path curve cverts 2)))
        (let ((a0-37 (-> this entity trans)))
          (let ((a1-11 *z-vector*))
            (let ((a2-8 6144.0))
              (.mov vf7 a2-8)
              )
            (.lvf vf5 (&-> a1-11 quad))
            )
          (.lvf vf4 (&-> a0-37 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-75 quad) vf6)
        )
      )
    (if (and (nonzero? (-> this path)) (nonzero? (-> this path curve num-cverts)))
        (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
        )
    (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
        (set! (-> this hit-points) (* 2.0 (-> this enemy-info default-hit-points)))
        (set! (-> this hit-points) (-> this enemy-info default-hit-points))
        )
    (let* ((v1-91 *game-info*)
           (a0-42 (+ (-> v1-91 attack-id) 1))
           )
      (set! (-> v1-91 attack-id) a0-42)
      (set! (-> this attack-id) a0-42)
      )
    (let* ((v1-92 *game-info*)
           (a0-44 (+ (-> v1-92 attack-id) 1))
           )
      (set! (-> v1-92 attack-id) a0-44)
      (set! (-> this persistent-attack-id) a0-44)
      )
    (set! (-> this gnd-collide-with) (-> this enemy-info gnd-collide-with))
    (set! (-> this fact) (new 'process 'fact-info-enemy this (the-as (pointer float) (-> arg0 fact-defaults))))
    (let ((cspec (if (logtest? (enemy-option multi-focus) (-> this fact enemy-options))
                     (the-as collide-spec (collide-spec jak bot player-list jak-vehicle))
                     (the-as collide-spec (collide-spec jak player-list jak-vehicle))
                     )
                 )
          )
      (reset-to-collide-spec (-> this focus) (the-as collide-spec cspec))
      )
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-101 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
      (cond
        ((and v1-101 (nonzero? (-> sv-16 elt-count)))
         (set! (-> this actor-group) (the-as (pointer actor-group) v1-101))
         (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
         )
        (else
          (set! (-> this actor-group) (the-as (pointer actor-group) #f))
          (set! (-> this actor-group-count) 0)
          0
          )
        )
      )
    (set! (-> this on-notice) (res-lump-struct (-> this entity) 'on-notice pair))
    (set! (-> this on-active) (res-lump-struct (-> this entity) 'on-active pair))
    (set! (-> this on-hostile) (res-lump-struct (-> this entity) 'on-hostile pair))
    (set! (-> this on-death) (res-lump-struct (-> this entity) 'on-death pair))
    (if (-> this on-notice)
        (logior! (-> this enemy-flags) (enemy-flag enable-on-notice))
        )
    (if (-> this on-active)
        (logior! (-> this enemy-flags) (enemy-flag enable-on-active))
        )
    (if (-> this on-hostile)
        (logior! (-> this enemy-flags) (enemy-flag enable-on-hostile))
        )
    (set! (-> this incoming attacker-handle) (the-as handle #f))
    (let ((s4-0 (-> this root)))
      (set! (-> this penetrated-by-all) (-> this root penetrated-by))
      (set! (-> this root penetrated-by) (get-penetrated-by this))
      (set! (-> s4-0 event-self) 'touched)
      )
    (set! (-> this penetrate-flinch) (-> arg0 penetrate-flinch))
    (set! (-> this penetrate-knocked) (-> arg0 penetrate-knocked))
    (set! (-> this reaction-time) (set-reaction-time! this (seconds 0.1) (seconds 0.8)))
    (let* ((v1-132 (-> this enemy-flags))
           (a0-61 (-> this fact enemy-options))
           (v1-133
             (logior (enemy-flag vulnerable vulnerable-backup use-notice-distance attackable-backup trackable trackable-backup)
                     v1-132
                     )
             )
           )
      (if (logtest? (enemy-option multi-focus) a0-61)
          (set! v1-133 (logior (enemy-flag multi-focus) v1-133))
          )
      (if (logtest? (enemy-option has-trigger) a0-61)
          (set! v1-133 (logior (enemy-flag use-trigger) v1-133))
          )
      (set! (-> this enemy-flags) v1-133)
      )
    (do-navigation-to-destination (-> this nav state) (-> this root trans))
    (if (and (should-move-to-ground? this)
             (not (logtest? (enemy-flag no-initial-move-to-ground) (-> this enemy-flags)))
             (not (logtest? (enemy-option ambush) (-> this fact enemy-options)))
             )
        (try-locate-ground this (meters 10) (meters 10) #t (-> this gnd-collide-with))
        )
    (if (zero? (-> this draw light-index))
        (set! (-> this draw light-index) (the-as uint 10))
        )
    0
    )
  )

;; WARN: Return type mismatch int vs object.
(defmethod init-from-entity! ((this nav-enemy) (arg0 entity-actor))
  (let ((a1-2 (res-lump-struct arg0 'art-level structure)))
    (when a1-2
      (let ((a0-3 (level-get *level* (the-as symbol a1-2))))
        (if a0-3
            (set! (-> this level) a0-3)
            )
        )
      )
    )
  (init-enemy-collision! this)
  (process-drawable-from-entity! this arg0)
  (init-enemy! this)
  (enemy-setup-gem)
  (let ((v1-10 (-> this fact enemy-options)))
    (cond
      ((logtest? (enemy-option spawner) v1-10)
       (process-entity-status! this (entity-perm-status dead) #t)
       (go (method-of-object this die-fast))
       )
      (*debug-view-anims*
        (go (method-of-object this view-anims))
        )
      ((logtest? (enemy-option dormant) v1-10)
       (let ((v1-18 (-> this root root-prim)))
         (set! (-> v1-18 prim-core collide-as) (collide-spec))
         (set! (-> v1-18 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> this draw status) (draw-control-status no-draw))
       (go (method-of-object this dormant))
       )
      ((logtest? (enemy-option dormant-aware) v1-10)
       (let ((v1-28 (-> this root root-prim)))
         (set! (-> v1-28 prim-core collide-as) (collide-spec))
         (set! (-> v1-28 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> this draw status) (draw-control-status no-draw))
       (go (method-of-object this dormant-aware))
       )
      (else
        (go-idle2 this)
        )
      )
    )
  0
  )

(defbehavior nav-enemy-simple-post nav-enemy ()
  (enemy-common-post self)
  (update-transforms (-> self root))
  0
  (none)
  )

(defbehavior nav-enemy-die-falling-post nav-enemy ()
  (enemy-die-falling-post)
  (none)
  )

(defbehavior nav-enemy-travel-post nav-enemy ()
  (nav-enemy-method-187 self)
  (none)
  )

(defbehavior nav-enemy-patrol-post nav-enemy ()
  (when (or (logtest? (-> self nav state flags) (nav-state-flag at-target)) (nav-enemy-method-174 self))
    (nav-enemy-method-164 self)
    (nav-enemy-method-173 self)
    )
  (nav-enemy-method-187 self)
  0
  (none)
  )

(defbehavior nav-enemy-chase-post nav-enemy ()
  (let ((a0-1 (handle->process (-> self focus handle))))
    (when a0-1
      (let ((gp-0 (-> self nav state))
            (v1-7 (get-trans (the-as process-focusable a0-1) 1))
            )
        (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
        (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
        (set! (-> gp-0 target-pos quad) (-> v1-7 quad))
        )
      0
      )
    )
  (nav-enemy-method-187 self)
  0
  (none)
  )

(defbehavior nav-enemy-flee-post nav-enemy ()
  (let ((a0-1 (handle->process (-> self focus handle))))
    (when a0-1
      (let ((gp-0 (-> self move-dest)))
        (if (or (not (nav-enemy-method-166 self gp-0 (get-trans (the-as process-focusable a0-1) 0)))
                (nav-enemy-method-174 self)
                )
            (go-stare2 self)
            )
        (let ((a0-7 (-> self nav state))
              (a1-3 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-3 quad) (-> a0-7 target-pos quad))
          (when (< 2048.0 (vector-vector-xz-distance gp-0 a1-3))
            (let ((v1-18 (-> self nav state)))
              (logclear! (-> v1-18 flags) (nav-state-flag directional-mode))
              (logior! (-> v1-18 flags) (nav-state-flag target-poly-dirty))
              (set! (-> v1-18 target-pos quad) (-> gp-0 quad))
              )
            0
            )
          )
        )
      )
    )
  (nav-enemy-method-187 self)
  0
  (none)
  )

(defbehavior nav-enemy-face-focus-post nav-enemy ()
  (let ((a0-0 self))
    (when (logtest? (enemy-flag ef38) (-> a0-0 enemy-flags))
      (let ((a0-4 (handle->process (-> self focus handle))))
        (if a0-4
            (seek-to-point-toward-point!
              (-> self root)
              (get-trans (the-as process-focusable a0-4) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (nav-enemy-simple-post)
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod nav-enemy-method-180 ((this nav-enemy) (arg0 float) (arg1 float))
  (if arg1
      (set! (-> this nav-radius-backup) arg0)
      )
  (if (zero? (-> this restore-nav-radius-time))
      (set! (-> this root nav-radius) arg0)
      )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod nav-enemy-method-179 ((this nav-enemy))
  (if (zero? (-> this restore-nav-radius-time))
      (set! (-> this root nav-radius) (-> this nav-radius-backup))
      )
  (none)
  )

(defmethod nav-enemy-method-162 ((this nav-enemy))
  (set! (-> this root nav-radius) 4.096)
  (set! (-> this restore-nav-radius-time)
        (the-as
          time-frame
          (max (-> this restore-nav-radius-time) (+ (current-time) (set-reaction-time! this (seconds 5) (seconds 8))))
          )
        )
  (none)
  )

(defbehavior nav-enemy-stare-post nav-enemy ()
  (let ((a0-0 self))
    (when (logtest? (enemy-flag ef38) (-> a0-0 enemy-flags))
      (let ((a0-4 (handle->process (-> self focus handle))))
        (if a0-4
            (seek-to-point-toward-point!
              (-> self root)
              (get-trans (the-as process-focusable a0-4) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (nav-enemy-method-187 self)
  (if (and (nav-enemy-method-174 self)
           (zero? (-> self restore-nav-radius-time))
           (time-elapsed? (-> self blocked-start-time) (seconds 4))
           )
      (nav-enemy-method-162 self)
      )
  0
  (none)
  )

(defbehavior nav-enemy-falling-post nav-enemy ()
  (enemy-falling-post)
  (none)
  )

(defbehavior nav-enemy-turn-to-face-dir nav-enemy ((arg0 vector) (arg1 float))
  (local-vars (v1-18 symbol))
  (let ((s4-0 (current-time)))
    (ja :group! (-> self draw art-group data (-> self enemy-info turn-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (until v1-18
      (seek-toward-heading-vec! (-> self root) arg0 (-> self nav max-rotation-rate) (seconds 0.02))
      (suspend)
      (ja :num! (loop! 0.75))
      (set! v1-18 (or (time-elapsed? s4-0 (seconds 10)) (enemy-method-103 self arg0 arg1)))
      )
    )
  (forward-up->quaternion (-> self root quat) arg0 *y-vector*)
  0
  (none)
  )

(defbehavior nav-enemy-turn-to-face-point nav-enemy ((arg0 vector) (arg1 float))
  (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> self root trans))))
    (set! (-> gp-1 y) 0.0)
    (when (< 0.0 (vector-length gp-1))
      (vector-normalize! gp-1 1.0)
      (nav-enemy-turn-to-face-dir gp-1 arg1)
      )
    )
  0
  (none)
  )

(defmethod go-stare2 ((this nav-enemy))
  (if (!= (-> this enemy-info taunt-anim) -1)
      (go (method-of-object this taunt))
      )
  (go (method-of-object this stare))
  )

(defmethod go-stare ((this nav-enemy))
  (let ((s5-0 (-> this focus aware)))
    (cond
      ((or (and (-> this enemy-info use-frustration) (logtest? (enemy-flag ef40) (-> this enemy-flags)))
           (nav-enemy-method-174 this)
           )
       (go-stare2 this)
       )
      ((and (= s5-0 (enemy-aware ea3)) (-> this enemy-info use-circling))
       (go (method-of-object this circling))
       )
      ((= s5-0 (enemy-aware ea4))
       (go-flee this)
       )
      (else
        (go-stare2 this)
        )
      )
    )
  )

(defmethod go-hostile ((this nav-enemy))
  (if (or (and (-> this enemy-info use-frustration) (logtest? (enemy-flag ef40) (-> this enemy-flags)))
          (nav-enemy-method-174 this)
          )
      (go-stare2 this)
      (go (method-of-object this hostile))
      )
  )

(defmethod go-flee ((this nav-enemy))
  (if (nav-enemy-method-167 this)
      (go (method-of-object this flee))
      (go (method-of-object this stare))
      )
  )

(define *nav-enemy-debug-control-info* (new 'static 'nav-enemy-debug-control-info))

(defbehavior nav-enemy-debug-control-post nav-enemy ()
  (let ((gp-0 *nav-enemy-debug-control-info*))
    (let ((f30-0 (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0)))
      (seek! (-> gp-0 steering) (fmax -1.0 (fmin 1.0 f30-0)) (seconds-per-frame))
      (if (cpad-hold? 0 x)
          (set! (-> gp-0 throttle) 1.0)
          (set! (-> gp-0 throttle) 0.0)
          )
      (format *stdcon* "input-x ~f  steering ~f  throttle ~f~%" f30-0 (-> gp-0 steering) (-> gp-0 throttle))
      )
    (format *stdcon* "target-speed ~M,  speed ~M~%" (-> self nav target-speed) (-> self nav state speed))
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 target-speed) (* 24576.0 (-> gp-0 throttle)))
      )
    0
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (let ((a1-4 (-> self nav state)))
        (set! (-> s4-0 quad) (-> a1-4 heading quad))
        )
      (vector-rotate-y! s4-0 s4-0 (* 1820.4445 (-> gp-0 steering)))
      (vector-float*! s4-0 s4-0 20480.0)
      (vector+! s5-0 (-> self root trans) s4-0)
      (let ((v1-26 (-> self nav state)))
        (logclear! (-> v1-26 flags) (nav-state-flag directional-mode))
        (logior! (-> v1-26 flags) (nav-state-flag target-poly-dirty))
        (set! (-> v1-26 target-pos quad) (-> s5-0 quad))
        )
      )
    )
  0
  (nav-enemy-method-187 self)
  (none)
  )

(defstate idle (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self state-timeout) (seconds 1))
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-5 enemy-flags))))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-7 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    )
  )

(defstate dormant (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy dormant) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag ef38))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-6 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    )
  )

(defstate dormant-aware (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (-> (method-of-type nav-enemy dormant) enter)
  )

(defstate active (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self state-timeout) (seconds 1))
    (logior! (-> self nav state flags) (nav-state-flag at-target))
    (let ((v1-8 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-8 enemy-flags)))
          (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-8 enemy-flags))))
          )
      (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-8 enemy-flags))))
      (set! (-> v1-8 nav callback-info) (-> v1-8 enemy-info callback-info))
      )
    0
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-11 enemy-flags))))
      )
    0
    (nav-enemy-method-176 self)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (until #f
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info walk-anim))
                    :num! (seek! max f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        (when (enemy-method-134 self 0.2)
          (ja-no-eval :num! (loop!))
          (ja-channel-push! 1 (seconds 0.6))
          (let ((v1-37 self))
            (set! (-> v1-37 enemy-flags) (the-as enemy-flag (logclear (-> v1-37 enemy-flags) (enemy-flag ef37))))
            (set! (-> v1-37 nav callback-info) *null-nav-callback-info*)
            )
          0
          (nav-enemy-method-178 self)
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                      :num! (seek! max f30-0)
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          (until (not (enemy-method-134 self 0.2))
            (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                        :num! (seek! max f30-0)
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          (let ((v1-101 self))
            (if (not (logtest? (enemy-flag ef37) (-> v1-101 enemy-flags)))
                (set! (-> v1-101 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-101 enemy-flags))))
                )
            (set! (-> v1-101 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-101 enemy-flags))))
            (set! (-> v1-101 nav callback-info) (-> v1-101 enemy-info callback-info))
            )
          0
          (nav-enemy-method-176 self)
          (ja-no-eval :num! (loop!))
          (ja-channel-push! 1 (seconds 0.6))
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info walk-anim))
                      :num! (seek! max f30-0)
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      )
    #f
    )
  :post nav-enemy-patrol-post
  )

(defstate notice (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy notice) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((a0-1 (handle->process (-> self focus handle))))
      (when a0-1
        (let ((gp-0 (-> self nav state))
              (v1-11 (get-trans (the-as process-focusable a0-1) 0))
              )
          (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
          (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
          (set! (-> gp-0 target-pos quad) (-> v1-11 quad))
          )
        0
        )
      )
    (let ((v1-14 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-14 enemy-flags)))
          (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-14 enemy-flags))))
          )
      (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-14 enemy-flags))))
      (set! (-> v1-14 nav callback-info) (-> v1-14 enemy-info callback-info))
      )
    0
    (let ((v1-17 self))
      (set! (-> v1-17 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-17 enemy-flags))))
      )
    0
    (let ((v1-19 (-> self nav)))
      (set! (-> v1-19 target-speed) 0.0)
      )
    0
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (rnd-float-range self 0.8 1.2))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info notice-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (let ((a1-9 (-> self nav state)))
          (set! (-> gp-0 quad) (-> a1-9 travel quad))
          )
        (seek-toward-heading-vec! (-> self root) gp-0 (-> self nav max-rotation-rate) (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-best-state self)
    )
  :post nav-enemy-simple-post
  )

(defstate hostile (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (nav-enemy-method-177 self)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-9 enemy-flags))))
      )
    0
    )
  :trans (behavior ()
    (nav-enemy-method-171 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (if (nav-enemy-method-174 self)
          (go-stare2 self)
          )
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (if (-> self enemy-info use-stop-chase)
               (go-virtual stop-chase)
               (go-virtual active)
               )
           )
          ((or (>= 2 (the-as int gp-0)) (not (get-focus! self)))
           (go-stare self)
           )
          ((= gp-0 (enemy-aware ea4))
           (go-flee self)
           )
          )
        )
      (when (and (-> self enemy-info use-frustration) (logtest? (enemy-flag ef40) (-> self enemy-flags)))
        (if (-> self enemy-info use-stop-chase)
            (go-virtual stop-chase)
            (go-stare self)
            )
        )
      )
    )
  :post nav-enemy-chase-post
  )

(defstate stop-chase (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (let ((a2-0 (-> self nav state)))
        (set! (-> a1-0 quad) (-> a2-0 target-pos quad))
        )
      (let ((f0-0 (vector-vector-distance (-> self root trans) a1-0)))
        (set! (-> self state-timeout)
              (the-as
                time-frame
                (the int (+ (lerp-scale 300.0 1200.0 f0-0 32768.0 122880.0) (rnd-float-range self 0.0 30.0)))
                )
              )
        )
      )
    (nav-enemy-method-176 self)
    (let ((v1-10 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-10 enemy-flags)))
          (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-10 enemy-flags))))
          )
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-10 enemy-flags))))
      (set! (-> v1-10 nav callback-info) (-> v1-10 enemy-info callback-info))
      )
    0
    (let ((v1-13 self))
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-13 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (nav-enemy-method-171 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (when (time-elapsed? (-> self state-time) (seconds 0.1))
      (if (nav-enemy-method-174 self)
          (go-stare2 self)
          )
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (if (time-elapsed? (-> self state-time) (-> self state-timeout))
               (go-virtual active)
               )
           )
          ((and (= gp-0 (enemy-aware ea3)) (get-focus! self))
           (go-hostile self)
           )
          ((= gp-0 (enemy-aware ea4))
           (go-flee self)
           )
          (else
            (if (time-elapsed? (-> self state-time) (-> self state-timeout))
                (go-stare self)
                )
            )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data (-> self enemy-info walk-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (rnd-float-range self 0.8 1.2)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    )
  :post nav-enemy-chase-post
  )

(defstate stare (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy stare) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag ef43) (-> self enemy-flags))))
    (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
    (let ((v1-9 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-9 enemy-flags)))
          (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-9 enemy-flags))))
          )
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-9 enemy-flags))))
      (set! (-> v1-9 nav callback-info) (-> v1-9 enemy-info callback-info))
      )
    0
    (let ((v1-12 self))
      (set! (-> v1-12 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-12 enemy-flags))))
      )
    0
    (nav-enemy-method-178 self)
    (vector-reset! (-> self root transv))
    (set-time! (-> self starting-time))
    )
  :exit (behavior ()
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf3 :class vf)
           )
      (init-vf0-vector)
      (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef43))))
      (let ((v1-4 (-> self nav state)))
        (set! (-> v1-4 speed) 0.0)
        )
      0
      (vector-reset! (-> self root transv))
      (if (logtest? (enemy-flag ef44) (-> self enemy-flags))
          (logior! (-> self nav flags) (nav-control-flag update-heading-from-facing))
          (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
          )
      (when (and (logtest? (-> self nav flags) (nav-control-flag update-heading-from-facing))
                 (not (nav-enemy-method-174 self))
                 )
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector-z-quaternion! gp-0 (-> self root quat))
          (set! (-> gp-0 y) 0.0)
          (let ((v1-23 gp-0))
            (let ((f0-2 1.0))
              (.lvf vf1 (&-> v1-23 quad))
              (.mul.vf vf2 vf1 vf1 :mask #b111)
              (let ((a0-9 f0-2))
                (.mov vf3 a0-9)
                )
              )
            (.mul.x.vf acc vf0 vf2 :mask #b1000)
            (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
            (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
            (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
            (.wait.vf)
            (.mul.vf vf1 vf1 Q :mask #b111)
            (.nop.vf)
            (.nop.vf)
            (.nop.vf)
            (.svf (&-> v1-23 quad) vf1)
            )
          (set! (-> self nav state heading quad) (-> gp-0 quad))
          )
        0
        )
      )
    )
  :trans (behavior ()
    (nav-enemy-method-171 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (let ((gp-0 (-> self focus aware)))
      (if (< (the-as int gp-0) 2)
          (set-time! (-> self starting-time))
          )
      (when (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (not (nav-enemy-method-174 self)))
        (cond
          ((>= 1 (the-as int gp-0))
           (go-virtual active)
           )
          ((= gp-0 (enemy-aware ea3))
           (if (and (get-focus! self)
                    (not (and (-> self enemy-info use-frustration) (logtest? (enemy-flag ef40) (-> self enemy-flags))))
                    (time-elapsed? (-> self starting-time) (-> self reaction-time))
                    )
               (go-hostile self)
               )
           (if (-> self enemy-info use-circling)
               (go-virtual circling)
               )
           )
          ((and (= gp-0 (enemy-aware ea4)) (nav-enemy-method-167 self))
           (go-flee self)
           )
          ((and (= gp-0 (enemy-aware ea2))
                (-> self enemy-info use-pacing)
                (time-elapsed? (-> self starting-time) (-> self reaction-time))
                )
           (go-virtual pacing)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info idle-anim)))
          )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post nav-enemy-stare-post
  )

(defstate taunt (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    ((-> (method-of-type nav-enemy stare) enter))
    (let ((gp-0 (handle->process (-> self focus handle))))
      (when (not gp-0)
        (if (nav-enemy-method-174 self)
            (go-virtual stare)
            (go-virtual active)
            )
        )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    )
  :exit (-> (method-of-type nav-enemy stare) exit)
  :trans (behavior ()
    (when (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (not (nav-enemy-method-174 self)))
      (let ((v1-6 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int v1-6))
           (go-virtual active)
           )
          ((and (= v1-6 (enemy-aware ea3)) (get-focus! self))
           (go-virtual hostile)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.8 1.2)))
      (let ((gp-0 (set-reaction-time! self (seconds 0.2) (seconds 0.7)))
            (s5-0 (current-time))
            (f28-0 f30-0)
            )
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                    :num! (loop! f28-0)
                    :frame-num 0.0
                    )
        (until (time-elapsed? s5-0 gp-0)
          (suspend)
          (ja :num! (loop! f28-0))
          )
        )
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info taunt-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-virtual stare)
    )
  :post nav-enemy-stare-post
  )

(defstate pacing (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-look-at-mode! self 1)
    (logior! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-9 enemy-flags))))
      )
    0
    (nav-enemy-method-176 self)
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self move-dest quad) (-> self root trans quad))
    (set! (-> self state-timeout) (set-reaction-time! self (seconds 7) (seconds 11)))
    (set-time! (-> self starting-time))
    (if (zero? (rnd-int self 2))
        (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag ef41) (-> self enemy-flags))))
        (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef41))))
        )
    (let ((gp-0 (handle->process (-> self focus handle))))
      (if (not gp-0)
          (go-virtual active)
          )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (if a0-1
          (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable a0-1) 0) quad))
          )
      )
    (let ((gp-1 (-> self focus aware)))
      (if (or (!= gp-1 3) (not (get-focus! self)))
          (set-time! (-> self starting-time))
          )
      (when (time-elapsed? (-> self state-time) (-> self reaction-time))
        (if (>= 1 (the-as int gp-1))
            (go-virtual active)
            )
        (when (= gp-1 (enemy-aware ea3))
          (when (and (get-focus! self) (time-elapsed? (-> self starting-time) (-> self reaction-time)))
            (nav-enemy-method-172 self)
            (go-virtual hostile)
            )
          (if (-> self enemy-info use-circling)
              (go-virtual circling)
              )
          )
        (if (nav-enemy-method-174 self)
            (go-stare2 self)
            )
        (when (time-elapsed? (-> self state-time) (-> self state-timeout))
          (nav-enemy-method-172 self)
          (go-stare2 self)
          )
        )
      )
    (when (>= 1024.0 (vector-vector-xz-distance (-> self root trans) (-> self move-dest)))
      (when (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (zero? (rnd-int self 3)))
        (nav-enemy-method-172 self)
        (go-stare2 self)
        )
      (countdown (gp-4 2)
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (f30-1 16384.0)
              (v1-70 (-> self enemy-flags))
              (s5-0 (-> self move-dest))
              )
          (let ((v1-71 (logxor (shl 512 32) (the-as int v1-70))))
            (set! (-> self enemy-flags) (the-as enemy-flag v1-71))
            (if (logtest? (shl 512 32) v1-71)
                (set! f30-1 (- f30-1))
                )
            )
          (set! (-> s5-0 quad) (-> self focus-pos quad))
          (vector-! s4-0 (-> self root trans) s5-0)
          (set! (-> s4-0 y) 0.0)
          (vector-normalize! s4-0 (rnd-float-range self 16384.0 49152.0))
          (vector-rotate-around-y! s4-0 s4-0 f30-1)
          (vector+! s5-0 s5-0 s4-0)
          (if (and (closest-point-on-mesh (-> self nav) s5-0 s5-0 (the-as nav-poly #f))
                   (< 4096.0 (vector-vector-xz-distance s5-0 (-> self root trans)))
                   )
              (return #f)
              )
          )
        )
      (go-stare2 self)
      )
    )
  :code (behavior ()
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info walk-anim)))
          )
      (let ((v1-8 (ja-group)))
        (if (not (and v1-8 (= v1-8 gp-0)))
            (ja-channel-push! 1 (seconds 0.2))
            )
        )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self move-dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-pos quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate circling (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-look-at-mode! self 1)
    (logior! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (nav-enemy-method-176 self)
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-11 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((gp-0 (handle->process (-> self focus handle))))
      (if (not gp-0)
          (go-virtual active)
          )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    (let ((f30-0 (-> self enemy-info circle-dist-lo))
          (f28-0 (-> self enemy-info circle-dist-hi))
          )
      (if (zero? (rnd-int self 4))
          (set! (-> self desired-angle) (rnd-float-range self f30-0 f28-0))
          (set! (-> self desired-angle)
                (fmax (fmin (vector-vector-xz-distance (-> self focus-pos) (-> self root trans)) f28-0) f30-0)
                )
          )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logxor (shl 512 32) (the-as int (-> self enemy-flags)))))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef42))))
    (set-time! (-> self starting-time))
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (if a0-1
          (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable a0-1) 0) quad))
          )
      )
    (let ((gp-1 (-> self focus aware)))
      (if (or (!= gp-1 3) (not (get-focus! self)))
          (set-time! (-> self starting-time))
          )
      (when (time-elapsed? (-> self state-time) (-> self reaction-time))
        (cond
          ((>= 1 (the-as int gp-1))
           (nav-enemy-method-172 self)
           (if (-> self enemy-info use-stop-chase)
               (go-virtual stop-chase)
               (go-virtual active)
               )
           )
          ((and (= gp-1 (enemy-aware ea3))
                (get-focus! self)
                (time-elapsed? (-> self starting-time) (-> self reaction-time))
                )
           (nav-enemy-method-172 self)
           (go-hostile self)
           )
          ((= gp-1 (enemy-aware ea2))
           (go-stare self)
           )
          ((= gp-1 (enemy-aware ea4))
           (go-flee self)
           )
          ((or (nav-enemy-method-174 self) (logtest? (enemy-flag ef42) (-> self enemy-flags)))
           (go-stare2 self)
           )
          )
        )
      )
    )
  :code (behavior ()
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info walk-anim)))
          )
      (let ((v1-8 (ja-group)))
        (if (not (and v1-8 (= v1-8 gp-0)))
            (ja-channel-push! 1 (seconds 0.1))
            )
        )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post (behavior ()
    (let ((a0-0 self))
      (when (logtest? (enemy-flag ef37) (-> a0-0 enemy-flags))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (let ((f30-0 16384.0))
              (if (logtest? (enemy-flag ef41) (-> self enemy-flags))
                  (set! f30-0 (- f30-0))
                  )
              (set! (-> s5-0 quad) (-> self focus-pos quad))
              (vector-! gp-0 (-> self root trans) s5-0)
              (set! (-> gp-0 y) 0.0)
              (vector-normalize! gp-0 (-> self desired-angle))
              (vector+! s5-0 s5-0 gp-0)
              (vector-rotate-around-y! gp-0 gp-0 f30-0)
              )
            (vector-normalize! gp-0 16384.0)
            (vector+! s5-0 s5-0 gp-0)
            )
          (let ((gp-1 (new 'stack-no-clear 'vector)))
            (set! (-> gp-1 quad) (-> self root trans quad))
            (closest-point-on-mesh (-> self nav) gp-1 s5-0 (the-as nav-poly #f))
            (if (< (vector-vector-xz-distance gp-1 (-> self root trans)) 409.6)
                (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag ef42) (-> self enemy-flags))))
                (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef42))))
                )
            (let ((v1-28 (-> self nav state)))
              (logclear! (-> v1-28 flags) (nav-state-flag directional-mode))
              (logior! (-> v1-28 flags) (nav-state-flag target-poly-dirty))
              (set! (-> v1-28 target-pos quad) (-> gp-1 quad))
              )
            )
          )
        0
        )
      )
    (nav-enemy-travel-post)
    )
  )

(defstate flee (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy flee) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (nav-enemy-method-177 self)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-9 enemy-flags))))
      )
    0
    (nav-enemy-method-173 self)
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (let ((v1-3 (-> self focus aware)))
        (if (!= v1-3 (enemy-aware ea4))
            (go-stare self)
            )
        )
      (if (nav-enemy-method-174 self)
          (go-stare2 self)
          )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data (-> self enemy-info run-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    )
  :post nav-enemy-flee-post
  )

(defstate victory (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy victory) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-4 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-9 enemy-flags))))
      )
    0
    (vector-reset! (-> self root transv))
    )
  :post nav-enemy-simple-post
  )

(defstate hit (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hit) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-4 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-9 enemy-flags))))
      )
    0
    )
  :code (behavior ()
    (local-vars (v1-37 enemy-flag) (v1-39 enemy-flag) (v1-41 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info hit-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-36 (-> self enemy-flags)))
      (if (logtest? v1-36 (enemy-flag vulnerable-backup))
          (set! v1-37 (logior v1-36 (enemy-flag vulnerable)))
          (set! v1-37 (logclear v1-36 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-37)
    (let ((v1-38 (-> self enemy-flags)))
      (if (logtest? v1-38 (enemy-flag attackable-backup))
          (set! v1-39 (logior v1-38 (enemy-flag attackable)))
          (set! v1-39 (logclear v1-38 (enemy-flag attackable)))
          )
      )
    (set! (-> self enemy-flags) v1-39)
    (let ((v1-40 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-40)
          (set! v1-41 (logior (enemy-flag trackable) v1-40))
          (set! v1-41 (logclear v1-40 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-41)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self focus-status) (focus-status hit))
    (go-hostile self)
    )
  :post nav-enemy-simple-post
  )

(defstate knocked (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-4 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-9 enemy-flags))))
      )
    0
    )
  :post nav-enemy-falling-post
  )

(defstate die (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy die) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-6 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    )
  :post nav-enemy-simple-post
  )

(defstate die-falling (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy die-falling) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-6 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    )
  :post nav-enemy-die-falling-post
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod enemy-method-91 ((this nav-enemy) (arg0 enemy-jump-info))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> arg0 dest-pos quad))
    (set! (-> v1-0 w) (-> this nav-radius-backup))
    (add-root-sphere-to-hash! (-> this nav) v1-0 #x100068)
    )
  )

;; WARN: Return type mismatch quaternion vs none.
(defmethod enemy-method-101 ((this nav-enemy) (arg0 int) (arg1 enemy-jump-info))
  (let ((v1-0 arg0))
    (when (or (zero? v1-0) (= v1-0 1) (= v1-0 2) (= v1-0 3))
      (let ((a1-4 this))
        (if (logtest? (enemy-flag ef38) (-> a1-4 enemy-flags))
            (seek-to-point-toward-point! (-> this root) (-> arg1 dest-pos) (-> this nav max-rotation-rate) (seconds 0.02))
            )
        )
      )
    )
  (none)
  )

(defstate jump (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-6 nav callback-info) *null-nav-callback-info*)
      )
    0
    (logclear! (-> self nav state flags) (nav-state-flag at-gap))
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump) exit)))
      (if t9-0
          (t9-0)
          )
      )
    ;; og:preserve-this fix potential use-after-free bug
    (if (-> self nav)
      (let ((v1-4 (-> self nav)))
        (logclear! (-> v1-4 shape nav-flags) (nav-flags has-extra-sphere))
        )
      )
    0
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'enemy-jump-info)))
      (let ((s5-0 0))
        (init-jump-info! self gp-0)
        (if (and (-> self enemy-info use-jump-blocked)
                 (logtest? (enemy-flag jump-check-blocked) (-> self enemy-flags))
                 (enemy-method-91 self gp-0)
                 )
            (go-virtual jump-blocked)
            )
        (let* ((v1-13 (-> self nav))
               (a1-2 (-> gp-0 dest-pos))
               (f0-0 (-> v1-13 extra-nav-sphere w))
               )
          (set! (-> v1-13 extra-nav-sphere quad) (-> a1-2 quad))
          (set! (-> v1-13 extra-nav-sphere w) f0-0)
          )
        0
        (let ((v1-16 (-> self nav)))
          (set! (-> v1-16 extra-nav-sphere w) (-> self nav-radius-backup))
          )
        0
        (let ((v1-18 (-> self nav)))
          (logior! (-> v1-18 shape nav-flags) (nav-flags has-extra-sphere))
          )
        0
        (when (logtest? (-> gp-0 flags) (enemy-jump-flags ejf0))
          (until #f
            (if (jump-anim-handler self s5-0 gp-0)
                (goto cfg-12)
                )
            (in-jump-handler self s5-0 gp-0)
            (enemy-method-101 self s5-0 gp-0)
            (suspend)
            (set! s5-0 1)
            )
          #f
          )
        )
      (label cfg-12)
      (logclear! (-> self root status) (collide-status on-surface on-ground touch-surface))
      (let ((s5-1 2))
        (logior! (-> self focus-status) (focus-status in-air))
        (until (on-ground? self gp-0)
          (+! (-> gp-0 hang-time) (- (current-time) (-> self clock old-frame-counter)))
          (jump-anim-handler self s5-1 gp-0)
          (in-jump-handler self s5-1 gp-0)
          (enemy-method-101 self s5-1 gp-0)
          (suspend)
          (set! s5-1 3)
          )
        )
      (logclear! (-> self focus-status) (focus-status in-air))
      (let ((v1-51 (-> self nav)))
        (logclear! (-> v1-51 shape nav-flags) (nav-flags has-extra-sphere))
        )
      0
      (let ((v1-55 (-> self nav state)))
        (set! (-> v1-55 current-poly) (the-as nav-poly #f))
        )
      0
      (logclear! (-> self nav state flags) (nav-state-flag at-target))
      (move-to-gspot! self)
      (let ((s5-2 4))
        (until #f
          (if (jump-anim-handler self s5-2 gp-0)
              (goto cfg-19)
              )
          (in-jump-handler self s5-2 gp-0)
          (enemy-method-101 self s5-2 gp-0)
          (suspend)
          (set! s5-2 5)
          )
        )
      #f
      (label cfg-19)
      (if (logtest? (enemy-flag directed) (-> self enemy-flags))
          ((lambda :behavior nav-enemy
             ((arg0 enemy-jump-info))
             (send-event (ppointer->process (-> self parent)) 'child-jumped)
             (none)
             )
           gp-0
           )
          )
      )
    (go-directed2 self)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (cond
        ((logtest? (enemy-flag ef37) (-> a0-0 enemy-flags))
         (nav-enemy-method-187 self)
         )
        (else
          (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
            (set! (-> a1-2 options) (overlaps-others-options))
            (set! (-> a1-2 collide-with-filter) (-> self enemy-info overlaps-others-collide-with-filter))
            (set! (-> a1-2 tlist) *touching-list*)
            (find-overlapping-shapes (-> self root) a1-2)
            )
          (nav-enemy-simple-post)
          )
        )
      )
    )
  )

(defstate jump-blocked (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump-blocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-6 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-178 self)
    )
  :post nav-enemy-simple-post
  )

(defstate directed (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag directed-ready))
    ((-> (method-of-type nav-enemy idle) enter))
    )
  :code (-> (method-of-type nav-enemy idle) code)
  :post (-> (method-of-type nav-enemy idle) post)
  )

(defstate view-anims (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (when (-> self nav)
      (let ((v1-1 self))
        (set! (-> v1-1 enemy-flags) (the-as enemy-flag (logclear (-> v1-1 enemy-flags) (enemy-flag ef38))))
        )
      0
      (let ((v1-3 self))
        (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logclear (-> v1-3 enemy-flags) (enemy-flag ef37))))
        (set! (-> v1-3 nav callback-info) *null-nav-callback-info*)
        )
      0
      )
    )
  )

(defstate debug-control (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :code (behavior ()
    (let ((v1-0 *nav-enemy-debug-control-info*))
      (set! (-> v1-0 steering) 0.0)
      (set! (-> v1-0 throttle) 0.0)
      )
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info walk-anim)) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post nav-enemy-debug-control-post
  )
