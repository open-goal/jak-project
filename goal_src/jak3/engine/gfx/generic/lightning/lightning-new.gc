;;-*-Lisp-*-
(in-package goal)

;; name: lightning-new.gc
;; name in dgo: lightning-new
;; dgos: GAME

;; DECOMP BEGINS

(define *lightning-alpha-additive* (new 'static 'gs-alpha :b #x2 :d #x1))

(define *lightning-alpha-blend* (new 'static 'gs-alpha :b #x1 :d #x1))

(define *lightning-alpha-subtractive* (new 'static 'gs-alpha :a #x2 :d #x1))

(defmethod init! ((this lightning-bolt) (arg0 int) (arg1 int) (arg2 lightning-appearance))
  (set! (-> this num-spans) arg0)
  (set! (-> this spans) (new 'process 'lightning-spans-array arg0))
  (set! (-> this num-active-spans) 0)
  (set! (-> this span-pts-start) (new 'process 'vector-array arg0))
  (let ((s3-0 (* arg1 arg0)))
    (let ((s2-1 (+ (* arg1 (+ arg0 -1)) 1)))
      (set! (-> this current-points) (new 'process 'vector-array s2-1))
      (set! (-> this desired-points) (new 'process 'vector-array s2-1))
      )
    (let ((f30-0 (* 2.0 (the float s3-0))))
      (set! (-> this strip1)
            (new 'process 'prim-strip (the int f30-0) (new 'static 'texture-id :index #x3 :page #x1) (the-as string #f))
            )
      (set! (-> this strip2)
            (new 'process 'prim-strip (the int f30-0) (new 'static 'texture-id :index #x3 :page #x1) (the-as string #f))
            )
      )
    )
  (set! (-> this appearance) arg2)
  (set! (-> this spans-internal) (new 'process 'lightning-spans-internal-array arg0))
  (set! (-> this current-uv-shift) 0.0)
  (set! (-> this strip1 clamp) (new 'static 'gs-clamp))
  (set! (-> this strip2 clamp) (new 'static 'gs-clamp))
  (when (-> this appearance use-sprite-bucket?)
    (set! (-> this strip1 bucket) (bucket-id generic-sprite-1))
    (set! (-> this strip1 sink) (the-as uint 65))
    (set! (-> this strip1 texture-index) (the-as uint 7))
    (set! (-> this strip2 bucket) (bucket-id generic-sprite-1))
    (set! (-> this strip2 sink) (the-as uint 65))
    (set! (-> this strip2 texture-index) (the-as uint 7))
    )
  (set! (-> this new-inner-point-generate-time)
        (rand-vu-int-range
          (the-as int (-> this appearance regenerate-time-start))
          (the-as int (-> this appearance regenerate-time-end))
          )
        )
  (set! (-> this base-width)
        (rand-vu-float-range (-> this appearance width-range-start) (-> this appearance width-range-end))
        )
  (set! (-> this fade-mode) (the-as uint 0))
  (set! (-> this current-fade-scalar) 1.0)
  (when (-> this appearance uv-shift?)
    (let* ((v1-31 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-32 (the-as number (logior #x3f800000 v1-31)))
           )
      (set! (-> this current-uv-shift) (+ -1.0 (the-as float v1-32)))
      )
    )
  (dotimes (v1-35 (-> this num-spans))
    (logand! (-> this spans-internal data v1-35 span-flags) -2)
    (set! (-> this spans-internal data v1-35 index) v1-35)
    )
  (set! (-> this base-color) *color-gray*)
  0
  (none)
  )

(defmethod reset-spans! ((this lightning-bolt))
  (set! (-> this num-active-spans) 0)
  0
  (none)
  )

(defmethod lightning-bolt-method-20 ((this lightning-bolt) (arg0 int) (arg1 lightning-span-internal))
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (let* ((f30-0 -0.5)
           (v1-2 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-3 (the-as number (logior #x3f800000 v1-2)))
           )
      (set! (-> s3-0 x) (+ f30-0 (+ -1.0 (the-as float v1-3))))
      )
    (let* ((f30-1 -0.5)
           (v1-7 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-8 (the-as number (logior #x3f800000 v1-7)))
           )
      (set! (-> s3-0 y) (+ f30-1 (+ -1.0 (the-as float v1-8))))
      )
    (set! (-> s3-0 z) (the float (-> arg1 index)))
    (set! (-> s3-0 w) 1.0)
    (set! (-> this desired-points data arg0 quad) (-> s3-0 quad))
    )
  (set! (-> this current-points data arg0 z) (the float (-> arg1 index)))
  (-> this desired-points data arg0)
  )

(defmethod lightning-bolt-method-21 ((this lightning-bolt) (arg0 int) (arg1 int) (arg2 float))
  (local-vars (sv-16 int) (sv-24 vector) (sv-28 vector) (sv-32 float))
  (let ((v1-0 (-> this desired-points)))
    (when (< 1 (- arg1 arg0))
      (set! sv-16 (/ (+ arg0 arg1) 2))
      (set! sv-24 (-> v1-0 data arg0))
      (set! sv-28 (-> v1-0 data arg1))
      (set! sv-32 (the-as float 1.0))
      (set! sv-32 (-> sv-28 z))
      (let ((s2-0 (-> v1-0 data sv-16)))
        (let* ((f30-0 (* 0.5 (+ (-> sv-24 x) (-> sv-28 x))))
               (f28-0 arg2)
               (f26-0 -0.5)
               (v1-6 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-7 (the-as number (logior #x3f800000 v1-6)))
               )
          (set! (-> s2-0 x) (+ f30-0 (* f28-0 (+ f26-0 (+ -1.0 (the-as float v1-7))))))
          )
        (let* ((f30-1 (* 0.5 (+ (-> sv-24 y) (-> sv-28 y))))
               (f28-1 arg2)
               (f26-1 -0.5)
               (v1-14 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-15 (the-as number (logior #x3f800000 v1-14)))
               )
          (set! (-> s2-0 y) (+ f30-1 (* f28-1 (+ f26-1 (+ -1.0 (the-as float v1-15))))))
          )
        (set! (-> s2-0 z) (lerp (-> sv-24 z) sv-32 0.5))
        )
      (lightning-bolt-method-21 this arg0 sv-16 (* arg2 (-> this fractal-reduction)))
      (lightning-bolt-method-21 this sv-16 arg1 (* arg2 (-> this fractal-reduction)))
      )
    )
  0
  (none)
  )

(defmethod lightning-bolt-method-15 ((this lightning-bolt) (arg0 object) (arg1 int) (arg2 lightning-span-internal))
  (let ((v1-0 (-> this generate-mode)))
    (cond
      ((zero? v1-0)
       (let ((f30-0 (the float (-> arg2 index)))
             (f28-0 (the float (+ (-> arg2 index) 1)))
             (f26-0 (/ 1.0 (the float (+ (-> arg2 num-inner-points) 1))))
             )
         0.0
         (let ((f24-0 (+ 0.0 f26-0)))
           (dotimes (s3-0 (-> arg2 num-inner-points))
             (let ((f22-0 (lerp f30-0 f28-0 f24-0)))
               (let ((s2-0 (-> this desired-points data (+ s3-0 1 arg1))))
                 (let* ((f20-0 -0.5)
                        (v1-13 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                        (v1-14 (the-as number (logior #x3f800000 v1-13)))
                        )
                   (set! (-> s2-0 x) (+ f20-0 (+ -1.0 (the-as float v1-14))))
                   )
                 (let* ((f20-1 -0.5)
                        (v1-18 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                        (v1-19 (the-as number (logior #x3f800000 v1-18)))
                        )
                   (set! (-> s2-0 y) (+ f20-1 (+ -1.0 (the-as float v1-19))))
                   )
                 (set! (-> s2-0 z) f22-0)
                 (set! (-> s2-0 w) 1.0)
                 )
               (set! (-> this current-points data (+ s3-0 1 arg1) z) f22-0)
               )
             (+! f24-0 f26-0)
             )
           )
         )
       )
      ((= v1-0 1)
       (lightning-bolt-method-21 this arg1 (+ (-> arg2 num-inner-points) 1 arg1) 1.0)
       )
      )
    )
  (none)
  )

;; WARN: Return type mismatch uint vs int.
(defmethod lightning-bolt-method-14 ((this lightning-bolt))
  (the-as int (-> this fade-mode))
  )

(defmethod lightning-bolt-method-13 ((this lightning-bolt) (arg0 int))
  (when (!= (-> this fade-mode) arg0)
    (let ((v1-1 arg0))
      (cond
        ((zero? v1-1)
         (set! (-> this current-fade-scalar) 1.0)
         (set-time! (-> this start-fade-time))
         )
        ((= v1-1 2)
         (set-time! (-> this start-fade-time))
         (set! (-> this current-fade-scalar) 1.0)
         )
        ((= v1-1 1)
         (set! (-> this current-fade-scalar) 0.0)
         (set-time! (-> this start-fade-time))
         )
        ((= v1-1 3)
         (dotimes (v1-12 (-> this num-spans))
           (logand! (-> this spans-internal data v1-12 span-flags) -2)
           )
         )
        )
      )
    (set! (-> this fade-mode) (the-as uint arg0))
    )
  (none)
  )

;; WARN: Function (method 11 lightning-bolt) has a return type of none, but the expression builder found a return statement.
(defmethod lightning-bolt-method-11 ((this lightning-bolt))
  (local-vars
    (sv-16 time-frame)
    (sv-24 float)
    (sv-32 time-frame)
    (sv-40 float)
    (sv-64 vector)
    (sv-68 float)
    (sv-72 float)
    )
  (with-pp
    (case (-> this fade-mode)
      ((2)
       (let* ((f1-2 (/ (the float (- (current-time) (-> this start-fade-time))) (the float (-> this appearance fade-time))))
              (f0-3 (fmax 0.0 (fmin 1.0 f1-2)))
              )
         (set! (-> this current-fade-scalar) (lerp 1.0 0.0 f0-3))
         )
       (if (>= 0.0 (-> this current-fade-scalar))
           (lightning-bolt-method-13 this 3)
           )
       )
      ((1)
       (let* ((f1-7 (/ (the float (- (current-time) (-> this start-fade-time))) (the float (-> this appearance fade-time))))
              (f0-9 (fmax 0.0 (fmin 1.0 f1-7)))
              )
         (set! (-> this current-fade-scalar) (lerp 0.0 1.0 f0-9))
         )
       (if (>= (-> this current-fade-scalar) 1.0)
           (lightning-bolt-method-13 this 0)
           )
       )
      )
    (if (= (-> this fade-mode) 3)
        (return 0)
        )
    (if (zero? (-> this fade-mode))
        (set! (-> this current-fade-scalar) 1.0)
        )
    (set! (-> this num-active-spans) (min (-> this num-active-spans) (+ (-> this num-spans) -1)))
    (let ((v1-31 (-> this num-active-spans))
          (a0-14 (+ (-> this num-spans) -1))
          )
      (while (>= a0-14 v1-31)
        (let ((a1-6 (-> this spans-internal data v1-31)))
          (logand! (-> a1-6 span-flags) -2)
          )
        (+! v1-31 1)
        )
      )
    (let ((v1-37 (time-elapsed? (-> this last-generate-time) (-> this new-inner-point-generate-time))))
      (dotimes (a0-17 (-> this num-active-spans))
        (-> this spans data a0-17)
        (let ((a1-12 (-> this spans-internal data a0-17)))
          (if (or v1-37 (not (logtest? (-> a1-12 span-flags) 1)))
              (logior! (-> a1-12 span-flags) 2)
              (logand! (-> a1-12 span-flags) -3)
              )
          )
        )
      )
    (let ((s5-0 0))
      (dotimes (s4-0 (-> this num-active-spans))
        (-> this spans data s4-0)
        (let* ((a2-13 (-> this spans-internal data s4-0))
               (s3-0 (+ (-> a2-13 num-inner-points) 1))
               )
          (when (logtest? (-> a2-13 span-flags) 2)
            (when (or (-> this snap-inner-points?)
                      (and (logtest? (-> a2-13 span-flags) 2) (not (logtest? (-> a2-13 span-flags) 1)))
                      )
              (dotimes (v1-55 s3-0)
                (set! (-> this current-points data (+ v1-55 s5-0) quad) (-> this desired-points data (+ v1-55 s5-0) quad))
                )
              )
            (lightning-bolt-method-20 this s5-0 a2-13)
            )
          (+! s5-0 s3-0)
          )
        )
      (when (time-elapsed? (-> this last-generate-time) (-> this new-inner-point-generate-time))
        (lightning-bolt-method-20 this s5-0 (-> this spans-internal data (-> this num-active-spans)))
        (if (-> this snap-inner-points?)
            (set! (-> this current-points data s5-0 quad) (-> this desired-points data s5-0 quad))
            )
        (set-time! (-> this last-generate-time))
        (set! (-> this new-inner-point-generate-time) (rand-vu-int-range
                                                        (the-as int (-> this appearance regenerate-time-start))
                                                        (the-as int (-> this appearance regenerate-time-end))
                                                        )
              )
        )
      )
    (let ((s5-1 0))
      (dotimes (s4-1 (-> this num-active-spans))
        (let* ((a1-24 (-> this spans data s4-1))
               (a3-5 (-> this spans-internal data s4-1))
               (s3-1 (+ (-> a3-5 num-inner-points) 1))
               )
          (if (logtest? (-> a3-5 span-flags) 2)
              (lightning-bolt-method-15 this a1-24 s5-1 a3-5)
              )
          (+! s5-1 s3-1)
          )
        )
      )
    (let ((s5-2 0))
      (dotimes (s4-2 (+ (-> this num-active-spans) 1))
        (-> this spans data s4-2)
        (let* ((v1-102 (-> this spans-internal data s4-2))
               (s3-2 (+ (-> v1-102 num-inner-points) 1))
               )
          (if (= s4-2 (-> this num-active-spans))
              (set! s3-2 1)
              )
          (cond
            ((not (-> this appearance use-accurate-interp?))
             (let ((a0-49 (the-as int (- (current-time) (-> pp clock old-frame-counter)))))
               0.0
               (if (logtest? (-> v1-102 span-flags) 2)
                   (set! a0-49 0)
                   )
               (let* ((f1-12 (/ (the float a0-49) (the float (-> this inner-point-travel-time))))
                      (f30-0 (fmax 0.0 (fmin 1.0 f1-12)))
                      )
                 (dotimes (s2-0 s3-2)
                   (vector-lerp!
                     (-> this current-points data (+ s2-0 s5-2))
                     (-> this current-points data (+ s2-0 s5-2))
                     (-> this desired-points data (+ s2-0 s5-2))
                     f30-0
                     )
                   )
                 )
               )
             )
            (else
              (set! sv-16 (- (current-time) (- (current-time) (-> pp clock old-frame-counter))))
              (set! sv-24 (the-as float 0.0))
              (set! sv-32 (current-time))
              (set! sv-40 (the-as float 0.0))
              (set! sv-24
                    (/ (the float (- sv-16 (-> this last-generate-time))) (the float (-> this inner-point-travel-time)))
                    )
              (set! sv-40
                    (/ (the float (- sv-32 (-> this last-generate-time))) (the float (-> this inner-point-travel-time)))
                    )
              (set! sv-24 (fmax 0.0 (fmin 1.0 sv-24)))
              (set! sv-40 (fmax 0.0 (fmin 1.0 sv-40)))
              (let ((f30-1 (- 1.0 sv-24)))
                (dotimes (s2-1 s3-2)
                  (set! sv-64 (new 'stack-no-clear 'vector))
                  (set! sv-68 (the-as float 0.0))
                  (set! sv-72 (the-as float 0.0))
                  (set-vector!
                    sv-64
                    (- (-> this desired-points data (+ s2-1 s5-2) x) (-> this current-points data (+ s2-1 s5-2) x))
                    (- (-> this desired-points data (+ s2-1 s5-2) y) (-> this current-points data (+ s2-1 s5-2) y))
                    0.0
                    1.0
                    )
                  (set! sv-68 (vector-normalize-ret-len! sv-64 1.0))
                  (when (< 0.0 f30-1)
                    (set! sv-72 (/ sv-68 f30-1))
                    (vector-float*! sv-64 sv-64 (* sv-72 (- sv-40 sv-24)))
                    (vector+! (-> this current-points data (+ s2-1 s5-2)) (-> this current-points data (+ s2-1 s5-2)) sv-64)
                    (set! (-> this current-points data (+ s2-1 s5-2) z) (-> this desired-points data (+ s2-1 s5-2) z))
                    )
                  )
                )
              )
            )
          (+! s5-2 s3-2)
          )
        )
      )
    (dotimes (v1-156 (-> this num-active-spans))
      (-> this spans data v1-156)
      (let ((a0-82 (-> this spans-internal data v1-156)))
        (logior! (-> a0-82 span-flags) 1)
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch vector vs none.
(defmethod lightning-bolt-method-19 ((this lightning-bolt) (arg0 vector) (arg1 int) (arg2 int) (arg3 matrix) (arg4 float) (arg5 float))
  (let ((a1-2
          (vector-! (new 'stack-no-clear 'vector) (-> this current-points data arg2) (-> this current-points data arg1))
          )
        )
    (set! (-> a1-2 x) (* (-> a1-2 x) arg4))
    (set! (-> a1-2 y) (* (-> a1-2 y) arg4))
    (set! (-> a1-2 z) (* (-> a1-2 z) arg5))
    (vector-rotate*! arg0 a1-2 arg3)
    )
  (none)
  )

(defun matrix<-vector-yz2! ((arg0 matrix) (arg1 vector) (arg2 vector))
  (set! (-> arg0 fvec quad) (-> arg1 quad))
  (vector-cross! (-> arg0 rvec) arg2 arg1)
  (vector-normalize! (-> arg0 rvec) 1.0)
  (vector-cross! (-> arg0 uvec) arg1 (-> arg0 rvec))
  (vector-normalize! (-> arg0 uvec) 1.0)
  (set! (-> arg0 rvec w) 1.0)
  (set! (-> arg0 uvec w) 1.0)
  (set! (-> arg0 fvec w) 1.0)
  arg0
  )

;; WARN: Return type mismatch number vs none.
;; WARN: Function (method 22 lightning-bolt) has a return type of none, but the expression builder found a return statement.
(defmethod lightning-bolt-method-22 ((this lightning-bolt))
  (with-pp
    (set! (-> this strip1 num-verts) (the-as uint 0))
    (set! (-> this strip2 num-verts) (the-as uint 0))
    (set! (-> this strip1 adnops 0 cmds) (gs-reg64 test-1))
    (set! (-> this strip1 data0)
          (new 'static 'gs-test :ate #x1 :afail #x1 :zte #x1 :ztst (gs-ztest greater-equal))
          )
    (set! (-> this strip2 adnops 0 cmds) (gs-reg64 test-1))
    (set! (-> this strip2 data0)
          (new 'static 'gs-test :ate #x1 :afail #x1 :zte #x1 :ztst (gs-ztest greater-equal))
          )
    (set! (-> this strip1 adnops 1 cmds) (gs-reg64 alpha-1))
    (set! (-> this strip2 adnops 1 cmds) (gs-reg64 alpha-1))
    (let ((v1-9 (-> this appearance blend-mode)))
      (cond
        ((= v1-9 1)
         (set! (-> this strip1 data1) (the-as gs-test *lightning-alpha-additive*))
         (set! (-> this strip2 data1) (the-as gs-test *lightning-alpha-additive*))
         )
        ((zero? v1-9)
         (set! (-> this strip1 data1) (the-as gs-test *lightning-alpha-blend*))
         (set! (-> this strip2 data1) (the-as gs-test *lightning-alpha-blend*))
         )
        ((= v1-9 2)
         (set! (-> this strip1 data1) (the-as gs-test *lightning-alpha-subtractive*))
         (set! (-> this strip2 data1) (the-as gs-test *lightning-alpha-subtractive*))
         )
        )
      )
    (set! (-> this strip1 tex-id) (the-as texture-id (-> this appearance tex-id)))
    (set! (-> this strip2 tex-id) (the-as texture-id (-> this appearance tex-id)))
    (if (= (-> this fade-mode) 3)
        (return 0)
        )
    (when (-> this appearance uv-shift?)
      (let ((f0-2 (/ (the float (- (current-time) (-> pp clock old-frame-counter)))
                     (the float (-> this appearance uv-shift-speed))
                     )
                  )
            )
        (+! (-> this current-uv-shift) f0-2)
        )
      (let ((f0-4 (-> this current-uv-shift)))
        (set! (-> this current-uv-shift) (- f0-4 (the float (the int f0-4))))
        )
      (if (< (-> this current-uv-shift) 1.0)
          (+! (-> this current-uv-shift) 1.0)
          )
      )
    (none)
    )
  )

(defun choose-nice-perp ((arg0 vector))
  (let* ((f0-0 (-> arg0 x))
         (f0-2 (* f0-0 f0-0))
         (f1-0 (-> arg0 z))
         )
    (if (< (+ f0-2 (* f1-0 f1-0)) 0.01)
        *x-vector*
        *up-vector*
        )
    )
  )

;; WARN: Function (method 12 lightning-bolt) has a return type of none, but the expression builder found a return statement.
(defmethod lightning-bolt-method-12 ((this lightning-bolt))
  (local-vars
    (sv-48 int)
    (sv-56 float)
    (sv-60 vector)
    (sv-64 matrix)
    (sv-96 lightning-span)
    (sv-100 lightning-span-internal)
    (sv-104 vector)
    (sv-224 matrix)
    (sv-228 vector)
    (sv-232 vector)
    (sv-236 float)
    (sv-240 vector)
    (sv-244 float)
    (sv-248 float)
    (sv-256 int)
    (sv-288 lightning-span)
    (sv-292 lightning-span-internal)
    (sv-296 vector)
    (sv-416 matrix)
    (sv-420 vector)
    (sv-424 vector)
    (sv-428 vector)
    (sv-432 float)
    )
  (when (= (-> this fade-mode) 3)
    (set! (-> this strip1 num-verts) (the-as uint 0))
    (set! (-> this strip2 num-verts) (the-as uint 0))
    (return 0)
    )
  (set! sv-48 0)
  (set! sv-56 (the-as float 0.0))
  (set! sv-60 (new 'stack-no-clear 'vector))
  (set! sv-64 (new 'stack-no-clear 'matrix))
  (lightning-bolt-method-22 this)
  (set! (-> sv-60 x) 0.0)
  (set! (-> sv-60 y) 0.0)
  (dotimes (s5-0 (-> this num-active-spans))
    (set! sv-96 (-> this spans data s5-0))
    (set! sv-100 (-> this spans-internal data s5-0))
    (set! sv-104 (new 'stack-no-clear 'vector))
    (set! sv-224 (new 'stack-no-clear 'matrix))
    (set! sv-228 (new 'stack-no-clear 'vector))
    (set! sv-232 (new 'stack-no-clear 'vector))
    (set! sv-236 (the-as float 0.0))
    (set! sv-240
          (vector-!
            (new 'stack-no-clear 'vector)
            (-> this span-pts-start data (+ s5-0 1))
            (-> this span-pts-start data s5-0)
            )
          )
    (set! sv-244 (the float (-> sv-100 index)))
    (vector-normalize! sv-240 1.0)
    (set! sv-236
          (vector-vector-distance (-> this span-pts-start data s5-0) (-> this span-pts-start data (+ s5-0 1)))
          )
    (matrix<-vector-yz2! sv-224 sv-240 (choose-nice-perp sv-240))
    (let ((f30-0 (-> sv-96 random-offset-size-start)))
      (lightning-bolt-method-19 this sv-104 sv-48 (+ sv-48 1) sv-224 f30-0 sv-236)
      (set! (-> sv-232 quad) (-> this current-points data sv-48 quad))
      (set! (-> sv-232 x) (* (-> sv-232 x) f30-0))
      (set! (-> sv-232 y) (* (-> sv-232 y) f30-0))
      )
    (set! (-> sv-232 z) (- (-> sv-232 z) sv-244))
    (set! (-> sv-232 z) (* (-> sv-232 z) sv-236))
    (vector-rotate*! sv-228 sv-232 sv-224)
    (vector+! sv-228 sv-228 (-> this span-pts-start data s5-0))
    (lightning-bolt-method-16 this sv-228 (vector-length sv-232) sv-56 sv-60 (the-as matrix sv-104))
    (set! sv-248 (-> sv-96 inner-random-offset-size))
    (dotimes (s4-1 (-> sv-100 num-inner-points))
      (set! sv-256 (+ sv-48 1 s4-1))
      (lightning-bolt-method-19 this sv-104 (+ sv-256 -1) sv-256 sv-224 sv-248 sv-236)
      (set! (-> sv-232 quad) (-> this current-points data sv-256 quad))
      (set! (-> sv-232 x) (* (-> sv-232 x) sv-248))
      (set! (-> sv-232 y) (* (-> sv-232 y) sv-248))
      (set! (-> sv-232 z) (- (-> sv-232 z) sv-244))
      (set! (-> sv-232 z) (* (-> sv-232 z) sv-236))
      (vector-rotate*! sv-228 sv-232 sv-224)
      (vector+! sv-228 sv-228 (-> this span-pts-start data s5-0))
      (lightning-bolt-method-16 this sv-228 (vector-length sv-232) sv-56 sv-60 (the-as matrix sv-104))
      )
    (set! sv-56 (+ sv-56 sv-236))
    (set! sv-48 (+ (-> sv-100 num-inner-points) 1 sv-48))
    (set! (-> sv-64 rvec quad) (-> sv-104 quad))
    )
  (let ((s5-1 (-> this num-active-spans)))
    (set! sv-288 (-> this spans data s5-1))
    (set! sv-292 (-> this spans-internal data s5-1))
    (set! sv-296 (new 'stack-no-clear 'vector))
    (set! sv-416 (new 'stack-no-clear 'matrix))
    (set! sv-420 (new 'stack-no-clear 'vector))
    (set! sv-424 (new 'stack-no-clear 'vector))
    (set! sv-428 (vector-!
                   (new 'stack-no-clear 'vector)
                   (-> this span-pts-start data s5-1)
                   (-> this span-pts-start data (+ s5-1 -1))
                   )
          )
    (set! sv-432 (the float (-> sv-292 index)))
    (vector-normalize! sv-428 1.0)
    (matrix<-vector-yz2! sv-416 sv-428 (choose-nice-perp sv-428))
    (let ((f0-33 (-> sv-288 random-offset-size-start)))
      (set! (-> sv-424 quad) (-> this current-points data sv-48 quad))
      (set! (-> sv-424 x) (* (-> sv-424 x) f0-33))
      (set! (-> sv-424 y) (* (-> sv-424 y) f0-33))
      )
    (set! (-> sv-424 z) (- (-> sv-424 z) sv-432))
    (vector-rotate*! sv-420 sv-424 sv-416)
    (vector+! sv-420 sv-420 (-> this span-pts-start data s5-1))
    )
  (lightning-bolt-method-16 this sv-420 0.0 sv-56 sv-60 sv-64)
  0
  (none)
  )

(defmethod relocate ((this lightning-bolt) (offset int))
  (if (nonzero? (-> this spans))
      (&+! (-> this spans) offset)
      )
  (if (nonzero? (-> this strip1))
      (&+! (-> this strip1) offset)
      )
  (if (nonzero? (-> this strip2))
      (&+! (-> this strip2) offset)
      )
  (dotimes (v1-12 (+ (-> this num-spans) -1))
    )
  (if (nonzero? (-> this spans-internal))
      (&+! (-> this spans-internal) offset)
      )
  (if (nonzero? (-> this current-points))
      (&+! (-> this current-points) offset)
      )
  (if (nonzero? (-> this desired-points))
      (&+! (-> this desired-points) offset)
      )
  (if (nonzero? (-> this span-pts-start))
      (&+! (-> this span-pts-start) offset)
      )
  (call-parent-method this offset)
  )

(defmethod lightning-bolt-method-17 ((this lightning-bolt) (arg0 uint) (arg1 float) (arg2 float) (arg3 curve2d-fast) (arg4 float))
  (if (not arg3)
      (return 1.0)
      )
  (let ((v1-2 arg0))
    (cond
      ((zero? v1-2)
       (curve2d-method-9 arg3 (/ arg2 arg4) 3)
       )
      ((= v1-2 1)
       (curve2d-method-9 arg3 arg1 3)
       )
      ((= v1-2 2)
       (let* ((v1-6 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
              (v1-7 (the-as number (logior #x3f800000 v1-6)))
              )
         (+ -1.0 (the-as float v1-7))
         )
       )
      (else
        1.0
        )
      )
    )
  )

(defmethod lightning-bolt-method-16 ((this lightning-bolt) (arg0 vector) (arg1 float) (arg2 float) (arg3 vector) (arg4 matrix))
  (local-vars (sv-160 vector) (sv-164 vector) (sv-168 vector) (sv-172 vector) (sv-176 rgba))
  0.0
  0.0
  0.0
  (let ((f28-0
          (/ (the float (- (current-time) (-> this last-generate-time))) (the float (-> this inner-point-travel-time)))
          )
        (f30-0 (+ arg2 arg1))
        )
    (math-camera-pos)
    (let* ((s2-0 (-> this appearance))
           (f24-0 (* (lightning-bolt-method-17
                       this
                       (-> s2-0 alpha-1-mode)
                       f28-0
                       f30-0
                       (-> s2-0 alpha-1-curve)
                       (-> s2-0 alpha-1-repeat-dist)
                       )
                     (lightning-bolt-method-17
                       this
                       (-> s2-0 alpha-2-mode)
                       f28-0
                       f30-0
                       (-> s2-0 alpha-2-curve)
                       (-> s2-0 alpha-2-repeat-dist)
                       )
                     (-> s2-0 base-alpha)
                     (-> this current-fade-scalar)
                     )
                  )
           (f22-0 (* (lightning-bolt-method-17
                       this
                       (-> s2-0 width-mode)
                       f28-0
                       f30-0
                       (-> s2-0 width-curve)
                       (-> s2-0 width-repeat-dist)
                       )
                     (-> this base-width)
                     )
                  )
           (f0-14 (/ f30-0 (-> s2-0 uv-repeat-dist)))
           (f28-1 (+ (- f0-14 (* (the float (the int (/ f0-14 6.0))) 6.0)) (-> this current-uv-shift)))
           )
      (vector-normalize! (the-as vector arg4) 1.0)
      (let* ((a2-4 (-> (camera-matrix) uvec))
             (v1-13 (matrix-f-u-compose (new 'stack-no-clear 'matrix) (the-as vector arg4) a2-4))
             (f26-1 6.0)
             )
        (set! sv-160 (vector+float*! (new 'stack-no-clear 'vector) arg0 (-> v1-13 rvec) (* 0.5 f22-0)))
        (set! sv-164 (vector+float*! (new 'stack-no-clear 'vector) arg0 (-> v1-13 rvec) (* -0.5 f22-0)))
        (set! sv-168 (vector+float*! (new 'stack-no-clear 'vector) arg0 (-> v1-13 uvec) (* 0.5 f22-0)))
        (set! sv-172 (vector+float*! (new 'stack-no-clear 'vector) arg0 (-> v1-13 uvec) (* -0.5 f22-0)))
        (set! sv-176 (the-as rgba (new 'stack-no-clear 'array 'rgba 1)))
        (set! sv-176 (-> this base-color))
        (set! sv-176 (copy-and-set-field sv-176 a (the int (* 128.0 f24-0))))
        (when (< f28-1 (-> arg3 x))
          (let ((s3-1 (new 'stack-no-clear 'vector))
                (s4-1 (new 'stack-no-clear 'vector))
                )
            (let ((f24-1 (/ (- (+ f26-1 f28-1) (-> arg3 x)) f26-1)))
              (let ((a1-10 (+ (the-as uint (-> this strip1 data 0 pos)) (* (+ (-> this strip1 num-verts) -2) 32)))
                    (s2-1 (+ (the-as uint (-> this strip1 data 0 pos)) (* (+ (-> this strip1 num-verts) -1) 32)))
                    )
                (vector-lerp! s3-1 (the-as vector a1-10) sv-160 f24-1)
                (vector-lerp! s4-1 (the-as vector s2-1) sv-164 f24-1)
                )
              (lightning-bolt-method-18 this (-> this strip1) s3-1 sv-176 0.0 f26-1)
              (lightning-bolt-method-18 this (-> this strip1) s4-1 sv-176 1.0 f26-1)
              (lightning-bolt-method-18 this (-> this strip1) s3-1 sv-176 0.0 0.0)
              (lightning-bolt-method-18 this (-> this strip1) s4-1 sv-176 1.0 0.0)
              (let ((a1-16 (+ (the-as uint (-> this strip2 data 0 pos)) (* (+ (-> this strip2 num-verts) -2) 32)))
                    (s2-2 (+ (the-as uint (-> this strip2 data 0 pos)) (* (+ (-> this strip2 num-verts) -1) 32)))
                    )
                (vector-lerp! s3-1 (the-as vector a1-16) sv-168 f24-1)
                (vector-lerp! s4-1 (the-as vector s2-2) sv-172 f24-1)
                )
              )
            (lightning-bolt-method-18 this (-> this strip2) s3-1 sv-176 1.0 f26-1)
            (lightning-bolt-method-18 this (-> this strip2) s4-1 sv-176 0.0 f26-1)
            (lightning-bolt-method-18 this (-> this strip2) s3-1 sv-176 1.0 0.0)
            (lightning-bolt-method-18 this (-> this strip2) s4-1 sv-176 0.0 0.0)
            )
          )
        )
      (lightning-bolt-method-18 this (-> this strip1) sv-160 sv-176 0.0 f28-1)
      (lightning-bolt-method-18 this (-> this strip1) sv-164 sv-176 1.0 f28-1)
      (lightning-bolt-method-18 this (-> this strip2) sv-168 sv-176 1.0 f28-1)
      (lightning-bolt-method-18 this (-> this strip2) sv-172 sv-176 0.0 f28-1)
      (set! (-> arg3 y) f30-0)
      (set! (-> arg3 x) f28-1)
      )
    )
  0
  (none)
  )

(defmethod lightning-bolt-method-18 ((this lightning-bolt) (arg0 prim-strip) (arg1 vector) (arg2 rgba) (arg3 float) (arg4 float))
  (when (< (-> arg0 num-verts) (-> arg0 allocated-num-verts))
    (let ((v1-5 (-> arg0 data (-> arg0 num-verts))))
      (set! (-> v1-5 pos quad) (-> arg1 quad))
      (set! (-> v1-5 col) arg2)
      (set! (-> v1-5 stq x) arg3)
      (set! (-> v1-5 stq y) arg4)
      )
    (+! (-> arg0 num-verts) 1)
    )
  0
  (none)
  )

(defbehavior lightning-new-tracker-init-by-other lightning-new-tracker ((arg0 lightning-tracker-init-params))
  (set! (-> self bolt) (new 'process 'lightning-bolt))
  (init! (-> self bolt) 2 (+ (-> arg0 num-inner-points) 2) (-> arg0 appearance))
  (set! (-> self lifetime) (-> arg0 lifetime))
  (set! (-> self bolt span-pts-start data 0 quad) (-> arg0 start-pt quad))
  (set! (-> self bolt span-pts-start data 1 quad) (-> arg0 end-pt quad))
  (set! (-> self bolt spans-internal data 0 num-inner-points) (-> arg0 num-inner-points))
  (set! (-> self bolt spans data 0 inner-random-offset-size) (-> arg0 inner-random-offset-size))
  (set! (-> self bolt spans data 0 random-offset-size-start) (-> arg0 random-offset-size-start))
  (set! (-> self bolt inner-point-travel-time) (seconds 0.017))
  (set! (-> self bolt snap-inner-points?) #t)
  (set! (-> self bolt appearance) (-> arg0 appearance))
  (set! (-> self bolt fractal-reduction) 0.4)
  (set! (-> self bolt generate-mode) (the-as uint 1))
  (go-virtual active)
  )

;; WARN: Return type mismatch process vs lightning-new-tracker.
(defun create-lightning-tracker-new ((arg0 lightning-tracker-init-params))
  (let ((v1-1 (process-spawn lightning-new-tracker arg0 :name "lightning-new-tracker" :stack-size #x8000)))
    (if v1-1
        (return (the-as lightning-new-tracker (-> v1-1 0)))
        )
    )
  (the-as lightning-new-tracker #f)
  )

(defmethod relocate ((this lightning-new-tracker) (offset int))
  (if (nonzero? (-> this bolt))
      (&+! (-> this bolt) offset)
      )
  (call-parent-method this offset)
  )

(defstate active (lightning-new-tracker)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self bolt num-active-spans) 1)
    (lightning-bolt-method-13 (-> self bolt) 0)
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (-> self lifetime))
        (go-virtual die)
        )
    (lightning-bolt-method-11 (-> self bolt))
    (lightning-bolt-method-12 (-> self bolt))
    )
  :code sleep-code
  )

(defstate die (lightning-new-tracker)
  :virtual #t
  :enter (behavior ()
    (lightning-bolt-method-13 (-> self bolt) 2)
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (lightning-bolt-method-11 (-> self bolt))
    (lightning-bolt-method-12 (-> self bolt))
    )
  :code (behavior ()
    (until (= (lightning-bolt-method-14 (-> self bolt)) 3)
      (suspend)
      )
    )
  )
