;;-*-Lisp-*-
(in-package goal)

;; name: eye.gc
;; name in dgo: eye
;; dgos: GAME

;; DECOMP BEGINS

;; og:preserve-this
(defun fnv64 ((data pointer) (length int))
  "64-bit hash for strings. This is extremely unlikely to have collisions for all strings
   in the game. (modern ND games rely on this and use this hash function as unique ID's for
   strings."
  (let* ((ret (the uint #xcbf29ce484222325))
         (ptr (the (pointer uint8) data))
         (end (&+ ptr length)))
    (while (!= ptr end)
      (set! ret (imul64 (logxor (-> ptr) ret) 1099511628211))
      (&+! ptr 1)
      )
    ret
    )
  )

(defun fnv64-string ((str string))
  (fnv64 (-> str data) (length str))
  )

(define *current-eye-merc-ctrl-name* (the string #f))

(define *eye-work* (new 'static 'eye-work
                     :sprite-tmpl (new 'static 'dma-gif-packet
                       :dma-vif (new 'static 'dma-packet
                         :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                         :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                         )
                       :gif (new 'static 'array uint64 2 #x508b400000008001 #x53531)
                       )
                     :sprite-tmpl2 (new 'static 'dma-gif-packet
                       :dma-vif (new 'static 'dma-packet
                         :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                         :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                         )
                       :gif (new 'static 'array uint64 2 #x50ab400000008001 #x53531)
                       )
                     :adgif-tmpl (new 'static 'dma-gif-packet
                       :dma-vif (new 'static 'dma-packet
                         :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                         :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                         )
                       :gif (new 'static 'array uint64 2 #x1000000000008005 #xe)
                       )
                     :blink-table (new 'static 'array float 10 0.0 0.667 0.9 1.0 1.0 1.0 1.0 0.333 0.1 0.0)
                     )
        )

(defun find-free-eye-index ((arg0 int) (arg1 string) (arg2 int))
  (dotimes (s4-0 32)
    (let ((s2-0 (-> *eye-control-array* data s4-0)))
      (when (!= (-> s2-0 level-index) -1)
        (when (string-charp= arg1 (-> s2-0 art-group-name))
          (if (= (-> *kernel-context* login-level-index) (-> s2-0 level-index))
              (return s4-0)
              )
          )
        )
      )
    )
  (let ((v1-14 (-> *level* level (-> *kernel-context* login-level-index))))
    (dotimes (s4-1 32)
      (let ((s2-1 (-> *eye-control-array* data s4-1)))
        (when (= (-> s2-1 level-index) -1)
          (cond
            ((< arg2 60)
             (set! (-> s2-1 high-res?) #f)
             (set! (-> s2-1 eye-slot) (logand (-> v1-14 eye-slot-lowres arg0) 15))
             (+! (-> v1-14 eye-slot-lowres arg0) 1)
             )
            (else
              (set! (-> s2-1 high-res?) #t)
              (set! (-> s2-1 eye-slot) (logand (-> v1-14 eye-slot-highres arg0) 3))
              (+! (-> v1-14 eye-slot-highres arg0) 1)
              )
            )
          (copyn-charp<-string (-> s2-1 art-group-name) arg1 (min 63 (+ (length arg1) 1)))
          (set! (-> s2-1 level-index) (-> *kernel-context* login-level-index))
          (return s4-1)
          )
        )
      )
    )
  (format 0 "ERROR: no free eye-controls available.~%")
  0
  )

(defun free-eye-index ((idx int))
  (when (< idx 32)
    (let ((v1-4 (-> *eye-control-array* data idx)))
      (set! (-> v1-4 process) (the-as handle #f))
      (set! (-> v1-4 random-time) (the-as uint 60))
      (set! (-> v1-4 blink) 0.0)
      (set! (-> v1-4 shaders) (the-as (inline-array adgif-shader) #f))
      (set! (-> v1-4 level-index) -1)
      (set! (-> v1-4 high-res?) #f)
      (set! (-> v1-4 eye-slot) (the-as uint 0))
      (set! (-> v1-4 art-group-name 0) (the-as uint 0))
      (dotimes (a0-4 2)
        (set! (-> v1-4 eyes a0-4 shader-count) (the-as uint 0))
        (dotimes (a1-3 8)
          (set! (-> (the-as eye-control (+ (+ (* a1-3 4) (* 80 a0-4)) (the-as int v1-4))) left shader 0) #f)
          )
        )
      )
    )
  0
  )

(defun render-eyes-32 ((arg0 dma-buffer) (arg1 eye-control) (arg2 int))
  (local-vars (sv-16 float))
  (let ((v1-0 *display*)
        (a0-1 1776)
        )
    (+! (-> v1-0 mem-reserve-size) a0-1)
    (when (not (-> v1-0 dma-buffer-overflow))
      (let ((a2-1 (-> v1-0 frames (-> v1-0 on-screen) global-buf)))
        (if (< (-> a2-1 real-buffer-end) (the-as int (&+ (-> a2-1 base) a0-1)))
            (set! (-> v1-0 dma-buffer-overflow) #t)
            )
        )
      (when (not (-> v1-0 dma-buffer-overflow))
        (let* ((v1-2 (-> arg1 eye-slot))
               (s4-0 32)
               (s3-0 (+ (* v1-2 32) 32))
               (s2-0 (* v1-2 32))
               )
          (let ((f28-0 (* 16.0 (+ (the float (+ s4-0 16)) (* 32.0 (-> arg1 left x)))))
                (f26-0 (* 16.0 (+ (the float (+ s3-0 16)) (* 32.0 (-> arg1 left y)))))
                (f30-0 (* 16.0 (+ (the float (+ s4-0 48)) (* 32.0 (-> arg1 right x)))))
                )
            (set! sv-16 (* 16.0 (+ (the float (+ s3-0 16)) (* 32.0 (-> arg1 right y)))))
            (let ((s1-0 (-> arg1 shaders 0)))
              (let ((v1-16 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-16) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-16) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-0 (the-as structure (&+ (the-as dma-gif-packet v1-16) 32))))
                  (quad-copy! (the-as pointer s0-0) (the-as pointer s1-0) 5)
                  (set! (-> (the-as adgif-shader s0-0) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-0) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-0) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0)))
              (let ((v1-25 (the-as object (-> arg0 base))))
                (set! (-> (the-as (inline-array vector4w) v1-25) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) v1-25) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 2) 128 128 128 128)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 3) 0 0 0 0)
                ;; og:preserve-this: stash the hashed name of the merc-ctrl that will read these eyes:
                (set! (-> (the (pointer uint64) v1-25) 6)
                      (fnv64-string *current-eye-merc-ctrl-name*)
                      )
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 4) (* s4-0 16) (the-as int (* s3-0 16)) #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 5) 0 0 0 0)
                (set-vector!
                  (-> (the-as (inline-array vector4w) v1-25) 6)
                  (* (+ s4-0 64) 16)
                  (the-as int (* (+ s3-0 32) 16))
                  #xffffff
                  0
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-30 (ash 16 (the-as int (-> s1-0 tex0 tw))))
                    (a0-35 (ash 16 (the-as int (-> s1-0 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x1f :scay1 (+ s2-0 31) :scay0 s2-0)))
                (let* ((f0-6 (* 256.0 (-> arg1 left iris-scale)))
                       (a1-34 (the-as object (-> arg0 base)))
                       (a2-15 (the int (- f28-0 f0-6)))
                       (t0-5 (the int (- f26-0 f0-6)))
                       (a3-9 (the int (+ f28-0 f0-6)))
                       (t1-0 (the int (+ f26-0 f0-6)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-34) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-34) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 4) a2-15 t0-5 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 5) v1-30 a0-35 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 6) a3-9 t1-0 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-1 (-> arg1 shaders 3)))
              (let ((v1-35 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-35) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-35) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-1 (the-as structure (&+ (the-as dma-gif-packet v1-35) 32))))
                  (quad-copy! (the-as pointer s0-1) (the-as pointer s1-1) 5)
                  (set! (-> (the-as adgif-shader s0-1) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-1) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-1) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-42 (ash 16 (the-as int (-> s1-1 tex0 tw))))
                    (a0-47 (ash 16 (the-as int (-> s1-1 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x20 :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0))
                                       )
                (let* ((f0-10 (* 256.0 (-> arg1 right iris-scale)))
                       (a1-44 (the-as object (-> arg0 base)))
                       (a2-25 (the int (- f30-0 f0-10)))
                       (t0-11 (the int (- sv-16 f0-10)))
                       (a3-19 (the int (+ f30-0 f0-10)))
                       (t1-1 (the int (+ sv-16 f0-10)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-44) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-44) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 4) a2-25 t0-11 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 5) v1-42 a0-47 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 6) a3-19 t1-1 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (dma-buffer-add-gs-set arg0
                                   (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                                   )
            (let ((s1-2 (-> arg1 shaders 1)))
              (let ((v1-50 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-50) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-50) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-2 (the-as structure (&+ (the-as dma-gif-packet v1-50) 32))))
                  (quad-copy! (the-as pointer s0-2) (the-as pointer s1-2) 5)
                  (set! (-> (the-as adgif-shader s0-2) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-2) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-2) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-57 (ash 16 (the-as int (-> s1-2 tex0 tw))))
                    (a0-65 (ash 16 (the-as int (-> s1-2 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x1f :scay1 (+ s2-0 31) :scay0 s2-0)))
                (let* ((f0-14 (* 256.0 (-> arg1 left pupil-scale)))
                       (a1-61 (the-as object (-> arg0 base)))
                       (a2-35 (the int (- f28-0 f0-14)))
                       (t0-17 (the int (- f26-0 f0-14)))
                       (a3-29 (the int (+ f28-0 f0-14)))
                       (t1-2 (the int (+ f26-0 f0-14)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-61) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-61) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 4) a2-35 t0-17 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 5) v1-57 a0-65 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 6) a3-29 t1-2 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-3 (-> arg1 shaders 4)))
              (let ((v1-62 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-62) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-62) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-3 (the-as structure (&+ (the-as dma-gif-packet v1-62) 32))))
                  (quad-copy! (the-as pointer s0-3) (the-as pointer s1-3) 5)
                  (set! (-> (the-as adgif-shader s0-3) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-3) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-3) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-69 (ash 16 (the-as int (-> s1-3 tex0 tw))))
                    (a0-77 (ash 16 (the-as int (-> s1-3 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x20 :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0))
                                       )
                (let* ((f0-18 (* 256.0 (-> arg1 right pupil-scale)))
                       (a1-71 (the-as object (-> arg0 base)))
                       (a2-45 (the int (- f30-0 f0-18)))
                       (t0-23 (the int (- sv-16 f0-18)))
                       (a3-39 (the int (+ f30-0 f0-18)))
                       (t1-3 (the int (+ sv-16 f0-18)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-71) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-71) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 4) a2-45 t0-23 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 5) v1-69 a0-77 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 6) a3-39 t1-3 #xffffff 0)
                  )
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (dma-buffer-add-gs-set arg0
                                 (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                 )
          (let ((s1-4 (-> arg1 shaders 2)))
            (let ((v1-77 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-77) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-77) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-4 (the-as structure (&+ (the-as dma-gif-packet v1-77) 32))))
                (quad-copy! (the-as pointer s0-4) (the-as pointer s1-4) 5)
                (set! (-> (the-as adgif-shader s0-4) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                      )
                (set! (-> (the-as adgif-shader s0-4) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-4) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-84 (ash 16 (the-as int (-> s1-4 tex0 tw))))
                  (a0-95 (ash 16 (the-as int (-> s1-4 tex0 th))))
                  )
              (when (< (-> arg1 left lid) 0.0)
                (let ((f0-23 (+ 1.0 (-> arg1 left lid))))
                  (set! (-> arg1 left lid) (+ f0-23 (* (- 1.0 f0-23) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x1f :scay1 (+ s2-0 31) :scay0 s2-0)))
              (let* ((f0-27 (+ (the float (+ s3-0 -32)) (* 32.0 (-> arg1 left lid))))
                     (a1-93 (the-as object (-> arg0 base)))
                     (a2-55 (* s4-0 16))
                     (t0-29 (the int (* 16.0 f0-27)))
                     (a3-51 (* (+ s4-0 32) 16))
                     (t1-6 (the int (* 16.0 (+ f0-27 (* 32.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (inline-array vector4w) a1-93) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-93) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 4) a2-55 t0-29 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 5) v1-84 a0-95 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 6) a3-51 t1-6 #xffffff 0)
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (let ((s1-5 (-> arg1 shaders 5)))
            (let ((v1-89 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-89) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-89) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-5 (the-as structure (&+ (the-as dma-gif-packet v1-89) 32))))
                (quad-copy! (the-as pointer s0-5) (the-as pointer s1-5) 5)
                (set! (-> (the-as adgif-shader s0-5) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                      )
                (set! (-> (the-as adgif-shader s0-5) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-5) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-96 (ash 16 (the-as int (-> s1-5 tex0 tw))))
                  (a0-107 (ash 16 (the-as int (-> s1-5 tex0 th))))
                  )
              (when (< (-> arg1 right lid) 0.0)
                (let ((f0-33 (+ 1.0 (-> arg1 right lid))))
                  (set! (-> arg1 right lid) (+ f0-33 (* (- 1.0 f0-33) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0
                                     (scissor-1 (new 'static 'gs-scissor :scax0 #x20 :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0))
                                     )
              (let* ((f0-37 (+ (the float (+ s3-0 -32)) (* 32.0 (-> arg1 right lid))))
                     (a1-108 (the-as object (-> arg0 base)))
                     (a2-66 (* (+ s4-0 64) 16))
                     (t0-35 (the int (* 16.0 f0-37)))
                     (a3-63 (* (+ s4-0 32) 16))
                     (t1-9 (the int (* 16.0 (+ f0-37 (* 32.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (inline-array vector4w) a1-108) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-108) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 4) a2-66 t0-35 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 5) v1-96 a0-107 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 6) a3-63 t1-9 #xffffff 0)
                )
              )
            )
          )
        (let ((v0-0 (&+ (-> arg0 base) 112)))
          (set! (-> arg0 base) v0-0)
          v0-0
          )
        )
      )
    )
  )

(defun render-eyes-64 ((arg0 dma-buffer) (arg1 eye-control) (arg2 int))
  (local-vars (sv-16 float))
  (let ((v1-0 *display*)
        (a0-1 1776)
        )
    (+! (-> v1-0 mem-reserve-size) a0-1)
    (when (not (-> v1-0 dma-buffer-overflow))
      (let ((a2-1 (-> v1-0 frames (-> v1-0 on-screen) global-buf)))
        (if (< (-> a2-1 real-buffer-end) (the-as int (&+ (-> a2-1 base) a0-1)))
            (set! (-> v1-0 dma-buffer-overflow) #t)
            )
        )
      (when (not (-> v1-0 dma-buffer-overflow))
        (let* ((v1-2 (-> arg1 eye-slot))
               (s4-0 64)
               (s3-0 (+ (* v1-2 64) 64))
               (s2-0 (* v1-2 64))
               )
          (let ((f28-0 (* 16.0 (+ (the float (+ s4-0 32)) (* 64.0 (-> arg1 left x)))))
                (f26-0 (* 16.0 (+ (the float (+ s3-0 32)) (* 64.0 (-> arg1 left y)))))
                (f30-0 (* 16.0 (+ (the float (+ s4-0 96)) (* 64.0 (-> arg1 right x)))))
                )
            (set! sv-16 (* 16.0 (+ (the float (+ s3-0 32)) (* 64.0 (-> arg1 right y)))))
            (let ((s1-0 (-> arg1 shaders 0)))
              (let ((v1-16 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-16) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-16) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-0 (the-as structure (&+ (the-as dma-gif-packet v1-16) 32))))
                  (quad-copy! (the-as pointer s0-0) (the-as pointer s1-0) 5)
                  (set! (-> (the-as adgif-shader s0-0) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-0) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-0) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0)))
              (let ((v1-25 (the-as object (-> arg0 base))))
                (set! (-> (the-as (inline-array vector4w) v1-25) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) v1-25) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 2) 128 128 128 128)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 3) 0 0 0 0)

                ;; og:preserve-this: stash the hashed name of the merc-ctrl that will read these eyes:
                (set! (-> (the (pointer uint64) v1-25) 6)
                      (fnv64-string *current-eye-merc-ctrl-name*)
                      )

                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 4) (* s4-0 16) (the-as int (* s3-0 16)) #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 5) 0 0 0 0)
                (set-vector!
                  (-> (the-as (inline-array vector4w) v1-25) 6)
                  (* (+ s4-0 128) 16)
                  (the-as int (* (+ s3-0 64) 16))
                  #xffffff
                  0
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-30 (ash 16 (the-as int (-> s1-0 tex0 tw))))
                    (a0-35 (ash 16 (the-as int (-> s1-0 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 63) :scay0 s2-0)))
                (let* ((f0-6 (* 512.0 (-> arg1 left iris-scale)))
                       (a1-34 (the-as object (-> arg0 base)))
                       (a2-15 (the int (- f28-0 f0-6)))
                       (t0-5 (the int (- f26-0 f0-6)))
                       (a3-9 (the int (+ f28-0 f0-6)))
                       (t1-0 (the int (+ f26-0 f0-6)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-34) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-34) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 4) a2-15 t0-5 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 5) v1-30 a0-35 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 6) a3-9 t1-0 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-1 (-> arg1 shaders 3)))
              (let ((v1-35 (the-as dma-gif-packet (-> arg0 base))))
                (set! (-> v1-35 dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> v1-35 quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-1 (the-as structure (&+ v1-35 32))))
                  (quad-copy! (the-as pointer s0-1) (the-as pointer s1-1) 5)
                  (set! (-> (the-as adgif-shader s0-1) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-1) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-1) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-42 (ash 16 (the-as int (-> s1-1 tex0 tw))))
                    (a0-47 (ash 16 (the-as int (-> s1-1 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x40 :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0))
                                       )
                (let* ((f0-10 (* 512.0 (-> arg1 right iris-scale)))
                       (a1-44 (the-as object (-> arg0 base)))
                       (a2-25 (the int (- f30-0 f0-10)))
                       (t0-11 (the int (- sv-16 f0-10)))
                       (a3-19 (the int (+ f30-0 f0-10)))
                       (t1-1 (the int (+ sv-16 f0-10)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-44) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-44) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 4) a2-25 t0-11 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 5) v1-42 a0-47 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 6) a3-19 t1-1 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (dma-buffer-add-gs-set arg0
                                   (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                                   )
            (let ((s1-2 (-> arg1 shaders 1)))
              (let ((v1-50 (the-as dma-gif-packet (-> arg0 base))))
                (set! (-> v1-50 dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> v1-50 quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-2 (the-as structure (&+ v1-50 32))))
                  (quad-copy! (the-as pointer s0-2) (the-as pointer s1-2) 5)
                  (set! (-> (the-as adgif-shader s0-2) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-2) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-2) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-57 (ash 16 (the-as int (-> s1-2 tex0 tw))))
                    (a0-65 (ash 16 (the-as int (-> s1-2 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 63) :scay0 s2-0)))
                (let* ((f0-14 (* 512.0 (-> arg1 left pupil-scale)))
                       (a1-61 (the-as object (-> arg0 base)))
                       (a2-35 (the int (- f28-0 f0-14)))
                       (t0-17 (the int (- f26-0 f0-14)))
                       (a3-29 (the int (+ f28-0 f0-14)))
                       (t1-2 (the int (+ f26-0 f0-14)))
                       )
                  (set! (-> (the-as (pointer uint128) a1-61)) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-61) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 4) a2-35 t0-17 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 5) v1-57 a0-65 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 6) a3-29 t1-2 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-3 (-> arg1 shaders 4)))
              (let ((v1-62 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-62) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-62) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-3 (the-as structure (&+ (the-as dma-gif-packet v1-62) 32))))
                  (quad-copy! (the-as pointer s0-3) (the-as pointer s1-3) 5)
                  (set! (-> (the-as adgif-shader s0-3) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-3) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-3) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-69 (ash 16 (the-as int (-> s1-3 tex0 tw))))
                    (a0-77 (ash 16 (the-as int (-> s1-3 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x40 :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0))
                                       )
                (let* ((f0-18 (* 512.0 (-> arg1 right pupil-scale)))
                       (a1-71 (the-as object (-> arg0 base)))
                       (a2-45 (the int (- f30-0 f0-18)))
                       (t0-23 (the int (- sv-16 f0-18)))
                       (a3-39 (the int (+ f30-0 f0-18)))
                       (t1-3 (the int (+ sv-16 f0-18)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-71) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-71) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 4) a2-45 t0-23 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 5) v1-69 a0-77 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 6) a3-39 t1-3 #xffffff 0)
                  )
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (dma-buffer-add-gs-set arg0
                                 (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                 )
          (let ((s1-4 (-> arg1 shaders 2)))
            (let ((v1-77 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-77) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-77) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-4 (the-as structure (&+ (the-as dma-gif-packet v1-77) 32))))
                (quad-copy! (the-as pointer s0-4) (the-as pointer s1-4) 5)
                (set! (-> (the-as adgif-shader s0-4) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                      )
                (set! (-> (the-as adgif-shader s0-4) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-4) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-84 (ash 16 (the-as int (-> s1-4 tex0 tw))))
                  (a0-95 (ash 16 (the-as int (-> s1-4 tex0 th))))
                  )
              (when (< (-> arg1 left lid) 0.0)
                (let ((f0-23 (+ 1.0 (-> arg1 left lid))))
                  (set! (-> arg1 left lid) (+ f0-23 (* (- 1.0 f0-23) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 63) :scay0 s2-0)))
              (let* ((f0-27 (+ (the float (+ s3-0 -64)) (* 64.0 (-> arg1 left lid))))
                     (a1-93 (the-as object (-> arg0 base)))
                     (a2-55 (* s4-0 16))
                     (t0-29 (the int (* 16.0 f0-27)))
                     (a3-51 (* (+ s4-0 64) 16))
                     (t1-6 (the int (* 16.0 (+ f0-27 (* 64.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (inline-array vector4w) a1-93) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-93) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 4) a2-55 t0-29 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 5) v1-84 a0-95 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 6) a3-51 t1-6 #xffffff 0)
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (let ((s1-5 (-> arg1 shaders 5)))
            (let ((v1-89 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-89) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-89) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-5 (the-as structure (&+ (the-as dma-gif-packet v1-89) 32))))
                (quad-copy! (the-as pointer s0-5) (the-as pointer s1-5) 5)
                (set! (-> (the-as adgif-shader s0-5) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                      )
                (set! (-> (the-as adgif-shader s0-5) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-5) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-96 (ash 16 (the-as int (-> s1-5 tex0 tw))))
                  (a0-107 (ash 16 (the-as int (-> s1-5 tex0 th))))
                  )
              (when (< (-> arg1 right lid) 0.0)
                (let ((f0-33 (+ 1.0 (-> arg1 right lid))))
                  (set! (-> arg1 right lid) (+ f0-33 (* (- 1.0 f0-33) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0
                                     (scissor-1 (new 'static 'gs-scissor :scax0 #x40 :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0))
                                     )
              (let* ((f0-37 (+ (the float (+ s3-0 -64)) (* 64.0 (-> arg1 right lid))))
                     (a1-108 (the-as object (-> arg0 base)))
                     (a2-66 (* (+ s4-0 128) 16))
                     (t0-35 (the int (* 16.0 f0-37)))
                     (a3-63 (* (+ s4-0 64) 16))
                     (t1-9 (the int (* 16.0 (+ f0-37 (* 64.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (pointer uint128) a1-108)) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-108) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 4) a2-66 t0-35 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 5) v1-96 a0-107 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 6) a3-63 t1-9 #xffffff 0)
                )
              )
            )
          )
        (let ((v0-0 (&+ (-> arg0 base) 112)))
          (set! (-> arg0 base) v0-0)
          v0-0
          )
        )
      )
    )
  )

(defun update-eyes ()
  (when (not (-> *blit-displays-work* screen-copied))
    (dotimes (gp-0 32)
      (let* ((s5-0 (-> *eye-control-array* data gp-0))
             (v1-7 (handle->process (-> s5-0 process)))
             )
        (when (and v1-7
                   (logtest? (-> (the-as process-drawable v1-7) skel status) (joint-control-status eye-anim))
                   (logtest? (-> (the-as process-drawable v1-7) draw status) (draw-control-status on-screen))
                   )
          (set! *current-eye-merc-ctrl-name* (-> (the process-drawable v1-7) draw mgeo name))
          (when (-> s5-0 shaders)
            (when (not (paused?))
              (cond
                ((and (>= (-> s5-0 left lid) 0.0) (>= (-> s5-0 right lid) 0.0))
                 (set! (-> s5-0 random-time) (the-as uint 60))
                 (set! (-> s5-0 blink) 0.0)
                 )
                (else
                  (+! (-> s5-0 random-time) -1)
                  (let ((v1-19 (-> s5-0 random-time)))
                    (when (< v1-19 (the-as uint 10))
                      (set! (-> s5-0 blink) (-> *eye-work* blink-table v1-19))
                      (if (zero? v1-19)
                          (set! (-> s5-0 random-time) (the-as uint (the int (rand-vu-float-range 60.0 240.0))))
                          )
                      )
                    )
                  )
                )
              )
            (when (-> s5-0 left shader)
              (cond
                ((and (= (-> s5-0 left pupil-scale) 0.0) (= (-> s5-0 left iris-scale) 0.0))
                 (dotimes (v1-24 (the-as int (-> s5-0 left shader-count)))
                   (set! (-> s5-0 left shader v1-24 tex0 tfx) 1)
                   )
                 )
                (else
                  (dotimes (v1-27 (the-as int (-> s5-0 left shader-count)))
                    (set! (-> s5-0 left shader v1-27 tex0 tfx) 0)
                    )
                  )
                )
              )
            (when (-> s5-0 right shader)
              (cond
                ((and (= (-> s5-0 right pupil-scale) 0.0) (= (-> s5-0 right iris-scale) 0.0))
                 (dotimes (v1-34 (the-as int (-> s5-0 right shader-count)))
                   (set! (-> s5-0 right shader v1-34 tex0 tfx) 1)
                   )
                 )
                (else
                  (dotimes (v1-37 (the-as int (-> s5-0 right shader-count)))
                    (set! (-> s5-0 right shader v1-37 tex0 tfx) 0)
                    )
                  )
                )
              )
            (cond
              ((-> s5-0 high-res?)
               (let ((v1-42 *display*)
                     (a0-45 16)
                     )
                 (+! (-> v1-42 mem-reserve-size) a0-45)
                 (when (not (-> v1-42 dma-buffer-overflow))
                   (let ((a2-0 (-> v1-42 frames (-> v1-42 on-screen) global-buf)))
                     (if (< (-> a2-0 real-buffer-end) (the-as int (&+ (-> a2-0 base) a0-45)))
                         (set! (-> v1-42 dma-buffer-overflow) #t)
                         )
                     )
                   (when (not (-> v1-42 dma-buffer-overflow))
                     (with-dma-buffer-add-bucket ((s3-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                                  (the-as bucket-id (-> s5-0 bucket))
                                                  )
                       (let ((t9-2 set-display-gs-state-offset)
                             (a0-50 s3-0)
                             (a1-35 (-> *eyes-texture-base* vram-page))
                             (a2-2 (the-as object 128))
                             )
                         (t9-2 a0-50 (the-as int a1-35) (the-as int a2-2) 256 0 0 64 64)
                         (let ((v1-50 *display*)
                               (a0-51 48)
                               )
                           (+! (-> v1-50 mem-reserve-size) a0-51)
                           (when (not (-> v1-50 dma-buffer-overflow))
                             (let* ((a2-3 (-> v1-50 frames (-> v1-50 on-screen) global-buf))
                                    (a1-44 (-> a2-3 real-buffer-end))
                                    )
                               (set! a2-2 (-> a2-3 base))
                               (if (< a1-44 (the-as int (&+ (the-as pointer a2-2) a0-51)))
                                   (set! (-> v1-50 dma-buffer-overflow) #t)
                                   )
                               )
                             (if (not (-> v1-50 dma-buffer-overflow))
                                 (dma-buffer-add-gs-set s3-0
                                                        (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                                        )
                                 )
                             )
                           )
                         (render-eyes-64 s3-0 s5-0 (the-as int a2-2))
                         )
                       (reset-display-gs-state *display* s3-0)
                       (let ((v1-55 *display*)
                             (a0-62 48)
                             )
                         (+! (-> v1-55 mem-reserve-size) a0-62)
                         (when (not (-> v1-55 dma-buffer-overflow))
                           (let ((a2-4 (-> v1-55 frames (-> v1-55 on-screen) global-buf)))
                             (if (< (-> a2-4 real-buffer-end) (the-as int (&+ (-> a2-4 base) a0-62)))
                                 (set! (-> v1-55 dma-buffer-overflow) #t)
                                 )
                             )
                           (if (not (-> v1-55 dma-buffer-overflow))
                               (dma-buffer-add-gs-set s3-0 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)))
                               )
                           )
                         )
                       )
                     )
                   )
                 )
               )
              ((not (-> s5-0 high-res?))
               (let ((v1-68 *display*)
                     (a0-74 16)
                     )
                 (+! (-> v1-68 mem-reserve-size) a0-74)
                 (when (not (-> v1-68 dma-buffer-overflow))
                   (let ((a2-7 (-> v1-68 frames (-> v1-68 on-screen) global-buf)))
                     (if (< (-> a2-7 real-buffer-end) (the-as int (&+ (-> a2-7 base) a0-74)))
                         (set! (-> v1-68 dma-buffer-overflow) #t)
                         )
                     )
                   (when (not (-> v1-68 dma-buffer-overflow))
                     (with-dma-buffer-add-bucket ((s3-1 (-> *display* frames (-> *display* on-screen) global-buf))
                                                  (the-as bucket-id (-> s5-0 bucket))
                                                  )
                       (let ((t9-6 set-display-gs-state-offset)
                             (a0-79 s3-1)
                             (a1-88 (-> *eyes-texture-base* vram-page))
                             (a2-9 (the-as object 64))
                             )
                         (t9-6 a0-79 (the-as int a1-88) (the-as int a2-9) 512 0 0 32 32)
                         (let ((v1-76 *display*)
                               (a0-80 48)
                               )
                           (+! (-> v1-76 mem-reserve-size) a0-80)
                           (when (not (-> v1-76 dma-buffer-overflow))
                             (let* ((a2-10 (-> v1-76 frames (-> v1-76 on-screen) global-buf))
                                    (a1-97 (-> a2-10 real-buffer-end))
                                    )
                               (set! a2-9 (-> a2-10 base))
                               (if (< a1-97 (the-as int (&+ (the-as pointer a2-9) a0-80)))
                                   (set! (-> v1-76 dma-buffer-overflow) #t)
                                   )
                               )
                             (if (not (-> v1-76 dma-buffer-overflow))
                                 (dma-buffer-add-gs-set s3-1
                                                        (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                                        )
                                 )
                             )
                           )
                         (render-eyes-32 s3-1 s5-0 (the-as int a2-9))
                         )
                       (reset-display-gs-state *display* s3-1)
                       (let ((v1-81 *display*)
                             (a0-91 48)
                             )
                         (+! (-> v1-81 mem-reserve-size) a0-91)
                         (when (not (-> v1-81 dma-buffer-overflow))
                           (let ((a2-11 (-> v1-81 frames (-> v1-81 on-screen) global-buf)))
                             (if (< (-> a2-11 real-buffer-end) (the-as int (&+ (-> a2-11 base) a0-91)))
                                 (set! (-> v1-81 dma-buffer-overflow) #t)
                                 )
                             )
                           (if (not (-> v1-81 dma-buffer-overflow))
                               (dma-buffer-add-gs-set s3-1 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)))
                               )
                           )
                         )
                       )
                     )
                   )
                 )
               )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch uint vs int.
(defun get-eye-block ((arg0 int) (arg1 int))
  (let ((v1-0 arg0)
        (a0-4 (-> ct32-24-block-table (* arg1 4)))
        )
    (the-as int (+ (-> *eyes-texture-base* vram-block) (* v1-0 32) a0-4))
    )
  )

(defun convert-eye-data ((arg0 eye) (arg1 uint))
  (local-vars
    (v0-0 float)
    (v1-0 uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (v1-4 uint128)
    (v1-5 uint128)
    )
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
    (.pextlb v1-0 arg1 0)
    (.pextlh v1-1 v1-0 0)
    (.pw.sra v1-2 v1-1 16)
    (.mov vf1 v1-2)
    (.pextlb v1-3 0 arg1)
    (.pextuh v1-4 0 v1-3)
    (.pw.sll v1-5 v1-4 6)
    (.mov vf2 v1-5)
    (vitof15.xyzw vf1 vf1)
    (vitof12.xyzw vf2 vf2)
    (.svf (&-> arg0 data 0 quad) vf1)
    (.svf (&-> arg0 data 1 quad) vf2)
    (.mov v0-0 vf2)
    v0-0
    )
  )

(defun merc-eye-anim ((arg0 process-drawable))
  (let* ((v1-2 (-> arg0 draw mgeo header eye-ctrl))
         (a0-2 (-> arg0 skel float-channels))
         (s3-0 (cond
                 ((> a0-2 0)
                  (-> arg0 skel channel (+ a0-2 -1 (-> arg0 skel active-channels)))
                  )
                 (else
                   (let ((a0-8 (-> arg0 skel root-channel))
                         (a1-4 (-> arg0 skel effect))
                         )
                     (-> a0-8 (if a1-4
                                  (-> a1-4 channel-offset)
                                  0
                                  )
                         )
                     )
                   )
                 )
               )
         (s4-0 (-> s3-0 frame-group))
         )
    (when (and (logtest? (-> arg0 skel status) (joint-control-status eye-anim))
               (and (nonzero? v1-2) (> (-> arg0 skel active-channels) 0) s4-0)
               )
      (cond
        ((and (-> arg0 skel override) (!= (-> arg0 skel override 41) 0.0))
         (let ((v1-6 (-> *eye-control-array* data (-> v1-2 eye-ctrl-index)))
               (a0-24 (-> arg0 skel override))
               )
           (set! (-> v1-6 left x) (-> a0-24 42))
           (set! (-> v1-6 left y) (-> a0-24 43))
           (set! (-> v1-6 left lid) (-> a0-24 44))
           (set! (-> v1-6 left iris-scale) (-> a0-24 45))
           (set! (-> v1-6 left pupil-scale) (-> a0-24 46))
           (set! (-> v1-6 left lid-scale) (-> a0-24 47))
           (set! (-> v1-6 right x) (-> a0-24 48))
           (set! (-> v1-6 right y) (-> a0-24 49))
           (set! (-> v1-6 right lid) (-> a0-24 50))
           (set! (-> v1-6 right iris-scale) (-> a0-24 51))
           (set! (-> v1-6 right pupil-scale) (-> a0-24 52))
           (set! (-> v1-6 right lid-scale) (-> a0-24 53))
           )
         (logior! (-> arg0 skel status) (joint-control-status eye-anim-valid))
         )
        (else
          (let* ((s5-0 (-> *eye-control-array* data (-> v1-2 eye-ctrl-index)))
                 (f0-13 (-> s3-0 frame-num))
                 (f30-0 (- f0-13 (* (the float (the int (/ f0-13 1.0))) 1.0)))
                 )
            (set! (-> s5-0 process) (process->handle arg0))
            (set! (-> s5-0 shaders) (-> v1-2 shader))
            (let ((a0-34 *level*)
                  (v1-11 (-> arg0 draw))
                  )
              (set! (-> s5-0 bucket) (the-as uint (vu1-bucket-map
                                                    (the-as int (-> a0-34 draw-index-map (-> v1-11 level-index)))
                                                    (the-as int (-> v1-11 default-texture-page))
                                                    (merc-mode texture)
                                                    )
                                             )
                    )
              )
            (let ((s2-0 (new 'stack-no-clear 'eye))
                  (s1-0 (new 'stack-no-clear 'eye))
                  )
              (cond
                ((-> s4-0 eye-anim)
                 (let ((s0-1 (min (the int (-> s3-0 frame-num)) (-> s4-0 eye-anim max-frame)))
                       (s3-2 (min (+ (the int (-> s3-0 frame-num)) 1) (-> s4-0 eye-anim max-frame)))
                       )
                   (convert-eye-data s2-0 (-> s4-0 eye-anim data (* s0-1 2) dword))
                   (convert-eye-data s1-0 (-> s4-0 eye-anim data (* s3-2 2) dword))
                   (vector4-lerp! (the-as vector (-> s5-0 eyes)) (the-as vector (&-> s2-0 x)) (the-as vector (&-> s1-0 x)) f30-0)
                   (vector4-lerp!
                     (the-as vector (&-> s5-0 left iris-scale))
                     (the-as vector (&-> s2-0 iris-scale))
                     (the-as vector (&-> s1-0 iris-scale))
                     f30-0
                     )
                   (convert-eye-data s2-0 (-> s4-0 eye-anim data (+ (* s0-1 2) 1) dword))
                   (convert-eye-data s1-0 (-> s4-0 eye-anim data (+ (* s3-2 2) 1) dword))
                   )
                 (vector4-lerp!
                   (the-as vector (-> s5-0 right))
                   (the-as vector (&-> s2-0 x))
                   (the-as vector (&-> s1-0 x))
                   f30-0
                   )
                 (vector4-lerp!
                   (the-as vector (&-> s5-0 right iris-scale))
                   (the-as vector (&-> s2-0 iris-scale))
                   (the-as vector (&-> s1-0 iris-scale))
                   f30-0
                   )
                 )
                (else
                  (format *stdcon* "no eye anim data for ~s~%" (-> arg0 name))
                  (set! (-> s5-0 left x) 0.0)
                  (set! (-> s5-0 left y) 0.0)
                  (set! (-> s5-0 left lid) -1.0)
                  (set! (-> s5-0 left iris-scale) 0.55)
                  (set! (-> s5-0 left pupil-scale) 0.45)
                  (set! (-> s5-0 left lid-scale) 1.0)
                  (set! (-> s5-0 right x) 0.0)
                  (set! (-> s5-0 right y) 0.0)
                  (set! (-> s5-0 right lid) -1.0)
                  (set! (-> s5-0 right iris-scale) 0.55)
                  (set! (-> s5-0 right pupil-scale) 0.45)
                  (set! (-> s5-0 right lid-scale) 1.0)
                  )
                )
              )
            )
          (logior! (-> arg0 skel status) (joint-control-status eye-anim-valid))
          )
        )
      )
    )
  (if (logtest? (-> arg0 skel status) (joint-control-status eye-anim-valid))
      (logclear! (-> arg0 skel status) (joint-control-status eye-anim-valid))
      )
  0
  (none)
  )
