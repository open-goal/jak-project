;;-*-Lisp-*-
(in-package goal)

;; name: eye.gc
;; name in dgo: eye
;; dgos: GAME

;; DECOMP BEGINS

(define *eye-work* (new 'static 'eye-work
                     :sprite-tmpl (new 'static 'dma-gif-packet
                       :dma-vif (new 'static 'dma-packet
                         :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                         :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                         )
                       :gif (new 'static 'array uint64 2 #x508b400000008001 #x53531)
                       )
                     :sprite-tmpl2 (new 'static 'dma-gif-packet
                       :dma-vif (new 'static 'dma-packet
                         :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                         :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                         )
                       :gif (new 'static 'array uint64 2 #x50ab400000008001 #x53531)
                       )
                     :adgif-tmpl (new 'static 'dma-gif-packet
                       :dma-vif (new 'static 'dma-packet
                         :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
                         :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
                         )
                       :gif (new 'static 'array uint64 2 #x1000000000008005 #xe)
                       )
                     :blink-table (new 'static 'array float 10 0.0 0.667 0.9 1.0 1.0 1.0 1.0 0.333 0.1 0.0)
                     )
        )

(defun find-free-eye-index ((arg0 int) (arg1 string) (arg2 int))
  (dotimes (s4-0 32)
    (let ((s2-0 (-> *eye-control-array* data s4-0)))
      (when (!= (-> s2-0 level-index) -1)
        (when (string-charp= arg1 (-> s2-0 art-group-name))
          (if (= (-> *kernel-context* login-level-index) (-> s2-0 level-index))
              (return s4-0)
              )
          )
        )
      )
    )
  (let ((v1-14 (-> *level* level (-> *kernel-context* login-level-index))))
    (dotimes (s4-1 32)
      (let ((s2-1 (-> *eye-control-array* data s4-1)))
        (when (= (-> s2-1 level-index) -1)
          (cond
            ((< arg2 60)
             (set! (-> s2-1 high-res?) #f)
             (set! (-> s2-1 eye-slot) (logand (-> v1-14 eye-slot-lowres arg0) 15))
             (+! (-> v1-14 eye-slot-lowres arg0) 1)
             )
            (else
              (set! (-> s2-1 high-res?) #t)
              (set! (-> s2-1 eye-slot) (logand (-> v1-14 eye-slot-highres arg0) 3))
              (+! (-> v1-14 eye-slot-highres arg0) 1)
              )
            )
          (copyn-charp<-string (-> s2-1 art-group-name) arg1 (min 63 (+ (length arg1) 1)))
          (set! (-> s2-1 level-index) (-> *kernel-context* login-level-index))
          (return s4-1)
          )
        )
      )
    )
  (format 0 "ERROR: no free eye-controls available.~%")
  0
  )

(defun free-eye-index ((idx int))
  (when (< idx 32)
    (let ((v1-4 (-> *eye-control-array* data idx)))
      (set! (-> v1-4 process) (the-as handle #f))
      (set! (-> v1-4 random-time) (the-as uint 60))
      (set! (-> v1-4 blink) 0.0)
      (set! (-> v1-4 shaders) (the-as (inline-array adgif-shader) #f))
      (set! (-> v1-4 level-index) -1)
      (set! (-> v1-4 high-res?) #f)
      (set! (-> v1-4 eye-slot) (the-as uint 0))
      (set! (-> v1-4 art-group-name 0) (the-as uint 0))
      (dotimes (a0-4 2)
        (set! (-> v1-4 eyes a0-4 shader-count) (the-as uint 0))
        (dotimes (a1-3 8)
          (set! (-> (the-as eye-control (+ (+ (* a1-3 4) (* 80 a0-4)) (the-as int v1-4))) left shader 0) #f)
          )
        )
      )
    )
  0
  )

(defun render-eyes-32 ((arg0 dma-buffer) (arg1 eye-control) (arg2 int))
  (local-vars (sv-16 float))
  (let ((v1-0 *display*)
        (a0-1 1776)
        )
    (+! (-> v1-0 mem-reserve-size) a0-1)
    (when (not (-> v1-0 dma-buffer-overflow))
      (let ((a2-1 (-> v1-0 frames (-> v1-0 on-screen) global-buf)))
        (if (< (-> a2-1 real-buffer-end) (the-as int (&+ (-> a2-1 base) a0-1)))
            (set! (-> v1-0 dma-buffer-overflow) #t)
            )
        )
      (when (not (-> v1-0 dma-buffer-overflow))
        (let* ((v1-2 (-> arg1 eye-slot))
               (s4-0 32)
               (s3-0 (+ (* v1-2 32) 32))
               (s2-0 (* v1-2 32))
               )
          (let ((f28-0 (* 16.0 (+ (the float (+ s4-0 16)) (* 32.0 (-> arg1 left x)))))
                (f26-0 (* 16.0 (+ (the float (+ s3-0 16)) (* 32.0 (-> arg1 left y)))))
                (f30-0 (* 16.0 (+ (the float (+ s4-0 48)) (* 32.0 (-> arg1 right x)))))
                )
            (set! sv-16 (* 16.0 (+ (the float (+ s3-0 16)) (* 32.0 (-> arg1 right y)))))
            (let ((s1-0 (-> arg1 shaders 0)))
              (let ((v1-16 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-16) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-16) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-0 (the-as structure (&+ (the-as dma-gif-packet v1-16) 32))))
                  (quad-copy! (the-as pointer s0-0) (the-as pointer s1-0) 5)
                  (set! (-> (the-as adgif-shader s0-0) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-0) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-0) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0)))
              (let ((v1-25 (the-as object (-> arg0 base))))
                (set! (-> (the-as (inline-array vector4w) v1-25) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) v1-25) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 2) 128 128 128 128)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 4) (* s4-0 16) (the-as int (* s3-0 16)) #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 5) 0 0 0 0)
                (set-vector!
                  (-> (the-as (inline-array vector4w) v1-25) 6)
                  (* (+ s4-0 64) 16)
                  (the-as int (* (+ s3-0 32) 16))
                  #xffffff
                  0
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-30 (ash 16 (the-as int (-> s1-0 tex0 tw))))
                    (a0-35 (ash 16 (the-as int (-> s1-0 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x1f :scay1 (+ s2-0 31) :scay0 s2-0)))
                (let* ((f0-6 (* 256.0 (-> arg1 left iris-scale)))
                       (a1-34 (the-as object (-> arg0 base)))
                       (a2-15 (the int (- f28-0 f0-6)))
                       (t0-5 (the int (- f26-0 f0-6)))
                       (a3-9 (the int (+ f28-0 f0-6)))
                       (t1-0 (the int (+ f26-0 f0-6)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-34) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-34) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 4) a2-15 t0-5 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 5) v1-30 a0-35 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 6) a3-9 t1-0 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-1 (-> arg1 shaders 3)))
              (let ((v1-35 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-35) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-35) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-1 (the-as structure (&+ (the-as dma-gif-packet v1-35) 32))))
                  (quad-copy! (the-as pointer s0-1) (the-as pointer s1-1) 5)
                  (set! (-> (the-as adgif-shader s0-1) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-1) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-1) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-42 (ash 16 (the-as int (-> s1-1 tex0 tw))))
                    (a0-47 (ash 16 (the-as int (-> s1-1 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x20 :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0))
                                       )
                (let* ((f0-10 (* 256.0 (-> arg1 right iris-scale)))
                       (a1-44 (the-as object (-> arg0 base)))
                       (a2-25 (the int (- f30-0 f0-10)))
                       (t0-11 (the int (- sv-16 f0-10)))
                       (a3-19 (the int (+ f30-0 f0-10)))
                       (t1-1 (the int (+ sv-16 f0-10)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-44) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-44) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 4) a2-25 t0-11 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 5) v1-42 a0-47 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 6) a3-19 t1-1 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (dma-buffer-add-gs-set arg0
                                   (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                                   )
            (let ((s1-2 (-> arg1 shaders 1)))
              (let ((v1-50 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-50) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-50) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-2 (the-as structure (&+ (the-as dma-gif-packet v1-50) 32))))
                  (quad-copy! (the-as pointer s0-2) (the-as pointer s1-2) 5)
                  (set! (-> (the-as adgif-shader s0-2) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-2) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-2) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-57 (ash 16 (the-as int (-> s1-2 tex0 tw))))
                    (a0-65 (ash 16 (the-as int (-> s1-2 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x1f :scay1 (+ s2-0 31) :scay0 s2-0)))
                (let* ((f0-14 (* 256.0 (-> arg1 left pupil-scale)))
                       (a1-61 (the-as object (-> arg0 base)))
                       (a2-35 (the int (- f28-0 f0-14)))
                       (t0-17 (the int (- f26-0 f0-14)))
                       (a3-29 (the int (+ f28-0 f0-14)))
                       (t1-2 (the int (+ f26-0 f0-14)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-61) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-61) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 4) a2-35 t0-17 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 5) v1-57 a0-65 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 6) a3-29 t1-2 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-3 (-> arg1 shaders 4)))
              (let ((v1-62 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-62) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-62) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-3 (the-as structure (&+ (the-as dma-gif-packet v1-62) 32))))
                  (quad-copy! (the-as pointer s0-3) (the-as pointer s1-3) 5)
                  (set! (-> (the-as adgif-shader s0-3) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                        )
                  (set! (-> (the-as adgif-shader s0-3) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-3) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-69 (ash 16 (the-as int (-> s1-3 tex0 tw))))
                    (a0-77 (ash 16 (the-as int (-> s1-3 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x20 :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0))
                                       )
                (let* ((f0-18 (* 256.0 (-> arg1 right pupil-scale)))
                       (a1-71 (the-as object (-> arg0 base)))
                       (a2-45 (the int (- f30-0 f0-18)))
                       (t0-23 (the int (- sv-16 f0-18)))
                       (a3-39 (the int (+ f30-0 f0-18)))
                       (t1-3 (the int (+ sv-16 f0-18)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-71) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-71) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 4) a2-45 t0-23 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 5) v1-69 a0-77 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 6) a3-39 t1-3 #xffffff 0)
                  )
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (dma-buffer-add-gs-set arg0
                                 (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                 )
          (let ((s1-4 (-> arg1 shaders 2)))
            (let ((v1-77 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-77) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-77) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-4 (the-as structure (&+ (the-as dma-gif-packet v1-77) 32))))
                (quad-copy! (the-as pointer s0-4) (the-as pointer s1-4) 5)
                (set! (-> (the-as adgif-shader s0-4) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                      )
                (set! (-> (the-as adgif-shader s0-4) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-4) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-84 (ash 16 (the-as int (-> s1-4 tex0 tw))))
                  (a0-95 (ash 16 (the-as int (-> s1-4 tex0 th))))
                  )
              (when (< (-> arg1 left lid) 0.0)
                (let ((f0-23 (+ 1.0 (-> arg1 left lid))))
                  (set! (-> arg1 left lid) (+ f0-23 (* (- 1.0 f0-23) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x1f :scay1 (+ s2-0 31) :scay0 s2-0)))
              (let* ((f0-27 (+ (the float (+ s3-0 -32)) (* 32.0 (-> arg1 left lid))))
                     (a1-93 (the-as object (-> arg0 base)))
                     (a2-55 (* s4-0 16))
                     (t0-29 (the int (* 16.0 f0-27)))
                     (a3-51 (* (+ s4-0 32) 16))
                     (t1-6 (the int (* 16.0 (+ f0-27 (* 32.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (inline-array vector4w) a1-93) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-93) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 4) a2-55 t0-29 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 5) v1-84 a0-95 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 6) a3-51 t1-6 #xffffff 0)
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (let ((s1-5 (-> arg1 shaders 5)))
            (let ((v1-89 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-89) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-89) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-5 (the-as structure (&+ (the-as dma-gif-packet v1-89) 32))))
                (quad-copy! (the-as pointer s0-5) (the-as pointer s1-5) 5)
                (set! (-> (the-as adgif-shader s0-5) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x1f :maxv #x1f)
                      )
                (set! (-> (the-as adgif-shader s0-5) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-5) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-96 (ash 16 (the-as int (-> s1-5 tex0 tw))))
                  (a0-107 (ash 16 (the-as int (-> s1-5 tex0 th))))
                  )
              (when (< (-> arg1 right lid) 0.0)
                (let ((f0-33 (+ 1.0 (-> arg1 right lid))))
                  (set! (-> arg1 right lid) (+ f0-33 (* (- 1.0 f0-33) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0
                                     (scissor-1 (new 'static 'gs-scissor :scax0 #x20 :scax1 #x3f :scay1 (+ s2-0 31) :scay0 s2-0))
                                     )
              (let* ((f0-37 (+ (the float (+ s3-0 -32)) (* 32.0 (-> arg1 right lid))))
                     (a1-108 (the-as object (-> arg0 base)))
                     (a2-66 (* (+ s4-0 64) 16))
                     (t0-35 (the int (* 16.0 f0-37)))
                     (a3-63 (* (+ s4-0 32) 16))
                     (t1-9 (the int (* 16.0 (+ f0-37 (* 32.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (inline-array vector4w) a1-108) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-108) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 4) a2-66 t0-35 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 5) v1-96 a0-107 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 6) a3-63 t1-9 #xffffff 0)
                )
              )
            )
          )
        (let ((v0-0 (&+ (-> arg0 base) 112)))
          (set! (-> arg0 base) v0-0)
          v0-0
          )
        )
      )
    )
  )

(defun render-eyes-64 ((arg0 dma-buffer) (arg1 eye-control) (arg2 int))
  (local-vars (sv-16 float))
  (let ((v1-0 *display*)
        (a0-1 1776)
        )
    (+! (-> v1-0 mem-reserve-size) a0-1)
    (when (not (-> v1-0 dma-buffer-overflow))
      (let ((a2-1 (-> v1-0 frames (-> v1-0 on-screen) global-buf)))
        (if (< (-> a2-1 real-buffer-end) (the-as int (&+ (-> a2-1 base) a0-1)))
            (set! (-> v1-0 dma-buffer-overflow) #t)
            )
        )
      (when (not (-> v1-0 dma-buffer-overflow))
        (let* ((v1-2 (-> arg1 eye-slot))
               (s4-0 64)
               (s3-0 (+ (* v1-2 64) 64))
               (s2-0 (* v1-2 64))
               )
          (let ((f28-0 (* 16.0 (+ (the float (+ s4-0 32)) (* 64.0 (-> arg1 left x)))))
                (f26-0 (* 16.0 (+ (the float (+ s3-0 32)) (* 64.0 (-> arg1 left y)))))
                (f30-0 (* 16.0 (+ (the float (+ s4-0 96)) (* 64.0 (-> arg1 right x)))))
                )
            (set! sv-16 (* 16.0 (+ (the float (+ s3-0 32)) (* 64.0 (-> arg1 right y)))))
            (let ((s1-0 (-> arg1 shaders 0)))
              (let ((v1-16 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-16) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-16) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-0 (the-as structure (&+ (the-as dma-gif-packet v1-16) 32))))
                  (quad-copy! (the-as pointer s0-0) (the-as pointer s1-0) 5)
                  (set! (-> (the-as adgif-shader s0-0) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-0) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-0) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0)))
              (let ((v1-25 (the-as object (-> arg0 base))))
                (set! (-> (the-as (inline-array vector4w) v1-25) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) v1-25) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 2) 128 128 128 128)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 4) (* s4-0 16) (the-as int (* s3-0 16)) #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) v1-25) 5) 0 0 0 0)
                (set-vector!
                  (-> (the-as (inline-array vector4w) v1-25) 6)
                  (* (+ s4-0 128) 16)
                  (the-as int (* (+ s3-0 64) 16))
                  #xffffff
                  0
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-30 (ash 16 (the-as int (-> s1-0 tex0 tw))))
                    (a0-35 (ash 16 (the-as int (-> s1-0 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 63) :scay0 s2-0)))
                (let* ((f0-6 (* 512.0 (-> arg1 left iris-scale)))
                       (a1-34 (the-as object (-> arg0 base)))
                       (a2-15 (the int (- f28-0 f0-6)))
                       (t0-5 (the int (- f26-0 f0-6)))
                       (a3-9 (the int (+ f28-0 f0-6)))
                       (t1-0 (the int (+ f26-0 f0-6)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-34) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-34) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 4) a2-15 t0-5 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 5) v1-30 a0-35 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-34) 6) a3-9 t1-0 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-1 (-> arg1 shaders 3)))
              (let ((v1-35 (the-as dma-gif-packet (-> arg0 base))))
                (set! (-> v1-35 dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> v1-35 quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-1 (the-as structure (&+ v1-35 32))))
                  (quad-copy! (the-as pointer s0-1) (the-as pointer s1-1) 5)
                  (set! (-> (the-as adgif-shader s0-1) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-1) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-1) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-42 (ash 16 (the-as int (-> s1-1 tex0 tw))))
                    (a0-47 (ash 16 (the-as int (-> s1-1 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x40 :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0))
                                       )
                (let* ((f0-10 (* 512.0 (-> arg1 right iris-scale)))
                       (a1-44 (the-as object (-> arg0 base)))
                       (a2-25 (the int (- f30-0 f0-10)))
                       (t0-11 (the int (- sv-16 f0-10)))
                       (a3-19 (the int (+ f30-0 f0-10)))
                       (t1-1 (the int (+ sv-16 f0-10)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-44) 0 quad) (-> *eye-work* sprite-tmpl dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-44) 1 quad) (-> *eye-work* sprite-tmpl quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 4) a2-25 t0-11 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 5) v1-42 a0-47 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-44) 6) a3-19 t1-1 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (dma-buffer-add-gs-set arg0
                                   (test-1 (new 'static 'gs-test :ate #x1 :afail #x3 :zte #x1 :ztst (gs-ztest always)))
                                   )
            (let ((s1-2 (-> arg1 shaders 1)))
              (let ((v1-50 (the-as dma-gif-packet (-> arg0 base))))
                (set! (-> v1-50 dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> v1-50 quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-2 (the-as structure (&+ v1-50 32))))
                  (quad-copy! (the-as pointer s0-2) (the-as pointer s1-2) 5)
                  (set! (-> (the-as adgif-shader s0-2) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-2) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-2) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-57 (ash 16 (the-as int (-> s1-2 tex0 tw))))
                    (a0-65 (ash 16 (the-as int (-> s1-2 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 63) :scay0 s2-0)))
                (let* ((f0-14 (* 512.0 (-> arg1 left pupil-scale)))
                       (a1-61 (the-as object (-> arg0 base)))
                       (a2-35 (the int (- f28-0 f0-14)))
                       (t0-17 (the int (- f26-0 f0-14)))
                       (a3-29 (the int (+ f28-0 f0-14)))
                       (t1-2 (the int (+ f26-0 f0-14)))
                       )
                  (set! (-> (the-as (pointer uint128) a1-61)) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-61) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 4) a2-35 t0-17 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 5) v1-57 a0-65 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-61) 6) a3-29 t1-2 #xffffff 0)
                  )
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((s1-3 (-> arg1 shaders 4)))
              (let ((v1-62 (the-as object (-> arg0 base))))
                (set! (-> (the-as dma-gif-packet v1-62) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
                (set! (-> (the-as dma-gif-packet v1-62) quad 1) (-> *eye-work* adgif-tmpl quad 1))
                (let ((s0-3 (the-as structure (&+ (the-as dma-gif-packet v1-62) 32))))
                  (quad-copy! (the-as pointer s0-3) (the-as pointer s1-3) 5)
                  (set! (-> (the-as adgif-shader s0-3) clamp)
                        (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                        )
                  (set! (-> (the-as adgif-shader s0-3) alpha) (new 'static 'gs-miptbp :tbp1 #x44))
                  (set! (-> (the-as adgif-shader s0-3) prims 9) (gs-reg64 alpha-1))
                  )
                )
              (&+! (-> arg0 base) 112)
              (let ((v1-69 (ash 16 (the-as int (-> s1-3 tex0 tw))))
                    (a0-77 (ash 16 (the-as int (-> s1-3 tex0 th))))
                    )
                (dma-buffer-add-gs-set arg0
                                       (scissor-1 (new 'static 'gs-scissor :scax0 #x40 :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0))
                                       )
                (let* ((f0-18 (* 512.0 (-> arg1 right pupil-scale)))
                       (a1-71 (the-as object (-> arg0 base)))
                       (a2-45 (the int (- f30-0 f0-18)))
                       (t0-23 (the int (- sv-16 f0-18)))
                       (a3-39 (the int (+ f30-0 f0-18)))
                       (t1-3 (the int (+ sv-16 f0-18)))
                       )
                  (set! (-> (the-as (inline-array vector4w) a1-71) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                  (set! (-> (the-as (inline-array vector4w) a1-71) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 2) 128 128 128 128)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 3) 0 0 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 4) a2-45 t0-23 #xffffff 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 5) v1-69 a0-77 0 0)
                  (set-vector! (-> (the-as (inline-array vector4w) a1-71) 6) a3-39 t1-3 #xffffff 0)
                  )
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (dma-buffer-add-gs-set arg0
                                 (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                 )
          (let ((s1-4 (-> arg1 shaders 2)))
            (let ((v1-77 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-77) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-77) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-4 (the-as structure (&+ (the-as dma-gif-packet v1-77) 32))))
                (quad-copy! (the-as pointer s0-4) (the-as pointer s1-4) 5)
                (set! (-> (the-as adgif-shader s0-4) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                      )
                (set! (-> (the-as adgif-shader s0-4) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-4) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-84 (ash 16 (the-as int (-> s1-4 tex0 tw))))
                  (a0-95 (ash 16 (the-as int (-> s1-4 tex0 th))))
                  )
              (when (< (-> arg1 left lid) 0.0)
                (let ((f0-23 (+ 1.0 (-> arg1 left lid))))
                  (set! (-> arg1 left lid) (+ f0-23 (* (- 1.0 f0-23) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0 (scissor-1 (new 'static 'gs-scissor :scax1 #x3f :scay1 (+ s2-0 63) :scay0 s2-0)))
              (let* ((f0-27 (+ (the float (+ s3-0 -64)) (* 64.0 (-> arg1 left lid))))
                     (a1-93 (the-as object (-> arg0 base)))
                     (a2-55 (* s4-0 16))
                     (t0-29 (the int (* 16.0 f0-27)))
                     (a3-51 (* (+ s4-0 64) 16))
                     (t1-6 (the int (* 16.0 (+ f0-27 (* 64.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (inline-array vector4w) a1-93) 0 quad) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-93) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 4) a2-55 t0-29 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 5) v1-84 a0-95 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-93) 6) a3-51 t1-6 #xffffff 0)
                )
              )
            )
          (&+! (-> arg0 base) 112)
          (let ((s1-5 (-> arg1 shaders 5)))
            (let ((v1-89 (the-as object (-> arg0 base))))
              (set! (-> (the-as dma-gif-packet v1-89) dma-vif quad) (-> *eye-work* adgif-tmpl dma-vif quad))
              (set! (-> (the-as dma-gif-packet v1-89) quad 1) (-> *eye-work* adgif-tmpl quad 1))
              (let ((s0-5 (the-as structure (&+ (the-as dma-gif-packet v1-89) 32))))
                (quad-copy! (the-as pointer s0-5) (the-as pointer s1-5) 5)
                (set! (-> (the-as adgif-shader s0-5) clamp)
                      (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp) :maxu #x3f :maxv #x3f)
                      )
                (set! (-> (the-as adgif-shader s0-5) alpha) (new 'static 'gs-miptbp :tbp1 #x1))
                (set! (-> (the-as adgif-shader s0-5) prims 9) (gs-reg64 alpha-1))
                )
              )
            (&+! (-> arg0 base) 112)
            (let ((v1-96 (ash 16 (the-as int (-> s1-5 tex0 tw))))
                  (a0-107 (ash 16 (the-as int (-> s1-5 tex0 th))))
                  )
              (when (< (-> arg1 right lid) 0.0)
                (let ((f0-33 (+ 1.0 (-> arg1 right lid))))
                  (set! (-> arg1 right lid) (+ f0-33 (* (- 1.0 f0-33) (-> arg1 blink))))
                  )
                )
              (dma-buffer-add-gs-set arg0
                                     (scissor-1 (new 'static 'gs-scissor :scax0 #x40 :scax1 #x7f :scay1 (+ s2-0 63) :scay0 s2-0))
                                     )
              (let* ((f0-37 (+ (the float (+ s3-0 -64)) (* 64.0 (-> arg1 right lid))))
                     (a1-108 (the-as object (-> arg0 base)))
                     (a2-66 (* (+ s4-0 128) 16))
                     (t0-35 (the int (* 16.0 f0-37)))
                     (a3-63 (* (+ s4-0 64) 16))
                     (t1-9 (the int (* 16.0 (+ f0-37 (* 64.0 (-> arg1 left lid-scale))))))
                     )
                (set! (-> (the-as (pointer uint128) a1-108)) (-> *eye-work* sprite-tmpl2 dma-vif quad))
                (set! (-> (the-as (inline-array vector4w) a1-108) 1 quad) (-> *eye-work* sprite-tmpl2 quad 1))
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 2) 128 128 128 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 3) 0 0 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 4) a2-66 t0-35 #xffffff 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 5) v1-96 a0-107 0 0)
                (set-vector! (-> (the-as (inline-array vector4w) a1-108) 6) a3-63 t1-9 #xffffff 0)
                )
              )
            )
          )
        (let ((v0-0 (&+ (-> arg0 base) 112)))
          (set! (-> arg0 base) v0-0)
          v0-0
          )
        )
      )
    )
  )

(defun update-eyes ()
  (when (not (-> *blit-displays-work* screen-copied))
    (dotimes (gp-0 32)
      (let* ((s5-0 (-> *eye-control-array* data gp-0))
             (v1-7 (handle->process (-> s5-0 process)))
             )
        (when (and v1-7
                   (logtest? (-> (the-as process-drawable v1-7) skel status) (joint-control-status eye-anim))
                   (logtest? (-> (the-as process-drawable v1-7) draw status) (draw-control-status on-screen))
                   )
          (when (-> s5-0 shaders)
            (when (not (paused?))
              (cond
                ((and (>= (-> s5-0 left lid) 0.0) (>= (-> s5-0 right lid) 0.0))
                 (set! (-> s5-0 random-time) (the-as uint 60))
                 (set! (-> s5-0 blink) 0.0)
                 )
                (else
                  (+! (-> s5-0 random-time) -1)
                  (let ((v1-19 (-> s5-0 random-time)))
                    (when (< v1-19 (the-as uint 10))
                      (set! (-> s5-0 blink) (-> *eye-work* blink-table v1-19))
                      (if (zero? v1-19)
                          (set! (-> s5-0 random-time) (the-as uint (the int (rand-vu-float-range 60.0 240.0))))
                          )
                      )
                    )
                  )
                )
              )
            (when (-> s5-0 left shader)
              (cond
                ((and (= (-> s5-0 left pupil-scale) 0.0) (= (-> s5-0 left iris-scale) 0.0))
                 (dotimes (v1-24 (the-as int (-> s5-0 left shader-count)))
                   (set! (-> s5-0 left shader v1-24 tex0 tfx) 1)
                   )
                 )
                (else
                  (dotimes (v1-27 (the-as int (-> s5-0 left shader-count)))
                    (set! (-> s5-0 left shader v1-27 tex0 tfx) 0)
                    )
                  )
                )
              )
            (when (-> s5-0 right shader)
              (cond
                ((and (= (-> s5-0 right pupil-scale) 0.0) (= (-> s5-0 right iris-scale) 0.0))
                 (dotimes (v1-34 (the-as int (-> s5-0 right shader-count)))
                   (set! (-> s5-0 right shader v1-34 tex0 tfx) 1)
                   )
                 )
                (else
                  (dotimes (v1-37 (the-as int (-> s5-0 right shader-count)))
                    (set! (-> s5-0 right shader v1-37 tex0 tfx) 0)
                    )
                  )
                )
              )
            (cond
              ((-> s5-0 high-res?)
               (let ((v1-42 *display*)
                     (a0-45 16)
                     )
                 (+! (-> v1-42 mem-reserve-size) a0-45)
                 (when (not (-> v1-42 dma-buffer-overflow))
                   (let ((a2-0 (-> v1-42 frames (-> v1-42 on-screen) global-buf)))
                     (if (< (-> a2-0 real-buffer-end) (the-as int (&+ (-> a2-0 base) a0-45)))
                         (set! (-> v1-42 dma-buffer-overflow) #t)
                         )
                     )
                   (when (not (-> v1-42 dma-buffer-overflow))
                     (with-dma-buffer-add-bucket ((s3-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                                  (the-as bucket-id (-> s5-0 bucket))
                                                  )
                       (let ((t9-2 set-display-gs-state-offset)
                             (a0-50 s3-0)
                             (a1-35 (-> *eyes-texture-base* vram-page))
                             (a2-2 (the-as object 128))
                             )
                         (t9-2 a0-50 (the-as int a1-35) (the-as int a2-2) 256 0 0 64 64)
                         (let ((v1-50 *display*)
                               (a0-51 48)
                               )
                           (+! (-> v1-50 mem-reserve-size) a0-51)
                           (when (not (-> v1-50 dma-buffer-overflow))
                             (let* ((a2-3 (-> v1-50 frames (-> v1-50 on-screen) global-buf))
                                    (a1-44 (-> a2-3 real-buffer-end))
                                    )
                               (set! a2-2 (-> a2-3 base))
                               (if (< a1-44 (the-as int (&+ (the-as pointer a2-2) a0-51)))
                                   (set! (-> v1-50 dma-buffer-overflow) #t)
                                   )
                               )
                             (if (not (-> v1-50 dma-buffer-overflow))
                                 (dma-buffer-add-gs-set s3-0
                                                        (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                                        )
                                 )
                             )
                           )
                         (render-eyes-64 s3-0 s5-0 (the-as int a2-2))
                         )
                       (reset-display-gs-state *display* s3-0)
                       (let ((v1-55 *display*)
                             (a0-62 48)
                             )
                         (+! (-> v1-55 mem-reserve-size) a0-62)
                         (when (not (-> v1-55 dma-buffer-overflow))
                           (let ((a2-4 (-> v1-55 frames (-> v1-55 on-screen) global-buf)))
                             (if (< (-> a2-4 real-buffer-end) (the-as int (&+ (-> a2-4 base) a0-62)))
                                 (set! (-> v1-55 dma-buffer-overflow) #t)
                                 )
                             )
                           (if (not (-> v1-55 dma-buffer-overflow))
                               (dma-buffer-add-gs-set s3-0 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)))
                               )
                           )
                         )
                       )
                     )
                   )
                 )
               )
              ((not (-> s5-0 high-res?))
               (let ((v1-68 *display*)
                     (a0-74 16)
                     )
                 (+! (-> v1-68 mem-reserve-size) a0-74)
                 (when (not (-> v1-68 dma-buffer-overflow))
                   (let ((a2-7 (-> v1-68 frames (-> v1-68 on-screen) global-buf)))
                     (if (< (-> a2-7 real-buffer-end) (the-as int (&+ (-> a2-7 base) a0-74)))
                         (set! (-> v1-68 dma-buffer-overflow) #t)
                         )
                     )
                   (when (not (-> v1-68 dma-buffer-overflow))
                     (with-dma-buffer-add-bucket ((s3-1 (-> *display* frames (-> *display* on-screen) global-buf))
                                                  (the-as bucket-id (-> s5-0 bucket))
                                                  )
                       (let ((t9-6 set-display-gs-state-offset)
                             (a0-79 s3-1)
                             (a1-88 (-> *eyes-texture-base* vram-page))
                             (a2-9 (the-as object 64))
                             )
                         (t9-6 a0-79 (the-as int a1-88) (the-as int a2-9) 512 0 0 32 32)
                         (let ((v1-76 *display*)
                               (a0-80 48)
                               )
                           (+! (-> v1-76 mem-reserve-size) a0-80)
                           (when (not (-> v1-76 dma-buffer-overflow))
                             (let* ((a2-10 (-> v1-76 frames (-> v1-76 on-screen) global-buf))
                                    (a1-97 (-> a2-10 real-buffer-end))
                                    )
                               (set! a2-9 (-> a2-10 base))
                               (if (< a1-97 (the-as int (&+ (the-as pointer a2-9) a0-80)))
                                   (set! (-> v1-76 dma-buffer-overflow) #t)
                                   )
                               )
                             (if (not (-> v1-76 dma-buffer-overflow))
                                 (dma-buffer-add-gs-set s3-1
                                                        (test-1 (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always)))
                                                        )
                                 )
                             )
                           )
                         (render-eyes-32 s3-1 s5-0 (the-as int a2-9))
                         )
                       (reset-display-gs-state *display* s3-1)
                       (let ((v1-81 *display*)
                             (a0-91 48)
                             )
                         (+! (-> v1-81 mem-reserve-size) a0-91)
                         (when (not (-> v1-81 dma-buffer-overflow))
                           (let ((a2-11 (-> v1-81 frames (-> v1-81 on-screen) global-buf)))
                             (if (< (-> a2-11 real-buffer-end) (the-as int (&+ (-> a2-11 base) a0-91)))
                                 (set! (-> v1-81 dma-buffer-overflow) #t)
                                 )
                             )
                           (if (not (-> v1-81 dma-buffer-overflow))
                               (dma-buffer-add-gs-set s3-1 (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)))
                               )
                           )
                         )
                       )
                     )
                   )
                 )
               )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch uint vs int.
(defun get-eye-block ((arg0 int) (arg1 int))
  (let ((v1-0 arg0)
        (a0-4 (-> ct32-24-block-table (* arg1 4)))
        )
    (the-as int (+ (-> *eyes-texture-base* vram-block) (* v1-0 32) a0-4))
    )
  )

(defun convert-eye-data ((arg0 eye) (arg1 uint))
  (local-vars
    (v0-0 float)
    (v1-0 uint128)
    (v1-1 uint128)
    (v1-2 uint128)
    (v1-3 uint128)
    (v1-4 uint128)
    (v1-5 uint128)
    )
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
    (.pextlb v1-0 arg1 0)
    (.pextlh v1-1 v1-0 0)
    (.pw.sra v1-2 v1-1 16)
    (.mov vf1 v1-2)
    (.pextlb v1-3 0 arg1)
    (.pextuh v1-4 0 v1-3)
    (.pw.sll v1-5 v1-4 6)
    (.mov vf2 v1-5)
    (vitof15.xyzw vf1 vf1)
    (vitof12.xyzw vf2 vf2)
    (.svf (&-> arg0 data 0 quad) vf1)
    (.svf (&-> arg0 data 1 quad) vf2)
    (.mov v0-0 vf2)
    v0-0
    )
  )

(defun merc-eye-anim ((arg0 process-drawable))
  (let* ((v1-2 (-> arg0 draw mgeo header eye-ctrl))
         (a0-2 (-> arg0 skel float-channels))
         (s3-0 (cond
                 ((> a0-2 0)
                  (-> arg0 skel channel (+ a0-2 -1 (-> arg0 skel active-channels)))
                  )
                 (else
                   (let ((a0-8 (-> arg0 skel root-channel))
                         (a1-4 (-> arg0 skel effect))
                         )
                     (-> a0-8 (if a1-4
                                  (-> a1-4 channel-offset)
                                  0
                                  )
                         )
                     )
                   )
                 )
               )
         (s4-0 (-> s3-0 frame-group))
         )
    (when (and (logtest? (-> arg0 skel status) (joint-control-status eye-anim))
               (and (nonzero? v1-2) (> (-> arg0 skel active-channels) 0) s4-0)
               )
      (cond
        ((and (-> arg0 skel override) (!= (-> arg0 skel override 41) 0.0))
         (let ((v1-6 (-> *eye-control-array* data (-> v1-2 eye-ctrl-index)))
               (a0-24 (-> arg0 skel override))
               )
           (set! (-> v1-6 left x) (-> a0-24 42))
           (set! (-> v1-6 left y) (-> a0-24 43))
           (set! (-> v1-6 left lid) (-> a0-24 44))
           (set! (-> v1-6 left iris-scale) (-> a0-24 45))
           (set! (-> v1-6 left pupil-scale) (-> a0-24 46))
           (set! (-> v1-6 left lid-scale) (-> a0-24 47))
           (set! (-> v1-6 right x) (-> a0-24 48))
           (set! (-> v1-6 right y) (-> a0-24 49))
           (set! (-> v1-6 right lid) (-> a0-24 50))
           (set! (-> v1-6 right iris-scale) (-> a0-24 51))
           (set! (-> v1-6 right pupil-scale) (-> a0-24 52))
           (set! (-> v1-6 right lid-scale) (-> a0-24 53))
           )
         (logior! (-> arg0 skel status) (joint-control-status eye-anim-valid))
         )
        (else
          (let* ((s5-0 (-> *eye-control-array* data (-> v1-2 eye-ctrl-index)))
                 (f0-13 (-> s3-0 frame-num))
                 (f30-0 (- f0-13 (* (the float (the int (/ f0-13 1.0))) 1.0)))
                 )
            (set! (-> s5-0 process) (process->handle arg0))
            (set! (-> s5-0 shaders) (-> v1-2 shader))
            (let ((a0-34 *level*)
                  (v1-11 (-> arg0 draw))
                  )
              (set! (-> s5-0 bucket) (the-as uint (vu1-bucket-map
                                                    (the-as int (-> a0-34 draw-index-map (-> v1-11 level-index)))
                                                    (the-as int (-> v1-11 default-texture-page))
                                                    (merc-mode texture)
                                                    )
                                             )
                    )
              )
            (let ((s2-0 (new 'stack-no-clear 'eye))
                  (s1-0 (new 'stack-no-clear 'eye))
                  )
              (cond
                ((-> s4-0 eye-anim)
                 (let ((s0-1 (min (the int (-> s3-0 frame-num)) (-> s4-0 eye-anim max-frame)))
                       (s3-2 (min (+ (the int (-> s3-0 frame-num)) 1) (-> s4-0 eye-anim max-frame)))
                       )
                   (convert-eye-data s2-0 (-> s4-0 eye-anim data (* s0-1 2) dword))
                   (convert-eye-data s1-0 (-> s4-0 eye-anim data (* s3-2 2) dword))
                   (vector4-lerp! (the-as vector (-> s5-0 eyes)) (the-as vector (&-> s2-0 x)) (the-as vector (&-> s1-0 x)) f30-0)
                   (vector4-lerp!
                     (the-as vector (&-> s5-0 left iris-scale))
                     (the-as vector (&-> s2-0 iris-scale))
                     (the-as vector (&-> s1-0 iris-scale))
                     f30-0
                     )
                   (convert-eye-data s2-0 (-> s4-0 eye-anim data (+ (* s0-1 2) 1) dword))
                   (convert-eye-data s1-0 (-> s4-0 eye-anim data (+ (* s3-2 2) 1) dword))
                   )
                 (vector4-lerp!
                   (the-as vector (-> s5-0 right))
                   (the-as vector (&-> s2-0 x))
                   (the-as vector (&-> s1-0 x))
                   f30-0
                   )
                 (vector4-lerp!
                   (the-as vector (&-> s5-0 right iris-scale))
                   (the-as vector (&-> s2-0 iris-scale))
                   (the-as vector (&-> s1-0 iris-scale))
                   f30-0
                   )
                 )
                (else
                  (format *stdcon* "no eye anim data for ~s~%" (-> arg0 name))
                  (set! (-> s5-0 left x) 0.0)
                  (set! (-> s5-0 left y) 0.0)
                  (set! (-> s5-0 left lid) -1.0)
                  (set! (-> s5-0 left iris-scale) 0.55)
                  (set! (-> s5-0 left pupil-scale) 0.45)
                  (set! (-> s5-0 left lid-scale) 1.0)
                  (set! (-> s5-0 right x) 0.0)
                  (set! (-> s5-0 right y) 0.0)
                  (set! (-> s5-0 right lid) -1.0)
                  (set! (-> s5-0 right iris-scale) 0.55)
                  (set! (-> s5-0 right pupil-scale) 0.45)
                  (set! (-> s5-0 right lid-scale) 1.0)
                  )
                )
              )
            )
          (logior! (-> arg0 skel status) (joint-control-status eye-anim-valid))
          )
        )
      )
    )
  (if (logtest? (-> arg0 skel status) (joint-control-status eye-anim-valid))
      (logclear! (-> arg0 skel status) (joint-control-status eye-anim-valid))
      )
  0
  (none)
  )
