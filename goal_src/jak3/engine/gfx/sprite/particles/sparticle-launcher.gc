;;-*-Lisp-*-
(in-package goal)

;; name: sparticle-launcher.gc
;; name in dgo: sparticle-launcher
;; dgos: GAME

(defmacro launch-particles (&key (system *sp-particle-system-2d*)
                                 particle
                                 origin
                                 &key (launch-state (the-as sparticle-launch-state #f))
                                 &key (launch-control (the-as sparticle-launch-control #f))
                                 &key (rate 1.0)
                                 &key (origin-is-matrix #f))
  (if origin-is-matrix
      `(sp-launch-particles-var
         ,system
         ,particle
         (the matrix ,origin)
         ,launch-state
         ,launch-control
         ,rate #|(if (= (get-video-mode) 'custom) (/ (-> *display* time-factor) 5.0) ,rate)|#)
      `(begin
         (vector-copy! (-> *launch-matrix* trans) (the vector ,origin))
         (sp-launch-particles-var
            ,system
            ,particle
            *launch-matrix*
            ,launch-state
            ,launch-control
            ,rate #|(if (= (get-video-mode) 'custom) (/ (-> *display* time-factor) 5.0) ,rate)|#)
         )
      )
  )

;; DECOMP BEGINS

;; WARN: Return type mismatch int vs sparticle-launcher.

(kmemopen global "part-tables")

(define *part-id-table* (new 'global 'boxed-array sparticle-launcher 5500))

(define *part-group-id-table* (new 'global 'boxed-array sparticle-launch-group 1700))

(define *sp-temp* 0.0)

(kmemclose)

(defun lookup-part-group-by-name ((arg0 string))
  (let* ((s5-0 *part-group-id-table*)
         (s4-0 (-> s5-0 length))
         )
    (dotimes (s3-0 s4-0)
      (let ((s2-0 (-> s5-0 s3-0)))
        (if (and (nonzero? s2-0) (string= arg0 (-> s2-0 name)))
            (return s2-0)
            )
        )
      )
    )
  (the-as sparticle-launch-group #f)
  )

;; WARN: Return type mismatch (pointer sparticle-launch-group) vs (pointer object).
(defun lookup-part-group-pointer-by-name ((arg0 string))
  (let* ((s4-0 *part-group-id-table*)
         (s3-0 (-> s4-0 length))
         )
    (dotimes (gp-0 s3-0)
      (let ((v1-2 (-> s4-0 gp-0)))
        (if (and (nonzero? v1-2) (string= arg0 (-> v1-2 name)))
            (return (the-as (pointer object) (&+ (-> s4-0 data) (* gp-0 4))))
            )
        )
      )
    )
  (the-as (pointer sparticle-launch-group) #f)
  )

(defun part-group-pointer? ((arg0 pointer))
  (let ((v1-0 *part-group-id-table*))
    (and (>= (the-as int arg0) (the-as int (-> v1-0 data))) (< (the-as int arg0) (the-as int (&-> v1-0 1700))))
    )
  )

(defun unlink-part-group-by-heap ((arg0 kheap))
  (let* ((v1-0 *part-group-id-table*)
         (a2-0 (-> v1-0 length))
         (a1-0 (-> arg0 base))
         (a0-1 (-> arg0 top-base))
         )
    (while (nonzero? a2-0)
      (+! a2-0 -1)
      (let ((a3-2 (-> v1-0 a2-0)))
        (when (and (>= (the-as int a3-2) (the-as int a1-0)) (< (the-as int a3-2) (the-as int a0-1)))
          (set! (-> v1-0 a2-0) (the-as sparticle-launch-group 0))
          0
          )
        )
      )
    )
  0
  )

(def-mips2c sp-init-fields! (function (pointer float) (inline-array sp-field-init-spec) sp-field-id sp-field-id symbol (inline-array sp-field-init-spec)))

(deftype sp-queued-launch-particles (structure)
  ((sp-system    sparticle-system)
   (sp-launcher  sparticle-launcher)
   (pos          vector  :inline)
   )
  )


(deftype sp-launch-queue (basic)
  ((in-use  int32)
   (queue   sp-queued-launch-particles  256 :inline)
   )
  )


(kmemopen global "launcher-queue")

(define *sp-launcher-lock* #f)

(define *sp-launch-queue* (new 'global 'sp-launch-queue))

(define *sp-launcher-enable* #t)

(kmemclose)

(defun particle-setup-adgif ((arg0 adgif-shader) (arg1 int))
  (let ((a1-1 (lookup-texture-by-id-fast (the-as texture-id arg1)))
        (s5-0 #f)
        )
    (when (not a1-1)
      (set! a1-1 (get-texture common-white common))
      (set! s5-0 #t)
      )
    (set! (-> arg0 tex1) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
    (set! (-> arg0 tex0 tfx) 0)
    (adgif-shader<-texture! arg0 a1-1)
    (set! (-> arg0 prims 1) (gs-reg64 tex0-1))
    (set! (-> arg0 prims 3) (the-as gs-reg64 (logior arg1 20)))
    (set! (-> arg0 prims 5) (gs-reg64 miptbp1-1))
    (set! (-> arg0 clamp-reg) (gs-reg64 zbuf-1))
    (set! (-> arg0 prims 9) (gs-reg64 alpha-1))
    (if s5-0
        (logior! (-> arg0 link-test) (link-test-flags backup-sprite-tex))
        )
    )
  (set! (-> arg0 alpha) (new 'static 'gs-miptbp :tbp1 #x44))
  (set! (-> arg0 clamp) (new 'static 'gs-clamp :minu #x13 :minv #x101))
  0
  (none)
  )

(deftype particle-adgif-cache (basic)
  ((used     int32)
   (last     uint16)
   (lastgif  adgif-shader)
   (tidhash  uint16        80)
   (spadgif  adgif-shader  80 :inline)
   )
  )


(kmemopen global "part-adgif-cache")

(define *particle-adgif-cache* (new 'global 'particle-adgif-cache))

(set! (-> *particle-adgif-cache* used) 0)

(kmemclose)

(defun particle-adgif-cache-flush ()
  (set! (-> *particle-adgif-cache* used) 0)
  (set! (-> *particle-adgif-cache* last) (the-as uint 0))
  0
  (none)
  )

(def-mips2c particle-adgif (function adgif-shader texture-id none))

;; ERROR: Bad vector register dependency: vf16
;; ERROR: Bad vector register dependency: vf17
;; ERROR: Bad vector register dependency: vf18
;; ERROR: Bad vector register dependency: vf19
;; ERROR: Bad vector register dependency: vf20
(defun particle-adgif-callback ((arg0 adgif-shader) (arg1 texture-id))
  (local-vars (v1-0 float))
  (rlet ((vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         )
    (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 4)))
      (let ((s4-0 (-> arg0 alpha))
            (s3-0 (-> arg0 clamp))
            )
        ;; og:preserve-this
        ; (.svf (&-> s5-0 0 quad) vf16)
        ; (.svf (&-> s5-0 1 quad) vf17)
        ; (.svf (&-> s5-0 2 quad) vf18)
        ; (.svf (&-> s5-0 3 quad) vf19)
        ; (.svf (&-> s5-0 4 quad) vf20)
        (particle-adgif arg0 arg1)
        (set! (-> arg0 alpha) s4-0)
        (set! (-> arg0 clamp) s3-0)
        )
      ;; og:preserve-this
      ; (.lvf vf16 (&-> s5-0 0 quad))
      ; (.lvf vf17 (&-> s5-0 1 quad))
      ; (.lvf vf18 (&-> s5-0 2 quad))
      ; (.lvf vf19 (&-> s5-0 3 quad))
      ; (.lvf vf20 (&-> s5-0 4 quad))
      )
    (.mov v1-0 vf20)
    0
    (none)
    )
  )

(defun sp-queue-launch ((arg0 sparticle-system) (arg1 sparticle-launcher) (arg2 matrix))
  (let ((v1-0 *sp-launch-queue*))
    (when (= (-> v1-0 in-use) 256)
      (format 0 "ERROR: sp-launch-particles called during processing, and queue is full~%")
      (return 0)
      )
    (let ((a3-5 (-> v1-0 queue (-> v1-0 in-use))))
      (set! (-> a3-5 sp-system) arg0)
      (set! (-> a3-5 sp-launcher) arg1)
      (set! (-> a3-5 pos quad) (-> arg2 trans quad))
      )
    (let ((v0-1 (+ (-> v1-0 in-use) 1)))
      (set! (-> v1-0 in-use) v0-1)
      v0-1
      )
    )
  )

(defun sp-adjust-launch ((arg0 sparticle-launchinfo)
                (arg1 sparticle-cpuinfo)
                (arg2 (inline-array sp-field-init-spec))
                (arg3 matrix)
                (arg4 symbol)
                )
  (let ((s2-0 (new 'stack-no-clear 'matrix))
        (s5-0 (new 'stack-no-clear 'matrix))
        )
    (let ((s0-0 (new 'stack-no-clear 'vector)))
      (sp-init-fields!
        (the-as (pointer float) (-> s2-0 rvec))
        arg2
        (sp-field-id launch-fields-start)
        (sp-field-id launch-fields-end)
        #t
        )
      (matrix-rotate-xyz! s5-0 (-> s2-0 rvec))
      (vector3s-matrix*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
      (matrix-rotate-xyz! s5-0 (-> s2-0 uvec))
      (vector3s-matrix*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
      (matrix*! s5-0 s5-0 arg3)
      (set-vector! s0-0 0.0 (-> s2-0 fvec w) 0.0 1.0)
      (vector-matrix*! s0-0 s0-0 s5-0)
      (+! (-> arg0 launchrot x) (-> s0-0 x))
      (+! (-> arg0 launchrot y) (-> s0-0 y))
      (+! (-> arg0 launchrot z) (-> s0-0 z))
      )
    (when (logtest? (sp-cpuinfo-flag set-conerot) (-> arg1 flags))
      (let ((f0-10 (vector-length (-> arg3 rvec)))
            (f1-3 (vector-length (-> arg3 uvec)))
            (f2-0 (vector-length (-> arg3 fvec)))
            )
        (set! (-> arg0 launchrot w) (* (-> arg0 launchrot w) f0-10))
        (set! (-> arg0 conerot w) (* (-> arg0 conerot w) f1-3))
        (set! (-> arg1 vel-sxvel w) (* (-> arg1 vel-sxvel w) f0-10))
        (set! (-> arg1 rot-syvel w) (* (-> arg1 rot-syvel w) f1-3))
        (set! (-> arg1 vel-sxvel x) (* (-> arg1 vel-sxvel x) f0-10))
        (set! (-> arg1 vel-sxvel y) (* (-> arg1 vel-sxvel y) f1-3))
        (set! (-> arg1 vel-sxvel z) (* (-> arg1 vel-sxvel z) f2-0))
        )
      )
    (matrix-rotate-xyz! s5-0 (-> s2-0 fvec))
    (matrix*! s5-0 s5-0 arg3)
    (vector3s-rotate*! (the-as vector3s (-> arg0 launchrot)) (the-as vector3s (-> arg0 launchrot)) s5-0)
    (vector3s-rotate*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
    (if (not (logtest? (sp-cpuinfo-flag launch-along-z) (-> arg1 flags)))
        (vector3s-rotate*! (the-as vector3s (-> arg1 acc)) (the-as vector3s (-> arg1 acc)) s5-0)
        )
    (if (logtest? (sp-cpuinfo-flag right-multiply-quat) (-> arg1 flags))
        (set! (-> arg0 conerot y) (+ 16384.0 (vector-y-angle (-> s5-0 fvec))))
        )
    (when arg4
      (let ((s4-1 (new 'stack-no-clear 'euler-angles)))
        (matrix->eul s4-1 s5-0 13)
        (set! (-> arg0 conerot x) (- (-> arg0 conerot x) (-> s4-1 y)))
        (set! (-> arg0 conerot y) (- (-> arg0 conerot y) (-> s4-1 z)))
        (set! (-> arg0 conerot z) (- (-> arg0 conerot z) (-> s4-1 x)))
        )
      )
    )
  0
  (none)
  )

(defun sp-euler-convert ((arg0 sparticle-launchinfo) (arg1 sparticle-cpuinfo))
  (local-vars (v1-1 float) (v1-2 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'quaternion))
          )
      (set-vector! a1-1 (-> arg0 conerot x) (-> arg0 conerot y) (-> arg0 conerot z) 1.0)
      (quaternion-zxy! s5-0 a1-1)
      (cond
        ((< (-> s5-0 w) 0.0)
         (.lvf vf1 (&-> arg0 conerot quad))
         (.lvf vf2 (&-> s5-0 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> arg0 conerot quad) vf1)
         (.mov v1-1 vf1)
         )
        (else
          (.lvf vf1 (&-> arg0 conerot quad))
          (.lvf vf2 (&-> s5-0 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> arg0 conerot quad) vf1)
          (.mov v1-2 vf1)
          )
        )
      )
    (cond
      (*sp-60-hz*
        (set! (-> arg1 rot-syvel x) (* 5.0 (-> arg1 rot-syvel x)))
        (set! (-> arg1 rot-syvel y) (* 5.0 (-> arg1 rot-syvel y)))
        (set! (-> arg1 rot-syvel z) (* 5.0 (-> arg1 rot-syvel z)))
        )
      (else
        (set! (-> arg1 rot-syvel x) (* 6.0 (-> arg1 rot-syvel x)))
        (set! (-> arg1 rot-syvel y) (* 6.0 (-> arg1 rot-syvel y)))
        (set! (-> arg1 rot-syvel z) (* 6.0 (-> arg1 rot-syvel z)))
        )
      )
    (quaternion-zxy! (-> arg1 rotvel3d) (-> arg1 rot-syvel))
    0
    (none)
    )
  )

(defun sp-rotate-system ((arg0 sparticle-launchinfo) (arg1 sparticle-cpuinfo) (arg2 transformq))
  (let ((s5-0 (new 'stack-no-clear 'matrix)))
    (let ((a1-1 (new 'stack-no-clear 'quaternion)))
      (let* ((v1-0 a1-1)
             (a0-1 arg2)
             (f0-0 (-> a0-1 quat x))
             (f1-0 (-> a0-1 quat y))
             (f2-0 (-> a0-1 quat z))
             )
        (set! (-> v1-0 x) f0-0)
        (set! (-> v1-0 y) f1-0)
        (set! (-> v1-0 z) f2-0)
        (set! (-> v1-0 w) (sqrtf (- (- (- 1.0 (* f2-0 f2-0)) (* f1-0 f1-0)) (* f0-0 f0-0))))
        )
      (quaternion->matrix s5-0 a1-1)
      )
    (vector3s-rotate*! (the-as vector3s (-> arg0 launchrot)) (the-as vector3s (-> arg0 launchrot)) s5-0)
    (vector3s-rotate*! (the-as vector3s (-> arg1 vel-sxvel)) (the-as vector3s (-> arg1 vel-sxvel)) s5-0)
    (if (not (logtest? (sp-cpuinfo-flag launch-along-z) (-> arg1 flags)))
        (vector3s-rotate*! (the-as vector3s (-> arg1 acc)) (the-as vector3s (-> arg1 acc)) s5-0)
        )
    )
  0
  (none)
  )

(deftype sp-launch-stack (structure)
  ((ra          basic)
   (dummy0      basic)
   (dummy1      basic)
   (b-spfic     basic)
   (r16         uint128)
   (r17         uint128)
   (r18         uint128)
   (pos         uint128)
   (matrix      matrix               :inline)
   (l-spfic     basic)
   (birth-info  sparticle-birthinfo  :inline)
   (sprite      sprite-vec-data-2d   :inline)
   (r19         uint128)
   (r20         uint128)
   (r21         uint128)
   (r22         uint128)
   )
  )


(def-mips2c sp-launch-particles-var (function sparticle-system sparticle-launcher matrix sparticle-launch-state sparticle-launch-control float none))

(define *death-adgif* (the-as adgif-shader #f))

;; WARN: Function sp-launch-particles-death has a return type of none, but the expression builder found a return statement.
(defun sp-launch-particles-death ((arg0 sparticle-system) (arg1 sparticle-launcher) (arg2 vector))
  (local-vars (v1-26 float) (v1-28 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf30 (&-> arg2 quad))
    (let ((v1-0 #x437f0000))
      (.mov vf31 v1-0)
      )
    (let ((s5-0 (new 'stack-no-clear 'matrix))
          (gp-0 (sp-get-particle arg0 0 (the-as sparticle-launch-state #f)))
          )
      (if (not gp-0)
          (return 0)
          )
      (let* ((a1-2 (-> arg1 init-specs 0))
             (a1-3 (sp-init-fields!
                     (the-as (pointer float) (-> s5-0 rvec))
                     (the-as (inline-array sp-field-init-spec) a1-2)
                     (sp-field-id sprite-fields-start)
                     (sp-field-id sprite-fields-end)
                     #t
                     )
                   )
             )
        (sp-init-fields! (&-> gp-0 omega) a1-3 (sp-field-id cpu-fields-start) (sp-field-id cpu-fields-end) #t)
        )
      (set! (-> s5-0 uvec y) 0.0)
      (set! (-> s5-0 uvec z) (the float (sar (shl (the int (-> s5-0 uvec z)) 48) 48)))
      (.lvf vf4 (&-> s5-0 fvec quad))
      (.lvf vf5 (&-> s5-0 rvec quad))
      (.min.x.vf vf4 vf4 vf31 :mask #b111)
      (.add.vf vf5 vf5 vf30 :mask #b111)
      (.svf (&-> s5-0 fvec quad) vf4)
      (.svf (&-> s5-0 rvec quad) vf5)
      (when (not *death-adgif*)
        (set! *death-adgif* (new 'static 'adgif-shader))
        (particle-adgif *death-adgif* (new 'static 'texture-id :index #x18 :page #x4))
        (set! (-> *death-adgif* alpha) (new 'static 'gs-miptbp :tbp1 #x48))
        )
      (let ((v1-14 (-> *death-adgif* quad 0 quad)))
        (set! (-> gp-0 adgif quad 0 quad) v1-14)
        )
      (let ((v1-16 (-> *death-adgif* quad 1 quad)))
        (set! (-> gp-0 adgif quad 1 quad) v1-16)
        )
      (let ((v1-18 (-> *death-adgif* quad 2 quad)))
        (set! (-> gp-0 adgif quad 2 quad) v1-18)
        )
      (let ((v1-20 (-> *death-adgif* quad 3 quad)))
        (set! (-> gp-0 adgif quad 3 quad) v1-20)
        )
      (let ((v1-22 (-> *death-adgif* quad 4 quad)))
        (set! (-> gp-0 adgif quad 4 quad) v1-22)
        )
      (set! (-> gp-0 clock-index) (the-as uint 8))
      (.lvf vf4 (&-> (-> *time-of-day-context* current-prt-color) quad))
      (.lvf vf5 (&-> s5-0 fvec quad))
      (.lvf vf6 (&-> gp-0 fade quad))
      (.mul.vf vf5 vf5 vf4 :mask #b111)
      (.mul.vf vf6 vf6 vf4 :mask #b111)
      (.svf (&-> s5-0 fvec quad) vf5)
      (.svf (&-> gp-0 fade quad) vf6)
      (.mov v1-26 vf6)
      (set! (-> gp-0 key) (the-as sparticle-launch-control 0))
      (set! (-> gp-0 binding) #f)
      (let ((v1-27 (-> gp-0 sprite)))
        (.lvf vf1 (&-> s5-0 rvec quad))
        (.lvf vf2 (&-> s5-0 uvec quad))
        (.lvf vf3 (&-> s5-0 fvec quad))
        (.svf (&-> v1-27 x-y-z-sx quad) vf1)
        (.svf (&-> v1-27 flag-rot-sy quad) vf2)
        (.sub.w.vf vf3 vf0 vf0 :mask #b1000)
        (.svf (&-> v1-27 r-g-b-a quad) vf3)
        )
      (.mov v1-28 vf3)
      (logior! (-> gp-0 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-5))
      (set! (-> gp-0 cache-alpha) (-> s5-0 fvec w))
      )
    0
    (none)
    )
  )

(defun sp-clear-queue ()
  (let ((gp-0 *sp-launch-queue*)
        (s5-0 *launch-matrix*)
        )
    (when (> (-> gp-0 in-use) 0)
      (dotimes (s4-0 (-> gp-0 in-use))
        (let ((v1-4 (-> gp-0 queue s4-0)))
          (set! (-> s5-0 trans quad) (-> v1-4 pos quad))
          (launch-particles :system (-> v1-4 sp-system) (-> v1-4 sp-launcher) s5-0 :origin-is-matrix #t)
          )
        )
      (set! (-> gp-0 in-use) 0)
      0
      )
    )
  0
  (none)
  )

(defun sp-relaunch-setup-fields ((arg0 object) (arg1 sparticle-launcher) (arg2 sparticle-cpuinfo) (arg3 sprite-vec-data-3d))
  (local-vars
    (sv-80 (inline-array sp-field-init-spec))
    (sv-88 sp-cpuinfo-flag)
    (sv-96 matrix)
    (sv-100 symbol)
    (sv-104 symbol)
    )
  (set! sv-80 (the-as (inline-array sp-field-init-spec) (-> arg1 init-specs 0)))
  (set! sv-88 (logand (-> arg2 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-9 level0 level1 sp-cpuinfo-flag-12)))
  (set! sv-96 (new 'stack-no-clear 'matrix))
  (set! sv-100 (the-as symbol #f))
  (set! sv-104 (the-as symbol #f))
  (set! (-> arg2 next-launcher) (the-as basic 0))
  (when (nonzero? (-> arg2 key))
    (let ((s3-0 #t))
      (cond
        ((logtest? (sp-cpuinfo-flag left-multiply-quat) (-> arg2 flags))
         (quaternion->matrix sv-96 (-> arg2 key proc root quat))
         )
        ((logtest? (-> arg2 key group flags) (sp-group-flag sp12))
         (let* ((v1-17 sv-96)
                (a3-1 (-> arg2 key local-space-binding mat-new))
                (a0-5 (-> a3-1 rvec quad))
                (a1-2 (-> a3-1 uvec quad))
                (a2-1 (-> a3-1 fvec quad))
                (a3-2 (-> a3-1 trans quad))
                )
           (set! (-> v1-17 rvec quad) a0-5)
           (set! (-> v1-17 uvec quad) a1-2)
           (set! (-> v1-17 fvec quad) a2-1)
           (set! (-> v1-17 trans quad) a3-2)
           )
         )
        (else
          (set! s3-0 #f)
          )
        )
      (when s3-0
        (matrix-transpose! sv-96 sv-96)
        (when (or (get-field-spec-by-id arg1 (sp-field-id spt-accel-x))
                  (get-field-spec-by-id arg1 (sp-field-id spt-accel-y))
                  (get-field-spec-by-id arg1 (sp-field-id spt-accel-z))
                  )
          (set! sv-100 #t)
          (vector3s-rotate*! (the-as vector3s (-> arg2 acc)) (the-as vector3s (-> arg2 acc)) sv-96)
          )
        (when (or (get-field-spec-by-id arg1 (sp-field-id spt-vel-x))
                  (get-field-spec-by-id arg1 (sp-field-id spt-vel-y))
                  (get-field-spec-by-id arg1 (sp-field-id spt-vel-z))
                  )
          (set! sv-104 #t)
          (vector3s-rotate*! (the-as vector3s (-> arg2 vel-sxvel)) (the-as vector3s (-> arg2 vel-sxvel)) sv-96)
          )
        (matrix-transpose! sv-96 sv-96)
        )
      )
    )
  (cond
    ((and (logtest? (-> arg2 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-13))
          (not (logtest? (-> arg2 flags) (sp-cpuinfo-flag distort)))
          (not (logtest? (-> arg2 flags) (sp-cpuinfo-flag glow)))
          )
     (let ((f20-0 (-> arg3 r-g-b-a x))
           (f22-0 (-> arg3 r-g-b-a y))
           (f24-0 (-> arg3 r-g-b-a z))
           (f26-0 (-> arg2 fade x))
           (f28-0 (-> arg2 fade y))
           (f30-0 (-> arg2 fade z))
           )
       (set! (-> arg3 r-g-b-a x) 99999.0)
       (set! (-> arg3 r-g-b-a y) 99999.0)
       (set! (-> arg3 r-g-b-a z) 99999.0)
       (set! (-> arg2 fade x) 99999.0)
       (set! (-> arg2 fade y) 99999.0)
       (set! (-> arg2 fade z) 99999.0)
       (set! sv-80
             (sp-init-fields!
               (the-as (pointer float) (-> arg3 x-y-z-sx))
               sv-80
               (sp-field-id sprite-fields-start)
               (sp-field-id sprite-fields-end)
               #f
               )
             )
       (set! sv-80
             (sp-init-fields! (&-> arg2 omega) sv-80 (sp-field-id cpu-fields-start) (sp-field-id cpu-fields-end) #f)
             )
       (logior! (-> arg2 flags) sv-88)
       (let ((v1-54 (-> *time-of-day-context* current-prt-color)))
         (if (= (-> arg3 r-g-b-a x) 99999.0)
             (set! (-> arg3 r-g-b-a x) f20-0)
             (set! (-> arg3 r-g-b-a x) (* (-> arg3 r-g-b-a x) (-> v1-54 x)))
             )
         (if (= (-> arg3 r-g-b-a y) 99999.0)
             (set! (-> arg3 r-g-b-a y) f22-0)
             (set! (-> arg3 r-g-b-a y) (* (-> arg3 r-g-b-a y) (-> v1-54 y)))
             )
         (if (= (-> arg3 r-g-b-a z) 99999.0)
             (set! (-> arg3 r-g-b-a z) f24-0)
             (set! (-> arg3 r-g-b-a z) (* (-> arg3 r-g-b-a z) (-> v1-54 z)))
             )
         (if (= (-> arg2 fade x) 99999.0)
             (set! (-> arg2 fade x) f26-0)
             (set! (-> arg2 fade x) (* (-> arg2 fade x) (-> v1-54 x)))
             )
         (if (= (-> arg2 fade y) 99999.0)
             (set! (-> arg2 fade y) f28-0)
             (set! (-> arg2 fade y) (* (-> arg2 fade y) (-> v1-54 y)))
             )
         (if (= (-> arg2 fade z) 99999.0)
             (set! (-> arg2 fade z) f30-0)
             (set! (-> arg2 fade z) (* (-> arg2 fade z) (-> v1-54 z)))
             )
         )
       )
     )
    (else
      (set! sv-80
            (sp-init-fields!
              (the-as (pointer float) (-> arg3 x-y-z-sx))
              sv-80
              (sp-field-id sprite-fields-start)
              (sp-field-id sprite-fields-end)
              #f
              )
            )
      (set! sv-80
            (sp-init-fields! (&-> arg2 omega) sv-80 (sp-field-id cpu-fields-start) (sp-field-id cpu-fields-end) #f)
            )
      )
    )
  (if sv-100
      (vector3s-rotate*! (the-as vector3s (-> arg2 acc)) (the-as vector3s (-> arg2 acc)) sv-96)
      )
  (if sv-104
      (vector3s-rotate*! (the-as vector3s (-> arg2 vel-sxvel)) (the-as vector3s (-> arg2 vel-sxvel)) sv-96)
      )
  0
  0
  (none)
  )

(defun sp-relaunch-particle-2d ((arg0 object) (arg1 sparticle-launcher) (arg2 sparticle-cpuinfo) (arg3 sprite-vec-data-2d))
  (sp-relaunch-setup-fields arg0 arg1 arg2 (the-as sprite-vec-data-3d arg3))
  (when (logtest? (-> arg2 flags) (sp-cpuinfo-flag distort))
    (set! (-> arg3 r-g-b-a w) 0.0)
    (set! (-> arg2 fade w) 0.0)
    (logclear! (-> arg2 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-2))
    )
  (when (logtest? (-> arg2 flags) (sp-cpuinfo-flag glow))
    )
  0
  (none)
  )

(defun sp-relaunch-particle-3d ((arg0 object) (arg1 sparticle-launcher) (arg2 sparticle-cpuinfo) (arg3 sprite-vec-data-3d))
  (local-vars (v1-9 float) (v1-10 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 (new 'stack-no-clear 'quaternion)))
      (let* ((v1-0 s4-0)
             (a2-1 arg3)
             (f0-0 (-> a2-1 qx-qy-qz-sy x))
             (f1-0 (-> a2-1 qx-qy-qz-sy y))
             (f2-0 (-> a2-1 qx-qy-qz-sy z))
             )
        (set! (-> v1-0 x) f0-0)
        (set! (-> v1-0 y) f1-0)
        (set! (-> v1-0 z) f2-0)
        (set! (-> v1-0 w) (sqrtf (- (- (- 1.0 (* f2-0 f2-0)) (* f1-0 f1-0)) (* f0-0 f0-0))))
        )
      (set! (-> arg3 qx-qy-qz-sy x) 0.0)
      (set! (-> arg3 qx-qy-qz-sy y) 0.0)
      (set! (-> arg3 qx-qy-qz-sy z) 0.0)
      (sp-relaunch-setup-fields arg0 arg1 arg2 arg3)
      (let* ((a1-1 (-> arg2 flags-s32))
             (v1-1 -2)
             (a0-1 (the-as uint (-> arg3 r-g-b-a x)))
             (a1-2 (logand a1-1 (sp-cpuinfo-flag-s32 sp-cpuinfo-flag-14)))
             )
        1
        (let ((a1-3 (sar a1-2 14)))
          (set! (-> arg3 r-g-b-a x) (the-as float (logior (logand a0-1 (the-as uint v1-1)) a1-3)))
          )
        )
      (let ((a1-4 (new 'stack-no-clear 'vector))
            (s3-0 (new 'stack-no-clear 'quaternion))
            )
        (set-vector! a1-4 (-> arg3 qx-qy-qz-sy x) (-> arg3 qx-qy-qz-sy y) (-> arg3 qx-qy-qz-sy z) 1.0)
        (quaternion-zxy! s3-0 a1-4)
        (if (logtest? (sp-cpuinfo-flag left-multiply-quat) (-> arg2 flags))
            (quaternion*! s3-0 s4-0 s3-0)
            )
        (cond
          ((< (-> s3-0 w) 0.0)
           (.lvf vf1 (&-> arg3 qx-qy-qz-sy quad))
           (.lvf vf2 (&-> s3-0 quad))
           (.sub.vf vf1 vf0 vf2 :mask #b111)
           (.svf (&-> arg3 qx-qy-qz-sy quad) vf1)
           (.mov v1-9 vf1)
           )
          (else
            (.lvf vf1 (&-> arg3 qx-qy-qz-sy quad))
            (.lvf vf2 (&-> s3-0 quad))
            (.add.vf vf1 vf0 vf2 :mask #b111)
            (.svf (&-> arg3 qx-qy-qz-sy quad) vf1)
            (.mov v1-10 vf1)
            )
          )
        )
      )
    (cond
      (*sp-60-hz*
        (set! (-> arg2 rot-syvel x) (* 5.0 (-> arg2 rot-syvel x)))
        (set! (-> arg2 rot-syvel y) (* 5.0 (-> arg2 rot-syvel y)))
        (set! (-> arg2 rot-syvel z) (* 5.0 (-> arg2 rot-syvel z)))
        )
      (else
        (set! (-> arg2 rot-syvel x) (* 6.0 (-> arg2 rot-syvel x)))
        (set! (-> arg2 rot-syvel y) (* 6.0 (-> arg2 rot-syvel y)))
        (set! (-> arg2 rot-syvel z) (* 6.0 (-> arg2 rot-syvel z)))
        )
      )
    (quaternion-zxy! (-> arg2 rotvel3d) (-> arg2 rot-syvel))
    0
    (none)
    )
  )

(defmethod initialize ((this sparticle-launch-control) (arg0 sparticle-launch-group) (arg1 process-drawable))
  (let ((s5-0 0))
    (set! (-> this group) arg0)
    (set! (-> this proc) arg1)
    (set! (-> this local-clock) 0)
    (set! (-> this local-space-binding) (the-as particle-local-space-info 1.0))
    (set! (-> this matrix) 0)
    (set! (-> this last-spawn-frame)
          (the-as int (+ (-> *display* real-frame-clock integral-frame-counter) (seconds -0.007)))
          )
    (set! (-> this last-spawn-time) 0)
    (if (logtest? (-> this group flags) (sp-group-flag sp4))
        (quaternion->matrix (-> this origin) (-> arg1 root quat))
        (matrix-identity! (-> this origin))
        )
    (when (logtest? (-> arg0 flags) (sp-group-flag sp6))
      (let ((f0-1 (-> arg0 rotate-x))
            (f1-0 (-> arg0 rotate-y))
            (f2-0 (-> arg0 rotate-z))
            (t9-2 matrix-rotate-xyz!)
            (a0-3 (new 'stack-no-clear 'matrix))
            (a1-2 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-2 x) f0-1)
        (set! (-> a1-2 y) f1-0)
        (set! (-> a1-2 z) f2-0)
        (set! (-> a1-2 w) 1.0)
        (let ((a1-3 (t9-2 a0-3 a1-2)))
          (matrix*! (-> this origin) a1-3 (-> this origin))
          )
        )
      )
    (when (logtest? (-> arg0 flags) (sp-group-flag sp7))
      (let ((a1-4 (new 'stack-no-clear 'vector)))
        (set! (-> a1-4 x) (-> arg0 scale-x))
        (set! (-> a1-4 y) (-> arg0 scale-y))
        (set! (-> a1-4 z) (-> arg0 scale-z))
        (set! (-> a1-4 w) 1.0)
        (set! (-> a1-4 w) 1.0)
        (scale-matrix! (-> this origin) a1-4 (-> this origin))
        )
      )
    (dotimes (s3-0 (-> arg0 length))
      (let* ((a0-7 (-> arg0 launcher s3-0))
             (a1-6 (-> *part-id-table* (-> a0-7 launcher)))
             (v1-29 (-> this data s5-0))
             )
        (when (nonzero? a1-6)
          (set! (-> v1-29 group-item) a0-7)
          (cond
            ((= (-> a1-6 type) sparticle-launcher)
             (set! (-> v1-29 accum) 0.0)
             (set! (-> v1-29 spawn-time) (the-as uint (+ (current-time) (seconds -100))))
             (set! (-> v1-29 offset) (the-as uint (-> a0-7 offset)))
             (set! (-> v1-29 randomize) (the-as uint 0))
             (cond
               ((logtest? (-> a0-7 flags) (sp-group-item-flag sp2))
                (logclear! (-> v1-29 flags) (sp-launch-state-flags sp0))
                (set! (-> v1-29 center) #f)
                (set! (-> v1-29 sprite3d) #f)
                (set! (-> v1-29 sprite) #f)
                )
               (else
                 (logior! (-> v1-29 flags) (sp-launch-state-flags sp0))
                 (set! (-> v1-29 center) (-> this origin trans))
                 (set! (-> v1-29 sprite3d) #f)
                 (set! (-> v1-29 sprite) #f)
                 )
               )
             (+! s5-0 1)
             )
            (else
              (format 0 "initialize called with non-particle-launcher~%")
              )
            )
          )
        )
      )
    (set! (-> this length) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs sparticle-launch-control.
(defmethod create-launch-control ((this sparticle-launch-group) (arg0 process))
  (let ((gp-0 (the-as object (new 'process 'sparticle-launch-control (-> this length)))))
    (when (zero? (the-as sparticle-launch-control gp-0))
      (go process-drawable-art-error "memory")
      (set! gp-0 0)
      (goto cfg-4)
      )
    (initialize (the-as sparticle-launch-control gp-0) this (the-as process-drawable arg0))
    (label cfg-4)
    (the-as sparticle-launch-control gp-0)
    )
  )

(defmethod kill-particles ((this sparticle-launch-control))
  (countdown (v1-0 (-> this length))
    (let ((a0-4 (-> this data v1-0)))
      (logclear! (-> a0-4 flags) (sp-launch-state-flags sp1))
      )
    )
  (set! (-> this local-clock) 0)
  (set! (-> this local-space-binding) (the-as particle-local-space-info 1.0))
  (kill-all-particles-with-key this)
  (if (> (-> this matrix) 0)
      (sprite-release-user-hvdf (-> this matrix))
      )
  0
  (none)
  )

(defmethod clear-2 ((this sparticle-launch-control))
  "Set length to 0"
  (kill-all-particles-with-key this)
  0
  (none)
  )

(defmethod is-visible? ((this sparticle-launch-control) (arg0 vector))
  (let* ((v1-0 (-> this group))
         (f0-0 (-> v1-0 bounds r))
         )
    (cond
      ((= f0-0 0.0)
       #t
       )
      ((nonzero? (-> this matrix))
       #t
       )
      (else
        (let ((s5-1 (vector+! (new 'stack-no-clear 'vector) arg0 (the-as vector (-> v1-0 bounds)))))
          (set! (-> s5-1 w) f0-0)
          (when (or *display-sprite-marks*
                    *display-sprite-spheres*
                    (and *display-actor-vis* (= (-> this proc) *debug-actor*))
                    )
            (add-debug-sphere
              *display-sprite-spheres*
              (bucket-id debug)
              s5-1
              (-> s5-1 w)
              (new 'static 'rgba :g #xff :a #x80)
              )
            (add-debug-matrix *display-sprite-marks* (bucket-id debug) (-> this origin) (meters 2))
            )
          ;; og:preserve-this
          ;; can we see it?
          (#if (not PC_PORT)
              (sphere-in-view-frustum? (the-as sphere s5-1))
              (if (-> *pc-settings* ps2-parts?)
                  ;; og:preserve-this launchers have larger bsphere if you have ps2 parts off
                  (sphere-in-view-frustum? (the-as sphere s5-1))
                  (sphere-in-view-frustum? (the-as sphere (begin (*! (-> s5-1 w) 4.0) s5-1)))
                  )
              )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch particle-local-space-info vs none.
(defmethod set-local-space-info ((this sparticle-launch-control) (arg0 particle-local-space-info))
  (set! (-> this local-space-binding) arg0)
  (none)
  )

(defun execute-particle-local-space-engine ((arg0 int))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (let* ((gp-0 *part-local-space-engine*)
              (v1-2 (-> gp-0 alive-list next0))
              (s5-0 (-> (the-as connection v1-2) next0))
              )
         (while (!= v1-2 (-> gp-0 alive-list-end))
           (let ((a0-4 (the-as connection v1-2)))
             ((the-as (function particle-local-space-info object) (-> (the-as connection v1-2) param0))
              (the-as particle-local-space-info a0-4)
              )
             )
           (set! v1-2 s5-0)
           (set! s5-0 (-> (the-as connection s5-0) next0))
           )
         )
       )
      ((= v1-0 1)
       (let* ((v1-7 *part-local-space-engine*)
              (a1-0 (-> v1-7 alive-list next0))
              (a0-13 (-> (the-as particle-local-space-info a1-0) next0))
              )
         (while (!= a1-0 (-> v1-7 alive-list-end))
           (let* ((a2-0 (-> (the-as particle-local-space-info a1-0) mat-prev))
                  (t1-0 (-> (the-as particle-local-space-info a1-0) mat-new))
                  (a1-1 (-> t1-0 rvec quad))
                  (a3-0 (-> t1-0 uvec quad))
                  (t0-0 (-> t1-0 fvec quad))
                  (t1-1 (-> t1-0 trans quad))
                  )
             (set! (-> a2-0 rvec quad) a1-1)
             (set! (-> a2-0 uvec quad) a3-0)
             (set! (-> a2-0 fvec quad) t0-0)
             (set! (-> a2-0 trans quad) t1-1)
             )
           (set! a1-0 a0-13)
           (set! a0-13 (-> a0-13 next0))
           )
         )
       )
      )
    )
  0
  (none)
  )

(defun local-space-camera ((arg0 particle-local-space-info))
  (let ((s5-0 (math-camera-matrix))
        (gp-0 (-> arg0 mat-new))
        )
    (logior! (-> arg0 flags) (part-local-space-flags pls2))
    (cond
      ((logtest? (-> arg0 flags) (part-local-space-flags pls0))
       (matrix-identity! gp-0)
       (set! (-> gp-0 trans quad) (-> s5-0 trans quad))
       )
      ((logtest? (-> arg0 flags) (part-local-space-flags pls1))
       (let ((a2-0 gp-0)
             (v1-7 (-> s5-0 rvec quad))
             (a0-4 (-> s5-0 uvec quad))
             (a1-0 (-> s5-0 fvec quad))
             (a3-0 (-> s5-0 trans quad))
             )
         (set! (-> a2-0 rvec quad) v1-7)
         (set! (-> a2-0 uvec quad) a0-4)
         (set! (-> a2-0 fvec quad) a1-0)
         (set! (-> a2-0 trans quad) a3-0)
         )
       (set! (-> gp-0 rvec y) 0.0)
       (set! (-> gp-0 fvec y) 0.0)
       (vector-normalize! (-> gp-0 rvec) 1.0)
       (vector-normalize! (-> gp-0 fvec) 1.0)
       (vector-cross! (-> gp-0 uvec) (-> gp-0 fvec) (-> gp-0 rvec))
       )
      (else
        (let* ((a2-1 s5-0)
               (v1-10 (-> a2-1 rvec quad))
               (a0-8 (-> a2-1 uvec quad))
               (a1-4 (-> a2-1 fvec quad))
               (a2-2 (-> a2-1 trans quad))
               )
          (set! (-> gp-0 rvec quad) v1-10)
          (set! (-> gp-0 uvec quad) a0-8)
          (set! (-> gp-0 fvec quad) a1-4)
          (set! (-> gp-0 trans quad) a2-2)
          )
        )
      )
    )
  0
  (none)
  )

(defun local-space-proc-joint ((arg0 particle-local-space-info))
  (let ((a2-0 (handle->process (-> arg0 hand))))
    (when a2-0
      (let ((s5-0 (-> (the-as process-drawable a2-0) node-list data (the-as int (-> arg0 param1)) bone transform))
            (gp-0 (-> arg0 mat-new))
            )
        (logior! (-> arg0 flags) (part-local-space-flags pls2))
        (cond
          ((logtest? (-> arg0 flags) (part-local-space-flags pls0))
           (matrix-identity! gp-0)
           (set! (-> gp-0 trans quad) (-> s5-0 trans quad))
           )
          ((logtest? (-> arg0 flags) (part-local-space-flags pls1))
           (let ((a2-2 gp-0)
                 (v1-14 (-> s5-0 rvec quad))
                 (a0-4 (-> s5-0 uvec quad))
                 (a1-5 (-> s5-0 fvec quad))
                 (a3-0 (-> s5-0 trans quad))
                 )
             (set! (-> a2-2 rvec quad) v1-14)
             (set! (-> a2-2 uvec quad) a0-4)
             (set! (-> a2-2 fvec quad) a1-5)
             (set! (-> a2-2 trans quad) a3-0)
             )
           (set! (-> gp-0 rvec y) 0.0)
           (set! (-> gp-0 fvec y) 0.0)
           (vector-normalize! (-> gp-0 rvec) 1.0)
           (vector-normalize! (-> gp-0 fvec) 1.0)
           (vector-cross! (-> gp-0 uvec) (-> gp-0 fvec) (-> gp-0 rvec))
           )
          (else
            (let* ((a2-3 s5-0)
                   (v1-17 (-> a2-3 rvec quad))
                   (a0-8 (-> a2-3 uvec quad))
                   (a1-9 (-> a2-3 fvec quad))
                   (a2-4 (-> a2-3 trans quad))
                   )
              (set! (-> gp-0 rvec quad) v1-17)
              (set! (-> gp-0 uvec quad) a0-8)
              (set! (-> gp-0 fvec quad) a1-9)
              (set! (-> gp-0 trans quad) a2-4)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod spawn-from-mat ((this sparticle-launch-control) (arg0 matrix))
  (let* ((a2-0 (-> this origin))
         (a3-0 arg0)
         (v1-0 (-> a3-0 rvec quad))
         (a0-1 (-> a3-0 uvec quad))
         (a1-1 (-> a3-0 fvec quad))
         (a3-1 (-> a3-0 trans quad))
         )
    (set! (-> a2-0 rvec quad) v1-0)
    (set! (-> a2-0 uvec quad) a0-1)
    (set! (-> a2-0 fvec quad) a1-1)
    (set! (-> a2-0 trans quad) a3-1)
    )
  (let ((s4-0 (-> this group)))
    (when (logtest? (-> s4-0 flags) (sp-group-flag sp6))
      (let ((f0-0 (-> s4-0 rotate-x))
            (f1-0 (-> s4-0 rotate-y))
            (f2-0 (-> s4-0 rotate-z))
            (t9-0 matrix-rotate-xyz!)
            (a0-2 (new 'stack-no-clear 'matrix))
            (a1-2 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-2 x) f0-0)
        (set! (-> a1-2 y) f1-0)
        (set! (-> a1-2 z) f2-0)
        (set! (-> a1-2 w) 1.0)
        (let ((a1-3 (t9-0 a0-2 a1-2)))
          (matrix*! (-> this origin) a1-3 (-> this origin))
          )
        )
      )
    (when (logtest? (-> s4-0 flags) (sp-group-flag sp7))
      (let ((a1-4 (new 'stack-no-clear 'vector)))
        (set! (-> a1-4 x) (-> s4-0 scale-x))
        (set! (-> a1-4 y) (-> s4-0 scale-y))
        (set! (-> a1-4 z) (-> s4-0 scale-z))
        (set! (-> a1-4 w) 1.0)
        (set! (-> a1-4 w) 1.0)
        (scale-matrix! (-> this origin) a1-4 (-> this origin))
        )
      )
    )
  (spawn this (-> arg0 trans))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod spawn-from-cspace ((this sparticle-launch-control) (arg0 cspace))
  (let* ((v1-0 (-> this origin))
         (a3-0 (-> arg0 bone transform))
         (a0-2 (-> a3-0 rvec quad))
         (a1-1 (-> a3-0 uvec quad))
         (a2-0 (-> a3-0 fvec quad))
         (a3-1 (-> a3-0 trans quad))
         )
    (set! (-> v1-0 rvec quad) a0-2)
    (set! (-> v1-0 uvec quad) a1-1)
    (set! (-> v1-0 fvec quad) a2-0)
    (set! (-> v1-0 trans quad) a3-1)
    )
  (let ((s4-0 (-> this group)))
    (when (logtest? (-> s4-0 flags) (sp-group-flag sp6))
      (let ((f0-0 (-> s4-0 rotate-x))
            (f1-0 (-> s4-0 rotate-y))
            (f2-0 (-> s4-0 rotate-z))
            (t9-0 matrix-rotate-xyz!)
            (a0-3 (new 'stack-no-clear 'matrix))
            (a1-2 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-2 x) f0-0)
        (set! (-> a1-2 y) f1-0)
        (set! (-> a1-2 z) f2-0)
        (set! (-> a1-2 w) 1.0)
        (let ((a1-3 (t9-0 a0-3 a1-2)))
          (matrix*! (-> this origin) a1-3 (-> this origin))
          )
        )
      )
    (when (logtest? (-> s4-0 flags) (sp-group-flag sp7))
      (let ((a1-4 (new 'stack-no-clear 'vector)))
        (set! (-> a1-4 x) (-> s4-0 scale-x))
        (set! (-> a1-4 y) (-> s4-0 scale-y))
        (set! (-> a1-4 z) (-> s4-0 scale-z))
        (set! (-> a1-4 w) 1.0)
        (set! (-> a1-4 w) 1.0)
        (scale-matrix! (-> this origin) a1-4 (-> this origin))
        )
      )
    )
  (spawn this (vector<-cspace! (-> this origin trans) arg0))
  (none)
  )

;; WARN: Return type mismatch int vs object.
(defmethod spawn ((this sparticle-launch-control) (arg0 vector))
  (with-pp
    (set! (-> this origin trans quad) (-> arg0 quad))
    (if (not (or (is-visible? this arg0)
                 (logtest? (-> this group flags) (sp-group-flag sp1 sp2))
                 (and (logtest? (-> this group flags) (sp-group-flag sp2 sp11))
                      (not (-> *setting-control* user-current part-bounds-check))
                      )
                 )
             )
        (return (the-as object 0))
        )
    (when (logtest? (-> this group flags) (sp-group-flag sp12))
      (let* ((v1-18 (-> this origin))
             (a3-0 (-> this local-space-binding mat-prev))
             (a0-5 (-> a3-0 rvec quad))
             (a1-2 (-> a3-0 uvec quad))
             (a2-0 (-> a3-0 fvec quad))
             (a3-1 (-> a3-0 trans quad))
             )
        (set! (-> v1-18 rvec quad) a0-5)
        (set! (-> v1-18 uvec quad) a1-2)
        (set! (-> v1-18 fvec quad) a2-0)
        (set! (-> v1-18 trans quad) a3-1)
        )
      )
    (let ((s4-0 (the-as int (current-time)))
          (s5-0 (-> this last-spawn-time))
          )
      (let ((v1-22 (-> *display* real-frame-clock integral-frame-counter)))
        (if (!= v1-22 (+ (-> this last-spawn-frame) 1))
            (set! s5-0 (the-as int (- (the-as time-frame s4-0) (logand (the-as int (-> pp clock sparticle-data x)) 255))))
            )
        )
      (set! (-> this last-spawn-frame) (the-as int (-> *display* real-frame-clock integral-frame-counter)))
      (set! (-> this last-spawn-time) s4-0)
      (when (logtest? (-> this group flags) (sp-group-flag sp0))
        (set! s5-0 (-> this local-clock))
        (+! (-> this local-clock) (logand (the-as int (-> pp clock sparticle-data x)) 255))
        (set! s4-0 (-> this local-clock))
        )
      (let* ((f30-0 (vector-vector-distance arg0 (math-camera-pos)))
             (v1-38 1)
             (a0-12 *time-of-day*)
             (s3-1 (ash v1-38 (if a0-12
                                  (-> a0-12 0 hours)
                                  0
                                  )
                        )
                   )
             )
        (if (nonzero? (-> this matrix))
            (set! f30-0 0.0)
            )

        ;; og:preserve-this if we have ps2 particles off, say we're at the camera
        (with-pc
          (if (not (-> *pc-settings* ps2-parts?))
              (set! f30-0 0.0)))

        (let ((s2-1 (-> this length)))
          (b! #t cfg-102 :delay (nop!))
          (label cfg-26)
          (+! s2-1 -1)
          (let* ((a3-2 (-> this data s2-1))
                 (v1-45 (-> a3-2 group-item))
                 (a1-5 (-> *part-id-table* (-> v1-45 launcher)))
                 )
            (when (and a1-5 (nonzero? a1-5) (logtest? (-> a3-2 flags) (sp-launch-state-flags sp0)))
              (let* ((f1-3 (if (!= (-> v1-45 falloff-to) 0.0)
                               (- 1.0 (/ f30-0 (-> v1-45 falloff-to)))
                               1.0
                               )
                           )
                     (f0-5 f1-3)
                     )
                (let ((a0-24 sparticle-launcher))
                  (b! (!= (-> a1-5 type) a0-24) cfg-101 :delay (nop!))
                  )
                (b! (not (logtest? (-> v1-45 flags) (sp-group-item-flag sp3))) cfg-49 :delay (nop!))
                (when (not (logtest? (-> a3-2 flags) (sp-launch-state-flags sp1)))
                  (set! (-> a3-2 spawn-time) (the-as uint s4-0))
                  (logior! (-> a3-2 flags) (sp-launch-state-flags sp1))
                  (when (< 0.0 f0-5)
                    (cond
                      ((logtest? (-> v1-45 flags) (sp-group-item-flag sp7))
                       (launch-particles
                         :system (if (logtest? (-> v1-45 flags) (sp-group-item-flag is-3d))
                             *sp-particle-system-3d*
                             *sp-particle-system-2d*
                             )
                         a1-5
                         (-> this origin)
                         :launch-state a3-2
                         :launch-control this
                         :rate f0-5
                         :origin-is-matrix #t
                         )
                       )
                      (else
                        (let ((t9-4 sp-launch-particles-var)
                              (a0-37 (if (logtest? (-> v1-45 flags) (sp-group-item-flag is-3d))
                                         *sp-particle-system-3d*
                                         *sp-particle-system-2d*
                                         )
                                     )
                              (a2-5 *launch-matrix*)
                              )
                          (set! (-> a2-5 trans quad) (-> a3-2 center quad))
                          (t9-4 a0-37 a1-5 a2-5 a3-2 this f0-5)
                          )
                        )
                      )
                    )
                  )
                (b! #t cfg-100 :delay (nop!))
                (label cfg-49)
                (when (or (logtest? s3-1 (-> v1-45 hour-mask))
                          (not (or (= (-> v1-45 fade-after) 0.0) (< f30-0 (-> v1-45 fade-after))))
                          )
                  0
                  (goto cfg-100)
                  )
                (b! (nonzero? (-> v1-45 period)) cfg-66 :delay (empty-form))
                (if (not (logtest? (-> v1-45 flags) (sp-group-item-flag sp6)))
                    (set! f0-5 (* 0.2 (the float (- s4-0 s5-0)) f0-5))
                    )
                (b! #t cfg-88 :delay (nop!))
                (label cfg-66)
                0
                0
                (let* ((a2-6 (-> v1-45 length))
                       (a0-56 (-> v1-45 period))
                       (t0-10 (mod (+ (- s5-0 (the-as int (-> this data s2-1 offset))) a0-56) (the-as int a0-56)))
                       (a0-57 (mod (the-as uint (+ (- s4-0 (the-as int (-> this data s2-1 offset))) a0-56)) a0-56))
                       )
                  (set! f0-5 (cond
                               ((and (< t0-10 (the-as int a2-6)) (< (the-as int a0-57) (the-as int a2-6)))
                                (* 0.2 (the float (- s4-0 s5-0)) f0-5)
                                )
                               ((and (< t0-10 (the-as int a2-6)) (>= (the-as int a0-57) (the-as int a2-6)))
                                (* 0.2 (the float (- a2-6 (the-as uint t0-10))) f0-5)
                                )
                               ((and (>= t0-10 (the-as int a2-6)) (< (the-as int a0-57) (the-as int a2-6)))
                                (* 0.2 (the float a0-57) f0-5)
                                )
                               (else
                                 (when (not (logtest? (-> v1-45 flags) (sp-group-item-flag sp1)))
                                   0
                                   (goto cfg-100)
                                   )
                                 (when (< (the-as uint (- s4-0 (the-as int (-> this data s2-1 spawn-time)))) (-> v1-45 period))
                                   0
                                   (goto cfg-100)
                                   )
                                 (set! (-> this data s2-1 offset) (- (-> v1-45 period) a0-57))
                                 (* 0.2 (the float (- s4-0 s5-0)) f0-5)
                                 )
                               )
                        )
                  )
                (label cfg-88)
                (set! (-> a3-2 spawn-time) (the-as uint s4-0))
                (logior! (-> a3-2 flags) (sp-launch-state-flags sp1))
                (when (< 0.0 f0-5)
                  (if (logtest? (-> v1-45 flags) (sp-group-item-flag sp6))
                      (set! f0-5 f1-3)
                      )
                  (cond
                    ((logtest? (-> v1-45 flags) (sp-group-item-flag sp7))
                     (launch-particles
                       :system (if (logtest? (-> v1-45 flags) (sp-group-item-flag is-3d))
                           *sp-particle-system-3d*
                           *sp-particle-system-2d*
                           )
                       a1-5
                       (-> this origin)
                       :launch-state a3-2
                       :launch-control this
                       :rate f0-5
                       :origin-is-matrix #t
                       )
                     )
                    (else
                      (let ((t9-6 sp-launch-particles-var)
                            (a0-82 (if (logtest? (-> v1-45 flags) (sp-group-item-flag is-3d))
                                       *sp-particle-system-3d*
                                       *sp-particle-system-2d*
                                       )
                                   )
                            (a2-23 *launch-matrix*)
                            )
                        (set! (-> a2-23 trans quad) (-> a3-2 center quad))
                        (t9-6 a0-82 a1-5 a2-23 a3-2 this f0-5)
                        )
                      )
                    )
                  )
                )
              (label cfg-100)
              (b! #t cfg-102 :delay (nop!))
              (label cfg-101)
              (format 0 "spawn called for non-sparticle-launcher~%")
              )
            )
          (label cfg-102)
          (b! (nonzero? s2-1) cfg-26 :delay (nop!))
          )
        )
      )
    0
    )
  )

(defun execute-part-engine ()
  (local-vars (sv-96 sparticle-launcher) (sv-104 int))
  (let ((gp-0 *sp-particle-system-2d*))
    (let* ((s5-0 *part-engine*)
           (s4-0 *part-id-table*)
           (s3-0 (new 'stack-no-clear 'matrix))
           (s2-0 (new 'stack-no-clear 'vector))
           (v1-1 (-> s5-0 alive-list next0))
           (s1-0 (-> v1-1 next0))
           )
      (while (!= v1-1 (-> s5-0 alive-list-end))
        (let* ((a0-2 (the-as process-drawable (-> (the-as connection v1-1) param1)))
               (a1-0 (-> a0-2 draw))
               (s0-0 (the-as object (-> (the-as connection v1-1) param3)))
               )
          (when (and (logtest? (-> a1-0 status) (draw-control-status on-screen))
                     (< (-> a1-0 distance) (-> (the-as vector s0-0) w))
                     )
            (set! sv-96 (-> s4-0 (-> (the-as connection v1-1) param2)))
            (set! sv-104 (the-as int (-> (the-as connection v1-1) param0)))
            (when (nonzero? sv-96)
              (let ((a1-8 (-> a0-2 node-list data sv-104)))
                (let* ((v1-7 s3-0)
                       (t0-0 (-> a1-8 bone transform))
                       (a0-5 (-> t0-0 rvec quad))
                       (a2-2 (-> t0-0 uvec quad))
                       (a3-0 (-> t0-0 fvec quad))
                       (t0-1 (-> t0-0 trans quad))
                       )
                  (set! (-> v1-7 rvec quad) a0-5)
                  (set! (-> v1-7 uvec quad) a2-2)
                  (set! (-> v1-7 fvec quad) a3-0)
                  (set! (-> v1-7 trans quad) t0-1)
                  )
                (vector<-cspace! (-> s3-0 trans) a1-8)
                )
              (set! (-> s2-0 quad) (-> (the-as vector s0-0) quad))
              (set! (-> s2-0 w) 1.0)
              (vector-matrix*! (-> s3-0 trans) s2-0 s3-0)
              (launch-particles :system gp-0 sv-96 s3-0 :origin-is-matrix #t)
              )
            )
          )
        (set! v1-1 s1-0)
        (set! s1-0 (-> s1-0 next0))
        )
      )
    (let* ((s5-1 (camera-pos))
           (v1-12 1)
           (a0-14 *time-of-day*)
           (s4-1 (ash v1-12 (if a0-14
                                (-> a0-14 0 hours)
                                0
                                )
                      )
                 )
           )
      (dotimes (s3-1 (-> *level* length))
        (let ((v1-16 (-> *level* level s3-1)))
          (when (= (-> v1-16 status) 'active)
            (let ((s2-1 (-> v1-16 part-engine)))
              (when s2-1
                (countdown (s1-1 (-> s2-1 length))
                  (let ((s0-1 (-> s2-1 data s1-1)))
                    (when (and (or (zero? (-> s0-1 param3))
                                   ;; og:preserve-this
                                   (< (vector-vector-distance s5-1 (the-as vector (&-> s0-1 param0))) (the-as float (-> s0-1 param3)))
                                   )
                               (not (logtest? s4-1 (the-as int (-> s0-1 prev1))))
                               )
                      (let ((a1-14 (-> s0-1 next1))
                            (t9-5 sp-launch-particles-var)
                            (a0-25 gp-0)
                            (a2-5 *launch-matrix*)
                            )
                        (set! (-> a2-5 trans quad) (-> (the-as vector (&-> s0-1 param0)) quad))
                        (t9-5
                          a0-25
                          (the-as sparticle-launcher a1-14)
                          a2-5
                          (the-as sparticle-launch-state #f)
                          (the-as sparticle-launch-control #f)
                          1.0
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defun sparticle-track-root ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((v1-3 (-> arg1 key proc root trans)))
    (set! (-> arg2 x) (-> v1-3 x))
    (set! (-> arg2 y) (-> v1-3 y))
    (set! (-> arg2 z) (-> v1-3 z))
    )
  0
  (none)
  )

(defun sparticle-track-root-prim ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((v1-4 (-> (the-as collide-shape (-> arg1 key proc root)) root-prim prim-core)))
    (set! (-> arg2 x) (-> v1-4 world-sphere x))
    (set! (-> arg2 y) (-> v1-4 world-sphere y))
    (set! (-> arg2 z) (-> v1-4 world-sphere z))
    )
  0
  (none)
  )

(defun sparticle-track-joint ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let* ((v1-1 (-> arg1 key proc))
         (a1-1 (the int (-> arg1 user-float)))
         (v1-3 (vector<-cspace! (new 'stack-no-clear 'vector) (-> v1-1 node-list data a1-1)))
         )
    (set! (-> arg2 x) (-> v1-3 x))
    (set! (-> arg2 y) (-> v1-3 y))
    (set! (-> arg2 z) (-> v1-3 z))
    )
  0
  (none)
  )

(defun sparticle-turn-to-vel ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-3d))
  (local-vars (v1-1 float) (v1-2 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'quaternion)))
      (quaternion-axis-angle! gp-0 0.0 1.0 0.0 (+ 32768.0 (vector-y-angle (-> arg1 vel-sxvel))))
      (cond
        ((< (-> gp-0 w) 0.0)
         (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
         (.lvf vf2 (&-> gp-0 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
         (.mov v1-1 vf1)
         )
        (else
          (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
          (.lvf vf2 (&-> gp-0 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
          (.mov v1-2 vf1)
          )
        )
      )
    0
    (none)
    )
  )

(defun sparticle-rotate-to-vel-3d ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-3d) (arg3 vector))
  (local-vars (v1-9 float) (v1-10 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (new 'stack-no-clear 'vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg1 vel-sxvel quad))
      (let ((s4-0 (-> arg1 key proc)))
        (vector-normalize! s5-0 1.0)
        (let ((s3-0 (new 'stack-no-clear 'vector))
              (v1-4 (new 'stack-no-clear 'vector))
              )
          (set! (-> v1-4 x) (-> arg2 x-y-z-sx x))
          (set! (-> v1-4 y) (-> arg2 x-y-z-sx y))
          (set! (-> v1-4 z) (-> arg2 x-y-z-sx z))
          (set! (-> v1-4 w) 1.0)
          (let ((s3-1 (vector-! s3-0 v1-4 (-> s4-0 root trans)))
                (s2-0 (new 'stack-no-clear 'matrix))
                )
            (cond
              (#t
                (set! (-> s3-1 y) 0.0)
                (vector-rotate-around-y! s3-1 s3-1 16384.0)
                (vector-normalize! s3-1 1.0)
                (matrix-r-f-compose s2-0 s5-0 s3-1 arg3)
                )
              (else
                (matrix-r-f-compose s2-0 s5-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> s4-0 root quat)) arg3)
                )
              )
            (let ((s5-1 (new 'stack-no-clear 'quaternion)))
              (matrix->quaternion s5-1 s2-0)
              (cond
                ((< (-> s5-1 w) 0.0)
                 (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
                 (.lvf vf2 (&-> s5-1 quad))
                 (.sub.vf vf1 vf0 vf2 :mask #b111)
                 (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
                 (.mov v1-9 vf1)
                 )
                (else
                  (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
                  (.lvf vf2 (&-> s5-1 quad))
                  (.add.vf vf1 vf0 vf2 :mask #b111)
                  (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
                  (.mov v1-10 vf1)
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defun birth-func-clean ((arg0 sparticle-system)
                (arg1 sparticle-cpuinfo)
                (arg2 sprite-vec-data-3d)
                (arg3 sparticle-launcher)
                (arg4 sparticle-launch-state)
                )
  (when *display-capture-mode*
    (set! (-> arg1 timer) 0)
    0
    )
  0
  (none)
  )

(defun birth-func-process-clock ((arg0 sparticle-system)
                        (arg1 sparticle-cpuinfo)
                        (arg2 sprite-vec-data-3d)
                        (arg3 sparticle-launcher)
                        (arg4 sparticle-launch-state)
                        )
  (set! (-> arg1 clock-index) (the-as uint (-> *kernel-context* current-process clock index)))
  0
  (none)
  )

(defun birth-func-copy-rot-color ((arg0 sparticle-system)
                         (arg1 sparticle-cpuinfo)
                         (arg2 sprite-vec-data-3d)
                         (arg3 sparticle-launcher)
                         (arg4 sparticle-launch-state)
                         )
  (local-vars (v1-5 float) (v1-6 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> arg4 sprite)))
      (let ((s4-0 (new 'stack-no-clear 'quaternion)))
        (let* ((v1-0 arg2)
               (f0-0 (-> v1-0 qx-qy-qz-sy x))
               (f1-0 (-> v1-0 qx-qy-qz-sy y))
               (f2-0 (-> v1-0 qx-qy-qz-sy z))
               )
          (set! (-> s4-0 x) f0-0)
          (set! (-> s4-0 y) f1-0)
          (set! (-> s4-0 z) f2-0)
          (set! (-> s4-0 w) (sqrtf (- (- (- 1.0 (* f2-0 f2-0)) (* f1-0 f1-0)) (* f0-0 f0-0))))
          )
        (quaternion-rotate-y! s4-0 s4-0 (-> s5-0 sprite flag-rot-sy z))
        (let ((v1-4 arg2))
          (cond
            ((< (-> s4-0 w) 0.0)
             (.lvf vf1 (&-> v1-4 qx-qy-qz-sy quad))
             (.lvf vf2 (&-> s4-0 quad))
             (.sub.vf vf1 vf0 vf2 :mask #b111)
             (.svf (&-> v1-4 qx-qy-qz-sy quad) vf1)
             (.mov v1-5 vf1)
             )
            (else
              (.lvf vf1 (&-> v1-4 qx-qy-qz-sy quad))
              (.lvf vf2 (&-> s4-0 quad))
              (.add.vf vf1 vf0 vf2 :mask #b111)
              (.svf (&-> v1-4 qx-qy-qz-sy quad) vf1)
              (.mov v1-6 vf1)
              )
            )
          )
        )
      (set! (-> arg2 r-g-b-a x) (-> s5-0 sprite r-g-b-a x))
      (set! (-> arg2 r-g-b-a y) (-> s5-0 sprite r-g-b-a y))
      (set! (-> arg2 r-g-b-a z) (-> s5-0 sprite r-g-b-a z))
      )
    0
    (none)
    )
  )

(define *global-toggle* 0)

(defun birth-func-copy2-rot-color ((arg0 sparticle-system)
                          (arg1 sparticle-cpuinfo)
                          (arg2 sprite-vec-data-3d)
                          (arg3 sparticle-launcher)
                          (arg4 sparticle-launch-state)
                          )
  (local-vars (v1-18 float) (v1-19 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> arg4 sprite)))
      (let ((s4-0 (new 'stack-no-clear 'quaternion)))
        (let* ((v1-0 arg2)
               (f0-0 (-> v1-0 qx-qy-qz-sy x))
               (f1-0 (-> v1-0 qx-qy-qz-sy y))
               (f2-0 (-> v1-0 qx-qy-qz-sy z))
               )
          (set! (-> s4-0 x) f0-0)
          (set! (-> s4-0 y) f1-0)
          (set! (-> s4-0 z) f2-0)
          (set! (-> s4-0 w) (sqrtf (- (- (- 1.0 (* f2-0 f2-0)) (* f1-0 f1-0)) (* f0-0 f0-0))))
          )
        (let ((a1-1 (new-stack-vector0)))
          (set! (-> a1-1 y) (-> s5-0 sprite flag-rot-sy z))
          (set! (-> a1-1 z) (if (logtest? *global-toggle* 1)
                                (the float (sar (shl (the int (- 16384.0 (-> s5-0 sprite x-y-z-sx w))) 48) 48))
                                (the float (sar (shl (the int (+ 16384.0 (-> s5-0 sprite x-y-z-sx w))) 48) 48))
                                )
                )
          (quaternion-zxy! s4-0 a1-1)
          )
        (let ((v1-17 arg2))
          (cond
            ((< (-> s4-0 w) 0.0)
             (.lvf vf1 (&-> v1-17 qx-qy-qz-sy quad))
             (.lvf vf2 (&-> s4-0 quad))
             (.sub.vf vf1 vf0 vf2 :mask #b111)
             (.svf (&-> v1-17 qx-qy-qz-sy quad) vf1)
             (.mov v1-18 vf1)
             )
            (else
              (.lvf vf1 (&-> v1-17 qx-qy-qz-sy quad))
              (.lvf vf2 (&-> s4-0 quad))
              (.add.vf vf1 vf0 vf2 :mask #b111)
              (.svf (&-> v1-17 qx-qy-qz-sy quad) vf1)
              (.mov v1-19 vf1)
              )
            )
          )
        )
      (set! (-> arg2 r-g-b-a x) (-> s5-0 sprite r-g-b-a x))
      (set! (-> arg2 r-g-b-a y) (-> s5-0 sprite r-g-b-a y))
      (set! (-> arg2 r-g-b-a z) (-> s5-0 sprite r-g-b-a z))
      )
    (set! *global-toggle* (+ *global-toggle* 1))
    0
    (none)
    )
  )

(defun birth-func-copy-omega-to-z ((arg0 sparticle-system)
                          (arg1 sparticle-cpuinfo)
                          (arg2 sprite-vec-data-3d)
                          (arg3 sparticle-launcher)
                          (arg4 sparticle-launch-state)
                          )
  (set! (-> arg2 qx-qy-qz-sy z) (+ -16384.0 (-> arg1 omega)))
  (set! (-> arg1 next-time) (-> arg4 sprite next-time))
  (set! (-> arg2 x-y-z-sx w) (* 163.85638 (the float (-> arg4 sprite next-time))))
  0
  (none)
  )

(defun birth-func-random-next-time ((arg0 sparticle-system)
                           (arg1 sparticle-cpuinfo)
                           (arg2 sprite-vec-data-3d)
                           (arg3 sparticle-launcher)
                           (arg4 sparticle-launch-state)
                           )
  (set! (-> arg1 next-time) (the-as uint (the int (rand-vu-float-range 0.0 (-> arg1 user-float)))))
  0
  (none)
  )

(defun sparticle-respawn-heights ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((gp-0 (the-as (array int32) (-> arg1 user-float))))
    (when (and (nonzero? gp-0)
               ;; og:preserve-this
               (or (and (< (-> arg1 vel-sxvel y) 0.0) (< (-> arg2 y) (the-as float (-> gp-0 1))))
                   (and (< 0.0 (-> arg1 vel-sxvel y)) (< (the-as float (-> gp-0 2)) (-> arg2 y)))
                   )
               )
      (sp-kill-particle arg0 arg1)
      (let ((s3-0 (+ (-> gp-0 length) -1)))
        (when (< 2 s3-0)
          (let ((s2-0 (new 'stack-no-clear 'vector))
                (s1-0 (if (zero? (-> gp-0 0))
                          *sp-particle-system-2d*
                          *sp-particle-system-3d*
                          )
                      )
                )
            (set-vector! s2-0 (-> arg2 x) (-> arg1 user-float) (-> arg2 z) 1.0)
            (let ((s5-1 3))
              (while (>= s3-0 s5-1)
                (let ((t9-1 sp-launch-particles-var)
                      (a0-2 s1-0)
                      (a1-3 (-> *part-id-table* (-> gp-0 s5-1)))
                      (a2-1 *launch-matrix*)
                      )
                  (set! (-> a2-1 trans quad) (-> s2-0 quad))
                  (t9-1 a0-2 a1-3 a2-1 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
                  )
                (+! s5-1 1)
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defun sparticle-respawn-timer ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (when (<= (-> arg1 timer) 0)
    (let ((gp-0 (the-as (array int32) (-> arg1 user-float))))
      (when (nonzero? gp-0)
        (sp-kill-particle arg0 arg1)
        (let ((s5-0 (+ (-> gp-0 length) -1)))
          (when (< 2 s5-0)
            (let ((s4-0 (new 'stack-no-clear 'vector))
                  (s3-0 (if (zero? (-> gp-0 0))
                            *sp-particle-system-2d*
                            *sp-particle-system-3d*
                            )
                        )
                  )
              (set-vector! s4-0 (-> arg2 x) (-> arg1 user-float) (-> arg2 z) 1.0)
              (let ((s2-1 3))
                (while (>= s5-0 s2-1)
                  (let ((t9-1 sp-launch-particles-var)
                        (a0-2 s3-0)
                        (a1-3 (-> *part-id-table* (-> gp-0 s2-1)))
                        (a2-1 *launch-matrix*)
                        )
                    (set! (-> a2-1 trans quad) (-> s4-0 quad))
                    (t9-1 a0-2 a1-3 a2-1 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
                    )
                  (+! s2-1 1)
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun sparticle-texture-animate ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((v1-0 (the-as (array int32) (-> arg1 user-float))))
    (when (nonzero? v1-0)
      (if (zero? (-> v1-0 2))
          (set! (-> v1-0 2) (-> arg1 timer))
          )
      (let* ((a0-6 (+ (-> v1-0 length) -3))
             (a2-1 (-> v1-0 0))
             (a3-0 (-> v1-0 2))
             (t0-1 (if (< (-> arg1 timer) 0)
                       (the-as int (-> *display* base-clock frame-counter))
                       (- a3-0 (-> arg1 timer))
                       )
                   )
             )
        (cond
          ((zero? (-> v1-0 1))
           (let ((v1-2
                   (the-as
                     (array int32)
                     (-> (the-as
                           (array int32)
                           (+ (* (+ (max 0 (min (+ (/ t0-1 a2-1) (-> arg1 user1-int16)) (+ a0-6 -1))) 3) 4) (the-as int v1-0))
                           )
                         0
                         )
                     )
                   )
                 )
             (if (nonzero? v1-2)
                 (particle-adgif-callback (-> arg1 adgif) (the-as texture-id v1-2))
                 )
             )
           )
          (else
            (let ((v1-4 (-> v1-0 (+ (mod (max 0 (+ (/ t0-1 a2-1) (-> arg1 user1-int16))) a0-6) 3))))
              (if (nonzero? v1-4)
                  (particle-adgif-callback (-> arg1 adgif) (the-as texture-id v1-4))
                  )
              )
            )
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; ERROR: Bad vector register dependency: vf1
;; ERROR: Bad vector register dependency: vf2
(defun sparticle-texture-day-night ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-2d))
  ;; og:preserve-this this was rewritten from assembly!
  (let ((s2-0 (the-as (array int32) (-> arg1 user-object))))
    (when (nonzero? s2-0)
      (let* ((v1-1 *time-of-day*)
              (s1-0 (if v1-1
                        (-> v1-1 0 hours)
                        0
                        )
                    )
              (f0-0 (rand-vu))
              )
        (cond
          ((or (< s1-0 6) (< 18 s1-0))
            (let ((night-tex (the texture-id (-> s2-0 7))))
              (when (nonzero? night-tex)
                ;; they use two consecutive pextlb with zeros to expand each 8-bit value in the rgba
                ;; to a 32-bit value with no sign extension (i believe) and then itof it. very fast!
                ;; 8 -> 32 expand to vf1
                ;; multiply by f0-0 (in vf2)
                ;; 8 -> 32 expand to vf2
                ;; to float
                ;; vf1 += vf2
                (let ((rgba-rand (the rgba (-> s2-0 9)))
                      (rgba-base (the rgba (-> s2-0 8))))
                  (set-vector! (-> arg2 r-g-b-a)
                      (* f0-0 (-> rgba-rand r))
                      (* f0-0 (-> rgba-rand g))
                      (* f0-0 (-> rgba-rand b))
                      (* f0-0 (-> rgba-rand a)))
                  (+! (-> arg2 r-g-b-a x) (-> rgba-base r))
                  (+! (-> arg2 r-g-b-a y) (-> rgba-base g))
                  (+! (-> arg2 r-g-b-a z) (-> rgba-base b))
                  (+! (-> arg2 r-g-b-a w) (-> rgba-base a))
                  )
                (when (nonzero? (-> s2-0 10))
                  (*! (-> arg2 r-g-b-a x) (-> *time-of-day-context* current-prt-color x))
                  (*! (-> arg2 r-g-b-a y) (-> *time-of-day-context* current-prt-color y))
                  (*! (-> arg2 r-g-b-a z) (-> *time-of-day-context* current-prt-color z))
                  (*! (-> arg2 r-g-b-a w) (-> *time-of-day-context* current-prt-color w))
                  )
                ;; sneak in a flag here for... some reason
                (if (logtest? (-> arg1 flags) (sp-cpuinfo-flag-s32 sp-cpuinfo-flag-14))
                    (set! (-> arg2 r-g-b-a x) (the-as float (logior 1 (the-as int (-> arg2 r-g-b-a x)))))
                    (set! (-> arg2 r-g-b-a x) (the-as float (logand (lognot 1) (the-as int (-> arg2 r-g-b-a x))))))
                (particle-adgif-callback (-> arg1 adgif) night-tex)
                )
              )
            )
          (else
            (let ((day-tex (the texture-id (-> s2-0 3))))
              (when (nonzero? day-tex)
                (let ((rgba-rand (the rgba (-> s2-0 5)))
                      (rgba-base (the rgba (-> s2-0 4))))
                  (set-vector! (-> arg2 r-g-b-a)
                      (* f0-0 (-> rgba-rand r))
                      (* f0-0 (-> rgba-rand g))
                      (* f0-0 (-> rgba-rand b))
                      (* f0-0 (-> rgba-rand a)))
                  (+! (-> arg2 r-g-b-a x) (-> rgba-base r))
                  (+! (-> arg2 r-g-b-a y) (-> rgba-base g))
                  (+! (-> arg2 r-g-b-a z) (-> rgba-base b))
                  (+! (-> arg2 r-g-b-a w) (-> rgba-base a))
                  )
                (when (nonzero? (-> s2-0 6))
                  (*! (-> arg2 r-g-b-a x) (-> *time-of-day-context* current-prt-color x))
                  (*! (-> arg2 r-g-b-a y) (-> *time-of-day-context* current-prt-color y))
                  (*! (-> arg2 r-g-b-a z) (-> *time-of-day-context* current-prt-color z))
                  (*! (-> arg2 r-g-b-a w) (-> *time-of-day-context* current-prt-color w))
                  )
                (if (logtest? (-> arg1 flags) (sp-cpuinfo-flag-s32 sp-cpuinfo-flag-14))
                    (set! (-> arg2 r-g-b-a x) (the-as float (logior 1 (the-as int (-> arg2 r-g-b-a x)))))
                    (set! (-> arg2 r-g-b-a x) (the-as float (logand (lognot 1) (the-as int (-> arg2 r-g-b-a x))))))
                (particle-adgif-callback (-> arg1 adgif) day-tex)
                )
              )
            )
          )
        )
      )
    )
  (none)
  )

(defun sparticle-mode-animate ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-2d))
  (let ((a0-1 (-> arg1 key))
        (v1-0 (the-as object (-> arg1 user-float)))
        )
    (when (nonzero? (the-as float v1-0))
      (let ((a1-2 (the-as (array uint32) (-> (the-as (array symbol) v1-0) 0 value))))
        (when (nonzero? a1-2)
          (let* ((a1-4 (the-as object (-> a1-2 (min (the-as int (+ (-> a0-1 state-mode 0) 1)) (+ (-> a1-2 length) -1)))))
                 (a0-8 (the-as
                         object
                         (-> (the-as (array int32) a1-4)
                             (+ (mod
                                  (the-as int (/ (-> a0-1 state-counter) (the-as uint (/ (-> (the-as vector4w a1-4) w) 8))))
                                  (+ (-> (the-as (pointer int32) a1-4) 0) -1)
                                  )
                                1
                                )
                             )
                         )
                       )
                 (a1-6 (/ (-> (the-as (array int32) v1-0) 1) 8))
                 (a2-14 (-> (the-as (pointer int64) a0-8) (/ a1-6 64)))
                 (a0-11 (logtest? a2-14 (ash 1 (logand a1-6 63))))
                 (s4-0 (if a0-11
                           (-> (the-as (pointer int32) v1-0) 6)
                           (-> (the-as (pointer int32) v1-0) 5)
                           )
                       )
                 )
            (if a0-11
                (set! (-> arg2 r-g-b-a x) (rand-vu-float-range 64.0 192.0))
                (set! (-> arg2 r-g-b-a x) (rand-vu-float-range 32.0 48.0))
                )
            (set! (-> arg2 r-g-b-a y) (-> arg2 r-g-b-a x))
            (set! (-> arg2 r-g-b-a z) (-> arg2 r-g-b-a x))
            (if (nonzero? s4-0)
                (particle-adgif-callback (-> arg1 adgif) (the-as texture-id s4-0))
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(def-mips2c sparticle-motion-blur (function sparticle-system sparticle-cpuinfo vector none))

;; WARN: Return type mismatch int vs object.
(defun-debug sparticle-motion-blur-old ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-3d))
  (let ((s2-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector4w))
        (s3-0 (new 'stack-no-clear 'vector4w))
        )
    (set! (-> s2-0 x) (-> arg2 x-y-z-sx x))
    (set! (-> s2-0 y) (-> arg2 x-y-z-sx y))
    (set! (-> s2-0 z) (-> arg2 x-y-z-sx z))
    (set! (-> s2-0 w) 1.0)
    (when (and (or (!= (-> arg1 vel-sxvel x) 0.0) (!= (-> arg1 vel-sxvel y) 0.0) (!= (-> arg1 vel-sxvel z) 0.0))
               (transform-point-qword! s5-0 s2-0)
               )
      (+! (-> s2-0 x) (* 32.0 (-> arg1 vel-sxvel x)))
      (+! (-> s2-0 y) (* 32.0 (-> arg1 vel-sxvel y)))
      (+! (-> s2-0 z) (* 32.0 (-> arg1 vel-sxvel z)))
      (when (transform-point-qword! s3-0 s2-0)
        (let* ((f0-14 (the float (+ (-> s5-0 x) -28672)))
               (f1-10 (the float (+ (-> s5-0 y) -29440)))
               (f2-4 (the float (+ (-> s3-0 x) -28672)))
               (f3-1 (the float (+ (-> s3-0 y) -29440)))
               (f30-0 (- f2-4 f0-14))
               (f28-0 (- f3-1 f1-10))
               )
          (set! (-> arg2 qx-qy-qz-sy z) (+ -16384.0 (atan f30-0 f28-0)))
          (let ((f0-17 (-> arg1 omega)))
            (if (!= f0-17 0.0)
                (set! (-> arg2 x-y-z-sx w) (* (sqrtf (+ (* f30-0 f30-0) (* f28-0 f28-0)))
                                              f0-17
                                              (lerp-scale 3.0 0.25 (/ 1.0 (the float (-> s5-0 z))) 0.000001 0.00000014285715)
                                              )
                      )
                )
            )
          )
        (return (the-as object #f))
        )
      )
    )
  (if (!= (-> arg1 omega) 0.0)
      (set! (-> arg2 x-y-z-sx w) 0.0)
      )
  0
  )

(defun sparticle-set-conerot ((arg0 sparticle-launcher) (arg1 vector))
  (let ((s5-0 (get-field-spec-by-id arg0 (sp-field-id spt-conerot-x)))
        (s4-0 (get-field-spec-by-id arg0 (sp-field-id spt-conerot-y)))
        (v1-3 (get-field-spec-by-id arg0 (sp-field-id spt-conerot-z)))
        )
    (set! (-> s5-0 initial-valuef) (-> arg1 x))
    (set! (-> s4-0 initial-valuef) (-> arg1 y))
    (set! (-> v1-3 initial-valuef) (-> arg1 z))
    )
  0
  (none)
  )

(defun sparticle-next-on-mode-1 ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (if (zero? (-> arg1 key state-mode 0))
      (set! (-> arg1 next-time)
            (the-as uint (* (max 1 (the-as int (-> *display* clock (-> arg1 clock-index) sparticle-data x))) 2))
            )
      )
  0.0
  )

(defun check-ground-bounce ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((f0-1 (+ (-> arg1 key origin trans y) (-> arg1 user-float))))
    (when (and (< (-> arg2 launchrot y) f0-1) (< (-> arg1 vel-sxvel y) 0.0))
      (set! (-> arg2 launchrot y) f0-1)
      (set! (-> arg1 vel-sxvel y) (* (-> arg1 vel-sxvel y) (- (rand-vu-float-range 0.6 0.8))))
      )
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defun check-drop-group-center ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((f0-0 (-> arg1 key origin trans y)))
    (if (< (-> arg2 launchrot y) f0-0)
        (sp-kill-particle arg0 arg1)
        )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun check-bubble-height ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (if (< (-> arg1 key origin trans y) (-> arg2 launchrot y))
      (sp-kill-particle arg0 arg1)
      )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun check-raise-group-center ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (if (< (-> arg1 key origin trans y) (-> arg2 launchrot y))
      (sp-kill-particle arg0 arg1)
      )
  (none)
  )

(defun birth-func-y->userdata ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 matrix))
  (+! (-> arg1 user-float) (-> arg2 rvec y))
  0
  (none)
  )

(defun birth-func-ocean-height ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 matrix))
  (set! (-> arg2 rvec y) (+ (get-height *ocean* (-> arg2 rvec) #t) (-> arg1 user-float)))
  0
  (none)
  )

(defun birth-func-camera-orient ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (local-vars (v1-0 float) (v1-1 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-1
            (forward-up-nopitch->quaternion (new 'stack-no-clear 'quaternion) (-> (math-camera-matrix) fvec) *up-vector*)
            )
          )
      (quaternion-rotate-x! s5-1 s5-1 16384.0)
      (cond
        ((< (-> s5-1 w) 0.0)
         (.lvf vf1 (&-> arg2 conerot quad))
         (.lvf vf2 (&-> s5-1 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> arg2 conerot quad) vf1)
         (.mov v1-0 vf1)
         )
        (else
          (.lvf vf1 (&-> arg2 conerot quad))
          (.lvf vf2 (&-> s5-1 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> arg2 conerot quad) vf1)
          (.mov v1-1 vf1)
          )
        )
      )
    0
    (none)
    )
  )

(defun birth-func-set-parent-pntr ((arg0 sparticle-system)
                          (arg1 sparticle-cpuinfo)
                          (arg2 sprite-vec-data-3d)
                          (arg3 sparticle-launcher)
                          (arg4 sparticle-launch-state)
                          )
  (set! (-> arg1 user-float) (the-as float (-> arg4 sprite sprite)))
  0
  (none)
  )

(defun birth-func-get-parent-quat ((arg0 sparticle-system)
                          (arg1 sparticle-cpuinfo)
                          (arg2 sprite-vec-data-3d)
                          (arg3 sparticle-launcher)
                          (arg4 sparticle-launch-state)
                          )
  (let ((a0-1 (-> arg4 sprite sprite))
        (a1-1 (new 'stack-no-clear 'quaternion))
        )
    (when a0-1
      (let ((v1-2 a1-1)
            (f0-0 (-> a0-1 flag-rot-sy x))
            (f1-0 (-> a0-1 flag-rot-sy y))
            (f2-0 (-> a0-1 flag-rot-sy z))
            )
        (set! (-> v1-2 x) f0-0)
        (set! (-> v1-2 y) f1-0)
        (set! (-> v1-2 z) f2-0)
        (set! (-> v1-2 w) (sqrtf (- (- (- 1.0 (* f2-0 f2-0)) (* f1-0 f1-0)) (* f0-0 f0-0))))
        )
      (quaternion->matrix (-> arg4 control origin) a1-1)
      )
    )
  0
  (none)
  )

(defun spt-func-camera-facing-orbiter ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((s5-0 (new 'stack-no-clear 'quaternion)))
    0.0
    (quaternion<-rotate-y-vector s5-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> arg1 rotvel3d)))
    (let ((f0-2 (- (camera-angle) (quaternion-xz-angle s5-0))))
      (quaternion-rotate-y! (-> arg1 rotvel3d) (-> arg1 rotvel3d) f0-2)
      )
    )
  )

(define *particle-quat* (new 'static 'quaternion :w 1.0))

(defun birth-func-set-quat ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (local-vars (a0-2 float) (a0-3 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a0-1 arg2)
          (v1-0 *particle-quat*)
          )
      (cond
        ((< (-> v1-0 w) 0.0)
         (.lvf vf1 (&-> a0-1 conerot quad))
         (.lvf vf2 (&-> v1-0 quad))
         (.sub.vf vf1 vf0 vf2 :mask #b111)
         (.svf (&-> a0-1 conerot quad) vf1)
         (.mov a0-2 vf1)
         )
        (else
          (.lvf vf1 (&-> a0-1 conerot quad))
          (.lvf vf2 (&-> v1-0 quad))
          (.add.vf vf1 vf0 vf2 :mask #b111)
          (.svf (&-> a0-1 conerot quad) vf1)
          (.mov a0-3 vf1)
          )
        )
      )
    0
    (none)
    )
  )

(define *particle-vel* (new 'static 'vector :w 1.0))

(defun birth-func-set-vel ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((v1-0 *particle-vel*))
    (set! (-> arg1 vel-sxvel x) (-> v1-0 x))
    (set! (-> arg1 vel-sxvel y) (-> v1-0 y))
    (set! (-> arg1 vel-sxvel z) (-> v1-0 z))
    )
  0
  (none)
  )

(defun birth-func-texture-group ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((s5-0 (the-as (array int32) (-> arg1 user-float))))
    (when (nonzero? s5-0)
      (let* ((s4-0 (+ (-> s5-0 length) -3))
             (v1-3 (+ (mod (the-as int (rand-uint31-gen *random-generator*)) s4-0) 3))
             (a1-1 (-> s5-0 v1-3))
             )
        (set! (-> arg1 user1-int16) (the-as uint (+ v1-3 -3)))
        (if (nonzero? a1-1)
            (particle-adgif-callback (-> arg1 adgif) (the-as texture-id a1-1))
            )
        )
      )
    )
  0
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod get-field-spec-by-id ((this sparticle-launcher) (arg0 sp-field-id))
  "Look up a field's init spec by ID number."
  (let ((v1-0 0))
    (until #f
      (let ((a2-2 (-> this init-specs v1-0 field)))
        (cond
          ((= a2-2 arg0)
           (return (-> this init-specs v1-0))
           )
          ((or (< (the-as uint arg0) (the-as uint a2-2)) (= a2-2 (sp-field-id spt-end)))
           (return (the-as sp-field-init-spec #f))
           )
          (else
            (+! v1-0 1)
            )
          )
        )
      )
    )
  (the-as sp-field-init-spec #f)
  )

(defmethod setup-special-textures ((this sparticle-launcher) (arg0 string))
  "Set the particle's texture to the texture with the given name, and convert userdata strings to textures."
  (let ((s5-0 (get-field-spec-by-id this (sp-field-id spt-texture)))
        (v1-1 (lookup-texture-id-by-name arg0 (the-as string #f)))
        )
    (if s5-0
        (set! (-> s5-0 initial-valuef) (the-as float v1-1))
        )
    )
  (let ((v1-3 (get-field-spec-by-id this (sp-field-id spt-userdata))))
    (when (and v1-3 (= (-> v1-3 flags) (sp-flag object)))
      (let ((gp-1 (the-as (array int32) (-> v1-3 initial-valuef))))
        (when (and (= (logand (the-as int gp-1) 7) 4) (type? gp-1 array) (logtest? (-> gp-1 1) 128))
          (set! (-> gp-1 0) (/ (-> gp-1 0) 8))
          (set! (-> gp-1 1) (/ (logand (-> gp-1 1) 8) 8))
          (set! (-> gp-1 2) (/ (-> gp-1 2) 8))
          (set! (-> gp-1 content-type) int32)
          (dotimes (s5-1 (+ (-> gp-1 length) -3))
            (set! (-> gp-1 (+ s5-1 3))
                  (the-as int (lookup-texture-id-by-name (the-as string (-> gp-1 (+ s5-1 3))) (the-as string #f)))
                  )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch degrees vs none.
(defun rot-to-particle ((arg0 degrees) (arg1 sprite-vec-data-2d) (arg2 matrix))
  (logand! (-> arg1 flag) -49)
  (let ((v1-4 (the int (* 0.000061035156 (+ 32768.0 arg0)))))
    (if (or (zero? v1-4) (= v1-4 3))
        (logior! (-> arg1 flag) 32)
        )
    )
  (set! (-> arg1 flag-rot-sy z) arg0)
  (none)
  )

(defun birth-func-flip-based-on-scale ((arg0 sparticle-system)
                              (arg1 sparticle-cpuinfo)
                              (arg2 sprite-vec-data-3d)
                              (arg3 sparticle-launcher)
                              (arg4 sparticle-launch-state)
                              )
  (when (< (-> arg2 x-y-z-sx w) 0.0)
    (set! (-> arg2 qx-qy-qz-sy x) (the-as float (logior (the-as int (-> arg2 qx-qy-qz-sy x)) 16)))
    (set! (-> arg2 x-y-z-sx w) (* -1.0 (-> arg2 x-y-z-sx w)))
    )
  (when (< (-> arg2 qx-qy-qz-sy w) 0.0)
    (set! (-> arg2 qx-qy-qz-sy x) (the-as float (logior (the-as int (-> arg2 qx-qy-qz-sy x)) 32)))
    (set! (-> arg2 qx-qy-qz-sy w) (* -1.0 (-> arg2 qx-qy-qz-sy w)))
    )
  0
  (none)
  )

(defun sparticle-2d-spline-align ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-2d) (arg3 object))
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (set! (-> s3-0 x) (-> arg1 vel-sxvel x))
    (set! (-> s3-0 y) (-> arg1 vel-sxvel y))
    (set! (-> s3-0 z) (-> arg1 vel-sxvel z))
    (set! (-> s3-0 w) 1.0)
    (let ((f30-0 (-> arg2 flag-rot-sy z)))
      (vector-normalize! s3-0 1.0)
      (let ((s5-0 deg-seek)
            (s4-0 f30-0)
            )
        0.0
        (let ((a0-2 (-> (math-camera-matrix) fvec)))
          0.0
          (let ((v1-1 (new 'stack-no-clear 'vector)))
            (let ((f0-7 (vector-dot a0-2 s3-0)))
              (vector-float*! v1-1 a0-2 f0-7)
              )
            (vector-! s3-0 s3-0 v1-1)
            )
          )
        (let ((a2-2 (matrix-transpose! (new 'stack-no-clear 'matrix) (math-camera-matrix))))
          (vector-matrix*! s3-0 s3-0 a2-2)
          )
        (let* ((a1-11 (the float (sar (shl (the int (atan (-> s3-0 y) (* -1.0 (-> s3-0 x)))) 48) 48)))
               (a2-3 (* 65536.0 (seconds-per-frame)))
               (f0-17 (s5-0 s4-0 a1-11 a2-3))
               )
          (rot-to-particle f0-17 arg2 (the-as matrix a2-3))
          )
        )
      )
    )
  0
  (none)
  )

(defun sparticle-2d-spline-align-instant ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-2d))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 x) (-> arg1 vel-sxvel x))
    (set! (-> s5-0 y) (-> arg1 vel-sxvel y))
    (set! (-> s5-0 z) (-> arg1 vel-sxvel z))
    (set! (-> s5-0 w) 1.0)
    (-> arg2 flag-rot-sy z)
    (vector-normalize! s5-0 1.0)
    0.0
    (let ((a0-2 (-> (math-camera-matrix) fvec)))
      0.0
      (let ((v1-1 (new 'stack-no-clear 'vector)))
        (let ((f0-8 (vector-dot a0-2 s5-0)))
          (vector-float*! v1-1 a0-2 f0-8)
          )
        (vector-! s5-0 s5-0 v1-1)
        )
      )
    (let ((a2-2 (matrix-transpose! (new 'stack-no-clear 'matrix) (math-camera-matrix))))
      (vector-matrix*! s5-0 s5-0 a2-2)
      (let ((f0-16 (the float (sar (shl (the int (atan (-> s5-0 y) (* -1.0 (-> s5-0 x)))) 48) 48))))
        (rot-to-particle f0-16 arg2 a2-2)
        )
      )
    )
  0
  (none)
  )

(defun birth-func-inherit-size ((arg0 sparticle-system)
                       (arg1 sparticle-cpuinfo)
                       (arg2 sprite-vec-data-3d)
                       (arg3 sparticle-launcher)
                       (arg4 sparticle-launch-state)
                       )
  (let ((v1-1 (-> arg4 sprite sprite)))
    (set! (-> arg2 x-y-z-sx w) (* (-> v1-1 x-y-z-sx w) (-> arg2 x-y-z-sx w)))
    (set! (-> arg2 qx-qy-qz-sy w) (* (-> v1-1 flag-rot-sy w) (-> arg2 qx-qy-qz-sy w)))
    )
  0
  (none)
  )

(defun birth-func-texture-group-2d ((arg0 object) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo) (arg3 object) (arg4 object))
  (birth-func-texture-group (the-as int arg0) arg1 arg2)
  0
  (none)
  )

(defun birth-func-set-vel-2d ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((v1-0 *particle-vel*))
    (set! (-> arg1 vel-sxvel x) (-> v1-0 x))
    (set! (-> arg1 vel-sxvel y) (-> v1-0 y))
    (set! (-> arg1 vel-sxvel z) (-> v1-0 z))
    )
  0
  (none)
  )

(defun sparticle-3d-rotate-xz-to-camera ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-3d))
  (local-vars (v1-4 float) (v1-5 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (new 'stack-no-clear 'vector)
    (-> arg1 key proc)
    (let ((a0-1 (math-camera-matrix))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 quad) (-> a0-1 rvec quad))
      (set! (-> s5-0 y) 0.0)
      (vector-normalize! s5-0 1.0)
      (let ((a1-3 (matrix-fr-compose (new 'stack-no-clear 'matrix) s5-0 *up-vector*))
            (s5-1 (new 'stack-no-clear 'quaternion))
            )
        (matrix->quaternion s5-1 a1-3)
        (cond
          ((< (-> s5-1 w) 0.0)
           (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
           (.lvf vf2 (&-> s5-1 quad))
           (.sub.vf vf1 vf0 vf2 :mask #b111)
           (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
           (.mov v1-4 vf1)
           )
          (else
            (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
            (.lvf vf2 (&-> s5-1 quad))
            (.add.vf vf1 vf0 vf2 :mask #b111)
            (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
            (.mov v1-5 vf1)
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod init-with-vec! ((this sparticle-subsampler) (arg0 vector))
  (let ((f30-0 (-> this spt-num)))
    (when (not (-> this inited?))
      (set! (-> this spawn-mat trans quad) (-> arg0 quad))
      (set! (-> this inited?) #t)
      (set! f30-0 0.000000000000000000000000000000000000000000001)
      )
    (set! (-> this sp-launcher birthaccum) 0.0)
    (let ((f28-0 (/ 1.0 f30-0)))
      0.0
      (let ((s4-0 (new 'stack-no-clear 'matrix)))
        (let* ((a2-0 s4-0)
               (a3-0 (-> this spawn-mat))
               (v1-8 (-> a3-0 rvec quad))
               (a0-3 (-> a3-0 uvec quad))
               (a1-1 (-> a3-0 fvec quad))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> a2-0 rvec quad) v1-8)
          (set! (-> a2-0 uvec quad) a0-3)
          (set! (-> a2-0 fvec quad) a1-1)
          (set! (-> a2-0 trans quad) a3-1)
          )
        (dotimes (s3-0 (the int f30-0))
          (let ((f0-5 (* f28-0 (the float s3-0))))
            (vector-lerp! (-> s4-0 trans) arg0 (-> this spawn-mat trans) f0-5)
            )
          (launch-particles :system (-> this sp-system) (-> this sp-launcher) s4-0 :origin-is-matrix #t)
          )
        )
      )
    )
  (let ((v0-2 (-> this spawn-mat trans)))
    (set! (-> v0-2 quad) (-> arg0 quad))
    v0-2
    )
  )

(defmethod init-with-mat! ((this sparticle-subsampler) (arg0 matrix))
  (when (not (-> this inited?))
    (let* ((a2-0 (-> this spawn-mat))
           (a3-0 arg0)
           (v1-2 (-> a3-0 rvec quad))
           (a0-1 (-> a3-0 uvec quad))
           (a1-1 (-> a3-0 fvec quad))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> a2-0 rvec quad) v1-2)
      (set! (-> a2-0 uvec quad) a0-1)
      (set! (-> a2-0 fvec quad) a1-1)
      (set! (-> a2-0 trans quad) a3-1)
      )
    (set! (-> this inited?) #t)
    )
  (set! (-> this sp-launcher birthaccum) 0.0)
  (let ((f30-0 (/ 1.0 (-> this spt-num))))
    0.0
    (let ((s4-0 (new 'stack-no-clear 'matrix)))
      (let* ((a2-1 s4-0)
             (a3-2 arg0)
             (v1-6 (-> a3-2 rvec quad))
             (a0-2 (-> a3-2 uvec quad))
             (a1-2 (-> a3-2 fvec quad))
             (a3-3 (-> a3-2 trans quad))
             )
        (set! (-> a2-1 rvec quad) v1-6)
        (set! (-> a2-1 uvec quad) a0-2)
        (set! (-> a2-1 fvec quad) a1-2)
        (set! (-> a2-1 trans quad) a3-3)
        )
      (dotimes (s3-0 (the int (-> this spt-num)))
        (let ((f0-5 (* f30-0 (the float s3-0))))
          (vector-lerp! (-> s4-0 trans) (-> arg0 trans) (-> this spawn-mat trans) f0-5)
          )
        (launch-particles :system (-> this sp-system) (-> this sp-launcher) s4-0 :origin-is-matrix #t)
        )
      )
    )
  (let ((v0-2 (-> this spawn-mat)))
    (let ((v1-10 (-> arg0 rvec quad))
          (a0-5 (-> arg0 uvec quad))
          (a1-5 (-> arg0 fvec quad))
          (a2-4 (-> arg0 trans quad))
          )
      (set! (-> v0-2 rvec quad) v1-10)
      (set! (-> v0-2 uvec quad) a0-5)
      (set! (-> v0-2 fvec quad) a1-5)
      (set! (-> v0-2 trans quad) a2-4)
      )
    v0-2
    )
  )

(defun spt-func-relative-pos ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-3d))
  (local-vars
    (sv-256 vector)
    (sv-260 vector)
    (sv-264 vector)
    (sv-268 matrix)
    (sv-272 matrix)
    (sv-276 matrix)
    (sv-280 matrix)
    (sv-284 matrix)
    )
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 x) (-> arg2 x-y-z-sx x))
    (set! (-> v1-0 y) (-> arg2 x-y-z-sx y))
    (set! (-> v1-0 z) (-> arg2 x-y-z-sx z))
    (set! (-> v1-0 w) 1.0)
    (set! sv-256 v1-0)
    )
  (let ((v1-1 (new 'stack-no-clear 'vector)))
    (set! (-> v1-1 x) (-> arg1 vel-sxvel x))
    (set! (-> v1-1 y) (-> arg1 vel-sxvel y))
    (set! (-> v1-1 z) (-> arg1 vel-sxvel z))
    (set! (-> v1-1 w) 1.0)
    (set! sv-260 v1-1)
    )
  (let ((v1-2 (new 'stack-no-clear 'vector)))
    (set! (-> v1-2 x) (-> arg1 acc x))
    (set! (-> v1-2 y) (-> arg1 acc y))
    (set! (-> v1-2 z) (-> arg1 acc z))
    (set! (-> v1-2 w) 1.0)
    (set! sv-264 v1-2)
    )
  (set! sv-268 (-> arg1 key local-space-binding mat-prev))
  (set! sv-272 (-> arg1 key local-space-binding mat-new))
  (set! sv-276 (new 'stack-no-clear 'matrix))
  (set! sv-280 (new 'stack-no-clear 'matrix))
  (set! sv-284 (new 'stack-no-clear 'matrix))
  (let* ((a2-1 sv-280)
         (a3-0 sv-268)
         (v1-12 (-> a3-0 rvec quad))
         (a0-4 (-> a3-0 uvec quad))
         (a1-1 (-> a3-0 fvec quad))
         (a3-1 (-> a3-0 trans quad))
         )
    (set! (-> a2-1 rvec quad) v1-12)
    (set! (-> a2-1 uvec quad) a0-4)
    (set! (-> a2-1 fvec quad) a1-1)
    (set! (-> a2-1 trans quad) a3-1)
    )
  (let* ((a2-2 sv-284)
         (a3-2 sv-272)
         (v1-13 (-> a3-2 rvec quad))
         (a0-5 (-> a3-2 uvec quad))
         (a1-2 (-> a3-2 fvec quad))
         (a3-3 (-> a3-2 trans quad))
         )
    (set! (-> a2-2 rvec quad) v1-13)
    (set! (-> a2-2 uvec quad) a0-5)
    (set! (-> a2-2 fvec quad) a1-2)
    (set! (-> a2-2 trans quad) a3-3)
    )
  (dotimes (s4-0 3)
    (vector-normalize! (the-as vector (&-> sv-280 quad s4-0)) 1.0)
    (vector-normalize! (the-as vector (&-> sv-284 quad s4-0)) 1.0)
    )
  (set! (-> sv-256 w) 1.0)
  (set! (-> sv-260 w) 0.0)
  (set! (-> sv-264 w) 0.0)
  (let ((a1-6 (matrix-inverse-of-rot-trans! (new 'stack-no-clear 'matrix) sv-280)))
    (matrix*! sv-276 a1-6 sv-284)
    )
  (vector-matrix*! sv-256 sv-256 sv-276)
  (set! (-> arg2 x-y-z-sx x) (-> sv-256 x))
  (set! (-> arg2 x-y-z-sx y) (-> sv-256 y))
  (set! (-> arg2 x-y-z-sx z) (-> sv-256 z))
  (-> arg2 x-y-z-sx)
  (vector-matrix*! sv-260 sv-260 sv-276)
  (set! (-> arg1 vel-sxvel x) (-> sv-260 x))
  (set! (-> arg1 vel-sxvel y) (-> sv-260 y))
  (set! (-> arg1 vel-sxvel z) (-> sv-260 z))
  (-> arg1 vel-sxvel)
  (vector-matrix*! sv-264 sv-264 sv-276)
  (set! (-> arg1 acc x) (-> sv-264 x))
  (set! (-> arg1 acc y) (-> sv-264 y))
  (set! (-> arg1 acc z) (-> sv-264 z))
  (-> arg1 acc)
  0
  (none)
  )

(defun spt-func-turn-to-vel-radial ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sprite-vec-data-3d))
  (local-vars (v1-5 float) (v1-6 float))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (new 'stack-no-clear 'vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg1 vel-sxvel quad))
      (let ((s3-0 (-> arg1 key proc)))
        (vector-normalize! s5-0 1.0)
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (v1-4 (new 'stack-no-clear 'vector))
              )
          (set! (-> v1-4 x) (-> arg2 x-y-z-sx x))
          (set! (-> v1-4 y) (-> arg2 x-y-z-sx y))
          (set! (-> v1-4 z) (-> arg2 x-y-z-sx z))
          (set! (-> v1-4 w) 1.0)
          (let ((s4-1 (vector-! s4-0 v1-4 (-> s3-0 root trans)))
                (s3-1 (new 'stack-no-clear 'matrix))
                )
            (set! (-> s4-1 y) 0.0)
            (vector-rotate-around-y! s4-1 s4-1 16384.0)
            (vector-normalize! s4-1 1.0)
            (matrix-f-r-compose s3-1 s5-0 s4-1)
            (let ((s5-1 (new 'stack-no-clear 'quaternion)))
              (matrix->quaternion s5-1 s3-1)
              (cond
                ((< (-> s5-1 w) 0.0)
                 (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
                 (.lvf vf2 (&-> s5-1 quad))
                 (.sub.vf vf1 vf0 vf2 :mask #b111)
                 (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
                 (.mov v1-5 vf1)
                 )
                (else
                  (.lvf vf1 (&-> arg2 qx-qy-qz-sy quad))
                  (.lvf vf2 (&-> s5-1 quad))
                  (.add.vf vf1 vf0 vf2 :mask #b111)
                  (.svf (&-> arg2 qx-qy-qz-sy quad) vf1)
                  (.mov v1-6 vf1)
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )
