;;-*-Lisp-*-
(in-package goal)

;; name: mood-funcs.gc
;; name in dgo: mood-funcs
;; dgos: GAME

;; DECOMP BEGINS

(defbehavior update-mood-default time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  0
  (none)
  )

(defun update-mood-copy-parent ((arg0 mood-context) (arg1 object) (arg2 int))
  (let* ((v1-3 (-> *level* level arg2))
         (a1-3 (-> v1-3 info memory-mode))
         )
    (when (or (or (= a1-3 (level-memory-mode borrow))
                  (= a1-3 (level-memory-mode borrow0))
                  (= a1-3 (level-memory-mode borrow1))
                  (= a1-3 (level-memory-mode borrow2))
                  (= a1-3 (level-memory-mode borrow3))
                  (= a1-3 (level-memory-mode borrow4))
                  (= a1-3 (level-memory-mode micro))
                  (= a1-3 (level-memory-mode borrow-city-small))
                  )
              (-> v1-3 borrow-from-level)
              )
      (let ((v1-4 (-> v1-3 borrow-from-level)))
        (if (and v1-4 (= (-> v1-4 status) 'active))
            (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-4 mood-context)) 1968)
            )
        )
      )
    )
  0
  (none)
  )

(defun get-sphere-interp ((arg0 sphere) (arg1 vector) (arg2 float) (arg3 float))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    0.0
    (set! (-> v1-0 quad) (-> arg0 quad))
    (vector-! v1-0 arg1 v1-0)
    (let ((f1-0 (vector-length v1-0)))
      (/ (fmax 0.0 (fmin (- f1-0 arg2) arg3)) arg3)
      )
    )
  )

(deftype ctywide-states (structure)
  ((light  light-state   :inline)
   (flame  flames-state  :inline)
   )
  )


(defbehavior update-mood-ctywide time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    (update-mood-flames arg0 6 1 8 1.0 0.000390625 1.5)
    )
  0
  (none)
  )

(defbehavior update-mood-copy-ctywide time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((v1-1 (level-get *level* 'ctywide)))
    (cond
      ((and v1-1 (= (-> v1-1 status) 'active))
       (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
       )
      (else
        (update-mood-ctywide arg0 arg1 arg2)
        (if (or (>= arg1 18.0) (>= 6.0 arg1))
            (set! (-> arg0 times 5 w) 1.0)
            )
        )
      )
    )
  0
  (none)
  )

(deftype ctysluma-states (structure)
  ((light    light-state   :inline)
   (flame    flames-state  :inline)
   (spec-0   sp-field-init-spec)
   (spec-1   sp-field-init-spec)
   (flicker  float)
   )
  )


;; WARN: Return type mismatch sp-field-init-spec vs float.
(defun init-mood-ctysluma ((arg0 mood-context))
  (let ((gp-0 (-> arg0 state)))
    (let ((a0-1 (-> *part-id-table* 2)))
      (set! (-> gp-0 4) (the-as uint 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 4) (the-as uint (get-field-spec-by-id a0-1 (sp-field-id spt-a))))
          )
      )
    (let ((a0-2 (-> *part-id-table* 3)))
      (set! (-> gp-0 5) (the-as uint 0))
      (the-as float (when (nonzero? a0-2)
                      (let ((v0-1 (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
                        (set! (-> gp-0 5) (the-as uint v0-1))
                        v0-1
                        )
                      )
              )
      )
    )
  )

(defbehavior update-mood-ctysluma time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (!= arg2 -1)
             (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as ctysluma-states (-> arg0 state))))
      (update-mood-flames arg0 6 1 8 1.0 0.000390625 1.5)
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> s5-1 spec-0))
          (set! (-> s5-1 spec-0 initial-valuef) (* 32.0 (-> s5-1 light fade)))
          )
      (if (nonzero? (-> s5-1 spec-1))
          (set! (-> s5-1 spec-1 initial-valuef) (* 8.0 (-> s5-1 light fade)))
          )
      (set! (-> arg0 times 7 w) (-> s5-1 flicker))
      (if (not (paused?))
          (set! (-> s5-1 flicker) (rand-vu-float-range 0.8 1.0))
          )
      )
    )
  0
  (none)
  )

(deftype ctyslumb-states (structure)
  ((light    light-state  :inline)
   (spec-0   sp-field-init-spec)
   (spec-1   sp-field-init-spec)
   (flicker  float)
   )
  )


;; WARN: Return type mismatch sp-field-init-spec vs uint.
(defun init-mood-ctyslumb ((arg0 mood-context))
  (let ((gp-0 (-> arg0 state)))
    (let ((a0-1 (-> *part-id-table* 4)))
      (set! (-> gp-0 2) (the-as uint 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 2) (the-as uint (get-field-spec-by-id a0-1 (sp-field-id spt-a))))
          )
      )
    (let ((a0-2 (-> *part-id-table* 5)))
      (set! (-> gp-0 3) (the-as uint 0))
      (the-as uint (when (nonzero? a0-2)
                     (let ((v0-1 (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
                       (set! (-> gp-0 3) (the-as uint v0-1))
                       v0-1
                       )
                     )
              )
      )
    )
  )

(defbehavior update-mood-ctyslumb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as object (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> (the-as ctyslumb-states s5-1) spec-0))
          (set! (-> (the-as ctyslumb-states s5-1) spec-0 initial-valuef)
                (* 32.0 (-> (the-as ctyslumb-states s5-1) light fade))
                )
          )
      (if (nonzero? (-> (the-as ctyslumb-states s5-1) spec-1))
          (set! (-> (the-as ctyslumb-states s5-1) spec-1 initial-valuef)
                (* 8.0 (-> (the-as ctyslumb-states s5-1) light fade))
                )
          )
      (set! (-> arg0 times 6 w) 1.0)
      (set! (-> arg0 times 7 w) (-> (the-as ctyslumb-states s5-1) flicker))
      (if (not (paused?))
          (set! (-> (the-as ctyslumb-states s5-1) flicker) (rand-vu-float-range 0.8 1.0))
          )
      )
    )
  0
  (none)
  )

(deftype ctyslumc-states (structure)
  ((light    light-state  :inline)
   (spec-0   sp-field-init-spec)
   (spec-1   sp-field-init-spec)
   (flicker  float)
   )
  )


;; WARN: Return type mismatch sp-field-init-spec vs none.
(defun init-mood-ctyslumc ((arg0 mood-context))
  (let ((gp-0 (-> arg0 state)))
    (let ((a0-1 (-> *part-id-table* 6)))
      (set! (-> gp-0 2) (the-as uint 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 2) (the-as uint (get-field-spec-by-id a0-1 (sp-field-id spt-a))))
          )
      )
    (let ((a0-2 (-> *part-id-table* 7)))
      (set! (-> gp-0 3) (the-as uint 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 3) (the-as uint (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
          )
      )
    )
  (none)
  )

(defbehavior update-mood-ctyslumc time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as object (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> (the-as ctyslumc-states s5-1) spec-0))
          (set! (-> (the-as ctyslumc-states s5-1) spec-0 initial-valuef)
                (* 32.0 (-> (the-as ctyslumc-states s5-1) light fade))
                )
          )
      (if (nonzero? (-> (the-as ctyslumc-states s5-1) spec-1))
          (set! (-> (the-as ctyslumc-states s5-1) spec-1 initial-valuef)
                (* 8.0 (-> (the-as ctyslumc-states s5-1) light fade))
                )
          )
      (set! (-> arg0 times 6 w) 1.0)
      (set! (-> arg0 times 7 w) (-> (the-as ctyslumc-states s5-1) flicker))
      (if (not (paused?))
          (set! (-> (the-as ctyslumc-states s5-1) flicker) (rand-vu-float-range 0.8 1.0))
          )
      )
    )
  0
  (none)
  )

(deftype ctygenb-states (structure)
  ((light         light-state    :inline)
   (flame         flames-state   :inline)
   (flicker       flicker-state  :inline)
   (spec-0        sp-field-init-spec)
   (spec-1        sp-field-init-spec)
   (spec-2        sp-field-init-spec)
   (spec-3        sp-field-init-spec)
   (next-flicker  float)
   )
  )


;; WARN: Return type mismatch sp-field-init-spec vs object.
(defun init-mood-ctygenb ((arg0 mood-context))
  (let ((gp-0 (-> arg0 state)))
    (let ((a0-1 (-> *part-id-table* 8)))
      (set! (-> gp-0 5) (the-as uint 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 5) (the-as uint (get-field-spec-by-id a0-1 (sp-field-id spt-a))))
          )
      )
    (let ((a0-2 (-> *part-id-table* 9)))
      (set! (-> gp-0 6) (the-as uint 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 6) (the-as uint (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
          )
      )
    (let ((a0-3 (-> *part-id-table* 10)))
      (set! (-> gp-0 7) (the-as uint 0))
      (if (nonzero? a0-3)
          (set! (-> gp-0 7) (the-as uint (get-field-spec-by-id a0-3 (sp-field-id spt-a))))
          )
      )
    (let ((a0-4 (-> *part-id-table* 11)))
      (set! (-> gp-0 8) (the-as uint 0))
      (when (nonzero? a0-4)
        (let ((v0-3 (get-field-spec-by-id a0-4 (sp-field-id spt-a))))
          (set! (-> gp-0 8) (the-as uint v0-3))
          v0-3
          )
        )
      )
    )
  )

(defbehavior update-mood-ctygenb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (!= arg2 -1)
             (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as object (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (update-mood-flames arg0 6 1 8 1.0 0.000390625 1.5)
      (when (or (>= arg1 18.0) (>= 6.0 arg1))
        (update-mood-flicker arg0 7 15)
        (let ((f1-2 (-> (the-as ctygenb-states gp-1) next-flicker))
              (f0-2 (-> arg0 times 7 w))
              )
          (set! (-> arg0 times 7 w) f1-2)
          (if (nonzero? (-> (the-as ctygenb-states gp-1) spec-0))
              (set! (-> (the-as ctygenb-states gp-1) spec-0 initial-valuef) (* 40.0 f0-2))
              )
          (if (nonzero? (-> (the-as ctygenb-states gp-1) spec-1))
              (set! (-> (the-as ctygenb-states gp-1) spec-1 initial-valuef) (* 20.0 f0-2))
              )
          (if (nonzero? (-> (the-as ctygenb-states gp-1) spec-2))
              (set! (-> (the-as ctygenb-states gp-1) spec-2 initial-valuef) (* 20.0 f0-2))
              )
          (if (nonzero? (-> (the-as ctygenb-states gp-1) spec-3))
              (set! (-> (the-as ctygenb-states gp-1) spec-3 initial-valuef) (* 8.0 f0-2))
              )
          (set! (-> (the-as ctygenb-states gp-1) next-flicker) f0-2)
          )
        )
      )
    )
  0
  (none)
  )

(define *mhcity-mood-fog-table*
  (new 'static 'mood-fog-table :data (new 'static 'inline-array mood-fog 8
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 171.4687 :y 155.0 :z 58.125 :w 128.0)
                                         :fog-dists (new 'static 'vector :y 819200.0 :z 240.0 :w 130.0)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 171.4687 :y 155.0 :z 58.125 :w 128.0)
                                         :fog-dists (new 'static 'vector :y 819200.0 :z 240.0 :w 130.0)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 171.4687 :y 155.0 :z 58.125 :w 128.0)
                                         :fog-dists (new 'static 'vector :y 819200.0 :z 240.0 :w 130.0)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 171.4687 :y 155.0 :z 58.125 :w 128.0)
                                         :fog-dists (new 'static 'vector :y 819200.0 :z 240.0 :w 130.0)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 171.4687 :y 155.0 :z 58.125 :w 128.0)
                                         :fog-dists (new 'static 'vector :y 819200.0 :z 240.0 :w 130.0)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 180.0 :y 179.0 :z 40.0 :w 128.0)
                                         :fog-dists (new 'static 'vector :x 40960.0 :y 819200.0 :z 240.0 :w 165.5)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 180.0 :y 159.0 :z 50.0 :w 128.0)
                                         :fog-dists (new 'static 'vector :x 40960.0 :y 819200.0 :z 240.0 :w 175.5)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       (new 'static 'mood-fog
                                         :fog-color (new 'static 'vector :x 180.0 :y 179.0 :z 40.0 :w 128.0)
                                         :fog-dists (new 'static 'vector :x 40960.0 :y 819200.0 :z 230.0 :w 165.5)
                                         :erase-color (new 'static 'vector :w 128.0)
                                         )
                                       )
                               )
  )

(defun overide-mhcity-fog ((arg0 mood-context) (arg1 float) (arg2 int))
  (when (not (-> *time-of-day-context* overide-enable))
    (let* ((f30-0 (vector-vector-distance (target-pos 0) (new 'static 'vector :x -1072496.6 :y -22159.36 :z 4246978.5)))
           (f0-0 (vector-vector-distance (target-pos 0) (new 'static 'vector :x -1118986.2 :y -30474.24 :z 3107348.5)))
           (f0-5 (fmin
                   (fmax 0.0 (fmin 1.0 (* 0.0000032552084 (+ -1228800.0 f30-0))))
                   (fmax 0.0 (fmin 1.0 (* 0.0000032552084 (+ -737280.0 f0-0))))
                   )
                 )
           )
      (overide-mood-fog arg0 arg1 (the-as int *mhcity-mood-fog-table*) f0-5)
      )
    )
  (none)
  )

(deftype mhcitya-states (structure)
  ((pulse  pulse-state  :inline)
   )
  )


;; WARN: Return type mismatch float vs object.
(defun init-mood-mhcitya ((arg0 mood-context))
  (let ((v1-0 (-> arg0 state)))
    (set! (-> v1-0 2) (the-as uint 1.0))
    (let ((f0-1 1.0))
      (set! (-> v1-0 1) (the-as uint f0-1))
      f0-1
      )
    )
  )

(defbehavior update-mood-mhcitya time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((s5-0 arg2))
    (copy-mood-exterior arg0)
    (overide-mhcity-fog arg0 arg1 arg2)
    (when (and (= (-> *level* level s5-0 status) 'active)
               (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
               )
      (-> arg0 state)
      (set! (-> arg0 times 5 w) 1.0)
      (update-mood-pulse arg0 6 0 0.75 0.25 (* 32768.0 (seconds-per-frame)) 0.0)
      (set! (-> arg0 times 7 w) 1.0)
      )
    )
  0
  (none)
  )

(deftype mhcityb-states (structure)
  ((pulse  pulse-state  :inline)
   )
  )


;; WARN: Return type mismatch float vs object.
(defun init-mood-mhcityb ((arg0 mood-context))
  (let ((v1-0 (-> arg0 state)))
    (set! (-> v1-0 2) (the-as uint 1.0))
    (let ((f0-1 1.0))
      (set! (-> v1-0 1) (the-as uint f0-1))
      f0-1
      )
    )
  )

(defbehavior update-mood-mhcityb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((s5-0 arg2))
    (copy-mood-exterior arg0)
    (overide-mhcity-fog arg0 arg1 arg2)
    (when (and (= (-> *level* level s5-0 status) 'active)
               (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
               )
      (-> arg0 state)
      (set! (-> arg0 times 5 w) 1.0)
      (update-mood-pulse arg0 6 0 0.75 0.25 (* 32768.0 (seconds-per-frame)) 0.0)
      (set! (-> arg0 times 7 w) 1.0)
      )
    )
  0
  (none)
  )

(defun calc-lmhcity-palettes ((arg0 mood-context))
  (let ((v1-3 (mod (-> *display* part-clock frame-counter) 4800)))
    (dotimes (a1-1 8)
      (let* ((a2-1 (* 600 a1-1))
             (a3-0 (+ a2-1 1200))
             )
        (cond
          ((= a1-1 7)
           (if (< v1-3 (mod a3-0 4800))
               (set! (-> arg0 times a1-1 w) (- 1.0 (* 0.0016666667 (the float v1-3))))
               )
           (if (< a2-1 v1-3)
               (set! (-> arg0 times a1-1 w) (* 0.0016666667 (the float (- v1-3 a2-1))))
               )
           )
          (else
            (when (and (< v1-3 a3-0) (< a2-1 v1-3))
              (let ((f0-5 (* 0.0016666667 (the float (- v1-3 a2-1)))))
                (if (< 1.0 f0-5)
                    (set! (-> arg0 times a1-1 w) (- 2.0 f0-5))
                    (set! (-> arg0 times a1-1 w) f0-5)
                    )
                )
              )
            )
          )
        )
      )
    )
  #f
  )

(defbehavior update-mood-lmhcitya time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (overide-mhcity-fog arg0 arg1 arg2)
  (if (< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
      (palette-select-special arg0)
      (calc-lmhcity-palettes arg0)
      )
  0
  (none)
  )

(defbehavior update-mood-lmhcityb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (overide-mhcity-fog arg0 arg1 arg2)
  (if (< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
      (palette-select-special arg0)
      (calc-lmhcity-palettes arg0)
      )
  0
  (none)
  )

(deftype ctyport-states (structure)
  ((light            light-state  :inline)
   (spec-0           sp-field-init-spec)
   (neon-min-bright  float)
   )
  )


(define *ctyport-level* (the-as level #f))

(defbehavior update-mood-ctyport time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((s4-0 arg2))
    (copy-mood-exterior arg0)
    (overide-mhcity-fog arg0 arg1 arg2)
    (when (and (!= s4-0 -1)
               (= (-> *level* level s4-0 status) 'active)
               (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
               )
      (-> arg0 state)
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) 1.0)
      (set! (-> arg0 times 7 w) 1.0)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defun reset-marquee-color! ()
  (set! *ctyport-level* (level-get *level* 'ctyport))
  (if *ctyport-level*
      (set-vector! (-> *ctyport-level* mood-context times 6) 0.0 0.0 0.0 1.0)
      )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defun add-marquee-color! ((arg0 float) (arg1 float) (arg2 float))
  (when *ctyport-level*
    (let ((v1-2 (-> *ctyport-level* mood-context)))
      (+! (-> v1-2 times 6 x) arg0)
      (+! (-> v1-2 times 6 y) arg1)
      (+! (-> v1-2 times 6 z) arg2)
      )
    )
  (none)
  )

(deftype ctymarka-states (structure)
  ((light  light-state  :inline)
   (blink  float)
   )
  )


(defbehavior update-mood-ctymarka time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (-> arg0 state)))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (the-as float (-> gp-1 2)))
      (set! (-> arg0 times 7 w) 0.75)
      (when (not (paused?))
        (let ((v1-11 (-> *display* part-clock frame-counter)))
          (if (< (* 0.2 (the float (mod v1-11 600))) 60.0)
              (set! (-> gp-1 2) (the-as uint 0.0))
              (set! (-> gp-1 2) (the-as uint 1.0))
              )
          )
        )
      )
    )
  0
  (none)
  )

(deftype mountain-states (structure)
  ((light0  light-state  :inline)
   (light1  light-state  :inline)
   (spec-0  sp-field-init-spec)
   (spec-1  sp-field-init-spec)
   (spec-2  sp-field-init-spec)
   (spec-3  sp-field-init-spec)
   (spec-4  sp-field-init-spec)
   (spec-5  sp-field-init-spec)
   (spec-6  sp-field-init-spec)
   )
  )


;; WARN: Return type mismatch sp-field-init-spec vs uint.
(defun init-mood-mountain ((arg0 mood-context))
  (let ((gp-0 (-> arg0 state)))
    (let ((a0-1 (-> *part-id-table* 12)))
      (set! (-> gp-0 4) (the-as uint 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 4) (the-as uint (get-field-spec-by-id a0-1 (sp-field-id spt-a))))
          )
      )
    (let ((a0-2 (-> *part-id-table* 13)))
      (set! (-> gp-0 5) (the-as uint 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 5) (the-as uint (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
          )
      )
    (let ((a0-3 (-> *part-id-table* 14)))
      (set! (-> gp-0 6) (the-as uint 0))
      (if (nonzero? a0-3)
          (set! (-> gp-0 6) (the-as uint (get-field-spec-by-id a0-3 (sp-field-id spt-a))))
          )
      )
    (let ((a0-4 (-> *part-id-table* 15)))
      (set! (-> gp-0 7) (the-as uint 0))
      (if (nonzero? a0-4)
          (set! (-> gp-0 7) (the-as uint (get-field-spec-by-id a0-4 (sp-field-id spt-a))))
          )
      )
    (let ((a0-5 (-> *part-id-table* 16)))
      (set! (-> gp-0 8) (the-as uint 0))
      (if (nonzero? a0-5)
          (set! (-> gp-0 8) (the-as uint (get-field-spec-by-id a0-5 (sp-field-id spt-a))))
          )
      )
    (let ((a0-6 (-> *part-id-table* 17)))
      (set! (-> gp-0 9) (the-as uint 0))
      (if (nonzero? a0-6)
          (set! (-> gp-0 9) (the-as uint (get-field-spec-by-id a0-6 (sp-field-id spt-a))))
          )
      )
    (let ((a0-7 (-> *part-id-table* 18)))
      (set! (-> gp-0 10) (the-as uint 0))
      (the-as uint (when (nonzero? a0-7)
                     (let ((v0-6 (get-field-spec-by-id a0-7 (sp-field-id spt-a))))
                       (set! (-> gp-0 10) (the-as uint v0-6))
                       v0-6
                       )
                     )
              )
      )
    )
  )

(defbehavior update-mood-mountain time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as object (-> arg0 state))))
      (update-mood-light arg0 5 0 0.875 0.25 2.0 0.0 1.0)
      (update-mood-light arg0 6 8 1.0 0.0 arg1 0.0 1.0)
      (set! (-> arg0 times 7 w) 1.0)
      (let* ((f0-1 (-> arg0 times 5 w))
             (f1-1 (* 24.0 f0-1))
             (f0-2 (* 20.0 f0-1))
             )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-0))
            (set! (-> (the-as mountain-states gp-1) spec-0 initial-valuef) f1-1)
            )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-1))
            (set! (-> (the-as mountain-states gp-1) spec-1 initial-valuef) f0-2)
            )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-2))
            (set! (-> (the-as mountain-states gp-1) spec-2 initial-valuef) f0-2)
            )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-3))
            (set! (-> (the-as mountain-states gp-1) spec-3 initial-valuef) f0-2)
            )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-4))
            (set! (-> (the-as mountain-states gp-1) spec-4 initial-valuef) f0-2)
            )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-5))
            (set! (-> (the-as mountain-states gp-1) spec-5 initial-valuef) f0-2)
            )
        (if (nonzero? (-> (the-as mountain-states gp-1) spec-6))
            (set! (-> (the-as mountain-states gp-1) spec-6 initial-valuef) f0-2)
            )
        )
      )
    )
  0
  (none)
  )

(deftype ctyinda-states (structure)
  ((light  light-state  :inline)
   )
  )


(defbehavior update-mood-ctyinda time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (set! (-> arg0 times 6 w) 1.0)
    (let ((f0-1 0.5))
      (let ((f1-0 1.0))
        (cond
          ((or (>= 6.0 arg1) (>= arg1 18.0))
           (set! f0-1 f1-0)
           )
          ((and (< 6.0 arg1) (< arg1 7.0))
           (+! f0-1 (* (- f1-0 f0-1) (- 7.0 arg1)))
           )
          ((and (< 17.0 arg1) (< arg1 18.0))
           (+! f0-1 (* (- f1-0 f0-1) (+ -17.0 arg1)))
           )
          )
        )
      (set! (-> arg0 times 7 w) f0-1)
      )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    )
  0
  (none)
  )

(deftype ctyindb-states (structure)
  ((light    light-state  :inline)
   (flicker  float)
   )
  )


(defbehavior update-mood-ctyindb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s4-1 (-> arg0 state)))
      (set! (-> arg0 times 6 w) 1.0)
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 7 w) (the-as float (-> s4-1 2)))
      (if (not (paused?))
          (set! (-> s4-1 2) (the-as uint (rand-vu-float-range 0.8 1.0)))
          )
      )
    )
  0
  (none)
  )

(deftype atoll-states (structure)
  ((light      light-state  :inline)
   (explosion  float)
   )
  )


(defun init-mood-atoll ((arg0 mood-context))
  (let ((v1-0 (-> arg0 state))
        (f0-0 0.0)
        )
    (set! (-> v1-0 2) (the-as uint f0-0))
    f0-0
    )
  )

(defbehavior update-mood-atoll time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s4-1 (the-as object (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 7 w) (-> (the-as atoll-states s4-1) explosion))
      (if (not (paused?))
          (seek! (-> (the-as atoll-states s4-1) explosion) 0.0 (* 2.0 (seconds-per-frame)))
          )
      )
    )
  0
  (none)
  )

(defun set-atoll-explosion! ((arg0 float))
  (let ((v1-1 (level-get *level* 'atoll)))
    (when v1-1
      (let ((v1-2 (-> v1-1 mood-context state))
            (f0-0 arg0)
            )
        (set! (-> v1-2 2) (the-as uint f0-0))
        f0-0
        )
      )
    )
  )

(defbehavior update-mood-atollext time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior-ambi arg0 #t)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (set-vector! (-> arg0 times 1) 1.0 1.0 1.0 1.0)
    (set! (-> arg0 times 2 w) 0.0)
    (set! (-> arg0 times 3 w) 0.0)
    (set! (-> arg0 times 4 w) 0.0)
    (set! (-> arg0 times 5 w) 0.0)
    (set! (-> arg0 times 6 w) 0.0)
    (set! (-> arg0 times 7 w) 0.0)
    )
  0
  (none)
  )
