;;-*-Lisp-*-
(in-package goal)

;; name: background.gc
;; name in dgo: background
;; dgos: GAME

(defun add-pc-tfrag3-data ((dma-buf dma-buffer) (lev level) (imm int))
  "Add PC-port specific tfrag data"
  (let ((packet (the-as dma-packet (-> dma-buf base))))
    (set! (-> packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc 25))
    (set! (-> packet vif0) (new 'static 'vif-tag))
    (set! (-> packet vif1) (new 'static 'vif-tag :cmd (vif-cmd pc-port) :imm imm))
    (set! (-> dma-buf base) (the pointer (&+ packet 16)))
    )

  ;; first 4 quadwords are planes, then itimes
  (let ((data-ptr (the-as (pointer uint128) (-> dma-buf base))))
    ;; the "use-camera-other" flag is set to "move" entire levels,
    ;; like the rotating city below in the throne room.
    (cond
      ((logtest? (-> lev info level-flags) (level-flags use-camera-other))
        (set! (-> data-ptr 0) (-> *math-camera* plane-other 0 quad))
        (set! (-> data-ptr 1) (-> *math-camera* plane-other 1 quad))
        (set! (-> data-ptr 2) (-> *math-camera* plane-other 2 quad))
        (set! (-> data-ptr 3) (-> *math-camera* plane-other 3 quad))
        (set! (-> data-ptr 4) (-> lev mood-context itimes 0 quad))
        (set! (-> data-ptr 5) (-> lev mood-context itimes 1 quad))
        (set! (-> data-ptr 6) (-> lev mood-context itimes 2 quad))
        (set! (-> data-ptr 7) (-> lev mood-context itimes 3 quad))
        (set! (-> data-ptr 8) (-> *math-camera* camera-temp-other vector 0 quad))
        (set! (-> data-ptr 9) (-> *math-camera* camera-temp-other vector 1 quad))
        (set! (-> data-ptr 10) (-> *math-camera* camera-temp-other vector 2 quad))
        (set! (-> data-ptr 11) (-> *math-camera* camera-temp-other vector 3 quad))
        (set! (-> data-ptr 12) (-> *math-camera* hvdf-off quad))
        (let ((vec (-> (the (inline-array vector) data-ptr) 13)))
          (set! (-> vec x) (-> *math-camera* pfog0))
          (set! (-> vec y) (-> *math-camera* fog-min))
          (set! (-> vec z) (-> *math-camera* fog-max))
          )
        (set! (-> data-ptr 14) (-> *math-camera* trans-other quad))

        (set! (-> data-ptr 15) (-> *math-camera* camera-rot-other vector 0 quad))
        (set! (-> data-ptr 16) (-> *math-camera* camera-rot-other vector 1 quad))
        (set! (-> data-ptr 17) (-> *math-camera* camera-rot-other vector 2 quad))
        (set! (-> data-ptr 18) (-> *math-camera* camera-rot-other vector 3 quad))

        (set! (-> data-ptr 19) (-> *math-camera* perspective vector 0 quad))
        (set! (-> data-ptr 20) (-> *math-camera* perspective vector 1 quad))
        (set! (-> data-ptr 21) (-> *math-camera* perspective vector 2 quad))
        (set! (-> data-ptr 22) (-> *math-camera* perspective vector 3 quad))

       )
      (else
        (set! (-> data-ptr 0) (-> *math-camera* plane 0 quad))
        (set! (-> data-ptr 1) (-> *math-camera* plane 1 quad))
        (set! (-> data-ptr 2) (-> *math-camera* plane 2 quad))
        (set! (-> data-ptr 3) (-> *math-camera* plane 3 quad))
        (set! (-> data-ptr 4) (-> lev mood-context itimes 0 quad))
        (set! (-> data-ptr 5) (-> lev mood-context itimes 1 quad))
        (set! (-> data-ptr 6) (-> lev mood-context itimes 2 quad))
        (set! (-> data-ptr 7) (-> lev mood-context itimes 3 quad))
        (set! (-> data-ptr 8) (-> *math-camera* camera-temp vector 0 quad))
        (set! (-> data-ptr 9) (-> *math-camera* camera-temp vector 1 quad))
        (set! (-> data-ptr 10) (-> *math-camera* camera-temp vector 2 quad))
        (set! (-> data-ptr 11) (-> *math-camera* camera-temp vector 3 quad))
        (set! (-> data-ptr 12) (-> *math-camera* hvdf-off quad))
        (let ((vec (-> (the (inline-array vector) data-ptr) 13)))
          (set! (-> vec x) (-> *math-camera* pfog0))
          (set! (-> vec y) (-> *math-camera* fog-min))
          (set! (-> vec z) (-> *math-camera* fog-max))
          )
        (set! (-> data-ptr 14) (-> *math-camera* trans quad))

        (set! (-> data-ptr 15) (-> *math-camera* camera-rot vector 0 quad))
        (set! (-> data-ptr 16) (-> *math-camera* camera-rot vector 1 quad))
        (set! (-> data-ptr 17) (-> *math-camera* camera-rot vector 2 quad))
        (set! (-> data-ptr 18) (-> *math-camera* camera-rot vector 3 quad))

        (set! (-> data-ptr 19) (-> *math-camera* perspective vector 0 quad))
        (set! (-> data-ptr 20) (-> *math-camera* perspective vector 1 quad))
        (set! (-> data-ptr 21) (-> *math-camera* perspective vector 2 quad))
        (set! (-> data-ptr 22) (-> *math-camera* perspective vector 3 quad))
        )
      )

    (copyn-charp<-string (the (pointer uint8) (&-> data-ptr 23)) (symbol->string (bsp-name lev)) 32)
    )
  (&+! (-> dma-buf base) (* 16 25))
  )

(defun pc-should-draw-hfrag ((lev level))
  (and lev
       (= (-> lev status) 'active)
       (nonzero? (-> lev bsp hfrag-drawable))
       (= (-> lev display?) 'display)
       )
  )

(defun pc-draw-hfrags ()
  "Generate DMA for all hfrag levels"
  (with-profiler 'hfrag *profile-hfrag-color*
    (with-dma-buffer-add-bucket ((dma-buf (-> *display* frames (-> *display* on-screen) global-buf))
                                 (bucket-id hfrag)
                                 )
      (dotimes (i (-> *level* draw-level-count))
        (let ((lev (-> *level* draw-level i)))
          (when (pc-should-draw-hfrag lev)
            (add-pc-tfrag3-data dma-buf lev i)
            )
          )
        )
      )
    )
  )

;; DECOMP BEGINS

(define *background-work* (new 'global 'background-work))

(define background-vu0-block (new 'static 'vu-function :length 59 :qlength 30))

(defun background-upload-vu0 ()
  "Upload VU0 functions for background. (believed unused?)"
  ;; (upload-vu0-program background-vu0-block (&-> *background-work* wait-to-vu0))
  0
  (none)
  )

(defun init-background ()
  "Reset lists of trees to draw for background rendering."
  (dotimes (v1-0 8)
    (set! (-> *background-work* tfrag-trees v1-0) #f)
    (set! (-> *background-work* tfrag-trans-trees v1-0) #f)
    (set! (-> *background-work* tfrag-water-trees v1-0) #f)
    )
  (set! (-> *background-work* tfrag-tree-count) 0)
  (set! (-> *background-work* tfrag-trans-tree-count) 0)
  (set! (-> *background-work* tfrag-water-tree-count) 0)
  (set! (-> *background-work* shrub-tree-count) 0)
  (set! (-> *background-work* tie-tree-count) 0)
  (set! (-> *background-work* wait-to-vu0) (the-as uint 0))
  0
  (none)
  )

(defun upload-vis-bits ((arg0 level) (arg1 level) (arg2 bsp-header))
  "Upload vis data to the scratchpad."
  (let ((v1-2 (/ (+ (-> arg2 visible-list-length) 15) 16)))
    (let ((a0-1 (-> arg0 vis-bits))
          (a1-1 (the-as (pointer uinteger) (-> arg2 all-visible-list)))
          ;; (a2-2 (the-as (pointer uint128) (+ #x3800 #x70000000)))
          (a2-2 (scratchpad-ptr uint128 :offset #x3800))
          )
      (b! (not *artist-flip-visible*) cfg-5 :delay (nop!))
      (nop!)
      (nop!)
      (label cfg-2)
      (let ((a3-2 (-> (the-as (pointer uint128) a0-1))))
        (&+! a0-1 16)
        (let ((t0-0 (-> (the-as (pointer uint128) a1-1) 0)))
          (set! a1-1 (&-> (the-as (pointer uint8) a1-1) 16))
          (nop!)
          (nop!)
          (let ((a3-3 (logxor a3-2 (the-as uint t0-0))))
            (+! v1-2 -1)
            (set! (-> a2-2 0) a3-3)
            )
          )
        )
      (set! a2-2 (&-> a2-2 1))
      (b! (> v1-2 0) cfg-2 :delay (nop!))
      0
      (b! #t cfg-8 :delay (nop!))
      (nop!)
      (label cfg-5)
      (nop!)
      (nop!)
      (label cfg-6)
      (let ((a1-2 (-> (the-as (pointer uint128) a0-1))))
        (&+! a0-1 16)
        (nop!)
        (+! v1-2 -1)
        (set! (-> a2-2 0) a1-2)
        )
      (set! a2-2 (&-> a2-2 1))
      )
    (b! (> v1-2 0) cfg-6 :delay (nop!))
    )
  0
  (label cfg-8)
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.
(defun set-background-regs! ((arg0 level))
  ;; not needed.
  (none)
  )

;; WARN: Return type mismatch plane vs none.
(defun set-tie-quard-planes! ((arg0 level))
  "Set up TIE work guard planes."
  (cond
    ((logtest? (-> arg0 info level-flags) (level-flags use-camera-other))
     (set! (-> *instance-tie-work* guard-plane 0 quad) (-> *math-camera* guard-plane-other 0 quad))
     (set! (-> *instance-tie-work* guard-plane 1 quad) (-> *math-camera* guard-plane-other 1 quad))
     (set! (-> *instance-tie-work* guard-plane 2 quad) (-> *math-camera* guard-plane-other 2 quad))
     (set! (-> *instance-tie-work* guard-plane 3 quad) (-> *math-camera* guard-plane-other 3 quad))
     )
    (else
      (set! (-> *instance-tie-work* guard-plane 0 quad) (-> *math-camera* guard-plane 0 quad))
      (set! (-> *instance-tie-work* guard-plane 1 quad) (-> *math-camera* guard-plane 1 quad))
      (set! (-> *instance-tie-work* guard-plane 2 quad) (-> *math-camera* guard-plane 2 quad))
      (set! (-> *instance-tie-work* guard-plane 3 quad) (-> *math-camera* guard-plane 3 quad))
      )
    )
  (none)
  )

;; WARN: Return type mismatch plane vs none.
(defun set-shrub-quard-planes! ((arg0 level))
  "Set shrub work guard planes."
  (cond
    ((logtest? (-> arg0 info level-flags) (level-flags use-camera-other))
     (set! (-> *instance-shrub-work* guard-plane 0 quad) (-> *math-camera* guard-plane-other 0 quad))
     (set! (-> *instance-shrub-work* guard-plane 1 quad) (-> *math-camera* guard-plane-other 1 quad))
     (set! (-> *instance-shrub-work* guard-plane 2 quad) (-> *math-camera* guard-plane-other 2 quad))
     (set! (-> *instance-shrub-work* guard-plane 3 quad) (-> *math-camera* guard-plane-other 3 quad))
     )
    (else
      (set! (-> *instance-shrub-work* guard-plane 0 quad) (-> *math-camera* guard-plane 0 quad))
      (set! (-> *instance-shrub-work* guard-plane 1 quad) (-> *math-camera* guard-plane 1 quad))
      (set! (-> *instance-shrub-work* guard-plane 2 quad) (-> *math-camera* guard-plane 2 quad))
      (set! (-> *instance-shrub-work* guard-plane 3 quad) (-> *math-camera* guard-plane 3 quad))
      )
    )
  (none)
  )

(defun set-subdivide-settings! ((arg0 level))
  "Set subdivide settings from the level."
  (if *artist-use-menu-subdiv*
      (update-subdivide-settings! *subdivide-settings* *math-camera* 11)
      (update-subdivide-settings! *subdivide-settings* *math-camera* (-> arg0 index))
      )
  (none)
  )

(defun add-pc-camera-data ((dma-buf dma-buffer))
  "Add PC-port specific camera data. used as fallback for collide mesh renderer.
   Same as add-pc-trag3-data but level-specific data is left undefined."
  (let ((packet (the-as dma-packet (-> dma-buf base))))
    (set! (-> packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc 25))
    (set! (-> packet vif0) (new 'static 'vif-tag))
    (set! (-> packet vif1) (new 'static 'vif-tag :cmd (vif-cmd pc-port)))
    (set! (-> dma-buf base) (the pointer (&+ packet 16)))
    )

  ;; first 4 quadwords are planes, then itimes
  (let ((data-ptr (the-as (pointer uint128) (-> dma-buf base))))
    ;; the "use-camera-other" flag is set to "move" entire levels,
    ;; like the rotating city below in the throne room.
    (set! (-> data-ptr 0) (-> *math-camera* plane 0 quad))
    (set! (-> data-ptr 1) (-> *math-camera* plane 1 quad))
    (set! (-> data-ptr 2) (-> *math-camera* plane 2 quad))
    (set! (-> data-ptr 3) (-> *math-camera* plane 3 quad))
    ;; (set! (-> data-ptr 4) (-> lev mood-context itimes 0 quad))
    ;; (set! (-> data-ptr 5) (-> lev mood-context itimes 1 quad))
    ;; (set! (-> data-ptr 6) (-> lev mood-context itimes 2 quad))
    ;; (set! (-> data-ptr 7) (-> lev mood-context itimes 3 quad))
    (set! (-> data-ptr 8) (-> *math-camera* camera-temp vector 0 quad))
    (set! (-> data-ptr 9) (-> *math-camera* camera-temp vector 1 quad))
    (set! (-> data-ptr 10) (-> *math-camera* camera-temp vector 2 quad))
    (set! (-> data-ptr 11) (-> *math-camera* camera-temp vector 3 quad))
    (set! (-> data-ptr 12) (-> *math-camera* hvdf-off quad))
    (let ((vec (-> (the (inline-array vector) data-ptr) 13)))
      (set! (-> vec x) (-> *math-camera* pfog0))
      (set! (-> vec y) (-> *math-camera* fog-min))
      (set! (-> vec z) (-> *math-camera* fog-max))
      )
    (set! (-> data-ptr 14) (-> *math-camera* trans quad))

    (set! (-> data-ptr 15) (-> *math-camera* camera-rot vector 0 quad))
    (set! (-> data-ptr 16) (-> *math-camera* camera-rot vector 1 quad))
    (set! (-> data-ptr 17) (-> *math-camera* camera-rot vector 2 quad))
    (set! (-> data-ptr 18) (-> *math-camera* camera-rot vector 3 quad))

    (set! (-> data-ptr 19) (-> *math-camera* perspective vector 0 quad))
    (set! (-> data-ptr 20) (-> *math-camera* perspective vector 1 quad))
    (set! (-> data-ptr 21) (-> *math-camera* perspective vector 2 quad))
    (set! (-> data-ptr 22) (-> *math-camera* perspective vector 3 quad))

    (charp<-string (the (pointer uint8) (&-> data-ptr 23)) (symbol->string #f))
    )
  (&+! (-> dma-buf base) (* 16 25))
  )

(defun add-pc-port-background-data ((dma-buf dma-buffer))
  "PC Port added"
  ;; loop over levels
  (dotimes (lev-idx (-> *level* length))
    (let ((lev (-> *level* draw-level lev-idx))
          (dma-start (-> dma-buf base)))
      (cond
        ((and lev (= (-> lev status) 'active))
         ;; the level is active.
         (let ((packet (the-as dma-packet (-> dma-buf base))))
           (set! (-> packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc 128))
           (set! (-> packet vif0) (the-as vif-tag *fog-color*))
           (set! (-> packet vif1) (new 'static 'vif-tag :cmd (vif-cmd pc-port)))
           (set! (-> dma-buf base) (the pointer (&+ packet 16)))
           )
         (quad-copy! (-> dma-buf base) (-> lev vis-bits) 128)
         (&+! (-> dma-buf base) (* 16 128))
         )
        (else
          (let ((packet (the-as dma-packet (-> dma-buf base))))
            (set! (-> packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc 1))
            (set! (-> packet vif0) (the-as vif-tag *fog-color*))
            (set! (-> packet vif1) (new 'static 'vif-tag :cmd (vif-cmd pc-port)))
            (set! (-> dma-buf base) (the pointer (&+ packet 16)))
            )
          (set! (-> (the (pointer uint128) (-> dma-buf base))) (the uint128 0))
          (&+! (-> dma-buf base) (* 16 1))
          )
        )


      (let ((a3-3 (-> dma-buf base)))
        (let ((v1-38 (the-as object (-> dma-buf base))))
          (set! (-> (the-as dma-packet v1-38) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
          (set! (-> (the-as dma-packet v1-38) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet v1-38) vif1) (new 'static 'vif-tag))
          (set! (-> dma-buf base) (&+ (the-as pointer v1-38) 16))
          )
        (dma-bucket-insert-tag (-> *display* frames (-> *display* on-screen) bucket-group)
                               (bucket-id bucket2)
                               dma-start
                               (the-as (pointer dma-tag) a3-3)
                               )
        )
      )
    )
  (let* ((dma-buff (-> *display* frames (-> *display* on-screen) global-buf))
         (dma-start (-> dma-buff base)))
    (add-pc-camera-data dma-buff)
    (let ((a3-22 (-> dma-buff base)))
      (let ((v1-57 (the-as object (-> dma-buff base))))
        (set! (-> (the-as dma-packet v1-57) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
        (set! (-> (the-as dma-packet v1-57) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet v1-57) vif1) (new 'static 'vif-tag))
        (set! (-> dma-buff base) (&+ (the-as pointer v1-57) 16))
        )
      (dma-bucket-insert-tag
        (-> *display* frames (-> *display* on-screen) bucket-group)
        (bucket-id bucket2)
        dma-start
        (the-as (pointer dma-tag) a3-22)
        )
      )
    )
  (the-as pointer 0)
  )

;; WARN: Function finish-background has a return type of none, but the expression builder found a return statement.
(defun finish-background ()
  "Run all renderers for background data added."

  (#when PC_PORT
    (add-pc-port-background-data
      (-> *display* frames (-> *display* on-screen) global-buf)
      )
    )

  (if (get-menu-mode *blit-displays-work*)
      (return #f)
      )
  (when (not (paused?))
    (flush-cache 0)
    (dotimes (gp-0 (-> *level* length))
      (let ((v1-8 (-> *level* level gp-0)))
        (when (= (-> v1-8 status) 'active)
          (-> v1-8 bsp wind-array)
          ;; (if (nonzero? (-> v1-8 bsp wind-array-length))
          ;;     (level-update-wind *wind-work*)
          ;;     )
          )
        )
      )
    )
  (background-upload-vu0)
  (dotimes (v1-14 (-> *level* length))
    (let ((a0-12 (-> *level* level v1-14)))
      (when (= (-> a0-12 status) 'active)
        (let ((a0-13 (-> a0-12 bsp)))
          (when (nonzero? (-> a0-13 tfrag-masks))
            (dotimes (a1-7 (-> a0-13 tfrag-masks length))
              (set! (-> a0-13 tfrag-closest a1-7) 4095996000.0)
              )
            )
          (when (nonzero? (-> a0-13 shrub-masks))
            (dotimes (a1-12 (-> a0-13 shrub-masks length))
              (set! (-> a0-13 shrub-closest a1-12) 4095996000.0)
              )
            )
          (when (nonzero? (-> a0-13 alpha-masks))
            (dotimes (a1-17 (-> a0-13 alpha-masks length))
              (set! (-> a0-13 alpha-closest a1-17) 4095996000.0)
              )
            )
          (when (nonzero? (-> a0-13 water-masks))
            (dotimes (a1-22 (-> a0-13 water-masks length))
              (set! (-> a0-13 water-closest a1-22) 4095996000.0)
              )
            )
          )
        )
      )
    )
  (when (nonzero? (-> *background-work* shrub-tree-count))
    (with-profiler 'shrubbery *profile-shrubbery-color*
      (dotimes (gp-2 (-> *background-work* shrub-tree-count))
        (set! *draw-index* (-> *background-work* shrub-levels gp-2 draw-index))
        (flush-cache 0)
        (let ((s5-1 (-> *background-work* shrub-trees gp-2))
              (s4-1 (-> *background-work* shrub-levels gp-2))
              )
          ; (if (nonzero? (-> s5-1 colors-added))
          ;     (time-of-day-interp-colors
          ;       (-> *instance-shrub-work* colors)
          ;       (the-as uint (-> s5-1 colors-added))
          ;       (-> s4-1 mood-context)
          ;       )
          ;     )
          (set-background-regs! s4-1)
          (set-shrub-quard-planes! s4-1)
          (draw-drawable-tree-instance-shrub s5-1 s4-1)
          )
        )
      )
    )
  (let ((gp-4 (the-as level #f)))
    (when (or (nonzero? (-> *background-work* tfrag-tree-count))
              (nonzero? (-> *background-work* tfrag-trans-tree-count))
              (nonzero? (-> *background-work* tfrag-water-tree-count))
              )
      (let ((s5-5 (max
                    (max (-> *background-work* tfrag-tree-count) (-> *background-work* tfrag-trans-tree-count))
                    (-> *background-work* tfrag-water-tree-count)
                    )
                  )
            (s4-3 (the-as time-of-day-palette #f))
            )
        (with-profiler 'tfrag *profile-tfrag-color*
          (dotimes (s3-2 s5-5)
            (let ((s2-1 (-> *background-work* tfrag-trees s3-2)))
              (when s2-1
                (let ((s1-1 (-> *background-work* tfrag-levels s3-2)))
                  (let ((a2-23 (-> s1-1 bsp))
                        (s0-1 (-> s2-1 time-of-day-pal))
                        )
                    (upload-vis-bits s1-1 gp-4 a2-23)
                    (set-subdivide-settings! s1-1)
                    (when (not (or (zero? s0-1) (= s4-3 s0-1)))
                      (flush-cache 0)
                      ;; (time-of-day-interp-colors-scratch (the-as (pointer rgba) (+ 6144 #x70000000)) s0-1 (-> s1-1 mood-context))
                      (set! s4-3 s0-1)
                      )
                    )
                  (set! *draw-index* (-> s1-1 draw-index))
                  (set! (-> *tfrag-work* min-dist z) 4095996000.0)
                  (set-background-regs! s1-1)
                  )
                (draw-drawable-tree-tfrag s2-1)
                (set! (-> *level* draw-level *draw-index* closest-object 0) (-> *tfrag-work* min-dist z))
                )
              )
            (let ((s2-2 (-> *background-work* tfrag-trans-trees s3-2)))
              (when s2-2
                (let ((s1-2 (-> *background-work* tfrag-trans-levels s3-2)))
                  (let ((a2-25 (-> s1-2 bsp))
                        (s0-2 (-> s2-2 time-of-day-pal))
                        )
                    (upload-vis-bits s1-2 gp-4 a2-25)
                    (set-subdivide-settings! s1-2)
                    (when (not (or (zero? s0-2) (= s4-3 s0-2)))
                      (flush-cache 0)
                      ;; (time-of-day-interp-colors-scratch (the-as (pointer rgba) (+ 6144 #x70000000)) s0-2 (-> s1-2 mood-context))
                      (set! s4-3 s0-2)
                      )
                    )
                  (set! *draw-index* (-> s1-2 draw-index))
                  (set! (-> *tfrag-work* min-dist z) 4095996000.0)
                  (set-background-regs! s1-2)
                  )
                (draw-drawable-tree-tfrag-trans s2-2)
                (set! (-> *level* draw-level *draw-index* closest-object 3) (-> *tfrag-work* min-dist z))
                )
              )
            (let ((s2-3 (-> *background-work* tfrag-water-trees s3-2)))
              (when s2-3
                (let ((s1-3 (-> *background-work* tfrag-water-levels s3-2)))
                  (let ((a2-27 (-> s1-3 bsp))
                        (s0-3 (-> s2-3 time-of-day-pal))
                        )
                    (upload-vis-bits s1-3 gp-4 a2-27)
                    (set-subdivide-settings! s1-3)
                    (when (not (or (zero? s0-3) (= s4-3 s0-3)))
                      (flush-cache 0)
                      ;; (time-of-day-interp-colors-scratch (the-as (pointer rgba) (+ 6144 #x70000000)) s0-3 (-> s1-3 mood-context))
                      (set! s4-3 s0-3)
                      )
                    )
                  (set! *draw-index* (-> s1-3 draw-index))
                  (set! (-> *tfrag-work* min-dist z) 4095996000.0)
                  (set-background-regs! s1-3)
                  )
                (draw-drawable-tree-tfrag-water s2-3)
                (set! (-> *level* draw-level *draw-index* closest-object 4) (-> *tfrag-work* min-dist z))
                )
              )
            )
          )
        )
      )
    (when (nonzero? (-> *background-work* tie-tree-count))
      (set! (-> *instance-tie-work* tod-env-color quad) (-> *time-of-day-context* current-env-color quad))
      (with-profiler 'tie *profile-tie-color*
        (dotimes (s5-8 (-> *background-work* tie-tree-count))
          (let ((s4-6 (-> *background-work* tie-levels s5-8)))
            (let ((a2-29 (-> s4-6 bsp)))
              (when (!= s4-6 gp-4)
                (set! (-> *instance-tie-work* min-dist x) 4095996000.0)
                (upload-vis-bits s4-6 gp-4 a2-29)
                (set-subdivide-settings! s4-6)
                (set! gp-4 s4-6)
                )
              )
            (set! *draw-index* (-> s4-6 draw-index))
            (set! (-> *prototype-tie-work* mood) (-> s4-6 mood-context))
            (set-background-regs! s4-6)
            (set-tie-quard-planes! s4-6)
            (tie-scissor-make-perspective-matrix
              (-> *instance-tie-work* tie-scissor-perspective-matrix)
              (if (logtest? (-> s4-6 info level-flags) (level-flags use-camera-other))
                  (-> *math-camera* camera-temp-other)
                  (-> *math-camera* camera-temp)
                  )
              )
            (draw-drawable-tree-instance-tie (-> *background-work* tie-trees s5-8) s4-6)
            )
          (set! (-> *background-work* tie-generic s5-8) (the-as basic (-> *prototype-tie-work* generic-next)))
          (set! (-> *background-work* tie-generic-trans s5-8)
                (the-as basic (-> *prototype-tie-work* generic-trans-next))
                )
          )
        )
      )
    )
  (let ((a0-116 (-> *display* frames (-> *display* on-screen) global-buf)))
    (when (< (-> a0-116 real-buffer-end) (the-as int (-> a0-116 base)))
      (break!)
      0
      )
    )

  ;; og::preserve-this PC version of hfrag (see hfrag.gc)
  (pc-draw-hfrags)
  ; (dotimes (gp-6 (-> *level* draw-level-count))
  ;   (let ((s5-10 (-> *level* draw-level gp-6)))
  ;     (when (and s5-10 (= (-> s5-10 status) 'active))
  ;       (when (and (nonzero? (-> s5-10 bsp hfrag-drawable)) (= (-> s5-10 display?) 'display))
  ;         (with-profiler 'hfrag *profile-hfrag-color*
  ;           (set! *draw-index* (-> s5-10 draw-index))
  ;           (let ((s4-9 (-> *display* frames (-> *display* on-screen) global-buf base)))
  ;             (draw (-> s5-10 bsp hfrag-drawable))
  ;             (let ((v1-293 *dma-mem-usage*))
  ;               (when (nonzero? v1-293)
  ;                 (set! (-> v1-293 length) (max 44 (-> v1-293 length)))
  ;                 (set! (-> v1-293 data 43 name) "hfragment")
  ;                 (+! (-> v1-293 data 43 count) 1)
  ;                 (+! (-> v1-293 data 43 used)
  ;                     (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint s4-9))
  ;                     )
  ;                 (set! (-> v1-293 data 43 total) (-> v1-293 data 43 used))
  ;                 )
  ;               )
  ;             )
  ;           )
  ;         )
  ;       )
  ;     )
  ;   )
  (let ((a0-139 (-> *display* frames (-> *display* on-screen) global-buf)))
    (when (< (-> a0-139 real-buffer-end) (the-as int (-> a0-139 base)))
      (break!)
      0
      )
    )
  (dotimes (v1-323 (-> *level* length))
    (let ((a1-55 (-> *level* level v1-323)))
      (when (= (-> a1-55 status) 'active)
        (let ((a0-145 (-> a1-55 bsp)))
          (when (nonzero? (-> a0-145 tfrag-masks))
            (let ((a2-43 (-> a1-55 texture-mask)))
              (dotimes (a3-5 (-> a0-145 tfrag-masks length))
                (let ((f0-12 (* (-> a0-145 tfrag-closest a3-5) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-12 4095996000.0)
                    (let ((t0-8 (-> a0-145 tfrag-masks data a3-5)))
                      (dotimes (t1-2 3)
                        (when (or (= t1-2 2) (>= f0-12 (-> t0-8 data t1-2 dist)))
                          (dotimes (t2-5 3)
                            (logior!
                              (-> (&-> a2-43 0 mask data t2-5) 0)
                              (-> (the-as (pointer int32) (+ (* t2-5 4) (the-as int t0-8) (* t1-2 16))) 0)
                              )
                            )
                          (goto cfg-176)
                          )
                        )
                      )
                    )
                  )
                (label cfg-176)
                )
              )
            )
          (when (nonzero? (-> a0-145 shrub-masks))
            (let ((a2-48 (-> a1-55 texture-mask 2)))
              (dotimes (a3-6 (-> a0-145 shrub-masks length))
                (let ((f0-14 (* (-> a0-145 shrub-closest a3-6) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-14 4095996000.0)
                    (let ((t0-24 (-> a0-145 shrub-masks data a3-6)))
                      (dotimes (t1-5 3)
                        (when (or (= t1-5 2) (>= f0-14 (-> t0-24 data t1-5 dist)))
                          (dotimes (t2-11 3)
                            (logior!
                              (-> a2-48 mask data t2-11)
                              (-> (the-as (pointer int32) (+ (* t2-11 4) (the-as int t0-24) (* t1-5 16))) 0)
                              )
                            )
                          (goto cfg-196)
                          )
                        )
                      )
                    )
                  )
                (label cfg-196)
                )
              )
            )
          (when (nonzero? (-> a0-145 alpha-masks))
            (let ((a2-53 (-> a1-55 texture-mask 3)))
              (dotimes (a3-7 (-> a0-145 alpha-masks length))
                (let ((f0-16 (* (-> a0-145 alpha-closest a3-7) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-16 4095996000.0)
                    (let ((t0-40 (-> a0-145 alpha-masks data a3-7)))
                      (dotimes (t1-8 3)
                        (when (or (= t1-8 2) (>= f0-16 (-> t0-40 data t1-8 dist)))
                          (dotimes (t2-17 3)
                            (logior!
                              (-> a2-53 mask data t2-17)
                              (-> (the-as (pointer int32) (+ (* t2-17 4) (the-as int t0-40) (* t1-8 16))) 0)
                              )
                            )
                          (goto cfg-216)
                          )
                        )
                      )
                    )
                  )
                (label cfg-216)
                )
              )
            )
          (when (nonzero? (-> a0-145 water-masks))
            (let ((a1-56 (-> a1-55 texture-mask 4)))
              (dotimes (a2-58 (-> a0-145 water-masks length))
                (let ((f0-18 (* (-> a0-145 water-closest a2-58) (-> *math-camera* fov-correction-factor))))
                  (when (!= f0-18 4095996000.0)
                    (let ((a3-16 (-> a0-145 water-masks data a2-58)))
                      (dotimes (t0-50 3)
                        (when (or (= t0-50 2) (>= f0-18 (-> a3-16 data t0-50 dist)))
                          (dotimes (t1-14 3)
                            (logior!
                              (-> a1-56 mask data t1-14)
                              (-> (the-as (pointer int32) (+ (* t1-14 4) (the-as int a3-16) (* t0-50 16))) 0)
                              )
                            )
                          (goto cfg-236)
                          )
                        )
                      )
                    )
                  )
                (label cfg-236)
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )
