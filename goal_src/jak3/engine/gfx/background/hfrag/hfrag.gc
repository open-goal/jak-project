;;-*-Lisp-*-
(in-package goal)

;; name: hfrag.gc
;; name in dgo: hfrag
;; dgos: HGA, WIN, DST

(define-extern *hfrag-work* hfrag-work)

;; DECOMP BEGINS

(defmethod init-work-from-current-hfrag! ((this hfrag-work))
  (let ((v1-0 (-> this hfrag)))
    (set! (-> this lowres-flag) #f)
    (dotimes (a1-0 (-> *level* length))
      (let ((a2-3 (-> *level* level a1-0)))
        (when (= (-> a2-3 status) 'active)
          (if (logtest? (-> a2-3 info level-flags) (level-flags low-res-hfrag))
              (set! (-> this lowres-flag) #t)
              )
          )
        )
      )
    (let ((f0-0 (-> v1-0 start-corner x))
          (f1-0 (-> v1-0 start-corner z))
          )
      (dotimes (a1-3 32)
        (dotimes (a2-9 32)
          (let ((a3-6 (+ (* a1-3 32) a2-9)))
            (set! (-> this corners a3-6 x) (+ f0-0 (* 524288.0 (the float a2-9))))
            (set! (-> this corners a3-6 y) 0.0)
            (set! (-> this corners a3-6 z) (+ f1-0 (* 524288.0 (the float a1-3))))
            (set! (-> this corners a3-6 w) 1.0)
            )
          )
        )
      )
    (let ((f0-1 (-> this near-dist))
          (f2-8 (-> this far-dist))
          (f1-1 819200.0)
          )
      (set! (-> this dists x) (- f2-8))
      (set! (-> this dists y) (- f0-1))
      (set! (-> this rdists x) (/ 1.0 (- (- f2-8 (+ f0-1 f1-1)))))
      (set! (-> this rdists y) (/ 1.0 (- (- f0-1 f1-1))))
      )
    (set! (-> this next-far) -1)
    (set! (-> this next-far-mid) -1)
    (set! (-> this next-mid) -1)
    (set! (-> this next-near-mid) -1)
    (set! (-> this next-near) -1)
    (set! (-> this next-far-scissor) -1)
    (set! (-> this next-near-mid-scissor) -1)
    (set! (-> this next-near-scissor) -1)
    (set! (-> this count-far) 0)
    (set! (-> this count-far-mid) 0)
    (set! (-> this count-mid) 0)
    (set! (-> this count-near-mid) 0)
    (set! (-> this count-near) 0)
    (set! (-> this count-far-scissor) 0)
    (set! (-> this count-near-mid-scissor) 0)
    (set! (-> this count-near-scissor) 0)
    (let ((a0-1 (-> v1-0 num-buckets-far)))
      (dotimes (a1-18 (the-as int a0-1))
        (let ((a2-13 (-> v1-0 buckets-far a1-18)))
          (set! (-> a2-13 next) (the-as pointer 0))
          (set! (-> a2-13 count) (the-as uint 0))
          (set! (-> a2-13 vertex-count) (the-as uint 32))
          (set! (-> a2-13 next-scissor) (the-as pointer 0))
          (set! (-> a2-13 count-scissor) (the-as uint 0))
          (set! (-> a2-13 vertex-count-scissor) (the-as uint 48))
          )
        )
      )
    (let ((a0-4 (-> v1-0 num-buckets-mid)))
      (dotimes (a1-19 (the-as int a0-4))
        (let ((a2-15 (-> v1-0 buckets-mid a1-19)))
          (set! (-> a2-15 next) (the-as pointer 0))
          (set! (-> a2-15 count) (the-as uint 0))
          (set! (-> a2-15 vertex-count) (the-as uint 32))
          (set! (-> a2-15 next-scissor) (the-as pointer 0))
          (set! (-> a2-15 count-scissor) (the-as uint 0))
          (set! (-> a2-15 vertex-count-scissor) (the-as uint 48))
          )
        )
      )
    (let ((a0-7 (-> v1-0 num-buckets-near)))
      (dotimes (a1-20 (the-as int a0-7))
        (let ((a2-17 (-> v1-0 buckets-near a1-20)))
          (set! (-> a2-17 next) (the-as pointer 0))
          (set! (-> a2-17 count) (the-as uint 0))
          (set! (-> a2-17 vertex-count) (the-as uint 32))
          (set! (-> a2-17 next-scissor) (the-as pointer 0))
          (set! (-> a2-17 count-scissor) (the-as uint 0))
          (set! (-> a2-17 vertex-count-scissor) (the-as uint 48))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod pick-level-of-detail! ((this hfrag-work) (arg0 level))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf12 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf20 :class vf)
         (vf21 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> this hfrag))
          (s2-0 (new 'stack-no-clear 'vector))
          )
      0
      (let ((s4-0 *math-camera*))
        (vector-! s2-0 (camera-pos) (-> s5-0 start-corner))
        (+ (* (the int (/ (-> s2-0 y) (meters 128))) 32) (the int (/ (-> s2-0 x) (meters 128))))
        (.lvf vf16 (&-> s4-0 plane 0 quad))
        (.lvf vf17 (&-> s4-0 plane 1 quad))
        (.lvf vf18 (&-> s4-0 plane 2 quad))
        (.lvf vf19 (&-> s4-0 plane 3 quad))
        (.lvf vf20 (&-> s4-0 guard-plane 0 quad))
        (.lvf vf21 (&-> s4-0 guard-plane 1 quad))
        (.lvf vf22 (&-> s4-0 guard-plane 2 quad))
        (.lvf vf23 (&-> s4-0 guard-plane 3 quad))
        (.lvf vf24 (&-> s4-0 camera-rot rvec quad))
        (.lvf vf25 (&-> s4-0 camera-rot uvec quad))
        (.lvf vf26 (&-> s4-0 camera-rot fvec quad))
        (.lvf vf27 (&-> s4-0 camera-rot trans quad))
        (let ((s3-1 (+ (+ (- (-> arg0 bsp visible-list-length) (-> arg0 bsp extra-vis-list-length)) 0)
                       (the-as int (-> arg0 vis-bits))
                       )
                    )
              )
          (dotimes (s2-1 1024)
            (let ((v1-13 (/ (-> s5-0 visids s2-1) 8))
                  (a0-9 (ash 128 (- (logand (-> s5-0 visids s2-1) 7))))
                  )
              (when (logtest? (-> (the-as (pointer uint8) (+ v1-13 (the-as int s3-1)))) a0-9)
                (let ((s1-2 (-> s5-0 spheres s2-1)))
                  (when (sphere-cull s1-2)
                    (set! (-> this scissor) (guard-band-cull s1-2))
                    (.lvf vf12 (&-> s1-2 quad))
                    (.mul.x.vf acc vf24 vf12)
                    (.add.mul.y.vf acc vf25 vf12 acc)
                    (.add.mul.z.vf acc vf26 vf12 acc)
                    (.add.mul.w.vf vf12 vf27 vf0 acc)
                    (.svf (&-> this pos-temp quad) vf12)
                    (let* ((f0-6 (-> this trans-temp z))
                           (f2-0 (-> s1-2 w))
                           (f1-2 (+ f0-6 f2-0))
                           (f0-7 (- f0-6 f2-0))
                           (v1-20 0)
                           )
                      (if (< f0-7 (-> s4-0 d))
                          (set! (-> this scissor) #t)
                          )
                      (if (< f1-2 (-> this far-dist))
                          (set! v1-20 (logior v1-20 8))
                          )
                      (if (< f0-7 (-> this far-dist))
                          (set! v1-20 (logior v1-20 4))
                          )
                      (if (< f1-2 (-> this near-dist))
                          (set! v1-20 (logior v1-20 2))
                          )
                      (if (< f0-7 (-> this near-dist))
                          (set! v1-20 (logior v1-20 1))
                          )
                      (set! (-> this subdiv-index) (the-as uint v1-20))
                      )
                    (cond
                      ((or (zero? (-> this subdiv-index)) (-> this lowres-flag))
                       (cond
                         ((-> this scissor)
                          (set! (-> this draw-table s2-1) (-> this next-far-scissor))
                          (set! (-> this next-far-scissor) s2-1)
                          (+! (-> this count-far-scissor) 1)
                          )
                         (else
                           (set! (-> this draw-table s2-1) (-> this next-far))
                           (set! (-> this next-far) s2-1)
                           (+! (-> this count-far) 1)
                           )
                         )
                       )
                      ((= (-> this subdiv-index) 4)
                       (set! (-> this draw-table s2-1) (-> this next-far-mid))
                       (set! (-> this next-far-mid) s2-1)
                       (+! (-> this count-far-mid) 1)
                       )
                      ((= (-> this subdiv-index) 12)
                       (set! (-> this draw-table s2-1) (-> this next-mid))
                       (set! (-> this next-mid) s2-1)
                       (+! (-> this count-mid) 1)
                       )
                      ((= (-> this subdiv-index) 13)
                       (cond
                         ((-> this scissor)
                          (set! (-> this draw-table s2-1) (-> this next-near-mid-scissor))
                          (set! (-> this next-near-mid-scissor) s2-1)
                          (+! (-> this count-near-mid-scissor) 1)
                          )
                         (else
                           (set! (-> this draw-table s2-1) (-> this next-near-mid))
                           (set! (-> this next-near-mid) s2-1)
                           (+! (-> this count-near-mid) 1)
                           )
                         )
                       )
                      (else
                        (set! (-> this draw-table s2-1) (-> this next-near))
                        (set! (-> this next-near) s2-1)
                        (+! (-> this count-near) 1)
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod generate-vertices! ((this hfrag-work))
  (local-vars (v1-1 float))
  (rlet ((vf13 :class vf)
         (vf14 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf28 :class vf)
         (vf31 :class vf)
         )
    (.lvf vf28 (&-> this constants quad))
    (.lvf vf13 (&-> this dists quad))
    (.lvf vf14 (&-> this rdists quad))
    (let ((v1-0 *math-camera*))
      (.lvf vf16 (&-> v1-0 camera-temp rvec quad))
      (.lvf vf17 (&-> v1-0 camera-temp uvec quad))
      (.lvf vf18 (&-> v1-0 camera-temp fvec quad))
      (.lvf vf19 (&-> v1-0 camera-temp trans quad))
      (.lvf vf24 (&-> v1-0 camera-rot rvec quad))
      (.lvf vf25 (&-> v1-0 camera-rot uvec quad))
      (.lvf vf26 (&-> v1-0 camera-rot fvec quad))
      (.lvf vf27 (&-> v1-0 camera-rot trans quad))
      (.lvf vf31 (&-> v1-0 hmge-scale quad))
      )
    (.mov v1-1 vf31)
    (set! (-> this next-scissor-tmpl vif0) (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd mscalf) :msk #x1))
    (set! (-> this ret-scissor-tmpl vif0) (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd mscalf) :msk #x1))
    (let ((s5-0 (-> *display* frames (-> *display* on-screen) global-buf)))
      (when (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask hfrag))
        (set! (-> this next-tmpl vif0) (-> this call-poly4-near))
        (set! (-> this ret-tmpl vif0) (-> this call-poly4-near))
        (if (>= (-> this next-near) 0)
            (asm-near this s5-0 (-> this next-near))
            )
        (set! (-> this next-tmpl vif0) (-> this call-poly9-near))
        (set! (-> this ret-tmpl vif0) (-> this call-poly9-near))
        (if (>= (-> this next-near-mid) 0)
            (asm-near-mid this s5-0 (-> this next-near-mid))
            )
        (set! (-> this next-tmpl vif0) (-> this call-poly25-mid))
        (set! (-> this ret-tmpl vif0) (-> this call-poly25-mid))
        (if (>= (-> this next-mid) 0)
            (asm-mid this s5-0 (-> this next-mid))
            )
        (set! (-> this next-tmpl vif0) (-> this call-poly9-mid))
        (set! (-> this ret-tmpl vif0) (-> this call-poly9-mid))
        (if (>= (-> this next-far-mid) 0)
            (asm-far-mid this s5-0 (-> this next-far-mid))
            )
        (set! (-> this next-tmpl vif0) (-> this call-poly25-far))
        (set! (-> this ret-tmpl vif0) (-> this call-poly25-far))
        (if (>= (-> this next-far) 0)
            (asm-far this s5-0 (-> this next-far))
            )
        )
      (when (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask hfrag-scissor))
        (if (>= (-> this next-far-scissor) 0)
            (asm-far-scissor this s5-0 (-> this next-far-scissor))
            )
        (if (>= (-> this next-near-mid-scissor) 0)
            (asm-near-mid-scissor this s5-0 (-> this next-near-mid-scissor))
            )
        )
      )
    0
    (none)
    )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod finalize-dma! ((this hfrag-work))
  (local-vars (v1-40 float))
  (rlet ((vf10 :class vf)
         (vf24 :class vf)
         (vf25 :class vf)
         (vf26 :class vf)
         (vf27 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (when (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask hfrag))
      (with-dma-buffer-add-bucket ((s4-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                   (bucket-id hfrag)
                                   )
        (.lvf vf5 (&-> this tex-data 0 quad 2 quad))
        (.lvf vf6 (&-> this shader-far quad 0 quad))
        (.lvf vf7 (&-> this shader-far quad 1 quad))
        (.lvf vf8 (&-> this shader-far quad 2 quad))
        (.lvf vf9 (&-> this shader-far quad 3 quad))
        (.lvf vf10 (&-> this shader-far quad 4 quad))
        (hfrag-work-method-32 this s4-0)
        (hfrag-work-method-33 this s4-0)
        (.lvf vf6 (&-> this shader-near quad 0 quad))
        (.lvf vf7 (&-> this shader-near quad 1 quad))
        (.lvf vf8 (&-> this shader-near quad 2 quad))
        (.lvf vf9 (&-> this shader-near quad 3 quad))
        (.lvf vf10 (&-> this shader-near quad 4 quad))
        (hfrag-work-method-34 this s4-0)
        )
      (hfrag-vu1-init-buf)
      )
    (when (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask hfrag-scissor))
      (case *subdivide-scissor-draw-mode*
        (((subdivide-setting textured))
         (set! (-> this giftag str-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type tri-strip) :iip #x1 :tme #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         (set! (-> this giftag fan-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type tri-fan) :iip #x1 :tme #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         )
        (((subdivide-setting outline))
         (set! (-> this giftag str-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type line-strip) :iip #x1 :tme #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         (set! (-> this giftag fan-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type line-strip) :iip #x1 :tme #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         )
        (((subdivide-setting gouraud))
         (set! (-> this giftag str-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type tri-strip) :iip #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         (set! (-> this giftag fan-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type tri-fan) :iip #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         )
        (((subdivide-setting hack))
         (set! (-> this giftag str-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type tri-strip) :iip #x1 :tme #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         (set! (-> this giftag fan-prim)
               (new 'static 'gif-tag-prim
                 :pre #x1
                 :prim (new 'static 'gs-prim :prim (gs-prim-type tri-fan) :iip #x1 :tme #x1 :fge #x1)
                 :nreg #x3
                 )
               )
         )
        )
      (.lvf vf5 (&-> this giftag qword quad))
      (let ((v1-39 *math-camera*))
        (.lvf vf24 (&-> v1-39 camera-temp rvec quad))
        (.lvf vf25 (&-> v1-39 camera-temp uvec quad))
        (.lvf vf26 (&-> v1-39 camera-temp fvec quad))
        (.lvf vf27 (&-> v1-39 camera-temp trans quad))
        )
      (.mov v1-40 vf27)
      (with-dma-buffer-add-bucket ((s4-1 (-> *display* frames (-> *display* on-screen) global-buf))
                                   (bucket-id hfrag-scissor)
                                   )
        (.lvf vf6 (&-> this shader-far quad 0 quad))
        (.lvf vf7 (&-> this shader-far quad 1 quad))
        (.lvf vf8 (&-> this shader-far quad 2 quad))
        (.lvf vf9 (&-> this shader-far quad 3 quad))
        (.lvf vf10 (&-> this shader-far quad 4 quad))
        (hfrag-work-method-24 this s4-1)
        (hfrag-work-method-25 this s4-1)
        (.lvf vf6 (&-> this shader-near quad 0 quad))
        (.lvf vf7 (&-> this shader-near quad 1 quad))
        (.lvf vf8 (&-> this shader-near quad 2 quad))
        (.lvf vf9 (&-> this shader-near quad 3 quad))
        (.lvf vf10 (&-> this shader-near quad 4 quad))
        (hfrag-work-method-26 this s4-1)
        )
      (generic-vu1-init-buf (bucket-id hfrag-scissor) (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24)))
      )
    0
    (none)
    )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(define *hfrag-debug* #t)

(defmethod trim-dma-to-fit-in-memory ((this hfrag-work))
  (let* ((a1-1 (-> *display* frames (-> *display* on-screen) global-buf))
         (v1-5 (-> a1-1 base))
         (v1-6 (&- (-> a1-1 end) (the-as uint v1-5)))
         (a1-5 (+ #x110c0
                  (* (+ (/ (-> generic-vu1-block qlength) 127) 1) 16)
                  (* (+ (/ (-> hfrag-vu1-block qlength) 127) 1) 16)
                  )
               )
         )
    (set! (-> this size-far) (* 272 (-> this count-far)))
    (set! (-> this size-far-mid) (* 2304 (-> this count-far-mid)))
    (set! (-> this size-mid) (* 1088 (-> this count-mid)))
    (set! (-> this size-near-mid) (* 9216 (-> this count-near-mid)))
    (set! (-> this size-near) (+ (* #x6000 (-> this count-near)) 1120))
    (set! (-> this size-far-scissor) (* 1952 (-> this count-far-scissor)))
    (set! (-> this size-near-mid-scissor) (* #x9800 (-> this count-near-mid-scissor)))
    (let ((v0-0 (+ a1-5
                   (-> this size-far)
                   (-> this size-far-mid)
                   (-> this size-mid)
                   (-> this size-near-mid)
                   (-> this size-near)
                   (-> this size-far-scissor)
                   (-> this size-near-mid-scissor)
                   )
                )
          )
      (when (< v1-6 v0-0)
        (let ((a1-19 (min (the int (* 0.0036764706 (the float (+ (- 272 v1-6) v0-0)))) (-> this count-far))))
          (set! (-> this count-far) (- (-> this count-far) a1-19))
          (set! (-> this size-far) (- (-> this size-far) (* 272 a1-19)))
          (set! v0-0 (- v0-0 (* 272 a1-19)))
          (let ((a3-11 (-> this next-far)))
            (dotimes (a2-39 a1-19)
              (set! a3-11 (-> this draw-table a3-11))
              )
            (set! (-> this next-far) a3-11)
            )
          )
        )
      (when (< v1-6 v0-0)
        (let ((a1-29 (min (the int (* 0.00043402778 (the float (+ (- 2304 v1-6) v0-0)))) (-> this count-far-mid))))
          (set! (-> this count-far-mid) (- (-> this count-far-mid) a1-29))
          (set! (-> this size-far-mid) (- (-> this size-far-mid) (* 2304 a1-29)))
          (set! v0-0 (- v0-0 (* 2304 a1-29)))
          (let ((a3-16 (-> this next-far-mid)))
            (dotimes (a2-47 a1-29)
              (set! a3-16 (-> this draw-table a3-16))
              )
            (set! (-> this next-far-mid) a3-16)
            )
          )
        )
      (when (< v1-6 v0-0)
        (let ((a1-39 (min (the int (* 0.00091911765 (the float (+ (- 1088 v1-6) v0-0)))) (-> this count-mid))))
          (set! (-> this count-mid) (- (-> this count-mid) a1-39))
          (set! (-> this size-mid) (- (-> this size-mid) (* 1088 a1-39)))
          (set! v0-0 (- v0-0 (* 1088 a1-39)))
          (let ((a3-21 (-> this next-mid)))
            (dotimes (a2-55 a1-39)
              (set! a3-21 (-> this draw-table a3-21))
              )
            (set! (-> this next-mid) a3-21)
            )
          )
        )
      (when (< v1-6 v0-0)
        (let ((a1-49 (min (the int (* 0.000108506945 (the float (+ (- 9216 v1-6) v0-0)))) (-> this count-near-mid))))
          (set! (-> this count-near-mid) (- (-> this count-near-mid) a1-49))
          (set! (-> this size-near-mid) (- (-> this size-near-mid) (* 9216 a1-49)))
          (set! v0-0 (- v0-0 (* 9216 a1-49)))
          (let ((a3-26 (-> this next-near-mid)))
            (dotimes (a2-63 a1-49)
              (set! a3-26 (-> this draw-table a3-26))
              )
            (set! (-> this next-near-mid) a3-26)
            )
          )
        )
      (when (< v1-6 v0-0)
        (let ((a1-59 (min (the int (* 0.000040690105 (the float (+ (- #x6000 v1-6) v0-0)))) (-> this count-near))))
          (set! (-> this count-near) (- (-> this count-near) a1-59))
          (set! (-> this size-near) (- (-> this size-near) (* #x6000 a1-59)))
          (set! v0-0 (- v0-0 (* #x6000 a1-59)))
          (let ((a3-31 (-> this next-near)))
            (dotimes (a2-71 a1-59)
              (set! a3-31 (-> this draw-table a3-31))
              )
            (set! (-> this next-near) a3-31)
            )
          )
        )
      (when (< v1-6 v0-0)
        (let ((a1-69 (min (the int (* 0.00051229505 (the float (+ (- 1952 v1-6) v0-0)))) (-> this count-far-scissor))))
          (set! (-> this count-far-scissor) (- (-> this count-far-scissor) a1-69))
          (set! (-> this size-far-scissor) (- (-> this size-far-scissor) (* 1952 a1-69)))
          (set! v0-0 (- v0-0 (* 224 a1-69)))
          (let ((a3-36 (-> this next-far-scissor)))
            (dotimes (a2-79 a1-69)
              (set! a3-36 (-> this draw-table a3-36))
              )
            (set! (-> this next-far-scissor) a3-36)
            )
          )
        )
      (when (< v1-6 v0-0)
        (let ((v1-11
                (min (the int (* 0.000025699013 (the float (+ (- #x9800 v1-6) v0-0)))) (-> this count-near-mid-scissor))
                )
              )
          (set! (-> this count-near-mid-scissor) (- (-> this count-near-mid-scissor) v1-11))
          (set! (-> this size-near-mid-scissor) (- (-> this size-near-mid-scissor) (* #x9800 v1-11)))
          (- v0-0 (* #x9800 v1-11))
          (let ((a2-82 (-> this next-near-mid-scissor)))
            (dotimes (a1-82 v1-11)
              (set! a2-82 (-> this draw-table a2-82))
              )
            (set! (-> this next-near-mid-scissor) a2-82)
            )
          )
        )
      )
    )
  (none)
  )

(defmethod draw ((this hfragment))
  "Draw the drawable, and typically its children.
   This usually means adding stuff to a list to be drawn later, rather than expensive drawing here."
  (let ((gp-0 *hfrag-work*))
    (let ((s4-0 (-> *level* draw-level *draw-index*)))
      (mem-copy! (&-> (-> gp-0 hfrag) type) (&-> this type) 96)
      (init-work-from-current-hfrag! gp-0)
      (pick-level-of-detail! gp-0 s4-0)
      (trim-dma-to-fit-in-memory gp-0)
      (time-of-day-interp-colors-scratch
        (the-as (pointer rgba) (+ #x3000 #x70000000))
        (-> this colors)
        (-> s4-0 mood-context)
        )
      )
    (generate-vertices! gp-0)
    (generate-montage-texture gp-0)
    (finalize-dma! gp-0)
    )
  (set-dirty-mask! (the-as level (-> *level* level)) 10 #x1a000 #xf4000)
  0
  (none)
  )

(defmethod add-tri-a-xy-zzz-to-collide-cache ((this hfragment)
                                             (arg0 collide-cache)
                                             (arg1 int)
                                             (arg2 int)
                                             (arg3 uint)
                                             (arg4 uint)
                                             (arg5 uint)
                                             (arg6 pat-surface)
                                             )
  (let ((v1-0 (-> arg0 num-tris)))
    (cond
      ((>= v1-0 460)
       (if (= *cheat-mode* 'debug)
           (print-exceeded-max-cache-tris)
           )
       )
      (else
        (let ((v1-6 (-> arg0 tris v1-0)))
          (let ((f0-2 (+ (* 32768.0 (the float arg1)) (-> this start-corner x)))
                (f1-5 (+ (* 32768.0 (the float arg2)) (-> this start-corner z)))
                )
            (set-vector! (-> v1-6 vertex 2) f0-2 (the float (* arg3 8)) f1-5 1.0)
            (set-vector! (-> v1-6 vertex 1) (+ 32768.0 f0-2) (the float (* arg4 8)) f1-5 1.0)
            (set-vector! (-> v1-6 vertex 0) f0-2 (the float (* arg5 8)) (+ 32768.0 f1-5) 1.0)
            )
          (set! (-> v1-6 clear-flags) (the-as uint128 0))
          (set! (-> v1-6 pat) arg6)
          (set! (-> v1-6 collide-ptr) #f)
          )
        (+! (-> arg0 num-tris) 1)
        )
      )
    )
  0
  (none)
  )

(defmethod add-tri-b-xy-zzz-to-collide-cache ((this hfragment)
                                             (arg0 collide-cache)
                                             (arg1 int)
                                             (arg2 int)
                                             (arg3 uint)
                                             (arg4 uint)
                                             (arg5 uint)
                                             (arg6 pat-surface)
                                             )
  (let ((v1-0 (-> arg0 num-tris)))
    (cond
      ((>= v1-0 460)
       (if (= *cheat-mode* 'debug)
           (print-exceeded-max-cache-tris)
           )
       )
      (else
        (let ((v1-6 (-> arg0 tris v1-0)))
          (let ((f0-2 (+ (* 32768.0 (the float arg1)) (-> this start-corner x)))
                (f1-5 (+ (* 32768.0 (the float arg2)) (-> this start-corner z)))
                )
            (set-vector! (-> v1-6 vertex 2) f0-2 (the float (* arg4 8)) (+ 32768.0 f1-5) 1.0)
            (set-vector! (-> v1-6 vertex 1) (+ 32768.0 f0-2) (the float (* arg3 8)) f1-5 1.0)
            (set-vector! (-> v1-6 vertex 0) (+ 32768.0 f0-2) (the float (* arg5 8)) (+ 32768.0 f1-5) 1.0)
            )
          (set! (-> v1-6 clear-flags) (the-as uint128 0))
          (set! (-> v1-6 pat) arg6)
          (set! (-> v1-6 collide-ptr) #f)
          )
        (+! (-> arg0 num-tris) 1)
        )
      )
    )
  0
  (none)
  )

(defmethod add-tri-to-collide-cache ((this hfragment) (arg0 collide-cache) (arg1 collide-query) (arg2 int) (arg3 int) (arg4 int) (arg5 int))
  (local-vars
    (sv-16 uint)
    (sv-24 uint)
    (sv-32 uint)
    (sv-40 uint)
    (sv-48 int)
    (sv-56 int)
    (sv-64 int)
    (sv-72 int)
    )
  (let ((v1-0 (-> this verts))
        (a0-2 (+ (* arg3 512) arg2))
        (s2-0 (-> this pat-array 0))
        )
    (when (not (logtest? (-> arg1 ignore-pat) s2-0))
      (when (nonzero? (-> (the-as hfrag-vertex (-> v1-0 a0-2)) packed-index bit11))
        (set! sv-16 (-> v1-0 a0-2 height))
        (set! sv-24 (-> v1-0 (+ a0-2 1) height))
        (set! sv-32 (-> v1-0 (+ a0-2 512) height))
        (set! sv-40 (-> v1-0 (+ a0-2 513) height))
        (set! sv-48 0)
        (set! sv-56 0)
        (set! sv-64 0)
        (set! sv-72 0)
        (if (< (the-as int sv-16) arg4)
            (set! sv-48 1)
            )
        (if (< arg5 (the-as int sv-16))
            (set! sv-48 (logior sv-48 2))
            )
        (if (< (the-as int sv-24) arg4)
            (set! sv-56 1)
            )
        (if (< arg5 (the-as int sv-24))
            (set! sv-56 (logior sv-56 2))
            )
        (if (< (the-as int sv-32) arg4)
            (set! sv-64 1)
            )
        (if (< arg5 (the-as int sv-32))
            (set! sv-64 (logior sv-64 2))
            )
        (if (< (the-as int sv-40) arg4)
            (set! sv-72 1)
            )
        (if (< arg5 (the-as int sv-40))
            (set! sv-72 (logior sv-72 2))
            )
        (if (not (logtest? (logand sv-48 sv-56) sv-64))
            (add-tri-a-xy-zzz-to-collide-cache this arg0 arg2 arg3 sv-16 sv-24 sv-32 s2-0)
            )
        (if (not (logtest? (logand sv-56 sv-64) sv-72))
            (add-tri-b-xy-zzz-to-collide-cache this arg0 arg2 arg3 sv-24 sv-32 sv-40 s2-0)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod bounding-box-query ((this hfragment) (arg0 collide-cache) (arg1 collide-query))
  (local-vars (sv-16 int) (sv-24 int) (sv-32 int) (sv-40 int) (sv-48 int) (sv-56 int))
  (set! sv-16 (the int (* 0.000030517578 (- (-> arg1 bbox min x) (-> this start-corner x)))))
  (set! sv-24 (the int (* 0.000030517578 (- (-> arg1 bbox min z) (-> this start-corner z)))))
  (set! sv-32 (the int (* 0.000030517578 (- (-> arg1 bbox max x) (-> this start-corner x)))))
  (set! sv-40 (the int (* 0.000030517578 (- (-> arg1 bbox max z) (-> this start-corner z)))))
  (set! sv-48 (the int (/ (-> arg1 bbox min y) 8)))
  (set! sv-56 (the int (/ (-> arg1 bbox max y) 8)))
  (set! sv-16 (max 0 (min 511 sv-16)))
  (set! sv-32 (max 0 (min 511 sv-32)))
  (set! sv-24 (max 0 (min 511 sv-24)))
  (set! sv-40 (max 0 (min 511 sv-40)))
  (let ((s3-0 sv-24)
        (s2-0 sv-40)
        )
    (while (>= s2-0 s3-0)
      (let ((s1-0 sv-16)
            (s0-0 sv-32)
            )
        (while (>= s0-0 s1-0)
          (add-tri-to-collide-cache this arg0 arg1 s1-0 s3-0 sv-48 sv-56)
          (+! s1-0 1)
          )
        )
      (+! s3-0 1)
      )
    )
  0
  (none)
  )

(defmethod line-sphere-query ((this hfragment) (arg0 collide-cache) (arg1 collide-query))
  (local-vars
    (v1-30 int)
    (v1-31 int)
    (v1-57 int)
    (v1-58 int)
    (a0-16 int)
    (a0-17 int)
    (a0-35 int)
    (a0-36 int)
    (s3-0 int)
    (s3-2 int)
    (sv-64 vector)
    (sv-68 vector)
    (sv-72 vector)
    (sv-76 float)
    (sv-80 float)
    (sv-128 int)
    (sv-144 int)
    (sv-160 int)
    (sv-176 int)
    (sv-192 int)
    (sv-208 int)
    )
  (set! sv-64 (new 'stack-no-clear 'vector))
  (set! sv-68 (new 'stack-no-clear 'vector))
  (set! sv-72 (new 'stack-no-clear 'vector))
  (set! sv-76 (the-as float 0.000030517578))
  (set! sv-80 (/ (-> arg1 radius) (meters 8)))
  (vector-! sv-64 (-> arg1 start-pos) (-> this start-corner))
  (vector-float*! sv-64 sv-64 sv-76)
  (vector-float*! sv-72 (-> arg1 move-dist) sv-76)
  (vector+! sv-68 sv-64 sv-72)
  (cond
    ((< (fabs (-> sv-72 z)) (fabs (-> sv-72 x)))
     (when (< (-> sv-72 x) 0.0)
       (let ((v1-15 (new 'stack-no-clear 'vector)))
         (set! (-> v1-15 quad) (-> sv-64 quad))
         (set! (-> sv-64 quad) (-> sv-68 quad))
         (set! (-> sv-68 quad) (-> v1-15 quad))
         )
       (vector-negate! sv-72 sv-72)
       )
     (let* ((a0-9 (the int (- (-> sv-64 x) sv-80)))
            (v1-20 (the int (+ (-> sv-68 x) sv-80)))
            (f0-15 (fmax 1.0 (the float (- v1-20 a0-9))))
            (f30-0 (/ (-> sv-72 y) f0-15))
            (f28-0 (/ (-> sv-72 z) f0-15))
            (f26-0 (+ sv-80 (* 0.5 (fabs f30-0))))
            (f24-0 (+ sv-80 (* 0.5 (fabs f28-0))))
            )
       (cond
         ((< a0-9 0)
          (+! (-> sv-64 y) (* f30-0 (- (the float a0-9))))
          (+! (-> sv-64 z) (* f28-0 (- (the float a0-9))))
          (set! s3-0 0)
          )
         (else
           (set! s3-0 (min 511 a0-9))
           )
         )
       (let ((s2-1 (max 0 (min 511 v1-20)))
             (s1-0 s3-0)
             )
         (while (>= s2-1 s1-0)
           (let* ((f0-23 (the float (- s1-0 s3-0)))
                  (f1-23 (+ (-> sv-64 y) (* f30-0 f0-23)))
                  (f0-25 (+ (-> sv-64 z) (* f28-0 f0-23)))
                  (s0-0 (the int (* 4096.0 (+ (- -0.5 f26-0) f1-23))))
                  )
             (set! sv-128 (the int (* 4096.0 (+ 0.5 f26-0 f1-23))))
             (let ((a0-15 (the int (- f0-25 f24-0)))
                   (v1-29 (the int (+ f0-25 f24-0)))
                   )
               (set! sv-144 0)
               (let ((a2-1 sv-144)
                     (a1-21 (min 511 a0-15))
                     )
                 (set-on-less-than a0-16 a2-1 a1-21)
                 (move-if-not-zero a0-17 a1-21 a0-16 a0-16)
                 )
               (set! sv-144 a0-17)
               (set! sv-160 0)
               (let ((a1-22 sv-160)
                     (a0-20 (min 511 v1-29))
                     )
                 (set-on-less-than v1-30 a1-22 a0-20)
                 (move-if-not-zero v1-31 a0-20 v1-30 v1-30)
                 )
               )
             (set! sv-160 v1-31)
             (while (>= sv-160 sv-144)
               (add-tri-to-collide-cache this arg0 arg1 s1-0 sv-144 s0-0 sv-128)
               (set! sv-144 (+ sv-144 1))
               )
             )
           (+! s1-0 1)
           )
         )
       )
     )
    (else
      (when (< (-> sv-72 z) 0.0)
        (let ((v1-42 (new 'stack-no-clear 'vector)))
          (set! (-> v1-42 quad) (-> sv-64 quad))
          (set! (-> sv-64 quad) (-> sv-68 quad))
          (set! (-> sv-68 quad) (-> v1-42 quad))
          )
        (vector-negate! sv-72 sv-72)
        )
      (let* ((a0-27 (the int (- (-> sv-64 z) sv-80)))
             (v1-47 (the int (+ (-> sv-68 z) sv-80)))
             (f0-36 (fmax 1.0 (the float (- v1-47 a0-27))))
             (f30-1 (/ (-> sv-72 y) f0-36))
             (f28-1 (/ (-> sv-72 x) f0-36))
             (f26-1 (+ sv-80 (* 0.5 (fabs f30-1))))
             (f24-1 (+ sv-80 (* 0.5 (fabs f28-1))))
             )
        (cond
          ((< a0-27 0)
           (+! (-> sv-64 y) (* f30-1 (the float (- a0-27))))
           (+! (-> sv-64 x) (* f28-1 (the float (- a0-27))))
           (set! s3-2 0)
           )
          (else
            (set! s3-2 (min 511 a0-27))
            )
          )
        (let ((s2-3 (max 0 (min 511 v1-47)))
              (s1-1 s3-2)
              )
          (while (>= s2-3 s1-1)
            (let* ((f0-44 (the float (- s1-1 s3-2)))
                   (f1-47 (+ (-> sv-64 y) (* f30-1 f0-44)))
                   (f0-46 (+ (-> sv-64 x) (* f28-1 f0-44)))
                   (s0-1 (the int (* 4096.0 (+ (- -0.5 f26-1) f1-47))))
                   )
              (set! sv-176 (the int (* 4096.0 (+ 0.5 f26-1 f1-47))))
              (let ((a0-34 (the int (- f0-46 f24-1)))
                    (v1-56 (the int (+ f0-46 f24-1)))
                    )
                (set! sv-192 0)
                (let ((a2-3 sv-192)
                      (a1-41 (min 511 a0-34))
                      )
                  (set-on-less-than a0-35 a2-3 a1-41)
                  (move-if-not-zero a0-36 a1-41 a0-35 a0-35)
                  )
                (set! sv-192 a0-36)
                (set! sv-208 0)
                (let ((a1-42 sv-208)
                      (a0-39 (min 511 v1-56))
                      )
                  (set-on-less-than v1-57 a1-42 a0-39)
                  (move-if-not-zero v1-58 a0-39 v1-57 v1-57)
                  )
                )
              (set! sv-208 v1-58)
              (while (>= sv-208 sv-192)
                (add-tri-to-collide-cache this arg0 arg1 sv-192 s1-1 s0-1 sv-176)
                (set! sv-192 (+ sv-192 1))
                )
              )
            (+! s1-1 1)
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun-debug hfrag-vert-print ((arg0 int) (arg1 int))
  (let ((s4-0 (-> *hfrag-work* hfrag verts)))
    (dotimes (s3-0 16)
      (dotimes (s2-0 16)
        (let ((v1-3 (+ (* (+ s3-0 arg1) 512) s2-0 arg0)))
          (format 0 "#x~2x " (+ (shr (-> s4-0 v1-3 packed-index bit11) 3) -1))
          )
        )
      (format 0 "~%")
      )
    )
  (none)
  )

(defmethod collect-stats ((this hfragment))
  "Collect triangle/perf statistics for rendering.
   This is only called when viewing stats.
   The vis-bits and culling registers are loaded during this time."
  (let ((v1-0 *hfrag-work*))
    (+! (-> *terrain-stats* hfrag groups) 1)
    (+! (-> *terrain-stats* hfrag fragments) (-> v1-0 count-far) (-> v1-0 count-far-scissor))
    (+! (-> *terrain-stats* hfrag fragments) (* (-> v1-0 count-far-mid) 16))
    (+! (-> *terrain-stats* hfrag fragments) (* (-> v1-0 count-mid) 4))
    (+! (-> *terrain-stats* hfrag fragments) (* (+ (-> v1-0 count-near-mid) (-> v1-0 count-near-mid-scissor)) 64))
    (+! (-> *terrain-stats* hfrag fragments) (* (+ (-> v1-0 count-near) (-> v1-0 count-near-scissor)) 256))
    (+! (-> *terrain-stats* hfrag tris) (* (+ (-> v1-0 count-far) (-> v1-0 count-far-scissor)) 32))
    (+! (-> *terrain-stats* hfrag tris) (* (-> v1-0 count-far-mid) 32))
    (+! (-> *terrain-stats* hfrag tris) (* (-> v1-0 count-mid) 32))
    (+! (-> *terrain-stats* hfrag tris) (* (+ (-> v1-0 count-near-mid) (-> v1-0 count-near-mid-scissor)) 128))
    (+! (-> *terrain-stats* hfrag tris) (* (+ (-> v1-0 count-near) (-> v1-0 count-near-scissor)) 512))
    (+! (-> *terrain-stats* hfrag dverts) (* (+ (-> v1-0 count-far) (-> v1-0 count-far-scissor)) 64))
    (+! (-> *terrain-stats* hfrag dverts) (* (-> v1-0 count-far-mid) 64))
    (+! (-> *terrain-stats* hfrag dverts) (* (-> v1-0 count-mid) 64))
    (+! (-> *terrain-stats* hfrag dverts) (* (+ (-> v1-0 count-near-mid) (-> v1-0 count-near-mid-scissor)) 256))
    (+! (-> *terrain-stats* hfrag dverts) (shl (+ (-> v1-0 count-near) (-> v1-0 count-near-scissor)) 10))
    )
  0
  (none)
  )

(defmethod mem-usage ((this hfragment) (usage memory-usage-block) (flags int))
  (let ((v1-0 43))
    (set! (-> usage length) (max (-> usage length) (+ v1-0 1)))
    (set! (-> usage data v1-0 name) "hfragment")
    (+! (-> usage data v1-0 count) 1)
    (let ((a2-9 (-> this size)))
      (+! (-> usage data v1-0 used) a2-9)
      (+! (-> usage data v1-0 total) (logand -16 (+ a2-9 15)))
      )
    )
  this
  )
