;;-*-Lisp-*-
(in-package goal)

;; name: texture-anim.gc
;; name in dgo: texture-anim
;; dgos: GAME

;; DECOMP BEGINS

(define *texture-anim-work*
  (new 'static 'texture-anim-work
    :erase-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif (new 'static 'array uint64 2 #x3003400000008001 #x551)
      )
    :draw-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #xa :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #xa :cmd (vif-cmd direct) :msk #x1)
        )
      :gif (new 'static 'array uint64 2 #x902a400000008001 #x525252521)
      )
    :draw2-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif (new 'static 'array uint64 2 #x500b400000008001 #x52521)
      )
    :fill-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif (new 'static 'array uint64 2 #x3003400000008001 #x551)
      )
    :adgif-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif (new 'static 'array uint64 2 #x1000000000008005 #xe)
      )
    :corner0 (new 'static 'vector :x -0.5 :y -0.5 :w 1.0)
    :corner1 (new 'static 'vector :x 0.5 :y -0.5 :w 1.0)
    :corner2 (new 'static 'vector :x -0.5 :y 0.5 :w 1.0)
    :corner3 (new 'static 'vector :x 0.5 :y 0.5 :w 1.0)
    :const (new 'static 'vector :x 128.0 :z 1.9921 :w 1.0)
    :color (new 'static 'vector4w :x #x80 :y #x80 :z #x80 :w #x80)
    :random (new 'static 'inline-array vector4w 8
      (new 'static 'vector4w :x #x17181920 :y #x13141516 :z -1995435758 :w #x1234567)
      (new 'static 'vector4w :x #x23878237 :y #x32048778 :z -1740074601 :w -2021050320)
      (new 'static 'vector4w :x #x62024762 :y -1876389256 :z #x28724781 :w #x68712983)
      (new 'static 'vector4w :x #x62176128 :y #x12387487 :z #x12780983 :w -2139999882)
      (new 'static 'vector4w :x #x34987239 :y #x78699872 :z -2087161499 :w #x1982397)
      (new 'static 'vector4w :x -1737344873 :y -1742502109 :z #x20987293 :w #x62102981)
      (new 'static 'vector4w :x -2110229208 :y -2022559591 :z -1743517309 :w #x29874310)
      (new 'static 'vector4w :x -2030034041 :y -1743611880 :z -2094950384 :w #x71623790)
      )
    )
  )

(defun texture-anim-layer-interp ((arg0 texture-anim-layer) (arg1 float))
  (format 0 "unsupported texture-anim-layer-interp~%")
  (break!)
  (none)
  )

;; og:preserve-this
(defenum texture-anim-pc
  (start-anim-array 12)
  (finish-anim-array 13)
  (erase-and-init 14)
  (upload-clut-16-16 15) ;; needed for fog clut upload
  (upload-generic-vram 16) ;; needed for fog texture upload
  (set-shader 17)
  (draw 18)
  (move-rg-to-ba 19)
  (set-clut-alpha 20)
  (copy-clut-alpha 21)
  (darkjak 22)
  (darkjak-highres 23)
  (skull-gem 27) ;; same as jak 2
  (default-water 28)
  (default-warp 29)
  (templea-water 30)
  (templea-warp 31)
  (templeb-warp 32)
  (templec-water 33)
  (sewc-water 34)
  (sewd-water 35)
  (sewe-water 36)
  (sewg-water 37)
  (sewh-water 38)
  (sewi-water 39)
  (sewj-water 40)
  (sewl-water 41)
  (sewm-water 42)
  (sewn-water 43)
  (desresc-warp 44)
  (ctyslumb-water 45)
  (nstb-quicksand 46)
  (ctyslumc-water 47)
  (factoryc-alpha 48)
  (hfrag 49)
  (hanga-sprite 50)
  (hanga-water 51)
  (desertd-water 52)
  (lmhcityb-tfrag 53)
  (towerb-water 54)
  (comb-field 55)
  (wasstada-alpha 56)
  (factoryb-water 57)
  (lmhcitya-tfrag 58)
  (mhcitya-pris 59)
  (rubblea-water 60)
  (rubblea2-water 61)
  (rubbleb-water 62)
  (rubblec-water 63)
  (foresta-water 64)
  (forestb-water 65)
  (lforplnt-pris 66)
  (ltnfxhip 67)
  (lgunnorm-water 68)
  (ljkdxvin 69)
  (security 70)
  (waspal-water 71)
  (mined-tfrag 72)
  (volcanox-warp 73)
  (templex-water 74)
  (volcanoa-water 75)
  (deshover 76)
  (clouds-and-fog 77) ;; same as jak 2
  (clouds-hires 78)
  (set-alpha 79)
  )

(deftype texture-anim-pc-upload (structure)
  ((data pointer)
   (width uint16)
   (height uint16)
   (dest uint32)
   (format gs-psm)
   (force-to-gpu uint8)
   (pad uint8 2)
   )
  :size-assert 16
  )

(deftype texture-anim-pc-texture-transform (structure)
  ((src-tbp uint32)
   (dest-tbp uint32)
   (pad0 uint32)
   (pad1 uint32)
   )
  )

(defmacro pc-texture-anim-flag (kind buf &key (qwc 0))
  `(dma-buffer-add-cnt-vif2
     ,buf
     ,qwc
     (new 'static 'vif-tag :cmd (vif-cmd pc-port) :imm (texture-anim-pc ,kind))
     (new 'static 'vif-tag)
     )
  )

(defmacro pc-texture-anim-flag-id (kind buf &key (qwc 0))
  `(dma-buffer-add-cnt-vif2
     ,buf
     ,qwc
     (new 'static 'vif-tag :cmd (vif-cmd pc-port) :imm ,kind)
     (new 'static 'vif-tag)
     )
  )

(defun texture-anim-layer-add-shader ((arg0 dma-buffer) (arg1 texture-anim-layer) (arg2 int))
  (format 0 "call to texture-anim-layer-add-shader~%")
  (break!)
  (none)
  )

;; WARN: Return type mismatch pointer vs none.
(defun texture-anim-layer-add-clut-shader ((arg0 dma-buffer) (arg1 texture-anim-layer) (arg2 int))
  (format 0 "call to texture-anim-layer-add-clut-shader~%")
  (break!)
  (none)
  )

;; WARN: Return type mismatch pointer vs none.
(defun texture-anim-layer-draw ((arg0 dma-buffer) (arg1 int) (arg2 int) (arg3 texture-anim-layer))
  (format 0 "call to texture-anim-layer-draw~%")
  (break!)
  (none)
  )

(defun default-texture-anim-layer-func ((arg0 dma-buffer) (arg1 uint) (arg2 int) (arg3 int) (arg4 texture-anim-layer) (arg5 float))
  (format 0 "call to default-texture-anim-layer-func~%")
  (break!)
  0
  )

(defun blend-clut-texture-anim-layer-func ((arg0 dma-buffer) (arg1 uint) (arg2 int) (arg3 int) (arg4 texture-anim-layer) (arg5 float))
  (format 0 "call to blend-clut-texture-anim-layer-func~%")
  (break!)
  0
  )

(defun add-clut-texture-anim-layer-func ((arg0 dma-buffer) (arg1 uint) (arg2 int) (arg3 int) (arg4 texture-anim-layer) (arg5 float))
  (format 0 "call to add-clut-texture-anim-layer-func~%")
  (break!)
  0
  )

(defun dest-blend-clut-texture-anim-layer-func ((arg0 dma-buffer) (arg1 uint) (arg2 int) (arg3 int) (arg4 texture-anim-layer) (arg5 float))
  (format 0 "call to dest-blend-clut-texture-anim-layer-func~%")
  (break!)
  0
  )

(defun move-rg-to-ba-texture-anim-layer-func ((arg0 dma-buffer) (arg1 uint) (arg2 int) (arg3 int) (arg4 texture-anim-layer) (arg5 float))
  (format 0 "call to move-rg-to-ba-texture-anim-layer-func~%")
  (break!)
  0
  )

(defun fill-rgb-texture-anim-layer-func ((arg0 dma-buffer) (arg1 uint) (arg2 int) (arg3 int) (arg4 texture-anim-layer) (arg5 float))
  (format 0 "call to fill-rgb-texture-anim-layer-func~%")
  (break!)
  0
  )

;; WARN: Return type mismatch pointer vs none.
(defun texture-anim-draw-mip-shader ((arg0 dma-buffer) (arg1 texture) (arg2 int))
  (format 0 "call to texture-anim-draw-mip-shader~%")
  (break!)
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun clear-texture-ids ((arg0 texture))
  (let ((v1-0 (-> arg0 w))
        (a1-0 (-> arg0 h))
        )
    (dotimes (a2-0 (the-as int (-> arg0 num-mips)))
      (let* ((a3-0 (- a2-0))
             (t0-1 (ash v1-0 a3-0))
             (t1-2 (ash a1-0 a3-0))
             (t2-0 (shr (-> arg0 dest a2-0) 5))
             (a3-6 (min 128 (the-as int (shr t2-0 1))))
             (t0-4 (* (/ (+ t0-1 63) 64) (/ (+ t1-2 63) 64)))
             )
        (if (and (logtest? t2-0 1) (< 32 v1-0))
            (+! t0-4 1)
            )
        (let ((t1-10 a3-6)
              (t2-2 (min 128 (+ t0-4 -1 a3-6)))
              )
          (while (>= (the-as uint t2-2) (the-as uint t1-10))
            (set! (-> *texture-pool* ids t1-10) (the-as uint 0))
            (+! t1-10 1)
            )
          )
        )
      )
    )
  (none)
  )


(defun texture-anim-draw-mips ((arg0 dma-buffer) (arg1 texture))
  (none)
  )

(defun pc-update-anim-frame-time ((anim texture-anim))
  (when (not (paused?))
    (with-pp
      (let ((f0-2 (+ (-> anim frame-time) (* (-> anim frame-delta) (seconds-per-frame))))
            (f1-2 (-> anim frame-mod))
            )
        (set! (-> anim frame-time) (- f0-2 (* (the float (the int (/ f0-2 f1-2))) f1-2)))
        )
      (if (< (-> anim frame-time) 0.0)
          (+! (-> anim frame-time) (-> anim frame-mod))
          )
      )
    )
  )

;; og:preserve-this
(defun pc-update-fixed-anim ((bucket bucket-id) (anim-id texture-anim-pc) (anim-array texture-anim-array))
  "Run a 'fixed' texture-anim, which should run entirely in C++."
  (with-dma-buffer-add-bucket ((dma-buf (-> *display* frames (-> *display* on-screen) global-buf))
                               bucket
                               )
    ;; determine how many texture we have:
    (let ((num-anims 0)
          (num-qwc-floats 0))
      (dotimes (i (-> anim-array length))
        (when (-> anim-array array-data i tex)
          (+! num-anims 1)
          (+! num-qwc-floats 1) ;; for times
          (+! num-qwc-floats (* 10 (-> anim-array array-data i num-layers)))
          )
        )

      ;; (format 0 "pc-update-fixed-anim: ~d layers~%" num)
      (pc-texture-anim-flag start-anim-array dma-buf)
      (pc-texture-anim-flag-id anim-id dma-buf :qwc num-qwc-floats)

      (let ((out-ptr (the (inline-array vector) (-> dma-buf base)))
            )
        (dotimes (i num-anims)
          (let ((anim (-> anim-array array-data i))
                (out-slot (the (pointer float) (&+ (-> dma-buf base) (* 11 16 i))))
                )

            (set! (-> out-ptr 0 x) (-> anim frame-time))
            (set! (-> out-ptr 0 y) (the-as float (if (-> anim tex)
                                                     (-> anim tex dest 0)
                                                     -1
                                                     )
                                           )
                  )
            (&+! out-ptr 16)

            (dotimes (j (-> anim num-layers))
              (quad-copy! (the pointer out-ptr) (the pointer (-> anim data j start-vectors)) 5)
              (&+! out-ptr 80)
              (quad-copy! (the pointer out-ptr) (the pointer (-> anim data j end-vectors)) 5)
              (&+! out-ptr 80)
              )

            (when (-> anim func)
              ((-> anim func) dma-buf anim)
              )
            (pc-update-anim-frame-time anim)
            )
          )
        )

      (&+! (-> dma-buf base) (* 16 num-qwc-floats))
      (pc-texture-anim-flag finish-anim-array dma-buf)
      )
    )

  (none)
  )

(deftype sky-input (structure)
  ((fog-height  float)
   (cloud-min   float)
   (cloud-max   float)
   (times       float 11)
   (max-times   float 6)
   (scales      float 6)
   (cloud-dest  int32)
   )
  )

(define-extern *sky-texture-anim-array* (texture-anim-array texture-anim))
;; og:preserve-this
(#when PC_PORT
  (define-extern *sky-hires-texture-anim-array* (texture-anim-array texture-anim)))
(define-extern *darkjak-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *darkjak-highres-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *skull-gem-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *default-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *default-warp-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *templea-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *templea-warp-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *templeb-warp-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *templec-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewc-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewd-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewe-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewg-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewh-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewi-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewj-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewl-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewm-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *sewn-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *desresc-warp-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *ctyslumb-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *nstb-quicksand-anim-array* (texture-anim-array texture-anim))
(define-extern *ctyslumc-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *factoryc-alpha-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *hfrag-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *hanga-sprite-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *hanga-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *desertd-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *lmhcityb-tfrag-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *towerb-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *comb-field-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *wasstada-alpha-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *factoryb-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *lmhcitya-tfrag-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *mhcitya-pris-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *rubblea-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *rubblea2-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *rubbleb-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *rubblec-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *foresta-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *forestb-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *lforplnt-pris-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *ltnfxhip-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *lgunnorm-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *ljkdxvin-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *security-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *waspal-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *mined-tfrag-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *volcanox-warp-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *templex-water-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *volcanoa-alpha-texture-anim-array* (texture-anim-array texture-anim))
(define-extern *deshover-texture-anim-array* (texture-anim-array texture-anim))

(defun make-sky-input ((si sky-input))
  (set! (-> si fog-height) (-> (the-as (array texture-anim) *sky-texture-anim-array*) 8 extra z))
  (set! (-> si cloud-min)  (-> *sky-texture-anim-array* array-data 7 extra y))
  (set! (-> si cloud-max)  (-> *sky-texture-anim-array* array-data 7 extra z))
  (set! (-> si cloud-dest) (the int (-> *sky-texture-anim-array* array-data 6 tex dest 0)))
  (dotimes (i (-> *sky-texture-anim-array* array-data 5 num-layers))
    (set! (-> si scales i) (-> *sky-texture-anim-array* array-data 5 data i start-color w))
    (set! (-> si max-times i) (-> *sky-texture-anim-array* array-data (1+ i) frame-mod))
    )
  (dotimes (i 9)
    (set! (-> si times i)
          (-> *sky-texture-anim-array* array-data i frame-time)
          )
    )
  )

(defun make-sky-hires-input ((si sky-input))
  (set! (-> si fog-height) (-> (the (array texture-anim) *sky-hires-texture-anim-array*) 10 extra z))
  (set! (-> si cloud-min)  (-> *sky-hires-texture-anim-array* array-data 9 extra y))
  (set! (-> si cloud-max)  (-> *sky-hires-texture-anim-array* array-data 9 extra z))
  (set! (-> si cloud-dest) (the int (-> *sky-hires-texture-anim-array* array-data 8 tex dest 0)))
  (dotimes (i (-> *sky-hires-texture-anim-array* array-data 7 num-layers))
    (set! (-> si scales i) (-> *sky-hires-texture-anim-array* array-data 7 data i start-color w))
    (set! (-> si max-times i) (-> *sky-hires-texture-anim-array* array-data (1+ i) frame-mod))
    )
  (dotimes (i 11)
    (set! (-> si times i)
          (-> *sky-hires-texture-anim-array* array-data i frame-time)
          )
    )
  )

(defmacro print-anim (&rest args)
  ;`(format 0 ,@args)
  0
  )

(defun pc-clut-blender ((bucket bucket-id) (id texture-anim-pc) (anim-array texture-anim-array))
  (let* ((sz (-> anim-array length))
         (qwc (+ 1 (/ (+ 3 sz) 4))))
    (with-dma-buffer-add-bucket ((dma-buf (-> *display* frames (-> *display* on-screen) global-buf))
                                 bucket
                                 )
                                (pc-texture-anim-flag start-anim-array dma-buf)
                                (pc-texture-anim-flag-id id dma-buf :qwc qwc)
                                (let ((morph (-> anim-array array-data 0 frame-time))
                                      (vec (the vector (-> dma-buf base)))
                                      )
                                  (set! (-> vec x) morph)
                                  )
                                (&+! (-> dma-buf base) 16)
                                (dotimes (i sz)
                                  (let ((tex (-> anim-array array-data i tex)))
                                    (set! (-> (the (pointer uint32) (-> dma-buf base)) i)
                                          (if tex (-> tex dest 0)
                                              -1)
                                          )
                                    )
                                 )
                                (&+! (-> dma-buf base) (- (* 16 qwc) 16))
                                (pc-texture-anim-flag finish-anim-array dma-buf)
                                )
    )
  (none)
  )

;; WARN: Function update-texture-anim has a return type of none, but the expression builder found a return statement.
(defun update-texture-anim ((bucket bucket-id) (anim-array texture-anim-array))
  (let ((anim-idx 0))
    (local-vars (sv-16 int) (sv-32 int) (sv-48 uint) (sv-64 int))

    ;; first, try PC ported animations.
    (case anim-array
          ((0)
           (format 0 "ZERO texture-anim-array - is there an animation array missing?~%")
           (return #f)
           )
          ((*sky-texture-anim-array*)
           (when (= bucket (bucket-id tex-lcom-sky-post))
             ;; og:preserve-this
             ;; skip. I believe this is only used to generate the envmap texture for the ocean.
             ;; it generates the exact same thing, so if we want this on PC one day, we can just
             ;; steal if from the beginning of the frame.
             (return #f)
             )
           (with-dma-buffer-add-bucket ((dma-buf (-> *display* frames (-> *display* on-screen) global-buf))
                                        bucket
                                        )
             (pc-texture-anim-flag start-anim-array dma-buf)
             (pc-texture-anim-flag clouds-and-fog dma-buf :qwc (/ (psize-of sky-input) 16))
             (make-sky-input (the sky-input (-> dma-buf base)))
             (&+! (-> dma-buf base) (psize-of sky-input))
             (pc-texture-anim-flag finish-anim-array dma-buf)
             (dotimes (i 8) ;; intentially skipping fog here!!
               (pc-update-anim-frame-time (-> *sky-texture-anim-array* array-data i))
               )
             )
           ;; falling through on purpose (TODO)
           (set! anim-idx 8) ;; fog
           ;; (return #f)
           )
          ((*sky-hires-texture-anim-array*)
           (when (= bucket (bucket-id tex-lcom-sky-post))
             ;; skip. I believe this is only used to generate the envmap texture for the ocean.
             ;; it generates the exact same thing, so if we want this on PC one day, we can just
             ;; steal if from the beginning of the frame.
             (return #f)
             )
           (with-dma-buffer-add-bucket ((dma-buf (-> *display* frames (-> *display* on-screen) global-buf))
                                         bucket
                                         )
             (pc-texture-anim-flag start-anim-array dma-buf)
             (pc-texture-anim-flag clouds-hires dma-buf :qwc (/ (psize-of sky-input) 16))
             (make-sky-hires-input (the sky-input (-> dma-buf base)))
             (&+! (-> dma-buf base) (psize-of sky-input))
             (pc-texture-anim-flag finish-anim-array dma-buf)
             (dotimes (i 10) ;; intentially skipping fog here!!
               (pc-update-anim-frame-time (-> *sky-hires-texture-anim-array* array-data i))
               )
             )
           ;; falling through on purpose
           (set! anim-idx 10) ;; fog
           ; (return #f)
           )
          ((*darkjak-texture-anim-array*)
           (pc-clut-blender bucket (texture-anim-pc darkjak) anim-array)
           (return #f)
           )
          ((*darkjak-highres-texture-anim-array*)
           (pc-clut-blender bucket (texture-anim-pc darkjak-highres) anim-array)
           (return #f)
           )
          ((*skull-gem-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc skull-gem) anim-array)
           (return #f)
           )
          ((*default-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc default-water) anim-array)
           (return #f)
           )
          ((*default-warp-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc default-warp) anim-array)
           (return #f)
           )
          ((*templea-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc templea-water) anim-array)
           (return #f)
           )
          ((*templea-warp-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc templea-warp) anim-array)
           (return #f)
           )
          ((*templeb-warp-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc templeb-warp) anim-array)
           (return #f)
           )
          ((*templec-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc templec-water) anim-array)
           (return #f)
           )
          ((*sewc-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewc-water) anim-array)
           (return #f)
           )
          ((*sewd-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewd-water) anim-array)
           (return #f)
           )
          ((*sewe-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewe-water) anim-array)
           (return #f)
           )
          ((*sewg-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewg-water) anim-array)
           (return #f)
           )
          ((*sewh-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewh-water) anim-array)
           (return #f)
           )
          ((*sewi-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewi-water) anim-array)
           (return #f)
           )
          ((*sewj-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewj-water) anim-array)
           (return #f)
           )
          ((*sewl-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewl-water) anim-array)
           (return #f)
           )
          ((*sewm-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewm-water) anim-array)
           (return #f)
           )
          ((*sewn-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc sewn-water) anim-array)
           (return #f)
           )
          ((*desresc-warp-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc desresc-warp) anim-array)
           (return #f)
           )
          ((*ctyslumb-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc ctyslumb-water) anim-array)
           (return #f)
           )
          ((*nstb-quicksand-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc nstb-quicksand) anim-array)
           (return #f)
           )
          ((*ctyslumc-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc ctyslumc-water) anim-array)
           (return #f)
           )
          ((*factoryc-alpha-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc factoryc-alpha) anim-array)
           (return #f)
           )
          ((*hfrag-texture-anim-array*)
           ; (pc-update-fixed-anim bucket (texture-anim-pc hfrag) anim-array)
           (return #f)
           )
          ((*hanga-sprite-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc hanga-sprite) anim-array)
           (return #f)
           )
          ((*hanga-water-texture-anim-array*)
           ;; missing destination texture
           ; (pc-update-fixed-anim bucket (texture-anim-pc hanga-water) anim-array)
           (return #f)
           )
          ((*desertd-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc desertd-water) anim-array)
           (return #f)
           )
          ((*lmhcityb-tfrag-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc lmhcityb-tfrag) anim-array)
           (return #f)
           )
          ((*towerb-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc towerb-water) anim-array)
           (return #f)
           )
          ((*comb-field-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc comb-field) anim-array)
           (return #f)
           )
          ((*wasstada-alpha-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc wasstada-alpha) anim-array)
           (return #f)
           )
          ((*factoryb-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc factoryb-water) anim-array)
           (return #f)
           )
          ((*lmhcitya-tfrag-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc lmhcitya-tfrag) anim-array)
           (return #f)
           )
          ((*mhcitya-pris-texture-anim-array*)
           ;; missing destination texture
           ; (pc-update-fixed-anim bucket (texture-anim-pc mhcitya-pris) anim-array)
           (return #f)
           )
          ((*rubblea-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc rubblea-water) anim-array)
           (return #f)
           )
          ((*rubblea2-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc rubblea2-water) anim-array)
           (return #f)
           )
          ((*rubbleb-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc rubbleb-water) anim-array)
           (return #f)
           )
          ((*rubblec-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc rubblec-water) anim-array)
           (return #f)
           )
          ((*foresta-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc foresta-water) anim-array)
           (return #f)
           )
          ((*forestb-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc forestb-water) anim-array)
           (return #f)
           )
          ((*lforplnt-pris-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc lforplnt-pris) anim-array)
           (return #f)
           )
          ((*ltnfxhip-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc ltnfxhip) anim-array)
           (return #f)
           )
          ((*lgunnorm-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc lgunnorm-water) anim-array)
           (return #f)
           )
          ((*ljkdxvin-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc ljkdxvin) anim-array)
           (return #f)
           )
          ((*security-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc security) anim-array)
           (return #f)
           )
          ((*waspal-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc waspal-water) anim-array)
           (return #f)
           )
          ((*mined-tfrag-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc mined-tfrag) anim-array)
           (return #f)
           )
          ((*volcanox-warp-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc volcanox-warp) anim-array)
           (return #f)
           )
          ((*templex-water-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc templex-water) anim-array)
           (return #f)
           )
          ((*volcanoa-alpha-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc volcanoa-water) anim-array)
           (return #f)
           )
          ((*deshover-texture-anim-array*)
           (pc-update-fixed-anim bucket (texture-anim-pc deshover) anim-array)
           (return #f)
           )
          (else
            (format 0 "Unhandled texture animation!~%")
            (break!)
            (return #f)
            )
          )

    (if (get-menu-mode *blit-displays-work*)
        (return #f)
        )
    (let ((v1-3 *display*)
          (a0-2 16)
          )
      (+! (-> v1-3 mem-reserve-size) a0-2)
      (when (not (-> v1-3 dma-buffer-overflow))
        (let ((a2-0 (-> v1-3 frames (-> v1-3 on-screen) global-buf)))
          (if (< (-> a2-0 real-buffer-end) (the-as int (&+ (-> a2-0 base) a0-2)))
              (set! (-> v1-3 dma-buffer-overflow) #t)
              )
          )
        (when (not (-> v1-3 dma-buffer-overflow))
          (with-dma-buffer-add-bucket ((s3-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                       bucket
                                       )

            ;; start of "emulated" texture anim data
            (pc-texture-anim-flag start-anim-array s3-0)

            ;;(dotimes (anim-idx (-> arg1 length))
            (while (< anim-idx (-> anim-array length))
              (let* ((s1-0 (-> anim-array array-data anim-idx))
                     (s0-0 (-> s1-0 tex))
                     )
                (when s0-0
                  0
                  (set! sv-16 (-> s0-0 w))
                  (set! sv-32 (-> s0-0 h))
                  (cond
                    ((or (= (-> s0-0 psm) (gs-psm ct32)) (= (-> s0-0 psm) (gs-psm mt8h)))
                     (set! sv-48 (shr (-> s0-0 dest 0) 5))
                     (clear-texture-ids s0-0)
                     )
                    (else
                      (set! sv-48 (shr (-> s0-0 clutdest) 5))
                      (set! sv-16 16)
                      (set! sv-32 16)
                      (set! (-> *texture-pool* ids (min 128 (the-as int (/ (the-as int sv-48) 2)))) (the-as uint 0))
                      0
                      )
                    )
                  (when (and (nonzero? sv-16) (nonzero? sv-32))
                    (pc-texture-anim-flag erase-and-init s3-0)
                    (let ((v1-34 *display*)
                          (a0-13 176)
                          )
                      (+! (-> v1-34 mem-reserve-size) a0-13)
                      (when (not (-> v1-34 dma-buffer-overflow))
                        (let ((a2-2 (-> v1-34 frames (-> v1-34 on-screen) global-buf)))
                          (if (< (-> a2-2 real-buffer-end) (the-as int (&+ (-> a2-2 base) a0-13)))
                              (set! (-> v1-34 dma-buffer-overflow) #t)
                              )
                          )
                        (if (not (-> v1-34 dma-buffer-overflow))
                            (dma-buffer-add-gs-set-flusha s3-0
                                                          (scissor-1 (new 'static 'gs-scissor :scax1 (+ sv-16 -1) :scay1 (+ sv-32 -1)))
                                                          (xyoffset-1 (new 'static 'gs-xy-offset :ofx #x8000 :ofy #x8000))
                                                          (frame-1 (new 'static 'gs-frame :fbw (/ (+ sv-16 63) 64) :fbp sv-48))
                                                          (test-1 (-> s1-0 test))
                                                          (alpha-1 (-> s1-0 alpha))
                                                          (clamp-1 (-> s1-0 clamp))
                                                          (texa (new 'static 'gs-texa :ta0 #x80 :ta1 #x80))
                                                          (zbuf-1 (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1))
                                                          (texflush 0)
                                                          )
                            )
                        )
                      )
                    (let ((v1-39 *display*)
                          (a0-22 80)
                          )
                      (+! (-> v1-39 mem-reserve-size) a0-22)
                      (when (not (-> v1-39 dma-buffer-overflow))
                        (let ((a2-13 (-> v1-39 frames (-> v1-39 on-screen) global-buf)))
                          (if (< (-> a2-13 real-buffer-end) (the-as int (&+ (-> a2-13 base) a0-22)))
                              (set! (-> v1-39 dma-buffer-overflow) #t)
                              )
                          )
                        (when (not (-> v1-39 dma-buffer-overflow))
                          (let ((v1-41 (-> s3-0 base))
                                (a3-0 2048)
                                (a2-15 2048)
                                (a0-27 (+ sv-16 2048))
                                (a1-63 (+ sv-32 2048))
                                )
                            (set! (-> (the-as (pointer uint128) v1-41)) (-> *texture-anim-work* erase-tmpl dma-vif quad))
                            (set! (-> (the-as (pointer uint128) v1-41) 1) (-> *texture-anim-work* erase-tmpl quad 1))
                            (set-vector!
                              (the-as vector4w (&+ v1-41 32))
                              (the-as int (-> s1-0 color r))
                              (the-as int (-> s1-0 color g))
                              (the-as int (-> s1-0 color b))
                              (the-as int (-> s1-0 color a))
                              )
                            (set-vector! (the-as vector4w (&+ v1-41 48)) (* a3-0 16) (* a2-15 16) #xffffff 0)
                            (set-vector! (the-as vector4w (&+ v1-41 64)) (* a0-27 16) (* a1-63 16) #xffffff 0)
                            )
                          (&+! (-> s3-0 base) 80)
                          )
                        )
                      )
                    )
                  (set! sv-64 0)
                  (while (< sv-64 (the-as int (-> s1-0 num-layers)))
                    (let ((t0-6 (-> s1-0 data sv-64)))
                      ((-> t0-6 func) s3-0 sv-48 sv-16 sv-32 t0-6 (-> s1-0 frame-time))
                      )
                    (set! sv-64 (+ sv-64 1))
                    )
                  (if (-> s1-0 func)
                      ((-> s1-0 func) s3-0 s1-0)
                      )
                  (if (and (= (-> s0-0 psm) (gs-psm ct32)) (< (the-as uint 1) (-> s0-0 num-mips)))
                      (texture-anim-draw-mips s3-0 s0-0)
                      )
                  (when (not (paused?))
                    (let ((f0-2 (+ (-> s1-0 frame-time) (* (-> s1-0 frame-delta) (seconds-per-frame))))
                          (f1-2 (-> s1-0 frame-mod))
                          )
                      (set! (-> s1-0 frame-time) (- f0-2 (* (the float (the int (/ f0-2 f1-2))) f1-2)))
                      )
                    (if (< (-> s1-0 frame-time) 0.0)
                        (+! (-> s1-0 frame-time) (-> s1-0 frame-mod))
                        )
                    )
                  )
                )
              (+! anim-idx 1)

              )
            ;;(reset-display-gs-state *display* s3-0)

            (dma-buffer-add-cnt-vif2
              s3-0
              0
              (new 'static 'vif-tag :cmd (vif-cmd pc-port) :imm (texture-anim-pc finish-anim-array))
              (new 'static 'vif-tag :cmd (vif-cmd pc-port))
              )
            )
          )
        )
      )
    )
  (none)
  )

(defun no-alpha-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Like others, but the tcc value is 0"
  (when (and (>= time (-> layer start-time)) (>= (-> layer end-time) time))
    (texture-anim-layer-interp layer time)
    (when (!= (-> layer interpolated-color w) 0.0)
      (texture-anim-layer-add-shader dma-buf layer 0)
      (texture-anim-layer-draw dma-buf width height layer)
      )
    )
  0
  )

(defun copy-alpha-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Copy only alpha from the layer source texture. Does a draw, possibly blending if that's how the layer is configured.
   Draw is always axis aligned, full size."
  (when (and (>= time (-> layer start-time)) (>= (-> layer end-time) time))

    ;; compute layer values for this frame
    (texture-anim-layer-interp layer time)

    (let ((s4-0 (/ (+ width 63) 64)))
      ;; set up fbmask for alpha only
      (dma-buffer-add-gs-set dma-buf (frame-1 (new 'static 'gs-frame :fbmsk #xffffff :fbw s4-0 :fbp fbp-to-draw)))
      ;; set up shader to sample from the layer's texture
      (texture-anim-layer-add-shader dma-buf layer 1)

      (let ((v1-7 (-> dma-buf base))
            (a2-6 #x8000)
            (a3-1 #x8000)
            (a0-10 (* (+ width 2048) 16))
            (a1-14 (* (+ height 2048) 16))
            )
        ;; generate drawing.
        (set! (-> (the-as (pointer uint128) v1-7)) (-> *texture-anim-work* draw-tmpl dma-vif quad))
        (set! (-> (the-as (pointer uint128) v1-7) 1) (-> *texture-anim-work* draw-tmpl quad 1))
        (set-vector! (the-as vector4w (&+ v1-7 32)) 128 128 128 (the int (* 128.0 (-> layer interpolated-color w))))
        (set-vector! (the-as vector (&+ v1-7 48)) 0.0 0.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ v1-7 64)) a2-6 a3-1 #xffffff 0)
        (set-vector! (the-as vector (&+ v1-7 80)) 1.0 0.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ v1-7 96)) a0-10 a3-1 #xffffff 0)
        (set-vector! (the-as vector (&+ v1-7 112)) 0.0 1.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ v1-7 128)) a2-6 a1-14 #xffffff 0)
        (set-vector! (the-as vector (&+ v1-7 144)) 1.0 1.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ v1-7 160)) a0-10 a1-14 #xffffff 0)
        )
      (&+! (-> dma-buf base) 176)

      ;; reset frame.
      (dma-buffer-add-gs-set dma-buf
                             (frame-1 (new 'static 'gs-frame :fbw s4-0 :fbp fbp-to-draw))
                             )
      ; (let* ((v1-11 dma-buf)
      ;        (a0-12 (the-as dma-packet (-> v1-11 base)))
      ;        )
      ;   (set! (-> a0-12 dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
      ;   (set! (-> a0-12 vif0) (new 'static 'vif-tag))
      ;   (set! (-> a0-12 vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
      ;   (set! (-> v1-11 base) (the-as pointer (&+ a0-12 16)))
      ;   )
      ; (let* ((v1-12 dma-buf)
      ;        (a0-14 (the-as object (-> v1-12 base)))
      ;        )
      ;   (set! (-> (the-as gs-gif-tag a0-14) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
      ;   (set! (-> (the-as gs-gif-tag a0-14) regs) GIF_REGS_ALL_AD)
      ;   (set! (-> v1-12 base) (&+ (the-as pointer a0-14) 16))
      ;   )
      ; (let ((v1-13 (-> dma-buf base)))
      ;   (set! (-> (the-as (pointer gs-frame) v1-13) 0) (new 'static 'gs-frame :fbw s4-0 :fbp fbp-to-draw))
      ;   (set! (-> (the-as (pointer gs-reg64) v1-13) 1) (gs-reg64 frame-1))
      ;   (set! (-> dma-buf base) (&+ v1-13 16))
      ;   )
      )
    )
  0
  )

(defun copy-clut-alpha-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Copy only alpha from the layer source clut."

  (pc-texture-anim-flag copy-clut-alpha dma-buf :qwc 1)
  (let ((transform (the texture-anim-pc-texture-transform (-> dma-buf base))))
    (set! (-> transform src-tbp) (-> layer tex dest 0))
    (set! (-> transform dest-tbp) (* 32 fbp-to-draw))
    (set! (-> transform pad0) 0)
    (set! (-> transform pad1) 0)
    )
  (&+! (-> dma-buf base) 16)
  (return 0)

  (when (and (>= time (-> layer start-time)) (>= (-> layer end-time) time))
    (texture-anim-layer-interp layer time)
    (let ((s4-0 1))
      (dma-buffer-add-gs-set dma-buf (frame-1 (new 'static 'gs-frame :fbmsk #xffffff :fbw s4-0 :fbp fbp-to-draw)))
      (texture-anim-layer-add-clut-shader dma-buf layer 1)
      (let ((a1-13 (-> dma-buf base))
            (a2-6 #x8000)
            (a3-1 #x8000)
            (v1-6 #x8100)
            (a0-9 #x8100)
            )
        (set! (-> (the-as (pointer uint128) a1-13)) (-> *texture-anim-work* draw-tmpl dma-vif quad))
        (set! (-> (the-as (pointer uint128) a1-13) 1) (-> *texture-anim-work* draw-tmpl quad 1))
        (set-vector! (the-as vector4w (&+ a1-13 32)) 128 128 128 (the int (* 128.0 (-> layer interpolated-color w))))
        (set-vector! (the-as vector (&+ a1-13 48)) 0.0 0.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ a1-13 64)) a2-6 a3-1 #xffffff 0)
        (set-vector! (the-as vector (&+ a1-13 80)) 1.0 0.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ a1-13 96)) v1-6 a3-1 #xffffff 0)
        (set-vector! (the-as vector (&+ a1-13 112)) 0.0 1.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ a1-13 128)) a2-6 a0-9 #xffffff 0)
        (set-vector! (the-as vector (&+ a1-13 144)) 1.0 1.0 1.0 0.0)
        (set-vector! (the-as vector4w (&+ a1-13 160)) v1-6 a0-9 #xffffff 0)
        )
      (&+! (-> dma-buf base) 176)
      (dma-buffer-add-gs-set dma-buf
                             (frame-1 (new 'static 'gs-frame :fbw s4-0 :fbp fbp-to-draw))
                             )
      ; (let* ((v1-10 dma-buf)
      ;        (a0-10 (the-as dma-packet (-> v1-10 base)))
      ;        )
      ;   (set! (-> a0-10 dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
      ;   (set! (-> a0-10 vif0) (new 'static 'vif-tag))
      ;   (set! (-> a0-10 vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
      ;   (set! (-> v1-10 base) (the-as pointer (the-as dma-packet (&+ a0-10 16))))
      ;   )
      ; (let* ((v1-11 dma-buf)
      ;        (a0-12 (the-as object (-> v1-11 base)))
      ;        )
      ;   (set! (-> (the-as gs-gif-tag a0-12) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
      ;   (set! (-> (the-as gs-gif-tag a0-12) regs) GIF_REGS_ALL_AD)
      ;   (set! (-> v1-11 base) (&+ (the-as pointer a0-12) 16))
      ;   )
      ; (let ((v1-12 (-> dma-buf base)))
      ;   (set! (-> (the-as (pointer gs-frame) v1-12) 0) (new 'static 'gs-frame :fbw s4-0 :fbp fbp-to-draw))
      ;   (set! (-> (the-as (pointer gs-reg64) v1-12) 1) (gs-reg64 frame-1))
      ;   (set! (-> dma-buf base) (&+ v1-12 16))
      ;   )
      )
    )
  0
  )

(defun set-alpha-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Set alpha to 128 for the texture."

  ;; PC version
  (pc-texture-anim-flag set-alpha dma-buf :qwc 1)
  (let ((transform (the texture-anim-pc-texture-transform (-> dma-buf base))))
    (set! (-> transform src-tbp) (* 32 fbp-to-draw))
    (set! (-> transform dest-tbp) (* 32 fbp-to-draw))
    (set! (-> transform pad0) 0)
    (set! (-> transform pad1) 0)
    )
  (&+! (-> dma-buf base) 16)
  (return 0)

  (let ((v1-1 (/ (+ width 63) 64)))
    ;; make sure alpha test is off, and set frame to allow only alpha writes
    (dma-buffer-add-gs-set dma-buf
                           (test-1 (new 'static 'gs-test :ate #x1 :afail #x1 :zte #x1 :ztst (gs-ztest always)))
                           (frame-1 (new 'static 'gs-frame :fbmsk #xffffff :fbw v1-1 :fbp fbp-to-draw))
                           )
    ;; draw the sprite.
    (let ((t0-4 (-> dma-buf base))
          (t2-12 2048)
          (t1-7 2048)
          (a2-1 (+ width 2048))
          (a3-1 (+ height 2048))
          )
      (set! (-> (the-as (pointer uint128) t0-4)) (-> *texture-anim-work* erase-tmpl dma-vif quad))
      (set! (-> (the-as (pointer uint128) t0-4) 1) (-> *texture-anim-work* erase-tmpl quad 1))
      (set-vector! (the-as vector4w (&+ t0-4 32)) 0 0 0 128) ;; rgba
      (set-vector! (the-as vector4w (&+ t0-4 48)) (* t2-12 16) (* t1-7 16) #xffffff 0)
      (set-vector! (the-as vector4w (&+ t0-4 64)) (* a2-1 16) (* a3-1 16) #xffffff 0)
      )
    (&+! (-> dma-buf base) 80)
    (dma-buffer-add-gs-set dma-buf
                           (frame-1 (new 'static 'gs-frame :fbw v1-1 :fbp fbp-to-draw))
                           )
    0
    ; (let* ((a2-7 dma-buf)
    ;        (a3-2 (the-as object (-> a2-7 base)))
    ;        )
    ;   (set! (-> (the-as dma-packet a3-2) dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
    ;   (set! (-> (the-as dma-packet a3-2) vif0) (new 'static 'vif-tag))
    ;   (set! (-> (the-as dma-packet a3-2) vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
    ;   (set! (-> a2-7 base) (&+ (the-as pointer a3-2) 16))
    ;   )
    ; (let* ((a2-8 dma-buf)
    ;        (a3-4 (the-as object (-> a2-8 base)))
    ;        )
    ;   (set! (-> (the-as gs-gif-tag a3-4) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
    ;   (set! (-> (the-as gs-gif-tag a3-4) regs) GIF_REGS_ALL_AD)
    ;   (set! (-> a2-8 base) (&+ (the-as pointer a3-4) 16))
    ;   )
    ; (let ((a2-9 (-> dma-buf base)))
    ;   (set! (-> (the-as (pointer gs-frame) a2-9) 0) (new 'static 'gs-frame :fbw v1-1 :fbp fbp-to-draw))
    ;   (set! (-> (the-as (pointer gs-reg64) a2-9) 1) (gs-reg64 frame-1))
    ;   (let ((v0-0 (&+ a2-9 16)))
    ;     (set! (-> dma-buf base) v0-0)
    ;     (the-as int v0-0)
    ;     )
    ;   )
    )
  )

(defun set-clut-alpha-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Set clut alpha to 128."

  ;; PC version
  (pc-texture-anim-flag set-clut-alpha dma-buf :qwc 1)
    (let ((transform (the texture-anim-pc-texture-transform (-> dma-buf base))))
    (set! (-> transform src-tbp) (* 32 fbp-to-draw))
    (set! (-> transform dest-tbp) (* 32 fbp-to-draw))
    (set! (-> transform pad0) 0)
    (set! (-> transform pad1) 0)
    )
  (&+! (-> dma-buf base) 16)
  (return 0)


  (let ((v1-0 1))
    (dma-buffer-add-gs-set dma-buf
                           (test-1 (new 'static 'gs-test :ate #x1 :afail #x1 :zte #x1 :ztst (gs-ztest always)))
                           (frame-1 (new 'static 'gs-frame :fbmsk #xffffff :fbw v1-0 :fbp fbp-to-draw))
                           )
    (let ((t0-13 (-> dma-buf base))
          (t2-0 2048)
          (t1-5 2048)
          (a3-7 2064)
          (a2-4 2064)
          )
      (set! (-> (the-as (pointer uint128) t0-13)) (-> *texture-anim-work* erase-tmpl dma-vif quad))
      (set! (-> (the-as (pointer uint128) t0-13) 1) (-> *texture-anim-work* erase-tmpl quad 1))
      (set-vector! (the-as vector4w (&+ t0-13 32)) 0 0 0 128)
      (set-vector! (the-as vector4w (&+ t0-13 48)) (* t2-0 16) (* t1-5 16) #xffffff 0)
      (set-vector! (the-as vector4w (&+ t0-13 64)) (* a3-7 16) (* a2-4 16) #xffffff 0)
      )
    (&+! (-> dma-buf base) 80)
    (dma-buffer-add-gs-set dma-buf
                           (frame-1 (new 'static 'gs-frame :fbw v1-0 :fbp fbp-to-draw))
                           )
    0
    ; (let* ((a2-9 dma-buf)
    ;        (a3-9 (the-as object (-> a2-9 base)))
    ;        )
    ;   (set! (-> (the-as dma-packet a3-9) dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
    ;   (set! (-> (the-as dma-packet a3-9) vif0) (new 'static 'vif-tag))
    ;   (set! (-> (the-as dma-packet a3-9) vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
    ;   (set! (-> a2-9 base) (&+ (the-as pointer a3-9) 16))
    ;   )
    ; (let* ((a2-10 dma-buf)
    ;        (a3-11 (the-as object (-> a2-10 base)))
    ;        )
    ;   (set! (-> (the-as gs-gif-tag a3-11) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
    ;   (set! (-> (the-as gs-gif-tag a3-11) regs) GIF_REGS_ALL_AD)
    ;   (set! (-> a2-10 base) (&+ (the-as pointer a3-11) 16))
    ;   )
    ; (let ((a2-11 (-> dma-buf base)))
    ;   (set! (-> (the-as (pointer gs-frame) a2-11) 0) (new 'static 'gs-frame :fbw v1-0 :fbp fbp-to-draw))
    ;   (set! (-> (the-as (pointer gs-reg64) a2-11) 1) (gs-reg64 frame-1))
    ;   (let ((v0-0 (&+ a2-11 16)))
    ;     (set! (-> dma-buf base) v0-0)
    ;     (the-as int v0-0)
    ;     )
    ;   )
    )
  )

(defun dest-texture-init ((arg0 texture-anim))
  (let ((v1-1 (new 'loading-level 'texture)))
    (let ((a0-2 (the int (-> arg0 extra x))))
      (let ((a1-1 (the int (-> arg0 extra y))))
        (set! (-> arg0 tex) v1-1)
        (set! (-> v1-1 w) a0-2)
        (set! (-> v1-1 h) a0-2)
        (set! (-> v1-1 num-mips) (the-as uint 1))
        (set! (-> v1-1 psm) (gs-psm ct32))
        (set! (-> v1-1 dest 0) (the-as uint (* a1-1 32)))
        )
      (set! (-> v1-1 width 0) (the-as uint (/ (+ a0-2 63) 64)))
      )
    (set! (-> v1-1 masks data 0 mask quad) (the-as uint128 0))
    (set! (-> v1-1 masks data 1 mask quad) (the-as uint128 0))
    (set! (-> v1-1 masks data 2 mask quad) (the-as uint128 0))
    )
  0
  0
  (none)
  )

(defun src-texture-init ((arg0 texture-anim-layer))
  (let ((v1-1 (new 'loading-level 'texture)))
    (let ((a0-2 (the int (-> arg0 extra x))))
      (let ((a1-1 (the int (-> arg0 extra y))))
        (set! (-> arg0 tex) v1-1)
        (set! (-> v1-1 w) a0-2)
        (set! (-> v1-1 h) a0-2)
        (set! (-> v1-1 num-mips) (the-as uint 1))
        (set! (-> v1-1 psm) (gs-psm ct32))
        (set! (-> v1-1 dest 0) (the-as uint (* a1-1 32)))
        )
      (set! (-> v1-1 width 0) (the-as uint (/ (+ a0-2 63) 64)))
      )
    (set! (-> v1-1 masks data 0 mask quad) (the-as uint128 0))
    (set! (-> v1-1 masks data 1 mask quad) (the-as uint128 0))
    (set! (-> v1-1 masks data 2 mask quad) (the-as uint128 0))
    )
  0
  0
  (none)
  )

(defun src-texture-init-mt8 ((arg0 texture-anim-layer))
  (let ((v1-1 (new 'loading-level 'texture)))
    (let ((a0-2 (the int (-> arg0 extra x))))
      (let ((a1-1 (the int (-> arg0 extra y)))
            (a2-0 (the int (-> arg0 extra z)))
            (a3-0 (the int (-> arg0 extra w)))
            )
        (set! (-> arg0 tex) v1-1)
        (set! (-> v1-1 w) a0-2)
        (set! (-> v1-1 h) a1-1)
        (set! (-> v1-1 num-mips) (the-as uint 1))
        (set! (-> v1-1 psm) (gs-psm mt8))
        (set! (-> v1-1 dest 0) (the-as uint (* a2-0 32)))
        (set! (-> v1-1 clutpsm) (the-as uint 0))
        (set! (-> v1-1 clutdest) (the-as uint (* a3-0 32)))
        )
      (set! (-> v1-1 width 0) (the-as uint (/ (+ a0-2 63) 64)))
      )
    (set! (-> v1-1 masks data 0 mask quad) (the-as uint128 0))
    (set! (-> v1-1 masks data 1 mask quad) (the-as uint128 0))
    (set! (-> v1-1 masks data 2 mask quad) (the-as uint128 0))
    )
  0
  0
  (none)
  )

;; I copied this from jak 2- I don't think we need the data!
(defun make-noise-texture ((arg0 pointer) (arg1 int) (arg2 int) (arg3 int))
  "Generate 'random' noise texture."
  (local-vars (t4-5 uint128) (t5-3 uint128))
  (let ((v1-0 (/ arg1 16))
        (a3-1 (/ arg3 16))
        )
    (when (< arg1 16)
      (set! a3-1 1)
      (set! v1-0 1)
      (set! arg2 (/ (* arg2 arg1) 16))
      )
    (let* ((a1-5 *texture-anim-work*)
           (v0-0 (-> a1-5 random-index))
           )
      (dotimes (t0-1 arg2)
        (let ((t1-0 0))
          (goto cfg-6)
          (until (>= t1-0 v1-0)
            (let* ((t2-0 (* t0-1 a3-1))
                   (t3-0 (+ v0-0 3))
                   (t4-0 (+ v0-0 5))
                   (t5-0 (+ v0-0 7))
                   (t3-1 (logand t3-0 7))
                   (t4-1 (logand t4-0 7))
                   (t7-0 (logand t5-0 7))
                   (t6-0 (* v0-0 16))
                   (t5-1 (* t3-1 16))
                   (t4-2 (* t4-1 16))
                   (t3-2 (* t7-0 16))
                   (t2-1 (+ t2-0 t1-0))
                   (t6-1 (the-as object (+ t6-0 (the-as uint a1-5))))
                   (t2-2 (* t2-1 16))
                   (t7-1 (the-as object (+ t5-1 (the-as uint a1-5))))
                   (t5-2 (-> (the-as (pointer uint128) t6-1) 15))
                   (t4-3 (the-as object (+ t4-2 (the-as uint a1-5))))
                   (t6-2 (-> (the-as (pointer uint128) t7-1) 15))
                   (t3-3 (the-as object (+ t3-2 (the-as uint a1-5))))
                   )
              (let ((t4-4 (-> (the-as (pointer uint128) t4-3) 15)))
                (.paddb t5-3 t5-2 t6-2)
                (nop!)
                (.paddb t4-5 t5-3 t4-4)
                )
              (nop!)
              (let ((t2-3 (+ t2-2 (the-as int arg0))))
                (set! (-> (the-as (pointer uint128) t3-3) 15) t4-5)
                (let ((t3-4 (+ v0-0 1)))
                  (set! (-> (the-as (pointer uint128) t2-3) 0) t4-5)
                  (set! v0-0 (logand t3-4 7))
                  )
                )
              )
            (nop!)
            (+! t1-0 1)
            (label cfg-6)
            )
          )
        )
      (set! (-> a1-5 random-index) v0-0)
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun make-cloud-clut ((arg0 (pointer uint32)) (arg1 float) (arg2 float))
  (local-vars (v1-10 int))
  0
  (let* ((s5-0 (the int (* 255.0 arg1)))
         (s4-1 (max (the int (* 255.0 arg2)) s5-0))
         (f30-0 (/ 128.0 (the float (- s4-1 s5-0))))
         )
    (dotimes (s3-0 256)
      (let ((s2-0 (-> *clut-translate* s3-0)))
        (cond
          ((and (>= s5-0 s3-0) (nonzero? s4-1))
           (set! v1-10 0)
           )
          ((>= s3-0 s4-1)
           (set! v1-10 128)
           )
          (else
            (let* ((f0-9 (sin (* 128.0 (fmin 128.0 (* (the float (- s3-0 s5-0)) f30-0)))))
                   (f0-11 (* f0-9 f0-9))
                   )
              (set! v1-10 (the int (* 128.0 f0-11)))
              )
            )
          )
        (set! (-> arg0 s2-0) (logior (logand (-> arg0 s2-0) -256) 128))
        (set! (-> arg0 s2-0) (logior (logand (-> arg0 s2-0) -65281) #x8000))
        (set! (-> arg0 s2-0) (logior (logand (-> arg0 s2-0) -16711681) #x800000))
        (set! (-> arg0 s2-0)
              (logior (logand (-> arg0 s2-0) (the-as uint #xffffffff00ffffff)) (shr (shl v1-10 56) 32))
              )
        )
      )
    )
  (none)
  )

(defun texture-anim-cloud-clut-upload ((arg0 dma-buffer) (arg1 texture-anim))
  (format 0 "unsupported texture-anim-cloud-clut-upload~%")
  (break!)
  (none)
  )

(defun texture-anim-cloud-clut-init ((arg0 texture-anim))
  (let ((s5-0 (new 'loading-level 'texture))
        (s4-0 (the int (-> arg0 extra x)))
        (v1-2 (new 'loading-level 'clut16x16))
        )
    (set! (-> arg0 tex) s5-0)
    (set! (-> s5-0 clutdest) (the-as uint (* s4-0 32)))
    (set! (-> s5-0 pad 0) (the-as uint v1-2))
    )
  0
  (none)
  )

;; copied from jak 2- I don't think we need the data.
(define-extern *slime-clut* clut16x16)
(defun make-slime-clut ((arg0 (pointer uint32)))
  (dotimes (v1-0 256)
    (let ((a1-2 (-> *clut-translate* v1-0))
          (a2-2 (-> *slime-clut* clut v1-0))
          )
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) -256) (shr (shl (-> a2-2 r) 56) 56)))
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) -65281) (shr (shl (-> a2-2 g) 56) 48)))
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) -16711681) (shr (shl (-> a2-2 b) 56) 40)))
      (set! (-> arg0 a1-2)
            (logior (logand (-> arg0 a1-2) (the-as uint #xffffffff00ffffff)) (shr (shl (-> a2-2 a) 56) 32))
            )
      )
    )
  (none)
  )

(defun texture-anim-slime-clut-upload ((arg0 dma-buffer) (arg1 texture-anim))
  (format 0 "unsupported texture-anim-slime-clut-upload~%")
  (break!)
  (none)
  )

(defun texture-anim-slime-clut-init ((arg0 texture-anim))
  (let ((s5-0 (new 'loading-level 'texture))
        (s4-0 (the int (-> arg0 extra x)))
        (v1-2 (new 'loading-level 'clut16x16))
        )
    (set! (-> arg0 tex) s5-0)
    (set! (-> s5-0 clutdest) (the-as uint (* s4-0 32)))
    (set! (-> s5-0 pad 0) (the-as uint v1-2))
    )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun make-ramp-clut ((arg0 (pointer uint32)) (arg1 pointer) (arg2 object))
  (dotimes (v1-0 256)
    (let ((a1-3 (-> *clut-translate* v1-0)))
      (set! (-> arg0 a1-3) (logior (logand (-> arg0 a1-3) -256) (shr (shl v1-0 56) 56)))
      (set! (-> arg0 a1-3) (logior (logand (-> arg0 a1-3) -65281) (shr (shl v1-0 56) 48)))
      (set! (-> arg0 a1-3) (logior (logand (-> arg0 a1-3) -16711681) (shr (shl v1-0 56) 40)))
      (set! (-> arg0 a1-3) (logior (logand (-> arg0 a1-3) (the-as uint #xffffffff00ffffff)) (shr (shl v1-0 56) 32)))
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun make-alpha-ramp-clut ((arg0 (pointer uint32)))
  (dotimes (v1-0 256)
    (let ((a1-2 (-> *clut-translate* v1-0)))
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) -256) 128))
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) -65281) #x8000))
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) -16711681) #x800000))
      (set! (-> arg0 a1-2) (logior (logand (-> arg0 a1-2) (the-as uint #xffffffff00ffffff)) (shr (shl v1-0 56) 32)))
      )
    )
  (none)
  )

(defun noise-texture-init ((arg0 texture-anim-layer))
  (let ((gp-0 (the int (-> arg0 extra x)))
        (s4-0 (the-as structure #f))
        )
    (case gp-0
      ((8)
       (set! s4-0 (new 'loading-level 'noise8x8))
       )
      ((16)
       (set! s4-0 (new 'loading-level 'noise16x16))
       )
      ((32)
       (set! s4-0 (new 'loading-level 'noise32x32))
       )
      ((64)
       (set! s4-0 (new 'loading-level 'noise64x64))
       )
      ((128)
       (set! s4-0 (new 'loading-level 'noise128x128))
       )
      )
    (when s4-0
      (let ((v1-14 (new 'loading-level 'texture)))
        (let ((a0-16 (the int (-> arg0 extra y)))
              (a1-6 (the int (-> arg0 extra z)))
              )
          (set! (-> arg0 tex) v1-14)
          (set! (-> v1-14 pad 0) (the-as uint s4-0))
          (set! (-> v1-14 w) gp-0)
          (set! (-> v1-14 h) gp-0)
          (set! (-> v1-14 num-mips) (the-as uint 1))
          (set! (-> v1-14 psm) (gs-psm mt8))
          (set! (-> v1-14 clutpsm) (the-as uint 0))
          (set! (-> v1-14 dest 0) (the-as uint (* a0-16 32)))
          (set! (-> v1-14 clutdest) (the-as uint (* a1-6 32)))
          )
        (set! (-> v1-14 width 0) (the-as uint 1))
        (set! (-> v1-14 masks data 0 mask quad) (the-as uint128 0))
        (set! (-> v1-14 masks data 1 mask quad) (the-as uint128 0))
        (set! (-> v1-14 masks data 2 mask quad) (the-as uint128 0))
        (make-noise-texture (the-as pointer (-> v1-14 pad 0)) gp-0 gp-0 gp-0)
        )
      )
    )
  0
  (none)
  )

(defun texture-anim-alpha-ramp-clut-upload ((arg0 dma-buffer) (arg1 texture-anim))
  (format 0 "unsupported texture-anim-alpha-ramp-clut-upload~%")
  (break!)
  (none)
  )

(defun texture-anim-alpha-ramp-clut-init ((arg0 texture-anim))
  (let ((s5-0 (new 'loading-level 'texture))
        (s4-0 (the int (-> arg0 extra x)))
        (a0-3 (new 'loading-level 'clut16x16))
        )
    (set! (-> arg0 tex) s5-0)
    (set! (-> s5-0 clutdest) (the-as uint (* s4-0 32)))
    (set! (-> s5-0 pad 0) (the-as uint a0-3))
    (make-alpha-ramp-clut (the-as (pointer uint32) a0-3))
    )
  0
  (none)
  )

(defun texture-anim-overide-size-init ((arg0 texture-anim))
  (when (-> arg0 tex-name)
    (let ((v1-2 (lookup-level-texture-by-name
                  (-> arg0 tex-name)
                  (-> *level* loading-level)
                  (the-as (pointer texture-page) #f)
                  )
                )
          )
      (when v1-2
        (let ((a0-2 (the int (-> arg0 extra x))))
          (let ((a1-1 (the int (-> arg0 extra y)))
                (a2-1 (the int (-> arg0 extra z)))
                )
            (set! (-> v1-2 w) a0-2)
            (set! (-> v1-2 h) a1-1)
            (set! (-> v1-2 num-mips) (the-as uint a2-1))
            )
          (set! (-> v1-2 dest 0) (the-as uint #xffff))
          (set! (-> v1-2 width 0) (the-as uint (/ a0-2 64)))
          )
        (set! (-> v1-2 masks data 0 mask quad) (the-as uint128 0))
        (set! (-> v1-2 masks data 1 mask quad) (the-as uint128 0))
        (set! (-> v1-2 masks data 2 mask quad) (the-as uint128 0))
        0
        )
      )
    )
  (none)
  )

(defun texture-anim-change-mt8h-init ((arg0 texture-anim))
  (when (-> arg0 tex-name)
    (let ((v1-2 (lookup-level-texture-by-name
                  (-> arg0 tex-name)
                  (-> *level* loading-level)
                  (the-as (pointer texture-page) #f)
                  )
                )
          )
      (when v1-2
        (let ((a0-2 (the int (-> arg0 extra x)))
              (a1-1 (the int (-> arg0 extra y)))
              (a2-1 (the int (-> arg0 extra z)))
              )
          (let ((a3-0 (the int (-> arg0 extra w))))
            (set! (-> v1-2 clutdest) (the-as uint (* a0-2 32)))
            (set! (-> v1-2 clutpsm) (the-as uint 0))
            (set! (-> v1-2 dest 0) (the-as uint (* a1-1 32)))
            (set! (-> v1-2 psm) (gs-psm mt8h))
            (set! (-> v1-2 w) a2-1)
            (set! (-> v1-2 h) a3-0)
            )
          (set! (-> v1-2 width 0) (the-as uint (/ a2-1 64)))
          )
        (set! (-> v1-2 masks data 0 mask quad) (the-as uint128 0))
        (set! (-> v1-2 masks data 1 mask quad) (the-as uint128 0))
        (set! (-> v1-2 masks data 2 mask quad) (the-as uint128 0))
        0
        )
      )
    )
  (none)
  )

(defmethod init! ((this texture-anim-array))
  (dotimes (s5-0 (-> this length))
    (init-textures! (-> this array-data s5-0))
    )
  this
  )

(defmethod clear! ((this texture-anim-array))
  (dotimes (s5-0 (-> this length))
    (clear-textures! (-> this array-data s5-0))
    )
  this
  )

(define *texture-anim-pages-table*
  (new 'static 'array uint8 16 #x2 #x3 #x3 #x3 #x3 #x8 #xc #xd #xd #xd #x20 #x28 #x2a #x2b #x2b #x0)
  )

(define *texture-anim-mip-array* (new 'static 'array uint16 48
                                   #x0
                                   #x0
                                   #x0
                                   #x0
                                   #x0
                                   #x0
                                   #x1
                                   #x0
                                   #x0
                                   #x0
                                   #x0
                                   #x1
                                   #x2
                                   #x0
                                   #x0
                                   #x0
                                   #x1
                                   #x2
                                   #x3
                                   #x0
                                   #x0
                                   #x4
                                   #x5
                                   #x6
                                   #x7
                                   #x0
                                   #x10
                                   #x14
                                   #x15
                                   #x16
                                   #x0
                                   #x40
                                   #x50
                                   #x54
                                   #x55
                                   #x0
                                   #x100
                                   #x140
                                   #x150
                                   #x154
                                   #x0
                                   #x400
                                   #x500
                                   #x540
                                   #x550
                                   #x0
                                   #x0
                                   #x0
                                   )
        )

(defmethod init-textures! ((this texture-anim))
  (local-vars (a3-6 uint128) (sv-16 texture-page))
  (if (logtest? (the-as int (-> this func)) 1)
      (set! (-> this func)
            (the-as (function dma-buffer texture-anim int) (-> (the-as symbol (-> this func)) value))
            )
      )
  (if (logtest? (the-as int (-> this init-func)) 1)
      (set! (-> this init-func) (the-as (function texture-anim int) (-> (the-as symbol (-> this init-func)) value)))
      )
  (if (-> this init-func)
      ((-> this init-func) this)
      )
  (when (-> this tex-name)
    (set! sv-16 (the-as texture-page #f))
    (let ((s5-0 (lookup-level-texture-by-name (-> this tex-name) (-> *level* loading-level) (& sv-16))))
      (set! (-> this tex) s5-0)
      (when (and s5-0 sv-16)
        0
        (cond
          ((= (-> s5-0 psm) (gs-psm mt8))
           (let ((v1-21 (-> s5-0 clutdest)))
             (when (!= v1-21 (* (/ (the-as int v1-21) 32) 32))
               (let ((a0-8 (+ (-> sv-16 segment 2 dest) (-> sv-16 vram-size)))
                     (v1-26 2048)
                     )
                 (set! (-> this tex clutdest) (* (shr (+ a0-8 2047) 11) 32))
                 (+! (-> sv-16 vram-size) v1-26)
                 )
               )
             )
           )
          ((= (-> s5-0 psm) (gs-psm ct32))
           (cond
             ((= (-> s5-0 dest 0) #xffff)
              (let ((s4-0 (-> sv-16 segment 2))
                    (a1-2 (log2 (max (-> s5-0 w) (-> s5-0 h))))
                    (a0-19 (min 4 (the-as int (-> s5-0 num-mips))))
                    (v1-35 2048)
                    )
                (let ((a2-6 (* (shr (+ (-> sv-16 vram-size) 2047 (-> s4-0 dest)) 11) 32))
                      (a3-2 (* 5 a1-2))
                      )
                  (dotimes (t0-0 a0-19)
                    (set! (-> s5-0 dest t0-0) (+ a2-6 (-> *texture-anim-mip-array* (+ a3-2 t0-0))))
                    (set! (-> s5-0 width t0-0) (the-as uint (/ (ash (-> s5-0 w) (- t0-0)) 64)))
                    )
                  )
                (when (>= a1-2 6)
                  (let ((a0-20 (+ (* 5 (+ a1-2 -6)) a0-19)))
                    (set! v1-35 (the-as int (* (the-as uint v1-35) (-> *texture-anim-pages-table* a0-20))))
                    )
                  )
                (+! (-> sv-16 vram-size) v1-35)
                )
              )
             (else
               (let ((v1-37 (-> s5-0 dest 0)))
                 (set! (-> s5-0 num-mips) (the-as uint 1))
                 (when (!= v1-37 (* (/ (the-as int v1-37) 32) 32))
                   (let ((v1-42 (+ (-> sv-16 segment 2 dest) (-> sv-16 vram-size)))
                         (a0-36 (shl (sar (+ (* (-> s5-0 w) (-> s5-0 h)) 2047) 11) 11))
                         )
                     (set! (-> this tex dest 0) (* (shr (+ v1-42 2047) 11) 32))
                     (+! (-> sv-16 vram-size) a0-36)
                     )
                   )
                 )
               )
             )
           )
          )
        )
      )
    )
  (dotimes (s5-1 (the-as int (-> this num-layers)))
    (initialize-texture! (-> this data s5-1))
    )
  (let ((v1-56 (-> this tex)))
    (when v1-56
      (dotimes (a0-40 3)
        (set! (-> v1-56 masks data a0-40 mask quad) (the-as uint128 0))
        )
      (dotimes (a0-43 (the-as int (-> this num-layers)))
        (let ((a1-13 (-> this data a0-43 tex)))
          (when a1-13
            (dotimes (a2-12 3)
              (let ((a3-5 (-> v1-56 masks data a2-12 mask quad))
                    (t0-3 (-> a1-13 masks data a2-12 mask quad))
                    )
                (.por a3-6 a3-5 t0-3)
                )
              (set! (-> v1-56 masks data a2-12 mask quad) a3-6)
              )
            )
          )
        )
      )
    )
  this
  )

(defmethod clear-textures! ((this texture-anim))
  (set! (-> this tex) #f)
  (dotimes (s5-0 (the-as int (-> this num-layers)))
    (clear-texture! (-> this data s5-0))
    )
  this
  )

(defmethod initialize-texture! ((this texture-anim-layer))
  (if (logtest? (the-as int (-> this func)) 1)
      (set! (-> this func) (the-as
                             (function dma-buffer uint int int texture-anim-layer float int)
                             (-> (the-as symbol (-> this func)) value)
                             )
            )
      )
  (when (logtest? (the-as int (-> this init-func)) 1)
    (set! (-> this init-func)
          (the-as (function texture-anim-layer int) (-> (the-as symbol (-> this init-func)) value))
          )
    (if (-> this init-func)
        ((-> this init-func) this)
        )
    )
  (if (-> this tex-name)
      (set! (-> this tex) (lookup-level-texture-by-name
                            (-> this tex-name)
                            (-> *level* loading-level)
                            (the-as (pointer texture-page) #f)
                            )
            )
      )
  this
  )

(defmethod clear-texture! ((this texture-anim-layer))
  (set! (-> this tex) #f)
  this
  )
