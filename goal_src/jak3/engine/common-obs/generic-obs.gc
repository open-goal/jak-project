;;-*-Lisp-*-
(in-package goal)

;; name: generic-obs.gc
;; name in dgo: generic-obs
;; dgos: GAME

(deftype mystery-cquery-type0 (structure)
  "(event explode explosion)"
  ((cquery          collide-query :inline)
   (explosion-trans vector        :inline)
   (proc-trans      vector        :inline)
   (probe           float)
   (dist            float)
   )
  )

(define-extern lookup-part-group-pointer-by-name (function string (pointer object)))

(define-extern process-entity-set! (function process entity entity))
(define-extern cshape-reaction-default (function control-info collide-query vector vector collide-status))

(defmacro set-part-tracker-params (type group duration callback userdata target mat-joint subsample-num)
  `(case ,type
    ((part-tracker)
     (set! (-> *part-tracker-params-default* group) ,group)
     (set! (-> *part-tracker-params-default* duration) ,duration)
     (set! (-> *part-tracker-params-default* callback) ,callback)
     (set! (-> *part-tracker-params-default* userdata) ,userdata)
     (set! (-> *part-tracker-params-default* target) ,target)
     (set! (-> *part-tracker-params-default* mat-joint) ,mat-joint)
     )
    (else
     (set! (-> *part-tracker-subsampler-params-default* group) ,group)
     (set! (-> *part-tracker-subsampler-params-default* duration) ,duration)
     (set! (-> *part-tracker-subsampler-params-default* callback) ,callback)
     (set! (-> *part-tracker-subsampler-params-default* userdata) ,userdata)
     (set! (-> *part-tracker-subsampler-params-default* target) ,target)
     (set! (-> *part-tracker-subsampler-params-default* mat-joint) ,mat-joint)
     (set! (-> *part-tracker-subsampler-params-default* subsample-num) ,subsample-num)
     )
    )
  )

(defmacro part-tracker-spawn (type &key (group #f)
                                   &key (to #f)
                                   &key (name #f)
                                   &key (stack-size #x4000)
                                   &key (stack *scratch-memory-top*)
                                   &key (unk 0)
                                   &key (duration (seconds 0))
                                   &key (callback #f)
                                   &key (userdata (the uint #f))
                                   &key (target #f)
                                   &key (mat-joint *launch-matrix*)
                                   &key (subsample-num 1.0))
  "Specialized `process-spawn` macro for [[part-tracker]]s.
   Returns a pointer to the new process, or #f (or is it 0?) if something goes wrong."
  (with-gensyms (new-tracker)
    `(let ((,new-tracker (the-as ,type (get-process *default-dead-pool* ,type ,stack-size ,unk))))
        (when ,new-tracker
          ((method-of-type ,type activate) ,new-tracker ,to ,(if name name `(symbol->string (quote ,type))) ,stack)
          (set-part-tracker-params ,type ,group ,duration ,callback ,userdata ,target ,mat-joint ,subsample-num)
          (run-now-in-process ,new-tracker
            (if (= ,type part-tracker) part-tracker-init part-tracker-subsampler-init)
            (if (= ,type part-tracker) *part-tracker-params-default* *part-tracker-subsampler-params-default*))
          (the (pointer ,type) (-> ,new-tracker ppointer))
          )
        )
    )
  )

;; DECOMP BEGINS

(define *part-tracker-params-default* (new 'static 'part-tracker-init-params))

(define *part-tracker-subsampler-params-default* (new 'static 'part-tracker-subsampler-init-params))

(defskelgroup skel-spotlight spotlight spotlight-lod0-jg -1
              ((spotlight-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              :origin-joint-index 5
              )

;; WARN: Return type mismatch object vs (pointer sparticle-launch-group).
(defun entity-lookup-part-group ((arg0 entity-actor) (arg1 (pointer string)) (arg2 symbol))
  (local-vars (sv-16 res-tag))
  (let ((gp-0 (the-as object #f)))
    (set! sv-16 (new 'static 'res-tag))
    (let ((s4-0 (res-lump-data arg0 arg2 pointer :tag-ptr (& sv-16))))
      (if (not s4-0)
          (go process-drawable-art-error (the-as string #f))
          )
      (let ((s3-0 (the-as object (-> (the-as (pointer uint32) s4-0)))))
        (cond
          ((part-group-pointer? (the-as pointer s3-0))
           (set! gp-0 (-> (the-as (pointer uint32) s4-0)))
           )
          ((= (-> (the-as string s3-0) type) string)
           (if arg1
               (set! (-> arg1 0) (the-as string s3-0))
               )
           (set! gp-0 (lookup-part-group-pointer-by-name (the-as string s3-0)))
           (if (the-as (pointer object) gp-0)
               (set! (-> (the-as (pointer int32) s4-0)) (the-as int gp-0))
               )
           )
          (else
            (go process-drawable-art-error (the-as string s3-0))
            )
          )
        )
      )
    (the-as (pointer sparticle-launch-group) gp-0)
    )
  )

(defbehavior clone-anim-once process-drawable ((arg0 handle) (arg1 symbol) (arg2 string))
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  (let ((gp-0 (handle->process arg0)))
    (if gp-0
        (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
        )
    (cond
      ((and gp-0 (joint-control-remap!
                   (-> self skel)
                   (-> self draw art-group)
                   (-> (the-as process-drawable gp-0) draw art-group)
                   '()
                   0
                   arg2
                   )
            )
       (when arg1
         (let* ((s5-1 (-> self root))
                (a0-7 (if (type? s5-1 collide-shape)
                          s5-1
                          )
                      )
                )
           (if a0-7
               (move-to-point! (the-as collide-shape a0-7) (-> (the-as process-drawable gp-0) root trans))
               (set! (-> self root trans quad) (-> (the-as process-drawable gp-0) root trans quad))
               )
           )
         (quaternion-copy! (-> self root quat) (-> (the-as process-drawable gp-0) root quat))
         )
       (if (logtest? (-> (the-as process-drawable gp-0) skel status) (joint-control-status valid-spooled-frame))
           (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
           )
       (logclear! (-> self draw status) (draw-control-status no-draw no-draw-temp uninited))
       (if (or (zero? (-> self skel active-channels)) (not (-> self skel root-channel 0 frame-group)))
           (logior! (-> self draw status) (draw-control-status no-draw-temp))
           )
       (let* ((gp-1 self)
              (v1-38 (if (type? gp-1 manipy)
                         gp-1
                         )
                     )
              )
         (if (and v1-38 (not (-> (the-as manipy v1-38) draw?)))
             (logior! (-> self draw status) (draw-control-status no-draw-temp))
             )
         )
       (update-anim-data (-> self skel))
       (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
       (let ((a0-22 (-> self skel effect)))
         (if a0-22
             (effect-control-method-9 a0-22)
             )
         )
       (if (logtest? (-> self skel status) (joint-control-status blend-shape blend-shape-valid))
           (merc-blend-shape self)
           )
       (if (logtest? (-> self skel status) (joint-control-status eye-anim-valid eye-anim))
           (merc-eye-anim self)
           )
       (cloth-post)
       )
      (else
        (set! (-> self skel active-channels) (the-as uint 0))
        (logior! (-> self draw status) (draw-control-status no-draw))
        (ja-post)
        )
      )
    )
  0
  (none)
  )

(defbehavior clone-anim process-drawable ((arg0 handle) (arg1 symbol) (arg2 string))
  (ja-post)
  (while (handle->process arg0)
    (clone-anim-once arg0 #t arg2)
    (suspend)
    )
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  0
  (none)
  )

(defmethod swingpole-method-22 ((this swingpole))
  (with-pp
    (if (nonzero? (-> this draw))
        (ja-post)
        )
    (cond
      ((nonzero? (-> this path))
       (set! (-> this path-pos) (get-norm! (-> this sync) 0))
       (let ((s5-0 (new 'stack-no-clear 'vector)))
         (get-point-at-percent-along-path! (-> this path) s5-0 (-> this path-pos) 'interp)
         (set! (-> this speed) (* (vector-vector-distance s5-0 (-> this root trans)) (-> pp clock frames-per-second)))
         (move-to-point! (the-as collide-shape (-> this root)) s5-0)
         )
       )
      ((>= (-> this joint-track) 0)
       (let ((v1-15 (ppointer->process (-> this parent)))
             (s5-1 (new 'stack-no-clear 'vector))
             )
         (let ((s4-0 (-> (the-as process-drawable v1-15) node-list data (-> this joint-track))))
           (vector<-cspace! s5-1 s4-0)
           (vector-normalize-copy! (-> this dir) (the-as vector (-> s4-0 bone transform)) 1.0)
           )
         (move-to-point! (the-as collide-shape (-> this root)) s5-1)
         )
       )
      )
    (when (nonzero? (-> this sound))
      (set! (-> this sound trans quad) (-> this root trans quad))
      (let ((f30-0 (lerp-scale -0.1 -0.05 (-> this speed) 8192.0 20480.0))
            (f0-6 (lerp-scale 0.7 1.0 (-> this speed) 8192.0 20480.0))
            )
        (set! (-> this sound pitch) (the int (* 1524.0 f30-0)))
        (set! (-> this sound volume) (the int (* 1024.0 f0-6)))
        )
      (update! (-> this sound))
      )
    0
    (none)
    )
  )

(defstate idle (swingpole)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (if (send-event proc 'pole-grab (-> block param 0))
           (go-virtual active (process->handle proc))
           )
       #f
       )
      )
    )
  :code (behavior ()
    (if (nonzero? (-> self draw))
        (ja-post)
        )
    (update-transforms (the-as collide-shape (-> self root)))
    (cond
      ((or (nonzero? (-> self path)) (>= (-> self joint-track) 0))
       (until #f
         (swingpole-method-22 self)
         (suspend)
         )
       #f
       )
      (else
        (logior! (-> self mask) (process-mask sleep))
        (suspend)
        0
        )
      )
    )
  )

(defstate active (swingpole)
  :virtual #t
  :code (behavior ((arg0 handle))
    (swingpole-method-22 self)
    (suspend)
    (while (let* ((s5-0 (handle->process arg0))
                  (a0-7 (if (type? s5-0 process-focusable)
                            s5-0
                            )
                        )
                  )
             (and a0-7 (focus-test? (the-as process-focusable a0-7) pole))
             )
      (swingpole-method-22 self)
      (suspend)
      )
    (suspend-for (seconds 0.5) (swingpole-method-22 self))
    (go-virtual idle)
    )
  )

(defmethod get-trans ((this swingpole))
  (-> this root trans)
  )

(defmethod init-collision! ((this swingpole))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this swingpole) (arg0 entity-actor))
  "Copy defaults from the entity."
  (stack-size-set! (-> this main-thread) 128)
  (init-collision! this)
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> this root quat) (-> arg0 quat))
  (vector-identity! (-> this root scale))
  (vector-y-quaternion! (-> this dir) (-> this root quat))
  (set! (-> this joint-track) -1)
  (let ((a1-5 (res-lump-struct (-> this entity) 'art-name structure)))
    (if a1-5
        (initialize-skeleton-by-name this (the-as string a1-5))
        )
    )
  (set! (-> this dir y) 0.0)
  (vector-normalize! (-> this dir) 1.0)
  (set! (-> this edge-length) 8192.0)
  (let ((s4-0 (new 'stack-no-clear 'sync-info-params)))
    (let ((a0-13 (res-lump-value arg0 'options uint128 :time -1000000000.0))
          (v1-17 0)
          )
      (if (not (logtest? (the-as int a0-13) 8))
          (set! v1-17 (logior v1-17 1))
          )
      (set! (-> s4-0 sync-type) 'sync-eased)
      (set! (-> s4-0 sync-flags) (the-as sync-flags v1-17))
      )
    (set! (-> s4-0 period) (the-as uint 0))
    (set! (-> s4-0 entity) arg0)
    (set! (-> s4-0 percent) 0.0)
    (set! (-> s4-0 ease-in) 0.2)
    (set! (-> s4-0 ease-out) 0.2)
    (set! (-> s4-0 pause-in) 0.0)
    (set! (-> s4-0 pause-out) 0.0)
    (initialize! (-> this sync) s4-0)
    )
  (when (nonzero? (-> this sync period))
    (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
    (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
    )
  (set! (-> this sound) (new 'process 'ambient-sound (-> this entity) (-> this root trans) 0.0))
  (go (method-of-object this idle))
  )

(defbehavior swingpole-init swingpole ((arg0 int))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-4)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (set! (-> self root trans quad) (-> (the-as process-drawable (-> self parent 0)) root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self joint-track) arg0)
  (set-vector! (-> self dir) 0.0 0.0 1.0 1.0)
  (set! (-> self edge-length) 8192.0)
  (go-virtual idle)
  )

(defstate die (process-hidden)
  :virtual #t
  :code nothing
  )

(defmethod init-from-entity! ((this process-hidden) (arg0 entity-actor))
  "Copy defaults from the entity."
  (process-entity-status! this (entity-perm-status dead) #t)
  (go (method-of-object this die))
  )

(deftype target-start (process-hidden)
  ()
  )


(deftype camera-start (process-hidden)
  ()
  )


(deftype cam-slope (process-hidden)
  ()
  )


(defbehavior manipy-post manipy ()
  ((-> self cur-post-hook))
  (when (and (>= (-> self shadow-volume-joint) 0) (-> self draw shadow-ctrl))
    (let ((a2-0 (-> self node-list data (-> self shadow-volume-joint)))
          (a3-0 (-> self draw shadow-ctrl))
          )
      (format *stdcon* "shadow-volume for ~A ~A~%" a2-0 a3-0)
      )
    )
  0
  (none)
  )

(defstate idle (manipy)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (s4-0 object))
    (case message
      (('blend-shape)
       (when (nonzero? (-> self skel))
         (cond
           ((-> block param 0)
            (set! s4-0 (logior (-> self skel status) (joint-control-status blend-shape eye-anim)))
            (set! (-> self skel status) (the-as joint-control-status s4-0))
            )
           (else
             (set! s4-0 (logclear (-> self skel status) (joint-control-status blend-shape eye-anim)))
             (set! (-> self skel status) (the-as joint-control-status s4-0))
             )
           )
         s4-0
         )
       )
      (('shadow)
       (when (nonzero? (-> self draw))
         (cond
           ((-> block param 0)
            (set! s4-0 (-> self shadow-backup))
            (set! (-> self draw shadow) (the-as shadow-geo s4-0))
            s4-0
            )
           (else
             (set! (-> self draw shadow) #f)
             #f
             )
           )
         )
       )
      (('shadow-volume)
       (let ((v1-14 (the-as
                      joint
                      (get-art-by-name-method (-> self draw jgeo) (the-as string (-> block param 0)) (the-as type #f))
                      )
                    )
             )
         (if v1-14
             (set! (-> self shadow-volume-joint) (+ (-> v1-14 number) 1))
             )
         )
       (when (and (-> self draw shadow-ctrl) (< 1 argc) (>= (the-as int (-> block param 1)) 0))
         (let ((v0-1 (command-get-int (-> block param 1) 0)))
           (set! (-> self draw shadow-ctrl settings flags) (the-as shadow-flags v0-1))
           v0-1
           )
         )
       )
      (('shadow-type)
       (if (and (-> self draw shadow-ctrl) (> argc 0))
           (set! (-> self draw shadow-ctrl settings shadow-type) (command-get-int (-> block param 0) 0))
           )
       )
      (('shadow-disable-smooth)
       (when (nonzero? (-> self draw))
         (cond
           ((-> block param 0)
            (when (-> self draw shadow-ctrl)
              (set! s4-0 (logior (-> self draw shadow-ctrl settings flags) (shadow-flags shdf08)))
              (set! (-> self draw shadow-ctrl settings flags) (the-as shadow-flags s4-0))
              s4-0
              )
            )
           (else
             (when (-> self draw shadow-ctrl)
               (set! s4-0 (logclear (-> self draw shadow-ctrl settings flags) (shadow-flags shdf08)))
               (set! (-> self draw shadow-ctrl settings flags) (the-as shadow-flags s4-0))
               s4-0
               )
             )
           )
         )
       )
      (('shadow-dir)
       (when (and (-> self draw shadow-ctrl) (> argc 0))
         (set! s4-0 (-> self draw shadow-ctrl settings shadow-dir))
         (set! (-> (the-as vector s4-0) x) (the-as float (-> block param 0)))
         (set! (-> (the-as vector s4-0) y) (the-as float (-> block param 1)))
         (set! (-> (the-as vector s4-0) z) (the-as float (-> block param 2)))
         (set! (-> (the-as vector s4-0) w) (the-as float (if (< 3 argc)
                                                             (command-get-param (-> block param 3) #f)
                                                             409600.0
                                                             )
                                                   )
               )
         s4-0
         )
       )
      (('shadow-top-plane)
       (when (and (-> self draw shadow-ctrl) (>= argc 4))
         (set! s4-0 (-> self draw shadow-ctrl settings top-plane))
         (set! (-> (the-as plane s4-0) x) (the-as float (-> block param 0)))
         (set! (-> (the-as plane s4-0) y) (the-as float (-> block param 1)))
         (set! (-> (the-as plane s4-0) z) (the-as float (-> block param 2)))
         (set! (-> (the-as plane s4-0) w) (the-as float (-> block param 3)))
         s4-0
         )
       )
      (('shadow-bot-plane)
       (when (and (-> self draw shadow-ctrl) (>= argc 4))
         (set! s4-0 (-> self draw shadow-ctrl settings bot-plane))
         (set! (-> (the-as plane s4-0) x) (the-as float (-> block param 0)))
         (set! (-> (the-as plane s4-0) y) (the-as float (-> block param 1)))
         (set! (-> (the-as plane s4-0) z) (the-as float (-> block param 2)))
         (set! (-> (the-as plane s4-0) w) (the-as float (-> block param 3)))
         s4-0
         )
       )
      (('shadow-fade-dist)
       (if (-> self draw shadow-ctrl)
           (set! (-> self draw shadow-ctrl settings fade-dist) (the-as float (-> block param 0)))
           )
       )
      (('no-fog)
       (set! s4-0 (logior (-> self draw status) (draw-control-status disable-fog)))
       (set! (-> self draw status) (the-as draw-control-status s4-0))
       s4-0
       )
      (('setup-spotlight-shadow)
       (when (-> self draw shadow-ctrl)
         (let ((v1-80 (command-get-process "spotlight" *target*)))
           (when v1-80
             (let ((s5-1 (-> (the-as process-drawable v1-80) node-list data 3)))
               (vector<-cspace! (new 'stack-no-clear 'vector) s5-1)
               (let ((s5-2 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-1 bone transform fvec) -1.0))
                     (s4-1
                       (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self draw shadow-joint-index)))
                       )
                     (f30-0 1638400.0)
                     (s3-0 (new 'stack-no-clear 'collide-query))
                     (f28-0 122880.0)
                     )
                 (set! (-> s3-0 start-pos quad) (-> s4-1 quad))
                 (vector-normalize-copy! (-> s3-0 move-dist) s5-2 f28-0)
                 (let ((v1-91 s3-0))
                   (set! (-> v1-91 radius) 1638.4)
                   (set! (-> v1-91 collide-with) (collide-spec obstacle hit-by-others-list))
                   (set! (-> v1-91 ignore-process0) self)
                   (set! (-> v1-91 ignore-process1) #f)
                   (set! (-> v1-91 ignore-pat)
                         (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                         )
                   (set! (-> v1-91 action-mask) (collide-action solid))
                   )
                 (let* ((f0-14 (fill-and-probe-using-line-sphere *collide-cache* s3-0))
                        (f28-1 (if (< 0.0 f0-14)
                                   (* f0-14 f28-0)
                                   122880.0
                                   )
                               )
                        )
                   (shadow-control-method-14
                     (-> self draw shadow-ctrl)
                     s4-1
                     s5-2
                     f30-0
                     (- f28-1 (command-get-float (-> block param 0) 0.0))
                     (+ f28-1 (command-get-float (-> block param 1) 0.0))
                     )
                   )
                 )
               )
             )
           )
         )
       )
      (('color-mult)
       (when (>= argc 4)
         (set! s4-0 (-> self draw color-mult))
         (set! (-> (the-as rgbaf s4-0) x) (command-get-float (-> block param 0) 0.0))
         (set! (-> (the-as rgbaf s4-0) y) (command-get-float (-> block param 1) 0.0))
         (set! (-> (the-as rgbaf s4-0) z) (command-get-float (-> block param 2) 0.0))
         (set! (-> (the-as rgbaf s4-0) w) (command-get-float (-> block param 3) 0.0))
         s4-0
         )
       )
      (('color-mult-vector)
       (set! s4-0 (-> self draw color-mult))
       (set! (-> (the-as rgbaf s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
       s4-0
       )
      (('color-emissive-vector)
       (set! s4-0 (-> self draw color-emissive))
       (set! (-> (the-as rgbaf s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
       s4-0
       )
      (('segment)
       (let ((a1-34 (/ (the-as int (-> block param 0)) 8))
             (a2-5 (/ (the-as int (-> block param 1)) 8))
             )
         (setup-masks (-> self draw) (the-as int a1-34) (the-as int a2-5))
         )
       )
      (('trans-hook)
       (set! s4-0 (-> block param 0))
       (set! (-> self new-trans-hook) (the-as (function none) s4-0))
       s4-0
       )
      (('post-hook)
       (set! s4-0 (-> block param 0))
       (set! (-> self new-post-hook) (the-as (function none) s4-0))
       s4-0
       )
      (('user-data)
       (set! s4-0 (-> block param 0))
       (set! (-> self userdata) (the-as uint s4-0))
       s4-0
       )
      (('eval)
       ((the-as (function manipy none) (-> block param 0)) self)
       )
      (('speed)
       (set! (-> self speed) (the-as float (-> block param 0)))
       )
      (('event-hook)
       (set! s4-0 (-> block param 0))
       (set! (-> self cur-event-hook) (the-as (function none) s4-0))
       s4-0
       )
      (('art-joint-anim)
       (set! (-> self new-joint-anim)
             (get-art-by-name (-> self draw art-group) (the-as string (-> block param 0)) art-joint-anim)
             )
       (set! (-> self new-joint-anim-blend) (the-as uint (if (>= argc 2)
                                                             (the-as int (-> block param 1))
                                                             0
                                                             )
                                                    )
             )
       (set! (-> self new-joint-anim-frame) (the-as float (if (>= argc 3)
                                                              (-> block param 2)
                                                              0.0
                                                              )
                                                    )
             )
       )
      (('anim-mode)
       (when (nonzero? (-> self skel))
         (set! (-> self anim-mode) (the-as symbol (-> block param 0)))
         (if (= (-> self anim-mode) 'clone-anim)
             (ja-post)
             )
         (-> self anim-mode)
         )
       )
      (('origin-joint-index 'center-joint)
       (set! (-> self draw origin-joint-index) (-> block param 0))
       (set! s4-0 (-> block param 0))
       (set! (-> self draw shadow-joint-index) (the-as uint s4-0))
       s4-0
       )
      (('max-vis-dist)
       (set! (-> self draw lod-set lod (-> self draw lod-set max-lod) dist) (the-as float (-> block param 0)))
       )
      (('grab)
       (set! (-> self cur-grab-handle) (process->handle (the-as process (-> block param 0))))
       (let ((v1-127 (handle->process (-> self cur-grab-handle))))
         (when v1-127
           (set! s4-0 (-> self old-grab-pos))
           (set! (-> (the-as vector s4-0) quad) (-> (the-as process-drawable v1-127) root trans quad))
           s4-0
           )
         )
       )
      (('target)
       (set! s4-0 (process->handle (the-as process (-> block param 0))))
       (set! (-> self cur-target-handle) (the-as handle s4-0))
       s4-0
       )
      (('trans)
       (cond
         ((type? (-> self root) collide-shape)
          (move-to-point! (-> self root) (the-as vector (-> block param 0)))
          )
         (else
           (set! s4-0 (-> self root trans))
           (set! (-> (the-as vector s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
           s4-0
           )
         )
       )
      (('scale)
       (set! s4-0 (-> self root scale))
       (set! (-> (the-as vector s4-0) quad) (-> (the-as vector (-> block param 0)) quad))
       s4-0
       )
      (('rot)
       (let ((s5-3 (new 'stack-no-clear 'matrix)))
         (matrix-rotate-y! s5-3 (the-as float (-> block param 0)))
         (matrix->quaternion (-> self root quat) s5-3)
         )
       )
      (('rot-quat)
       (quaternion-copy! (-> self root quat) (the-as quaternion (-> block param 0)))
       )
      (('clone-copy-trans)
       (set! s4-0 (-> block param 0))
       (set! (-> self clone-copy-trans) (the-as symbol s4-0))
       s4-0
       )
      (('release)
       (set! (-> self cur-grab-handle) (the-as handle #f))
       #f
       )
      (('draw)
       (set! (-> self draw?) (the-as symbol (-> block param 0)))
       (cond
         ((-> block param 0)
          (let ((v1-146 (logtest? (-> self draw status) (draw-control-status no-draw))))
            (logclear! (-> self draw status) (draw-control-status no-draw))
            (when v1-146
              (cond
                ((nonzero? (-> self skel))
                 (let ((gp-1 (-> self skel status)))
                   (logior! (-> self skel status) (joint-control-status sync-math))
                   (set! s4-0 (ja-post))
                   (set! (-> self skel status) gp-1)
                   )
                 s4-0
                 )
                (else
                  (ja-post)
                  )
                )
              )
            )
          )
         (else
           (set! s4-0 (logior (-> self draw status) (draw-control-status no-draw)))
           (set! (-> self draw status) (the-as draw-control-status s4-0))
           s4-0
           )
         )
       )
      (('sync)
       (when (nonzero? (-> self skel))
         (cond
           ((-> block param 0)
            (set! s4-0 (logior (-> self skel status) (joint-control-status sync-math)))
            (set! (-> self skel status) (the-as joint-control-status s4-0))
            )
           (else
             (set! s4-0 (logclear (-> self skel status) (joint-control-status sync-math)))
             (set! (-> self skel status) (the-as joint-control-status s4-0))
             )
           )
         s4-0
         )
       )
      (('query)
       (case (-> block param 0)
         (('grab)
          (handle->process (-> self cur-grab-handle))
          )
         (('done)
          (case (-> self anim-mode)
            (('play1 'play)
             (>= (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -2)))
             )
            )
          )
         )
       )
      (('set-frame-num)
       (let ((v1-179 (-> self skel root-channel 0)))
         (set! (-> v1-179 num-func) num-func-identity)
         (set! (-> v1-179 frame-num) (the-as float (-> block param 0)))
         )
       )
      (('prefix)
       (set! s4-0 (-> block param 0))
       (set! (-> self prefix) (the-as basic s4-0))
       s4-0
       )
      (('light-index)
       (let ((v0-29 (command-get-int (-> block param 0) 0)))
         (set! (-> self draw light-index) (the-as uint v0-29))
         v0-29
         )
       )
      (('eye-slot)
       (set! (-> self draw mgeo header eye-ctrl eye-slot) (command-get-int (-> block param 0) 0))
       )
      (('shadow-mask)
       (let ((v0-31 (command-get-int (-> block param 0) 0)))
         (set! (-> self draw shadow-mask) (the-as uint v0-31))
         v0-31
         )
       )
      (('shadow-values)
       (let ((v0-32 (command-get-int (-> block param 0) 0)))
         (set! (-> self draw shadow-values) (the-as uint v0-32))
         v0-32
         )
       )
      (('mirror)
       (cond
         ((-> block param 0)
          (set! s4-0 (-> self node-list data 2))
          (set! (-> (the-as cspace s4-0) param0)
                (the-as (function cspace transformq none) cspace<-parented-matrix-mirror!)
                )
          (set! (-> (the-as cspace s4-0) param1) (the-as basic (-> *math-camera* mirror-trans)))
          (set! (-> (the-as cspace s4-0) param2) (the-as basic (-> *math-camera* mirror-normal)))
          )
         (else
           (set! s4-0 (-> self node-list data 2))
           (set! (-> (the-as cspace s4-0) param0) #f)
           )
         )
       s4-0
       )
      (('draw-mirror)
       (send-event (ppointer->process (-> self child)) 'draw (-> block param 0))
       )
      (('user)
       (set! s4-0 (-> block param 1))
       (set! (-> self user-uint64 (/ (the-as int (-> block param 0)) 8)) (the-as uint s4-0))
       s4-0
       )
      (('die)
       (deactivate self)
       )
      (('do-effect)
       (if (and (nonzero? (-> self skel)) (-> self skel effect))
           (do-effect (-> self skel effect) (the-as string (-> block param 0)) (the-as float (-> block param 1)) -1)
           )
       )
      (('no-actor-pause)
       (set! s4-0 (logclear (-> self mask) (process-mask actor-pause)))
       (set! (-> self mask) (the-as process-mask s4-0))
       s4-0
       )
      (else
        (if (-> self cur-event-hook)
            ((-> self cur-event-hook))
            )
        )
      )
    )
  :trans (behavior ()
    (if (!= (-> self cur-trans-hook) (-> self new-trans-hook))
        (set! (-> self cur-trans-hook) (-> self new-trans-hook))
        )
    (if (!= (-> self cur-post-hook) (-> self new-post-hook))
        (set! (-> self cur-post-hook) (-> self new-post-hook))
        )
    (when (and (-> self new-joint-anim)
               (nonzero? (-> self skel))
               (and (!= (ja-group) (-> self new-joint-anim)) (!= (-> self anim-mode) 'clone-anim))
               )
      (ja-channel-push! 1 (the-as time-frame (-> self new-joint-anim-blend)))
      (ja :group! (-> self new-joint-anim) :num! (identity (ja-aframe (-> self new-joint-anim-frame) 0)))
      )
    (let ((v1-20 (handle->process (-> self cur-grab-handle))))
      (when v1-20
        (let ((gp-1 (-> (the-as process-drawable v1-20) root trans)))
          (if (type? (-> self root) collide-shape)
              (move-by-vector! (-> self root) (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos)))
              (vector+!
                (-> self root trans)
                (-> self root trans)
                (vector-! (new 'stack-no-clear 'vector) gp-1 (-> self old-grab-pos))
                )
              )
          (set! (-> self old-grab-pos quad) (-> gp-1 quad))
          )
        )
      )
    ((-> self cur-trans-hook))
    )
  :code (behavior ()
    (logclear! (-> self mask) (process-mask heap-shrunk))
    (until #f
      (case (-> self anim-mode)
        (('loop)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (loop!))
         )
        (('play)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (seek!))
         )
        (('copy-parent)
         (let ((v1-17 (-> self skel root-channel 0)))
           (set! (-> v1-17 num-func) num-func-identity)
           (let ((a0-10 (-> self parent)))
             (set! (-> v1-17 frame-num) (-> (the-as process-drawable (if a0-10
                                                                         (the-as process-drawable (-> a0-10 0 self))
                                                                         )
                                                    )
                                            skel
                                            root-channel
                                            0
                                            frame-num
                                            )
                   )
             )
           )
         (ja-post)
         (manipy-post)
         (suspend)
         0
         )
        (('clone-parent)
         (let ((gp-0 (ppointer->process (-> self parent))))
           (set! (-> self post-hook) #f)
           (joint-control-copy! (-> self skel) (-> (the-as process-drawable gp-0) skel))
           (joint-control-remap!
             (-> self skel)
             (-> self draw art-group)
             (-> (the-as process-drawable gp-0) draw art-group)
             '()
             0
             ""
             )
           )
         (update-anim-data (-> self skel))
         (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
         (manipy-post)
         (suspend)
         0
         )
        (('clone-anim)
         (clone-anim-once
           (if (handle->process (-> self cur-target-handle))
               (the-as handle (-> self cur-target-handle))
               (ppointer->handle (-> self parent))
               )
           (-> self clone-copy-trans)
           (the-as string (-> self prefix))
           )
         (manipy-post)
         (suspend)
         0
         )
        (('mirror)
         (let ((gp-1 (if (handle->process (-> self cur-target-handle))
                         (-> self cur-target-handle)
                         (ppointer->handle (-> self parent))
                         )
                     )
               )
           (clone-anim-once gp-1 (-> self clone-copy-trans) (the-as string (-> self prefix)))
           (logior! (-> self draw global-effect) (draw-control-global-effect disable-envmap))
           (set! (-> self draw light-index) (the-as uint 5))
           (if (logtest? (-> (the-as process-drawable (handle->process gp-1)) draw status)
                         (draw-control-status no-draw no-draw-temp no-draw-bounds)
                         )
               (logior! (-> self draw status) (draw-control-status no-draw-temp))
               )
           )
         (manipy-post)
         (suspend)
         0
         )
        (('still)
         (ja-post)
         (manipy-post)
         (suspend)
         0
         )
        (('play1)
         (ja-post)
         (manipy-post)
         (suspend)
         (ja :num! (seek! max (-> self speed)))
         (if (ja-done? 0)
             (deactivate self)
             )
         )
        )
      )
    #f
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior manipy-init manipy ((arg0 vector) (arg1 entity-actor) (arg2 skeleton-group) (arg3 vector) (arg4 manipy-options))
  (stack-size-set! (-> self main-thread) 128)
  (logior! (-> self mask) (process-mask heap-shrunk))
  (process-entity-set! self arg1)
  (cond
    ((= arg3 'collide-shape-moving)
     (let ((s3-1 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
       (set! (-> s3-1 dynam) (copy *standard-dynamics* 'process))
       (set! (-> s3-1 reaction) cshape-reaction-default)
       (set! (-> s3-1 no-reaction)
             (the-as (function collide-shape-moving collide-query vector vector object) nothing)
             )
       (let ((v1-11 (new 'process 'collide-shape-prim-sphere s3-1 (the-as uint 0))))
         (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 4096.0)
         (set! (-> s3-1 total-prims) (the-as uint 1))
         (set! (-> s3-1 root-prim) v1-11)
         )
       (set! (-> s3-1 nav-radius) (* 0.75 (-> s3-1 root-prim local-sphere w)))
       (let ((v1-14 (-> s3-1 root-prim)))
         (set! (-> s3-1 backup-collide-as) (-> v1-14 prim-core collide-as))
         (set! (-> s3-1 backup-collide-with) (-> v1-14 prim-core collide-with))
         )
       (set! (-> self root) s3-1)
       )
     )
    (arg3
      (let ((s3-2 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
        (let ((v1-18 (new 'process 'collide-shape-prim-sphere s3-2 (the-as uint 0))))
          (set! (-> v1-18 prim-core collide-as) (collide-spec collectable notice-blue-eco-powerup))
          (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
          (set-vector! (-> v1-18 local-sphere) (-> arg3 x) (-> arg3 y) (-> arg3 z) (-> arg3 w))
          (set! (-> s3-2 total-prims) (the-as uint 1))
          (set! (-> s3-2 root-prim) v1-18)
          )
        (set! (-> s3-2 nav-radius) (* 0.75 (-> s3-2 root-prim local-sphere w)))
        (let ((v1-21 (-> s3-2 root-prim)))
          (set! (-> s3-2 backup-collide-as) (-> v1-21 prim-core collide-as))
          (set! (-> s3-2 backup-collide-with) (-> v1-21 prim-core collide-with))
          )
        (set! (-> self root) s3-2)
        )
      )
    (else
      (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
      )
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton self arg2 (the-as pair 0))
  (if (type? (-> self root) collide-shape)
      (update-transforms (-> self root))
      )
  (set! (-> self shadow-backup) (-> self draw shadow))
  (set! (-> self shadow-volume-joint) -1)
  (set! (-> self options) arg4)
  (when (-> self draw shadow)
    (set! (-> self draw shadow-ctrl) (new
                                       'process
                                       'shadow-control
                                       0.0
                                       0.0
                                       614400.0
                                       (the-as vector #f)
                                       (shadow-flags shdf02 shdf03 shdf04 disable-draw)
                                       245760.0
                                       )
          )
    (quad-copy! (the-as pointer (-> self draw shadow-ctrl settings)) (the-as pointer *default-shadow-settings*) 5)
    )
  (set! (-> self new-trans-hook) nothing)
  (set! (-> self cur-trans-hook) nothing)
  (set! (-> self new-post-hook) nothing)
  (set! (-> self cur-post-hook) nothing)
  (set! (-> self cur-event-hook) #f)
  (set! (-> self cur-grab-handle) (the-as handle #f))
  (set! (-> self cur-target-handle) (the-as handle #f))
  (set! (-> self clone-copy-trans) #t)
  (set! (-> self draw?) #t)
  (set! (-> self prefix) "")
  (set! (-> self speed) 1.0)
  (when (logtest? (-> self options) (manipy-options mo0))
    (let ((v1-56 (the-as joint (get-art-by-name-method (-> self draw jgeo) "neckA" (the-as type #f)))))
      (when v1-56
        (set! (-> self joint 0) (new 'process 'joint-mod (joint-mod-mode flex-blend) self (+ (-> v1-56 number) 1)))
        (set! (-> self joint 0 parented-scale?) #t)
        )
      )
    )
  (when (logtest? (-> self options) (manipy-options mo1))
    (let ((v1-64 (the-as joint (get-art-by-name-method (-> self draw jgeo) "horns" (the-as type #f)))))
      (when v1-64
        (set! (-> self joint 1) (new 'process 'joint-mod (joint-mod-mode joint-set) self (+ (-> v1-64 number) 1)))
        (set! (-> self joint 1 parented-scale?) #t)
        (set! (-> self joint 1 track-mode) (track-mode no-trans no-rotate))
        (trs-set! (-> self joint 1) (the-as vector #f) (the-as quaternion #f) *null-vector*)
        )
      )
    )
  (cond
    ((nonzero? (-> self skel))
     (set! (-> self new-joint-anim) (ja-group))
     (set! (-> self new-joint-anim-frame) 0.0)
     (set! (-> self anim-mode) 'loop)
     )
    (else
      (set! (-> self anim-mode) 'still)
      )
    )
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (go-virtual idle)
  (none)
  )

(defmethod deactivate ((this part-tracker))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  ((method-of-type process deactivate) this)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod notify-parent-of-death ((this part-tracker))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer pp))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'notify)
      (set! (-> gp-0 param 0) (the-as uint 'die))
      (let ((s5-0 send-event-function)
            (s4-0 (ppointer->process (-> this parent)))
            )
        (s5-0
          (if (type? s4-0 process)
              s4-0
              )
          gp-0
          )
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch process vs part-tracker-subsampler.
(defmethod relocate ((this part-tracker-subsampler) (offset int))
  (if (nonzero? (-> this root))
      (&+! (-> this root) offset)
      )
  (if (nonzero? (-> this subsampler))
      (&+! (-> this subsampler) offset)
      )
  (the-as part-tracker-subsampler ((method-of-type process relocate) this offset))
  )

(defstate active (part-tracker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('clock)
       (+! (-> self clock ref-count) -1)
       (+! (-> (the-as process (-> block param 0)) clock ref-count) 1)
       (set! v0-0 (-> (the-as process (-> block param 0)) clock))
       (set! (-> self clock) (the-as clock v0-0))
       v0-0
       )
      (('draw)
       (when (not (-> block param 0))
         (set! v0-0 1)
         (set! (-> self duration) (the-as time-frame v0-0))
         v0-0
         )
       )
      (('trans)
       (set! v0-0 (-> self root trans))
       (set! (-> (the-as vector v0-0) quad) (-> (the-as vector (-> block param 0)) quad))
       v0-0
       )
      (('die)
       (deactivate self)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (and (nonzero? (-> self duration)) (time-elapsed? (-> self state-time) (-> self duration)))
        (go-virtual linger)
        )
    (if (-> self callback)
        ((-> self callback) self)
        )
    (let* ((gp-0 (handle->process (-> self target)))
           (v1-15 (if (type? gp-0 process-drawable)
                      gp-0
                      )
                  )
           )
      (cond
        ((and v1-15
              (nonzero? (-> (the-as process-drawable v1-15) root))
              (nonzero? (-> (the-as process-drawable v1-15) node-list))
              )
         (spawn-from-cspace (-> self part) (-> (the-as process-drawable v1-15) node-list data (-> self target-joint)))
         (set! (-> self root trans quad) (-> self part origin trans quad))
         )
        (else
          (let ((a0-11 (-> self root trans)))
            (set! (-> self mat trans quad) (-> a0-11 quad))
            )
          (spawn-from-mat (-> self part) (-> self mat))
          )
        )
      )
    )
  :code sleep-code
  )

(defstate linger (part-tracker)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (-> self linger-callback)
        ((-> self linger-callback) self)
        )
    (if (time-elapsed? (-> self state-time) (-> self linger-duration))
        (go-virtual die)
        )
    (let* ((gp-0 (handle->process (-> self target)))
           (v1-13 (if (type? gp-0 process-drawable)
                      gp-0
                      )
                  )
           )
      (if (and v1-13
               (nonzero? (-> (the-as process-drawable v1-13) root))
               (nonzero? (-> (the-as process-drawable v1-13) node-list))
               )
          (vector<-cspace!
            (-> self root trans)
            (-> (the-as process-drawable v1-13) node-list data (-> self target-joint))
            )
          )
      )
    )
  :code sleep-code
  )

(defstate die (part-tracker)
  :virtual #t
  :enter (behavior ()
    (notify-parent-of-death self)
    )
  :code (behavior ()
    (suspend)
    0
    )
  )

(defstate active (part-tracker-subsampler)
  :virtual #t
  :trans (behavior ()
    (if (and (nonzero? (-> self duration)) (time-elapsed? (-> self state-time) (-> self duration)))
        (go-virtual linger)
        )
    (if (-> self callback)
        ((-> self callback) self)
        )
    (let* ((gp-0 (handle->process (-> self target)))
           (v1-15 (if (type? gp-0 process-drawable)
                      gp-0
                      )
                  )
           )
      (cond
        ((and v1-15
              (nonzero? (-> (the-as process-drawable v1-15) root))
              (nonzero? (-> (the-as process-drawable v1-15) node-list))
              )
         (init-with-mat!
           (-> self subsampler)
           (-> (the-as process-drawable v1-15) node-list data (-> self target-joint) bone transform)
           )
         (set! (-> self root trans quad) (-> self subsampler spawn-mat trans quad))
         )
        (else
          (let ((a0-11 (-> self root trans)))
            (set! (-> self mat trans quad) (-> a0-11 quad))
            )
          (init-with-mat! (-> self subsampler) (-> self mat))
          )
        )
      )
    )
  )

(defbehavior part-tracker-init-base part-tracker ((arg0 sparticle-launch-group)
                                        (arg1 time-frame)
                                        (arg2 (function part-tracker vector))
                                        (arg3 uint)
                                        (arg4 process-drawable)
                                        (arg5 object)
                                        )
  (stack-size-set! (-> self main-thread) 16)
  (when (= pointer process-tree)
    (+! (-> self clock ref-count) -1)
    (+! (-> *display* part-clock ref-count) 1)
    (set! (-> self clock) (-> *display* part-clock))
    )
  (set! (-> self target) (process->handle arg4))
  (cond
    (arg4
      (set! (-> self target-joint) (the-as int arg5))
      )
    ((logtest? (-> arg0 flags) (sp-group-flag sp5))
     (let* ((s1-1 (-> self mat))
            (a2-1 (math-camera-matrix))
            (v1-18 (-> a2-1 rvec quad))
            (a0-10 (-> a2-1 uvec quad))
            (a1-2 (-> a2-1 fvec quad))
            (a2-2 (-> a2-1 trans quad))
            )
       (set! (-> s1-1 rvec quad) v1-18)
       (set! (-> s1-1 uvec quad) a0-10)
       (set! (-> s1-1 fvec quad) a1-2)
       (set! (-> s1-1 trans quad) a2-2)
       )
     (set! (-> self mat trans quad) (-> (the-as matrix arg5) trans quad))
     (set! (-> self offset quad) (-> self mat trans quad))
     )
    (else
      (let* ((v1-21 (-> self mat))
             (a3-1 (the-as matrix arg5))
             (a0-15 (-> a3-1 rvec quad))
             (a1-3 (-> a3-1 uvec quad))
             (a2-3 (-> a3-1 fvec quad))
             (a3-2 (-> a3-1 trans quad))
             )
        (set! (-> v1-21 rvec quad) a0-15)
        (set! (-> v1-21 uvec quad) a1-3)
        (set! (-> v1-21 fvec quad) a2-3)
        (set! (-> v1-21 trans quad) a3-2)
        )
      (set! (-> self offset quad) (-> self mat trans quad))
      )
    )
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> self mat trans quad))
  (if (zero? arg0)
      (go process-drawable-art-error "null group")
      )
  (set! (-> self callback) arg2)
  (set! (-> self linger-callback) #f)
  (set! (-> self userdata) arg3)
  (set! arg1 (cond
               ((> arg1 0)
                (empty)
                arg1
                )
               ((= arg1 -1)
                0
                )
               (else
                 (the-as time-frame (-> arg0 duration))
                 )
               )
        )
  (set! (-> self duration) (the-as time-frame arg1))
  (set! (-> self linger-duration) (the-as time-frame (-> arg0 linger-duration)))
  (if (or (zero? (+ (-> self duration) (seconds 0.007))) (= (-> self duration) (seconds 218.447)))
      (deactivate self)
      )
  (none)
  )

(defpart 57
  :init-specs ((:texture (middot level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 1))
    (:scale-y :copy scale-x)
    (:timer (seconds 0.1))
    )
  )

(defbehavior part-tracker-subsampler-init part-tracker-subsampler ((arg0 part-tracker-subsampler-init-params))
  (part-tracker-init-base
    (-> arg0 group)
    (-> arg0 duration)
    (-> arg0 callback)
    (-> arg0 userdata)
    (-> arg0 target)
    (-> arg0 mat-joint)
    )
  (dotimes (s5-0 1)
    (let* ((v1-2 (-> arg0 group launcher s5-0))
           (s4-0 (-> *part-id-table* (-> v1-2 launcher)))
           )
      (let ((a2-1 (if (logtest? (-> v1-2 flags) (sp-group-item-flag is-3d))
                      *sp-particle-system-3d*
                      *sp-particle-system-2d*
                      )
                  )
            )
        self
        (set! (-> self subsampler)
              (new 'process 'sparticle-subsampler a2-1 (-> *part-id-table* 57) (-> arg0 subsample-num))
              )
        )
      (set! (-> self subsampler sp-launcher) s4-0)
      )
    )
  (go-virtual active)
  )

(defbehavior part-tracker-init part-tracker ((arg0 part-tracker-init-params))
  (part-tracker-init-base
    (-> arg0 group)
    (-> arg0 duration)
    (-> arg0 callback)
    (-> arg0 userdata)
    (-> arg0 target)
    (-> arg0 mat-joint)
    )
  (set! (-> self part) (create-launch-control (-> arg0 group) self))
  (when (and (-> arg0 target) (logtest? (-> self part group flags) (sp-group-flag sp12 sp14)))
    (let* ((gp-0 (-> self part))
           (s5-0 (method-of-object gp-0 set-local-space-info))
           (s4-0 (add-connection *part-local-space-engine* self local-space-proc-joint (-> self target-joint) 0 0))
           )
      (let ((v1-10 (process->handle (-> arg0 target))))
        (if (= v1-10 #f)
            (set! v1-10 (process->handle self))
            )
        (set! (-> (the-as particle-local-space-info s4-0) hand) (the-as handle v1-10))
        )
      (matrix-identity! (-> (the-as particle-local-space-info s4-0) mat-new))
      (matrix-identity! (-> (the-as particle-local-space-info s4-0) mat-prev))
      (set! (-> (the-as particle-local-space-info s4-0) flags)
            (if (logtest? (-> self part group flags) (sp-group-flag sp14))
                (part-local-space-flags pls0)
                (part-local-space-flags)
                )
            )
      (s5-0 gp-0 (the-as particle-local-space-info s4-0))
      )
    )
  (set! (-> self event-hook) (-> (method-of-object self active) event))
  (go-virtual active)
  )

(defun part-tracker-track-root ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (let ((v1-3 (-> arg1 key proc root trans)))
    (set! (-> arg2 x) (-> v1-3 x))
    (set! (-> arg2 y) (-> v1-3 y))
    (set! (-> arg2 z) (-> v1-3 z))
    )
  0
  (none)
  )

(defun part-tracker-move-to-target ((arg0 part-tracker))
  (let* ((a0-1 *target*)
         (a2-0 (if (not a0-1)
                   (-> arg0 root trans)
                   (get-trans a0-1 3)
                   )
               )
         )
    (vector-lerp!
      (-> arg0 root trans)
      (-> arg0 offset)
      a2-0
      (* 0.006666667 (the float (- (current-time) (-> arg0 state-time))))
      )
    )
  )

(defun part-tracker-track-target ((arg0 part-tracker))
  (set! (-> arg0 linger-callback) (-> arg0 callback))
  (let* ((a0-1 *target*)
         (v1-2 (if (not a0-1)
                   (-> arg0 root trans)
                   (get-trans a0-1 3)
                   )
               )
         (v0-1 (-> arg0 root trans))
         )
    (set! (-> v0-1 quad) (-> v1-2 quad))
    v0-1
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod notify-parent-of-death ((this lightning-tracker))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer pp))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'notify)
      (set! (-> gp-0 param 0) (the-as uint 'die))
      (let ((s5-0 send-event-function)
            (s4-0 (ppointer->process (-> this parent)))
            )
        (s5-0
          (if (type? s4-0 process)
              s4-0
              )
          gp-0
          )
        )
      )
    (none)
    )
  )

(defmethod update ((this lightning-tracker))
  (if (-> this callback)
      ((-> this callback) this)
      )
  (let ((a0-6 (cond
                ((>= (-> this target-joint0) 0)
                 (let ((s5-0 (handle->process (-> this target0))))
                   (if (type? s5-0 process-drawable)
                       s5-0
                       )
                   )
                 )
                (else
                  (the-as process #f)
                  )
                )
              )
        )
    (cond
      ((< (-> this target-joint0) 0)
       (when (and (!= (-> this lightning spec rand-func) 3) (!= (-> this lightning spec rand-func) 2))
         (let ((v1-17 (-> this lightning))
               (a0-9 (-> this offset0))
               )
           (set! (-> v1-17 state meet data 0 quad) (-> a0-9 quad))
           )
         )
       )
      ((or (not a0-6) (zero? (-> (the-as process-drawable a0-6) root)))
       (deactivate this)
       )
      ((= (-> this target-joint0) 256)
       (let ((s5-1 (-> this lightning))
             (a0-12 (get-trans (the-as process-focusable a0-6) 3))
             )
         (set! (-> s5-1 state meet data 0 quad) (-> a0-12 quad))
         )
       )
      (else
        (let ((s5-2 (-> this lightning))
              (a0-16 (vector<-cspace!
                       (new 'stack-no-clear 'vector)
                       (-> (the-as process-focusable a0-6) node-list data (-> this target-joint0))
                       )
                     )
              )
          (set! (-> s5-2 state meet data 0 quad) (-> a0-16 quad))
          )
        )
      )
    )
  (let ((a0-22 (cond
                 ((>= (-> this target-joint1) 0)
                  (let ((s5-3 (handle->process (-> this target1))))
                    (if (type? s5-3 process-drawable)
                        (the-as process-focusable s5-3)
                        )
                    )
                  )
                 (else
                   (the-as process-focusable #f)
                   )
                 )
               )
        )
    (cond
      ((< (-> this target-joint1) 0)
       (when (and (!= (-> this lightning spec rand-func) 3) (!= (-> this lightning spec rand-func) 2))
         (let ((a0-26 (-> this lightning))
               (v1-44 (-> this offset1))
               )
           (set! (-> a0-26 state meet data (+ (-> a0-26 state points-to-draw) -1) quad) (-> v1-44 quad))
           )
         )
       )
      ((or (not a0-22) (zero? (-> a0-22 root)))
       (deactivate this)
       )
      ((= (-> this target-joint1) 256)
       (let ((gp-1 (-> this lightning))
             (v1-51 (get-trans a0-22 3))
             )
         (set! (-> gp-1 state meet data (+ (-> gp-1 state points-to-draw) -1) quad) (-> v1-51 quad))
         )
       )
      (else
        (let ((s5-4 (-> this lightning))
              (v1-54 (vector<-cspace! (new 'stack-no-clear 'vector) (-> a0-22 node-list data (-> this target-joint1))))
              )
          (set! (-> s5-4 state meet data (+ (-> s5-4 state points-to-draw) -1) quad) (-> v1-54 quad))
          )
        )
      )
    )
  0
  (none)
  )

(defstate active (lightning-tracker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (deactivate self)
       )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound))
      (let ((v1-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-1 command) (sound-command set-param))
        (set! (-> v1-1 id) (-> self sound))
        (set! (-> v1-1 params volume) -4)
        (set! (-> v1-1 auto-time) 240)
        (set! (-> v1-1 auto-from) 2)
        (set! (-> v1-1 params mask) (the-as uint 17))
        (-> v1-1 id)
        )
      )
    )
  :code (behavior ()
    (set! (-> self sound) (new 'static 'sound-id))
    (when (!= (+ (-> self lightning spec delay) (-> self lightning spec delay-rand)) 0.0)
      (let ((gp-0 (current-time))
            (s5-0 (the int (rand-vu-float-range
                             (-> self lightning spec delay)
                             (+ (-> self lightning spec delay) (-> self lightning spec delay-rand))
                             )
                       )
                  )
            )
        (while (not (time-elapsed? gp-0 s5-0))
          (suspend)
          )
        )
      )
    (let ((gp-1 (-> self lightning spec sound)))
      (when gp-1
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (set! (-> s5-1 quad) (-> self offset1 quad))
          (when (and (>= (-> self target-joint1) 0) (< (-> self target-joint1) 256))
            (let* ((s4-0 (handle->process (-> self target1)))
                   (v1-28 (if (type? s4-0 process-drawable)
                              (the-as process-drawable s4-0)
                              )
                          )
                   )
              (if (and v1-28 (nonzero? (-> v1-28 root)))
                  (set! (-> s5-1 quad)
                        (-> (vector<-cspace! (new 'stack-no-clear 'vector) (-> v1-28 node-list data (-> self target-joint1))) quad)
                        )
                  )
              )
            )
          (set! (-> self sound) (sound-play-by-spec gp-1 (new-sound-id) s5-1))
          )
        )
      )
    (let ((v1-33 (-> self lightning))
          (a0-10 1)
          )
      (let ((a1-10 (!= a0-10 (-> v1-33 state mode))))
        (case a0-10
          ((3)
           (if a1-10
               (set! (-> v1-33 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-33 state start-color) (-> v1-33 spec start-color))
           (set! (-> v1-33 state end-color) (-> v1-33 spec end-color))
           )
          )
        )
      (set! (-> v1-33 state mode) (the-as uint a0-10))
      )
    (set-time! (-> self start-time))
    (while (or (zero? (-> self duration)) (not (time-elapsed? (-> self start-time) (-> self duration))))
      (update self)
      (suspend)
      )
    (let ((f30-0 (-> self lightning spec fade-time)))
      (when (< 0.0 f30-0)
        (let ((v1-47 (-> self lightning))
              (a0-14 3)
              )
          (let ((a1-20 (!= a0-14 (-> v1-47 state mode))))
            (case a0-14
              ((3)
               (if a1-20
                   (set! (-> v1-47 state counter) 0.0)
                   )
               )
              ((1)
               (set! (-> v1-47 state start-color) (-> v1-47 spec start-color))
               (set! (-> v1-47 state end-color) (-> v1-47 spec end-color))
               )
              )
            )
          (set! (-> v1-47 state mode) (the-as uint a0-14))
          )
        (set-time! (-> self start-time))
        (while (not (time-elapsed? (-> self start-time) (the int f30-0)))
          (suspend)
          )
        )
      )
    (let ((v1-54 (-> self lightning))
          (a0-17 0)
          )
      (let ((a1-30 (!= a0-17 (-> v1-54 state mode))))
        (case a0-17
          ((3)
           (if a1-30
               (set! (-> v1-54 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-54 state start-color) (-> v1-54 spec start-color))
           (set! (-> v1-54 state end-color) (-> v1-54 spec end-color))
           )
          )
        )
      (set! (-> v1-54 state mode) (the-as uint a0-17))
      )
    (notify-parent-of-death self)
    (suspend)
    0
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior lightning-tracker-init lightning-tracker ((arg0 lightning-spec) (arg1 time-frame) (arg2 symbol) (arg3 process-drawable) (arg4 vector) (arg5 vector))
  (stack-size-set! (-> self main-thread) 128)
  (set! (-> self target0) (process->handle arg3))
  (let ((s1-1 (ppointer->process (-> self parent))))
    (set! (-> self target1) (process->handle (the-as process (if (type? s1-1 process-drawable)
                                                                 s1-1
                                                                 )
                                                     )
                                             )
          )
    )
  ;; Note: there's some changes here to skip setting things if arg4 is #f.
  ;; the address of #f is misaligned, but on ps2 the lq instruction will silently mask.
  ;; Loading from #f doesn't really make sense, so this was likely just a mistake in the
  ;; original game.
  ;; the OpenGOAL compiler uses vmovaps, which will crash on a misaligned load because
  ;; this has been useful for finding errors. So to prevent this crash, we skip the load
  ;; if the argument is #f. (some callers of this directly pass #f, so it's not a bug higher up).
  (cond
    ((>= 256 (the-as int arg4))
     (set! (-> self target-joint0) (the-as int arg4))
     (vector-identity! (-> self offset0))
     )
    (else
      (set! (-> self target-joint0) -1)
      ;: og:preserve-this hack, fixed bug in original game
      (when arg4
        (set! (-> self offset0 quad) (-> arg4 quad))
        )
      )
    )
  (cond
    ((>= 256 (the-as int arg5))
     (set! (-> self target-joint1) (the-as int arg5))
     (vector-identity! (-> self offset1))
     )
    (else
      (set! (-> self target-joint1) -1)
      ;: og:preserve-this hack, fixed bug in original game
      (when arg5
        (set! (-> self offset1 quad) (-> arg5 quad))
        )
      )
    )
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self callback) (the-as (function lightning-tracker none) arg2))
  (set! arg1
        (cond
          ((> arg1 0)
           (empty)
           arg1
           )
          ((= arg1 -1)
           0
           )
          (else
            (the-as
              time-frame
              (the int (rand-vu-float-range (-> arg0 duration) (+ (-> arg0 duration) (-> arg0 duration-rand))))
              )
            )
          )
        )
  (set! (-> self duration) (the-as time-frame arg1))
  (set! (-> self lightning) (new 'process 'lightning-control arg0 self 0.0))
  (let ((v1-21 (-> self lightning))
        (a0-17 0)
        )
    (let ((a1-7 (!= a0-17 (-> v1-21 state mode))))
      (case a0-17
        ((3)
         (if a1-7
             (set! (-> v1-21 state counter) 0.0)
             )
         )
        ((1)
         (set! (-> v1-21 state start-color) (-> v1-21 spec start-color))
         (set! (-> v1-21 state end-color) (-> v1-21 spec end-color))
         )
        )
      )
    (set! (-> v1-21 state mode) (the-as uint a0-17))
    )
  (go-virtual active)
  (none)
  )

;; WARN: Return type mismatch object vs symbol.
(defbehavior process-grab? process ((arg0 process) (arg1 symbol))
  (let ((a0-1 (command-get-process arg0 *target*)))
    (the-as symbol (if a0-1
                       (send-event a0-1 'change-mode 'grab (cond
                                                             ((= arg1 #t)
                                                              #f
                                                              )
                                                             ((= arg1 'dead)
                                                              'dead
                                                              )
                                                             (else
                                                               #t
                                                               )
                                                             )
                                   )
                       )
            )
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defbehavior process-release? process ((arg0 process))
  (let* ((gp-0 (command-get-process arg0 *target*))
         (a0-2 (if (type? gp-0 process-focusable)
                   gp-0
                   )
               )
         )
    (the-as symbol (if (and a0-2 (focus-test? (the-as process-focusable a0-2) grabbed))
                       (send-event a0-2 'end-mode 'grab)
                       #t
                       )
            )
    )
  )

(defun camera-look-at ((arg0 pair) (arg1 uint))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (if gp-0
        (send-event *camera* 'change-target gp-0 arg1)
        )
    gp-0
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defun ja-anim-done? ((arg0 process))
  (with-pp
    (let ((gp-0 (command-get-process arg0 *target*)))
      (the-as
        symbol
        (when gp-0
          (cond
            ((type? gp-0 manipy)
             (send-event gp-0 'query 'done)
             )
            ((type? gp-0 process-drawable)
             (when (not (logtest? (-> (the-as process-drawable gp-0) skel status) (joint-control-status spooling-not-last-block))
                        )
               (let ((s5-0 pp))
                 (set! pp gp-0)
                 (let ((v0-1 (the-as object (ja-done? 0))))
                   (set! pp s5-0)
                   v0-1
                   )
                 )
               )
             )
            )
          )
        )
      )
    )
  )

(defun camera-pov-from ((arg0 pair) (arg1 uint))
  (let ((gp-0 (command-get-process arg0 *target*)))
    (when gp-0
      (when (= arg1 -10)
        (set! arg1 (the-as uint 0))
        (when (> (-> (the-as process-drawable gp-0) skel active-channels) 0)
          (let ((v1-7 (the-as
                        joint
                        (get-art-by-name-method (-> (the-as process-drawable gp-0) draw jgeo) "camera" (the-as type #f))
                        )
                      )
                )
            (if v1-7
                (set! arg1 (the-as uint (+ (-> v1-7 number) 1)))
                )
            )
          )
        )
      (let ((v1-9 (process->ppointer gp-0)))
        (set-setting! 'pov-handle v1-9 (the float arg1) (-> v1-9 0 pid))
        )
      )
    gp-0
    )
  )

(deftype med-res-level (process-drawable)
  ((level-name  symbol)
   (part-mode   symbol)
   (index       int32)
   )
  (:state-methods
    idle
    )
  )


(defstate idle (med-res-level)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((v1-1 (level-get *level* (-> self level-name))))
        (cond
          ((and v1-1 (= (-> v1-1 display?) 'special))
           (logclear! (-> self draw status) (draw-control-status no-draw))
           (if (nonzero? (-> self skel))
               (ja :num! (loop!))
               )
           )
          ((and v1-1 (= (-> v1-1 status) 'active))
           (logior! (-> self draw status) (draw-control-status no-draw))
           )
          (else
            (logclear! (-> self draw status) (draw-control-status no-draw))
            (if (nonzero? (-> self skel))
                (ja :num! (loop!))
                )
            )
          )
        )
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this med-res-level) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 128)
  (let ((s4-0 (res-lump-struct arg0 'art-name structure))
        (s3-0 (res-lump-struct (-> this entity) 'level structure))
        (v1-5 (res-lump-value (-> this entity) 'index uint128 :time -1000000000.0))
        )
    (when s3-0
      (set! (-> this level-name) (the-as symbol s3-0))
      (set! (-> this index) (the-as int v1-5))
      (set! (-> this root) (new 'process 'trsqv))
      (process-drawable-from-entity! this arg0)
      (logclear! (-> this mask) (process-mask actor-pause))
      (initialize-skeleton-by-name this (the-as string s4-0))
      (logior! (-> this draw status) (draw-control-status no-closest-distance))
      (if (nonzero? (-> this draw))
          (go (method-of-object this idle))
          )
      )
    )
  )

(defmethod deactivate ((this part-spawner))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  (if (nonzero? (-> this sound))
      (stop! (-> this sound))
      )
  (if (nonzero? (-> this sound-extra))
      (stop! (-> this sound-extra))
      )
  ((method-of-type process deactivate) this)
  (none)
  )

(defmethod is-in-view? ((this part-spawner))
  (sphere<-vector+r! (-> this world-sphere) (-> this root trans) (-> this radius))
  (sphere-in-view-frustum? (-> this world-sphere))
  )

(defstate active (part-spawner)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stop)
       (process-entity-status! self (entity-perm-status subtask-complete) #t)
       (set! (-> self enable) #f)
       #t
       )
      (('start)
       (process-entity-status! self (entity-perm-status subtask-complete) #f)
       (set! (-> self enable) #t)
       #t
       )
      (('trans)
       (let ((v0-1 (the-as object (-> (the-as vector (-> block param 0)) quad))))
         (set! (-> self root trans quad) (the-as uint128 v0-1))
         v0-1
         )
       )
      )
    )
  :trans (behavior ()
    (when (-> self enable)
      (when (nonzero? (-> self path))
        (debug-draw (-> self path))
        (get-point-at-percent-along-path! (-> self path) (-> self root trans) (-> self path-pos) 'interp)
        (displacement-between-points-at-percent-normalized! (-> self path) (-> self last-velocity) (-> self path-pos))
        (let ((f0-3 (+ (-> self path-pos) (* (-> self path-speed) (seconds-per-frame)))))
          (set! (-> self path-pos) f0-3)
          (set! (-> self path-pos) (- f0-3 (* (the float (the int (/ f0-3 1.0))) 1.0)))
          )
        )
      (spawn (-> self part) (-> self root trans))
      (when (nonzero? (-> self sound))
        (update-trans! (-> self sound) (-> self root trans))
        (update! (-> self sound))
        )
      (when (nonzero? (-> self sound-extra))
        (update-trans! (-> self sound-extra) (-> self root trans))
        (update! (-> self sound-extra))
        )
      )
    )
  :code sleep-code
  )

(defmethod init-from-entity! ((this part-spawner) (arg0 entity-actor))
  (local-vars (sv-16 string))
  (stack-size-set! (-> this main-thread) 64)
  (logior! (-> this mask) (process-mask ambient))
  (+! (-> this clock ref-count) -1)
  (+! (-> *display* part-clock ref-count) 1)
  (set! (-> this clock) (-> *display* part-clock))
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (quaternion-copy! (-> this root quat) (-> arg0 quat))
  (vector-identity! (-> this root scale))
  (set! (-> this radius) 12288.0)
  (set! (-> this enable)
        (not (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
             )
        )
  (set! (-> this sound) (new 'process 'ambient-sound (-> this entity) (-> this root trans) 0.0))
  (set! (-> this sound-extra) (new 'process 'ambient-sound (-> this entity) (-> this root trans) 1.0))
  (when (res-lump-data arg0 'path pointer)
    (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
    (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
    (set! (-> this path-speed) (res-lump-float arg0 'speed :default 1.0))
    )
  (let ((v1-36 (res-lump-struct arg0 'trans-offset structure)))
    (if v1-36
        (vector+! (-> this root trans) (-> this root trans) (the-as vector v1-36))
        )
    )
  (let ((s4-0 (res-lump-struct arg0 'rot-offset (pointer degrees))))
    (when s4-0
      (if (< 0.0 (-> s4-0 0))
          (quaternion-rotate-local-x! (-> this root quat) (-> this root quat) (-> s4-0 0))
          )
      (if (< 0.0 (-> s4-0 1))
          (quaternion-rotate-local-y! (-> this root quat) (-> this root quat) (-> s4-0 1))
          )
      (if (< 0.0 (-> s4-0 2))
          (quaternion-rotate-local-z! (-> this root quat) (-> this root quat) (-> s4-0 2))
          )
      )
    )
  (set! sv-16 "#f")
  (set! (-> this mode) (entity-lookup-part-group arg0 (& sv-16) 'art-name))
  (when (-> this mode)
    (let ((s5-1 (-> this mode 0)))
      (when (and (nonzero? s5-1) (= (-> s5-1 type) sparticle-launch-group))
        (cond
          ((logtest? (-> s5-1 flags) (sp-group-flag sp8))
           (countdown (v1-60 (-> s5-1 length))
             (let* ((a0-34 (-> s5-1 launcher v1-60))
                    (a2-12 (-> *part-id-table* (-> a0-34 launcher)))
                    )
               (when (nonzero? a2-12)
                 (let ((a1-22 (-> this level part-engine)))
                   (when (and a1-22 (< (-> a1-22 length) (-> a1-22 allocated-length)))
                     (let ((a3-14 (-> a1-22 data (-> a1-22 length))))
                       (set! (-> a3-14 next1) (the-as connectable a2-12))
                       (set! (-> a3-14 prev1) (the-as connectable (-> a0-34 hour-mask)))
                       (set! (-> (the-as vector (&-> a3-14 param0)) quad) (-> this root trans quad))
                       (set! (-> a3-14 param3) (the-as int (-> a0-34 fade-after)))
                       )
                     (+! (-> a1-22 length) 1)
                     )
                   )
                 )
               )
             )
           (process-entity-status! this (entity-perm-status dead) #t)
           (deactivate this)
           )
          ((logtest? (-> s5-1 flags) (sp-group-flag sp9))
           (process-entity-status! this (entity-perm-status dead) #t)
           (deactivate this)
           )
          (else
            (set! (-> this part) (create-launch-control s5-1 this))
            (when (logtest? (-> s5-1 flags) (sp-group-flag sp10))
              (process-entity-status! this (entity-perm-status subtask-complete) #t)
              (set! (-> this enable) #f)
              )
            (go (method-of-object this active))
            )
          )
        )
      )
    )
  (go process-drawable-art-error sv-16)
  )

(deftype launcher (process-drawable)
  ((spring-height    meters)
   (camera           state)
   (active-distance  float)
   (seek-time        time-frame)
   (dest             vector  :inline)
   (sound-id         sound-id)
   )
  (:state-methods
    idle
    active
    deactivated
    )
  )


(defpartgroup group-beach-launcher
  :id 7
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 58 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 59 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 60 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 61 :fade-after (meters 50) :falloff-to (meters 80))
    (sp-item 62 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 58
  :init-specs ((:num 1.5)
    (:x (meters 1.5))
    (:y (meters -0.5))
    (:rot-x 5)
    (:r 4096.0)
    (:g 2867.2)
    (:b 3276.8)
    (:vel-y (meters 0.026666667))
    (:timer (seconds 0.9))
    (:flags (distort))
    (:next-time (seconds 0.6))
    (:next-launcher 63)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 63
  :init-specs ((:fade-b -4.551111))
  )

(defpart 59
  :init-specs ((:texture (hotdot level-default-sprite))
    (:num 1.0)
    (:x (meters 0) (meters 1.8))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 60
  :init-specs ((:texture (hotdot level-default-sprite))
    (:num 2.0)
    (:x (meters 1.8) (meters 1))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 61
  :init-specs ((:texture (woodchip level-default-sprite))
    (:num 1.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 0.3) (meters 0.4))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.1))
    (:r 10.0 6.0)
    (:g 64.0 128.0)
    (:b 10.0 6.0)
    (:a 80.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a -0.2)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.6) (seconds 0.397))
    (:flags (sp-cpuinfo-flag-2))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 62
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.15))
    (:next-launcher 64)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 64
  :init-specs ((:fade-a -0.18))
  )

(defpartgroup group-jungle-launcher
  :id 8
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 58 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 65 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 66 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 67 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 65
  :init-specs ((:texture (hotdot level-default-sprite))
    (:num 1.0)
    (:x (meters 0) (meters 1.4))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.24414062) (meters 0.48828125))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 66
  :init-specs ((:texture (hotdot level-default-sprite))
    (:num 2.0)
    (:x (meters 1.4) (meters 0.9))
    (:scale-x (meters 0.2))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.5) (meters 1))
    (:r 0.0 1 128.0)
    (:g 64.0 196.0)
    (:b 128.0 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.0025))
    (:scalevel-y (meters 0.048828125) (meters 0.09765625))
    (:timer (seconds 0.27))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 67
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 64.0 32.0)
    (:g 32.0 32.0)
    (:b 10.0 5.0)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.15))
    (:next-launcher 64)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-swamp-launcher
  :id 9
  :bounds (static-bspherem 0 3 0 5)
  :parts ((sp-item 58 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 59 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 60 :fade-after (meters 70) :falloff-to (meters 100) :flags (is-3d))
    (sp-item 68 :fade-after (meters 70) :falloff-to (meters 100))
    )
  )

(defpart 68
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:num 0.5)
    (:x (meters 2.9) (meters 2.5))
    (:y (meters -0.5))
    (:scale-x (meters 2) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 16.0 16.0)
    (:g 16.0 16.0)
    (:b 5.0 2.5)
    (:a 0.0)
    (:vel-x (meters -0.011666667) (meters -0.0033333334))
    (:vel-y (meters 0))
    (:rotvel-z (degrees -1.2) 1 (degrees 2.4))
    (:fade-a 0.6)
    (:accel-y (meters 0.0016666667))
    (:friction 0.996)
    (:timer (seconds 0.9))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.15))
    (:next-launcher 64)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defbehavior cam-launcher-joystick camera-slave ()
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (set! (-> s5-0 rvec quad) (the-as uint128 0))
      (set! (-> s5-0 uvec quad) (the-as uint128 0))
      (set! (-> s5-0 fvec quad) (the-as uint128 0))
      (set! (-> s5-0 trans quad) (the-as uint128 0))
      (let ((gp-0 (vector-reset! (new 'stack-no-clear 'vector))))
        (let* ((f0-0 (analog-input (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))
               (f0-1 (* -546.13336 f0-0))
               (f0-3 (fmin 546.13336 (fmax -546.13336 f0-1)))
               )
          (matrix-axis-angle! s5-0 (-> *camera* local-down) f0-3)
          )
        (vector-! gp-0 (-> self trans) (-> *camera* tpos-curr))
        (vector-matrix*! gp-0 gp-0 s5-0)
        (vector+! (-> self trans) gp-0 (-> *camera* tpos-curr))
        )
      )
    )
  )

(defstate cam-launcher-shortfall (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
        (vector-flatten! gp-0 (-> self tracking inv-mat fvec) (-> *camera* local-down))
        (vector-normalize! gp-0 1.0)
        (set! (-> self pivot-pt quad) (-> gp-0 quad))
        (vector+float*! gp-0 gp-0 (-> *camera* local-down) 1000.0)
        (vector-normalize-copy! (-> self tracking inv-mat fvec) gp-0 1.0)
        )
      (vector-cross!
        (-> self tracking inv-mat uvec)
        (-> self tracking inv-mat fvec)
        (the-as vector (-> self tracking))
        )
      (set! (-> self blend-from-type) (camera-blend-from-type unknown-0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
          (send-event *camera* 'teleport)
          (if (and (-> *camera* on-ground) (time-elapsed? gp-0 (seconds 1)))
              (send-event *camera* 'change-state cam-string (seconds 0.5))
              )
          )
        (suspend)
        )
      )
    #f
    )
  )

(defbehavior cam-launcher-long-joystick camera-slave ()
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (set! (-> gp-0 rvec quad) (the-as uint128 0))
      (set! (-> gp-0 uvec quad) (the-as uint128 0))
      (set! (-> gp-0 fvec quad) (the-as uint128 0))
      (set! (-> gp-0 trans quad) (the-as uint128 0))
      (let* ((f0-0 (analog-input (the-as int (+ (-> *cpad-list* cpads 0 rightx) -128)) 0.0 48.0 110.0 -1.0))
             (f0-1 (* -546.13336 f0-0))
             (f0-3 (fmin 546.13336 (fmax -546.13336 f0-1)))
             )
        (matrix-axis-angle! gp-0 (-> *camera* local-down) f0-3)
        )
      (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
      )
    (vector-normalize! (-> self view-flat) 4096.0)
    )
  )

(defstate cam-launcher-longfall (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (new 'stack-no-clear 'vector)
      (vector-negate! (-> self view-flat) (-> self tracking inv-mat fvec))
      (vector-normalize! (-> self view-flat) 4096.0)
      (vector--float*! (-> self trans) (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
      (vector+! (-> self trans) (-> self trans) (-> self view-flat))
      (set! (-> self blend-from-type) (camera-blend-from-type unknown-0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      (cam-calc-follow! (-> self tracking) (-> self trans) #f)
      (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
      )
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (cam-launcher-long-joystick)
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (let ((s4-0 (new 'stack-no-clear 'vector))
                (s5-0 (new 'stack-no-clear 'vector))
                )
            0.0
            0.0
            0.0
            (send-event *camera* 'teleport)
            (let* ((f0-4 (vector-dot (-> self velocity) (-> *camera* local-down)))
                   (f30-0 (* 0.975 f0-4))
                   )
              (vector--float*! s4-0 (-> *camera* tpos-curr) (-> *camera* local-down) 28672.0)
              (vector-! s4-0 s4-0 (-> self trans))
              (let ((f28-0 (vector-dot s4-0 (-> *camera* local-down))))
                (vector--float*! s5-0 s4-0 (-> *camera* local-down) f28-0)
                (cond
                  ((< f28-0 f30-0)
                   (set! f30-0 f28-0)
                   )
                  ((< 20480.0 f28-0)
                   (let ((f28-1 (+ -20480.0 f28-0)))
                     (let ((f0-8 (lerp f30-0 f28-1 0.005)))
                       (if (< f30-0 f0-8)
                           (set! f30-0 f0-8)
                           )
                       )
                     (if (< (* 0.09 f28-1) f30-0)
                         (set! f30-0 (* 0.09 f28-1))
                         )
                     )
                   )
                  )
                )
              (vector+float*! (-> self velocity) s5-0 (-> *camera* local-down) f30-0)
              )
            )
          (vector+! (-> self trans) (-> self trans) (-> self velocity))
          (set! (-> self trans x) (-> *camera* tpos-curr x))
          (set! (-> self trans z) (-> *camera* tpos-curr z))
          (vector+! (-> self trans) (-> self trans) (-> self view-flat))
          (if (and (-> *camera* on-ground) (time-elapsed? gp-0 (seconds 1)))
              (send-event *camera* 'change-state cam-string (seconds 0.5))
              )
          )
        (vector-reset! (-> self tracking follow-off))
        (vector+! (-> self tracking follow-pt) (-> *camera* tpos-curr-adj) (-> self tracking follow-off))
        (vector--float*!
          (-> self tracking follow-pt)
          (-> self tracking follow-pt)
          (-> *camera* local-down)
          (-> *camera* settings target-height)
          )
        (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
        (suspend)
        )
      )
    #f
    )
  )

(defstate idle (launcher)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('instant-death)
       (go-virtual deactivated)
       )
      (('trans)
       (move-to-point! (the-as collide-shape (-> self root)) (the-as vector (-> block param 0)))
       (update-transforms (the-as collide-shape (-> self root)))
       )
      )
    )
  :trans (behavior ()
    (when (and *target*
               (and (>= (-> self active-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                    (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                    )
               )
      (cond
        ((send-event *target* 'query 'powerup (pickup-type eco-blue))
         (go-virtual active)
         )
        (else
          (let ((gp-0 'target-launch))
            (if (= (send-event *target* 'query 'mode) gp-0)
                (send-event *target* 'end-mode 'launch)
                )
            )
          )
        )
      (if (and (and *target* (and (>= 32768.0 (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                                  (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                  )
                    )
               (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
               )
          (talker-spawn-func (-> *talker-speech* 44) *entity-pool* (target-pos 0) (the-as region #f))
          )
      )
    )
  :code sleep-code
  )

(defstate active (launcher)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (or (= message 'touch) (= message 'attack))
      (set-time! (-> self state-time))
      (send-event proc 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
      )
    (cond
      ((= message 'instant-death)
       (go-virtual deactivated)
       )
      ((= message 'trans)
       (move-to-point! (the-as collide-shape (-> self root)) (the-as vector (-> block param 0)))
       (update-transforms (the-as collide-shape (-> self root)))
       )
      )
    )
  :exit (behavior ()
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 120)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    )
  :trans (behavior ()
    (if (or (or (not *target*)
                (or (< (-> self active-distance) (vector-vector-distance (-> self root trans) (-> *target* control trans)))
                    (focus-test? *target* teleporting)
                    )
                )
            (not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
            )
        (go-virtual idle)
        )
    (spawn (-> self part) (-> self root trans))
    (sound-play "launch-idle" :id (-> self sound-id))
    (if (and (and *target*
                  (and (>= (+ 2867.2 (-> (the-as collide-shape (-> self root)) root-prim prim-core world-sphere w))
                           (vector-vector-distance (-> self root trans) (-> *target* control trans))
                           )
                       (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                       )
                  )
             (not (time-elapsed? (-> self state-time) (seconds 0.5)))
             )
        (send-event *target* 'launch (-> self spring-height) (-> self camera) (-> self dest) (-> self seek-time))
        )
    )
  :code (behavior ()
    (sound-play "launch-start")
    (sleep-code)
    )
  )

(defstate deactivated (launcher)
  :virtual #t
  :code sleep-code
  )

(defmethod init-from-entity! ((this launcher) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-4)
      )
    (set! (-> s4-0 nav-radius) 13926.4)
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (update-transforms (the-as collide-shape (-> this root)))
  (set! (-> this active-distance) 409600.0)
  (set! (-> this spring-height) (res-lump-float arg0 'spring-height :default 163840.0))
  (let ((s4-1 (res-lump-value arg0 'mode uint128 :time -1000000000.0)))
    (let ((v1-14 (-> this level name)))
      (set! (-> this part) (create-launch-control
                             (cond
                               ((= v1-14 'beach)
                                (-> *part-group-id-table* 7)
                                )
                               ((= v1-14 'swamp)
                                (-> *part-group-id-table* 9)
                                )
                               (else
                                 (-> *part-group-id-table* 8)
                                 )
                               )
                             this
                             )
            )
      )
    (let ((v1-20 (logand (the-as int s4-1) 255)))
      (cond
        ((= (the-as uint v1-20) 1)
         (set! (-> this camera) cam-launcher-longfall)
         )
        ((= (the-as uint v1-20) 2)
         (set! (-> this camera) #f)
         )
        (else
          (set! (-> this camera) cam-launcher-shortfall)
          )
        )
      )
    )
  (let ((v1-25 (res-lump-struct arg0 'alt-vector vector)))
    (when v1-25
      (set-vector! (-> this dest) (-> v1-25 x) (-> v1-25 y) (-> v1-25 z) 1.0)
      (set! (-> this seek-time) (the-as time-frame (the int (* 300.0 (-> v1-25 w)))))
      )
    )
  (set! (-> this sound-id) (new-sound-id))
  (nav-mesh-connect-from-ent this)
  (go (method-of-object this idle))
  )

;; WARN: Return type mismatch object vs none.
(defbehavior launcher-init-by-other launcher ((arg0 vector) (arg1 float) (arg2 int) (arg3 float))
  (stack-size-set! (-> self main-thread) 128)
  (let ((s2-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s2-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-4 prim-core collide-with) (collide-spec jak player-list))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s2-0 total-prims) (the-as uint 1))
      (set! (-> s2-0 root-prim) v1-4)
      )
    (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s2-0 root-prim)))
      (set! (-> s2-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s2-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> self root) s2-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
  (set-vector! (-> self root quat) 0.0 0.0 0.0 1.0)
  (update-transforms (the-as collide-shape (-> self root)))
  (set! (-> self spring-height) arg1)
  (set! (-> self active-distance) arg3)
  (let ((v1-18 (-> self level name)))
    (set! (-> self part) (create-launch-control
                           (cond
                             ((= v1-18 'beach)
                              (-> *part-group-id-table* 7)
                              )
                             ((= v1-18 'swamp)
                              (-> *part-group-id-table* 9)
                              )
                             (else
                               (-> *part-group-id-table* 8)
                               )
                             )
                           self
                           )
          )
    )
  (case (logand arg2 255)
    ((1)
     (set! (-> self camera) cam-launcher-longfall)
     )
    ((2)
     (set! (-> self camera) #f)
     )
    (else
      (set! (-> self camera) cam-launcher-shortfall)
      )
    )
  (let ((v1-29 (res-lump-struct (-> self entity) 'alt-vector vector)))
    (when v1-29
      (set-vector! (-> self dest) (-> v1-29 x) (-> v1-29 y) (-> v1-29 z) 1.0)
      (set! (-> self seek-time) (the-as time-frame (the int (* 300.0 (-> v1-29 w)))))
      )
    )
  (set! (-> self sound-id) (new-sound-id))
  (go-virtual idle)
  (none)
  )

(defstate active (touch-tracker)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('touched)
       (let ((v1-1 (ppointer->process (-> self parent))))
         (when (!= v1-1 proc)
           (cond
             ((= (-> self event) 'attack)
              (send-event
                proc
                (-> self event)
                :from v1-1
                #f
                (static-attack-info ((mode (-> self event-mode)) (id (new-attack-id))))
                )
              )
             ((-> self event)
              (send-event proc (-> self event) :from v1-1)
              )
             (else
               (let ((t0-5 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> t0-5 from) (process->ppointer proc))
                 (set! (-> t0-5 num-params) argc)
                 (set! (-> t0-5 message) message)
                 (set! (-> t0-5 param 0) (-> block param 0))
                 (set! (-> t0-5 param 1) (-> block param 1))
                 (set! (-> t0-5 param 2) (-> block param 2))
                 (set! (-> t0-5 param 3) (-> block param 3))
                 (set! (-> t0-5 param 4) (-> block param 4))
                 (set! (-> t0-5 param 5) (-> block param 5))
                 (send-event-function v1-1 t0-5)
                 )
               )
             )
           )
         )
       )
      (('target)
       (set! v0-0 (process->handle (the-as process (-> block param 0))))
       (set! (-> self target) (the-as handle v0-0))
       v0-0
       )
      (('event)
       (set! (-> self event) (the-as symbol (-> block param 0)))
       (set! v0-0 (-> block param 1))
       (set! (-> self event-mode) (the-as symbol v0-0))
       v0-0
       )
      (('exit)
       (set! v0-0 (-> block param 0))
       (set! (-> self run-function) (the-as (function object) v0-0))
       v0-0
       )
      (('eval)
       ((the-as (function touch-tracker object) (-> block param 0)) self)
       )
      (('function)
       (set! v0-0 (-> block param 0))
       (set! (-> self callback) (the-as (function touch-tracker none) v0-0))
       v0-0
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self state-time))
    (while ((-> self run-function))
      (let* ((gp-0 (handle->process (-> self target)))
             (a0-4 (if (type? gp-0 process-drawable)
                       gp-0
                       )
                   )
             )
        (when a0-4
          (let* ((gp-1 (-> (the-as process-drawable a0-4) root))
                 (a0-6 (if (type? gp-1 collide-shape)
                           gp-1
                           )
                       )
                 )
            (if a0-6
                (set! (-> (the-as collide-shape (-> self root)) trans quad)
                      (-> (the-as collide-shape a0-6) root-prim prim-core world-sphere quad)
                      )
                )
            )
          )
        )
      (if (-> self callback)
          ((-> self callback) self)
          )
      (update-transforms (the-as collide-shape (-> self root)))
      (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-3 options) (overlaps-others-options oo1))
        (set! (-> a1-3 collide-with-filter) (the-as collide-spec -1))
        (set! (-> a1-3 tlist) *touching-list*)
        (find-overlapping-shapes (the-as collide-shape (-> self root)) a1-3)
        )
      (suspend)
      )
    (let ((v1-21 (-> (the-as collide-shape (-> self root)) root-prim)))
      (set! (-> v1-21 prim-core collide-as) (collide-spec))
      (set! (-> v1-21 prim-core collide-with) (collide-spec))
      )
    0
    (suspend)
    0
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior touch-tracker-init touch-tracker ((arg0 vector) (arg1 float) (arg2 time-frame))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec jak enemy))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec
              crate
              civilian
              enemy
              obstacle
              vehicle-sphere
              hit-by-player-list
              hit-by-others-list
              collectable
              pusher
              )
            )
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 arg1)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> self root) s4-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (set! (-> self duration) arg2)
  (set! (-> self target) (the-as handle #f))
  (set! (-> self event) #f)
  (set! (-> self callback) #f)
  (set! (-> self run-function)
        (lambda :behavior touch-tracker () (not (time-elapsed? (-> self state-time) (-> self duration))))
        )
  (set! (-> self event-hook) (-> (method-of-object self active) event))
  (go-virtual active)
  (none)
  )

(defmethod explosion-method-22 ((this explosion))
  0
  (none)
  )

(defbehavior explosion-init-by-other explosion ((arg0 explosion-init-params))
  (mem-copy! (the-as pointer (-> self params)) (the-as pointer arg0) 72)
  (logclear! (-> self mask) (process-mask actor-pause movie))
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-5 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-5 prim-core action) (collide-action solid))
      (set-vector! (-> v1-5 local-sphere) 0.0 0.0 0.0 0.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-5)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-8 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-8 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-8 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (set! (-> (the-as collide-shape (-> self root)) event-self) 'touched)
  (set! (-> self root trans quad) (-> arg0 spawn-point quad))
  (quaternion-copy! (-> self root quat) (-> arg0 spawn-quat))
  (vector-identity! (-> self root scale))
  (vector-float*! (-> self root scale) (-> self root scale) (-> arg0 scale))
  (trs-matrix-calc! (-> self root) (-> self mat))
  (let ((v1-19 (-> (the-as collide-shape (-> self root)) root-prim)))
    (set! (-> v1-19 local-sphere w) (-> arg0 radius))
    (set! (-> v1-19 prim-core world-sphere w) (-> arg0 radius))
    (set! (-> v1-19 prim-core collide-with) (-> arg0 collide-with))
    )
  (let* ((v1-20 *game-info*)
         (a0-19 (+ (-> v1-20 attack-id) 1))
         )
    (set! (-> v1-20 attack-id) a0-19)
    (set! (-> self attack-id) a0-19)
    )
  (let ((a0-20 (-> arg0 group)))
    (when a0-20
      (set! (-> self duration) (-> a0-20 duration))
      (set! (-> self linger-duration) (-> a0-20 linger-duration))
      (set! (-> self part) (create-launch-control a0-20 self))
      )
    )
  (let ((v1-26 (new 'stack-no-clear 'traffic-danger-info)))
    (set! (-> v1-26 sphere quad) (-> self root trans quad))
    (vector-reset! (-> v1-26 velocity))
    (set! (-> v1-26 sphere r) (* 2.0 (-> arg0 radius)))
    (set! (-> v1-26 notify-radius) 204800.0)
    (set! (-> v1-26 danger-level) 1.0)
    (set! (-> v1-26 decay-rate) 0.0)
    (set! (-> v1-26 flags) (the-as uint 1))
    (set! (-> v1-26 danger-type) (the-as uint 5))
    (send-event *traffic-manager* 'add-danger-sphere v1-26)
    )
  (explosion-method-22 self)
  (go-virtual explode)
  )

(defun explosion-spawn-legacy-version ((arg0 process-drawable) (arg1 type) (arg2 explosion-init-params))
  (let ((s4-0 (get-process *default-dead-pool* arg1 #x4000 1)))
    (when s4-0
      (let ((t9-1 (method-of-type process activate)))
        (t9-1 s4-0 arg0 "explosion" (the-as pointer #x70004000))
        )
      (run-now-in-process s4-0 explosion-init-by-other arg2)
      (-> s4-0 ppointer)
      )
    )
  )

;; WARN: Return type mismatch process vs none.
(defun explosion-spawn ((arg0 explosion-init-params) (arg1 process-drawable))
  (let* ((gp-0 (the-as process #f))
         (s3-0 (get-process *default-dead-pool* explosion #x4000 1))
         (v1-1 (when s3-0
                 (let ((t9-1 (method-of-type explosion activate)))
                   (t9-1 (the-as explosion s3-0) arg1 "explosion" (the-as pointer #x70004000))
                   )
                 (run-now-in-process s3-0 explosion-init-by-other arg0)
                 (-> s3-0 ppointer)
                 )
               )
         )
    (if v1-1
        (set! gp-0 (-> v1-1 0))
        )
    )
  (none)
  )

(defun find-closest-solid-sphere-prim ((arg0 collide-shape) (arg1 vector) (arg2 collide-spec))
  (let ((gp-0 (the-as collide-shape-prim #f)))
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (set! (-> s3-0 x) (the-as float #x7f800000))
      (let ((s2-0 (-> arg0 root-prim))
            (s1-0 1)
            )
        (when (zero? (-> s2-0 prim-core prim-type))
          (let ((v1-3 s2-0))
            (set! s2-0 (-> (the-as collide-shape-prim-group v1-3) child 0))
            (set! s1-0 (the-as int (-> v1-3 specific 0)))
            )
          )
        (while (nonzero? s1-0)
          (+! s1-0 -1)
          (when (and (= (-> s2-0 prim-core prim-type) -1)
                     (logtest? (-> s2-0 prim-core action) (collide-action solid))
                     (logtest? (-> s2-0 prim-core collide-as) arg2)
                     )
            (set! (-> s3-0 y) (vector-vector-distance arg1 (the-as vector (-> s2-0 prim-core))))
            (set! (-> s3-0 y) (fmax 0.0 (- (-> s3-0 y) (-> s2-0 prim-core world-sphere w))))
            (when (< (-> s3-0 y) (-> s3-0 x))
              (set! (-> s3-0 x) (-> s3-0 y))
              (set! gp-0 s2-0)
              )
            )
          (&+! s2-0 80)
          )
        )
      )
    gp-0
    )
  )

(define *explosion-debug-sphere* (new 'static 'sphere))

(defstate explode (explosion)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (a0-13 process))
    (case message
      (('touched)
       (let ((s4-0 (new 'stack-no-clear 'mystery-cquery-type0)))
         (set! (-> s4-0 explosion-trans quad)
               (-> (the-as collide-shape (-> self root)) root-prim prim-core world-sphere quad)
               )
         (let* ((s2-0 proc)
                (s3-0 (if (type? s2-0 process-drawable)
                          s2-0
                          )
                      )
                )
           (when (and s3-0 (!= s3-0 (handle->process (-> self params ignore-proc))))
             (let ((v1-6 (find-closest-solid-sphere-prim
                           (the-as collide-shape (-> (the-as process-drawable s3-0) root))
                           (-> s4-0 explosion-trans)
                           (-> self params collide-with)
                           )
                         )
                   )
               (cond
                 (v1-6
                   (set! (-> s4-0 proc-trans quad) (-> v1-6 prim-core world-sphere quad))
                   )
                 ((begin
                    (let ((s2-2 proc))
                      (set! a0-13 (if (type? s2-2 process-focusable)
                                      s2-2
                                      )
                            )
                      )
                    a0-13
                    )
                  (set! (-> s4-0 proc-trans quad) (-> (get-trans (the-as process-focusable a0-13) 3) quad))
                  )
                 (else
                   (let* ((s2-4 (-> (the-as process-focusable s3-0) root))
                          (v1-12 (if (type? s2-4 collide-shape)
                                     s2-4
                                     )
                                 )
                          )
                     (if v1-12
                         (set! (-> s4-0 proc-trans quad) (-> v1-12 root-prim prim-core world-sphere quad))
                         (set! (-> s4-0 proc-trans quad) (-> (the-as process-focusable s3-0) root trans quad))
                         )
                     )
                   )
                 )
               )
             (set! (-> s4-0 dist) (vector-vector-distance (-> s4-0 proc-trans) (-> s4-0 explosion-trans)))
             (set! (-> s4-0 dist) (fmax 0.0 (- (-> s4-0 dist) (-> s4-0 proc-trans w))))
             (set! (-> s4-0 probe) -1.0)
             (when (< 0.0 (-> s4-0 dist))
               (set! (-> s4-0 cquery start-pos quad) (-> s4-0 explosion-trans quad))
               (vector-! (-> s4-0 cquery move-dist) (-> s4-0 proc-trans) (-> s4-0 explosion-trans))
               (let ((v1-23 (-> s4-0 cquery)))
                 (set! (-> v1-23 radius) 40.96)
                 (set! (-> v1-23 collide-with) (collide-spec backgnd))
                 (set! (-> v1-23 ignore-process0) #f)
                 (set! (-> v1-23 ignore-process1) #f)
                 (set! (-> v1-23 ignore-pat)
                       (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                       )
                 (set! (-> v1-23 action-mask) (collide-action solid))
                 )
               (set! (-> s4-0 probe) (fill-and-probe-using-line-sphere *collide-cache* (-> s4-0 cquery)))
               )
             (when (< (-> s4-0 probe) 0.0)
               (let ((s3-1 (new 'stack-no-clear 'inline-array 'vector 2)))
                 (vector-! (-> s3-1 0) (-> s4-0 proc-trans) (-> s4-0 explosion-trans))
                 (set! (-> s3-1 1 x) (- 1.0 (fmin 1.0 (/ (-> s4-0 dist) (-> self params radius)))))
                 (set! (-> s3-1 1 y) (+ 1.0 (* (-> s3-1 1 x) (+ -1.0 (-> self params damage-scale)))))
                 (set! (-> s3-1 1 z) (* (-> s3-1 1 y) (-> self params damage)))
                 (vector-normalize! (-> s3-1 0) (-> s3-1 1 w))
                 (send-event
                   proc
                   'attack
                   (-> block param 0)
                   (static-attack-info
                     :mask (vehicle-impulse-factor)
                     ((id (-> self attack-id))
                      (damage (-> s3-1 1 z))
                      (vehicle-damage-factor (-> self params vehicle-damage-factor))
                      (vehicle-impulse-factor (-> self params vehicle-impulse-factor))
                      (mode 'explode)
                      (attacker-velocity (-> s3-1 0))
                      )
                     )
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (set-time! (-> self start-time))
    (when (nonzero? (-> self params collide-with))
      (update-transforms (the-as collide-shape (-> self root)))
      (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-0 options) (overlaps-others-options))
        (set! (-> a1-0 collide-with-filter) (the-as collide-spec -1))
        (set! (-> a1-0 tlist) *touching-list*)
        (find-overlapping-shapes (the-as collide-shape (-> self root)) a1-0)
        )
      )
    (let ((v1-11 (-> (the-as collide-shape (-> self root)) root-prim)))
      (set! (-> v1-11 prim-core collide-as) (collide-spec))
      (set! (-> v1-11 prim-core collide-with) (collide-spec))
      )
    0
    (while (not (time-elapsed? (-> self start-time) (the-as time-frame (-> self duration))))
      (spawn-from-mat (-> self part) (-> self mat))
      (suspend)
      )
    (set-time! (-> self start-time))
    (while (not (time-elapsed? (-> self start-time) (the-as time-frame (-> self linger-duration))))
      (suspend)
      )
    )
  )

(defun process-drawable-random-point! ((arg0 process-drawable) (arg1 vector))
  (let ((v1-1 (-> arg0 node-list length))
        (s4-0 (-> arg0 root))
        )
    (cond
      ((>= v1-1 7)
       (let ((v1-2 (rand-vu-int-range 3 (+ v1-1 -1))))
         (vector<-cspace! arg1 (-> arg0 node-list data v1-2))
         )
       )
      ((and (nonzero? s4-0) (type? s4-0 collide-shape))
       (vector+!
         arg1
         (the-as vector (-> (the-as collide-shape s4-0) root-prim prim-core))
         (rand-vu-sphere-point! arg1 (-> (the-as collide-shape s4-0) root-prim prim-core world-sphere w))
         )
       )
      (else
        (vector+! arg1 (-> arg0 root trans) (rand-vu-sphere-point! arg1 (-> arg0 draw bounds w)))
        )
      )
    )
  arg1
  )

(defun process-drawable-pair-random-point! ((arg0 process-drawable) (arg1 process-drawable) (arg2 vector) (arg3 float))
  (let ((s4-0 (new-stack-vector0))
        (s3-0 (new-stack-vector0))
        )
    (process-drawable-random-point! arg0 s4-0)
    (process-drawable-random-point! arg1 s3-0)
    (vector-lerp! arg2 s4-0 s3-0 arg3)
    )
  )

(deftype simple-prim (process-drawable)
  ((strip  prim-strip)
   )
  (:state-methods
    active
    )
  (:methods
    (init-strip! (_type_) none)
    (strip-setup (_type_) none)
    (get-alpha (_type_) int)
    (allocate-trans-and-strip! (_type_) prim-strip)
    (get-color (_type_) rgba)
    )
  )


(defmethod init-from-entity! ((this simple-prim) (arg0 entity-actor))
  (allocate-trans-and-strip! this)
  (process-entity-set! this arg0)
  (process-drawable-from-entity! this arg0)
  (let ((v1-3 ((method-of-type res-lump get-property-struct)
               (-> this entity)
               'trans-offset
               'interp
               -1000000000.0
               *zero-vector*
               (the-as (pointer res-tag) #f)
               *res-static-buf*
               )
              )
        )
    (vector+! (-> this root trans) (-> this root trans) (the-as vector v1-3))
    )
  (let ((f0-0 (res-lump-float (-> this entity) 'scale :default 1.0)))
    (vector-float*! (-> this root scale) (-> this root scale) f0-0)
    )
  (vector-float*! (-> this root scale) (-> this root scale) 4096.0)
  (let ((f0-2 (res-lump-float (-> this entity) 'rotoffset)))
    (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-2)
    )
  (let ((f0-3 (res-lump-float (-> this entity) 'tiltmin)))
    (quaternion-rotate-local-x! (-> this root quat) (-> this root quat) f0-3)
    )
  (set! (-> this strip tex-id) (new 'static 'texture-id :index #x3 :page #x1))
  (go (method-of-object this active))
  )

(defmethod allocate-trans-and-strip! ((this simple-prim))
  "Allocate transform and strip."
  (set! (-> this root) (new 'process 'trsqv))
  (quaternion-identity! (-> this root quat))
  (let ((v0-2 (new 'process 'prim-strip 4 (new 'static 'texture-id :index #x3 :page #x1) (the-as string #f))))
    (set! (-> this strip) v0-2)
    v0-2
    )
  )

(defbehavior simple-prim-init-by-other simple-prim ((arg0 vector) (arg1 vector) (arg2 texture-id))
  (allocate-trans-and-strip! self)
  (set! (-> self root trans quad) (-> arg0 quad))
  (set! (-> self root scale quad) (-> arg1 quad))
  (set! (-> self strip tex-id) arg2)
  (go-virtual active)
  )

(defmethod strip-setup ((this simple-prim))
  (set! (-> this strip num-verts) (the-as uint 4))
  (set! (-> this strip alpha) *simple-prim-alpha-blend*)
  (set! (-> this strip adnops 0 cmds) (gs-reg64 test-1))
  (set! (-> this strip data0) (new 'static 'gs-test
                                :ate #x1
                                :atst (gs-atest greater-equal)
                                :aref #x26
                                :zte #x1
                                :ztst (gs-ztest greater-equal)
                                )
        )
  (none)
  )

(defstate active (simple-prim)
  :virtual #t
  :enter (behavior ()
    '()
    )
  :trans (behavior ()
    (strip-setup self)
    (init-strip! self)
    )
  :code sleep-code
  )

(defmethod get-alpha ((this simple-prim))
  128
  )

(defmethod get-color ((this simple-prim))
  *color-gray*
  )

;; WARN: Return type mismatch rgba vs none.
(defmethod init-strip! ((this simple-prim))
  (quaternion-normalize! (-> this root quat))
  (let ((s2-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
        (s3-0 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
        (gp-0 (get-alpha this))
        (s4-0 (new 'stack-no-clear 'vector))
        (s5-0 (get-color this))
        )
    (vector-normalize! s2-0 (-> this root scale x))
    (vector-normalize! s3-0 (-> this root scale y))
    (let ((v1-8 (-> this strip data)))
      (vector+! s4-0 (-> this root trans) s2-0)
      (vector+! s4-0 s4-0 s3-0)
      (set! (-> v1-8 0 pos quad) (-> s4-0 quad))
      (set! (-> v1-8 0 stq z) 0.0)
      (set! (-> v1-8 0 stq x) 0.0)
      (set! (-> v1-8 0 stq y) 0.0)
      (set! (-> v1-8 0 col) s5-0)
      (set! (-> v1-8 0 col a) gp-0)
      (let ((v1-9 (-> v1-8 1)))
        (vector+float*! s4-0 (-> this root trans) s2-0 -1.0)
        (vector+! s4-0 s4-0 s3-0)
        (set! (-> v1-9 pos quad) (-> s4-0 quad))
        (set! (-> v1-9 stq z) 0.0)
        (set! (-> v1-9 stq x) 1.0)
        (set! (-> v1-9 stq y) 0.0)
        (set! (-> v1-9 col) s5-0)
        (set! (-> v1-9 col a) gp-0)
        (let ((v1-10 (&+ v1-9 32)))
          (vector+! s4-0 (-> this root trans) s2-0)
          (vector+float*! s4-0 s4-0 s3-0 -1.0)
          (set! (-> v1-10 pos quad) (-> s4-0 quad))
          (set! (-> v1-10 stq z) 0.0)
          (set! (-> v1-10 stq x) 0.0)
          (set! (-> v1-10 stq y) 1.0)
          (set! (-> v1-10 col) s5-0)
          (set! (-> v1-10 col a) gp-0)
          (let ((v1-11 (&+ v1-10 32)))
            (vector+float*! s4-0 (-> this root trans) s2-0 -1.0)
            (vector+float*! s4-0 s4-0 s3-0 -1.0)
            (set! (-> v1-11 pos quad) (-> s4-0 quad))
            (set! (-> v1-11 stq z) 0.0)
            (set! (-> v1-11 stq x) 1.0)
            (set! (-> v1-11 stq y) 1.0)
            (set! (-> v1-11 col) s5-0)
            (set! (-> v1-11 col a) gp-0)
            )
          )
        )
      )
    )
  (none)
  )

(defmethod relocate ((this simple-prim) (offset int))
  (if (nonzero? (-> this strip))
      (&+! (-> this strip) offset)
      )
  (call-parent-method this offset)
  )

(deftype simple-prim-zbuf-mask (simple-prim)
  ()
  )


(defmethod strip-setup ((this simple-prim-zbuf-mask))
  (set! (-> this strip num-verts) (the-as uint 4))
  (set! (-> this strip alpha) *simple-prim-additive*)
  (set! (-> this strip adnops 0 cmds) (gs-reg64 test-1))
  (set! (-> this strip data0) (new 'static 'gs-test
                                :ate #x1
                                :atst (gs-atest greater-equal)
                                :aref #x26
                                :zte #x1
                                :ztst (gs-ztest greater-equal)
                                )
        )
  (set! (-> this strip bucket) (bucket-id generic-sprite-1))
  (set! (-> this strip sink) (the-as uint 65))
  (none)
  )

(defmethod get-color ((this simple-prim-zbuf-mask))
  *color-black*
  )

(deftype simple-prim-particle-binding (simple-prim)
  ((color     rgba)
   (lifetime  time-frame)
   )
  (:state-methods
    die
    )
  (:methods
    (setup! (_type_ int sparticle-cpuinfo sparticle-launchinfo) none)
    )
  )


(defmethod get-color ((this simple-prim-particle-binding))
  (-> this color)
  )

(defstate die (simple-prim-particle-binding)
  :virtual #t
  :code nothing
  )

(defstate active (simple-prim-particle-binding)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (init-strip! self)
    (if (time-elapsed? (-> self state-time) (-> self lifetime))
        (go-virtual die)
        )
    )
  :code sleep-code
  )

(defmethod setup! ((this simple-prim-particle-binding) (arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  "Set up this prim with the given particle info."
  (set! (-> this lifetime) (seconds 5))
  (set! (-> this root scale x) (-> arg2 launchrot w))
  (set! (-> this root scale y) (-> arg2 conerot w))
  (set! (-> this color r) (the int (* 128.0 (-> arg2 rotate-x))))
  (set! (-> this color g) (the int (* 128.0 (-> arg2 rotate-y))))
  (set! (-> this color b) (the int (* 128.0 (-> arg2 rotate-z))))
  (set! (-> this color a) (the int (* 128.0 (-> arg2 coneradius))))
  (set-vector! (-> this root trans) (-> arg2 launchrot x) (-> arg2 launchrot y) (-> arg2 launchrot z) 1.0)
  (set! (-> this strip adnops 0 cmds) (gs-reg64 test-1))
  (set! (-> this strip data0) (new 'static 'gs-test
                                :ate #x1
                                :atst (gs-atest greater-equal)
                                :aref #x26
                                :zte #x1
                                :ztst (gs-ztest greater-equal)
                                )
        )
  (cond
    ((logtest? (-> arg1 flags) (sp-cpuinfo-flag aux-list))
     (set! (-> this strip alpha) *simple-prim-additive*)
     (set! (-> this color) *color-black*)
     )
    ((logtest? (-> arg1 flags) (sp-cpuinfo-flag sp-cpuinfo-flag-3))
     (set! (-> this strip alpha) *simple-prim-additive*)
     )
    (else
      (set! (-> this strip alpha) *simple-prim-alpha-blend*)
      )
    )
  (set! (-> this strip num-verts) (the-as uint 4))
  (none)
  )

(defun birth-func-simple-prim ((arg0 int) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let ((s3-0 (get-process *default-dead-pool* simple-prim-particle-binding #x4000 1)))
    (setup!
      (the-as simple-prim-particle-binding (-> (when s3-0
                                                 (let ((t9-1 (method-of-type process activate)))
                                                   (t9-1 s3-0 *entity-pool* "prim" (the-as pointer #x70004000))
                                                   )
                                                 (run-now-in-process
                                                   s3-0
                                                   simple-prim-init-by-other
                                                   *zero-vector*
                                                   *zero-vector*
                                                   (new 'static 'texture-id :index #x3 :page #x1)
                                                   )
                                                 (-> s3-0 ppointer)
                                                 )
                                               0
                                               )
              )
      arg0
      arg1
      arg2
      )
    )
  (none)
  )

(deftype part-controller (process)
  ((actor-group         (pointer actor-group))
   (actor-group-count   int32)
   (spawn-delay         time-frame)
   (current-part-index  uint16)
   (state-time          time-frame)
   (next-reset-time     time-frame)
   (reset-interval-min  time-frame)
   (reset-interval-max  time-frame)
   (particle-launchers  (array (pointer sparticle-launch-group)))
   (spawn-sound         sound-name)
   )
  (:state-methods
    active
    )
  )


(defmethod relocate ((this part-controller) (offset int))
  (if (nonzero? (-> this particle-launchers))
      (&+! (-> this particle-launchers) offset)
      )
  (call-parent-method this offset)
  )

(defmethod run-logic? ((this part-controller))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defmethod init-from-entity! ((this part-controller) (arg0 entity-actor))
  (local-vars (sv-16 res-tag) (sv-32 string))
  (stack-size-set! (-> this main-thread) 32)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-3 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-3 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-3))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (when (<= (-> this actor-group-count) 0)
    (process-entity-status! this (entity-perm-status dead) #t)
    (deactivate this)
    (return 0)
    )
  (let ((a0-9 ((method-of-type res-lump get-property-struct)
               arg0
               'sound-name
               'interp
               -1000000000.0
               ""
               (the-as (pointer res-tag) #f)
               *res-static-buf*
               )
              )
        )
    (set! (-> this spawn-sound) (string->sound-name (the-as string a0-9)))
    )
  (let ((a3-2 (+ 0 (-> this actor-group 0 length))))
    (set! (-> this particle-launchers)
          (the-as (array (pointer sparticle-launch-group)) (new 'process 'boxed-array pointer a3-2))
          )
    )
  (set! (-> this particle-launchers length) 0)
  (dotimes (s4-0 (min 1 (-> this actor-group-count)))
    (dotimes (s3-0 (-> this actor-group s4-0 length))
      (set! sv-32 "#f")
      (set! (-> this particle-launchers (-> this particle-launchers length))
            (entity-lookup-part-group (-> this actor-group s4-0 data s3-0 actor) (& sv-32) 'art-name)
            )
      (+! (-> this particle-launchers length) 1)
      )
    )
  (set! (-> this spawn-delay) (the-as time-frame (the int (* 300.0 (res-lump-float arg0 'delay :default 1.0)))))
  (let ((s4-1 (the int (* 300.0 (res-lump-float arg0 'base-time :default 4.0))))
        (v1-50 (the int (* 300.0 (res-lump-float arg0 'offset-time :default 2.0))))
        )
    (set! (-> this reset-interval-min) (the-as time-frame (- s4-1 v1-50)))
    (set! (-> this reset-interval-max) (the-as time-frame (+ s4-1 v1-50)))
    )
  (go (method-of-object this active))
  )

(defstate active (part-controller)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self next-reset-time) (+ (current-time)
                                       (-> self reset-interval-min)
                                       (mod
                                         (the-as int (rand-uint31-gen *random-generator*))
                                         (+ (- 1 (-> self reset-interval-min)) (-> self reset-interval-max))
                                         )
                                       )
          )
    )
  :trans (behavior ()
    (when (< (-> self next-reset-time) (current-time))
      (set! (-> self current-part-index) (the-as uint 0))
      (set! (-> self state-time) 0)
      (set! (-> self next-reset-time) (+ (current-time)
                                         (-> self reset-interval-min)
                                         (mod
                                           (the-as int (rand-uint31-gen *random-generator*))
                                           (+ (- 1 (-> self reset-interval-min)) (-> self reset-interval-max))
                                           )
                                         )
            )
      )
    (when (and (time-elapsed? (-> self state-time) (-> self spawn-delay))
               (< (-> self current-part-index) (the-as uint (-> self particle-launchers length)))
               )
      (when (-> self particle-launchers (-> self current-part-index))
        (let ((gp-1 (-> self actor-group 0 data (-> self current-part-index) actor extra trans)))
          (sound-play-by-name (-> self spawn-sound) (new-sound-id) 1024 0 0 (sound-group) gp-1)
          (cond
            ((logtest? (-> self particle-launchers (-> self current-part-index) 0 flags) (sp-group-flag sp13))
             (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
             (part-tracker-spawn
               part-tracker-subsampler
               :to *entity-pool*
               :group (-> self particle-launchers (-> self current-part-index) 0)
               )
             )
            (else
              (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
              (part-tracker-spawn
                part-tracker
                :to *entity-pool*
                :group (-> self particle-launchers (-> self current-part-index) 0)
                )
              )
            )
          )
        )
      (+! (-> self current-part-index) 1)
      (set-time! (-> self state-time))
      )
    )
  :code sleep-code
  )

(deftype sound-controller (process)
  ((spawn-sound  sound-name)
   (sync         sync-linear  :inline)
   (prev-val     float)
   (pos          vector       :inline)
   )
  (:state-methods
    active
    die
    )
  )


(defmethod init-from-entity! ((this sound-controller) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 32)
  (let ((a0-3 (the-as string ((method-of-type res-lump get-property-struct)
                              arg0
                              'sound-name
                              'interp
                              -1000000000.0
                              ""
                              (the-as (pointer res-tag) #f)
                              *res-static-buf*
                              )
                      )
              )
        )
    (set! (-> this spawn-sound) (string->sound-name a0-3))
    )
  (set! (-> this pos quad) (-> arg0 extra trans quad))
  (let ((a1-3 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-5 0))
      (if #f
          (set! v1-5 (logior v1-5 1))
          )
      (set! (-> a1-3 sync-type) 'sync-linear)
      (set! (-> a1-3 sync-flags) (the-as sync-flags v1-5))
      )
    (set! (-> a1-3 entity) arg0)
    (set! (-> a1-3 period) (the-as uint #x6fc23b000))
    (set! (-> a1-3 percent) 0.0)
    (initialize! (-> this sync) a1-3)
    )
  (set! (-> this prev-val) (get-norm! (-> this sync) 0))
  (go (method-of-object this active))
  )

(defmethod deactivate ((this sound-controller))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (call-parent-method this)
  (none)
  )

(defstate die (sound-controller)
  :virtual #t
  :code (behavior ()
    '()
    )
  )

(defstate active (sound-controller)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (go-virtual die)
       )
      (('reset)
       (sync-now! (-> self sync) 0.0)
       )
      (('play)
       (sound-play-by-name (-> self spawn-sound) (new-sound-id) 1024 0 0 (sound-group) (-> self pos))
       )
      )
    )
  :trans (behavior ()
    (let ((f30-0 (get-norm! (-> self sync) 0)))
      (if (< f30-0 (-> self prev-val))
          (sound-play-by-name (-> self spawn-sound) (new-sound-id) 1024 0 0 (sound-group) (-> self pos))
          )
      (set! (-> self prev-val) f30-0)
      )
    )
  :code sleep-code
  )

(deftype sound-on-path (process-drawable)
  "An [[ambient-sound]] that is being moved along a path."
  ((spawn-sound   sound-name)
   (loop-sound    uint32  :offset 228)
   (amb-sound     ambient-sound)
   (is-spooling?  symbol)
   )
  (:state-methods
    active
    die
    no-play
    )
  )


(defmethod deactivate ((this sound-on-path))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this amb-sound))
      (stop! (-> this amb-sound))
      )
  (if (nonzero? (-> this loop-sound))
      (sound-stop (the-as sound-id (-> this loop-sound)))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs sound-on-path.
(defmethod relocate ((this sound-on-path) (offset int))
  (if (nonzero? (-> this amb-sound))
      (&+! (-> this amb-sound) offset)
      )
  (the-as sound-on-path ((method-of-type process-drawable relocate) this offset))
  )

(defmethod init-from-entity! ((this sound-on-path) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 32)
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (let ((s4-0 ((method-of-type res-lump get-property-struct)
               arg0
               'sound-name
               'interp
               -1000000000.0
               ""
               (the-as (pointer res-tag) #f)
               *res-static-buf*
               )
              )
        )
    (set! (-> this is-spooling?) (nonzero? (res-lump-value arg0 'spooling-val uint128 :time -1000000000.0)))
    ;; og:preserve-this
    (set! (-> this path) (new 'process 'path-control this (#if PC_PORT (if (string= (-> this name) "sound-on-path-119") 'path1 'path) 'path) 0.0 arg0 #f))
    (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
    (logclear! (-> this mask) (process-mask actor-pause))
    ;; og:preserve-this
    (when (string= (the string s4-0) "")
      (go (method-of-object this no-play))
      (return 0)
      )
    (cond
      ((-> this is-spooling?)
       (set! (-> this loop-sound)
             (the-as
               uint
               (add-process *gui-control* this (gui-channel background) (gui-action queue) (the-as string s4-0) -99.0 0)
               )
             )
       )
      (else
        (set! (-> this amb-sound) (new 'process 'ambient-sound (the-as basic s4-0) (-> this root trans) 0.0))
        (let ((f0-0 (res-lump-float arg0 'sound-falloff-far :default 245760.0)))
          (set-falloff-far! (-> this amb-sound) f0-0)
          )
        (update-vol! (-> this amb-sound) 1.0)
        (update-pitch-mod! (-> this amb-sound) 0.0)
        )
      )
    )
  (go (method-of-object this active))
  )

(defmethod run-logic? ((this sound-on-path))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defstate die (sound-on-path)
  :virtual #t
  :code (behavior ()
    '()
    )
  )

(defstate no-play (sound-on-path)
  :virtual #t
  :code sleep-code
  )

(defstate active (sound-on-path)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (go-virtual die)
       )
      )
    )
  :trans (behavior ()
    (let ((f0-0 (path-control-method-25 (-> self path) (target-pos 0)))
          (gp-1 (new 'stack-no-clear 'vector))
          )
      (get-point-at-percent-along-path! (-> self path) gp-1 f0-0 'interp)
      (set! (-> self root trans quad) (-> gp-1 quad))
      (cond
        ((-> self is-spooling?)
         (case (get-status *gui-control* (the-as sound-id (-> self loop-sound)))
           (((gui-status ready))
            (set-action!
              *gui-control*
              (gui-action play)
              (the-as sound-id (-> self loop-sound))
              (gui-channel none)
              (gui-action none)
              (the-as string #f)
              (the-as (function gui-connection symbol) #f)
              (the-as process #f)
              )
            )
           )
         )
        (else
          (update-trans! (-> self amb-sound) gp-1)
          (update! (-> self amb-sound))
          )
        )
      )
    )
  :code sleep-code
  )

(defstate active (external-camera-controller)
  :virtual #t
  :trans (behavior ()
    (set-zero! *camera-smush-control*)
    )
  :code (behavior ()
    (process-entity-status! self (entity-perm-status no-kill) #t)
    (set-setting! 'calm #t 0.0 0)
    (while (not (process-grab? *target* #f))
      (suspend)
      )
    (set-setting! 'mode-name 'cam-fixed 0.0 0)
    (set-setting! 'interp-time 'abs 450.0 0)
    (set-setting! 'entity-name (res-lump-struct (-> self entity) 'camera-name structure) 0.0 0)
    (suspend-for (-> self pause-time))
    (if (-> self blur)
        (set-setting! 'blur-a 'abs 0.5 0)
        )
    (remove-setting! 'mode-name)
    (remove-setting! 'entity-name)
    (remove-setting! 'interp-time)
    (suspend-for (seconds 0.5))
    (while (not (process-release? *target*))
      (suspend)
      )
    (remove-setting! 'interp-time)
    (suspend-for (seconds 0.5))
    (remove-setting! 'blur-a)
    (process-entity-status! self (entity-perm-status no-kill) #f)
    )
  )

(defbehavior external-camera-controller-init-by-other external-camera-controller ((arg0 entity) (arg1 time-frame) (arg2 symbol))
  (process-entity-set! self arg0)
  (set! (-> self pause-time) arg1)
  (set! (-> self blur) arg2)
  (go-virtual active)
  )

(deftype level-exit (process-drawable)
  ((minimap       connection-minimap)
   (task-counter  uint32)
   (ent           basic)
   )
  (:state-methods
    active
    )
  )


(defmethod init-from-entity! ((this level-exit) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (set! (-> this minimap) #f)
  (set! (-> this task-counter) (the-as uint 0))
  (set! (-> this ent) arg0)
  (go (method-of-object this active))
  )

(defmethod run-logic? ((this level-exit))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defmethod deactivate ((this level-exit))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (-> this minimap)
      (kill-callback (-> *minimap* engine) (-> this minimap))
      )
  (call-parent-method this)
  (none)
  )

(defstate active (level-exit)
  :virtual #t
  :trans (behavior ()
    (set! (-> self task-counter) (-> *game-info* task-counter))
    (if *bigmap*
        (set-map-indices! *bigmap*)
        )
    (let ((gp-0 (res-lump-struct (-> self entity) 'on-running structure)))
      (cond
        ((or (not gp-0) (and gp-0 (script-eval (the-as pair gp-0))))
         (if (not (-> self minimap))
             (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 14) (the-as int #f) (the-as vector #t) 0))
             )
         )
        (else
          (when (-> self minimap)
            (logior! (-> self minimap flags) (minimap-flag fade-out))
            (set! (-> self minimap) #f)
            )
          )
        )
      )
    )
  :code sleep-code
  )
