;;-*-Lisp-*-
(in-package goal)

;; name: airlock.gc
;; name in dgo: airlock
;; dgos: GAME

;; +++airlock-options
(defenum airlock-options
  :type uint32
  :bitfield #t
  (ao0 0)
  (front 1)
  (block-flut 2)
  (back 3)
  (ao4 4)
  )
;; ---airlock-options


(declare-type blocking-plane process-drawable)

(define-extern blocking-plane-spawn (function curve-control (inline-array vector) float none :behavior process))
(define-extern blocking-plane-destroy (function none :behavior blocking-plane))
;; DECOMP BEGINS

(deftype com-airlock (process-drawable)
  ((level-name              pair)
   (open-test               pair)
   (on-running              pair)
   (were-behind?            symbol)
   (inner?                  symbol)
   (sound-behind?           symbol)
   (visible-move?           symbol)
   (saw-pilot?              handle)
   (last-distance           meters)
   (y-height                vector)
   (pre-open-speed          float)
   (open?                   symbol)
   (latch-closed-time       time-frame)
   (latch-open-time         time-frame)
   (gear                    joint-mod)
   (gear-rot                degrees)
   (gear-rotv               degrees)
   (gear-start-frame        float)
   (gear-stop-frame         float)
   (gear-play-time          time-frame)
   (open-frame              float)
   (pre-open-frame          float)
   (lock-frame              float)
   (close-speed-multiplier  float)
   (open-distance           meters  2)
   (active-distance         meters  2)
   (sound-id                sound-id)
   (gear-sound-id           sound-id)
   (sound-gear              sound-spec)
   (sound-pre-open          sound-spec)
   (sound-pre-open-stop     sound-spec)
   (sound-lock-loop         sound-spec)
   (sound-lock-stop         sound-spec)
   (sound-open              sound-spec)
   (sound-open-loop         sound-spec)
   (sound-open-stop         sound-spec)
   (sound-close             sound-spec)
   (sound-close-loop        sound-spec)
   (sound-close-stop        sound-spec)
   (sound-post-close        sound-spec)
   (sound-post-close-stop   sound-spec)
   (spool-sound-time        time-frame)
   (start-open-time         time-frame)
   (door-radius             float)
   (allow-pilot?            symbol)
   (allow-flut?             symbol)
   (blocking-plane?         symbol)
   )
  (:state-methods
    (open symbol)
    (close symbol)
    )
  (:methods
    (init-airlock! (_type_) _type_)
    (want-cross-airlock? (_type_) object)
    (destination-loaded? (_type_ symbol) symbol)
    (check-crossing-distance (_type_ vector symbol) float)
    (com-airlock-method-26 (_type_ vector symbol) symbol)
    (rotate-gear! (_type_ float) degrees)
    (play-city-voice-sound (_type_ symbol) none)
    (spawn-blocking-plane (_type_ symbol) none)
    )
  )


(defmethod deactivate ((this com-airlock))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (process-entity-status! this (entity-perm-status subtask-complete) #f)
  (if (nonzero? (-> this sound-id))
      (sound-stop (-> this sound-id))
      )
  (if (nonzero? (-> this gear-sound-id))
      (sound-stop (-> this gear-sound-id))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs com-airlock.
(defmethod relocate ((this com-airlock) (offset int))
  (if (nonzero? (-> this gear))
      (&+! (-> this gear) offset)
      )
  (the-as com-airlock ((method-of-type process-drawable relocate) this offset))
  )

(defmethod init-airlock! ((this com-airlock))
  (local-vars (sv-16 res-tag) (sv-32 res-tag))
  (process-entity-status! this (entity-perm-status subtask-complete) #f)
  (set! (-> this open?) #f)
  (process-drawable-from-entity! this (-> this entity))
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((s5-0 (res-lump-value (-> this entity) 'options airlock-options :time -1000000000.0)))
    (set! (-> this were-behind?) #f)
    (set! (-> this inner?) (logtest? s5-0 (airlock-options ao0)))
    (set! (-> this on-running) (res-lump-struct (-> this entity) 'on-running pair))
    (set! (-> this sound-behind?) #f)
    (set! (-> this saw-pilot?) (the-as handle #f))
    (set! (-> this open-frame) 0.0)
    (set! (-> this pre-open-frame) 0.0)
    (set! (-> this lock-frame) 0.0)
    (set! (-> this pre-open-speed) 2.0)
    (set! (-> this allow-pilot?) #f)
    (set! (-> this allow-flut?) (not (logtest? s5-0 (airlock-options block-flut))))
    (let ((v1-16 (cond
                   ((logtest? s5-0 (airlock-options front))
                    'front
                    )
                   ((logtest? s5-0 (airlock-options back))
                    'back
                    )
                   )
                 )
          )
      (set! (-> this blocking-plane?) v1-16)
      )
    )
  (set! (-> this open-distance 0) 143360.0)
  (set! (-> this open-distance 1) 143360.0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-21 (res-lump-data (-> this entity) 'distance (pointer float) :tag-ptr (& sv-16))))
    (when v1-21
      (if (>= (-> sv-16 elt-count) (the-as uint 1))
          (set! (-> this open-distance 0) (-> v1-21 0))
          )
      (if (>= (-> sv-16 elt-count) (the-as uint 2))
          (set! (-> this open-distance 1) (-> v1-21 1))
          )
      )
    )
  (set! (-> this active-distance 0) (+ 143360.0 (-> this open-distance 0)))
  (set! (-> this active-distance 1) (+ 143360.0 (-> this open-distance 1)))
  (set! sv-32 (new 'static 'res-tag))
  (let ((v1-25 (res-lump-data (-> this entity) 'idle-distance (pointer float) :tag-ptr (& sv-32))))
    (when v1-25
      (if (>= (-> sv-32 elt-count) (the-as uint 1))
          (set! (-> this active-distance 0) (-> v1-25 0))
          )
      (if (>= (-> sv-32 elt-count) (the-as uint 2))
          (set! (-> this active-distance 1) (-> v1-25 1))
          )
      )
    )
  (set! (-> this y-height) (res-lump-data (-> this entity) 'height vector))
  (set! (-> this level-name) (res-lump-struct (-> this entity) 'on-notice pair))
  (set! (-> this open-test)
        (the-as pair ((method-of-type res-lump get-property-struct)
                      (-> this entity)
                      'open-test
                      'interp
                      -1000000000.0
                      (the-as structure '(not (or (scene-player?) (focus-test? *target* grabbed))))
                      (the-as (pointer res-tag) #f)
                      *res-static-buf*
                      )
                )
        )
  (set! (-> this gear-start-frame) -1.0)
  (set! (-> this gear-stop-frame) 10000.0)
  (set! (-> this sound-gear) #f)
  (set! (-> this sound-pre-open) #f)
  (set! (-> this sound-pre-open-stop) #f)
  (set! (-> this sound-lock-loop) #f)
  (set! (-> this sound-lock-stop) #f)
  (set! (-> this sound-post-close) #f)
  (set! (-> this sound-post-close-stop) #f)
  (set! (-> this sound-open) #f)
  (set! (-> this sound-close) #f)
  (set! (-> this sound-open-loop) #f)
  (set! (-> this sound-close-loop) #f)
  (set! (-> this sound-open-stop) #f)
  (set! (-> this sound-close-stop) #f)
  (set! (-> this door-radius) 20480.0)
  (set! (-> this close-speed-multiplier) 2.0)
  this
  )

(defbehavior airlock-stop-part-trackers com-airlock ()
  (let ((gp-0 (ppointer->process (-> self child))))
    (while gp-0
      (if (type? gp-0 part-tracker)
          (send-event gp-0 'draw #f)
          )
      (set! gp-0 (ppointer->process (-> gp-0 brother)))
      )
    )
  0
  (none)
  )

(defun airlock-command-lookup ((arg0 pair))
  (let* ((s5-0 (the-as object (-> *setting-control* user-current airlock-command)))
         (s4-0 (-> (the-as pair s5-0) car))
         )
    (while (not (null? s5-0))
      (let ((a0-1 (-> (the-as pair s4-0) car)))
        (if (or (= a0-1 'any) (string= (the-as string a0-1) (the-as string arg0)))
            (return (-> (the-as pair (-> (the-as pair s4-0) cdr)) car))
            )
        )
      (set! s5-0 (-> (the-as pair s5-0) cdr))
      (set! s4-0 (-> (the-as pair s5-0) car))
      )
    )
  #f
  )

(defmethod com-airlock-method-26 ((this com-airlock) (arg1 vector) (side symbol))
  (case side
    (('front)
     (let ((f0-0 (check-crossing-distance this arg1 #f)))
       (and (< 0.0 f0-0) (or (< (vector-vector-xz-distance (-> this root trans) arg1) (-> this active-distance 0))
                             (< 0.0 (-> this last-distance))
                             )
            )
       )
     )
    )
  )

(defmethod check-crossing-distance ((this com-airlock) (arg0 vector) (arg1 symbol))
  (let ((s5-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
        (s4-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> this root trans)))
        )
    (set! (-> s4-1 y) 0.0)
    (let ((f30-0 (vector-dot s4-1 s5-0)))
      (cond
        ((not arg1)
         )
        ((or (< (vector-vector-xz-distance (-> this root trans) arg0) 40960.0)
             (< 0.7 (fabs (vector-dot s5-0 (vector-normalize! s4-1 1.0))))
             )
         (when (and (< f30-0 0.0)
                    (< 0.0 (-> this last-distance))
                    (and (not (and *target* (focus-test? *target* grabbed teleporting)))
                         (< (fabs (- f30-0 (-> this last-distance))) 81920.0)
                         )
                    )
           (let ((s5-1 (res-lump-struct (-> this entity) 'on-cross pair)))
             (if s5-1
                 (script-eval s5-1)
                 )
             )
           )
         (set! (-> this last-distance) f30-0)
         )
        ((< 0.0 (-> this last-distance))
         (set! f30-0 (fmax 4096.0 f30-0))
         )
        ((< (-> this last-distance) 0.0)
         (set! f30-0 (fmin -4096.0 f30-0))
         )
        )
      f30-0
      )
    )
  )

(defmethod want-cross-airlock? ((this com-airlock))
  (local-vars (a0-22 entity-actor))
  (let* ((tpos (target-pos 0))
         (f30-0 (check-crossing-distance this tpos #t))
         (target-dist (vector-vector-xz-distance (-> this root trans) tpos))
         (s5-0 (< (current-time) (-> this latch-open-time)))
         (cmd (airlock-command-lookup (the-as pair (-> this name))))
         )
    (if (= cmd 'open)
        (set! s5-0 #t)
        )
    (and (or s5-0 (< target-dist (if (>= f30-0 0.0)
                                     (-> this active-distance 0)
                                     (-> this active-distance 1)
                                     )
                     )
             )
         (and (or s5-0 (not (-> this y-height)) (and (>= (-> tpos y) (- (-> this root trans y) (-> this y-height y)))
                                                     (< (-> tpos y) (+ (-> this root trans y) (-> this y-height x)))
                                                     )
                  )
              (begin
                (if (and (not (-> this were-behind?)) (and (< f30-0 0.0) (-> this inner?)))
                    (set! (-> this were-behind?) #t)
                    )
                (< (-> this latch-closed-time) (current-time))
                )
              (or (not (and *target* (or (focus-test? *target* teleporting)
                                         (and (not (-> this allow-pilot?)) (focus-test? *target* pilot))
                                         (and (not (-> this allow-flut?)) (focus-test? *target* flut))
                                         )
                            )
                       )
                  (< f30-0 -409.6)
                  )
              (let ((f28-0 (check-crossing-distance this (camera-pos) #f)))
                (if (and *target*
                         (< target-dist 81920.0)
                         (or (< (* f30-0 f28-0) 0.0) (and (>= 32768.0 (fabs f30-0)) (if (= (-> this blocking-plane?) 'front)
                                                                                        (< f30-0 0.0)
                                                                                        (< 0.0 f30-0)
                                                                                        )
                                                          )
                             )
                         (and (or (not (-> this allow-flut?)) (not (-> this allow-pilot?)))
                              (not (logtest? (focus-status flut pilot) (-> *target* focus-status)))
                              )
                         )
                    (persist-with-delay *setting-control* 'pilot (seconds 0.1) 'pilot #f 0.0 0)
                    )
                (or (and (< f30-0 (-> this open-distance 0))
                         (or (not (-> this were-behind?)) (< f30-0 20480.0))
                         (and (or (< 409.6 f30-0)
                                  (begin
                                    (let ((a0-21 (-> this entity)))
                                      (set! a0-22 (entity-actor-lookup a0-21 'next-actor 0))
                                      )
                                    (not a0-22)
                                    )
                                  (logtest? (-> a0-22 extra perm status) (entity-perm-status subtask-complete))
                                  )
                              (script-eval (-> this open-test))
                              (and (-> *setting-control* user-current airlock)
                                   (!= cmd 'close)
                                   (not (and (-> this blocking-plane?) *target* (or (and (not (-> this allow-pilot?)) (focus-test? *target* pilot))
                                                                                    (and (not (-> this allow-flut?)) (focus-test? *target* flut))
                                                                                    )
                                             )
                                        )
                                   )
                              )
                         )
                    s5-0
                    (and (or (not *target*) (not (logtest? (-> *target* focus-status) (focus-status in-head))))
                         (not (and (and (-> this next-state) (= (-> this next-state name) 'close))
                                   (= (-> this skel root-channel 0 frame-num) 0.0)
                                   )
                              )
                         (or (< (* f30-0 f28-0) 0.0)
                             (and (< (fabs f28-0) 4096.0)
                                  (< (vector-vector-xz-distance (camera-pos) (-> this root trans)) (-> this door-radius))
                                  )
                             )
                         )
                    )
                )
              )
         )
    )
  )

(defmethod destination-loaded? ((this com-airlock) (level-status symbol))
  (let ((s5-1 (script-eval (-> this level-name))))
    (cond
      ((not s5-1)
       (if level-status
           'unknown
           #f
           )
       )
      (level-status
        (let ((a1-3 (car s5-1)))
          (while (not (null? s5-1))
            (let ((v1-4 (status-of-level-and-borrows *level* (the-as symbol a1-3) level-status)))
              (case level-status
                (('display)
                 (if (!= v1-4 'active)
                     (return #f)
                     )
                 )
                (else
                  (if (not (or (= v1-4 'loaded) (= v1-4 'active)))
                      (return #f)
                      )
                  )
                )
              )
            (set! s5-1 (cdr s5-1))
            (set! a1-3 (car (the-as pair s5-1)))
            )
          )
        #t
        )
      (else
        (let* ((v1-13 s5-1)
               (a0-8 (car v1-13))
               )
          (while (not (null? v1-13))
            (dotimes (a1-6 10)
              (if (= a0-8 (-> *load-state* want a1-6 name))
                  (goto cfg-32)
                  )
              )
            #t
            (return #f)
            (label cfg-32)
            (set! v1-13 (cdr v1-13))
            (set! a0-8 (car (the-as pair v1-13)))
            )
          )
        #t
        )
      )
    )
  )

(defmethod rotate-gear! ((this com-airlock) (arg0 float))
  (cond
    ((and (>= (ja-aframe-num 0) (-> this gear-start-frame)) (< (ja-aframe-num 0) (-> this gear-stop-frame)))
     (if (and (zero? (-> this gear-sound-id))
              (-> this sound-gear)
              (and (-> this next-state) (= (-> this next-state name) 'open))
              (>= (check-crossing-distance this (target-pos 0) #f) 0.0)
              )
         (set! (-> this gear-sound-id) (sound-play-by-spec (-> this sound-gear) (new-sound-id) (the-as vector #t)))
         )
     (set-time! (-> this gear-play-time))
     (when (nonzero? (-> this gear))
       (seek! (-> this gear-rotv) arg0 (* 131072.0 (seconds-per-frame)))
       (+! (-> this gear-rot) (* (-> this gear-rotv) (seconds-per-frame)))
       (twist-set! (-> this gear) (the-as float #f) (the-as float #f) (-> this gear-rot))
       )
     )
    (else
      (when (and (nonzero? (-> this gear-sound-id)) (time-elapsed? (-> this gear-play-time) (seconds 1.5)))
        (let ((v1-28 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-28 command) (sound-command set-param))
          (set! (-> v1-28 id) (-> this gear-sound-id))
          (set! (-> v1-28 params volume) -4)
          (set! (-> v1-28 auto-time) 120)
          (set! (-> v1-28 auto-from) 2)
          (set! (-> v1-28 params mask) (the-as uint 17))
          (-> v1-28 id)
          )
        (set! (-> this gear-sound-id) (new 'static 'sound-id))
        0
        )
      )
    )
  (-> this gear-rotv)
  )

(defmethod play-city-voice-sound ((this com-airlock) (arg0 symbol))
  (let ((gp-0 (the-as (array string) #f)))
    (case arg0
      (('enter)
       (set! gp-0 (new 'static 'boxed-array :type string "cityv005" "cityv006" "cityv007" "cityv008" "cityv009"))
       )
      (('exit)
       (set! gp-0 (new 'static 'boxed-array :type string "cityv001" "cityv002" "cityv003" "cityv004"))
       )
      )
    (cond
      ((and gp-0 (time-elapsed? (-> this spool-sound-time) (seconds 2)))
       (set-time! (-> this spool-sound-time))
       (add-process
         *gui-control*
         this
         (gui-channel alert)
         (gui-action play)
         (-> gp-0 (rand-vu-int-range 0 (+ (-> gp-0 length) -1)))
         -99.0
         0
         )
       )
      (else
        0
        )
      )
    )
  (none)
  )

(defmethod spawn-blocking-plane ((this com-airlock) (side symbol))
  (case side
    (('front)
     (let ((s5-0 (new 'static 'inline-array vector 2 (new 'static 'vector) (new 'static 'vector))))
       (vector-matrix*!
         (-> s5-0 0)
         (new 'static 'vector :x 40960.0 :w 1.0)
         (-> this node-list data 0 bone transform)
         )
       (vector-matrix*!
         (-> s5-0 1)
         (new 'static 'vector :x -40960.0 :w 1.0)
         (-> this node-list data 0 bone transform)
         )
       (blocking-plane-spawn (the-as curve-control #f) s5-0 122880.0)
       )
     )
    (('back)
     (let ((s5-1 (new 'static 'inline-array vector 2 (new 'static 'vector) (new 'static 'vector))))
       (vector-matrix*!
         (-> s5-1 0)
         (new 'static 'vector :x -40960.0 :w 1.0)
         (-> this node-list data 0 bone transform)
         )
       (vector-matrix*!
         (-> s5-1 1)
         (new 'static 'vector :x 40960.0 :w 1.0)
         (-> this node-list data 0 bone transform)
         )
       (blocking-plane-spawn (the-as curve-control #f) s5-1 122880.0)
       )
     )
    (else
      (blocking-plane-destroy)
      )
    )
  0
  (none)
  )

(defskelgroup skel-com-airlock-outer com-airlock-outer com-airlock-outer-lod0-jg com-airlock-outer-idle-ja
              ((com-airlock-outer-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

(defskelgroup skel-com-airlock-inner com-airlock-inner com-airlock-inner-lod0-jg com-airlock-inner-idle-ja
              ((com-airlock-inner-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

(defstate close (com-airlock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('close)
       (set! (-> self latch-closed-time) (+ (current-time) (if (>= argc 1)
                                                               (the-as int (-> block param 0))
                                                               3000
                                                               )
                                            )
             )
       (if (and (>= argc 2) (and (= (-> block param 1) #t) (not (want-cross-airlock? self))))
           (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
           )
       (and (-> self next-state) (= (-> self next-state name) 'open))
       )
      (('open)
       (set! (-> self latch-open-time) (+ (current-time) (if (>= argc 1)
                                                             (the-as int (-> block param 0))
                                                             3000
                                                             )
                                          )
             )
       (if (and (>= argc 2) (and (= (-> block param 1) #t) (want-cross-airlock? self) (destination-loaded? self #f)))
           (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! max)
           )
       (and (-> self next-state) (= (-> self next-state name) 'close))
       )
      (('front)
       (let ((f30-0 (check-crossing-distance self (target-pos 0) #f))
             (f0-3 (check-crossing-distance self (camera-pos) #f))
             )
         (and (< 2048.0 f30-0) (>= (* f30-0 f0-3) 0.0))
         )
       )
      (('back)
       (let ((f30-1 (check-crossing-distance self (target-pos 0) #f))
             (f0-5 (check-crossing-distance self (camera-pos) #f))
             )
         (and (< f30-1 -2048.0) (>= (* f30-1 f0-5) 0.0))
         )
       )
      (('sound)
       (if (>= (check-crossing-distance self (target-pos 0) #f) 0.0)
           (play-city-voice-sound self (the-as symbol (-> block param 0)))
           )
       )
      (('distance)
       (* (the int (check-crossing-distance self (target-pos 0) #f)) 8)
       )
      (('open?)
       (-> self open?)
       )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set-time! (-> self state-time))
    (set! (-> self visible-move?) #f)
    )
  :exit (behavior ()
    (spawn-blocking-plane self #f)
    (when (nonzero? (-> self sound-id))
      (let ((v1-4 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-4 command) (sound-command set-param))
        (set! (-> v1-4 id) (-> self sound-id))
        (set! (-> v1-4 params volume) -4)
        (set! (-> v1-4 auto-time) 24)
        (set! (-> v1-4 auto-from) 2)
        (set! (-> v1-4 params mask) (the-as uint 17))
        (-> v1-4 id)
        )
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    (when (nonzero? (-> self gear-sound-id))
      (let ((v1-9 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-9 command) (sound-command set-param))
        (set! (-> v1-9 id) (-> self gear-sound-id))
        (set! (-> v1-9 params volume) -4)
        (set! (-> v1-9 auto-time) 24)
        (set! (-> v1-9 auto-from) 2)
        (set! (-> v1-9 params mask) (the-as uint 17))
        (-> v1-9 id)
        )
      (set! (-> self gear-sound-id) (new 'static 'sound-id))
      0
      )
    (airlock-stop-part-trackers)
    )
  :trans (behavior ()
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (set! (-> self visible-move?) #t)
        )
    (when (and (want-cross-airlock? self)
               (and (!= (-> self state-time) (current-time))
                    (begin
                      (let ((gp-0 (res-lump-struct (-> self entity) 'on-activate structure)))
                        (if gp-0
                            (script-eval (the-as pair gp-0))
                            )
                        )
                      (destination-loaded? self #f)
                      )
                    )
               )
      (when (nonzero? (-> self sound-id))
        (let ((v1-19 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-19 command) (sound-command set-param))
          (set! (-> v1-19 id) (-> self sound-id))
          (set! (-> v1-19 params volume) -4)
          (set! (-> v1-19 auto-time) 24)
          (set! (-> v1-19 auto-from) 2)
          (set! (-> v1-19 params mask) (the-as uint 17))
          (-> v1-19 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (go-virtual open #f)
      )
    (let ((gp-1 (-> self on-running)))
      (if gp-1
          (script-eval gp-1)
          )
      )
    )
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status subtask-complete) #f)
    (when (not arg0)
      ((lambda :behavior com-airlock () (when (ja-max? 0)
                                          (let ((gp-0 (res-lump-struct (-> self entity) 'on-start-close pair)))
                                            (if (and gp-0 (not *scene-player*))
                                                (script-eval gp-0)
                                                )
                                            )
                                          )
                                     )
       )
      (spawn-blocking-plane self #t)
      (if (and (-> self sound-close)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (sound-play-by-spec (-> self sound-close) (new-sound-id) (the-as vector #t))
          )
      (if (and (-> self sound-close-loop)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (set! (-> self sound-id) (sound-play-by-spec (-> self sound-close-loop) (new-sound-id) (the-as vector #t)))
          )
      (while (< (-> self open-frame) (ja-aframe-num 0))
        (rotate-gear! self 65536.0)
        (when (and (-> self were-behind?)
                   (< 0.4 (vector-dot
                            (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
                            (-> (math-camera-matrix) fvec)
                            )
                      )
                   (< 0.0 (check-crossing-distance self (target-pos 0) #f))
                   )
          (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
          (goto cfg-42)
          )
        (suspend)
        (ja :num! (seek! 0.0 (-> self close-speed-multiplier)))
        (transform-post)
        )
      (label cfg-42)
      (if (com-airlock-method-26 self (target-pos 0) 'front)
          ((lambda :behavior com-airlock
             ()
             (let ((gp-0 (res-lump-struct (-> self entity) 'on-exit structure)))
               (if (and gp-0 (not *scene-player*))
                   (script-eval (the-as pair gp-0))
                   )
               )
             (when (-> self were-behind?)
               (let ((gp-1 (res-lump-struct (-> self entity) 'on-inside structure)))
                 (set! (-> self were-behind?) #f)
                 (if (and gp-1 (not *scene-player*))
                     (script-eval (the-as pair gp-1))
                     )
                 )
               )
             )
           )
          )
      (when (nonzero? (-> self sound-id))
        (let ((v1-48 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-48 command) (sound-command set-param))
          (set! (-> v1-48 id) (-> self sound-id))
          (set! (-> v1-48 params volume) -4)
          (set! (-> v1-48 auto-time) 24)
          (set! (-> v1-48 auto-from) 2)
          (set! (-> v1-48 params mask) (the-as uint 17))
          (-> v1-48 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (if (and (-> self sound-close-stop) (not arg0) (-> self visible-move?))
          (sound-play-by-spec (-> self sound-close-stop) (new-sound-id) (the-as vector #t))
          )
      (while (not (ja-min? 0))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-post-close)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-post-close) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek! 0.0))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-73 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-73 command) (sound-command set-param))
          (set! (-> v1-73 id) (-> self sound-id))
          (set! (-> v1-73 params volume) -4)
          (set! (-> v1-73 auto-time) 24)
          (set! (-> v1-73 auto-from) 2)
          (set! (-> v1-73 params mask) (the-as uint 17))
          (-> v1-73 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-post-close-stop)
            (sound-play-by-spec (-> self sound-post-close-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (set! (-> self open?) #f)
      (when (com-airlock-method-26 self (target-pos 0) 'front)
        (let ((gp-3 (res-lump-struct (-> self entity) 'on-deactivate structure)))
          (if (and gp-3 (not *scene-player*))
              (script-eval (the-as pair gp-3))
              )
          )
        )
      (while (!= (-> self gear-rotv) 0.0)
        (rotate-gear! self 0.0)
        (suspend)
        (transform-post)
        )
      (when (nonzero? (-> self gear-sound-id))
        (let ((v1-93 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-93 command) (sound-command set-param))
          (set! (-> v1-93 id) (-> self gear-sound-id))
          (set! (-> v1-93 params volume) -4)
          (set! (-> v1-93 auto-time) 24)
          (set! (-> v1-93 auto-from) 2)
          (set! (-> v1-93 params mask) (the-as uint 17))
          (-> v1-93 id)
          )
        (set! (-> self gear-sound-id) (new 'static 'sound-id))
        0
        )
      (airlock-stop-part-trackers)
      )
    (spawn-blocking-plane self #f)
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defstate open (com-airlock)
  :virtual #t
  :event (-> (method-of-type com-airlock close) event)
  :enter (behavior ((arg0 symbol))
    (set! (-> self visible-move?) #f)
    )
  :exit (-> (method-of-type com-airlock close) exit)
  :trans (behavior ()
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (set! (-> self visible-move?) #t)
        )
    (if (not (want-cross-airlock? self))
        (go-virtual close #f)
        )
    (when (logtest? (-> self mask) (process-mask sleep-code))
      (let ((v1-15 (destination-loaded? self 'display)))
        (when (or (not v1-15) (= v1-15 'unknown))
          (if (and (not v1-15) (< (-> self open-frame) (ja-aframe-num 0)))
              (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
              )
          (go-virtual close #f)
          )
        )
      )
    (let ((gp-1 (-> self on-running)))
      (if gp-1
          (script-eval gp-1)
          )
      )
    )
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      ((lambda :behavior com-airlock
         ()
         (when (ja-min? 0)
           (let ((gp-0 (res-lump-struct (-> self entity) 'on-start-open pair)))
             (if (and gp-0 (not *scene-player*) (time-elapsed? (-> self start-open-time) (seconds 0.1)))
                 (script-eval gp-0)
                 )
             )
           )
         )
       )
      (set-time! (-> self start-open-time))
      (when (< (check-crossing-distance self (target-pos 0) #f) 0.0)
        (if (< (ja-aframe-num 0) (-> self pre-open-frame))
            (ja :num-func num-func-identity :frame-num (ja-aframe (-> self pre-open-frame) 0))
            )
        )
      (while (< (ja-aframe-num 0) (-> self lock-frame))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-pre-open)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-pre-open) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek! (ja-aframe (-> self lock-frame) 0) (-> self pre-open-speed)))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-29 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-29 command) (sound-command set-param))
          (set! (-> v1-29 id) (-> self sound-id))
          (set! (-> v1-29 params volume) -4)
          (set! (-> v1-29 auto-time) 24)
          (set! (-> v1-29 auto-from) 2)
          (set! (-> v1-29 params mask) (the-as uint 17))
          (-> v1-29 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-pre-open-stop)
            (sound-play-by-spec (-> self sound-pre-open-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (while (< (ja-aframe-num 0) (-> self open-frame))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-lock-loop)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-lock-loop) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek! (ja-aframe (-> self open-frame) 0) 2.0))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-52 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-52 command) (sound-command set-param))
          (set! (-> v1-52 id) (-> self sound-id))
          (set! (-> v1-52 params volume) -4)
          (set! (-> v1-52 auto-time) 24)
          (set! (-> v1-52 auto-from) 2)
          (set! (-> v1-52 params mask) (the-as uint 17))
          (-> v1-52 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-lock-stop)
            (sound-play-by-spec (-> self sound-lock-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (while (not (destination-loaded? self #t))
        (if (not (destination-loaded? self #f))
            (go-virtual close #f)
            )
        (rotate-gear! self 65536.0)
        (suspend)
        (transform-post)
        )
      (process-entity-status! self (entity-perm-status subtask-complete) #t)
      (set! (-> self open?) #t)
      (let ((s5-10 (res-lump-struct (-> self entity) 'on-enter structure)))
        (if s5-10
            (script-eval (the-as pair s5-10))
            )
        )
      (if (and (-> self sound-open)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (sound-play-by-spec (-> self sound-open) (new-sound-id) (the-as vector #t))
          )
      (if (and (-> self sound-open-loop)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (set! (-> self sound-id) (sound-play-by-spec (-> self sound-open-loop) (new-sound-id) (the-as vector #t)))
          )
      (set! (-> *ACTOR-bank* birth-max) 1000)
      (while (not (ja-max? 0))
        (rotate-gear! self 65536.0)
        (suspend)
        (ja :num! (seek!))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-104 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-104 command) (sound-command set-param))
          (set! (-> v1-104 id) (-> self sound-id))
          (set! (-> v1-104 params volume) -4)
          (set! (-> v1-104 auto-time) 24)
          (set! (-> v1-104 auto-from) 2)
          (set! (-> v1-104 params mask) (the-as uint 17))
          (-> v1-104 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (when (nonzero? (-> self gear-sound-id))
        (let ((v1-109 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-109 command) (sound-command set-param))
          (set! (-> v1-109 id) (-> self gear-sound-id))
          (set! (-> v1-109 params volume) -4)
          (set! (-> v1-109 auto-time) 24)
          (set! (-> v1-109 auto-from) 2)
          (set! (-> v1-109 params mask) (the-as uint 17))
          (-> v1-109 id)
          )
        (set! (-> self gear-sound-id) (new 'static 'sound-id))
        0
        )
      (airlock-stop-part-trackers)
      (if (and (-> self sound-open-stop) (not arg0) (-> self visible-move?))
          (sound-play-by-spec (-> self sound-open-stop) (new-sound-id) (the-as vector #t))
          )
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (set! (-> self open?) #t)
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! max)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(deftype com-airlock-outer (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this com-airlock-outer) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 7)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (init-airlock! this)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-com-airlock-outer" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this pre-open-frame) 35.0)
  (set! (-> this lock-frame) 45.0)
  (set! (-> this open-frame) 45.0)
  (set! (-> this sound-pre-open) (static-sound-spec "airlock-slider" :group 0))
  (set! (-> this sound-pre-open-stop) (static-sound-spec "airlock-slide-e" :group 0))
  (set! (-> this sound-open) (static-sound-spec "airlock-seal" :group 0))
  (set! (-> this sound-open-loop) (static-sound-spec "airlock-open" :group 0))
  (set! (-> this sound-open-stop) (static-sound-spec "airlock-hit" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "airlock-open" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "airlock-hit" :group 0))
  (set! (-> this sound-post-close) (static-sound-spec "airlock-slider" :group 0))
  (set! (-> this sound-post-close-stop) (static-sound-spec "airlock-slide-e" :group 0))
  (go (method-of-object this close) #t)
  )

(deftype com-airlock-inner (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this com-airlock-inner) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 8)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-com-airlock-inner" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this lock-frame) 37.0)
  (set! (-> this pre-open-frame) 65.0)
  (set! (-> this open-frame) 75.0)
  (set! (-> this gear) (new 'process 'joint-mod (joint-mod-mode rotate) this 12))
  (set! (-> this inner?)
        (logtest? (the-as
                    int
                    (res-lump-value (-> this entity) 'options uint128 :default (the-as uint128 1) :time -1000000000.0)
                    )
                  1
                  )
        )
  (set! (-> this pre-open-speed) 0.9)
  (set! (-> this sound-gear) (static-sound-spec "airlock-gear" :group 0))
  (set! (-> this sound-pre-open) (static-sound-spec "airlock-slider" :group 0))
  (set! (-> this sound-pre-open-stop) (static-sound-spec "airlock-slide-e" :group 0))
  (set! (-> this sound-lock-loop) (static-sound-spec "airlock-turn" :group 0))
  (set! (-> this sound-lock-stop) (static-sound-spec "airlock-unlock" :group 0))
  (set! (-> this sound-open) (static-sound-spec "airlock-seal" :group 0))
  (set! (-> this sound-open-loop) (static-sound-spec "airlock-open" :group 0))
  (set! (-> this sound-open-stop) (static-sound-spec "airlock-hit" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "airlock-open" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "airlock-hit" :group 0))
  (go (method-of-object this close) #t)
  )

(defskelgroup skel-cty-door cty-door cty-door-lod0-jg cty-door-idle-ja
              ((cty-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 8)
              )

(deftype cty-door (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this cty-door) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 32768.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 28672.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 28672.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-door" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open) (static-sound-spec "hqdoor-open" :group 0))
  (set! (-> this sound-close) (static-sound-spec "hqdoor-close" :group 0))
  (go (method-of-object this close) #t)
  )

(defskelgroup skel-vin-door-ctyinda vin-door-ctyinda vin-door-ctyinda-lod0-jg vin-door-ctyinda-idle-ja
              ((vin-door-ctyinda-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 6)
              )

(deftype vin-door-ctyinda (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this vin-door-ctyinda) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 12288.0 0.0 24576.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 8192.0 16384.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) -8192.0 16384.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vin-door-ctyinda" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open) (static-sound-spec "vindoor-open" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "vindoor-close" :group 0))
  (set! (-> this door-radius) 8192.0)
  (go (method-of-object this close) #t)
  )

(defskelgroup skel-com-airlock-outer-mhcity com-airlock-outer-mhcity com-airlock-outer-mhcity-lod0-jg com-airlock-outer-mhcity-idle-ja
              ((com-airlock-outer-mhcity-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

(deftype com-airlock-outer-mhcity (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this com-airlock-outer-mhcity) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (init-airlock! this)
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-com-airlock-outer-mhcity" (the-as (pointer level) #f))
      )
    (the-as pair 0)
    )
  (set! (-> this sound-pre-open) (static-sound-spec "airlock-slider" :group 0))
  (set! (-> this sound-pre-open-stop) (static-sound-spec "airlock-slide-e" :group 0))
  (set! (-> this sound-open) (static-sound-spec "airlock-seal" :group 0))
  (set! (-> this sound-open-loop) (static-sound-spec "airlock-open" :group 0))
  (set! (-> this sound-open-stop) (static-sound-spec "airlock-hit" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "airlock-open" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "airlock-hit" :group 0))
  (set! (-> this sound-post-close) (static-sound-spec "airlock-slider" :group 0))
  (set! (-> this sound-post-close-stop) (static-sound-spec "airlock-slide-e" :group 0))
  (go (method-of-object this close) #t)
  )

(defskelgroup skel-hip-door-a hip-door-a hip-door-a-lod0-jg hip-door-a-idle-ja
              ((hip-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

(deftype hip-door-a (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this hip-door-a) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-hip-door-a" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this sound-open-loop) (static-sound-spec "wood-door-open" :group 0))
  (set! (-> this sound-open-stop) (static-sound-spec "wood-open-hit" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "wood-door-close" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "wood-close-hit" :group 0))
  (set! (-> this door-radius) 8192.0)
  (go (method-of-object this close) #t)
  )
