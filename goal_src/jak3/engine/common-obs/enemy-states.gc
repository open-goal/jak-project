;;-*-Lisp-*-
(in-package goal)

;; name: enemy-states.gc
;; name in dgo: enemy-states
;; dgos: GAME

;; DECOMP BEGINS

(defstate idle (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (stop-look-at! self)
    (logclear! (-> self enemy-flags) (enemy-flag notice alert cam-attack-mode))
    (logior! (-> self enemy-flags) (enemy-flag use-notice-distance))
    (set! (-> self state-timeout) (seconds 0.5))
    (if (-> self on-notice)
        (logior! (-> self enemy-flags) (enemy-flag enable-on-notice))
        )
    (if (-> self on-active)
        (logior! (-> self enemy-flags) (enemy-flag enable-on-active))
        )
    (if (-> self on-hostile)
        (logior! (-> self enemy-flags) (enemy-flag enable-on-hostile))
        )
    (when (not (logtest? (enemy-flag chase-startup) (-> self enemy-flags)))
      (if (logtest? (-> self enemy-flags) (enemy-flag actor-pause-backup))
          (logior! (-> self mask) (process-mask actor-pause))
          (logclear! (-> self mask) (process-mask actor-pause))
          )
      )
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (-> self state-timeout))
      (let ((v1-3 (-> self focus aware)))
        (cond
          ((< 1 (the-as int v1-3))
           (go-virtual notice)
           )
          ((> (the-as int v1-3) 0)
           (go-virtual active)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (sleep-code)
    )
  :post (behavior ()
    (play-idle-frames! (-> self idle-anim-player) self)
    (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
        (set-time! (-> self last-draw-time))
        )
    (update-focus self)
    (ja-post)
    )
  )

(defstate dormant (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    ((-> (method-of-type enemy idle) enter))
    (set! (-> self root nav-flags) (nav-flags))
    (let ((v1-4 (-> self root root-prim)))
      (set! (-> v1-4 prim-core collide-as) (collide-spec))
      (set! (-> v1-4 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (set! (-> self draw origin quad) (-> self root trans quad))
    (if (logtest? (enemy-flag directed) (-> self enemy-flags))
        (logior! (-> self enemy-flags) (enemy-flag directed-ready))
        )
    (logior! (-> self focus-status) (focus-status disable))
    )
  :exit (behavior ()
    (logclear! (-> self focus-status) (focus-status disable))
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-3 prim-core collide-with) (-> self root backup-collide-with))
      )
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (logclear! (-> self enemy-flags) (enemy-flag directed-ready))
    (logior! (-> self root nav-flags) (nav-flags has-root-sphere))
    )
  :code sleep-code
  )

(defstate dormant-aware (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (-> (method-of-type enemy dormant) enter)
  :exit (-> (method-of-type enemy dormant) exit)
  :trans (behavior ()
    (when (and (time-elapsed? (-> self state-time) (-> self state-timeout)) (> (the-as int (-> self focus aware)) 0))
      (if (logtest? (enemy-option ambush) (-> self fact enemy-options))
          (go-ambush-delay self)
          (go-virtual active)
          )
      )
    )
  :code sleep-code
  :post (behavior ()
    (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
        (set-time! (-> self last-draw-time))
        )
    (update-focus self)
    )
  )

(defstate ambush-delay (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self desired-angle) (fmax 0.0 (res-lump-float (-> self entity) 'ambush-delay)))
    (logior! (-> self focus-status) (focus-status disable))
    (let ((v1-6 (-> self root root-prim)))
      (set! (-> v1-6 prim-core collide-as) (collide-spec))
      (set! (-> v1-6 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (logior! (-> self enemy-flags) (enemy-flag directed-ready))
    (logclear! (-> self root nav-flags) (nav-flags has-root-sphere))
    )
  :exit (behavior ()
    ((-> (method-of-type enemy dormant) exit))
    (logior! (-> self enemy-flags) (enemy-flag alert))
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (the int (* 300.0 (-> self desired-angle))))
        (go-virtual ambush)
        )
    )
  :code sleep-code
  )

(defstate ambush (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag alert))
    )
  :code (behavior ()
    (go-virtual notice)
    )
  )

(defstate active (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logclear! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (when (logtest? (-> self enemy-flags) (enemy-flag enable-on-active))
      (logclear! (-> self enemy-flags) (enemy-flag enable-on-active))
      (let ((gp-0 (-> self on-active)))
        (if gp-0
            (script-eval gp-0 :vector (-> self root trans))
            )
        )
      )
    (when (not (logtest? (enemy-flag chase-startup) (-> self enemy-flags)))
      (if (logtest? (-> self enemy-flags) (enemy-flag actor-pause-backup))
          (logior! (-> self mask) (process-mask actor-pause))
          (logclear! (-> self mask) (process-mask actor-pause))
          )
      )
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.1))
      (let ((v1-3 (-> self focus aware)))
        (cond
          ((< (the-as int v1-3) 1)
           (go-idle self)
           )
          ((< 1 (the-as int v1-3))
           (go-virtual notice)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (sleep-code)
    )
  :post (behavior ()
    (play-idle-frames! (-> self idle-anim-player) self)
    (enemy-simple-post)
    )
  )

(defstate notice (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-3 (logior (-> self enemy-flags) (enemy-flag cam-attack-mode))))
      (set! (-> self enemy-flags) (logclear v1-3 (enemy-flag use-trigger)))
      )
    (logclear! (-> self mask) (process-mask actor-pause))
    (set-look-at-mode! self 1)
    (when (logtest? (-> self enemy-flags) (enemy-flag enable-on-notice))
      (logclear! (-> self enemy-flags) (enemy-flag enable-on-notice))
      (let ((gp-0 (-> self on-notice)))
        (if gp-0
            (script-eval gp-0 :vector (-> self root trans))
            )
        )
      )
    (let ((gp-1 (-> self focus aware)))
      (when (logtest? (-> self enemy-flags) (enemy-flag alert))
        (cond
          ((and (= gp-1 (enemy-aware ea3)) (get-focus! self))
           (go-hostile self)
           )
          ((= gp-1 (enemy-aware ea4))
           (go-flee self)
           )
          (else
            (go-stare self)
            )
          )
        )
      )
    (logior! (-> self enemy-flags) (enemy-flag alert))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (rnd-float-range self 0.8 1.2))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info notice-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (vector-! gp-0 (target-pos 0) (-> self root trans))
        (seek-toward-heading-vec! (-> self root) gp-0 131072.0 (seconds 0.05))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-best-state self)
    )
  :post enemy-simple-post
  )

(defstate hostile (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-look-at-mode! self 1)
    (logior! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (logclear! (-> self enemy-flags) (enemy-flag chase-startup))
    (logclear! (-> self mask) (process-mask actor-pause))
    (when (logtest? (enemy-flag enable-on-hostile) (-> self enemy-flags))
      (logclear! (-> self enemy-flags) (enemy-flag enable-on-hostile))
      (let ((gp-0 (-> self on-hostile)))
        (if gp-0
            (script-eval gp-0 :vector (-> self root trans))
            )
        )
      )
    )
  :trans (behavior ()
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (let ((gp-0 (-> self focus aware)))
      (when (time-elapsed? (-> self state-time) (-> self reaction-time))
        (cond
          ((or (>= 2 (the-as int gp-0)) (not (get-focus! self)))
           (go-stare self)
           )
          ((= gp-0 (enemy-aware ea4))
           (go-flee self)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data (-> self enemy-info hostile-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    )
  :post enemy-simple-post
  )

(defstate stare (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logclear! (-> self mask) (process-mask actor-pause))
    (logclear! (-> self enemy-flags) (enemy-flag chase-startup))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.1))
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (go-virtual active)
           )
          ((and (= gp-0 (enemy-aware ea3)) (get-focus! self))
           (go-hostile self)
           )
          ((= gp-0 (enemy-aware ea4))
           (go-flee self)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info idle-anim)))
          )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post enemy-simple-post
  )

(defstate victory (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag victory))
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (rnd-float-range self 0.8 1.2)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info victory-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-best-state self)
    )
  :post enemy-simple-post
  )

(defstate flee (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-look-at-mode! self 1)
    (logclear! (-> self enemy-flags) (enemy-flag chase-startup))
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (if (!= (-> self focus aware) (enemy-aware ea4))
          (go-stare self)
          )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim)) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post enemy-simple-post
  )

(defstate jump (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logclear! (-> self mask) (process-mask actor-pause))
    (logior! (-> self focus-status) (focus-status dangerous))
    (let* ((v1-6 *game-info*)
           (a0-2 (+ (-> v1-6 attack-id) 1))
           )
      (set! (-> v1-6 attack-id) a0-2)
      (set! (-> self attack-id) a0-2)
      )
    (logclear! (-> self focus-status) (focus-status in-air))
    )
  :exit (behavior ()
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'enemy-jump-info)))
      (let ((s5-0 0))
        (init-jump-info! self gp-0)
        (if (and (-> self enemy-info use-jump-blocked)
                 (logtest? (enemy-flag jump-check-blocked) (-> self enemy-flags))
                 (enemy-method-91 self gp-0)
                 )
            (go-virtual jump-blocked)
            )
        (when (logtest? (-> gp-0 flags) (enemy-jump-flags ejf0))
          (until #f
            (if (jump-anim-handler self s5-0 gp-0)
                (goto cfg-12)
                )
            (in-jump-handler self s5-0 gp-0)
            (enemy-method-101 self s5-0 gp-0)
            (suspend)
            (set! s5-0 1)
            )
          #f
          )
        )
      (label cfg-12)
      (logclear! (-> self root status) (collide-status on-surface on-ground touch-surface))
      (let ((s5-1 2))
        (logior! (-> self focus-status) (focus-status in-air))
        (until (on-ground? self gp-0)
          (+! (-> gp-0 hang-time) (- (current-time) (-> self clock old-frame-counter)))
          (jump-anim-handler self s5-1 gp-0)
          (in-jump-handler self s5-1 gp-0)
          (enemy-method-101 self s5-1 gp-0)
          (suspend)
          (set! s5-1 3)
          )
        )
      (logclear! (-> self focus-status) (focus-status in-air))
      (move-to-gspot! self)
      (let ((s5-2 4))
        (until #f
          (if (jump-anim-handler self s5-2 gp-0)
              (goto cfg-19)
              )
          (in-jump-handler self s5-2 gp-0)
          (enemy-method-101 self s5-2 gp-0)
          (suspend)
          (set! s5-2 5)
          )
        )
      )
    #f
    (label cfg-19)
    (if (logtest? (enemy-flag directed) (-> self enemy-flags))
        ((lambda :behavior enemy () (send-event (ppointer->process (-> self parent)) 'child-jumped)))
        )
    (go-directed2 self)
    )
  :post (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> a1-0 options) (overlaps-others-options))
      (set! (-> a1-0 collide-with-filter) (-> self enemy-info overlaps-others-collide-with-filter))
      (set! (-> a1-0 tlist) *touching-list*)
      (find-overlapping-shapes (-> self root) a1-0)
      )
    (enemy-simple-post)
    )
  )

(defstate jump-blocked (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.5))
      (if (logtest? (enemy-flag directed) (-> self enemy-flags))
          (go-virtual jump)
          (go-directed2 self)
          )
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 (-> self draw art-group data (-> self enemy-info idle-anim)))))
        (ja-channel-push! 1 (seconds 0.2))
        (ja :group! (-> self draw art-group data (-> self enemy-info idle-anim))
            :num! (identity (rand-vu-float-range 0.0 (the float (+ (-> (ja-group) frames num-frames) -1))))
            )
        )
      )
    (let ((f30-0 (rnd-float-range self 0.75 1.25)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    )
  :post enemy-simple-post
  )

(defstate hit (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (stop-look-at! self)
    (logclear! (-> self mask) (process-mask actor-pause))
    (play-damage-sound self 0)
    )
  :code (behavior ()
    (local-vars (v1-37 enemy-flag) (v1-39 enemy-flag) (v1-41 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info hit-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-36 (-> self enemy-flags)))
      (if (logtest? v1-36 (enemy-flag vulnerable-backup))
          (set! v1-37 (logior v1-36 (enemy-flag vulnerable)))
          (set! v1-37 (logclear v1-36 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-37)
    (let ((v1-38 (-> self enemy-flags)))
      (if (logtest? v1-38 (enemy-flag attackable-backup))
          (set! v1-39 (logior v1-38 (enemy-flag attackable)))
          (set! v1-39 (logclear v1-38 (enemy-flag attackable)))
          )
      )
    (set! (-> self enemy-flags) v1-39)
    (let ((v1-40 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-40)
          (set! v1-41 (logior (enemy-flag trackable) v1-40))
          (set! v1-41 (logclear v1-40 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-41)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self focus-status) (focus-status hit))
    (go-hostile self)
    )
  :post enemy-simple-post
  )

(defstate knocked (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (when (>= 0.0 (-> self hit-points))
      (let ((v1-2 (handle->process (-> self incoming attacker-handle))))
        (when (or (not (-> self draw))
                  (and (or (not v1-2) (!= (-> v1-2 type) target))
                       (or (not (logtest? (-> self draw status) (draw-control-status on-screen)))
                           (let ((f0-1 450560.0))
                             (< (* f0-1 f0-1) (vector-vector-xz-distance-squared (-> self root trans) (math-camera-pos)))
                             )
                           )
                       )
                  )
          (send-event (ppointer->process (-> self parent)) 'child-die)
          (go-virtual die-fast)
          )
        )
      )
    (set-time! (-> self state-time))
    (stop-look-at! self)
    (logior! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self mask) (process-mask actor-pause))
    (let* ((v1-30 *game-info*)
           (a0-13 (+ (-> v1-30 attack-id) 1))
           )
      (set! (-> v1-30 attack-id) a0-13)
      (set! (-> self attack-id) a0-13)
      )
    (if (logtest? (enemy-option knocked-into-water) (-> self fact enemy-options))
        (logior! (-> self enemy-flags) (enemy-flag check-water))
        )
    (if (and (enemy-method-123 self) (-> self enemy-info ragdoll-info))
        (set! (-> self root transv y) 0.0)
        )
    (let ((v1-43 (-> self root)))
      (logclear! (-> v1-43 status) (collide-status
                                     on-surface
                                     on-ground
                                     touch-surface
                                     touch-wall
                                     touch-ceiling
                                     touch-actor
                                     on-special-surface
                                     touch-edge
                                     blocked
                                     on-water
                                     impact-surface
                                     touch-background
                                     stuck
                                     glance
                                     )
                 )
      (when (not (logtest? (-> v1-43 root-prim prim-core action) (collide-action no-normal-reset)))
        (let ((a0-25 (-> v1-43 dynam gravity-normal)))
          (set! (-> v1-43 local-normal quad) (-> a0-25 quad))
          (set! (-> v1-43 surface-normal quad) (-> a0-25 quad))
          (set! (-> v1-43 poly-normal quad) (-> a0-25 quad))
          )
        (set! (-> v1-43 coverage) 0.0)
        (set! (-> v1-43 touch-angle) 0.0)
        )
      (knocked-handler self (-> v1-43 transv))
      )
    (if (>= (-> self enemy-info knocked-seek-ry-clamp) 0.0)
        (set! (-> self desired-angle) (get-knockback-angle self))
        )
    (if (or (= (-> self hit-points) 0.0) (nonzero? (-> self fated-time)))
        (on-dying self)
        (play-damage-sound self 0)
        )
    (logclear! (-> self focus-status) (focus-status dangerous))
    (if (= (-> self incoming knocked-type) (knocked-type yellow-shot))
        (logclear! (-> self enemy-flags) (enemy-flag trackable))
        )
    (set! (-> self root penetrate-using) (penetrate lunge vehicle knocked))
    (reset-penetrate! self)
    (enemy-method-50 self 1)
    (ragdoll-spawn! self #t #f)
    )
  :exit (behavior ()
    (disable-ragdoll self)
    )
  :trans (behavior ()
    (if (>= (-> self enemy-info knocked-seek-ry-clamp) 0.0)
        (seek-toward-yaw-angle! (-> self root) (-> self desired-angle) 138353.78 (seconds 0.1))
        )
    )
  :code (behavior ()
    (cond
      ((handle->process (-> self ragdoll-proc))
       (let ((gp-0 (current-time)))
         (until (time-elapsed? gp-0 (seconds 0.2))
           (suspend)
           )
         )
       (until (ragdoll-settled? self)
         (if (or (time-elapsed? (-> self state-time) (seconds 4)) (enemy-method-109 self))
             (go-die self)
             )
         (suspend)
         )
       (if (within-gspot-range? self)
           (go-die self)
           )
       )
      (else
        (let ((gp-1 (new 'stack-no-clear 'enemy-knocked-info)))
          (let ((s5-0 0))
            (set! (-> gp-1 anim-speed) (rnd-float-range self 0.9 1.1))
            (set! (-> gp-1 on-surface-count) 0)
            (set! (-> gp-1 move-count) 0)
            (until (enemy-method-88 self gp-1)
              (if (time-elapsed? (-> self state-time) (seconds 2))
                  (go-die self)
                  )
              (if (logtest? (-> self root status) (collide-status on-surface))
                  (+! (-> gp-1 on-surface-count) 1)
                  )
              (knocked-anim-handler self s5-0 gp-1)
              (suspend)
              (+! (-> gp-1 move-count) 1)
              (set! s5-0 1)
              )
            )
          (let ((s5-1 2))
            (set-time! (-> gp-1 land-can-land-time))
            (until #f
              (if (logtest? (-> self root status) (collide-status on-surface))
                  (+! (-> gp-1 on-surface-count) 1)
                  )
              (if (knocked-anim-handler self s5-1 gp-1)
                  (goto cfg-33)
                  )
              (suspend)
              (+! (-> gp-1 move-count) 1)
              (set! s5-1 3)
              (if (enemy-method-88 self gp-1)
                  (set-time! (-> gp-1 land-can-land-time))
                  )
              )
            )
          #f
          (label cfg-33)
          (if (and (not (logtest? (enemy-flag death-start) (-> self enemy-flags)))
                   (or (within-gspot-range? self)
                       (enemy-method-109 self)
                       (time-elapsed? (-> gp-1 land-can-land-time) (-> self enemy-info knocked-can-land-timeout))
                       )
                   )
              (go-die self)
              )
          (while (not (knocked-anim-handler self 4 gp-1))
            (suspend)
            )
          )
        )
      )
    (cond
      ((or (= (-> self hit-points) 0.0) (nonzero? (-> self fated-time)))
       (cond
         ((logtest? (enemy-flag death-start) (-> self enemy-flags))
          (set! (-> self hit-points) 0.0)
          (let ((v1-90 (-> self root root-prim)))
            (set! (-> v1-90 prim-core collide-as) (collide-spec))
            (set! (-> v1-90 prim-core collide-with) (collide-spec))
            )
          0
          (send-event self 'death-end)
          (let ((gp-2 (-> self child)))
            (while gp-2
              (send-event (ppointer->process gp-2) 'notice 'die)
              (set! gp-2 (-> gp-2 0 brother))
              )
            )
          (while (-> self child)
            (suspend)
            )
          (cleanup-for-death self)
          )
         (else
           (when (and (-> self skel effect) (logtest? (enemy-flag auto-death-phase-out) (-> self enemy-flags)))
             (do-effect (-> self skel effect) "death-default" 0.0 -1)
             (suspend)
             0
             )
           (go-die self)
           )
         )
       )
      (else
        (go-virtual knocked-recover)
        )
      )
    )
  :post enemy-falling-post
  )

(defstate knocked-recover (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (local-vars (v1-1 enemy-flag) (v1-13 enemy-flag) (v1-15 enemy-flag) (v1-17 enemy-flag))
    (let ((v1-0 (-> self enemy-flags)))
      (if (logtest? (enemy-flag check-water-backup) v1-0)
          (set! v1-1 (logior (enemy-flag check-water) v1-0))
          (set! v1-1 (logclear v1-0 (enemy-flag check-water)))
          )
      )
    (set! (-> self enemy-flags) v1-1)
    (when (!= (-> self hit-points) 0.0)
      (set! (-> self root penetrate-using)
            (the-as penetrate (logclear (-> self root penetrate-using) (penetrate knocked)))
            )
      (enemy-method-50 self 2)
      (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
          (logior! (-> self focus-status) (focus-status dangerous))
          (logclear! (-> self focus-status) (focus-status dangerous))
          )
      (let ((v1-12 (-> self enemy-flags)))
        (if (logtest? v1-12 (enemy-flag vulnerable-backup))
            (set! v1-13 (logior v1-12 (enemy-flag vulnerable)))
            (set! v1-13 (logclear v1-12 (enemy-flag vulnerable)))
            )
        )
      (set! (-> self enemy-flags) v1-13)
      (let ((v1-14 (-> self enemy-flags)))
        (if (logtest? v1-14 (enemy-flag attackable-backup))
            (set! v1-15 (logior v1-14 (enemy-flag attackable)))
            (set! v1-15 (logclear v1-14 (enemy-flag attackable)))
            )
        )
      (set! (-> self enemy-flags) v1-15)
      (let ((v1-16 (-> self enemy-flags)))
        (if (logtest? (enemy-flag trackable-backup) v1-16)
            (set! v1-17 (logior (enemy-flag trackable) v1-16))
            (set! v1-17 (logclear v1-16 (enemy-flag trackable)))
            )
        )
      (set! (-> self enemy-flags) v1-17)
      (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
      (logclear! (-> self focus-status) (focus-status hit))
      )
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (seconds 0.01))
             (and (not (handle->process (-> self ragdoll-proc)))
                  (or (within-gspot-range? self)
                      (time-elapsed? (-> self state-time) (-> self enemy-info knocked-recover-timeout))
                      )
                  )
             )
        (go-die self)
        )
    )
  :code (behavior ()
    (local-vars (v1-58 symbol))
    (cond
      ((handle->process (-> self ragdoll-proc))
       (ja-channel-push! 1 0)
       (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim)) :num! (seek!) :frame-num 0.0)
       (enable-ragdoll! (-> (the-as ragdoll-proc (handle->process (-> self ragdoll-proc))) ragdoll) self)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      (else
        (ja-channel-push! 1 (seconds 0.2))
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim)) :num! (loop!) :frame-num 0.0)
        (until v1-58
          (suspend)
          (ja :num! (loop!))
          (set! v1-58 (and (logtest? (-> self root status) (collide-status on-surface))
                           (< (vector-length (-> self root transv)) 2048.0)
                           )
                )
          )
        )
      )
    (if (enemy-method-109 self)
        (go-die self)
        (go-hostile self)
        )
    )
  :post (behavior ()
    (when (not (handle->process (-> self ragdoll-proc)))
      (let ((gp-0 (-> self root)))
        (if (focus-test? self under-water)
            (accelerate-fall! self (-> gp-0 transv))
            (vector-v++!
              (-> gp-0 transv)
              (compute-acc-due-to-gravity gp-0 (new 'stack-no-clear 'vector) (-> self enemy-info slip-factor))
              )
            )
        (let ((a2-1 (new 'stack-no-clear 'collide-query)))
          (set! (-> a2-1 collide-with) (-> self enemy-info recover-gnd-collide-with))
          (set! (-> a2-1 ignore-process0) self)
          (set! (-> a2-1 ignore-process1) #f)
          (set! (-> a2-1 ignore-pat) (logior (new 'static 'pat-surface :noendlessfall #x1) (-> gp-0 pat-ignore-mask)))
          (set! (-> a2-1 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide gp-0 (-> gp-0 transv) a2-1 (meters 0))
          )
        )
      (apply-friction self)
      )
    (let ((gp-1 (-> self root))
          (a1-5 (new 'stack-no-clear 'collide-query))
          (s5-1 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-1 quad) (-> gp-1 gspot-pos quad))
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (set! (-> s4-1 quad) (-> gp-1 gspot-normal quad))
        (when (not (find-ground gp-1 a1-5 (-> self enemy-info gnd-collide-with) 8192.0 81920.0 1024.0 (the-as process #f)))
          (set! (-> gp-1 gspot-pos quad) (-> s5-1 quad))
          (set! (-> gp-1 gspot-normal quad) (-> s4-1 quad))
          )
        )
      )
    (enemy-simple-post)
    )
  )

;; WARN: Return type mismatch entity-perm-status vs none.
(defmethod mark-as-dead ((this enemy))
  (cond
    ((logtest? (process-mask enemy) (-> this mask))
     (+! (-> *game-info* enemies-killed) 1.0)
     )
    ((logtest? (process-mask guard civilian) (-> this mask))
     (+! (-> *game-info* civilians-killed) 1.0)
     )
    )
  (logior! (-> this focus-status) (focus-status dead))
  (process-entity-status! this (entity-perm-status subtask-complete) #t)
  (none)
  )

(defmethod on-dying ((this enemy))
  (when (not (logtest? (enemy-flag called-dying) (-> this enemy-flags)))
    (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag called-dying) (-> this enemy-flags))))
    (play-damage-sound this 1)
    (when (and (logtest? (enemy-flag has-gem) (-> this enemy-flags))
               (not (logtest? (enemy-flag spawn-gem) (-> this enemy-flags)))
               )
      (logior! (-> this enemy-flags) (enemy-flag spawn-gem))
      (remove-from-process *part-engine* this)
      (setup-masks
        (-> this draw)
        (the-as int (-> this enemy-info gem-no-seg))
        (the-as int (-> this enemy-info gem-seg))
        )
      (let* ((a0-11
               (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data (-> this enemy-info gem-joint)))
               )
             (s4-0 (ppointer->process (birth-pickup-at-point a0-11 (pickup-type gem) 1.0 #t *entity-pool* (-> this fact))))
             (s5-0 (if (type? s4-0 gem)
                       s4-0
                       )
                   )
             )
        (if s5-0
            (set! (-> (the-as gem s5-0) gem-pool) (the-as uint (get-gem-pool-idx this)))
            )
        )
      )
    (logclear! (-> this enemy-flags) (enemy-flag vulnerable vulnerable-backup))
    (logclear! (-> this focus-status) (focus-status dangerous))
    (logclear! (-> this enemy-flags) (enemy-flag dangerous-backup))
    (logclear! (-> this enemy-flags) (enemy-flag attackable attackable-backup))
    (logclear! (-> this mask) (process-mask actor-pause))
    (logclear! (-> this enemy-flags) (enemy-flag actor-pause-backup))
    (mark-as-dead this)
    (if (-> this skel effect)
        (logior! (-> this skel effect flags) (effect-control-flag ecf1))
        )
    (stop-look-at! this)
    )
  (none)
  )

(defstate die (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (on-dying self)
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set-time! (-> self state-time))
    (set! (-> self hit-points) 0.0)
    (ragdoll-spawn! self #f #t)
    )
  :code (behavior ()
    (cond
      ((handle->process (-> self ragdoll-proc))
       (let ((gp-0 (current-time)))
         (until (time-elapsed? gp-0 (seconds 0.2))
           (suspend)
           )
         )
       (if (-> self skel effect)
           (do-effect (-> self skel effect) "death-default" 0.0 -1)
           )
       (let ((gp-1 (current-time)))
         (until (time-elapsed? gp-1 (seconds 0.8))
           (suspend)
           )
         )
       )
      (else
        (ja-channel-push! 1 (seconds 0.075))
        (let ((f30-0 (rnd-float-range self 0.8 1.2)))
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info die-anim))
                      :num! (seek! max f30-0)
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      )
    (send-event self 'death-end)
    (let ((gp-2 (-> self child)))
      (while gp-2
        (send-event (ppointer->process gp-2) 'notice 'die)
        (set! gp-2 (-> gp-2 0 brother))
        )
      )
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post enemy-simple-post
  )

(defmethod falling? ((this enemy))
  (let ((s5-0 (-> this root))
        (a1-0 (new 'stack-no-clear 'collide-query))
        (gp-0 #t)
        )
    (when (find-ground
            s5-0
            a1-0
            (-> this enemy-info recover-gnd-collide-with)
            8192.0
            81920.0
            1024.0
            (the-as process #f)
            )
      (if (< (- (-> s5-0 trans y) (-> s5-0 gspot-pos y)) 8192.0)
          (set! gp-0 #f)
          )
      )
    gp-0
    )
  )

(defstate die-falling (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (on-dying self)
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self hit-points) 0.0)
    (if (logtest? (enemy-option knocked-into-water) (-> self fact enemy-options))
        (logior! (-> self enemy-flags) (enemy-flag check-water))
        )
    (ragdoll-spawn! self #f #t)
    )
  :exit (behavior ()
    (local-vars (v0-0 enemy-flag))
    (let ((v1-0 (-> self enemy-flags)))
      (if (logtest? (enemy-flag check-water-backup) v1-0)
          (set! v0-0 (logior (enemy-flag check-water) v1-0))
          (set! v0-0 (logclear v1-0 (enemy-flag check-water)))
          )
      )
    (set! (-> self enemy-flags) v0-0)
    )
  :code (behavior ()
    (cond
      ((handle->process (-> self ragdoll-proc))
       (let ((gp-0 (current-time)))
         (until (time-elapsed? gp-0 (seconds 1))
           (suspend)
           )
         )
       (if (-> self skel effect)
           (do-effect (-> self skel effect) "death-default" 0.0 -1)
           )
       (let ((gp-1 (current-time)))
         (until (time-elapsed? gp-1 (seconds 1))
           (suspend)
           )
         )
       (deactivate-ragdoll! self)
       )
      (else
        (ja-channel-push! 1 (seconds 0.1))
        (let ((gp-2 (-> self draw art-group data (if (falling? self)
                                                     (-> self enemy-info die-falling-anim)
                                                     (-> self enemy-info die-anim)
                                                     )
                        )
                    )
              (f30-0 (rnd-float-range self 0.8 1.2))
              )
          (ja-no-eval :group! gp-2 :num! (seek! max f30-0) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      )
    (send-event self 'death-end)
    (let ((gp-3 (-> self child)))
      (while gp-3
        (send-event (ppointer->process gp-3) 'notice 'die)
        (set! gp-3 (-> gp-3 0 brother))
        )
      )
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post enemy-die-falling-post
  )

(defstate directed (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag directed-ready))
    ((-> (method-of-type enemy idle) enter))
    )
  :exit (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag directed-ready))
    )
  :code (-> (method-of-type enemy idle) code)
  :post (-> (method-of-type enemy idle) post)
  )

(defstate die-fast (enemy)
  :virtual #t
  :code nothing
  )

(defstate view-anims (enemy)
  :virtual #t
  :enter (behavior ()
    '()
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (let ((gp-0 (-> self draw art-group)))
      (until #f
        (dotimes (s5-0 (-> gp-0 length))
          (let ((s4-0 (-> gp-0 data s5-0)))
            (when (and s4-0 (= (-> s4-0 type) art-joint-anim))
              (ja-channel-set! 1)
              (ja-no-eval :group! s4-0 :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              )
            )
          )
        )
      )
    #f
    )
  :post transform-post
  )

;; WARN: Return type mismatch symbol vs object.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior gun-dark-2-anim-code enemy ()
  0.0
  (let ((f28-0 (the float (ja-num-frames 0))))
    0.0
    0.0
    (let ((f30-0 1.0))
      0.0
      (let* ((f26-0 (/ (ja-frame-num 0) f28-0))
             (f0-12 (cond
                      ((< 0.5 f26-0)
                       (let* ((f24-0 0.3)
                              (v1-4 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                              (v1-5 (the-as number (logior #x3f800000 v1-4)))
                              )
                         (- f26-0 (+ f24-0 (* (+ -1.0 (the-as float v1-5)) (+ -0.3 f26-0))))
                         )
                       )
                      (else
                        (let* ((f24-1 0.3)
                               (v1-11 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                               (v1-12 (the-as number (logior #x3f800000 v1-11)))
                               )
                          (+ f24-1 (* (+ -1.0 (the-as float v1-12)) (- 0.7 f26-0)) f26-0)
                          )
                        )
                      )
                    )
             (f26-1 (fmax 0.0 (fmin 1.0 f0-12)))
             (f28-1 (* f28-0 f26-1))
             )
        (let* ((f1-8 (* 0.000061035156 (-> self root root-prim local-sphere w)))
               (f0-21 (fmax 0.0 (fmin 1.0 f1-8)))
               )
          (* f30-0 (lerp 2.0 1.0 f0-21))
          )
        (cond
          ((>= (-> self enemy-info idle-anim) 0)
           (let ((s5-0 (ja-group))
                 (f30-1 (ja-frame-num 0))
                 (gp-0 (-> self draw art-group data (-> self enemy-info idle-anim)))
                 )
             (ja-channel-push! 2 (seconds 1))
             (ja :group! s5-0 :num! (identity f30-1))
             (ja :chan 1
                 :group! gp-0
                 :num! (identity (* f26-1 (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1))))
                 )
             )
           (let* ((gp-1 (current-time))
                  (f30-2 18.0)
                  (f28-2 6.0)
                  (v1-45 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                  (v1-46 (the-as number (logior #x3f800000 v1-45)))
                  (f30-3 (+ f30-2 (* f28-2 (+ -1.0 (the-as float v1-46)))))
                  )
             (until #f
               (let* ((f0-32 (* 0.0033333334 (the float (- (current-time) gp-1))))
                      (f0-34 (/ (- f0-32 (* (the float (the int (/ f0-32 f30-3))) f30-3)) f30-3))
                      (f0-36 (cos (* 65536.0 f0-34)))
                      (f0-37 (+ 1.0 f0-36))
                      (f28-3 (* 0.5 f0-37))
                      )
                 (ja :num! identity :frame-interp0 f28-3 :frame-interp1 f28-3)
                 (let ((a0-20 (-> self skel root-channel 1)))
                   (let ((f0-39 (- 1.0 f28-3)))
                     (set! (-> a0-20 frame-interp 1) f0-39)
                     (set! (-> a0-20 frame-interp 0) f0-39)
                     )
                   (joint-control-channel-group-eval! a0-20 (the-as art-joint-anim #f) num-func-identity)
                   )
                 )
               (suspend)
               0
               )
             )
           #f
           )
          (else
            (until (time-elapsed? (-> self state-time) (seconds 2))
              (let* ((f1-22 (* 0.0016666667 (the float (- (current-time) (-> self state-time)))))
                     (f0-42 (fmax 0.0 (fmin 1.0 f1-22)))
                     )
                (ja :num! (seek! f28-1 (lerp 0.2 0.01 f0-42)))
                )
              (suspend)
              0
              )
            )
          )
        )
      )
    )
  (sleep-code)
  )

(defun gun-dark-2-ragdoll-start ((arg0 enemy))
  (local-vars (s4-0 process))
  (when (-> arg0 enemy-info ragdoll-info)
    (let ((s5-0 (handle->process (-> arg0 ragdoll-proc))))
      (cond
        (s5-0
          (set! s4-0 s5-0)
          )
        (else
          (set! (-> arg0 ragdoll-proc)
                (ppointer->handle
                  (process-spawn
                    ragdoll-proc
                    (-> arg0 enemy-info ragdoll-info)
                    :name "ragdoll-proc"
                    :to arg0
                    :stack-size #x5000
                    )
                  )
                )
          (set! s4-0 (handle->process (-> arg0 ragdoll-proc)))
          (if (not s4-0)
              (return 0)
              )
          (set! (-> arg0 enemy-flags)
                (the-as enemy-flag (logior (enemy-flag auto-death-phase-out) (-> arg0 enemy-flags)))
                )
          )
        )
      (if (-> (the-as ragdoll-proc s4-0) ragdoll)
          (logior! (-> (the-as ragdoll-proc s4-0) ragdoll ragdoll-flags) (ragdoll-flag rf3 rf4))
          )
      (let ((s3-0 (new 'stack-no-clear 'vector)))
        (vector-float*! s3-0 (-> arg0 root transv) (seconds-per-frame))
        (if s5-0
            (ragdoll-proc-method-15 (the-as ragdoll-proc s4-0) #f (the-as vector #f) #f)
            (ragdoll-proc-method-15 (the-as ragdoll-proc s4-0) #f (the-as vector #f) #t)
            )
        (let ((v0-0 (the-as object (-> (the-as ragdoll-proc s4-0) ragdoll ragdoll-joints 0 velocity))))
          (set! (-> (the-as vector v0-0) quad) (-> s3-0 quad))
          v0-0
          )
        )
      )
    )
  )

(defstate gun-dark-2-stretch (enemy)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-4 object) (sv-112 event-message-block) (sv-128 event-message-block))
    (case message
      (('attack)
       (let* ((s5-0 (the-as object (-> block param 1)))
              (s4-0 (new 'stack-no-clear 'vector))
              (v1-1 (-> (the-as attack-info s5-0) mode))
              )
         (set! v0-4 (cond
                      ((= v1-1 'gravity-end)
                       (set! (-> self root transv quad) (the-as uint128 0))
                       (gun-dark-2-ragdoll-start self)
                       (let* ((s4-1 self)
                              (s1-0 (method-of-object s4-1 get-incoming-attack!))
                              (s0-0 proc)
                              )
                         (set! sv-112 block)
                         (let ((a3-1 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block))
                               (t1-0 #f)
                               )
                           (s1-0
                             s4-1
                             (the-as process-drawable s0-0)
                             sv-112
                             a3-1
                             (the-as attack-info s5-0)
                             (the-as touching-shapes-entry t1-0)
                             )
                           )
                         )
                       (damage-enemy! self proc block)
                       (set! (-> self incoming penetrate-using) (penetrate vehicle))
                       (set! (-> self incoming knocked-type) (knocked-type vehicle))
                       (set! (-> self incoming attack-direction quad) (the-as uint128 0))
                       (set! (-> self starting-time) 0)
                       (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
                         (set! (-> a1-4 from) (process->ppointer proc))
                         (set! (-> a1-4 num-params) argc)
                         (set! (-> a1-4 message) 'hit-knocked)
                         (set! (-> a1-4 param 0) (-> block param 0))
                         (set! (-> a1-4 param 1) (-> block param 1))
                         (set! (-> a1-4 param 2) (-> block param 2))
                         (set! (-> a1-4 param 3) (-> block param 3))
                         (set! (-> a1-4 param 4) (-> block param 4))
                         (set! (-> a1-4 param 5) (-> block param 5))
                         (send-event-function self a1-4)
                         )
                       )
                      (else
                        (when (!= (-> (the-as attack-info s5-0) id) (-> self incoming attack-id))
                          (let* ((s2-1 self)
                                 (s1-1 (method-of-object s2-1 get-incoming-attack!))
                                 (s0-1 proc)
                                 )
                            (set! sv-128 block)
                            (let ((a3-2 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block))
                                  (t0-1 (the-as uint s5-0))
                                  (t1-1 (-> block param 0))
                                  )
                              (s1-1
                                s2-1
                                (the-as process-drawable s0-1)
                                sv-128
                                a3-2
                                (the-as attack-info t0-1)
                                (the-as touching-shapes-entry t1-1)
                                )
                              )
                            )
                          (knocked-handler self s4-0)
                          (let ((gp-1 (-> self child)))
                            (while gp-1
                              (when (send-event (-> gp-1 0) 'is-gravity)
                                (send-event
                                  (-> gp-1 0)
                                  'attack-forward
                                  (-> self incoming attack-direction)
                                  (-> self incoming attack-position)
                                  (the-as uint s5-0)
                                  (-> self incoming penetrate-using)
                                  s4-0
                                  (-> self incoming attack-position)
                                  )
                                (set! v0-4 0)
                                (goto cfg-17)
                                )
                              (set! gp-1 (-> gp-1 0 brother))
                              )
                            )
                          #f
                          )
                        )
                      )
               )
         )
       (label cfg-17)
       v0-4
       )
      (else
        (if (zero? (-> self starting-time))
            (enemy-event-handler proc argc message block)
            )
        )
      )
    )
  :enter (behavior ()
    (local-vars (v1-7 enemy-flag) (v1-9 enemy-flag) (v1-11 enemy-flag) (v1-34 enemy-flag))
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-6 (-> self enemy-flags)))
      (if (logtest? v1-6 (enemy-flag vulnerable-backup))
          (set! v1-7 (logior v1-6 (enemy-flag vulnerable)))
          (set! v1-7 (logclear v1-6 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-7)
    (let ((v1-8 (-> self enemy-flags)))
      (if (logtest? v1-8 (enemy-flag attackable-backup))
          (set! v1-9 (logior v1-8 (enemy-flag attackable)))
          (set! v1-9 (logclear v1-8 (enemy-flag attackable)))
          )
      )
    (set! (-> self enemy-flags) v1-9)
    (let ((v1-10 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-10)
          (set! v1-11 (logior (enemy-flag trackable) v1-10))
          (set! v1-11 (logclear v1-10 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-11)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self focus-status) (focus-status hit))
    (vector-float*! (-> self root transv) (-> self root transv) 0.5)
    (set! (-> self root penetrated-by) (penetrate))
    (+! (-> self root transv y) 2048.0)
    (set-time! (-> self state-time))
    (set! (-> self root penetrated-by) (logior (get-penetrated-by self) (penetrate vehicle)))
    (set-time! (-> self starting-time))
    (set! (-> self focus-status) (the-as focus-status (logior (focus-status no-gravity) (-> self focus-status))))
    (let ((v1-33 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-33)
          (set! v1-34 (logior (enemy-flag trackable) v1-33))
          (set! v1-34 (logclear v1-33 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-34)
    (stop-look-at! self)
    (when (and (-> self draw) (-> self draw shadow-ctrl))
      (let ((v1-41 (-> self draw shadow-ctrl)))
        (logior! (-> v1-41 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  :exit (behavior ()
    (set! (-> self focus-status)
          (the-as focus-status (logclear (-> self focus-status) (focus-status no-gravity)))
          )
    (when (and (-> self draw) (-> self draw shadow-ctrl))
      (let ((v1-6 (-> self draw shadow-ctrl)))
        (logclear! (-> v1-6 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  :trans (behavior ()
    (let ((gp-0 (-> self child)))
      (while gp-0
        (when (send-event (-> gp-0 0) 'is-gravity)
          (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-1 from) (process->ppointer self))
            (set! (-> a1-1 num-params) 0)
            (set! (-> a1-1 message) 'get-float-speed)
            (let ((f0-0 (the-as float (send-event-function (-> gp-0 0) a1-1))))
              (+! (-> self root transv y) (* f0-0 (seconds-per-frame)))
              )
            )
          0
          (goto cfg-11)
          )
        (set! gp-0 (-> gp-0 0 brother))
        )
      )
    (label cfg-11)
    (vector-float*! (-> self root transv) (-> self root transv) (- 1.0 (* 0.5 (seconds-per-frame))))
    (let ((s3-0 (new 'stack 'collide-query))
          (gp-2 (vector-float*! (new 'stack-no-clear 'vector) (-> self root transv) (seconds-per-frame)))
          )
      (set! (-> s3-0 start-pos quad) (-> (get-trans self 3) quad))
      (set! (-> s3-0 move-dist quad) (-> gp-2 quad))
      (let ((v1-26 s3-0))
        (set! (-> v1-26 radius) (* 0.7 (-> self root root-prim prim-core world-sphere w)))
        (set! (-> v1-26 collide-with)
              (collide-spec backgnd civilian enemy obstacle hit-by-others-list pusher vehicle-mesh)
              )
        (set! (-> v1-26 ignore-process0) self)
        (set! (-> v1-26 ignore-process1) #f)
        (set! (-> v1-26 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> v1-26 action-mask) (collide-action solid))
        )
      (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* s3-0)))
        (set! f30-0
              (cond
                ((>= f30-0 0.0)
                 (vector-float*! gp-2 gp-2 f30-0)
                 (let ((s5-1 (new 'stack-no-clear 'vector))
                       (s4-0 (new 'stack-no-clear 'vector))
                       (v1-31 (-> s3-0 best-other-tri))
                       (f28-0 0.9)
                       )
                   (set! (-> s5-1 quad) (-> v1-31 normal quad))
                   (set! (-> s4-0 quad) (-> v1-31 intersect quad))
                   (let ((v1-32 (and (-> v1-31 collide-ptr) (let ((s2-0 (-> v1-31 collide-ptr)))
                                                              (if (type? s2-0 collide-shape-prim-sphere)
                                                                  s2-0
                                                                  )
                                                              )
                                     )
                                )
                         )
                     (when v1-32
                       (let ((s2-1 (-> (the-as collide-shape-prim-sphere v1-32) cshape process)))
                         (let ((s1-0 (new 'stack-no-clear 'vector)))
                           (set! (-> s1-0 quad) (-> self root transv quad))
                           (let* ((s0-0 s2-1)
                                  (v1-37 (if (type? s0-0 process-focusable)
                                             s0-0
                                             )
                                         )
                                  )
                             (when v1-37
                               (when (focus-test? (the-as process-focusable v1-37) no-gravity)
                                 (vector-float*! s1-0 s1-0 0.5)
                                 (set! f28-0 0.5)
                                 )
                               )
                             )
                           )
                         (let ((f1-6 (fmax 0.0 (fmin 1.0 (* 0.000008138021 (vector-length (-> self root transv))))))
                               (f0-12 0.0)
                               )
                           (if (< 0.1 f1-6)
                               (set! f0-12 (lerp 3.0 12.0 f1-6))
                               )
                           (send-event
                             s2-1
                             'attack
                             #f
                             (static-attack-info :mask (vehicle-impulse-factor) ((id (-> self attack-id))
                                                                                 (damage f0-12)
                                                                                 (vehicle-damage-factor 1.0)
                                                                                 (vehicle-impulse-factor 1.0)
                                                                                 (penetrate-using (penetrate vehicle))
                                                                                 (vector (-> self root transv))
                                                                                 (attacker-velocity (-> self root transv))
                                                                                 (intersection s4-0)
                                                                                 )
                                                 )
                             )
                           )
                         )
                       )
                     )
                   (let ((s2-3 (vector-! (new 'stack-no-clear 'vector) (-> s3-0 start-pos) s4-0)))
                     0.0
                     (let* ((f0-16 (vector-normalize-ret-len! s2-3 1.0))
                            (f0-18 (* 1.3 (- (* 0.7 (-> self root root-prim prim-core world-sphere w)) f0-16)))
                            )
                       (vector-normalize! s2-3 f0-18)
                       )
                     (vector+! (-> self root trans) (-> self root trans) s2-3)
                     )
                   (let ((f26-0 (vector-dot (-> self root transv) s5-1)))
                     (vector+float*! (-> self root transv) (-> self root transv) s5-1 (* -2.0 f26-0))
                     (vector-float*! (-> self root transv) (-> self root transv) f28-0)
                     (let ((s3-1 (-> self child)))
                       (while s3-1
                         (when (send-event (-> s3-1 0) 'is-gravity)
                           (send-event (-> s3-1 0) 'impact s4-0 (vector-float*! (new 'stack-no-clear 'vector) s5-1 (- f26-0)))
                           0
                           (goto cfg-38)
                           )
                         (set! s3-1 (-> s3-1 0 brother))
                         )
                       )
                     )
                   )
                 (label cfg-38)
                 f30-0
                 )
                (else
                  1.0
                  )
                )
              )
        (vector+! (-> self root trans) (-> self root trans) gp-2)
        (if (< f30-0 1.0)
            (vector+float*! (-> self root trans) (-> self root trans) (-> self root transv) (* f30-0 (seconds-per-frame)))
            )
        )
      )
    )
  :code (behavior ()
    (gun-dark-2-anim-code)
    )
  :post (behavior ()
    (let ((gp-0 (-> self skel status)))
      (logior! (-> self skel status) (joint-control-status sync-math))
      (ja-post)
      (update-transforms (-> self root))
      (set! (-> self skel status) gp-0)
      )
    (let ((gp-1 (-> self child)))
      (while gp-1
        (when (send-event (-> gp-1 0) 'is-gravity)
          (send-event (-> gp-1 0) 'update-rotation)
          (return 0)
          )
        (set! gp-1 (-> gp-1 0 brother))
        )
      )
    )
  )
