;;-*-Lisp-*-
(in-package goal)

;; name: vent.gc
;; name in dgo: vent
;; dgos: GAME

;; DECOMP BEGINS

(deftype vent (process-drawable)
  ((root                 collide-shape :override)
   (show-particles       symbol)
   (collect-effect       sparticle-launch-group)
   (collect-effect2      sparticle-launch-group)
   (collect-effect-time  time-frame)
   (blocker              entity-actor)
   (block-func           (function vent symbol))
   (pickup-handle        handle)
   )
  (:methods
    (init! (_type_ entity-actor pickup-type) object)
    )
  (:states
    vent-blocked
    (vent-pickup handle)
    vent-wait-for-touch
    )
  )


(defmethod init! ((this vent) (arg0 entity-actor) (arg1 pickup-type))
  (stack-size-set! (-> this main-thread) 128)
  (logior! (-> this mask) (process-mask actor-pause))
  (let ((s3-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s3-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-6 local-sphere) 0.0 10240.0 0.0 12288.0)
      (set! (-> s3-0 total-prims) (the-as uint 1))
      (set! (-> s3-0 root-prim) v1-6)
      )
    (set! (-> s3-0 nav-radius) (* 0.75 (-> s3-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s3-0 root-prim)))
      (set! (-> s3-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s3-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s3-0)
    )
  (set! (-> this root trans quad) (-> arg0 extra trans quad))
  (update-transforms (-> this root))
  (set! (-> this root pause-adjust-distance) 409600.0)
  (set! (-> this fact) (new 'process 'fact-info this arg1 (-> *FACT-bank* eco-full-inc)))
  (set! (-> this block-func) (the-as (function vent symbol) true-func))
  (case (-> this fact pickup-type)
    (((pickup-type eco-blue))
     (set! (-> this part) (create-launch-control (-> *part-group-id-table* 156) this))
     (set! (-> this collect-effect) (-> *part-group-id-table* 169))
     (set! (-> this collect-effect2) (-> *part-group-id-table* 155))
     (set! (-> this sound) (new 'process 'ambient-sound "eco-bg-blue" (-> this root trans) 0.0))
     )
    (((pickup-type eco-red))
     (set! (-> this part) (create-launch-control (-> *part-group-id-table* 160) this))
     (set! (-> this collect-effect) (-> *part-group-id-table* 171))
     (set! (-> this collect-effect2) (-> *part-group-id-table* 159))
     (set! (-> this sound) (new 'process 'ambient-sound "eco-bg-red" (-> this root trans) 0.0))
     )
    (((pickup-type eco-green) (pickup-type health))
     (set! (-> this part) (create-launch-control (-> *part-group-id-table* 148) this))
     (set! (-> this collect-effect) (-> *part-group-id-table* 141))
     (set! (-> this collect-effect2) (-> *part-group-id-table* 124))
     (case (-> this fact pickup-type)
       (((pickup-type eco-green))
        (set! (-> this sound) (new 'process 'ambient-sound "eco-loop" (-> this root trans) 0.0))
        )
       (else
         (set! (-> this sound) (new 'process 'ambient-sound "eco-bg-green" (-> this root trans) 0.0))
         )
       )
     )
    (((pickup-type eco-yellow))
     (set! (-> this part) (create-launch-control (-> *part-group-id-table* 162) this))
     (set! (-> this collect-effect) (-> *part-group-id-table* 170))
     (set! (-> this collect-effect2) (-> *part-group-id-table* 165))
     (set! (-> this sound) (new 'process 'ambient-sound "eco-bg-yellow" (-> this root trans) 0.0))
     )
    )
  (set! (-> this blocker) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (when (-> this blocker)
    (logior! (-> this fact options) (actor-option blocked))
    (set! (-> this block-func)
          (lambda ((arg0 vent))
            (not (logtest? (-> arg0 blocker extra perm status) (entity-perm-status subtask-complete)))
            )
          )
    )
  (set! (-> this show-particles) #t)
  (when (logtest? (-> this fact options) (actor-option blocked))
    (when (logtest? (-> this fact options) (actor-option draw-blocker))
      (case (-> this fact pickup-type)
        (((pickup-type eco-blue))
         (set! (-> this block-func)
               (lambda ((arg0 vent)) (not (task-complete? *game-info* (game-task eco-blue-button))))
               )
         )
        (((pickup-type eco-red))
         (set! (-> this block-func)
               (lambda ((arg0 vent)) (not (task-complete? *game-info* (game-task eco-red-button))))
               )
         )
        (((pickup-type eco-yellow))
         (set! (-> this block-func)
               (lambda ((arg0 vent)) (not (task-complete? *game-info* (game-task eco-yellow-button))))
               )
         )
        )
      )
    (if ((-> this block-func) this)
        (go vent-blocked)
        )
    )
  (go vent-wait-for-touch)
  )

(defbehavior vent-standard-event-handler vent ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('show-particles)
     (let ((v0-0 (the-as object (-> arg3 param 0))))
       (set! (-> self show-particles) (the-as symbol v0-0))
       v0-0
       )
     )
    (('hide)
     (set! (-> self block-func) (the-as (function vent symbol) true-func))
     (go vent-blocked)
     )
    )
  )

(defstate vent-wait-for-touch (vent)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (if (and (or (= message 'touch) (= message 'attack))
             (or (!= (-> self fact pickup-type) 5)
                 (and *target*
                      (logtest? (the-as game-feature (logand (game-feature board-trail) (-> *setting-control* user-current features)))
                                (-> *target* game features)
                                )
                      (-> *setting-control* user-current board-trail)
                      (focus-test? *target* board)
                      )
                 )
             (= (send-event proc 'get-pickup (-> self fact pickup-type) (-> self fact pickup-amount)) #t)
             )
        (go vent-pickup (process->handle proc))
        )
    (vent-standard-event-handler proc argc message block)
    )
  :code (behavior ()
    (until #f
      (let ((a0-0 (-> self part))
            (a1-0 (-> self root trans))
            (gp-0 (-> self sound))
            )
        (if (and (nonzero? a0-0) (-> self show-particles))
            (spawn a0-0 a1-0)
            )
        (if (nonzero? gp-0)
            (update! gp-0)
            )
        )
      (suspend)
      )
    #f
    )
  )

(defstate vent-blocked (vent)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('show)
       (go vent-wait-for-touch)
       )
      )
    )
  :code (behavior ()
    (until #f
      (if (not ((-> self block-func) self))
          (go vent-wait-for-touch)
          )
      (suspend)
      )
    #f
    )
  )

(defstate vent-pickup (vent)
  :event vent-standard-event-handler
  :code (behavior ((arg0 handle))
    (when (-> self show-particles)
      (when (nonzero? (-> self collect-effect))
        (when (time-elapsed? (-> self collect-effect-time) (seconds 1))
          (let* ((s5-0 (handle->process arg0))
                 (gp-0 (if (type? s5-0 process-drawable)
                           s5-0
                           )
                       )
                 )
            (when gp-0
              (let* ((s5-1 (-> (the-as process-focusable gp-0) root))
                     (v1-9 (if (type? s5-1 collide-shape)
                               s5-1
                               )
                           )
                     )
                (when v1-9
                  (cond
                    ((logtest? (-> self collect-effect flags) (sp-group-flag sp13))
                     (set! (-> *launch-matrix* trans quad) (-> v1-9 root-prim prim-core world-sphere quad))
                     (part-tracker-spawn
                       part-tracker-subsampler
                       :to gp-0
                       :group (-> self collect-effect)
                       :callback part-tracker-track-target
                       )
                     )
                    (else
                      (set! (-> *launch-matrix* trans quad) (-> v1-9 root-prim prim-core world-sphere quad))
                      (part-tracker-spawn part-tracker :to gp-0 :group (-> self collect-effect) :callback part-tracker-track-target)
                      )
                    )
                  (cond
                    ((logtest? (-> self collect-effect2 flags) (sp-group-flag sp13))
                     (set! (-> *launch-matrix* trans quad) (-> self root root-prim prim-core world-sphere quad))
                     (part-tracker-spawn
                       part-tracker-subsampler
                       :to self
                       :group (-> self collect-effect2)
                       :callback part-tracker-move-to-target
                       )
                     )
                    (else
                      (set! (-> *launch-matrix* trans quad) (-> self root root-prim prim-core world-sphere quad))
                      (part-tracker-spawn
                        part-tracker
                        :to self
                        :group (-> self collect-effect2)
                        :callback part-tracker-move-to-target
                        )
                      )
                    )
                  (set-time! (-> self collect-effect-time))
                  )
                )
              )
            )
          )
        )
      )
    (go vent-wait-for-touch)
    )
  )

(deftype ecovent (vent)
  ()
  )


(defmethod init-from-entity! ((this ecovent) (arg0 entity-actor))
  (init! this arg0 (pickup-type eco-green))
  )

(deftype light-eco-vent (process-drawable)
  ((part2        sparticle-launch-control)
   (pickup-time  time-frame)
   (touch-time   time-frame)
   )
  (:state-methods
    (open symbol)
    (close symbol)
    )
  )


;; WARN: Return type mismatch process-drawable vs light-eco-vent.
(defmethod relocate ((this light-eco-vent) (offset int))
  (if (nonzero? (-> this part2))
      (&+! (-> this part2) offset)
      )
  (the-as light-eco-vent ((method-of-type process-drawable relocate) this offset))
  )

(defmethod deactivate ((this light-eco-vent))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part2))
      (kill-particles (-> this part2))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defskelgroup skel-light-eco-vent light-eco-vent light-eco-vent-lod0-jg light-eco-vent-close-open-ja
              ((light-eco-vent-lod0-mg (meters 20))
               (light-eco-vent-lod1-mg (meters 40))
               (light-eco-vent-lod2-mg (meters 999999))
               )
              :bounds (static-spherem 0 0 0 4)
              )

(defstate open (light-eco-vent)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (and (or (= message 'touch) (= message 'attack))
               (and ((method-of-type touching-shapes-entry prims-touching?)
                     (the-as touching-shapes-entry (-> block param 0))
                     (the-as collide-shape (-> self root))
                     (the-as uint 2)
                     )
                    ((method-of-type touching-shapes-entry prims-touching-action?)
                     (the-as touching-shapes-entry (-> block param 0))
                     (the-as collide-shape (-> (the-as process-drawable proc) root))
                     (collide-action solid)
                     (collide-action)
                     )
                    (begin
                      (if (time-elapsed? (-> self touch-time) (seconds 0.1))
                          (sound-play "light-charge")
                          )
                      (set-time! (-> self touch-time))
                      (time-elapsed? (-> self pickup-time) (seconds 0.015))
                      )
                    (= (send-event proc 'get-pickup (-> self fact pickup-type) 100.0) #t)
                    )
               )
      (if (and (time-elapsed? (-> self pickup-time) (seconds 0.1))
               (not (logtest? (-> self fact options) (actor-option no-reaction)))
               )
          (send-event proc 'powerup)
          )
      (set-time! (-> self pickup-time))
      #f
      )
    )
  :trans (behavior ()
    (if (not (logtest? (the-as game-feature (logand (game-feature lighteco) (-> *setting-control* user-current features)))
                       (-> *game-info* features)
                       )
             )
        (go-virtual close #f)
        )
    )
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (while (not (ja-max? 0))
        (ja :num! (seek!))
        (transform-post)
        (suspend)
        )
      )
    (ja :num-func num-func-identity :frame-num max)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  :post (behavior ()
    (let ((a0-0 (-> self part))
          (v1-0 (-> self part2))
          (a1-1 (-> self root trans))
          (gp-0 (-> self sound))
          )
      (cond
        ((time-elapsed? (-> self touch-time) (seconds 0.1))
         (if (nonzero? a0-0)
             (spawn a0-0 a1-1)
             )
         )
        (else
          (if (nonzero? v1-0)
              (spawn v1-0 a1-1)
              )
          )
        )
      (if (nonzero? gp-0)
          (update! gp-0)
          )
      )
    )
  )

(defstate close (light-eco-vent)
  :virtual #t
  :trans (behavior ()
    (if (logtest? (the-as game-feature (logand (game-feature lighteco) (-> *setting-control* user-current features)))
                  (-> *game-info* features)
                  )
        (go-virtual open #f)
        )
    )
  :code (behavior ((arg0 symbol))
    (stop! (-> self sound))
    (when (not arg0)
      (while (not (ja-min? 0))
        (ja :num! (seek! 0.0))
        (transform-post)
        (suspend)
        )
      )
    (ja :num-func num-func-identity :frame-num 0.0)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defmethod init-from-entity! ((this light-eco-vent) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec collectable))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> s3-0 local-sphere) 0.0 4096.0 0.0 12288.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 3)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 6144.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 6144.0 0.0 2457.6)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 10240.0 0.0 2457.6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-light) (-> *FACT-bank* eco-full-inc))
        )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-light-eco-vent" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 144) this))
  (set! (-> this part2) (create-launch-control (-> *part-group-id-table* 145) this))
  (set! (-> this sound) (new 'process 'ambient-sound "eco-bg-light" (-> this root trans) 0.0))
  (set-falloff-far! (-> this sound) 81920.0)
  (set-falloff-mode! (-> this sound) 9)
  (if (logtest? (the-as game-feature (logand (game-feature lighteco) (-> *setting-control* user-current features)))
                (-> *game-info* features)
                )
      (go (method-of-object this open) #t)
      (go (method-of-object this close) #t)
      )
  )

(deftype dark-eco-vent (process-drawable)
  ((part2        sparticle-launch-control)
   (pickup-time  time-frame)
   (touch-time   time-frame)
   )
  (:state-methods
    (open symbol)
    (close symbol)
    )
  )


;; WARN: Return type mismatch process-drawable vs dark-eco-vent.
(defmethod relocate ((this dark-eco-vent) (offset int))
  (if (nonzero? (-> this part2))
      (&+! (-> this part2) offset)
      )
  (the-as dark-eco-vent ((method-of-type process-drawable relocate) this offset))
  )

(defmethod deactivate ((this dark-eco-vent))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part2))
      (kill-particles (-> this part2))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defskelgroup skel-dark-eco-vent dark-eco-vent dark-eco-vent-lod0-jg dark-eco-vent-close-open-ja
              ((dark-eco-vent-lod0-mg (meters 20))
               (dark-eco-vent-lod1-mg (meters 40))
               (dark-eco-vent-lod2-mg (meters 999999))
               )
              :bounds (static-spherem 0 0 0 4)
              )

(defstate open (dark-eco-vent)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (and (or (= message 'touch) (= message 'attack))
               (and ((method-of-type touching-shapes-entry prims-touching?)
                     (the-as touching-shapes-entry (-> block param 0))
                     (the-as collide-shape (-> self root))
                     (the-as uint 2)
                     )
                    ((method-of-type touching-shapes-entry prims-touching-action?)
                     (the-as touching-shapes-entry (-> block param 0))
                     (the-as collide-shape (-> (the-as process-drawable proc) root))
                     (collide-action solid)
                     (collide-action)
                     )
                    (begin
                      (if (time-elapsed? (-> self touch-time) (seconds 0.1))
                          (sound-play "dark-charge")
                          )
                      (set-time! (-> self touch-time))
                      (time-elapsed? (-> self pickup-time) (seconds 0.015))
                      )
                    (= (send-event proc 'get-pickup (-> self fact pickup-type) 100.0) #t)
                    )
               )
      (if (and (time-elapsed? (-> self pickup-time) (seconds 0.1))
               (not (logtest? (-> self fact options) (actor-option no-reaction)))
               )
          (send-event proc 'powerup)
          )
      (set-time! (-> self pickup-time))
      #f
      )
    )
  :trans (behavior ()
    (if (not (logtest? (the-as game-feature (logand (game-feature darkeco) (-> *setting-control* user-current features)))
                       (-> *game-info* features)
                       )
             )
        (go-virtual close #f)
        )
    )
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (while (not (ja-max? 0))
        (ja :num! (seek!))
        (transform-post)
        (suspend)
        )
      )
    (ja :num-func num-func-identity :frame-num max)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  :post (behavior ()
    (let ((a0-0 (-> self part))
          (v1-0 (-> self part2))
          (a1-1 (-> self root trans))
          (gp-0 (-> self sound))
          )
      (cond
        ((time-elapsed? (-> self touch-time) (seconds 0.1))
         (if (nonzero? a0-0)
             (spawn a0-0 a1-1)
             )
         )
        (else
          (if (nonzero? v1-0)
              (spawn v1-0 a1-1)
              )
          )
        )
      (if (nonzero? gp-0)
          (update! gp-0)
          )
      )
    )
  )

(defstate close (dark-eco-vent)
  :virtual #t
  :trans (behavior ()
    (if (logtest? (the-as game-feature (logand (game-feature darkeco) (-> *setting-control* user-current features)))
                  (-> *game-info* features)
                  )
        (go-virtual open #f)
        )
    )
  :code (behavior ((arg0 symbol))
    (stop! (-> self sound))
    (when (not arg0)
      (while (not (ja-min? 0))
        (ja :num! (seek! 0.0))
        (transform-post)
        (suspend)
        )
      )
    (if (nonzero? (-> self part))
        (kill-particles (-> self part))
        )
    (ja :num-func num-func-identity :frame-num 0.0)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defmethod init-from-entity! ((this dark-eco-vent) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec collectable))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> s3-0 local-sphere) 0.0 4096.0 0.0 12288.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 3)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 6144.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 6144.0 0.0 2457.6)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 2))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 10240.0 0.0 2457.6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this fact) (new 'process 'fact-info this (pickup-type eco-pill-dark) (-> *FACT-bank* eco-full-inc)))
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dark-eco-vent" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 146) this))
  (set! (-> this part2) (create-launch-control (-> *part-group-id-table* 147) this))
  (set! (-> this sound) (new 'process 'ambient-sound "eco-bg-dark" (-> this root trans) 0.0))
  (set-falloff-far! (-> this sound) 81920.0)
  (set-falloff-mode! (-> this sound) 9)
  (go (method-of-object this open) #t)
  )
