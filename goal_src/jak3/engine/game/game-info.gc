;;-*-Lisp-*-
(in-package goal)

;; name: game-info.gc
;; name in dgo: game-info
;; dgos: GAME

(define-extern stop (function symbol int))
(define-extern start (function symbol continue-point target))
(define-extern menu-secrets-notify-powerup-collect (function int))
(define-extern lightning-probe-callback (function lightning-tracker none))
(define-extern process-drawable-shock-effect (function process-drawable lightning-spec (function lightning-tracker none) sparticle-launcher int int float object))
(define-extern *lightning-darkjak-pill* lightning-spec)
(define-extern ready-hud (function symbol int none))
(define-extern override-player-controls (function cpad-info int))
(define-extern *highscore-info-array* (array highscore-info))
(define-extern *user* symbol)

;; DECOMP BEGINS

(defmethod debug-draw ((this border-plane))
  (let* ((v1-0 (-> this action))
         (s1-0 (if (= v1-0 'load)
                   (the-as uint #x8000ff00)
                   (the-as uint #x800000ff)
                   )
               )
         )
    (add-debug-text-sphere
      #t
      (bucket-id debug-no-zbuf1)
      (-> this trans)
      (meters 0.2)
      (symbol->string-debug (-> this name))
      (the-as rgba s1-0)
      )
    (add-debug-vector
      #t
      (bucket-id debug-no-zbuf1)
      (-> this trans)
      (-> this normal)
      (meters 2)
      (the-as rgba s1-0)
      )
    )
  0
  )

(defmethod point-past-plane? ((this border-plane) (arg0 vector))
  (>= (vector-dot (vector-! (new 'stack-no-clear 'vector) arg0 (-> this trans)) (-> this normal)) 0.0)
  )

(defmethod task-complete? ((this game-info) (task game-task))
  (logtest? (-> this task-perm-list data task status) (entity-perm-status complete))
  )

(defmethod subtask-index-by-name ((this game-info) (arg0 string))
  (let ((subtasks (-> *game-info* sub-task-list)))
    (dotimes (i (-> subtasks length))
      (when (nonzero? i)
        (let ((v1-4 (-> subtasks i)))
          (if (string= arg0 (-> v1-4 name))
              (return i)
              )
          )
        )
      )
    )
  0
  )

(defmethod get-max-ammo-for-gun ((this game-info) (gun pickup-type))
  (let ((f0-0 (the-as number 0.0)))
    (case gun
      (((pickup-type ammo-yellow)
        (pickup-type eco-yellow)
        (pickup-type gun-yellow-1)
        (pickup-type gun-yellow-2)
        (pickup-type gun-yellow-3)
        )
       (set! f0-0 (-> *FACT-bank* ammo-yellow-max))
       (if (logtest? (game-feature gun-upgrade-yellow-ammo-1) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (/ (-> *FACT-bank* ammo-yellow-max) 2)))
           )
       (if (logtest? (game-feature gun-upgrade-yellow-ammo-2) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (/ (-> *FACT-bank* ammo-yellow-max) 2)))
           )
       (if (logtest? (game-secrets gun-upgrade-ammo-yellow) (-> this secrets))
           (set! f0-0 (+ (the-as float f0-0) (-> *FACT-bank* ammo-yellow-max)))
           )
       )
      (((pickup-type ammo-red)
        (pickup-type eco-red)
        (pickup-type gun-red-1)
        (pickup-type gun-red-2)
        (pickup-type gun-red-3)
        )
       (set! f0-0 (-> *FACT-bank* ammo-red-max))
       (if (logtest? (game-feature gun-upgrade-red-ammo-1) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (/ (-> *FACT-bank* ammo-red-max) 2)))
           )
       (if (logtest? (game-feature gun-upgrade-red-ammo-2) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (/ (-> *FACT-bank* ammo-red-max) 2)))
           )
       (if (logtest? (game-secrets gun-upgrade-ammo-red) (-> this secrets))
           (set! f0-0 (+ (the-as float f0-0) (-> *FACT-bank* ammo-red-max)))
           )
       )
      (((pickup-type ammo-blue)
        (pickup-type eco-blue)
        (pickup-type gun-blue-1)
        (pickup-type gun-blue-2)
        (pickup-type gun-blue-3)
        )
       (set! f0-0 (-> *FACT-bank* ammo-blue-max))
       (if (logtest? (game-feature gun-upgrade-blue-ammo-1) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (/ (-> *FACT-bank* ammo-blue-max) 2)))
           )
       (if (logtest? (game-feature gun-upgrade-blue-ammo-2) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (/ (-> *FACT-bank* ammo-blue-max) 2)))
           )
       (if (logtest? (game-secrets gun-upgrade-ammo-blue) (-> this secrets))
           (set! f0-0 (+ (the-as float f0-0) (-> *FACT-bank* ammo-blue-max)))
           )
       )
      (((pickup-type ammo-dark)
        (pickup-type eco-dark)
        (pickup-type gun-dark-1)
        (pickup-type gun-dark-2)
        (pickup-type gun-dark-3)
        )
       (set! f0-0 (-> *FACT-bank* ammo-dark-max))
       (if (logtest? (game-feature gun-upgrade-dark-ammo-1) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (-> *FACT-bank* ammo-dark-max)))
           )
       (if (logtest? (game-feature gun-upgrade-dark-ammo-2) (-> this features))
           (set! f0-0 (+ (the-as float f0-0) (-> *FACT-bank* ammo-dark-max)))
           )
       (if (logtest? (game-secrets gun-upgrade-ammo-dark) (-> this secrets))
           (set! f0-0 (+ (the-as float f0-0) (-> *FACT-bank* ammo-dark-max)))
           )
       )
      )
    (the-as float f0-0)
    )
  )

(define *default-continue* (new 'static 'continue-point
                             :name "default"
                             :level #f
                             :flags (continue-flags change-continue)
                             :trans (new 'static 'vector :w 1.0)
                             :camera-trans (new 'static 'vector :w 1.0)
                             :quat (new 'static 'vector4h :data (new 'static 'array int16 4 0 0 0 #x7fff))
                             :on-goto #f
                             :vis-nick #f
                             :vehicle-type #x1b
                             :want-count 10
                             :want (new 'static 'inline-array level-buffer-state-small 10
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               (new 'static 'level-buffer-state-small :name 'dummy :display? #f)
                               )
                             :want-sound (new 'static 'array symbol 3 #f #f #f)
                             )
        )

(defmethod continue-point-method-10 ((this continue-point) (arg0 load-state))
  (let ((level (lookup-level-info (-> this vis-nick))))
    (set! (-> this vis-nick) (if level
                                 (-> level name)
                                 )
          )
    )
  (dotimes (i (-> this want-count))
    (set! (-> this want i name) (-> arg0 want i name))
    (set! (-> (the-as level-buffer-state-small (-> this want i)) display?) (-> arg0 want i display?))
    )
  (dotimes (ii 3)
    (set! (-> this want-sound ii) (-> arg0 want-sound ii name))
    )
  (set! (-> this camera-trans quad) (-> *camera-combiner* trans quad))
  (when *camera-combiner*
    (let ((rot (-> *camera-combiner* inv-camera-rot))
          (continue-rot (-> this camera-rot))
          )
      (set! (-> continue-rot 0) (the int (* 32767.0 (-> rot rvec x))))
      (set! (-> continue-rot 1) (the int (* 32767.0 (-> rot rvec y))))
      (set! (-> continue-rot 2) (the int (* 32767.0 (-> rot rvec z))))
      (set! (-> continue-rot 3) (the int (* 32767.0 (-> rot uvec x))))
      (set! (-> continue-rot 4) (the int (* 32767.0 (-> rot uvec y))))
      (set! (-> continue-rot 5) (the int (* 32767.0 (-> rot uvec z))))
      (set! (-> continue-rot 6) (the int (* 32767.0 (-> rot fvec x))))
      (set! (-> continue-rot 7) (the int (* 32767.0 (-> rot fvec y))))
      (set! (-> continue-rot 8) (the int (* 32767.0 (-> rot fvec z))))
      )
    )
  (add-borrow-levels arg0)
  this
  )

(defmethod move-camera! ((this continue-point))
  (set! (-> *camera-combiner* trans quad) (-> this camera-trans quad))
  (let ((gp-0 (-> *camera-combiner* inv-camera-rot))
        (s5-0 (-> this camera-rot))
        )
    (matrix-identity! gp-0)
    (set! (-> gp-0 rvec x) (* 0.00003051851 (the float (-> s5-0 0))))
    (set! (-> gp-0 rvec y) (* 0.00003051851 (the float (-> s5-0 1))))
    (set! (-> gp-0 rvec z) (* 0.00003051851 (the float (-> s5-0 2))))
    (set! (-> gp-0 uvec x) (* 0.00003051851 (the float (-> s5-0 3))))
    (set! (-> gp-0 uvec y) (* 0.00003051851 (the float (-> s5-0 4))))
    (set! (-> gp-0 uvec z) (* 0.00003051851 (the float (-> s5-0 5))))
    (set! (-> gp-0 fvec x) (* 0.00003051851 (the float (-> s5-0 6))))
    (set! (-> gp-0 fvec y) (* 0.00003051851 (the float (-> s5-0 7))))
    (set! (-> gp-0 fvec z) (* 0.00003051851 (the float (-> s5-0 8))))
    )
  (send-event *camera* 'change-target *target*)
  (cam-master-activate-slave #t)
  0
  (none)
  )

(defmethod get-current-continue-forced ((this game-info))
  (cond
    ((and (= (-> this mode) 'play) (-> this current-continue))
     (-> this current-continue)
     )
    (else
      (let ((gp-0 *default-continue*))
        (position-in-front-of-camera! (-> gp-0 trans) 40960.0 4096.0)
        (set-vector! (-> gp-0 quat) 0 0 0 #x7fff)
        (continue-point-method-10 gp-0 *load-state*)
        gp-0
        )
      )
    )
  )

(defmethod get-continue-by-name ((this game-info) (name string))
  (if (not name)
      (return (the-as continue-point #f))
      )
  (let ((levels *level-load-list*))
    (while (not (null? levels))
      (let ((continues (-> (the-as level-load-info (-> (the-as symbol (-> levels car)) value)) continues)))
        (while (not (null? continues))
          (let ((cont (the-as continue-point (-> continues car))))
            (if (string= name (-> cont name))
                (return cont)
                )
            )
          (set! continues (the-as pair (-> continues cdr)))
          )
        )
      (set! levels (the-as pair (-> levels cdr)))
      )
    )
  (the-as continue-point #f)
  )

(defmethod set-continue! ((this game-info) (arg0 basic) (arg1 symbol))
  (let ((s5-0 (-> this current-continue)))
    (if (null? arg0)
        (set! arg0 (the-as basic #f))
        )
    (case (rtype-of arg0)
      ((string)
       (let ((v1-7 (get-continue-by-name this (the-as string arg0))))
         (if v1-7
             (set! (-> this current-continue) v1-7)
             )
         )
       )
      ((continue-point)
       (set! (-> this current-continue) (the-as continue-point arg0))
       )
      (else
        (let ((s3-3 *default-continue*))
          (position-in-front-of-camera! (-> s3-3 trans) 40960.0 4096.0)
          (set-vector! (-> s3-3 quat) 0 0 0 #x7fff)
          (let ((v1-10 (lookup-level-info (-> *load-state* vis-nick))))
            (set! (-> s3-3 vis-nick) (if v1-10
                                         (-> v1-10 name)
                                         )
                  )
            )
          (dotimes (v1-11 (-> s3-3 want-count))
            (set! (-> s3-3 want v1-11 name) (-> *load-state* want v1-11 name))
            (set! (-> s3-3 want v1-11 display?) (-> *load-state* want v1-11 display?))
            )
          (dotimes (v1-14 3)
            (set! (-> s3-3 want-sound v1-14) (-> *load-state* want-sound v1-14 name))
            )
          (set! (-> this current-continue) s3-3)
          )
        )
      )
    (if (and (logtest? (-> this current-continue flags) (continue-flags change-continue))
             (and (!= (-> this current-continue) *default-continue*) (not arg1))
             )
        (set! (-> this current-continue) s5-0)
        )
    (when (!= s5-0 (-> this current-continue))
      (set! (-> this continue-deaths) 0)
      (set! (-> this continue-time) (-> *display* game-clock frame-counter))
      )
    )
  (-> this current-continue)
  )

(defmethod task-perm-by-index ((this game-info) (arg0 int))
  (-> this task-perm-list data arg0)
  )

(defmethod calculate-percentage ((this game-info))
  (let ((gp-0 0)
        (completed-tasks 0)
        )
    0.0
    (let ((s3-0 6)
          (s2-0 72)
          )
      (while (>= (the-as uint s2-0) (the-as uint s3-0))
        (let ((v1-0 (the-as game-task-node-info #f)))
          (let ((node (max 2 (the-as int (-> *game-info* play-list s3-0 play-node)))))
            (while (< (the-as uint node) (the-as uint 271))
              (let ((node-info (-> *game-info* sub-task-list node)))
                (if (and (= (-> node-info task) s3-0) (logtest? (-> node-info flags) (game-task-node-flag close-task)))
                    (set! v1-0 node-info)
                    )
                (if (< (the-as uint s3-0) (the-as uint (-> node-info task)))
                    (goto cfg-13)
                    )
                )
              (+! node 1)
              )
            )
          (label cfg-13)
          (when (and v1-0 (not (logtest? (game-task-node-flag no-percent) (-> v1-0 flags))))
            (+! gp-0 1)
            (if (task-complete? this (the-as game-task s3-0))
                (+! completed-tasks 1)
                )
            )
          )
        (+! s3-0 1)
        )
      )
    (/ (* 100.0 (the float completed-tasks)) (the float gp-0))
    )
  )

(defun task-level->string ((arg0 int))
  (symbol->string (-> *task-level* arg0))
  )

(defun level-name->task-level ((arg0 symbol))
  (let ((v1-0 (lookup-level-info arg0)))
    (if v1-0
        (the-as int (-> v1-0 task-level))
        0
        )
    )
  )

(defmethod inc-death-count! ((this game-info))
  (let ((level (level-get-target-inside *level*)))
    (when (and level (>= (- (-> *display* game-clock frame-counter) (-> this death-time)) (seconds 2)))
      (let ((subtasks (-> *game-info* sub-task-list)))
        (dotimes (i (-> subtasks length))
          (when (nonzero? i)
            (let ((subtask (-> subtasks i)))
              (when (game-task-node-info-method-12 subtask)
                (when (or (and (-> subtask manager) (handle->process (-> subtask manager manager)))
                          (and (-> subtask manager)
                               (-> subtask manager level)
                               (= (status-of-level-and-borrows *level* (-> subtask manager level) #f) 'active)
                               )
                          (and (not (-> subtask manager)) (= (-> level info taskname) (-> subtask level)))
                          )
                  (format #t "death count inc for ~S~%" (-> subtask name))
                  (set! (-> subtask death-count) (the-as uint (seekl (the-as int (-> subtask death-count)) #xffff 1)))
                  )
                )
              )
            )
          )
        )
      )
    )
  (set! (-> this death-time) (-> *display* game-clock frame-counter))
  0
  (none)
  )

(defmethod initialize! ((this game-info) (mode symbol) (arg2 game-save) (continue-name string) (reset-spec resetter-spec))
  (local-vars
    (sv-96 process)
    (sv-112 process-tree)
    (sv-128 cpu-thread)
    (sv-144 (function symbol symbol continue-point game-save resetter-spec none :behavior process))
    (sv-160 symbol)
    )
  (when reset-spec
    (if (not continue-name)
        (set! continue-name (-> reset-spec continue))
        )
    (if (not mode)
        (set! mode (-> reset-spec reset-mode))
        )
    (mem-copy! (the-as pointer (-> this death-resetter)) (the-as pointer reset-spec) 16)
    (set! reset-spec (-> this death-resetter))
    )
  (when (and continue-name (= (-> continue-name type) string))
    (let ((name (get-continue-by-name this continue-name)))
      (when (not name)
        (format 0 "ERROR: attempting to reset to continue ~A when it doesn't exist~%" continue-name)
        (break!)
        0
        )
      (set! continue-name (the-as string name))
      )
    )
  (case mode
    (('dead 'life)
     (+! (-> this total-deaths) 1)
     (+! (-> this continue-deaths) 1)
     (+! (-> this task-deaths) 1)
     (when *target*
       (let ((level-info (-> *target* current-level info)))
         (set! (-> this deaths-per-level (-> level-info task-level))
               (the-as uint (seekl (the-as int (-> this deaths-per-level (-> level-info task-level))) 255 1))
               )
         )
       )
     (case (-> this mode)
       (('play)
        (set! mode 'life)
        )
       (else
         (set! this this)
         (goto cfg-114)
         )
       )
     )
    (('try)
     (+! (-> this total-trys) 1)
     )
    )
  (case mode
    (('dead 'life 'try)
     (inc-death-count! this)
     )
    )
  (kill-current-talker '() '() 'die)
  (case mode
    (('game 'boot)
     (+! (-> this task-counter) 1)
     (reset! (-> *display* total-game-clock))
     (set! (-> this features) (game-feature sidekick darkjak darkjak-bomb0 darkjak-bomb1))
     (set! (-> this debug-features) (game-feature))
     (set! (-> this old-features) (game-feature))
     (set! (-> this items) (game-items))
     (set! (-> this debug-items) (game-items))
     (set! (-> this old-items) (game-items))
     (set! (-> this vehicles) (game-vehicles))
     (set! (-> this debug-vehicles) (game-vehicles))
     (set! (-> this old-vehicles) (game-vehicles))
     (set! (-> this secrets) (game-secrets))
     (set! (-> this purchase-secrets) (game-secrets))
     (set! (-> this current-vehicle) (vehicle-type-u8 vt27))
     (set-continue!
       this
       (cond
         ((the-as basic continue-name)
          (the-as basic continue-name)
          )
         ((demo?)
          "title-start"
          )
         ((and *debug-segment* (= mode 'boot))
          "wascity-start"
          )
         (else
           "title-start"
           )
         )
       #f
       )
     (set! mode 'game)
     (set! (-> this auto-save-count) 0)
     (set! (-> *setting-control* user-default auto-save) #f)
     (set! (-> this money) 0.0)
     (set! (-> this money-total) 0.0)
     (set! (-> this fuel) 0.0)
     (set! (-> this buzzer-total) 0.0)
     (set! (-> this eco-pill-dark) 0.0)
     (set! (-> this eco-pill-dark-total) 0.0)
     (set! (-> this eco-pill-light) 0.0)
     (set! (-> this eco-pill-light-total) 0.0)
     (set! (-> this gem) 0.0)
     (set! (-> this gem-total) 0.0)
     (set! (-> this skill) 0.0)
     (set! (-> this skill-total) 0.0)
     (set! (-> this skill-high-watermark) 0.0)
     (set! (-> this light-crystal) 0.0)
     (set! (-> this dark-crystal) 0.0)
     (set! (-> this karma) 0.0)
     (set! (-> this perm-list length) 0)
     (dotimes (v1-57 (-> this unknown-arr4 allocated-length))
       (set! (-> this unknown-arr4 v1-57) (the-as uint 0))
       )
     (set! (-> this death-movie-tick) (rand-vu-int-count 10))
     (set! (-> this gun-type) (pickup-type gun-red-1))
     (set! (-> this gun-ammo 0) (-> *FACT-bank* ammo-yellow-start))
     (set! (-> this gun-ammo 1) (-> *FACT-bank* ammo-red-start))
     (set! (-> this gun-ammo 2) (-> *FACT-bank* ammo-blue-start))
     (set! (-> this gun-ammo 3) (-> *FACT-bank* ammo-dark-start))
     (set! (-> this shield) 100.0)
     (set! (-> this score) 0.0)
     (set! (-> this score-owner) (the-as handle #f))
     (set! (-> this goal) 0.0)
     (set! (-> this miss) 0.0)
     (set! (-> this miss-max) 0.0)
     (set! (-> this timer) 0)
     (set! (-> this timer-flash) #f)
     (set! (-> this timer-owner) (the-as handle #f))
     (set! (-> this counter) 0.0)
     (set! (-> this counter-flash) #f)
     (set! (-> this wanted-flash) #f)
     (set! (-> this distance) 0.0)
     (set! (-> this enemies-killed) 0.0)
     (set! (-> this civilians-killed) 0.0)
     (set! (-> this marauders-killed) 0.0)
     (dotimes (v1-66 4)
       (set! (-> this shots-fired v1-66) 0.0)
       (set! (-> this shots-hit v1-66) 0.0)
       )
     (set! (-> this crates-opened) 0.0)
     (set! (-> this health-collected) 0.0)
     (set! (-> this board-time) 0)
     (set! (-> this attack-id) (the-as uint 2))
     (set! (-> this total-trys) 0)
     (set! (-> this total-deaths) 0)
     (set! (-> this continue-deaths) 0)
     (set! (-> this task-deaths) 0)
     (set! (-> this death-pos length) 0)
     (set! (-> this game-start-time) (-> *display* game-clock frame-counter))
     (set! (-> this task-pickup-time) (-> *display* game-clock frame-counter))
     (set! (-> this continue-time) (-> *display* game-clock frame-counter))
     (set! (-> this death-time) (-> *display* game-clock frame-counter))
     (set! (-> this hit-time) (-> *display* game-clock frame-counter))
     (dotimes (v1-86 138)
       (set! (-> this task-complete-time 0) 0)
       (set! (-> this task-start-time 0) 0)
       (nop!)
       )
     (dotimes (v1-89 32)
       (set! (-> this money-per-level v1-89) (the-as uint 0))
       (set! (-> this deaths-per-level v1-89) (the-as uint 0))
       (set! (-> this task-enter-times v1-89) 0)
       (set! (-> this task-in-times v1-89) 0)
       (set! (-> this level-opened v1-89) (the-as uint 0))
       (nop!)
       )
     (let ((v1-93 (-> *game-info* sub-task-list)))
       (dotimes (a0-39 (-> v1-93 length))
         (when (nonzero? a0-39)
           (let ((a1-17 (-> v1-93 a0-39)))
             (set! (-> a1-17 gem-count) (the-as uint 0))
             (set! (-> a1-17 skill-count) (the-as uint 0))
             (set! (-> a1-17 death-count) (the-as uint 0))
             (set! (-> a1-17 close-time) (the-as uint 0))
             )
           0
           )
         )
       )
     (dotimes (v1-96 (-> this game-score length))
       (set! (-> this game-score v1-96) 0.0)
       )
     (initialize *bigmap*)
     )
    )
  (case mode
    (('game 'try 'life)
     (case (-> this mode)
       (('play)
        (set! *display-profile* #f)
        (set! *display-entity-errors* #f)
        )
       )
     (set! (-> this life-max) (-> *GAME-bank* life-max-default))
     (set! (-> this life) (-> *GAME-bank* life-start-default))
     (let ((f0-39 (+ 0.5 (* 0.5 (you-suck-scale *game-info* #f 0)))))
       (set! (-> this gun-ammo 0) (fmax (-> this gun-ammo 0) (* f0-39 (-> *FACT-bank* ammo-yellow-start))))
       (set! (-> this gun-ammo 1) (fmax (-> this gun-ammo 1) (* f0-39 (-> *FACT-bank* ammo-red-start))))
       (set! (-> this gun-ammo 2) (fmax (-> this gun-ammo 2) (* f0-39 (-> *FACT-bank* ammo-blue-start))))
       (set! (-> this gun-ammo 3) (fmax (-> this gun-ammo 3) (* f0-39 (-> *FACT-bank* ammo-dark-start))))
       )
     )
    )
  (let ((v1-117 (-> this mode)))
    (cond
      ((= v1-117 'movie)
       (task-node-reset mode)
       (open! (-> *game-info* sub-task-list (game-task-node city-start-start)) 'event)
       (update-task-masks mode)
       (if (and reset-spec (nonzero? (-> reset-spec node)))
           (task-node-open! (-> reset-spec node) 'event)
           )
       )
      ((= v1-117 'debug)
       (reset-actors mode)
       (open! (-> *game-info* sub-task-list (game-task-node city-start-start)) 'event)
       (if (and reset-spec (nonzero? (-> reset-spec node)))
           (task-node-open! (-> reset-spec node) 'event)
           )
       (if arg2
           (load-game this arg2)
           )
       )
      ((= v1-117 'play)
       (when *target*
         (set-setting *setting-control* *target* 'allow-pause #f 0 0)
         (set-setting *setting-control* *target* 'allow-progress #f 0 0)
         (set-setting *setting-control* *target* 'allow-continue #f 0 0)
         (apply-settings *setting-control*)
         )
       (send-event (handle->process (-> *game-info* auto-save-proc)) 'die)
       (set! (-> *setting-control* user-default border-mode) #f)
       (set! (-> *setting-control* user-default region-mode) #f)
       (apply-settings *setting-control*)
       (set! *spawn-actors* #f)
       (set-blackout-frames (seconds 0.1))
       (send-event *target* 'reset)
       (let* ((s1-2 (get-process *4k-dead-pool* process #x4000 1))
              (v1-149
                (when s1-2
                  (let ((s0-1 (method-of-type process activate)))
                    (set! sv-96 s1-2)
                    (set! sv-112 *default-pool*)
                    (let ((a2-12 (symbol->string (-> process symbol)))
                          (a3-5 #x70004000)
                          (t9-30 s0-1)
                          )
                      (t9-30 sv-96 sv-112 a2-12 (the-as pointer a3-5))
                      )
                    )
                  (let ((s0-2 set-to-run))
                    (set! sv-128 (-> s1-2 main-thread))
                    (set! sv-144 (lambda :behavior process
                                   ((arg0 symbol) (arg1 symbol) (arg2 continue-point) (arg3 game-save) (arg4 resetter-spec))
                                   (set! (-> self mask) (process-mask))
                                   (stop arg0)
                                   (reset-actors arg1)
                                   (open! (-> *game-info* sub-task-list (game-task-node city-start-start)) 'event)
                                   (if (and arg4 (nonzero? (-> arg4 node)))
                                       (task-node-open! (-> arg4 node) 'event)
                                       )
                                   (set-continue! *game-info* arg2 #t)
                                   (when arg3
                                     (load-game *game-info* arg3)
                                     (set! arg2 (get-current-continue-forced *game-info*))
                                     (reset-actors 'life)
                                     (send-event (handle->process (-> *game-info* auto-save-proc)) 'done)
                                     )
                                   (suspend)
                                   (start arg0 arg2)
                                   (none)
                                   )
                          )
                    (set! sv-160 (-> this mode))
                    (let ((t0-4 (if (the-as basic continue-name)
                                    (the-as basic continue-name)
                                    (get-current-continue-forced this)
                                    )
                                )
                          (t1-3 arg2)
                          (t2-0 reset-spec)
                          )
                      ((the-as (function cpu-thread function symbol symbol continue-point game-save resetter-spec none) s0-2)
                       sv-128
                       sv-144
                       sv-160
                       mode
                       (the-as continue-point t0-4)
                       t1-3
                       t2-0
                       )
                      )
                    )
                  (-> s1-2 ppointer)
                  )
                )
              )
         (when v1-149
           (set! (-> v1-149 0 mask) (process-mask))
           0
           )
         )
       (set-master-mode 'game)
       )
      )
    )
  (label cfg-114)
  this
  )

(defmethod give ((this game-info) (arg0 symbol) (arg1 float) (arg2 handle))
  (local-vars (f0-63 float))
  (with-pp
    (case arg0
      (('life)
       (if (>= arg1 0.0)
           (seek! (-> this life) (-> this life-max) arg1)
           (seek! (-> this life) 0.0 (- arg1))
           )
       (-> this life)
       )
      (('money)
       (if (< 0.0 arg1)
           (+! (-> this money-total) arg1)
           )
       (set! (-> this money) (+ (-> this money) arg1))
       )
      (('gem)
       (when (< 0.0 arg1)
         (+! (-> this gem-total) arg1)
         (let ((s4-0 (handle->process arg2)))
           (if (and s4-0 (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
                           (set! (-> a1-4 from) (process->ppointer pp))
                           (set! (-> a1-4 num-params) 0)
                           (set! (-> a1-4 message) 'handle-gem-pickup)
                           (and (not (send-event-function s4-0 a1-4)) (-> s4-0 entity))
                           )
                    )
               (toggle-status (-> s4-0 entity) (entity-perm-status save) #t)
               )
           )
         )
       (set! (-> this gem) (+ (-> this gem) arg1))
       )
      (('skill)
       (if (< 0.0 arg1)
           (+! (-> this skill-total) arg1)
           )
       (+! (-> this skill) arg1)
       (if (< 0.0 arg1)
           (menu-secrets-notify-powerup-collect)
           )
       (set! (-> this skill-high-watermark) (fmax (-> this skill-high-watermark) (-> this skill)))
       (-> this skill)
       )
      (('karma)
       (set! (-> this karma) (+ (-> this karma) arg1))
       )
      (('eco-pill-dark)
       (cond
         ((< 0.0 arg1)
          (seek! (-> this eco-pill-dark) (-> *FACT-bank* eco-pill-dark-max-default) arg1)
          (+! (-> this eco-pill-dark-total) arg1)
          )
         (else
           (seek! (-> this eco-pill-dark) 0.0 (- arg1))
           )
         )
       (-> this eco-pill-dark)
       )
      (('eco-pill-light)
       (cond
         ((< 0.0 arg1)
          (seek! (-> this eco-pill-light) (-> *FACT-bank* eco-pill-light-max-default) arg1)
          (+! (-> this eco-pill-light-total) arg1)
          )
         (else
           (seek! (-> this eco-pill-light) 0.0 (- arg1))
           )
         )
       (-> this eco-pill-light)
       )
      (('fuel-cell)
       (let ((s5-1 (the int arg1)))
         (when (not (or (task-complete? this (the-as game-task s5-1)) (>= (the-as uint 1) (the-as uint s5-1))))
           (set! (-> this task-deaths) 0)
           (set! (-> this task-pickup-time) (-> *display* game-clock frame-counter))
           (set! (-> this task-complete-time s5-1) (-> *display* game-clock frame-counter))
           (+! (-> this fuel) 1.0)
           (logior! (-> this task-perm-list data s5-1 status) (entity-perm-status complete))
           (task-resolution-close! (the-as game-task s5-1))
           )
         )
       (-> this fuel)
       )
      (('buzzer)
       (logand (the int arg1) #xffff)
       (sar (the int arg1) 16)
       0.0
       )
      (('ammo-yellow 'ammo-red 'ammo-blue 'ammo-dark)
       0.0
       (let* ((v1-47 arg0)
              (s4-1 (cond
                      ((= v1-47 'ammo-yellow)
                       (set! f0-63 (get-max-ammo-for-gun this (pickup-type ammo-yellow)))
                       0
                       )
                      ((= v1-47 'ammo-red)
                       (set! f0-63 (get-max-ammo-for-gun this (pickup-type ammo-red)))
                       1
                       )
                      ((= v1-47 'ammo-blue)
                       (set! f0-63 (get-max-ammo-for-gun this (pickup-type ammo-blue)))
                       2
                       )
                      (else
                        (set! f0-63 (get-max-ammo-for-gun this (pickup-type ammo-dark)))
                        3
                        )
                      )
                    )
              )
         (let ((f30-0 (the float (the int f0-63))))
           (if (>= arg1 0.0)
               (seek! (-> this gun-ammo s4-1) f30-0 arg1)
               (seek! (-> this gun-ammo s4-1) 0.0 (fabs arg1))
               )
           (set! (-> this gun-ammo s4-1) (fmin (-> this gun-ammo s4-1) f30-0))
           )
         (-> this gun-ammo s4-1)
         )
       )
      (('gun-yellow)
       (if (logtest? (logand (-> *setting-control* user-current features) (game-feature gun-yellow-1))
                     (-> this features)
                     )
           1.0
           0.0
           )
       )
      (('gun-dark)
       (if (logtest? (logand (-> *setting-control* user-current features) (game-feature gun-dark-1)) (-> this features))
           1.0
           0.0
           )
       )
      (('board)
       (cond
         ((< 0.0 arg1)
          (logior! (-> this features) (game-feature board))
          )
         ((< arg1 0.0)
          (logclear! (-> this features) (game-feature board))
          )
         )
       (if (logtest? (game-feature board) (-> this features))
           1.0
           0.0
           )
       )
      (('shield)
       (if (>= arg1 0.0)
           (seek! (-> this shield) (-> *FACT-bank* shield-max) arg1)
           (seek! (-> this shield) 0.0 (fabs arg1))
           )
       (-> this shield)
       )
      )
    )
  )

(defmethod game-info-method-21 ((this game-info))
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod reset! ((this fact-info-target) (arg0 symbol))
  (when (or (not arg0) (= arg0 'eco))
    (set! (-> this eco-timeout) 0)
    (set! (-> this eco-level) 0.0)
    (set! (-> this eco-pickup-time) (-> *display* game-clock frame-counter))
    )
  (when (or (not arg0) (= arg0 'health))
    (set! (-> this health-max) (-> *FACT-bank* health-max-default))
    (set! (-> this health) (-> this health-max))
    (set! (-> this health-pickup-time) (seconds -100))
    )
  (when (or (not arg0) (= arg0 'buzzer))
    (set! (-> this buzzer-max) (-> *FACT-bank* buzzer-max-default))
    (set! (-> this buzzer) 0.0)
    )
  (when (or (not arg0) (= arg0 'eco-pill-green))
    (set! (-> this eco-pill-green-max) (-> *FACT-bank* eco-pill-green-max-default))
    (set! (-> this eco-pill-green) 0.0)
    )
  (when (or (not arg0) (= arg0 'eco-green))
    (set! (-> this eco-green-max) (-> *FACT-bank* eco-green-max-default))
    (set! (-> this eco-green) 0.0)
    )
  (when (or (not arg0) (= arg0 'trick-judge))
    (set! (-> this trick-point-start-time) 0)
    (set! (-> this trick-point-duration) 0)
    0
    )
  (when (or (not arg0) (= arg0 'trick-point))
    (set! (-> this trick-point) 0.0)
    (set! (-> (the-as target (-> this process)) game score) 0.0)
    )
  (none)
  )

(defmethod pickup-collectable! ((this fact-info-target) (pickup pickup-type) (amount float) (pickup-handle handle))
  (local-vars (sv-112 vector) (sv-128 matrix))
  (case pickup
    (((pickup-type health))
     (cond
       ((>= amount 0.0)
        (when (< 0.0 amount)
          (if (or (!= (handle->process pickup-handle) (handle->process (-> this eco-source)))
                  (>= (- (-> *display* game-clock frame-counter) (-> this eco-source-time)) (seconds 0.5))
                  )
              (sound-play "get-green-eco")
              )
          (send-event (-> this process) 'color-effect 'health (seconds 0.2))
          (when (handle->process pickup-handle)
            (set! (-> this eco-source) pickup-handle)
            (set! (-> this eco-source-time) (-> *display* game-clock frame-counter))
            )
          )
        (set! (-> this health-pickup-time) (-> *display* game-clock frame-counter))
        (seek! (-> this health) (-> this health-max) amount)
        )
       (else
         (seek! (-> this health) 0.0 (- amount))
         (if (>= amount -10.0)
             (pickup-collectable! this (pickup-type eco-pill-green) 0.0 pickup-handle)
             )
         (cond
           ((= (-> this health) 0.0)
            (give (-> this process game) 'life (- (-> *GAME-bank* life-single-inc)) pickup-handle)
            )
           ((and (< 0.0 (-> *game-info* eco-pill-light))
                 (logtest? (the-as game-feature (logand (game-feature lightjak-regen) (-> *setting-control* user-current features)))
                           (-> this process game features)
                           )
                 )
            )
           )
         )
       )
     (-> this health)
     )
    (((pickup-type health-max))
     (let ((f0-15 (-> this health-max)))
       (set! (-> this health-max) (fmax 0.0 (fmin (+ (-> this health-max) amount) (-> *FACT-bank* health-max-max))))
       (set! (-> this health)
             (fmax 0.0 (fmin (+ (-> this health) (fmax 0.0 (- (-> this health-max) f0-15))) (-> this health-max)))
             )
       )
     (set! (-> this health-pickup-time) (-> *display* game-clock frame-counter))
     (-> this health-max)
     )
    (((pickup-type eco-pill-green))
     (when (>= amount 0.0)
       (set! (-> this eco-pill-green-pickup-time) (-> *display* game-clock frame-counter))
       (seek! (-> this eco-pill-green) (-> this eco-pill-green-max) amount)
       (when (and (>= (-> this eco-pill-green) (-> *FACT-bank* eco-pill-green-max-default))
                  (< (-> this health) (-> this health-max))
                  )
         (set! (-> this eco-pill-green) (- (-> this eco-pill-green) (-> *FACT-bank* eco-pill-green-max-default)))
         (pickup-collectable!
           this
           (pickup-type health)
           (-> *FACT-bank* health-small-inc)
           (process->handle (-> this process))
           )
         )
       )
     (-> this eco-pill-green)
     )
    (((pickup-type eco-green))
     (cond
       ((< 0.0 amount)
        (set! (-> this eco-green-pickup-time) (-> *display* game-clock frame-counter))
        (seek! (-> this eco-green) (-> this eco-green-max) amount)
        (sound-play "get-green-eco")
        (send-event (-> this process) 'color-effect 'eco-green (seconds 0.2))
        )
       (else
         (seek! (-> this eco-green) 0.0 (- amount))
         )
       )
     (-> this eco-green)
     )
    (((pickup-type eco-pill-dark))
     (when (< 0.0 amount)
       (if (>= (- (-> *display* game-clock frame-counter) (-> this eco-pill-dark-pickup-time)) (seconds 0.05))
           (sound-play "get-dark-eco")
           )
       (send-event (-> this process) 'color-effect 'eco-pill-dark (seconds 0.2))
       (cond
         ((>= (- (-> *display* game-clock frame-counter) (-> this process shock-effect-time)) (seconds 0.1))
          (set! (-> this process shock-effect-time) (-> *display* game-clock frame-counter))
          (let ((s3-3 (rand-vu-int-range 0 2)))
            (dotimes (s2-2 s3-3)
              (process-drawable-shock-effect
                (-> this process)
                *lightning-darkjak-pill*
                lightning-probe-callback
                (the-as sparticle-launcher #f)
                0
                0
                40960.0
                )
              )
            )
          )
         (else
           (send-event (handle->process pickup-handle) 'effect #f)
           )
         )
       (set! (-> this eco-pill-dark-pickup-time) (-> *display* game-clock frame-counter))
       )
     (give (-> this process game) 'eco-pill-dark amount pickup-handle)
     )
    (((pickup-type eco-pill-light))
     (when (< 0.0 amount)
       (when (>= (- (-> *display* game-clock frame-counter) (-> this eco-pill-light-pickup-time)) (seconds 0.05))
         (dotimes (s3-4 10)
           (let ((v0-21 (rand-vu-int-range 3 (+ (-> this process node-list length) -1)))
                 (s2-3 sp-launch-particles-var)
                 (s1-0 *sp-particle-system-2d*)
                 (s0-0 (-> *part-id-table* 1))
                 )
             (set! sv-128 *launch-matrix*)
             (set! sv-112 (-> sv-128 trans))
             (let ((v1-122 (-> (vector<-cspace! (new 'stack-no-clear 'vector) (-> this process node-list data v0-21)) quad)))
               (set! (-> sv-112 quad) v1-122)
               )
             (let ((a3-13 #f)
                   (t0-4 #f)
                   (t1-4 1.0)
                   )
               (s2-3 s1-0 s0-0 sv-128 (the-as sparticle-launch-state a3-13) (the-as sparticle-launch-control t0-4) t1-4)
               )
             )
           )
         (sound-play "get-light-eco")
         )
       (if (< (-> this process game eco-pill-light) (* 0.95 (-> *FACT-bank* eco-pill-light-max-default)))
           (send-event (-> this process) 'color-effect 'eco-pill-light (seconds 0.2))
           )
       (set! (-> this eco-pill-light-pickup-time) (-> *display* game-clock frame-counter))
       )
     (give (-> this process game) 'eco-pill-light amount pickup-handle)
     )
    (((pickup-type trick-judge))
     (when (< 0.0 amount)
       (set! (-> this trick-point) 0.0)
       (set! (-> this trick-point-start-time) (-> *display* game-clock frame-counter))
       (set! (-> this trick-point-duration) (the-as time-frame (the int amount)))
       )
     (the float (-> this trick-point-duration))
     )
    (((pickup-type trick-point))
     (when (nonzero? (-> this trick-point-duration))
       (set! (-> this trick-point-pickup-time) (-> *display* game-clock frame-counter))
       (set! (-> this trick-point)
             (fmax 0.0 (fmin (+ (-> this trick-point) amount) (-> *FACT-bank* trick-point-max)))
             )
       (when (!= amount 0.0)
         (sound-play "get-trick-point")
         (process-spawn-function
           process
           (lambda :behavior process
             ((arg0 symbol) (arg1 symbol) (arg2 int))
             (let ((s3-0 (new 'stack-no-clear 'vector4w)))
               (set! (-> s3-0 quad) (the-as uint128 0))
               (when (transform-point-qword! s3-0 (the-as vector arg0))
                 (let ((s5-0 (new
                               'stack
                               'font-context
                               *font-default-matrix*
                               (+ (the int (/ (the float (+ (/ (-> s3-0 x) 16) -1792)) (-> *video-params* relative-x-scale))) -48)
                               (+ (/ (-> s3-0 y) 16) -1855)
                               0.0
                               (font-color orange)
                               (font-flags shadow kerning)
                               )
                             )
                       )
                   (set! (-> s5-0 scale) (lerp-scale 0.6 1.0 (the-as float arg1) 50.0 8000.0))
                   (let ((v1-9 s5-0))
                     (set! (-> v1-9 origin z) (the float (/ (-> s3-0 z) 16)))
                     )
                   (set! (-> s5-0 flags) (font-flags shadow kerning large))
                   (suspend-for (+ arg2 -75)
                     (+! (-> s5-0 origin y) (* -120.0 (seconds-per-frame)))
                     (let ((s2-0 print-game-text))
                       (format (clear *temp-string*) "~4,,0f" arg1)
                       (s2-0 *temp-string* s5-0 #f 44 (bucket-id debug-no-zbuf1))
                       )
                     )
                   (suspend-for (seconds 0.25)
                     (set! (-> s5-0 alpha) (lerp-scale 1.0 0.0 (the float (- (current-time) time)) 0.0 150.0))
                     (+! (-> s5-0 origin y) (* -120.0 (seconds-per-frame)))
                     (let ((s3-2 print-game-text))
                       (format (clear *temp-string*) "~4,,0f" arg1)
                       (s3-2 *temp-string* s5-0 #f 44 (bucket-id debug-no-zbuf1))
                       )
                     )
                   )
                 )
               )
             (none)
             )
           (get-trans (-> this process) 3)
           amount
           510
           :to (-> this process)
           )
         )
       )
     (-> this trick-point)
     )
    (((pickup-type money))
     (when (< 0.0 amount)
       (if (>= (- (-> *display* game-clock frame-counter) (-> this money-pickup-time)) (seconds 0.05))
           (sound-play "money-pickup")
           )
       (set! (-> this money-pickup-time) (-> *display* game-clock frame-counter))
       )
     (give (-> this process game) 'money amount pickup-handle)
     )
    (((pickup-type gem))
     (when (< 0.0 amount)
       (if (>= (- (-> *display* game-clock frame-counter) (-> this gem-pickup-time)) (seconds 0.05))
           (sound-play "gem-pickup")
           )
       (set! (-> this gem-pickup-time) (-> *display* game-clock frame-counter))
       )
     (ready-hud 'hud-skullgem 240)
     (give (-> this process game) 'gem amount pickup-handle)
     )
    (((pickup-type skill))
     (when (< 0.0 amount)
       (if (>= (- (-> *display* game-clock frame-counter) (-> this skill-pickup-time)) (seconds 0.05))
           (sound-play "skill-pickup")
           )
       (set! (-> this skill-pickup-time) (-> *display* game-clock frame-counter))
       )
     (ready-hud 'hud-skill -1)
     (give (-> this process game) 'skill amount pickup-handle)
     )
    (((pickup-type karma))
     (if (!= amount 0.0)
         (set! (-> this karma-pickup-time) (-> *display* game-clock frame-counter))
         )
     (give (-> this process game) 'karma amount pickup-handle)
     )
    (((pickup-type fuel-cell))
     (let ((s3-12 (the int amount)))
       (if (not (or (task-complete? (-> this process game) (the-as game-task s3-12)) (>= (the-as uint 1) (the-as uint s3-12)))
                )
           (set! (-> this task-pickup-time) (-> *display* game-clock frame-counter))
           )
       )
     (give (-> this process game) 'fuel-cell amount pickup-handle)
     )
    (((pickup-type buzzer))
     (let ((f0-60 (give (-> this process game) 'buzzer amount pickup-handle)))
       (if (!= f0-60 (-> this buzzer))
           (set! (-> this buzzer-pickup-time) (-> *display* game-clock frame-counter))
           )
       (set! (-> this buzzer) f0-60)
       )
     (-> this buzzer)
     )
    (((pickup-type ammo-yellow) (pickup-type ammo-red) (pickup-type ammo-blue) (pickup-type ammo-dark))
     (if (< 0.0 amount)
         (set! (-> this ammo-pickup-time) (-> *display* game-clock frame-counter))
         )
     (let ((s3-13 (cond
                    ((= pickup (pickup-type ammo-yellow))
                     'ammo-yellow
                     )
                    ((= pickup (pickup-type ammo-red))
                     'ammo-red
                     )
                    ((= pickup (pickup-type ammo-blue))
                     'ammo-blue
                     )
                    (else
                      'ammo-dark
                      )
                    )
                  )
           )
       (if (< 0.0 amount)
           (send-event (-> this process) 'color-effect s3-13 (seconds 0.2))
           )
       (give (-> this process game) s3-13 amount pickup-handle)
       )
     )
    (((pickup-type gun-red-1)
      (pickup-type gun-red-2)
      (pickup-type gun-red-3)
      (pickup-type gun-yellow-1)
      (pickup-type gun-yellow-2)
      (pickup-type gun-yellow-3)
      (pickup-type gun-blue-1)
      (pickup-type gun-blue-2)
      (pickup-type gun-blue-3)
      (pickup-type gun-dark-1)
      (pickup-type gun-dark-2)
      (pickup-type gun-dark-3)
      (pickup-type board)
      )
     (let ((v1-240 pickup))
       (give
         (-> this process game)
         (cond
           ((= v1-240 (pickup-type gun-yellow-1))
            'gun-yellow
            )
           ((= v1-240 (pickup-type gun-yellow-2))
            'gun-yellow
            )
           ((= v1-240 (pickup-type gun-yellow-3))
            'gun-yellow
            )
           ((= v1-240 (pickup-type gun-red-1))
            'gun-red
            )
           ((= v1-240 (pickup-type gun-red-2))
            'gun-red
            )
           ((= v1-240 (pickup-type gun-red-3))
            'gun-red
            )
           ((= v1-240 (pickup-type gun-blue-1))
            'gun-blue
            )
           ((= v1-240 (pickup-type gun-blue-2))
            'gun-blue
            )
           ((= v1-240 (pickup-type gun-blue-3))
            'gun-blue
            )
           ((= v1-240 (pickup-type gun-dark-1))
            'gun-dark
            )
           ((= v1-240 (pickup-type gun-dark-2))
            'gun-dark
            )
           ((= v1-240 (pickup-type gun-dark-3))
            'gun-dark
            )
           (else
             'board
             )
           )
         amount
         pickup-handle
         )
       )
     )
    (((pickup-type shield))
     (if (< 0.0 amount)
         (set! (-> this shield-pickup-time) (-> *display* game-clock frame-counter))
         )
     (give (-> this process game) 'shield amount pickup-handle)
     )
    (((pickup-type eco-red) (pickup-type eco-blue) (pickup-type eco-yellow))
     (if (= amount 0.0)
         (return (if (= (-> this eco-type) pickup)
                     (-> this eco-level)
                     0.0
                     )
                 )
         )
     (when (!= (-> this eco-type) pickup)
       (set! (-> this eco-level) 0.0)
       (set! (-> this eco-timeout) 0)
       0
       )
     (set! (-> this eco-type) (the-as int pickup))
     (let ((f0-68 (-> this eco-level)))
       (set! (-> this eco-level) 1.0)
       (when (and (= f0-68 0.0) (< 0.0 (-> this eco-level)))
         (set! (-> this eco-pickup-time) (-> *display* game-clock frame-counter))
         (send-event (-> this process) 'reset-collide)
         )
       )
     (set! (-> this eco-timeout)
           (the-as
             seconds
             (min
               (the-as int (+ (-> this eco-timeout) (* (the-as int (-> *FACT-bank* eco-single-timeout)) (the int amount))))
               (the-as
                 int
                 (+ (-> *FACT-bank* eco-full-timeout) (- (-> *display* game-clock frame-counter) (-> this eco-pickup-time)))
                 )
               )
             )
           )
     (if (>= (the-as
               int
               (- (-> this eco-timeout) (the-as uint (- (-> *display* game-clock frame-counter) (-> this eco-pickup-time))))
               )
             (the-as int (-> *FACT-bank* eco-full-timeout))
             )
         (set! (-> this eco-level) 2.0)
         )
     (when (not (and (= (handle->process pickup-handle) (handle->process (-> this eco-source)))
                     (< (- (-> *display* game-clock frame-counter) (-> this eco-source-time)) (seconds 0.5))
                     )
                )
       (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.2))
       (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 17 (seconds 0.2))
       (let ((v1-285 pickup))
         (cond
           ((= v1-285 (pickup-type eco-blue))
            (sound-play "get-blue-eco")
            )
           ((or (= v1-285 (pickup-type eco-green)) (= v1-285 (pickup-type health)))
            (sound-play "get-green-eco")
            )
           ((= v1-285 (pickup-type eco-yellow))
            (sound-play "get-yellow-eco")
            )
           ((= v1-285 (pickup-type eco-red))
            (sound-play "get-red-eco")
            )
           )
         )
       )
     (set! (-> this eco-source) pickup-handle)
     (set! (-> this eco-source-time) (-> *display* game-clock frame-counter))
     (-> this eco-level)
     )
    (else
      ((method-of-type fact-info pickup-collectable!) this pickup amount pickup-handle)
      )
    )
  )

(defmethod actor-perm ((this game-info) (arg0 actor-id))
  (let ((v1-0 (-> this perm-list)))
    (countdown (a0-1 (-> v1-0 length))
      (if (= arg0 (-> v1-0 data a0-1 aid))
          (return (-> v1-0 data a0-1))
          )
      )
    )
  (the-as entity-perm #f)
  )

(defmethod copy-perms-from-level! ((this game-info) (arg0 level))
  (let ((s5-0 (-> this perm-list))
        (s4-0 (-> arg0 bsp level entity))
        )
    (dotimes (s3-0 (-> s4-0 length))
      (let ((s2-0 (-> s4-0 data s3-0 entity extra perm)))
        (when (or (nonzero? (-> s2-0 task)) (logtest? (-> s2-0 status) (entity-perm-status save bit-13 bit-14)))
          (let ((v1-10 (actor-perm this (-> s2-0 aid))))
            (cond
              (v1-10
                (set! (-> v1-10 quad) (-> s2-0 quad))
                )
              ((< (-> s5-0 length) (-> s5-0 allocated-length))
               (set! (-> s5-0 data (-> s5-0 length) quad) (-> s2-0 quad))
               (+! (-> s5-0 length) 1)
               )
              )
            )
          )
        )
      )
    )
  0
  )

(defmethod copy-perms-to-level! ((this game-info) (arg0 level))
  (let ((s5-0 (-> arg0 bsp level entity)))
    (dotimes (s4-0 (-> s5-0 length))
      (let* ((s3-0 (-> s5-0 data s4-0 entity extra perm))
             (v1-7 (actor-perm this (-> s3-0 aid)))
             )
        (when v1-7
          (set! (-> s3-0 quad) (-> v1-7 quad))
          (update s3-0 'level (entity-perm-status bit-0 error bit-9))
          )
        )
      )
    )
  0
  )

(defmethod print ((this continue-point))
  (format #t "#<~A ~S @ #x~X>" (-> this type) (-> this name) this)
  this
  )

(defmethod debug-draw ((this continue-point))
  (add-debug-x #t (bucket-id debug-no-zbuf1) (-> this trans) (new 'static 'rgba :r #xff :a #x80))
  (add-debug-text-3d
    #t
    (bucket-id debug-no-zbuf1)
    (-> this name)
    (-> this trans)
    (font-color white)
    (new 'static 'vector2h :y 8)
    )
  (let ((t9-2 vector-z-quaternion!)
        (a0-3 (new-stack-vector0))
        (a1-2 (new 'stack-no-clear 'quaternion))
        )
    (set! (-> a1-2 x) (* 0.00003051851 (the float (-> this quat x))))
    (set! (-> a1-2 y) (* 0.00003051851 (the float (-> this quat y))))
    (set! (-> a1-2 z) (* 0.00003051851 (the float (-> this quat z))))
    (set! (-> a1-2 w) (* 0.00003051851 (the float (-> this quat w))))
    (let ((a3-2 (t9-2 a0-3 a1-2)))
      (add-debug-vector
        #t
        (bucket-id debug-no-zbuf1)
        (-> this trans)
        a3-2
        (meters 2)
        (new 'static 'rgba :r #xff :g #x80 :a #x80)
        )
      )
    )
  0
  )

(defun-debug trsq->continue-point ((arg0 trsq))
  (let ((v1-1 (level-get-target-inside *level*)))
    (format #t "~%(static-continue-point ~A ()~%" (symbol->string-debug (-> v1-1 name)))
    )
  (format #t "                       (target ~m ~m ~m " (-> arg0 trans x) (-> arg0 trans y) (-> arg0 trans z))
  (format #t "~f ~f ~f ~f)~%" (-> arg0 quat x) (-> arg0 quat y) (-> arg0 quat z) (-> arg0 quat w))
  (let ((gp-1 *math-camera*))
    (format
      #t
      "                       (camera ~m ~m ~m ~f ~f ~f "
      (-> gp-1 trans x)
      (-> gp-1 trans y)
      (-> gp-1 trans z)
      (-> gp-1 inv-camera-rot rvec x)
      (-> gp-1 inv-camera-rot rvec y)
      (-> gp-1 inv-camera-rot rvec z)
      )
    (format
      #t
      "~f ~f ~f ~f ~f ~f)~%"
      (-> gp-1 inv-camera-rot uvec x)
      (-> gp-1 inv-camera-rot uvec y)
      (-> gp-1 inv-camera-rot uvec z)
      (-> gp-1 inv-camera-rot fvec x)
      (-> gp-1 inv-camera-rot fvec y)
      (-> gp-1 inv-camera-rot fvec z)
      )
    )
  (let ((gp-2 format)
        (s5-1 #t)
        (s4-1 "                       (load '~A ")
        (v1-5 (lookup-level-info (-> *load-state* vis-nick)))
        )
    (gp-2 s5-1 s4-1 (if v1-5
                        (-> v1-5 name)
                        )
          )
    )
  (dotimes (gp-3 4)
    (let ((v1-8 (lookup-level-info (-> *load-state* want gp-3 name))))
      (if (and v1-8 (!= (-> v1-8 memory-mode) 10) (!= (-> *load-state* want gp-3 name) #f))
          (format #t "'~A '~A " (-> *load-state* want gp-3 name) (-> *load-state* want gp-3 display?))
          (format #t "#f #f ")
          )
      )
    )
  (format #t ")~%                       (sound ")
  (dotimes (gp-4 3)
    (format #t "~A " (-> *load-state* want-sound gp-4 name))
    )
  (format #t ")~%)~%")
  0
  )

(defun position->stream ((stream string) (arg1 symbol) (newline? symbol))
  (format
    stream
    "bug-report ~S ~S ~DK "
    *user*
    arg1
    (shr (* (dma-buffer-length (-> *display* frames (-> *display* last-screen) global-buf)) 16) 10)
    )
  (if newline?
      (format stream "~%")
      )
  (let* ((s4-1 format)
         (s3-1 stream)
         (s2-1 "nick ~S continue ~S ")
         (v1-9 (lookup-level-info (-> *load-state* vis-nick)))
         (a2-2 (if v1-9
                   (-> v1-9 name)
                   )
               )
         (v1-11 (-> *game-info* current-continue))
         )
    (s4-1 s3-1 s2-1 a2-2 (if v1-11
                             (-> v1-11 name)
                             )
          )
    )
  (if newline?
      (format stream "~%")
      )
  (dotimes (s4-2 10)
    (if (or (= (-> *level* level s4-2 status) 'active)
            (= (-> *level* level s4-2 status) 'alive)
            (= (-> *level* level s4-2 status) 'loaded)
            )
        (format stream "level ~D ~-8A ~-8A " s4-2 (-> *level* level s4-2 name) (-> *level* level s4-2 display?))
        (format stream "level ~D ~-8A ~-8A " s4-2 #f #f)
        )
    (if newline?
        (format stream "~%")
        )
    )
  (format stream "music ~-8S sound " (-> *setting-control* user-current music))
  (dotimes (s4-3 6)
    (format stream "~-8S " (-> *level* sound-bank s4-3 name))
    )
  (if newline?
      (format stream "~%")
      )
  (let ((v1-41 (target-pos 0)))
    (format stream "target ~m ~m ~m " (-> v1-41 x) (-> v1-41 y) (-> v1-41 z))
    )
  (if newline?
      (format stream "~%")
      )
  (let ((v1-45 (math-camera-pos)))
    (format stream "camera-trans ~m ~m ~m " (-> v1-45 x) (-> v1-45 y) (-> v1-45 z))
    )
  (if newline?
      (format stream "~%")
      )
  (let* ((a1-15 (math-camera-matrix))
         (v1-49 (matrix->quaternion (new 'stack-no-clear 'quaternion) a1-15))
         )
    (format stream "camera-rot ~f ~f ~f ~f" (-> v1-49 x) (-> v1-49 y) (-> v1-49 z) (-> v1-49 w))
    )
  (format stream "~%")
  0
  (none)
  )

(defun bug-report-display ((arg0 symbol))
  (case *bug-report-output-mode*
    (('*stdcon*)
     (when (not *progress-process*)
       (let ((s5-0
               "                                                                                                                                                                                                                                                                "
               )
             )
         (clear s5-0)
         (position->stream s5-0 arg0 #t)
         (process-spawn-function
           process
           (lambda :behavior process
             ((arg0 string))
             (suspend-for (seconds 10)
               (format *stdcon* "~S~%" arg0)
               )
             (none)
             )
           s5-0
           )
         )
       )
     )
    (('file-stream)
     (format (clear *temp-string*) "db/bug-report/bug-report-~S.txt" *user*)
     *temp-string*
     (let ((s5-2 (new 'stack 'file-stream *temp-string* 'append)))
       (file-stream-seek s5-2 0 2)
       (position->stream (the-as string s5-2) arg0 #f)
       (file-stream-close s5-2)
       )
     )
    (else
      (position->stream (the-as string #t) arg0 #f)
      )
    )
  0
  )

(defun-debug print-continues ()
  (let ((levels *level-load-list*))
    (while (not (null? levels))
      (let ((continues (-> (the-as level-load-info (-> (the-as symbol (car levels)) value)) continues)))
        (while (not (null? continues))
          (let ((continue (the-as continue-point (car continues))))
            (if (not (logtest? (-> continue flags) (continue-flags change-continue)))
                (format #t "~S~%" (-> continue name))
                )
            )
          (set! continues (cdr continues))
          )
        )
      (set! levels (cdr levels))
      )
    )
  0
  )

(defmethod print ((this game-task-info))
  (format #t "#<game-task-info ~S @ #x~X>" (-> this name) this)
  this
  )

(defmethod debug-inspect ((this game-info) (arg0 symbol))
  (local-vars
    (sv-16 int)
    (sv-24 int)
    (sv-32 int)
    (sv-40 int)
    (sv-48 int)
    (sv-56 int)
    (sv-64 string)
    (sv-80 string)
    (sv-96 string)
    (sv-112 string)
    )
  (inspect this)
  (when (or (not arg0) (= arg0 'game-task))
    (format #t "~Tgame-task:~%")
    (format #t "~T~T~-32S     intro      play  death gem skill~%" "task")
    (format #t "~T~T--------------------~%")
    (let ((game-task 2)
          (game-task-max 137)
          )
      (while (>= (the-as uint game-task-max) (the-as uint game-task))
        (when (task-complete? this (the-as game-task game-task))
          (set! sv-16 0)
          (set! sv-24 0)
          (set! sv-32 0)
          (set! sv-40 0)
          (set! sv-48 0)
          (set! sv-56 0)
          (let ((game-subtasks (-> *game-info* sub-task-list)))
            (dotimes (i (-> game-subtasks length))
              (when (nonzero? i)
                (let ((subtask (-> game-subtasks i)))
                  (when (= (-> subtask task) game-task)
                    (when (zero? sv-24)
                      (set! sv-24 (the-as int (-> subtask close-time)))
                      (set! sv-16 (the-as int (-> subtask close-time)))
                      )
                    (when (logtest? (-> subtask flags) (game-task-node-flag closed))
                      (set! sv-32 (the-as int (-> subtask close-time)))
                      (set! sv-40 (the-as int (-> subtask gem-count)))
                      (set! sv-48 (the-as int (-> subtask skill-count)))
                      )
                    (set! sv-56 (+ sv-56 (-> subtask death-count)))
                    (if (logtest? (-> subtask flags) (game-task-node-flag close-task))
                        (goto cfg-19)
                        )
                    )
                  )
                )
              )
            )
          (label cfg-19)
          (if (nonzero? (-> this task-start-time game-task))
              (set! sv-24 (max sv-24 (-> this task-start-time game-task)))
              )
          (format
            #t
            "~T~T~-32S ~6,,1f min ~6,,1f min ~3d ~3d ~3d~%"
            (game-task->string (the-as game-task game-task))
            (* 0.000055555556 (the float (- sv-24 sv-16)))
            (* 0.000055555556 (the float (- sv-32 sv-24)))
            sv-56
            sv-40
            sv-48
            )
          )
        (+! game-task 1)
        )
      )
    )
  (when (= arg0 'game-task-node)
    (let ((s4-1 (-> *game-info* sub-task-list)))
      (dotimes (s3-1 (-> s4-1 length))
        (when (nonzero? s3-1)
          (let ((s2-1 (-> s4-1 s3-1))
                (s1-1 format)
                (s0-1 #t)
                )
            (set! sv-64 "~-55S ~-16S ~S    ~A~%")
            (set! sv-80 (-> s2-1 name))
            (cond
              ((logtest? (-> s2-1 flags) (game-task-node-flag closed))
               (set! sv-96 "closed")
               )
              ((game-task-node-info-method-12 s2-1)
               (set! sv-96 "open")
               )
              (else
                (set! sv-96 "inactive")
                )
              )
            (if (task-complete? *game-info* (-> s2-1 task))
                (set! sv-112 "res")
                (set! sv-112 "   ")
                )
            (let ((t1-1 (lookup-text! *common-text* (-> s2-1 description) #f)))
              (s1-1 s0-1 sv-64 sv-80 sv-96 sv-112 t1-1)
              )
            )
          )
        )
      )
    )
  (when (or (not arg0) (= arg0 'level))
    (format #t "~Tlevel:~%")
    (format #t "~T~T~-32S death in-time   enter-time~%" "level")
    (format #t "~T~T--------------------~%")
    (dotimes (s4-2 (-> *task-level* length))
      (format
        #t
        "~T~T~-32S ~3d  ~6,,1f min  ~6,,1f min~%"
        (-> *task-level* s4-2)
        (-> this deaths-per-level s4-2)
        (* 0.000055555556 (the float (-> this task-in-times s4-2)))
        (* 0.000055555556 (the float (max 0 (+ -300000 (-> this task-enter-times s4-2)))))
        )
      )
    )
  (when (or (not arg0) (= arg0 'score))
    (format #t "~Tscore:~%")
    (format #t "~T~T--------------------~%")
    (dotimes (s4-3 18)
      (let ((v1-70 (get-game-score-ref this s4-3))
            (t9-18 format)
            (a0-26 #t)
            (a1-24 "~T~T~-32S ~8,,0f ~8,,0f ~8,,0f~%")
            (a2-22 s4-3)
            )
        (t9-18
          a0-26
          a1-24
          (cond
            ((= a2-22 7)
             "snake-total-jump-distance"
             )
            ((= a2-22 5)
             "snake-total-air-time"
             )
            ((= a2-22 10)
             "hoverboard"
             )
            ((= a2-22 12)
             "gungame-2"
             )
            ((= a2-22 17)
             "arena-training"
             )
            ((= a2-22 8)
             "snake-roll-count"
             )
            ((= a2-22 14)
             "gungame-4"
             )
            ((= a2-22 6)
             "snake-jump-distance"
             )
            ((= a2-22 13)
             "gungame-3"
             )
            ((= a2-22 4)
             "snake-air-time"
             )
            ((= a2-22 9)
             "wascity-gungame-1"
             )
            ((zero? a2-22)
             "none"
             )
            ((= a2-22 15)
             "power-game"
             )
            ((= a2-22 3)
             "snake-race"
             )
            ((= a2-22 1)
             "neo-sat-game"
             )
            ((= a2-22 16)
             "destroy-interceptors"
             )
            ((= a2-22 11)
             "gungame-1"
             )
            ((= a2-22 2)
             "turtle-race"
             )
            (else
              "*unknown*"
              )
            )
          (-> v1-70 0)
          (-> v1-70 1)
          (-> v1-70 2)
          )
        )
      )
    )
  (when (= arg0 'entity-perm)
    (format #t "~Tentity-perm:~%")
    (let ((s5-1 (-> this perm-list)))
      (dotimes (s4-4 (-> s5-1 length))
        (format #t "~T~T~`entity-perm`P~%" (-> s5-1 data s4-4))
        )
      )
    )
  this
  )

(defmethod you-suck-stage ((this game-info) (arg0 symbol) (arg1 int))
  (local-vars (v0-0 int))
  (cond
    ((logtest? (-> *game-info* secrets) (game-secrets hero-mode))
     0
     )
    ((nonzero? arg1)
     (let* ((a0-3 (-> *game-info* sub-task-list arg1))
            (a1-1 (shr (-> a0-3 suck-death-count) 5))
            (v1-7 (logand (-> a0-3 suck-death-count) 31))
            (f0-1 (fmax 0.0 (fmin 1.0 (/ (the float (- (-> a0-3 death-count) a1-1)) (the float v1-7)))))
            )
       (return (the int (* 32.0 f0-1)))
       )
     v0-0
     )
    (else
      (let ((s5-0 (-> *game-info* sub-task-list)))
        (dotimes (s4-0 (-> s5-0 length))
          (when (nonzero? s4-0)
            (let ((gp-0 (-> s5-0 s4-0)))
              (when (and (game-task-node-info-method-12 gp-0) (-> gp-0 manager) (handle->process (-> gp-0 manager manager)))
                (let ((v1-23 (level-get-target-inside *level*)))
                  (when (and v1-23 (= (-> v1-23 info taskname) (-> gp-0 level)))
                    (let* ((a0-13 (shr (-> gp-0 suck-death-count) 5))
                           (v1-30 (logand (-> gp-0 suck-death-count) 31))
                           (f0-5 (fmax 0.0 (fmin 1.0 (/ (the float (- (-> gp-0 death-count) a0-13)) (the float v1-30)))))
                           )
                      (return (the int (* 32.0 f0-5)))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      0
      )
    )
  )

(defmethod you-suck-scale ((this game-info) (arg0 symbol) (arg1 int))
  (* 0.03125 (the float (you-suck-stage this arg0 arg1)))
  )

(defmethod adjust-to-screen-flip ((this cpad-info))
  (if (and (not (paused?)) (zero? (-> this number)) (-> *setting-control* user-current player-control-override))
      (override-player-controls this)
      )
  (when (logtest? (-> *game-info* secrets) (game-secrets hflip-screen))
    (set! (-> this leftx) (- 255 (the-as int (-> this leftx))))
    (set! (-> this rightx) (- 255 (the-as int (-> this rightx))))
    )
  0
  )

(defmethod get-game-score-ref ((this game-info) (arg0 int))
  (&+ (-> this game-score data) (* (* arg0 8) 4))
  )

(defmethod game-info-method-29 ((this game-info) (arg0 int))
  (let ((gp-0 0))
    (let ((s4-0 (-> *highscore-info-array* arg0))
          (s3-0 (get-game-score-ref this arg0))
          (s5-0 (new 'stack-no-clear 'array 'int8 4))
          )
      (dotimes (v1-3 4)
        (set! (-> s5-0 v1-3) 0)
        )
      (dotimes (s2-0 8)
        (let ((f0-0 (-> s3-0 s2-0)))
          (when (!= f0-0 0.0)
            (let ((v1-9 (get-rank s4-0 f0-0)))
              (+! (-> s5-0 v1-9) 1)
              )
            )
          )
        )
      (dotimes (v1-13 4)
        (if (> (-> s5-0 v1-13) 0)
            (set! gp-0 v1-13)
            )
        )
      )
    gp-0
    )
  )

(defmethod get-highscore-rank ((this game-info) (arg0 int) (arg1 float))
  (get-rank (-> *highscore-info-array* arg0) arg1)
  )

(defmethod game-info-method-31 ((this game-info) (arg0 int) (arg1 int))
  (let ((highscore-arr (-> *highscore-info-array* arg0)))
    (case arg1
      ((1 2 3)
       (-> highscore-arr award-scores (+ arg1 -1))
       )
      (else
        (let ((f0-1 (-> (get-game-score-ref *game-info* arg0) 0)))
          (if (= f0-1 0.0)
              (set! f0-1 (-> highscore-arr gold-score))
              )
          (if (logtest? (-> highscore-arr flags) (highscore-flags time))
              (fmin f0-1 (-> highscore-arr gold-score))
              (fmax f0-1 (-> highscore-arr gold-score))
              )
          )
        )
      )
    )
  )

(defmethod get-rank ((this highscore-info) (score float))
  (let ((place 0))
    (cond
      ((logtest? (-> this flags) (highscore-flags time))
       (cond
         ((= score 0.0)
          )
         ((>= (-> this gold-score) score)
          (set! place 3)
          )
         ((>= (-> this silver-score) score)
          (set! place 2)
          )
         ((>= (-> this bronze-score) score)
          (set! place 1)
          )
         )
       )
      (else
        (cond
          ((>= score (-> this gold-score))
           (set! place 3)
           )
          ((>= score (-> this silver-score))
           (set! place 2)
           )
          ((>= score (-> this bronze-score))
           (set! place 1)
           )
          )
        )
      )
    place
    )
  )

(define *highscore-info-array*
  (new 'static 'boxed-array :type highscore-info
    (new 'static 'highscore-info)
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 100.0 500.0 1000.0))
    (new 'static 'highscore-info
      :flags (highscore-flags time hf2)
      :award-scores (new 'static 'array float 3 63000.0 58500.0 54000.0)
      )
    (new 'static 'highscore-info
      :flags (highscore-flags time hf2)
      :award-scores (new 'static 'array float 3 84000.0 81000.0 79500.0)
      )
    (new 'static 'highscore-info
      :flags (highscore-flags hf2)
      :award-scores (new 'static 'array float 3 750.0 1050.0 1350.0)
      )
    (new 'static 'highscore-info
      :flags (highscore-flags hf2)
      :award-scores (new 'static 'array float 3 3000.0 3750.0 4500.0)
      )
    (new 'static 'highscore-info
      :flags (highscore-flags hf3)
      :award-scores (new 'static 'array float 3 737280.0 819200.0 901120.0)
      )
    (new 'static 'highscore-info
      :flags (highscore-flags hf3)
      :award-scores (new 'static 'array float 3 2048000.0 2662400.0 3276800.0)
      )
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 3.0 6.0 9.0))
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 10000.0 20000.0 40000.0))
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 25000.0 50000.0 75000.0))
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 12000.0 14000.0 16000.0))
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 13000.0 15000.0 17000.0))
    (new 'static 'highscore-info :flags (highscore-flags hf1))
    (new 'static 'highscore-info :flags (highscore-flags hf1))
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 200.0 500.0 1000.0))
    (new 'static 'highscore-info :award-scores (new 'static 'array float 3 30.0 45.0 60.0))
    (new 'static 'highscore-info
      :flags (highscore-flags time hf2)
      :award-scores (new 'static 'array float 3 19500.0 16500.0 15000.0)
      )
    )
  )

(defmethod game-info-method-27 ((this game-info) (arg0 game-score) (arg1 float))
  (when (!= arg1 0.0)
    (let ((v1-3 (&+ (-> this game-score data) (* (* arg0 8) 4))))
      (cond
        ((logtest? (-> *highscore-info-array* arg0 flags) (highscore-flags time))
         (dotimes (a0-8 8)
           (when (or (= (-> (&+ v1-3 (* a0-8 4)) 0) 0.0) (< arg1 (-> (&+ v1-3 (* a0-8 4)) 0)))
             (let ((a1-9 7))
               (while (< a0-8 a1-9)
                 (set! (-> (&+ v1-3 (* a1-9 4)) 0) (-> (&+ v1-3 (* (+ a1-9 -1) 4)) 0))
                 (+! a1-9 -1)
                 )
               )
             (set! (-> (&+ v1-3 (* a0-8 4)) 0) arg1)
             (return a0-8)
             )
           )
         )
        (else
          (dotimes (a0-9 8)
            (when (< (-> (&+ v1-3 (* a0-9 4)) 0) arg1)
              (let ((a1-16 7))
                (while (< a0-9 a1-16)
                  (set! (-> (&+ v1-3 (* a1-16 4)) 0) (-> (&+ v1-3 (* (+ a1-16 -1) 4)) 0))
                  (+! a1-16 -1)
                  )
                )
              (set! (-> (&+ v1-3 (* a0-9 4)) 0) arg1)
              (return a0-9)
              )
            )
          )
        )
      )
    )
  -1
  )

(kmemopen global "game-info-tables")

(let ((gp-0 *game-info*))
  (set! (-> gp-0 task-counter) (the-as uint 1))
  (when (zero? (-> gp-0 perm-list))
    (set! (-> gp-0 perm-list) (new 'global 'entity-perm-array 4096))
    (set! (-> gp-0 perm-list length) 0)
    0
    )
  (if (zero? (-> gp-0 unknown-arr4))
      (set! (-> gp-0 unknown-arr4) (new 'global 'boxed-array uint16 1460))
      )
  (when (zero? (-> gp-0 death-pos))
    (set! (-> gp-0 death-pos) (new 'global 'vector-array 64))
    (set! (-> gp-0 death-pos length) 0)
    0
    )
  (if (zero? (-> gp-0 display-text-handle))
      (set! (-> gp-0 display-text-handle) (the-as handle #f))
      )
  (if (zero? (-> gp-0 game-score))
      (set! (-> gp-0 game-score) (new 'global 'boxed-array float 144))
      )
  (if (not (-> gp-0 current-continue))
      (set-continue! gp-0 *default-continue* #f)
      )
  (if (not (-> gp-0 last-continue))
      (set! (-> gp-0 last-continue) *default-continue*)
      )
  (when (zero? (-> gp-0 task-node-exclusive))
    (set! (-> gp-0 task-node-exclusive) (new 'global 'boxed-array uint16 32))
    (set! (-> gp-0 task-node-exclusive length) 0)
    0
    )
  (set! (-> gp-0 want-auto-save) #f)
  (set! (-> gp-0 auto-save-proc) (the-as handle #f))
  (set! (-> gp-0 auto-save-status) (mc-status-code ok))
  (set! (-> gp-0 auto-save-card) 0)
  (set! (-> gp-0 auto-save-which) -1)
  (set! (-> gp-0 pov-camera-handle) (the-as handle #f))
  (set! (-> gp-0 other-camera-handle) (the-as handle #f))
  (set! (-> gp-0 features) (game-feature
                             gun
                             gun-red-1
                             gun-red-2
                             gun-red-3
                             gun-yellow-1
                             gun-yellow-2
                             gun-yellow-3
                             gun-blue-1
                             gun-blue-2
                             gun-blue-3
                             gun-dark-1
                             gun-dark-2
                             gun-dark-3
                             board
                             sidekick
                             board-launch
                             board-zap
                             darkjak
                             darkjak-smack
                             darkjak-bomb0
                             darkjak-bomb1
                             darkjak-tracking
                             darkjak-invinc
                             lightjak
                             lightjak-regen
                             lightjak-swoop
                             lightjak-freeze
                             lightjak-shield
                             artifact-invis
                             jakc
                             lighteco
                             darkeco
                             )
        )
  (set! (-> gp-0 vehicles) (game-vehicles v-turtle v-snake v-scorpion v-toad v-fox v-rhino v-mirage v-x-ride))
  (dotimes (v1-51 2)
    (set! (-> gp-0 controller v1-51) (the-as handle #f))
    )
  (set! (-> gp-0 gun-ammo 0) (-> *FACT-bank* ammo-yellow-start))
  (set! (-> gp-0 gun-ammo 1) (-> *FACT-bank* ammo-red-start))
  (set! (-> gp-0 gun-ammo 2) (-> *FACT-bank* ammo-blue-start))
  (set! (-> gp-0 gun-ammo 3) (-> *FACT-bank* ammo-dark-start))
  (set! (-> gp-0 shield) 100.0)
  (set! (-> gp-0 score) 0.0)
  (set! (-> gp-0 score-owner) (the-as handle #f))
  (set! (-> gp-0 timer) 0)
  (set! (-> gp-0 timer-flash) #f)
  (set! (-> gp-0 timer-owner) (the-as handle #f))
  (set! (-> gp-0 counter) 0.0)
  (set! (-> gp-0 counter-flash) #f)
  (set! (-> gp-0 health-bar) 0.0)
  (set! (-> gp-0 health-bar-owner) (the-as handle #f))
  (set! (-> gp-0 wanted-flash) #f)
  (set! (-> gp-0 distance) 0.0)
  (set! (-> gp-0 health-bar-vehicle) 0.0)
  (set! (-> gp-0 dust-storm) (the-as handle #f))
  (set! (-> gp-0 current-vehicle) (vehicle-type-u8 vt27))
  )

0

(kmemclose)
