;;-*-Lisp-*-
(in-package goal)

;; name: decomp.gc
;; name in dgo: decomp
;; dgos: GAME

;; DECOMP BEGINS

(defun unpack-comp-rle ((arg0 (pointer int8)) (arg1 (pointer int8)))
  "Decompress data compressed with run-length encoding."
  (local-vars (v1-2 int) (v1-3 uint))
  (nop!)
  (loop
    (loop
      (set! v1-2 (-> arg1 0))
      (set! arg1 (&-> arg1 1))
      (b! (<= v1-2 0) cfg-5 :delay (nop!))
      (let ((a2-0 (-> arg1 0)))
        (set! arg1 (&-> arg1 1))
        (label cfg-3)
        (nop!)
        (nop!)
        (nop!)
        (nop!)
        (set! (-> arg0 0) a2-0)
        )
      (set! arg0 (&-> arg0 1))
      (b! (> v1-2 0) cfg-3 :delay (set! v1-2 (+ v1-2 -1)))
      )
    (label cfg-5)
    (b! (zero? v1-2) cfg-8 :delay (set! v1-3 (the-as uint (- v1-2))))
    (label cfg-6)
    (let ((a2-1 (-> arg1 0)))
      (set! arg1 (&-> arg1 1))
      (nop!)
      (nop!)
      (set! (-> arg0 0) a2-1)
      )
    (+! v1-3 -1)
    (b! (> (the-as int v1-3) 0) cfg-6 :delay (set! arg0 (&-> arg0 1)))
    )
  (label cfg-8)
  arg1
  )

(deftype huf-dictionary-node (structure)
  ((zero  uint16)
   (one   uint16)
   )
  )


(defun unpack-comp-huf ((arg0 (pointer uint8)) (arg1 (pointer uint8)) (arg2 uint) (arg3 huf-dictionary-node))
  "Decompress data compressed with huffman encoding."
  (local-vars (t1-1 uint) (t3-2 (pointer uint16)))
  (nop!)
  (let ((t1-0 (-> arg3 zero))
        (a2-1 (+ arg2 -1028))
        (t2-0 (-> arg3 one))
        )
    (nop!)
    (label cfg-1)
    (let ((v1-4 128))
      (nop!)
      (let ((t0-0 (-> arg1 0)))
        (set! arg1 (&-> arg1 1))
        (label cfg-2)
        (let ((t3-0 (logand t0-0 v1-4)))
          (shift-arith-right-32 v1-4 v1-4 1)
          (b! (zero? t3-0) cfg-4 :delay (set! t1-1 t1-0))
          )
        )
      (nop!)
      (set! t1-1 t2-0)
      (label cfg-4)
      (let ((t2-1 (+ t1-1 -256)))
        (let ((t3-1 (* t1-1 4)))
          (b! (< (the-as int t2-1) 0) cfg-8 :delay (set! t3-2 (the-as (pointer uint16) (+ t3-1 a2-1))))
          )
        (b! (zero? t2-1) cfg-10 :delay (set! t1-0 (-> t3-2 0)))
        )
      (b! (nonzero? v1-4) cfg-2 :delay (set! t2-0 (-> t3-2 1)))
      (b! #t cfg-1 :delay (nop!))
      (label cfg-8)
      (set! (-> arg0 0) t1-1)
      (set! arg0 (&-> arg0 1))
      (nop!)
      (set! t1-0 (-> arg3 zero))
      (b! (nonzero? v1-4) cfg-2 :delay (set! t2-0 (-> arg3 one)))
      )
    )
  (b! #t cfg-1 :delay (nop!))
  (label cfg-10)
  (nop!)
  (nop!)
  0
  (none)
  )

(defun unpack-comp-lzo ((arg0 (pointer uint8)) (arg1 (pointer uint8)))
  "Decompress data compressed with LZO encoding."
  0
  (let ((v1-1 arg0))
    (b! (>= (the-as uint 17) (-> arg1 0)) cfg-5 :delay #f)
    (let ((a2-4 (the-as int (+ (-> arg1 0) -17))))
      (set! arg1 (&-> arg1 1))
      (b! (< a2-4 4) cfg-41)
      (until (<= a2-4 0)
        (set! (-> arg0 0) (-> arg1 0))
        (set! arg0 (&-> arg0 1))
        (set! arg1 (&-> arg1 1))
        (+! a2-4 -1)
        )
      (b! #t cfg-15 :delay (nop!))
      (label cfg-5)
      (b! #t cfg-45 :delay (nop!))
      (label cfg-6)
      (let ((a2-6 (-> arg1 0)))
        (set! arg1 (&-> arg1 1))
        (b! (>= (the-as int a2-6) 16) cfg-18)
        (b! (nonzero? a2-6) cfg-12 :delay (empty-form))
        (while (zero? (-> arg1 0))
          (+! a2-6 255)
          (set! arg1 (&-> arg1 1))
          )
        (set! a2-6 (+ (-> arg1 0) 15 a2-6))
        (set! arg1 (&-> arg1 1))
        (label cfg-12)
        (set! (-> arg0 0) (-> arg1 0))
        (set! (-> arg0 1) (-> arg1 1))
        (set! (-> arg0 2) (-> arg1 2))
        (set! arg0 (&-> arg0 3))
        (set! arg1 (&-> arg1 3))
        (until (<= (the-as int a2-6) 0)
          (set! (-> arg0 0) (-> arg1 0))
          (set! arg0 (&-> arg0 1))
          (set! arg1 (&-> arg1 1))
          (+! a2-6 -1)
          )
        (label cfg-15)
        (set! a2-6 (-> arg1 0))
        (set! arg1 (&-> arg1 1))
        (b! (>= (the-as int a2-6) 16) cfg-18)
        (let ((a2-10 (the-as (pointer uint8) (&- (&- (&-> arg0 -2049) (the-as uint (/ (the-as int a2-6) 4))) (the-as uint (* (-> arg1 0) 4))))))
          (set! arg1 (&-> arg1 1))
          (set! (-> arg0 0) (-> a2-10 0))
          (set! (-> arg0 1) (-> a2-10 1))
          (set! (-> arg0 2) (-> a2-10 2))
          (set! arg0 (&-> arg0 3))
          (&-> a2-10 2)
          )
        (b! #t cfg-39 :delay (nop!))
        (b! #t cfg-43 :delay (nop!))
        (label cfg-18)
        (b! (< (the-as int a2-6) 64) cfg-20)
        (let ((a3-23
                (the-as (pointer uint8) (&- (&- (&-> arg0 -1) (the-as uint (logand (/ (the-as int a2-6) 4) 7))) (the-as uint (* (-> arg1 0) 8))))
                )
              )
          (set! arg1 (&-> arg1 1))
          (let ((a2-13 (+ (/ (the-as int a2-6) 32) -1)))
            (b! #t cfg-36 :delay (nop!))
            (label cfg-20)
            (b! (< (the-as int a2-6) 32) cfg-27)
            (set! a2-13 (the-as int (logand a2-6 31)))
            (b! (nonzero? a2-13) cfg-26 :delay (empty-form))
            (b! #t cfg-24 :delay (nop!))
            (label cfg-23)
            (+! a2-13 255)
            (set! arg1 (&-> arg1 1))
            (label cfg-24)
            (b! (zero? (-> arg1 0)) cfg-23 :delay (nop!))
            (set! a2-13 (the-as int (+ (-> arg1 0) 31 a2-13)))
            (set! arg1 (&-> arg1 1))
            (label cfg-26)
            (set! a3-23 (the-as (pointer uint8) (&- (&-> arg0 -1) (the-as uint (+ (shr (-> arg1 0) 2) (* (-> arg1 1) 64))))))
            (set! arg1 (&-> arg1 2))
            (b! #t cfg-36 :delay (nop!))
            (label cfg-27)
            (b! (< (the-as int a2-6) 16) cfg-35)
            (let ((a3-32 (the-as (pointer uint8) (&- arg0 (the-as uint (shl (logand a2-6 8) 11))))))
              (set! a2-13 (the-as int (logand a2-6 7)))
              (b! (nonzero? a2-13) cfg-33 :delay (empty-form))
              (b! #t cfg-31 :delay (nop!))
              (label cfg-30)
              (+! a2-13 255)
              (set! arg1 (&-> arg1 1))
              (label cfg-31)
              (b! (zero? (-> arg1 0)) cfg-30 :delay (nop!))
              (set! a2-13 (the-as int (+ (-> arg1 0) 7 a2-13)))
              (set! arg1 (&-> arg1 1))
              (label cfg-33)
              (let ((a3-33 (&- a3-32 (the-as uint (+ (shr (-> arg1 0) 2) (* (-> arg1 1) 64))))))
                (set! arg1 (&-> arg1 2))
                (b! (= a3-33 arg0) cfg-47 :delay (nop!))
                (set! a3-23 (&-> (the-as (pointer uint8) a3-33) -16384))
                )
              )
            (b! #t cfg-36 :delay (nop!))
            (label cfg-35)
            (let ((a2-16 (the-as (pointer uint8) (&- (&- (&-> arg0 -1) (the-as uint (/ (the-as int a2-6) 4))) (the-as uint (* (-> arg1 0) 4))))))
              (set! arg1 (&-> arg1 1))
              (set! (-> arg0 0) (-> a2-16 0))
              (set! (-> arg0 1) (-> a2-16 1))
              (set! arg0 (&-> arg0 2))
              (&-> a2-16 1)
              )
            (b! #t cfg-39 :delay (nop!))
            (label cfg-36)
            (set! (-> arg0 0) (-> a3-23 0))
            (set! (-> arg0 1) (-> a3-23 1))
            (set! arg0 (&-> arg0 2))
            (let ((a3-39 (&-> a3-23 2)))
              (until (<= (the-as int a2-13) 0)
                (set! (-> arg0 0) (-> a3-39 0))
                (set! arg0 (&-> arg0 1))
                (set! a3-39 (&-> a3-39 1))
                (+! a2-13 -1)
                )
              )
            )
          )
        (label cfg-39)
        (set! a2-4 (the-as int (logand (-> arg1 -2) 3)))
        (b! (zero? (the-as uint a2-4)) cfg-45 :delay (nop!))
        (until (<= a2-4 0)
          (label cfg-41)
          (set! (-> arg0 0) (-> arg1 0))
          (set! arg0 (&-> arg0 1))
          (set! arg1 (&-> arg1 1))
          (set! a2-4 (the-as int (+ (the-as uint a2-4) -1)))
          )
        (set! a2-6 (-> arg1 0))
        )
      )
    (set! arg1 (&-> arg1 1))
    (label cfg-43)
    (b! #t cfg-18 :delay (nop!))
    (label cfg-45)
    (b! #t cfg-6 :delay (nop!))
    (label cfg-47)
    (&- arg0 (the-as uint v1-1))
    )
  (none)
  )

(defmethod update-vis! ((this level) (arg0 level-vis-info) (arg1 uint) (arg2 (pointer uint8)))
  "Load/decompress precomputed visibility."
  (local-vars (t0-3 uint128) (sv-16 int) (sv-32 (pointer int8)))
  (let* ((a0-1 (-> arg0 from-bsp current-leaf-idx))
         (v1-1 (-> arg0 current-vis-string))
         (s3-0 (-> arg0 vis-string a0-1))
         )
    0
    (+ #x70000000 0)
    (+ 2048 #x70000000)
    (b! (!= v1-1 s3-0) cfg-8 :delay (empty-form))
    (b! (not (logtest? (vis-info-flag loading) (-> arg0 flags))) cfg-6 :delay (empty-form))
    (if (check-busy *ramdisk-rpc*)
        (return #f)
        )
    (logclear! (-> arg0 flags) (vis-info-flag loading))
    (let ((s3-1 (the-as (pointer integer) (-> this vis-buffer))))
      (b! #t cfg-16 :delay (nop!))
      (label cfg-6)
      (return #t)
      (label cfg-8)
      (when (logtest? (vis-info-flag loading) (-> arg0 flags))
        (if (check-busy *ramdisk-rpc*)
            (return #f)
            )
        (logclear! (-> arg0 flags) (vis-info-flag loading))
        )
      (set! (-> arg0 current-vis-string) s3-0)
      (b! (logtest? (vis-info-flag in-iop) (-> arg0 flags)) cfg-15 :delay (empty-form))
      (set! s3-1 (&+ arg2 s3-0))
      (b! #t cfg-16 :delay (nop!))
      (label cfg-15)
      (format 0 "ERROR: ramdisk vis for level ~A, this is not supported~%" (-> this name))
      (let ((v0-1 #f))
        (b! #t cfg-49 :delay (nop!))
        (label cfg-16)
        (let ((s2-0 (the-as int (logand (vis-info-flag
                                          dummy0
                                          dummy1
                                          dummy2
                                          dummy3
                                          dummy4
                                          dummy5
                                          dummy6
                                          dummy7
                                          dummy8
                                          dummy9
                                          dummy10
                                          dummy11
                                          dummy12
                                          dummy13
                                          dummy14
                                          dummy15
                                          dummy16
                                          dummy17
                                          dummy18
                                          dummy19
                                          dummy20
                                          dummy21
                                          dummy22
                                          dummy23
                                          dummy24
                                          dummy25
                                          dummy26
                                          dummy27
                                          dummy28
                                          )
                                        (-> arg0 flags)
                                        )
                            )
                    )
              ;; og:preserve-this
              (s1-0 (&-> (the-as (pointer int8) *fake-scratchpad-data*) 0))
              (s0-0 (the-as (pointer int8) (&+ *fake-scratchpad-data* 2048)))
              (s4-1 (-> this bsp visible-list-length))
              )
          (when (zero? (the-as vis-info-flag s2-0))
            (let ((v1-30 (/ (+ s4-1 15) 16)))
              (dotimes (a0-19 v1-30)
                (set! (-> (the-as (pointer int128) (&+ s1-0 (* a0-19 16)))) (the int128 0))
                )
              )
            (mem-copy! s1-0 (the-as (pointer uint8) s3-1) s4-1)
            )
          (while (nonzero? s2-0)
            (let ((v1-33 (logand s2-0 7)))
              (cond
                ((= v1-33 1)
                 (let ((v1-35 (/ (+ s4-1 15) 16)))
                   (dotimes (a0-23 v1-35)
                     (set! (-> (the-as (pointer int128) (&+ s1-0 (* a0-23 16)))) (the int128 0))
                     )
                   )
                 (set! sv-16 (-> this bsp extra-vis-list-length))
                 (set! sv-32 (&+ s1-0 (- s4-1 sv-16)))
                 (let ((v1-45 (unpack-vis (-> this bsp drawable-trees) s1-0 (the-as (pointer int8) s3-1))))
                   (dotimes (a0-25 sv-16)
                     (let ((a1-9 (-> v1-45 0)))
                       (set! v1-45 (&-> v1-45 1))
                       (set! (-> sv-32 0) a1-9)
                       )
                     (set! sv-32 (&-> sv-32 1))
                     )
                   )
                 #f
                 )
                ((= v1-33 2)
                 (unpack-comp-rle s1-0 (the-as (pointer int8) s3-1))
                 )
                ((= v1-33 3)
                 (unpack-comp-huf
                   (the-as (pointer uint8) s1-0)
                   (the-as (pointer uint8) s3-1)
                   (-> arg0 dictionary)
                   (the-as huf-dictionary-node (+ (-> arg0 dictionary) (-> arg0 dictionary-length) -4))
                   )
                 )
                ((= v1-33 4)
                 (unpack-comp-lzo (the-as (pointer uint8) s1-0) (the-as (pointer uint8) s3-1))
                 )
                )
              )
            (set! s3-1 s1-0)
            (set! s1-0 s0-0)
            (set! s0-0 (the-as (pointer int8) s3-1))
            (shift-arith-right-32 s2-0 s2-0 3)
            )
          (let ((s2-1 (the-as (pointer uint8) s3-1))
                (s1-1 (-> this bsp all-visible-list))
                (v1-51 #f)
                )
            (dotimes (s0-1 s4-1)
              (when (!= (logand (-> s2-1 0) (-> s1-1 0)) (-> s2-1 0))
                (format #t "ERROR: illegal vis bits set [byte ~X] ~X -> ~X~%" s0-1 (-> s2-1 0) (-> s1-1 0))
                (set! v1-51 #t)
                )
              (set! s2-1 (&-> s2-1 1))
              (set! s1-1 (&-> s1-1 1))
              )
            (when v1-51
              (format #t "src = #x~x dest = #x~x  ~s  ~s~%" s3-1 (-> arg0 vis-bits) (-> arg0 level) (-> arg0 from-level))
              (format #t "leaf-index = ~d~%" (-> arg0 from-bsp current-leaf-idx))
              0
              )
            )
          (let ((v1-55 s3-1)
                (a0-42 (the-as object (-> arg0 vis-bits)))
                (a1-22 (the-as (pointer uinteger) (-> this bsp all-visible-list)))
                (a2-11 (/ (+ s4-1 15) 16))
                )
            (dotimes (a3-6 a2-11)
              (let ((t0-2 (-> (the-as (pointer uint128) v1-55) 0))
                    (t1-1 (-> (the-as (pointer uint128) a1-22) 0))
                    )
                (.pand t0-3 t0-2 t1-1)
                )
              (set! (-> (the-as (pointer uint128) a0-42) 0) t0-3)
              (set! a0-42 (+ (the-as uint a0-42) 16))
              (set! v1-55 (&-> (the-as (pointer uint8) v1-55) 16))
              (set! a1-22 (&-> (the-as (pointer uint8) a1-22) 16))
              )
            )
          )
        (set! v0-1 #t)
        (label cfg-49)
        v0-1
        )
      )
    )
  )

;; WARN: Return type mismatch int vs (pointer uint8).
(defun pack-comp-rle ((arg0 (pointer uint8)) (arg1 (pointer uint8)) (arg2 int) (arg3 int))
  "Compress data, used for map mask stuff."
  (let ((s4-0 0))
    0
    (while (and (> arg2 0) (< (+ s4-0 131) arg3))
      (cond
        ((= (-> arg1 0) (-> arg1 1))
         (let ((v1-2 (-> arg1 0)))
           (set! arg1 (&-> arg1 2))
           (let ((a0-2 2))
             (+! arg2 -2)
             (while (> arg2 0)
               (cond
                 ((= v1-2 (-> arg1 0))
                  (+! a0-2 1)
                  (set! arg1 (&-> arg1 1))
                  (+! arg2 -1)
                  (if (>= a0-2 128)
                      (goto cfg-12)
                      )
                  )
                 (else
                   (goto cfg-12)
                   )
                 )
               )
             (label cfg-12)
             (set! (-> arg0 0) (the-as uint (+ a0-2 -1)))
             )
           (set! (-> arg0 1) v1-2)
           )
         (set! arg0 (&-> arg0 2))
         (+! s4-0 2)
         )
        (else
          (let ((a0-4 arg1)
                (v1-4 1)
                )
            (set! arg1 (&-> arg1 1))
            (+! arg2 -1)
            (while (< 1 arg2)
              (when (and (= (-> arg1 0) (-> arg1 1)) (< 2 arg2))
                (if (= (-> arg1 0) (-> arg1 2))
                    (goto cfg-26)
                    )
                )
              (+! v1-4 1)
              (set! arg1 (&-> arg1 1))
              (+! arg2 -1)
              (if (>= v1-4 127)
                  (goto cfg-26)
                  )
              )
            (label cfg-26)
            (when (= arg2 1)
              (+! v1-4 1)
              (set! arg1 (&-> arg1 1))
              (+! arg2 -1)
              )
            (set! (-> arg0 0) (the-as uint (- v1-4)))
            (let ((a1-21 (&-> arg0 1))
                  (a2-4 (+ s4-0 1))
                  )
              (dotimes (t0-0 v1-4)
                (set! (-> a1-21 t0-0) (-> a0-4 t0-0))
                )
              (set! arg0 (&+ a1-21 v1-4))
              (set! s4-0 (+ a2-4 v1-4))
              )
            )
          )
        )
      )
    (if (< arg3 (+ s4-0 131))
        (format 0 "(GOMI) Warning: May have run out of bigmap bit mask compression memory~%")
        )
    (when (= arg2 1)
      (set! (-> arg0 0) (the-as uint -1))
      (set! (-> arg0 1) (-> arg1 0))
      (set! arg0 (&-> arg0 2))
      (+! s4-0 2)
      (&-> arg1 1)
      )
    (set! (-> arg0 0) (the-as uint 0))
    (&-> arg0 1)
    (the-as (pointer uint8) (+ s4-0 1))
    )
  )
