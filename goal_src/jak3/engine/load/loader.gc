;;-*-Lisp-*-
(in-package goal)

;; name: loader.gc
;; name in dgo: loader
;; dgos: GAME

(define-extern art-group-load-check (function string kheap int art-group))

;; +++loader:spooler-flags
(defenum spooler-flags
  :bitfield #t
  :type uint32
  (blackout-on-stall)
  )
;; ---loader:spooler-flags

;; DECOMP BEGINS

(defmethod mem-usage ((this subtitle-range) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 74 (-> usage length)))
  (set! (-> usage data 73 name) "subtitle")
  (+! (-> usage data 73 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 73 used) v1-6)
    (+! (-> usage data 73 total) (logand -16 (+ v1-6 15)))
    )
  this
  )


;; WARN: Return type mismatch symbol vs load-dir.
(defmethod mem-usage ((this load-dir) (usage memory-usage-block) (flags int))
  (set! (-> usage length) (max 86 (-> usage length)))
  (set! (-> usage data 85 name) "array")
  (+! (-> usage data 85 count) 1)
  (let ((v1-6 (asize-of this)))
    (+! (-> usage data 85 used) v1-6)
    (+! (-> usage data 85 total) (logand -16 (+ v1-6 15)))
    )
  (set! (-> usage length) (max 86 (-> usage length)))
  (set! (-> usage data 85 name) "array")
  (set! (-> usage data 85 count) (-> usage data 85 count))
  (let ((v1-15 (asize-of (-> this string-array))))
    (+! (-> usage data 85 used) v1-15)
    (+! (-> usage data 85 total) (logand -16 (+ v1-15 15)))
    )
  (set! (-> usage length) (max 86 (-> usage length)))
  (set! (-> usage data 85 name) "array")
  (set! (-> usage data 85 count) (-> usage data 85 count))
  (let ((v1-24 (asize-of (-> this data-array))))
    (+! (-> usage data 85 used) v1-24)
    (+! (-> usage data 85 total) (logand -16 (+ v1-24 15)))
    )
  (dotimes (s3-0 (-> this data-array length))
    (mem-usage (-> this data-array s3-0) usage flags)
    )
  (the-as load-dir #f)
  )

(defmethod load-to-heap-by-name ((this load-dir-art-group) (arg0 string) (arg1 symbol) (arg2 kheap) (arg3 int))
  (let ((s5-0 (-> this string-array)))
    (dotimes (s3-0 (-> s5-0 length))
      (when (string= arg0 (-> s5-0 s3-0))
        (when (= arg1 'reload)
          (let ((v1-5 (art-group-load-check arg0 arg2 arg3)))
            (if v1-5
                (set! (-> this art-group-array s3-0) v1-5)
                )
            )
          )
        (return (-> this art-group-array s3-0))
        )
      )
    (when (= arg1 'load)
      (let ((v0-2 (art-group-load-check arg0 arg2 arg3)))
        (when v0-2
          (set! (-> s5-0 (-> s5-0 length)) arg0)
          (set! (-> this art-group-array (-> s5-0 length)) v0-2)
          (+! (-> s5-0 length) 1)
          (+! (-> this art-group-array length) 1)
          )
        v0-2
        )
      )
    )
  )

(defmethod set-loaded-art ((this load-dir-art-group) (arg0 art-group))
  (let ((s4-0 (-> this string-array)))
    (dotimes (s3-0 (-> s4-0 length))
      (when (string= (-> arg0 name) (-> s4-0 s3-0))
        (set! (-> this art-group-array s3-0) arg0)
        (set! arg0 (-> this art-group-array s3-0))
        (goto cfg-7)
        )
      )
    (set! (-> s4-0 (-> s4-0 length)) (-> arg0 name))
    (set! (-> this art-group-array (-> s4-0 length)) arg0)
    (+! (-> s4-0 length) 1)
    )
  (+! (-> this art-group-array length) 1)
  (label cfg-7)
  arg0
  )

(defun drawable-load ((arg0 drawable) (arg1 kheap))
  ;; og:preserve-this
  ; (local-vars (sp-0 pointer))
  (cond
    ((type? arg0 string)
     ; (the-as none sp-0)
     ; (if (< (the-as uint sp-0) (the-as uint *stack-top*))
     ;     (set! sp-0 (&+ *kernel-sp* -1024))
     ;     )
     (let ((s5-1 (the-as drawable (loado (the-as string arg0) arg1))))
       (if (and s5-1 (type? s5-1 drawable))
           (login s5-1)
           )
       )
     )
    ((type? arg0 drawable)
     (login arg0)
     )
    )
  )

(defun art-load ((arg0 string) (arg1 kheap))
  ;; og:preserve-this
  ; (local-vars (sp-0 pointer))
  ; (the-as none sp-0)
  ; (if (< (the-as uint sp-0) (the-as uint *stack-top*))
  ;     (set! sp-0 (&+ *kernel-sp* -1024))
  ;     )
  (let ((s5-0 (the-as art (loado arg0 arg1))))
    (if (type? s5-0 art)
        (login s5-0)
        (the-as art #f)
        )
    )
  )

(defun art-group-load-check ((arg0 string) (arg1 kheap) (arg2 int))
  ;; og:preserve-this
  ; (local-vars (sp-0 pointer))
  (when *debug-segment*
    ; (the-as none sp-0)
    ; (if (< (the-as uint sp-0) (the-as uint *stack-top*))
    ;     (set! sp-0 (&+ *kernel-sp* -1024))
    ;     )
    (let ((s3-1 (the-as art-group (loado (make-file-name (file-kind art-group) arg0 arg2 #f) arg1))))
      (cond
        ((not s3-1)
         (format 0 "ERROR: art-group ~A is not a valid file.~%" arg0)
         (the-as art-group #f)
         )
        ((not (type? s3-1 art-group))
         (format 0 "ERROR: art-group ~A is not a art-group.~%" arg0)
         (the-as art-group #f)
         )
        ((not (file-info-correct-version? (-> s3-1 info) (file-kind art-group) arg2))
         (the-as art-group #f)
         )
        (else
          (login s3-1)
          )
        )
      )
    )
  )

(defmethod print ((this external-art-buffer))
  (format
    #t
    "#<~A ~S ~D ~A @ #x~X>"
    (-> this type)
    (-> this pending-load-file)
    (-> this pending-load-file-part)
    (-> this status)
    this
    )
  this
  )

(defun external-art-buffer-init ((arg0 external-art-buffer))
  (let ((v1-0 (-> arg0 heap)))
    (set! (-> v1-0 base) (the-as pointer (+ #x84000 (* #x3dc00 (-> arg0 index)))))
    (set! (-> v1-0 current) (-> v1-0 base))
    (set! (-> v1-0 top-base) (&+ (-> v1-0 base) #x3dc00))
    (set! (-> v1-0 top) (-> v1-0 top-base))
    )
  0
  )

(defmethod set-pending-file ((this external-art-buffer) (arg0 string) (arg1 int) (arg2 handle) (arg3 float))
  (set! (-> this pending-load-file) arg0)
  (set! (-> this pending-load-file-part) arg1)
  (set! (-> this pending-load-file-owner) arg2)
  (set! (-> this pending-load-file-priority) arg3)
  0
  )

(defmethod unlock! ((this external-art-buffer))
  (set! (-> this locked?) #f)
  0
  )

(defmethod inactive? ((this external-art-buffer))
  (!= (-> this status) 'active)
  )

(defmethod file-status ((this external-art-buffer) (arg0 string) (arg1 int))
  (when (and (name= (-> this pending-load-file) arg0) (= (-> this pending-load-file-part) arg1))
    (if (and (name= (-> this load-file) arg0) (= (-> this load-file-part) arg1))
        (-> this status)
        'pending
        )
    )
  )

(defmethod link-art-to-master ((this art-group))
  (when this
    (countdown (s5-0 (-> this length))
      (let* ((s3-0 (-> this data s5-0))
             (s4-0 (if (type? s3-0 art-element)
                       s3-0
                       )
                   )
             (s2-0 #f)
             )
        (when s4-0
          (let ((s3-1 11))
            (while (begin (label cfg-24) (nonzero? s3-1))
              (+! s3-1 -1)
              (let ((v1-8 (get-art-group-by-name (-> *level* level s3-1) (-> s4-0 master-art-group-name))))
                (when v1-8
                  (countdown (a0-5 (-> v1-8 length))
                    (if (= (-> v1-8 data a0-5) s4-0)
                        (goto cfg-24)
                        )
                    )
                  (cond
                    ((and (< (-> s4-0 master-art-group-index) (-> v1-8 length))
                          (not (-> v1-8 data (-> s4-0 master-art-group-index)))
                          )
                     (set! (-> v1-8 data (-> s4-0 master-art-group-index)) s4-0)
                     (set! s2-0 #t)
                     )
                    (else
                      (countdown (a0-17 (-> v1-8 length))
                        (when (not (-> v1-8 data a0-17))
                          (set! (-> v1-8 data a0-17) s4-0)
                          (set! s2-0 #t)
                          (goto cfg-24)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          (if (not s2-0)
              (format 0 "ERROR: ~A could not find a master slot to link for ~A.~%" (-> this name) s4-0)
              )
          )
        )
      )
    )
  this
  )

(defmethod unlink-art-to-master ((this art-group))
  (when this
    (countdown (s5-0 (-> this length))
      (let* ((s3-0 (-> this data s5-0))
             (s4-0 (if (type? s3-0 art-element)
                       s3-0
                       )
                   )
             (s3-1 #f)
             )
        (when s4-0
          (let ((s2-0 11))
            (while (begin (label cfg-13) (nonzero? s2-0))
              (+! s2-0 -1)
              (let ((v1-8 (get-art-group-by-name (-> *level* level s2-0) (-> s4-0 master-art-group-name))))
                (when v1-8
                  (countdown (a0-5 (-> v1-8 length))
                    (when (= s4-0 (-> v1-8 data a0-5))
                      (set! (-> v1-8 data a0-5) #f)
                      (set! s3-1 #t)
                      (goto cfg-13)
                      )
                    )
                  )
                )
              )
            )
          (if (not s3-1)
              (format 0 "ERROR: ~A could not find a master slot to unlink for ~A.~%" (-> this name) s4-0)
              )
          )
        )
      )
    )
  0
  )

(defmethod link-file ((this external-art-buffer) (arg0 art-group))
  (when arg0
    (link-art-to-master arg0)
    (set! (-> this art-group) arg0)
    )
  arg0
  )

(defmethod unlink-file ((this external-art-buffer) (arg0 art-group))
  (when arg0
    (unlink-art-to-master arg0)
    (set! (-> this art-group) #f)
    )
  0
  )

;; WARN: Found some very strange gotos. Check result carefully, this is not well tested.
(defmethod update ((this external-art-buffer))
  (when (or (not (name= (-> this pending-load-file) (-> this load-file)))
            (!= (-> this pending-load-file-part) (-> this load-file-part))
            )
    (when (not (handle->process (-> this pending-load-file-owner)))
      (set! (-> this pending-load-file) #f)
      (set! (-> this pending-load-file-part) -1)
      (set! (-> this pending-load-file-owner) (the-as handle #f))
      (set! (-> this pending-load-file-priority) 100000000.0)
      )
    (when (= (-> this status) 'initialize)
      ((-> this init-heap) this)
      (set! (-> this status) 'inactive)
      )
    (cond
      ((-> this load-file)
       (if (= (-> this status) 'loading)
           (str-load-cancel)
           )
       (set! (-> this load-file) #f)
       (set! (-> this load-file-part) -1)
       (set! (-> this load-file-owner) (the-as handle #f))
       (set! (-> this load-file-priority) 100000000.0)
       )
      (else
        (set! (-> this load-file) (-> this pending-load-file))
        (set! (-> this load-file-part) (-> this pending-load-file-part))
        (set! (-> this load-file-owner) (-> this pending-load-file-owner))
        (set! (-> this load-file-priority) (-> this pending-load-file-priority))
        )
      )
    )
  (label cfg-18)
  (cond
    ((-> this load-file)
     (case (-> this status)
       (('active 'reserved)
        )
       (('error)
        (set! (-> this status) 'inactive)
        (set! (-> this load-file) #f)
        (set! (-> this load-file-part) -1)
        (set! (-> this load-file-owner) (the-as handle #f))
        (set! (-> this load-file-priority) 100000000.0)
        (set! (-> this pending-load-file) #f)
        (set! (-> this pending-load-file-part) -1)
        (set! (-> this pending-load-file-owner) (the-as handle #f))
        (set! (-> this pending-load-file-priority) 100000000.0)
        (set! (-> this art-group) #f)
        )
       (('inactive)
        (let ((v1-31 (-> this heap)))
          (set! (-> v1-31 current) (-> v1-31 base))
          )
        (cond
          ((string= (-> this load-file) "reserved")
           (cond
             ((-> *art-control* reserve-buffer)
              (format 0 "ERROR: trying double reserve ~A when ~A is reserved~%" this (-> *art-control* reserve-buffer))
              )
             (else
               (set! (-> this status) 'reserved)
               (set! (-> *art-control* reserve-buffer) this)
               )
             )
           )
          ((and (!= (-> *level* loading-level) (-> *level* level-default))
                (or (< 81920.0 (-> this load-file-priority))
                    (logtest? (-> *level* loading-level info level-flags) (level-flags external))
                    )
                )
           )
          ((let ((v1-46 (logand -64 (&+ (-> this heap current) 63))))
             (str-load (-> this load-file) (-> this load-file-part) v1-46 (&- (-> this heap top) (the-as uint v1-46)))
             )
           (set! (-> this status) 'loading)
           0
           )
          )
        )
       (('loading)
        (case (str-load-status (&-> this len))
          (('error)
           (set! (-> this status) 'error)
           )
          (('busy)
           )
          (else
            (set! (-> this buf) (logand -64 (&+ (-> this heap current) 63)))
            (set! (-> this status) 'loaded)
            (goto cfg-18)
            )
          )
        )
       (('loaded)
        (let ((a0-39 (-> this buf)))
          (cond
            ((-> this login?)
             (set! (-> this art-group)
                   (the-as art-group (link a0-39 (-> this load-file data) (-> this len) (-> this heap) (if *print-login*
                                                                                                           8
                                                                                                           0
                                                                                                           )
                                           )
                           )
                   )
             (let ((s4-0 (-> this art-group))
                   (s3-0 (-> this load-file))
                   )
               (cond
                 ((not s4-0)
                  (format 0 "ERROR: art-group ~A part ~D is not a valid file.~%" s3-0 (-> this load-file-part))
                  (set! (-> this status) 'error)
                  )
                 ((not (type? s4-0 art-group))
                  (format 0 "ERROR: art-group ~A part ~D is not a art-group.~%" s3-0 (-> this load-file-part))
                  (set! (-> this status) 'error)
                  )
                 ((not (file-info-correct-version? (-> s4-0 info) (file-kind art-group) 0))
                  (set! (-> this status) 'error)
                  )
                 (else
                   (login s4-0)
                   (set! (-> this status) 'locked)
                   )
                 )
               )
             )
            (else
              (set! (-> this status) 'locked)
              (set! (-> this art-group) (the-as art-group a0-39))
              )
            )
          )
        )
       (('locked)
        (when (and (not (-> this locked?)) (handle->process (-> this load-file-owner)))
          (if (-> this login?)
              (link-file this (-> this art-group))
              )
          (if (-> this other)
              (set! (-> this other locked?) #t)
              )
          (set! (-> this status) 'active)
          (goto cfg-18)
          )
        )
       )
     )
    (else
      (case (-> this status)
        (('initialize)
         )
        (('reserved)
         (cond
           ((= (-> *art-control* reserve-buffer) this)
            (set! (-> *art-control* reserve-buffer) #f)
            (set! (-> this status) 'inactive)
            )
           (else
             (format 0 "ERROR: trying tro free ~A when ~A is reserved~%" this (-> *art-control* reserve-buffer))
             )
           )
         )
        (('active)
         (if (-> this login?)
             (unlink-file this (-> this art-group))
             )
         (let ((v1-89 (-> this heap)))
           (set! (-> v1-89 current) (-> v1-89 base))
           )
         (set! (-> this art-group) #f)
         (set! (-> this status) 'inactive)
         (when (and (-> this other) (-> this other locked?))
           (unlock! (-> this other))
           (update (-> this other))
           )
         )
        (else
          (let ((v1-99 (-> this heap)))
            (set! (-> v1-99 current) (-> v1-99 base))
            )
          (set! (-> this art-group) #f)
          (set! (-> this status) 'inactive)
          )
        )
      )
    )
  0
  )

(define *preload-spool-anims* #t)

(defmethod file-status ((this external-art-control) (arg0 string) (arg1 int))
  (dotimes (s3-0 2)
    (let ((v1-3 (file-status (-> this buffer s3-0) arg0 arg1)))
      (if v1-3
          (return v1-3)
          )
      )
    )
  #f
  )

(defmethod update ((this external-art-control) (arg0 symbol))
  (if (nonzero? (-> this reserve-buffer-count))
      (spool-push this "reserved" 0 *dproc* (if (-> this reserve-buffer)
                                                -110.0
                                                -0.5
                                                )
                  )
      )
  (dotimes (v1-5 2)
    (set! (-> this buffer v1-5 frame-lock) #f)
    )
  (dotimes (v1-8 3)
    (set! (-> this rec v1-8 anim-name) #f)
    )
  (dotimes (s4-0 2)
    (let ((s3-0 (-> this rec s4-0)))
      (when (-> s3-0 name)
        (dotimes (s2-0 2)
          (when (and (file-status (-> this buffer s2-0) (-> s3-0 name) (-> s3-0 parts))
                     (not (-> this buffer s2-0 frame-lock))
                     )
            (set! (-> this buffer s2-0 frame-lock) #t)
            (set! (-> s3-0 anim-name) (the-as string (-> this buffer s2-0)))
            (set! (-> this buffer s2-0 pending-load-file-owner) (-> s3-0 owner))
            (set! (-> this buffer s2-0 load-file-owner) (-> s3-0 owner))
            (set! (-> this buffer s2-0 pending-load-file-priority) (-> s3-0 priority))
            (set! (-> this buffer s2-0 load-file-priority) (-> s3-0 priority))
            (goto cfg-24)
            )
          )
        )
      )
    (label cfg-24)
    )
  (dotimes (s4-1 2)
    (let ((s3-1 (-> this rec s4-1)))
      (when (and (-> s3-1 name) (not (-> s3-1 anim-name)))
        (if (and (not *preload-spool-anims*) (>= (-> s3-1 priority) 0.0))
            (goto cfg-46)
            )
        (dotimes (s2-1 2)
          (when (not (-> this buffer s2-1 frame-lock))
            (set! (-> this buffer s2-1 frame-lock) #t)
            (set-pending-file (-> this buffer s2-1) (-> s3-1 name) (-> s3-1 parts) (-> s3-1 owner) (-> s3-1 priority))
            (set! (-> s3-1 anim-name) (the-as string (-> this buffer s2-1)))
            (goto cfg-46)
            )
          )
        )
      )
    (label cfg-46)
    )
  (when (not (-> this reserve-buffer))
    (let ((s4-2 (the-as external-art-buffer (-> this rec 0 anim-name))))
      (if (and s4-2
               (-> s4-2 locked?)
               (not (string= (-> s4-2 pending-load-file) "reserved"))
               (not (string= (-> s4-2 other pending-load-file) "reserved"))
               )
          (set-pending-file (-> s4-2 other) (the-as string #f) -1 (the-as handle #f) 100000000.0)
          )
      )
    )
  (dotimes (s4-3 2)
    (update (-> this buffer s4-3))
    )
  (let ((s4-4 (-> this queue-stream)))
    (set! (-> s4-4 length) 0)
    (dotimes (s3-2 3)
      (when (-> this rec s3-2 name)
        (mem-copy! (&-> (-> s4-4 (-> s4-4 length)) type) (&-> (-> this rec s3-2) type) 44)
        (+! (-> s4-4 length) 1)
        )
      )
    )
  (when (and arg0 *display-art-control*)
    (dotimes (s5-1 3)
      (let ((t9-8 format)
            (a0-27 *stdcon*)
            (a1-8 "rec ~d ~S ~D ~f ~A~%")
            (a2-5 s5-1)
            (a3-3 (-> this rec s5-1 name))
            (t0-3 (-> this rec s5-1 parts))
            (t1-0 (-> this rec s5-1 priority))
            (v1-121 (handle->process (-> this rec s5-1 owner)))
            )
        (t9-8 a0-27 a1-8 a2-5 a3-3 t0-3 t1-0 (if v1-121
                                                 (-> v1-121 name)
                                                 )
              )
        )
      )
    (dotimes (s5-2 2)
      (let ((t9-9 format)
            (a0-28 *stdcon*)
            (a1-9 "buf ~d ~C ~S ~D ~A ~A~%")
            (a2-6 s5-2)
            (a3-4 (if (-> this buffer s5-2 locked?)
                      108
                      32
                      )
                  )
            (t0-4 (-> this buffer s5-2 pending-load-file))
            (t1-1 (-> this buffer s5-2 pending-load-file-part))
            (t2-5 (-> this buffer s5-2 status))
            (v1-142 (handle->process (-> this buffer s5-2 pending-load-file-owner)))
            )
        (t9-9 a0-28 a1-9 a2-6 a3-4 t0-4 t1-1 t2-5 (if v1-142
                                                      (-> v1-142 name)
                                                      )
              )
        )
      )
    (format *stdcon* " a: ~S~%" (-> this active-stream))
    )
  0
  )

(defmethod none-reserved? ((this external-art-control))
  (zero? (-> this reserve-buffer-count))
  )

(defmethod reserve-alloc ((this external-art-control))
  (cond
    ((or (nonzero? (-> this dma-reserve-buffer-count)) (= *master-mode* 'progress))
     (set! (-> this dma-reserve-buffer-count) 1)
     (when (and (-> *bigmap* drawing-flag) (zero? (-> *blit-displays-work* count-down)))
       (let ((v1-8 (-> this dma-reserve-heap)))
         (set! (-> v1-8 base) (logand -64 (&+ (&+ (-> *display* frames 1 global-buf end) -252992) 63)))
         (set! (-> v1-8 current) (-> v1-8 base))
         (set! (-> v1-8 top-base) (&+ (-> v1-8 base) #x3dc00))
         (set! (-> v1-8 top) (-> v1-8 top-base))
         )
       (set! (-> *display* frames 1 global-buf end) (-> this dma-reserve-heap base))
       (-> this dma-reserve-heap)
       )
     )
    (else
      (set! (-> this reserve-buffer-count) 1)
      (if (and (-> this reserve-buffer) (not (check-busy *load-str-rpc*)))
          (-> this reserve-buffer heap)
          )
      )
    )
  )

(defmethod reserve-free ((this external-art-control) (arg0 kheap))
  (cond
    ((nonzero? (-> this dma-reserve-buffer-count))
     (set! (-> this dma-reserve-buffer-count) 0)
     (let ((v1-3 (-> *display* frames 1 global-buf)))
       (set! (-> v1-3 end) (the-as pointer (+ (+ (-> v1-3 allocated-length) 28) (the-as int v1-3))))
       )
     )
    ((and (zero? (-> this reserve-buffer-count)) (zero? (-> this dma-reserve-buffer-count)))
     (format 0 "ERROR: illegal attempt to free a buffer #x~X which had not been reserved (none reserved).~%" arg0)
     )
    ((not (-> this reserve-buffer))
     (set! (-> this reserve-buffer-count) 0)
     0
     )
    ((= (-> this reserve-buffer heap) arg0)
     (set-pending-file (-> this reserve-buffer) (the-as string #f) -1 (the-as handle #f) 100000000.0)
     (update (-> this reserve-buffer))
     (set! (-> this reserve-buffer-count) 0)
     0
     )
    (else
      (format 0 "ERROR: illegal attempt to free a buffer #x~X which had not been reserved (buffer unknown).~%" arg0)
      )
    )
  0
  )

(defmethod clear-rec ((this external-art-control))
  (dotimes (v1-0 3)
    (set! (-> this rec v1-0 type) spool-anim)
    (set! (-> this rec v1-0 name) #f)
    (set! (-> this rec v1-0 priority) 100000000.0)
    (set! (-> this rec v1-0 owner) (the-as handle #f))
    )
  (set! (-> this frame-mask) (the-as uint (-> *setting-control* user-current process-mask)))
  0
  )

(defmethod spool-push ((this external-art-control) (arg0 string) (arg1 int) (arg2 process) (arg3 float))
  (when (and (= arg3 -99.0) arg2)
    (let ((a0-2 (target-pos 0)))
      (set! arg3 (vector-vector-distance a0-2 (-> (the-as process-drawable arg2) root trans)))
      )
    )
  (cond
    ((and (= arg1 (-> this rec 0 parts)) (name= arg0 (-> this rec 0 name)))
     (if (>= arg3 (-> this rec 0 priority))
         (return (the-as int #f))
         )
     (mem-copy! (&-> (-> this rec) 0 type) (&-> (-> this rec 1) type) 44)
     (mem-copy! (&-> (-> this rec 1) type) (&-> (-> this rec 2) type) 44)
     (set! (-> this rec 2 name) #f)
     (set! (-> this rec 2 owner) (the-as handle #f))
     )
    ((and (= arg1 (-> this rec 1 parts)) (name= arg0 (-> this rec 1 name)))
     (if (>= arg3 (-> this rec 1 priority))
         (return (the-as int #f))
         )
     (mem-copy! (&-> (-> this rec 1) type) (&-> (-> this rec 2) type) 44)
     (set! (-> this rec 2 name) #f)
     (set! (-> this rec 2 owner) (the-as handle #f))
     )
    ((and (= arg1 (-> this rec 2 parts)) (name= arg0 (-> this rec 2 name)))
     (if (>= arg3 (-> this rec 2 priority))
         (return (the-as int #f))
         )
     (set! (-> this rec 2 name) #f)
     (set! (-> this rec 2 owner) (the-as handle #f))
     )
    )
  (cond
    ((< arg3 (-> this rec 0 priority))
     (mem-copy! (&-> (-> this rec 2) type) (&-> (-> this rec 1) type) 44)
     (mem-copy! (&-> (-> this rec 1) type) (&-> (-> this rec) 0 type) 44)
     (set! (-> this rec 0 name) arg0)
     (set! (-> this rec 0 parts) arg1)
     (set! (-> this rec 0 priority) arg3)
     (set! (-> this rec 0 owner) (process->handle arg2))
     )
    ((< arg3 (-> this rec 1 priority))
     (mem-copy! (&-> (-> this rec 2) type) (&-> (-> this rec 1) type) 44)
     (set! (-> this rec 1 name) arg0)
     (set! (-> this rec 1 parts) arg1)
     (set! (-> this rec 1 priority) arg3)
     (set! (-> this rec 1 owner) (process->handle arg2))
     )
    ((< arg3 (-> this rec 2 priority))
     (set! (-> this rec 2 name) arg0)
     (set! (-> this rec 2 parts) arg1)
     (set! (-> this rec 2 priority) arg3)
     (set! (-> this rec 2 owner) (process->handle arg2))
     )
    )
  0
  )

(deftype spooler-block (basic)
  ((anim              spool-anim)
   (idle              art-joint-anim)
   (exit              art-joint-anim)
   (break-func        (function process-drawable object))
   (flags             spooler-flags)
   (part              int32)
   (part-audio-start  float)
   (old-status        uint16)
   (old-pos           int32)
   (good-time         time-frame)
   (old-time          time-frame)
   (good-count        int32)
   (sid               sound-id)
   (real-start-time   time-frame)
   (paused?           symbol)
   )
  )


(defbehavior ja-play-spooled-anim process-drawable ((arg0 spool-anim)
                                          (arg1 art-joint-anim)
                                          (arg2 art-joint-anim)
                                          (arg3 (function process-drawable symbol))
                                          (arg4 spooler-flags)
                                          )
  (local-vars (v0-62 int) (sv-176 int))
  (let ((gp-0 (new 'stack 'spooler-block)))
    (let ((s5-0 gp-0))
      (set! (-> s5-0 anim) arg0)
      (set! (-> s5-0 idle) arg1)
      (set! (-> s5-0 exit) arg2)
      (set! (-> s5-0 break-func) arg3)
      (set! (-> s5-0 flags) arg4)
      (set! (-> s5-0 part-audio-start) -17.0)
      (set! (-> s5-0 old-status) (the-as uint (-> self skel status)))
      (set! (-> s5-0 old-pos) -2)
      (set! (-> s5-0 sid) (new-sound-id))
      (set! (-> s5-0 paused?) #f)
      )
    (let ((v1-7
            (lookup-gui-connection *gui-control* self (gui-channel art-load) (-> gp-0 anim name) (new 'static 'sound-id))
            )
          )
      (if v1-7
          (set! (-> gp-0 sid) (-> v1-7 id))
          )
      )
    (if (!= self *target*)
        (send-event *target* 'movie)
        )
    (backup-load-state-and-set-cmds *load-state* (-> gp-0 anim command-list))
    (logior! (-> self skel status) (joint-control-status sync-math spooling spooling-not-last-block))
    (talker-surpress!)
    (apply-settings *setting-control*)
    (when (or (and (-> *setting-control* user-current spooling)
                   (or (< 2 (-> gp-0 anim parts))
                       (not (string= (-> *setting-control* user-current spool-anim name) (-> gp-0 anim name)))
                       )
                   )
              (logtest? (-> *art-control* frame-mask) 28)
              (!= *master-mode* 'game)
              )
      (cond
        ((-> gp-0 idle)
         (when (!= (ja-group) (-> gp-0 idle))
           (ja-channel-push! 1 (seconds 0.05))
           (ja :group! (-> gp-0 idle) :num! min)
           )
         )
        (else
          (ja-channel-set! 0)
          )
        )
      (while (or (and (-> *setting-control* user-current spooling)
                      (or (< 2 (-> gp-0 anim parts))
                          (not (string= (-> *setting-control* user-current spool-anim name) (-> gp-0 anim name)))
                          )
                      )
                 (logtest? (-> *art-control* frame-mask) 28)
                 (!= *master-mode* 'game)
                 )
        (format #t "WARNING: ---------------------> loader stall on lock~%")
        (if ((-> gp-0 break-func) self)
            (goto cfg-139)
            )
        (gui-control-method-12
          *gui-control*
          self
          (gui-channel art-load)
          (gui-action queue)
          (-> gp-0 anim name)
          (-> gp-0 part)
          -9.0
          (-> gp-0 sid)
          )
        (suspend)
        (if (-> gp-0 idle)
            (ja :num! (loop!))
            )
        )
      )
    (set-setting! 'spooling (process->ppointer self) 0.0 0)
    (set-setting! 'spool-anim (-> gp-0 anim) 0.0 0)
    (apply-settings *setting-control*)
    (set-time! (-> gp-0 old-time))
    (while (< (-> gp-0 part) (-> gp-0 anim parts))
      (when (> (-> gp-0 part) 0)
        (while (let ((v1-103 (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))))
                 (not (or (= v1-103 'active) (= v1-103 'locked)))
                 )
          (if ((-> gp-0 break-func) self)
              (goto cfg-139)
              )
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-0 anim name)
            (+ (-> gp-0 part) -1)
            -20.0
            (-> gp-0 sid)
            )
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-0 anim name)
            (-> gp-0 part)
            -10.0
            (-> gp-0 sid)
            )
          (when (and (not (-> gp-0 paused?)) (< (-> *setting-control* user-current movie-skip-frame) 0.0))
            (format
              #t
              "WARNING: ---------------------> loader pre stall on art ~S ~D ~A~%"
              (-> gp-0 anim name)
              (-> gp-0 part)
              (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))
              )
            (set! (-> gp-0 paused?) #t)
            (if (nonzero? (-> gp-0 part))
                (sound-pause (-> gp-0 sid))
                )
            )
          (if (logtest? (-> gp-0 flags) (spooler-flags blackout-on-stall))
              (set-blackout-frames (seconds 0.05))
              )
          (suspend)
          )
        )
      (gui-control-method-12
        *gui-control*
        self
        (gui-channel art-load)
        (gui-action queue)
        (-> gp-0 anim name)
        (-> gp-0 part)
        -20.0
        (-> gp-0 sid)
        )
      (update *gui-control* #f)
      (update *art-control* #f)
      (gui-control-method-12
        *gui-control*
        self
        (gui-channel art-load)
        (gui-action queue)
        (-> gp-0 anim name)
        (-> gp-0 part)
        -20.0
        (-> gp-0 sid)
        )
      (when (!= (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part)) 'active)
        (cond
          ((-> gp-0 idle)
           (when (!= (ja-group) (-> gp-0 idle))
             (ja-channel-set! 1)
             (ja :group! (-> gp-0 idle) :num! min)
             )
           )
          (else
            (ja-channel-set! 0)
            )
          )
        (while (!= (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part)) 'active)
          (if ((-> gp-0 break-func) self)
              (goto cfg-139)
              )
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-0 anim name)
            (-> gp-0 part)
            -20.0
            (-> gp-0 sid)
            )
          (when (not (-> gp-0 paused?))
            (format
              #t
              "WARNING: ---------------------> loader stall on art ~S ~D ~A~%"
              (-> gp-0 anim name)
              (-> gp-0 part)
              (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))
              )
            (set! (-> gp-0 paused?) #t)
            (if (nonzero? (-> gp-0 part))
                (sound-pause (-> gp-0 sid))
                )
            )
          (if (logtest? (-> gp-0 flags) (spooler-flags blackout-on-stall))
              (set-blackout-frames (seconds 0.05))
              )
          (suspend)
          (if (-> gp-0 idle)
              (ja :num! (loop!))
              )
          )
        )
      (when (-> gp-0 paused?)
        (set! (-> gp-0 paused?) #f)
        (sound-continue (-> gp-0 sid))
        (format
          #t
          "WARNING: ---------------------> loader release lock on art ~S ~D ~A~%"
          (-> gp-0 anim name)
          (-> gp-0 part)
          (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))
          )
        )
      (gui-control-method-12
        *gui-control*
        self
        (gui-channel art-load)
        (gui-action queue)
        (-> gp-0 anim name)
        (-> gp-0 part)
        -20.0
        (-> gp-0 sid)
        )
      (let ((s5-8 (get-art-by-name (-> self draw art-group) (-> gp-0 anim anim-name) art-joint-anim)))
        (cond
          (s5-8
            (ja-channel-set! 1)
            (ja-no-eval :group! s5-8 :num! (seek!) :frame-num 0.0)
            (when (zero? (-> gp-0 part))
              (str-play-async (-> gp-0 anim name) (-> gp-0 sid) 1024 2)
              (set! (-> *art-control* active-stream) (-> gp-0 anim name))
              )
            (let* ((f30-0 (* 0.05859375 (-> s5-8 speed)))
                   (f28-0 (+ (-> gp-0 part-audio-start) (/ (the float (+ (-> s5-8 frames num-frames) -1)) f30-0)))
                   )
              (set! sv-176 (current-str-pos (-> gp-0 sid)))
              (set-time! (-> gp-0 good-time))
              (until (>= (the float v0-62) f28-0)
                (if (= (-> self skel root-channel 0) (-> self skel channel))
                    (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
                    )
                (if (or ((-> gp-0 break-func) self)
                        (and (<= sv-176 0) (time-elapsed? (-> gp-0 good-time) (seconds 4)))
                        (and (< 300 (-> gp-0 good-count)) (<= sv-176 0))
                        )
                    (goto cfg-139)
                    )
                (gui-control-method-12
                  *gui-control*
                  self
                  (gui-channel art-load)
                  (gui-action queue)
                  (-> gp-0 anim name)
                  (-> gp-0 part)
                  -20.0
                  (-> gp-0 sid)
                  )
                (if (< (+ (-> gp-0 part) 1) (-> gp-0 anim parts))
                    (gui-control-method-12
                      *gui-control*
                      self
                      (gui-channel art-load)
                      (gui-action queue)
                      (-> gp-0 anim name)
                      (+ (-> gp-0 part) 1)
                      -10.0
                      (-> gp-0 sid)
                      )
                    (logclear! (-> self skel status) (joint-control-status spooling-not-last-block))
                    )
                (execute-commands-up-to *load-state* (ja-aframe-num 0))
                (cond
                  ((and (< (-> gp-0 old-pos) sv-176) (< -1 sv-176))
                   (+! (-> gp-0 good-count) (- (current-time) (-> self clock old-frame-counter)))
                   (set-time! (-> gp-0 good-time))
                   )
                  (else
                    0
                    )
                  )
                (set! (-> gp-0 old-pos) sv-176)
                (set-time! (-> gp-0 old-time))
                (if (and (logtest? (-> gp-0 flags) (spooler-flags blackout-on-stall)) (<= sv-176 0))
                    (set-blackout-frames (seconds 0.05))
                    )
                (suspend)
                (let* ((f26-0 (* (- (the float (current-str-pos (-> gp-0 sid))) (-> gp-0 part-audio-start)) f30-0))
                       (f0-16 (if (str-id-is-playing? (-> gp-0 sid))
                                  (fmax 0.0 (fmin f26-0 (the float (+ (-> (ja-group) frames num-frames) -1))))
                                  (fmax 0.0 (fmin (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -1))))
                                  )
                              )
                       )
                  (ja-no-eval :num! (seek!) :frame-num f0-16)
                  )
                (set! v0-62 (current-str-pos (-> gp-0 sid)))
                (set! sv-176 v0-62)
                )
              (set! (-> gp-0 part-audio-start) f28-0)
              )
            (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
            )
          (else
            (format
              0
              ;; og:preserve-this fixed missing %
              "ERROR: <asg> ~A in spool anim loop for ~A ~D, but not loaded.~%"
              self
              (-> gp-0 anim name)
              (-> gp-0 part)
              )
            (goto cfg-139)
            )
          )
        )
      (+! (-> gp-0 part) 1)
      )
    (+! (-> gp-0 part) -1)
    (label cfg-139)
    (ja-abort-spooled-anim (-> gp-0 anim) (-> gp-0 exit) (-> gp-0 part))
    )
  0
  )

(defbehavior ja-abort-spooled-anim process-drawable ((arg0 spool-anim) (arg1 art-joint-anim) (arg2 int))
  (let ((s3-0 0))
    (let ((v1-1
            (lookup-gui-connection *gui-control* self (gui-channel art-load) (-> arg0 name) (new 'static 'sound-id))
            )
          )
      (when v1-1
        (set! s3-0 (the-as int (-> v1-1 id)))
        (set! (-> v1-1 action) (gui-action abort))
        )
      )
    (if (zero? s3-0)
        (return (the-as int #f))
        )
    (str-play-stop (-> arg0 name) (the-as sound-id s3-0))
    )
  (restore-load-state-and-cleanup *load-state*)
  (set! (-> *art-control* active-stream) #f)
  (logclear! (-> self skel status) (joint-control-status spooling spooling-not-last-block))
  (if (not (logtest? (-> self skel status) (joint-control-status sync-math)))
      (logclear! (-> self skel status) (joint-control-status sync-math))
      )
  (cond
    ((and arg1 (>= arg2 0))
     (ja-channel-push! 1 (seconds 0.03))
     (set! (-> self skel root-channel 0 frame-group) arg1)
     (while (!= (-> self skel root-channel 0) (-> self skel channel))
       (gui-control-method-12
         *gui-control*
         self
         (gui-channel art-load)
         (gui-action queue)
         (-> arg0 name)
         arg2
         -20.0
         (new 'static 'sound-id)
         )
       (suspend)
       (ja :num! (seek!))
       )
     )
    (else
      (ja-channel-set! 0)
      )
    )
  (remove-setting! 'spooling)
  (remove-setting! 'spool-anim)
  0
  )


(defmethod print ((this gui-connection))
  (let* ((t9-0 format)
         (a0-1 #t)
         (a1-0 "#<gc ~12S ~2D ~6D ~6,,0f ~7S ~8S ")
         (a2-0 (-> this name))
         (a3-0 (-> this anim-part))
         (t0-0 (-> this id))
         (t1-0 (-> this priority))
         (v1-0 (-> this channel))
         (t2-1 (cond
                 ((= v1-0 (gui-channel hud-lower-left))
                  "hud-lower-left"
                  )
                 ((= v1-0 (gui-channel citizen))
                  "citizen"
                  )
                 ((= v1-0 (gui-channel pecker))
                  "pecker"
                  )
                 ((= v1-0 (gui-channel jak-effect-1))
                  "jak-effect-1"
                  )
                 ((= v1-0 (gui-channel ashelin))
                  "ashelin"
                  )
                 ((= v1-0 (gui-channel hud-lower-left-1))
                  "hud-lower-left-1"
                  )
                 ((= v1-0 (gui-channel message))
                  "message"
                  )
                 ((= v1-0 (gui-channel hud-middle-left))
                  "hud-middle-left"
                  )
                 ((= v1-0 (gui-channel gun))
                  "gun"
                  )
                 ((= v1-0 (gui-channel hud-upper-center-2))
                  "hud-upper-center-2"
                  )
                 ((= v1-0 (gui-channel hud-middle-right))
                  "hud-middle-right"
                  )
                 ((= v1-0 (gui-channel subtitle))
                  "subtitle"
                  )
                 ((= v1-0 (gui-channel notice))
                  "notice"
                  )
                 ((= v1-0 (gui-channel art-load-next))
                  "art-load-next"
                  )
                 ((= v1-0 (gui-channel voicebox))
                  "voicebox"
                  )
                 ((= v1-0 (gui-channel sig))
                  "sig"
                  )
                 ((= v1-0 (gui-channel hud-center-left))
                  "hud-center-left"
                  )
                 ((= v1-0 (gui-channel task))
                  "task"
                  )
                 ((= v1-0 (gui-channel hud-upper-right))
                  "hud-upper-right"
                  )
                 ((= v1-0 (gui-channel hud-center-right))
                  "hud-center-right"
                  )
                 ((= v1-0 (gui-channel alert))
                  "alert"
                  )
                 ((= v1-0 (gui-channel hud-upper-left))
                  "hud-upper-left"
                  )
                 ((= v1-0 (gui-channel query))
                  "query"
                  )
                 ((= v1-0 (gui-channel hud-lower-right))
                  "hud-lower-right"
                  )
                 ((= v1-0 (gui-channel screen))
                  "screen"
                  )
                 ((= v1-0 (gui-channel guard))
                  "guard"
                  )
                 ((= v1-0 (gui-channel supertitle))
                  "supertitle"
                  )
                 ((= v1-0 (gui-channel hal))
                  "hal"
                  )
                 ((= v1-0 (gui-channel hud-upper-center))
                  "hud-upper-center"
                  )
                 ((= v1-0 (gui-channel blackout))
                  "blackout"
                  )
                 ((= v1-0 (gui-channel bbush))
                  "bbush"
                  )
                 ((= v1-0 (gui-channel hud))
                  "hud"
                  )
                 ((= v1-0 (gui-channel voice))
                  "voice"
                  )
                 ((= v1-0 (gui-channel jak-mode))
                  "jak-mode"
                  )
                 ((= v1-0 (gui-channel max))
                  "max"
                  )
                 ((= v1-0 (gui-channel none))
                  "none"
                  )
                 ((= v1-0 (gui-channel freeze))
                  "freeze"
                  )
                 ((= v1-0 (gui-channel notice-low))
                  "notice-low"
                  )
                 ((= v1-0 (gui-channel art-load))
                  "art-load"
                  )
                 ((= v1-0 (gui-channel hud-auto-save-message))
                  "hud-auto-save-message"
                  )
                 ((= v1-0 (gui-channel jak))
                  "jak"
                  )
                 ((= v1-0 (gui-channel progress))
                  "progress"
                  )
                 ((= v1-0 (gui-channel resetter))
                  "resetter"
                  )
                 ((= v1-0 (gui-channel jak-effect-2))
                  "jak-effect-2"
                  )
                 ((= v1-0 (gui-channel daxter))
                  "daxter"
                  )
                 ((= v1-0 (gui-channel hud-lower-left-2))
                  "hud-lower-left-2"
                  )
                 ((= v1-0 (gui-channel background))
                  "background"
                  )
                 ((= v1-0 (gui-channel beast))
                  "beast"
                  )
                 ((= v1-0 (gui-channel hud-auto-save))
                  "hud-auto-save"
                  )
                 ((= v1-0 (gui-channel hud-lower-center))
                  "hud-lower-center"
                  )
                 ((= v1-0 (gui-channel rider))
                  "rider"
                  )
                 ((= v1-0 (gui-channel movie))
                  "movie"
                  )
                 (else
                   "*unknown*"
                   )
                 )
               )
         (v1-1 (-> this action))
         )
    (t9-0 a0-1 a1-0 a2-0 a3-0 t0-0 t1-0 t2-1 (cond
                                               ((= v1-1 (gui-action queue))
                                                "queue"
                                                )
                                               ((= v1-1 (gui-action stop))
                                                "stop"
                                                )
                                               ((= v1-1 (gui-action play))
                                                "play"
                                                )
                                               ((= v1-1 (gui-action hide))
                                                "hide"
                                                )
                                               ((= v1-1 (gui-action fade))
                                                "fade"
                                                )
                                               ((= v1-1 (gui-action none))
                                                "none"
                                                )
                                               ((= v1-1 (gui-action abort))
                                                "abort"
                                                )
                                               ((= v1-1 (gui-action stopping))
                                                "stopping"
                                                )
                                               ((= v1-1 (gui-action hidden))
                                                "hidden"
                                                )
                                               ((= v1-1 (gui-action playing))
                                                "playing"
                                                )
                                               (else
                                                 "*unknown*"
                                                 )
                                               )
          )
    )
  (let ((s5-0 format)
        (s4-0 #t)
        (s3-0 " ~6S @ #x~A>")
        (v1-3 (get-status *gui-control* (-> this id)))
        )
    (s5-0
      s4-0
      s3-0
      (cond
        ((= v1-3 (gui-status ready))
         "ready"
         )
        ((= v1-3 (gui-status active))
         "active"
         )
        ((= v1-3 (gui-status stop))
         "stop"
         )
        ((= v1-3 (gui-status unknown))
         "unknown"
         )
        ((= v1-3 (gui-status hide))
         "hide"
         )
        ((= v1-3 (gui-status pending))
         "pending"
         )
        (else
          "*unknown*"
          )
        )
      this
      )
    )
  this
  )

(defmethod channel-id-set! ((this gui-control) (arg0 gui-connection) (arg1 sound-id))
  (set! (-> this ids (-> arg0 channel)) arg1)
  0
  )

;; WARN: Return type mismatch connectable vs gui-connection.
(defmethod lookup-gui-connection ((this gui-control) (arg0 process) (arg1 gui-channel) (arg2 string) (arg3 sound-id))
  (let ((s1-0 (-> this engine alive-list next0)))
    (-> this engine)
    (let ((s0-0 (-> (the-as gui-connection s1-0) next0)))
      (while (!= s1-0 (-> this engine alive-list-end))
        (if (and (or (= arg1 (gui-channel none)) (= (-> (the-as gui-connection s1-0) channel) arg1))
                 (or (not arg0)
                     (= (-> arg0 type) scene-player)
                     (= arg0 ((method-of-type gui-connection get-process) (the-as connection s1-0)))
                     )
                 (or (not arg2) (string= arg2 (-> (the-as gui-connection s1-0) name)))
                 (or (zero? arg3) (= (-> (the-as gui-connection s1-0) id) arg3))
                 )
            (return (the-as gui-connection s1-0))
            )
        (set! s1-0 s0-0)
        (-> this engine)
        (set! s0-0 (-> s0-0 next0))
        )
      )
    )
  (countdown (s1-1 32)
    (let ((s0-1 (-> this connections s1-1)))
      (if (and (nonzero? (-> s0-1 id))
               (or (= arg1 (gui-channel none)) (= (-> s0-1 channel) arg1))
               (and (or (not arg0) (= (-> arg0 type) scene-player) (= arg0 (handle->process (-> s0-1 handle))))
                    (or (not arg2) (string= arg2 (-> s0-1 name)))
                    (or (zero? arg3) (= (-> s0-1 id) arg3))
                    )
               )
          (return s0-1)
          )
      )
    )
  (the-as gui-connection #f)
  )

;; WARN: Return type mismatch int vs sound-id.
(defmethod lookup-gui-connection-id ((this gui-control) (arg0 string) (arg1 gui-channel) (arg2 gui-action))
  (let ((s2-0 (-> this engine alive-list next0)))
    (-> this engine)
    (let ((s1-0 (-> (the-as gui-connection s2-0) next0)))
      (while (!= (the-as gui-connection s2-0) (-> this engine alive-list-end))
        (if (and (or (= arg1 (gui-channel none)) (= arg1 (-> (the-as gui-connection s2-0) channel)))
                 (or (= arg2 (gui-action none)) (= arg2 (-> (the-as gui-connection s2-0) action)))
                 (or (not arg0) (string= arg0 (-> (the-as gui-connection s2-0) name)))
                 )
            (return (the-as sound-id (-> (the-as gui-connection s2-0) id)))
            )
        (set! s2-0 s1-0)
        (-> this engine)
        (set! s1-0 (-> s1-0 next0))
        )
      )
    )
  (countdown (s2-1 32)
    (let ((s1-1 (-> this connections s2-1)))
      (if (and (nonzero? (-> s1-1 id))
               (or (= arg1 (gui-channel none)) (= arg1 (-> s1-1 channel)))
               (or (= arg2 (gui-action none)) (= arg2 (-> s1-1 action)))
               (or (not arg0) (string= arg0 (-> s1-1 name)))
               )
          (return (the-as sound-id (-> s1-1 id)))
          )
      )
    )
  (the-as sound-id 0)
  )

(defmethod sound-params-set! ((this gui-control) (arg0 sound-id) (arg1 symbol) (arg2 int) (arg3 int) (arg4 int) (arg5 float))
  (when (nonzero? arg0)
    (let ((v1-2 (lookup-gui-connection *gui-control* (the-as process #f) (gui-channel none) (the-as string #f) arg0)))
      (when v1-2
        (if arg1
            (logior! (-> v1-2 flags) (gui-connection-flags gcf1))
            )
        (when (>= arg2 0)
          (logior! (-> v1-2 flags) (gui-connection-flags fo-min))
          (set! (-> v1-2 fo-min) arg2)
          )
        (when (>= arg3 0)
          (logior! (-> v1-2 flags) (gui-connection-flags fo-max))
          (set! (-> v1-2 fo-max) arg3)
          )
        (when (>= arg4 0)
          (logior! (-> v1-2 flags) (gui-connection-flags fo-curve))
          (set! (-> v1-2 fo-curve) arg4)
          )
        (when (>= arg5 0.0)
          (logior! (-> v1-2 flags) (gui-connection-flags volume))
          (set! (-> v1-2 volume) (the int (* 1024.0 arg5)))
          )
        v1-2
        )
      )
    )
  )

;; WARN: Return type mismatch object vs symbol.
;; WARN: disable def twice: 34. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod gui-control-method-18 ((this gui-control) (arg0 gui-channel))
  (let ((v1-0 arg0))
    (the-as
      symbol
      (cond
        ((or (= v1-0 (gui-channel message)) (= v1-0 (gui-channel notice)) (= v1-0 (gui-channel notice-low)))
         (not (or (logtest? (-> *art-control* frame-mask) 28) (!= *master-mode* 'game)))
         )
        ((= v1-0 (gui-channel query))
         (and (not (or (logtest? (-> *art-control* frame-mask) 28) (!= *master-mode* 'game)))
              (and *target* (not (logtest? (-> *target* focus-status) (focus-status dead hit))))
              )
         )
        (else
          #t
          )
        )
      )
    )
  )

(defmethod handle-command ((this gui-control) (arg0 gui-channel) (arg1 gui-channel) (arg2 symbol) (arg3 gui-connection))
  (let ((s5-0 (-> this ids arg1)))
    (cond
      ((nonzero? s5-0)
       (case arg2
         (('wait)
          (if (nonzero? (get-status this s5-0))
              (return #f)
              )
          )
         (('stop 'priority-stop)
          (when (nonzero? (-> this ids arg1))
            (let ((s2-0 (lookup-gui-connection this (the-as process #f) arg1 (the-as string #f) s5-0)))
              (when (and s2-0 (or (= arg2 'priority) (= s2-0 arg3) (and arg3 (< (-> arg3 priority) (-> s2-0 priority)))))
                (stop-str this s2-0)
                (cond
                  ((= (shr (the-as int arg1) 4) 5)
                   (set! (-> this times arg1)
                         (the-as time-frame (max (-> this times arg1) (+ (-> *display* base-clock frame-counter) (seconds 0.1))))
                         )
                   (set! (-> s2-0 action) (gui-action hidden))
                   )
                  ((= arg1 (gui-channel query))
                   (set! (-> s2-0 action) (gui-action play))
                   )
                  (else
                    (set! (-> s2-0 action) (gui-action hidden))
                    )
                  )
                )
              )
            )
          (if (nonzero? (get-status this s5-0))
              (return #f)
              )
          )
         (('hide)
          (let ((v1-34 (lookup-gui-connection this (the-as process #f) arg1 (the-as string #f) s5-0)))
            (when (and v1-34 (!= (-> v1-34 action) 8))
              (set-action!
                this
                (gui-action hide)
                s5-0
                (gui-channel none)
                (gui-action none)
                (the-as string #f)
                (the-as (function gui-connection symbol) #f)
                (the-as process #f)
                )
              (set! (-> this times arg1)
                    (the-as time-frame (max (-> this times arg1) (+ (-> *display* base-clock frame-counter) (seconds 0.1))))
                    )
              )
            )
          (if (nonzero? (get-status this s5-0))
              (return #f)
              )
          )
         )
       )
      ((< (-> *display* base-clock frame-counter) (-> this times arg1))
       (if (= arg2 'wait)
           (return #f)
           )
       )
      )
    )
  #t
  )

(defmethod handle-command-list ((this gui-control) (arg0 gui-channel) (arg1 gui-connection))
  (local-vars (sv-16 int) (sv-32 int) (sv-48 int))
  (let ((gp-0 #t))
    (cond
      ((or (not (gui-control-method-18 this arg0)) (< (-> *display* base-clock frame-counter) (-> this times arg0)))
       #f
       )
      ((not (null? (-> this cmd arg0)))
       (let* ((s2-0 (-> this cmd arg0))
              (v1-9 (car s2-0))
              )
         (while (not (null? s2-0))
           (let ((a2-1 (/ (the-as int (car v1-9)) 8))
                 (s1-0 (cdr v1-9))
                 )
             (case a2-1
               ((95)
                (let ((s0-0 80))
                  (set! sv-16 92)
                  (while (>= (the-as uint sv-16) (the-as uint s0-0))
                    (if (not (handle-command this arg0 (the-as gui-channel s0-0) (the-as symbol s1-0) arg1))
                        (set! gp-0 #f)
                        )
                    (+! s0-0 1)
                    )
                  )
                )
               ((79)
                (let ((s0-1 66))
                  (set! sv-32 70)
                  (while (>= (the-as uint sv-32) (the-as uint s0-1))
                    (if (not (handle-command this arg0 (the-as gui-channel s0-1) (the-as symbol s1-0) arg1))
                        (set! gp-0 #f)
                        )
                    (+! s0-1 1)
                    )
                  )
                )
               ((47)
                (let ((s0-2 18))
                  (set! sv-48 32)
                  (while (>= (the-as uint sv-48) (the-as uint s0-2))
                    (if (not (handle-command this arg0 (the-as gui-channel s0-2) (the-as symbol s1-0) arg1))
                        (set! gp-0 #f)
                        )
                    (+! s0-2 1)
                    )
                  )
                )
               (else
                 (if (not (handle-command this arg0 (the-as gui-channel a2-1) (the-as symbol s1-0) arg1))
                     (set! gp-0 #f)
                     )
                 )
               )
             )
           (set! s2-0 (cdr s2-0))
           (set! v1-9 (car s2-0))
           )
         )
       gp-0
       )
      )
    )
  )

;; WARN: Return type mismatch int vs gui-status.
(defmethod get-status ((this gui-control) (arg0 sound-id))
  (let ((gp-0 (the-as connectable #f)))
    (if (zero? arg0)
        (return (gui-status unknown))
        )
    (let ((v1-4 (-> this engine alive-list next0)))
      (-> this engine)
      (let ((a0-3 (-> v1-4 next0)))
        (while (!= v1-4 (-> this engine alive-list-end))
          (when (= arg0 (-> (the-as gui-connection v1-4) id))
            (set! gp-0 v1-4)
            (goto cfg-15)
            )
          (set! v1-4 a0-3)
          (-> this engine)
          (set! a0-3 (-> a0-3 next0))
          )
        )
      )
    #t
    (countdown (v1-10 32)
      (let ((a0-7 (-> this connections v1-10)))
        (when (= arg0 (-> a0-7 id))
          (set! gp-0 a0-7)
          (goto cfg-15)
          )
        )
      )
    (label cfg-15)
    (the-as
      gui-status
      (cond
        ((= (-> (the-as gui-connection gp-0) channel) (gui-channel movie))
         (cond
           ((= (-> (the-as gui-connection gp-0) id) (-> this ids (-> (the-as gui-connection gp-0) channel)))
            3
            )
           ((handle-command-list this (-> (the-as gui-connection gp-0) channel) (the-as gui-connection gp-0))
            2
            )
           (else
             1
             )
           )
         )
        ((let ((v1-22 (shr (the-as int (-> (the-as gui-connection gp-0) channel)) 4)))
           (or (= v1-22 1) (= v1-22 2))
           )
         (case (-> (the-as gui-connection gp-0) action)
           (((gui-action queue) (gui-action play) (gui-action playing) (gui-action fade) (gui-action stop))
            (cond
              ((the-as gui-connection gp-0)
               (dotimes (s4-0 4)
                 (when (and (string-charp=
                              (-> (the-as gui-connection gp-0) name)
                              (the-as (pointer uint8) (-> *sound-iop-info* stream-name s4-0))
                              )
                            (or (= (-> (the-as gui-connection gp-0) id) (-> *sound-iop-info* stream-id s4-0))
                                (zero? (-> *sound-iop-info* stream-id s4-0))
                                )
                            (begin
                              (if (logtest? (-> *sound-iop-info* stream-status s4-0) (stream-status ss9))
                                  (return (gui-status stop))
                                  )
                              (and (logtest? (-> *sound-iop-info* stream-status s4-0) (stream-status ss1 ss6))
                                   (if (and (>= (the-as uint (-> (the-as gui-connection gp-0) channel)) (the-as uint 16))
                                            (>= (the-as uint 17) (the-as uint (-> (the-as gui-connection gp-0) channel)))
                                            )
                                       (= (file-status
                                            *art-control*
                                            (-> (the-as gui-connection gp-0) name)
                                            (the-as int (-> (the-as gui-connection gp-0) anim-part))
                                            )
                                          'active
                                          )
                                       #t
                                       )
                                   )
                              )
                            )
                   (cond
                     ((logtest? (-> *sound-iop-info* stream-status s4-0) (stream-status ss4))
                      (return (gui-status active))
                      )
                     ((or (= (-> (the-as gui-connection gp-0) id) (-> this ids (-> (the-as gui-connection gp-0) channel)))
                          (handle-command-list this (-> (the-as gui-connection gp-0) channel) (the-as gui-connection gp-0))
                          )
                      (return (gui-status ready))
                      )
                     (else
                       (return (gui-status pending))
                       )
                     )
                   (the-as none 0)
                   )
                 )
               1
               )
              (else
                0
                )
              )
            )
           (else
             0
             )
           )
         )
        ((= (shr (the-as int (-> (the-as gui-connection gp-0) channel)) 4) 5)
         (cond
           ((= (-> (the-as gui-connection gp-0) id) (-> this ids (-> (the-as gui-connection gp-0) channel)))
            (if (or (= (-> (the-as gui-connection gp-0) action) (gui-action hide))
                    (= (-> (the-as gui-connection gp-0) action) (gui-action hidden))
                    )
                4
                3
                )
            )
           ((handle-command-list this (-> (the-as gui-connection gp-0) channel) (the-as gui-connection gp-0))
            2
            )
           (else
             1
             )
           )
         )
        (else
          (case (shr (the-as int (-> (the-as gui-connection gp-0) channel)) 4)
            ((4 5)
             (cond
               ((= (-> (the-as gui-connection gp-0) id) (-> this ids (-> (the-as gui-connection gp-0) channel)))
                3
                )
               ((handle-command-list this (-> (the-as gui-connection gp-0) channel) (the-as gui-connection gp-0))
                2
                )
               (else
                 1
                 )
               )
             )
            (else
              0
              )
            )
          )
        )
      )
    )
  )

(defmethod set-action! ((this gui-control)
                       (arg0 gui-action)
                       (arg1 sound-id)
                       (arg2 gui-channel)
                       (arg3 gui-action)
                       (arg4 string)
                       (arg5 (function gui-connection symbol))
                       (arg6 process)
                       )
  (local-vars (sv-16 gui-action) (sv-17 gui-action) (sv-20 string) (sv-24 (function gui-connection symbol)))
  (set! sv-16 arg0)
  (set! sv-17 arg3)
  (set! sv-20 arg4)
  (set! sv-24 arg5)
  (let ((s1-0 (-> this engine alive-list next0)))
    (-> this engine)
    (let ((s0-0 (-> s1-0 next0)))
      (while (!= s1-0 (-> this engine alive-list-end))
        (when (and (or (= arg1 1) (= arg1 (-> (the-as gui-connection s1-0) id)))
                   (or (= arg2 (gui-channel none)) (= arg2 (-> (the-as gui-connection s1-0) channel)))
                   (or (= sv-17 (gui-action none)) (= sv-17 (-> (the-as gui-connection s1-0) action)))
                   (or (not sv-20) (string= sv-20 (-> (the-as gui-connection s1-0) name)))
                   (or (not arg5) (arg5 (the-as gui-connection s1-0)))
                   (or (not arg6) (= arg6 (get-process (the-as gui-connection s1-0))))
                   )
          (cond
            ((and (= sv-16 (gui-action hide))
                  (!= (-> this ids (-> (the-as gui-connection s1-0) channel)) (-> (the-as gui-connection s1-0) id))
                  )
             (set! (-> (the-as gui-connection s1-0) action) (gui-action hidden))
             )
            ((and (= sv-16 (gui-action play)) (= (-> (the-as gui-connection s1-0) action) (gui-action playing)))
             )
            (else
              (set! (-> (the-as gui-connection s1-0) action) sv-16)
              ;; og:preserve-this fixed naughty dog bug here. was 'play instead of (gui-action play)
              (if (and (= sv-16 (gui-action play))
                       (handle-command-list this (-> (the-as gui-connection s1-0) channel) (the-as gui-connection s1-0))
                       )
                  (channel-id-set! this (the-as gui-connection s1-0) (-> (the-as gui-connection s1-0) id))
                  )
              )
            )
          )
        (set! s1-0 s0-0)
        (-> this engine)
        (set! s0-0 (-> s0-0 next0))
        )
      )
    )
  0
  )

;; WARN: Return type mismatch int vs sound-id.
(defmethod add-process ((this gui-control)
                       (arg0 process)
                       (arg1 gui-channel)
                       (arg2 gui-action)
                       (arg3 string)
                       (arg4 float)
                       (arg5 time-frame)
                       )
  (local-vars
    (sv-16 int)
    (sv-20 gui-connection)
    (sv-32 connectable)
    (sv-48 connectable)
    (sv-64 connectable)
    (sv-80 int)
    )
  (set! sv-32 (the-as connectable #f))
  (set! sv-48 (-> this engine alive-list next0))
  (-> this engine)
  (set! sv-64 (-> sv-48 next0))
  (while (!= sv-48 (-> this engine alive-list-end))
    (when (and (= arg1 (-> (the-as gui-connection sv-48) channel))
               (string= arg3 (-> (the-as gui-connection sv-48) name))
               (= ((method-of-type gui-connection get-process) (the-as connection sv-48)) arg0)
               )
      (set! sv-32 sv-48)
      (goto cfg-12)
      )
    (set! sv-48 sv-64)
    (-> this engine)
    (set! sv-64 (-> sv-64 next0))
    )
  (label cfg-12)
  (when (not sv-32)
    (set! sv-16 0)
    (set! sv-80 32)
    (while (nonzero? sv-80)
      (set! sv-80 (+ sv-80 -1))
      (set! sv-20 (-> this connections sv-80))
      (if (and (nonzero? (-> sv-20 id))
               (= arg1 (-> sv-20 channel))
               (string= arg3 (-> sv-20 name))
               (>= (-> sv-20 priority) -1.0)
               )
          (set! sv-16 (the-as int (-> sv-20 id)))
          )
      )
    (if (zero? sv-16)
        (set! sv-16 (the-as int (new-sound-id)))
        )
    (set! sv-32 (add-connection (-> this engine) arg0 arg4 0 arg3 sv-16))
    (the-as connection sv-32)
    )
  (the-as sound-id (cond
                     (sv-32
                       (set! (-> (the-as gui-connection sv-32) priority) arg4)
                       (set! (-> (the-as gui-connection sv-32) channel) arg1)
                       (set! (-> (the-as gui-connection sv-32) action) arg2)
                       (set! (-> (the-as gui-connection sv-32) param2) (the-as int arg3))
                       (set! (-> (the-as gui-connection sv-32) hold-time) arg5)
                       (set! (-> (the-as gui-connection sv-32) flags) (gui-connection-flags gcf0))
                       (set! (-> (the-as gui-connection sv-32) fade) (the-as uint 0))
                       (the-as int (-> (the-as gui-connection sv-32) id))
                       )
                     (else
                       (format 0 "ERROR: could not connection ~A to gui engine.~%" arg0)
                       0
                       )
                     )
          )
  )

(defmethod remove-process ((this gui-control) (arg0 process) (arg1 gui-channel))
  (let ((con-i-0 (the-as gui-connection (-> this engine alive-list next0))))
    (-> this engine)
    (let ((s2-0 (-> (the-as connectable con-i-0) next0)))
      (while (!= con-i-0 (-> this engine alive-list-end))
        (if (and (= arg1 (-> con-i-0 channel)) (= arg0 (get-process con-i-0)))
            (move-to-dead con-i-0)
            )
        (set! con-i-0 (the-as gui-connection s2-0))
        (-> this engine)
        (set! s2-0 (-> s2-0 next0))
        )
      )
    )
  0
  )

;; WARN: Return type mismatch int vs sound-id.
(defmethod gui-control-method-12 ((this gui-control)
                                 (arg0 process)
                                 (arg1 gui-channel)
                                 (arg2 gui-action)
                                 (arg3 string)
                                 (arg4 int)
                                 (arg5 float)
                                 (arg6 sound-id)
                                 )
  (local-vars
    (sv-16 gui-connection)
    (sv-20 int)
    (sv-24 gui-connection)
    (sv-28 process)
    (sv-32 int)
    (sv-48 sound-id)
    )
  (set! sv-48 arg6)
  (set! sv-16 (the-as gui-connection #f))
  (set! sv-20 0)
  (set! sv-32 32)
  (while (nonzero? sv-32)
    (set! sv-32 (+ sv-32 -1))
    (set! sv-24 (-> this connections sv-32))
    (when (and (nonzero? (-> sv-24 id))
               (= arg1 (-> sv-24 channel))
               (let ((v1-14 (handle->process (-> sv-24 handle))))
                 (and (or (= v1-14 arg0) (= (-> arg0 type) scene-player) (and v1-14 (= (-> v1-14 type) scene-player)))
                      (and (string= arg3 (-> sv-24 name)) (= arg4 (-> sv-24 anim-part)))
                      )
                 )
               )
      (when (< (-> sv-24 priority) arg5)
        (set! (-> sv-24 time-stamp) (-> this update-time))
        (return (the-as sound-id (-> sv-24 id)))
        )
      (set! sv-16 sv-24)
      (goto cfg-44)
      )
    )
  (countdown (v1-33 32)
    (let ((a0-15 (-> this connections v1-33)))
      (when (or (zero? (-> a0-15 id)) (not (handle->process (-> a0-15 handle))))
        (set! sv-16 a0-15)
        (set! (-> sv-16 param3) 0)
        (set! (-> sv-16 flags) (gui-connection-flags))
        (goto cfg-44)
        )
      )
    )
  (label cfg-44)
  (the-as
    sound-id
    (cond
      (sv-16
        (when (zero? (-> (the-as gui-connection sv-16) id))
          (when (zero? sv-20)
            (let ((v1-46 (lookup-gui-connection this arg0 arg1 arg3 (new 'static 'sound-id))))
              (if v1-46
                  (set! sv-20 (the-as int (-> v1-46 id)))
                  )
              )
            )
          (if (zero? sv-20)
              (set! sv-20 (the-as int sv-48))
              )
          (set! (-> sv-16 param3) (if (nonzero? sv-20)
                                      sv-20
                                      (the-as int (new-sound-id))
                                      )
                )
          )
        (when (= arg5 -99.0)
          (let ((s2-1 arg0))
            (set! sv-28 (if (type? s2-1 process-drawable)
                            s2-1
                            )
                  )
            )
          (set! arg5 (if sv-28
                         (vector-vector-distance (target-pos 0) (-> (the-as process-drawable sv-28) root trans))
                         -1.0
                         )
                )
          )
        (set! (-> sv-16 time-stamp) (-> this update-time))
        (set! (-> sv-16 handle) (process->handle arg0))
        (set! (-> sv-16 priority) arg5)
        (set! (-> sv-16 channel) arg1)
        (set! (-> sv-16 action) arg2)
        (set! (-> sv-16 anim-part) (the-as uint arg4))
        (set! (-> sv-16 param2) (the-as int arg3))
        (set! (-> sv-16 fade) (the-as uint 0))
        (the-as int (-> (the-as gui-connection sv-16) id))
        )
      (else
        0
        )
      )
    )
  )

(defmethod gui-control-method-22 ((this gui-control) (arg0 gui-connection) (arg1 vector))
  (case (shr (the-as int (-> arg0 channel)) 4)
    ((1 2)
     (let ((s5-0 (-> this spool-connections)))
       (case (-> arg0 action)
         (((gui-action queue) (gui-action play) (gui-action playing) (gui-action fade))
          (let ((f30-0 (-> arg0 priority)))
            (when (= f30-0 -99.0)
              (let* ((s2-0 (get-process arg0))
                     (v1-10 (if (type? s2-0 process-drawable)
                                s2-0
                                )
                            )
                     )
                (set! f30-0 (cond
                              ((= (-> arg0 id) (-> this ids (-> arg0 channel)))
                               -1.0
                               )
                              (v1-10
                                (vector-vector-distance arg1 (-> (the-as process-drawable v1-10) root trans))
                                )
                              (else
                                -1.0
                                )
                              )
                      )
                )
              )
            (dotimes (s4-1 4)
              (cond
                ((>= (-> s5-0 s4-1 priority) f30-0)
                 (let ((s3-1 s4-1))
                   (while (< s3-1 4)
                     (when (= (-> s5-0 s3-1 id) (-> arg0 id))
                       (let ((s2-1 s3-1))
                         (while (< s2-1 3)
                           (mem-copy! (the-as pointer (-> s5-0 s2-1)) (the-as pointer (-> s5-0 (+ s2-1 1))) 48)
                           (+! s2-1 1)
                           )
                         )
                       (set! (-> s5-0 3 param2) (the-as int ""))
                       (set! (-> s5-0 3 priority) 100000000.0)
                       )
                     (+! s3-1 1)
                     )
                   )
                 (let ((s3-2 3))
                   (while (!= s3-2 s4-1)
                     (mem-copy! (the-as pointer (-> s5-0 s3-2)) (the-as pointer (-> s5-0 (+ s3-2 -1))) 48)
                     (+! s3-2 -1)
                     )
                   )
                 (mem-copy! (the-as pointer (-> s5-0 s4-1)) (the-as pointer arg0) 48)
                 (set! (-> s5-0 s4-1 priority) f30-0)
                 (goto cfg-42)
                 )
                ((= (-> s5-0 s4-1 id) (-> arg0 id))
                 (goto cfg-42)
                 )
                )
              )
            )
          )
         )
       )
     )
    )
  (label cfg-42)
  0
  )

(defmethod stop-str ((this gui-control) (arg0 gui-connection))
  (case (shr (the-as int (-> arg0 channel)) 4)
    ((1 2)
     (if (= (get-status this (-> arg0 id)) (gui-status active))
         (str-play-stop (-> arg0 name) (-> arg0 id))
         )
     )
    )
  (if (= (-> this ids (-> arg0 channel)) (-> arg0 id))
      (channel-id-set! this arg0 (new 'static 'sound-id))
      )
  0
  )

(defmethod gui-control-method-21 ((this gui-control) (arg0 gui-connection))
  (with-pp
    (when *sound-player-enable*
      (let ((gp-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-0 command) (sound-command set-param))
        (set! (-> gp-0 id) (-> arg0 id))
        (set! (-> gp-0 params mask) (the-as uint 0))
        (when (logtest? (-> arg0 flags) (gui-connection-flags gcf1))
          (let* ((s4-0 (get-process arg0))
                 (v1-8 (if (type? s4-0 process-drawable)
                           s4-0
                           )
                       )
                 )
            (when (and v1-8 (nonzero? (-> (the-as process-drawable v1-8) root)))
              (let ((a1-3 (-> (the-as process-drawable v1-8) root trans)))
                (let ((s4-1 pp))
                  (when (= a1-3 #t)
                    (if (and s4-1 (type? s4-1 process-drawable) (nonzero? (-> (the-as process-drawable s4-1) root)))
                        (set! a1-3 (-> (the-as process-drawable s4-1) root trans))
                        (set! a1-3 (the-as vector #f))
                        )
                    )
                  )
                (sound-trans-convert (-> gp-0 params trans) a1-3)
                )
              (logior! (-> gp-0 params mask) 32)
              )
            )
          )
        (set! (-> gp-0 params fo-curve) (-> arg0 fo-curve))
        (set! (-> gp-0 params fo-min) (-> arg0 fo-min))
        (set! (-> gp-0 params fo-max) (-> arg0 fo-max))
        (set! (-> gp-0 params volume) (-> arg0 volume))
        (if (logtest? (-> arg0 flags) (gui-connection-flags fo-curve))
            (logior! (-> gp-0 params mask) 256)
            )
        (if (logtest? (-> arg0 flags) (gui-connection-flags fo-min))
            (logior! (-> gp-0 params mask) 64)
            )
        (if (logtest? (-> arg0 flags) (gui-connection-flags fo-max))
            (logior! (-> gp-0 params mask) 128)
            )
        (if (logtest? (-> arg0 flags) (gui-connection-flags volume))
            (logior! (-> gp-0 params mask) 1)
            )
        )
      )
    0
    )
  )

;; og:preserve-this added for debugging
(#when PC_PORT
(define *gui-kick-str* #f))

(defmethod update-connection ((this gui-control) (arg0 gui-connection) (arg1 process) (arg2 symbol))
  (local-vars (v1-75 symbol))
  (when (and (>= (the-as uint (-> arg0 channel)) (the-as uint 16))
             (>= (the-as uint 17) (the-as uint (-> arg0 channel)))
             )
    (case (-> arg0 action)
      (((gui-action queue))
       (spool-push *art-control* (-> arg0 name) (the-as int (-> arg0 anim-part)) arg1 (-> arg0 priority))
       (if (and (logtest? (-> arg0 flags) (gui-connection-flags gcf0))
                (= (get-status this (-> arg0 id)) (gui-status active))
                )
           (set! (-> arg0 action) (gui-action playing))
           )
       )
      )
    )
  (let ((v1-16 (-> arg0 action)))
    (b! (!= v1-16 (gui-action play)) cfg-47 :delay (empty-form))
    (if (handle-command-list this (-> arg0 channel) arg0)
        (channel-id-set! this arg0 (-> arg0 id))
        )
    (let ((s3-0 (get-status this (-> arg0 id))))
      (if (and (logtest? (-> arg0 flags) (gui-connection-flags gcf1 fo-curve fo-min fo-max volume))
               (logtest? (-> arg0 flags) (gui-connection-flags gcf0))
               )
          (gui-control-method-21 this arg0)
          )
      (cond
        ((or (not (gui-control-method-18 this (-> arg0 channel))) (= s3-0 (gui-status stop)))
         (if (= (-> this ids (-> arg0 channel)) (-> arg0 id))
             (channel-id-set! this arg0 (new 'static 'sound-id))
             )
         (if (and arg2 (or (< (shr (the-as int (-> arg0 channel)) 4) (the-as uint 4)) (= s3-0 (gui-status stop))))
             (move-to-dead arg0)
             )
         )
        ((= (-> this ids (-> arg0 channel)) (-> arg0 id))
         (cond
           ((= s3-0 (gui-status ready))
            (case (shr (the-as int (-> arg0 channel)) 4)
              ((1 2)
               ;; og:preserve-this added condition
               (if (#if PC_PORT (or *gui-kick-str* (not (paused?)))
                                (not (paused?)))
                   (str-play-async
                     (-> arg0 name)
                     (-> arg0 id)
                     (if (logtest? (-> arg0 flags) (gui-connection-flags volume))
                         (-> arg0 volume)
                         1024
                         )
                     (the-as int (-> this group (-> arg0 channel)))
                     )
                   )
               )
              )
            )
           ((= s3-0 (gui-status active))
            (set! (-> arg0 action) (gui-action playing))
            )
           )
         )
        )
      )
    (b! #t cfg-124 :delay (nop!))
    (label cfg-47)
    (b! (not (or (= v1-16 (gui-action playing)) (= v1-16 (gui-action fade)))) cfg-102 :delay (empty-form))
    (b!
      (not (and (= (get-status this (-> arg0 id)) (gui-status active))
                (gui-control-method-18 this (-> arg0 channel))
                (or (= (-> arg0 action) (gui-action playing)) (< (-> arg0 fade) (the-as uint 30)))
                )
           )
      cfg-91
      :delay (nop!)
      )
    (channel-id-set! this arg0 (-> arg0 id))
    (set! (-> this times 0) 0)
    (let ((v1-73 (shr (the-as int (-> arg0 channel)) 4)))
      (set! v1-75
            (and (or (= v1-73 1) (= v1-73 2))
                 (not (and (>= (the-as uint (-> arg0 channel)) (the-as uint 16))
                           (>= (the-as uint 17) (the-as uint (-> arg0 channel)))
                           )
                      )
                 (begin
                   (dotimes (s3-1 4)
                     (when (and (string-charp= (-> arg0 name) (the-as (pointer uint8) (-> *sound-iop-info* stream-name s3-1)))
                                (= (-> arg0 id) (-> *sound-iop-info* stream-id s3-1))
                                (logtest? (-> *sound-iop-info* stream-status s3-1) (stream-status ss6))
                                )
                       (set! v1-75 #t)
                       (goto cfg-81)
                       )
                     )
                   #f
                   )
                 )
            )
      )
    (label cfg-81)
    (b! v1-75 cfg-91 :delay (nop!))
    (if (and (logtest? (-> arg0 flags) (gui-connection-flags gcf1 fo-curve fo-min fo-max volume))
             (logtest? (-> arg0 flags) (gui-connection-flags gcf0))
             )
        (gui-control-method-21 this arg0)
        )
    (when (= (-> arg0 action) (gui-action fade))
      (set! (-> arg0 fade) (the-as uint (seekl (the-as int (-> arg0 fade)) 30 1)))
      (when *sound-player-enable*
        (let ((s5-1 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> s5-1 command) (sound-command set-param))
          (set! (-> s5-1 id) (-> arg0 id))
          (set! (-> s5-1 params volume) (the int (* 1024.0 (lerp-scale 1.0 0.0 (the float (-> arg0 fade)) 0.0 30.0))))
          (set! (-> s5-1 params mask) (the-as uint 1))
          (-> s5-1 id)
          )
        )
      )
    (b! #t cfg-101 :delay (nop!))
    (label cfg-91)
    (when (= (-> this ids (-> arg0 channel)) (-> arg0 id))
      (channel-id-set! this arg0 (new 'static 'sound-id))
      (set! (-> this times (-> arg0 channel)) (+ (-> *display* base-clock frame-counter) (-> arg0 hold-time)))
      )
    (if (and arg2 (or (< (shr (the-as int (-> arg0 channel)) 4) (the-as uint 4))
                      (= (get-status this (-> arg0 id)) (gui-status stop))
                      )
             )
        (move-to-dead arg0)
        (set! (-> arg0 action) (gui-action play))
        )
    (label cfg-101)
    (b! #t cfg-124 :delay (nop!))
    (label cfg-102)
    (cond
      ((= v1-16 (gui-action stop))
       (stop-str this arg0)
       (if arg2
           (move-to-dead arg0)
           )
       )
      ((= v1-16 (gui-action abort))
       (if (= (-> this ids (-> arg0 channel)) (-> arg0 id))
           (channel-id-set! this arg0 (new 'static 'sound-id))
           )
       (if arg2
           (move-to-dead arg0)
           )
       )
      ((= v1-16 (gui-action hide))
       )
      ((= v1-16 (gui-action hidden))
       (cond
         ((or (< (shr (the-as int (-> arg0 channel)) 4) (the-as uint 4))
              (= (get-status this (-> arg0 id)) (gui-status stop))
              )
          (stop-str this arg0)
          (if arg2
              (move-to-dead arg0)
              )
          )
         (else
           (if (= (-> this ids (-> arg0 channel)) (-> arg0 id))
               (channel-id-set! this arg0 (new 'static 'sound-id))
               )
           )
         )
       )
      )
    )
  (label cfg-124)
  0
  (none)
  )

(defmethod update ((this gui-control) (arg0 symbol))
  (set! (-> this ids 65)
        (the-as sound-id (if (and (>= (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                                  (= (-> *setting-control* user-current bg-a) 0.0)
                                  (= (-> *setting-control* user-current bg-a-force) 0.0)
                                  )
                             0
                             1
                             )
                )
        )
  (let ((s4-0 (target-pos 0)))
    (dotimes (v1-8 4)
      (set! (-> this spool-connections v1-8 param2) (the-as int #f))
      (set! (-> this spool-connections v1-8 param3) 0)
      (set! (-> this spool-connections v1-8 priority) 100000000.0)
      )
    (let ((con-i-0 (the-as gui-connection (-> this engine alive-list next0))))
      (-> this engine)
      (let ((s2-0 (-> (the-as connectable con-i-0) next0)))
        (while (!= (the-as connectable con-i-0) (-> this engine alive-list-end))
          (gui-control-method-22 this con-i-0 s4-0)
          (case (-> con-i-0 action)
            (((gui-action playing))
             (channel-id-set! this con-i-0 (-> con-i-0 id))
             )
            )
          (set! con-i-0 (the-as gui-connection s2-0))
          (-> this engine)
          (set! s2-0 (-> s2-0 next0))
          )
        )
      )
    (let ((s3-1 (-> this update-time)))
      (countdown (s2-1 32)
        (let ((s1-0 (-> this connections s2-1)))
          (when (nonzero? (-> s1-0 id))
            (cond
              ((= (-> s1-0 time-stamp) s3-1)
               (gui-control-method-22 this s1-0 s4-0)
               )
              (else
                (if (= (-> this ids (-> s1-0 channel)) (-> s1-0 id))
                    (channel-id-set! this s1-0 (new 'static 'sound-id))
                    )
                (set! (-> s1-0 param3) 0)
                0
                )
              )
            )
          )
        )
      )
    )
  (let ((s4-1 (new 'stack-no-clear 'array 'sound-id 4))
        (s3-2 0)
        )
    (let ((s2-2 (-> *setting-control* user-current movie-name)))
      (dotimes (s1-1 4)
        (set! (-> s4-1 s1-1) (-> this spool-connections s1-1 id))
        (when (and (-> this spool-connections s1-1 name) (case (-> this spool-connections s1-1 channel)
                                                           (((gui-channel art-load) (gui-channel art-load-next))
                                                            #t
                                                            )
                                                           )
                   )
          (set! s3-2 (logior s3-2 (ash 1 s1-1)))
          (if (and s2-2 (string= (-> this spool-connections s1-1 name) (the-as string s2-2)))
              (set! s3-2 (logior s3-2 (ash 1 (+ s1-1 4))))
              )
          )
        )
      )
    (let* ((t9-6 str-play-queue)
           (v1-69 (-> this spool-connections 0 name))
           (a0-32 (if v1-69
                      v1-69
                      )
                  )
           (v1-70 (-> this spool-connections 1 name))
           (a1-7 (if v1-70
                     v1-70
                     )
                 )
           (v1-71 (-> this spool-connections 2 name))
           (a2-4 (if v1-71
                     v1-71
                     )
                 )
           (v1-72 (-> this spool-connections 3 name))
           )
      (t9-6
        a0-32
        a1-7
        a2-4
        (if v1-72
            v1-72
            )
        s4-1
        (the-as pointer s3-2)
        )
      )
    )
  (-> this engine)
  (let ((con-i-1 (the-as gui-connection (-> this engine alive-list-end prev0))))
    (-> this engine)
    (let ((s4-2 (-> (the-as connectable con-i-1) prev0)))
      (while (!= (the-as connectable con-i-1) (-> this engine alive-list))
        (update-connection this con-i-1 ((method-of-type connection get-process) (the-as connection con-i-1)) #t)
        (set! con-i-1 (the-as gui-connection s4-2))
        (-> this engine)
        (set! s4-2 (-> s4-2 prev0))
        )
      )
    )
  (countdown (s4-3 32)
    (let ((v1-91 (-> this connections s4-3)))
      (if (nonzero? (-> v1-91 id))
          (update-connection this v1-91 (handle->process (-> v1-91 handle)) #f)
          )
      )
    )
  (when arg0
    (when *display-art-control*
      (dotimes (s5-1 4)
        (let ((a3-4 (-> this spool-connections s5-1)))
          (if (-> a3-4 name)
              (format *stdcon* "~D: ~`gui-connection`P~%" s5-1 a3-4)
              )
          )
        )
      (dotimes (s5-2 4)
        (format
          *stdcon*
          "~0KCh ~D: ~8D ~5X ~6D ~G~1K~%"
          s5-2
          (-> *sound-iop-info* stream-id-signed s5-2)
          (-> *sound-iop-info* stream-status s5-2)
          (-> *sound-iop-info* stream-position s5-2)
          (-> *sound-iop-info* stream-name s5-2)
          )
        )
      )
    (when *display-gui-control*
      (-> this engine)
      (let ((a2-12 (-> this engine alive-list-end prev0)))
        (-> this engine)
        (let ((s5-3 (-> a2-12 prev0)))
          (while (!= a2-12 (-> this engine alive-list))
            (format *stdcon* "c: ~`gui-connection`P~%" a2-12)
            (set! a2-12 s5-3)
            (-> this engine)
            (set! s5-3 (-> s5-3 prev0))
            )
          )
        )
      (countdown (s5-4 32)
        (let ((a2-13 (-> this connections s5-4)))
          (if (nonzero? (-> a2-13 id))
              (format *stdcon* "l: ~`gui-connection`P~%" a2-13)
              )
          )
        )
      )
    )
  (set! (-> this update-time) (-> *display* base-clock frame-counter))
  0
  )

(defmethod new gui-control ((allocation symbol) (type-to-make type) (arg0 int))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 engine) ((method-of-type engine new) allocation engine 'gui-control arg0 gui-connection))
    (dotimes (v1-3 32)
      (set! (-> gp-0 connections v1-3 handle) (the-as handle #f))
      )
    (dotimes (v1-6 96)
      (set! (-> gp-0 cmd v1-6) '())
      (set! (-> gp-0 group v1-6) (sound-group music))
      )
    (set! (-> gp-0 cmd 64) '((64 . wait) (72 . wait) (65 . wait) (66 . stop) (95 . stop)))
    (set! (-> gp-0 cmd 72) '((64 . wait) (72 . wait) (65 . wait) (66 . stop) (95 . hide)))
    (set! (-> gp-0 cmd 73) '((64 . wait) (73 . wait) (65 . wait) (66 . stop) (67 . stop) (95 . hide)))
    (set! (-> gp-0 cmd 74) '((64 . wait) (72 . wait) (65 . wait) (73 . wait) (87 . hide) (89 . hide)))
    (set! (-> gp-0 cmd 66)
          '((64 . wait)
            (65 . wait)
            (68 . wait)
            (71 . wait)
            (67 . wait)
            (66 . wait)
            (69 . wait)
            (83 . hide)
            (84 . hide)
            (85 . hide)
            (92 . hide)
            )
          )
    (set! (-> gp-0 cmd 67)
          '((64 . wait)
            (65 . wait)
            (68 . wait)
            (71 . wait)
            (67 . wait)
            (66 . wait)
            (69 . wait)
            (83 . hide)
            (84 . hide)
            (85 . hide)
            (82 . hide)
            (92 . hide)
            )
          )
    (set! (-> gp-0 cmd 68)
          '((65 . wait)
            (68 . wait)
            (67 . wait)
            (66 . wait)
            (69 . wait)
            (83 . hide)
            (84 . hide)
            (85 . hide)
            (82 . hide)
            (92 . hide)
            )
          )
    (set! (-> gp-0 cmd 71)
          '((65 . wait)
            (71 . wait)
            (67 . wait)
            (66 . wait)
            (69 . wait)
            (83 . hide)
            (84 . hide)
            (85 . hide)
            (82 . hide)
            (92 . hide)
            )
          )
    (set! (-> gp-0 cmd 69) '((65 . wait) (71 . wait) (67 . wait) (66 . wait)))
    (set! (-> gp-0 cmd 70) '((65 . wait) (90 . hide) (91 . hide) (81 . hide) (80 . hide) (94 . wait)))
    (set! (-> gp-0 cmd 80) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (80 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 81) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (81 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 82)
          '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (67 . wait) (71 . wait) (69 . wait) (82 . wait))
          )
    (set! (-> gp-0 cmd 83)
          '((64 . wait)
            (72 . wait)
            (73 . wait)
            (65 . wait)
            (67 . wait)
            (71 . wait)
            (69 . wait)
            (66 . wait)
            (83 . wait)
            (84 . hide)
            (85 . hide)
            )
          )
    (set! (-> gp-0 cmd 84)
          '((64 . wait)
            (72 . wait)
            (73 . wait)
            (65 . wait)
            (67 . wait)
            (71 . wait)
            (69 . wait)
            (66 . wait)
            (83 . wait)
            (84 . wait)
            )
          )
    (set! (-> gp-0 cmd 85)
          '((64 . wait)
            (72 . wait)
            (73 . wait)
            (65 . wait)
            (67 . wait)
            (71 . wait)
            (69 . wait)
            (66 . wait)
            (83 . wait)
            (85 . wait)
            )
          )
    (set! (-> gp-0 cmd 86) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (86 . wait) (93 . wait)))
    (set! (-> gp-0 cmd 87) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (87 . wait) (74 . wait)))
    (set! (-> gp-0 cmd 88) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (88 . wait) (93 . wait)))
    (set! (-> gp-0 cmd 89) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (89 . wait) (74 . wait)))
    (set! (-> gp-0 cmd 92)
          '((64 . wait)
            (72 . wait)
            (73 . wait)
            (65 . wait)
            (92 . wait)
            (69 . wait)
            (68 . wait)
            (71 . wait)
            (67 . wait)
            (66 . wait)
            )
          )
    (set! (-> gp-0 cmd 90) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (90 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 91) '((64 . wait) (72 . wait) (73 . wait) (65 . wait) (91 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 93) '((65 . wait) (86 . hide) (88 . hide)))
    (set! (-> gp-0 cmd 94) '((65 . wait) (94 . wait) (70 . hide)))
    (set! (-> gp-0 cmd 16) '((16 . wait)))
    (set! (-> gp-0 cmd 17) '((17 . wait)))
    (set! (-> gp-0 cmd 18) '((18 . wait)))
    (set! (-> gp-0 cmd 27) '((27 . wait)))
    (set! (-> gp-0 cmd 31) '((31 . wait)))
    (set! (-> gp-0 cmd 24) '((64 . wait) (24 . wait)))
    (set! (-> gp-0 cmd 26) '((64 . wait) (26 . wait)))
    (set! (-> gp-0 cmd 36) '((64 . wait) (36 . wait)))
    (set! (-> gp-0 cmd 32) '((64 . wait) (32 . wait)))
    (set! (-> gp-0 cmd 30) '((64 . wait) (30 . wait)))
    (set! (-> gp-0 cmd 33) '((64 . wait) (33 . wait)))
    (set! (-> gp-0 cmd 34) '((64 . wait) (34 . wait)))
    (set! (-> gp-0 cmd 20) '((64 . wait) (20 . wait) (19 . wait) (29 . wait) (25 . wait)))
    (set! (-> gp-0 cmd 19) '((64 . wait) (20 . wait) (19 . wait) (29 . wait) (25 . wait)))
    (set! (-> gp-0 cmd 25) '((64 . wait) (20 . wait) (19 . wait) (29 . wait) (25 . wait)))
    (set! (-> gp-0 cmd 29) '((64 . wait) (20 . wait) (19 . wait) (29 . wait) (25 . wait)))
    (set! (-> gp-0 cmd 21)
          '((64 . wait) (21 . wait) (22 . wait) (23 . wait) (25 . wait) (19 . wait) (28 . wait) (35 . wait))
          )
    (set! (-> gp-0 cmd 22)
          '((64 . wait) (21 . wait) (22 . wait) (23 . wait) (25 . wait) (19 . wait) (28 . wait) (35 . wait))
          )
    (set! (-> gp-0 cmd 23)
          '((64 . wait) (21 . wait) (22 . wait) (23 . wait) (25 . wait) (19 . wait) (28 . wait) (35 . wait))
          )
    (set! (-> gp-0 cmd 28)
          '((64 . wait) (21 . wait) (22 . wait) (23 . wait) (25 . wait) (19 . wait) (28 . wait) (35 . wait))
          )
    (set! (-> gp-0 cmd 35)
          '((64 . wait) (21 . wait) (22 . wait) (23 . wait) (25 . wait) (19 . wait) (28 . wait) (35 . wait))
          )
    ;; og:preserve-this added
    (set! (-> gp-0 cmd (gui-channel subtitle-pc)) '(((the binteger (gui-channel blackout)) . wait)))
    (set! (-> gp-0 group 18) (sound-group))
    (set! (-> gp-0 group 27) (sound-group))
    (set! (-> gp-0 group 31) (sound-group))
    (set! (-> gp-0 group 24) (sound-group music dialog))
    (set! (-> gp-0 group 26) (sound-group music dialog))
    (set! (-> gp-0 group 36) (sound-group music dialog))
    gp-0
    )
  )

(kmemopen global "gui-controls")

(define *gui-control* (new 'global 'gui-control 64))

(if (zero? *art-control*)
    (set! *art-control* (new 'global 'external-art-control))
    )

(kmemclose)
