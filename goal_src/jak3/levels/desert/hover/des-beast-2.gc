;;-*-Lisp-*-
(in-package goal)

;; name: des-beast-2.gc
;; name in dgo: des-beast-2
;; dgos: DESBATTL

;; DECOMP BEGINS

(deftype quantum-reflector (process-focusable)
  ((rod      handle)
   (minimap  connection-minimap)
   )
  (:state-methods
    hidden
    idle
    die
    )
  )


(defskelgroup skel-quantum-reflector quantum-reflector quantum-reflector-lod0-jg quantum-reflector-idle-ja
              ((quantum-reflector-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defstate hidden (quantum-reflector)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('appear)
       (let ((v1-1 (the-as object (-> block param 0))))
         (let ((a0-4 (-> self entity extra perm)))
           (logior! (-> a0-4 status) (entity-perm-status bit-5))
           (set! (-> a0-4 user-int16 0) (the int (/ (-> (the-as vector v1-1) x) METER_LENGTH)))
           (set! (-> a0-4 user-int16 1) (the int (/ (-> (the-as vector v1-1) y) METER_LENGTH)))
           (set! (-> a0-4 user-int16 2) (the int (/ (-> (the-as vector v1-1) z) METER_LENGTH)))
           )
         (set! (-> self root trans quad) (-> (the-as vector v1-1) quad))
         )
       (logclear! (-> self mask) (process-mask actor-pause))
       (send-event *camera* 'change-target self)
       (go-virtual idle)
       )
      )
    )
  :code sleep-code
  )

(defstate idle (quantum-reflector)
  :virtual #t
  :enter (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (set-time! (-> self state-time))
      (set-vector! (-> self root scale) 2.0 2.0 2.0 1.0)
      (logclear! (-> self mask) (process-mask actor-pause))
      (let ((v1-8 (-> self entity extra perm)))
        (set! (-> self root trans x) (* 4096.0 (the float (-> v1-8 user-int16 0))))
        (set! (-> self root trans y) (* 4096.0 (the float (-> v1-8 user-int16 1))))
        (set! (-> self root trans z) (* 4096.0 (the float (-> v1-8 user-int16 2))))
        )
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (set-vector! (-> gp-0 move-dist) 0.0 -204800.0 0.0 1.0)
        (set! (-> gp-0 start-pos quad) (-> self root trans quad))
        (+! (-> gp-0 start-pos y) 102400.0)
        (let ((v1-15 gp-0))
          (set! (-> v1-15 radius) 409.6)
          (set! (-> v1-15 collide-with) (collide-spec backgnd))
          (set! (-> v1-15 ignore-process0) #f)
          (set! (-> v1-15 ignore-process1) #f)
          (set! (-> v1-15 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-15 action-mask) (collide-action solid))
          )
        (let ((f0-17 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
          (cond
            ((>= f0-17 0.0)
             (let ((a0-22 (-> self root trans)))
               (let ((v1-19 (-> gp-0 start-pos)))
                 (let ((a1-1 (-> gp-0 move-dist)))
                   (let ((a2-0 f0-17))
                     (.mov vf7 a2-0)
                     )
                   (.lvf vf5 (&-> a1-1 quad))
                   )
                 (.lvf vf4 (&-> v1-19 quad))
                 )
               (.add.x.vf vf6 vf0 vf0 :mask #b1000)
               (.mul.x.vf acc vf5 vf7 :mask #b111)
               (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
               (.svf (&-> a0-22 quad) vf6)
               )
             (+! (-> self root trans y) 10240.0)
             )
            (else
              (format 0 "~A failed to find ground~%" (-> self name))
              )
            )
          )
        )
      (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 12) (the-as int #f) (the-as vector #t) 0))
      (let ((gp-1 (new 'stack-no-clear 'task-arrow-params)))
        (set! (-> gp-1 pos quad) (-> self root trans quad))
        (quaternion-identity! (-> gp-1 quat))
        (set! (-> gp-1 flags) (task-arrow-flags taf3 taf5))
        (set! (-> gp-1 map-icon) (the-as uint 12))
        (set! (-> self rod) (process->handle (task-arrow-spawn gp-1 self)))
        )
      (ja-no-eval :group! quantum-reflector-idle-ja :num! zero)
      )
    )
  :exit (behavior ()
    (send-event (handle->process (-> self rod)) 'die)
    (kill-callback (-> *minimap* engine) (-> self minimap))
    (set! (-> self minimap) #f)
    )
  :trans (behavior ()
    (let ((f0-0 (vector-vector-xz-distance-squared (target-pos 0) (-> self root trans)))
          (f1-0 24576.0)
          )
      (when (< f0-0 (* f1-0 f1-0))
        (let* ((v1-5 (-> *game-info* sub-task-list (game-task-node desert-beast-battle-resolution)))
               (a0-4 (handle->process (if (-> v1-5 manager)
                                          (-> v1-5 manager manager)
                                          (the-as handle #f)
                                          )
                                      )
                     )
               )
          (when a0-4
            (if (send-event a0-4 'complete)
                (go-virtual die)
                )
            )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (let* ((f0-1 (* 24.272593 (the float (- (current-time) (-> self state-time)))))
           (f30-0 (- f0-1 (* (the float (the int (/ f0-1 65536.0))) 65536.0)))
           )
      (quaternion-set! (-> self root quat) 0.0 (sin f30-0) 0.0 (cos f30-0))
      )
    (ja-post)
    )
  )

(defstate die (quantum-reflector)
  :virtual #t
  :enter (behavior ()
    (remove-setting! 'airlock)
    )
  :trans (behavior ()
    (when (not (-> self child))
      (cleanup-for-death self)
      (deactivate self)
      )
    )
  :code sleep-code
  )

(defmethod init-from-entity! ((this quantum-reflector) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (the-as penetrate -1))
    (let ((v1-3 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set-vector! (-> v1-3 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-3)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-quantum-reflector" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this event-hook) (-> (method-of-object this hidden) event))
  (set! (-> this rod) (the-as handle #f))
  (set! (-> this minimap) #f)
  (if (task-node-closed? (game-task-node desert-beast-battle-kill-last-beast))
      (go (method-of-object this idle))
      (go (method-of-object this hidden))
      )
  )

(deftype beast-grenade-2 (projectile-bounce)
  ((minimap       connection-minimap)
   (blast-damage  basic)
   (blast-radius  float)
   )
  (:methods
    (beast-grenade-2-method-44 (_type_) none)
    )
  )


(defmethod play-impact-sound ((this beast-grenade-2) (arg0 projectile-options))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (sound-play "ball-launch")
       )
      ((= v1-0 (projectile-options po0))
       (sound-play "ball-explode")
       )
      )
    )
  0
  (none)
  )

(defmethod projectile-method-25 ((this beast-grenade-2))
  (spawn (-> this part) (-> this root trans))
  (ja-post)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-impact! ((this beast-grenade-2))
  (go (method-of-object this impact))
  (none)
  )

;; WARN: Return type mismatch sound-id vs none.
(defmethod projectile-method-39 ((this beast-grenade-2))
  (let* ((s4-0 (-> this root))
         (s5-0 (-> s4-0 status))
         )
    (when (logtest? s5-0 (collide-status touch-surface))
      (go-impact! this)
      (vector-float*! (-> s4-0 transv) (-> s4-0 transv) 0.2)
      )
    (when (and (logtest? s5-0 (collide-status impact-surface))
               (time-elapsed? (-> this played-bounce-time) (seconds 0.3))
               )
      (set-time! (-> this played-bounce-time))
      (sound-play "grenade-bounce")
      )
    )
  (none)
  )

(defstate moving (beast-grenade-2)
  :virtual #t
  :post (behavior ()
    (transform-post)
    )
  )

(defstate impact (beast-grenade-2)
  :virtual #t
  :enter (behavior ()
    (call-parent-state-handler enter)
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-0 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-0 spawn-quat))
      (set! (-> gp-0 radius) (-> self blast-radius))
      (set! (-> gp-0 scale) 1.0)
      (set! (-> gp-0 group) (if (-> self blast-damage)
                                (-> *part-group-id-table* 411)
                                (-> *part-group-id-table* 412)
                                )
            )
      (set! (-> gp-0 collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> gp-0 damage) (if (-> self blast-damage)
                                 4.0
                                 0.0
                                 )
            )
      (set! (-> gp-0 damage-scale) 0.5)
      (set! (-> gp-0 vehicle-damage-factor) 1.0)
      (set! (-> gp-0 vehicle-impulse-factor) 0.2)
      (set! (-> gp-0 ignore-proc) (process->handle #f))
      (explosion-spawn gp-0 (the-as process-drawable *default-pool*))
      )
    (let ((f0-6 (lerp-scale 3276.8 0.0 (vector-vector-distance (camera-pos) (-> self root trans)) 40960.0 163840.0)))
      (if (!= f0-6 0.0)
          (activate! *camera-smush-control* f0-6 37 600 1.0 0.1 (-> self clock))
          )
      )
    (cpad-set-buzz!
      (-> *cpad-list* cpads 0)
      1
      (the int (* 255.0 (lerp-scale
                          1.0
                          0.0
                          (vector-vector-distance (target-pos 0) (-> self root trans))
                          40960.0
                          (-> self blast-radius)
                          )
                  )
           )
      (seconds 0.2)
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-35 (-> self root root-prim)))
      (set! (-> v1-35 prim-core collide-as) (collide-spec))
      (set! (-> v1-35 prim-core collide-with) (collide-spec))
      )
    0
    )
  :code (behavior ()
    (while (-> self child)
      (suspend)
      )
    )
  )

(defstate dissipate (beast-grenade-2)
  :virtual #t
  :enter (behavior ()
    (call-parent-state-handler enter)
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    )
  )

(defmethod handle-proj-hit! ((this beast-grenade-2) (arg0 process) (arg1 event-message-block))
  (when (time-elapsed? (-> this spawn-time) (seconds 0.5))
    (let ((t9-0 (method-of-type projectile-bounce handle-proj-hit!)))
      (when (not (t9-0 this arg0 arg1))
        (when (type? arg0 projectile)
          (set! (-> this blast-damage) #f)
          enter-state
          (go (method-of-object this impact))
          )
        )
      )
    )
  )

(defmethod setup-collision! ((this beast-grenade-2))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) projectile-bounce-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate explode))
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  (set-collide-with!
    (-> this root)
    (collide-spec
      backgnd
      jak
      crate
      civilian
      enemy
      obstacle
      vehicle-sphere
      hit-by-others-list
      player-list
      pusher
      shield
      )
    )
  (set-collide-as! (-> this root) (collide-spec enemy))
  (set! (-> this root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1 :board #x1)
        )
  (none)
  )

(defmethod init-proj-settings! ((this beast-grenade-2))
  (set! (-> this attack-mode) 'eco-dark)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-des-beast-grenade" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
    (t9-2 this)
    )
  (set! (-> this move)
        (lambda ((arg0 projectile))
          (when (< (-> arg0 root transv y) 0.0)
            (let* ((s5-0 (handle->process (-> arg0 desired-target)))
                   (a0-5 (if (type? s5-0 process-focusable)
                             s5-0
                             )
                         )
                   )
              (when a0-5
                (let ((s5-2
                        (vector-! (new 'stack-no-clear 'vector) (get-trans (the-as process-focusable a0-5) 0) (-> arg0 root trans))
                        )
                      (s4-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 root transv) 1.0))
                      (f30-0 (vector-length (-> arg0 root transv)))
                      )
                  (vector-normalize! s5-2 1.0)
                  (rotate-vector-to-vector
                    s4-0
                    s5-2
                    (the-as vector (* 182.04445 (seconds-per-frame) (lerp-scale 0.0 30.0 (-> arg0 root transv y) 0.0 -40960.0)))
                    )
                  (vector-normalize-copy! (-> arg0 root transv) s4-0 f30-0)
                  )
                )
              )
            )
          (seek-toward-heading-vec! (-> arg0 root) (-> arg0 root transv) 131072.0 (seconds 0.1))
          (quaternion*! (-> arg0 root quat) (-> arg0 root quat) (the-as quaternion (&-> arg0 stack 400)))
          (projectile-move-fill-all-dirs arg0)
          (none)
          )
        )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 413) this))
  (set! (-> this blast-radius) 163840.0)
  (set! (-> this max-speed) 122880.0)
  (set! (-> this timeout) (seconds 6))
  (set! (-> this gravity) 36864.0)
  (set! (-> this desired-target) (-> *vehicle-info* handle-by-vehicle-type 14))
  (set! (-> this blast-damage) (the-as basic #t))
  (set! (-> this vehicle-damage-factor) 0.333)
  (let ((s5-1 (new 'stack-no-clear 'light-trail-tracker-spawn-params)))
    (set! (-> s5-1 tracked-obj) (process->handle this))
    (set! (-> s5-1 appearance) *beast-grenade-trail*)
    (set! (-> s5-1 max-num-crumbs) (the int (* 0.5 (the float (-> s5-1 appearance max-age)))))
    (set! (-> s5-1 track-immediately?) #t)
    (let* ((v1-28 (estimate-light-trail-mem-usage
                    (the-as uint (-> s5-1 max-num-crumbs))
                    (the-as uint (= (-> s5-1 appearance lie-mode) (lie-mode use-two-strips)))
                    )
                  )
           (s4-1 (get-process *default-dead-pool* light-trail-tracker-projectile (+ v1-28 8192) 1))
           )
      (when s4-1
        (let ((t9-6 (method-of-type process activate)))
          (t9-6 s4-1 *entity-pool* "light-trail" (the-as pointer #x70004000))
          )
        (run-now-in-process s4-1 light-trail-tracker-init-by-other s5-1)
        (-> s4-1 ppointer)
        )
      )
    )
  (set-vector! (-> this root scale) 16.0 16.0 16.0 1.0)
  (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 135) (the-as int #f) (the-as vector #t) 0))
  0
  (none)
  )

(deftype des-beast-2 (des-beast)
  ((focus-vel        vector  :inline)
   (shot-velocity    vector  :inline)
   (vehicle-handle   handle)
   (pickup-handle    handle)
   (shot-count       uint32)
   (follow-distance  float)
   (anim-interp      float)
   (last-beast       basic)
   )
  )


(defstate hostile (des-beast-2)
  :virtual #t
  :enter (behavior ()
    (if (!= (-> self run-start-frame) 0.0)
        (quaternion-rotate-local-y! (-> self root quat) (-> self root quat) 32768.0)
        )
    (set! (-> self oomass) 1.0)
    (set-time! (-> self state-time))
    (set! (-> self main-speed-factor) 0.8)
    (set! (-> self main-speed-factor-dest) 0.8)
    (set! (-> self shot-count) (the-as uint 0))
    (logclear! (-> self mask) (process-mask actor-pause))
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (if (and (!= (-> self s-clock) 1.0) *camera*)
        (set! (-> *camera* slave 0 trans quad) (-> *beast-camera-slow-motion* quad))
        )
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (let* ((s4-0 (the int (the float (the int (-> self path-pos)))))
             (s5-0 (+ s4-0 1))
             (f0-6 (-> self path-pos))
             (f30-0 (- f0-6 (the float (the int f0-6))))
             )
        (if (= s5-0 (-> self des-path node-count))
            (go-virtual die)
            )
        (vector-lerp!
          gp-0
          (the-as vector (-> self des-path node s4-0))
          (the-as vector (-> self des-path node s5-0))
          f30-0
          )
        )
      (seek-toward-heading-vec!
        (-> self root)
        (vector-! (new 'stack-no-clear 'vector) gp-0 (-> self root trans))
        14563.556
        (seconds 0.1)
        )
      (when (< (vector-vector-distance (-> self root trans) gp-0) 204800.0)
        (+! (-> self path-pos) (* 10.0 (seconds-per-frame) (-> self path-pos-speed)))
        (des-beast-method-163 self)
        )
      )
    (when (< (-> self next-shoot) (current-time))
      (when (< (vector-vector-xz-distance (-> self root trans) (-> self target-gun-pos)) 819200.0)
        (des-beast-method-164 self)
        (+! (-> self shot-count) 1)
        (set! (-> self next-shoot) (+ (current-time) (cond
                                                       ((< (the-as uint 2) (-> self shot-count))
                                                        (set! (-> self shot-count) (the-as uint 0))
                                                        (if (-> self last-beast)
                                                            900
                                                            1500
                                                            )
                                                        )
                                                       ((-> self last-beast)
                                                        450
                                                        )
                                                       (else
                                                         750
                                                         )
                                                       )
                                      )
              )
        )
      )
    (when (< (-> self hit-points) 0.0)
      (if (-> self last-beast)
          (send-event (ppointer->process (-> self parent)) 'last-beast-died (-> self root trans))
          (send-event (ppointer->process (-> self parent)) 'beast-died (-> self root trans))
          )
      (go-virtual die-run)
      )
    )
  :code (behavior ()
    (ja-channel-push! 2 0)
    (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
    (ja-no-eval :group! (-> self draw art-group data 5) :num! (seek!) :frame-num 0.0)
    (until #f
      (let ((f30-0 (lerp-scale 0.0 1.0 (-> self main-speed-factor-dest) 0.8 1.0)))
        (let ((a0-4 (-> self skel root-channel 0)))
          (let ((f0-10 (- 1.0 f30-0)))
            (set! (-> a0-4 frame-interp 1) f0-10)
            (set! (-> a0-4 frame-interp 0) f0-10)
            )
          (set! (-> a0-4 frame-group) (the-as art-joint-anim (-> self draw art-group data 4)))
          (set! (-> a0-4 param 0) 0.0)
          (set! (-> a0-4 frame-num) (-> self skel root-channel 0 frame-num))
          (joint-control-channel-group! a0-4 (the-as art-joint-anim (-> self draw art-group data 4)) num-func-chan)
          )
        (ja-no-eval :chan 1
                    :group! (-> self draw art-group data 5)
                    :num! (chan 0)
                    :frame-interp0 f30-0
                    :frame-interp1 f30-0
                    :frame-num (-> self skel root-channel 0 frame-num)
                    )
        (set! (-> self anim-interp) f30-0)
        )
      (ja :num! (loop! (fmax 0.8 (* (-> self main-speed-factor) (-> self speed-factor)))))
      (des-beast-method-162 self)
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (local-vars
      (sv-336 float)
      (sv-496 vector)
      (sv-500 float)
      (sv-504 int)
      (sv-512 (inline-array desbeast-node))
      (sv-516 vector)
      )
    (cond
      (#f
        (let ((s3-0 (-> self target-gun-pos))
              (gp-0 (new 'stack-no-clear 'trajectory))
              (s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 21)))
              (s4-0 (new 'stack-no-clear 'vector))
              )
          (vector+! s3-0 (-> self focus-pos) (-> self focus-vel))
          (setup-from-to-height! gp-0 s5-0 s3-0 122880.0 -36864.0)
          (compute-transv-at-time gp-0 0.0 s4-0)
          (add-debug-vector #t (bucket-id debug-no-zbuf1) s5-0 s4-0 (meters 0.00024414062) *color-red*)
          )
        )
      (#f
        (new 'stack-no-clear 'vector)
        (let ((gp-1 (-> self target-gun-pos))
              (v1-9 (-> self root trans))
              (s5-1 (new 'stack-no-clear 'inline-array 'vector 16))
              )
          (set! (-> s5-1 0 quad) (-> self focus-pos quad))
          (set! (-> s5-1 1 quad) (-> self focus-vel quad))
          (vector-! (-> s5-1 5) (-> s5-1 0) v1-9)
          (set! (-> s5-1 2 x) (vector-length (-> s5-1 5)))
          (vector-normalize! (-> s5-1 5) 1.0)
          (set! (-> s5-1 2 y) (/ 122880.0 (vector-length (-> s5-1 1))))
          (set! (-> s5-1 2 z) (vector-dot
                                (vector-float*! (new 'stack-no-clear 'vector) (-> s5-1 5) -1.0)
                                (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-1 1) 1.0)
                                )
                )
          (let ((f0-6 1.0)
                (f1-1 (-> s5-1 2 y))
                )
            (set! (-> s5-1 2 w) (- f0-6 (* f1-1 f1-1)))
            )
          (set! (-> s5-1 3 x) (* 2.0 (-> s5-1 2 z) (-> s5-1 2 y) (-> s5-1 2 x)))
          (let ((f0-12 (-> s5-1 2 x)))
            (set! (-> s5-1 3 y) (- (* f0-12 f0-12)))
            )
          (let ((f0-16 (-> s5-1 3 x)))
            (set! (-> s5-1 3 z) (- (* f0-16 f0-16) (* 4.0 (-> s5-1 3 y) (-> s5-1 2 w))))
            )
          (when (>= (-> s5-1 3 z) 0.0)
            (let ((f0-22 (- (-> s5-1 3 x)))
                  (f1-12 (sqrtf (-> s5-1 3 z)))
                  )
              (if (< f1-12 f0-22)
                  (set! (-> s5-1 3 w) (/ (- f0-22 f1-12) (* 2.0 (-> s5-1 2 w))))
                  (set! (-> s5-1 3 w) (/ (+ f0-22 f1-12) (* 2.0 (-> s5-1 2 w))))
                  )
              )
            (set! (-> s5-1 4 x) (/ (-> s5-1 3 w) (+ 90112.0 (fmax 0.0 (vector-dot (-> self root transv) (-> s5-1 5))))))
            (vector+float*! gp-1 (-> s5-1 0) (-> s5-1 1) (-> s5-1 4 x))
            0
            )
          (let ((f1-20 (/ (-> s5-1 2 x) (meters 30))))
            (set! (-> gp-1 y)
                  (fmin (+ 327680.0 (-> self root trans y)) (+ 20480.0 (* 9216.0 (* f1-20 f1-20)) (-> gp-1 y)))
                  )
            )
          )
        )
      (else
        (vector+! (-> self target-gun-pos) (-> self focus-pos) (-> self focus-vel))
        (let ((s5-2 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 21)))
              (gp-2 (new 'stack-no-clear 'trajectory))
              )
          (let ((s3-2 (vector-! (new 'stack-no-clear 'vector) (-> self target-gun-pos) s5-2))
                (s4-3 (new 'stack-no-clear 'vector))
                )
            (let ((f0-34 (vector-length s3-2)))
              (set! sv-336 (the-as float 0.0))
              (let ((f0-35 (fmin 819200.0 f0-34)))
                (vector-normalize! s3-2 f0-35)
                )
              )
            (vector+! s4-3 s5-2 s3-2)
            (set! sv-336 (the-as float 122880.0))
            (setup-from-to-height! gp-2 s5-2 s4-3 32768.0 -36864.0)
            )
          (set! (-> self shot-velocity quad) (-> gp-2 initial-velocity quad))
          )
        (vector-length-max! (-> self shot-velocity) 122880.0)
        )
      )
    (when (>= 1638400.0 (vector-vector-xz-distance (-> self root trans) (target-pos 0)))
      (let ((gp-4 (new 'stack-no-clear 'vector)))
        (transform-point-vector! gp-4 (-> self root trans))
        (+! (-> gp-4 x) -2048.0)
        (cond
          ((< (-> gp-4 z) 0.0)
           (let ((gp-6 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (camera-pos))))
             (if (< 0.0 (vector-dot gp-6 (-> (camera-matrix) rvec)))
                 (send-event (handle->process (-> self manager)) 'off-to-left)
                 (send-event (handle->process (-> self manager)) 'off-to-right)
                 )
             )
           )
          (else
            (cond
              ((< (-> gp-4 x) -248.0)
               (send-event (handle->process (-> self manager)) 'off-to-left)
               )
              ((< 264.0 (-> gp-4 x))
               (send-event (handle->process (-> self manager)) 'off-to-right)
               )
              )
            )
          )
        )
      )
    (let ((gp-7 *target*))
      (when gp-7
        (set! sv-496 (new 'stack-no-clear 'vector))
        (set! sv-500 (the-as float 0.0))
        (set! sv-504 -1)
        (set! sv-512 (-> self des-path node))
        (let ((s5-5 (new 'stack-no-clear 'vector)))
          (set! (-> s5-5 quad) (-> (get-trans gp-7 0) quad))
          (set! sv-516 s5-5)
          )
        (vector+float*!
          sv-516
          sv-516
          (vector-z-quaternion! (new 'stack-no-clear 'vector) (get-quat gp-7 0))
          (-> self follow-distance)
          )
        (dotimes (gp-8 (the-as int (+ (-> self des-path node-count) -1)))
          (let* ((a1-30 (-> sv-512 gp-8))
                 (a2-9 (-> sv-512 (+ gp-8 1)))
                 (s5-8 (new 'stack-no-clear 'vector))
                 (f0-47 (vector-segment-distance-point! sv-516 (the-as vector a1-30) (the-as vector a2-9) s5-8))
                 )
            (when (or (= sv-504 -1) (< f0-47 sv-500))
              (set! sv-500 f0-47)
              (set! sv-504 gp-8)
              (set! (-> sv-496 quad) (-> s5-8 quad))
              )
            )
          )
        (when (!= sv-504 -1)
          (let* ((s4-5 (-> self root trans))
                 (s5-9 (new 'stack-no-clear 'inline-array 'vector 2))
                 (f30-2 (vector-vector-distance s4-5 sv-496))
                 )
            (if (< (vector-dot (vector-! (-> s5-9 0) sv-496 s4-5) (vector-z-quaternion! (-> s5-9 1) (-> self root quat))) 0.0)
                (set! f30-2 (* -1.0 f30-2))
                )
            (let ((f0-53 (* (lerp-scale -0.7 0.7 f30-2 -245760.0 245760.0) (lerp-scale 1.0 0.0 sv-500 122880.0 983040.0))))
              (seek! (-> self main-speed-factor-dest) (+ 0.8 f0-53) (* 0.6 (seconds-per-frame)))
              )
            )
          )
        )
      )
    (enemy-common-post self)
    )
  )

(defstate die-run (des-beast-2)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('death-end)
       (go-virtual die)
       )
      )
    )
  :enter (behavior ()
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (set! (-> self oomass) 0.001)
    (set! (-> self root penetrated-by) (penetrate))
    (sound-play "desbeast-death")
    (process-entity-status! self (entity-perm-status dead) #t)
    (set-time! (-> self state-time))
    (set! (-> self pickup-handle) (the-as handle #f))
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data 16))
    )
  :trans (behavior ()
    (when (and (-> self last-beast) (time-elapsed? (-> self state-time) (seconds 1.5)) (not (-> self pickup-handle)))
      (let ((gp-0 (entity-by-name "quantum-reflector-1")))
        (when gp-0
          (entity-birth-no-kill gp-0)
          (let ((a0-4 (if gp-0
                          (-> gp-0 extra process)
                          )
                      )
                )
            (when a0-4
              (set! (-> self pickup-handle) (process->handle a0-4))
              (send-event a0-4 'appear (-> self root trans))
              (set-setting! 'string-max-length 'abs (meters 30) 0)
              (set-setting! 'string-min-length 'abs (meters 10) 0)
              (set-setting! 'string-max-height 'abs (meters 25) 0)
              (let ((v1-25 (-> (process->handle self) process)))
                (set-setting! 'handle-of-interest v1-25 0.0 (-> v1-25 0 pid))
                )
              )
            )
          )
        )
      )
    )
  :code (behavior ()
    (suspend-for (seconds 0.1)
      )
    (until (ja-done? 0)
      (suspend)
      )
    (logior! (-> self skel effect flags) (effect-control-flag ecf1))
    (do-effect (-> self skel effect) "death-default" 0.0 -1)
    (suspend-for (seconds 3)
      )
    (go-virtual die)
    )
  :post (behavior ()
    (seek! (-> self main-speed-factor-dest) 1.0 (* 0.5 (seconds-per-frame)))
    (ja :num! (seek! max (* (-> self main-speed-factor) (-> self speed-factor))))
    (des-beast-method-162 self)
    (enemy-common-post self)
    )
  )

(defstate die (des-beast-2)
  :virtual #t
  :event #f
  :enter (behavior ()
    (logior! (-> self skel effect flags) (effect-control-flag ecf2))
    (logior! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-8 (-> self root root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (cleanup-for-death self)
    )
  :exit #f
  :trans (behavior ()
    (if (not (-> self child))
        (deactivate self)
        )
    )
  :code sleep-code
  :post #f
  )

(defmethod get-linear-vel! ((this des-beast-2) (arg0 vector))
  (cond
    ((and (-> this next-state) (= (-> this next-state name) 'hostile))
     (let ((s4-0 (new 'stack-no-clear 'vector)))
       (set! (-> s4-0 quad) (-> (ja-linear-vel 0) quad))
       (let ((s3-0 (new 'stack-no-clear 'vector)))
         (set! (-> s3-0 quad) (-> (ja-linear-vel 1) quad))
         (vector-lerp! arg0 s4-0 s3-0 (-> this anim-interp))
         )
       )
     )
    (else
      ((method-of-type des-beast get-linear-vel!) this arg0)
      )
    )
  )

(defmethod des-beast-method-164 ((this des-beast-2))
  (let* ((a1-0 (-> this node-list data 21))
         (a0-2 (vector<-cspace! (new 'stack-no-clear 'vector) a1-0))
         (v1-1 (-> this shot-velocity))
         )
    (new 'stack-no-clear 'vector)
    (vector+! v1-1 v1-1 (-> this root transv))
    (let ((a1-3 (new 'stack-no-clear 'projectile-init-by-other-params)))
      (set! (-> a1-3 ent) (-> this entity))
      (set! (-> a1-3 charge) 1.0)
      (set! (-> a1-3 options) (projectile-options))
      (logclear! (-> a1-3 options) (projectile-options po14 po15 po16))
      (set! (-> a1-3 pos quad) (-> a0-2 quad))
      (set! (-> a1-3 vel quad) (-> v1-1 quad))
      (set! (-> a1-3 notify-handle) (the-as handle #f))
      (set! (-> a1-3 owner-handle) (process->handle this))
      (set! (-> a1-3 target-handle) (the-as handle #f))
      (set! (-> a1-3 target-pos quad) (-> this target-gun-pos quad))
      (set! (-> a1-3 ignore-handle) (process->handle this))
      (let* ((v1-10 *game-info*)
             (a0-16 (+ (-> v1-10 attack-id) 1))
             )
        (set! (-> v1-10 attack-id) a0-16)
        (set! (-> a1-3 attack-id) a0-16)
        )
      (set! (-> a1-3 timeout) (seconds 4))
      (spawn-projectile beast-grenade-2 a1-3 this *default-dead-pool*)
      )
    )
  0
  (none)
  )

(defmethod find-best-focus ((this des-beast-2))
  (if (not (-> this vehicle-handle))
      (set! (-> this vehicle-handle) (-> *vehicle-info* handle-by-vehicle-type 14))
      )
  (let* ((s4-0 (handle->process (-> this vehicle-handle)))
         (s5-0 (if (type? s4-0 process-focusable)
                   s4-0
                   )
               )
         )
    (when s5-0
      (enemy-method-70 this (the-as process-focusable s5-0) (get-enemy-aware this (enemy-aware ea3)))
      s5-0
      )
    )
  )

;; WARN: Return type mismatch int vs process.
(defmethod update-focus ((this des-beast-2))
  (call-parent-method this)
  (let ((s4-0 (handle->process (-> this focus handle))))
    (when s4-0
      (set! (-> this focus-pos quad) (-> (get-trans (the-as process-focusable s4-0) 3) quad))
      (let ((s5-1 (new 'stack-no-clear 'vector)))
        (set! (-> s5-1 quad) (-> (get-transv (the-as process-focusable s4-0)) quad))
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          (set! (-> s4-1 quad) (-> this focus-vel quad))
          (let* ((f28-0 (vector-length s4-1))
                 (f30-0 (lerp f28-0 (vector-length s5-1) (* 0.75 (seconds-per-frame))))
                 )
            (cond
              ((< 0.0 f28-0)
               (vector-normalize! s5-1 1.0)
               (vector-normalize! s4-1 1.0)
               (rotate-vector-to-vector s4-1 s5-1 (the-as vector (* 7281.778 (seconds-per-frame))))
               (vector-float*! (-> this focus-vel) s4-1 f30-0)
               )
              (else
                (set! (-> this focus-vel quad) (-> s5-1 quad))
                )
              )
            )
          )
        )
      )
    )
  (the-as process 0)
  )

(defmethod enemy-common-post ((this des-beast-2))
  (if (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status on-screen)))
      (set-time! (-> this last-draw-time))
      )
  (update-focus this)
  ((method-of-type des-beast enemy-common-post) this)
  (none)
  )

(defmethod event-handler ((this des-beast-2) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('event-foot)
     (sound-play "desbeast-step")
     (let ((f0-0 (lerp-scale 204.8 0.0 (vector-vector-distance (camera-pos) (-> this root trans)) 204800.0 737280.0)))
       (if (!= f0-0 0.0)
           (activate! *camera-smush-control* f0-0 37 600 1.0 0.1 (-> self clock))
           )
       )
     )
    (('follow-distance)
     (set! (-> this follow-distance) (the-as float (-> arg3 param 0)))
     )
    (('last-beast)
     (set! (-> this hit-points) (* 3.0 (-> this hit-points)))
     (let ((v0-5 (the-as object #t)))
       (set! (-> this last-beast) (the-as basic v0-5))
       v0-5
       )
     )
    (else
      ((method-of-type des-beast event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod go-idle2 ((this des-beast-2))
  (go (method-of-object this hostile))
  )

;; WARN: Return type mismatch cspace vs none.
(defmethod init-enemy! ((this des-beast-2))
  (let ((t9-0 (method-of-type des-beast init-enemy!)))
    (t9-0 this)
    )
  (set! (-> this vehicle-handle) (the-as handle #f))
  (set! (-> this hit-points) 80.0)
  (set! (-> this follow-distance) 0.0)
  (set! (-> this last-beast) #f)
  (vector-reset! (-> this focus-vel))
  (let ((a0-2 (-> this node-list data 20)))
    (set! (-> a0-2 param0)
          (lambda ((arg0 cspace) (arg1 transformq))
            (cspace<-parented-transformq-joint! arg0 arg1)
            (let ((s4-0 (-> arg0 param1))
                  (gp-0 (new 'stack-no-clear 'matrix))
                  )
              (matrix->trans (-> arg0 bone transform) (-> gp-0 trans))
              (vector-normalize-copy! (-> gp-0 uvec) (-> (the-as des-beast-2 s4-0) shot-velocity) 1.0)
              (set! (-> (the-as des-beast-2 s4-0) angle-turret)
                    (deg-seek
                      (-> (the-as des-beast-2 s4-0) angle-turret)
                      (vector-y-angle (-> gp-0 uvec))
                      (* 16384.0 (seconds-per-frame))
                      )
                    )
              (quaternion-vector-angle!
                (the-as quaternion (-> gp-0 rvec))
                *up-vector*
                (-> (the-as des-beast-2 s4-0) angle-turret)
                )
              (quaternion->matrix (-> arg0 bone transform) (the-as quaternion (-> gp-0 rvec)))
              (set! (-> arg0 bone transform trans quad) (-> gp-0 trans quad))
              )
            0
            (none)
            )
          )
    (set! (-> a0-2 param1) this)
    )
  (let ((v0-1 (-> this node-list data 21)))
    (set! (-> v0-1 param0)
          (lambda ((arg0 cspace) (arg1 transformq))
            (cspace<-parented-transformq-joint! arg0 arg1)
            (let ((s4-0 (-> arg0 param1))
                  (gp-0 (new 'stack-no-clear 'matrix))
                  )
              (matrix->trans (-> arg0 bone transform) (-> gp-0 trans))
              (vector-normalize-copy! (-> gp-0 fvec) (-> (the-as des-beast-2 s4-0) shot-velocity) 1.0)
              (set! (-> (the-as des-beast-2 s4-0) angle-gun)
                    (deg-seek
                      (-> (the-as des-beast-2 s4-0) angle-gun)
                      (- (vector-x-angle (-> gp-0 fvec)))
                      (* 10922.667 (seconds-per-frame))
                      )
                    )
              (quaternion-vector-angle!
                (the-as quaternion (-> gp-0 rvec))
                *y-vector*
                (-> (the-as des-beast-2 s4-0) angle-turret)
                )
              (quaternion-vector-angle!
                (the-as quaternion (-> gp-0 uvec))
                *x-vector*
                (-> (the-as des-beast-2 s4-0) angle-gun)
                )
              (quaternion*!
                (the-as quaternion (-> gp-0 uvec))
                (the-as quaternion (-> gp-0 rvec))
                (the-as quaternion (-> gp-0 uvec))
                )
              (quaternion->matrix (-> arg0 bone transform) (the-as quaternion (-> gp-0 uvec)))
              (set! (-> arg0 bone transform trans quad) (-> gp-0 trans quad))
              )
            0
            (none)
            )
          )
    (set! (-> v0-1 param1) this)
    )
  (none)
  )
