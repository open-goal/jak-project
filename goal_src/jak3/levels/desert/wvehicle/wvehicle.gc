;;-*-Lisp-*-
(in-package goal)

;; name: wvehicle.gc
;; name in dgo: wvehicle
;; dgos: LPATK, LFACCAR, WASALL

;; DECOMP BEGINS

(defmethod wvehicle-method-166 ((this wvehicle) (arg0 float) (arg1 float))
  (let* ((v1-0 (-> this info))
         (f0-0 (-> this engine-max-torque))
         (f1-3 (* (+ 1.0 (-> v1-0 engine drag))
                  (if (< arg0 (-> v1-0 engine max-rpm))
                      1.0
                      0.0
                      )
                  (fmax (-> this idle-throttle) arg1)
                  )
               )
         (f2-5 0.2)
         (f3-2 1.0)
         (f4-2 (/ (- arg0 (-> v1-0 engine peak-torque-rpm)) (-> v1-0 engine powerband-width-rpm)))
         )
    (* f0-0 (+ (* f1-3 (fmax f2-5 (- f3-2 (* f4-2 f4-2))))
               (* -1.0 (/ arg0 (-> v1-0 engine peak-torque-rpm)) (-> v1-0 engine drag))
               )
       )
    )
  )

(defmethod wvehicle-method-164 ((this wvehicle) (arg0 vehicle-wheel-state) (arg1 vehicle-wheel-info))
  (let ((gp-0 (new 'stack-no-clear 'wvehicle-stack-type6)))
    (set-vector! (-> gp-0 vec0) 1.0 0.0 0.0 1.0)
    (set-vector! (-> gp-0 vec1) 0.0 1.0 0.0 1.0)
    (quaternion-copy! (-> gp-0 quat3) (-> this root quat))
    (let* ((v1-3 (-> gp-0 mat0))
           (a3-0 (-> this rbody matrix))
           (a0-7 (-> a3-0 rvec quad))
           (a1-2 (-> a3-0 uvec quad))
           (a2-1 (-> a3-0 fvec quad))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-3 rvec quad) a0-7)
      (set! (-> v1-3 uvec quad) a1-2)
      (set! (-> v1-3 fvec quad) a2-1)
      (set! (-> v1-3 trans quad) a3-1)
      )
    (set! (-> gp-0 vec2 quad) (-> arg1 local-pos quad))
    (+! (-> gp-0 vec2 x) (-> arg1 susp-arm-length))
    (set! (-> gp-0 vec2 x) (* (-> gp-0 vec2 x) (-> arg0 x-scale)))
    (+! (-> gp-0 vec2 y) (-> arg1 probe-y-offset))
    (vector+float*!
      (-> arg0 probe-local-pos)
      (-> gp-0 vec2)
      (-> arg0 local-axis)
      (* (-> arg1 steer-arm-length) (-> arg0 x-scale))
      )
    (set! (-> gp-0 float0)
          (+ (-> arg1 probe-y-offset) (* (-> arg1 radius) (-> arg1 scale)) (* -1.0 (-> arg0 pos2) (-> arg1 travel)))
          )
    (set! (-> arg0 sin-susp-ang) (fmax -1.0 (fmin 1.0 (/ (-> gp-0 float0) (-> arg1 susp-arm-length)))))
    (let ((f0-21 1.0)
          (f1-11 (-> arg0 sin-susp-ang))
          )
      (set! (-> arg0 cos-susp-ang) (sqrtf (- f0-21 (* f1-11 f1-11))))
      )
    (quaternion-identity! (-> gp-0 quat4))
    (set! (-> gp-0 quat4 z) (* (sin (-> arg1 camber)) (-> arg0 x-scale)))
    (set! (-> gp-0 quat4 w) (cos (-> arg1 camber)))
    (when (logtest? (-> arg1 flags) (vehicle-wheel-flag vwf5))
      (quaternion-set!
        (-> gp-0 quat0)
        0.0
        0.0
        (* (-> arg0 sin-susp-ang) (-> arg0 x-scale))
        (+ 1.0 (-> arg0 cos-susp-ang))
        )
      (quaternion-normalize! (-> gp-0 quat0))
      (quaternion*! (-> gp-0 quat4) (-> gp-0 quat4) (-> gp-0 quat0))
      )
    (set! (-> gp-0 vec2 quad) (-> arg1 local-pos quad))
    (+! (-> gp-0 vec2 x) (* (-> arg1 susp-arm-length) (-> arg0 cos-susp-ang)))
    (set! (-> gp-0 vec2 x) (* (-> gp-0 vec2 x) (-> arg0 x-scale)))
    (+! (-> gp-0 vec2 y) (-> gp-0 float0))
    (vector+float*!
      (-> gp-0 vec2)
      (-> gp-0 vec2)
      (-> arg0 local-axis)
      (* (-> arg1 steer-arm-length) (-> arg0 x-scale))
      )
    (vector-matrix*! (-> gp-0 vec3) (-> gp-0 vec2) (-> gp-0 mat0))
    (quaternion-vector-angle! (-> gp-0 quat2) (-> gp-0 vec1) (-> arg0 steer-angle))
    (quaternion-vector-angle! (-> gp-0 quat1) (-> gp-0 vec0) (-> arg0 angle))
    (quaternion*! (-> gp-0 quat0) (-> gp-0 quat2) (-> gp-0 quat4))
    (quaternion*! (-> gp-0 quat0) (-> gp-0 quat0) (-> gp-0 quat1))
    (quaternion*! (-> arg0 quat) (-> gp-0 quat3) (-> gp-0 quat0))
    (set! (-> arg0 trans quad) (-> gp-0 vec3 quad))
    )
  0
  (none)
  )

(defmethod wvehicle-method-165 ((this wvehicle))
  (let ((s5-0 (new 'stack-no-clear 'vehicle-controls)))
    (set! (-> s5-0 steering) (seconds-per-frame))
    (dotimes (s4-0 (-> this info physics-model wheel-count))
      (let* ((a1-0 (-> this wheel s4-0))
             (a2-0 (-> a1-0 info))
             )
        (let* ((f0-1 (-> a1-0 pos2))
               (f1-1 (- (-> a1-0 pos) (-> a1-0 pos2)))
               (f2-1 1.0)
               (f3-0 (-> s5-0 steering))
               (f4-0 (-> a1-0 forward-vel))
               (f4-2 (* f4-0 f4-0))
               (f5-0 (-> a1-0 up-vel))
               (f4-3 (+ f4-2 (* f5-0 f5-0)))
               (f5-3 8192.0)
               (f3-1 (* f3-0 (fmin f4-3 (* f5-3 f5-3))))
               (f4-5 15.0)
               (f5-6 8192.0)
               )
          (set! (-> a1-0 pos2) (+ f0-1 (* f1-1 (fmin f2-1 (* f3-1 (/ f4-5 (* f5-6 f5-6)))))))
          )
        (set! (-> a1-0 angle)
              (the float (sar (shl (the int (+ (-> a1-0 angle) (* 10430.379 (-> a1-0 rev) (-> s5-0 steering)))) 48) 48))
              )
        ((-> a2-0 callback) this a1-0 a2-0)
        )
      )
    )
  (let ((s5-1 (new 'stack-no-clear 'matrix)))
    (let ((a2-1 (-> this draw shadow-ctrl settings)))
      (vector+float*! (-> s5-1 rvec) (-> a2-1 center) (-> a2-1 shadow-dir) (-> a2-1 shadow-dir w))
      )
    0
    (dotimes (s4-1 (-> this info physics-model wheel-count))
      (let ((s3-0 (-> this wheel s4-1)))
        (-> s3-0 info)
        (let ((s2-0 (handle->process (-> s3-0 handle))))
          (cond
            (s2-0
              (let ((s1-0 (-> (the-as process-focusable s2-0) draw shadow-ctrl settings)))
                (vector-! (-> s5-1 uvec) (-> s5-1 rvec) (-> s1-0 center))
                (vector-normalize! (-> s5-1 uvec) 1.0)
                (mem-copy! (the-as pointer s1-0) (the-as pointer (-> this draw shadow-ctrl settings)) 80)
                (set! (-> s5-1 uvec w) (-> s1-0 shadow-dir w))
                (set! (-> s1-0 shadow-dir quad) (-> s5-1 uvec quad))
                )
              (let ((v1-39 (-> (the-as process-focusable s2-0) root)))
                (set! (-> v1-39 trans quad) (-> s3-0 trans quad))
                (quaternion-copy! (-> v1-39 quat) (-> s3-0 quat))
                )
              (logand! (-> s3-0 flags) -9)
              (cond
                ((< 11.780972 (fabs (-> s3-0 rev)))
                 (when (not (logtest? (-> s3-0 flags) 1))
                   (logior! (-> s3-0 flags) 1)
                   (lods-assign! (-> (the-as process-focusable s2-0) draw) (the-as lod-set (&-> s2-0 stack 216)))
                   )
                 )
                (else
                  (when (logtest? (-> s3-0 flags) 1)
                    (logand! (-> s3-0 flags) -2)
                    (lods-assign! (-> (the-as process-focusable s2-0) draw) (the-as lod-set (&-> s2-0 stack 164)))
                    )
                  )
                )
              )
            (else
              (logior! (-> s3-0 flags) 8)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod clear-impulse-force-flag! ((this wvehicle))
  (let ((t9-0 (method-of-type vehicle clear-impulse-force-flag!)))
    (t9-0 this)
    )
  (when (logtest? (vehicle-flag waiting-for-player) (-> this v-flags))
    (let ((s5-0 (-> this root)))
      (when (and (logtest? (-> this v-flags) (vehicle-flag player-touching))
                 (not (logtest? (vehicle-flag player-driving) (-> this v-flags)))
                 )
        (pull-riders! s5-0)
        (cond
          ((logtest? (do-push-aways s5-0) (collide-spec jak))
           (+! (-> this overlap-player-counter) 1)
           (when (< (the-as uint 60) (-> this overlap-player-counter))
             (send-event
               *target*
               'attack-invinc
               #f
               (static-attack-info
                 :mask (vehicle-impulse-factor)
                 ((id (new-attack-id)) (damage 1000.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'smush))
                 )
               )
             (set! (-> this overlap-player-counter) (the-as uint 0))
             0
             )
           )
          (else
            (set! (-> this overlap-player-counter) (the-as uint 0))
            0
            )
          )
        )
      )
    )
  (none)
  )

(defmethod vehicle-method-77 ((this wvehicle))
  (local-vars (a0-19 float) (a0-23 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (if (-> this nav)
        (logior! (-> this nav flags) (nav-control-flag output-sphere-hash))
        )
    (if (not (logtest? (-> this rbody flags) (rigid-body-flag enable-physics)))
        (vehicle-method-142 this)
        )
    (if (logtest? (-> this v-flags) (vehicle-flag in-air))
        (set! (-> this ground-time) (the-as uint (current-time)))
        )
    (let ((v1-16 (-> this rbody)))
      (cond
        ((logtest? (vehicle-flag overturned) (-> this v-flags))
         (if (and (not (logtest? (-> this v-flags) (vehicle-flag in-air))) (< 0.0 (-> v1-16 matrix uvec y)))
             (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag overturned))))
             )
         )
        (else
          (when (and (logtest? (-> this v-flags) (vehicle-flag in-air))
                     (not (logtest? (-> this v-flags) (vehicle-flag dead)))
                     (< (-> v1-16 matrix uvec y) 0.0)
                     (let ((a0-18 (-> v1-16 lin-velocity))
                           (f1-2 16384.0)
                           )
                       (.lvf vf1 (&-> a0-18 quad))
                       (.add.w.vf vf2 vf0 vf0 :mask #b1)
                       (.mul.vf vf1 vf1 vf1)
                       (.mul.x.vf acc vf2 vf1 :mask #b1)
                       (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                       (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                       (.mov a0-19 vf1)
                       (< a0-19 (* f1-2 f1-2))
                       )
                     (let ((a0-22 (-> v1-16 ang-velocity))
                           (f1-5 4.0)
                           )
                       (.lvf vf1 (&-> a0-22 quad))
                       (.add.w.vf vf2 vf0 vf0 :mask #b1)
                       (.mul.vf vf1 vf1 vf1)
                       (.mul.x.vf acc vf2 vf1 :mask #b1)
                       (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                       (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                       (.mov a0-23 vf1)
                       (< a0-23 (* f1-5 f1-5))
                       )
                     )
            (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag overturned) (-> this v-flags))))
            (set! (-> this overturned-time) (the-as uint (current-time)))
            )
          )
        )
      (if (and (not (logtest? (-> this v-flags) (vehicle-flag dead)))
               (< (+ 8192.0 (-> v1-16 position y)) (-> this water-height))
               )
          (go (method-of-object this sink))
          )
      )
    (when (logtest? (vehicle-flag player-driving net-player-driving) (-> this v-flags))
      (when (and (logtest? (-> this controls flags) (vehicle-controls-flag vcf1))
                 (>= (the-as uint (- (current-time) (the-as int (-> this shoot-time)))) (-> this shoot-delay))
                 )
        (set! (-> this shoot-time) (the-as uint (current-time)))
        (wvehicle-method-169 this)
        )
      )
    (when (logtest? (vehicle-flag player-driving) (-> this v-flags))
      (let ((v1-39 *game-info*))
        (set! (-> v1-39 health-bar-vehicle) (-> this hit-points))
        (set! (-> v1-39 race-number-turbos) (the int (-> this turbo-supply)))
        (set! (-> v1-39 vehicle-turbo-ready) (-> this turbo-ready))
        )
      (new 'stack-no-clear 'vector)
      (dotimes (s5-0 (-> this info rider attach-point-count))
        (let* ((s3-0 (handle->process (-> this attached-array s5-0)))
               (s4-0 (if (type? s3-0 process-focusable)
                         s3-0
                         )
                     )
               )
          (when (and s4-0 (focus-test? (the-as process-focusable s4-0) pilot-riding))
            (wvehicle-method-171 this (-> (the-as process-focusable s4-0) root trans) s5-0)
            (wvehicle-method-172 this (-> (the-as process-focusable s4-0) root quat) s5-0)
            )
          )
        )
      0
      )
    ((method-of-type vehicle vehicle-method-77) this)
    (none)
    )
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod rigid-body-object-method-30 ((this wvehicle))
  (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag sounds))))
  (let ((f0-0 (-> this player-dist2))
        (f1-0 245760.0)
        )
    (if (< f0-0 (* f1-0 f1-0))
        (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag sounds) (-> this v-flags))))
        )
    )
  (let ((v1-8 (new 'stack-no-clear 'matrix)))
    (set! (-> v1-8 fvec x) (seconds-per-frame))
    (set! (-> v1-8 uvec quad) (-> this draw color-emissive quad))
    (set! (-> v1-8 uvec x) (fmax 0.0 (+ (-> v1-8 uvec x) (* -2.0 (-> v1-8 fvec x)))))
    (set! (-> this draw color-emissive quad) (-> v1-8 uvec quad))
    )
  (let ((t9-0 (method-of-type vehicle rigid-body-object-method-30)))
    (t9-0 this)
    )
  (wvehicle-method-165 this)
  (vector-reset! (-> this surface-velocity))
  (dotimes (v1-15 (-> this info physics-model wheel-count))
    (let ((a0-13 (-> this wheel v1-15)))
      (set! (-> a0-13 prev-flags) (-> a0-13 flags))
      )
    )
  #f
  )

(defmethod wvehicle-method-162 ((this wvehicle) (arg0 float))
  (let ((s5-0 (-> this info)))
    (let ((s4-0 (new 'stack-no-clear 'wvehicle-physics-work)))
      (let ((f0-0 (-> this engine-rev)))
        (set! (-> s4-0 mat uvec x) (* 9.549297 f0-0))
        )
      (set! (-> s4-0 mat uvec z) 1.0)
      (if (or (= 0.0 (-> this controls throttle))
              (and (logtest? (vehicle-flag turbo-boost) (-> this v-flags))
                   (= (-> this gear-select) (+ (-> s5-0 transmission gear-count) -1))
                   (< (-> s5-0 transmission upshift-rpm) (-> s4-0 mat uvec x))
                   )
              )
          (set! (-> s4-0 mat uvec z) 0.0)
          )
      (set! (-> this engine-rpm) (-> s4-0 mat uvec x))
      (set! (-> s4-0 mat uvec w) (the-as float (current-time)))
      (vector-! (the-as vector (-> s4-0 mat)) (-> this rbody lin-velocity) (-> this surface-velocity))
      (when (not (logtest? (-> this v-flags) (vehicle-flag in-air)))
        (let ((f0-12 (* (/ (fmax 0.0 (vector-dot (the-as vector (-> s4-0 mat)) (-> this rbody matrix fvec)))
                           (-> this avg-drive-wheel-radius)
                           )
                        (-> this gear-ratio)
                        (-> this final-drive-ratio)
                        )
                     )
              )
          (set! (-> s4-0 mat uvec y) (* 9.549297 f0-12))
          )
        (cond
          ((logtest? (vehicle-flag reverse-gear) (-> this v-flags))
           (set! (-> this next-gear-select) 0)
           0
           )
          ((and (zero? (-> this gear-select)) (not (logtest? (vehicle-flag reverse-gear) (-> this v-flags))))
           (set! (-> this next-gear-select) 1)
           )
          ((and (< (-> s5-0 transmission upshift-rpm) (-> s4-0 mat uvec y))
                (and (< (-> this gear-select) (+ (-> s5-0 transmission gear-count) -1))
                     (> (-> this gear-select) 0)
                     (= (-> this clutch-grab) 1.0)
                     (< 0.5 (-> this controls throttle))
                     )
                )
           (set! (-> this next-gear-select) (+ (-> this gear-select) 1))
           )
          ((and (< (-> s4-0 mat uvec y) (-> s5-0 transmission downshift-rpm)) (< 1 (-> this gear-select)))
           (set! (-> this next-gear-select) (+ (-> this gear-select) -1))
           )
          )
        )
      (let ((v1-47 (-> this shift-state)))
        (cond
          ((zero? v1-47)
           (cond
             ((>= 1 (-> this gear-select))
              (cond
                ((or (< (-> s4-0 mat uvec x) (-> s5-0 engine clutch-min-rpm)) (= (-> this controls throttle) 0.0))
                 (seek! (-> this clutch-grab) 0.0 (* 16.0 arg0))
                 )
                ((or (< (-> s5-0 engine clutch-max-rpm) (-> s4-0 mat uvec x))
                     (and (< 0.0 (-> this clutch-grab)) (< (-> s5-0 engine peak-torque-rpm) (-> s4-0 mat uvec x)))
                     )
                 (seek! (-> this clutch-grab) (-> s4-0 mat uvec z) (* 3.0 arg0))
                 )
                (else
                  (seek! (-> this clutch-grab) 0.0 (* 3.0 arg0))
                  )
                )
              )
             (else
               (seek! (-> this clutch-grab) (-> s4-0 mat uvec z) (* 8.0 arg0))
               )
             )
           (when (!= (-> this next-gear-select) (-> this gear-select))
             (set! (-> this shift-state) (the-as uint 1))
             (set! (-> this shift-time) (the-as uint (-> s4-0 mat uvec w)))
             )
           )
          ((= v1-47 1)
           (seek! (-> this clutch-grab) 0.0 (* 16.0 arg0))
           (when (= (-> this clutch-grab) 0.0)
             (set! (-> this shift-state) (the-as uint 2))
             (set! (-> this shift-time) (the-as uint (-> s4-0 mat uvec w)))
             )
           )
          ((= v1-47 2)
           (set! (-> this gear-select) (-> this next-gear-select))
           (when (< (the-as uint 15) (- (the-as uint (-> s4-0 mat uvec w)) (the-as uint (-> this shift-time))))
             (set! (-> this shift-state) (the-as uint 3))
             (set! (-> this shift-time) (the-as uint (-> s4-0 mat uvec w)))
             )
           )
          ((= v1-47 3)
           (seek! (-> this clutch-grab) (-> s4-0 mat uvec z) (* 8.0 arg0))
           (when (!= (-> this next-gear-select) (-> this gear-select))
             (set! (-> this shift-state) (the-as uint 1))
             (set! (-> this shift-time) (the-as uint (-> s4-0 mat uvec w)))
             )
           (when (= (-> this clutch-grab) (-> s4-0 mat uvec z))
             (set! (-> this shift-state) (the-as uint 0))
             (set! (-> this shift-time) (the-as uint (-> s4-0 mat uvec w)))
             )
           )
          )
        )
      )
    (set! (-> this gear-ratio) (-> s5-0 transmission gear-ratio-array (-> this gear-select)))
    (set! (-> this final-drive-ratio) (-> s5-0 transmission final-drive-ratio))
    (set! (-> this total-gear-ratio) (* (-> this final-drive-ratio) (-> this gear-ratio)))
    (set! (-> this inv-total-gear-ratio) (/ 1.0 (-> this total-gear-ratio)))
    (set! (-> this engine-max-torque) (-> s5-0 engine max-torque))
    (set! (-> this clutch-inertia) (* 0.0 (-> s5-0 transmission inertia)))
    )
  0
  (none)
  )

(defmethod wvehicle-method-163 ((this wvehicle))
  (let ((s5-0 (-> this info))
        (s4-0 (new 'stack-no-clear 'matrix))
        )
    (set! (-> s4-0 rvec z) (-> this controls throttle))
    (set! (-> s4-0 uvec x) (vector-dot (the-as vector (-> this rbody matrix)) (-> this rbody ang-velocity)))
    (set! (-> s4-0 rvec w) (-> this rbody matrix fvec y))
    (set! (-> s4-0 uvec y) (+ (-> s4-0 rvec w) (* -1.0 (-> s4-0 uvec x))))
    (if (and (< (cos 12743.111) (-> s4-0 rvec w))
             (< (-> s4-0 uvec x) -0.1)
             (and (< 1.0 (-> s4-0 uvec y))
                  (not (logtest? (-> this wheel 0 flags) 2))
                  (not (logtest? (-> this wheel 1 flags) 2))
                  (logtest? (-> this wheel 2 flags) 2)
                  (logtest? (-> this wheel 3 flags) 2)
                  )
             )
        (set! (-> s4-0 rvec z) 0.0)
        )
    (set! (-> this engine-torque) (wvehicle-method-166 this (-> this engine-rpm) (-> s4-0 rvec z)))
    (let ((f0-13 0.0))
      (dotimes (v1-23 (-> s5-0 physics-model wheel-count))
        (let ((a0-9 (-> this wheel v1-23 info)))
          (if (logtest? (-> a0-9 flags) (vehicle-wheel-flag vwf0))
              (+! f0-13 (-> a0-9 inertia))
              )
          )
        )
      (set! (-> this drive-wheel-inertia) f0-13)
      (let* ((f1-6 (-> this final-drive-ratio))
             (f1-8 (* f1-6 f1-6))
             (f2-1 (-> s5-0 transmission inertia))
             (f3-0 (-> this gear-ratio))
             )
        (set! (-> this wheel-inertia)
              (+ f0-13
                 (* f1-8
                    (+ f2-1 (* f3-0 f3-0 (+ (-> this clutch-inertia) (* (-> s5-0 engine inertia) (-> this clutch-grab)))))
                    )
                 )
              )
        )
      )
    (set! (-> s4-0 rvec x) (* (/ 1.0 (the float (-> s5-0 physics-model drive-wheel-count)))
                              (-> this engine-torque)
                              (-> this clutch-grab)
                              (-> this total-gear-ratio)
                              )
          )
    (set! (-> this wheel-torque) 0.0)
    (set! (-> this wheel-braking-torque) 0.0)
    (set! (-> this wheel-ground-torque) 0.0)
    (dotimes (v1-31 (-> s5-0 physics-model wheel-count))
      (let* ((a0-14 (-> this wheel v1-31))
             (a1-5 (-> a0-14 info))
             )
        (set! (-> a0-14 torque) 0.0)
        (set! (-> a0-14 braking-torque) 0.0)
        (set! (-> a0-14 inertia) (-> a1-5 inertia))
        (let ((f0-26 0.0))
          (if (logtest? (-> a1-5 flags) (vehicle-wheel-flag vwf1))
              (+! f0-26 (-> this controls brake))
              )
          (if (logtest? (-> a1-5 flags) (vehicle-wheel-flag vwf2))
              (+! f0-26 (-> this controls handbrake))
              )
          (+! (-> a0-14 braking-torque) (* (fmin 1.0 f0-26) (-> a1-5 max-brake-torque) (-> s5-0 handling brake-factor)))
          )
        (+! (-> this wheel-braking-torque) (-> a0-14 braking-torque))
        (when (logtest? (-> a1-5 flags) (vehicle-wheel-flag vwf0))
          (set! (-> a0-14 inertia) (-> this wheel-inertia))
          (set! (-> a0-14 torque) (-> s4-0 rvec x))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-92 ((this wvehicle) (arg0 vehicle-controls))
  (seek! (-> this controls steering) (-> arg0 steering) (* 8.0 (seconds-per-frame)))
  (seek! (-> this controls lean-z) (-> arg0 lean-z) (* 8.0 (seconds-per-frame)))
  (set! (-> this controls handbrake) (-> arg0 handbrake))
  (let ((f0-11 (-> arg0 throttle))
        (f30-0 (-> arg0 brake))
        )
    (set! f30-0
          (cond
            ((< 0.0 f0-11)
             (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
             (if (< (-> this wheel-rev) -1.5)
                 (set! f30-0 1.0)
                 )
             f30-0
             )
            ((< 0.0 f30-0)
             (cond
               ((logtest? (vehicle-flag reverse-gear) (-> this v-flags))
                (set! f0-11 f30-0)
                0.0
                )
               (else
                 (let ((v1-13 (new 'stack-no-clear 'vector)))
                   (vector-! (the-as vector (&-> v1-13 x)) (-> this rbody lin-velocity) (-> this surface-velocity))
                   (if (< (vector-dot (the-as vector (&-> v1-13 x)) (-> this rbody matrix fvec)) 40960.0)
                       (logior! (-> this v-flags) (vehicle-flag reverse-gear))
                       )
                   )
                 f30-0
                 )
               )
             )
            (else
              (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
              f30-0
              )
            )
          )
    (case (-> this shift-state)
      ((1 2)
       (set! f0-11 0.0)
       )
      )
    (seek! (-> this controls throttle) f0-11 (* 8.0 (seconds-per-frame)))
    (+! (-> this controls brake) (* (- f30-0 (-> this controls brake)) (fmin 1.0 (* 8.0 (seconds-per-frame)))))
    )
  (set! (-> this controls prev-flags) (-> this controls flags))
  (set! (-> this controls flags) (-> arg0 flags))
  0
  (none)
  )

(defmethod vehicle-method-88 ((this wvehicle) (arg0 vehicle-controls))
  (set! (-> arg0 steering) (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0))
  (set! (-> arg0 lean-z) (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 48.0 110.0 -1.0))
  (set! (-> arg0 throttle) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 6)))))
  (set! (-> arg0 brake) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 7)))))
  (set! (-> arg0 handbrake) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 5)))))
  (cond
    ((-> *setting-control* user-current jump)
     (if (cpad-hold? 0 l1)
         (logior! (-> arg0 flags) (vehicle-controls-flag vcf0))
         )
     )
    (else
      (logclear! (-> this controls flags) (vehicle-controls-flag vcf0))
      (logclear! (-> this controls prev-flags) (vehicle-controls-flag vcf0))
      )
    )
  (if (and (cpad-hold? 0 r1) (-> *setting-control* user-current gun))
      (logior! (-> arg0 flags) (vehicle-controls-flag vcf1))
      )
  (if (and (cpad-hold? 0 r2) (-> *setting-control* user-current turbo))
      (logior! (-> arg0 flags) (vehicle-controls-flag vcf2))
      )
  (if (cpad-pressed? 0 r3)
      (set! (-> this v-flags) (the-as vehicle-flag (logxor (shl #x8000 16) (the-as int (-> this v-flags)))))
      )
  (if (not (-> *setting-control* user-current allow-look-around))
      (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag camera-inside-view))))
      )
  (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag camera-look-mode))))
  (if (logtest? (vehicle-flag camera-inside-view) (-> this v-flags))
      (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag camera-look-mode) (-> this v-flags))))
      )
  (if (cpad-pressed? 0 l2)
      (set! (-> this cam-view) 1)
      )
  (cond
    ((cpad-hold? 0 l2)
     (let ((f30-0 (analog-input (the-as int (-> *cpad-list* cpads 0 rightx)) 128.0 48.0 110.0 -1.0))
           (f0-8 (analog-input (the-as int (-> *cpad-list* cpads 0 righty)) 128.0 48.0 110.0 -1.0))
           )
       (cond
         ((< (fabs f0-8) (fabs f30-0))
          (cond
            ((< f30-0 -0.5)
             (set! (-> this cam-view) 3)
             )
            ((< 0.5 f30-0)
             (set! (-> this cam-view) 2)
             )
            )
          )
         (else
           (cond
             ((< 0.5 f0-8)
              (set! (-> this cam-view) 0)
              0
              )
             ((< f0-8 -0.5)
              (set! (-> this cam-view) 1)
              )
             )
           )
         )
       )
     )
    (else
      (set! (-> this cam-view) 0)
      0
      )
    )
  (if (nonzero? (-> this cam-view))
      (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag camera-look-mode) (-> this v-flags))))
      )
  0
  (none)
  )

(defmethod vehicle-method-94 ((this wvehicle))
  (let ((t9-0 (method-of-type vehicle vehicle-method-94)))
    (t9-0 this)
    )
  (set-setting! 'string-camera-floor 'abs (+ 12288.0 (-> this water-height)) 0)
  (cond
    ((logtest? (vehicle-flag reverse-gear) (-> this v-flags))
     (let ((v1-6 (process->ppointer this)))
       (set-setting! 'butt-handle v1-6 32768.0 (-> v1-6 0 pid))
       )
     )
    (else
      (remove-setting! 'butt-handle)
      )
    )
  (let ((f0-2 (vector-vector-distance-squared (-> this draw origin) (math-camera-pos)))
        (f1-1 (-> this draw origin w))
        )
    (if (< f0-2 (* f1-1 f1-1))
        (logclear! (-> this draw status) (draw-control-status force-vu1))
        (logior! (-> this draw status) (draw-control-status force-vu1))
        )
    )
  0
  (none)
  )

(defmethod vehicle-method-93 ((this wvehicle))
  (let ((t9-0 (method-of-type vehicle vehicle-method-93)))
    (t9-0 this)
    )
  (let ((s4-0 (-> this info))
        (s5-0 (new 'stack-no-clear 'inline-array 'matrix 2))
        )
    (set! (-> s5-0 0 trans z) (vector-dot (-> this rbody lin-velocity) (-> this rbody matrix fvec)))
    (set! (-> s5-0 0 trans w) (vector-dot (-> this rbody lin-velocity) (the-as vector (-> this rbody matrix))))
    (set! (-> s5-0 0 trans y) (/ (* 2.0 (fabs (-> s5-0 0 trans w))) (fmax 409.6 (-> s5-0 0 trans z))))
    (set! (-> s5-0 0 trans x)
          (/ (-> s4-0 handling tire-steering-speed-factor)
             (fmax 409.6 (- (-> s5-0 0 trans z) (-> s4-0 handling tire-steering-speed-bias)))
             )
          )
    (set! (-> s5-0 0 fvec y) (fmin 1.0 (fmax (-> s5-0 0 trans y) (-> s5-0 0 trans x))))
    (set! (-> s5-0 0 fvec x) (* (-> this controls steering) (-> s5-0 0 fvec y)))
    (set! (-> s5-0 0 fvec z) (* (-> this info handling tire-steering-angle) (-> s5-0 0 fvec x)))
    (set! (-> s5-0 0 fvec w)
          (* (-> s5-0 0 fvec z) (+ 1.0 (* (-> this info handling ackermann-factor) (fabs (-> s5-0 0 fvec x)))))
          )
    (set! (-> s5-0 1 uvec y)
          (* 2.0
             (+ (-> s4-0 physics-model rear-wheel local-pos x)
                (-> s4-0 physics-model rear-wheel susp-arm-length)
                (-> s4-0 physics-model rear-wheel steer-arm-length)
                )
             )
          )
    (set! (-> s5-0 1 uvec z)
          (- (-> s4-0 physics-model front-wheel local-pos z) (-> s4-0 physics-model rear-wheel local-pos z))
          )
    (set! (-> s5-0 1 uvec w) 0.0)
    (when (< 18.204445 (fabs (-> s5-0 0 fvec z)))
      (cond
        ((logtest? (-> s4-0 physics-model rear-wheel flags) (vehicle-wheel-flag vwf4))
         (set! (-> s5-0 1 rvec w) (/ (* 0.5 (-> s5-0 1 uvec z)) (sin (fabs (-> s5-0 0 fvec z)))))
         (let ((f0-32
                 (- (* (-> s5-0 1 rvec w) (cos (fabs (-> s5-0 0 fvec z))))
                    (* 2.0 (+ (-> s4-0 physics-model rear-wheel local-pos x) (-> s4-0 physics-model rear-wheel susp-arm-length)))
                    )
                 )
               (f1-22 (* 0.5 (-> s5-0 1 uvec z)))
               )
           (set! (-> s5-0 1 rvec z) (sqrtf (+ (* f1-22 f1-22) (* f0-32 f0-32))))
           )
         (+! (-> s5-0 1 rvec w) (-> s4-0 physics-model rear-wheel steer-arm-length))
         (set! (-> s5-0 1 rvec z) (- (-> s5-0 1 rvec z) (-> s4-0 physics-model rear-wheel steer-arm-length)))
         )
        (else
          (set! (-> s5-0 1 rvec w) (/ (-> s5-0 1 uvec z) (tan (fabs (-> s5-0 0 fvec z)))))
          (set! (-> s5-0 1 rvec w)
                (- (-> s5-0 1 rvec w)
                   (+ (-> s4-0 physics-model front-wheel local-pos x)
                      (-> s4-0 physics-model front-wheel susp-arm-length)
                      (* -0.5 (-> s5-0 1 uvec y))
                      )
                   )
                )
          (set! (-> s5-0 1 rvec z) (- (-> s5-0 1 rvec w) (-> s5-0 1 uvec y)))
          )
        )
      (set! (-> s5-0 1 uvec w)
            (/ (- (-> s5-0 1 rvec w) (-> s5-0 1 rvec z)) (+ (-> s5-0 1 rvec w) (-> s5-0 1 rvec z)))
            )
      )
    (set! (-> s5-0 1 rvec x) (- 1.0 (-> s5-0 1 uvec w)))
    (set! (-> s5-0 1 rvec y) (+ 1.0 (-> s5-0 1 uvec w)))
    (cond
      ((< (-> s5-0 0 fvec z) 0.0)
       (set! (-> s5-0 0 rvec x) (-> s5-0 0 fvec z))
       (set! (-> s5-0 0 rvec y) (-> s5-0 0 fvec w))
       (set! (-> s5-0 0 uvec x) (-> s5-0 1 rvec y))
       (set! (-> s5-0 0 uvec y) (-> s5-0 1 rvec x))
       )
      (else
        (set! (-> s5-0 0 rvec x) (-> s5-0 0 fvec w))
        (set! (-> s5-0 0 rvec y) (-> s5-0 0 fvec z))
        (set! (-> s5-0 0 uvec x) (-> s5-0 1 rvec x))
        (set! (-> s5-0 0 uvec y) (-> s5-0 1 rvec y))
        )
      )
    (dotimes (s4-1 (-> this info physics-model wheel-count))
      (let* ((s3-0 (-> this wheel s4-1))
             (s2-0 (-> s3-0 info))
             )
        (if (logtest? (-> s2-0 flags) (vehicle-wheel-flag vwf4))
            (set! (-> s3-0 steer-angle) (* (-> (&-> s5-0 0 rvec data (logand s4-1 1)) 0) (sign (-> s2-0 local-pos z))))
            )
        (if (logtest? (-> s2-0 flags) (vehicle-wheel-flag vwf0))
            (set! (-> s3-0 drive-diff) (-> (&-> s5-0 0 rvec data (logand s4-1 1)) 4))
            )
        )
      )
    )
  (dotimes (s5-1 (-> this info physics-model wheel-count))
    (let ((s3-1 (-> this wheel s5-1)))
      (set-vector! (-> s3-1 local-axis) (cos (-> s3-1 steer-angle)) 0.0 (- (sin (-> s3-1 steer-angle))) 1.0)
      )
    )
  (let ((s5-2 (new 'stack-no-clear 'wvehicle-physics-work)))
    (set! (-> s5-2 mat rvec x) (the-as float (current-time)))
    (cond
      ((logtest? (-> this info flags) 4096)
       (when (and (logtest? (-> this controls flags) (vehicle-controls-flag vcf0))
                  (not (logtest? (-> this controls prev-flags) (vehicle-controls-flag vcf0)))
                  (< (the-as uint 45) (- (the-as uint (-> s5-2 mat rvec x)) (the-as uint (-> this jump-time))))
                  (< (the-as uint 45) (- (the-as uint (-> s5-2 mat rvec x)) (the-as uint (-> this ground-time))))
                  )
         (let ((v1-77 0))
           (dotimes (a0-15 4)
             (let ((a1-5 (-> this wheel a0-15)))
               (if (and (logtest? (-> a1-5 flags) 2) (< 0.0 (-> a1-5 up-force)))
                   (+! v1-77 1)
                   )
               )
             )
           (when (>= v1-77 2)
             (let ((v1-79 (new 'stack-no-clear 'matrix)))
               (vector-float*! (-> v1-79 rvec) (-> this rbody matrix uvec) (* 0.3
                                                                              (-> this rbody matrix uvec y)
                                                                              (-> this info info mass)
                                                                              (-> this info extra gravity)
                                                                              (-> this info handling jump-thrust-factor)
                                                                              )
                               )
               (add-force! (-> this rbody) (-> v1-79 rvec))
               )
             (rigid-body-control-method-12 (-> this rbody) 1.0)
             (init-velocities! (-> this rbody))
             (set! (-> this jump-time) (the-as uint (-> s5-2 mat rvec x)))
             (sound-play-by-name (-> this info sound jump-sound) (new-sound-id) 1024 0 0 (sound-group) #t)
             )
           )
         )
       )
      ((logtest? (-> this controls flags) (vehicle-controls-flag vcf0))
       (set! (-> this susp-spring-control) 0.5)
       (set! (-> this jump-control) 0.0)
       (if (logtest? (vehicle-flag player-driving) (-> this v-flags))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.05))
           )
       (if (and (not (logtest? (-> this controls prev-flags) (vehicle-controls-flag vcf0)))
                (logtest? (-> this v-flags) (vehicle-flag on-ground))
                )
           (sound-play "toad-prehop")
           )
       )
      (else
        (set! (-> this susp-spring-control) 1.0)
        (when (and (logtest? (-> this controls prev-flags) (vehicle-controls-flag vcf0))
                   (< (the-as uint 300) (- (the-as uint (-> s5-2 mat rvec x)) (the-as uint (-> this jump-time))))
                   (< (the-as uint 45) (- (the-as uint (-> s5-2 mat rvec x)) (the-as uint (-> this ground-time))))
                   )
          0
          (when (>= (-> this rbody matrix uvec y) 0.707)
            (set! (-> this jump-time) (the-as uint (-> s5-2 mat rvec x)))
            (set! (-> this jump-control) (-> this info handling jump-thrust-factor))
            (sound-play-by-name (-> this info sound jump-sound) (new-sound-id) 1024 0 0 (sound-group) #t)
            )
          )
        (if (< (the-as uint 60) (- (the-as uint (-> s5-2 mat rvec x)) (the-as uint (-> this jump-time))))
            (set! (-> this jump-control) 0.0)
            )
        )
      )
    )
  (if (not (logtest? (vehicle-flag turbo-boost) (-> this v-flags)))
      (set! (-> this turbo-ready) (fmin 1.0 (+ (-> this turbo-ready) (* 0.5 (seconds-per-frame)))))
      )
  (if (logtest? (-> this controls flags) (vehicle-controls-flag vcf2))
      (vehicle-method-64 this)
      )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod alloc-rbody-control! ((this wvehicle) (arg0 rigid-body-object-constants))
  (let ((s4-0 (new 'stack-no-clear 'inline-array 'quaternion 2)))
    (vector-y-quaternion! (the-as vector (-> s4-0 0)) (-> this root quat))
    (vector+float*!
      (-> this root trans)
      (-> this root trans)
      (the-as vector (-> s4-0 0))
      (-> (the-as rigid-body-vehicle-constants arg0) setup settle-height)
      )
    (quaternion-axis-angle!
      (-> s4-0 1)
      1.0
      0.0
      0.0
      (-> (the-as rigid-body-vehicle-constants arg0) setup settle-rot-x)
      )
    (quaternion*! (-> this root quat) (-> this root quat) (-> s4-0 1))
    )
  (let ((t9-3 (method-of-type vehicle alloc-rbody-control!)))
    (t9-3 this (the-as rigid-body-vehicle-constants arg0))
    )
  (iterate-prims (-> this root) (lambda ((arg0 collide-shape-prim))
                                  (logior! (-> arg0 prim-core collide-as) (collide-spec camera-blocker))
                                  (none)
                                  )
                 )
  (set! (-> this control-hook) #f)
  (set! (-> this ai-min-speed) 61440.0)
  (set! (-> this ai-max-speed) 102400.0)
  (set! (-> this minimap) #f)
  (set! (-> this clutch-grab) 0.0)
  (set! (-> this gear-select) 1)
  (set! (-> this shoot-delay) (the-as uint 60))
  (wvehicle-method-167 this)
  (set! (-> this info physics-model wheel-count) 4)
  (set! (-> this susp-spring-control) 1.0)
  (set! (-> this jump-control) 0.0)
  (set! (-> this turbo-ready) 1.0)
  (set! (-> this net) #f)
  (let ((v1-19 (new 'stack-no-clear 'wvehicle-stack-type4)))
    (set! (-> v1-19 float2) (vector-dot (-> this root transv) (-> this rbody matrix fvec)))
    (set! (-> v1-19 byte0) 0)
    (set! (-> v1-19 float0) 0.0)
    (dotimes (a0-14 (-> this info physics-model wheel-count))
      (let ((a1-11 (-> this wheel a0-14)))
        (let ((a2-2 (-> a1-11 info)))
          (set! (-> a1-11 x-scale) (if (= (logand a0-14 1) 1)
                                       -1.0
                                       1.0
                                       )
                )
          (set! (-> a1-11 surface) #f)
          (set! (-> v1-19 float1) (* (-> a2-2 radius) (-> a2-2 scale)))
          (set! (-> a1-11 rev) (/ (-> v1-19 float2) (-> v1-19 float1)))
          (when (logtest? (-> a2-2 flags) (vehicle-wheel-flag vwf0))
            (+! (-> v1-19 byte0) 1)
            (+! (-> v1-19 float0) (-> v1-19 float1))
            (set! (-> a1-11 drive-diff) 1.0)
            )
          (set! (-> a1-11 handle) (the-as handle #f))
          (set! (-> a1-11 tread-tracker) (the-as handle #f))
          (set! (-> a1-11 inertia) (-> a2-2 inertia))
          )
        (set! (-> a1-11 probe-local-dir quad) (-> (new 'static 'vector :y -1.0 :w 1.0) quad))
        (set! (-> a1-11 local-axis quad) (-> (new 'static 'vector :x 1.0 :w 1.0) quad))
        )
      )
    (set! (-> (the-as rigid-body-vehicle-constants arg0) physics-model drive-wheel-count) (-> v1-19 byte0))
    (set! (-> this avg-drive-wheel-radius) (/ (-> v1-19 float0) (the float (-> v1-19 byte0))))
    (set! (-> this wheel-rev) (/ (-> v1-19 float2) (-> this avg-drive-wheel-radius)))
    (when (< 0.0 (-> v1-19 float2))
      (set! (-> this gear-select) (+ (-> (the-as rigid-body-vehicle-constants arg0) transmission gear-count) -1))
      (let ((f0-25 (-> (the-as rigid-body-vehicle-constants arg0) engine idle-rpm)))
        (set! (-> this engine-rev) (* 0.10471976 f0-25))
        )
      )
    )
  (dotimes (v1-26 (-> this info rider attach-point-count))
    (set! (-> this attached-array v1-26) (the-as handle #f))
    )
  (vector-reset! (-> this surface-velocity))
  (set! (-> this draw light-index) (the-as uint 30))
  (set! (-> this draw lod-set lod 0 dist) 1228800.0)
  (set! (-> this draw lod-set lod 1 dist) 1232896.0)
  (set! (-> this draw lod-set lod 2 dist) 1236992.0)
  (set! (-> this gun-aim-yaw) 0.0)
  (set! (-> this gun-aim-yaw-vel) 0.0)
  (set! (-> this gun-yaw) 0.0)
  (set! (-> this gun-pitch) 0.0)
  (set! (-> this shoot-delay) (the-as uint 30))
  (set! (-> this lock-turret) #f)
  (none)
  )

(defmethod vehicle-method-134 ((this wvehicle))
  (if (focus-test? this grabbed)
      (go (method-of-object this race-waiting))
      (go (method-of-object this player-control))
      )
  0
  (none)
  )

(defmethod on-impact ((this wvehicle) (arg0 rigid-body-impact))
  (mem-copy! (the-as pointer (-> this impact)) (the-as pointer arg0) 64)
  ((method-of-type vehicle on-impact) this arg0)
  (none)
  )

;; WARN: disable def twice: 12. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 59. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod rbody-event-handler ((this wvehicle) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (case arg2
    (('test-ready)
     (and (and (-> this next-state) (= (-> this next-state name) 'race-waiting))
          (logtest? (-> this v-flags) (vehicle-flag riding))
          )
     )
    (('repair)
     (let ((f0-0 (the-as float (-> arg3 param 0)))
           (f1-0 (-> this hit-points))
           )
       (if (< 0.0 f1-0)
           (set! (-> this hit-points) (fmin 1.0 (+ f1-0 f0-0)))
           )
       )
     )
    (('touched)
     (when (zero? (-> (the-as process-drawable arg0) rbody))
       (let* ((s5-0 arg0)
              (v1-10 (if (type? s5-0 process-focusable)
                         s5-0
                         )
                     )
              )
         (when (and v1-10
                    (logtest? (-> v1-10 mask) (process-mask target))
                    (logtest? (vehicle-flag waiting-for-player) (-> this v-flags))
                    (logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
                    )
           (logior! (-> this v-flags) (vehicle-flag player-touching))
           (set! v0-0 (current-time))
           (set! (-> this player-touch-time) (the-as time-frame v0-0))
           v0-0
           )
         )
       )
     )
    (('begin-race)
     (let ((a1-2 (-> arg3 param 0)))
       (race-setup this (the-as int a1-2))
       )
     (logclear! (-> this focus-status) (focus-status grabbed))
     (when (and (-> this next-state) (= (-> this next-state name) 'race-waiting))
       (cond
         ((logtest? (vehicle-flag player-driving) (-> this v-flags))
          (logclear! (-> this v-flags) (vehicle-flag player-grabbed))
          (go (method-of-object this player-control))
          )
         (else
           (go (method-of-object this race-racing))
           )
         )
       )
     )
    (('turbo-pickup)
     (when (< (-> this turbo-supply) 3.0)
       (sound-play "turbo-pickup")
       (if (logtest? (vehicle-flag player-driving) (-> this v-flags))
           (sound-play "turbo-pickup")
           )
       (+! (-> this turbo-supply) 1.0)
       (set! (-> this turbo-supply) (fmin 3.0 (-> this turbo-supply)))
       (let ((v1-47 (-> this draw color-emissive)))
         (set! (-> v1-47 x) 2.0)
         )
       )
     #t
     )
    (('race-decision-point)
     (when (logtest? (vehicle-flag ai-driving) (-> this v-flags))
       (let* ((v1-51 (the-as race-decision-point (-> arg3 param 0)))
              (a0-25 (-> v1-51 decision-type))
              )
         (cond
           ((zero? a0-25)
            (cond
              ((and (nonzero? (-> v1-51 shortcuts))
                    (>= (-> this race racer-state speed-factor) (-> this race state info ai-max-speed-factor))
                    (< 0.1 (- (+ (-> this race state target-pos) (-> this race racer-state target-pos-offset))
                              (-> this race racer-state pos)
                              )
                       )
                    )
               (race-select-path-randomly-from-mask this (-> v1-51 shortcuts))
               (set! (-> this shortcut-time) (the-as uint (current-time)))
               (set! (-> this shortcut-speed-factor) 1.0)
               )
              (else
                (race-select-path-randomly-from-mask this (-> v1-51 safe-paths))
                (set! (-> this shortcut-speed-factor) 0.0)
                )
              )
            )
           ((= a0-25 1)
            (when (and (>= (-> this turbo-supply) 1.0)
                       (< (-> this path-deviation) 1.0)
                       (>= (-> this race racer-state speed-factor) (-> this race state info ai-max-speed-factor))
                       )
              (apply-momentum! this)
              (vehicle-method-64 this)
              )
            )
           )
         )
       )
     )
    (('hide)
     (logior! (-> this draw status) (draw-control-status no-draw))
     (dotimes (s5-3 (-> this info physics-model wheel-count))
       (send-event (handle->process (-> this wheel s5-3 handle)) 'hide)
       )
     (let ((gp-1 (-> this child)))
       (while gp-1
         (send-event (ppointer->process gp-1) 'hide)
         (set! gp-1 (-> gp-1 0 brother))
         )
       )
     #f
     )
    (('unhide)
     (logclear! (-> this draw status) (draw-control-status no-draw))
     (dotimes (s5-4 (-> this info physics-model wheel-count))
       (send-event (handle->process (-> this wheel s5-4 handle)) 'unhide)
       )
     (let ((gp-2 (-> this child)))
       (while gp-2
         (send-event (ppointer->process gp-2) 'unhide)
         (set! gp-2 (-> gp-2 0 brother))
         )
       )
     #f
     )
    (('race-pass)
     (send-event (find-rider this) 'race-pass)
     )
    (('race-got-passed)
     (send-event (find-rider this) 'race-got-passed)
     )
    (('race-finished)
     (-> arg3 param 0)
     (cond
       ((logtest? (vehicle-flag player-driving) (-> this v-flags))
        (set! (-> this damage-factor) 0.0)
        (set! v0-0 (method-of-object this wvehicle-method-177))
        (set! (-> this control-hook) (the-as (function vehicle vehicle-controls) v0-0))
        v0-0
        )
       (else
         (go (method-of-object this race-finished))
         )
       )
     )
    (('race-deactivate)
     (set! (-> this damage-factor) (-> this info damage inv-hit-points))
     (set! (-> this race path) #f)
     (cond
       ((logtest? (vehicle-flag player-driving) (-> this v-flags))
        (logclear! (-> this v-flags) (vehicle-flag player-grabbed))
        (set! v0-0 (method-of-object this control-hook-player))
        (set! (-> this control-hook) (the-as (function vehicle vehicle-controls) v0-0))
        v0-0
        )
       (else
         (go (method-of-object this die))
         )
       )
     )
    (('set-control-hook-race-ai)
     (set! v0-0 (method-of-object this wvehicle-method-177))
     (set! (-> this control-hook) (the-as (function vehicle vehicle-controls) v0-0))
     v0-0
     )
    (('ai-set-target-speed)
     (let ((f0-18 (the-as float (-> arg3 param 0))))
       (set! (-> this ai-min-speed) f0-18)
       (set! (-> this ai-max-speed) f0-18)
       f0-18
       )
     )
    (('ai-set-target-process)
     (let* ((s5-7 (-> arg3 param 0))
            (a0-77 (if (type? s5-7 process-drawable)
                       s5-7
                       )
                   )
            )
       (cond
         ((the-as uint a0-77)
          (set! v0-0 (process->handle (the-as uint a0-77)))
          (set! (-> this target-status handle) (the-as handle v0-0))
          v0-0
          )
         (else
           (set! (-> this target-status handle) (the-as handle #f))
           #f
           )
         )
       )
     )
    (('ai-set-target-position)
     (let ((v1-138 (the-as object (-> arg3 param 0))))
       (set! (-> this ai-state) (the-as uint 2))
       (set! v0-0 (-> this ai-target-point))
       (set! (-> (the-as vector v0-0) quad) (-> (the-as vector v1-138) quad))
       )
     v0-0
     )
    (('ai-set-mode)
     (set! v0-0 (-> arg3 param 0))
     (set! (-> this ai-state) (the-as uint v0-0))
     v0-0
     )
    (('ai-drop-off)
     (let ((v1-140 (the-as object (-> arg3 param 0))))
       (set! (-> this other-pos quad) (-> (the-as wvehicle-ai-drop-off-params v1-140) dest quad))
       (set! (-> this other-proc) (process->handle (-> (the-as wvehicle-ai-drop-off-params v1-140) proc)))
       )
     (set! v0-0 (logior (vehicle-flag vf53) (-> this v-flags)))
     (set! (-> this v-flags) (the-as vehicle-flag v0-0))
     v0-0
     )
    (('ai-ignore-nav-mesh)
     (cond
       ((-> arg3 param 0)
        (set! v0-0 (logior (vehicle-flag vf52) (-> this v-flags)))
        (set! (-> this v-flags) (the-as vehicle-flag v0-0))
        )
       (else
         (set! v0-0 (logclear (-> this v-flags) (vehicle-flag vf52)))
         (set! (-> this v-flags) (the-as vehicle-flag v0-0))
         )
       )
     v0-0
     )
    (('ai-set-inaccuracy-factor)
     (wvehicle-method-202 this (the-as float (-> arg3 param 0)))
     )
    (('ai-set-attack-delay-factor)
     (wvehicle-method-201 this (the-as float (-> arg3 param 0)))
     )
    (('go-player-control)
     (go (method-of-object this player-control))
     )
    (('set-rigid-body-info)
     (set! (-> this info) (the-as rigid-body-vehicle-constants (-> arg3 param 0)))
     (rigid-body-object-method-37 this)
     )
    (('no-pickup)
     (set! v0-0 (logior (vehicle-flag vf55) (-> this v-flags)))
     (set! (-> this v-flags) (the-as vehicle-flag v0-0))
     v0-0
     )
    (else
      ((method-of-type vehicle rbody-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod vehicle-method-119 ((this wvehicle))
  (cond
    ((and (logtest? (-> this v-flags) (vehicle-flag player-grabbed)) (-> this race path))
     (wvehicle-method-185 this)
     )
    (else
      (let ((t9-1 (method-of-type vehicle vehicle-method-119)))
        (t9-1 this)
        )
      )
    )
  (if (logtest? (game-secrets unlimited-turbos) (-> *game-info* secrets))
      (set! (-> this turbo-supply) 3.0)
      )
  0
  (none)
  )

(defmethod vehicle-method-118 ((this wvehicle))
  (when (not (logtest? (-> this rbody flags) (rigid-body-flag enable-physics)))
    (if (handle->process (-> this wheel 0 tread-tracker))
        (wvehicle-method-196 this)
        )
    )
  (cond
    ((have-vehicle-v-type? (the-as vehicle-type (-> this info vehicle-type)))
     (if (not (-> this minimap))
         (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 133) (the-as int #f) (the-as vector #t) 0))
         )
     )
    (else
      (when (-> this minimap)
        (logior! (-> this minimap flags) (minimap-flag fade-out))
        (set! (-> this minimap) #f)
        )
      )
    )
  ((method-of-type vehicle vehicle-method-118) this)
  (none)
  )
