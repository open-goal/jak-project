;;-*-Lisp-*-
(in-package goal)

;; name: volcano-obs.gc
;; name in dgo: volcano-obs
;; dgos: VOCA

;; DECOMP BEGINS

(deftype vol-rising-step (process-drawable)
  ((sync       sync-paused  :inline)
   (idle-anim  int32)
   (amplitude  float)
   (init-y     float)
   (sound-id   sound-id)
   )
  (:state-methods
    inactive
    pre-active
    active
    )
  (:methods
    (vol-rising-step-method-23 (_type_) none)
    (vol-rising-step-method-24 (_type_) none)
    )
  )


(defstate inactive (vol-rising-step)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual pre-active)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self root trans y) (- (-> self init-y) (-> self amplitude)))
    (ja-no-eval :group! (-> self draw art-group data (-> self idle-anim)) :num! zero)
    (transform-post)
    )
  :code sleep-code
  )

(defstate pre-active (vol-rising-step)
  :virtual #t
  :code (behavior ()
    (let ((gp-0 (get-timeframe-offset! (-> self sync) 0)))
      (while (< (current-time) gp-0)
        (suspend)
        )
      )
    (go-virtual active)
    )
  )

(defstate active (vol-rising-step)
  :virtual #t
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans rider-trans
  :code sleep-code
  :post (behavior ()
    (let ((f0-0 (cos (get-scaled-val! (-> self sync) 32768.0 0)))
          (f1-1 (/ (-> self amplitude) 2))
          )
      (set! (-> self root trans y) (- (- (-> self init-y) f1-1) (* f0-0 f1-1)))
      )
    (let* ((gp-1 sound-play-by-name)
           (s5-0 (make-u128 101 (the-as uint #x766f6d2d74616c70)))
           (s4-0 (-> self sound-id))
           (f30-0 1024.0)
           (f28-0 1.0)
           (f0-6 (fabs (* 2.0 (- 0.5 (get-norm! (-> self sync) 0)))))
           (f0-8 (* f0-6 f0-6))
           )
      (gp-1 (the-as sound-name s5-0) s4-0 (the int (* f30-0 (- f28-0 (* f0-8 f0-8)))) 0 0 (sound-group) #t)
      )
    (rider-post)
    )
  )

(defmethod deactivate ((this vol-rising-step))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

(defmethod init-from-entity! ((this vol-rising-step) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 32)
  (vol-rising-step-method-24 this)
  (process-drawable-from-entity! this arg0)
  (vol-rising-step-method-23 this)
  (set-vector! (-> this root scale) 1.3 1.0 1.3 1.0)
  (let ((a1-3 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-8 0))
      (if #t
          (set! v1-8 (logior v1-8 1))
          )
      (set! (-> a1-3 sync-type) 'sync-paused)
      (set! (-> a1-3 sync-flags) (the-as sync-flags v1-8))
      )
    (set! (-> a1-3 entity) (-> this entity))
    (set! (-> a1-3 period) (the-as uint 2400))
    (set! (-> a1-3 percent) 0.0)
    (set! (-> a1-3 pause-in) 0.05)
    (set! (-> a1-3 pause-out) 0.3)
    (initialize! (-> this sync) a1-3)
    )
  (set! (-> this root pause-adjust-distance) 327680.0)
  (set! (-> this init-y) (-> this root trans y))
  (set! (-> this sound-id) (new-sound-id))
  (go (method-of-object this inactive))
  )

(deftype vol-rising-step-a (vol-rising-step)
  ()
  )


(defskelgroup skel-vol-rising-step-a vol-rising-step-a vol-rising-step-a-lod0-jg vol-rising-step-a-idle-ja
              ((vol-rising-step-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 9.3)
              )

(defmethod vol-rising-step-method-23 ((this vol-rising-step-a))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-rising-step-a" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this idle-anim) 2)
  (set! (-> this amplitude) (res-lump-float (-> this entity) 'y-offset :default 40960.0))
  (+! (-> this root trans y) (res-lump-float (-> this entity) 'tunemeters :default 16384.0))
  0
  (none)
  )

(defmethod vol-rising-step-method-24 ((this vol-rising-step-a))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 -32768.0 0.0 38092.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype vol-rising-step-b (vol-rising-step)
  ()
  )


(defskelgroup skel-vol-rising-step-b vol-rising-step-b vol-rising-step-b-lod0-jg vol-rising-step-b-idle-ja
              ((vol-rising-step-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 9.3)
              )

(defmethod vol-rising-step-method-23 ((this vol-rising-step-b))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-rising-step-b" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this idle-anim) 2)
  (set! (-> this amplitude) (res-lump-float (-> this entity) 'y-offset :default 40960.0))
  0
  (none)
  )

(defmethod vol-rising-step-method-24 ((this vol-rising-step-b))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 -32768.0 0.0 38092.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype vol-rising-step-c (vol-rising-step)
  ()
  )


(defskelgroup skel-vol-rising-step-c vol-rising-step-c vol-rising-step-c-lod0-jg vol-rising-step-c-idle-ja
              ((vol-rising-step-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 9.3)
              )

(defmethod vol-rising-step-method-23 ((this vol-rising-step-c))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-rising-step-c" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this idle-anim) 2)
  (set! (-> this amplitude) (res-lump-float (-> this entity) 'y-offset :default 40960.0))
  (+! (-> this root trans y) 10240.0)
  0
  (none)
  )

(defmethod vol-rising-step-method-24 ((this vol-rising-step-c))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 -32768.0 0.0 38092.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype vol-rising-step-d (vol-rising-step)
  ()
  )


(defskelgroup skel-vol-rising-step-d vol-rising-step-d 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 -8 0 9.3)
              )

(defmethod vol-rising-step-method-23 ((this vol-rising-step-d))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-rising-step-d" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this idle-anim) 2)
  (set! (-> this amplitude) (res-lump-float (-> this entity) 'y-offset :default 40960.0))
  0
  (none)
  )

(defmethod vol-rising-step-method-24 ((this vol-rising-step-d))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 -32768.0 0.0 38092.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype lava-shoot (process-drawable)
  ((root                collide-shape-moving :override)
   (sync                sync-paused           :inline)
   (attack-id           uint32)
   (sound-id            sound-id)
   (no-collision-timer  time-frame)
   )
  (:state-methods
    idle
    )
  )


(defstate idle (lava-shoot)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'attack)
       (let* ((s4-0 proc)
              (gp-0 (if (type? s4-0 process-focusable)
                        s4-0
                        )
                    )
              )
         (when gp-0
           (when (or (focus-test? (the-as process-focusable gp-0) mech)
                     (time-elapsed? (-> self no-collision-timer) (-> *TARGET-bank* hit-invulnerable-timeout))
                     )
             (let ((s4-1 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))))
               (let* ((v1-10 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> (the-as process-focusable gp-0) root quat)))
                      (f0-1 (vector-dot s4-1 v1-10))
                      )
                 (if (< 0.0 f0-1)
                     (vector-float*! s4-1 s4-1 -1.0)
                     )
                 )
               (when (send-event
                       gp-0
                       'attack
                       (-> block param 0)
                       (static-attack-info
                         :mask (vehicle-impulse-factor)
                         ((id (-> self attack-id))
                          (damage 2.0)
                          (vehicle-damage-factor 1.0)
                          (vehicle-impulse-factor 1.0)
                          (mode 'burnup)
                          (vector s4-1)
                          (shove-back (meters 3))
                          (shove-up (meters 5))
                          (control (if (focus-test? (the-as process-focusable gp-0) board)
                                       1.0
                                       0.0
                                       )
                                   )
                          )
                         )
                       )
                 (let ((v0-0 (current-time)))
                   (set! (-> self no-collision-timer) v0-0)
                   v0-0
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :code sleep-code
  :post (behavior ()
    (let ((f30-0 (get-norm! (-> self sync) 0)))
      (set! (-> *part-id-table* 4601 init-specs 1 initial-valuef) (* 3.0 f30-0 f30-0))
      (set! (-> *part-id-table* 4601 init-specs 11 initial-valuef) (* 109.22667 f30-0))
      (sound-play-by-name
        (static-sound-name "geyser-loop")
        (-> self sound-id)
        (the int (* 1024.0 f30-0))
        0
        0
        (sound-group)
        #t
        )
      (let* ((v1-13 (-> self root root-prim))
             (a0-4 (the int (* f30-0 (the float (-> v1-13 specific 0)))))
             )
        (dotimes (a1-2 (the-as int (-> (the-as collide-shape-prim-group v1-13) num-children)))
          (cond
            ((>= a1-2 a0-4)
             (logclear! (-> (the-as collide-shape-prim-group v1-13) child a1-2 prim-core action) (collide-action solid))
             (logclear!
               (-> (the-as collide-shape-prim-group v1-13) child a1-2 prim-core collide-as)
               (collide-spec obstacle)
               )
             )
            (else
              (logior! (-> (the-as collide-shape-prim-group v1-13) child a1-2 prim-core action) (collide-action solid))
              (logior! (-> (the-as collide-shape-prim-group v1-13) child a1-2 prim-core collide-as) (collide-spec obstacle))
              )
            )
          )
        )
      )
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (quaternion->matrix gp-0 (-> self root quat))
      (set! (-> gp-0 trans quad) (-> self root trans quad))
      (spawn-from-mat (-> self part) gp-0)
      )
    0
    )
  )

(defmethod deactivate ((this lava-shoot))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this sound-id))
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defmethod init-from-entity! ((this lava-shoot) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 7) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 8))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) -3)
      (set-vector! (-> s3-0 local-sphere) 0.0 -32768.0 16384.0 40960.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) -3)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) -3)
      (set-vector! (-> v1-14 local-sphere) 0.0 -8192.0 8192.0 8192.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) -3)
      (set-vector! (-> v1-16 local-sphere) 0.0 -16384.0 10240.0 8192.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) -3)
      (set-vector! (-> v1-18 local-sphere) 0.0 -24576.0 13926.4 8192.0)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) -3)
      (set-vector! (-> v1-20 local-sphere) 0.0 -32768.0 14745.6 8192.0)
      )
    (let ((v1-22 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-22 prim-core action) (collide-action solid))
      (set! (-> v1-22 transform-index) -3)
      (set-vector! (-> v1-22 local-sphere) 0.0 -40960.0 16384.0 8192.0)
      )
    (let ((v1-24 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-24 prim-core action) (collide-action solid))
      (set! (-> v1-24 transform-index) -3)
      (set-vector! (-> v1-24 local-sphere) 0.0 -49152.0 18432.0 8192.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-27 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (let ((a1-31 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-29 0))
      (if #t
          (set! v1-29 (logior v1-29 1))
          )
      (set! (-> a1-31 sync-type) 'sync-paused)
      (set! (-> a1-31 sync-flags) (the-as sync-flags v1-29))
      )
    (set! (-> a1-31 entity) (-> this entity))
    (set! (-> a1-31 period) (the-as uint 2400))
    (set! (-> a1-31 percent) 0.0)
    (set! (-> a1-31 pause-in) 0.05)
    (set! (-> a1-31 pause-out) 0.3)
    (initialize! (-> this sync) a1-31)
    )
  (let* ((v1-37 *game-info*)
         (a0-50 (+ (-> v1-37 attack-id) 1))
         )
    (set! (-> v1-37 attack-id) a0-50)
    (set! (-> this attack-id) a0-50)
    )
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1388) this))
  (update-transforms (-> this root))
  (go (method-of-object this idle))
  )

(deftype vol-balance-plat-chain-physics (chain-physics)
  ()
  )


(defmethod apply-gravity ((this vol-balance-plat-chain-physics) (arg0 vector) (arg1 int) (arg2 process-drawable))
  (with-pp
    (vector-float*!
      arg0
      (-> this gravity)
      (* 4096.0 (-> pp clock time-adjust-ratio) (lerp-scale 0.01 0.1 (the float arg1) 0.0 8.0))
      )
    (vector+float*! arg0 arg0 (the-as vector (+ (the-as uint (-> this chain-joints 0 velocity)) (* arg1 64))) 0.2)
    0
    (none)
    )
  )

(defmethod chain-physics-method-14 ((this vol-balance-plat-chain-physics) (arg0 vector) (arg1 int))
  (vector-float*!
    arg0
    (the-as vector (+ (the-as uint (-> this chain-joints 0 velocity)) (* (+ arg1 1) 64)))
    0.4
    )
  0
  (none)
  )

(defmethod chain-physics-method-16 ((this vol-balance-plat-chain-physics) (arg0 int))
  1820.4445
  )

(defmethod gravity-update ((this vol-balance-plat-chain-physics) (arg0 process-drawable))
  ((method-of-type chain-physics gravity-update) this arg0)
  0
  (none)
  )

(defmethod chain-physics-method-17 ((this vol-balance-plat-chain-physics) (arg0 vector) (arg1 int))
  0
  (none)
  )

(deftype vol-balance-plat (rigid-body-object)
  ((pivot-transform   transformq  :inline)
   (init-pos          vector      :inline)
   (force-pos         vector      :inline)
   (rope              vol-balance-plat-chain-physics)
   (rope-initialized  symbol)
   )
  )


(defskelgroup skel-vol-balance-plat vol-balance-plat vol-balance-plat-lod0-jg vol-balance-plat-idle-ja
              ((vol-balance-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -12 0 14)
              )

(define *vol-balance-plat-chain-setup* (new 'static 'boxed-array :type chain-physics-setup
                                         (new 'static 'chain-physics-setup :joint-index 4)
                                         (new 'static 'chain-physics-setup :joint-index 5)
                                         (new 'static 'chain-physics-setup :joint-index 6)
                                         (new 'static 'chain-physics-setup :joint-index 7)
                                         (new 'static 'chain-physics-setup :joint-index 8)
                                         (new 'static 'chain-physics-setup :joint-index 9)
                                         (new 'static 'chain-physics-setup :joint-index 10)
                                         (new 'static 'chain-physics-setup :joint-index 11)
                                         (new 'static 'chain-physics-setup :joint-index 12)
                                         )
        )

(define *vol-balance-plat-rigid-body-constants*
  (new 'static 'rigid-body-object-constants
    :info (new 'static 'rigid-body-info
      :mass 2.0
      :inv-mass 0.5
      :linear-damping 0.97
      :angular-damping 0.97
      :bounce-factor 0.8
      :friction-factor 1.0
      :cm-offset-joint (new 'static 'vector :y -24576.0 :w 1.0)
      :inertial-tensor-box (new 'static 'array meters 3 (meters 15) (meters 30) (meters 15))
      )
    :extra (new 'static 'rigid-body-object-extra-info
      :max-time-step 0.033333335
      :gravity (meters 20)
      :idle-distance (meters 200)
      :attack-force-scale 0.2
      )
    :name '*vol-balance-plat-rigid-body-constants*
    )
  )

(defmethod rigid-body-object-method-53 ((this vol-balance-plat) (arg0 float))
  (when (logtest? (-> this flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    (when (logtest? (-> this flags) (rigid-body-object-flag player-impulse-force))
      (logclear! (-> this flags) (rigid-body-object-flag player-impulse-force))
      (vector-float*! (-> this player-force) (-> this player-force) (/ 1.0 arg0))
      )
    (apply-impact! (-> this rbody) (-> this player-force-position) (-> this player-force))
    (apply-impact!
      (-> this rbody)
      (-> this init-pos)
      (vector-normalize-copy! (new 'stack-no-clear 'vector) *y-vector* (vector-length (-> this player-force)))
      )
    )
  0
  (none)
  )

(defmethod on-impact ((this vol-balance-plat) (arg0 rigid-body-impact))
  (sound-play "platform-swing")
  0
  (none)
  )

(defmethod rigid-body-object-method-32 ((this vol-balance-plat))
  (detect-riders! (-> this root))
  ((method-of-type rigid-body-object rigid-body-object-method-32) this)
  (none)
  )

(defmethod apply-gravity! ((this vol-balance-plat) (arg0 float))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-! a1-1 (-> this init-pos) (-> this root trans))
    (let ((f0-0 0.0))
      (set! (-> a1-1 z) f0-0)
      (set! (-> a1-1 x) f0-0)
      )
    (vector-float*! a1-1 a1-1 80.0)
    (add-force! (-> this rbody) a1-1)
    )
  (let ((a0-5 (-> this init-pos)))
    (set-vector! (new 'stack-no-clear 'vector) (-> a0-5 x) (+ 163840.0 (-> a0-5 y)) (-> a0-5 z) 1.0)
    )
  (let* ((f0-7 4.0)
         (s4-0 (-> this node-list data 12))
         (f30-0 (sin (* 65536.0 (/ (the float (mod (current-time) (the int (* 300.0 f0-7)))) (* 300.0 f0-7)))))
         (s2-0 (new 'stack-no-clear 'vector))
         (s3-0 (vector<-cspace! (new 'stack-no-clear 'vector) s4-0))
         )
    (let ((s1-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (the-as vector (-> s4-0 bone transform)) 1.0)))
      (vector-float*!
        s2-0
        s1-0
        (* f30-0 (if (= (res-lump-value (-> this entity) 'extra-id uint :time -1000000000.0) 1)
                     40960.0
                     8192.0
                     )
           )
        )
      )
    (apply-impact! (-> this rbody) s3-0 s2-0)
    )
  (let ((s4-3 (new 'stack-no-clear 'vector))
        (a1-7 (-> this node-list data 12))
        )
    (new 'stack-no-clear 'vector)
    (vector-float*! s4-3 *y-vector* (* -1.0 (-> this info extra gravity) (-> this rbody info mass)))
    (apply-impact! (-> this rbody) (vector<-cspace! (new 'stack-no-clear 'vector) a1-7) s4-3)
    )
  (rigid-body-object-method-53 this arg0)
  0
  (none)
  )

(defmethod rbody-post ((this vol-balance-plat))
  (rigid-body-object-method-32 this)
  (quaternion-copy! (-> this root quat) (the-as quaternion (-> this rbody rot)))
  (rigid-body-control-method-25 (-> this rbody) (-> this root trans))
  (when (not (-> this rope-initialized))
    (set! (-> this rope-initialized) #t)
    (initialize-chain-joints (-> this rope))
    )
  (update (-> this rope) this)
  (rider-post)
  (none)
  )

(defmethod rbody-event-handler ((this vol-balance-plat) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('bonk)
     (sound-play "platform-swing")
     )
    )
  ((method-of-type rigid-body-object rbody-event-handler) this arg0 arg1 arg2 arg3)
  )

(defmethod relocate ((this vol-balance-plat) (offset int))
  (if (nonzero? (-> this rope))
      (&+! (-> this rope) offset)
      )
  (call-parent-method this offset)
  )

(defmethod init-collision! ((this vol-balance-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 -49152.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 7)
      (set-vector! (-> v1-14 local-sphere) 0.0 -16384.0 0.0 55296.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid rideable))
      (set! (-> v1-16 transform-index) 12)
      (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 28672.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-19 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-19 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-19 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-rbody-control! ((this vol-balance-plat))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-balance-plat" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root pause-adjust-distance) 614400.0)
  (let ((a0-3 (-> this skel root-channel 0)))
    (set! (-> a0-3 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-3 frame-num) 0.0)
    (joint-control-channel-group! a0-3 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (set! (-> this rope) (new 'process 'vol-balance-plat-chain-physics))
  (chain-physics-initialize this (-> this rope) 4 8192.0 *vol-balance-plat-chain-setup*)
  (alloc-rbody-control! this *vol-balance-plat-rigid-body-constants*)
  (set! (-> this init-pos quad) (-> this root trans quad))
  (let ((a0-10 (-> this node-list data 4)))
    (set! (-> a0-10 param0)
          (lambda ((arg0 cspace) (arg1 transformq))
            (let ((gp-0 (-> arg0 param1)))
              (cspace<-parented-transformq-joint! arg0 arg1)
              (set! (-> arg0 bone transform trans quad) (-> (the-as vol-balance-plat gp-0) init-pos quad))
              )
            (none)
            )
          )
    (set! (-> a0-10 param1) this)
    )
  (rigid-body-object-method-42 this)
  (apply-momentum! this)
  0
  (none)
  )

(deftype vol-steam-explosion (process-drawable)
  ((root                collide-shape-moving :override)
   (sync                sync-paused           :inline)
   (notify-actor        entity-actor)
   (attack-id           uint32)
   (lid-y               float)
   (extra-id            int32)
   (y-speed             float)
   (sound-id            sound-id)
   (stopped-up-by       handle)
   (no-collision-timer  time-frame)
   (trigger-count       int32)
   )
  (:state-methods
    idle
    stopped-up
    active
    )
  (:methods
    (vol-steam-explosion-method-23 (_type_) none)
    )
  )


(defmethod vol-steam-explosion-method-23 ((this vol-steam-explosion))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 6) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 7))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) -3)
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 40960.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-12 transform-index) -3)
      (set-vector! (-> v1-12 local-sphere) 0.0 8192.0 0.0 8192.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 transform-index) -3)
      (set-vector! (-> v1-14 local-sphere) 0.0 16384.0 0.0 12288.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-16 transform-index) -3)
      (set-vector! (-> v1-16 local-sphere) 0.0 32768.0 0.0 16384.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-18 transform-index) -3)
      (set-vector! (-> v1-18 local-sphere) 0.0 49152.0 0.0 20480.0)
      )
    (set-vector!
      (-> (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 1)) local-sphere)
      0.0
      -12288.0
      0.0
      12288.0
      )
    (let ((v1-22 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-22 prim-core action) (collide-action solid))
      (set-vector! (-> v1-22 local-sphere) 0.0 -6144.0 0.0 4505.6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-25 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-25 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-25 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defstate idle (vol-steam-explosion)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (+! (-> self trigger-count) 1)
       (if (= (-> self trigger-count) 2)
           (go-virtual active)
           )
       )
      )
    )
  :code sleep-code
  )

(defstate stopped-up (vol-steam-explosion)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('in-hole)
       (if (and (or (= (-> self extra-id) 1) (= (-> self extra-id) 2))
                (< 9011.2 (the-as float (-> block param 0)))
                (< 4096.0 (the-as float (-> block param 1)))
                )
           (go-virtual active)
           )
       #t
       )
      (('trans)
       (-> self root trans)
       )
      (('occupied-by-other)
       (or (not (-> block param 0)) (!= (handle->process (-> self stopped-up-by)) (-> block param 0)))
       )
      )
    )
  :enter (behavior ()
    (let ((v1-1 (the-as collide-shape-prim-group (-> self root root-prim))))
      (set! (-> v1-1 child 4 prim-core action) (collide-action))
      (set! (-> v1-1 child 4 prim-core collide-as) (collide-spec))
      )
    0
    )
  :exit (behavior ()
    (set! (-> self stopped-up-by) (the-as handle #f))
    )
  :code (behavior ()
    (suspend-for (seconds 0.5)
      )
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'trigger)
      (let ((t9-0 send-event-function)
            (v1-7 (-> self notify-actor))
            )
        (t9-0
          (if v1-7
              (-> v1-7 extra process)
              )
          a1-0
          )
        )
      )
    (sleep-code)
    )
  )

(defstate active (vol-steam-explosion)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack 'touch)
       (let* ((s5-0 proc)
              (gp-0 (if (type? s5-0 process-focusable)
                        s5-0
                        )
                    )
              )
         (when gp-0
           (when (or (focus-test? (the-as process-focusable gp-0) mech)
                     (time-elapsed? (-> self no-collision-timer) (-> *TARGET-bank* hit-invulnerable-timeout))
                     )
             (let ((a0-7
                     (vector-! (new 'stack-no-clear 'vector) (-> (the-as process-focusable gp-0) root trans) (-> self root trans))
                     )
                   )
               (vector-normalize! a0-7 1.0)
               )
             (when (send-event gp-0 'shove #f (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                                                  (damage 2.0)
                                                                                                  (vehicle-damage-factor 1.0)
                                                                                                  (vehicle-impulse-factor 1.0)
                                                                                                  (shove-back (meters 3))
                                                                                                  (shove-up (meters 1))
                                                                                                  )
                                                                  )
                               )
               (let ((v0-1 (the-as object (current-time))))
                 (set! (-> self no-collision-timer) (the-as time-frame v0-1))
                 v0-1
                 )
               )
             )
           )
         )
       )
      (('untrigger)
       (go-virtual idle)
       )
      (('active?)
       #t
       )
      (('get-norm)
       (get-norm! (-> self sync) 0)
       )
      (('in-hole)
       (when (and (or (= (-> self extra-id) 1) (= (-> self extra-id) 2))
                  (< (the-as float (-> block param 0)) 6144.0)
                  (< (the-as float (-> block param 1)) 2048.0)
                  )
         (set! (-> self stopped-up-by) (process->handle proc))
         (go-virtual stopped-up)
         )
       #f
       )
      (('set-y)
       (if (-> block param 0)
           (set! (-> self lid-y) (the-as float (-> block param 0)))
           (set! (-> self lid-y) (+ 819200.0 (-> self root trans y)))
           )
       )
      (('trans)
       (-> self root trans)
       )
      )
    )
  :enter (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'untrigger)
      (let ((t9-0 send-event-function)
            (v1-2 (-> self notify-actor))
            )
        (t9-0
          (if v1-2
              (-> v1-2 extra process)
              )
          a1-0
          )
        )
      )
    (let ((v1-6 (-> self root root-prim)))
      (set! (-> (the-as collide-shape-prim-group v1-6) child 4 prim-core action) (collide-action solid))
      (set! (-> (the-as collide-shape-prim-group v1-6) child 4 prim-core collide-as) (collide-spec obstacle))
      )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :code sleep-code
  :post (behavior ()
    (let ((f30-0 (get-norm! (-> self sync) 0)))
      (sound-play-by-name
        (static-sound-name "steam-vent")
        (-> self sound-id)
        (the int (* 1024.0 f30-0))
        0
        0
        (sound-group)
        #t
        )
      (let ((f0-5 (lerp-scale 0.0 1.0 (- (-> self lid-y) (-> self root trans y)) 0.0 81920.0)))
        (set! (-> *part-id-table* 4610 init-specs 1 initial-valuef) (* 3.0 f30-0 f30-0 f0-5))
        (set! (-> *part-id-table* 4610 init-specs 9 initial-valuef) (* 13.653334 f30-0 (-> self y-speed) f0-5))
        )
      (let ((v1-15 (-> self root root-prim))
            (a0-5 (the int (* 4.0 f30-0)))
            )
        (dotimes (a1-3 4)
          (cond
            ((or (>= a1-3 a0-5)
                 (>= (+ (-> (the-as collide-shape-prim-group v1-15) child a1-3 prim-core world-sphere y)
                        (-> (the-as collide-shape-prim-group v1-15) child a1-3 prim-core world-sphere w)
                        )
                     (+ -4096.0 (-> self lid-y))
                     )
                 )
             (logclear! (-> (the-as collide-shape-prim-group v1-15) child a1-3 prim-core action) (collide-action solid))
             (logclear!
               (-> (the-as collide-shape-prim-group v1-15) child a1-3 prim-core collide-as)
               (collide-spec obstacle)
               )
             )
            (else
              (logior! (-> (the-as collide-shape-prim-group v1-15) child a1-3 prim-core action) (collide-action solid))
              (logior! (-> (the-as collide-shape-prim-group v1-15) child a1-3 prim-core collide-as) (collide-spec obstacle))
              )
            )
          )
        )
      )
    (let ((gp-0 (new 'stack-no-clear 'matrix)))
      (let* ((a2-22 gp-0)
             (a3-29 *identity-matrix*)
             (v1-18 (-> a3-29 rvec quad))
             (a0-6 (-> a3-29 uvec quad))
             (a1-4 (-> a3-29 fvec quad))
             (a3-30 (-> a3-29 trans quad))
             )
        (set! (-> a2-22 rvec quad) v1-18)
        (set! (-> a2-22 uvec quad) a0-6)
        (set! (-> a2-22 fvec quad) a1-4)
        (set! (-> a2-22 trans quad) a3-30)
        )
      (matrix<-quat gp-0 (-> self root quat))
      (set! (-> gp-0 trans quad) (-> self root trans quad))
      (spawn-from-mat (-> self part) gp-0)
      )
    0
    )
  )

(defmethod deactivate ((this vol-steam-explosion))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

(defmethod init-from-entity! ((this vol-steam-explosion) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 128)
  (vol-steam-explosion-method-23 this)
  (process-drawable-from-entity! this arg0)
  (let ((a1-3 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-4 0))
      (if #t
          (set! v1-4 (logior v1-4 1))
          )
      (set! (-> a1-3 sync-type) 'sync-paused)
      (set! (-> a1-3 sync-flags) (the-as sync-flags v1-4))
      )
    (set! (-> a1-3 entity) (-> this entity))
    (set! (-> a1-3 period) (the-as uint 1200))
    (set! (-> a1-3 percent) 0.0)
    (set! (-> a1-3 pause-in) 0.05)
    (set! (-> a1-3 pause-out) 0.7)
    (initialize! (-> this sync) a1-3)
    )
  (let* ((v1-12 *game-info*)
         (a0-10 (+ (-> v1-12 attack-id) 1))
         )
    (set! (-> v1-12 attack-id) a0-10)
    (set! (-> this attack-id) a0-10)
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1394) this))
  (set! (-> this lid-y) 4096000.0)
  (set! (-> this extra-id) (res-lump-value (-> this entity) 'extra-id int :time -1000000000.0))
  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this y-speed) (res-lump-float (-> this entity) 'y-speed :default 140.0))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this stopped-up-by) (the-as handle #f))
  (set! (-> this trigger-count) 0)
  (update-transforms (-> this root))
  (let ((v1-21 (-> this extra-id)))
    (if (or (zero? v1-21) (= v1-21 1) (= v1-21 2))
        (go (method-of-object this active))
        (go (method-of-object this idle))
        )
    )
  )

(deftype spinning-hole (vol-steam-explosion)
  ()
  )


(defskelgroup skel-vol-bouncer vol-bouncer vol-bouncer-lod0-jg vol-bouncer-idle-ja
              ((vol-bouncer-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(deftype vol-bouncer (bouncer)
  ()
  )


(defstate idle (vol-bouncer)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (when ((method-of-type touching-shapes-entry prims-touching?)
              (the-as touching-shapes-entry (-> block param 0))
              (-> self root)
              (the-as uint 1)
              )
         (when (send-event proc 'jump (-> self spring-height) (-> self spring-height) (-> self mods))
           (sound-play "bouncer")
           (go-virtual fire)
           )
         )
       )
      (('touch)
       (let ((gp-2 (-> block param 0)))
         (cond
           (((method-of-type touching-shapes-entry prims-touching-action?)
             (the-as touching-shapes-entry gp-2)
             (-> self root)
             (collide-action solid)
             (collide-action)
             )
            (when ((method-of-type touching-shapes-entry prims-touching?)
                   (the-as touching-shapes-entry gp-2)
                   (-> self root)
                   (the-as uint 1)
                   )
              (if (not (and (-> self next-state) (let ((v1-21 (-> self next-state name)))
                                                   (or (= v1-21 'smush) (= v1-21 'fire))
                                                   )
                            )
                       )
                  (go-virtual smush)
                  )
              )
            )
           (((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry gp-2)
             (-> self root)
             (the-as uint 4)
             )
            (persist-with-delay
              *setting-control*
              (the-as symbol (process->ppointer self))
              (seconds 0.05)
              'double-jump
              #f
              0.0
              0
              )
            )
           )
         )
       )
      (('attack)
       (let ((v1-28 (the-as object (-> block param 1)))
             (a0-16 (-> block param 0))
             (a2-7 0)
             )
         (cond
           ((= (-> (the-as attack-info v1-28) mode) 'flop)
            (set! a2-7 1)
            )
           ((= (-> (the-as attack-info v1-28) mode) 'board)
            (set! a2-7 9)
            )
           )
         (when (and (nonzero? a2-7)
                    (and ((method-of-type touching-shapes-entry prims-touching?)
                          (the-as touching-shapes-entry a0-16)
                          (-> self root)
                          (the-as uint a2-7)
                          )
                         (send-event proc 'jump (-> self spring-height) (-> self spring-height) (-> self mods))
                         )
                    )
           (sound-play "bouncer")
           (go-virtual fire)
           #f
           )
         )
       )
      )
    )
  :code (behavior ()
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (until #f
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      )
    #f
    )
  )

(defstate fire (vol-bouncer)
  :virtual #t
  :code (behavior ()
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
    (sound-play "bouncer-whoosh")
    (ja-no-eval :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
                :num! (seek!)
                :frame-num (ja-aframe 6.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle)
    )
  :post transform-post
  )

(defmethod init-skel! ((this vol-bouncer))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-bouncer" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  0
  (none)
  )

(defmethod init-collision! ((this vol-bouncer))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) -2128.2815 5212.979 223.6416 25526.682)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype vol-lava-ball (process-drawable)
  ((y-initial           float)
   (y-velocity          float)
   (y-acc               float)
   (attack-id           uint32)
   (no-collision-timer  time-frame)
   )
  (:state-methods
    idle
    done
    )
  )


(defskelgroup skel-vol-lava-ball vol-lava-ball vol-lava-ball-lod0-jg -1
              ((vol-lava-ball-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defbehavior vol-lava-ball-post vol-lava-ball ()
  (+! (-> self y-velocity) (* (-> self y-acc) (seconds-per-frame)))
  (set! (-> self y-velocity) (- (-> self y-velocity) (* 163840.0 (seconds-per-frame))))
  (let ((f30-0 (+ (-> self root trans y) (-> self y-velocity)))
        (f28-0 (-> self y-initial))
        )
    (if (and (< f30-0 f28-0) (< f28-0 (-> self root trans y)))
        (sound-play "lava-splashdown")
        )
    (set! (-> self root trans y) (fmax f28-0 f30-0))
    )
  (set! (-> self y-velocity) (* 0.997 (seconds-per-frame) (-> self y-velocity)))
  (let ((f0-12 (lerp-scale 1.0 2.0 (- (-> self root trans y) (-> self y-initial)) 0.0 20480.0)))
    (set-vector! (-> self root scale) f0-12 f0-12 f0-12 1.0)
    )
  (let* ((gp-2
           (vector-rotate-y! (new 'stack-no-clear 'vector) *x-vector* (* 182.04445 (rand-vu-float-range -180.0 180.0)))
           )
         (f0-21 (* 182.04445
                   (lerp-scale 0.0 1.0 (- (-> self root trans y) (-> self y-initial)) 16384.0 81920.0)
                   (rand-vu-float-range 100.0 250.0)
                   (seconds-per-frame)
                   )
                )
         (a2-5 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) gp-2 f0-21))
         (gp-3 (-> self root quat))
         )
    (quaternion*! gp-3 gp-3 a2-5)
    (quaternion-normalize! gp-3)
    )
  (spawn (-> self part) (-> self root trans))
  (transform-post)
  (none)
  )

(defstate idle (vol-lava-ball)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trans)
       (-> self root trans)
       )
      (('push)
       (-> self root trans)
       (let ((f0-0 (the-as float (-> block param 0))))
         (set! (-> self y-acc) (* 2211840.0 f0-0))
         )
       )
      (('done)
       (go-virtual done)
       )
      (('touch)
       (let* ((s4-0 proc)
              (gp-0 (if (type? s4-0 process-focusable)
                        s4-0
                        )
                    )
              )
         (when gp-0
           (when (time-elapsed? (-> self no-collision-timer) (-> *TARGET-bank* hit-invulnerable-timeout))
             (let ((s4-2
                     (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (-> (the-as process-drawable gp-0) root trans))
                     )
                   )
               (set! (-> s4-2 y) 0.0)
               (vector-xz-normalize! s4-2 1.0)
               (when (send-event
                       gp-0
                       'attack
                       (-> block param 0)
                       (static-attack-info
                         :mask (vehicle-impulse-factor)
                         ((id (-> self attack-id))
                          (damage 2.0)
                          (vehicle-damage-factor 1.0)
                          (vehicle-impulse-factor 1.0)
                          (mode 'burnup)
                          (vector s4-2)
                          (shove-back (meters 8))
                          (shove-up (meters 10))
                          (control (if (focus-test? (the-as process-focusable gp-0) board)
                                       1.0
                                       0.0
                                       )
                                   )
                          )
                         )
                       )
                 (let ((v0-0 (the-as object (current-time))))
                   (set! (-> self no-collision-timer) (the-as time-frame v0-0))
                   v0-0
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self no-collision-timer) 0)
    (set! (-> self y-acc) 0.0)
    (set! (-> self y-velocity) 0.0)
    (logclear! (-> self mask) (process-mask actor-pause))
    (ja-channel-set! 1)
    (ja-no-eval :group! vol-lava-ball-idle-ja :num! zero)
    )
  :code sleep-code
  :post vol-lava-ball-post
  )

(defstate done (vol-lava-ball)
  :virtual #t
  :trans (behavior ()
    (if (>= (-> self y-initial) (-> self root trans y))
        (go empty-state)
        )
    (seek! (-> self y-acc) 0.0 (* 204800.0 (seconds-per-frame)))
    )
  :code sleep-code
  :post vol-lava-ball-post
  )

(defbehavior vol-lava-ball-init-by-other vol-lava-ball ((arg0 vector) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-6 prim-core action) (collide-action solid deadly))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 10240.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-lava-ball" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self y-velocity) 0.0)
  (set! (-> self y-initial) (-> self root trans y))
  (let* ((v1-17 *game-info*)
         (a0-15 (+ (-> v1-17 attack-id) 1))
         )
    (set! (-> v1-17 attack-id) a0-15)
    (set! (-> self attack-id) a0-15)
    )
  (set! (-> self no-collision-timer) 0)
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 1397) self))
  (go-virtual idle)
  )

(deftype vol-lava-ball-spout (process-drawable)
  ((sync          sync-paused  :inline)
   (ball          handle)
   (ball-height   float)
   (sound-id      sound-id)
   (explode-time  time-frame)
   )
  (:state-methods
    idle
    going-active
    active
    )
  )


(defstate idle (vol-lava-ball-spout)
  :virtual #t
  :trans (behavior ()
    (if (< (vector-vector-xz-distance (target-pos 0) (-> self root trans)) 573440.0)
        (go-virtual going-active)
        )
    )
  :code sleep-code
  )

(defstate going-active (vol-lava-ball-spout)
  :virtual #t
  :code (behavior ()
    (let ((gp-0 (get-timeframe-offset! (-> self sync) 0)))
      (until (< gp-0 (current-time))
        (suspend)
        )
      )
    (go-virtual active)
    )
  )

(defstate active (vol-lava-ball-spout)
  :virtual #t
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self ball)
          (process->handle
            (ppointer->process
              (process-spawn vol-lava-ball (-> self root trans) (-> self entity) :name "vol-lava-ball" :to self)
              )
            )
          )
    (set! (-> self explode-time) (+ (get-timeframe-offset! (-> self sync) 0) (the int (-> self sync pause-in))))
    (if (< (+ (current-time) (the-as time-frame (-> self sync period))) (-> self explode-time))
        (set! (-> self explode-time) (- (-> self explode-time) (the-as int (-> self sync period))))
        )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (when (< 655360.0 (vector-vector-xz-distance (target-pos 0) (-> self root trans)))
      (send-event (handle->process (-> self ball)) 'done)
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post (behavior ()
    (when (< 8192.0 (vector-vector-xz-distance (-> self root trans) (camera-pos)))
      (when (< (-> self explode-time) (current-time))
        (sound-play "geyser-start")
        (set! (-> self explode-time) (+ (get-timeframe-offset! (-> self sync) 0) (the int (-> self sync pause-in))))
        )
      (let ((f30-1 (get-norm! (-> self sync) 0)))
        (sound-play-by-name
          (static-sound-name "geyser-loop")
          (-> self sound-id)
          (the int (* 1024.0 f30-1))
          0
          0
          (sound-group)
          #t
          )
        (let ((a1-5 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-5 from) (process->ppointer self))
          (set! (-> a1-5 num-params) 0)
          (set! (-> a1-5 message) 'trans)
          (let ((v1-17 (the-as vector (send-event-function (handle->process (-> self ball)) a1-5))))
            (when v1-17
              (let ((f28-0 (lerp-scale 1.0 0.0 (- (-> v1-17 y) (-> self root trans y)) 0.0 (-> self ball-height))))
                (send-event (handle->process (-> self ball)) 'push (* f28-0 f30-1))
                (set! (-> *part-id-table* 4612 init-specs 2 initial-valuef) (* 10.0 f30-1 (- 1.0 f28-0)))
                (set! (-> *part-id-table* 4612 init-specs 13 initial-valuef)
                      (+ (* 6826.6665 f30-1 f28-0) (* (/ (-> self ball-height) 500) f30-1 (- 1.0 f28-0)))
                      )
                )
              0
              )
            )
          )
        )
      (let ((gp-2 (new 'stack-no-clear 'matrix)))
        (let* ((a2-5 gp-2)
               (a3-3 *identity-matrix*)
               (v1-38 (-> a3-3 rvec quad))
               (a0-23 (-> a3-3 uvec quad))
               (a1-8 (-> a3-3 fvec quad))
               (a3-4 (-> a3-3 trans quad))
               )
          (set! (-> a2-5 rvec quad) v1-38)
          (set! (-> a2-5 uvec quad) a0-23)
          (set! (-> a2-5 fvec quad) a1-8)
          (set! (-> a2-5 trans quad) a3-4)
          )
        (matrix<-quat gp-2 (-> self root quat))
        (set! (-> gp-2 trans quad) (-> self root trans quad))
        (spawn-from-mat (-> self part) gp-2)
        )
      )
    )
  )

(defmethod deactivate ((this vol-lava-ball-spout))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

(defmethod init-from-entity! ((this vol-lava-ball-spout) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (let ((a1-3 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-1 0))
      (if #t
          (set! v1-1 (logior v1-1 1))
          )
      (set! (-> a1-3 sync-type) 'sync-paused)
      (set! (-> a1-3 sync-flags) (the-as sync-flags v1-1))
      )
    (set! (-> a1-3 entity) (-> this entity))
    (set! (-> a1-3 period) (the-as uint 1800))
    (set! (-> a1-3 percent) 0.0)
    (set! (-> a1-3 pause-in) 0.7)
    (set! (-> a1-3 pause-out) 0.05)
    (initialize! (-> this sync) a1-3)
    )
  (set! (-> this ball-height) (res-lump-float (-> this entity) 'y-offset :default 81920.0))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1395) this))
  (set! (-> this ball) (the-as handle #f))
  (set! (-> this sound-id) (new-sound-id))
  (go (method-of-object this idle))
  )

(deftype vol-collapsing-rock (process-drawable)
  ()
  (:state-methods
    inactive
    idle
    (falling symbol)
    )
  )


(defskelgroup skel-vol-collapsing-rock vol-collapsing-rock vol-collapsing-rock-lod0-jg vol-collapsing-rock-idle-ja
              ((vol-collapsing-rock-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 20 -16 32)
              :origin-joint-index 3
              )

(defstate inactive (vol-collapsing-rock)
  :virtual #t
  :enter (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! vol-collapsing-rock-falling-ja :num! zero)
    (transform-post)
    )
  :trans (behavior ()
    (if (task-node-closed? (game-task-node volcano-darkeco-indax-1-introduction))
        (go-virtual idle)
        )
    )
  :code sleep-code
  )

(defstate idle (vol-collapsing-rock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual falling #f)
       )
      )
    )
  :trans (behavior ()
    (gui-control-method-12
      *gui-control*
      self
      (gui-channel art-load)
      (gui-action queue)
      "volcano-indax-1-res"
      0
      -99.0
      (new 'static 'sound-id)
      )
    )
  :code sleep-code
  )

(defstate falling (vol-collapsing-rock)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    )
  :code (behavior ((arg0 symbol))
    (cond
      (arg0
        (ja-no-eval :group! vol-collapsing-rock-falling-ja
                    :num! (identity (the float (+ (-> (the-as art-joint-anim vol-collapsing-rock-falling-ja) frames num-frames) -1)))
                    )
        (ja-post)
        (suspend)
        (transform-post)
        )
      (else
        (process-spawn scene-player :init scene-player-init "volcano-indax-1-res" #t #f :name "scene-player")
        )
      )
    (sleep-code)
    )
  )

(defmethod init-from-entity! ((this vol-collapsing-rock) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> s3-0 prim-core action) (collide-action solid no-smack))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 81920.0 -65536.0 131072.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-8 prim-core action) (collide-action solid no-smack))
      (set! (-> v1-8 transform-index) 12)
      (set-vector! (-> v1-8 local-sphere) -258.4576 55495.066 403.456 60998.043)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) -4071.424 21141.094 -3941.9905 49417.42)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) -963.3792 34254.027 -114976.36 62616.78)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vol-collapsing-rock" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (if (or (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
          (task-node-closed? (game-task-node volcano-darkeco-indax-1))
          )
      (go (method-of-object this falling) #t)
      (go (method-of-object this inactive))
      )
  )
