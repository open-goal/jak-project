;;-*-Lisp-*-
(in-package goal)

;; name: comb-obs.gc
;; name in dgo: comb-obs
;; dgos: RAILA, COMBA

(define-extern *comb-energy-ring-lightning-width* curve2d-fast)
(define-extern *comb-energy-ring-lightning* lightning-appearance)

;; DECOMP BEGINS

(deftype comb-elevator (elevator)
  ()
  )


(defskelgroup skel-comb-elevator min-elevator min-elevator-lod0-jg min-elevator-idle-ja
              ((min-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 11)
              )

(defmethod get-art-group ((this comb-elevator))
  (art-group-get-by-name *level* "skel-comb-elevator" (the-as (pointer level) #f))
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-collision! ((this comb-elevator))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 45056.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 45056.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint (shl #xfe00 16)))))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 3)
      (set-vector! (-> v1-18 local-sphere) 0.0 0.0 0.0 45056.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-21 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-21 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-21 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch sound-spec vs none.
(defmethod init-bounce-params! ((this comb-elevator))
  (call-parent-method this)
  (setup-masks (-> this draw) 1 2)
  (set! (-> this draw light-index) (the-as uint 1))
  (set! (-> this bounce-scale) 0.0)
  (set! (-> this sound-running-loop) (static-sound-spec "min-elevator" :group 0))
  (none)
  )

(defmethod base-plat-method-34 ((this comb-elevator))
  0
  (none)
  )

(deftype comb-pillar (process-focusable)
  ((center-pos          vector  :inline)
   (attack-vel          vector  :inline)
   (exploder-params     joint-exploder-static-params)
   (exploder-skel       skeleton-group)
   (exploder-anim       uint32)
   (hit-points          float)
   (incoming-attack-id  int32)
   )
  (:state-methods
    idle
    explode
    )
  (:methods
    (update-fade (_type_) none)
    (set-cspec! (_type_) none)
    (go-explode (_type_) none)
    (set-attack-vel! (_type_ vector) none)
    (on-attack (_type_ process attack-info object) symbol)
    (on-impulse (_type_ rigid-body-impact) symbol)
    )
  )


(defskelgroup skel-comb-pillar comb-pillar comb-pillar-lod0-jg comb-pillar-idle-ja
              ((comb-pillar-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 70 0 75)
              )

(defskelgroup skel-comb-pillar-explode comb-pillar comb-pillar-explode-lod0-jg comb-pillar-explode-idle-ja
              ((comb-pillar-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6.5 0 7)
              )

(define *comb-pillar-explode-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    :art-level #f
    )
  )

(defmethod init-from-entity! ((this comb-pillar) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 286720.0 0.0 307200.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 286720.0 0.0 307200.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (let ((s5-1 (new 'stack-no-clear 'inline-array 'vector 1)))
    (vector-y-quaternion! (-> s5-1 0) (-> this root quat))
    (vector+float*! (-> this center-pos) (-> this root trans) (-> s5-1 0) 286720.0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-pillar" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this hit-points) 8.0)
  (set! (-> this exploder-params) *comb-pillar-explode-params*)
  (set! (-> this exploder-skel)
        (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-pillar-explode" (the-as (pointer level) #f)))
        )
  (set! (-> this exploder-anim) (the-as uint 7))
  (set! (-> this draw lod-set lod 0 dist) 1228800.0)
  (set! (-> this draw lod-set lod 1 dist) 1232896.0)
  (set-cspec! this)
  (go (method-of-object this idle))
  )

(defmethod set-cspec! ((this comb-pillar))
  (iterate-prims
    (-> this root)
    (lambda ((arg0 collide-shape-prim))
      (set! (-> arg0 prim-core collide-with) (collide-spec
                                               backgnd
                                               jak
                                               bot
                                               crate
                                               civilian
                                               enemy
                                               obstacle
                                               vehicle-sphere
                                               hit-by-player-list
                                               hit-by-others-list
                                               player-list
                                               collectable
                                               pusher
                                               shield
                                               vehicle-sphere-no-probe
                                               )
            )
      (set! (-> arg0 prim-core collide-as) (collide-spec obstacle vehicle-sphere vehicle-mesh))
      (none)
      )
    )
  (update-transforms (-> this root))
  0
  (none)
  )

(defmethod update-fade ((this comb-pillar))
  (let ((f0-2 (fmax 0.0 (+ -81920.0 (vector-vector-distance (-> this center-pos) (camera-pos)))))
        (f1-0 40960.0)
        )
    (cond
      ((< f0-2 f1-0)
       (logior! (-> this draw status) (draw-control-status force-fade))
       (set! (-> this draw force-fade) (the-as uint (the int (* 128.0 (/ f0-2 f1-0)))))
       )
      (else
        (logclear! (-> this draw status) (draw-control-status force-fade))
        )
      )
    )
  (ja-post)
  0
  (none)
  )

(defmethod go-explode ((this comb-pillar))
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((v1-3 (-> this root root-prim)))
    (set! (-> v1-3 prim-core collide-as) (collide-spec))
    (set! (-> v1-3 prim-core collide-with) (collide-spec))
    )
  0
  (logior! (-> this root penetrated-by) (penetrate vehicle))
  (go (method-of-object this explode))
  0
  (none)
  )

(defmethod get-inv-mass ((this comb-pillar))
  0.125
  )

(defmethod set-attack-vel! ((this comb-pillar) (arg0 vector))
  (set! (-> this attack-vel quad) (-> arg0 quad))
  (if (< 81920.0 (vector-length (-> this attack-vel)))
      (vector-normalize! (-> this attack-vel) 81920.0)
      )
  0
  (none)
  )

(defmethod on-attack ((this comb-pillar) (arg0 process) (arg1 attack-info) (arg2 object))
  (vector-reset! (-> this attack-vel))
  (let ((a1-1 (new 'stack-no-clear 'vector))
        (f30-0 0.0)
        )
    (vector-reset! a1-1)
    (when (logtest? (attack-mask attacker-velocity) (-> arg1 mask))
      (vector-float*! a1-1 (-> arg1 attacker-velocity) 1.0)
      (set-attack-vel! this a1-1)
      )
    (when (logtest? (attack-mask damage) (-> arg1 mask))
      (if (>= (-> arg1 damage) 2.0)
          (set! f30-0 (-> arg1 damage))
          )
      )
    (set! (-> this hit-points) (- (-> this hit-points) f30-0))
    )
  (if (< (-> this hit-points) 0.0)
      (go-explode this)
      )
  #t
  )

(defmethod on-impulse ((this comb-pillar) (arg0 rigid-body-impact))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-1 (-> arg0 normal) (-> arg0 impulse))
    (set-attack-vel! this a1-1)
    )
  (when (< 286720.0 (-> arg0 impulse))
    (go-explode this)
    #t
    )
  )

(defstate idle (comb-pillar)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('impact-impulse)
       (let ((a1-1 (-> block param 0)))
         (on-impulse self (the-as rigid-body-impact a1-1))
         )
       )
      (('attack)
       (let ((s4-0 (the-as object (-> block param 1))))
         (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)
         (when (!= (-> (the-as attack-info s4-0) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (the-as int (-> (the-as attack-info s4-0) id)))
           (on-attack self proc (the-as attack-info s4-0) (-> block param 0))
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (update-fade self)
    )
  )

(defstate explode (comb-pillar)
  :virtual #t
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    (sound-play "sentry-explode")
    (let ((gp-1 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set! (-> gp-1 duration) (seconds 4))
      (set! (-> gp-1 gravity) -163840.0)
      (set! (-> gp-1 rot-speed) 5.0)
      (vector+!
        (-> gp-1 fountain-rand-transv-lo)
        (new 'static 'vector :x -40960.0 :y 40960.0 :z -40960.0 :w 1.0)
        (-> self attack-vel)
        )
      (vector+!
        (-> gp-1 fountain-rand-transv-hi)
        (new 'static 'vector :x 40960.0 :y 122880.0 :z 40960.0 :w 1.0)
        (-> self attack-vel)
        )
      (process-spawn
        joint-exploder
        (-> self exploder-skel)
        (-> self exploder-anim)
        gp-1
        (-> self exploder-params)
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (suspend-for (seconds 2))
    (cleanup-for-death self)
    )
  :post #f
  )

(deftype comb-block (process-focusable)
  ((attack-vel          vector                    :inline)
   (exploder-params     joint-exploder-static-params)
   (exploder-skel       skeleton-group)
   (exploder-anim       uint32)
   (hit-points          float)
   (incoming-attack-id  int32)
   (parts               sparticle-launch-control  4)
   )
  (:state-methods
    idle
    explode
    )
  (:methods
    (spawn-parts (_type_) none)
    (set-cspec! (_type_) none)
    (go-explode (_type_) none)
    (set-attack-vel! (_type_ vector) none)
    (on-attack (_type_ process attack-info object) symbol)
    (on-impact (_type_ rigid-body-impact) symbol)
    )
  )


(defskelgroup skel-comb-block comb-obstacle comb-obstacle-lod0-jg comb-obstacle-idle-ja
              ((comb-obstacle-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 11)
              :origin-joint-index 5
              )

(defskelgroup skel-comb-block-explode comb-obstacle comb-obstacle-explode-lod0-jg comb-obstacle-explode-idle-ja
              ((comb-obstacle-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6.5 0 7)
              )

(define *comb-block-explode-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 21 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 22 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    :art-level #f
    )
  )

(defmethod relocate ((this comb-block) (offset int))
  (dotimes (v1-0 4)
    (if (nonzero? (-> this parts v1-0))
        (&+! (-> this parts v1-0) offset)
        )
    )
  (call-parent-method this offset)
  )

(defmethod deactivate ((this comb-block))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (dotimes (s5-0 4)
    (let ((a0-1 (-> this parts s5-0)))
      (if (nonzero? a0-1)
          (kill-particles a0-1)
          )
      )
    )
  (call-parent-method this)
  (none)
  )

(defmethod init-from-entity! ((this comb-block) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 61440.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-block" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this hit-points) 0.1)
  (set! (-> this exploder-params) *comb-block-explode-params*)
  (set! (-> this exploder-skel)
        (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-block-explode" (the-as (pointer level) #f)))
        )
  (set! (-> this exploder-anim) (the-as uint 6))
  (set! (-> this draw lod-set lod 0 dist) 1228800.0)
  (set! (-> this draw lod-set lod 1 dist) 1232896.0)
  (dotimes (s5-2 4)
    (set! (-> this parts s5-2) (create-launch-control (-> *part-group-id-table* 1235) this))
    )
  (set-cspec! this)
  (go (method-of-object this idle))
  )

(defmethod set-cspec! ((this comb-block))
  (iterate-prims
    (-> this root)
    (lambda ((arg0 collide-shape-prim))
      (set! (-> arg0 prim-core collide-with) (collide-spec
                                               backgnd
                                               jak
                                               bot
                                               crate
                                               civilian
                                               enemy
                                               obstacle
                                               vehicle-sphere
                                               hit-by-player-list
                                               hit-by-others-list
                                               player-list
                                               collectable
                                               pusher
                                               shield
                                               vehicle-sphere-no-probe
                                               )
            )
      (set! (-> arg0 prim-core collide-as) (collide-spec obstacle vehicle-sphere vehicle-mesh))
      (none)
      )
    )
  (update-transforms (-> this root))
  0
  (none)
  )

(defmethod spawn-parts ((this comb-block))
  (dotimes (s5-0 4)
    (let ((v1-0 (+ s5-0 5)))
      (spawn (-> this parts s5-0) (-> this node-list data v1-0 bone transform trans))
      )
    )
  (ja-post)
  0
  (none)
  )

(defmethod go-explode ((this comb-block))
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((v1-3 (-> this root root-prim)))
    (set! (-> v1-3 prim-core collide-as) (collide-spec))
    (set! (-> v1-3 prim-core collide-with) (collide-spec))
    )
  0
  (logior! (-> this root penetrated-by) (penetrate vehicle))
  (go (method-of-object this explode))
  0
  (none)
  )

(defmethod get-inv-mass ((this comb-block))
  0.5
  )

(defmethod set-attack-vel! ((this comb-block) (arg0 vector))
  (set! (-> this attack-vel quad) (-> arg0 quad))
  (if (< 81920.0 (vector-length (-> this attack-vel)))
      (vector-normalize! (-> this attack-vel) 81920.0)
      )
  0
  (none)
  )

(defmethod on-attack ((this comb-block) (arg0 process) (arg1 attack-info) (arg2 object))
  (vector-reset! (-> this attack-vel))
  (let ((a1-1 (new 'stack-no-clear 'vector))
        (f30-0 1.0)
        )
    (vector-reset! a1-1)
    (when (logtest? (attack-mask attacker-velocity) (-> arg1 mask))
      (vector-float*! a1-1 (-> arg1 attacker-velocity) 1.0)
      (set-attack-vel! this a1-1)
      )
    (if (logtest? (attack-mask damage) (-> arg1 mask))
        (set! f30-0 (-> arg1 damage))
        )
    (set! (-> this hit-points) (- (-> this hit-points) f30-0))
    )
  (if (< (-> this hit-points) 0.0)
      (go-explode this)
      )
  #t
  )

(defmethod on-impact ((this comb-block) (arg0 rigid-body-impact))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-float*! a1-1 (-> arg0 normal) (-> arg0 impulse))
    (set-attack-vel! this a1-1)
    )
  (when (< 286720.0 (-> arg0 impulse))
    (go-explode this)
    #t
    )
  )

(defstate idle (comb-block)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('impact-impulse)
       (let ((a1-1 (-> block param 0)))
         (on-impact self (the-as rigid-body-impact a1-1))
         )
       )
      (('attack)
       (let ((s4-0 (the-as object (-> block param 1))))
         (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)
         (when (!= (-> (the-as attack-info s4-0) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (the-as int (-> (the-as attack-info s4-0) id)))
           (on-attack self proc (the-as attack-info s4-0) (-> block param 0))
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (spawn-parts self)
    )
  )

(defstate explode (comb-block)
  :virtual #t
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    (sound-play "sentry-explode")
    (let ((gp-1 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-1 spawn-point quad) (-> self node-list data 5 bone transform trans quad))
      (quaternion-identity! (-> gp-1 spawn-quat))
      (set! (-> gp-1 radius) 40960.0)
      (set! (-> gp-1 scale) 1.0)
      (set! (-> gp-1 group) (-> *part-group-id-table* 217))
      (set! (-> gp-1 collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> gp-1 damage) 7.0)
      (set! (-> gp-1 damage-scale) 1.0)
      (set! (-> gp-1 vehicle-damage-factor) 1.0)
      (set! (-> gp-1 vehicle-impulse-factor) 1.0)
      (set! (-> gp-1 ignore-proc) (process->handle #f))
      (explosion-spawn gp-1 (the-as process-drawable *default-pool*))
      )
    (let ((gp-2 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set! (-> gp-2 duration) (seconds 4))
      (set! (-> gp-2 gravity) -163840.0)
      (set! (-> gp-2 rot-speed) 10.0)
      (vector+!
        (-> gp-2 fountain-rand-transv-lo)
        (new 'static 'vector :x -245760.0 :y 245760.0 :z -245760.0 :w 1.0)
        (-> self attack-vel)
        )
      (vector+!
        (-> gp-2 fountain-rand-transv-hi)
        (new 'static 'vector :x 245760.0 :y 245760.0 :z 245760.0 :w 1.0)
        (-> self attack-vel)
        )
      (process-spawn
        joint-exploder
        (-> self exploder-skel)
        (-> self exploder-anim)
        gp-2
        (-> self exploder-params)
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (suspend-for (seconds 2))
    (cleanup-for-death self)
    )
  :post #f
  )

(deftype comb-energy-ring (process-focusable)
  ((speed           float)
   (hum-id          sound-id)
   (bolt            lightning-bolt)
   (shocked-player  symbol)
   )
  (:state-methods
    idle
    )
  (:methods
    (update-sound-and-bolt (_type_) none)
    (set-cspec! (_type_) none)
    (comb-energy-ring-method-31 (_type_) none)
    (init-bolt! (_type_) none)
    (update-bolt (_type_ vector vector) none)
    )
  )


(defskelgroup skel-comb-energy-ring comb-energy-ring comb-energy-ring-lod0-jg comb-energy-ring-idle-ja
              ((comb-energy-ring-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 29)
              )

(if #t
    (set! *comb-energy-ring-lightning-width* (new 'static 'curve2d-fast
                                               :xs (new 'static 'vector :y -1.0 :z -2.0 :w -3.0)
                                               :ys (new 'static 'vector :x 0.5 :y 4.5 :z 5.5 :w 6.5)
                                               :one-over-x-deltas (new 'static 'vector :x 4.0 :y 1.0 :z 1.0 :w 1.0)
                                               )
          )
    )

(if (or (zero? *comb-energy-ring-lightning*) (!= loading-level global))
    (set! *comb-energy-ring-lightning* (new 'loading-level 'lightning-appearance))
    )

(set! (-> *comb-energy-ring-lightning* base-alpha) 1.0)

(set! (-> *comb-energy-ring-lightning* tex-id) (the-as uint #x403f00))

(set! (-> *comb-energy-ring-lightning* blend-mode) (the-as uint 1))

(set! (-> *comb-energy-ring-lightning* alpha-1-curve) *curve-unity*)

(set! (-> *comb-energy-ring-lightning* alpha-1-mode) (the-as uint 3))

(set! (-> *comb-energy-ring-lightning* alpha-1-repeat-dist) 262144.0)

(set! (-> *comb-energy-ring-lightning* alpha-2-curve) #f)

(set! (-> *comb-energy-ring-lightning* alpha-2-mode) (the-as uint 3))

(set! (-> *comb-energy-ring-lightning* alpha-2-repeat-dist) 4096.0)

(set! (-> *comb-energy-ring-lightning* width-curve) *comb-energy-ring-lightning-width*)

(set! (-> *comb-energy-ring-lightning* width-mode) (the-as uint 2))

(set! (-> *comb-energy-ring-lightning* width-repeat-dist) 4096.0)

(set! (-> *comb-energy-ring-lightning* uv-repeat-dist) 28672.0)

(set! (-> *comb-energy-ring-lightning* regenerate-time-start) (seconds 0.167))

(set! (-> *comb-energy-ring-lightning* regenerate-time-end) (seconds 0.25))

(set! (-> *comb-energy-ring-lightning* width-range-start) 18841.6)

(set! (-> *comb-energy-ring-lightning* width-range-end) 20480.0)

(set! (-> *comb-energy-ring-lightning* fade-time) (seconds 0.1))

(set! (-> *comb-energy-ring-lightning* uv-shift?) #f)

(set! (-> *comb-energy-ring-lightning* uv-shift-speed) (seconds 0.1))

(set! (-> *comb-energy-ring-lightning* use-sprite-bucket?) #t)

(set! (-> *comb-energy-ring-lightning* use-accurate-interp?) #t)

(defmethod init-bolt! ((this comb-energy-ring))
  (set! (-> this bolt) (new 'process 'lightning-bolt))
  (init! (-> this bolt) 4 16 *comb-energy-ring-lightning*)
  0
  (none)
  )

(defmethod update-bolt ((this comb-energy-ring) (arg0 vector) (arg1 vector))
  (let ((gp-0 (-> this bolt)))
    (set! (-> gp-0 inner-point-travel-time) (seconds 1))
    (set! (-> gp-0 snap-inner-points?) #t)
    (set! (-> gp-0 fractal-reduction) 0.4)
    (set! (-> gp-0 generate-mode) (the-as uint 1))
    (set! (-> gp-0 appearance) *comb-energy-ring-lightning*)
    (set! (-> gp-0 num-active-spans) 1)
    (dotimes (v1-6 4)
      (set! (-> gp-0 spans data v1-6 random-offset-size-start) 4096.0)
      (set! (-> gp-0 spans-internal data v1-6 num-inner-points) 14)
      (set! (-> gp-0 spans data v1-6 inner-random-offset-size) 4096.0)
      )
    (set! (-> gp-0 span-pts-start data 0 quad) (-> arg0 quad))
    (set! (-> gp-0 span-pts-start data 2 quad) (-> arg0 quad))
    (set! (-> gp-0 span-pts-start data 1 quad) (-> arg1 quad))
    (set! (-> gp-0 span-pts-start data 3 quad) (-> arg1 quad))
    (set! (-> gp-0 spans data 0 random-offset-size-start) 0.0)
    (set! (-> gp-0 spans data 1 random-offset-size-start) 0.0)
    (set! (-> gp-0 spans data 2 random-offset-size-start) 0.0)
    (set! (-> gp-0 spans data 3 random-offset-size-start) 0.0)
    (set! (-> gp-0 spans-internal data 3 num-inner-points) 0)
    (if (and (!= (lightning-bolt-method-14 gp-0) 0) (!= (lightning-bolt-method-14 gp-0) 1))
        (lightning-bolt-method-13 gp-0 1)
        )
    (lightning-bolt-method-11 gp-0)
    (lightning-bolt-method-12 gp-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this comb-energy-ring) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (the-as penetrate -1))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 114688.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 6)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 5)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-energy-ring" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (init-bolt! this)
  (set! (-> this shocked-player) #f)
  (set! (-> this speed) (rand-vu-float-range 0.25 0.5))
  (set! (-> this draw lod-set lod 0 dist) 1228800.0)
  (set! (-> this draw lod-set lod 1 dist) 1232896.0)
  (set! (-> this hum-id) (new 'static 'sound-id))
  (set-cspec! this)
  (go (method-of-object this idle))
  )

;; WARN: Return type mismatch process-focusable vs comb-energy-ring.
(defmethod relocate ((this comb-energy-ring) (offset int))
  (if (nonzero? (-> this bolt))
      (&+! (-> this bolt) offset)
      )
  (the-as comb-energy-ring ((method-of-type process-focusable relocate) this offset))
  )

(defmethod set-cspec! ((this comb-energy-ring))
  (iterate-prims
    (-> this root)
    (lambda ((arg0 collide-shape-prim))
      (set! (-> arg0 prim-core collide-with) (collide-spec
                                               backgnd
                                               jak
                                               bot
                                               crate
                                               civilian
                                               enemy
                                               obstacle
                                               vehicle-sphere
                                               hit-by-player-list
                                               hit-by-others-list
                                               player-list
                                               collectable
                                               pusher
                                               shield
                                               vehicle-sphere-no-probe
                                               )
            )
      (set! (-> arg0 prim-core collide-as) (collide-spec obstacle vehicle-sphere vehicle-mesh))
      (none)
      )
    )
  (let ((s5-0 (-> this root root-prim)))
    (mem-copy!
      (the-as pointer (-> (the-as collide-shape-prim-group s5-0) child 0 local-sphere))
      (the-as pointer (new 'static 'vector :w 16384.0))
      16
      )
    (mem-copy!
      (the-as pointer (-> (the-as collide-shape-prim-group s5-0) child 1 local-sphere))
      (the-as pointer (new 'static 'vector :w 16384.0))
      16
      )
    )
  (update-transforms (-> this root))
  0
  (none)
  )

(defmethod update-sound-and-bolt ((this comb-energy-ring))
  (cond
    ((< (vector-vector-distance (-> this root trans) (target-pos 0)) 409600.0)
     (if (zero? (-> this hum-id))
         (set! (-> this hum-id) (new-sound-id))
         )
     (sound-play "rotating-arc" :id (-> this hum-id))
     )
    (else
      (when (nonzero? (-> this hum-id))
        (sound-stop (-> this hum-id))
        (set! (-> this hum-id) (new 'static 'sound-id))
        0
        )
      )
    )
  (ja-post)
  (update-transforms (-> this root))
  (let ((v1-13 (-> this root root-prim)))
    (update-bolt
      this
      (the-as vector (-> (the-as collide-shape-prim-group v1-13) child 0 prim-core))
      (the-as vector (-> (the-as collide-shape-prim-group v1-13) child 1 prim-core))
      )
    )
  0
  (none)
  )

(defmethod get-inv-mass ((this comb-energy-ring))
  0.125
  )

(defstate idle (comb-energy-ring)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (format #t "energy-ring got touched event from ~s~%" proc)
       (when (not (-> self shocked-player))
         (set! (-> self shocked-player) #t)
         (sound-play "ring-shock")
         (send-event
           proc
           'attack
           #f
           (static-attack-info
             :mask (vehicle-impulse-factor)
             ((id (new-attack-id)) (damage 32.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 0.0))
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek! max (-> self speed)) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self speed)))
        )
      )
    #f
    )
  :post (behavior ()
    (update-sound-and-bolt self)
    )
  )

(deftype comb-turbo (process-drawable)
  ((root        collide-shape :override)
   (touch-time  time-frame)
   (player-got  symbol)
   (boost       float)
   (plane       vector         :inline)
   (mat         matrix         :inline)
   )
  (:state-methods
    idle
    die
    )
  (:methods
    (init-collision! (_type_) none)
    (init-fields! (_type_) none)
    (comb-turbo-method-24 (_type_) none)
    )
  )


(defstate idle (comb-turbo)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (format #t "comb-turbo: got event ~s from ~s~%" message proc)
    (when (= message 'touched)
      (let ((s5-1 proc))
        (when (and (if (type? s5-1 vehicle)
                       s5-1
                       )
                   (not (-> self player-got))
                   )
          (set! (-> self player-got) #t)
          (send-event proc 'turbo-pad (-> self boost))
          (let ((v0-1 (current-time)))
            (set! (-> self touch-time) v0-1)
            v0-1
            )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (if (and (-> self player-got) (time-elapsed? (-> self touch-time) (seconds 3)))
        (go-virtual die)
        )
    0
    )
  )

(defstate die (comb-turbo)
  :virtual #t
  :code (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (until (time-elapsed? (-> self state-time) (seconds 2))
      (suspend)
      )
    )
  )

(defmethod init-collision! ((this comb-turbo))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrate-using) (the-as penetrate -1))
    (set! (-> s5-0 penetrated-by) (the-as penetrate -1))
    (let ((v1-4 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-4 prim-core collide-as) (collide-spec obstacle))
      (set-vector! (-> v1-4 local-sphere) 0.0 0.0 0.0 32768.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-4)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-7 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-7 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-7 prim-core collide-with))
      )
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-fields! ((this comb-turbo))
  (let ((s5-0 (-> this mat)))
    (let ((s4-0 (new 'stack-no-clear 'quaternion)))
      (quaternion-rotate-local-y! s4-0 (-> this root quat) 16384.0)
      (quaternion->matrix s5-0 s4-0)
      )
    (set! (-> s5-0 trans quad) (-> this root trans quad))
    (set! (-> this plane quad) (-> s5-0 rvec quad))
    )
  (set! (-> this plane w) (- (vector-dot (-> this plane) (-> this root trans))))
  (update-transforms (-> this root))
  (set! (-> this player-got) #f)
  (set! (-> this boost) 1.0)
  (set-time! (-> this touch-time))
  0
  (none)
  )

(defmethod init-from-entity! ((this comb-turbo) (arg0 entity-actor))
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (init-fields! this)
  (go (method-of-object this idle))
  )

(deftype task-manager-lightjak-training-shield (task-manager)
  ((gui-id  sound-id)
   )
  (:methods
    (print-text (_type_ text-id) none)
    )
  )


;; WARN: Return type mismatch float vs none.
(defmethod print-text ((this task-manager-lightjak-training-shield) (arg0 text-id))
  (when (= (get-status *gui-control* (-> this gui-id)) (gui-status active))
    (let ((s5-1
            (new 'stack 'font-context *font-default-matrix* 32 290 0.0 (font-color default) (font-flags shadow kerning))
            )
          )
      (set! (-> s5-1 flags) (font-flags shadow kerning middle middle-vert large))
      (let ((v1-4 s5-1))
        (set! (-> v1-4 width) (the float 440))
        )
      (let ((v1-5 s5-1))
        (set! (-> v1-5 height) (the float 80))
        )
      (let ((v1-6 s5-1))
        (set! (-> v1-6 scale) 0.8)
        )
      (let ((s4-0 print-game-text))
        (format (clear *temp-string*) (lookup-text! *common-text* arg0 #f))
        (s4-0 *temp-string* s5-1 #f 44 (bucket-id hud-draw-hud-alpha))
        )
      )
    )
  (none)
  )

(defstate active (task-manager-lightjak-training-shield)
  :virtual #t
  :enter (behavior ()
    (if *target*
        (send-event *target* 'get-pickup (pickup-type eco-pill-light) 100.0)
        )
    (set! (-> self gui-id)
          (add-process *gui-control* self (gui-channel message) (gui-action play) (-> self name) 81920.0 0)
          )
    (let ((t1-1 (the-as uint #x3810000040020)))
      (set-setting! 'features 'clear (shr t1-1 32) t1-1)
      )
    )
  :exit (behavior ()
    (send-event *target* 'get-pickup (pickup-type health) 100.0)
    )
  :code (behavior ()
    (while (not (and *target*
                     (focus-test? *target* light)
                     (and (focus-test? *target* light) (nonzero? (-> *target* lightjak)))
                     (nonzero? (-> *target* lightjak shield-start-time))
                     )
                )
      (if (not (and *target* (focus-test? *target* light)))
          (send-event *target* 'get-pickup (pickup-type eco-pill-light) 100.0)
          )
      (print-text self (text-id text-05f8))
      (suspend)
      )
    (suspend-for (seconds 6) (print-text self (text-id light-jak-shield-how-to)))
    (send-event *target* 'end-mode 'lightjak)
    (go-virtual complete)
    )
  )
