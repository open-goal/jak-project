;;-*-Lisp-*-
(in-package goal)

;; name: comb-field.gc
;; name in dgo: comb-field
;; dgos: RAILA, COMBA

;; DECOMP BEGINS

(deftype comb-field (process-drawable)
  ((root                collide-shape :override)
   (pass                pickup-type)
   (incoming-attack-id  uint32)
   (next-message-time   time-frame)
   (message             int32)
   (plane               plane          :inline)
   (color               vector         :inline)
   (target-pos          vector         :inline)
   (hum-sound-id        sound-id)
   (flash               float)
   (touch-count         int32)
   (touch-time          time-frame)
   (breach              symbol)
   )
  (:state-methods
    idle-close
    )
  (:methods
    (init-collision! (_type_ path-control float) none)
    (on-jak-touch (_type_) none)
    (play-hum (_type_) none)
    )
  )


(defskelgroup skel-comb-field security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

(defmethod on-jak-touch ((this comb-field))
  (when (time-elapsed? (-> this touch-time) (seconds 0.25))
    (set-time! (-> this touch-time))
    (sound-play "barrier-deflect")
    )
  0
  (none)
  )

(defmethod play-hum ((this comb-field))
  (let ((v1-0 *target*))
    (when v1-0
      (let ((f0-0 (vector-vector-distance-squared (-> this root trans) (-> v1-0 control trans)))
            (f1-0 655360.0)
            )
        (cond
          ((< f0-0 (* f1-0 f1-0))
           (if (zero? (-> this hum-sound-id))
               (set! (-> this hum-sound-id) (new-sound-id))
               )
           (sound-play "barrier-loop" :id (-> this hum-sound-id))
           )
          (else
            (sound-stop (-> this hum-sound-id))
            (set! (-> this hum-sound-id) (new 'static 'sound-id))
            0
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate idle-close (comb-field)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('on)
       (let ((v1-2 (-> self root root-prim)))
         (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
         (set! v0-0 (-> self root backup-collide-with))
         (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
         )
       v0-0
       )
      (('off)
       (let ((v1-4 (-> self root root-prim)))
         (set! (-> v1-4 prim-core collide-as) (collide-spec))
         (set! (-> v1-4 prim-core collide-with) (collide-spec))
         )
       0
       )
      (('attack)
       (let ((v1-5 (the-as attack-info (-> block param 1))))
         (when (!= (-> v1-5 id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> v1-5 id))
           (let ((s4-0 (as-type proc process-drawable)))
             (when s4-0
               (let ((gp-1 (process-spawn
                             manipy
                             :init manipy-init
                             (-> (the-as process-drawable s4-0) root trans)
                             (-> self entity)
                             (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer level) #f))
                             #f
                             0
                             :name "manipy"
                             :to self
                             :stack-size #x20000
                             )
                           )
                     )
                 (when gp-1
                   (send-event (ppointer->process gp-1) 'anim-mode 'play1)
                   (send-event (ppointer->process gp-1) 'speed 1.5)
                   (send-event (ppointer->process gp-1) 'art-joint-anim "generic-ripples-idle" 0)
                   (set-vector! (-> (the-as process-drawable (-> gp-1 0)) root scale) 1.0 1.0 1.0 1.0)
                   (quaternion-rotate-local-x! (-> (the-as process-drawable (-> gp-1 0)) root quat) (-> self root quat) -16384.0)
                   (vector+*!
                     (-> (the-as process-drawable (-> gp-1 0)) root trans)
                     (-> (the-as process-drawable (-> gp-1 0)) root trans)
                     *up-vector*
                     8192.0
                     )
                   (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> gp-1 0)) root trans) (the-as vector (-> self plane)))))
                     (vector+*!
                       (-> (the-as process-drawable (-> gp-1 0)) root trans)
                       (-> (the-as process-drawable (-> gp-1 0)) root trans)
                       (the-as vector (-> self plane))
                       (- f0-6)
                       )
                     (vector+*!
                       (-> (the-as process-drawable (-> gp-1 0)) root trans)
                       (-> (the-as process-drawable (-> gp-1 0)) root trans)
                       (the-as vector (-> self plane))
                       (if (< 0.0 f0-6)
                           -2048.0
                           2048.0
                           )
                       )
                     )
                   (send-event (ppointer->process gp-1) 'trans-hook (lambda () #f))
                   )
                 )
               )
             )
           (when (zero? (-> self touch-count))
             (+! (-> self touch-count) 1)
             (set! (-> self flash) 0.375)
             )
           (set! v0-0 (+ (-> self touch-count) 1))
           (set! (-> self touch-count) (the-as int v0-0))
           v0-0
           )
         )
       )
      (('touched)
       (when (zero? (-> self touch-count))
         (+! (-> self touch-count) 1)
         (set! (-> self flash) 0.375)
         )
       (+! (-> self touch-count) 1)
       (let ((v1-78 (as-type proc process-focusable)))
         (when v1-78
           (let ((gp-4 (as-type (-> (the-as process-drawable v1-78) root) collide-shape)))
             (when gp-4
               (if (logtest? (-> (the-as collide-shape gp-4) root-prim prim-core collide-as) (collide-spec jak))
                   (on-jak-touch self)
                   )
               (when (logtest? (-> (the-as collide-shape gp-4) root-prim prim-core collide-as) (collide-spec vehicle-sphere))
                 (when (not (-> self breach))
                   (sound-play "barrier-cross")
                   (set! v0-0 #t)
                   (set! (-> self breach) (the-as symbol v0-0))
                   v0-0
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :trans (behavior ()
    (play-hum self)
    )
  :code (behavior ()
    (until #f
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-1 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-1 (-> self color) f30-0)
        (set-comb-field-color! a0-1)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (seek! (-> self flash) 0.0 (seconds-per-frame))
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-comb-field-flash! gp-0)
        )
      (suspend)
      )
    #f
    )
  )

;; WARN: Return type mismatch vector vs none.
(defmethod init-collision! ((this comb-field) (arg0 path-control) (arg1 float))
  (let ((s3-0 (new 'static 'vector))
        (s4-0 (new 'static 'vector))
        )
    0.0
    (get-point-in-path! arg0 s3-0 0.0 'exact)
    (get-point-in-path! arg0 s4-0 1.0 'exact)
    (* 0.5 (vector-vector-distance s3-0 s4-0))
    (let ((s2-1 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
      (set! (-> s2-1 penetrated-by) (penetrate vehicle))
      (let ((v1-8 (new 'process 'collide-shape-prim-mesh s2-1 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle blocking-plane camera-blocker))
        (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-8 prim-core action) (collide-action solid))
        (set! (-> v1-8 transform-index) 3)
        (set! (-> s2-1 total-prims) (the-as uint 1))
        (set! (-> s2-1 root-prim) v1-8)
        )
      (set! (-> s2-1 nav-radius) (* 0.75 (-> s2-1 root-prim local-sphere w)))
      (let ((v1-11 (-> s2-1 root-prim)))
        (set! (-> s2-1 backup-collide-as) (-> v1-11 prim-core collide-as))
        (set! (-> s2-1 backup-collide-with) (-> v1-11 prim-core collide-with))
        )
      (set! (-> this root) s2-1)
      )
    (let ((s2-2 (new 'stack-no-clear 'matrix))
          (s1-0 (-> this root))
          )
      (vector+! (-> s1-0 trans) s3-0 s4-0)
      (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
      (vector-! (-> s2-2 rvec) s4-0 s3-0)
      (let ((f30-1 (vector-normalize-ret-len! (-> s2-2 rvec) 1.0)))
        (set! (-> s1-0 scale x) (/ f30-1 METER_LENGTH))
        (set! (-> s1-0 scale y) (/ arg1 METER_LENGTH))
        (set! (-> s1-0 scale z) 1.0)
        (vector-copy! (-> s2-2 uvec) (new 'static 'vector :y 1.0 :w 1.0))
        (vector-cross! (-> s2-2 fvec) (-> s2-2 rvec) (-> s2-2 uvec))
        (vector-normalize! (-> s2-2 fvec) 1.0)
        (matrix->quaternion (-> s1-0 quat) s2-2)
        (set! (-> this plane quad) (-> s2-2 fvec quad))
        (set! (-> this plane w) (- (vector-dot (-> s2-2 fvec) (-> this root trans))))
        (let ((v0-8 (-> this root root-prim local-sphere)))
          (set! (-> v0-8 x) 0.0)
          (set! (-> v0-8 y) (* 0.00024414062 (/ arg1 2)))
          (set! (-> v0-8 z) 0.0)
          (let ((f0-18 0.5)
                (f1-5 (* f30-1 f30-1))
                (f2-1 arg1)
                )
            (set! (-> v0-8 w) (* f0-18 (sqrtf (+ f1-5 (* f2-1 f2-1)))))
            )
          )
        )
      )
    )
  (none)
  )

(defmethod init-from-entity! ((this comb-field) (arg0 entity-actor))
  "Set up a newly created process from the entity that created it."
  (set! (-> this breach) #f)
  (set! (-> this hum-sound-id) (new 'static 'sound-id))
  (set! (-> this pass) (res-lump-value arg0 'pickup-type pickup-type :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f)))
    (set! (-> this path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (init-collision! this (-> this path) 204800.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-field" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root event-self) 'touched)
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this draw status) (draw-control-status disable-fog))
  (set-comb-field-texture-masks! (the-as vector (-> this draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> this color) 0.0 0.5 1.0 1.0)
  (set-comb-field-color! (-> this color))
  (set-vector! (-> this draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> this draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (go (method-of-object this idle-close))
  )
