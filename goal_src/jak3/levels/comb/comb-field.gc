;;-*-Lisp-*-
(in-package goal)

;; name: comb-field.gc
;; name in dgo: comb-field
;; dgos: RAILA, COMBA

;; DECOMP BEGINS

(deftype comb-field (process-drawable)
  ((root                collide-shape :override)
   (pass                pickup-type)
   (incoming-attack-id  uint32)
   (next-message-time   time-frame)
   (message             int32)
   (plane               plane          :inline)
   (color               vector         :inline)
   (target-pos          vector         :inline)
   (hum-sound-id        sound-id)
   (flash               float)
   (touch-count         int32)
   (touch-time          time-frame)
   (breach              symbol)
   )
  (:state-methods
    idle-close
    )
  (:methods
    (init-collision! (_type_ path-control float) none)
    (on-jak-touch (_type_) none)
    (play-hum (_type_) none)
    )
  )


(defskelgroup skel-comb-field security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

(defmethod on-jak-touch ((this comb-field))
  (when (time-elapsed? (-> this touch-time) (seconds 0.25))
    (set-time! (-> this touch-time))
    (sound-play "barrier-deflect")
    )
  0
  (none)
  )

(defmethod play-hum ((this comb-field))
  (let ((v1-0 *target*))
    (when v1-0
      (let ((f0-0 (vector-vector-distance-squared (-> this root trans) (-> v1-0 control trans)))
            (f1-0 655360.0)
            )
        (cond
          ((< f0-0 (* f1-0 f1-0))
           (if (zero? (-> this hum-sound-id))
               (set! (-> this hum-sound-id) (new-sound-id))
               )
           (sound-play "barrier-loop" :id (-> this hum-sound-id))
           )
          (else
            (sound-stop (-> this hum-sound-id))
            (set! (-> this hum-sound-id) (new 'static 'sound-id))
            0
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate idle-close (comb-field)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('on)
         (let ((v1-2 (-> self root root-prim)))
           (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
           (set! v0-0 (-> self root backup-collide-with))
           (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
           )
         v0-0
         )
        (('off)
         (let ((v1-4 (-> self root root-prim)))
           (set! (-> v1-4 prim-core collide-as) (collide-spec))
           (set! (-> v1-4 prim-core collide-with) (collide-spec))
           )
         0
         )
        (('attack)
         (let ((v1-5 (the-as attack-info (-> block param 1))))
           (when (!= (-> v1-5 id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> v1-5 id))
             (let* ((gp-0 proc)
                    (s4-0 (if (type? gp-0 process-drawable)
                              gp-0
                              )
                          )
                    )
               (when s4-0
                 (let ((gp-1 (process-spawn
                               manipy
                               :init manipy-init
                               (-> (the-as process-drawable s4-0) root trans)
                               (-> self entity)
                               (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer level) #f))
                               #f
                               0
                               :name "manipy"
                               :to self
                               :stack-size #x20000
                               )
                             )
                       )
                   (when gp-1
                     (send-event (ppointer->process gp-1) 'anim-mode 'play1)
                     (send-event (ppointer->process gp-1) 'speed 1.5)
                     (send-event (ppointer->process gp-1) 'art-joint-anim "generic-ripples-idle" 0)
                     (set-vector! (-> (the-as process-drawable (-> gp-1 0)) root scale) 1.0 1.0 1.0 1.0)
                     (quaternion-rotate-local-x! (-> (the-as process-drawable (-> gp-1 0)) root quat) (-> self root quat) -16384.0)
                     (let ((v1-43 (-> (the-as process-drawable (-> gp-1 0)) root trans)))
                       (let ((a0-22 (-> (the-as process-drawable (-> gp-1 0)) root trans)))
                         (let ((a1-17 *up-vector*))
                           (let ((a2-8 8192.0))
                             (.mov vf7 a2-8)
                             )
                           (.lvf vf5 (&-> a1-17 quad))
                           )
                         (.lvf vf4 (&-> a0-22 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> v1-43 quad) vf6)
                       )
                     (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> gp-1 0)) root trans) (the-as vector (-> self plane)))))
                       (let ((v1-50 (-> (the-as process-drawable (-> gp-1 0)) root trans)))
                         (let ((a0-26 (-> (the-as process-drawable (-> gp-1 0)) root trans)))
                           (let ((a1-18 (-> self plane)))
                             (let ((a2-9 (- f0-6)))
                               (.mov vf7 a2-9)
                               )
                             (.lvf vf5 (&-> a1-18 quad))
                             )
                           (.lvf vf4 (&-> a0-26 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-50 quad) vf6)
                         )
                       (let ((v1-53 (-> (the-as process-drawable (-> gp-1 0)) root trans)))
                         (let ((a0-29 (-> (the-as process-drawable (-> gp-1 0)) root trans)))
                           (let ((a1-19 (-> self plane)))
                             (let ((a2-11 (the-as float (if (< 0.0 f0-6)
                                                            -2048.0
                                                            2048.0
                                                            )
                                                  )
                                          )
                                   )
                               (.mov vf7 a2-11)
                               )
                             (.lvf vf5 (&-> a1-19 quad))
                             )
                           (.lvf vf4 (&-> a0-29 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-53 quad) vf6)
                         )
                       )
                     (send-event (ppointer->process gp-1) 'trans-hook (lambda () #f))
                     )
                   )
                 )
               )
             (when (zero? (-> self touch-count))
               (+! (-> self touch-count) 1)
               (set! (-> self flash) 0.375)
               )
             (set! v0-0 (+ (-> self touch-count) 1))
             (set! (-> self touch-count) (the-as int v0-0))
             v0-0
             )
           )
         )
        (('touched)
         (when (zero? (-> self touch-count))
           (+! (-> self touch-count) 1)
           (set! (-> self flash) 0.375)
           )
         (+! (-> self touch-count) 1)
         (let* ((gp-3 proc)
                (v1-75 (if (type? gp-3 process-focusable)
                           gp-3
                           )
                       )
                )
           (when v1-75
             (let* ((s5-1 (-> (the-as process-drawable v1-75) root))
                    (gp-4 (if (type? s5-1 collide-shape)
                              s5-1
                              )
                          )
                    )
               (when gp-4
                 (if (logtest? (-> (the-as collide-shape gp-4) root-prim prim-core collide-as) (collide-spec jak))
                     (on-jak-touch self)
                     )
                 (when (logtest? (-> (the-as collide-shape gp-4) root-prim prim-core collide-as) (collide-spec vehicle-sphere))
                   (when (not (-> self breach))
                     (sound-play "barrier-cross")
                     (set! v0-0 #t)
                     (set! (-> self breach) (the-as symbol v0-0))
                     v0-0
                     )
                   )
                 )
               )
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (play-hum self)
    )
  :code (behavior ()
    (until #f
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-1 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-1 (-> self color) f30-0)
        (set-comb-field-color! a0-1)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (seek! (-> self flash) 0.0 (seconds-per-frame))
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-comb-field-flash! gp-0)
        )
      (suspend)
      )
    #f
    )
  )

;; WARN: Return type mismatch vector vs none.
(defmethod init-collision! ((this comb-field) (arg0 path-control) (arg1 float))
  (let ((s3-0 (new 'static 'vector))
        (s4-0 (new 'static 'vector))
        )
    0.0
    (get-point-in-path! arg0 s3-0 0.0 'exact)
    (get-point-in-path! arg0 s4-0 1.0 'exact)
    (* 0.5 (vector-vector-distance s3-0 s4-0))
    (let ((s2-1 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
      (set! (-> s2-1 penetrated-by) (penetrate vehicle))
      (let ((v1-8 (new 'process 'collide-shape-prim-mesh s2-1 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle blocking-plane camera-blocker))
        (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-8 prim-core action) (collide-action solid))
        (set! (-> v1-8 transform-index) 3)
        (set! (-> s2-1 total-prims) (the-as uint 1))
        (set! (-> s2-1 root-prim) v1-8)
        )
      (set! (-> s2-1 nav-radius) (* 0.75 (-> s2-1 root-prim local-sphere w)))
      (let ((v1-11 (-> s2-1 root-prim)))
        (set! (-> s2-1 backup-collide-as) (-> v1-11 prim-core collide-as))
        (set! (-> s2-1 backup-collide-with) (-> v1-11 prim-core collide-with))
        )
      (set! (-> this root) s2-1)
      )
    (let ((s2-2 (new 'stack-no-clear 'matrix))
          (s1-0 (-> this root))
          )
      (vector+! (-> s1-0 trans) s3-0 s4-0)
      (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
      (vector-! (-> s2-2 rvec) s4-0 s3-0)
      (let ((f30-1 (vector-normalize-ret-len! (-> s2-2 rvec) 1.0)))
        (set! (-> s1-0 scale x) (/ f30-1 METER_LENGTH))
        (set! (-> s1-0 scale y) (/ arg1 METER_LENGTH))
        (set! (-> s1-0 scale z) 1.0)
        (set! (-> s2-2 uvec quad) (-> (new 'static 'vector :y 1.0 :w 1.0) quad))
        (vector-cross! (-> s2-2 fvec) (-> s2-2 rvec) (-> s2-2 uvec))
        (vector-normalize! (-> s2-2 fvec) 1.0)
        (matrix->quaternion (-> s1-0 quat) s2-2)
        (set! (-> this plane quad) (-> s2-2 fvec quad))
        (set! (-> this plane w) (- (vector-dot (-> s2-2 fvec) (-> this root trans))))
        (let ((v0-8 (-> this root root-prim local-sphere)))
          (set! (-> v0-8 x) 0.0)
          (set! (-> v0-8 y) (* 0.00024414062 (/ arg1 2)))
          (set! (-> v0-8 z) 0.0)
          (let ((f0-18 0.5)
                (f1-5 (* f30-1 f30-1))
                (f2-1 arg1)
                )
            (set! (-> v0-8 w) (* f0-18 (sqrtf (+ f1-5 (* f2-1 f2-1)))))
            )
          )
        )
      )
    )
  (none)
  )

(defmethod init-from-entity! ((this comb-field) (arg0 entity-actor))
  (set! (-> this breach) #f)
  (set! (-> this hum-sound-id) (new 'static 'sound-id))
  (set! (-> this pass) (res-lump-value arg0 'pickup-type pickup-type :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f)))
    (set! (-> this path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (init-collision! this (-> this path) 204800.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-comb-field" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root event-self) 'touched)
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this draw status) (draw-control-status disable-fog))
  (set-comb-field-texture-masks! (the-as vector (-> this draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> this color) 0.0 0.5 1.0 1.0)
  (set-comb-field-color! (-> this color))
  (set-vector! (-> this draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> this draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (go (method-of-object this idle-close))
  )
