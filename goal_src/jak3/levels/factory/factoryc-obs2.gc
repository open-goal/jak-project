;;-*-Lisp-*-
(in-package goal)

;; name: factoryc-obs2.gc
;; name in dgo: factoryc-obs2
;; dgos: FACC

;; DECOMP BEGINS

(deftype fac-break-floor (process-drawable)
  ((root          collide-shape :override)
   (notify-actor  entity-actor)
   )
  (:state-methods
    idle
    die
    )
  )


(defskelgroup skel-fac-break-floor fac-break-floor fac-break-floor-lod0-jg fac-break-floor-idle-ja
              ((fac-break-floor-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defskelgroup skel-fac-break-floor-explode fac-break-floor fac-break-floor-explode-lod0-jg fac-break-floor-explode-idle-ja
              ((fac-break-floor-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *fac-break-floor-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 21 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 22 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 23 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 24 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 25 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 26 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defstate idle (fac-break-floor)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (when (logtest? (-> (the-as attack-info (-> block param 1)) penetrate-using) (penetrate flop))
         (go-virtual die)
         #f
         )
       )
      )
    )
  :code sleep-code
  )

(defstate die (fac-break-floor)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (sound-play "break-floor")
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer self))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'trigger)
      (let ((t9-2 send-event-function)
            (v1-6 (-> self notify-actor))
            )
        (t9-2
          (if v1-6
              (-> v1-6 extra process)
              )
          a1-1
          )
        )
      )
    )
  :code (behavior ()
    ((lambda :behavior fac-break-floor
       ()
       (cond
         ((logtest? (-> *part-group-id-table* 750 flags) (sp-group-flag sp13))
          (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
          (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 750))
          )
         (else
           (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
           (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 750))
           )
         )
       (let ((gp-2 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
         (let* ((s5-0 *target*)
                (a0-14 (if (type? s5-0 process-focusable)
                           s5-0
                           )
                       )
                )
           (when a0-14
             (set! (-> gp-2 fountain-rand-transv-lo quad) (-> (get-trans a0-14 0) quad))
             (+! (-> gp-2 fountain-rand-transv-lo y) 16384.0)
             )
           )
         (set! (-> gp-2 fountain-rand-transv-hi x) 24576.0)
         (set! (-> gp-2 fountain-rand-transv-hi y) 81920.0)
         (set! (-> gp-2 fountain-rand-transv-hi z) 12288.0)
         (set! (-> gp-2 fountain-rand-transv-hi w) 32768.0)
         (process-spawn
           joint-exploder
           (art-group-get-by-name *level* "skel-fac-break-floor-explode" (the-as (pointer level) #f))
           6
           gp-2
           *fac-break-floor-exploder-params*
           :name "joint-exploder"
           :to self
           )
         )
       )
     )
    (suspend)
    (ja-channel-set! 0)
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this fac-break-floor) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this root penetrated-by) (penetrate flop))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-break-floor" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (let ((a0-15 (-> this skel root-channel 0)))
    (set! (-> a0-15 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (set! (-> a0-15 frame-num) 0.0)
    (joint-control-channel-group! a0-15 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object this idle))
  )

(deftype fac-break-fence (process-focusable)
  ((notify-actor  entity-actor)
   )
  (:state-methods
    idle
    die
    )
  )


(defstate idle (fac-break-fence)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('impact-impulse)
       (let ((gp-0 (the-as object (-> block param 0))))
         (format #t "roboguard::handle-events: got impact-impulse ~M~%" (-> (the-as rigid-body-impact gp-0) impulse))
         (when (< 16384.0 (-> (the-as rigid-body-impact gp-0) impulse))
           (logior! (-> self root penetrated-by) (penetrate vehicle))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.15))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 192 (seconds 0.1))
           (go-virtual die)
           #t
           )
         )
       )
      )
    )
  :code sleep-code
  )

(defstate die (fac-break-fence)
  :virtual #t
  :enter (behavior ()
    '()
    )
  :code (behavior ()
    (suspend)
    (ja-channel-set! 0)
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post ja-post
  )

(defmethod get-inv-mass ((this fac-break-fence))
  6.6666665
  )

(deftype fac-break-fence-a (fac-break-fence)
  ((pad  uint8  4)
   )
  )


(defskelgroup skel-fac-break-fence-a fac-break-fence-a fac-break-fence-a-lod0-jg fac-break-fence-a-idle-ja
              ((fac-break-fence-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 9 6 0 12)
              )

(defskelgroup skel-fac-break-fence-a-explode fac-break-fence-a fac-break-fence-a-explode-lod0-jg fac-break-fence-a-explode-idle-ja
              ((fac-break-fence-a-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 12 0 0 18)
              )

(define *fac-break-fence-a-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    :collide-sound (static-sound-name "fence-debris")
    :collide-sound-interval (seconds 0.4)
    )
  )

(defstate die (fac-break-fence-a)
  :virtual #t
  :enter (behavior ()
    (local-vars (v1-10 float))
    (rlet ((vf1 :class vf)
           (vf2 :class vf)
           )
      (let ((v1-1 (-> self root root-prim)))
        (set! (-> v1-1 prim-core collide-as) (collide-spec))
        (set! (-> v1-1 prim-core collide-with) (collide-spec))
        )
      0
      (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
        (let* ((s5-0 *target*)
               (s4-0 (if (type? s5-0 process-focusable)
                         s5-0
                         )
                     )
               )
          (when s4-0
            (let ((s5-1 (get-trans s4-0 0))
                  (s3-1 (vector-! (new 'stack-no-clear 'vector) (get-trans s4-0 0) (-> self root trans)))
                  (s4-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                  )
              (.lvf vf1 (&-> s4-1 quad))
              (.lvf vf2 (&-> s3-1 quad))
              (.mul.vf vf1 vf1 vf2)
              (.add.y.vf vf1 vf1 vf1 :mask #b1)
              (.add.z.vf vf1 vf1 vf1 :mask #b1)
              (.mov v1-10 vf1)
              (if (< (the int v1-10) 0)
                  (vector-negate-in-place! s4-1)
                  )
              (vector+float*! (-> gp-0 fountain-rand-transv-lo) s5-1 s4-1 49152.0)
              )
            )
          )
        (set! (-> gp-0 fountain-rand-transv-hi x) 49152.0)
        (set! (-> gp-0 fountain-rand-transv-hi y) 262144.0)
        (set! (-> gp-0 fountain-rand-transv-hi z) 0.0)
        (set! (-> gp-0 fountain-rand-transv-hi w) 24576.0)
        (process-spawn
          joint-exploder
          (art-group-get-by-name *level* "skel-fac-break-fence-a-explode" (the-as (pointer level) #f))
          6
          gp-0
          *fac-break-fence-a-exploder-params*
          :name "joint-exploder"
          :to self
          )
        )
      (let ((a1-9 (new 'static 'vector :x 49152.0 :y 24576.0 :w 1.0))
            (gp-1 (new 'stack-no-clear 'vector))
            )
        (vector-matrix*! gp-1 a1-9 (-> self node-list data 0 bone transform))
        (cond
          ((logtest? (-> *part-group-id-table* 751 flags) (sp-group-flag sp13))
           (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
           (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 751))
           )
          (else
            (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
            (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 751))
            )
          )
        )
      )
    )
  :code (behavior ()
    (sound-play "fac-hit-fence")
    (sound-play "fence-break")
    (suspend)
    (ja-channel-set! 0)
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this fac-break-fence-a) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 36864.0 24576.0 0.0 49152.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-break-fence-a" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (let ((a0-14 (-> this skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
    )
  (transform-post)
  (if (not (task-node-closed? (game-task-node factory-assault-broke-ultimate-fence)))
      (go (method-of-object this idle))
      )
  )

(deftype fac-break-fence-b (fac-break-fence)
  ((pad  uint8  4)
   )
  )


(defskelgroup skel-fac-break-fence-b fac-break-fence-b fac-break-fence-b-lod0-jg fac-break-fence-b-idle-ja
              ((fac-break-fence-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 10 6 0 12.5)
              )

(defskelgroup skel-fac-break-fence-b-explode fac-break-fence-b fac-break-fence-b-explode-lod0-jg fac-break-fence-b-explode-idle-ja
              ((fac-break-fence-b-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 12 0 0 18)
              )

(define *fac-break-fence-b-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    :collide-sound (static-sound-name "fence-debris")
    :collide-sound-interval (seconds 0.4)
    )
  )

(defstate die (fac-break-fence-b)
  :virtual #t
  :enter (behavior ()
    (local-vars (v1-10 float))
    (rlet ((vf1 :class vf)
           (vf2 :class vf)
           )
      (let ((v1-1 (-> self root root-prim)))
        (set! (-> v1-1 prim-core collide-as) (collide-spec))
        (set! (-> v1-1 prim-core collide-with) (collide-spec))
        )
      0
      (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
        (let* ((s5-0 *target*)
               (s4-0 (if (type? s5-0 process-focusable)
                         s5-0
                         )
                     )
               )
          (when s4-0
            (let ((s5-1 (get-trans s4-0 0))
                  (s3-1 (vector-! (new 'stack-no-clear 'vector) (get-trans s4-0 0) (-> self root trans)))
                  (s4-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                  )
              (.lvf vf1 (&-> s4-1 quad))
              (.lvf vf2 (&-> s3-1 quad))
              (.mul.vf vf1 vf1 vf2)
              (.add.y.vf vf1 vf1 vf1 :mask #b1)
              (.add.z.vf vf1 vf1 vf1 :mask #b1)
              (.mov v1-10 vf1)
              (if (< (the int v1-10) 0)
                  (vector-negate-in-place! s4-1)
                  )
              (vector+float*! (-> gp-0 fountain-rand-transv-lo) s5-1 s4-1 49152.0)
              )
            )
          )
        (set! (-> gp-0 fountain-rand-transv-hi x) 49152.0)
        (set! (-> gp-0 fountain-rand-transv-hi y) 262144.0)
        (set! (-> gp-0 fountain-rand-transv-hi z) 0.0)
        (set! (-> gp-0 fountain-rand-transv-hi w) 24576.0)
        (process-spawn
          joint-exploder
          (art-group-get-by-name *level* "skel-fac-break-fence-b-explode" (the-as (pointer level) #f))
          6
          gp-0
          *fac-break-fence-b-exploder-params*
          :name "joint-exploder"
          :to self
          )
        )
      (let ((a1-9 (new 'static 'vector :x 49152.0 :y 24576.0 :w 1.0))
            (gp-1 (new 'stack-no-clear 'vector))
            )
        (vector-matrix*! gp-1 a1-9 (-> self node-list data 0 bone transform))
        (cond
          ((logtest? (-> *part-group-id-table* 751 flags) (sp-group-flag sp13))
           (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
           (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 751))
           )
          (else
            (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
            (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 751))
            )
          )
        )
      )
    )
  :code (behavior ()
    (sound-play "fac-hit-fence")
    (sound-play "fence-break")
    (suspend)
    (ja-channel-set! 0)
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this fac-break-fence-b) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 40960.0 24576.0 0.0 51200.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-break-fence-b" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (let ((a0-14 (-> this skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
    )
  (transform-post)
  (if (not (task-node-closed? (game-task-node factory-assault-broke-ultimate-fence)))
      (go (method-of-object this idle))
      )
  )

(deftype fac-break-fence-c (fac-break-fence)
  ((pad  uint8  4)
   )
  )


(defskelgroup skel-fac-break-fence-c fac-break-fence-c fac-break-fence-c-lod0-jg fac-break-fence-c-idle-ja
              ((fac-break-fence-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 12 0 0 18)
              )

(defskelgroup skel-fac-break-fence-c-explode fac-break-fence-c fac-break-fence-c-explode-lod0-jg fac-break-fence-c-explode-idle-ja
              ((fac-break-fence-c-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 12 0 0 18)
              )

(define *fac-break-fence-c-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    :collide-sound (static-sound-name "fence-debris")
    :collide-sound-interval (seconds 0.4)
    )
  )

(defmethod init-from-entity! ((this fac-break-fence-c) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 49152.0 0.0 0.0 73728.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-break-fence-c" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (let ((a0-14 (-> this skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
    )
  (transform-post)
  (if (not (task-node-closed? (game-task-node factory-assault-broke-ultimate-fence)))
      (go (method-of-object this idle))
      )
  )

(defstate idle (fac-break-fence-c)
  :virtual #t
  :code sleep-code
  :post ja-post
  )

(defstate die (fac-break-fence-c)
  :virtual #t
  :enter (behavior ()
    (local-vars (v1-10 float))
    (rlet ((vf1 :class vf)
           (vf2 :class vf)
           )
      (let ((v1-1 (-> self root root-prim)))
        (set! (-> v1-1 prim-core collide-as) (collide-spec))
        (set! (-> v1-1 prim-core collide-with) (collide-spec))
        )
      0
      (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
        (let* ((s5-0 *target*)
               (s4-0 (if (type? s5-0 process-focusable)
                         s5-0
                         )
                     )
               )
          (when s4-0
            (let ((s5-1 (get-trans s4-0 0))
                  (s3-1 (vector-! (new 'stack-no-clear 'vector) (get-trans s4-0 0) (-> self root trans)))
                  (s4-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                  )
              (.lvf vf1 (&-> s4-1 quad))
              (.lvf vf2 (&-> s3-1 quad))
              (.mul.vf vf1 vf1 vf2)
              (.add.y.vf vf1 vf1 vf1 :mask #b1)
              (.add.z.vf vf1 vf1 vf1 :mask #b1)
              (.mov v1-10 vf1)
              (if (< (the int v1-10) 0)
                  (vector-negate-in-place! s4-1)
                  )
              (vector+float*! (-> gp-0 fountain-rand-transv-lo) s5-1 s4-1 49152.0)
              )
            )
          )
        (set! (-> gp-0 fountain-rand-transv-hi x) 49152.0)
        (set! (-> gp-0 fountain-rand-transv-hi y) 262144.0)
        (set! (-> gp-0 fountain-rand-transv-hi z) 0.0)
        (set! (-> gp-0 fountain-rand-transv-hi w) 24576.0)
        (process-spawn
          joint-exploder
          (art-group-get-by-name *level* "skel-fac-break-fence-c-explode" (the-as (pointer level) #f))
          6
          gp-0
          *fac-break-fence-c-exploder-params*
          :name "joint-exploder"
          :to self
          )
        )
      (let ((a1-9 (new 'static 'vector :x 49152.0 :y 24576.0 :w 1.0))
            (gp-1 (new 'stack-no-clear 'vector))
            )
        (vector-matrix*! gp-1 a1-9 (-> self node-list data 0 bone transform))
        (cond
          ((logtest? (-> *part-group-id-table* 751 flags) (sp-group-flag sp13))
           (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
           (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 751))
           )
          (else
            (set! (-> *launch-matrix* trans quad) (-> gp-1 quad))
            (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 751))
            )
          )
        )
      )
    )
  :code (behavior ()
    (sound-play "fac-hit-fence")
    (sound-play "fence-break")
    (suspend)
    (ja-channel-set! 0)
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post ja-post
  )

(deftype fac-switch (process-drawable)
  ((actor-group        (pointer actor-group))
   (actor-group-count  int32)
   (lever-jmod         joint-mod-rotate-local    :inline)
   (part-red           sparticle-launch-control  :overlay-at part)
   (part-green         sparticle-launch-control)
   (minimap            connection-minimap)
   )
  (:state-methods
    idle
    (done symbol)
    )
  (:methods
    (is-done? (_type_) symbol)
    )
  )


(defskelgroup skel-fac-switch fac-switch fac-switch-lod0-jg fac-switch-idle-ja
              ((fac-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defmethod is-done? ((this fac-switch))
  (or (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
      (let ((a0-2 (res-lump-struct (-> this entity) 'task-name string)))
        (if a0-2
            (task-closed? a0-2)
            #f
            )
        )
      )
  )

(defmethod relocate ((this fac-switch) (offset int))
  (when (nonzero? (-> this part-green))
    (if (nonzero? (-> this part-green))
        (&+! (-> this part-green) offset)
        )
    )
  (call-parent-method this offset)
  )

(defstate idle (fac-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((gp-0 (the-as object (-> block param 1))))
         (when (and (= (-> (find-offending-process-focusable proc (the-as attack-info gp-0)) type) target)
                    (logtest? (-> (the-as attack-info gp-0) penetrate-using) (penetrate flop punch spin roll uppercut bonk))
                    )
           (when (and *target* (focus-test? *target* indax))
             (let ((gp-1 (res-lump-struct (-> self entity) 'on-activate structure)))
               (if gp-1
                   (script-eval (the-as pair gp-1))
                   )
               )
             (sound-play "floor-switch")
             (go-virtual done #f)
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (setup-masks (-> self draw) 4 0)
    (setup-masks (-> self draw) 0 2)
    (quaternion-identity! (-> self lever-jmod rotation))
    )
  :exit (behavior ()
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    )
  :trans (behavior ()
    (cond
      ((task-open? (res-lump-struct (-> self entity) 'task-name string))
       (if (not (-> self minimap))
           (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 129) (the-as int #f) (the-as vector #t) 0))
           )
       )
      (else
        (when (-> self minimap)
          (logior! (-> self minimap flags) (minimap-flag fade-out))
          (set! (-> self minimap) #f)
          )
        )
      )
    (spawn-from-cspace (-> self part) (joint-node fac-switch-lod0-jg glow))
    )
  :code sleep-code
  :post ja-post
  )

(defstate done (fac-switch)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (setup-masks (-> self draw) 0 4)
    (setup-masks (-> self draw) 2 0)
    )
  :trans (behavior ()
    (spawn-from-cspace (-> self part-green) (joint-node fac-switch-lod0-jg glow))
    )
  :code (behavior ((arg0 symbol))
    (when (> (-> self actor-group-count) 0)
      (dotimes (s5-0 (length (-> self actor-group 0)))
        (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-0 from) (process->ppointer self))
          (set! (-> a1-0 num-params) 0)
          (set! (-> a1-0 message) 'trigger)
          (let ((t9-0 send-event-function)
                (v1-7 (-> self actor-group 0 data s5-0 actor))
                )
            (t9-0
              (if v1-7
                  (-> v1-7 extra process)
                  )
              a1-0
              )
            )
          )
        )
      )
    (set-time! (-> self state-time))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (cond
      ((not arg0)
       (suspend-for
         (seconds 0.3)
         (let* ((f28-0 (lerp-clamp 0.0 3640.889 (* 0.011111111 (the float (- (current-time) (-> self state-time))))))
                (f30-0 (cos f28-0))
                (f0-2 (sin f28-0))
                )
           (quaternion-set! (-> self lever-jmod rotation) f0-2 0.0 0.0 f30-0)
           )
         )
       (let ((gp-2 (res-lump-struct (-> self entity) 'cutaway-camera structure)))
         (when (and gp-2 *target*)
           (while (not (process-grab? *target* #f))
             (suspend)
             )
           (set-setting! 'entity-name gp-2 0.0 0)
           (suspend-for (seconds 3) '())
           (remove-setting! 'entity-name)
           (while (not (process-release? *target*))
             (suspend)
             )
           )
         )
       )
      (else
        (quaternion-set! (-> self lever-jmod rotation) 0.34202015 0.0 0.0 0.9396926)
        )
      )
    (sleep-code)
    )
  :post pusher-post
  )

(defmethod init-from-entity! ((this fac-switch) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 4)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 5)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-20 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-20 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-20 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this minimap) #f)
  (set! (-> this entity) arg0)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-switch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-26 (res-lump-data arg0 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-26 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-26))
       )
      (else
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (init (-> this lever-jmod) this (the-as uint 4) (joint-mod-base-flags attached))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 753) this))
  (set! (-> this part-green) (create-launch-control (-> *part-group-id-table* 754) this))
  (if (is-done? this)
      (go (method-of-object this done) #t)
      (go (method-of-object this idle))
      )
  )

(deftype fac-move-plat-a (plat)
  ((dead-set-time  float)
   )
  (:state-methods
    locking-down
    )
  (:methods
    (fac-move-plat-a-method-39 (_type_) none)
    )
  )


(defskelgroup skel-fac-move-pla fac-move-plat-a fac-move-plat-a-lod0-jg fac-move-plat-a-idle-ja
              ((fac-move-plat-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(defmethod get-art-group ((this fac-move-plat-a))
  (art-group-get-by-name *level* "skel-fac-move-pla" (the-as (pointer level) #f))
  )

(defmethod init-collision! ((this fac-move-plat-a))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 36864.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pause-adjust-distance) 573440.0)
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod base-plat-method-33 ((this fac-move-plat-a))
  (set-vector! (-> this root scale) 1.4 1.4 1.6 1.0)
  (none)
  )

(defmethod deactivate ((this fac-move-plat-a))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  ((method-of-type plat deactivate) this)
  (none)
  )

(defmethod go-initial-state ((this fac-move-plat-a))
  (set! (-> this dead-set-time) (res-lump-float (-> this entity) 'fac-plat-dead-set :default 0.5))
  (cond
    ((or (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
         (task-closed? (res-lump-struct (-> this entity) 'task-name string))
         )
     (fac-move-plat-a-method-39 this)
     (go (method-of-object this plat-idle))
     )
    (else
      (go (method-of-object this plat-path-active))
      )
    )
  )

;; WARN: Return type mismatch vector vs none.
(defmethod fac-move-plat-a-method-39 ((this fac-move-plat-a))
  (set! (-> this path-pos) (-> this dead-set-time))
  (get-point-at-percent-along-path! (-> this path) (-> this basetrans) (-> this path-pos) 'interp)
  (none)
  )

(defstate plat-idle (fac-move-plat-a)
  :virtual #t
  :event plat-event
  :trans (behavior ()
    (call-parent-state-handler trans)
    )
  :code (behavior ()
    (call-parent-state-handler code)
    )
  )

(defstate plat-path-active (fac-move-plat-a)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual locking-down)
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (if (< (vector-vector-distance (-> self root trans) (ear-trans 0)) 163840.0)
        (sound-play "move-plat-loop" :id (-> self sound-id) :position (-> self root trans))
        )
    (let ((v1-11 (shr (-> self sync period) 1)))
      (if (< (mod (current-time) (the-as time-frame v1-11))
             (mod (-> self clock old-frame-counter) (the-as time-frame v1-11))
             )
          (sound-play "move-plat-hit")
          )
      )
    (plat-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post plat-post
  )

(defstate locking-down (fac-move-plat-a)
  :virtual #t
  :event plat-event
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    )
  :trans plat-trans
  :code (behavior ()
    (let ((f30-0 (-> self dead-set-time)))
      (suspend-for
        (seconds 3)
        (set! (-> self path-pos)
              (lerp-clamp (get-norm! (-> self sync) 0) f30-0 (* 0.0011111111 (the float (- (current-time) time))))
              )
        (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
        )
      (suspend)
      (set! (-> self path-pos) f30-0)
      )
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (sleep-code)
    )
  :post plat-post
  )

(deftype fac-move-plat-b (plat)
  ()
  )


(defskelgroup skel-fac-move-pla fac-move-plat-b fac-move-plat-b-lod0-jg fac-move-plat-b-idle-ja
              ((fac-move-plat-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 9)
              )

(defmethod get-art-group ((this fac-move-plat-b))
  (art-group-get-by-name *level* "skel-fac-move-pla" (the-as (pointer level) #f))
  )

;; WARN: Return type mismatch float vs none.
(defmethod init-collision! ((this fac-move-plat-b))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 22528.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (set! (-> this root pause-adjust-distance) 327680.0)
  (none)
  )

(defmethod deactivate ((this fac-move-plat-b))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  ((method-of-type plat deactivate) this)
  (none)
  )

(defmethod go-initial-state ((this fac-move-plat-b))
  (let ((f0-0 (res-lump-float (-> this entity) 'fac-plat-dead-start :default -1.0)))
    (if (>= f0-0 0.0)
        (get-point-at-percent-along-path! (-> this path) (-> this basetrans) f0-0 'interp)
        )
    )
  (if (and (nonzero? (res-lump-value (-> this entity) 'fac-plat-reset-stopped uint128 :time -1000000000.0))
           (not (task-closed? (res-lump-struct (-> this entity) 'task-name string)))
           )
      (go (method-of-object this plat-idle))
      (go (method-of-object this plat-path-active))
      )
  )

(defstate plat-idle (fac-move-plat-b)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual plat-path-active)
       )
      (('bonk)
       (start-bounce! self)
       )
      )
    )
  :trans (behavior ()
    (call-parent-state-handler trans)
    )
  :code (behavior ()
    (call-parent-state-handler code)
    )
  )

(defstate plat-path-active (fac-move-plat-b)
  :virtual #t
  :event plat-event
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (if (< (vector-vector-distance (-> self root trans) (ear-trans 0)) 163840.0)
        (sound-play "move-plat-loop" :id (-> self sound-id) :position (-> self root trans))
        )
    (let ((v1-11 (shr (-> self sync period) 1)))
      (if (< (mod (current-time) (the-as time-frame v1-11))
             (mod (-> self clock old-frame-counter) (the-as time-frame v1-11))
             )
          (sound-play "move-plat-hit")
          )
      )
    (plat-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post plat-post
  )

(deftype fac-rotfan (process-drawable)
  ((root                collide-shape :override)
   (motor-noise         sound-id)
   (effect-opacity      float)
   (no-collision-timer  time-frame)
   (attack-id           int32)
   )
  (:state-methods
    idle
    spindown
    out
    )
  (:methods
    (is-out? (_type_) symbol)
    )
  )


(defskelgroup skel-fac-rotfan fac-rotfan fac-rotfan-lod0-jg fac-rotfan-idle-ja
              ((fac-rotfan-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 20)
              )

(defmethod is-out? ((this fac-rotfan))
  (or (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
      (task-closed? (res-lump-struct (-> this entity) 'task-name string))
      )
  )

(defbehavior fac-rotfan-part-trans fac-rotfan ()
  (when (not (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
    (set! (-> *part-id-table* 2832 init-specs 8 initial-valuef) (-> self effect-opacity))
    (if (< (-> self effect-opacity) 30.0)
        (set! (-> *part-id-table* 2832 init-specs 8 random-rangef) 0.0)
        )
    (spawn-from-cspace (-> self part) (joint-node fac-rotfan-lod0-jg electrified))
    )
  (none)
  )

(defstate idle (fac-rotfan)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual spindown)
       )
      (('touch)
       (let* ((s4-0 proc)
              (gp-0 (if (type? s4-0 process-focusable)
                        s4-0
                        )
                    )
              )
         (when (and gp-0 (= (-> gp-0 type) target) ((method-of-type touching-shapes-entry prims-touching?)
                                                    (the-as touching-shapes-entry (-> block param 0))
                                                    (-> self root)
                                                    (the-as uint 4)
                                                    )
                    )
           (when (time-elapsed? (-> self no-collision-timer) (-> *TARGET-bank* hit-invulnerable-timeout))
             (let ((s4-1
                     (vector-negate! (new 'stack-no-clear 'vector) (the-as vector (-> self node-list data 3 bone transform)))
                     )
                   )
               (set! (-> s4-1 y) 0.0)
               (vector-xz-normalize! s4-1 1.0)
               (when (send-event
                       gp-0
                       'attack
                       (-> block param 0)
                       (static-attack-info
                         :mask (vehicle-impulse-factor)
                         ((id (the-as uint (-> self attack-id)))
                          (damage 0.0)
                          (vehicle-damage-factor 1.0)
                          (vehicle-impulse-factor 1.0)
                          (mode 'shock)
                          (vector s4-1)
                          (shove-back (meters 6))
                          (shove-up (meters 1))
                          (control (if (focus-test? (the-as process-focusable gp-0) board)
                                       1.0
                                       0.0
                                       )
                                   )
                          )
                         )
                       )
                 (let ((v0-0 (the-as object (current-time))))
                   (set! (-> self no-collision-timer) (the-as time-frame v0-0))
                   v0-0
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (ja-no-eval :group! fac-rotfan-spin-ja :num! (loop! 0.5) :frame-num 0.0)
    (set! (-> self effect-opacity) 40.0)
    (set! (-> self no-collision-timer) 0)
    0
    )
  :trans fac-rotfan-part-trans
  :code (behavior ()
    (let ((f28-0 15.0))
      (new-sound-id)
      (until #f
        (let ((f30-0 (* 0.05 (the float (mod (current-time) 300)))))
          (let ((f26-0 (- f30-0 (* (the float (the int (/ f30-0 5.0))) 5.0))))
            (if (< f26-0 f28-0)
                (sound-play-by-name
                  (static-sound-name "fan-blades-fast")
                  (new-sound-id)
                  (the int (* 1024.0 (rand-vu-float-range 0.75 1.0)))
                  -1219
                  0
                  (sound-group)
                  #t
                  )
                )
            (set! f28-0 f26-0)
            )
          (ja :group! fac-rotfan-spin-ja :num! (identity f30-0))
          )
        (suspend)
        )
      )
    #f
    )
  :post (behavior ()
    (sound-play "fan-motor-loop" :id (-> self motor-noise))
    (ja-post)
    )
  )

(defstate spindown (fac-rotfan)
  :virtual #t
  :trans fac-rotfan-part-trans
  :code (behavior ()
    (set-time! (-> self state-time))
    (let* ((f30-0 15.0)
           (f28-0 f30-0)
           (gp-0 900)
           (f26-0 (* 0.0033333334 (the float (mod (current-time) 300)) f30-0))
           )
      (- f26-0 (* (the float (the int (/ f26-0 5.0))) 5.0))
      (let ((s5-0 #f)
            (s4-0 (the-as sound-id #f))
            )
        (while (not (time-elapsed? (-> self state-time) gp-0))
          (let ((f24-0 (/ (the float (- (current-time) (-> self state-time))) (the float gp-0))))
            (set! (-> self effect-opacity) (lerp 40.0 0.0 f24-0))
            (let ((f0-13 (+ f26-0 (* (lerp f30-0 0.0 f24-0) (seconds-per-frame)))))
              (set! f26-0 (- f0-13 (* (the float (the int (/ f0-13 15.0))) 15.0)))
              )
            )
          (set! f28-0
                (cond
                  ((not (time-elapsed? (-> self state-time) (seconds 2.035)))
                   (let ((f24-1 (- f26-0 (* (the float (the int (/ f26-0 5.0))) 5.0))))
                     (if (< f24-1 f28-0)
                         (set! s4-0
                               (sound-play-by-name
                                 (static-sound-name "fan-blades-slow")
                                 (new-sound-id)
                                 (the int (* 1024.0 (rand-vu-float-range 0.75 1.0)))
                                 -1524
                                 0
                                 (sound-group)
                                 #t
                                 )
                               )
                         )
                     f24-1
                     )
                   )
                  (else
                    (when (not s5-0)
                      (sound-stop s4-0)
                      (sound-play "fan-blades-stop")
                      (set! s5-0 #t)
                      )
                    f28-0
                    )
                  )
                )
          (ja :group! fac-rotfan-spin-ja :num! (identity f26-0))
          (when *sound-player-enable*
            (let ((s3-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
              (set! (-> s3-3 command) (sound-command set-param))
              (set! (-> s3-3 id) (-> self motor-noise))
              (set! (-> s3-3 params pitch-mod)
                    (the int
                         (* 1524.0
                            (lerp-clamp
                              -1.4
                              -0.1
                              (* 0.06666667 (lerp f30-0 0.0 (/ (the float (- (current-time) (-> self state-time))) (the float gp-0))))
                              )
                            )
                         )
                    )
              (set! (-> s3-3 params mask) (the-as uint 2))
              (-> s3-3 id)
              )
            )
          (suspend)
          )
        )
      )
    (sound-stop (-> self motor-noise))
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core collide-with)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core collide-as)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core action)
          (collide-action)
          )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (sleep-code)
    )
  :post transform-post
  )

(defstate out (fac-rotfan)
  :virtual #t
  :enter (behavior ()
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core collide-with)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core collide-as)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core action)
          (collide-action)
          )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    )
  :code (behavior ()
    (ja :group! fac-rotfan-spin-ja :num! (identity 2.0))
    (sleep-code)
    )
  :post ja-post
  )

(defmethod deactivate ((this fac-rotfan))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this motor-noise))
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defmethod init-from-entity! ((this fac-rotfan) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 4)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 4))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 2))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 3)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this motor-noise) (new-sound-id))
  (set! (-> this root pause-adjust-distance) 327680.0)
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 755) this))
  (let* ((v1-29 *game-info*)
         (a0-27 (+ (-> v1-29 attack-id) 1))
         )
    (set! (-> v1-29 attack-id) a0-27)
    (set! (-> this attack-id) (the-as int a0-27))
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-rotfan" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (if (is-out? this)
      (go (method-of-object this out))
      (go (method-of-object this idle))
      )
  )

(deftype fac-robot-ass-manager (process)
  ()
  (:state-methods
    idle
    )
  )


(defstate idle (fac-robot-ass-manager)
  :virtual #t
  :code sleep-code
  )

(defmethod init-from-entity! ((this fac-robot-ass-manager) (arg0 entity-actor))
  (process-entity-set! this arg0)
  (go (method-of-object this idle))
  )

(deftype factory-conveyor (conveyor)
  ()
  )


(defmethod init-fields! ((this factory-conveyor))
  (local-vars (sv-16 res-tag))
  (set! (-> this speed) 22528.0)
  (set! (-> this pull-y-threshold) 10240.0)
  (set! (-> this speed-mult-array) (the-as (pointer float) #f))
  (set! (-> this speed-mult-array-len) 0)
  (let ((a0-1 (-> this entity)))
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-3 (res-lump-data a0-1 'scale-factor pointer :tag-ptr (& sv-16))))
      (when v1-3
        (set! (-> this speed-mult-array) (the-as (pointer float) v1-3))
        (set! (-> this speed-mult-array-len) (the-as int (-> sv-16 elt-count)))
        )
      )
    )
  (set! (-> this belt-radius) (* 4096.0 (the-as float ((method-of-type res-lump get-property-struct)
                                                       (-> this entity)
                                                       'extra-radius
                                                       'interp
                                                       -1000000000.0
                                                       (the-as structure 6.0)
                                                       (the-as (pointer res-tag) #f)
                                                       *res-static-buf*
                                                       )
                                                )
                                 )
        )
  (set! (-> this root pause-adjust-distance) 327680.0)
  0
  (none)
  )

(deftype fac-punch-wall (process-drawable)
  ((root            collide-shape :override)
   (notify-actor    entity-actor)
   (spool-sound-id  sound-id)
   )
  (:state-methods
    idle
    die
    )
  (:states
    perish-immediately
    )
  )


(defskelgroup skel-fac-punch-wall fac-punch-wall fac-punch-wall-lod0-jg fac-punch-wall-idle-ja
              ((fac-punch-wall-lod0-mg (meters 20)) (fac-punch-wall-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 25)
              )

(defstate idle (fac-punch-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let* ((a1-2 (-> block param 1))
              (v1-1 (find-offending-process-focusable proc (the-as attack-info a1-2)))
              )
         (when (and v1-1
                    (= (-> v1-1 type) target)
                    (not (focus-test? v1-1 indax))
                    (< (if *target*
                           (vector-vector-distance (-> self root trans) (-> *target* control trans))
                           4096000.0
                           )
                       163840.0
                       )
                    )
           (go-virtual die)
           #f
           )
         )
       )
      )
    )
  :code sleep-code
  :post ja-post
  )

(defstate die (fac-punch-wall)
  :virtual #t
  :enter (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'trigger)
      (let ((t9-0 send-event-function)
            (v1-2 (-> self notify-actor))
            )
        (t9-0
          (if v1-2
              (-> v1-2 extra process)
              )
          a1-0
          )
        )
      )
    )
  :code (behavior ()
    (sound-play "fac-glass-break")
    (let ((v1-4 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1)))
      (set! (-> v1-4 prim-core collide-as) (collide-spec))
      (set! (-> v1-4 prim-core collide-with) (collide-spec))
      )
    0
    (set-time! (-> self state-time))
    (ja-no-eval :group! fac-punch-wall-drop-ja :num! (seek! 10.0 2.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 10.0 2.0))
      )
    (set! (-> self spool-sound-id)
          (add-process *gui-control* self (gui-channel background) (gui-action play) "glassmsh" -99.0 0)
          )
    (ja-no-eval :group! fac-punch-wall-drop-ja :num! (seek! max 2.0) :frame-num 10.0)
    (until (ja-done? 0)
      (when *sound-player-enable*
        (let ((v1-44 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-44 command) (sound-command set-param))
          (set! (-> v1-44 id) (-> self spool-sound-id))
          (set! (-> v1-44 params volume) 696)
          (set! (-> v1-44 params mask) (the-as uint 1))
          (-> v1-44 id)
          )
        )
      (suspend)
      (ja :num! (seek! max 2.0))
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (setup-masks (-> self draw) 1 2)
    (sleep-code)
    )
  :post ja-post
  )

(defstate perish-immediately (fac-punch-wall)
  :enter (behavior ()
    (ja :group! fac-punch-wall-drop-ja :num! max)
    (setup-masks (-> self draw) 1 2)
    (let ((v1-16 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1)))
      (set! (-> v1-16 prim-core collide-as) (collide-spec))
      (set! (-> v1-16 prim-core collide-with) (collide-spec))
      )
    0
    )
  :code sleep-code
  )

(defmethod init-from-entity! ((this fac-punch-wall) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 204800.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 2))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 102400.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec backgnd))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 102400.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-punch-wall" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this spool-sound-id) (the-as sound-id #f))
  (let ((a0-21 (-> this skel root-channel 0)))
    (set! (-> a0-21 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (set! (-> a0-21 frame-num) 0.0)
    (joint-control-channel-group! a0-21 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
    )
  (transform-post)
  (logclear! (-> this mask) (process-mask actor-pause))
  (if (not (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this idle))
      (go perish-immediately)
      )
  )
