;;-*-Lisp-*-
(in-package goal)

;; name: factory-manager.gc
;; name in dgo: factory-manager
;; dgos: LFACTORY

(define-extern *factory-fighter-trail* light-trail-composition)
(define-extern factory-fighter-spawn (function process factory-fighter))

;; DECOMP BEGINS

(deftype task-manager-factory-sky-battle (task-manager)
  ((factory-sky-battle-entity  entity-actor)
   (check-timer                time-frame)
   (ended-timer                time-frame)
   (mission-complete-time      time-frame)
   (actor-group                (pointer actor-group))
   (actor-group-count          int32)
   (cur-group                  int8)
   (hud-delay                  handle)
   (sound-id                   sound-id)
   (hud-damage                 handle)
   (hint-given                 symbol)
   )
  (:methods
    (task-manager-factory-sky-battle-method-32 (_type_) none)
    )
  )


(define *fac-task-manager* (the-as task-manager-factory-sky-battle #f))

(define *fac-fighter-fired* (the-as time-frame 0))

(define *fac-wave* 0)

(define *fac-shotsleft* 0)

(deftype light-trail-tracker-vehicle (light-trail-tracker)
  ()
  )


(defmethod should-track? ((this light-trail-tracker-vehicle) (arg0 process-focusable))
  #f
  )

(if (or (zero? *factory-fighter-trail*) (!= loading-level global))
    (set! *factory-fighter-trail* (new 'loading-level 'light-trail-composition))
    )

(set! (-> *factory-fighter-trail* color-mode) (the-as uint 0))

(set! (-> *factory-fighter-trail* color-repeat-dist) 40960.0)

(set! (-> *factory-fighter-trail* alpha-1-mode) (the-as uint 0))

(set! (-> *factory-fighter-trail* alpha-2-mode) (the-as uint 1))

(set! (-> *factory-fighter-trail* base-alpha) 1.0)

(set! (-> *factory-fighter-trail* alpha-repeat-dist) 6144.0)

(set! (-> *factory-fighter-trail* width-mode) (the-as uint 2))

(set! (-> *factory-fighter-trail* base-width) 2048.0)

(set! (-> *factory-fighter-trail* width-repeat-dist) 20480.0)

(set! (-> *factory-fighter-trail* uv-mode) (the-as uint 0))

(set! (-> *factory-fighter-trail* uv-repeat-dist) 16384000.0)

(set! (-> *factory-fighter-trail* lie-mode) (lie-mode appearance0))

(set! (-> *factory-fighter-trail* max-age) (seconds 0.5))

(if #f
    (set! (-> *factory-fighter-trail* tex-id) (lookup-texture-id-by-name (the-as string #f) (the-as string #f)))
    (set! (-> *factory-fighter-trail* tex-id) (new 'static 'texture-id :index #x3 :page #x1))
    )

(set! (-> *factory-fighter-trail* width-curve) (the-as curve2d-piecewise *curve-linear-up*))

(set! (-> *factory-fighter-trail* color-curve) (the-as curve-color-piecewise *trail-color-curve-red*))

(set! (-> *factory-fighter-trail* alpha-curve-1) (the-as curve2d-piecewise *curve-linear-down*))

(set! (-> *factory-fighter-trail* alpha-curve-2) *curve-linear-up-red*)

(set! (-> *factory-fighter-trail* zbuffer?) #f)

(set! (-> *factory-fighter-trail* lie-vector quad) (-> *up-vector* quad))

(set! (-> *factory-fighter-trail* use-tape-mode?) #f)

(set! (-> *factory-fighter-trail* blend-mode) (the-as uint 1))

(set! (-> *factory-fighter-trail* frame-stagger) (the-as uint 5))

(defun fac-count-curves ((arg0 entity-actor))
  (let ((s4-0 (new 'stack 'curve))
        (v1-1 (entity-actor-lookup arg0 'path-actor 0))
        (gp-0 0)
        )
    (if v1-1
        (set! arg0 v1-1)
        )
    (dotimes (s3-0 666)
      (if (get-curve-data! arg0 s4-0 'path 'path-k (the float s3-0))
          (+! gp-0 1)
          )
      )
    gp-0
    )
  )

(define *fac-tmp-str* (new 'global 'string 128 (the-as string #f)))

;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 448 mismatch: defined as size 4, got size 16
(defmethod init-paths-for-list! ((this factory-manager) (arg0 factory-pathlist) (arg1 string))
  (local-vars
    (sv-144 entity)
    (sv-160 int)
    (sv-176 int)
    (sv-192 int)
    (sv-208 (function _varargs_ object))
    (sv-224 int)
    (sv-240 string)
    (sv-256 int)
    (sv-272 (function _varargs_ object))
    (sv-288 int)
    (sv-304 string)
    (sv-320 int)
    (sv-336 vector)
    (sv-352 vector)
    (sv-368 vector)
    (sv-384 int)
    (sv-400 (function _varargs_ object))
    (sv-416 int)
    (sv-432 string)
    (sv-448 float)
    )
  (set! (-> arg0 npath) 0)
  (set! (-> arg0 nloop) 0)
  (let ((s3-0 (new 'stack 'curve)))
    0
    (let ((s2-0 1))
      0
      0
      (let ((s1-0 #f))
        (while (not s1-0)
          (let ((s0-0 0))
            (clear *fac-tmp-str*)
            (format *fac-tmp-str* "~S-~d" arg1 s2-0)
            (if #f
                (format 0 "String: ~A~%" *fac-tmp-str*)
                )
            (set! sv-144 (entity-by-name *fac-tmp-str*))
            (+! s2-0 1)
            (if (not sv-144)
                (set! s1-0 #t)
                )
            (set! sv-160 0)
            (when sv-144
              (set! (-> this entity) (the-as entity-actor sv-144))
              (set! sv-160 (fac-count-curves (the-as entity-actor sv-144)))
              (set! sv-176 0)
              (while (< sv-176 sv-160)
                (set! sv-192 (+ sv-176 (-> arg0 npath)))
                (while (not (get-curve-data! sv-144 s3-0 'path 'path-k (the float s0-0)))
                  (+! s0-0 1)
                  )
                (set! (-> arg0 path sv-192) (new 'process 'curve-control this 'path (the float s0-0)))
                (+! s0-0 1)
                (logior! (-> arg0 path sv-192 flags) (path-control-flag display draw-line draw-point draw-text))
                (when #f
                  (set! sv-208 format)
                  (set! sv-224 0)
                  (set! sv-240 "Path ~d length ~M~%")
                  (set! sv-256 sv-192)
                  (let ((a3-3 (total-distance (-> arg0 path sv-192))))
                    (sv-208 sv-224 sv-240 sv-256 a3-3)
                    )
                  )
                (set! sv-336 (new 'stack-no-clear 'vector))
                (set! sv-352 (new 'stack-no-clear 'vector))
                (get-point-at-percent-along-path! (-> arg0 path sv-192) sv-336 0.0 'interp)
                (get-point-at-percent-along-path! (-> arg0 path sv-192) sv-352 1.0 'interp)
                (when #f
                  (set! sv-272 format)
                  (set! sv-288 0)
                  (set! sv-304 "Begin to end of path ~d is ~M~%")
                  (set! sv-320 sv-192)
                  (let ((a3-6 (vector-vector-distance sv-336 sv-352)))
                    (sv-272 sv-288 sv-304 sv-320 a3-6)
                    )
                  )
                (when (>= 4.096 (vector-vector-distance-squared sv-336 sv-352))
                  (if #f
                      (format 0 "Path idx ~d is a loop~%" sv-192)
                      )
                  (logior! (-> arg0 inout sv-192 flags) (factory-inout-flag fi0))
                  (set! (-> arg0 loops (-> arg0 nloop)) sv-192)
                  (+! (-> arg0 nloop) 1)
                  )
                (set! sv-176 (+ sv-176 1))
                )
              )
            )
          (+! (-> arg0 npath) sv-160)
          )
        )
      )
    )
  (when #f
    (if (<= (-> arg0 npath) 0)
        (format 0 "No path found~%")
        )
    )
  (dotimes (s5-1 (-> arg0 npath))
    (when (not (logtest? (-> arg0 inout s5-1 flags) (factory-inout-flag fi0)))
      (let ((f28-0 40960000.0)
            (s3-1 -1)
            (s4-1 -1)
            (f30-1 -1.0)
            )
        0.0
        0.0
        (let ((s2-1 (new 'stack-no-clear 'vector))
              (s1-1 (new 'stack-no-clear 'vector))
              (s0-1 (new 'stack-no-clear 'vector))
              )
          (set! sv-368 (new 'stack-no-clear 'vector))
          (set! sv-384 0)
          (while (< sv-384 (-> arg0 npath))
            (when (logtest? (-> arg0 inout sv-384 flags) (factory-inout-flag fi0))
              (get-point-at-percent-along-path! (-> arg0 path s5-1) s2-1 0.0 'interp)
              (get-point-at-percent-along-path! (-> arg0 path s5-1) s1-1 1.0 'interp)
              (if #f
                  (format 0 "Path idx ~d is an entrance~%" s5-1)
                  )
              (let ((f26-0 (path-control-method-25 (-> arg0 path sv-384) s2-1))
                    (f24-0 (path-control-method-25 (-> arg0 path sv-384) s1-1))
                    )
                (if #f
                    (format 0 "u1: ~f u2: ~f~%" f26-0 f24-0)
                    )
                (get-point-at-percent-along-path! (-> arg0 path sv-384) s0-1 f26-0 'interp)
                (get-point-at-percent-along-path! (-> arg0 path sv-384) sv-368 f24-0 'interp)
                (when #f
                  (set! sv-400 format)
                  (set! sv-416 0)
                  (set! sv-432 "Dist1: ~M Dist2: ~M~%")
                  (set! sv-448 (vector-vector-distance s2-1 s0-1))
                  (let ((a3-12 (vector-vector-distance s1-1 sv-368)))
                    (sv-400 sv-416 sv-432 sv-448 a3-12)
                    )
                  )
                (when (< (vector-vector-distance s2-1 s0-1) f28-0)
                  (set! s4-1 1)
                  (set! f28-0 (vector-vector-distance s2-1 s0-1))
                  (set! s3-1 sv-384)
                  (set! f30-1 f26-0)
                  )
                (when (< (vector-vector-distance s1-1 sv-368) f28-0)
                  (set! s4-1 0)
                  (set! f28-0 (vector-vector-distance s1-1 sv-368))
                  (set! s3-1 sv-384)
                  (set! f30-1 f24-0)
                  )
                )
              )
            (set! sv-384 (+ sv-384 1))
            )
          )
        (if #f
            (format 0 "Best dist: ~M best loop: ~d Best pos: ~f EExit: ~d~%" f28-0 s3-1 f30-1 s4-1)
            )
        (cond
          ((>= 40960.0 f28-0)
           (set! (-> arg0 inout s5-1 lpath) s3-1)
           (set! (-> arg0 inout s5-1 lpos) f30-1)
           (if (zero? s4-1)
               (logior! (-> arg0 inout s5-1 flags) (factory-inout-flag fi1))
               )
           (if (= s4-1 1)
               (logior! (-> arg0 inout s5-1 flags) (factory-inout-flag fi2))
               )
           )
          (else
            (if #f
                (format 0 "ERROR: Path could not be connected!~%")
                )
            (set! (-> arg0 inout s5-1 lpath) 0)
            (set! (-> arg0 inout s5-1 lpos) 0.0)
            )
          )
        )
      )
    )
  #f
  )

(defstate idle (factory-manager)
  :virtual #t
  :code (behavior ()
    (until #f
      (while (or (<= (-> self fpath npath) 0) (<= (-> self tpath npath) 0))
        (suspend)
        )
      (when (and (zero? (-> self player-born)) (and *target* (focus-test? *target* pilot)))
        (set-time! (-> self player-born))
        (set! (-> self player-died) 0)
        0
        )
      (if (and (not *target*) (zero? (-> self player-died)))
          (set-time! (-> self player-died))
          )
      (when (!= *fac-wave* (-> self cur-wave))
        (set! (-> self cur-wave) (the-as uint *fac-wave*))
        (if (= *fac-wave* 1)
            (set! (-> self nfighters-total) (-> self nfighters-spawned))
            )
        )
      (when (and *target*
                 (< (-> self nfighters-spawned) (the-as uint 50))
                 (< (-> self nfighters-total) (the-as uint 50))
                 (focus-test? *target* pilot)
                 (> (-> self tpath npath) 0)
                 (time-elapsed? (-> self fighter-spawned) (seconds 0.2))
                 (time-elapsed? (-> self fighter-killed) (seconds 0.2))
                 )
        (set-time! (-> self fighter-spawned))
        (factory-fighter-spawn self)
        (+! (-> self nfighters-spawned) 1)
        (+! (-> self nfighters-total) 1)
        )
      (when (and *target*
                 (< (-> self ntanks-spawned) (the-as uint 4))
                 (> (-> self fpath npath) 0)
                 (focus-test? *target* pilot)
                 (time-elapsed? (-> self tank-spawned) (seconds 2))
                 )
        (set-time! (-> self tank-spawned))
        (fac-robotank-spawn self)
        (+! (-> self ntanks-spawned) 1)
        )
      (suspend)
      )
    #f
    )
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: Function (method 15 factory-manager) has a return type of none, but the expression builder found a return statement.
(defmethod factory-manager-method-15 ((this factory-manager))
  (dotimes (v1-0 (-> this fpath npath))
    (if (or (zero? (-> this fpath path v1-0))
            (logtest? (-> this fpath path v1-0 flags) (path-control-flag not-found))
            )
        (return #f)
        )
    )
  #t
  (none)
  )

(deftype factory-fighter-path (process-drawable)
  ()
  )


;; WARN: Return type mismatch none vs object.
(defmethod init-from-entity! ((this factory-fighter-path) (arg0 entity-actor))
  (cleanup-for-death this)
  )

(deftype factory-tanks-path (process-drawable)
  ()
  )


;; WARN: Return type mismatch none vs object.
(defmethod init-from-entity! ((this factory-tanks-path) (arg0 entity-actor))
  (cleanup-for-death this)
  )

(defbehavior factory-manager-init-by-other factory-manager ((arg0 level))
  (set! (-> self level) arg0)
  (set! (-> self player-died) 0)
  (set! (-> self player-born) 0)
  (set! (-> self nfighters-spawned) (the-as uint 0))
  (set! (-> self nfighters-total) (the-as uint 0))
  (set! (-> self cur-wave) (the-as uint 0))
  (init-paths-for-list! self (-> self fpath) "factory-fighter-path")
  (init-paths-for-list! self (-> self tpath) "factory-tanks-path")
  (go-virtual idle)
  )

(defmethod relocate ((this factory-manager) (offset int))
  (dotimes (v1-0 (-> this fpath npath))
    (if (nonzero? (-> this fpath path v1-0))
        (&+! (-> this fpath path v1-0) offset)
        )
    )
  (dotimes (v1-3 (-> this tpath npath))
    (if (nonzero? (-> this tpath path v1-3))
        (&+! (-> this tpath path v1-3) offset)
        )
    )
  (call-parent-method this offset)
  )

(defun factory-manager-start ((arg0 level))
  (kill-by-type factory-manager *active-pool*)
  (process-spawn factory-manager arg0 :name "factory-manager" :to *entity-pool*)
  0
  (none)
  )

(define *fac-fighter-rigid-body-constants*
  (new 'static 'rigid-body-object-constants
    :info (new 'static 'rigid-body-info
      :mass 1.5
      :inv-mass 0.6666667
      :linear-damping 0.97
      :angular-damping 0.94
      :bounce-factor 0.75
      :friction-factor 0.99
      :cm-offset-joint (new 'static 'vector :w 1.0)
      :inertial-tensor-box (new 'static 'array meters 3 (meters 2.5) (meters 5) (meters 2.5))
      )
    :extra (new 'static 'rigid-body-object-extra-info
      :max-time-step 0.033333335
      :gravity (meters 20)
      :idle-distance (meters 200)
      :attack-force-scale 2.0
      )
    :name '*fac-fighter-rigid-body-constants*
    )
  )

(defskelgroup skel-factory-fighter kg-fighter kg-fighter-lod0-jg kg-fighter-idle-ja
              ((kg-fighter-lod0-mg (meters 20)) (kg-fighter-lod1-mg (meters 40)) (kg-fighter-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-fac-fighter-explode kg-fighter kg-fighter-explode-lod0-jg kg-fighter-explode-idle-ja
              ((kg-fighter-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *fac-fighter-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defun fighter-best-birth-path ((arg0 factory-manager))
  (local-vars (v0-2 int))
  (let ((f30-0 409600000.0))
    0
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      0.0
      0.0
      (set! (-> s5-0 quad) (-> *target* control trans quad))
      (dotimes (s4-0 (-> arg0 fpath npath))
        (when (logtest? (-> arg0 fpath inout s4-0 flags) (factory-inout-flag fi1))
          (get-point-at-percent-along-path! (-> arg0 fpath path s4-0) s5-0 0.0 'interp)
          (let ((f0-2 (vector-vector-distance s5-0 (-> *target* control trans))))
            (vector-! s5-0 s5-0 (-> *target* control trans))
            (let ((f1-1 (vector-dot s5-0 (-> *target* node-list data 0 bone transform fvec))))
              (if (and (>= f30-0 f0-2) (>= f1-1 0.0))
                  (set! f30-0 f0-2)
                  )
              )
            )
          )
        )
      )
    )
  (until (logtest? (-> arg0 fpath inout v0-2 flags) (factory-inout-flag fi1))
    (set! v0-2 (rand-vu-int-range 0 (+ (-> arg0 fpath npath) -1)))
    )
  v0-2
  )

(defun fighter-birth-path ((arg0 factory-manager))
  (local-vars (v0-0 int))
  0
  (until (logtest? (-> arg0 fpath inout v0-0 flags) (factory-inout-flag fi1))
    (set! v0-0 (rand-vu-int-range 0 (+ (-> arg0 fpath npath) -1)))
    )
  v0-0
  )

(defbehavior factory-fighter-standard-event-handler factory-fighter ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched 'attack)
     (when (!= (-> arg0 type) guard-shot)
       (when (-> self engine-sound-playing?)
         (sound-stop (-> self engine-sound))
         (set! (-> self engine-sound-playing?) #f)
         )
       (if (< (rand-vu) 0.2)
           (go-virtual dive)
           (go-virtual explode)
           )
       )
     )
    )
  )

(defstate idle (factory-fighter)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 1))
        (go-virtual flying)
        )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defmethod deactivate ((this factory-fighter))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (remove-from-process *part-engine* this)
  (sound-stop (-> this engine-sound))
  (set! (-> this engine-sound) (new 'static 'sound-id))
  ((method-of-type process-focusable deactivate) this)
  (none)
  )

(defmethod fire-shot ((this factory-fighter))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let ((s5-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s4-0 quad) (-> (get-trans *target* 3) quad))
          (let ((v1-4 s5-0))
            (let ((a0-3 (-> this root trans)))
              (let ((a1-1 (-> this forw)))
                (let ((a2-1 17203.2))
                  (.mov vf7 a2-1)
                  )
                (.lvf vf5 (&-> a1-1 quad))
                )
              (.lvf vf4 (&-> a0-3 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-4 quad) vf6)
            )
          (let ((a1-2 s5-0))
            (let ((v1-5 s5-0))
              (let ((a0-4 (-> this upvc)))
                (let ((a2-3 2252.8))
                  (.mov vf7 a2-3)
                  )
                (.lvf vf5 (&-> a0-4 quad))
                )
              (.lvf vf4 (&-> v1-5 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-2 quad) vf6)
            )
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-3 from) (process->ppointer pp))
              (set! (-> a1-3 num-params) 0)
              (set! (-> a1-3 message) 'get-vehicle)
              (let ((a0-7 (the-as vehicle (send-event-function *target* a1-3))))
                (when a0-7
                  (vector-float*! s3-0 (-> a0-7 rbody lin-velocity) 0.4)
                  (vector+! s4-0 s4-0 s3-0)
                  (sound-play "fighter-fire")
                  )
                )
              )
            (when #t
              (rand-vu-sphere-point-uniform! s3-0 (* 61440.0 (rand-vu)))
              (vector+! s4-0 s4-0 s3-0)
              )
            )
          (spawn-ffight-projectile this s5-0 s4-0 819200.0 #f)
          )
        )
      )
    )
  )

(defmethod factory-fighter-method-62 ((this factory-fighter) (arg0 symbol))
  (when (>= (- (current-time) (-> this red-tip-change-time)) 0)
    (set! (-> this red-tip-on) (not (-> this red-tip-on)))
    (set! (-> this red-tip-change-time) (+ (current-time) (seconds 0.5)))
    (set! arg0 #t)
    )
  (when (and arg0 (logtest? (-> this draw status) (draw-control-status on-screen)))
    (remove-from-process *part-engine* this)
    (if (-> this red-tip-on)
        (add-connection *part-engine* this 5 this 2794 (new 'static 'vector :y 2252.8 :z 4505.6 :w 819200.0))
        (add-connection *part-engine* this 5 this 2794 (new 'static 'vector :y 2252.8 :z 4505.6 :w 819200.0))
        )
    )
  0
  (none)
  )

(defmethod factory-fighter-method-61 ((this factory-fighter))
  (local-vars (v1-64 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((f30-0 (seconds-per-frame)))
      1.0
      (-> this path-pos)
      (let* ((s5-0 (ppointer->process (-> this parent)))
             (f0-2 f30-0)
             (f28-0 (/ 1.0 f0-2))
             )
        (set! (-> this path-pos)
              (path-control-method-26 (-> s5-0 fpath path (-> this path-idx)) (-> this path-pos) (* 143360.0 f30-0))
              )
        (when (>= (-> this path-pos) 1.0)
          (set! (-> this newpath) 2)
          (cond
            ((logtest? (-> s5-0 fpath inout (-> this path-idx) flags) (factory-inout-flag fi0))
             (set! (-> this path-pos) 0.0)
             (vector-reset! (-> this forw))
             (vector-reset! (-> this upvc))
             )
            ((>= (-> s5-0 fpath inout (-> this path-idx) lpath) 0)
             (set! (-> this path-pos) (-> s5-0 fpath inout (-> this path-idx) lpos))
             (set! (-> this path-idx) (-> s5-0 fpath inout (-> this path-idx) lpath))
             (vector-reset! (-> this forw))
             (vector-reset! (-> this upvc))
             )
            (else
              (set! (-> this disappear) #t)
              )
            )
          )
        (set! (-> this ppos quad) (-> this root trans quad))
        (get-point-at-percent-along-path!
          (-> s5-0 fpath path (-> this path-idx))
          (-> this root trans)
          (-> this path-pos)
          'interp
          )
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (s2-0 (new 'stack-no-clear 'vector))
              (s3-0 (new 'stack-no-clear 'vector))
              (s5-1 (new 'stack-no-clear 'vector))
              )
          (vector-! s2-0 (-> this root trans) (-> this ppos))
          (vector-float*! s2-0 s2-0 f28-0)
          (set! (-> s4-0 quad) (-> s2-0 quad))
          (vector-normalize! s4-0 1.0)
          (vector-! s3-0 s2-0 (-> this pvel))
          (set! (-> this pvel quad) (-> s2-0 quad))
          (vector-float*! s3-0 s3-0 (/ f28-0 (meters 15)))
          (cond
            ((< 0.0 (-> this blendpath))
             (let ((v1-52 (new 'stack-no-clear 'vector)))
               (vector-float*! s3-0 s3-0 (- 1.0 (-> this blendpath)))
               (vector-float*! v1-52 (-> this pacc) (-> this blendpath))
               (vector+! s3-0 s3-0 v1-52)
               )
             (set! (-> this blendpath) (fmax 0.0 (- (-> this blendpath) (* 4.0 f30-0))))
             )
            ((zero? (-> this newpath))
             (set! (-> this pacc quad) (-> s3-0 quad))
             )
            (else
              (set! (-> s3-0 quad) (-> this pacc quad))
              (+! (-> this newpath) -1)
              (if (zero? (-> this newpath))
                  (set! (-> this blendpath) 1.0)
                  )
              )
            )
          (let ((f0-22 0.0))
            (.lvf vf1 (&-> s2-0 quad))
            (.add.w.vf vf2 vf0 vf0 :mask #b1)
            (.mul.vf vf1 vf1 vf1)
            (.mul.x.vf acc vf2 vf1 :mask #b1)
            (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
            (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
            (.mov v1-64 vf1)
            (if (>= f0-22 v1-64)
                (vector-reset! s3-0)
                )
            )
          (vector+! s5-1 *up-vector* s3-0)
          (vector-normalize! s5-1 1.0)
          (forward-up->quaternion (-> this root quat) s4-0 s5-1)
          (set! (-> this forw quad) (-> s4-0 quad))
          (set! (-> this upvc quad) (-> s5-1 quad))
          )
        )
      )
    (transform-post)
    (none)
    )
  )

(defstate flying (factory-fighter)
  :virtual #t
  :event factory-fighter-standard-event-handler
  :enter (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 4) :num! (loop!) :frame-num 0.0)
    )
  :trans (behavior ()
    (factory-fighter-method-62 self #f)
    (new 'stack-no-clear 'vector)
    0.0
    (let ((s5-0 (new 'stack-no-clear 'matrix))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> gp-0 quad) (-> self root trans quad))
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (if (-> self disappear)
            (go-virtual die)
            )
        (quaternion->matrix s5-0 (-> self root quat))
        (set-vector! s4-0 0.0 4096.0 -8192.0 1.0)
        (vector-rotate*! s4-0 s4-0 s5-0)
        (vector+! gp-0 gp-0 s4-0)
        )
      (send-event (handle->process (-> self light-trail)) 'notice 'add-crumb-pos gp-0)
      )
    (when (time-elapsed? (-> self last-snd-cmd) (seconds 0.1))
      (set! (-> self engine-sound-playing?) #t)
      (sound-play-by-name
        (static-sound-name "fighter-engine")
        (-> self engine-sound)
        1024
        (the int (* 1524.0 (doppler-pitch-shift (-> self root trans) (-> self pvel))))
        0
        (sound-group)
        #t
        )
      (set-time! (-> self last-snd-cmd))
      )
    )
  :code (behavior ()
    (local-vars (v1-12 float))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (until #f
        (when (and *target* (time-elapsed? (-> self last-fire) (seconds 2)) (time-elapsed? *fac-fighter-fired* (seconds 1)))
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (let ((s5-0 (new 'stack-no-clear 'vector)))
              0.0
              (let ((v1-9 s5-0))
                (let ((a0-4 (-> self root trans)))
                  (let ((a1-0 (-> self forw)))
                    (let ((a2-1 17203.2))
                      (.mov vf7 a2-1)
                      )
                    (.lvf vf5 (&-> a1-0 quad))
                    )
                  (.lvf vf4 (&-> a0-4 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> v1-9 quad) vf6)
                )
              (let ((a1-1 s5-0))
                (let ((v1-10 s5-0))
                  (let ((a0-5 (-> self upvc)))
                    (let ((a2-3 2252.8))
                      (.mov vf7 a2-3)
                      )
                    (.lvf vf5 (&-> a0-5 quad))
                    )
                  (.lvf vf4 (&-> v1-10 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-1 quad) vf6)
                )
              (.lvf vf1 (&-> gp-0 quad))
              (.add.w.vf vf2 vf0 vf0 :mask #b1)
              (.mul.vf vf1 vf1 vf1)
              (.mul.x.vf acc vf2 vf1 :mask #b1)
              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
              (.mov v1-12 vf1)
              v1-12
              (vector-! gp-0 (get-trans *target* 3) s5-0)
              )
            (vector-normalize! gp-0 1.0)
            (when (and (logtest? (-> self draw status) (draw-control-status on-screen))
                       (< 0.8 (vector-dot (-> self forw) gp-0))
                       (< (vector-vector-distance (-> *target* control trans) (-> self root trans)) 491520.0)
                       (< 163840.0 (vector-vector-distance (-> *target* control trans) (-> self root trans)))
                       )
              (fire-shot self)
              (set-time! (-> self last-fire))
              (set! *fac-fighter-fired* (current-time))
              )
            )
          )
        (-> self skel root-channel 0)
        (suspend)
        )
      #f
      )
    )
  :post (behavior ()
    (factory-fighter-method-61 self)
    )
  )

(defstate dive (factory-fighter)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (cond
      ((logtest? (-> *part-group-id-table* 730 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 730))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 730))
        )
      )
    (set! (-> self rot-vel) (rand-vu-float-range -910.2222 910.2222))
    (set! (-> self rot-acc) (rand-vu-float-range -3640.889 3640.889))
    (sound-play "fighter-explode")
    (let ((gp-3 (new 'stack-no-clear 'vector)))
      (rand-vu-sphere-point-uniform! gp-3 20480.0)
      (vector+! (-> self pvel) (-> self pvel) gp-3)
      )
    )
  :trans (behavior ()
    (when (not (time-elapsed? (-> self state-time) (seconds 1)))
      )
    (if (time-elapsed? (-> self state-time) (seconds 3))
        (go-virtual explode)
        )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (let ((a0-0 (new 'stack-no-clear 'vector))
            (f0-0 (seconds-per-frame))
            )
        (set-vector! (-> self pacc) 0.0 -81920.0 0.0 1.0)
        (vector-float*! a0-0 (-> self pacc) f0-0)
        (vector+! (-> self pvel) (-> self pvel) a0-0)
        (vector-float*! v1-0 (-> self pvel) f0-0)
        )
      (vector+! (-> self root trans) (-> self root trans) v1-0)
      )
    (quaternion-rotate-local-z! (-> self root quat) (-> self root quat) (-> self rot-vel))
    (+! (-> self rot-vel) (* (-> self rot-acc) (seconds-per-frame)))
    (set! (-> self rot-vel) (fmax -5461.3335 (fmin 5461.3335 (-> self rot-vel))))
    (transform-post)
    )
  )

(defstate explode (factory-fighter)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (remove-from-process *part-engine* self)
    (set! (-> self root root-prim local-sphere w) 491520.0)
    (cond
      ((logtest? (-> *part-group-id-table* 730 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 730))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 730))
        )
      )
    (sound-play "fighter-explode")
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
        (let ((v1-1 (new 'stack-no-clear 'vector)))
          (let ((a0-1 (-> gp-0 fountain-rand-transv-lo)))
            (let ((a1-2 (-> self root trans)))
              (let ((a2-1 *up-vector*))
                (let ((a3-1 2048.0))
                  (.mov vf7 a3-1)
                  )
                (.lvf vf5 (&-> a2-1 quad))
                )
              (.lvf vf4 (&-> a1-2 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-1 quad) vf6)
            )
          (let ((a2-2 v1-1))
            (let ((a0-2 (-> self pvel)))
              (let ((a1-3 *up-vector*))
                (let ((a3-3 40960.0))
                  (.mov vf7 a3-3)
                  )
                (.lvf vf5 (&-> a1-3 quad))
                )
              (.lvf vf4 (&-> a0-2 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a2-2 quad) vf6)
            )
          (let ((a2-3 (-> gp-0 fountain-rand-transv-lo)))
            (let ((a0-3 v1-1))
              (let ((a1-4 *identity-vector*))
                (let ((a3-5 -204800.0))
                  (.mov vf7 a3-5)
                  )
                (.lvf vf5 (&-> a1-4 quad))
                )
              (.lvf vf4 (&-> a0-3 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a2-3 quad) vf6)
            )
          (let ((a1-5 (-> gp-0 fountain-rand-transv-hi)))
            (let ((a0-4 *identity-vector*))
              (let ((a2-5 204800.0))
                (.mov vf7 a2-5)
                )
              (.lvf vf5 (&-> a0-4 quad))
              )
            (.lvf vf4 (&-> v1-1 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-5 quad) vf6)
            )
          )
        (set! (-> gp-0 gravity) -122880.0)
        (set! (-> gp-0 rot-speed) 16.0)
        (set! (-> gp-0 friction) 1.0)
        (process-spawn
          joint-exploder
          (art-group-get-by-name *level* "skel-fac-fighter-explode" (the-as (pointer level) #f))
          7
          gp-0
          *fac-fighter-exploder-params*
          :name "joint-exploder"
          :to self
          :unk 0
          )
        )
      (let ((v1-10 (ppointer->process (-> self parent))))
        (+! (-> v1-10 nfighters-spawned) -1)
        )
      (while (-> self child)
        (suspend)
        )
      )
    )
  :post (behavior ()
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (let ((a0-0 (new 'stack-no-clear 'vector))
            (f0-0 (seconds-per-frame))
            )
        (set-vector! (-> self pacc) 0.0 -327680.0 0.0 1.0)
        (vector-float*! a0-0 (-> self pacc) f0-0)
        (vector+! (-> self pvel) (-> self pvel) a0-0)
        (vector-float*! v1-0 (-> self pvel) f0-0)
        )
      (vector+! (-> self root trans) (-> self root trans) v1-0)
      )
    (transform-post)
    )
  )

(defstate die (factory-fighter)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (while (not (time-elapsed? (-> self state-time) (seconds 2)))
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (let ((v1-28 (ppointer->process (-> self parent))))
      (+! (-> v1-28 nfighters-spawned) -1)
      )
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod init-collision! ((this factory-fighter))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 10240.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  (set! (-> this root event-self) 'touched)
  (none)
  )

(defmethod get-trans ((this factory-fighter) (arg0 int))
  "Get the `trans` for this process."
  (-> this root trans)
  )

(defbehavior factory-fighter-init-by-other factory-fighter ()
  (init-collision! self)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self level) (level-get *level* 'factoryb))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-factory-fighter" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (alloc-rbody-control! self *fac-fighter-rigid-body-constants*)
  (set! (-> self path-idx) (fighter-birth-path (ppointer->process (-> self parent))))
  (vector-reset! (-> self pacc))
  (set! (-> self blendpath) 0.0)
  (set! (-> self newpath) 2)
  (set! (-> self path-pos) 0.0)
  (set! (-> self rot-vel) 0.0)
  (set! (-> self rot-acc) 0.0)
  (set! (-> self disappear) #f)
  (set-time! (-> self last-fire))
  (set! (-> self turret-gun) 5)
  (set! (-> self engine-sound) (new-sound-id))
  (set! (-> self engine-sound-playing?) #f)
  (set-time! (-> self last-snd-cmd))
  (set! (-> self red-tip-on) #f)
  (set-time! (-> self red-tip-change-time))
  (factory-fighter-method-62 self #t)
  (set! (-> self draw light-index) (the-as uint 10))
  (logclear! (-> self mask) (process-mask actor-pause))
  (process-entity-status! self (entity-perm-status no-kill) #t)
  (let ((gp-1 (new 'stack-no-clear 'light-trail-tracker-spawn-params)))
    (set! (-> gp-1 tracked-obj) (process->handle self))
    (set! (-> gp-1 appearance) *factory-fighter-trail*)
    (set! (-> gp-1 max-num-crumbs) (the int (* 0.25 (the float (-> gp-1 appearance max-age)))))
    (set! (-> gp-1 track-immediately?) #t)
    (let* ((v1-38
             (estimate-light-trail-mem-usage
               (the-as uint (-> gp-1 max-num-crumbs))
               (the-as uint (= (-> gp-1 appearance lie-mode) (lie-mode use-two-strips)))
               )
             )
           (s5-1 (get-process *default-dead-pool* light-trail-tracker-vehicle (+ v1-38 8192) 1))
           )
      (set! (-> self light-trail)
            (ppointer->handle (when s5-1
                                (let ((t9-13 (method-of-type process activate)))
                                  (t9-13 s5-1 self "light-trail" (the-as pointer #x70004000))
                                  )
                                (run-now-in-process s5-1 light-trail-tracker-init-by-other gp-1)
                                (-> s5-1 ppointer)
                                )
                              )
            )
      )
    )
  (go-virtual idle)
  )

;; WARN: Return type mismatch process vs factory-fighter.
(defun factory-fighter-spawn ((arg0 process))
  (let ((gp-0 (the-as process #f)))
    (let ((v1-1 (process-spawn factory-fighter :name "factory-fighter" :to arg0)))
      (if v1-1
          (set! gp-0 (-> v1-1 0))
          )
      )
    (the-as factory-fighter gp-0)
    )
  )

(defskelgroup skel-fac-target fac-target fac-target-lod0-jg fac-target-idle-ja
              ((fac-target-lod0-mg (meters 20)) (fac-target-lod1-mg (meters 40)) (fac-target-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(defskelgroup skel-fac-target-explode fac-target fac-target-explode-lod0-jg fac-target-explode-idle-ja
              ((fac-target-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(define *fac-target-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defmethod init-from-entity! ((this fac-target) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec enemy obstacle))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec enemy obstacle))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 5)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 16384.0 16384.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this root event-self) 'touched)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (process-entity-status! this (entity-perm-status no-kill) #t)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-target" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this light-jm) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 5))
  (set! (-> this draw lod-set lod 0 dist) 409600.0)
  (set! (-> this draw lod-set lod 1 dist) 819200.0)
  (set! (-> this draw lod-set lod 2 dist) 1024000.0)
  (let ((a1-11 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-25 0))
      (if #t
          (set! v1-25 (logior v1-25 1))
          )
      (set! (-> a1-11 sync-type) 'sync-paused)
      (set! (-> a1-11 sync-flags) (the-as sync-flags v1-25))
      )
    (set! (-> a1-11 entity) (-> this entity))
    (set! (-> a1-11 period) (the-as uint 1500))
    (set! (-> a1-11 percent) 0.0)
    (set! (-> a1-11 pause-in) 0.0)
    (set! (-> a1-11 pause-out) 0.0)
    (initialize! (-> this sync) a1-11)
    )
  (fac-target-method-33 this)
  (cond
    ((task-node-closed? (game-task-node factory-sky-battle-wave2))
     (process-entity-status! this (entity-perm-status subtask-complete) #t)
     (let ((v1-34 (-> this root root-prim)))
       (set! (-> v1-34 prim-core collide-as) (collide-spec))
       (set! (-> v1-34 prim-core collide-with) (collide-spec))
       )
     0
     (logior! (-> this draw status) (draw-control-status no-draw))
     (cleanup-for-death this)
     (go (method-of-object this die-fast))
     )
    (else
      (go (method-of-object this retracted))
      )
    )
  )

(defstate die-fast (fac-target)
  :virtual #t
  :code nothing
  )

(defun hack-wave ()
  (logtest? (current-time) 64)
  )

(defmethod fac-target-method-33 ((this fac-target))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 1 0)
  0
  (none)
  )

(defmethod fac-target-method-34 ((this fac-target))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 1 0)
  (setup-masks (-> this draw) 2 0)
  0
  (none)
  )

(defbehavior fac-target-standard-event-handler fac-target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('die-fast)
     (process-entity-status! self (entity-perm-status subtask-complete) #t)
     (go-virtual die-fast)
     )
    (('touched)
     (let ((gp-0 arg0))
       (when (if (type? gp-0 vehicle)
                 gp-0
                 )
         (sound-play "light-explode" :position (-> self root trans))
         (go-virtual retract)
         )
       )
     )
    (('attack)
     (let ((v1-8 (the-as attack-info (-> arg3 param 1))))
       (when (or (and (logtest? (-> v1-8 mask) (attack-mask attacker))
                      (= (-> (handle->process (-> v1-8 attacker)) type) target)
                      )
                 (let ((gp-2 arg0))
                   (if (type? gp-2 warf-projectile)
                       gp-2
                       )
                   )
                 )
         (sound-play "light-explode" :position (-> self root trans))
         (go-virtual retract)
         )
       )
     )
    )
  )

(defstate idle (fac-target)
  :virtual #t
  :event fac-target-standard-event-handler
  :enter (behavior ()
    (add-connection *part-engine* self 5 self 2795 (new 'static 'vector :z 24576.0 :w 1638400.0))
    (add-connection *part-engine* self 5 self 2796 (new 'static 'vector :x 8192.0 :z 16384.0 :w 1638400.0))
    (add-connection *part-engine* self 5 self 2796 (new 'static 'vector :x -8192.0 :z 16384.0 :w 1638400.0))
    (add-connection *part-engine* self 5 self 2796 (new 'static 'vector :y 8192.0 :z 16384.0 :w 1638400.0))
    (add-connection *part-engine* self 5 self 2796 (new 'static 'vector :y -8192.0 :z 16384.0 :w 1638400.0))
    (ja :group! fac-target-desend-ja :num! max)
    (sync-now! (-> self sync) 0.0)
    (set-time! (-> self state-time))
    (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 148) (the-as int #f) (the-as vector #t) 0))
    )
  :trans (behavior ()
    (ja :num! (seek! 0.0 0.5))
    )
  :code (behavior ()
    (until #f
      (quaternion-axis-angle!
        (-> self light-jm quat)
        0.0
        0.0
        1.0
        (the float (sar (shl (* 100 (current-time)) 48) 48))
        )
      (suspend)
      )
    #f
    )
  :post transform-post
  )

(defstate retract (fac-target)
  :virtual #t
  :enter (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (process-entity-status! self (entity-perm-status subtask-complete) #t)
      (let ((v1-1 (-> self root root-prim)))
        (set! (-> v1-1 prim-core collide-as) (collide-spec))
        (set! (-> v1-1 prim-core collide-with) (collide-spec))
        )
      0
      (logior! (-> self draw status) (draw-control-status no-draw))
      (fac-target-method-33 self)
      (set-time! (-> self state-time))
      (when (-> self minimap)
        (logior! (-> self minimap flags) (minimap-flag fade-out))
        (set! (-> self minimap) #f)
        )
      (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (let ((s4-0 (-> self node-list data 3 bone transform)))
            (vector-float*! s5-0 (-> s4-0 fvec) (* 4096.0 (rand-vu-float-range 20.0 30.0)))
            (let ((v1-20 (-> gp-0 fountain-rand-transv-lo)))
              (let ((a0-7 (-> self root trans)))
                (let ((a1-3 (-> s4-0 fvec)))
                  (let ((a2-3 2048.0))
                    (.mov vf7 a2-3)
                    )
                  (.lvf vf5 (&-> a1-3 quad))
                  )
                (.lvf vf4 (&-> a0-7 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> v1-20 quad) vf6)
              )
            )
          (let ((a1-4 (-> gp-0 fountain-rand-transv-lo)))
            (let ((v1-21 s5-0))
              (let ((a0-8 *identity-vector*))
                (let ((a2-5 -204800.0))
                  (.mov vf7 a2-5)
                  )
                (.lvf vf5 (&-> a0-8 quad))
                )
              (.lvf vf4 (&-> v1-21 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-4 quad) vf6)
            )
          (let ((a0-9 (-> gp-0 fountain-rand-transv-hi)))
            (let ((v1-22 *identity-vector*))
              (let ((a1-6 204800.0))
                (.mov vf7 a1-6)
                )
              (.lvf vf5 (&-> v1-22 quad))
              )
            (.lvf vf4 (&-> s5-0 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-9 quad) vf6)
            )
          )
        (set! (-> gp-0 gravity) -122880.0)
        (set! (-> gp-0 rot-speed) 16.0)
        (cond
          ((logtest? (-> *part-group-id-table* 733 flags) (sp-group-flag sp13))
           (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
           (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 733))
           )
          (else
            (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
            (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 733))
            )
          )
        (process-spawn
          joint-exploder
          (art-group-get-by-name *level* "skel-fac-target-explode" (the-as (pointer level) #f))
          9
          gp-0
          *fac-target-exploder-params*
          :name "joint-exploder"
          :to self
          :unk 0
          )
        )
      )
    )
  :trans (behavior ()
    (ja :num! (seek! 0.0 0.5))
    )
  :code sleep-code
  :post transform-post
  )

(defstate retracted (fac-target)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die-fast)
       (let ((v1-2 (-> self root root-prim)))
         (set! (-> v1-2 prim-core collide-as) (collide-spec))
         (set! (-> v1-2 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> self draw status) (draw-control-status no-draw))
       (cleanup-for-death self)
       (let* ((a0-5 self)
              (t9-1 (method-of-object a0-5 fac-target-method-34))
              )
         (t9-1 a0-5)
         )
       (go-virtual die-fast)
       )
      (('trigger)
       (when (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
                  )
         (logior! (-> self draw status) (draw-control-status on-screen))
         (let* ((a0-12 self)
                (t9-3 (method-of-object a0-12 fac-target-method-34))
                )
           (t9-3 a0-12)
           )
         (go-virtual idle)
         )
       )
      )
    )
  :enter (behavior ()
    (when (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
      (let ((v1-5 (-> self root root-prim)))
        (set! (-> v1-5 prim-core collide-as) (collide-spec))
        (set! (-> v1-5 prim-core collide-with) (collide-spec))
        )
      0
      (logior! (-> self draw status) (draw-control-status no-draw))
      )
    (ja :group! fac-target-desend-ja :num! max)
    (fac-target-method-33 self)
    (transform-post)
    )
  :trans (behavior ()
    (ja :num-func num-func-identity :frame-num max)
    )
  :code sleep-code
  )

(defstate explode (fac-target)
  :virtual #t
  :trans (behavior ()
    (ja :num-func num-func-identity :frame-num 0.0)
    )
  :code sleep-code
  :post ja-post
  )

;; WARN: Return type mismatch int vs search-info-flag.
(defmethod process-mask->search-info-flag ((this fac-target))
  (let ((v0-0 0))
    (if (and (-> this next-state) (= (-> this next-state name) 'idle))
        (set! v0-0 (logior v0-0 40))
        )
    (the-as search-info-flag v0-0)
    )
  )

(defmethod get-trans ((this fac-target) (arg0 int))
  "Get the `trans` for this process."
  (let ((v1-0 (-> this root)))
    (cond
      ((= arg0 3)
       (let ((a2-1 (-> this node-list data 5 bone transform))
             (gp-0 (new 'stack-no-clear 'vector))
             )
         (set-vector! gp-0 0.0 0.0 20480.0 1.0)
         (vector-matrix*! gp-0 gp-0 a2-1)
         (set! (-> gp-0 w) 20480.0)
         gp-0
         )
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

;; WARN: Return type mismatch process-focusable vs fac-target.
(defmethod relocate ((this fac-target) (offset int))
  (if (nonzero? (-> this light-jm))
      (&+! (-> this light-jm) offset)
      )
  (the-as fac-target ((method-of-type process-focusable relocate) this offset))
  )

(defmethod task-manager-method-26 ((this task-manager-factory-sky-battle))
  (with-pp
    (when (time-elapsed? (-> this check-timer) (seconds 0.1))
      (if (not (-> this factory-sky-battle-entity))
          (task-manager-factory-sky-battle-method-32 this)
          )
      (when (not (-> this hint-given))
        (set! (-> this hint-given) #t)
        (talker-spawn-func (-> *talker-speech* 101) *entity-pool* (target-pos 0) (the-as region #f))
        )
      (when (< (-> this cur-group) (-> this actor-group-count))
        (let ((s5-1 (-> this actor-group (-> this cur-group))))
          (dotimes (s4-1 (-> s5-1 length))
            (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-1 from) (process->ppointer pp))
              (set! (-> a1-1 num-params) 0)
              (set! (-> a1-1 message) 'trigger)
              (let ((t9-3 send-event-function)
                    (v1-21 (-> s5-1 data s4-1 actor))
                    )
                (t9-3
                  (if v1-21
                      (-> v1-21 extra process)
                      )
                  a1-1
                  )
                )
              )
            )
          )
        )
      (when (and (zero? (-> this cur-group))
                 (> (-> this actor-group-count) 0)
                 (task-node-closed? (game-task-node factory-sky-battle-wave1))
                 )
        (let ((s5-2 (-> this actor-group 0)))
          (dotimes (s4-2 (-> s5-2 length))
            (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-2 from) (process->ppointer pp))
              (set! (-> a1-2 num-params) 0)
              (set! (-> a1-2 message) 'die-fast)
              (let ((t9-5 send-event-function)
                    (v1-36 (-> s5-2 data s4-2 actor))
                    )
                (t9-5
                  (if v1-36
                      (-> v1-36 extra process)
                      )
                  a1-2
                  )
                )
              )
            )
          )
        (set! (-> this cur-group) 1)
        )
      (when (and (= (-> this cur-group) 1)
                 (> (-> this actor-group-count) 0)
                 (task-node-closed? (game-task-node factory-sky-battle-wave2))
                 )
        (let ((s5-3 (-> this actor-group 1)))
          (dotimes (s4-3 (-> s5-3 length))
            (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-3 from) (process->ppointer pp))
              (set! (-> a1-3 num-params) 0)
              (set! (-> a1-3 message) 'die-fast)
              (let ((t9-7 send-event-function)
                    (v1-53 (-> s5-3 data s4-3 actor))
                    )
                (t9-7
                  (if v1-53
                      (-> v1-53 extra process)
                      )
                  a1-3
                  )
                )
              )
            )
          )
        (set! (-> this cur-group) 2)
        )
      (set! *fac-wave* (-> this cur-group))
      (let ((s5-4 0))
        (when (> (-> this actor-group-count) 0)
          (dotimes (v1-63 (-> this actor-group (-> this cur-group) length))
            (if (not (logtest? (-> this actor-group (-> this cur-group) data v1-63 actor extra perm status)
                               (entity-perm-status subtask-complete)
                               )
                     )
                (+! s5-4 1)
                )
            )
          )
        (if (and (> (-> this actor-group-count) 0)
                 (= (-> this cur-group) 2)
                 (zero? s5-4)
                 (zero? (-> this mission-complete-time))
                 )
            (set-time! (-> this mission-complete-time))
            )
        (if (and (nonzero? (-> this mission-complete-time))
                 (time-elapsed? (-> this mission-complete-time) (seconds 4))
                 (not (task-node-closed? (game-task-node factory-sky-battle-resolution)))
                 *target*
                 (not (logtest? (-> *target* focus-status) (focus-status dead)))
                 )
            (send-event this 'complete)
            )
        (when (and (> (-> this actor-group-count) 0) (= (-> this cur-group) 1) (zero? s5-4))
          (task-node-close! (game-task-node factory-sky-battle-wave2) 'event)
          (set! (-> this cur-group) 2)
          )
        (when (and (> (-> this actor-group-count) 0) (zero? (-> this cur-group)) (zero? s5-4))
          (task-node-close! (game-task-node factory-sky-battle-wave1) 'event)
          (set! (-> this cur-group) 1)
          )
        (when (!= (-> *game-info* counter) (the float s5-4))
          (if (zero? (-> this hud-delay))
              (set! (-> this hud-delay) (the-as handle (current-time)))
              )
          (when (or (time-elapsed? (the-as int (-> this hud-delay)) (seconds 0.5)) (= (-> *game-info* counter) 0.0))
            (cond
              ((< 0.0 (-> *game-info* counter))
               (sound-play "hud-chime")
               (+! (-> *game-info* counter) -1.0)
               )
              (else
                (if (= (-> this cur-group) 1)
                    (sound-play "hud-chime2")
                    )
                (if (= (-> this cur-group) 2)
                    (sound-play "hud-chime3")
                    )
                (set! (-> *game-info* counter) (the float s5-4))
                )
              )
            (set! (-> this hud-delay) (new 'static 'handle))
            0
            )
          )
        )
      (set-time! (-> this check-timer))
      )
    0
    (none)
    )
  )

(defmethod task-manager-factory-sky-battle-method-32 ((this task-manager-factory-sky-battle))
  (local-vars (sv-16 res-tag))
  (let ((a0-2 (entity-by-name "factory-sky-battle-manager-1")))
    (when a0-2
      (set! (-> this factory-sky-battle-entity) (the-as entity-actor a0-2))
      (set! sv-16 (new 'static 'res-tag))
      (let ((v1-1 (res-lump-data a0-2 'actor-groups pointer :tag-ptr (& sv-16))))
        (cond
          ((and v1-1 (nonzero? (-> sv-16 elt-count)))
           (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
           (set! (-> this actor-group) (the-as (pointer actor-group) v1-1))
           )
          (else
            (format 0 "ERROR: task-manager-nest-cocoons: nst-cocoon-manager entity missing cocoon actor-group!~%")
            )
          )
        )
      (set! (-> this cur-group) 0)
      (set! (-> *game-info* counter) 0.0)
      (set! (-> this hud-counter)
            (ppointer->handle (process-spawn hud-fac-manager :init hud-init-by-other :name "hud-fac-manager" :to this))
            )
      (set! (-> this hud-damage)
            (ppointer->handle
              (process-spawn hud-factory-damage :init hud-init-by-other :name "hud-factory-damage" :to this)
              )
            )
      )
    )
  (none)
  )

(defstate resolution (task-manager-factory-sky-battle)
  :virtual #t
  :enter (behavior ()
    (send-event (handle->process (-> self hud-damage)) 'hide-and-die)
    (call-parent-state-handler enter)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod task-manager-method-25 ((this task-manager-factory-sky-battle))
  (let ((t9-0 (method-of-type task-manager task-manager-method-25)))
    (t9-0 this)
    )
  (set-action!
    *gui-control*
    (gui-action stop)
    (-> this sound-id)
    (gui-channel none)
    (gui-action none)
    (the-as string #f)
    (the-as (function gui-connection symbol) #f)
    (the-as process #f)
    )
  (send-event (handle->process (-> this hud-counter)) 'hide-and-die)
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod set-time-limit ((this task-manager-factory-sky-battle))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set-setting! 'allow-look-around #f 0.0 0)
  (set! (-> *game-info* counter) 0.0)
  (set! *fac-task-manager* (the-as task-manager-factory-sky-battle (process->ppointer this)))
  (set! (-> this factory-sky-battle-entity) #f)
  (set! (-> this hud-damage) (the-as handle #f))
  (set! (-> this cur-group) 0)
  (set! (-> this actor-group-count) 0)
  (set! (-> this check-timer) (+ (current-time) (seconds 1)))
  (set! (-> this hint-given) #f)
  (kill-by-type fac-gun-tower-break *active-pool*)
  (none)
  )

(defmethod draw ((this hud-fac-manager))
  (format (clear (-> this strings 0 text)) "~D" (-> this values 0 current))
  (cond
    ((= *fac-wave* 2)
     (set! (-> this sprites 0 tid) (the-as texture-id (get-texture hud-fac-tower-01 factoryb-minimap)))
     (set! (-> this sprites 0 angle) 16384.0)
     (set-hud-piece-position! (the-as hud-sprite (-> this sprites)) 455 225)
     (set-hud-piece-position! (the-as hud-sprite (-> this strings 0 pos)) 488 257)
     )
    (else
      (set! (-> this sprites 0 tid) (the-as texture-id (get-texture hud-fac-target-01 factoryb-minimap)))
      (set! (-> this sprites 0 angle) 0.0)
      (set-hud-piece-position! (the-as hud-sprite (-> this sprites)) 488 225)
      (set-hud-piece-position! (the-as hud-sprite (-> this strings 0 pos)) 488 257)
      )
    )
  (dotimes (s5-1 8)
    (set-hud-piece-position! (-> this sprites (+ s5-1 1)) (+ (* 11 (logand s5-1 3)) 430) (+ (if (< 3 s5-1)
                                                                                                30
                                                                                                0
                                                                                                )
                                                                                            145
                                                                                            )
                             )
    (set! (-> this sprites (+ s5-1 1) scale-x) (if (< s5-1 *fac-shotsleft*)
                                                   0.8
                                                   0.0
                                                   )
          )
    (set! (-> this sprites (+ s5-1 1) scale-y) (if (< s5-1 *fac-shotsleft*)
                                                   0.8
                                                   0.0
                                                   )
          )
    (set! (-> this sprites (+ s5-1 1) angle) 16384.0)
    )
  ((method-of-type hud draw) this)
  0
  (none)
  )

(defmethod update-values! ((this hud-fac-manager))
  (set! (-> this values 0 target) (the int (-> *game-info* counter)))
  ((method-of-type hud update-values!) this)
  0
  (none)
  )

(defmethod init-callback ((this hud-fac-manager))
  (set! (-> this level) (level-get *level* 'factoryb))
  (set! (-> this gui-id)
        (add-process *gui-control* this (gui-channel hud-center-right) (gui-action hidden) (-> this name) 81920.0 0)
        )
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this sprites 0 tid) (the-as texture-id (get-texture hud-fac-target-01 factoryb-minimap)))
  (set! (-> this sprites 0 flags) (hud-sprite-flags hsf2))
  (set! (-> this sprites 0 scale-x) 0.66)
  (set! (-> this sprites 0 scale-y) 0.66)
  (dotimes (s5-0 8)
    (set! (-> this sprites (+ s5-0 1) tid) (the-as texture-id (get-texture hud-torpedo factoryb-minimap)))
    (set! (-> this sprites (+ s5-0 1) flags) (hud-sprite-flags hsf2))
    (set! (-> this sprites (+ s5-0 1) angle) 16384.0)
    (set! (-> this sprites (+ s5-0 1) scale-x) 1.0)
    (set! (-> this sprites (+ s5-0 1) scale-y) 1.0)
    )
  (alloc-string-if-needed this 0)
  (set! (-> this strings 0 scale) 0.8)
  (set! (-> this strings 0 flags) (font-flags shadow kerning middle large))
  0
  (none)
  )

(defun factory-shotsleft ((arg0 int))
  (set! *fac-shotsleft* arg0)
  0
  (none)
  )
