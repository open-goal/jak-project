;;-*-Lisp-*-
(in-package goal)

;; name: hvehicle.gc
;; name in dgo: hvehicle
;; dgos: HGA, CWI, LFACTORY

;; DECOMP BEGINS

(defmethod vehicle-method-76 ((this hvehicle))
  (let ((t9-0 (method-of-type vehicle vehicle-method-76)))
    (t9-0 this)
    )
  (vehicle-method-100 this)
  (set! (-> this flight-level-index) 0)
  (let ((a1-0 (-> this root trans)))
    (set! (-> this flight-level) (get-height-at-point *traffic-height-map* a1-0))
    )
  0
  (none)
  )

(defmethod vehicle-method-104 ((this hvehicle))
  (vehicle-controller-method-11 (-> this controller))
  (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag persistent in-pursuit) (-> this v-flags))))
  (logior! (-> this controller flags) (vehicle-controller-flag ignore-others))
  0
  (none)
  )

(defmethod vehicle-method-105 ((this hvehicle))
  (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag in-pursuit))))
  (logclear! (-> this controller flags) (vehicle-controller-flag ignore-others direct-mode))
  (hvehicle-method-158 this)
  0
  (none)
  )

(defmethod vehicle-method-74 ((this hvehicle) (arg0 int) (arg1 time-frame))
  (when (and (< (-> this crash-level) arg0) (>= arg0 2))
    (sound-play "bike-engine-off")
    (hvehicle-method-156 this)
    )
  ((method-of-type vehicle vehicle-method-74) this arg0 arg1)
  0
  (none)
  )

(defmethod vehicle-method-122 ((this hvehicle))
  (let ((s5-0 (-> this child)))
    (while s5-0
      (send-event (ppointer->process s5-0) 'traffic-off)
      (set! s5-0 (-> s5-0 0 brother))
      )
    )
  (dotimes (s5-1 (-> this info rider seat-count))
    (put-rider-in-seat this s5-1 (the-as process #f))
    )
  (vehicle-method-138 this)
  (vehicle-controller-method-11 (-> this controller))
  (vehicle-method-106 this)
  0
  (none)
  )

(defmethod vehicle-method-123 ((this hvehicle))
  (vehicle-method-76 this)
  (set! (-> this root trans y) (-> this flight-level))
  (logior! (-> this v-flags) (vehicle-flag ai-driving ignition))
  (let ((gp-1 (-> this child)))
    (while gp-1
      (send-event (ppointer->process gp-1) 'traffic-on)
      (set! gp-1 (-> gp-1 0 brother))
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-124 ((this hvehicle))
  (let ((t9-0 (method-of-type vehicle vehicle-method-124)))
    (t9-0 this)
    )
  (vehicle-controller-method-11 (-> this controller))
  (hvehicle-method-156 this)
  0
  (none)
  )

(defmethod hvehicle-method-161 ((this hvehicle) (arg0 traffic-object-spawn-params))
  (let ((v1-0 (-> arg0 behavior)))
    (cond
      ((= v1-0 2)
       (let ((a1-1 (-> arg0 nav-branch)))
         (if a1-1
             (vehicle-controller-method-13 (-> this controller) a1-1 (-> this root trans))
             )
         )
       (vehicle-method-123 this)
       (go (method-of-object this active))
       )
      ((zero? v1-0)
       (vehicle-method-76 this)
       (logior! (-> this v-flags) (vehicle-flag persistent))
       (logclear! (-> this draw status) (draw-control-status no-draw))
       (logior! (-> this skel status) (joint-control-status sync-math))
       (ja-post)
       (update-transforms (-> this root))
       (logclear! (-> this skel status) (joint-control-status sync-math))
       (go (method-of-object this idle))
       )
      (else
        (vehicle-method-109 this)
        #f
        )
      )
    )
  )

(defmethod vehicle-method-103 ((this hvehicle))
  (local-vars (v1-13 float) (v1-25 float) (v1-30 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (when (time-elapsed? (-> this disturbed-time) (seconds 2))
      (cond
        ((logtest? (vehicle-flag ai-driving) (-> this v-flags))
         (when (and (not (logtest? (-> this controller flags) (vehicle-controller-flag off-path)))
                    (>= (-> this rbody matrix uvec y) (cos 910.2222))
                    )
           (.lvf vf1 (&-> (-> this rbody ang-velocity) quad))
           (.add.w.vf vf2 vf0 vf0 :mask #b1)
           (.mul.vf vf1 vf1 vf1)
           (.mul.x.vf acc vf2 vf1 :mask #b1)
           (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
           (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
           (.mov v1-13 vf1)
           (let ((f0-1 v1-13)
                 (f1-0 0.5)
                 )
             (if (< f0-1 (* f1-0 f1-0))
                 (logclear! (-> this v-flags) (vehicle-flag disturbed))
                 )
             )
           )
         )
        (else
          (when (>= (-> this rbody matrix uvec y) (cos 910.2222))
            (let* ((f0-3 (-> this camera-dist2))
                   (f1-3 0.000024414063)
                   (f0-4 (* f0-3 (* f1-3 f1-3)))
                   )
              (.lvf vf1 (&-> (-> this rbody ang-velocity) quad))
              (.add.w.vf vf2 vf0 vf0 :mask #b1)
              (.mul.vf vf1 vf1 vf1)
              (.mul.x.vf acc vf2 vf1 :mask #b1)
              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
              (.mov v1-25 vf1)
              (when (and (< v1-25 f0-4) (begin
                                          (.lvf vf1 (&-> (-> this rbody lin-velocity) quad))
                                          (.add.w.vf vf2 vf0 vf0 :mask #b1)
                                          (.mul.vf vf1 vf1 vf1)
                                          (.mul.x.vf acc vf2 vf1 :mask #b1)
                                          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                                          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                                          (.mov v1-30 vf1)
                                          (let ((f1-7 v1-30)
                                                (f2-0 614.4)
                                                )
                                            (< f1-7 (* f0-4 (* f2-0 f2-0)))
                                            )
                                          )
                         )
                (logclear! (-> this v-flags) (vehicle-flag disturbed))
                (vehicle-method-142 this)
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-101 ((this hvehicle))
  (let ((gp-0 (-> this draw shadow-ctrl))
        (s4-0 (-> this root))
        (s3-0 (new 'stack-no-clear 'collide-query))
        )
    (logclear! (-> s4-0 status) (collide-status on-ground))
    (cond
      ((above-ground? s4-0 s3-0 (-> s4-0 trans) (collide-spec backgnd) 0.0 102400.0 1024.0)
       (set! (-> s4-0 gspot-pos quad) (-> s4-0 trans quad))
       (set! (-> s4-0 gspot-pos y) (-> s3-0 best-other-tri intersect y))
       (set! (-> s4-0 gspot-normal quad) (-> s3-0 best-other-tri normal quad))
       (set! (-> s4-0 ground-pat) (-> s3-0 best-other-tri pat))
       (when (logtest? (-> gp-0 settings flags) (shadow-flags disable-draw))
         (set! (-> gp-0 settings top-plane w) (- (-> this root trans y) (-> this root gspot-pos y)))
         (set! (-> gp-0 settings bot-plane w) (- (-> this root trans y) (-> this root gspot-pos y)))
         )
       (logclear! (-> gp-0 settings flags) (shadow-flags disable-draw))
       0
       )
      (else
        (let ((v1-18 gp-0))
          (logior! (-> v1-18 settings flags) (shadow-flags disable-draw))
          )
        0
        )
      )
    )
  (none)
  )

(defmethod rigid-body-object-method-30 ((this hvehicle))
  (let ((s5-0 (-> this draw shadow-ctrl)))
    (when (!= *vehicle-shadow-control-disabled* s5-0)
      (let ((s4-0 (new 'stack-no-clear 'inline-array 'vector 2)))
        (set! (-> s4-0 0 y) (vector-vector-xz-distance-squared (camera-pos) (-> this root trans)))
        ;; og:preserve-this shadow cull toggle
        (#when PC_PORT
            (if (not (-> *pc-settings* ps2-shadow?))
                (set! (-> s4-0 0 y) 0.0)))
        (let ((f0-1 245760.0))
          (cond
            ((< (* f0-1 f0-1) (-> s4-0 0 y))
             (logior! (-> s5-0 settings flags) (shadow-flags disable-draw))
             0
             (set! (-> this draw bounds w) (-> this bound-radius))
             )
            (else
              (-> this root)
              (if (or (logtest? (-> s5-0 settings flags) (shadow-flags disable-draw))
                      (let ((a1-1 (-> this clock))
                            (a0-2 (-> this traffic-priority-id))
                            )
                        (not (logtest? (logxor a0-2 (-> a1-1 integral-frame-counter)) 7))
                        )
                      )
                  (vehicle-method-101 this)
                  )
              (set! (-> s4-0 0 x) (sqrtf (-> s4-0 0 y)))
              (when (not (logtest? #x40000 (-> this info flags)))
                (set! (-> this draw bounds w)
                      (lerp-scale
                        (- (-> s5-0 settings center y) (-> this root gspot-pos y))
                        (-> this bound-radius)
                        (-> s4-0 0 x)
                        81920.0
                        122880.0
                        )
                      )
                (if (< (-> this draw bounds w) (-> this bound-radius))
                    (set! (-> this draw bounds w) (-> this bound-radius))
                    )
                )
              (set! (-> s4-0 0 z) (lerp-scale 0.0 1.0 (-> s4-0 0 x) 245760.0 40960.0))
              (set! (-> s4-0 0 z)
                    (fmax 0.01 (+ (* -2.0 (-> s4-0 0 z) (-> s4-0 0 z) (-> s4-0 0 z)) (* 3.0 (-> s4-0 0 z) (-> s4-0 0 z))))
                    )
              (set! (-> s4-0 0 w) (* 4096.0 (+ 5.0 (* 5.0 (- 1.0 (-> this root gspot-normal y))))))
              (set! (-> s4-0 1 x) (- (-> s5-0 settings center y) (-> this root gspot-pos y)))
              (set! (-> s5-0 settings shadow-dir w) (+ 20480.0 (* 409600.0 (-> s4-0 0 z)) (-> s4-0 1 x)))
              (+! (-> s4-0 0 z) 0.5)
              (seek!
                (-> s5-0 settings top-plane w)
                (+ (-> s4-0 1 x) (* (-> s4-0 0 z) (- (-> s4-0 0 w))))
                (* 81920.0 (seconds-per-frame))
                )
              (seek!
                (-> s5-0 settings bot-plane w)
                (+ (-> s4-0 1 x) (* (-> s4-0 0 z) (-> s4-0 0 w)))
                (* 81920.0 (seconds-per-frame))
                )
              )
            )
          )
        )
      )
    )
  ((method-of-type vehicle rigid-body-object-method-30) this)
  )

(defmethod rigid-body-object-method-54 ((this hvehicle))
  (logclear! (-> this v-flags) (vehicle-flag impact))
  (let ((s5-0 (new 'stack-no-clear 'rigid-body-move-work)))
    (set! (-> s5-0 mat trans w) -4096000.0)
    (set! (-> s5-0 cquery start-pos quad) (-> this rbody position quad))
    (vector-float*! (-> s5-0 cquery move-dist) (-> this rbody lin-velocity) (seconds-per-frame))
    (let ((v1-6 (-> s5-0 cquery)))
      (set! (-> v1-6 radius) (+ 4096.0 (-> this root root-prim local-sphere w)))
      (set! (-> v1-6 collide-with) (collide-spec
                                     backgnd
                                     bot
                                     crate
                                     civilian
                                     enemy
                                     obstacle
                                     vehicle-sphere
                                     hit-by-player-list
                                     hit-by-others-list
                                     collectable
                                     blocking-plane
                                     pusher
                                     vehicle-mesh-probeable
                                     shield
                                     vehicle-sphere-no-probe
                                     )
            )
      (set! (-> v1-6 ignore-process0) this)
      (set! (-> v1-6 ignore-process1) #f)
      (set! (-> v1-6 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1))
      (set! (-> v1-6 action-mask) (collide-action solid))
      )
    (if (focus-test? this dead)
        (set! (-> s5-0 cquery ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
        )
    (if (logtest? (-> this v-flags) (vehicle-flag player-touching))
        (logclear! (-> s5-0 cquery collide-with) (collide-spec jak player-list))
        )
    (water-info-init! (-> this root) (the-as water-info (-> s5-0 mat)) (collide-action solid semi-solid))
    (if (and (logtest? (the-as int (-> s5-0 mat trans x)) 1) (logtest? #x20000000 (the-as int (-> s5-0 mat trans x))))
        (set! (-> s5-0 mat trans w) (-> s5-0 mat fvec x))
        )
    (set! (-> this water-height) (-> s5-0 mat trans w))
    (when (< (- (+ (-> s5-0 cquery start-pos y) (fmin 0.0 (-> s5-0 cquery move-dist y))) (-> s5-0 cquery radius))
             (-> s5-0 mat trans w)
             )
      (let ((v1-25
              (new 'static 'water-control :flags (water-flag active swim-ground can-ground over-water) :joint-index 3)
              )
            )
        (logior! (-> s5-0 cquery collide-with) (collide-spec water))
        (set! (-> v1-25 height) (-> s5-0 mat trans w))
        (set! (-> v1-25 collide-height) (-> s5-0 mat trans w))
        (set! (-> this water) v1-25)
        )
      )
    (fill-using-line-sphere *collide-cache* (-> s5-0 cquery))
    )
  (set! (-> this water) (the-as water-control 0))
  0
  (rigid-body-control-method-10 (-> this rbody) this (-> this rbody time-remaining) (-> this max-time-step))
  0
  (none)
  )

(defmethod clear-impulse-force-flag! ((this hvehicle))
  (let ((t9-0 (method-of-type vehicle clear-impulse-force-flag!)))
    (t9-0 this)
    )
  (let ((s5-0 (-> this root)))
    (when (and (logtest? (-> this v-flags) (vehicle-flag player-touching))
               (not (logtest? (vehicle-flag player-driving) (-> this v-flags)))
               )
      (pull-riders! s5-0)
      (cond
        ((logtest? (do-push-aways s5-0) (collide-spec jak))
         (+! (-> this overlap-player-counter) 1)
         (when (< (the-as uint 60) (-> this overlap-player-counter))
           (send-event
             *target*
             'attack-invinc
             #f
             (static-attack-info
               :mask (vehicle-impulse-factor)
               ((id (new-attack-id)) (damage 1000.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'smush))
               )
             )
           (set! (-> this overlap-player-counter) (the-as uint 0))
           0
           )
         )
        (else
          (set! (-> this overlap-player-counter) (the-as uint 0))
          0
          )
        )
      )
    )
  (none)
  )

(defmethod vehicle-method-92 ((this hvehicle) (arg0 vehicle-controls))
  (seek! (-> this controls steering) (-> arg0 steering) (* 8.0 (seconds-per-frame)))
  (seek! (-> this controls lean-z) (-> arg0 lean-z) (* 8.0 (seconds-per-frame)))
  (let ((f0-10 (-> arg0 throttle))
        (f30-0 (-> arg0 brake))
        )
    (set! f30-0
          (cond
            ((< 0.0 f0-10)
             (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
             (if (< 0.0 f30-0)
                 (set! f30-0 0.25)
                 )
             f30-0
             )
            ((< 0.0 f30-0)
             (cond
               ((logtest? (vehicle-flag reverse-gear) (-> this v-flags))
                (let ((f0-11 -0.5)
                      (f1-5 0.0)
                      (f2-0 -40960.0)
                      )
                  (set! f0-10
                        (fmax
                          f0-11
                          (fmin
                            f1-5
                            (* (/ 1.0 f2-0) f30-0 (- 8192.0 (vector-dot (-> this rbody lin-velocity) (-> this rbody matrix fvec))))
                            )
                          )
                        )
                  )
                0.0
                )
               (else
                 (let* ((v1-22 (-> this rbody lin-velocity))
                        (f1-10 (+ (* (-> v1-22 x) (-> v1-22 x)) (* (-> v1-22 z) (-> v1-22 z))))
                        (f2-8 8192.0)
                        )
                   (if (< f1-10 (* f2-8 f2-8))
                       (logior! (-> this v-flags) (vehicle-flag reverse-gear))
                       )
                   )
                 f30-0
                 )
               )
             )
            (else
              (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
              f30-0
              )
            )
          )
    (seek! (-> this controls throttle) f0-10 (* 4.0 (seconds-per-frame)))
    (+! (-> this controls brake) (* (- f30-0 (-> this controls brake)) (fmin 1.0 (* 8.0 (seconds-per-frame)))))
    )
  (set! (-> this controls prev-flags) (-> this controls flags))
  (set! (-> this controls flags) (-> arg0 flags))
  0
  (none)
  )

(defmethod init-reverse ((this hvehicle) (arg0 vehicle-controls))
  (set! (-> arg0 steering) 0.0)
  (set! (-> arg0 lean-z) 0.0)
  (set! (-> arg0 throttle) 0.0)
  (set! (-> arg0 brake) (if (logtest? (-> this v-flags) (vehicle-flag on-ground))
                            1.0
                            0.0
                            )
        )
  (set! (-> arg0 handbrake) 0.0)
  (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
  0
  (none)
  )

(defmethod vehicle-method-88 ((this hvehicle) (arg0 vehicle-controls))
  (when (and (cpad-pressed? 0 r2) (not *pause-lock*))
    (if (zero? (-> this flight-level-index))
        (hvehicle-method-154 this)
        (hvehicle-method-155 this)
        )
    )
  (set! (-> arg0 steering) (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0))
  (set! (-> arg0 lean-z) (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 48.0 110.0 -1.0))
  (set! (-> arg0 throttle) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton (abutton-idx x)))))) ;; og:preserve-this abutton indexing
  (set! (-> arg0 brake) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton (abutton-idx square)))))) ;; og:preserve-this abutton indexing
  (when (or (cpad-hold? 0 l1) (and (logtest? (-> this info flags) 2048) (cpad-hold? 0 r1)))
    (if (logtest? (-> this info flags) 16)
        (logior! (-> arg0 flags) (vehicle-controls-flag vcf0))
        )
    )
  (if (cpad-pressed? 0 circle)
      (vehicle-method-64 this)
      )
  (if (cpad-pressed? 0 r3)
      (set! (-> this v-flags) (the-as vehicle-flag (logxor (shl 1 32) (the-as int (-> this v-flags)))))
      )
  (if (not (-> *setting-control* user-current allow-look-around))
      (set! (-> this v-flags) (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag camera-look-mode))))
      )
  0
  (none)
  )

(defmethod control-hook-player ((this hvehicle))
  (let ((gp-0 (new 'stack-no-clear 'vehicle-controls)))
    (mem-set32! (&-> gp-0 steering) 6 0)
    (cond
      ((or (logtest? (-> this v-flags) (vehicle-flag player-grabbed))
           (and *target* (focus-test? *target* dead grabbed))
           )
       (set! (-> gp-0 steering) 0.0)
       (set! (-> gp-0 lean-z) 0.0)
       (set! (-> gp-0 throttle) 0.0)
       (set! (-> gp-0 brake) (if (logtest? (-> this v-flags) (vehicle-flag on-ground))
                                 1.0
                                 0.0
                                 )
             )
       (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
       )
      ((and (zero? (-> this crash-level)) (not (logtest? (vehicle-flag ai-driving) (-> this v-flags))))
       (vehicle-method-88 this (the-as vehicle-controls (&-> gp-0 steering)))
       )
      )
    (vehicle-method-92 this (the-as vehicle-controls (&-> gp-0 steering)))
    )
  0
  (none)
  )

(defmethod vehicle-method-94 ((this hvehicle))
  (local-vars (v1-14 float) (v1-24 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((f0-0 (the-as number -4096000.0)))
      (dotimes (v1-1 (-> *level* length))
        (let ((a0-4 (-> *level* level v1-1)))
          (when (= (-> a0-4 status) 'active)
            (let ((a0-6 (-> a0-4 bsp city-level-info)))
              (when (nonzero? a0-6)
                (let ((f1-0 (the-as float (-> a0-6 camera-ceiling))))
                  (if (= (the-as meters f1-0) 0.0)
                      (set! f1-0 40960000.0)
                      )
                  (set! f0-0 (fmax (the-as float f0-0) f1-0))
                  )
                )
              )
            )
          )
        )
      (if (>= -4096000.0 (the-as float f0-0))
          (set! f0-0 40960000.0)
          )
      (set-setting! 'string-camera-ceiling 'abs (the-as float f0-0) 0)
      )
    (cond
      ((logtest? (vehicle-flag camera-rapid-tracking-mode) (-> this v-flags))
       (.lvf vf1 (&-> (-> this root transv) quad))
       (.add.w.vf vf2 vf0 vf0 :mask #b1)
       (.mul.vf vf1 vf1 vf1)
       (.mul.x.vf acc vf2 vf1 :mask #b1)
       (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
       (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
       (.mov v1-14 vf1)
       (let ((f0-1 v1-14)
             (f1-2 122880.0)
             )
         (if (< f0-1 (* f1-2 f1-2))
             (vehicle-method-87 this)
             )
         )
       )
      (else
        (let* ((f0-2 143360.0)
               (f0-4 (* f0-2 f0-2))
               )
          (.lvf vf1 (&-> (-> this root transv) quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov v1-24 vf1)
          (if (< f0-4 v1-24)
              (vehicle-method-86 this)
              )
          )
        )
      )
    (let ((t9-3 (method-of-type vehicle vehicle-method-94)))
      (t9-3 this)
      )
    (when *target*
      (let ((v1-31 (math-camera-matrix))
            (a0-17 (new 'stack-no-clear 'matrix))
            )
        (set! (-> a0-17 uvec quad) (-> *target* alt-cam-pos quad))
        (vector-! (-> a0-17 rvec) (-> a0-17 uvec) (-> v1-31 trans))
        (let ((f0-7 (/ (vector-dot (-> a0-17 rvec) (-> v1-31 uvec)) (vector-dot (-> a0-17 rvec) (-> v1-31 fvec)))))
          (cond
            ((and (< f0-7 0.15) (< -0.5 f0-7))
             (set-setting! 'vertical-follow-matches-camera #f 0.0 0)
             )
            (else
              (if (< (fabs (-> this root transv y)) 8192.0)
                  (remove-setting! 'vertical-follow-matches-camera)
                  )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-93 ((this hvehicle))
  (let ((t9-0 (method-of-type vehicle vehicle-method-93)))
    (t9-0 this)
    )
  (cond
    ((logtest? (vehicle-flag ignition) (-> this v-flags))
     (-> this controls throttle)
     (let* ((f1-2
              (fmax
                0.0
                (fmin 1.0 (/ (* (vector-length (-> this rbody lin-velocity)) (-> this info handling engine-intake-factor))
                             (-> this info handling max-xz-speed)
                             )
                      )
                )
              )
            (f1-5 (fmin (-> this controls throttle) (* 0.83333 (+ 0.5 f1-2))))
            )
       0
       (if (logtest? (vehicle-flag turbo-boost) (-> this v-flags))
           (set! f1-5 (+ 1.0 (* (-> this turbo-boost-factor) (-> this info handling turbo-boost-factor))))
           )
       (if (< (-> this engine-thrust) f1-5)
           (+! (-> this engine-thrust)
               (* (- f1-5 (-> this engine-thrust))
                  (fmin 1.0 (* (-> this info handling engine-response-rate) (seconds-per-frame)))
                  )
               )
           (seek! (-> this engine-thrust) f1-5 (seconds-per-frame))
           )
       )
     )
    (else
      (set! (-> this engine-thrust) 0.0)
      )
    )
  (set! (-> this engine-power-factor) (fabs (-> this engine-thrust)))
  (when (logtest? (vehicle-flag flight-level-transition) (-> this v-flags))
    (if (or (and (> (-> this flight-level-index) 0)
                 (< (fabs (- (-> this flight-level) (-> this rbody position y))) 8192.0)
                 (< (fabs (-> this rbody lin-velocity y)) 8192.0)
                 )
            (and (zero? (-> this flight-level-index)) (logtest? (-> this v-flags) (vehicle-flag on-ground)))
            )
        (hvehicle-method-153 this)
        )
    (when (and (> (-> this flight-level-index) 0) (time-elapsed? (-> this transition-time) (seconds 2)))
      (hvehicle-method-153 this)
      (hvehicle-method-156 this)
      )
    )
  (when (and (logtest? (vehicle-flag flight-level-transition-ending) (-> this v-flags))
             (time-elapsed? (-> this transition-end-time) (seconds 1))
             )
    (logclear! (-> this v-flags) (vehicle-flag flight-level-transition-ending))
    (vehicle-method-87 this)
    )
  (if (and (logtest? (-> this controls flags) (vehicle-controls-flag vcf0)) (< 0.0 (-> this jump-time)))
      (set! (-> this jump-thrust) 1.0)
      (set! (-> this jump-thrust) 0.0)
      )
  (cond
    ((logtest? (-> this controls flags) (vehicle-controls-flag vcf0))
     (seek! (-> this jump-time) 0.0 (seconds-per-frame))
     )
    ((not (logtest? (-> this v-flags) (vehicle-flag in-air)))
     (seek! (-> this jump-time) 0.1 (* 0.5 (seconds-per-frame)))
     )
    )
  0
  (none)
  )

(defmethod hvehicle-method-157 ((this hvehicle))
  (let ((a1-0 (-> this clock))
        (a0-1 (-> this traffic-priority-id))
        )
    (when (not (logtest? (logxor a0-1 (-> a1-0 integral-frame-counter)) 7))
      (let ((a1-2 (-> this root trans)))
        (set! (-> this flight-level) (get-height-at-point *traffic-height-map* a1-2))
        )
      )
    )
  (set! (-> this target-acceleration y)
        (- (* 8.0 (- (-> this flight-level) (-> this root trans y))) (-> this root transv y))
        )
  (vector-v++! (-> this root transv) (-> this target-acceleration))
  (vector-v++! (-> this root trans) (-> this root transv))
  (let* ((v1-14 (-> this root transv))
         (f30-0 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
         (s5-0 (new 'stack-no-clear 'matrix))
         )
    (when (< 40.96 f30-0)
      (vector-float*! (-> s5-0 uvec) (-> this root transv) (/ 1.0 f30-0))
      (quaternion-set! (the-as quaternion (-> s5-0 rvec)) 0.0 (-> s5-0 uvec x) 0.0 (+ 1.0 (-> s5-0 uvec z)))
      (quaternion-normalize! (the-as quaternion (-> s5-0 rvec)))
      (quaternion-rotate-local-z!
        (the-as quaternion (-> s5-0 rvec))
        (the-as quaternion (-> s5-0 rvec))
        (* -0.08886719 (-> this controls steering) (fmin 81920.0 f30-0))
        )
      (quaternion-smooth-seek!
        (-> this root quat)
        (-> this root quat)
        (the-as quaternion (-> s5-0 rvec))
        (* 0.00014686584 (seconds-per-frame) f30-0)
        )
      )
    )
  0
  (none)
  )

(defmethod control-hook-ai ((this hvehicle) (arg0 vehicle-controls))
  (let ((s5-0 (new 'stack-no-clear 'vehicle-physics-work)))
    (mem-set32! (the-as pointer (-> s5-0 mat)) 6 0)
    (set! (-> s5-0 mat trans quad) (-> this rbody matrix rvec quad))
    (set! (-> s5-0 force quad) (-> this rbody matrix fvec quad))
    (let ((f28-0 (* (-> this rbody ang-velocity y) (vector-length (-> this rbody lin-velocity))))
          (f30-0 (seconds-per-frame))
          )
      (when (zero? (-> this flight-level-index))
        (if (logtest? (-> this v-flags) (vehicle-flag riding))
            (hvehicle-method-154 this)
            )
        )
      (vector-! (-> s5-0 mat fvec) (-> this target-acceleration) (-> this lin-acceleration))
      (let ((f0-3 (* 0.00006 (vector-dot (-> s5-0 force) (-> s5-0 mat fvec)) f30-0)))
        (set! (-> s5-0 mat rvec y) (fmax 0.0 (fmin 1.0 (* 20.0 f0-3))))
        (set! (-> s5-0 mat rvec z) (fmax 0.0 (fmin 1.0 (* -40.0 f0-3))))
        (if (= this *debug-actor*)
            (format *stdcon* "delta-throttle ~f~%" f0-3)
            )
        )
      (when (logtest? (-> this v-flags) (vehicle-flag player-edge-grabbing))
        (set! (-> s5-0 mat rvec y) 0.0)
        (set! (-> s5-0 mat rvec z) 1.0)
        (logclear! (-> this v-flags) (vehicle-flag reverse-gear))
        )
      (let ((f0-7 (* 6.0 f30-0))
            (f4-0 (* 0.00018024445
                     (- (vector-dot (-> s5-0 mat trans) (-> this target-acceleration)) f28-0)
                     (if (< (-> this controls throttle) 0.0)
                         -1.0
                         1.0
                         )
                     f30-0
                     )
                  )
            )
        (set! (-> s5-0 mat rvec x)
              (fmax -1.0 (fmin 1.0 (+ (-> this controls steering) (fmax (fmin f4-0 f0-7) (- f0-7)))))
              )
        )
      )
    (set! (-> s5-0 mat rvec w) 0.0)
    (vehicle-method-92 this (the-as vehicle-controls (-> s5-0 mat)))
    (when (= this *debug-actor*)
      (let ((v1-43 (-> s5-0 mat)))
        (format *stdcon* "steer ~f, throttle ~f, brake ~f~%" (-> v1-43 rvec x) (-> v1-43 rvec y) (-> v1-43 rvec z))
        )
      (let ((v1-45 (-> this controls)))
        (format *stdcon* "steer ~f, throttle ~f, brake ~f~%" (-> v1-45 steering) (-> v1-45 throttle) (-> v1-45 brake))
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-117 ((this hvehicle))
  (let ((t9-0 (method-of-type vehicle vehicle-method-117)))
    (t9-0 this)
    )
  (set! (-> this v-flags)
        (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag sounds particles joints)))
        )
  (let ((f0-0 (-> this player-dist2))
        (f1-0 245760.0)
        )
    (if (< f0-0 (* f1-0 f1-0))
        (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag sounds) (-> this v-flags))))
        )
    )
  (when (logtest? (-> this draw status) (draw-control-status on-screen))
    (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag particles) (-> this v-flags))))
    (let ((f0-1 (-> this camera-dist2))
          (f1-3 245760.0)
          )
      (if (< f0-1 (* f1-3 f1-3))
          (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag joints) (-> this v-flags))))
          )
      )
    )
  (let ((a1-0 (-> this rbody position)))
    (set! (-> this flight-level) (get-height-at-point *traffic-height-map* a1-0))
    )
  0
  (none)
  )

(defmethod hvehicle-method-159 ((this hvehicle))
  (local-vars (a0-28 int) (a0-30 int) (a0-40 int) (a0-42 int) (a0-45 int) (a0-47 int))
  (let* ((v1-1 (-> *perf-stats* data 37))
         (a0-1 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-1) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-1)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (set! (-> this camera-dist2) (vector-vector-distance-squared (-> this root trans) (camera-pos)))
  (set! (-> this player-dist2) (vector-vector-distance-squared (-> this root trans) (target-pos 0)))
  (let ((a0-5 (-> this controller))
        (t9-4 (method-of-type vehicle-controller vehicle-controller-method-18))
        (a1-4 (-> this target-acceleration))
        )
    (t9-4 a0-5 a1-4 (-> this root transv) this (/ 1.0 (seconds-per-frame)))
    (cond
      ((logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
       (if (not (vehicle-method-102 this))
           (disable-physics! this)
           )
       )
      (else
        (if (vehicle-method-102 this)
            (apply-momentum! this)
            )
        )
      )
    (cond
      ((logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
       (control-hook-ai this (the-as vehicle-controls a1-4))
       (vehicle-method-103 this)
       (vehicle-method-117 this)
       )
      (else
        (let ((f1-3
                (* 0.000024414063
                   (vector-dot (the-as vector (-> this node-list data 0 bone transform)) (-> this target-acceleration))
                   )
                )
              )
          (+! (-> this controls steering) (* 0.1 (- f1-3 (-> this controls steering))))
          )
        (set! (-> this controls steering) (fmax -1.0 (fmin 1.0 (-> this controls steering))))
        (let* ((v1-42 (-> *perf-stats* data 19))
               (a0-14 (-> v1-42 ctrl))
               )
          (+! (-> v1-42 count) 1)
          (b! (zero? a0-14) cfg-12 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mtpc pcr0 0)
          (.mtpc pcr1 0)
          (.sync.l)
          (.sync.p)
          (.mtc0 Perf a0-14)
          )
        (.sync.l)
        (.sync.p)
        (label cfg-12)
        0
        (hvehicle-method-157 this)
        (set! (-> this v-flags)
              (the-as vehicle-flag (logclear (-> this v-flags) (vehicle-flag sounds particles joints)))
              )
        (let ((f0-9 (-> this player-dist2))
              (f1-8 245760.0)
              )
          (cond
            ((< f0-9 (* f1-8 f1-8))
             (let ((f0-10 (vector-length (-> this root transv))))
               (seek! (-> this engine-power-factor) (/ f0-10 (meters 15)) (* 6.0 (seconds-per-frame)))
               )
             (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag sounds) (-> this v-flags))))
             (rigid-body-object-method-38 this)
             )
            (else
              (if (logtest? (vehicle-flag sounds) (-> this unknown-flags))
                  (vehicle-method-106 this)
                  )
              )
            )
          )
        (when (logtest? (-> this draw status) (draw-control-status on-screen))
          (when #t
            (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
            (set! (-> this v-flags) (the-as vehicle-flag (logior (vehicle-flag particles) (-> this v-flags))))
            (vehicle-method-78 this)
            )
          )
        (let ((v1-83 (-> *perf-stats* data 19)))
          (b! (zero? (-> v1-83 ctrl)) cfg-21 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mfpc a0-28 pcr0)
          (+! (-> v1-83 accum0) a0-28)
          (.mfpc a0-30 pcr1)
          (+! (-> v1-83 accum1) a0-30)
          )
        (label cfg-21)
        0
        (let* ((v1-86 (-> *perf-stats* data 20))
               (a0-32 (-> v1-86 ctrl))
               )
          (+! (-> v1-86 count) 1)
          (b! (zero? a0-32) cfg-23 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mtpc pcr0 0)
          (.mtpc pcr1 0)
          (.sync.l)
          (.sync.p)
          (.mtc0 Perf a0-32)
          )
        (.sync.l)
        (.sync.p)
        (label cfg-23)
        0
        (rigid-body-object-method-30 this)
        (update-transforms (-> this root))
        (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
        (vehicle-method-115 this)
        (let ((v1-98 (-> *perf-stats* data 20)))
          (b! (zero? (-> v1-98 ctrl)) cfg-25 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mfpc a0-40 pcr0)
          (+! (-> v1-98 accum0) a0-40)
          (.mfpc a0-42 pcr1)
          (+! (-> v1-98 accum1) a0-42)
          )
        (label cfg-25)
        0
        )
      )
    )
  (let ((v1-101 (-> *perf-stats* data 37)))
    (b! (zero? (-> v1-101 ctrl)) cfg-28 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-45 pcr0)
    (+! (-> v1-101 accum0) a0-45)
    (.mfpc a0-47 pcr1)
    (+! (-> v1-101 accum1) a0-47)
    )
  (label cfg-28)
  0
  0
  (none)
  )

(defmethod alloc-rbody-control! ((this hvehicle) (arg0 rigid-body-object-constants))
  (let ((t9-0 (method-of-type vehicle alloc-rbody-control!)))
    (t9-0 this arg0)
    )
  (vehicle-method-101 this)
  (set! (-> this engine-sound-id) (new 'static 'sound-id))
  (set! (-> this thrust-sound-id) (new 'static 'sound-id))
  (set! (-> this roll-sound-id) (new 'static 'sound-id))
  (set! (-> this extra-sound-id) (new 'static 'sound-id))
  (set! (-> this damage-pop-sound-id) (new-sound-id))
  (set! (-> this squad) *ff-squad-control*)
  (set! (-> this jump-thrust) 1.0)
  (if (not (-> this squad))
      (format 0 "hvehicle::initialize-rigid-body: error: no squad-control~%")
      )
  (vehicle-controller-method-9 (-> this controller))
  (set! (-> this controller target-speed-offset)
        (* (rand-vu) (-> (the-as rigid-body-vehicle-constants arg0) target-speed-offset))
        )
  (if (zero? (-> this draw light-index))
      (set! (-> this draw light-index) (the-as uint 10))
      )
  (none)
  )

(defmethod touch-handler ((this hvehicle) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (b!
    (or (not (logtest? (process-mask target crate enemy guard civilian) (-> arg0 mask)))
        (and (logtest? (-> arg0 mask) (process-mask target)) (focus-test? arg0 dangerous pilot))
        )
    cfg-32
    :delay (nop!)
    )
  (let ((s5-0 (new 'stack-no-clear 'vehicle-physics-work)))
    (set! (-> s5-0 velocity x) (get-inv-mass arg0))
    (init-rbody-impact-from-tshape! this (the-as rigid-body-impact (-> s5-0 mat)) arg1)
    (if (logtest? (-> this rbody flags) (rigid-body-flag enable-physics))
        (rigid-body-control-method-23 (-> this rbody) (the-as vector (-> s5-0 mat)) (-> s5-0 mat fvec))
        (set! (-> s5-0 mat fvec quad) (-> this root transv quad))
        )
    (let ((v1-17 (-> arg0 root)))
      (set! (-> s5-0 force quad) (-> v1-17 transv quad))
      (vector-! (-> s5-0 mat fvec) (-> v1-17 transv) (-> s5-0 mat fvec))
      )
    (let ((f0-2 (vector-dot (-> s5-0 mat fvec) (-> s5-0 mat uvec))))
      (when (< f0-2 0.0)
        (set! (-> s5-0 mat trans x) (* -1.0 (/ 1.0 (+ (-> s5-0 velocity x) (-> this info info inv-mass))) f0-2))
        (vector+float*!
          (-> s5-0 force)
          (-> s5-0 force)
          (-> s5-0 mat uvec)
          (* 3.1 (-> s5-0 velocity x) (-> s5-0 mat trans x))
          )
        (set! (-> s5-0 force y) (fmax (* 49152.0 (-> s5-0 velocity x)) (-> s5-0 force y)))
        (when (or (logtest? (vehicle-flag in-pursuit) (-> this v-flags)) (!= arg0 *target*))
          (set! (-> s5-0 velocity y) (the-as float (current-time)))
          (when (>= (- (the-as uint (-> s5-0 velocity y)) (the-as uint (-> this sent-attack-time))) (the-as uint 150))
            (set! (-> this sent-attack-time) (the-as uint (current-time)))
            (let* ((v1-41 *game-info*)
                   (a0-18 (+ (-> v1-41 attack-id) 1))
                   )
              (set! (-> v1-41 attack-id) a0-18)
              (set! (-> this outgoing-attack-id) a0-18)
              )
            )
          (let ((f0-11 (+ 0.5 (/ (-> s5-0 mat trans x) (meters 10)))))
            (when (send-event
                    arg0
                    'attack
                    arg1
                    (static-attack-info :mask (vehicle-impulse-factor) ((id (-> this outgoing-attack-id))
                                                                        (damage f0-11)
                                                                        (vehicle-damage-factor 1.0)
                                                                        (vehicle-impulse-factor 1.0)
                                                                        (attacker (process->handle (find-rider this)))
                                                                        (mode 'vehicle)
                                                                        (vector (-> s5-0 force))
                                                                        (penetrate-using (penetrate vehicle))
                                                                        )
                                        )
                    )
              )
            )
          )
        (impulse-handler this)
        (let ((a2-4 (new 'stack-no-clear 'vector)))
          (vector-float*! a2-4 (-> s5-0 mat uvec) (* -1.0 (-> s5-0 mat trans x)))
          (apply-impact! (-> this rbody) (the-as vector (-> s5-0 mat)) a2-4)
          )
        (rigid-body-control-method-12 (-> this rbody) 1.0)
        (init-velocities! (-> this rbody))
        (when #f
          (set-time! (-> *debug-vehicle-work* impact-time))
          (mem-copy! (the-as pointer (-> *debug-vehicle-work* impact)) (the-as pointer (-> s5-0 mat)) 64)
          (let ((v1-75 (-> arg1 head)))
            (set! (-> *debug-vehicle-work* prim-sphere1 quad) (-> v1-75 prim1 cprim prim-core world-sphere quad))
            (set! (-> *debug-vehicle-work* prim-sphere2 quad) (-> v1-75 prim2 cprim prim-core world-sphere quad))
            )
          (add-debug-x #t (bucket-id debug-no-zbuf1) (the-as vector (-> s5-0 mat)) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (the-as vector (-> s5-0 mat))
            (-> s5-0 mat uvec)
            (-> s5-0 mat trans x)
            *color-blue*
            )
          )
        (on-impact this (the-as rigid-body-impact (-> s5-0 mat)))
        (if (and (-> this next-state) (= (-> this next-state name) 'idle))
            (go (method-of-object this waiting))
            )
        )
      )
    )
  (label cfg-32)
  #t
  )

(defmethod rbody-event-handler ((this hvehicle) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('traffic-off)
     (when (not (logtest? (-> this v-flags) (vehicle-flag persistent)))
       (cond
         ((logtest? (-> this v-flags) (vehicle-flag dead))
          (go (method-of-object this die))
          )
         (else
           (if (logtest? (vehicle-flag ai-driving) (-> this v-flags))
               (vehicle-method-109 this)
               )
           )
         )
       )
     )
    (('traffic-off-force)
     (vehicle-method-109 this)
     )
    (('traffic-activate)
     (set! (-> this controller traffic) (the-as traffic-engine (-> arg3 param 1)))
     (logior! (-> this v-flags) (vehicle-flag traffic-managed))
     (let ((s5-0 (the-as traffic-object-spawn-params (-> arg3 param 0))))
       (set! (-> this root trans quad) (-> s5-0 position quad))
       (quaternion-copy! (-> this root quat) (-> s5-0 rotation))
       (set! (-> this root transv quad) (-> s5-0 velocity quad))
       (hvehicle-method-161 this s5-0)
       )
     )
    (('turbo-ring)
     (set! (-> this turbo-boost-factor) (the-as float (-> arg3 param 0)))
     (set! (-> this turbo-boost-time) (the-as uint (current-time)))
     (set! (-> this turbo-boost-duration) (the-as uint 75))
     (logior! (-> this v-flags) (vehicle-flag turbo-boost))
     (if (logtest? (vehicle-flag player-driving) (-> this v-flags))
         (sound-play "boost-ring")
         )
     )
    (('rider-off)
     (send-event (ppointer->process (-> this child)) 'rider-off)
     )
    (('rider-on)
     (send-event (ppointer->process (-> this child)) 'rider-on)
     )
    (else
      ((method-of-type vehicle rbody-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defstate active (hvehicle)
  :virtual #t
  :event vehicle-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (vehicle-method-135 self)
    (logior! (-> self v-flags) (vehicle-flag riding ai-driving))
    (vehicle-method-138 self)
    (set! (-> self flight-level-index) 1)
    )
  :exit (behavior ()
    (vehicle-controller-method-11 (-> self controller))
    )
  :trans #f
  :code sleep-code
  :post (behavior ()
    (vehicle-method-129 self)
    (hvehicle-method-159 self)
    )
  )

(defstate waiting (hvehicle)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type vehicle waiting) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (hvehicle-method-156 self)
    )
  )

(defstate player-control (hvehicle)
  :virtual #t
  :enter (behavior ()
    (set! (-> self damage-factor) (* 0.7518797 (-> self damage-factor)))
    (let ((t9-0 (-> (method-of-type vehicle player-control) enter)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type vehicle player-control) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self damage-factor) (* 1.33 (-> self damage-factor)))
    (hvehicle-method-156 self)
    )
  )

(defstate explode (hvehicle)
  :virtual #t
  :enter (behavior ()
    (rlet ((vf0 :class vf))
      (init-vf0-vector)
      (call-parent-state-handler enter)
      (let ((gp-0 (-> self child)))
        (while gp-0
          (send-event (ppointer->process gp-0) 'traffic-off)
          (set! gp-0 (-> gp-0 0 brother))
          )
        )
      (impulse-handler self)
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            (gp-1 (-> self rbody))
            )
        (set! (-> gp-1 linear-damping) 0.99)
        (set! (-> gp-1 angular-damping) 0.97)
        (vector-reset! s4-0)
        (set! (-> s4-0 y) 163840.0)
        (dotimes (s3-0 3)
          (set! (-> s5-0 data s3-0) (* 4096.0 (+ -1.0 (* 2.0 (rand-vu)))))
          )
        (vector+! s5-0 s5-0 (-> gp-1 position))
        (apply-impact! gp-1 s5-0 s4-0)
        (rigid-body-control-method-12 gp-1 1.0)
        (init-velocities! gp-1)
        )
      (let ((a0-8 (-> self draw color-mult)))
        (vector-float*! (the-as vector a0-8) (the-as vector a0-8) 0.25)
        )
      (let ((gp-2 (new 'stack-no-clear 'explosion-init-params)))
        (set! (-> gp-2 spawn-point quad) (-> self root trans quad))
        (quaternion-identity! (-> gp-2 spawn-quat))
        (set! (-> gp-2 radius) (+ 12288.0 (-> self root root-prim local-sphere w)))
        (set! (-> gp-2 scale) (/ (-> self draw bounds w) 11264))
        (set! (-> gp-2 group) (-> *part-group-id-table* (-> self info explosion-part)))
        (set! (-> gp-2 collide-with)
              (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
              )
        (set! (-> gp-2 damage) 2.0)
        (set! (-> gp-2 damage-scale) 1.0)
        (set! (-> gp-2 vehicle-damage-factor) 1.0)
        (set! (-> gp-2 vehicle-impulse-factor) 1.0)
        (set! (-> gp-2 ignore-proc) (process->handle #f))
        (explosion-spawn gp-2 (the-as process-drawable *default-pool*))
        )
      (let ((gp-3 (-> self info explosion)))
        (when gp-3
          (set! (-> gp-3 skel)
                (the-as skeleton-group (art-group-get-by-name *level* (-> gp-3 skel-name) (the-as (pointer level) #f)))
                )
          (let ((s5-1 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
            (set! (-> s5-1 duration) (seconds 4))
            (set! (-> s5-1 gravity) -327680.0)
            (set! (-> s5-1 rot-speed) 10.2)
            (set-vector! (-> s5-1 fountain-rand-transv-lo) -81920.0 61440.0 -81920.0 1.0)
            (set-vector! (-> s5-1 fountain-rand-transv-hi) 81920.0 131072.0 81920.0 1.0)
            (let ((v1-64
                    (process-spawn joint-exploder (-> gp-3 skel) (-> gp-3 anim) s5-1 gp-3 :name "joint-exploder" :to self :unk 0)
                    )
                  )
              (when v1-64
                (let ((v1-67 (-> (the-as joint-exploder (-> v1-64 0)) draw)))
                  (if v1-67
                      (.svf (&-> (-> v1-67 color-mult) quad) vf0)
                      )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
