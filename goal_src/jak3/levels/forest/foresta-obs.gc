;;-*-Lisp-*-
(in-package goal)

;; name: foresta-obs.gc
;; name in dgo: foresta-obs
;; dgos: FRSTA

(declare-type for-tower process-drawable)

;; DECOMP BEGINS

(deftype water-anim-for (water-anim)
  ()
  )


(define ripple-for-water-anim-for (new 'static 'ripple-wave-set
                                    :count 3
                                    :converted #f
                                    :normal-scale 2.5
                                    :wave (new 'static 'inline-array ripple-wave 4
                                      (new 'static 'ripple-wave :scale 20.0 :xdiv 1 :speed 1.5)
                                      (new 'static 'ripple-wave :scale 20.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                      (new 'static 'ripple-wave :scale 10.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                      (new 'static 'ripple-wave)
                                      )
                                    )
        )

;; WARN: Return type mismatch ripple-wave-set vs object.
(defmethod init-water! ((this water-anim-for))
  (let ((t9-0 (method-of-type water-anim init-water!)))
    (t9-0 this)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> this draw ripple) v1-2)
    (set-vector! (-> this draw color-mult) 0.5 0.5 0.5 1.0)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (let ((v0-2 ripple-for-water-anim-for))
      (set! (-> v1-2 waveform) v0-2)
      v0-2
      )
    )
  )

(deftype water-anim-for-a (water-anim-for)
  ()
  )


(deftype water-anim-for-b (water-anim-for)
  ()
  )


(deftype water-anim-for-c (water-anim-for)
  ()
  )


(deftype water-anim-for-d (water-anim-for)
  ()
  )


(deftype water-anim-for-e (water-anim-for)
  ()
  )


(deftype water-anim-for-f (water-anim-for)
  ()
  )


(deftype for-log (process-drawable)
  ((root              collide-shape-moving :override)
   (shakers           shaker                4 :inline)
   (last-ridden-time  time-frame)
   (water-anim        entity-actor)
   )
  (:state-methods
    idle
    active
    )
  (:methods
    (init-collision! (_type_) none)
    (event-handler (_type_ process int symbol event-message-block) object)
    (get-water-height (_type_ vector) float)
    )
  )


(defskelgroup skel-for-log for-log 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 12.5))

(defun for-log-callback ((arg0 cspace) (arg1 transformq))
  (let ((s4-0 (-> arg0 param1))
        (s3-0 (the-as object (-> arg0 param2)))
        )
    (quaternion*!
      (-> arg1 quat)
      (-> arg1 quat)
      (quaternion-vector-angle!
        (the-as quaternion (new 'stack-no-clear 'vector))
        (the-as vector (-> (the-as for-log s4-0) shakers (the-as int s3-0)))
        (-> (the-as for-log s4-0) shakers (the-as int s3-0) shake)
        )
      )
    (quaternion-rotate-local-y!
      (-> arg1 quat)
      (-> arg1 quat)
      (-> (the-as for-log s4-0) shakers (the-as int s3-0) y-shake)
      )
    (if (< (the int (-> (the-as for-log s4-0) shakers (the-as int s3-0) decay-time))
           (- (current-time) (-> (the-as for-log s4-0) shakers (the-as int s3-0) start-time))
           )
        (set! (-> arg0 param0) #f)
        )
    )
  (cspace<-parented-transformq-joint! arg0 arg1)
  0
  (none)
  )

(defbehavior for-log-event-handler for-log ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (event-handler self arg0 arg1 arg2 arg3)
  )

(defstate idle (for-log)
  :virtual #t
  :event for-log-event-handler
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (sleep-code)
    )
  :post (behavior ()
    (dotimes (gp-0 4)
      (shaker-method-9 (-> self shakers gp-0))
      )
    (transform-post)
    )
  )

(defstate active (for-log)
  :virtual #t
  :event for-log-event-handler
  :trans (behavior ()
    (if (time-elapsed? (-> self last-ridden-time) (seconds 5))
        (go-virtual idle)
        )
    )
  :code sleep-code
  :post (behavior ()
    (dotimes (gp-0 4)
      (shaker-method-9 (-> self shakers gp-0))
      )
    (ja-post)
    )
  )

(defmethod event-handler ((this for-log) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('ridden 'edge-grabbed)
     (set-time! (-> this last-ridden-time))
     (if (not (and (-> this next-state) (= (-> this next-state name) 'active)))
         (go (method-of-object this active))
         )
     )
    (('bonk 'attack)
     (let ((v1-10 arg0))
       (when (and v1-10 (or (= arg2 'bonk) (if (= (-> this shakers 0 shake) 0.0)
                                               #t
                                               #f
                                               )
                            )
                  )
         (let ((s5-0 (new 'stack-no-clear 'vector)))
           (vector-inv-orient-by-quat!
             s5-0
             (vector-cross!
               (new 'stack-no-clear 'vector)
               (vector-normalize!
                 (vector-! (new 'stack-no-clear 'vector) (-> (the-as process-drawable v1-10) root trans) (-> this root trans))
                 1.0
                 )
               *up-vector*
               )
             (-> this root quat)
             )
           (let ((v1-15 (-> this shakers)))
             (set! (-> v1-15 0 axis quad) (-> s5-0 quad))
             (set-time! (-> v1-15 0 start-time))
             (set! (-> v1-15 0 decay-time) 300.0)
             (set! (-> v1-15 0 freq) 150.0)
             (set! (-> v1-15 0 amplitude) 1820.4445)
             (set! (-> v1-15 0 y-amplitude) 910.2222)
             )
           (let ((a0-21 (-> this node-list data 4)))
             (set! (-> a0-21 param0) for-log-callback)
             (set! (-> a0-21 param1) this)
             (set! (-> a0-21 param2) (the-as basic 0))
             )
           (let ((v1-18 (-> this shakers 1)))
             (set! (-> v1-18 axis quad) (-> s5-0 quad))
             (set! (-> v1-18 start-time) (+ (current-time) (seconds -0.06)))
             (set! (-> v1-18 decay-time) 600.0)
             (set! (-> v1-18 freq) 150.0)
             (set! (-> v1-18 amplitude) 364.0889)
             (set! (-> v1-18 y-amplitude) 0.0)
             (set! (-> v1-18 y-decay-time) 450.0)
             (set! (-> v1-18 y-freq) 150.0)
             (set! (-> v1-18 y-amplitude) 3640.889)
             )
           (let ((v1-20 (-> this node-list data 5)))
             (set! (-> v1-20 param0) for-log-callback)
             (set! (-> v1-20 param1) this)
             (set! (-> v1-20 param2) (the-as basic 1))
             )
           (let ((v1-21 (-> this shakers 2)))
             (set! (-> v1-21 axis quad) (-> s5-0 quad))
             (set! (-> v1-21 start-time) (+ (current-time) (seconds -0.2)))
             (set! (-> v1-21 decay-time) 600.0)
             (set! (-> v1-21 freq) 150.0)
             (set! (-> v1-21 amplitude) 364.0889)
             (set! (-> v1-21 y-decay-time) 450.0)
             (set! (-> v1-21 y-freq) 150.0)
             (set! (-> v1-21 y-amplitude) 3640.889)
             )
           (let ((v1-23 (-> this node-list data 6)))
             (set! (-> v1-23 param0) for-log-callback)
             (set! (-> v1-23 param1) this)
             (set! (-> v1-23 param2) (the-as basic 2))
             )
           (let ((v1-24 (-> this shakers 3)))
             (set! (-> v1-24 axis quad) (-> s5-0 quad))
             (set! (-> v1-24 start-time) (+ (current-time) (seconds -0.2)))
             (set! (-> v1-24 decay-time) 600.0)
             (set! (-> v1-24 freq) 150.0)
             (set! (-> v1-24 amplitude) 364.0889)
             (set! (-> v1-24 y-decay-time) 450.0)
             (set! (-> v1-24 y-freq) 150.0)
             (set! (-> v1-24 y-amplitude) 3640.889)
             )
           )
         (let ((v0-0 (the-as object (-> this node-list data 7))))
           (set! (-> (the-as cspace v0-0) param0) for-log-callback)
           (set! (-> (the-as cspace v0-0) param1) this)
           (set! (-> (the-as cspace v0-0) param2) (the-as basic 3))
           v0-0
           )
         )
       )
     )
    )
  )

(defmethod init-collision! ((this for-log))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 51200.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod get-water-height ((this for-log) (arg0 vector))
  (let ((v1-0 (-> this water-anim)))
    0.0
    (cond
      (v1-0
        (let* ((a2-0 v1-0)
               (a0-1 (if a2-0
                         (-> a2-0 extra process)
                         )
                     )
               )
          (if a0-1
              (get-ripple-height (the-as water-anim a0-1) arg0)
              (-> v1-0 extra trans y)
              )
          )
        )
      (else
        (get-height *ocean* arg0 #t)
        )
      )
    )
  )

(defmethod init-from-entity! ((this for-log) (arg0 entity-actor))
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-for-log" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this water-anim) (entity-actor-lookup (-> this entity) 'water-actor 0))
  (go (method-of-object this idle))
  )

(deftype for-jump-pad (jump-pad)
  ()
  )


(defskelgroup skel-for-jump-pad for-jump-pad 0 3
              ((1 (meters 20)) (2 (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defmethod get-fan-joint-idx ((this for-jump-pad))
  4
  )

(defmethod get-skel ((this for-jump-pad))
  (art-group-get-by-name *level* "skel-for-jump-pad" (the-as (pointer level) #f))
  )

(defmethod init-collision! ((this for-jump-pad))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 0)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 8))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action))
      (set-vector! (-> v1-10 local-sphere) 0.0 4096.0 0.0 10240.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype for-pillar (process-drawable)
  ((extend-height   meters)
   (id              int32)
   (sound-id        uint32)
   (last-ride-time  uint64)
   (ridden?         basic)
   )
  (:state-methods
    idle
    rise
    complete
    )
  (:methods
    (get-skel (_type_) art-group)
    (init-collision! (_type_) none)
    )
  )


(defskelgroup skel-for-pillar for-pillar for-pillar-lod0-jg for-pillar-idle-ja
              ((for-pillar-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -20 0 30)
              :origin-joint-index 3
              )

(defbehavior for-pillar-event-handler for-pillar ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('ridden)
     (when (task-node-closed? (game-task-node forest-ring-chase-statue-5))
       (when (and (and (nonzero? (-> self id)) (!= (-> self id) 5))
                  (or (task-node-open? (game-task-node forest-ring-chase-resolution))
                      (task-node-open? (game-task-node forest-turn-on-machine-resolution))
                      )
                  )
         (let ((v1-7 (handle->process (-> (the-as focus (-> arg3 param 0)) handle))))
           (when (= (-> v1-7 type) target)
             (set! (-> self last-ride-time) (the-as uint (current-time)))
             (when (not (-> self ridden?))
               (set! (-> self ridden?) (the-as basic #t))
               (when (and (-> self next-state) (= (-> self next-state name) 'complete))
                 (set! (-> self extend-height)
                       (+ 4096.0 (res-lump-float (-> self entity) 'height) (-> self entity extra trans y))
                       )
                 (go-virtual rise)
                 )
               )
             )
           )
         #t
         )
       )
     )
    (('trigger)
     (logclear! (-> self mask) (process-mask actor-pause))
     (set! (-> self extend-height)
           (+ -28672.0 (res-lump-float (-> self entity) 'height) (-> self entity extra trans y))
           )
     (go-virtual rise)
     )
    (('above-water)
     (logclear! (-> self mask) (process-mask actor-pause))
     (set! (-> self extend-height) (+ 2048.0 (-> self entity extra trans y)))
     (go-virtual rise)
     )
    (('jump-to-above-water)
     (logclear! (-> self mask) (process-mask actor-pause))
     (set! (-> self extend-height) (+ 2048.0 (-> self entity extra trans y)))
     (go-virtual complete)
     )
    )
  )

(defstate idle (for-pillar)
  :virtual #t
  :event for-pillar-event-handler
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (transform-and-sleep)
    )
  )

(defstate rise (for-pillar)
  :virtual #t
  :trans (behavior ()
    (rider-trans)
    (set! (-> self root trans y) (seek-ease
                                   (-> self root trans y)
                                   (-> self extend-height)
                                   (* 32768.0 (seconds-per-frame))
                                   4096.0
                                   (* 10240.0 (seconds-per-frame))
                                   )
          )
    (let ((f0-7 1.0))
      (let ((f1-3 (- (-> self extend-height) (-> self root trans y))))
        (if (< f1-3 4096.0)
            (set! f0-7 (* 0.00024414062 f1-3))
            )
        )
      (sound-play-by-name
        (static-sound-name "pillar-loop")
        (the-as sound-id (-> self sound-id))
        (the int (* 1024.0 f0-7))
        0
        0
        (sound-group)
        #t
        )
      )
    (when (= (-> self root trans y) (-> self extend-height))
      (process-entity-status! self (entity-perm-status subtask-complete) #t)
      (go-virtual complete)
      )
    )
  :code (behavior ()
    (sound-play "water-plr-rise")
    (sleep-code)
    )
  :post (behavior ()
    (rider-post)
    (when (and (nonzero? (-> self part)) (let ((f30-0 (-> self root trans y)))
                                           (if (type? self for-tower)
                                               (set! f30-0 (+ 61440.0 f30-0))
                                               )
                                           (< 90112.0 f30-0)
                                           )
               )
      (let ((a1-1 (new 'stack-no-clear 'vector)))
        (set! (-> a1-1 quad) (-> self entity extra trans quad))
        (set! (-> a1-1 y) 90112.0)
        (spawn (-> self part) a1-1)
        )
      )
    )
  )

(defstate complete (for-pillar)
  :virtual #t
  :event for-pillar-event-handler
  :enter (behavior ()
    (if (nonzero? (-> self sound-id))
        (sound-stop (the-as sound-id (-> self sound-id)))
        )
    )
  :trans (behavior ()
    (rider-trans)
    (when (and (-> self ridden?) (time-elapsed? (the-as int (-> self last-ride-time)) (seconds 3)))
      (set! (-> self ridden?) #f)
      (set! (-> self extend-height)
            (+ -28672.0 (res-lump-float (-> self entity) 'height) (-> self entity extra trans y))
            )
      (go-virtual rise)
      )
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (set! (-> self root trans y) (-> self extend-height))
    (ja :group! (ja-group) :num! min)
    (transform-and-sleep-code)
    )
  :post rider-post
  )

(defmethod get-skel ((this for-pillar))
  (art-group-get-by-name *level* "skel-for-pillar" (the-as (pointer level) #f))
  )

(defmethod init-collision! ((this for-pillar))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 -81920.0 0.0 122880.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod deactivate ((this for-pillar))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this sound-id))
      (sound-stop (the-as sound-id (-> this sound-id)))
      )
  (call-parent-method this)
  (none)
  )

(defmethod init-from-entity! ((this for-pillar) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 64)
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this (the-as skeleton-group (get-skel this)) (the-as pair 0))
  (set! (-> this id)
        (res-lump-value (-> this entity) 'extra-id int :default (the-as uint128 -1) :time -1000000000.0)
        )
  (if (and (not (task-node-closed? (game-task-node forest-turn-on-machine-introduction)))
           (or (and (= (-> this id) 1) (task-node-closed? (game-task-node forest-ring-chase-statue-1)))
               (and (= (-> this id) 2) (task-node-closed? (game-task-node forest-ring-chase-statue-2)))
               (and (= (-> this id) 3) (task-node-closed? (game-task-node forest-ring-chase-statue-3)))
               (and (= (-> this id) 4) (task-node-closed? (game-task-node forest-ring-chase-statue-4)))
               (and (= (-> this id) 5) (task-node-closed? (game-task-node forest-ring-chase-statue-5)))
               )
           )
      (process-entity-status! this (entity-perm-status subtask-complete) #t)
      )
  (+! (-> this root trans y) -28672.0)
  (set! (-> this extend-height)
        (+ -28672.0 (res-lump-float (-> this entity) 'height) (-> this entity extra trans y))
        )
  (if (task-node-closed? (game-task-node forest-kill-plants-armor))
      (+! (-> this root trans y) 30720.0)
      )
  (set! (-> this sound-id) (the-as uint (new-sound-id)))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 586) this))
  (set! (-> this ridden?) #f)
  (if (or (task-node-closed? (game-task-node forest-turn-on-machine-resolution))
          (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
          )
      (go (method-of-object this complete))
      )
  (go (method-of-object this idle))
  )

(deftype for-telescope (process-drawable)
  ((sound-id  sound-id)
   )
  (:state-methods
    idle
    )
  (:methods
    (for-telescope-method-21 (_type_) none)
    )
  )


(defskelgroup skel-for-telescope for-telescope for-telescope-lod0-jg for-telescope-idle-ja
              ((for-telescope-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 14 0 45)
              )

(defstate idle (for-telescope)
  :virtual #t
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :exit (behavior ()
    (if (nonzero? (-> self sound-id))
        (sound-stop (-> self sound-id))
        )
    )
  :trans (behavior ()
    (sound-play "airloop" :id (-> self sound-id) :position (-> self node-list data 14 bone transform trans))
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek! max 0.5) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.5))
        )
      )
    #f
    )
  :post transform-post
  )

(defmethod for-telescope-method-21 ((this for-telescope))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 16) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 17))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid no-standon))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 -61440.0 0.0 184320.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-15 transform-index) 6)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 12) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-17 transform-index) 18)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 13) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-19 transform-index) 19)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 14) (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-21 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-21 transform-index) 20)
      (set-vector! (-> v1-21 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 15) (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-23 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-23 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-23 transform-index) 21)
      (set-vector! (-> v1-23 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (let ((v1-25 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-25 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-25 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-25 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-25 transform-index) 5)
      (set-vector! (-> v1-25 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (let ((v1-27 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-27 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-27 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-27 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-27 transform-index) 8)
      (set-vector! (-> v1-27 local-sphere) 0.0 0.0 0.0 24576.0)
      )
    (let ((v1-29 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-29 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-29 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-29 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-29 transform-index) 9)
      (set-vector! (-> v1-29 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-31 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-31 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-31 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-31 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-31 transform-index) 10)
      (set-vector! (-> v1-31 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-33 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-33 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-33 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-33 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-33 transform-index) 11)
      (set-vector! (-> v1-33 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-35 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-35 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-35 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-35 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-35 transform-index) 12)
      (set-vector! (-> v1-35 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-37 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 7) (the-as uint 0))))
      (set! (-> v1-37 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-37 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-37 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-37 transform-index) 13)
      (set-vector! (-> v1-37 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-39 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 8) (the-as uint 0))))
      (set! (-> v1-39 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-39 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-39 prim-core action) (collide-action solid))
      (set! (-> v1-39 transform-index) 14)
      (set-vector! (-> v1-39 local-sphere) 0.0 0.0 0.0 24576.0)
      )
    (let ((v1-41 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 9) (the-as uint 0))))
      (set! (-> v1-41 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-41 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-41 prim-core action) (collide-action solid))
      (set! (-> v1-41 transform-index) 15)
      (set-vector! (-> v1-41 local-sphere) 0.0 0.0 0.0 12288.0)
      )
    (let ((v1-43 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 10) (the-as uint 0))))
      (set! (-> v1-43 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-43 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-43 prim-core action) (collide-action solid))
      (set! (-> v1-43 transform-index) 16)
      (set-vector! (-> v1-43 local-sphere) 0.0 0.0 0.0 24576.0)
      )
    (let ((v1-45 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 11) (the-as uint 0))))
      (set! (-> v1-45 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-45 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-45 prim-core action) (collide-action solid))
      (set! (-> v1-45 transform-index) 17)
      (set-vector! (-> v1-45 local-sphere) 0.0 0.0 0.0 12288.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-48 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-48 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-48 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch entity-perm-status vs object.
(defmethod init-from-entity! ((this for-telescope) (arg0 entity-actor))
  (process-entity-status! this (entity-perm-status dead) #t)
  )

(defbehavior for-telescope-init-by-other for-telescope ((arg0 vector) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (for-telescope-method-21 self)
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-rotate-local-y! (-> self root quat) (-> self root quat) 11832.889)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-for-telescope" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (if (not (task-node-closed? (game-task-node forest-ring-chase-resolution)))
      (setup-masks (-> self draw) 1 30)
      )
  (set! (-> self sound-id) (new-sound-id))
  (go-virtual idle)
  )

(deftype for-tower (for-pillar)
  ((telescope  handle)
   )
  )


(defskelgroup skel-for-tower for-tower for-tower-lod0-jg for-tower-idle-ja
              ((for-tower-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -10 0 30)
              :origin-joint-index 3
              )

(defstate complete (for-tower)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('kill-telescope)
       (let ((a0-2 (handle->process (-> self telescope))))
         (if a0-2
             (deactivate a0-2)
             )
         )
       )
      (else
        (for-pillar-event-handler proc argc message block)
        )
      )
    )
  )

(defmethod get-skel ((this for-tower))
  (art-group-get-by-name *level* "skel-for-tower" (the-as (pointer level) #f))
  )

(defmethod init-collision! ((this for-tower))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 2))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 -122880.0 0.0 204800.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 -122880.0 0.0 204800.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this for-tower) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 64)
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton this (the-as skeleton-group (get-skel this)) (the-as pair 0))
  (+! (-> this root trans y) -28672.0)
  (set! (-> this extend-height) (+ (-> this root trans y) (res-lump-float arg0 'height)))
  (set! (-> this sound-id) (the-as uint (new-sound-id)))
  (setup-masks (-> this draw) 1 2)
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 587) this))
  (set! (-> this ridden?) #f)
  (cond
    ((and (task-node-closed? (game-task-node forest-kill-plants-armor))
          (not (task-node-closed? (game-task-node forest-kill-plants-resolution)))
          )
     (+! (-> this root trans y) 30720.0)
     (set! (-> this extend-height) (+ 2048.0 (-> this entity extra trans y)))
     (set! (-> this telescope) (the-as handle #f))
     (go (method-of-object this complete))
     )
    ((or (task-node-closed? (game-task-node forest-kill-plants-resolution))
         (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
         )
     (let ((s4-1 (new 'stack-no-clear 'vector)))
       (set! (-> s4-1 quad) (-> this root trans quad))
       (set! (-> s4-1 y) (+ 65536.0 (-> this extend-height) (-> s4-1 y)))
       (set! (-> this telescope)
             (ppointer->handle (process-spawn for-telescope s4-1 arg0 :name "for-telescope" :to this))
             )
       )
     (go (method-of-object this complete))
     )
    )
  (set! (-> this telescope) (the-as handle #f))
  (go (method-of-object this idle))
  )

(deftype shoulder-plates (process-drawable)
  ()
  (:state-methods
    idle
    )
  )


(defskelgroup skel-shoulder-plates shoulder-plates shoulder-plates-lod0-jg shoulder-plates-idle-ja
              ((shoulder-plates-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defbehavior shoulder-plates-init-by-other shoulder-plates ((arg0 vector) (arg1 entity-actor) (arg2 level))
  (set! (-> self level) arg2)
  (process-entity-set! self arg1)
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-shoulder-plates" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go-virtual idle)
  )

(defstate idle (shoulder-plates)
  :virtual #t
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (ja-post)
    (sleep-code)
    )
  )

;; WARN: Return type mismatch entity-perm-status vs object.
(defmethod init-from-entity! ((this shoulder-plates) (arg0 entity-actor))
  (process-entity-status! this (entity-perm-status dead) #t)
  )
