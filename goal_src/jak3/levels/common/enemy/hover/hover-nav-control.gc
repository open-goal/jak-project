;;-*-Lisp-*-
(in-package goal)

;; name: hover-nav-control.gc
;; name in dgo: hover-nav-control
;; dgos: TEMA, SEA, FACC, LFORM, FACD, LPATK, TOWERA, PRECA, VOCA

(define-extern *nav-network* nav-network)

;; DECOMP BEGINS

(deftype nav-network-control (process)
  ((nav-network  nav-network)
   )
  (:state-methods
    idle
    )
  )


(defstate idle (nav-network-control)
  :virtual #t
  :code sleep-code
  :post (behavior ()
    (nav-network-method-28 (-> self nav-network))
    )
  )

(defbehavior nav-network-control-init-by-other nav-network-control ((arg0 nav-network) (arg1 level))
  (set! (-> self nav-network) arg0)
  (set! (-> self level) arg1)
  (logior! (-> self mask) (process-mask no-kill))
  (go-virtual idle)
  )

(defun detect-loop ((arg0 list-node))
  (let ((v1-0 arg0)
        (a2-0 (the-as list-node #f))
        (a1-0 0)
        )
    (while v1-0
      (when (< 1 a1-0)
        (let ((a3-2 arg0))
          (while (and a3-2 (!= a3-2 a2-0))
            (when (= a3-2 v1-0)
              (break!)
              0
              )
            (set! a3-2 (-> a3-2 next))
            )
          )
        )
      (set! a2-0 v1-0)
      (set! v1-0 (-> v1-0 next))
      (+! a1-0 1)
      )
    )
  #f
  )

(defun list-contains ((arg0 list-node) (arg1 list-node))
  (when (and arg0 arg1)
    (let ((v1-1 arg0))
      (while v1-1
        (let ((a0-2 (-> v1-1 next)))
          (if (= v1-1 arg1)
              (return #t)
              )
          (set! v1-1 a0-2)
          )
        )
      )
    #f
    )
  )

(defmethod new nav-network ((allocation symbol) (type-to-make type))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 network) (-> *dummy-adjacency* node-array))
    (set! (-> gp-0 edge) (-> *dummy-adjacency* edge-array))
    (dotimes (v1-6 5)
      (set! (-> gp-0 list-table v1-6) #f)
      )
    (reset! gp-0)
    (set! (-> gp-0 control-handle) (the-as handle #f))
    gp-0
    )
  )

(defmethod alloc-nav-network-for-level! ((this nav-network) (arg0 int) (arg1 int))
  (set! (-> this segment-pool) (the-as (pointer hover-nav-path-segment) (malloc 'loading-level (* 96 arg0))))
  (set! (-> this free-segment-list) #f)
  (dotimes (v1-1 64)
    (let ((a0-3 (&+ (-> this segment-pool) (* 96 v1-1))))
      (set! (-> a0-3 0) #f)
      (set! (-> a0-3 1) #f)
      (let ((a2-1 (-> this free-segment-list))
            (a1-4 (&-> this free-segment-list))
            )
        (when (zero? a0-3)
          (break!)
          0
          )
        (when (or (= a0-3 a2-1) (= a0-3 a1-4))
          (break!)
          0
          )
        (when (not (or (not a2-1) (!= (-> a2-1 prev) a0-3)))
          (break!)
          0
          )
        (when a2-1
          (set! (-> a0-3 0) a2-1)
          (set! (-> a0-3 1) (the-as hover-nav-path-segment (-> a2-1 prev)))
          (if (-> a0-3 1)
              (set! (-> a0-3 1 next) (the-as list-node a0-3))
              )
          (if (-> a0-3 0)
              (set! (-> a0-3 0 prev) (the-as list-node a0-3))
              )
          )
        (if (or (not a2-1) (= a2-1 (-> a1-4 0)))
            (set! (-> a1-4 0) (the-as hover-nav-path-segment a0-3))
            )
        )
      )
    )
  (set! (-> this sphere-pool) (the-as (pointer hover-nav-sphere) (malloc 'loading-level (* 48 arg1))))
  (set! (-> this free-sphere-list) #f)
  (dotimes (v1-5 10)
    (let ((a0-6 (&+ (-> this sphere-pool) (* 48 v1-5))))
      (set! (-> a0-6 0) #f)
      (set! (-> a0-6 1) #f)
      (let ((a2-5 (-> this free-sphere-list))
            (a1-8 (&-> this free-sphere-list))
            )
        (when (zero? a0-6)
          (break!)
          0
          )
        (when (or (= a0-6 a2-5) (= a0-6 a1-8))
          (break!)
          0
          )
        (when (not (or (not a2-5) (!= (-> a2-5 prev) a0-6)))
          (break!)
          0
          )
        (when a2-5
          (set! (-> a0-6 0) a2-5)
          (set! (-> a0-6 1) (the-as hover-nav-sphere (-> a2-5 prev)))
          (if (-> a0-6 1)
              (set! (-> a0-6 1 next) (the-as list-node a0-6))
              )
          (if (-> a0-6 0)
              (set! (-> a0-6 0 prev) (the-as list-node a0-6))
              )
          )
        (if (or (not a2-5) (= a2-5 (-> a1-8 0)))
            (set! (-> a1-8 0) (the-as hover-nav-sphere a0-6))
            )
        )
      )
    )
  (init-by-other! this (the-as level #f) *dummy-adjacency*)
  0
  (none)
  )

(defmethod init-by-other! ((this nav-network) (arg0 level) (arg1 nav-network-data))
  (set! (-> this network) (-> arg1 node-array))
  (set! (-> this edge) (-> arg1 edge-array))
  (while (-> this sphere-list)
    (let ((v1-2 (-> this sphere-list)))
      (let ((a0-1 v1-2))
        (let ((a1-1 (&-> this sphere-list)))
          (if (= (-> a1-1 0) a0-1)
              (set! (-> a1-1 0) (the-as hover-nav-sphere (-> a0-1 next)))
              )
          )
        (if (-> a0-1 prev)
            (set! (-> a0-1 prev next) (-> a0-1 next))
            )
        (if (-> a0-1 next)
            (set! (-> a0-1 next prev) (-> a0-1 prev))
            )
        (set! (-> a0-1 prev) #f)
        (set! (-> a0-1 next) #f)
        )
      (let ((a1-8 (-> this free-sphere-list))
            (a0-3 (&-> this free-sphere-list))
            )
        (when (zero? v1-2)
          (break!)
          0
          )
        (when (or (= v1-2 a1-8) (= v1-2 a0-3))
          (break!)
          0
          )
        (when (not (or (not a1-8) (!= (-> a1-8 prev) v1-2)))
          (break!)
          0
          )
        (when a1-8
          (set! (-> v1-2 next) a1-8)
          (set! (-> v1-2 prev) (-> a1-8 prev))
          (if (-> v1-2 prev)
              (set! (-> v1-2 prev next) v1-2)
              )
          (if (-> v1-2 next)
              (set! (-> v1-2 next prev) v1-2)
              )
          )
        (if (or (not a1-8) (= a1-8 (-> a0-3 0)))
            (set! (-> a0-3 0) v1-2)
            )
        )
      )
    )
  (if (and arg0 (not (handle->process (-> this control-handle))))
      (set! (-> this control-handle)
            (process->handle
              (ppointer->process (process-spawn nav-network-control this arg0 :name "nav-network-control"))
              )
            )
      )
  0
  (none)
  )

(defmethod reset! ((this nav-network))
  (set! (-> this open-list) #f)
  (set! (-> this closed-list) #f)
  (let ((v1-0 (-> this network)))
    (when v1-0
      (dotimes (a0-2 (-> v1-0 length))
        (let ((a1-3 (-> v1-0 a0-2 path-node)))
          (set! (-> a1-3 status) (net-path-node-status none))
          (set! (-> a1-3 parent) #f)
          (set! (-> a1-3 next) #f)
          (set! (-> a1-3 prev) #f)
          )
        )
      )
    )
  0
  (none)
  )


(defmethod nav-network-method-30 ((this nav-network))
  0
  (none)
  )

(defmethod nav-network-method-15 ((this nav-network) (arg0 nav-network-path-node))
  (local-vars (a2-4 list-node))
  (when (nonzero? (-> arg0 status))
    (break!)
    0
    )
  (let ((f0-1 (+ (-> arg0 cost-to-start) (-> arg0 cost-to-end))))
    (when (not (and (not (-> arg0 next)) (not (-> arg0 prev))))
      (break!)
      0
      )
    (let ((v1-8 (the-as list-node (-> this open-list))))
      (while v1-8
        (let ((a2-1 (-> v1-8 next)))
          (if (= v1-8 arg0)
              (return #t)
              )
          (set! v1-8 a2-1)
          )
        )
      )
    (when #f
      (break!)
      0
      )
    (logior! (-> arg0 status) (net-path-node-status open))
    (let ((v1-17 (the-as list-node (-> this open-list))))
      (while v1-17
        (let ((a2-3 (-> (the-as nav-network-path-node v1-17) next)))
          (when (< f0-1 (+ (-> (the-as nav-network-path-node v1-17) cost-to-start)
                           (-> (the-as nav-network-path-node v1-17) cost-to-end)
                           )
                   )
            (set! a2-4 v1-17)
            (goto cfg-23)
            )
          (set! v1-17 a2-3)
          )
        )
      )
    )
  (set! a2-4 (the-as list-node #f))
  (label cfg-23)
  (cond
    (a2-4
      (let ((v1-20 arg0)
            (a0-1 (-> this list-table))
            )
        (when (zero? v1-20)
          (break!)
          0
          )
        (when (or (= v1-20 a2-4) (= v1-20 a0-1))
          (break!)
          0
          )
        (when (not (or (not a2-4) (!= (-> (the-as nav-network-path-node a2-4) prev) v1-20)))
          (break!)
          0
          )
        (when (the-as nav-network-path-node a2-4)
          (set! (-> v1-20 next) (the-as nav-network-path-node a2-4))
          (set! (-> v1-20 prev) (-> (the-as nav-network-path-node a2-4) prev))
          (if (-> v1-20 prev)
              (set! (-> v1-20 prev next) v1-20)
              )
          (if (-> v1-20 next)
              (set! (-> v1-20 next prev) v1-20)
              )
          )
        (if (or (not (the-as nav-network-path-node a2-4)) (= (the-as nav-network-path-node a2-4) (-> a0-1 0)))
            (set! (-> a0-1 0) v1-20)
            )
        )
      )
    (else
      (let ((a2-8 (the-as list-node #f)))
        (let ((v1-21 (the-as list-node (-> this open-list))))
          (while v1-21
            (let ((a3-22 (-> v1-21 next)))
              (set! a2-8 v1-21)
              (set! v1-21 a3-22)
              )
            )
          )
        (let ((v1-23 arg0)
              (a0-2 (-> this list-table))
              )
          (when (or (= v1-23 a2-8) (= v1-23 a0-2))
            (break!)
            0
            )
          (when (not (or (not (the-as nav-network-path-node a2-8)) (!= (-> (the-as nav-network-path-node a2-8) next) v1-23)))
            (break!)
            0
            )
          (cond
            ((the-as nav-network-path-node a2-8)
             (set! (-> v1-23 next) (-> (the-as nav-network-path-node a2-8) next))
             (set! (-> v1-23 prev) (the-as nav-network-path-node a2-8))
             (if (-> v1-23 prev)
                 (set! (-> v1-23 prev next) v1-23)
                 )
             (if (-> v1-23 next)
                 (set! (-> v1-23 next prev) v1-23)
                 )
             )
            (else
              (set! (-> v1-23 next) (-> a0-2 0))
              (set! (-> v1-23 prev) #f)
              (if (-> v1-23 next)
                  (set! (-> v1-23 next prev) v1-23)
                  )
              (set! (-> a0-2 0) v1-23)
              )
            )
          )
        )
      )
    )
  arg0
  )

(defmethod nav-network-method-13 ((this nav-network) (arg0 int) (arg1 nav-network-path-node))
  (when (nonzero? (-> arg1 status))
    (break!)
    0
    )
  (let ((v1-3 arg1)
        (a3-2 (-> this list-table arg0))
        (a0-2 (the-as object (&+ (-> this list-table) (* arg0 4))))
        )
    (when (zero? v1-3)
      (break!)
      0
      )
    (when (or (= v1-3 a3-2) (= v1-3 (the-as (pointer list-node) a0-2)))
      (break!)
      0
      )
    (when (not (or (not a3-2) (!= (-> a3-2 prev) v1-3)))
      (break!)
      0
      )
    (when a3-2
      (set! (-> v1-3 next) a3-2)
      (set! (-> v1-3 prev) (-> a3-2 prev))
      (if (-> v1-3 prev)
          (set! (-> v1-3 prev next) v1-3)
          )
      (if (-> v1-3 next)
          (set! (-> v1-3 next prev) v1-3)
          )
      )
    (if (or (not a3-2) (= a3-2 (-> (the-as nav-network-path-node a0-2) next)))
        (set! (-> (the-as nav-network-path-node a0-2) next) v1-3)
        )
    )
  arg1
  )

(defmethod nav-network-method-14 ((this nav-network) (arg0 int) (arg1 nav-network-path-node))
  (let ((v1-0 arg1))
    (let ((a3-1 (the-as list-node (&+ (-> this list-table) (* arg0 4)))))
      (if (= (-> a3-1 next) v1-0)
          (set! (-> a3-1 next) (-> v1-0 next))
          )
      )
    (if (-> v1-0 prev)
        (set! (-> v1-0 prev next) (-> v1-0 next))
        )
    (if (-> v1-0 next)
        (set! (-> v1-0 next prev) (-> v1-0 prev))
        )
    (set! (-> v1-0 prev) #f)
    (set! (-> v1-0 next) #f)
    )
  (let ((v1-4 (-> this list-table arg0)))
    (while v1-4
      (let ((a0-2 (-> v1-4 next)))
        (if (= v1-4 arg1)
            (return #t)
            )
        (set! v1-4 a0-2)
        )
      )
    )
  (when #f
    (break!)
    0
    )
  (when (not (and (not (-> arg1 next)) (not (-> arg1 prev))))
    (break!)
    0
    )
  (set! (-> arg1 status) (net-path-node-status none))
  0
  )

;; WARN: Return type mismatch object vs none.
(defmethod nav-network-method-16 ((this nav-network) (arg0 nav-network-path-node))
  (nav-network-method-14 this 0 arg0)
  (none)
  )

(defmethod nav-network-method-17 ((this nav-network))
  (let ((gp-0 (-> this open-list)))
    (if gp-0
        (nav-network-method-16 this gp-0)
        (set! gp-0 (the-as nav-network-path-node #f))
        )
    gp-0
    )
  )

(defmethod close-node! ((this nav-network) (arg0 nav-network-path-node))
  (nav-network-method-13 this 1 arg0)
  (let ((v0-1 (logior (-> arg0 status) (net-path-node-status closed))))
    (set! (-> arg0 status) v0-1)
    v0-1
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod nav-network-method-19 ((this nav-network) (arg0 nav-network-path-node))
  (nav-network-method-14 this 1 arg0)
  (none)
  )

(defmethod nav-network-method-23 ((this nav-network) (arg0 hover-nav-path-info) (arg1 vector) (arg2 vector) (arg3 int) (arg4 int))
  (-> this network)
  (let ((gp-0 (-> this free-segment-list)))
    (cond
      ((and gp-0 (nonzero? gp-0))
       (let ((v1-2 gp-0))
         (let ((a0-1 (&-> this free-segment-list)))
           (if (= (-> a0-1 0) v1-2)
               (set! (-> a0-1 0) (the-as hover-nav-path-segment (-> v1-2 next)))
               )
           )
         (if (-> v1-2 prev)
             (set! (-> v1-2 prev next) (-> v1-2 next))
             )
         (if (-> v1-2 next)
             (set! (-> v1-2 next prev) (-> v1-2 prev))
             )
         (set! (-> v1-2 prev) #f)
         (set! (-> v1-2 next) #f)
         )
       (set! (-> gp-0 curve-matrix rvec quad) (-> arg1 quad))
       (set! (-> gp-0 curve-matrix uvec quad) (-> arg2 quad))
       (set! (-> gp-0 pos-index 0) arg3)
       (set! (-> gp-0 pos-index 1) arg4)
       (set! (-> gp-0 dist)
             (vector-vector-distance (the-as vector (-> gp-0 curve-matrix)) (-> gp-0 curve-matrix uvec))
             )
       (if (not (-> arg0 segment-list))
           (set! (-> arg0 tail-segment) gp-0)
           )
       (let ((v1-9 gp-0)
             (a1-7 (-> arg0 segment-list))
             (a0-13 (&-> arg0 segment-list))
             )
         (when (zero? v1-9)
           (break!)
           0
           )
         (when (or (= v1-9 a1-7) (= v1-9 a0-13))
           (break!)
           0
           )
         (when (not (or (not a1-7) (!= (-> a1-7 prev) v1-9)))
           (break!)
           0
           )
         (when a1-7
           (set! (-> v1-9 next) a1-7)
           (set! (-> v1-9 prev) (-> a1-7 prev))
           (if (-> v1-9 prev)
               (set! (-> v1-9 prev next) v1-9)
               )
           (if (-> v1-9 next)
               (set! (-> v1-9 next prev) v1-9)
               )
           )
         (if (or (not a1-7) (= a1-7 (-> a0-13 0)))
             (set! (-> a0-13 0) v1-9)
             )
         )
       gp-0
       )
      (else
        (the-as hover-nav-path-segment #f)
        )
      )
    )
  )

;; WARN: Return type mismatch hover-nav-path-segment vs none.
(defmethod nav-network-method-22 ((this nav-network) (arg0 object) (arg1 int) (arg2 int))
  (let ((t0-0 (-> this network)))
    (nav-network-method-23 this (the-as hover-nav-path-info arg0) (-> t0-0 arg1 pos) (-> t0-0 arg2 pos) arg1 arg2)
    )
  (none)
  )

(defmethod nav-network-method-24 ((this nav-network) (arg0 hover-nav-path-info))
  (while (-> arg0 segment-list)
    (let ((v1-0 (-> arg0 segment-list)))
      (let ((a2-0 v1-0))
        (let ((a3-0 (&-> arg0 segment-list)))
          (if (= (-> a3-0 0) a2-0)
              (set! (-> a3-0 0) (the-as hover-nav-path-segment (-> a2-0 next)))
              )
          )
        (if (-> a2-0 prev)
            (set! (-> a2-0 prev next) (-> a2-0 next))
            )
        (if (-> a2-0 next)
            (set! (-> a2-0 next prev) (-> a2-0 prev))
            )
        (set! (-> a2-0 prev) #f)
        (set! (-> a2-0 next) #f)
        )
      (let ((a3-7 (-> this free-segment-list))
            (a2-2 (&-> this free-segment-list))
            )
        (when (zero? v1-0)
          (break!)
          0
          )
        (when (or (= v1-0 a3-7) (= v1-0 a2-2))
          (break!)
          0
          )
        (when (not (or (not a3-7) (!= (-> a3-7 prev) v1-0)))
          (break!)
          0
          )
        (when a3-7
          (set! (-> v1-0 next) a3-7)
          (set! (-> v1-0 prev) (-> a3-7 prev))
          (if (-> v1-0 prev)
              (set! (-> v1-0 prev next) v1-0)
              )
          (if (-> v1-0 next)
              (set! (-> v1-0 next prev) v1-0)
              )
          )
        (if (or (not a3-7) (= a3-7 (-> a2-2 0)))
            (set! (-> a2-2 0) v1-0)
            )
        )
      )
    )
  (set! (-> arg0 tail-segment) #f)
  (set! (-> arg0 curr-segment) #f)
  0
  (none)
  )

(defmethod nav-network-method-20 ((this nav-network) (arg0 nav-network-path-node) (arg1 vector))
  (let* ((s3-0 (-> this network))
         (s2-0 (-> s3-0 (-> arg0 row-index)))
         )
    (dotimes (s1-0 (-> s2-0 count))
      (let* ((v1-8 (-> s3-0 (-> s2-0 adjacency s1-0 index)))
             (s0-0 (-> v1-8 path-node))
             (f0-1 (+ (-> arg0 cost-to-start) (-> s2-0 adjacency s1-0 dist)))
             )
        (when (or (not (or (logtest? (-> s0-0 status) (net-path-node-status open))
                           (logtest? (-> s0-0 status) (net-path-node-status closed))
                           )
                       )
                  (< f0-1 (-> s0-0 cost-to-start))
                  )
          (set! (-> s0-0 parent) arg0)
          (set! (-> s0-0 cost-to-start) f0-1)
          (set! (-> s0-0 cost-to-end) (vector-vector-distance (-> v1-8 pos) arg1))
          (cond
            ((logtest? (-> s0-0 status) (net-path-node-status open))
             (nav-network-method-16 this s0-0)
             (nav-network-method-15 this s0-0)
             )
            ((logtest? (-> s0-0 status) (net-path-node-status closed))
             (nav-network-method-19 this s0-0)
             (nav-network-method-15 this s0-0)
             )
            (else
              (nav-network-method-15 this s0-0)
              )
            )
          )
        )
      )
    )
  (close-node! this arg0)
  0
  (none)
  )

(defmethod nav-network-method-21 ((this nav-network) (arg0 int) (arg1 vector))
  (let* ((v1-0 (-> this network))
         (s5-0 (-> v1-0 arg0 path-node))
         )
    (set! (-> s5-0 row-index) arg0)
    (set! (-> s5-0 status) (net-path-node-status none))
    (set! (-> s5-0 parent) #f)
    (set! (-> s5-0 cost-to-start) 0.0)
    (set! (-> s5-0 cost-to-end) (vector-vector-distance (-> v1-0 arg0 pos) arg1))
    (nav-network-method-15 this s5-0)
    )
  0
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod nav-network-method-25 ((this nav-network) (arg0 hover-nav-path-info) (arg1 int) (arg2 int) (arg3 int) (arg4 vector))
  (local-vars (s2-2 nav-network-path-node))
  (reset! this)
  (let ((s4-0 (-> this network)))
    (nav-network-method-21 this (-> this edge arg1 start-index) arg4)
    (nav-network-method-21 this (-> this edge arg1 end-index) arg4)
    (let ((s1-1 (-> this edge arg3 start-index))
          (s2-1 (-> this edge arg3 end-index))
          )
      (until #f
        (let ((a1-5 (nav-network-method-17 this)))
          (when (not a1-5)
            (set! s2-2 (the-as nav-network-path-node #f))
            (goto cfg-12)
            )
          (when (or (= (-> a1-5 row-index) s1-1) (= (-> a1-5 row-index) s2-1))
            (set! s2-2 a1-5)
            (goto cfg-12)
            )
          (nav-network-method-20 this a1-5 arg4)
          )
        )
      )
    #f
    (set! s2-2 (nav-network-method-17 this))
    (label cfg-12)
    (when s2-2
      (nav-network-method-23 this arg0 (-> s4-0 (-> s2-2 row-index) pos) arg4 (-> s2-2 row-index) -1)
      (while (and s2-2 (-> s2-2 parent))
        (if *debug-hover*
            (add-debug-sphere #t (bucket-id debug-no-zbuf1) (-> s4-0 (-> s2-2 row-index) pos) (meters 0.5) *color-blue*)
            )
        (nav-network-method-22 this arg0 (-> s2-2 parent row-index) (-> s2-2 row-index))
        (set! s2-2 (-> s2-2 parent))
        )
      #t
      )
    )
  )

(defmethod nav-network-method-26 ((this nav-network) (arg0 process) (arg1 collide-prim-core))
  (local-vars (a3-2 list-node))
  (let ((a1-4 (process->handle arg0)))
    (let ((v1-2 (the-as list-node (-> this sphere-list))))
      (while v1-2
        (let ((a3-1 (-> (the-as hover-nav-sphere v1-2) next)))
          (when (= (-> (the-as hover-nav-sphere v1-2) handle) a1-4)
            (set! a3-2 v1-2)
            (goto cfg-12)
            )
          (set! v1-2 a3-1)
          )
        )
      )
    (set! a3-2 (the-as list-node #f))
    (label cfg-12)
    (when (not a3-2)
      (let ((v1-6 (-> this free-sphere-list)))
        (when v1-6
          (let ((a3-3 v1-6))
            (let ((t0-3 (&-> this free-sphere-list)))
              (if (= (-> t0-3 0) a3-3)
                  (set! (-> t0-3 0) (the-as hover-nav-sphere (-> a3-3 next)))
                  )
              )
            (if (-> a3-3 prev)
                (set! (-> a3-3 prev next) (-> a3-3 next))
                )
            (if (-> a3-3 next)
                (set! (-> a3-3 next prev) (-> a3-3 prev))
                )
            (set! (-> a3-3 prev) #f)
            (set! (-> a3-3 next) #f)
            )
          (set! (-> v1-6 handle) (the-as handle a1-4))
          (let ((a1-5 v1-6)
                (a3-5 (-> this sphere-list))
                (a0-1 (&-> this sphere-list))
                )
            (when (zero? a1-5)
              (break!)
              0
              )
            (when (or (= a1-5 a3-5) (= a1-5 a0-1))
              (break!)
              0
              )
            (when (not (or (not a3-5) (!= (-> a3-5 prev) a1-5)))
              (break!)
              0
              )
            (when a3-5
              (set! (-> a1-5 next) a3-5)
              (set! (-> a1-5 prev) (-> a3-5 prev))
              (if (-> a1-5 prev)
                  (set! (-> a1-5 prev next) a1-5)
                  )
              (if (-> a1-5 next)
                  (set! (-> a1-5 next prev) a1-5)
                  )
              )
            (if (or (not a3-5) (= a3-5 (-> a0-1 0)))
                (set! (-> a0-1 0) a1-5)
                )
            )
          (set! a3-2 v1-6)
          )
        )
      )
    )
  (when a3-2
    (set! (-> (the-as hover-nav-sphere a3-2) timer) (seconds 0.5))
    (when arg1
      (set! (-> (the-as hover-nav-sphere a3-2) sphere quad) (-> arg1 world-sphere quad))
      (set! (-> (the-as hover-nav-sphere a3-2) sphere r) (fmax 4096.0 (-> (the-as hover-nav-sphere a3-2) sphere r)))
      )
    )
  0
  (none)
  )

(defmethod nav-network-method-27 ((this nav-network) (arg0 vector) (arg1 process) (arg2 vector) (arg3 vector) (arg4 float))
  (local-vars (sv-32 sphere) (sv-36 vector))
  (vector-reset! arg0)
  (let ((s1-0 (process->handle arg1))
        (s2-0 0)
        )
    (let ((v1-3 (the-as list-node (-> this sphere-list))))
      (while v1-3
        (let ((s0-0 (-> (the-as hover-nav-sphere v1-3) next)))
          (when (!= (-> (the-as hover-nav-sphere v1-3) handle) s1-0)
            (set! sv-32 (-> (the-as hover-nav-sphere v1-3) sphere))
            (set! sv-36 (new 'stack-no-clear 'vector))
            (vector-segment-distance-point! sv-32 arg2 arg3 sv-36)
            (when (and (>= (+ arg4 (-> sv-32 r)) (vector-vector-distance sv-32 sv-36))
                       (< 0.0 (vector-vector-distance arg2 sv-36))
                       )
              (let ((v1-11 (vector-! (new 'stack-no-clear 'vector) (the-as vector sv-32) arg2)))
                (vector+! arg0 arg0 v1-11)
                )
              (+! s2-0 1)
              )
            )
          (set! v1-3 s0-0)
          )
        )
      )
    (vector-float*! arg0 arg0 (/ 1.0 (the float s2-0)))
    )
  )

(defmethod nav-network-method-32 ((this nav-network) (arg0 vector) (arg1 int))
  (let ((s3-0 (-> this network))
        (gp-0 (the-as int #f))
        )
    (let ((f30-0 0.0))
      (dotimes (s2-0 (-> s3-0 length))
        (when (logtest? arg1 (ash 1 (-> s3-0 s2-0 sub-graph)))
          (let* ((a0-6 (-> s3-0 s2-0 pos))
                 (f0-0 (vector-vector-distance a0-6 arg0))
                 )
            (when (or (not gp-0) (< f0-0 f30-0))
              (set! gp-0 s2-0)
              (set! f30-0 f0-0)
              )
            )
          )
        )
      )
    gp-0
    )
  )

(defmethod nav-network-method-33 ((this nav-network) (arg0 vector) (arg1 vector) (arg2 int))
  (local-vars (sv-32 vector))
  (let ((s2-0 (-> this network))
        (s1-0 (-> this edge))
        (f30-0 0.0)
        (gp-0 -1)
        )
    (dotimes (s0-0 (-> s1-0 length))
      (when (logtest? arg2 (ash 1 (-> s1-0 s0-0 sub-graph)))
        (let* ((v1-6 (-> s1-0 s0-0))
               (a1-1 (-> s2-0 (-> v1-6 start-index) pos))
               (a2-1 (-> s2-0 (-> v1-6 end-index) pos))
               )
          (set! sv-32 (new 'stack-no-clear 'vector))
          (let ((f0-0 (vector-segment-distance-point! arg0 a1-1 a2-1 sv-32)))
            (when (or (= gp-0 -1) (< f0-0 f30-0))
              (set! gp-0 s0-0)
              (set! f30-0 f0-0)
              (set! (-> arg1 quad) (-> sv-32 quad))
              )
            )
          )
        )
      )
    gp-0
    )
  )

(defmethod nav-network-method-34 ((this nav-network) (arg0 vector) (arg1 vector) (arg2 int))
  (local-vars
    (sv-16 (array nav-network-info))
    (sv-20 (array nav-network-edge))
    (sv-24 number)
    (sv-32 int)
    (sv-64 vector)
    )
  (set! sv-16 (-> this network))
  (set! sv-20 (-> this edge))
  (set! sv-24 0.0)
  (set! sv-32 -1)
  (dotimes (s3-0 (-> sv-20 length))
    (when (logtest? arg2 (ash 1 (-> sv-20 s3-0 sub-graph)))
      (let* ((s2-0 (-> sv-20 s3-0))
             (a1-2 (-> sv-16 (-> s2-0 start-index) pos))
             (a2-1 (-> sv-16 (-> s2-0 end-index) pos))
             )
        (set! sv-64 (new 'stack-no-clear 'vector))
        (let ((f0-2 (- (vector-segment-distance-point! arg0 a1-2 a2-1 sv-64) (-> s2-0 radius))))
          (when (or (= sv-32 -1) (< f0-2 (the-as float sv-24)))
            (set! sv-32 s3-0)
            (set! sv-24 f0-2)
            (set! (-> arg1 quad) (-> sv-64 quad))
            )
          )
        )
      )
    )
  sv-32
  )

(defmethod nav-network-method-35 ((this nav-network) (arg0 vector) (arg1 vector) (arg2 int))
  (let* ((s5-0 (new 'stack-no-clear 'vector))
         (a0-2 (nav-network-method-34 this arg0 s5-0 arg2))
         )
    (when (!= a0-2 -1)
      (let* ((v1-3 (vector-! (new 'stack-no-clear 'vector) arg0 s5-0))
             (f0-0 (vector-length v1-3))
             )
        (cond
          ((>= (-> this edge a0-2 radius) f0-0)
           (set! (-> arg1 quad) (-> arg0 quad))
           )
          (else
            (vector-float*! v1-3 v1-3 (/ (-> this edge a0-2 radius) f0-0))
            (vector+! arg1 s5-0 v1-3)
            )
          )
        )
      #t
      )
    )
  )

(defmethod nav-network-method-28 ((this nav-network))
  (with-pp
    (let ((v1-0 (the-as list-node (-> this sphere-list))))
      (while v1-0
        (let ((a0-2 (-> v1-0 next)))
          (set! (-> (the-as hover-nav-sphere v1-0) timer)
                (- (-> (the-as hover-nav-sphere v1-0) timer) (- (current-time) (-> pp clock old-frame-counter)))
                )
          (when (<= (-> (the-as hover-nav-sphere v1-0) timer) 0)
            (let ((a1-4 v1-0))
              (let ((a2-3 (&-> this sphere-list)))
                (if (= (-> a2-3 0) a1-4)
                    (set! (-> a2-3 0) (the-as hover-nav-sphere (-> a1-4 next)))
                    )
                )
              (if (-> a1-4 prev)
                  (set! (-> a1-4 prev next) (-> a1-4 next))
                  )
              (if (-> a1-4 next)
                  (set! (-> a1-4 next prev) (-> a1-4 prev))
                  )
              (set! (-> a1-4 prev) #f)
              (set! (-> a1-4 next) #f)
              )
            (let ((a2-10 (-> this free-sphere-list))
                  (a1-6 (&-> this free-sphere-list))
                  )
              (when (zero? v1-0)
                (break!)
                0
                )
              (when (or (= v1-0 a2-10) (= v1-0 a1-6))
                (break!)
                0
                )
              (when (not (or (not a2-10) (!= (-> a2-10 prev) v1-0)))
                (break!)
                0
                )
              (when a2-10
                (set! (-> v1-0 next) a2-10)
                (set! (-> v1-0 prev) (-> a2-10 prev))
                (if (-> v1-0 prev)
                    (set! (-> v1-0 prev next) v1-0)
                    )
                (if (-> v1-0 next)
                    (set! (-> v1-0 next prev) v1-0)
                    )
                )
              (if (or (not a2-10) (= a2-10 (-> a1-6 0)))
                  (set! (-> a1-6 0) (the-as hover-nav-sphere v1-0))
                  )
              )
            )
          (set! v1-0 a0-2)
          )
        )
      )
    (let ((v1-2 (the-as list-node (-> this sphere-list))))
      (while v1-2
        (let ((s5-0 (-> v1-2 next)))
          (let ((s4-0 (handle->process (-> (the-as hover-nav-sphere v1-2) handle))))
            (when s4-0
              (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-8 from) (process->ppointer pp))
                (set! (-> a1-8 num-params) 0)
                (set! (-> a1-8 message) 'get-hover-nav-sphere)
                (let ((a2-14 (send-event-function s4-0 a1-8)))
                  (if a2-14
                      (nav-network-method-26 this s4-0 (the-as collide-prim-core a2-14))
                      )
                  )
                )
              )
            )
          (set! v1-2 s5-0)
          )
        )
      )
    0
    (none)
    )
  )

(defmethod nav-network-method-36 ((this nav-network) (arg0 bounding-box))
  (set-to-point! arg0 (-> this network 0 pos))
  (let* ((s4-0 (-> this network length))
         (s3-0 0)
         (v1-7 (-> this network s3-0))
         )
    (while (< s3-0 s4-0)
      (add-point! arg0 (-> v1-7 pos))
      (+! s3-0 1)
      (set! v1-7 (-> this network s3-0))
      )
    )
  0
  (none)
  )

(defmethod print-vis-bbox ((this nav-network) (arg0 string))
  (let ((gp-0 (new 'stack-no-clear 'bounding-box))
        (s5-0 (entity-by-name arg0))
        )
    (when s5-0
      (nav-network-method-36 this gp-0)
      (vector-! (-> gp-0 min) (-> gp-0 min) (-> s5-0 extra trans))
      (vector-! (-> gp-0 max) (-> gp-0 max) (-> s5-0 extra trans))
      (format #t "actor-vis ~S ~m   " (res-lump-struct s5-0 'name structure) (-> s5-0 extra vis-dist))
      (format
        #t
        " ~m ~m ~m    ~m ~m ~m~%"
        (-> gp-0 min x)
        (-> gp-0 min y)
        (-> gp-0 min z)
        (-> gp-0 max x)
        (-> gp-0 max y)
        (-> gp-0 max z)
        )
      )
    )
  0
  (none)
  )

(when (zero? *nav-network*)
  (set! *nav-network* (the-as nav-network 0))
  0
  )

(defmethod probe-background ((this hover-nav-control) (arg0 vector) (arg1 vector) (arg2 float))
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0)))
      (set! (-> gp-0 start-pos quad) (-> arg0 quad))
      (set! (-> gp-0 move-dist quad) (-> v1-1 quad))
      (vector-normalize! (-> gp-0 move-dist) (fmin (vector-length v1-1) (fmax 16384.0 (* 2.0 arg2))))
      )
    (let ((v1-5 gp-0))
      (set! (-> v1-5 radius) 4096.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (fill-using-line-sphere *collide-cache* gp-0)
    (< (probe-using-line-sphere *collide-cache* gp-0) 0.0)
    )
  )

(defmethod hover-nav-control-method-27 ((this hover-nav-control) (arg0 vector) (arg1 vector))
  (nav-network-method-32 (-> this nav) arg0 (if (= (-> this sub-graph) -1)
                                                -1
                                                (ash 1 (-> this sub-graph))
                                                )
                         )
  )

(defmethod hover-nav-control-method-28 ((this hover-nav-control) (arg0 vector) (arg1 vector))
  (nav-network-method-33 (-> this nav) arg0 arg1 (if (= (-> this sub-graph) -1)
                                                     -1
                                                     (ash 1 (-> this sub-graph))
                                                     )
                         )
  )

(defmethod hover-nav-control-method-29 ((this hover-nav-control) (arg0 vector) (arg1 vector))
  (nav-network-method-35 (-> this nav) arg0 arg1 (if (= (-> this sub-graph) -1)
                                                     -1
                                                     (ash 1 (-> this sub-graph))
                                                     )
                         )
  )

(defmethod get-curr-segment ((this hover-nav-control))
  (-> this path-info curr-segment)
  )

(defmethod hover-nav-control-method-22 ((this hover-nav-control))
  (logtest? (-> this flags) (hover-nav-flags hnf1))
  )

(defmethod hover-nav-control-method-20 ((this hover-nav-control))
  (nav-network-method-24 (-> this nav) (-> this path-info))
  (set! (-> this curr-dest-pt) -1)
  (set! (-> this u-param) 0.0)
  0
  (none)
  )

(defmethod hover-nav-control-method-31 ((this hover-nav-control))
  (hover-nav-control-method-32 this (-> this root transv))
  (set! (-> this path-info curr-segment) (-> this path-info segment-list))
  0.0
  )

(defmethod hover-nav-control-method-30 ((this hover-nav-control) (arg0 vector) (arg1 vector))
  (local-vars
    (s0-0 int)
    (sv-48 (array nav-network-info))
    (sv-52 (array nav-network-edge))
    (sv-56 int)
    (sv-272 (pointer float))
    (sv-276 (inline-array vector))
    (sv-280 (inline-array vector))
    (sv-288 int)
    (sv-304 vector)
    )
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (hover-nav-control-method-20 this)
    (let ((s2-0 (new 'stack-no-clear 'vector))
          (s3-0 (new 'stack-no-clear 'vector))
          (s5-0 (-> this path-info))
          )
      (set! sv-48 (-> this nav network))
      (cond
        ((< (vector-vector-distance arg0 arg1) 13107.2)
         (nav-network-method-23 (-> this nav) s5-0 (the-as vector (hover-nav-control-method-17 this)) arg1 -1 -1)
         (hover-nav-control-method-31 this)
         )
        (else
          (set! sv-52 (-> this nav edge))
          (set! sv-56 (hover-nav-control-method-28 this arg0 s2-0))
          (let ((v1-13
                  (and (!= sv-56 -1)
                       (begin (set! s0-0 (hover-nav-control-method-28 this arg1 s3-0)) (!= s0-0 -1))
                       (begin
                         (when (< (-> sv-52 s0-0 radius) (vector-vector-distance arg1 s3-0))
                           (set! sv-304 (new 'stack-no-clear 'vector))
                           (let ((v1-21 arg1)
                                 (a0-12 s3-0)
                                 )
                             (.lvf vf4 (&-> v1-21 quad))
                             (.lvf vf5 (&-> a0-12 quad))
                             )
                           (.mov.vf vf6 vf0 :mask #b1000)
                           (.sub.vf vf6 vf4 vf5 :mask #b111)
                           (.svf (&-> sv-304 quad) vf6)
                           (vector-normalize! sv-304 (-> sv-52 s0-0 radius))
                           (let ((v1-26 arg1))
                             (let ((a0-14 s3-0))
                               (.mov.vf vf6 vf0 :mask #b1000)
                               (.lvf vf4 (&-> a0-14 quad))
                               )
                             (.lvf vf5 (&-> sv-304 quad))
                             (.add.vf vf6 vf4 vf5 :mask #b111)
                             (.svf (&-> v1-26 quad) vf6)
                             )
                           0
                           )
                         (cond
                           ((= sv-56 s0-0)
                            (set! sv-272 (new 'stack-no-clear 'array 'float 16))
                            (let ((v1-31 (new 'stack-no-clear 'inline-array 'vector 4)))
                              (dotimes (a0-16 4)
                                (set! (-> v1-31 a0-16 quad) (the-as uint128 0))
                                )
                              (set! sv-276 v1-31)
                              )
                            (let ((v1-32 (new 'stack-no-clear 'inline-array 'vector 4)))
                              (dotimes (a0-19 4)
                                (set! (-> v1-32 a0-19 quad) (the-as uint128 0))
                                )
                              (set! sv-280 v1-32)
                              )
                            (set! sv-288 0)
                            (set! (-> sv-276 0 quad) (-> arg0 quad))
                            (set! (-> sv-276 1 quad) (-> s2-0 quad))
                            (set! (-> sv-276 2 quad) (-> s3-0 quad))
                            (set! (-> sv-276 3 quad) (-> arg1 quad))
                            (dotimes (s4-1 4)
                              (let ((s3-2 (+ s4-1 1)))
                                (while (< s3-2 4)
                                  ;; og:preserve-this
                                  (set! (-> (&+ sv-272 (+ (* s4-1 16) (* s3-2 4))) 0)
                                        (vector-vector-distance (-> sv-276 s4-1) (-> sv-276 s3-2))
                                        )
                                  (+! s3-2 1)
                                  )
                                )
                              )
                            (let ((v1-50 0)
                                  (f0-4 (-> sv-52 sv-56 radius))
                                  )
                              (while (begin (label cfg-30) (< v1-50 4))
                                (set! (-> sv-280 sv-288 quad) (-> sv-276 v1-50 quad))
                                (set! sv-288 (+ sv-288 1))
                                (+! v1-50 1)
                                (while (< v1-50 4)
                                  (if (< f0-4
                                         (-> (the-as (pointer float) (+ (+ (* v1-50 4) (* (+ v1-50 -1) 16)) (the-as int (the-as pointer sv-272)))))
                                         )
                                      (goto cfg-30)
                                      )
                                  (+! v1-50 1)
                                  )
                                (goto cfg-32)
                                )
                              )
                            (label cfg-32)
                            (when (< sv-288 4)
                              (set! (-> sv-280 sv-288 quad) (-> sv-276 3 quad))
                              (set! sv-288 (+ sv-288 1))
                              )
                            (if (< 1 sv-288)
                                (nav-network-method-23 (-> this nav) s5-0 (-> sv-280 0) (-> sv-280 1) -1 -1)
                                )
                            #t
                            )
                           ((and (nav-network-method-23 (-> this nav) s5-0 s3-0 arg1 -1 -1)
                                 (nav-network-method-25 (-> this nav) s5-0 sv-56 (the-as int s2-0) s0-0 s3-0)
                                 )
                            (nav-network-method-23
                              (-> this nav)
                              s5-0
                              (the-as vector (hover-nav-control-method-17 this))
                              (-> sv-48 (-> s5-0 segment-list pos-index 0) pos)
                              -1
                              (-> s5-0 segment-list pos-index 0)
                              )
                            #t
                            )
                           )
                         )
                       )
                  )
                )
            (if v1-13
                (hover-nav-control-method-31 this)
                0
                )
            )
          )
        )
      )
    0.0
    )
  )

(defmethod hover-nav-control-method-32 ((this hover-nav-control) (arg0 vector))
  (let ((a2-0 (the-as hover-nav-path-segment #f))
        (v1-0 (-> this path-info segment-list))
        )
    (while v1-0
      (cond
        (a2-0
          (vector-float*! (-> v1-0 curve-matrix fvec) (-> a2-0 curve-matrix trans) -1.0)
          )
        (arg0
          (set! (-> v1-0 curve-matrix fvec quad) (-> arg0 quad))
          )
        (else
          (vector-! (-> v1-0 curve-matrix fvec) (-> v1-0 curve-matrix uvec) (the-as vector (-> v1-0 curve-matrix)))
          (vector-float*! (-> v1-0 curve-matrix fvec) (-> v1-0 curve-matrix fvec) 0.5)
          )
        )
      (let ((a2-6 (-> v1-0 next)))
        (cond
          (a2-6
            (vector-!
              (-> v1-0 curve-matrix trans)
              (-> (the-as hover-nav-path-segment a2-6) curve-matrix uvec)
              (the-as vector (-> v1-0 curve-matrix))
              )
            (vector-float*! (-> v1-0 curve-matrix trans) (-> v1-0 curve-matrix trans) -0.5)
            )
          (else
            (set-vector! (-> v1-0 curve-matrix trans) 0.0 0.0 0.0 0.0)
            )
          )
        )
      (set! (-> v1-0 curve-matrix rvec w) 1.0)
      (set! (-> v1-0 curve-matrix uvec w) 1.0)
      (set! (-> v1-0 curve-matrix fvec w) 1.0)
      (set! (-> v1-0 curve-matrix trans w) 1.0)
      (set! a2-0 v1-0)
      (set! v1-0 (the-as hover-nav-path-segment (-> v1-0 next)))
      )
    )
  0
  (none)
  )

(defmethod hover-nav-control-method-33 ((this hover-nav-control))
  (* (-> this max-speed-multiplier) (-> this params max-speed))
  )

(defmethod hover-nav-control-method-34 ((this hover-nav-control))
  (* (-> this max-acceleration-multiplier) (-> this params max-acceleration))
  )

(defmethod set-multipliers ((this hover-nav-control) (arg0 float) (arg1 float))
  (set! (-> this max-speed-multiplier) arg0)
  (set! (-> this max-acceleration-multiplier) arg1)
  0
  (none)
  )

(defmethod hover-nav-control-method-18 ((this hover-nav-control) (arg0 path-control) (arg1 int) (arg2 int))
  (set! (-> this fixed-path-info path) arg0)
  (set! (-> this fixed-path-info start-index) (if (= arg1 -1)
                                                  0
                                                  arg1
                                                  )
        )
  (set! (-> this fixed-path-info end-index) (if (= arg2 -1)
                                                (the int (get-num-segments arg0))
                                                arg2
                                                )
        )
  (set! (-> this fixed-path-info current-index) (-> this fixed-path-info start-index))
  (set! (-> this fixed-path-info step)
        (if (< (-> this fixed-path-info start-index) (-> this fixed-path-info end-index))
            1
            -1
            )
        )
  (logior! (-> this flags) (hover-nav-flags hnf0))
  (logclear! (-> this flags) (hover-nav-flags hnf1))
  0
  (none)
  )

(defmethod hover-nav-control-method-19 ((this hover-nav-control))
  (set! (-> this fixed-path-info path) #f)
  (hover-nav-control-method-20 this)
  (logclear! (-> this flags) (hover-nav-flags hnf0 hnf1))
  0
  (none)
  )

(defmethod hover-nav-control-method-23 ((this hover-nav-control) (arg0 vector))
  (let* ((s3-0 (new 'stack-no-clear 'vector))
         (s5-0 (hover-nav-control-method-28 this arg0 s3-0))
         )
    (if s5-0
        (fmax 0.0 (- (vector-vector-distance arg0 s3-0) (-> this nav edge s5-0 radius)))
        40959960.0
        )
    )
  )

(defmethod hover-nav-control-method-24 ((this hover-nav-control) (arg0 vector) (arg1 vector))
  (!= (hover-nav-control-method-28 this arg1 arg0) -1)
  )

(defmethod hover-nav-control-method-17 ((this hover-nav-control))
  (-> (the-as collide-shape-prim-group (-> this root root-prim))
      child
      (-> this params nav-collide-prim-index)
      prim-core
      )
  )

(defmethod hover-nav-control-method-15 ((this hover-nav-control) (arg0 vector))
  (local-vars (sv-32 vector) (sv-36 collide-shape-moving))
  (set! sv-32 (new 'stack-no-clear 'vector))
  (set! sv-36 (-> this root))
  (vector-inv-orient-by-quat! sv-32 (-> sv-36 transv) (-> sv-36 quat))
  (vector-float*! arg0 sv-32 (/ 1.0 (hover-nav-control-method-33 this)))
  )

(defmethod hover-nav-control-method-16 ((this hover-nav-control) (arg0 vector))
  (local-vars (sv-32 vector))
  (set! sv-32 (new 'stack-no-clear 'vector))
  (vector-inv-orient-by-quat! sv-32 (-> this transvv) (-> this root quat))
  (vector-float*! arg0 sv-32 (/ 1.0 (hover-nav-control-method-34 this)))
  )

(defmethod hover-nav-control-method-10 ((this hover-nav-control) (arg0 vector) (arg1 vector) (arg2 vector))
  (set! (-> this dest-pos quad) (-> arg0 quad))
  (cond
    ;; og:preserve-this condition has been changed from `arg2` because some places call this method with #t as arg2
    ((and (!= arg2 #t) arg2) ; arg2
      (set! (-> this root transv quad) (-> arg2 quad))
      )
    (else
      (set! (-> this dest-vel quad) (the-as uint128 0))
      (set! (-> this root transv quad) (the-as uint128 0))
      )
    )
  (vector-normalize-copy! (-> this dest-move-dir) arg1 1.0)
  0
  (none)
  )

(defmethod hover-nav-control-method-12 ((this hover-nav-control) (arg0 vector))
  (local-vars (sv-16 int) (sv-128 collide-prim-core))
  (when *debug-hover*
    (if arg0
        (add-debug-sphere #t (bucket-id debug) arg0 (meters 0.9) *color-yellow*)
        )
    )
  (hover-nav-control-method-20 this)
  (cond
    ((logtest? (-> this flags) (hover-nav-flags hnf0))
     (let* ((s3-0 (-> this fixed-path-info))
            (s5-1 (-> s3-0 path))
            (s4-0 (hover-nav-control-method-17 this))
            )
       (set! sv-16 (cond
                     ((>= (-> s3-0 current-index) (+ (-> s3-0 end-index) -2))
                      (-> s3-0 current-index)
                      )
                     (else
                       (let ((f30-0 (path-control-method-29
                                      s5-1
                                      (the-as vector (hover-nav-control-method-17 this))
                                      (-> s3-0 current-index)
                                      (the-as float #f)
                                      )
                                    )
                             )
                         (if (< (path-control-method-29
                                  s5-1
                                  (the-as vector (hover-nav-control-method-17 this))
                                  (+ (-> s3-0 current-index) 1)
                                  (the-as float #f)
                                  )
                                f30-0
                                )
                             (+! (-> s3-0 current-index) 1)
                             )
                         )
                       (-> s3-0 current-index)
                       )
                     )
             )
       (cond
         ((>= sv-16 (+ (-> s3-0 end-index) -2))
          (let* ((s2-2 (-> this nav))
                 (s1-2 (method-of-object s2-2 nav-network-method-23))
                 (s0-0 (-> this path-info))
                 )
            (set! sv-128 s4-0)
            (let ((a3-4 (get-point-in-path! s5-1 (new 'stack-no-clear 'vector) (the float (-> s3-0 end-index)) 'interp))
                  (t0-1 -1)
                  (t1-0 -1)
                  )
              (s1-2 s2-2 s0-0 (the-as vector sv-128) a3-4 t0-1 t1-0)
              )
            )
          (let ((s2-3 (new 'stack-no-clear 'vector)))
            (if (and (< (path-control-method-29 s5-1 (the-as vector s4-0) (+ (-> s3-0 end-index) -1) (the-as float s2-3)) 12288.0)
                     (< (vector-vector-distance
                          s2-3
                          (get-point-at-percent-along-path! s5-1 (new 'stack-no-clear 'vector) 1.0 'interp)
                          )
                        2048.0
                        )
                     )
                (logior! (-> this flags) (hover-nav-flags hnf1))
                )
            )
          )
         (else
           (let ((s2-4 (new 'stack-no-clear 'vector)))
             (let ((s3-1 (+ (-> s3-0 end-index) -2)))
               (while (< sv-16 s3-1)
                 (let ((s1-3 (get-point-in-path! s5-1 (new 'stack-no-clear 'vector) (the float s3-1) 'interp)))
                   (let ((a3-9 (get-point-in-path! s5-1 (new 'stack-no-clear 'vector) (the float (+ s3-1 1)) 'interp)))
                     (nav-network-method-23 (-> this nav) (-> this path-info) s1-3 a3-9 -1 -1)
                     )
                   (set! (-> s2-4 quad) (-> s1-3 quad))
                   )
                 (+! s3-1 -1)
                 )
               )
             (nav-network-method-23 (-> this nav) (-> this path-info) (the-as vector s4-0) s2-4 -1 -1)
             )
           )
         )
       )
     (hover-nav-control-method-31 this)
     )
    (arg0
      (hover-nav-control-method-30 this (the-as vector (hover-nav-control-method-17 this)) arg0)
      )
    )
  0
  (none)
  )

(defmethod hover-nav-control-method-25 ((this hover-nav-control))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-1 (-> this path-info curr-segment)))
      (when v1-1
        (let ((a2-1 (matrix*! (new 'stack-no-clear 'matrix) *hermite-matrix* (-> v1-1 curve-matrix))))
          (new 'stack-no-clear 'vector)
          (let ((a1-1 (new 'stack-no-clear 'vector)))
            (let ((f0-0 (-> this u-param)))
              (set-vector! a1-1 (* 6.0 f0-0) 2.0 0.0 0.0)
              )
            (vector-matrix*! (-> this transvv) a1-1 a2-1)
            )
          )
        (vector-length-max! (-> this transvv) (-> this params max-acceleration))
        (let ((a1-3 (-> this transvv))
              (v1-5 (-> this transvv))
              (a0-7 (new 'stack-no-clear 'vector))
              )
          (.lvf vf1 (&-> (-> this nav-collide-impulse) quad))
          (let ((f0-6 (seconds-per-frame)))
            (.mov at-0 f0-6)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> a0-7 quad) vf1)
          (vector+! a1-3 v1-5 a0-7)
          )
        (vector-v++! (-> this root transv) (-> this transvv))
        (vector-length-max! (-> this root transv) (-> this params max-speed))
        (vector-v++! (-> this root trans) (-> this root transv))
        )
      )
    0
    (none)
    )
  )

(defmethod hover-nav-control-method-13 ((this hover-nav-control))
  (hover-nav-control-method-25 this)
  (let ((v1-2 (-> this root))
        (a2-0 (new 'stack-no-clear 'collide-query))
        )
    (set! (-> a2-0 collide-with) (-> v1-2 root-prim prim-core collide-with))
    (set! (-> a2-0 ignore-process0) (-> v1-2 process))
    (set! (-> a2-0 ignore-process1) #f)
    (set! (-> a2-0 ignore-pat)
          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
          )
    (set! (-> a2-0 action-mask) (collide-action solid))
    (fill-cache-integrate-and-collide v1-2 (-> v1-2 transv) a2-0 (meters 0))
    )
  0
  (none)
  )

;; ERROR: Stack slot load at 128 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 144 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 128 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 144 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 128 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 144 mismatch: defined as size 4, got size 16
(defmethod hover-nav-control-method-11 ((this hover-nav-control))
  (local-vars (sv-48 vector) (sv-128 float) (sv-144 float))
  (let ((s5-0 (-> this root)))
    (let ((s4-0 (hover-nav-control-method-17 this)))
      (let ((v1-2 (vector-! (new 'stack-no-clear 'vector) (the-as vector s4-0) (-> s5-0 trans))))
        (set! sv-48 (vector-! (new 'stack-no-clear 'vector) (-> this dest-pos) v1-2))
        )
      (when (not (logtest? (-> this flags) (hover-nav-flags hnf0)))
        (let* ((s3-0 (-> this root transv))
               (f30-0 (vector-length s3-0))
               (s2-0 lerp-scale)
               (s1-0 0.0)
               (s0-0 (hover-nav-control-method-33 this))
               )
          (set! sv-128 (* 2.0 f30-0))
          (set! sv-144 (the-as float 0.0))
          (let* ((t0-0 (hover-nav-control-method-33 this))
                 (f0-4 (s2-0 s1-0 s0-0 sv-128 sv-144 t0-0))
                 (t0-2 (vector+float*! (new 'stack-no-clear 'vector) (the-as vector s4-0) s3-0 (/ f0-4 f30-0)))
                 (s4-1 (nav-network-method-27
                         (-> this nav)
                         (new 'stack-no-clear 'vector)
                         (-> this root process)
                         (the-as vector s4-0)
                         t0-2
                         (-> s4-0 world-sphere w)
                         )
                       )
                 )
            (let ((f0-7 (vector-length s4-1)))
              (seek! (-> this nav-collide-impulse-len) f0-7 (* (hover-nav-control-method-34 this) (seconds-per-frame)))
              )
            (vector-normalize-copy! (-> this nav-collide-impulse) s4-1 (- (-> this nav-collide-impulse-len)))
            )
          )
        0
        )
      )
    (let ((f30-1 (hover-nav-control-method-34 this))
          (f28-0 (hover-nav-control-method-33 this))
          )
      (vector-z-quaternion! (-> this move-dir) (-> s5-0 quat))
      (set! (-> this speed) (vector-length (-> s5-0 transv)))
      (vector-! (-> this dest-offset) sv-48 (-> s5-0 trans))
      (let ((s4-2 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> this dest-offset) 1.0))
            (v0-12 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 transv) 1.0))
            )
        (set! (-> this speed-dest) (vector-dot (-> s5-0 transv) s4-2))
        (set! (-> this local-dist) (vector-dot v0-12 (-> this dest-offset)))
        )
      (let* ((f0-19 (fmax 0.0 (+ -2048.0 (vector-length (-> this dest-offset)))))
             (f1-5 (sqrtf (* 1.6 f0-19 f30-1)))
             (f0-22 0.0)
             )
        (seek! (-> this target-speed) (fmax (fmin f1-5 f28-0) f0-22) (* 0.9 (seconds-per-frame) f30-1))
        )
      )
    )
  0
  (none)
  )

(defun hover-bounce-reaction ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (vector-reflect! s4-0 arg3 (-> arg0 surface-normal))
    (vector-float*! arg2 s4-0 0.4)
    )
  (-> arg0 status)
  )

(defmethod hover-nav-control-method-9 ((this hover-nav-control))
  (hover-nav-control-method-20 this)
  0
  (none)
  )

(defmethod relocate ((this hover-nav-control) (offset int))
  (if (nonzero? (-> this root))
      (&+! (-> this root) offset)
      )
  (when (-> this fixed-path-info path)
    (if (nonzero? (-> this fixed-path-info path))
        (&+! (-> this fixed-path-info path) offset)
        )
    )
  this
  )

(defmethod new hover-nav-control ((allocation symbol) (type-to-make type) (arg0 process) (arg1 collide-shape-moving) (arg2 hover-nav-params))
  (let ((s5-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> s5-0 root) arg1)
    (set! (-> s5-0 root reaction) hover-bounce-reaction)
    (set! (-> s5-0 fixed-path-info path) #f)
    (set! (-> s5-0 nav) *nav-network*)
    (set! (-> s5-0 path-info segment-list) #f)
    (set! (-> s5-0 path-info tail-segment) #f)
    (set! (-> s5-0 path-info curr-segment) #f)
    (set! (-> s5-0 flags) (hover-nav-flags))
    (set! (-> s5-0 sub-graph)
          (if (-> arg0 entity)
              (res-lump-value (-> arg0 entity) 'hover-enemy-sub-graph int :default (the-as uint128 -1) :time -1000000000.0)
              -1
              )
          )
    (set! (-> s5-0 params) arg2)
    (set! *hover-nav-time-offset* (+ *hover-nav-time-offset* 1))
    (vector-reset! (-> s5-0 dest-pos))
    (set! (-> s5-0 dest-vel quad) (the-as uint128 0))
    (set! (-> s5-0 dest-move-dir quad) (the-as uint128 0))
    (set! (-> s5-0 dest-offset quad) (the-as uint128 0))
    (set! (-> s5-0 nav-collide-impulse quad) (the-as uint128 0))
    (vector-z-quaternion! (-> s5-0 move-dir) (-> s5-0 root quat))
    (set! (-> s5-0 nav-collide-impulse-len) 0.0)
    (set! (-> s5-0 speed) 0.0)
    (set! (-> s5-0 target-speed) 0.0)
    (set! (-> s5-0 target-acceleration) 0.0)
    (set! (-> s5-0 speed-dest) 0.0)
    (set! (-> s5-0 curr-dest-pt) -1)
    (set-multipliers s5-0 1.0 1.0)
    (nav-network-method-26 (-> s5-0 nav) arg0 (the-as collide-prim-core #f))
    s5-0
    )
  )
