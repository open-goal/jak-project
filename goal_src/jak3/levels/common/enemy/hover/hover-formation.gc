;;-*-Lisp-*-
(in-package goal)

;; name: hover-formation.gc
;; name in dgo: hover-formation
;; dgos: TEMA, SEA, FACC, LFORM, FACD, LPATK, TOWERA, PRECA, VOCA

;; DECOMP BEGINS

(defmethod is-formation-type-in-range ((this hover-formation-control))
  (case (-> this formation-type)
    (((formation-type unknown-2) (formation-type unknown-3) (formation-type unknown-0))
     #f
     )
    (else
      #t
      )
    )
  )

(defmethod hover-formation-control-method-16 ((this hover-formation-control))
  (let ((gp-0 (hover-formation-control-method-13 this (new 'stack-no-clear 'vector)))
        (s4-0 (cond
                ((-> this anchor-proc)
                 (let ((s3-0 (handle->process (-> this anchor-proc))))
                   (if (type? s3-0 process-focusable)
                       s3-0
                       )
                   )
                 )
                (else
                  *target*
                  )
                )
              )
        )
    (and s4-0
         (< (vector-vector-distance gp-0 (get-trans (the-as process-focusable s4-0) 0)) (-> this notice-dist))
         (or (not (logtest? (-> this flags) 1))
             (< (- (-> gp-0 y) (-> (get-trans (the-as process-focusable s4-0) 0) y)) 16384.0)
             )
         )
    )
  )

(defmethod set-anchor-proc ((this hover-formation-control) (arg0 handle))
  (set! (-> this anchor-proc) arg0)
  0
  )

(defmethod hover-formation-control-method-13 ((this hover-formation-control) (arg0 vector))
  (with-pp
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer pp))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) 'path)
      (let* ((t9-0 send-event-function)
             (v1-2 (-> this entity))
             (s4-0 (the-as path-control (t9-0
                                          (if v1-2
                                              (-> v1-2 extra process)
                                              )
                                          a1-1
                                          )
                           )
                   )
             (s1-0 (cond
                     ((-> this anchor-proc)
                      (let ((s3-0 (handle->process (-> this anchor-proc))))
                        (if (type? s3-0 process-focusable)
                            s3-0
                            )
                        )
                      )
                     (else
                       *target*
                       )
                     )
                   )
             )
        (cond
          (s1-0
            (let ((s2-0 (get-trans (the-as process-focusable s1-0) 3))
                  (s3-1 (new 'stack-no-clear 'vector))
                  )
              (set! (-> s3-1 quad) (-> (get-trans (the-as process-focusable s1-0) 1) quad))
              (if (= (-> s3-1 y) -40959590.0)
                  (set! (-> s3-1 quad) (-> s2-0 quad))
                  (+! (-> s3-1 y) 6144.0)
                  )
              (cond
                ((and s4-0 (begin
                             (let ((f0-3 (path-control-method-23 s4-0 s2-0)))
                               (get-point-at-percent-along-path! s4-0 arg0 f0-3 'interp)
                               )
                             (>= 40960.0 (vector-vector-xz-distance s3-1 arg0))
                             )
                      )
                 (set! (-> arg0 y) (-> s3-1 y))
                 )
                (else
                  (set! (-> arg0 quad) (-> s3-1 quad))
                  (set! (-> arg0 w) 1.0)
                  )
                )
              )
            )
          (else
            (set! (-> arg0 quad) (-> this center quad))
            )
          )
        )
      )
    (let ((f30-1 (-> arg0 y)))
      (nav-network-method-35 *nav-network* arg0 arg0 (-> this sub-graph-mask))
      (set! (-> arg0 y) f30-1)
      )
    0
    arg0
    )
  )

(defmethod hover-formation-control-method-14 ((this hover-formation-control))
  (with-pp
    (when (not (logtest? (-> this flags) 4))
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer pp))
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'path)
        (let* ((t9-0 send-event-function)
               (v1-5 (-> this entity))
               (s5-0 (the-as path-control (t9-0
                                            (if v1-5
                                                (-> v1-5 extra process)
                                                )
                                            a1-0
                                            )
                             )
                     )
               (a0-7 (cond
                       ((-> this anchor-proc)
                        (let ((s4-0 (handle->process (-> this anchor-proc))))
                          (if (type? s4-0 process-focusable)
                              s4-0
                              )
                          )
                        )
                       (else
                         *target*
                         )
                       )
                     )
               )
          (cond
            ((and s5-0 a0-7)
             (let ((f30-1
                     (fmin
                       1.0
                       (+ 0.1 (path-control-method-23 s5-0 (hover-formation-control-method-13 this (new 'stack-no-clear 'vector))))
                       )
                     )
                   )
               (let ((s4-2 (new 'stack-no-clear 'vector)))
                 (displacement-between-points-at-percent-normalized! s5-0 s4-2 f30-1)
                 (forward-up-nopitch->inv-matrix (-> this zone-to-world) s4-2 *up-vector*)
                 )
               (set! (-> this zone-to-world trans quad)
                     (-> (get-point-at-percent-along-path! s5-0 (new 'stack-no-clear 'vector) f30-1 'interp) quad)
                     )
               )
             (matrix-inverse-of-rot-trans! (-> this world-to-zone) (-> this zone-to-world))
             )
            ((logtest? (-> this flags) 8)
             (let ((s5-1 (hover-formation-control-method-13 this (new 'stack-no-clear 'vector))))
               (let ((s4-5 (vector-! (new 'stack-no-clear 'vector) (-> this entity extra trans) s5-1)))
                 (vector-normalize! s4-5 1.0)
                 (forward-up-nopitch->inv-matrix (-> this zone-to-world) s4-5 *up-vector*)
                 )
               (set! (-> this zone-to-world trans quad) (-> s5-1 quad))
               )
             (matrix-inverse-of-rot-trans! (-> this world-to-zone) (-> this zone-to-world))
             )
            (a0-7
              (let* ((a1-15
                       (quaternion-slerp!
                         (-> this focus-quat)
                         (-> this focus-quat)
                         (get-quat (the-as process-focusable a0-7) 2)
                         (* 0.001 (seconds-per-frame))
                         )
                       )
                     (a1-16 (vector-z-quaternion! (new 'stack-no-clear 'vector) a1-15))
                     )
                (forward-up-nopitch->inv-matrix (-> this zone-to-world) a1-16 *up-vector*)
                )
              (set! (-> this zone-to-world trans quad)
                    (-> (hover-formation-control-method-13 this (new 'stack-no-clear 'vector)) quad)
                    )
              (matrix-inverse-of-rot-trans! (-> this world-to-zone) (-> this zone-to-world))
              )
            )
          )
        )
      (when (and (logtest? (-> this flags) 16) *nav-network*)
        (let ((a1-20 (vector+float*!
                       (new 'stack-no-clear 'vector)
                       (-> this zone-to-world trans)
                       (-> this zone-to-world fvec)
                       (-> this offset 0 z)
                       )
                     )
              (s4-7 (new 'stack-no-clear 'vector))
              )
          (when (nav-network-method-33 *nav-network* a1-20 s4-7 (-> this sub-graph-mask))
            (let ((s5-5 (vector-! (new 'stack-no-clear 'vector) s4-7 (-> this zone-to-world trans)))
                  (s4-8 (new 'stack-no-clear 'vector))
                  )
              (set! (-> s4-8 quad) (-> this zone-to-world trans quad))
              (set! (-> s5-5 y) 0.0)
              (vector-normalize! s5-5 1.0)
              (forward-up-nopitch->inv-matrix (-> this zone-to-world) s5-5 *up-vector*)
              (set! (-> this zone-to-world trans quad) (-> s4-8 quad))
              )
            (matrix-inverse-of-rot-trans! (-> this world-to-zone) (-> this zone-to-world))
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod hover-formation-control-method-15 ((this hover-formation-control) (arg0 vector) (arg1 vector))
  (vector-matrix*!
    arg0
    (hover-formation-control-method-13 this (new 'stack-no-clear 'vector))
    (-> this world-to-zone)
    )
  (vector+! arg0 arg0 arg1)
  (vector-matrix*! arg0 arg0 (-> this zone-to-world))
  )

(deftype gen-perms-context (structure)
  ((num            int32)
   (table          uint32)
   (iterate-count  int32)
   )
  )


(defun gen-perms ((arg0 int)
         (arg1 (function int int form-search-info uint))
         (arg2 (function form-search-info float))
         (arg3 form-search-info)
         )
  (local-vars (sv-80 int))
  (let ((s2-0 (new 'stack-no-clear 'array 'int32 32)))
    (dotimes (v1-0 arg0)
      (set! (-> s2-0 v1-0) 0)
      )
    (arg2 arg3)
    (let ((s1-0 1))
      (while (< s1-0 arg0)
        (cond
          ((>= (-> s2-0 s1-0) s1-0)
           (set! (-> s2-0 s1-0) 0)
           0
           )
          (else
            (let ((s0-0 arg1))
              (set! sv-80 s1-0)
              (let ((a1-1 (if (odd? s1-0)
                              (-> s2-0 s1-0)
                              0
                              )
                          )
                    (a2-1 arg3)
                    )
                (s0-0 sv-80 a1-1 a2-1)
                )
              )
            (+! (-> s2-0 s1-0) 1)
            (arg2 arg3)
            (set! s1-0 0)
            )
          )
        (+! s1-0 1)
        )
      )
    )
  #f
  )

(defun test-gen-perms ((arg0 int))
  (let ((gp-0 (new 'stack-no-clear 'gen-perms-context))
        (s4-0 (new 'stack 'gen-perms-context))
        )
    (dotimes (v1-1 arg0)
      (set! (-> (the-as (pointer int32) (+ (the-as uint gp-0) (* v1-1 4)))) v1-1)
      )
    (set! (-> s4-0 num) arg0)
    (set! (-> s4-0 table) (the-as uint gp-0))
    (set! (-> s4-0 iterate-count) 0)
    (gen-perms
      arg0
      (the-as
        (function int int form-search-info uint)
        (lambda ((arg0 int) (arg1 int) (arg2 (pointer object)))
          (let ((v0-0 (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg0 4))))))
            (set! (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg0 4))))
                  (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg1 4))))
                  )
            (set! (-> (the-as (pointer int32) (+ (the-as uint (-> arg2 1)) (* arg1 4)))) v0-0)
            v0-0
            )
          )
        )
      (the-as
        (function form-search-info float)
        (lambda ((arg0 vector))
          (format #t "(")
          (dotimes (s5-0 (the-as int (-> arg0 x)))
            (format #t "~d " (-> (the-as (pointer int32) (+ (the-as uint (-> arg0 y)) (* s5-0 4)))))
            )
          (format #t ")~%")
          )
        )
      (the-as form-search-info s4-0)
      )
    (format #t "iterate-count: ~d~%" (-> s4-0 iterate-count))
    )
  )

;; WARN: disable def twice: 125. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod hover-formation-control-method-10 ((this hover-formation-control) (arg0 vector) (arg1 vector) (arg2 float))
  (vector-rotate-y! arg0 arg1 arg2)
  (cond
    ((logtest? (-> this flags) 2)
     (let ((s4-0 (hover-formation-control-method-15 this (new 'stack-no-clear 'vector) arg0))
           (s3-0 (new 'stack-no-clear 'vector))
           )
       (set! (-> s3-0 quad) (-> this zone-to-world trans quad))
       (let ((s5-1 (new 'stack-no-clear 'collide-query))
             (gp-1 (new 'stack-no-clear 'collide-query))
             )
         (let ((s2-0 (new 'stack-no-clear 'vector))
               (f30-0 819.2)
               )
           (vector-normalize! (vector-! s2-0 s4-0 s3-0) 6144.0)
           (vector+! s4-0 s4-0 s2-0)
           (vector-normalize! (vector-! s2-0 s3-0 s4-0) (+ 204.8 f30-0))
           (vector-! s3-0 s3-0 s2-0)
           (set! (-> s5-1 start-pos quad) (-> s4-0 quad))
           (vector-! (-> s5-1 move-dist) s3-0 (-> s5-1 start-pos))
           (let ((f0-2 (vector-length (-> s5-1 move-dist))))
             (if (< 81920.0 f0-2)
                 (vector-float*! (-> s5-1 move-dist) (-> s5-1 move-dist) (/ 81920.0 f0-2))
                 )
             )
           (set! (-> gp-1 start-pos quad) (-> s3-0 quad))
           (vector-! (-> gp-1 move-dist) s4-0 (-> gp-1 start-pos))
           (let ((f0-4 (vector-length (-> gp-1 move-dist))))
             (if (< 81920.0 f0-4)
                 (vector-float*! (-> gp-1 move-dist) (-> gp-1 move-dist) (/ 81920.0 f0-4))
                 )
             )
           (let ((v1-27 s5-1))
             (set! (-> v1-27 radius) f30-0)
             (set! (-> v1-27 collide-with) (collide-spec backgnd))
             (set! (-> v1-27 ignore-process0) #f)
             (set! (-> v1-27 ignore-process1) #f)
             (set! (-> v1-27 ignore-pat)
                   (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                   )
             (set! (-> v1-27 action-mask) (collide-action solid))
             )
           (let ((v1-28 gp-1))
             (set! (-> v1-28 radius) f30-0)
             (set! (-> v1-28 collide-with) (collide-spec backgnd))
             (set! (-> v1-28 ignore-process0) #f)
             (set! (-> v1-28 ignore-process1) #f)
             (set! (-> v1-28 ignore-pat)
                   (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                   )
             (set! (-> v1-28 action-mask) (collide-action solid))
             )
           )
         (fill-using-line-sphere *collide-cache* s5-1)
         (and (< (probe-using-line-sphere *collide-cache* s5-1) 0.0)
              (< (probe-using-line-sphere *collide-cache* gp-1) 0.0)
              )
         )
       )
     )
    (else
      #t
      )
    )
  )

(defmethod hover-formation-control-method-11 ((this hover-formation-control))
  (let ((s5-0 (-> this search-info)))
    (set! (-> s5-0 form) (the-as uint this))
    (let ((v1-0 (new 'stack-no-clear 'inline-array 'vector 16)))
      (dotimes (a0-1 16)
        (set! (-> v1-0 a0-1 quad) (the-as uint128 0))
        )
      (set! (-> s5-0 pos-table) v1-0)
      )
    (set! (-> s5-0 best-cost) -1.0)
    (set! (-> s5-0 count) 0)
    (dotimes (s4-0 16)
      (let* ((s3-0 (handle->process (-> this actor-table s4-0)))
             (a0-8 (if (type? s3-0 process-focusable)
                       s3-0
                       )
                   )
             )
        (cond
          (a0-8
            (set! (-> s5-0 actor-position s4-0 quad) (-> (get-trans (the-as process-focusable a0-8) 3) quad))
            (set! (-> s5-0 actor-valid? s4-0) #t)
            (+! (-> s5-0 count) 1)
            )
          (else
            (set! (-> s5-0 actor-valid? s4-0) #f)
            )
          )
        )
      (set! (-> s5-0 index-table s4-0) (the-as uint s4-0))
      (set! (-> s5-0 best-mapping s4-0) (the-as uint s4-0))
      )
    (let* ((f30-0 (-> this rotation-inc))
           (f28-0 f30-0)
           (s3-2 (the int (* 0.5 (/ 65536.0 f30-0))))
           (s4-1 0)
           )
      (let ((s2-0 (new 'stack-no-clear 'vector)))
        (when (and (> (-> s5-0 count) 0) (hover-formation-control-method-10 this s2-0 (the-as vector (-> this offset)) 0.0))
          (set! (-> s5-0 pos-table s4-1 quad) (-> s2-0 quad))
          (+! s4-1 1)
          )
        (let ((s1-0 0))
          (while (not (or (>= s1-0 s3-2) (>= s4-1 (-> s5-0 count))))
            (when (hover-formation-control-method-10 this s2-0 (-> this offset (logand (+ s1-0 1) 1)) f28-0)
              (set! (-> s5-0 pos-table s4-1 quad) (-> s2-0 quad))
              (+! s4-1 1)
              )
            (when (hover-formation-control-method-10 this s2-0 (-> this offset (logand (+ s1-0 1) 1)) (- f28-0))
              (set! (-> s5-0 pos-table s4-1 quad) (-> s2-0 quad))
              (+! s4-1 1)
              )
            (+! f28-0 f30-0)
            (+! s1-0 1)
            )
          )
        )
      (when (< s4-1 (-> s5-0 count))
        (let ((f28-1 0.0)
              (s3-3 (- (-> s5-0 count) s4-1))
              )
          (dotimes (s2-1 s3-3)
            (vector-rotate-y! (-> s5-0 pos-table s4-1) (-> this offset (logand (+ s2-1 1) 1)) f28-1)
            (+! f28-1 (* (the float (+ s2-1 1)) f30-0))
            (set! f30-0 (* -1.0 f30-0))
            (+! s4-1 1)
            )
          )
        )
      )
    (dotimes (s4-2 (-> s5-0 count))
      (hover-formation-control-method-15 this (-> s5-0 dest-pos-table s4-2) (-> s5-0 pos-table s4-2))
      )
    (if (< 1 (-> s5-0 count))
        (gen-perms
          (-> s5-0 count)
          (lambda ((arg0 int) (arg1 int) (arg2 form-search-info))
            (let ((v0-0 (-> arg2 index-table arg0)))
              (set! (-> arg2 index-table arg0) (-> arg2 index-table arg1))
              (set! (-> arg2 index-table arg1) v0-0)
              v0-0
              )
            )
          (lambda ((arg0 form-search-info))
            (let ((s5-0 0)
                  (f30-0 0.0)
                  )
              (dotimes (s4-0 (-> arg0 count))
                (when (-> arg0 actor-valid? s4-0)
                  (+! f30-0
                      (vector-vector-distance (-> arg0 actor-position s4-0) (-> arg0 dest-pos-table (-> arg0 index-table s5-0)))
                      )
                  (+! s5-0 1)
                  )
                )
              (when (or (= (-> arg0 best-cost) -1.0) (< f30-0 (-> arg0 best-cost)))
                (dotimes (v1-18 16)
                  (set! (-> arg0 best-mapping v1-18) (-> arg0 index-table v1-18))
                  )
                (set! (-> arg0 best-cost) f30-0)
                f30-0
                )
              )
            )
          s5-0
          )
        )
    (let ((s4-3 0))
      (dotimes (s3-4 16)
        (let ((a0-31 (handle->process (-> this actor-table s3-4))))
          (when a0-31
            (send-event a0-31 'update-formation (-> s5-0 pos-table (-> s5-0 best-mapping s4-3)))
            (+! s4-3 1)
            )
          )
        )
      )
    )
  0
  )

(defmethod hover-formation-control-method-17 ((this hover-formation-control) (arg0 process))
  (let ((v1-2 (process->handle arg0))
        (a2-0 -1)
        (a1-4 -1)
        )
    (dotimes (a3-0 16)
      (when (= v1-2 (-> this actor-table a3-0))
        (set! a2-0 a3-0)
        (goto cfg-17)
        )
      (if (and (not (-> this actor-table a3-0)) (= a1-4 -1))
          (set! a1-4 a3-0)
          )
      )
    (label cfg-17)
    (when (= a2-0 -1)
      (cond
        ((= a1-4 -1)
         (format 0 "ERROR!!! Too many actors in formation. Currently there is a maximum of ~M. ~%" 16)
         )
        (else
          (when (!= a1-4 -1)
            (set! (-> this actor-table a1-4) (the-as handle v1-2))
            (hover-formation-control-method-11 this)
            )
          )
        )
      )
    )
  0
  )

(defmethod hover-formation-control-method-18 ((this hover-formation-control) (arg0 process))
  (let ((v1-2 (process->handle arg0)))
    (dotimes (a1-4 16)
      (when (= v1-2 (-> this actor-table a1-4))
        (set! (-> this actor-table a1-4) (the-as handle #f))
        (hover-formation-control-method-11 this)
        #t
        (goto cfg-12)
        )
      )
    )
  (label cfg-12)
  0
  )

(defmethod try-update-formation-type ((this hover-formation-control) (arg0 formation-type))
  (when (!= (-> this formation-type) arg0)
    (set! (-> this formation-type) arg0)
    (hover-formation-control-method-11 this)
    )
  0
  )

(defmethod new hover-formation-control ((allocation symbol)
                                      (type-to-make type)
                                      (arg0 hover-formation)
                                      (arg1 entity)
                                      (arg2 float)
                                      (arg3 vector)
                                      (arg4 float)
                                      (arg5 handle)
                                      )
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 entity) arg1)
    (set! (-> gp-0 anchor-proc) arg5)
    (set! (-> gp-0 flags) (the-as uint 0))
    (set! (-> gp-0 notice-dist) arg2)
    (set! (-> gp-0 rotation-inc) arg4)
    (set! (-> gp-0 offset 0 quad) (-> arg3 quad))
    (let ((a1-2 (-> gp-0 offset 1))
          (v1-3 (-> gp-0 offset))
          (a0-2 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-2 x) 0.0)
      (set! (-> a0-2 y) 10240.0)
      (set! (-> a0-2 z) 24576.0)
      (set! (-> a0-2 w) 1.0)
      (vector+! a1-2 (the-as vector v1-3) a0-2)
      )
    (set! (-> gp-0 center quad) (-> gp-0 entity extra trans quad))
    (quaternion-copy! (-> gp-0 focus-quat) *unity-quaternion*)
    (let ((v1-6 (res-lump-value (-> gp-0 entity) 'options uint128 :time -1000000000.0)))
      (if (logtest? (the-as int v1-6) 256)
          (logior! (-> gp-0 flags) 1)
          )
      (if (logtest? #x20000 v1-6)
          (logior! (-> gp-0 flags) 2)
          )
      (if (logtest? #x40000 v1-6)
          (logior! (-> gp-0 flags) 8)
          )
      (if (logtest? #x80000 v1-6)
          (logior! (-> gp-0 flags) 16)
          )
      )
    (dotimes (v1-11 16)
      (set! (-> gp-0 actor-table v1-11) (the-as handle #f))
      )
    (let ((f0-6 (res-lump-float (-> gp-0 entity) 'rotoffset)))
      (matrix-rotate-y! (-> gp-0 zone-to-world) f0-6)
      )
    (set! (-> gp-0 zone-to-world trans quad) (-> gp-0 center quad))
    (matrix-inverse-of-rot-trans! (-> gp-0 world-to-zone) (-> gp-0 zone-to-world))
    (set! (-> gp-0 formation-type) (res-lump-value
                                     (-> gp-0 entity)
                                     'formation-type
                                     formation-type
                                     :default (the-as uint128 3)
                                     :time -1000000000.0
                                     )
          )
    (let ((v1-19
            (res-lump-value (-> arg0 entity) 'hover-enemy-sub-graph int :default (the-as uint128 -1) :time -1000000000.0)
            )
          )
      (set! (-> gp-0 sub-graph-mask) (if (!= v1-19 -1)
                                         (ash 1 v1-19)
                                         -1
                                         )
            )
      )
    gp-0
    )
  )

(defstate idle (hover-formation)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('join)
       (hover-formation-control-method-17 (-> self formation) proc)
       )
      (('leave)
       (hover-formation-control-method-18 (-> self formation) proc)
       )
      (('set-type)
       (let ((a1-11 1))
         (case (-> block param 0)
           (('line)
            (set! a1-11 0)
            )
           (('circle)
            (set! a1-11 2)
            )
           (('semicircle)
            (set! a1-11 3)
            )
           )
         (try-update-formation-type (-> self formation) (the-as formation-type a1-11))
         )
       )
      (('update-sphere)
       (hover-formation-control-method-20 (-> self formation) (process->handle proc) (-> block param 0))
       )
      (('get-formation)
       (-> self formation)
       )
      (('set-los)
       (cond
         ((-> block param 0)
          (set! v0-0 (logior (-> self formation flags) 2))
          (set! (-> self formation flags) (the-as uint v0-0))
          )
         (else
           (set! v0-0 (logand -3 (-> self formation flags)))
           (set! (-> self formation flags) (the-as uint v0-0))
           )
         )
       v0-0
       )
      (('path)
       (if (not (logtest? (-> self path flags) (path-control-flag not-found)))
           (-> self path)
           )
       )
      )
    )
  :code sleep-code
  :post (behavior ()
    (when *target*
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer self))
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'get-turret)
        (let ((a1-1 (send-event-function *target* a1-0)))
          (if a1-1
              (set-anchor-proc (-> self formation) (the-as handle a1-1))
              (set-anchor-proc (-> self formation) (process->handle *target*))
              )
          )
        )
      )
    (hover-formation-control-method-14 (-> self formation))
    (when (and (logtest? (-> self formation flags) 2) (time-elapsed? (-> self formation-timer) (seconds 0.2)))
      (hover-formation-control-method-11 (-> self formation))
      (set-time! (-> self formation-timer))
      )
    (if (not (logtest? (-> self path flags) (path-control-flag not-found)))
        (debug-draw (-> self path))
        )
    0
    )
  )

(defmethod relocate ((this hover-formation) (offset int))
  (if (nonzero? (-> this formation))
      (&+! (-> this formation) offset)
      )
  (if (nonzero? (-> this path))
      (&+! (-> this path) offset)
      )
  (call-parent-method this offset)
  )

(defmethod hover-formation-method-15 ((this hover-formation) (arg0 vector) (arg1 vector))
  0
  )

(defmethod init-from-entity! ((this hover-formation) (arg0 entity-actor))
  (local-vars (sv-32 vector))
  (stack-size-set! (-> this main-thread) 32)
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 (-> this entity) #f))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (let* ((s5-0 (method-of-type hover-formation-control new))
         (s4-0 'process)
         (s3-0 hover-formation-control)
         (s2-0 this)
         (v0-2 (entity-actor-lookup (-> this entity) 'alt-actor 0))
         (s1-0 (if v0-2
                   v0-2
                   (-> this entity)
                   )
               )
         (s0-0 (res-lump-float (-> this entity) 'notice-dist :default 225280.0))
         )
    (let ((t9-4 (method-of-type res-lump get-property-struct))
          (a0-6 (-> this entity))
          (a1-5 'trans-offset)
          (a2-3 'interp)
          (a3-2 -1000000000.0)
          (t0-2 (new 'stack-no-clear 'vector))
          )
      (set! (-> t0-2 x) 0.0)
      (set! (-> t0-2 y) 20480.0)
      (set! (-> t0-2 z) 61440.0)
      (set! (-> t0-2 w) 1.0)
      (set! sv-32 (the-as vector (t9-4 a0-6 a1-5 a2-3 a3-2 t0-2 (the-as (pointer res-tag) #f) *res-static-buf*)))
      )
    (let ((t2-4 (res-lump-float (-> this entity) 'formation-rotinc :default 5461.3335))
          (t3-0 #f)
          )
      (set! (-> this formation) (s5-0 s4-0 s3-0 s2-0 s1-0 s0-0 sv-32 t2-4 (the-as handle t3-0)))
      )
    )
  (set-time! (-> this formation-timer))
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((t9-7 process-entity-status!)
        (a0-10 this)
        (a1-8 8)
        (a2-6 #t)
        )
    (t9-7 a0-10 (the-as entity-perm-status a1-8) a2-6)
    (hover-formation-method-15 this (the-as vector a1-8) (the-as vector a2-6))
    )
  (go (method-of-object this idle))
  )

(deftype flying-formation (hover-formation)
  ()
  )
