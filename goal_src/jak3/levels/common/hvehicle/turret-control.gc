;;-*-Lisp-*-
(in-package goal)

;; name: turret-control.gc
;; name in dgo: turret-control
;; dgos: HGA, LPATK, RAILA, LFACCAR, CWI, WASALL, LFACTORY, COMBA

(deftype turret-control-stack-var0 (structure)
  ((params projectile-init-by-other-params :inline :offset 0)
   (mat0 matrix :inline :offset 128)
   (vec2 vector :inline :offset 192)
   (vec3 vector :inline :offset 208)
   )
  )

(deftype turret-control-stack-var1 (structure)
  ((vec-1 vector :inline :offset-assert 0)
   (vec-2 vector :inline :offset-assert 16)
   (vec-3 vector :inline :offset-assert 32)
   (vec-4 vector :inline :offset-assert 48)
   (vec-5 vector :inline :offset-assert 64)
   (vec-6 vector :inline :offset-assert 80)
   (vec-7 vector :inline :offset-assert 96)
   (mat-1 matrix :inline :offset-assert 112)
   (vec-8 vector :inline :offset-assert 176)
   (vec-9 vector :inline :offset-assert 192)
   (vec-10 vector :inline :offset-assert 208)
   (vec-11 vector :inline :offset-assert 224)
   (vec-12 vector :inline :offset-assert 240)
   )
  )

;; +++turret-flag
(defenum turret-flag
  :bitfield #t
  :type uint8
  (firing 0)
  (aiming 1)
  (should-shoot 2)
  (targetting-laser 3)
  (display-marks 4)
  (no-rot-y-clamp 5)
  )
;; ---turret-flag


;; DECOMP BEGINS

(deftype turret-barrel-info (structure)
  ((local-pos  vector  :inline)
   (local-dir  vector  :inline)
   )
  )


(deftype turret-control-info (structure)
  ((shot-type               type)
   (joint-index             int8)
   (barrel-count            int8)
   (shot-speed              float)
   (attack-range            float)
   (damage                  float)
   (vehicle-damage-factor   float)
   (vehicle-impulse-factor  float)
   (rot-min                 float               2)
   (rot-max                 float               2)
   (rot-x-min               float               :overlay-at (-> rot-min 0))
   (rot-x-max               float               :overlay-at (-> rot-max 0))
   (rot-y-min               float               :overlay-at (-> rot-min 1))
   (rot-y-max               float               :overlay-at (-> rot-max 1))
   (local-pos               vector              :inline)
   (local-dir               vector              :inline)
   (barrel-array            turret-barrel-info  4 :inline)
   )
  )


(deftype turret-control (structure)
  ((info                  turret-control-info)
   (guard-settings        squad-unit-settings)
   (flags                 turret-flag)
   (shot-count            int8)
   (burst-count           int16)
   (shot-delay            uint16)
   (burst-delay           uint16)
   (target-dist           float)
   (inaccuracy            float)
   (burst-delay-factor    float)
   (aim-offset-angle      degrees)
   (aim-rot               float  2)
   (aim-rot-vel           float  2)
   (aim-rot-offset        float  2)
   (aim-rot-x             float  :overlay-at (-> aim-rot 0))
   (aim-rot-y             float  :overlay-at (-> aim-rot 1))
   (aim-rot-vel-x         float  :overlay-at (-> aim-rot-vel 0))
   (aim-rot-vel-y         float  :overlay-at (-> aim-rot-vel 1))
   (target-in-sight-time  time-frame)
   (aim-acquire-time      time-frame)
   (shoot-time            time-frame)
   (owner-handle          handle)
   (ignore-handle         handle)
   )
  (:methods
    (turret-control-method-9 (_type_ vehicle vector vector) none)
    (turret-control-method-10 (_type_ vehicle) none)
    (turret-control-method-11 (_type_ object object vector) none)
    (update-joint-mod (_type_ joint-mod-rotate-local) none)
    (turret-control-method-13 (_type_) none)
    (turret-control-method-14 (_type_) none)
    (set-info (_type_ turret-control-info) none)
    (turret-control-method-16 (_type_ float float) none)
    (turret-control-method-17 (_type_ vehicle) none)
    )
  )


(defmethod set-info ((this turret-control) (arg0 turret-control-info))
  (set! (-> this info) arg0)
  (set! (-> this owner-handle) (the-as handle #f))
  (set! (-> this ignore-handle) (the-as handle #f))
  (set! (-> this inaccuracy) 1.0)
  (set! (-> this burst-delay-factor) 1.0)
  0
  (none)
  )

(defmethod update-joint-mod ((this turret-control) (arg0 joint-mod-rotate-local))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 x) (- (-> this aim-rot-x)))
    (set! (-> v1-0 y) (-> this aim-rot-y))
    (set! (-> v1-0 z) 0.0)
    (quaternion-zxy! (-> arg0 rotation) v1-0)
    )
  0
  (none)
  )

(defmethod turret-control-method-13 ((this turret-control))
  (let ((f30-0 (/ (* 298261630.0 (-> this inaccuracy) (-> this guard-settings inaccuracy))
                  (fmax 40960.0 (-> this target-dist))
                  )
               )
        )
    (set! (-> this aim-rot-offset 0) (* f30-0 (cos (-> this aim-offset-angle))))
    (set! (-> this aim-rot-offset 1) (* f30-0 (sin (-> this aim-offset-angle))))
    )
  (+! (-> this aim-offset-angle) (* 32768.0 (rand-vu)))
  0
  (none)
  )

(defmethod turret-control-method-14 ((this turret-control))
  (logclear! (-> this flags) (turret-flag firing aiming))
  (set! (-> this burst-count) 0)
  (set! (-> this aim-offset-angle) (* 65536.0 (rand-vu)))
  0
  (none)
  )

(defun vehicle-los-clear? ((arg0 vector) (arg1 vector))
  (let ((v1-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> v1-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> v1-0 move-dist) arg1 arg0)
    (let ((a0-1 v1-0))
      (set! (-> a0-1 radius) 2048.0)
      (set! (-> a0-1 collide-with) (collide-spec backgnd))
      (set! (-> a0-1 ignore-process0) #f)
      (set! (-> a0-1 ignore-process1) #f)
      (set! (-> a0-1 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> a0-1 action-mask) (collide-action solid))
      )
    (< (fill-and-probe-using-line-sphere *collide-cache* v1-0) 0.0)
    )
  )

(defun vehicle-draw-beam ((arg0 sparticle-launcher) (arg1 vector) (arg2 vector) (arg3 object) (arg4 symbol))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-2 (vector+! (new 'stack-no-clear 'vector) arg1 arg2)))
      (when (or (not arg4) (line-in-view-frustum? arg1 a1-2))
        (let ((s5-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'quaternion))
              )
          (if (get-field-spec-by-id arg0 (sp-field-id spt-scale-y))
              (set! (-> *beam-info* y-scale) (vector-length arg2))
              )
          (let ((a0-4 s5-0))
            (let ((v1-10 arg2))
              (let ((a1-5 0.5))
                (.mov vf7 a1-5)
                )
              (.lvf vf5 (&-> v1-10 quad))
              )
            (.lvf vf4 (&-> arg1 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-4 quad) vf6)
            )
          (forward-up->quaternion s4-0 arg2 (new 'static 'vector :y 1.0 :w 1.0))
          (dotimes (s3-1 3)
            (quaternion-rotate-local-z! s4-0 s4-0 10922.667)
            (quaternion-copy! *particle-quat* s4-0)
            (let ((t9-5 sp-launch-particles-var)
                  (a0-8 *sp-particle-system-3d*)
                  (a1-9 arg0)
                  (a2-3 *launch-matrix*)
                  )
              (set! (-> a2-3 trans quad) (-> s5-0 quad))
              (t9-5 a0-8 a1-9 a2-3 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defun vehicle-draw-laser-spot ((arg0 vector) (arg1 vector) (arg2 symbol))
  (vector+float*! (new 'stack-no-clear 'vector) arg0 arg1 -1638.4)
  (cond
    (arg2
      (launch-particles (-> *part-id-table* 918) arg0)
      (launch-particles (-> *part-id-table* 917) arg0)
      )
    (else
      (launch-particles (-> *part-id-table* 919) arg0)
      )
    )
  0
  (none)
  )

(defun vehicle-draw-laser ((arg0 vector) (arg1 vector))
  (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (camera-pos) arg0) 1.0)
  (set! (-> (new 'stack-no-clear 'vector) quad) (-> arg0 quad))
  (let ((s5-1 (-> *part-id-table* 916)))
    (get-field-spec-by-id s5-1 (sp-field-id spt-timer))
    (let* ((s4-3 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
           (f30-0 (vector-vector-distance (camera-pos) arg0))
           (s3-2 (get-field-spec-by-id s5-1 (sp-field-id spt-scale-x)))
           (f0-4 (cond
                   ((< f30-0 122.88)
                    0.0
                    )
                   ((< 65536.0 f30-0)
                    1.0
                    )
                   (else
                     (* 0.000015287453 (+ -122.88 f30-0))
                     )
                   )
                 )
           (f30-1 (-> s3-2 initial-valuef))
           (f28-0 (-> s3-2 random-rangef))
           )
      (set! (-> s3-2 initial-valuef) (* f30-1 f0-4))
      (set! (-> s3-2 random-rangef) (* f28-0 f0-4))
      (vehicle-draw-beam s5-1 arg0 s4-3 #f #t)
      (set! (-> s3-2 initial-valuef) f30-1)
      (set! (-> s3-2 random-rangef) f28-0)
      )
    )
  0
  (none)
  )

(defmethod turret-control-method-9 ((this turret-control) (arg0 vehicle) (arg1 vector) (arg2 vector))
  (let ((gp-0 (new 'stack-no-clear 'turret-control-stack-var1)))
    (set! (-> gp-0 vec-12 x) (seconds-per-frame))
    (let* ((v1-1 (-> gp-0 mat-1))
           (a3-1 (-> arg0 node-list data (-> this info joint-index) bone transform))
           (a0-4 (-> a3-1 rvec quad))
           (a1-4 (-> a3-1 uvec quad))
           (a2-1 (-> a3-1 fvec quad))
           (a3-2 (-> a3-1 trans quad))
           )
      (set! (-> v1-1 rvec quad) a0-4)
      (set! (-> v1-1 uvec quad) a1-4)
      (set! (-> v1-1 fvec quad) a2-1)
      (set! (-> v1-1 trans quad) a3-2)
      )
    (set! (-> this target-dist) (vector-vector-distance (-> gp-0 mat-1 trans) arg1))
    (let ((f0-3 (/ (-> this target-dist) (-> this info shot-speed))))
      (vector+float*! (-> gp-0 vec-1) arg1 arg2 f0-3)
      )
    (when (not (logtest? (-> this flags) (turret-flag aiming)))
      (logior! (-> this flags) (turret-flag aiming))
      (turret-control-method-13 this)
      )
    (vector-matrix*! (-> gp-0 vec-6) (-> this info local-pos) (-> gp-0 mat-1))
    (vector-! (-> gp-0 vec-5) (-> gp-0 vec-1) (-> gp-0 vec-6))
    (let* ((v1-14 (-> gp-0 mat-1))
           (a3-3 (-> arg0 node-list data 0 bone transform))
           (a0-11 (-> a3-3 rvec quad))
           (a1-9 (-> a3-3 uvec quad))
           (a2-3 (-> a3-3 fvec quad))
           (a3-4 (-> a3-3 trans quad))
           )
      (set! (-> v1-14 rvec quad) a0-11)
      (set! (-> v1-14 uvec quad) a1-9)
      (set! (-> v1-14 fvec quad) a2-3)
      (set! (-> v1-14 trans quad) a3-4)
      )
    (matrix-transpose! (the-as matrix (-> gp-0 vec-8)) (-> gp-0 mat-1))
    (vector-rotate*! (-> gp-0 vec-3) (-> gp-0 vec-5) (the-as matrix (-> gp-0 vec-8)))
    (set! (-> gp-0 vec-4 y) (atan (-> gp-0 vec-3 x) (-> gp-0 vec-3 z)))
    (let* ((v1-15 (-> gp-0 vec-3))
           (f0-11 (sqrtf (+ (* (-> v1-15 x) (-> v1-15 x)) (* (-> v1-15 z) (-> v1-15 z)))))
           )
      (set! (-> gp-0 vec-4 x) (atan (-> gp-0 vec-3 y) f0-11))
      )
    (+! (-> gp-0 vec-4 x) (-> this aim-rot-offset 0))
    (+! (-> gp-0 vec-4 y) (-> this aim-rot-offset 1))
    (dotimes (s3-1 2)
      (+! (-> this aim-rot-vel s3-1)
          (* 5.0
             (- (* 8.0 (if (or (zero? s3-1) (not (logtest? (-> this flags) (turret-flag no-rot-y-clamp))))
                           (- (-> gp-0 vec-4 data s3-1) (-> this aim-rot s3-1))
                           (deg- (-> gp-0 vec-4 data s3-1) (-> this aim-rot s3-1))
                           )
                   )
                (-> this aim-rot-vel s3-1)
                )
             (-> gp-0 vec-12 x)
             )
          )
      (set! (-> this aim-rot-vel s3-1) (* (-> this aim-rot-vel s3-1) (fmax 0.0 (- 1.0 (* 0.1 (-> gp-0 vec-12 x))))))
      (+! (-> this aim-rot s3-1) (* (-> this aim-rot-vel s3-1) (-> gp-0 vec-12 x)))
      (when (or (zero? s3-1) (not (logtest? (-> this flags) (turret-flag no-rot-y-clamp))))
        (let ((f0-31 (-> this info rot-min s3-1)))
          (when (< (-> this aim-rot s3-1) f0-31)
            (set! (-> this aim-rot s3-1) f0-31)
            (set! (-> this aim-rot-vel s3-1) 0.0)
            )
          )
        (let ((f0-33 (-> this info rot-max s3-1)))
          (when (< f0-33 (-> this aim-rot s3-1))
            (set! (-> this aim-rot s3-1) f0-33)
            (set! (-> this aim-rot-vel s3-1) 0.0)
            )
          )
        )
      )
    (logclear! (-> this flags) (turret-flag should-shoot))
    (when (and (< (fabs (deg- (-> this aim-rot-x) (-> gp-0 vec-4 x))) 2912.7112)
               (< (fabs (deg- (-> this aim-rot-y) (-> gp-0 vec-4 y))) 2912.7112)
               (< (-> this target-dist) (-> this info attack-range))
               )
      (logior! (-> this flags) (turret-flag should-shoot))
      (when (logtest? (-> this flags) (turret-flag targetting-laser))
        (let* ((v1-88 (-> gp-0 mat-1))
               (a3-5 (-> arg0 node-list data (-> this info joint-index) bone transform))
               (a0-29 (-> a3-5 rvec quad))
               (a1-20 (-> a3-5 uvec quad))
               (a2-5 (-> a3-5 fvec quad))
               (a3-6 (-> a3-5 trans quad))
               )
          (set! (-> v1-88 rvec quad) a0-29)
          (set! (-> v1-88 uvec quad) a1-20)
          (set! (-> v1-88 fvec quad) a2-5)
          (set! (-> v1-88 trans quad) a3-6)
          )
        (set! (-> gp-0 vec-7 quad) (-> gp-0 mat-1 fvec quad))
        (let ((s3-2 (new 'stack-no-clear 'collide-query)))
          (set! (-> s3-2 start-pos quad) (-> gp-0 vec-6 quad))
          (vector-float*! (-> s3-2 move-dist) (-> gp-0 vec-7) (-> this info attack-range))
          (let ((v1-93 s3-2))
            (set! (-> v1-93 radius) 409.6)
            (set! (-> v1-93 collide-with)
                  (collide-spec backgnd jak bot crate enemy obstacle hit-by-others-list player-list)
                  )
            (set! (-> v1-93 ignore-process0) arg0)
            (set! (-> v1-93 ignore-process1) #f)
            (set! (-> v1-93 ignore-pat)
                  (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                  )
            (set! (-> v1-93 action-mask) (collide-action solid))
            )
          (let ((f30-1 (fill-and-probe-using-line-sphere *collide-cache* s3-2))
                (s5-1 #f)
                )
            (cond
              ((< f30-1 0.0)
               (vector+! (-> gp-0 vec-2) (-> s3-2 start-pos) (-> s3-2 move-dist))
               )
              (else
                (let* ((s4-1 (-> s3-2 best-other-tri collide-ptr))
                       (a0-43 (if (type? s4-1 collide-shape-prim)
                                  s4-1
                                  )
                              )
                       )
                  (if (and a0-43 (logtest? (-> (the-as collide-shape-prim a0-43) prim-core collide-as) (collide-spec jak)))
                      (set! s5-1 #t)
                      )
                  )
                (vector+float*! (-> gp-0 vec-2) (-> s3-2 start-pos) (-> s3-2 move-dist) f30-1)
                (vehicle-draw-laser-spot (-> gp-0 vec-2) (-> gp-0 vec-7) s5-1)
                )
              )
            (when (not s5-1)
              )
            )
          )
        (let ((t9-13 vehicle-draw-laser)
              (a0-48 (-> gp-0 vec-6))
              (a1-27 (-> gp-0 vec-2))
              )
          (-> gp-0 vec-7)
          (t9-13 a0-48 a1-27)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod turret-control-method-10 ((this turret-control) (arg0 vehicle))
  (cond
    ((logtest? (-> this flags) (turret-flag should-shoot))
     (cond
       ((logtest? (-> this flags) (turret-flag firing))
        (cond
          ((> (-> this shot-count) 0)
           (when (time-elapsed? (-> this shoot-time) (the-as time-frame (-> this shot-delay)))
             (turret-control-method-17 this arg0)
             (set! (-> this shot-delay) (+ (-> this guard-settings shot-delay)
                                           (rand-vu-int-count (the-as int (+ (-> this guard-settings rand-shot-delay) 1)))
                                           )
                   )
             )
           )
          (else
            (logclear! (-> this flags) (turret-flag firing))
            (+! (-> this burst-count) 1)
            (turret-control-method-13 this)
            )
          )
        )
       (else
         (when (and (time-elapsed? (-> this shoot-time) (the-as time-frame (-> this burst-delay)))
                    (time-elapsed? (-> this aim-acquire-time) (the-as time-frame (-> this guard-settings acquire-delay)))
                    )
           (set! (-> this shot-count)
                 (+ (-> this guard-settings shot-count) (rand-vu-int-count (+ (-> this guard-settings rand-shot-count) 1)))
                 )
           (set! (-> this burst-delay)
                 (+ (-> this guard-settings burst-delay)
                    (rand-vu-int-count (the-as int (+ (-> this guard-settings rand-burst-delay) 1)))
                    )
                 )
           (set! (-> this burst-delay)
                 (the-as uint (the int (* (-> this burst-delay-factor) (the float (-> this burst-delay)))))
                 )
           (logior! (-> this flags) (turret-flag firing))
           )
         )
       )
     )
    (else
      (set-time! (-> this aim-acquire-time))
      (turret-control-method-14 this)
      )
    )
  0
  (none)
  )

(defmethod turret-control-method-11 ((this turret-control) (arg0 object) (arg1 object) (arg2 vector))
  (when (nonzero? (-> this info))
    (turret-control-method-9 this (the-as vehicle arg0) (the-as vector arg1) arg2)
    (turret-control-method-10 this (the-as vehicle arg0))
    )
  0
  (none)
  )

(defmethod turret-control-method-17 ((this turret-control) (arg0 vehicle))
  (let ((s4-0 (new 'stack-no-clear 'turret-control-stack-var0)))
    (set! (-> s4-0 params ent) (-> arg0 entity))
    (set! (-> s4-0 params charge) 1.0)
    (set! (-> s4-0 params options) (projectile-options))
    (logclear! (-> s4-0 params options) (projectile-options po14 po15 po16))
    (set! (-> s4-0 params notify-handle) (process->handle arg0))
    (set! (-> s4-0 params owner-handle) (process->handle (handle->process (-> this owner-handle))))
    (set! (-> s4-0 params target-handle) (the-as handle #f))
    (set! (-> s4-0 params target-pos quad) (the-as uint128 0))
    (set! (-> s4-0 params ignore-handle) (process->handle (handle->process (-> this ignore-handle))))
    (let* ((v1-20 *game-info*)
           (a0-19 (+ (-> v1-20 attack-id) 1))
           )
      (set! (-> v1-20 attack-id) a0-19)
      (set! (-> s4-0 params attack-id) a0-19)
      )
    (set! (-> s4-0 params timeout) (seconds 4))
    (set! (-> s4-0 params damage) (-> this info damage))
    (logior! (-> s4-0 params options) (projectile-options po14))
    (set! (-> s4-0 params vehicle-damage-factor) (-> this info vehicle-damage-factor))
    (logior! (-> s4-0 params options) (projectile-options po15))
    (set! (-> s4-0 params vehicle-impulse-factor) (-> this info vehicle-impulse-factor))
    (logior! (-> s4-0 params options) (projectile-options po16))
    (let* ((v1-31 (-> s4-0 mat0))
           (a3-0 (-> arg0 node-list data (-> this info joint-index) bone transform))
           (a0-24 (-> a3-0 rvec quad))
           (a1-8 (-> a3-0 uvec quad))
           (a2-0 (-> a3-0 fvec quad))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-31 rvec quad) a0-24)
      (set! (-> v1-31 uvec quad) a1-8)
      (set! (-> v1-31 fvec quad) a2-0)
      (set! (-> v1-31 trans quad) a3-1)
      )
    (dotimes (s3-0 (-> this info barrel-count))
      (vector-matrix*! (-> s4-0 vec2) (the-as vector (-> this info barrel-array s3-0)) (-> s4-0 mat0))
      (set! (-> s4-0 vec3 quad) (-> s4-0 mat0 fvec quad))
      (set! (-> s4-0 params pos quad) (-> s4-0 vec2 quad))
      (vector-float*! (-> s4-0 params vel) (-> s4-0 vec3) (-> this info shot-speed))
      (spawn-projectile (-> this info shot-type) (-> s4-0 params) arg0 *default-dead-pool*)
      )
    )
  (set-time! (-> this shoot-time))
  (+! (-> this shot-count) -1)
  0
  (none)
  )

(defmethod turret-control-method-16 ((this turret-control) (arg0 float) (arg1 float))
  (let ((f0-0 (seconds-per-frame)))
    (set! (-> this aim-rot-vel-x) arg1)
    (set! (-> this aim-rot-vel-y) arg0)
    (dotimes (v1-1 2)
      (+! (-> this aim-rot v1-1) (* f0-0 (-> this aim-rot-vel v1-1)))
      (let ((f1-4 (-> this info rot-min v1-1)))
        (when (< (-> this aim-rot v1-1) f1-4)
          (set! (-> this aim-rot v1-1) f1-4)
          (set! (-> this aim-rot-vel v1-1) 0.0)
          )
        )
      (let ((f1-6 (-> this info rot-max v1-1)))
        (when (< f1-6 (-> this aim-rot v1-1))
          (set! (-> this aim-rot v1-1) f1-6)
          (set! (-> this aim-rot-vel v1-1) 0.0)
          )
        )
      )
    )
  0
  (none)
  )
