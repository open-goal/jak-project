;;-*-Lisp-*-
(in-package goal)

;; name: precura-obs.gc
;; name in dgo: precura-obs
;; dgos: PRECA

;; +++precur-hint-type
(defenum precur-hint-type
  :type uint8
  (pickup-hint)
  (place-hint)
  (normal)
  )
;; ---precur-hint-type


;; DECOMP BEGINS

(defun spawn-mech-shock-effect ()
  (process-spawn-function
    process
    (lambda :behavior process
      ()
      (let ((gp-0 (current-time)))
        (suspend-for (seconds 1) (when (time-elapsed? gp-0 (seconds 0.03))
                                   (set! gp-0 (current-time))
                                   (process-drawable-shock-effect
                                     *target*
                                     (-> *lightning-spec-id-table* 1)
                                     lightning-probe-callback
                                     (-> *part-id-table* 160)
                                     0
                                     0
                                     40960.0
                                     )
                                   )
                     )
        )
      #f
      )
    :to *target*
    )
  0
  (none)
  )

(deftype precur-switch (process-drawable)
  ((alt-actor  entity-actor)
   )
  (:state-methods
    idle
    going-down
    going-up
    idle-down
    )
  )


(defskelgroup skel-precur-switch precur-switch 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 4))

(defstate idle (precur-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (go-virtual going-down)
       )
      )
    )
  :enter (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 2) :num! zero)
    (transform-post)
    )
  :trans rider-trans
  :code sleep-code
  :post rider-post
  )

(defstate going-down (precur-switch)
  :virtual #t
  :enter (behavior ()
    (sound-play "bridge-button")
    )
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle-down)
    )
  :post rider-post
  )

(defstate going-up (precur-switch)
  :virtual #t
  :trans rider-trans
  :code (behavior ()
    (let* ((v1-0 (-> self alt-actor))
           (a0-0 (if v1-0
                     (-> v1-0 extra process)
                     )
                 )
           )
      (if a0-0
          (send-event a0-0 'stop-rotate)
          )
      )
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! 0.0) :frame-num 1.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 0.0))
      )
    (go-virtual idle)
    )
  :post rider-post
  )

(defstate idle-down (precur-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (current-time)))
         (set! (-> self state-time) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (rider-trans)
    (if (time-elapsed? (-> self state-time) (seconds 0.1))
        (go-virtual going-up)
        )
    )
  :code (behavior ()
    (let* ((v1-0 (-> self alt-actor))
           (a0-0 (if v1-0
                     (-> v1-0 extra process)
                     )
                 )
           )
      (if a0-0
          (send-event a0-0 'start-rotate)
          )
      )
    (sleep-code)
    )
  :post rider-post
  )

(defmethod init-from-entity! ((this precur-switch) (arg0 entity-actor))
  (set! (-> this alt-actor) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set! (-> v1-16 transform-index) 4)
      (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-19 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-19 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-19 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-switch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

(deftype precur-jump-plate (process-drawable)
  ((start-quat  quaternion  :inline)
   (turn-start  time-frame)
   (angle       float)
   (first?      symbol)
   (idx         uint8)
   (sound-id    sound-id)
   )
  (:state-methods
    idle
    turn
    )
  )


(defskelgroup skel-precur-jump-plate precur-jump-plate precur-jump-plate-lod0-jg precur-jump-plate-idle-ja
              ((precur-jump-plate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(defstate idle (precur-jump-plate)
  :virtual #t
  :enter (behavior ()
    (transform-post)
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (rider-trans)
    )
  :code (behavior ()
    (local-vars (v1-3 time-frame) (a0-3 float) (f0-0 float))
    (let ((gp-0 (current-time)))
      (until (>= v1-3 (the int (* f0-0 a0-3)))
        (suspend)
        (set! v1-3 (- (current-time) gp-0))
        (set! f0-0 300.0)
        (set! a0-3 (if (-> self first?)
                       (the float (-> self idx))
                       2.0
                       )
              )
        )
      )
    (set! (-> self first?) #f)
    (go-virtual turn)
    )
  :post rider-post
  )

(defmethod run-logic? ((this precur-jump-plate))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defstate turn (precur-jump-plate)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self turn-start))
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    (sound-play "bridg-ring-stop")
    )
  :trans (behavior ()
    float
    (set! (-> self angle)
          (the float (sar (shl (the int (* 72.81778 (the float (- (current-time) (-> self turn-start))))) 48) 48))
          )
    (quaternion-rotate-local-z! (-> self root quat) (-> self start-quat) (-> self angle))
    (sound-play "bridg-ring-turn" :id (-> self sound-id) :pitch 1)
    (when #f
      (sound-stop (-> self sound-id))
      (sound-play "bridg-ring-turn" :id (-> self sound-id) :position (-> self root trans))
      )
    (when #f
      (sound-stop (-> self sound-id))
      (sound-play "bridg-ring-turn" :id (-> self sound-id) :position (-> self root trans))
      )
    (when (and (< (seconds 1) (- (current-time) (-> self turn-start)))
               (< 0.0 (-> self angle))
               (< (-> self angle) 3640.889)
               )
      (quaternion-rotate-local-z! (-> self root quat) (-> self start-quat) 0.0)
      (go-virtual idle)
      )
    (rider-trans)
    )
  :code sleep-code
  :post (behavior ()
    (if (< (fabs (-> self angle)) 8192.0)
        (rider-post)
        (ja-post)
        )
    )
  )

(defmethod init-from-entity! ((this precur-jump-plate) (arg0 entity-actor))
  (set-time! (-> this state-time))
  (set-time! (-> this turn-start))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 2)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid rideable))
      (set! (-> v1-19 transform-index) 2)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-jump-plate" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (quaternion-copy! (-> this start-quat) (-> this root quat))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this first?) #t)
  (set! (-> this idx) (the-as uint (the int (* 0.000027126736 (+ 147456.0 (-> this root trans z))))))
  (go (method-of-object this idle))
  )

(set! (-> *lightning-spec-id-table* 36) (new 'static 'lightning-spec
                                          :name "generator-lightning-shock"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #xff)
                                          :end-color (new 'static 'rgba :b #xff :a #xff)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 30.0
                                          :texture (new 'static 'texture-id :index #x3b :page #x4)
                                          :reduction 0.6
                                          :num-points 20
                                          :box-size 40960.0
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 3276.8
                                          :duration 210.0
                                          :sound (static-sound-spec "shock" :group 0)
                                          )
      )

(set! (-> *lightning-spec-id-table* 37) (new 'static 'lightning-spec
                                          :name "generator-lightning-shock-target"
                                          :flags (lightning-spec-flags lsf2)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 120.0
                                          :texture (new 'static 'texture-id :index #x3f :page #x4)
                                          :reduction 0.5
                                          :num-points 16
                                          :box-size 8601.6
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 4096.0
                                          :duration -1.0
                                          :sound #f
                                          )
      )

(defpartgroup group-debug-placeholder-multiple-generator
  :id 1324
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 4445 :flags (sp7)))
  )

(defpart 4445
  :init-specs ((:texture (middot level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 0.3))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:vel-y (meters 0.01))
    (:timer (seconds 2))
    (:flags ())
    (:conerot-x (degrees -45) (degrees 90))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(deftype precur-generator (process-drawable)
  ((root                 collide-shape :override)
   (attack-id            uint32)
   (shove-id             uint32)
   (sound-id             sound-id)
   (next-lightning-time  uint32)
   (shock-distance       float)
   )
  (:state-methods
    idle
    explode
    )
  (:methods
    (init-fields (_type_) none)
    )
  )


(defstate idle (precur-generator)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (format 0 "explode-event~%")
       (if (type? proc explosion)
           (go-virtual explode)
           )
       )
      )
    )
  :trans (behavior ()
    (local-vars (sv-128 symbol) (sv-144 vector))
    (sound-play "prec-generator" :id (-> self sound-id) :position (-> self root trans))
    (when (< (the-as time-frame (-> self next-lightning-time)) (current-time))
      (process-drawable-shock-effect
        self
        (-> *lightning-spec-id-table* 36)
        lightning-probe-callback
        (-> *part-id-table* 160)
        5
        0
        40960.0
        )
      (set! (-> self next-lightning-time) (the-as uint (+ (current-time) (seconds 0.1))))
      )
    (when (< (vector-vector-xz-distance (target-pos 0) (-> self root trans)) (-> self shock-distance))
      (send-event
        *target*
        'attack
        #f
        (static-attack-info
          :mask (vehicle-impulse-factor)
          ((id (-> self attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0))
          )
        )
      (let ((gp-1 (new 'stack-no-clear 'vector)))
        (set! (-> gp-1 quad) (-> self root trans quad))
        (vector-! gp-1 (target-pos 0) (-> self root trans))
        (set! (-> gp-1 y) 0.0)
        (vector-normalize! gp-1 1.0)
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.3))
        (send-event
          *target*
          'shove
          #f
          (static-attack-info :mask (vehicle-impulse-factor) ((id (-> self shove-id))
                                                              (damage 2.0)
                                                              (vehicle-damage-factor 1.0)
                                                              (vehicle-impulse-factor 1.0)
                                                              (vector gp-1)
                                                              (shove-back (meters 2))
                                                              (shove-up (meters 1.5))
                                                              )
                              )
          )
        )
      (let ((gp-2 (get-process *default-dead-pool* lightning-tracker #x4000 0)))
        (when gp-2
          (let ((t9-10 (method-of-type lightning-tracker activate)))
            (t9-10 (the-as lightning-tracker gp-2) *entity-pool* "lightning-tracker" (the-as pointer #x70004000))
            )
          (let ((s5-2 run-function-in-process)
                (s4-0 gp-2)
                (s3-0 lightning-tracker-init)
                (s2-0 (-> *lightning-spec-id-table* 37))
                (s1-0 90)
                (s0-0 #f)
                )
            (set! sv-128 (the-as symbol #f))
            (set! sv-144 (new 'stack-no-clear 'vector))
            (set! (-> sv-144 x) (-> (target-pos 0) x))
            (let* ((f30-0 (-> (target-pos 0) y))
                   (f28-0 4096.0)
                   (f26-0 1.0)
                   (f24-0 4.0)
                   (v1-35 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                   (v1-36 (the-as number (logior #x3f800000 v1-35)))
                   )
              (set! (-> sv-144 y) (+ f30-0 (* f28-0 (+ f26-0 (* f24-0 (+ -1.0 (the-as float v1-36)))))))
              )
            (set! (-> sv-144 z) (-> (target-pos 0) z))
            (set! (-> sv-144 w) 1.0)
            (let ((t3-0 (-> self root trans)))
              ((the-as (function object object object object object object object object none) s5-2)
               s4-0
               s3-0
               s2-0
               s1-0
               s0-0
               sv-128
               sv-144
               t3-0
               )
              )
            )
          (-> gp-2 ppointer)
          )
        )
      (if *target*
          (spawn-mech-shock-effect)
          )
      )
    )
  :code sleep-code
  )

(defstate explode (precur-generator)
  :virtual #t
  :enter (behavior ()
    (sound-play "gen-explode")
    )
  :code sleep-code
  )

(defmethod init-fields ((this precur-generator))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this next-lightning-time) (the-as uint 0))
  (let* ((v1-0 *game-info*)
         (a0-2 (+ (-> v1-0 attack-id) 1))
         )
    (set! (-> v1-0 attack-id) a0-2)
    (set! (-> this attack-id) a0-2)
    )
  (let* ((v1-1 *game-info*)
         (a0-4 (+ (-> v1-1 attack-id) 1))
         )
    (set! (-> v1-1 attack-id) a0-4)
    (set! (-> this shove-id) a0-4)
    )
  (set! (-> this shock-distance) 61440.0)
  0
  (none)
  )

(deftype precur-generator-a (precur-generator)
  ()
  )


(defskelgroup skel-precur-generator-a precur-generator-a precur-generator-a-lod0-jg precur-generator-a-idle-ja
              ((precur-generator-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(defskelgroup skel-precur-generator-a-explode precur-generator-a precur-generator-a-explode-lod0-jg precur-generator-a-explode-idle-ja
              ((precur-generator-a-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(define *precur-generator-a-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defstate idle (precur-generator-a)
  :virtual #t
  :enter (behavior ()
    (set-precura-generator-light! 1.0)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type precur-generator idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate explode (precur-generator-a)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (cond
      ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
        )
      )
    (when (type? (-> self root) collide-shape)
      (let ((v1-36 (-> self root root-prim)))
        (set! (-> v1-36 prim-core collide-as) (collide-spec))
        (set! (-> v1-36 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (sound-stop (-> self sound-id))
    (set-precura-generator-light! 0.0)
    (format 0 "tag1~%")
    (let ((t9-11 (-> (method-of-type precur-generator explode) enter)))
      (if t9-11
          (t9-11)
          )
      )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set-vector! (-> gp-0 fountain-rand-transv-lo) -122880.0 40960.0 -122880.0 1.0)
      (set-vector! (-> gp-0 fountain-rand-transv-hi) 122880.0 81920.0 122880.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-precur-generator-a-explode" (the-as (pointer level) #f))
        5
        gp-0
        *precur-generator-a-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (suspend)
    (when (type? (-> self root) collide-shape)
      (let ((v1-10 (-> self root root-prim)))
        (set! (-> v1-10 prim-core collide-as) (collide-spec))
        (set! (-> v1-10 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defmethod init-from-entity! ((this precur-generator-a) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-generator-a" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-fields this)
  (go (method-of-object this idle))
  )

(deftype precur-generator-b (precur-generator)
  ()
  )


(defskelgroup skel-precur-generator-b precur-generator-b precur-generator-b-lod0-jg precur-generator-b-idle-ja
              ((precur-generator-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              )

(defskelgroup skel-precur-generator-b-explode precur-generator-b precur-generator-b-explode-lod0-jg precur-generator-b-explode-idle-ja
              ((precur-generator-b-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(define *precur-generator-b-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 21 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 22 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defstate idle (precur-generator-b)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (if (type? proc explosion)
           (go-virtual explode)
           )
       )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type precur-generator idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate explode (precur-generator-b)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (cond
      ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
        )
      )
    (when (type? (-> self root) collide-shape)
      (let ((v1-36 (-> self root root-prim)))
        (set! (-> v1-36 prim-core collide-as) (collide-spec))
        (set! (-> v1-36 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (sound-stop (-> self sound-id))
    (let ((t9-9 (-> (method-of-type precur-generator explode) enter)))
      (if t9-9
          (t9-9)
          )
      )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set-vector! (-> gp-0 fountain-rand-transv-lo) -122880.0 40960.0 -122880.0 1.0)
      (set-vector! (-> gp-0 fountain-rand-transv-hi) 122880.0 81920.0 122880.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-precur-generator-b-explode" (the-as (pointer level) #f))
        5
        gp-0
        *precur-generator-b-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defmethod init-from-entity! ((this precur-generator-b) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-generator-b" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-fields this)
  (set! (-> this shock-distance) 40960.0)
  (go (method-of-object this idle))
  )

(deftype precur-generator-c (process-drawable)
  ((root                 collide-shape :override)
   (actor-group          (pointer actor-group))
   (actor-group-count    int32)
   (next-lightning-time  uint32)
   (sound-id             sound-id)
   )
  (:state-methods
    idle
    explode
    )
  )


(defskelgroup skel-precur-generator-c precur-generator-c precur-generator-c-lod0-jg precur-generator-c-idle-ja
              ((precur-generator-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              )

(defskelgroup skel-precur-generator-c-explode precur-generator-c precur-generator-c-explode-lod0-jg precur-generator-c-explode-idle-ja
              ((precur-generator-c-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(define *precur-generator-c-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 21 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defstate idle (precur-generator-c)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (when (type? proc explosion)
         (when (nonzero? (-> self actor-group-count))
           (dotimes (gp-0 (length (-> self actor-group 0)))
             (let ((v1-5 (-> self actor-group 0 data gp-0)))
               (when v1-5
                 (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
                   (set! (-> a1-3 from) (process->ppointer self))
                   (set! (-> a1-3 num-params) 0)
                   (set! (-> a1-3 message) 'trigger)
                   (let ((t9-1 send-event-function)
                         (v1-6 (-> v1-5 actor))
                         )
                     (t9-1
                       (if v1-6
                           (-> v1-6 extra process)
                           )
                       a1-3
                       )
                     )
                   )
                 0
                 )
               )
             )
           )
         (go-virtual explode)
         )
       )
      )
    )
  :trans (behavior ()
    (sound-play "prec-generator" :id (-> self sound-id) :position (-> self root trans))
    (when (< (the-as time-frame (-> self next-lightning-time)) (current-time))
      (process-drawable-shock-effect
        self
        (-> *lightning-spec-id-table* 36)
        lightning-probe-callback
        (-> *part-id-table* 160)
        5
        0
        81920.0
        )
      (set! (-> self next-lightning-time) (the-as uint (+ (current-time) (seconds 0.1))))
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate explode (precur-generator-c)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (cond
      ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
        )
      )
    (sound-stop (-> self sound-id))
    (let ((t9-7 (-> (method-of-type precur-generator explode) enter)))
      (if t9-7
          (t9-7)
          )
      )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set-vector! (-> gp-0 fountain-rand-transv-lo) -122880.0 40960.0 -122880.0 1.0)
      (set-vector! (-> gp-0 fountain-rand-transv-hi) 122880.0 81920.0 122880.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-precur-generator-c-explode" (the-as (pointer level) #f))
        5
        gp-0
        *precur-generator-c-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (suspend)
    (when (type? (-> self root) collide-shape)
      (let ((v1-10 (-> self root root-prim)))
        (set! (-> v1-10 prim-core collide-as) (collide-spec))
        (set! (-> v1-10 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (suspend-for (seconds 1.2))
    (when (res-lump-struct (-> self entity) 'art-name structure)
      (logclear! (-> self mask) (process-mask actor-pause))
      (process-grab? *target* #f)
      (set-setting! 'entity-name "camera-359" 0.0 0)
      (suspend-for (seconds 2))
      (task-close! "precursor-tour-generator-trigger")
      (send-event (process-by-name "precur-door-b-4" *active-pool*) 'open)
      (suspend-for (seconds 1))
      (set-setting! 'interp-time 'abs 450.0 0)
      (remove-setting! 'entity-name)
      (process-release? *target*)
      (suspend)
      0
      )
    (cleanup-for-death self)
    )
  )

(defmethod init-from-entity! ((this precur-generator-c) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (stack-size-set! (-> this main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (set! (-> this sound-id) (new-sound-id))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-generator-c" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this next-lightning-time) (the-as uint 0))
  (set! (-> this entity) arg0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-19 (res-lump-data arg0 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-19 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-19))
       )
      (else
        (format 0 "ERROR: entity missing actor-group!~%")
        )
      )
    )
  (go (method-of-object this idle))
  )

(deftype precur-generator-d-gem (process-drawable)
  ((root        collide-shape :override)
   (ang-vel     float)
   (offset-vec  vector         :inline)
   (init-pos    vector         :inline)
   (sound-id    sound-id)
   )
  (:state-methods
    idle
    orbit-gen
    smoking
    explode
    )
  )


(defskelgroup skel-precur-generator-d-gem precur-generator-d-gem precur-generator-d-gem-lod0-jg precur-generator-d-gem-idle-ja
              ((precur-generator-d-gem-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defstate idle (precur-generator-d-gem)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('spin)
       (let ((v1-1 (the-as object (-> block param 0)))
             (gp-0 (new 'stack-no-clear 'vector))
             )
         (set! (-> gp-0 quad) (-> (the-as vector (-> block param 1)) quad))
         (set! (-> self root trans quad) (-> (the-as vector v1-1) quad))
         (set! (-> gp-0 y) 0.0)
         (vector-normalize! gp-0 1.0)
         (quaternion-look-at! (-> self root quat) gp-0 *up-vector*)
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate orbit-gen (precur-generator-d-gem)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (go-virtual smoking)
       )
      )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    (sound-play "gem-pain")
    )
  :trans (behavior ()
    (sound-play "gem-airloop" :id (-> self sound-id))
    (vector-rotate-around-y! (-> self offset-vec) (-> self offset-vec) (* (-> self ang-vel) (seconds-per-frame)))
    (vector+! (-> self root trans) (-> self init-pos) (-> self offset-vec))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self offset-vec quad))
      (set! (-> gp-0 y) 0.0)
      (vector-normalize! gp-0 1.0)
      (quaternion-look-at! (-> self root quat) gp-0 *up-vector*)
      )
    )
  :code sleep-code
  :post transform-post
  )

(defstate smoking (precur-generator-d-gem)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (go-virtual explode)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (spawn (-> self part) (-> self root trans))
    (sound-play "gem-smokeloop" :id (-> self sound-id))
    (vector-rotate-around-y!
      (-> self offset-vec)
      (-> self offset-vec)
      (* 3.0 (seconds-per-frame) (-> self ang-vel))
      )
    (vector+! (-> self root trans) (-> self init-pos) (-> self offset-vec))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self offset-vec quad))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (rand-vu-sphere-point! s5-0 3072.0)
        (vector+! (-> self root trans) (-> self root trans) s5-0)
        )
      (set! (-> gp-0 y) 0.0)
      (vector-normalize! gp-0 1.0)
      (quaternion-look-at! (-> self root quat) gp-0 *up-vector*)
      )
    )
  :code sleep-code
  :post transform-post
  )

(defstate explode (precur-generator-d-gem)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (when (type? (-> self root) collide-shape)
      (let ((v1-4 (-> self root root-prim)))
        (set! (-> v1-4 prim-core collide-as) (collide-spec))
        (set! (-> v1-4 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (cond
      ((logtest? (-> *part-group-id-table* 1318 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1318))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1318))
        )
      )
    (sound-play "gem-explode")
    )
  :code (behavior ()
    (suspend)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defbehavior precur-generator-d-gem-init-by-other precur-generator-d-gem ((arg0 vector) (arg1 float) (arg2 vector))
  (let ((s3-0 (new 'process 'collide-shape self (collide-list-enum usually-hit-by-player))))
    (set! (-> s3-0 penetrated-by) (penetrate))
    (let ((s2-0 (new 'process 'collide-shape-prim-group s3-0 (the-as uint 1) 0)))
      (set! (-> s3-0 total-prims) (the-as uint 2))
      (set! (-> s2-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s2-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s2-0 prim-core action) (collide-action solid))
      (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s3-0 root-prim) s2-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s3-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (set! (-> s3-0 nav-radius) (* 0.75 (-> s3-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s3-0 root-prim)))
      (set! (-> s3-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s3-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> self root) s3-0)
    )
  (set! (-> self sound-id) (new-sound-id))
  (set! (-> self offset-vec quad) (-> arg2 quad))
  (set! (-> self ang-vel) arg1)
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 1317) self))
  (set! (-> self root trans quad) (-> arg0 quad))
  (set! (-> self init-pos quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-precur-generator-d-gem" (the-as (pointer level) #f))
      )
    (the-as pair 0)
    )
  (go-virtual orbit-gen)
  )

(deftype precur-generator-d (process-drawable)
  ((root                 collide-shape :override)
   (actor-group          (pointer actor-group))
   (actor-group-count    int32)
   (next-lightning-time  uint32)
   (proc-handle          handle         3)
   (animation-speed      float)
   (sound-id             sound-id)
   )
  (:state-methods
    idle
    explode
    explosions
    )
  (:methods
    (spawn-gems (_type_) none)
    )
  )


(defskelgroup skel-precur-generator-d precur-generator-d precur-generator-d-lod0-jg precur-generator-d-idle-ja
              ((precur-generator-d-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              )

(defskelgroup skel-precur-generator-d-explode precur-generator-d precur-generator-d-explode-lod0-jg precur-generator-d-explode-idle-ja
              ((precur-generator-d-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(define *precur-generator-d-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 21 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 22 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 23 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 24 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 25 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 26 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 27 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 28 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 29 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 30 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defmethod spawn-gems ((this precur-generator-d))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 quad) (-> this root trans quad))
    (set! (-> this proc-handle 0) (ppointer->handle (process-spawn
                                                      precur-generator-d-gem
                                                      s5-0
                                                      14563.556
                                                      (new 'static 'vector :x 61440.0 :y -40960.0 :w 1.0)
                                                      :name "precur-generator-d-gem"
                                                      :to this
                                                      )
                                                    )
          )
    (set! (-> this proc-handle 1) (ppointer->handle (process-spawn
                                                      precur-generator-d-gem
                                                      s5-0
                                                      -6553.6
                                                      (new 'static 'vector :x 61440.0 :y -32768.0 :w 1.0)
                                                      :name "precur-generator-d-gem"
                                                      :to this
                                                      )
                                                    )
          )
    (set! (-> this proc-handle 2) (ppointer->handle (process-spawn
                                                      precur-generator-d-gem
                                                      s5-0
                                                      11650.845
                                                      (new 'static 'vector :x 61440.0 :y -53248.0 :w 1.0)
                                                      :name "precur-generator-d-gem"
                                                      :to this
                                                      )
                                                    )
          )
    )
  (none)
  )

(defstate idle (precur-generator-d)
  :virtual #t
  :trans (behavior ()
    (sound-play "prec-generator" :id (-> self sound-id) :position (-> self root trans))
    (when (< (the-as time-frame (-> self next-lightning-time)) (current-time))
      (process-drawable-shock-effect
        self
        (-> *lightning-spec-id-table* 36)
        lightning-probe-callback
        (-> *part-id-table* 160)
        5
        0
        163840.0
        )
      (set! (-> self next-lightning-time) (the-as uint (+ (current-time) (seconds 0.1))))
      )
    (let ((v1-10 (the-as object #f)))
      (set! (-> self animation-speed) 0.5)
      (dotimes (a0-7 3)
        (set! v1-10 (or (handle->process (-> self proc-handle a0-7)) v1-10))
        (if (not v1-10)
            (set! (-> self animation-speed) (* 2.0 (-> self animation-speed)))
            )
        )
      (if (not v1-10)
          (go-virtual explode)
          )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! precur-generator-d-idle-ja :num! (seek! max (-> self animation-speed)) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self animation-speed)))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate explode (precur-generator-d)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (cond
      ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
        )
      )
    (sound-stop (-> self sound-id))
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set-vector! (-> gp-0 fountain-rand-transv-lo) 0.0 0.0 0.0 1.0)
      (set-vector! (-> gp-0 fountain-rand-transv-hi) 0.0 0.0 0.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-precur-generator-d-explode" (the-as (pointer level) #f))
        5
        gp-0
        *precur-generator-d-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (when (type? (-> self root) collide-shape)
      (let ((v1-10 (-> self root root-prim)))
        (set! (-> v1-10 prim-core collide-as) (collide-spec))
        (set! (-> v1-10 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (go-virtual explosions)
    )
  )

(defstate explosions (precur-generator-d)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (activate! *camera-smush-control* 2048.0 15 1500 1.0 0.9 (-> *display* camera-clock))
    (persist-with-delay *setting-control* 'blur-a (seconds 5) 'blur-a 'abs 0.8 0)
    (disable *screen-filter*)
    (process-grab? *target* #f)
    )
  :code (behavior ()
    (while (not (time-elapsed? (-> self state-time) (seconds 0.5)))
      (suspend)
      )
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (rand-vu-sphere-point! gp-0 105472.0)
      (set! (-> gp-0 y) -20480.0)
      (cond
        ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-0 (-> self root trans) gp-0) quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-0 (-> self root trans) gp-0) quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
          )
        )
      (sound-play "gem-explode")
      (rand-vu-sphere-point! gp-0 105472.0)
      (set! (-> gp-0 y) -32768.0)
      (cond
        ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-0 (-> self root trans) gp-0) quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-0 (-> self root trans) gp-0) quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
          )
        )
      )
    (sound-play "gem-explode")
    (setup
      *screen-filter*
      (new 'static 'vector :x 255.0 :y 255.0 :z 255.0)
      (new 'static 'vector :x 255.0 :y 255.0 :z 255.0 :w 128.0)
      (* 0.033333335 (seconds-per-frame))
      (bucket-id tex-hud-pris2)
      #x3fffff
      #x33001
      #t
      )
    (set-setting! 'allow-blackout #f 0.0 0)
    (while (not (time-elapsed? (-> self state-time) (seconds 1.5)))
      (suspend)
      )
    (let ((gp-4 (new 'stack-no-clear 'vector)))
      (rand-vu-sphere-point! gp-4 105472.0)
      (set! (-> gp-4 y) -61440.0)
      (cond
        ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-4 (-> self root trans) gp-4) quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-4 (-> self root trans) gp-4) quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
          )
        )
      (sound-play "gem-explode")
      (rand-vu-sphere-point! gp-4 105472.0)
      (set! (-> gp-4 y) -20480.0)
      (cond
        ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-4 (-> self root trans) gp-4) quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-4 (-> self root trans) gp-4) quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
          )
        )
      )
    (sound-play "gem-explode")
    (while (not (time-elapsed? (-> self state-time) (seconds 2)))
      (suspend)
      )
    (let ((gp-8 (new 'stack-no-clear 'vector)))
      (rand-vu-sphere-point! gp-8 105472.0)
      (set! (-> gp-8 y) -61440.0)
      (cond
        ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-8 (-> self root trans) gp-8) quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-8 (-> self root trans) gp-8) quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
          )
        )
      (sound-play "gem-explode")
      (rand-vu-sphere-point! gp-8 105472.0)
      (set! (-> gp-8 y) -20480.0)
      (cond
        ((logtest? (-> *part-group-id-table* 1313 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-8 (-> self root trans) gp-8) quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1313))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> (vector+! gp-8 (-> self root trans) gp-8) quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1313))
          )
        )
      )
    (sound-play "gem-explode")
    (while (not (time-elapsed? (-> self state-time) (seconds 6)))
      (suspend)
      )
    (process-spawn scene-player :init scene-player-init "precursor-tour-res" #t #f :name "scene-player")
    )
  )

(defmethod init-from-entity! ((this precur-generator-d) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-generator-d" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this next-lightning-time) (the-as uint 0))
  (set! (-> this entity) arg0)
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this animation-speed) 0.5)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-18 (res-lump-data arg0 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-18 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-18))
       )
      (else
        (format 0 "ERROR: entity missing actor-group!~%")
        )
      )
    )
  (dotimes (v1-20 3)
    (set! (-> this proc-handle v1-20) (the-as handle #f))
    )
  (spawn-gems this)
  (set! (-> this root scale z) 1.3)
  (go (method-of-object this idle))
  )

(deftype precur-platform-round (process-drawable)
  ((root              collide-shape :override)
   (start-quat        quaternion     :inline)
   (start-height      float)
   (sound-id          sound-id)
   (start-dip-time    float)
   (last-ridden-time  float)
   )
  (:state-methods
    idle
    hidden-state
    rotate-plat
    fade-in
    )
  (:methods
    (precur-platform-round-method-24 () none)
    )
  )


(defskelgroup skel-precur-platform-round precur-platform-round precur-platform-round-lod0-jg precur-platform-round-idle-ja
              ((precur-platform-round-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 17.5)
              )

(defstate idle (precur-platform-round)
  :virtual #t
  :code sleep-code
  :post ja-post
  )

(defstate hidden-state (precur-platform-round)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stop-rotate)
       (go-virtual idle)
       )
      (('trigger)
       (go-virtual fade-in)
       )
      )
    )
  :enter (behavior ()
    (when (type? (-> self root) collide-shape)
      (let ((v1-2 (-> self root root-prim)))
        (set! (-> v1-2 prim-core collide-as) (collide-spec))
        (set! (-> v1-2 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (set! (-> self draw force-fade) (the-as uint 0))
    0
    )
  :exit (behavior ()
    (when (type? (-> self root) collide-shape)
      (let ((v1-2 (-> self root root-prim)))
        (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
        (set! (-> v1-2 prim-core collide-with) (-> self root backup-collide-with))
        )
      )
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    )
  :code sleep-code
  :post rider-post
  )

(defstate fade-in (precur-platform-round)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (sound-play "plat-appear")
    )
  :exit (behavior ()
    (logclear! (-> self draw status) (draw-control-status force-fade))
    (spawn-from-mat (-> self part) (-> self node-list data 4 bone transform))
    )
  :trans (behavior ()
    (let ((f30-0 (* 0.0033333334 (the float (- (current-time) (-> self state-time))))))
      (spawn-from-mat (-> self part) (-> self node-list data 4 bone transform))
      (let ((f0-2 (fmax 0.0 (fmin 1.0 f30-0))))
        (logior! (-> self draw status) (draw-control-status force-fade))
        (set! (-> self draw force-fade) (the-as uint (the int (* 128.0 f0-2))))
        (when (= f0-2 1.0)
          (spawn-from-mat (-> self part) (-> self node-list data 4 bone transform))
          (go-virtual rotate-plat)
          )
        )
      )
    (rider-trans)
    )
  :code sleep-code
  :post rider-post
  )

;; WARN: Return type mismatch object vs none.
(defbehavior rotate-platform-behavior precur-platform-round ()
  (add-debug-sphere
    #t
    (bucket-id debug)
    (-> self node-list data 4 bone transform trans)
    (meters 1)
    *color-green*
    )
  (sound-play "prec-plats" :id (-> self sound-id) :position (-> self root trans))
  (if (not (time-elapsed? (-> self state-time) (seconds 10)))
      (spawn-from-mat (-> self part) (-> self node-list data 4 bone transform))
      )
  0.0
  (let* ((f0-2 (* 0.00033333336 (the float (- (current-time) (-> self state-time)))))
         (f0-3 (lerp 0.0 65536.0 f0-2))
         )
    (quaternion-rotate-local-y! (-> self root quat) (-> self start-quat) f0-3)
    )
  (rider-trans)
  (when (< 0.0 (-> self start-dip-time))
    (let ((f30-0
            (sin-rad
              (* 0.010471975 (the float (- (current-time) (the-as time-frame (the int (-> self start-dip-time))))))
              )
            )
          )
      (when (< (seconds 1) (- (current-time) (the-as time-frame (the int (-> self start-dip-time)))))
        (set! (-> self start-dip-time) -1.0)
        (set! (-> self root trans y) (-> self start-height))
        (format 0 "end-dip~%")
        )
      (set! (-> self root trans y) (+ (* -10240.0 f30-0) (-> self start-height)))
      (format 0 "processing-dip: ~f~%" f30-0)
      )
    )
  (none)
  )

(defstate rotate-plat (precur-platform-round)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (persist-with-delay *setting-control* 'pilot-exit (seconds 0.5) 'pilot-exit #f 0.0 0)
       )
      (('ridden)
       (when (< (-> self start-dip-time) 0.0)
         (when (< (seconds 0.1) (- (current-time) (the-as time-frame (the int (-> self last-ridden-time)))))
           (set! (-> self start-dip-time) (the float (current-time)))
           (format 0 "start-dip~%")
           )
         )
       (set! (-> self last-ridden-time) (the float (current-time)))
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans rotate-platform-behavior
  :code sleep-code
  :post rider-post
  )

(defmethod init-from-entity! ((this precur-platform-round) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 2)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 71680.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 2)
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 71680.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this start-dip-time) -1.0)
  (set! (-> this start-height) (-> this root trans y))
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-precur-platform-round" (the-as (pointer level) #f))
      )
    (the-as pair 0)
    )
  (quaternion-copy! (-> this start-quat) (-> this root quat))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1314) this))
  (let* ((s5-2 (-> this part))
         (s4-2 (method-of-object s5-2 set-local-space-info))
         (s3-1 (add-connection *part-local-space-engine* this local-space-proc-joint 4 0 0))
         )
    (let ((v1-31 (process->handle this)))
      (if (= v1-31 #f)
          (set! v1-31 (process->handle this))
          )
      (set! (-> (the-as particle-local-space-info s3-1) hand) (the-as handle v1-31))
      )
    (matrix-identity! (-> (the-as particle-local-space-info s3-1) mat-new))
    (matrix-identity! (-> (the-as particle-local-space-info s3-1) mat-prev))
    (set! (-> (the-as particle-local-space-info s3-1) flags) (part-local-space-flags))
    (s4-2 s5-2 (the-as particle-local-space-info s3-1))
    )
  (go (method-of-object this hidden-state))
  )

(deftype precur-door-d (process-drawable)
  ((root  collide-shape :override)
   )
  (:state-methods
    idle
    die
    )
  )


(defskelgroup skel-precur-door-d precur-door-d precur-door-d-lod0-jg precur-door-d-idle-ja
              ((precur-door-d-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 20)
              )

(defskelgroup skel-precur-door-d-explode precur-door-d precur-door-d-explode-lod0-jg precur-door-d-explode-idle-ja
              ((precur-door-d-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 20)
              )

(define *precur-door-d-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 21 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defstate idle (precur-door-d)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((s4-0 (the-as attack-info (-> block param 1))))
         (case (-> s4-0 mode)
           (('mech-punch 'crush)
            (let ((s3-0
                    (the-as attack-info (mem-copy! (the-as pointer (new 'stack-no-clear 'attack-info)) (the-as pointer s4-0) 168))
                    )
                  )
              (compute-intersect-info
                s3-0
                s4-0
                self
                (if (type? proc process-drawable)
                    proc
                    )
                (the-as touching-shapes-entry (-> block param 0))
                )
              (if (logtest? (-> s3-0 mask) (attack-mask intersection))
                  (go-virtual die)
                  )
              )
            )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (let ((gp-0 (matrix<-transformq! (new 'stack-no-clear 'matrix) (the-as transformq (-> self root trans))))
          (s5-0 (new 'stack-no-clear 'quaternion))
          )
      (quaternion-copy! s5-0 (-> self root quat))
      (quaternion-rotate-local-y! s5-0 s5-0 16384.0)
      (when (= (status-of-level-and-borrows *level* 'lmech #f) 'active)
        (mech-target-spawn
          (vector-matrix*! (new 'stack-no-clear 'vector) (new 'static 'vector :x 8192.0 :w 1.0) gp-0)
          self
          s5-0
          (-> self entity)
          )
        (mech-target-spawn
          (vector-matrix*! (new 'stack-no-clear 'vector) (new 'static 'vector :x -8192.0 :w 1.0) gp-0)
          self
          s5-0
          (-> self entity)
          )
        )
      )
    )
  :exit (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post transform-post
  )

(defstate die (precur-door-d)
  :virtual #t
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (sound-play "prec-break-door")
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set-vector! (-> gp-0 fountain-rand-transv-lo) -122880.0 40960.0 -122880.0 1.0)
      (set-vector! (-> gp-0 fountain-rand-transv-hi) 122880.0 81920.0 122880.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-precur-door-d-explode" (the-as (pointer level) #f))
        5
        gp-0
        *precur-door-d-exploder-params*
        :name "joint-exploder"
        :to self
        :unk 0
        )
      )
    (suspend)
    (when (type? (-> self root) collide-shape)
      (let ((v1-10 (-> self root root-prim)))
        (set! (-> v1-10 prim-core collide-as) (collide-spec))
        (set! (-> v1-10 prim-core collide-with) (collide-spec))
        )
      0
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (transform-post)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defmethod init-from-entity! ((this precur-door-d) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 2)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 71680.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 2)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 71680.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-door-d" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

(defbehavior precur-door-d-init-by-other precur-door-d ((arg0 object) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (init-from-entity! self arg1)
  )

(defskelgroup skel-precur-door-c precur-door-c precur-door-c-lod0-jg precur-door-c-idle-ja
              ((precur-door-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(defskelgroup skel-precur-door-c-explode precur-door-c precur-door-c-explode-lod0-jg precur-door-c-explode-idle-ja
              ((precur-door-c-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *precur-door-c-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(deftype precur-door-c (process-drawable)
  ((root  collide-shape :override)
   )
  (:state-methods
    idle
    explode
    )
  (:methods
    (init-collision! (_type_) none)
    (spawn-exploder (_type_) (pointer joint-exploder))
    )
  )


(defbehavior precur-door-c-handler precur-door-c ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (case (-> (the-as attack-info (-> arg3 param 1)) mode)
       (('spin 'dark-smack)
        (go-virtual explode)
        )
       )
     )
    )
  )

;; WARN: Return type mismatch (pointer process) vs (pointer joint-exploder).
(defmethod spawn-exploder ((this precur-door-c))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (f0-0 (rand-vu-float-range 0.5 1.5))
            )
        (let ((v1-1 (-> gp-0 fountain-rand-transv-lo)))
          (let ((a0-4 (-> this root trans)))
            (let ((a1-2 *up-vector*))
              (let ((a2-1 0.0))
                (.mov vf7 a2-1)
                )
              (.lvf vf5 (&-> a1-2 quad))
              )
            (.lvf vf4 (&-> a0-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> v1-1 quad) vf6)
          )
        (vector-reset! s4-0)
        (let ((a1-3 s4-0))
          (let ((v1-3 s4-0))
            (let ((a0-5 *up-vector*))
              (let ((a2-3 40960.0))
                (.mov vf7 a2-3)
                )
              (.lvf vf5 (&-> a0-5 quad))
              )
            (.lvf vf4 (&-> v1-3 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-3 quad) vf6)
          )
        (let ((a1-4 (-> gp-0 fountain-rand-transv-lo)))
          (let ((v1-4 s4-0))
            (let ((a0-6 *identity-vector*))
              (let ((a2-5 (* -204800.0 f0-0)))
                (.mov vf7 a2-5)
                )
              (.lvf vf5 (&-> a0-6 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-4 quad) vf6)
          )
        (let ((a0-7 (-> gp-0 fountain-rand-transv-hi)))
          (let ((v1-5 *identity-vector*))
            (let ((a1-6 (* 204800.0 f0-0)))
              (.mov vf7 a1-6)
              )
            (.lvf vf5 (&-> v1-5 quad))
            )
          (.lvf vf4 (&-> s4-0 quad))
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a0-7 quad) vf6)
          )
        )
      (set! (-> gp-0 gravity) -122880.0)
      (set! (-> gp-0 rot-speed) 16.0)
      (set! (-> gp-0 friction) 0.3)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-precur-door-c-explode" (the-as (pointer level) #f))
        5
        gp-0
        *precur-door-c-exploder-params*
        :name "joint-exploder"
        :to this
        :unk 0
        )
      )
    )
  )

(defstate explode (precur-door-c)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (spawn-exploder self)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defstate idle (precur-door-c)
  :virtual #t
  :event precur-door-c-handler
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defmethod init-collision! ((this precur-door-c))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 32768.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 0)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-9 transform-index) 0)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this precur-door-c) (arg0 entity-actor))
  (init-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-door-c" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

(defun-debug hint-type->string ((arg0 precur-hint-type))
  (case arg0
    (((precur-hint-type pickup-hint))
     "pickup-hint"
     )
    (((precur-hint-type normal))
     "normal"
     )
    (((precur-hint-type place-hint))
     "place-hint"
     )
    (else
      "*unknown*"
      )
    )
  )

(deftype task-manager-precur-tour (task-manager)
  ((hint-type  precur-hint-type)
   )
  )


(defmethod set-time-limit ((this task-manager-precur-tour))
  (call-parent-method this)
  (disable *screen-filter*)
  (set-setting! 'gun-special-mode #t 0.0 0)
  (set-setting! 'pilot-exit #f 0.0 0)
  (set-setting! 'music 'pretour 0.0 0)
  (set! (-> this hint-type) (precur-hint-type normal))
  (none)
  )

;; WARN: disable def twice: 12. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod taskman-event-handler ((this task-manager-precur-tour) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('pickup-hint)
     (when (= (-> this hint-type) (precur-hint-type normal))
       (set! (-> this hint-type) (precur-hint-type pickup-hint))
       0
       )
     )
    (('place-hint)
     (when (= (-> this hint-type) (precur-hint-type pickup-hint))
       (let ((v0-0 (the-as object 1)))
         (set! (-> this hint-type) (the-as precur-hint-type v0-0))
         v0-0
         )
       )
     )
    (else
      ((method-of-type task-manager taskman-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

;; WARN: Return type mismatch sound-id vs none.
(defmethod task-manager-method-26 ((this task-manager-precur-tour))
  (cond
    ((= (-> this hint-type) (precur-hint-type pickup-hint))
     (talker-spawn-func (-> *talker-speech* 348) *entity-pool* (target-pos 0) (the-as region #f))
     )
    ((= (-> this hint-type) (precur-hint-type place-hint))
     (talker-spawn-func (-> *talker-speech* 349) *entity-pool* (target-pos 0) (the-as region #f))
     )
    ((= (-> this hint-type) (precur-hint-type normal))
     (talker-spawn-func (-> *talker-speech* 350) *entity-pool* (target-pos 0) (the-as region #f))
     (talker-spawn-func (-> *talker-speech* 141) *entity-pool* (target-pos 0) (the-as region #f))
     )
    )
  (none)
  )

(defskelgroup skel-precura-door-a precur-door-a precur-door-a-lod0-jg precur-door-a-idle-ja
              ((precur-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 10)
              )

(deftype precura-door-a (process-drawable)
  ((open-test     pair)
   (open-started  time-frame)
   (do-camera?    symbol)
   (open-frame    float)
   (precur-tour?  symbol)
   )
  (:state-methods
    open
    close
    )
  (:methods
    (precura-door-a-method-22 () none)
    )
  )


(defmethod init-from-entity! ((this precura-door-a) (arg0 entity-actor))
  (set! (-> this open-started) 0)
  (set! (-> this open-frame) 45.0)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 24576.0 0.0 40960.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 0.0 24576.0 0.0 40960.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (set! (-> this precur-tour?) (task-node-open? (game-task-node precursor-tour-generator-trigger)))
  (set! (-> this open-test)
        (the-as
          pair
          ((method-of-type res-lump get-property-struct)
           (-> this entity)
           'open-test
           'interp
           -1000000000.0
           (the-as structure '(not (or (scene-player?) (focus-test? *target* grabbed))))
           (the-as (pointer res-tag) #f)
           *res-static-buf*
           )
          )
        )
  (set! (-> this do-camera?)
        (the-as
          symbol
          (and (res-lump-struct (-> this entity) 'camera-name structure)
               (task-node-closed? (game-task-node precursor-tour-resolution))
               )
          )
        )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precura-door-a" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root pause-adjust-distance) 1228800.0)
  (go (method-of-object this close))
  )

(defstate close (precura-door-a)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (until #f
      (when (script-eval (-> self open-test))
        (when (and (-> self precur-tour?)
                   (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
                        )
                   )
          (suspend-for (seconds 1.5))
          (set-setting! 'entity-name "camera-420" 0.0 0)
          (process-grab? *target* #f)
          (process-entity-status! self (entity-perm-status subtask-complete) #t)
          )
        (go-virtual open)
        )
      (suspend)
      )
    #f
    )
  :post transform-post
  )

(defun precura-do-blur-if-more-than-dist-away ((arg0 vector) (arg1 float))
  (let ((f0-0 (vector-vector-distance (target-pos 0) arg0)))
    (when (< arg1 f0-0)
      (persist-with-delay *setting-control* 'blur-a (seconds 2) 'blur-a 'abs 0.5 0)
      (set! (-> *display* force-sync) (the-as uint 200))
      )
    )
  0
  (none)
  )

(defstate open (precura-door-a)
  :virtual #t
  :enter (behavior ()
    (cond
      ((-> self precur-tour?)
       (set-time! (-> self state-time))
       (set-time! (-> self open-started))
       )
      (else
        (cond
          ((and (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
                     )
                (and (-> self do-camera?) (zero? (-> self open-started)))
                )
           (precura-do-blur-if-more-than-dist-away (-> self root trans) 368640.0)
           (if (res-lump-struct (-> self entity) 'camera-name structure)
               (process-spawn
                 external-camera-controller
                 (-> self entity)
                 900
                 #f
                 :name "external-camera-controller"
                 :to *entity-pool*
                 )
               )
           (let* ((v1-19 (-> *game-info* sub-task-list (game-task-node precursor-destroy-ship-escape)))
                  (v1-21 (if (-> v1-19 manager)
                             (-> v1-19 manager manager)
                             (the-as handle #f)
                             )
                         )
                  )
             (if v1-21
                 (send-event (handle->process v1-21) 'extra-time 1200)
                 )
             )
           (process-entity-status! self (entity-perm-status subtask-complete) #t)
           (set-time! (-> self open-started))
           )
          (else
            (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
            )
          )
        (set-time! (-> self state-time))
        )
      )
    )
  :code (behavior ()
    (when (-> self precur-tour?)
      (suspend-for (seconds 2.5))
      (remove-setting! 'entity-name)
      (process-release? *target*)
      )
    (sleep-code)
    )
  :post (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 2))
      (if (>= 0.0 (ja-frame-num 0))
          (sound-play "prec-door-open")
          )
      (ja :num! (seek! (ja-aframe (-> self open-frame) 0)))
      )
    (transform-post)
    )
  )
