;;-*-Lisp-*-
(in-package goal)

;; name: precura-obs2.gc
;; name in dgo: precura-obs2
;; dgos: PRECA

;; +++precur-hint-mode
(defenum precur-hint-mode
  :type uint8
  (teach-bomb)
  (normal)
  )
;; ---precur-hint-mode


(define-extern *precur-tour-lightning* lightning-appearance)

;; DECOMP BEGINS

(defpartgroup group-kg-bomb-explosion
  :id 1325
  :duration (seconds 2)
  :linger-duration (seconds 1)
  :flags (sp0 sp5 sp6 sp7)
  :bounds (static-bspherem 0 0 0 15)
  :rotate ((degrees 0) (degrees 90) (degrees 0))
  :scale (1.5 1.5 1.5)
  :parts ((sp-item 4446 :flags (sp3))
    (sp-item 4447 :flags (sp3))
    (sp-item 4448 :flags (sp3))
    (sp-item 4449 :flags (sp3))
    )
  )

(defpart 4446
  :init-specs ((:texture (shockwave level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 10))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:scalevel-x (meters 0.33333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -1.28)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0))
    )
  )

(defpart 4447
  :init-specs ((:texture (glow-soft level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 20))
    (:rot-x (degrees 225))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 0.0)
    (:b 255.0)
    (:a 64.0)
    (:fade-a -0.21333334)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 40960.0)
    )
  )

(defpart 4448
  :init-specs ((:texture (starflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 50))
    (:rot-x (degrees 2.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 0.0)
    (:b 255.0)
    (:a 255.0)
    (:omega (degrees 6767.9995))
    (:scalevel-x (meters -0.6666667))
    (:scalevel-y :copy scalevel-x)
    (:timer (seconds 0.135))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    )
  )

(defpart 4450
  :init-specs ((:texture (explosion-edge level-default-sprite))
    (:birth-func 'birth-func-flip-based-on-scale)
    (:num 10.0)
    (:scale-x (meters -1) 2.0 (meters 2))
    (:rot-y (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 130.0)
    (:g 200.0 20.0)
    (:b 255.0)
    (:a 128.0)
    (:vel-y (meters 0) (meters 0.16666667))
    (:scalevel-x (meters 0.013333334) (meters 0.013333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.26666668)
    (:fade-g -0.1)
    (:fade-a -0.42666668 -0.42666668)
    (:friction 0.8)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-0))
    (:func 'sparticle-2d-spline-align-instant)
    (:conerot-x (degrees 0) (degrees 360))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 4449
  :init-specs ((:texture (water-radiate level-default-sprite))
    (:birth-func 'birth-func-flip-based-on-scale)
    (:num 100.0)
    (:x (meters 0) (meters 0.1))
    (:scale-x (meters -1) 2.0 (meters 2))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:vel-y (meters 0.16666667) (meters 0.033333335))
    (:scalevel-x (meters 0.013333334))
    (:fade-g -1.7)
    (:fade-a -0.85)
    (:friction 0.83)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-3 left-multiply-quat))
    (:func 'sparticle-2d-spline-align-instant)
    (:next-time (seconds 0.25))
    (:next-launcher 4451)
    (:conerot-x (degrees -90) (degrees 180))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 4451
  :init-specs ((:scalevel-x (meters 0)) (:scalevel-y :copy scalevel-x) (:fade-g -0.6666667) (:friction 0.99))
  )

(deftype mechblock (process-focusable)
  ((root            collide-shape-moving :override)
   (origin          vector                :inline)
   (drop-point      vector                :inline :offset 256)
   (allow-drag?     symbol)
   (reset-on-land?  symbol)
   (nav-mesh        nav-mesh)
   (hit-something?  symbol)
   (attack-id       uint32)
   (next-entity     entity)
   )
  (:state-methods
    idle
    carry
    drag-object
    fall
    wait
    )
  (:methods
    (can-drop? (_type_ vector) symbol)
    )
  )


(defmethod can-drop? ((this mechblock) (arg0 vector))
  (let ((v1-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg0 8192.0))
        (a1-1 (new 'stack-no-clear 'collide-query))
        )
    (vector+float*! (-> a1-1 start-pos) (-> this root trans) v1-0 -1.0)
    (vector-float*! (-> a1-1 move-dist) v1-0 2.0)
    (let ((v1-1 a1-1))
      (set! (-> v1-1 radius) 40.96)
      (set! (-> v1-1 collide-with) (collide-spec backgnd))
      (set! (-> v1-1 ignore-process0) #f)
      (set! (-> v1-1 ignore-process1) #f)
      (set! (-> v1-1 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-1 action-mask) (collide-action solid))
      )
    (cond
      ((= (fill-and-probe-using-line-sphere *collide-cache* a1-1) -100000000.0)
       (return #t)
       )
      (else
        (sound-play "mech-drag-pikup")
        (return #f)
        )
      )
    )
  (the-as symbol 0)
  )

(defstate idle (mechblock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('carry? 'carry-info)
       (-> self carry)
       )
      (('pickup)
       (go-virtual carry)
       (cond
         ((-> self allow-drag?)
          (carry!
            (the-as carry-info (-> block param 0))
            (-> self carry)
            (the-as vector (-> block param 1))
            (the-as vector (-> block param 2))
            )
          (go-virtual drag-object)
          )
         (else
           (drag! (the-as carry-info (-> block param 0)) (-> self carry))
           (go-virtual carry)
           )
         )
       )
      )
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (dotimes (gp-0 2)
      (transform-post)
      (carry-info-method-9 (-> self carry))
      (suspend)
      )
    (sleep-code)
    )
  :post (behavior ()
    (when *display-nav-marks*
      )
    )
  )

(defstate wait (mechblock)
  :virtual #t
  :exit (behavior ()
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-3 prim-core collide-with) (-> self root backup-collide-with))
      )
    )
  :trans (behavior ()
    (when (or (not *target*) (< 40960.0 (vector-vector-distance (-> self origin) (-> *target* control trans))))
      (move-to-point!
        (-> self root)
        (vector+! (new 'stack-no-clear 'vector) (-> self origin) (new 'static 'vector :y 81920.0 :w 1.0))
        )
      (quaternion-copy! (-> self root quat) (the-as quaternion (&-> self stack 96)))
      (set-vector! (-> self root transv) 0.0 -4096.0 0.0 1.0)
      (set! (-> self drop-point quad) (-> self origin quad))
      (go-virtual fall)
      )
    )
  :code (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defstate carry (mechblock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('carry? 'carry-info)
       (-> self carry)
       )
      (('can-drop?)
       (can-drop? self (the-as vector (-> block param 0)))
       )
      (('drop)
       (set! (-> self root transv quad) (-> (the-as vector (-> block param 1)) quad))
       (set! (-> self drop-point quad) (-> self root trans quad))
       (go-virtual fall)
       )
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    (carry-info-method-9 (-> self carry))
    (carry-info-method-13 (-> self carry))
    (update-transforms (-> self root))
    )
  )

(defstate drag-object (mechblock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('carry? 'carry-info)
         (-> self carry)
         )
        (('drop)
         (if (handle->process (-> self carry other))
             (drop! (the-as carry-info (send-event (handle->process (-> self carry other)) 'carry-info)) (-> self carry))
             )
         (set! (-> self root transv quad) (-> (the-as vector (-> block param 1)) quad))
         (set! (-> self drop-point quad) (-> self root trans quad))
         (go-virtual fall)
         )
        (('move)
         (let ((s4-0 (-> self root))
               (s5-0 (new 'stack-no-clear 'vector))
               )
           (set! (-> s5-0 quad) (-> s4-0 trans quad))
           (set! (-> s4-0 transv quad) (-> (the-as vector (-> block param 0)) quad))
           (let ((s2-0 (-> self nav))
                 (s1-0 (-> s4-0 root-prim prim-core))
                 (s3-0 (new 'stack-no-clear 'vector))
                 )
             (.lvf vf1 (&-> (-> s4-0 transv) quad))
             (let ((f0-0 (seconds-per-frame)))
               (.mov at-0 f0-0)
               )
             (.mov vf2 at-0)
             (.mov.vf vf1 vf0 :mask #b1000)
             (.mul.x.vf vf1 vf1 vf2 :mask #b111)
             (.svf (&-> s3-0 quad) vf1)
             (set! (-> s3-0 y) 0.0)
             (vector-float*! s3-0 s3-0 10.0)
             (when (nonzero? s2-0)
               (let ((v1-28 s2-0)
                     (a0-26 s1-0)
                     (a1-6 (new 'stack-no-clear 'nav-poly))
                     )
                 (vector-! (the-as vector (-> a1-6 vertex)) (the-as vector a0-26) (the-as vector (-> v1-28 state mesh bounds)))
                 (set! (-> a1-6 vertex1 x) (-> v1-28 nearest-y-threshold))
                 (set! (-> a1-6 data 20) (the-as uint 2))
                 (let ((a2-4 (nav-mesh-method-45 (-> v1-28 state mesh) a1-6)))
                   (cond
                     (a2-4
                       (clamp-vector-to-mesh-cross-gaps
                         s2-0
                         (the-as vector s1-0)
                         a2-4
                         s3-0
                         204.8
                         #f
                         (the-as clamp-travel-vector-to-mesh-return-info #f)
                         )
                       )
                     (else
                       )
                     )
                   )
                 )
               )
             (vector-float*! (-> s4-0 transv) s3-0 (/ (-> self clock frames-per-second) 10))
             )
           (let ((v1-35 (-> s4-0 root-prim)))
             (set! (-> v1-35 prim-core collide-as) (-> s4-0 backup-collide-as))
             (set! (-> v1-35 prim-core collide-with) (-> s4-0 backup-collide-with))
             )
           (set! (-> s4-0 root-prim type) collide-shape-prim-sphere)
           (let ((a2-5 (new 'stack-no-clear 'collide-query)))
             (set! (-> a2-5 collide-with)
                   (logclear (-> s4-0 root-prim prim-core collide-with) (collide-spec backgnd jak player-list tobot))
                   )
             (set! (-> a2-5 ignore-process0) self)
             (set! (-> a2-5 ignore-process1) #f)
             (set! (-> a2-5 ignore-pat) (-> s4-0 pat-ignore-mask))
             (set! (-> a2-5 action-mask) (collide-action solid))
             (fill-cache-integrate-and-collide s4-0 (-> s4-0 transv) a2-5 (meters 0))
             )
           (when (nonzero? (-> self nav))
             (let ((v1-44 (-> self nav))
                   (a0-41 (-> self root root-prim prim-core))
                   (a1-9 (new 'stack-no-clear 'nav-poly))
                   )
               (vector-! (the-as vector (-> a1-9 vertex)) (the-as vector a0-41) (the-as vector (-> v1-44 state mesh bounds)))
               (set! (-> a1-9 vertex1 x) (-> v1-44 nearest-y-threshold))
               (set! (-> a1-9 data 20) (the-as uint 2))
               (let ((v1-46 (nav-mesh-method-45 (-> v1-44 state mesh) a1-9)))
                 (when v1-46
                   (when (< (-> self root trans y) (-> v1-46 vertex0 y))
                     (let* ((a0-47 (-> self root))
                            (t9-7 (method-of-object a0-47 move-by-vector!))
                            (a1-11 (new 'stack-no-clear 'vector))
                            )
                       (set! (-> a1-11 x) 0.0)
                       (set! (-> a1-11 y) (- (-> v1-46 vertex0 y) (-> self root trans y)))
                       (set! (-> a1-11 z) 0.0)
                       (set! (-> a1-11 w) 1.0)
                       (t9-7 a0-47 a1-11)
                       )
                     )
                   )
                 )
               )
             )
           (set! (-> s4-0 root-prim type) collide-shape-prim-mesh)
           (let ((v1-50 (-> s4-0 root-prim)))
             (set! (-> v1-50 prim-core collide-as) (collide-spec))
             (set! (-> v1-50 prim-core collide-with) (collide-spec))
             )
           0
           (vector-! (the-as vector (-> block param 1)) (-> s4-0 trans) s5-0)
           )
         )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    (carry-info-method-9 (-> self carry))
    (translate! (-> self carry))
    (update-transforms (-> self root))
    )
  )

(defstate fall (mechblock)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('carry-info)
       (-> self carry)
       )
      (('carry? 'pickup)
       (the-as basic #f)
       )
      (('touched)
       (when (!= (-> proc type) target)
         (sound-play "block-hit")
         (let ((v0-0 (the-as basic (-> proc entity))))
           (set! (-> self hit-something?) (the-as symbol v0-0))
           v0-0
           )
         )
       )
      )
    )
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (set-time! (-> self state-time))
    (if (handle->process (-> self carry other))
        (drop-impl!
          (the-as carry-info (send-event (handle->process (-> self carry other)) 'carry-info))
          (-> self carry)
          )
        )
    (set! (-> self root status) (collide-status))
    (set! (-> self root root-prim local-sphere w) (-> self carry carry-radius))
    )
  :trans (behavior ()
    (when (or (and (logtest? (-> self root status) (collide-status on-surface)) (< 0.8 (-> self root surface-angle)))
              (time-elapsed? (-> self state-time) (seconds 5))
              )
      (vector-reset! (-> self root transv))
      (set! (-> self root root-prim local-sphere w) (-> self carry backup-radius))
      (cond
        ((and (-> self reset-on-land?)
              (and (or (< 12288.0 (vector-vector-distance (-> self drop-point) (-> self root trans)))
                       (time-elapsed? (-> self state-time) (seconds 5))
                       )
                   (and (-> self next-entity)
                        (not (logtest? (-> self next-entity extra perm status) (entity-perm-status subtask-complete)))
                        )
                   )
              )
         (sound-play "block-break")
         (cond
           ((logtest? (-> *part-group-id-table* 195 flags) (sp-group-flag sp13))
            (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
            (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 195))
            )
           (else
             (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
             (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 195))
             )
           )
         (go-virtual wait)
         )
        ((or (< 12288.0 (vector-vector-distance (-> self drop-point) (-> self root trans)))
             (time-elapsed? (-> self state-time) (seconds 5))
             )
         (sound-play "block-break")
         (cond
           ((logtest? (-> *part-group-id-table* 195 flags) (sp-group-flag sp13))
            (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
            (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 195))
            )
           (else
             (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
             (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 195))
             )
           )
         (go-virtual wait)
         )
        (else
          (go-virtual idle)
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (vector-v++! (-> self root transv) (compute-acc-due-to-gravity (-> self root) (new-stack-vector0) 0.0))
    (let ((v1-2 (new-stack-vector0))
          (f0-1 (vector-dot (-> self root dynam gravity-normal) (-> self root transv)))
          )
      0.0
      (vector-! v1-2 (-> self root transv) (vector-float*! v1-2 (-> self root dynam gravity-normal) f0-1))
      (let* ((f1-2 (vector-length v1-2))
             (f2-0 f1-2)
             )
        (if (< f0-1 (- (-> self root dynam gravity-max)))
            (set! f0-1 (- (-> self root dynam gravity-max)))
            )
        (vector+!
          (-> self root transv)
          (vector-float*! (-> self root transv) (-> self root dynam gravity-normal) f0-1)
          (vector-float*! v1-2 v1-2 (/ f1-2 f2-0))
          )
        )
      )
    (let ((a2-8 (new 'stack-no-clear 'collide-query))
          (gp-1 (-> self root))
          )
      (let ((v1-3 #x80402))
        (set! (-> gp-1 root-prim type) collide-shape-prim-sphere)
        (if (time-elapsed? (-> self state-time) (seconds 0.2))
            (set! v1-3 0)
            )
        (set! (-> a2-8 collide-with) (logclear (-> gp-1 root-prim prim-core collide-with) v1-3))
        )
      (set! (-> a2-8 ignore-process0) self)
      (set! (-> a2-8 ignore-process1) #f)
      (set! (-> a2-8 ignore-pat) (-> gp-1 pat-ignore-mask))
      (set! (-> a2-8 action-mask) (collide-action solid))
      (fill-cache-integrate-and-collide gp-1 (-> gp-1 transv) a2-8 (meters 0))
      (set! (-> gp-1 root-prim type) collide-shape-prim-mesh)
      )
    (transform-post)
    (carry-info-method-9 (-> self carry))
    )
  )

(defun precur-bomb-bounce-reaction ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (let ((f28-0 (vector-dot arg3 (-> arg0 surface-normal)))
        (s2-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    0.0
    (let ((f30-0 (vector-length arg3)))
      0.0
      (let* ((f0-5 (fabs (vector-dot (-> arg0 surface-normal) *up-vector*)))
             (f0-6 (* f0-5 f0-5))
             (f0-7 (- 1.0 f0-6))
             )
        (set! (-> s3-0 quad) (-> arg0 surface-normal quad))
        (set! (-> s3-0 y) 0.0)
        (vector-normalize! s3-0 f0-7)
        )
      (vector-float*! s3-0 s3-0 f30-0)
      (vector-float*! s2-0 (-> arg0 surface-normal) (* f28-0 (rand-vu-float-range 1.6 2.2)))
      (vector-! arg2 arg3 s2-0)
      (vector+! arg2 arg2 s3-0)
      (let ((f0-12 (fmin (vector-normalize-ret-len! arg2 1.0) f30-0)))
        (vector-float*! arg2 arg2 f0-12)
        )
      )
    )
  (-> arg0 status)
  )

(deftype precur-bomb (mechblock)
  ((bomb-timer              uint32)
   (blink-timer             uint32)
   (blink-rate              float)
   (blink                   symbol)
   (collide-timer           uint32)
   (spin-quat               quaternion  :inline)
   (default-emissive-color  vector      :inline)
   (hint?                   symbol)
   (sound-id                sound-id)
   )
  (:state-methods
    ready
    explode
    spawn-up
    pre-spawn-up
    )
  (:methods
    (update-blink (_type_) object)
    )
  )


(defmethod get-trans ((this precur-bomb) (arg0 int))
  "Get the `trans` for this process."
  (let ((s5-0 (-> this root)))
    (cond
      ((zero? arg0)
       (-> s5-0 trans)
       )
      ((and (= arg0 1) (type? s5-0 collide-shape-moving))
       (-> s5-0 gspot-pos)
       )
      ((= arg0 2)
       (the-as vector #f)
       )
      ((= arg0 3)
       (-> s5-0 trans)
       )
      (else
        (-> s5-0 trans)
        )
      )
    )
  )

;; WARN: Return type mismatch int vs search-info-flag.
(defmethod process-mask->search-info-flag ((this precur-bomb))
  (the-as search-info-flag (logior 0 16))
  )

(defmethod update-blink ((this precur-bomb))
  (when (and (>= (the-as uint (- (current-time) (the-as int (-> this blink-timer))))
                 (the-as uint (the int (-> this blink-rate)))
                 )
             (nonzero? (-> this blink-timer))
             )
    (let ((f0-3 (* 0.00033333333 (the float (- (current-time) (the-as int (-> this bomb-timer)))))))
      (set! (-> this blink-rate) (lerp 600.0 30.0 f0-3))
      )
    (set! (-> this blink-timer) (the-as uint (current-time)))
    (sound-play "prec-bomb-timer")
    (cond
      ((-> this blink)
       (set-vector! (-> this draw color-emissive) 1.0 0.0 0.0 1.0)
       (set! (-> this blink) (not (-> this blink)))
       )
      (else
        (set! (-> this draw color-emissive quad) (-> this default-emissive-color quad))
        (set! (-> this blink) (not (-> this blink)))
        )
      )
    )
  (if (and (>= (the-as uint (- (current-time) (the-as int (-> this bomb-timer)))) (the-as uint 3000))
           (nonzero? (-> this bomb-timer))
           )
      (go (method-of-object this explode))
      )
  )

(defbehavior precur-bomb-handler precur-bomb ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (let ((s4-0 (the-as attack-info (-> arg3 param 1))))
       (case (-> s4-0 mode)
         (('mech-punch 'crush)
          (let ((s3-0
                  (the-as attack-info (mem-copy! (the-as pointer (new 'stack-no-clear 'attack-info)) (the-as pointer s4-0) 168))
                  )
                )
            (compute-intersect-info
              s3-0
              s4-0
              self
              (if (type? arg0 process-drawable)
                  arg0
                  )
              (the-as touching-shapes-entry (-> arg3 param 0))
              )
            (when (logtest? (-> s3-0 mask) (attack-mask intersection))
              (let ((gp-1 (new 'stack-no-clear 'vector)))
                (vector-z-quaternion! gp-1 (target-rot))
                (set! (-> self drop-point quad) (-> self root trans quad))
                (vector-normalize-copy! gp-1 gp-1 102400.0)
                (+! (-> gp-1 y) 102400.0)
                (set! (-> self root transv quad) (-> gp-1 quad))
                )
              (when (zero? (-> self bomb-timer))
                (set! (-> self bomb-timer) (the-as uint (current-time)))
                (set! (-> self blink-timer) (the-as uint (current-time)))
                )
              (go-virtual fall)
              )
            )
          )
         (else
           (go-virtual explode)
           )
         )
       )
     )
    (('combo)
     #t
     )
    (('dont-face?)
     #t
     )
    )
  )

(defstate ready (precur-bomb)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('fall)
       (let ((gp-0 (new 'stack-no-clear 'vector)))
         (vector-z-quaternion! gp-0 (target-rot))
         (set! (-> self drop-point quad) (-> self root trans quad))
         (vector-normalize-copy! gp-0 gp-0 102400.0)
         (+! (-> gp-0 y) 102400.0)
         (set! (-> self root transv quad) (-> gp-0 quad))
         )
       (when (zero? (-> self bomb-timer))
         (set! (-> self bomb-timer) (the-as uint (current-time)))
         (set! (-> self blink-timer) (the-as uint (current-time)))
         )
       (go-virtual fall)
       )
      (else
        (precur-bomb-handler proc argc message block)
        )
      )
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    (set-precura-bomb-light! 0.0 (* 10.0 (seconds-per-frame)))
    )
  :code (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (until #f
      (let ((f30-0 27306.666))
        (sound-play "bomb-hover" :id (-> self sound-id))
        (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* f30-0 (seconds-per-frame)))
        (quaternion-rotate-z! (-> self root quat) (-> self root quat) (* f30-0 (seconds-per-frame)))
        )
      (suspend)
      0
      )
    #f
    )
  :post transform-post
  )

(defstate idle (precur-bomb)
  :virtual #t
  :event precur-bomb-handler
  :trans (behavior ()
    (update-blink self)
    (let ((t9-1 (-> (method-of-type mechblock idle) trans)))
      (if t9-1
          (t9-1)
          )
      )
    )
  )

(defstate pre-spawn-up (precur-bomb)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (if (time-elapsed? (-> self state-time) (seconds 0.4))
        (go-virtual spawn-up)
        )
    )
  )

(defstate spawn-up (precur-bomb)
  :virtual #t
  :event precur-bomb-handler
  :enter (behavior ()
    (set-precura-bomb-light! 1.0 (* 2.0 (seconds-per-frame)))
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (let ((f30-0 3072.0)
          (f28-0 36408.89)
          )
      (while (< 40.96 f30-0)
        (+! (-> self root trans y) f30-0)
        (set! f30-0 (* 0.87 f30-0))
        (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* f28-0 (seconds-per-frame)))
        (quaternion-rotate-z! (-> self root quat) (-> self root quat) (* f28-0 (seconds-per-frame)))
        (set! f28-0 (* 0.95 f28-0))
        (suspend)
        )
      )
    (go-virtual ready)
    )
  :post transform-post
  )

(defstate carry (precur-bomb)
  :virtual #t
  :enter (behavior ()
    (when (zero? (-> self bomb-timer))
      (set! (-> self bomb-timer) (the-as uint (current-time)))
      (set! (-> self blink-timer) (the-as uint (current-time)))
      )
    )
  :trans (behavior ()
    (when (-> self hint?)
      (let ((gp-0
              (new 'stack 'font-context *font-default-matrix* 32 280 0.0 (font-color default) (font-flags shadow kerning))
              )
            )
        (send-event (ppointer->process (-> self parent)) 'stop-hint)
        (set! (-> gp-0 flags) (font-flags shadow kerning large))
        (let ((v1-9 gp-0))
          (set! (-> v1-9 width) (the float 340))
          )
        (let ((v1-10 gp-0))
          (set! (-> v1-10 height) (the float 80))
          )
        (let ((v1-11 gp-0))
          (set! (-> v1-11 scale) 0.9)
          )
        (let ((s5-0 print-game-text))
          (format (clear *temp-string*) (lookup-text! *common-text* (text-id press-to-throw-held-objects) #f))
          (s5-0 *temp-string* gp-0 #f 44 (bucket-id hud-draw-hud-alpha))
          )
        )
      )
    (let ((t9-6 (-> (method-of-type mechblock carry) trans)))
      (if t9-6
          (t9-6)
          )
      )
    (let ((a2-3 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
      (add-debug-matrix #t (bucket-id debug) a2-3 (meters 4))
      )
    )
  :post (behavior ()
    (let ((t9-0 (-> (method-of-type mechblock carry) post)))
      (if t9-0
          ((the-as (function none) t9-0))
          )
      )
    (update-blink self)
    )
  )

(defstate fall (precur-bomb)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('carry-info)
       (-> self carry)
       )
      (('carry? 'pickup)
       #f
       )
      (('touched)
       (if (not (type? proc target))
           (go-virtual explode)
           )
       (let ((v0-0 (the-as object (-> proc entity))))
         (set! (-> self hit-something?) (the-as symbol v0-0))
         v0-0
         )
       )
      (else
        (precur-bomb-handler proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (when (logtest? (-> self root status) (collide-status touch-surface))
      (if (< 0.09 (* 0.0033333334 (the float (- (current-time) (the-as int (-> self collide-timer))))))
          (sound-play "pre-bomb-bounce")
          )
      (set! (-> self collide-timer) (the-as uint (current-time)))
      (vector-float*! (-> self root transv) (-> self root transv) 0.75)
      )
    (when (and (logtest? (-> self root status) (collide-status on-surface))
               (< 0.8 (-> self root surface-angle))
               (let ((v1-26 (-> self root transv)))
                 (< (sqrtf (+ (* (-> v1-26 x) (-> v1-26 x)) (* (-> v1-26 z) (-> v1-26 z)))) 2048.0)
                 )
               )
      (set! (-> self root transv quad) (the-as uint128 0))
      (set! (-> self root root-prim local-sphere w) (-> self carry backup-radius))
      (go-virtual idle)
      )
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (set! (-> gp-1 quad) (-> self root transv quad))
      (let ((f0-9 32768.0))
        (set! (-> gp-1 y) 0.0)
        (let* ((f0-11 (* (/ f0-9 (meters 5)) (vector-length gp-1)))
               (f30-0 (fmin 32768.0 f0-11))
               )
          (vector-normalize! gp-1 1.0)
          (vector-cross! gp-1 *up-vector* gp-1)
          (quaternion-vector-angle! (-> self spin-quat) gp-1 (* f30-0 (seconds-per-frame)))
          )
        )
      )
    (quaternion*! (-> self root quat) (-> self spin-quat) (-> self root quat))
    (if (< (/ (-> self root trans y) METER_LENGTH) 500.0)
        (go-virtual explode)
        )
    )
  :post (behavior ()
    (let ((t9-0 (-> (method-of-type mechblock fall) post)))
      (if t9-0
          ((the-as (function none) t9-0))
          )
      )
    (update-blink self)
    )
  )

(defstate explode (precur-bomb)
  :virtual #t
  :enter (behavior ()
    (sound-play "prec-bomb-xplo")
    (let ((gp-1 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-1 spawn-point quad) (-> self root trans quad))
      (quaternion-identity! (-> gp-1 spawn-quat))
      (set! (-> gp-1 radius) 40960.0)
      (set! (-> gp-1 scale) 1.0)
      (set! (-> gp-1 group) (-> *part-group-id-table* 1325))
      (set! (-> gp-1 collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> gp-1 damage) 2.0)
      (set! (-> gp-1 damage-scale) 1.0)
      (set! (-> gp-1 vehicle-damage-factor) 1.0)
      (set! (-> gp-1 vehicle-impulse-factor) 1.0)
      (set! (-> gp-1 ignore-proc) (process->handle #f))
      (when (type? (-> self root) collide-shape)
        (let ((v1-17 (-> self root root-prim)))
          (set! (-> v1-17 prim-core collide-as) (collide-spec))
          (set! (-> v1-17 prim-core collide-with) (collide-spec))
          )
        0
        )
      (logior! (-> self draw status) (draw-control-status no-draw))
      (transform-post)
      (explosion-spawn gp-1 self)
      )
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defskelgroup skel-precur-bomb precur-bomb precur-bomb-lod0-jg precur-bomb-idle-ja
              ((precur-bomb-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 2.7)
              )

(defbehavior precur-bomb-init-by-other precur-bomb ((arg0 vector) (arg1 symbol))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) precur-bomb-bounce-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec backgnd jak crate obstacle hit-by-others-list player-list tobot)
            )
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 11059.2)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s4-0 max-iteration-count) (the-as uint 4))
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> self root) s4-0)
    )
  (set! (-> self sound-id) (new-sound-id))
  (set! (-> self hint?) arg1)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-bomb" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (mem-copy! (the-as pointer (-> self origin)) (the-as pointer (-> self root trans)) 48)
  (set! (-> self collide-timer) (the-as uint 0))
  (set! (-> self bomb-timer) (the-as uint 0))
  (set! (-> self blink-timer) (the-as uint 0))
  (set! (-> self blink-rate) 600.0)
  (set! (-> self blink) #t)
  (set! (-> self default-emissive-color quad) (-> self draw color-emissive quad))
  (set! (-> self allow-drag?) #f)
  (set! (-> self reset-on-land?) #f)
  (let* ((v1-22 *game-info*)
         (a0-19 (+ (-> v1-22 attack-id) 1))
         )
    (set! (-> v1-22 attack-id) a0-19)
    (set! (-> self attack-id) a0-19)
    )
  (set! (-> self hit-something?) #f)
  (let ((gp-1 (new 'stack-no-clear 'vector)))
    (set! (-> gp-1 quad) (-> self root trans quad))
    (+! (-> gp-1 y) 12288.0)
    (let ((v1-28 (new 'process 'carry-info self 3 (new 'static 'vector :w 1.0) (new 'static 'vector :w 1.0) 0.0)))
      (set! (-> v1-28 max-distance) 16384.0)
      (set! (-> v1-28 min-pull) 2048.0)
      (set! (-> v1-28 max-pull) 6963.2)
      (set! (-> v1-28 carry-radius) 6144.0)
      (set! (-> v1-28 mode) (carry-mode mech-carry))
      (set! (-> v1-28 point quad) (-> gp-1 quad))
      (set! (-> v1-28 hold-trans quad) (-> (new 'static 'vector :y 12288.0 :w 1.0) quad))
      (set! (-> self carry) v1-28)
      )
    )
  (logior! (-> self mask) (process-mask enemy))
  (logior! (-> self focus-status) (focus-status hit))
  (go-virtual pre-spawn-up)
  )

(deftype precur-box (mechblock)
  ((taskman  handle)
   )
  )


(defskelgroup skel-precur-box precur-box precur-box-lod0-jg precur-box-idle-ja
              ((precur-box-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 4)
              )

(defstate idle (precur-box)
  :virtual #t
  :exit (behavior ()
    (if (handle->process (-> self taskman))
        (send-event (handle->process (-> self taskman)) 'place-hint)
        )
    (let ((t9-1 (-> (method-of-type mechblock idle) exit)))
      (if t9-1
          (t9-1)
          )
      )
    )
  :trans (behavior ()
    (if (and (handle->process (-> self taskman))
             (< (vector-vector-distance (-> self root trans) (target-pos 0)) 20480.0)
             )
        (send-event (handle->process (-> self taskman)) 'pickup-hint)
        )
    (let ((t9-3 (-> (method-of-type mechblock idle) trans)))
      (if t9-3
          (t9-3)
          )
      )
    )
  )

(defmethod init-from-entity! ((this precur-box) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec backgnd jak crate obstacle hit-by-others-list player-list tobot)
            )
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 1228.8 0.0 16384.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) 16384.0)
    (let ((v1-8 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-8 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-8 prim-core collide-with))
      )
    (set! (-> s4-0 max-iteration-count) (the-as uint 4))
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-box" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (mem-copy! (the-as pointer (-> this origin)) (the-as pointer (-> this root trans)) 48)
  (set! (-> this allow-drag?) #f)
  (set! (-> this reset-on-land?) #t)
  (let* ((v1-17 *game-info*)
         (a0-16 (+ (-> v1-17 attack-id) 1))
         )
    (set! (-> v1-17 attack-id) a0-16)
    (set! (-> this attack-id) a0-16)
    )
  (set! (-> this hit-something?) #f)
  (set! (-> this next-entity) (entity-actor-lookup (-> this entity) 'next-actor 0))
  (let ((v1-19 (new 'process 'carry-info this 3 (new 'static 'vector :w 1.0) (new 'static 'vector :y 1.0 :w 1.0) 0.0))
        )
    (set! (-> v1-19 max-distance) 24576.0)
    (set! (-> v1-19 min-pull) 2048.0)
    (set! (-> v1-19 max-pull) 6963.2)
    (set! (-> v1-19 carry-radius) 4096.0)
    (set! (-> v1-19 mode) (carry-mode mech-carry))
    (set! (-> this carry) v1-19)
    )
  (set! (-> this nav-mesh) (nav-mesh-from-res-tag (-> this entity) 'nav-mesh-actor 0))
  (if (not (-> this nav-mesh))
      (go process-drawable-art-error "no nav-mesh")
      )
  (add-process-drawable-to-nav-mesh (-> this nav-mesh) this #f)
  (let ((v1-28 (-> *game-info* sub-task-list (game-task-node precursor-tour-generator-trigger))))
    (set! (-> this taskman) (if (-> v1-28 manager)
                                (-> v1-28 manager manager)
                                (the-as handle #f)
                                )
          )
    )
  (go (method-of-object this idle))
  )

(defun-debug hint-mode->string ((arg0 precur-hint-mode))
  (case arg0
    (((precur-hint-mode normal))
     "normal"
     )
    (((precur-hint-mode teach-bomb))
     "teach-bomb"
     )
    (else
      "*unknown*"
      )
    )
  )

(deftype precur-bomb-spawner (process-drawable)
  ((proc-handle  handle)
   (hint-mode    precur-hint-mode)
   )
  (:state-methods
    idle
    )
  (:methods
    (spawn-bomb (_type_) handle)
    )
  )


(defskelgroup skel-precur-bomb-spawner precur-bomb-spawner precur-bomb-spawner-lod0-jg precur-bomb-spawner-idle-ja
              ((precur-bomb-spawner-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; WARN: Return type mismatch int vs handle.
(defmethod spawn-bomb ((this precur-bomb-spawner))
  (local-vars (v1-10 (pointer process)))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 quad) (-> this root trans quad))
    (format 0 "spawning bomb~%")
    (sound-play "prec-bomb-spawn")
    (format 0 "spawning bomb-post~%")
    (+! (-> s5-0 y) -10240.0)
    (cond
      ((= (-> this hint-mode) (precur-hint-mode teach-bomb))
       (let ((s4-1 (get-process *default-dead-pool* precur-bomb #x4000 1)))
         (set! v1-10 (when s4-1
                       (let ((t9-5 (method-of-type precur-bomb activate)))
                         (t9-5 (the-as precur-bomb s4-1) this "precur-bomb" (the-as pointer #x70004000))
                         )
                       (run-now-in-process s4-1 precur-bomb-init-by-other s5-0 #t)
                       (-> s4-1 ppointer)
                       )
               )
         )
       )
      (else
        (let ((s4-2 (get-process *default-dead-pool* precur-bomb #x4000 1)))
          (set! v1-10 (when s4-2
                        (let ((t9-8 (method-of-type precur-bomb activate)))
                          (t9-8 (the-as precur-bomb s4-2) this "precur-bomb" (the-as pointer #x70004000))
                          )
                        (run-now-in-process s4-2 precur-bomb-init-by-other s5-0 #f)
                        (-> s4-2 ppointer)
                        )
                )
          )
        )
      )
    )
  (the-as handle (when (-> v1-10 0)
                   (let ((v0-10 (ppointer->handle v1-10)))
                     (set! (-> this proc-handle) (the-as handle v0-10))
                     v0-10
                     )
                   )
          )
  )

(defstate idle (precur-bomb-spawner)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stop-hint)
       (let ((v0-0 (the-as object 1)))
         (set! (-> self hint-mode) (the-as precur-hint-mode v0-0))
         v0-0
         )
       )
      (('attack)
       (let ((s4-0 (the-as attack-info (-> block param 1))))
         (case (-> s4-0 mode)
           (('mech-punch 'crush)
            (let ((s3-0
                    (the-as attack-info (mem-copy! (the-as pointer (new 'stack-no-clear 'attack-info)) (the-as pointer s4-0) 168))
                    )
                  )
              (compute-intersect-info
                s3-0
                s4-0
                self
                (if (type? proc process-drawable)
                    proc
                    )
                (the-as touching-shapes-entry (-> block param 0))
                )
              (when (logtest? (-> s3-0 mask) (attack-mask intersection))
                (let ((a0-10 (handle->process (-> self proc-handle))))
                  (when a0-10
                    (if (and (-> a0-10 next-state) (= (-> a0-10 next-state name) 'ready))
                        (send-event a0-10 'fall)
                        )
                    )
                  )
                )
              )
            )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (spawn-bomb self)
    (ja-no-eval :group! precur-bomb-spawner-spawn-ja :num! (seek! max 2.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 2.0))
      )
    )
  :code (behavior ()
    (until #f
      (let ((v1-1 (handle->process (-> self proc-handle))))
        (cond
          (v1-1
            (when (not (or (and (-> v1-1 next-state) (= (-> v1-1 next-state name) 'idle))
                           (and (-> v1-1 next-state) (= (-> v1-1 next-state name) 'ready))
                           (and (-> v1-1 next-state) (= (-> v1-1 next-state name) 'spawn-up))
                           )
                       )
              (spawn-bomb self)
              (ja-no-eval :group! precur-bomb-spawner-spawn-ja :num! (seek! max 2.0) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! max 2.0))
                )
              )
            )
          (else
            (spawn-bomb self)
            (ja-no-eval :group! precur-bomb-spawner-spawn-ja :num! (seek! max 2.0) :frame-num 0.0)
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max 2.0))
              )
            )
          )
        )
      (spawn (-> self part) (-> self root trans))
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this precur-bomb-spawner) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-bomb-spawner" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (cond
    ((res-lump-struct (-> this entity) 'art-name structure)
     (set! (-> this hint-mode) (precur-hint-mode teach-bomb))
     0
     )
    (else
      (set! (-> this hint-mode) (precur-hint-mode normal))
      )
    )
  (set! (-> this proc-handle) (the-as handle #f))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1315) this))
  (go (method-of-object this idle))
  )

(set! (-> *lightning-spec-id-table* 38) (new 'static 'lightning-spec
                                          :name "laser-lightning-shock-target"
                                          :flags (lightning-spec-flags lsf2)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 120.0
                                          :texture (new 'static 'texture-id :index #x8f :page #x4)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 8601.6
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 1638.4
                                          :duration -1.0
                                          :sound #f
                                          )
      )

(defpart 4452
  :init-specs ((:texture (pal-lightning level-default-sprite))
    (:birth-func 'birth-func-set-quat)
    (:num 1.0)
    (:scale-x (meters 1))
    (:scale-y (meters 1))
    (:r 128.0 64.0)
    (:g 128.0 64.0)
    (:b 128.0 64.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 left-multiply-quat))
    )
  )

(define *laser-angles-array* (new 'static 'boxed-array :type float 36.40889 8192.0 16384.0 24576.0))

(defpartgroup group-placeholder-single-laser
  :id 1326
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 4453 :flags (sp7) :period (seconds 11) :length (seconds 0.017)))
  )

(defpart 4453
  :init-specs ((:texture (middot level-default-sprite))
    (:num 3.0)
    (:y (meters -0.3) (meters -0.3))
    (:scale-y (meters 0.1) (meters 0.05))
    (:r 80.0)
    (:g 200.0)
    (:b 128.0)
    (:a 128.0)
    (:omega (degrees 0.045))
    (:fade-a -0.21333334 -0.21333334)
    (:accel-y (meters 0) (meters -0.00083333335))
    (:timer (seconds 2))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:func 'sparticle-motion-blur)
    (:rotate-x (degrees 90))
    )
  )

(deftype precur-laser-beam (process-drawable)
  ((laser-dir          vector      :inline)
   (attack-id          uint32)
   (org-laser-quat     quaternion  :inline)
   (on-duration        float)
   (off-duration       float)
   (current-angle      int8)
   (last-attack-time   uint32)
   (counter            uint8)
   (sound-id           sound-id)
   (actor-group        (pointer actor-group))
   (actor-group-count  int32)
   )
  (:state-methods
    active
    telegraph
    hide
    dormant
    )
  (:methods
    (fire-beam (_type_ vector vector) none)
    (fire-beam0 (_type_ vector vector) none)
    )
  )


(defun elec-mech ((arg0 vector) (arg1 uint))
  (format 0 "~d~%" arg1)
  (send-event
    *target*
    'shove
    #f
    (static-attack-info
      :mask (vehicle-impulse-factor)
      ((id arg1)
       (damage 10.0)
       (vehicle-damage-factor 1.0)
       (vehicle-impulse-factor 1.0)
       (vector arg0)
       (shove-back (meters 3))
       (mode 'shock)
       (shove-up (meters 1))
       )
      )
    )
  (send-event
    *target*
    'attack
    #f
    (static-attack-info
      :mask (vehicle-impulse-factor)
      ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'shock))
      )
    )
  (spawn-mech-shock-effect)
  (none)
  )

(defmethod fire-beam ((this precur-laser-beam) (arg0 vector) (arg1 vector))
  (local-vars (sv-560 collide-query) (sv-564 float))
  (set! sv-560 (new 'stack-no-clear 'collide-query))
  (set! sv-564 83968.0)
  (set! (-> sv-560 start-pos quad) (-> arg0 quad))
  (vector-normalize-copy! arg1 arg1 sv-564)
  (vector-normalize-copy! (-> sv-560 move-dist) arg1 sv-564)
  (let ((v1-5 sv-560))
    (set! (-> v1-5 radius) 40.96)
    (set! (-> v1-5 collide-with) (collide-spec backgnd))
    (set! (-> v1-5 ignore-process0) #f)
    (set! (-> v1-5 ignore-process1) #f)
    (set! (-> v1-5 ignore-pat)
          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
          )
    (set! (-> v1-5 action-mask) (collide-action solid))
    )
  (let ((f0-4 (fill-and-probe-using-line-sphere *collide-cache* sv-560)))
    (cond
      ((>= f0-4 0.0)
       (vector-float*! (-> sv-560 move-dist) (-> sv-560 move-dist) f0-4)
       (set! sv-564 (* sv-564 f0-4))
       )
      (else
        (set! (-> sv-560 best-other-tri collide-ptr) #f)
        )
      )
    )
  (set! (-> *part-id-table* 4452 init-specs 4 initial-valuef) sv-564)
  (draw-beam (-> *part-id-table* 4452) arg0 arg1 #t)
  (let ((v1-19 sv-560))
    (set! (-> v1-19 radius) 40.96)
    (set! (-> v1-19 collide-with) (collide-spec jak enemy player-list))
    (set! (-> v1-19 ignore-process0) #f)
    (set! (-> v1-19 ignore-process1) #f)
    (set! (-> v1-19 ignore-pat)
          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
          )
    (set! (-> v1-19 action-mask) (collide-action solid))
    )
  (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* sv-560))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (vector-! s3-0 (target-pos 0) arg0)
    (set! (-> s3-0 y) 0.0)
    (vector-normalize! s3-0 1.0)
    (when (and (>= f30-0 0.0)
               (>= (the-as uint (- (current-time) (the-as int (-> this last-attack-time)))) (the-as uint 600))
               )
      (elec-mech s3-0 (-> this attack-id))
      (set! (-> this last-attack-time) (the-as uint (current-time)))
      )
    )
  (vector-float*! arg1 arg1 -1.0)
  (vector-normalize-copy! (-> sv-560 move-dist) arg1 sv-564)
  (let ((f30-1 (fill-and-probe-using-line-sphere *collide-cache* sv-560))
        (s3-1 (new 'stack-no-clear 'vector))
        )
    (vector-! s3-1 (target-pos 0) arg0)
    (set! (-> s3-1 y) 0.0)
    (vector-normalize! s3-1 1.0)
    (when (and (>= f30-1 0.0)
               (>= (the-as uint (- (current-time) (the-as int (-> this last-attack-time)))) (the-as uint 600))
               )
      (format 0 "attack-time: ~d~%" (-> this last-attack-time))
      (elec-mech s3-1 (-> this attack-id))
      (set! (-> this last-attack-time) (the-as uint (current-time)))
      )
    )
  (draw-beam (-> *part-id-table* 4452) arg0 arg1 #t)
  (none)
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defmethod fire-beam0 ((this precur-laser-beam) (arg0 vector) (arg1 vector))
  "Unused."
  (local-vars (sv-560 collide-query) (sv-564 float))
  (set! sv-560 (new 'stack-no-clear 'collide-query))
  (set! sv-564 83968.0)
  (set! (-> sv-560 start-pos quad) (-> arg0 quad))
  (vector-float*! (-> sv-560 move-dist) arg1 sv-564)
  (let ((v1-7 sv-560))
    (set! (-> v1-7 radius) 40.96)
    (set! (-> v1-7 collide-with) (collide-spec backgnd))
    (set! (-> v1-7 ignore-process0) #f)
    (set! (-> v1-7 ignore-process1) #f)
    (set! (-> v1-7 ignore-pat)
          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
          )
    (set! (-> v1-7 action-mask) (collide-action solid))
    )
  (let ((f0-3 (fill-and-probe-using-line-sphere *collide-cache* sv-560)))
    (cond
      ((>= f0-3 0.0)
       (vector-float*! (-> sv-560 move-dist) (-> sv-560 move-dist) f0-3)
       (set! sv-564 (* sv-564 f0-3))
       )
      (else
        (set! (-> sv-560 best-other-tri collide-ptr) #f)
        )
      )
    )
  (set! (-> *part-id-table* 4452 init-specs 4 initial-valuef) sv-564)
  (let ((s3-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'matrix))
        )
    (vector+float*! s3-0 arg0 arg1 sv-564)
    (matrix-f-compose s4-0 arg1)
    (set! (-> s4-0 trans quad) (-> s3-0 quad))
    (if (logtest? (-> *part-group-id-table* 1326 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to *entity-pool*
          :group (-> *part-group-id-table* 1326)
          :mat-joint s4-0
          )
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1326) :mat-joint s4-0)
        )
    (vector+float*! s3-0 arg0 arg1 (- sv-564))
    (matrix-f-compose s4-0 (vector-float*! (new 'stack-no-clear 'vector) arg1 -1.0))
    (set! (-> s4-0 trans quad) (-> s3-0 quad))
    (if (logtest? (-> *part-group-id-table* 1326 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to *entity-pool*
          :group (-> *part-group-id-table* 1326)
          :mat-joint s4-0
          )
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1326) :mat-joint s4-0)
        )
    )
  (none)
  )

(defstate telegraph (precur-laser-beam)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (vector-y-quaternion! (-> self laser-dir) (-> self root quat))
    (cond
      ((= (-> self counter) 2)
       (set! (-> self counter) (the-as uint 0))
       (set! (-> self on-duration) 690.0)
       )
      (else
        (+! (-> self counter) 1)
        (set! (-> self on-duration) 60.0)
        )
      )
    )
  :code (behavior ()
    (while (not (time-elapsed? (-> self state-time) (the int (-> self off-duration))))
      (when (not (time-elapsed? (-> self state-time) (seconds 0.1)))
        )
      (suspend)
      )
    (go-virtual active)
    )
  )

(defstate dormant (precur-laser-beam)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('go-active)
       (go-virtual active)
       )
      )
    )
  :code (behavior ()
    (local-vars (sv-16 res-tag))
    (set! sv-16 (new 'static 'res-tag))
    (let ((gp-0 (res-lump-data (-> self entity) 'actor-groups pointer :tag-ptr (& sv-16))))
      (cond
        ((and gp-0 (nonzero? (-> sv-16 elt-count)))
         (suspend-for (seconds 1)
           )
         (set! (-> self actor-group-count) (the-as int (-> sv-16 elt-count)))
         (set! (-> self actor-group) (the-as (pointer actor-group) gp-0))
         (dotimes (gp-1 (length (-> self actor-group 0)))
           (let* ((v1-15 (-> self actor-group 0 data gp-1 actor))
                  (a0-6 (if v1-15
                            (-> v1-15 extra process)
                            )
                        )
                  )
             (if a0-6
                 (send-event a0-6 'go-active)
                 )
             )
           )
         )
        (else
          (format #t "entity missing actor-group!~%")
          (until #f
            (suspend)
            )
          #f
          )
        )
      )
    )
  )

(defstate active (precur-laser-beam)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (sound-stop (-> self sound-id))
    )
  :trans (behavior ()
    (sound-play "arc-bar" :id (-> self sound-id) :position (-> self root trans))
    )
  :code (behavior ()
    (while (not (time-elapsed? (-> self state-time) (the int (-> self on-duration))))
      (vector-y-quaternion! (-> self laser-dir) (-> self root quat))
      (if (>= (the-as uint (- (current-time) (the-as int (-> self last-attack-time)))) (the-as uint 600))
          (fire-beam self (-> self root trans) (-> self laser-dir))
          )
      (suspend)
      )
    (go-virtual hide)
    )
  :post ja-post
  )

(defstate hide (precur-laser-beam)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (cond
      ((< (-> self current-angle) (+ (length *laser-angles-array*) -1))
       (+! (-> self current-angle) 1)
       )
      (else
        (set! (-> self current-angle) 0)
        0
        )
      )
    (quaternion-rotate-local-x!
      (-> self root quat)
      (-> self org-laser-quat)
      (-> *laser-angles-array* (-> self current-angle))
      )
    )
  :code (behavior ()
    (while (not (time-elapsed? (-> self state-time) (the int (-> self off-duration))))
      (suspend)
      )
    (go-virtual telegraph)
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this precur-laser-beam) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (set! (-> this on-duration) 60.0)
  (set! (-> this off-duration) 15.0)
  (set! (-> this last-attack-time) (the-as uint 0))
  (set! (-> this counter) (the-as uint 0))
  (set! (-> this sound-id) (new-sound-id))
  (quaternion-copy! (-> this org-laser-quat) (-> this root quat))
  (let* ((v1-4 *game-info*)
         (a0-5 (+ (-> v1-4 attack-id) 1))
         )
    (set! (-> v1-4 attack-id) a0-5)
    (set! (-> this attack-id) a0-5)
    )
  (set! (-> this current-angle) 0)
  (quaternion-rotate-local-x!
    (-> this root quat)
    (-> this org-laser-quat)
    (-> *laser-angles-array* (-> this current-angle))
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (go (method-of-object this dormant))
  )

(defpartgroup group-precura-engulfing-death
  :id 1327
  :bounds (static-bspherem 0 0 0 5)
  :parts ((sp-item 4454 :flags (sp7)))
  )

(defpart 4454
  :init-specs ((:texture (explosion-nebula level-default-sprite))
    (:birth-func 'birth-func-texture-group)
    (:num 20.0 5.0)
    (:x (meters -5) (meters 10))
    (:z (meters -5) (meters 10))
    (:scale-x (meters 5) (meters 10))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 240.0 15.0)
    (:g 200.0 16.0)
    (:b 160.0 16.0)
    (:a 32.0 32.0)
    (:scalevel-x (meters 0.20833333))
    (:rotvel-z (degrees -0.4) (degrees 0.8))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -2.1333334 -1.0666667)
    (:fade-g -4.266667 -2.1333334)
    (:fade-b -5.3333335)
    (:timer (seconds 0.535) (seconds 0.265))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata :data (new 'static 'boxed-array :type int32 40 1 0 #x400000 #x400000 #x400700))
    (:next-time (seconds 0.1) (seconds 0.03))
    (:next-launcher 4455)
    )
  )

(defpart 4455
  :init-specs ((:b 0.0)
    (:fade-r 0.0)
    (:fade-g 0.0)
    (:fade-b 0.0)
    (:fade-a -0.4 -0.2)
    (:next-time (seconds 0.017) (seconds 0.03))
    (:next-launcher 4456)
    )
  )

(defpart 4456
  :init-specs ((:fade-r -0.125) (:fade-g 0.4) (:fade-b 0.4))
  )

(deftype task-manager-precura (task-manager)
  ((part-doom      sparticle-launch-control)
   (doom-time      time-frame)
   (extra-time     time-frame)
   (doom-counter   uint8)
   (faded          uint8)
   (movie-played?  symbol)
   )
  )


(define *precura-continue-sphere* (new 'static 'sphere :x 684753.7 :y 2241180.5 :z -334490.84 :r 122880.0))

(define *precura-continue2-sphere* (new 'static 'sphere :x 733905.7 :y 2241180.5 :z -334490.84 :r 40960.0))

(defmethod taskman-event-handler ((this task-manager-precura) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('extra-time)
     (let* ((v1-1 (-> arg3 param 0))
            (v0-0 (the-as object (+ (-> this extra-time) (the-as time-frame v1-1))))
            )
       (set! (-> this extra-time) (the-as time-frame v0-0))
       v0-0
       )
     )
    (else
      ((method-of-type task-manager taskman-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(define *pca-sph1* (new 'static 'sphere :x 261120.0 :y 2199552.0 :z -181452.8 :r 31129.6))

(define *pca-sph2* (new 'static 'sphere :x 261120.0 :y 2199552.0 :z 115916.8 :r 31129.6))

(defmethod task-manager-method-26 ((this task-manager-precura))
  (when *target*
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> (target-pos 0) quad))
      (let ((s3-0 (new 'stack-no-clear 'vector)))
        (when (and (>= (-> s4-0 z) (-> *pca-sph1* z)) (>= (-> *pca-sph2* z) (-> s4-0 z)))
          (set! (-> s3-0 quad) (-> *pca-sph1* quad))
          (set! (-> s4-0 z) 0.0)
          (set! (-> s3-0 z) 0.0)
          (when (< (vector-vector-distance s4-0 s3-0) (-> *pca-sph1* r))
            (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) s3-0 s4-0)))
              (set! (-> s5-1 y) 0.0)
              (set! (-> s5-1 z) 0.0)
              (set! (-> s5-1 x) (sign (-> s5-1 x)))
              (send-event
                *target*
                'attack
                #f
                (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                                    (damage 2.0)
                                                                    (vehicle-damage-factor 1.0)
                                                                    (vehicle-impulse-factor 1.0)
                                                                    (mode 'shock-no-interrupt)
                                                                    (vector s5-1)
                                                                    )
                                    )
                )
              )
            )
          )
        )
      )
    )
  (* 0.0033333334 (the float (- (-> this time-limit) (- (current-time) (-> this start-time)))))
  (if (and (not (logtest? (-> this info mask) (task-manager-mask time-limit)))
           (-> this movie-played?)
           (not (movie?))
           )
      (logior! (-> this info mask) (task-manager-mask time-limit))
      )
  (if (and (movie?) (not (-> this movie-played?)))
      (set! (-> this movie-played?) #t)
      )
  (let ((f0-14 (vector-vector-distance-squared (target-pos 0) *precura-continue2-sphere*))
        (f1-5 (-> *precura-continue2-sphere* r))
        )
    (if (and (< f0-14 (* f1-5 f1-5)) (not (task-node-closed? (game-task-node precursor-destroy-ship-escape))))
        (task-node-close! (game-task-node precursor-destroy-ship-escape) 'event)
        )
    )
  (when (and (not (time-elapsed? (-> this start-time) (seconds 1)))
             (< (seconds 150) (-> this time-limit))
             (let ((f0-15 (vector-vector-distance-squared (target-pos 0) *precura-continue-sphere*))
                   (f1-8 (-> *precura-continue-sphere* r))
                   )
               (< f0-15 (* f1-8 f1-8))
               )
             )
    (set! (-> this time-limit) (seconds 150))
    (send-event (process-by-name "dp-bipedal-104" *active-pool*) 'die-fast)
    (send-event (process-by-name "dp-bipedal-105" *active-pool*) 'die-fast)
    (send-event (process-by-name "dp-bipedal-106" *active-pool*) 'die-fast)
    (send-event (process-by-name "neo-wasp-9" *active-pool*) 'die-fast)
    (send-event (process-by-name "neo-wasp-10" *active-pool*) 'die-fast)
    (send-event (process-by-name "neo-wasp-11" *active-pool*) 'die-fast)
    (send-event (process-by-name "neo-wasp-15" *active-pool*) 'die-fast)
    )
  0
  (call-parent-method this)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod hud-timer-handler ((this task-manager-precura))
  (with-pp
    (when (or (> (-> this extra-time) 0) (and *target* (focus-test? *target* dead)))
      (let ((v1-7 (- (current-time) (-> pp clock old-frame-counter))))
        (if (and (> (-> this extra-time) 0) (< (-> this extra-time) v1-7))
            (set! v1-7 (-> this extra-time))
            )
        (if (> (-> this extra-time) 0)
            (set! (-> this extra-time) (- (-> this extra-time) v1-7))
            )
        (+! (-> this time-limit) v1-7)
        )
      )
    (let ((v1-10 (- (-> this time-limit) (- (current-time) (-> this start-time)))))
      (cond
        ((and (>= (seconds 0.015) v1-10) (not (-> this movie-played?)) (not (movie?)))
         (process-spawn scene-player :init scene-player-init "precursor-destroy-ship-lose" #t #f :name "scene-player")
         (logclear! (-> this info mask) (task-manager-mask time-limit))
         )
        ((not (movie?))
         (call-parent-method this)
         )
        )
      )
    (none)
    )
  )

(defmethod relocate ((this task-manager-precura) (offset int))
  (if (nonzero? (-> this part-doom))
      (&+! (-> this part-doom) offset)
      )
  (call-parent-method this offset)
  )

(defmethod task-manager-method-25 ((this task-manager-precura))
  (if (nonzero? (-> this part-doom))
      (kill-particles (-> this part-doom))
      )
  (disable *screen-filter*)
  (call-parent-method this)
  (none)
  )

(defmethod init! ((this task-manager-precura))
  (set! (-> this part-doom) (create-launch-control (-> *part-group-id-table* 1327) this))
  (set-time! (-> this doom-time))
  (set! (-> this doom-counter) (the-as uint 0))
  (set! (-> this faded) (the-as uint 0))
  (set! (-> this movie-played?) #f)
  (set! (-> this extra-time) 0)
  (call-parent-method this)
  (none)
  )

;; WARN: Return type mismatch int vs object.
(defun process-drawable-shock-wave-effect ((arg0 process-drawable)
                                  (arg1 lightning-spec)
                                  (arg2 (function lightning-tracker none))
                                  (arg3 sparticle-launcher)
                                  (arg4 vector)
                                  (arg5 int)
                                  (arg6 float)
                                  )
  (local-vars
    (sv-624 (pointer lightning-tracker))
    (sv-640 float)
    (sv-656 matrix)
    (sv-672 collide-query)
    (sv-688 symbol)
    (sv-704 vector)
    (sv-720 int)
    (sv-736 process)
    )
  (set! sv-640 arg6)
  (let ((s5-0 *lightning-probe-vars*))
    (set! sv-656 (new 'stack-no-clear 'matrix))
    (set! sv-672 (new 'stack-no-clear 'collide-query))
    (set! sv-688 (the-as symbol #f))
    (set! (-> sv-672 start-pos quad) (-> arg4 quad))
    (set! sv-704 (-> sv-672 move-dist))
    (set! (-> sv-704 x) (rand-vu-float-range 0.0 65536.0))
    (set! (-> sv-704 y) (rand-vu-float-range 0.0 65536.0))
    (set! (-> sv-704 z) (rand-vu-float-range 0.0 65536.0))
    (set! (-> sv-704 w) 1.0)
    (matrix-rotate-zyx! sv-656 (-> sv-672 move-dist))
    (set! sv-720 6)
    (while (nonzero? sv-720)
      (set! sv-720 (+ sv-720 -1))
      (vector-rotate*! (-> sv-672 move-dist) (-> s5-0 probe-dirs sv-720) sv-656)
      (vector-normalize! (-> sv-672 move-dist) sv-640)
      (let ((v1-18 sv-672))
        (set! (-> v1-18 radius) 409.6)
        (set! (-> v1-18 collide-with) (collide-spec backgnd crate obstacle hit-by-others-list pusher))
        (set! (-> v1-18 ignore-process0) arg0)
        (set! (-> v1-18 ignore-process1) #f)
        (set! (-> v1-18 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> v1-18 action-mask) (collide-action solid))
        )
      (when (>= (fill-and-probe-using-line-sphere *collide-cache* sv-672) 0.0)
        (set-time! (-> s5-0 last-valid-time))
        (set! (-> s5-0 end-pos quad) (-> sv-672 best-other-tri intersect quad))
        (when (< 8192.0 (vector-vector-distance (-> s5-0 end-pos) (-> sv-672 start-pos)))
          (set! sv-688 #t)
          (goto cfg-7)
          )
        )
      )
    (label cfg-7)
    (when sv-688
      (set! sv-736 (get-process *default-dead-pool* lightning-tracker #x4000 0))
      (set! sv-624
            (the-as
              (pointer lightning-tracker)
              (when sv-736
                (let ((t9-9 (method-of-type lightning-tracker activate)))
                  (t9-9 (the-as lightning-tracker sv-736) arg0 "lightning-tracker" (the-as pointer #x70004000))
                  )
                (run-now-in-process sv-736 lightning-tracker-init arg1 arg5 arg2 arg0 arg4 (-> s5-0 end-pos))
                (-> sv-736 ppointer)
                )
              )
            )
      (when sv-624
        (set! (-> sv-624 0 user-time 0) 0)
        (when arg3
          (let ((v1-46 (get-field-spec-by-id arg3 (sp-field-id spt-timer))))
            (if v1-46
                (set! (-> v1-46 initial-valuef) (the-as float (-> sv-624 0 duration)))
                )
            )
          (let ((t9-12 sp-launch-particles-var)
                (a0-26 *sp-particle-system-2d*)
                (a2-5 *launch-matrix*)
                )
            (set! (-> a2-5 trans quad) (-> s5-0 end-pos quad))
            (t9-12 a0-26 arg3 a2-5 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        )
      )
    )
  0
  )

(defpartgroup group-placeholder-single-shockwave
  :id 1328
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 4457 :flags (sp7)))
  )

(defpart 4457
  :init-specs ((:texture (middot level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 5))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 0.0)
    (:b 0.0)
    (:a 128.0)
    (:timer (seconds 0.005))
    (:flags ())
    )
  )

(defskelgroup skel-precur-spot-ring gun gun-dark-2-ring-lod0-jg gun-dark-2-ring-idle-ja
              ((gun-dark-2-ring-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0.5 84)
              :longest-edge (meters 80)
              :shadow gun-dark-2-ring-shadow-mg
              )

(deftype precur-spot-shadow-effect (process-drawable)
  ((focal-length     float)
   (near-clip        float)
   (far-clip         float)
   (color            rgba)
   (pre-flicker-pos  vector               :inline)
   (jmod-outer       joint-mod-add-local  :inline)
   (jmod-inner       joint-mod-add-local  :inline)
   )
  (:state-methods
    idle
    inactive
    )
  (:methods
    (set-inner-jmod-scale (_type_ vector) none)
    (set-outer-jmod-scale (_type_ vector) none)
    )
  )


;; WARN: Return type mismatch vector vs none.
(defmethod set-inner-jmod-scale ((this precur-spot-shadow-effect) (arg0 vector))
  (set! (-> this jmod-inner transform scale quad) (-> arg0 quad))
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod set-outer-jmod-scale ((this precur-spot-shadow-effect) (arg0 vector))
  (set! (-> this jmod-outer transform scale quad) (-> arg0 quad))
  (none)
  )

(defbehavior precur-spot-shadow-effect-init-by-other precur-spot-shadow-effect ((arg0 vector) (arg1 vector))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-copy! (-> self root quat) (the-as quaternion arg1))
  (set! (-> self pre-flicker-pos quad) (-> self root trans quad))
  (set! (-> self level) (-> *level* level-default))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-spot-ring" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init (-> self jmod-inner) self (the-as uint 4) (joint-mod-base-flags attached scale))
  (init (-> self jmod-outer) self (the-as uint 3) (joint-mod-base-flags attached scale))
  (set! (-> self focal-length) 409600.0)
  (set! (-> self near-clip) 0.0)
  (set! (-> self far-clip) 122880.0)
  (set! (-> self color) (new 'static 'rgba :r #xf0 :g #xf0 :a #x80))
  (cond
    ((-> self draw shadow)
     (set! (-> self draw shadow-ctrl) (new
                                        'process
                                        'shadow-control
                                        0.0
                                        0.0
                                        614400.0
                                        (the-as vector #f)
                                        (shadow-flags shdf02 shdf03 shdf04 disable-draw)
                                        245760.0
                                        )
           )
     (set! (-> self draw shadow-ctrl settings shadow-type) 1)
     (set! (-> self draw shadow-ctrl settings flags) (shadow-flags disable-fade shdf03 shdf04 shdf07))
     (logclear! (-> self draw status) (draw-control-status no-draw))
     )
    (else
      (go process-drawable-art-error "Shadow error (no self draw shadow)")
      )
    )
  (go-virtual idle)
  )

(defbehavior precur-spot-shadow-effect-handler precur-spot-shadow-effect ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('on)
     (go-virtual idle)
     )
    (('off)
     (go-virtual inactive)
     )
    )
  )

(defstate idle (precur-spot-shadow-effect)
  :virtual #t
  :event precur-spot-shadow-effect-handler
  :enter (behavior ()
    (setup-masks (-> self draw) 0 1)
    (let ((v1-3 (-> self draw shadow-ctrl)))
      (logclear! (-> v1-3 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :trans (behavior ()
    (shadow-control-method-14
      (-> self draw shadow-ctrl)
      (-> self root trans)
      (vector-negate! (new 'stack-no-clear 'vector) (-> self node-list data 3 bone transform uvec))
      (-> self focal-length)
      (-> self near-clip)
      (-> self far-clip)
      )
    (persist-with-delay
      *setting-control*
      'spotlight-color
      (seconds 0.1)
      'spotlight-color
      #f
      0.0
      (the-as int (-> self color))
      )
    )
  :code sleep-code
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 x) (+ -1024.0 (* 4096.0 (* 0.5 (rand-vu)))))
      (set! (-> gp-0 y) 0.0)
      (set! (-> gp-0 z) (+ -1024.0 (* 4096.0 (* 0.5 (rand-vu)))))
      (set! (-> gp-0 w) 1.0)
      (vector+! (-> self root trans) (-> self root trans) gp-0)
      )
    (+! (-> self root trans y) -8192.0)
    (ja-post)
    )
  )

(defstate inactive (precur-spot-shadow-effect)
  :virtual #t
  :event precur-spot-shadow-effect-handler
  :enter (behavior ()
    (setup-masks (-> self draw) 0 1)
    (let ((v1-3 (-> self draw shadow-ctrl)))
      (logior! (-> v1-3 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :trans (behavior ()
    '()
    )
  :code sleep-code
  )

(deftype precur-path (process-drawable)
  ((pathb                path-control)
   (last-attack-time     uint32)
   (attack-id            uint32)
   (bolt                 lightning-bolt)
   (shock-part-time      uint32)
   (shock-shadow-handle  handle)
   )
  (:state-methods
    idle
    dormant
    )
  (:methods
    (probe-for-player-collision (_type_ vector vector) none)
    (draw-lightning (_type_ vector vector) none)
    )
  )


;; WARN: Return type mismatch time-frame vs none.
(defmethod probe-for-player-collision ((this precur-path) (arg0 vector) (arg1 vector))
  (local-vars (sv-576 collide-query) (sv-580 vector) (sv-584 float))
  (set! sv-576 (new 'stack-no-clear 'collide-query))
  (set! sv-580 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
  (set! sv-584 (vector-vector-distance arg0 arg1))
  (set! (-> sv-576 start-pos quad) (-> arg0 quad))
  (vector-normalize-copy! (-> sv-576 move-dist) sv-580 sv-584)
  (let ((v1-5 sv-576))
    (set! (-> v1-5 radius) 40.96)
    (set! (-> v1-5 collide-with) (collide-spec jak enemy player-list))
    (set! (-> v1-5 ignore-process0) #f)
    (set! (-> v1-5 ignore-process1) #f)
    (set! (-> v1-5 ignore-pat)
          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
          )
    (set! (-> v1-5 action-mask) (collide-action solid))
    )
  (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* sv-576))
        (s5-1 (new 'stack-no-clear 'vector))
        )
    (set! (-> s5-1 y) 0.0)
    (vector-normalize! s5-1 1.0)
    (when (and (>= f30-0 0.0)
               (>= (the-as uint (- (current-time) (the-as int (-> this last-attack-time)))) (the-as uint 600))
               )
      (elec-mech s5-1 (-> this attack-id))
      (set! (-> this last-attack-time) (the-as uint (current-time)))
      )
    )
  (none)
  )

(set! (-> *lightning-spec-id-table* 39) (new 'static 'lightning-spec
                                          :name "lightning-shock-wave"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 15.0
                                          :texture (new 'static 'texture-id :index #x3f :page #x4)
                                          :reduction 0.42
                                          :num-points 8
                                          :box-size 8192.0
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 819.2
                                          :duration 90.0
                                          :sound (static-sound-spec "shock" :group 0)
                                          )
      )

(if (or (zero? *precur-tour-lightning*) (!= loading-level global))
    (set! *precur-tour-lightning* (new 'loading-level 'lightning-appearance))
    )

(set! (-> *precur-tour-lightning* base-alpha) 1.0)

(set! (-> *precur-tour-lightning* tex-id) (the-as uint #x403f00))

(set! (-> *precur-tour-lightning* blend-mode) (the-as uint 1))

(set! (-> *precur-tour-lightning* alpha-1-curve) *curve-linear-down*)

(set! (-> *precur-tour-lightning* alpha-1-mode) (the-as uint 0))

(set! (-> *precur-tour-lightning* alpha-1-repeat-dist) 262144.0)

(set! (-> *precur-tour-lightning* alpha-2-curve) #f)

(set! (-> *precur-tour-lightning* alpha-2-mode) (the-as uint 3))

(set! (-> *precur-tour-lightning* alpha-2-repeat-dist) 4096.0)

(set! (-> *precur-tour-lightning* width-curve) *curve-linear-down*)

(set! (-> *precur-tour-lightning* width-mode) (the-as uint 3))

(set! (-> *precur-tour-lightning* width-repeat-dist) 4096.0)

(set! (-> *precur-tour-lightning* uv-repeat-dist) 28672.0)

(set! (-> *precur-tour-lightning* regenerate-time-start) (seconds 0.085))

(set! (-> *precur-tour-lightning* regenerate-time-end) (seconds 0.167))

(set! (-> *precur-tour-lightning* width-range-start) 4096.0)

(set! (-> *precur-tour-lightning* width-range-end) 4096.0)

(set! (-> *precur-tour-lightning* fade-time) (seconds 0.3))

(set! (-> *precur-tour-lightning* uv-shift?) #t)

(set! (-> *precur-tour-lightning* uv-shift-speed) (seconds -0.5))

(set! (-> *precur-tour-lightning* use-sprite-bucket?) #t)

(set! (-> *precur-tour-lightning* use-accurate-interp?) #t)

(defmethod draw-lightning ((this precur-path) (arg0 vector) (arg1 vector))
  (let ((gp-0 (-> this bolt)))
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      0.0
      (when arg0
        (let ((f0-1 (vector-vector-distance arg0 arg1)))
          (vector+! s3-0 arg0 arg1)
          (vector-float*! s3-0 s3-0 0.5)
          (when (handle->process (-> this shock-shadow-handle))
            (let ((a0-8 (the-as precur-spot-shadow-effect (-> this shock-shadow-handle process 0)))
                  (a1-6 (new 'stack-no-clear 'vector))
                  )
              (set! (-> a0-8 root trans quad) (-> s3-0 quad))
              (set-vector! a1-6 (* 0.0001319679 f0-1) 0.4 0.4 1.0)
              (set-outer-jmod-scale a0-8 a1-6)
              )
            )
          )
        )
      )
    (set! (-> gp-0 inner-point-travel-time) (seconds 0.25))
    (set! (-> gp-0 snap-inner-points?) #t)
    (set! (-> gp-0 fractal-reduction) 0.6)
    (set! (-> gp-0 generate-mode) (the-as uint 1))
    (set! (-> gp-0 appearance) *precur-tour-lightning*)
    (set! (-> gp-0 num-active-spans) 2)
    (set! (-> gp-0 spans-internal data 0 num-inner-points) 30)
    (set! (-> gp-0 spans data 0 inner-random-offset-size) 10240.0)
    (set! (-> gp-0 spans data 1 inner-random-offset-size) 10240.0)
    (when arg0
      (set! (-> gp-0 span-pts-start data 0 quad) (-> arg0 quad))
      (+! (-> gp-0 span-pts-start data 0 y) 4096.0)
      )
    (when arg1
      (set! (-> gp-0 span-pts-start data 1 quad) (-> arg1 quad))
      (+! (-> gp-0 span-pts-start data 1 y) 4096.0)
      )
    (set! (-> gp-0 spans-internal data 1 num-inner-points) 0)
    (lightning-bolt-method-11 gp-0)
    (lightning-bolt-method-12 gp-0)
    )
  (none)
  )

(defstate idle (precur-path)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (lightning-bolt-method-13 (-> self bolt) 1)
    )
  :exit (behavior ()
    (set-precura-laser-light! 0.0 (* 8.0 (seconds-per-frame)) 0)
    (set-precura-laser-light! 0.0 (* 8.0 (seconds-per-frame)) 1)
    )
  :trans (behavior ()
    (when *target*
      (if (focus-test? *target* grabbed)
          (go-virtual dormant)
          )
      )
    (if (nonzero? (-> self path))
        (debug-draw (-> self path))
        )
    (if (nonzero? (-> self pathb))
        (debug-draw (-> self pathb))
        )
    (let ((f30-0 (* 0.0006666667 (the float (- (current-time) (-> self state-time)))))
          (s5-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (if (< 0.9 f30-0)
          (go-virtual dormant)
          )
      (set-precura-laser-light! (- 1.0 f30-0) 0.0 0)
      (set-precura-laser-light! f30-0 0.0 1)
      (get-point-at-percent-along-path! (-> self path) s5-0 f30-0 'interp)
      (get-point-at-percent-along-path! (-> self pathb) gp-0 f30-0 'interp)
      (probe-for-player-collision self s5-0 gp-0)
      (draw-lightning self s5-0 gp-0)
      (process-drawable-shock-wave-effect
        self
        (-> *lightning-spec-id-table* 39)
        lightning-probe-callback
        (-> *part-id-table* 160)
        s5-0
        0
        40960.0
        )
      (process-drawable-shock-wave-effect
        self
        (-> *lightning-spec-id-table* 39)
        lightning-probe-callback
        (-> *part-id-table* 160)
        gp-0
        0
        40960.0
        )
      (when (>= (the-as uint (- (current-time) (the-as int (-> self shock-part-time)))) 0)
        (spawn (-> self part) s5-0)
        (spawn (-> self part) gp-0)
        (set! (-> self shock-part-time) (the-as uint (current-time)))
        )
      )
    (process-drawable-shock-effect
      self
      (-> *lightning-spec-id-table* 1)
      lightning-probe-callback
      (-> *part-id-table* 160)
      0
      0
      40960.0
      )
    (if (time-elapsed? (-> self state-time) (seconds 5))
        (go-virtual dormant)
        )
    )
  :code sleep-code
  )

(defstate dormant (precur-path)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (lightning-bolt-method-13 (-> self bolt) 2)
    )
  :trans (behavior ()
    (draw-lightning self (the-as vector #f) (the-as vector #f))
    (when *target*
      (if (and (time-elapsed? (-> self state-time) (seconds 3))
               (not (logtest? (-> *target* focus-status) (focus-status grabbed)))
               )
          (go-virtual idle)
          )
      )
    )
  :code sleep-code
  )

(defmethod relocate ((this precur-path) (offset int))
  (if (nonzero? (-> this pathb))
      (&+! (-> this pathb) offset)
      )
  (if (nonzero? (-> this bolt))
      (&+! (-> this bolt) offset)
      )
  (call-parent-method this offset)
  )

(defmethod init-from-entity! ((this precur-path) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (when (res-lump-data arg0 'patha pointer)
    (set! (-> this path) (new 'process 'curve-control this 'patha -1000000000.0))
    (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
    )
  (when (res-lump-data arg0 'pathb pointer)
    (set! (-> this pathb) (new 'process 'curve-control this 'pathb -1000000000.0))
    (logior! (-> this pathb flags) (path-control-flag display draw-line draw-point draw-text))
    )
  (set! (-> this last-attack-time) (the-as uint 0))
  (set! (-> this shock-part-time) (the-as uint 0))
  (let* ((v1-13 *game-info*)
         (a0-10 (+ (-> v1-13 attack-id) 1))
         )
    (set! (-> v1-13 attack-id) a0-10)
    (set! (-> this attack-id) a0-10)
    )
  (set! (-> this bolt) (new 'process 'lightning-bolt))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1316) this))
  (init! (-> this bolt) 2 32 *precur-tour-lightning*)
  (new 'stack-no-clear 'vector)
  (let ((v1-22 (process-spawn
                 precur-spot-shadow-effect
                 (-> this root trans)
                 (-> this root quat)
                 :name "precur-spot-shadow-effect"
                 :to this
                 )
               )
        )
    (when v1-22
      (set! (-> this shock-shadow-handle) (ppointer->handle v1-22))
      (set! (-> (the-as (pointer precur-spot-shadow-effect) v1-22) 0 far-clip) 2867.2)
      (set! (-> (the-as (pointer precur-spot-shadow-effect) v1-22) 0 near-clip) 0.4096)
      (set! (-> (the-as (pointer precur-spot-shadow-effect) v1-22) 0 color)
            (new 'static 'rgba :r #x90 :g #x90 :b #xff :a #x80)
            )
      (set-inner-jmod-scale
        (the-as precur-spot-shadow-effect (-> (the-as (pointer precur-spot-shadow-effect) v1-22) 0))
        (new 'static 'vector :x 0.0001 :y 0.0001 :z 0.0001 :w 1.0)
        )
      )
    )
  (go (method-of-object this idle))
  )

(defskelgroup skel-precur-door-b precur-door-b precur-door-b-lod0-jg precur-door-b-idle-ja
              ((precur-door-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(deftype precur-door-b (com-airlock)
  ((pad  uint8  4)
   )
  )


(defmethod init-from-entity! ((this precur-door-b) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 40960.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-precur-door-b" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this open-test) (the-as pair ((method-of-type res-lump get-property-struct)
                                          (-> this entity)
                                          'open-test
                                          'interp
                                          -1000000000.0
                                          (the-as structure '(not #f))
                                          (the-as (pointer res-tag) #f)
                                          *res-static-buf*
                                          )
                                    )
        )
  (init-airlock! this)
  (go (method-of-object this close) #t)
  )

(defstate open (precur-door-b)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (let ((gp-0 sound-play-by-name)
          (a0-3 (make-u128 (the-as uint #x6e65706f2d72) (the-as uint #x6f6f642d63657270)))
          )
      (gp-0 (the-as sound-name a0-3) (new-sound-id) 1024 0 0 (sound-group) #t)
      (let ((t9-2 (-> (method-of-type com-airlock open) enter)))
        (if t9-2
            (t9-2 (the-as symbol a0-3))
            )
        )
      )
    )
  )
