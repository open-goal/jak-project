;;-*-Lisp-*-
(in-package goal)

;; name: temple-obs.gc
;; name in dgo: temple-obs
;; dgos: TEMA

;; DECOMP BEGINS

(defun templea-login ((arg0 level))
  (set! *nav-network* (new 'loading-level 'nav-network))
  (alloc-nav-network-for-level! *nav-network* 64 10)
  0
  (none)
  )

(defun templea-logout ((arg0 level))
  (set! *nav-network* (the-as nav-network 0))
  0
  (none)
  )

(defun templea-activate ((arg0 level))
  (if (and (nonzero? *nav-network*) *nav-network*)
      (init-by-other! *nav-network* arg0 *templea-adjacency*)
      )
  0
  (none)
  )

(defskelgroup skel-tpl-bouncer tpl-bouncer tpl-bouncer-lod0-jg tpl-bouncer-idle-ja
              ((tpl-bouncer-lod0-mg (meters 20)) (tpl-bouncer-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(deftype tpl-bouncer (bouncer)
  ()
  (:state-methods
    broken
    )
  )


(defstate idle (tpl-bouncer)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (when ((method-of-type touching-shapes-entry prims-touching?)
              (the-as touching-shapes-entry (-> block param 0))
              (-> self root)
              (the-as uint 1)
              )
         (when (send-event proc 'jump (-> self spring-height) (-> self spring-height) (-> self mods))
           (sound-play "bouncer")
           (go-virtual fire)
           )
         )
       )
      (('touch)
       (let ((gp-2 (-> block param 0)))
         (cond
           (((method-of-type touching-shapes-entry prims-touching-action?)
             (the-as touching-shapes-entry gp-2)
             (-> self root)
             (collide-action solid)
             (collide-action)
             )
            (when ((method-of-type touching-shapes-entry prims-touching?)
                   (the-as touching-shapes-entry gp-2)
                   (-> self root)
                   (the-as uint 1)
                   )
              (if (not (and (-> self next-state) (let ((v1-22 (-> self next-state name)))
                                                   (or (= v1-22 'smush) (= v1-22 'fire))
                                                   )
                            )
                       )
                  (go-virtual smush)
                  )
              )
            )
           (((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry gp-2)
             (-> self root)
             (the-as uint 4)
             )
            (persist-with-delay
              *setting-control*
              (the-as symbol (process->ppointer self))
              (seconds 0.05)
              'double-jump
              #f
              0.0
              0
              )
            )
           )
         )
       )
      (('attack)
       (let ((v1-29 (the-as object (-> block param 1)))
             (a0-16 (-> block param 0))
             (a2-7 0)
             )
         (cond
           ((= (-> (the-as attack-info v1-29) mode) 'flop)
            (set! a2-7 1)
            )
           ((= (-> (the-as attack-info v1-29) mode) 'board)
            (set! a2-7 9)
            )
           )
         (when (and (nonzero? a2-7)
                    (and ((method-of-type touching-shapes-entry prims-touching?)
                          (the-as touching-shapes-entry a0-16)
                          (-> self root)
                          (the-as uint a2-7)
                          )
                         (send-event proc 'jump (-> self spring-height) (-> self spring-height) (-> self mods))
                         )
                    )
           (sound-play "bouncer")
           (go-virtual fire)
           #f
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self draw force-lod) 0)
    (if (task-node-closed? (game-task-node volcano-darkeco-resolution))
        (go-virtual broken)
        )
    )
  :code (behavior ()
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (until #f
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      )
    #f
    )
  )

(defstate fire (tpl-bouncer)
  :virtual #t
  :code (behavior ()
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
    (sound-play "bouncer-whoosh")
    (ja-no-eval :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
                :num! (seek!)
                :frame-num (ja-aframe 6.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle)
    )
  :post transform-post
  )

(defstate broken (tpl-bouncer)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self draw force-lod) 1)
    )
  :code sleep-code
  :post ja-post
  )

(defmethod init-skel! ((this tpl-bouncer))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-bouncer" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  0
  (none)
  )

(defmethod init-collision! ((this tpl-bouncer))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 4)
      (set-vector! (-> s4-0 local-sphere) -2128.2815 5212.979 223.6416 25526.682)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 1))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 4)
      (set-vector! (-> v1-9 local-sphere) -2128.2815 5212.979 223.6416 25526.682)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) -2128.2815 5212.979 223.6416 25526.682)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defskelgroup skel-tpl-outer-airlock-door tpl-outer-airlock-door tpl-outer-airlock-door-lod0-jg tpl-outer-airlock-door-idle-ja
              ((tpl-outer-airlock-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 18)
              )

(deftype tpl-outer-airlock-door (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this tpl-outer-airlock-door) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 24576.0 0.0 61440.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 24576.0 0.0 61440.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 24576.0 0.0 61440.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-tpl-outer-airlock-door" (the-as (pointer level) #f))
      )
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this lock-frame) 45.0)
  (set! (-> this open-frame) 90.0)
  (set! (-> this sound-pre-open) (static-sound-spec "door-eye-open" :group 0))
  (set! (-> this sound-open-loop) (static-sound-spec "door-open" :group 0))
  (set! (-> this sound-open-stop) (static-sound-spec "door-open-hit" :group 0))
  (set! (-> this sound-close-loop) (static-sound-spec "door-close" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "door-close-hit" :group 0))
  (set! (-> this sound-post-close) (static-sound-spec "door-eye-close" :group 0))
  (set! (-> this sound-behind?) #t)
  (go (method-of-object this close) #t)
  )

(defskelgroup skel-tpl-mardoor tpl-mardoor tpl-mardoor-lod0-jg tpl-mardoor-idle-ja
              ((tpl-mardoor-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 9)
              )

(deftype tpl-mardoor (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this tpl-mardoor) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 24576.0 0.0 36864.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 32768.0 0.0 65536.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 32768.0 0.0 65536.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-mardoor" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this lock-frame) 30.0)
  (set! (-> this open-frame) 30.0)
  (set! (-> this sound-pre-open) (static-sound-spec "mardoor-open" :group 0))
  (set! (-> this sound-close) (static-sound-spec "mardoor-close" :group 0))
  (set! (-> this sound-close-stop) (static-sound-spec "mardoor-cls-hit" :group 0))
  (set! (-> this sound-post-close) (static-sound-spec "mardoor-turn-cl" :group 0))
  (set! (-> this sound-behind?) #t)
  (go (method-of-object this close) #t)
  )

(deftype task-manager-temple-defend (task-manager)
  ()
  )


(defmethod set-time-limit ((this task-manager-temple-defend))
  (set-setting! 'extra-bank '((temple4 temple6)) 0.0 0)
  (set-setting! 'music 'templedf 0.0 0)
  ((method-of-type task-manager set-time-limit) this)
  (none)
  )

(deftype task-manager-temple-oracle (task-manager)
  ()
  )


(defstate active (task-manager-temple-oracle)
  :virtual #t
  :trans (behavior ()
    (format *stdcon* "Temple Oracle: Press down to fail, up to complete~%")
    (if (cpad-pressed? 0 up)
        (send-event self 'complete)
        )
    (if (cpad-pressed? 0 down)
        (send-event self 'fail)
        )
    )
  )

(deftype task-manager-temple-oracle-powerup (task-manager)
  ((arrow-h  handle)
   )
  )


(defstate active (task-manager-temple-oracle-powerup)
  :virtual #t
  :enter (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
      (let ((a0-0 (-> self info sphere-array 0)))
        (set! (-> gp-0 pos quad) (-> a0-0 quad))
        )
      (quaternion-identity! (-> gp-0 quat))
      (set! (-> gp-0 flags) (task-arrow-flags taf5))
      (set! (-> gp-0 map-icon) (the-as uint 13))
      (set! (-> self arrow-h) (process->handle (task-arrow-spawn gp-0 self)))
      )
    (let ((t9-3 (-> (find-parent-state) enter)))
      (if t9-3
          (t9-3)
          )
      )
    )
  :trans (behavior ()
    (let ((t9-1 (-> (find-parent-state) trans)))
      (if t9-1
          (t9-1)
          )
      )
    (when (-> self arrow-h)
      (let ((gp-0 (-> self arrow-h process 0)))
        (when (and (< (vector-vector-distance (-> (the-as process-drawable gp-0) root trans) (target-pos 0)) 20480.0)
                   (movie?)
                   )
          (send-event gp-0 'leave)
          (set! (-> self arrow-h) (the-as handle #f))
          )
        )
      )
    )
  )

(deftype task-manager-lightjak-training (task-manager)
  ((gui-id  sound-id)
   )
  (:methods
    (task-manager-lightjak-training-method-32 (_type_ text-id) none)
    )
  )


;; WARN: Return type mismatch float vs none.
(defmethod task-manager-lightjak-training-method-32 ((this task-manager-lightjak-training) (arg0 text-id))
  (when (= (get-status *gui-control* (-> this gui-id)) (gui-status active))
    (let ((s5-1
            (new 'stack 'font-context *font-default-matrix* 32 290 0.0 (font-color default) (font-flags shadow kerning))
            )
          )
      (set! (-> s5-1 flags) (font-flags shadow kerning middle middle-vert large))
      (let ((v1-4 s5-1))
        (set! (-> v1-4 width) (the float 440))
        )
      (let ((v1-5 s5-1))
        (set! (-> v1-5 height) (the float 80))
        )
      (let ((v1-6 s5-1))
        (set! (-> v1-6 scale) 0.7)
        )
      (let ((s4-0 print-game-text))
        (format (clear *temp-string*) (lookup-text! *common-text* arg0 #f))
        (s4-0 *temp-string* s5-1 #f 44 (bucket-id hud-draw-hud-alpha))
        )
      )
    )
  (none)
  )

(defstate active (task-manager-lightjak-training)
  :virtual #t
  :enter (behavior ()
    (when *target*
      (send-event *target* 'get-pickup (pickup-type eco-pill-light) 100.0)
      (send-event *target* 'get-pickup (pickup-type health) -1.0)
      )
    (set! (-> self gui-id)
          (add-process *gui-control* self (gui-channel message) (gui-action play) (-> self name) 81920.0 0)
          )
    )
  :exit (behavior ()
    (send-event *target* 'get-pickup (pickup-type health) 100.0)
    )
  :trans (behavior ()
    (task-manager-lightjak-training-method-32 self (text-id text-05f6))
    (if (and *target* (focus-test? *target* light))
        (send-event self 'complete)
        )
    (let ((t9-3 (-> (find-parent-state) trans)))
      (if t9-3
          (t9-3)
          )
      )
    )
  )

(deftype task-manager-lightjak-training-freeze (task-manager-lightjak-training)
  ()
  )


(defstate active (task-manager-lightjak-training-freeze)
  :virtual #t
  :enter (behavior ()
    (if *target*
        (send-event *target* 'get-pickup (pickup-type eco-pill-light) 100.0)
        )
    (set! (-> self gui-id)
          (add-process *gui-control* self (gui-channel message) (gui-action play) (-> self name) 81920.0 0)
          )
    )
  :exit #f
  :trans (behavior ()
    (task-manager-lightjak-training-method-32 self (text-id text-05f7))
    (if (!= (-> *display* entity-clock clock-ratio) 1.0)
        (send-event self 'complete)
        )
    (let ((t9-2 (-> (method-of-type task-manager active) trans)))
      (if t9-2
          (t9-2)
          )
      )
    )
  )

(deftype task-manager-lightjak-training-swoop (task-manager-lightjak-training)
  ((learned-to-flap?  symbol)
   (flap-count        int32)
   )
  )


(defstate active (task-manager-lightjak-training-swoop)
  :virtual #t
  :enter (behavior ()
    (if *target*
        (send-event *target* 'get-pickup (pickup-type eco-pill-light) 100.0)
        )
    (set! (-> self gui-id)
          (add-process *gui-control* self (gui-channel message) (gui-action play) (-> self name) 81920.0 0)
          )
    (set! (-> self learned-to-flap?) #f)
    )
  :exit #f
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type task-manager active) trans)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :code (behavior ()
    (until #f
      (cond
        ((not *target*)
         (suspend)
         0
         )
        ((and (focus-test? *target* light)
              (nonzero? (-> *target* lightjak))
              (logtest? (-> *target* lightjak stage) (lightjak-stage swoop))
              )
         (cond
           ((-> self learned-to-flap?)
            (cond
              ((nonzero? (-> self flap-count))
               )
              ((and (-> *target* next-state) (= (-> *target* next-state name) 'target-lightjak-swoop-again))
               (+! (-> self flap-count) 1)
               )
              (else
                (task-manager-lightjak-training-method-32 self (text-id text-061f))
                )
              )
            )
           ((and (-> *target* next-state) (= (-> *target* next-state name) 'target-lightjak-swoop))
            (set! (-> self learned-to-flap?) #t)
            )
           (else
             (task-manager-lightjak-training-method-32 self (text-id text-061e))
             )
           )
         )
        (else
          (task-manager-lightjak-training-method-32 self (text-id text-05f9))
          )
        )
      (suspend)
      )
    #f
    )
  )

(defpartgroup group-holo-halo
  :id 677
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 2618 :flags (sp6 sp7)) (sp-item 2619 :flags (sp6 sp7)))
  )

;; WARN: Return type mismatch float vs none.
(defun sparticle-holo-halo0 ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let* ((v1-2 (-> *display* part-clock frame-counter))
         (f0-1 (* 0.00020833334 (the float (mod v1-2 4800))))
         )
    (set! (-> arg2 conerot z) (* 65536.0 f0-1))
    )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defun sparticle-holo-halo1 ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (let* ((v1-2 (-> *display* part-clock frame-counter))
         (f0-1 (* 0.00020833334 (the float (mod v1-2 4800))))
         )
    (set! (-> arg2 conerot z) (* -65536.0 f0-1))
    )
  (none)
  )

(defpart 2618
  :init-specs ((:texture (colorflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 14))
    (:rot-z (degrees 0))
    (:scale-y (meters 14))
    (:r 100.0)
    (:g 100.0)
    (:b 150.0)
    (:a 48.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-3))
    (:func 'sparticle-holo-halo0)
    )
  )

(defpart 2619
  :init-specs ((:texture (colorflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 14))
    (:rot-z (degrees 0))
    (:scale-y (meters 14))
    (:r 100.0)
    (:g 100.0)
    (:b 150.0)
    (:a 48.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-3))
    (:func 'sparticle-holo-halo1)
    )
  )

(deftype tpl-holo-eye (process-drawable)
  ((eyeball-jmod        joint-mod-set-world-no-trans  :inline)
   (other-eyeball-jmod  joint-mod-set-world           :inline)
   (next-blink-time     time-frame)
   (trigger-radius      float)
   (idle-clock          time-frame)
   (actor-group         (pointer actor-group))
   (actor-group-count   int32)
   (triggered?          symbol)
   (untriggered?        symbol)
   (kill-quat           quaternion                    :inline)
   (kill-angle          float)
   (kill-speed          float)
   (init-trans          vector                        :inline)
   (perm-part           handle)
   )
  (:state-methods
    idle
    alert
    die
    die-fast
    )
  (:methods
    (tpl-holo-eye-method-24 (_type_) none)
    )
  )


(defskelgroup skel-tpl-holo-eye tpl-holo-eye tpl-holo-eye-lod0-jg tpl-holo-eye-idle-ja
              ((tpl-holo-eye-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; WARN: Return type mismatch transformq vs none.
(defmethod tpl-holo-eye-method-24 ((this tpl-holo-eye))
  (let ((s5-1 (quaternion-look-at!
                (new 'stack-no-clear 'quaternion)
                (vector-normalize-copy!
                  (new 'stack-no-clear 'vector)
                  (vector-!
                    (new 'stack-no-clear 'vector)
                    (get-trans *target* 3)
                    (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data 4))
                    )
                  1.0
                  )
                *up-vector*
                )
              )
        )
    (if (>= (-> (quaternion*!
                  (new 'stack-no-clear 'quaternion)
                  s5-1
                  (quaternion-conjugate! (new 'stack-no-clear 'quaternion) (-> this root quat))
                  )
                w
                )
            0.81915206
            )
        (quaternion-copy! (-> this eyeball-jmod transform quat) s5-1)
        )
    )
  (quaternion-copy! (-> this other-eyeball-jmod transform quat) (-> this eyeball-jmod transform quat))
  (set! (-> this other-eyeball-jmod transform trans quad) (-> this node-list data 4 bone transform trans quad))
  (none)
  )

(defstate idle (tpl-holo-eye)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (let ((v0-0 (the-as object #t)))
         (set! (-> self triggered?) (the-as symbol v0-0))
         v0-0
         )
       )
      (('kill)
       (go-virtual die)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self triggered?) #f)
    )
  :trans (behavior ()
    (when *target*
      (b!
        (not (or (logtest? (target-flags invisible) (-> *target* target-flags))
                 (< 40960.0 (- (-> (target-pos 0) y) (-> self root trans y)))
                 )
             )
        cfg-7
        :delay (nop!)
        )
      (quaternion-copy! (-> self eyeball-jmod transform quat) (-> self root quat))
      (quaternion-copy! (-> self other-eyeball-jmod transform quat) (-> self root quat))
      (set! (-> self other-eyeball-jmod transform trans quad) (-> self node-list data 4 bone transform trans quad))
      (b! #t cfg-16 :delay (nop!))
      (label cfg-7)
      (tpl-holo-eye-method-24 self)
      (if (or (-> self triggered?) (< (if *target*
                                          (vector-vector-xz-distance (-> self root trans) (-> *target* control trans))
                                          4096000.0
                                          )
                                      (-> self trigger-radius)
                                      )
              )
          (go-virtual alert)
          )
      )
    (label cfg-16)
    (+! (-> self idle-clock) (- (current-time) (-> self clock old-frame-counter)))
    (let ((f30-1 (* 0.0003030303 (the float (mod (-> self idle-clock) 3300))))
          (f0-5 (* 0.00025641025 (the float (mod (-> self idle-clock) 3900))))
          (s4-0 (-> self root trans))
          (gp-0 (-> self init-trans))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 x) 0.0)
      (set! (-> s5-0 y) (* 8192.0 (cos (* 65536.0 f0-5)) (sin (* 65536.0 f30-1))))
      (set! (-> s5-0 z) 0.0)
      (set! (-> s5-0 w) 1.0)
      (vector+! s4-0 gp-0 s5-0)
      )
    )
  :code (behavior ()
    (ja-no-eval :group! tpl-holo-eye-shuteye-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (set! (-> self next-blink-time)
          (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 2101) 900 (current-time)))
          )
    (until #f
      (ja-no-eval :group! tpl-holo-eye-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (when (< (-> self next-blink-time) (current-time))
        (set! (-> self next-blink-time)
              (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 2101) 900 (current-time)))
              )
        (ja-no-eval :group! tpl-holo-eye-blink-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    #f
    )
  :post ja-post
  )

(defstate alert (tpl-holo-eye)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('untrigger)
       (let ((v0-0 (the-as object #t)))
         (set! (-> self untriggered?) (the-as symbol v0-0))
         v0-0
         )
       )
      (('kill)
       (go-virtual die)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self untriggered?) #f)
    )
  :exit (behavior ()
    (when (and (nonzero? (-> self actor-group)) (-> self actor-group 0))
      (let ((gp-0 (-> self actor-group 0)))
        (dotimes (s5-0 (-> gp-0 length))
          (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-0 from) (process->ppointer self))
            (set! (-> a1-0 num-params) 0)
            (set! (-> a1-0 message) 'down)
            (let ((t9-0 send-event-function)
                  (v1-8 (-> gp-0 data s5-0 actor))
                  )
              (t9-0
                (if v1-8
                    (-> v1-8 extra process)
                    )
                a1-0
                )
              )
            )
          )
        )
      )
    )
  :trans (behavior ()
    (cond
      ((and *target*
            (not (logtest? (target-flags invisible) (-> *target* target-flags)))
            (< (- (-> (target-pos 0) y) (-> self root trans y)) 40960.0)
            )
       (tpl-holo-eye-method-24 self)
       (if (or (and (-> self triggered?) (-> self untriggered?))
               (and (not (-> self triggered?))
                    (< (-> self trigger-radius) (if *target*
                                                    (vector-vector-xz-distance (-> self root trans) (-> *target* control trans))
                                                    4096000.0
                                                    )
                       )
                    )
               )
           (go-virtual idle)
           )
       )
      (else
        (go-virtual idle)
        )
      )
    )
  :code (behavior ()
    (sound-play "temple-holo-eye")
    (ja-no-eval :group! tpl-holo-eye-openeye-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (when (and (nonzero? (-> self actor-group)) (-> self actor-group 0))
      (let ((gp-1 (-> self actor-group 0)))
        (dotimes (s5-1 (-> gp-1 length))
          (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-3 from) (process->ppointer self))
            (set! (-> a1-3 num-params) 0)
            (set! (-> a1-3 message) 'up)
            (let ((t9-5 send-event-function)
                  (v1-35 (-> gp-1 data s5-1 actor))
                  )
              (t9-5
                (if v1-35
                    (-> v1-35 extra process)
                    )
                a1-3
                )
              )
            )
          )
        )
      )
    (sleep-code)
    )
  :post ja-post
  )

(defstate die (tpl-holo-eye)
  :virtual #t
  :enter (behavior ()
    (sound-play "holo-eye-close")
    (quaternion-copy! (-> self kill-quat) (-> self root quat))
    (set! (-> self kill-angle) 0.0)
    (set! (-> self kill-speed) 0.0)
    (set-time! (-> self state-time))
    (let ((v1-6 (res-lump-struct (-> self entity) 'continue-name structure)))
      (when v1-6
        (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-3 from) (process->ppointer self))
          (set! (-> a1-3 num-params) 2)
          (set! (-> a1-3 message) 'checkpoint)
          (set! (-> a1-3 param 0) (the-as uint v1-6))
          (set! (-> a1-3 param 1) (the-as uint (-> self entity)))
          (let ((t9-4 send-event-function)
                (v1-10 (-> *game-info* sub-task-list (game-task-node arena-training-1-collect)))
                )
            (t9-4
              (handle->process (if (-> v1-10 manager)
                                   (-> v1-10 manager manager)
                                   (the-as handle #f)
                                   )
                               )
              a1-3
              )
            )
          )
        )
      )
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (let ((t0-1 (res-lump-struct (-> self entity) 'camera-name structure)))
      (when t0-1
        (persist-with-delay *setting-control* 'entity-name (seconds 2) 'entity-name (the-as symbol t0-1) 0.0 0)
        (until (process-grab? *target* #f)
          (suspend)
          )
        (let ((gp-0 (current-time)))
          (until (time-elapsed? gp-0 (seconds 1))
            (suspend)
            )
          )
        )
      )
    (set-time! (-> self state-time))
    (until #f
      (seek! (-> self kill-speed) 182044.44 (* 182044.44 (seconds-per-frame)))
      (+! (-> self kill-angle) (* (-> self kill-speed) (seconds-per-frame)))
      (let ((a2-4 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *y-vector* (-> self kill-angle))))
        (quaternion*! (-> self root quat) (-> self kill-quat) a2-4)
        )
      (set! (-> self other-eyeball-jmod transform scale quad) (-> self root scale quad))
      (set! (-> self eyeball-jmod transform scale quad) (-> self root scale quad))
      (let* ((f0-9 (lerp-scale 1.0 0.0 (the float (- (current-time) (-> self state-time))) 0.0 60.0))
             (f0-11 (* f0-9 f0-9))
             )
        (set! (-> self root scale x) (* f0-11 f0-11))
        )
      (set! (-> self root scale y) (+ 1.0 (* 0.5 (-> self root scale x))))
      (set! (-> self root scale z) (-> self root scale x))
      (when (= (-> self root scale x) 0.0)
        (send-event (handle->process (-> self perm-part)) 'die)
        (let ((gp-1 (current-time)))
          (until (time-elapsed? gp-1 (seconds 1))
            (suspend)
            )
          )
        (until (process-release? *target*)
          (suspend)
          )
        (let ((gp-2 (res-lump-struct (-> self entity) 'on-deactivate structure)))
          (if gp-2
              (script-eval (the-as pair gp-2))
              )
          )
        (go-virtual die-fast)
        )
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defstate die-fast (tpl-holo-eye)
  :virtual #t
  :code (behavior ()
    (send-event (handle->process (-> self perm-part)) 'die)
    (when (and (nonzero? (-> self actor-group)) (>= (-> self actor-group-count) 2) (-> self actor-group 1))
      (let ((gp-0 (-> self actor-group 1)))
        (dotimes (s5-0 (-> gp-0 length))
          (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-1 from) (process->ppointer self))
            (set! (-> a1-1 num-params) 0)
            (set! (-> a1-1 message) 'open)
            (let ((t9-1 send-event-function)
                  (v1-16 (-> gp-0 data s5-0 actor))
                  )
              (t9-1
                (if v1-16
                    (-> v1-16 extra process)
                    )
                a1-1
                )
              )
            )
          )
        )
      )
    (while (-> self child)
      (suspend)
      )
    (process-entity-status! self (entity-perm-status dead) #t)
    )
  )

(defmethod init-from-entity! ((this tpl-holo-eye) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (stack-size-set! (-> this main-thread) 320)
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-holo-eye" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this trigger-radius) (res-lump-float (-> this entity) 'holo-eye-activate-radius :default 77824.0))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-8 (res-lump-data arg0 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-8 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-8))
       )
      (else
        (format 0 "ERROR: ~s: entity missing actor-group!~%" (-> this name))
        )
      )
    )
  (set! (-> this init-trans quad) (-> this root trans quad))
  (init (-> this eyeball-jmod) this (the-as uint 4) (joint-mod-base-flags attached scale))
  (init (-> this other-eyeball-jmod) this (the-as uint 9) (joint-mod-base-flags attached trans quat scale))
  (set! (-> this perm-part)
        (ppointer->handle (if (logtest? (-> *part-group-id-table* 677 flags) (sp-group-flag sp13))
                              (part-tracker-spawn
                                part-tracker-subsampler
                                :to this
                                :group (-> *part-group-id-table* 677)
                                :duration -1
                                :target this
                                :mat-joint (the-as object 0)
                                )
                              (part-tracker-spawn
                                part-tracker
                                :to this
                                :group (-> *part-group-id-table* 677)
                                :duration -1
                                :target this
                                :mat-joint (the-as object 0)
                                )
                              )
                          )
        )
  (set! (-> this idle-clock) 0)
  (set! (-> this triggered?) #f)
  (set! (-> this untriggered?) #f)
  (set! (-> this root pause-adjust-distance) 327680.0)
  (let ((s5-3 (res-lump-struct (-> this entity) 'on-activate structure)))
    (if (and s5-3 (not (script-eval (the-as pair s5-3))))
        (go (method-of-object this die-fast))
        )
    )
  (go (method-of-object this idle))
  )

;; WARN: Return type mismatch object vs none.
(defmethod deactivate ((this tpl-holo-eye))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (let ((t9-0 (method-of-type process-focusable deactivate)))
    (t9-0 (the-as process-focusable this))
    )
  (send-event (handle->process (-> this perm-part)) 'die)
  (none)
  )

(deftype tpl-spike-trap (process-drawable)
  ((was-up              symbol)
   (no-collision-timer  time-frame)
   (attack-id           int32)
   )
  (:state-methods
    idle-down
    idle-up
    )
  )


(defskelgroup skel-tpl-spike-trap tpl-spike-trap tpl-spike-trap-lod0-jg tpl-spike-trap-idle-ja
              ((tpl-spike-trap-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12)
              )

(defstate idle-down (tpl-spike-trap)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('up)
       (go-virtual idle-up)
       )
      )
    )
  :code (behavior ()
    (when (-> self was-up)
      (sound-play "temple-spikes")
      (ja-no-eval :group! tpl-spike-trap-down-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (set! (-> self was-up) #f)
    (sleep-code)
    )
  :post ja-post
  )

(defstate idle-up (tpl-spike-trap)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('down)
       (go-virtual idle-down)
       )
      (('touch)
       (let* ((s4-0 proc)
              (gp-0 (if (type? s4-0 process-focusable)
                        s4-0
                        )
                    )
              )
         (when (and gp-0 (= (-> gp-0 type) target))
           (when (time-elapsed? (-> self no-collision-timer) (seconds 0.2))
             (let* ((v1-9
                      ((method-of-type res-lump get-property-struct)
                       (-> self entity)
                       'spike-toss-dest
                       'interp
                       -1000000000.0
                       (new 'static 'structure)
                       (the-as (pointer res-tag) #f)
                       *res-static-buf*
                       )
                      )
                    (s4-2
                      (vector-! (new 'stack-no-clear 'vector) (the-as vector v1-9) (-> (the-as process-drawable gp-0) root trans))
                      )
                    )
               (set! (-> s4-2 y) 0.0)
               (vector-xz-normalize! s4-2 1.0)
               (when (send-event
                       gp-0
                       'attack-invinc
                       (-> block param 0)
                       (static-attack-info
                         :mask (vehicle-impulse-factor)
                         ((id (the-as uint (-> self attack-id)))
                          (damage 2.0)
                          (vehicle-damage-factor 1.0)
                          (vehicle-impulse-factor 1.0)
                          (vector s4-2)
                          (shove-back (meters 10))
                          (shove-up (meters 5))
                          (control (if (focus-test? (the-as process-focusable gp-0) board)
                                       1.0
                                       0.0
                                       )
                                   )
                          )
                         )
                       )
                 (let ((v0-0 (the-as object (current-time))))
                   (set! (-> self no-collision-timer) (the-as time-frame v0-0))
                   v0-0
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (when (not (-> self was-up))
      (sound-play "temple-spikes")
      (ja-no-eval :group! tpl-spike-trap-up-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (set! (-> self was-up) #t)
    (sleep-code)
    )
  :post ja-post
  )

(defmethod init-from-entity! ((this tpl-spike-trap) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) projectile-bounce-reaction)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 32768.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 32768.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-spike-trap" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this was-up) #f)
  (set-time! (-> this no-collision-timer))
  (let* ((v1-24 *game-info*)
         (a0-17 (+ (-> v1-24 attack-id) 1))
         )
    (set! (-> v1-24 attack-id) a0-17)
    (set! (-> this attack-id) (the-as int a0-17))
    )
  (go (method-of-object this idle-down))
  )

(defpart 2620
  :init-specs ((:texture (pal-lightning level-default-sprite))
    (:birth-func 'birth-func-set-quat)
    (:num 1.0)
    (:scale-x (meters 2))
    (:scale-y (meters 40))
    (:r 128.0 64.0)
    (:g 128.0 64.0)
    (:b 128.0 64.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 left-multiply-quat))
    )
  )

(defskelgroup skel-tpl-elec-swing-pole tpl-elec-swing-pole tpl-elec-swing-pole-lod0-jg tpl-elec-swing-pole-idle-ja
              ((tpl-elec-swing-pole-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 8 9)
              )

(deftype tpl-elec-swing-pole (swingpole)
  ((root       collide-shape     :override)
   (y-start    float)
   (y-end      float)
   (electrify  symbol)
   (lightning  lightning-control  4)
   (y-disable  float)
   (sound-id   sound-id)
   )
  (:state-methods
    goup
    )
  )


(defmethod deactivate ((this tpl-elec-swing-pole))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (-> this sound-id)
      (sound-stop (-> this sound-id))
      )
  ((method-of-type swingpole deactivate) this)
  (none)
  )

(defmethod swingpole-method-22 ((this tpl-elec-swing-pole))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((t9-0 (method-of-type swingpole swingpole-method-22)))
      (t9-0 this)
      )
    (cond
      ((-> this electrify)
       (let ((f30-0 (-> *part-id-table* 2620 init-specs 4 initial-valuef)))
         (set! (-> *part-id-table* 2620 init-specs 4 initial-valuef) (-> this edge-length))
         (draw-beam (-> *part-id-table* 2620) (-> this root trans) (-> this dir) #f)
         (set! (-> *part-id-table* 2620 init-specs 4 initial-valuef) f30-0)
         )
       (dotimes (s5-0 4)
         (let ((f30-1 (rand-vu-float-range 0.0 (-> this edge-length)))
               (f0-3 (rand-vu-float-range 0.0 (-> this edge-length)))
               )
           (let ((a0-5 (-> this lightning s5-0))
                 (v1-16 (new 'stack-no-clear 'vector))
                 )
             (let ((a1-4 (-> this root trans)))
               (let ((a2-1 (-> this dir)))
                 (let ((a3-1 f30-1))
                   (.mov vf7 a3-1)
                   )
                 (.lvf vf5 (&-> a2-1 quad))
                 )
               (.lvf vf4 (&-> a1-4 quad))
               )
             (.add.x.vf vf6 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf5 vf7 :mask #b111)
             (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
             (.svf (&-> v1-16 quad) vf6)
             (set! (-> a0-5 state meet data 0 quad) (-> v1-16 quad))
             )
           (let ((a0-8 (-> this lightning s5-0))
                 (v1-20 (new 'stack-no-clear 'vector))
                 )
             (let ((a1-6 (-> this root trans)))
               (let ((a2-2 (-> this dir)))
                 (let ((a3-2 f0-3))
                   (.mov vf7 a3-2)
                   )
                 (.lvf vf5 (&-> a2-2 quad))
                 )
               (.lvf vf4 (&-> a1-6 quad))
               )
             (.add.x.vf vf6 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf5 vf7 :mask #b111)
             (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
             (.svf (&-> v1-20 quad) vf6)
             (set! (-> a0-8 state meet data (+ (-> a0-8 state points-to-draw) -1) quad) (-> v1-20 quad))
             )
           )
         (let ((v1-24 (-> this lightning s5-0))
               (a0-11 2)
               )
           (let ((a1-12 (!= a0-11 (-> v1-24 state mode))))
             (case a0-11
               ((3)
                (if a1-12
                    (set! (-> v1-24 state counter) 0.0)
                    )
                )
               ((1)
                (set! (-> v1-24 state start-color) (-> v1-24 spec start-color))
                (set! (-> v1-24 state end-color) (-> v1-24 spec end-color))
                )
               )
             )
           (set! (-> v1-24 state mode) (the-as uint a0-11))
           )
         )
       (sound-play "pole-hum-loop" :id (-> this sound-id))
       )
      (else
        (sound-stop (-> this sound-id))
        (dotimes (v1-30 4)
          (let ((a0-18 (-> this lightning v1-30))
                (a1-22 0)
                )
            (let ((a2-6 (!= a1-22 (-> a0-18 state mode))))
              (case a1-22
                ((3)
                 (if a2-6
                     (set! (-> a0-18 state counter) 0.0)
                     )
                 )
                ((1)
                 (set! (-> a0-18 state start-color) (-> a0-18 spec start-color))
                 (set! (-> a0-18 state end-color) (-> a0-18 spec end-color))
                 )
                )
              )
            (set! (-> a0-18 state mode) (the-as uint a1-22))
            )
          )
        )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch swingpole vs tpl-elec-swing-pole.
(defmethod relocate ((this tpl-elec-swing-pole) (offset int))
  (dotimes (v1-0 4)
    (if (nonzero? (-> this lightning v1-0))
        (&+! (-> this lightning v1-0) offset)
        )
    )
  (the-as tpl-elec-swing-pole ((method-of-type swingpole relocate) this offset))
  )

(defstate idle (tpl-elec-swing-pole)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('down)
       (set! (-> self electrify) #f)
       #f
       )
      (('up)
       (let ((v0-0 #t))
         (set! (-> self electrify) v0-0)
         v0-0
         )
       )
      (('touch 'attack)
       (if (send-event proc 'pole-grab (-> block param 0))
           (go-virtual active (process->handle proc))
           )
       #f
       )
      )
    )
  :trans (behavior ()
    (if (task-node-closed? (game-task-node temple-oracle-pole-half))
        (go-virtual goup)
        )
    )
  )

(defstate goup (tpl-elec-swing-pole)
  :virtual #t
  :trans (behavior ()
    (seek! (-> self root trans y) (-> self y-disable) (* 16384.0 (seconds-per-frame)))
    )
  :code sleep-code
  :post transform-post
  )

(defstate active (tpl-elec-swing-pole)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('down)
       (set! (-> self electrify) #f)
       #f
       )
      (('up)
       (let ((v0-0 #t))
         (set! (-> self electrify) v0-0)
         v0-0
         )
       )
      )
    )
  :trans (behavior ()
    (if (and *target* (-> self electrify))
        (send-event
          *target*
          'attack
          #f
          (static-attack-info
            :mask (vehicle-impulse-factor)
            ((id (new-attack-id)) (damage 100.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'shock))
            )
          )
        )
    )
  )

(defmethod init-collision! ((this tpl-elec-swing-pole))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 7) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 8))
      (set! (-> s4-0 prim-core collide-as) (collide-spec collectable))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 32768.0 32768.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 8192.0 8192.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 16384.0 8192.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 24576.0 8192.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 32768.0 8192.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 40960.0 8192.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 49152.0 8192.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec collectable))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak player-list tobot))
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 57344.0 8192.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch collide-prim-core vs vector.
(defmethod get-trans ((this tpl-elec-swing-pole))
  (the-as vector (-> this root root-prim prim-core))
  )

(defmethod init-from-entity! ((this tpl-elec-swing-pole) (arg0 entity-actor))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (stack-size-set! (-> this main-thread) 128)
    (set! (-> this y-start) (res-lump-float (-> this entity) 'y-start))
    (set! (-> this y-end) (res-lump-float (-> this entity) 'y-end))
    (set! (-> this electrify) #f)
    (set! (-> this sound-id) (new-sound-id))
    (init-collision! this)
    (set! (-> this root trans quad) (-> arg0 extra trans quad))
    (quaternion-copy! (-> this root quat) (-> arg0 quat))
    (vector-identity! (-> this root scale))
    (vector-z-quaternion! (-> this dir) (-> this root quat))
    (set! (-> this joint-track) -1)
    (set! (-> this y-disable) (+ 37888.0 (-> this root trans y)))
    (initialize-skeleton
      this
      (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-elec-swing-pole" (the-as (pointer level) #f)))
      (the-as pair 0)
      )
    (set! (-> this dir y) 0.0)
    (vector-normalize! (-> this dir) 1.0)
    (set! (-> this edge-length) 8192.0)
    (let ((s4-1 (new 'stack-no-clear 'sync-info-params)))
      (let ((a0-15 (res-lump-value arg0 'options uint128 :time -1000000000.0))
            (v1-19 0)
            )
        (if (not (logtest? (the-as int a0-15) 8))
            (set! v1-19 (logior v1-19 1))
            )
        (set! (-> s4-1 sync-type) 'sync-eased)
        (set! (-> s4-1 sync-flags) (the-as sync-flags v1-19))
        )
      (set! (-> s4-1 period) (the-as uint 0))
      (set! (-> s4-1 entity) arg0)
      (set! (-> s4-1 percent) 0.0)
      (set! (-> s4-1 ease-in) 0.2)
      (set! (-> s4-1 ease-out) 0.2)
      (set! (-> s4-1 pause-in) 0.0)
      (set! (-> s4-1 pause-out) 0.0)
      (initialize! (-> this sync) s4-1)
      )
    (when (nonzero? (-> this sync period))
      (set! (-> this path) (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f))
      (when (and (zero? (-> this path curve num-cverts)) (-> this entity))
        (set! (-> this path curve num-cverts) 2)
        (set! (-> this path curve cverts) (-> (new 'process 'vector-array 2) data))
        (logclear! (-> this path flags) (path-control-flag not-found))
        (let ((v1-39 (-> this path curve cverts 0)))
          (let ((a0-30 (-> this entity trans)))
            (let ((a1-13 *y-vector*))
              (let ((a2-8 (* 4096.0 (-> this y-start))))
                (.mov vf7 a2-8)
                )
              (.lvf vf5 (&-> a1-13 quad))
              )
            (.lvf vf4 (&-> a0-30 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> v1-39 quad) vf6)
          )
        (let ((v1-42 (-> this path curve cverts 1)))
          (let ((a0-32 (-> this entity trans)))
            (let ((a1-14 *y-vector*))
              (let ((a2-10 (* 4096.0 (-> this y-end))))
                (.mov vf7 a2-10)
                )
              (.lvf vf5 (&-> a1-14 quad))
              )
            (.lvf vf4 (&-> a0-32 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> v1-42 quad) vf6)
          )
        )
      (if (and (nonzero? (-> this path)) (nonzero? (-> this path curve num-cverts)))
          (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
          )
      )
    (set! (-> this sound) (new 'process 'ambient-sound (-> this entity) (-> this root trans) 0.0))
    (set! (-> this edge-length) 65536.0)
    (dotimes (s5-1 4)
      (set! (-> this lightning s5-1) (new
                                       'process
                                       'lightning-control
                                       (new 'static 'lightning-spec
                                         :name #f
                                         :flags (lightning-spec-flags lsf0)
                                         :start-color (new 'static 'rgba :r #x80 :g #x80 :b #x80 :a #x80)
                                         :end-color (new 'static 'rgba :r #x80 :g #x80 :b #x80 :a #x80)
                                         :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                         :fade-start-factor 0.2
                                         :fade-time 120.0
                                         :texture (new 'static 'texture-id :index #x3f :page #x4)
                                         :reduction 0.42
                                         :num-points 10
                                         :box-size 8192.0
                                         :merge-factor 0.5
                                         :merge-count 2
                                         :radius 512.0
                                         :duration -1.0
                                         :sound #f
                                         )
                                       this
                                       0.0
                                       )
            )
      (let ((v1-57 (-> this lightning s5-1))
            (a0-39 0)
            )
        (let ((a1-18 (!= a0-39 (-> v1-57 state mode))))
          (case a0-39
            ((3)
             (if a1-18
                 (set! (-> v1-57 state counter) 0.0)
                 )
             )
            ((1)
             (set! (-> v1-57 state start-color) (-> v1-57 spec start-color))
             (set! (-> v1-57 state end-color) (-> v1-57 spec end-color))
             )
            )
          )
        (set! (-> v1-57 state mode) (the-as uint a0-39))
        )
      )
    (go (method-of-object this idle))
    )
  )

(deftype tpl-spindle (process-drawable)
  ((root           collide-shape :override)
   (init-quat      quaternion     :inline)
   (init-quat2     quaternion     :inline)
   (rot-angle      float)
   (shudder-angle  float)
   (cycle-time     float)
   (cycle-offset   float)
   )
  (:state-methods
    idle
    idle-slow
    )
  )


(defskelgroup skel-tpl-spindle tpl-spindle tpl-spindle-lod0-jg tpl-spindle-idle-ja
              ((tpl-spindle-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 45)
              )

(defstate idle (tpl-spindle)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (rider-trans)
    (let ((gp-1 (quaternion-vector-angle!
                  (new 'stack-no-clear 'quaternion)
                  *z-vector*
                  (* 436.90668
                     (the float (- (current-time) (-> self state-time)))
                     (lerp-scale 1.0 2.0 (-> self clock clock-ratio) 1.0 0.05)
                     )
                  )
                )
          )
      (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *z-vector* 0.0)
      (quaternion*! (-> self root quat) (-> self init-quat2) gp-1)
      )
    (quaternion-normalize! (-> self root quat))
    (when (= (-> self clock clock-ratio) 0.05)
      )
    )
  :code sleep-code
  :post (behavior ()
    (rider-post)
    )
  )

(defstate idle-slow (tpl-spindle)
  :virtual #t
  :trans (behavior ()
    (rider-trans)
    (let ((a2-1 (quaternion-vector-angle!
                  (new 'stack-no-clear 'quaternion)
                  *z-vector*
                  (+ (-> self rot-angle) (-> self shudder-angle))
                  )
                )
          )
      (quaternion*! (-> self root quat) (-> self init-quat) a2-1)
      )
    (when (!= (-> self clock clock-ratio) 0.05)
      (quaternion-copy! (-> self init-quat2) (-> self root quat))
      (go-virtual idle)
      )
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (the int (-> self cycle-offset)))
        (suspend)
        )
      )
    (until #f
      (let ((gp-1 (current-time)))
        (until (time-elapsed? gp-1 (the int (-> self cycle-time)))
          (suspend)
          )
        )
      (sound-play "fan-shake" :position (-> self root trans))
      (let ((gp-3 (current-time)))
        (until (time-elapsed? gp-3 (seconds 0.01))
          (let ((f0-5 (* 36408.89 (the float (- (current-time) gp-3))))
                (f1-3 (* 0.33333334 (- 3.0 (the float (- (current-time) gp-3)))))
                )
            (set! (-> self shudder-angle) (* 0.0018204444 f1-3 (sin f0-5)))
            )
          (suspend)
          )
        )
      (set! (-> self shudder-angle) 0.0)
      (let ((gp-4 (current-time)))
        (until (time-elapsed? gp-4 (seconds 0.04))
          (suspend)
          )
        )
      (sound-play "fan-turn" :position (-> self root trans))
      (let* ((f0-9 100.0)
             (f30-1 (* 16384.0 f0-9))
             (gp-6 (current-time))
             )
        (until (time-elapsed? gp-6 (seconds 0.01))
          (set! (-> self rot-angle)
                (the float (sar (shl (the int (+ (-> self rot-angle) (* f30-1 (seconds-per-frame)))) 48) 48))
                )
          (suspend)
          )
        )
      (let ((v1-47 #x4000))
        (if (< (-> self rot-angle) 0.0)
            (set! (-> self rot-angle)
                  (the float (sar (shl (* v1-47 (/ (- (the int (-> self rot-angle)) (/ v1-47 2)) v1-47)) 48) 48))
                  )
            (set! (-> self rot-angle)
                  (the float (sar (shl (* v1-47 (/ (+ (the int (-> self rot-angle)) (/ v1-47 2)) v1-47)) 48) 48))
                  )
            )
        )
      )
    #f
    )
  :post (behavior ()
    (rider-post)
    )
  )

(defmethod init-from-entity! ((this tpl-spindle) (arg0 entity-actor))
  (local-vars (sv-16 int))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 184320.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-spindle" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this root rider-max-momentum) 819.2)
  (set! (-> this rot-angle) 0.0)
  (set! (-> this shudder-angle) 0.0)
  (quaternion-copy! (-> this init-quat) (-> this root quat))
  (quaternion-copy! (-> this init-quat2) (-> this root quat))
  (ja-channel-push! 1 0)
  (let ((s4-2 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval!
      s4-2
      (the-as art-joint-anim (-> this draw art-group data 2))
      num-func-identity
      )
    (set! (-> s4-2 frame-num) 0.0)
    )
  (transform-post)
  (let ((f28-0 0.4)
        (f30-0 0.0)
        )
    (set! sv-16 0)
    (let ((v1-30 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (the-as (pointer res-tag) (& sv-16)))))
      (when v1-30
        (set! f28-0 (-> v1-30 0))
        (set! f30-0 (-> v1-30 1))
        )
      )
    (set! (-> this cycle-time) (the float (max 0 (+ (the int (* 300.0 f28-0)) -6))))
    (set! (-> this cycle-offset) (the float (the int (* 300.0 f30-0))))
    )
  (set! (-> this draw light-index) (the-as uint 5))
  (go (method-of-object this idle-slow))
  )

(deftype tpl-fan-two (process-drawable)
  ((quat          quaternion  :inline)
   (cycle-time    float)
   (cycle-offset  float)
   (start-timef   float)
   (next-sound    float)
   (last-sound    float)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-tpl-fan-two tpl-fan-two tpl-fan-two-lod0-jg tpl-fan-two-idle-ja
              ((tpl-fan-two-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(defstate idle (tpl-fan-two)
  :virtual #t
  :enter (behavior ()
    (set! (-> self start-timef) (the float (current-time)))
    (set! (-> self next-sound) (the float (current-time)))
    )
  :trans (behavior ()
    (let ((f0-2 (lerp-scale 91022.22 (-> self cycle-time) (-> self clock clock-ratio) 1.0 0.05)))
      0.0
      (+! (-> self start-timef) (* f0-2 (seconds-per-frame)))
      )
    (let ((f30-0 (- (-> self start-timef) (-> self cycle-offset))))
      (let ((a2-2 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *z-vector* (+ -3640.889 f30-0))))
        (quaternion*! (-> self root quat) (-> self quat) a2-2)
        )
      (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
      (let ((f0-11
              (lerp-scale
                1.0
                0.0
                (fabs (vector-dot (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> self root trans)) *z-vector*))
                20480.0
                81920.0
                )
              )
            )
        (when (< (-> self next-sound) f30-0)
          (+! (-> self next-sound) 32768.0)
          (if (and (!= f0-11 0.0) (< -40960.0 (- (-> (target-pos 0) y) (-> self root trans y))))
              (sound-play-by-name
                (static-sound-name "fan-whsh-fast")
                (new-sound-id)
                1024
                (the int (* 1524.0 (lerp-scale 0.0 -0.3 (-> self clock clock-ratio) 1.0 0.05)))
                0
                (sound-group)
                (-> self root trans)
                )
              )
          )
        )
      )
    (rider-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (rider-post)
    )
  )

(defmethod init-from-entity! ((this tpl-fan-two) (arg0 entity-actor))
  (local-vars (sv-16 int))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-fan-two" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (quaternion-copy! (-> this quat) (-> this root quat))
  (let ((f28-0 720.0)
        (f30-0 0.0)
        )
    (set! sv-16 0)
    (let ((v1-22 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (the-as (pointer res-tag) (& sv-16)))))
      (when v1-22
        (set! f28-0 (-> v1-22 0))
        (set! f30-0 (-> v1-22 1))
        )
      )
    (set! (-> this cycle-time) (* 182.04445 f28-0))
    (set! (-> this cycle-offset) (* 182.04445 f30-0))
    )
  (set! (-> this draw light-index) (the-as uint 5))
  (go (method-of-object this idle))
  )

(deftype tpl-fan-three (process-drawable)
  ((quat          quaternion  :inline)
   (cycle-time    float)
   (cycle-offset  float)
   (start-timef   float)
   (next-sound    float)
   (last-sound    float)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-tpl-fan-three tpl-fan-three tpl-fan-three-lod0-jg tpl-fan-three-idle-ja
              ((tpl-fan-three-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(defstate idle (tpl-fan-three)
  :virtual #t
  :enter (behavior ()
    (set! (-> self start-timef) (the float (current-time)))
    (set! (-> self next-sound) (the float (current-time)))
    )
  :trans (behavior ()
    (let ((f0-2 (lerp-scale 91022.22 (-> self cycle-time) (-> self clock clock-ratio) 1.0 0.05)))
      0.0
      (+! (-> self start-timef) (* f0-2 (seconds-per-frame)))
      )
    (let ((f30-0 (- (-> self start-timef) (-> self cycle-offset))))
      (let ((a2-2 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *z-vector* (+ 10922.667 f30-0))))
        (quaternion*! (-> self root quat) (-> self quat) a2-2)
        )
      (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
      (let ((f0-11
              (lerp-scale
                1.0
                0.0
                (fabs (vector-dot (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> self root trans)) *z-vector*))
                20480.0
                81920.0
                )
              )
            )
        (when (< (-> self next-sound) f30-0)
          (+! (-> self next-sound) 21845.334)
          (if (and (!= f0-11 0.0) (< -40960.0 (- (-> (target-pos 0) y) (-> self root trans y))))
              (sound-play-by-name
                (static-sound-name "fan-whsh-fast")
                (new-sound-id)
                1024
                (the int (* 1524.0 (lerp-scale 0.0 -0.7 (-> self clock clock-ratio) 1.0 0.05)))
                0
                (sound-group)
                (-> self root trans)
                )
              )
          )
        )
      )
    (rider-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (rider-post)
    )
  )

(defmethod init-from-entity! ((this tpl-fan-three) (arg0 entity-actor))
  (local-vars (sv-16 int))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-fan-three" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (quaternion-copy! (-> this quat) (-> this root quat))
  (let ((f28-0 720.0)
        (f30-0 0.0)
        )
    (set! sv-16 0)
    (let ((v1-22 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (the-as (pointer res-tag) (& sv-16)))))
      (when v1-22
        (set! f28-0 (-> v1-22 0))
        (set! f30-0 (-> v1-22 1))
        )
      )
    (set! (-> this cycle-time) (* 182.04445 f28-0))
    (set! (-> this cycle-offset) (* 182.04445 f30-0))
    )
  (set! (-> this draw light-index) (the-as uint 5))
  (go (method-of-object this idle))
  )

(deftype tpl-break-alcove (process-drawable)
  ((root          collide-shape :override)
   (alt-actor     entity-actor)
   (extra-id      uint32)
   (perm          uint32)
   (part-explode  sparticle-launch-control)
   (spawn-part    sparticle-launch-control)
   )
  (:state-methods
    idle
    closed
    die-fast
    )
  )


(defskelgroup skel-tpl-break-alcove tpl-break-alcove tpl-break-alcove-lod0-jg tpl-break-alcove-idle-ja
              ((tpl-break-alcove-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 8 0 30)
              )

(defstate idle (tpl-break-alcove)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (sound-play "door-break")
    (set! (-> self spawn-part) (the-as sparticle-launch-control #t))
    )
  :code (behavior ()
    (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-0 (res-lump-struct (-> self entity) 'on-exit structure)))
      (if gp-0
          (script-eval (the-as pair gp-0))
          )
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 1))
        (suspend)
        )
      )
    (cleanup-for-death self)
    (deactivate self)
    )
  :post (behavior ()
    (when (-> self spawn-part)
      (set! (-> self spawn-part) #f)
      (let ((gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
        (matrix<-trans gp-0 (-> self root trans))
        (spawn-from-mat (-> self part-explode) gp-0)
        )
      )
    (transform-post)
    )
  )

(defstate closed (tpl-break-alcove)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((v1-1 (the-as attack-info (-> block param 1))))
         (if (or (= (-> v1-1 mode) 'dark-smack) (and (logtest? (attack-mask penetrate-using) (-> v1-1 mask))
                                                     (logtest? (penetrate dark-smack) (-> v1-1 penetrate-using))
                                                     )
                 )
             (go-virtual idle)
             )
         )
       )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (let ((gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
      (matrix<-trans gp-0 (-> self root trans))
      (spawn-from-mat (-> self part) gp-0)
      )
    (transform-post)
    )
  )

(defstate die-fast (tpl-break-alcove)
  :virtual #t
  :code (behavior ()
    (suspend)
    (process-entity-status! self (entity-perm-status dead) #t)
    )
  )

(defmethod deactivate ((this tpl-break-alcove))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  (if (nonzero? (-> this part-explode))
      (kill-particles (-> this part-explode))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs tpl-break-alcove.
(defmethod relocate ((this tpl-break-alcove) (offset int))
  (if (nonzero? (-> this part-explode))
      (&+! (-> this part-explode) offset)
      )
  (the-as tpl-break-alcove ((method-of-type process-drawable relocate) this offset))
  )

(defmethod init-from-entity! ((this tpl-break-alcove) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 2)
      (set-vector! (-> s3-0 local-sphere) 0.0 32768.0 0.0 32768.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this entity) arg0)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-break-alcove" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this draw light-index) (the-as uint 10))
  (set! (-> this alt-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this extra-id) (res-lump-value (-> this entity) 'extra-id uint :time -1000000000.0))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 675) this))
  (set! (-> this part-explode) (create-launch-control (-> *part-group-id-table* 676) this))
  (let ((s5-1 (res-lump-struct (-> this entity) 'on-activate structure)))
    (if (and s5-1 (not (script-eval (the-as pair s5-1))))
        (go (method-of-object this die-fast))
        )
    )
  (go (method-of-object this closed))
  )

(defskelgroup skel-tpl-break-door-a tpl-break-door-a tpl-break-door-a-lod0-jg tpl-break-door-a-idle-ja
              ((tpl-break-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 8 0 30)
              )

(deftype tpl-break-door-a (process-drawable)
  ((root          collide-shape :override)
   (alt-actor     entity-actor)
   (extra-id      uint32)
   (perm          uint32)
   (part-explode  sparticle-launch-control)
   (spawn-part    sparticle-launch-control)
   )
  (:state-methods
    idle
    closed
    die-fast
    )
  )


(defstate idle (tpl-break-door-a)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (sound-play "door-break")
    (set! (-> self spawn-part) (the-as sparticle-launch-control #t))
    )
  :code (behavior ()
    (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-0 (res-lump-struct (-> self entity) 'on-exit structure)))
      (if gp-0
          (script-eval (the-as pair gp-0))
          )
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 1))
        (suspend)
        )
      )
    (cleanup-for-death self)
    (deactivate self)
    )
  :post (behavior ()
    (when (-> self spawn-part)
      (set! (-> self spawn-part) #f)
      (let ((gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
        (matrix<-trans gp-0 (-> self root trans))
        (spawn-from-mat (-> self part-explode) gp-0)
        )
      )
    (transform-post)
    )
  )

(defstate closed (tpl-break-door-a)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack 'attack-invinc)
       (let ((v1-2 (the-as attack-info (-> block param 1))))
         (if (or (= (-> v1-2 mode) 'dark-smack) (and (logtest? (attack-mask penetrate-using) (-> v1-2 mask))
                                                     (logtest? (penetrate dark-smack) (-> v1-2 penetrate-using))
                                                     )
                 )
             (go-virtual idle)
             )
         )
       )
      )
    )
  :code (behavior ()
    (sound-play "door-break")
    (ja-channel-push! 1 0)
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (let ((gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
      (matrix<-trans gp-0 (-> self root trans))
      (spawn-from-mat (-> self part) gp-0)
      )
    (transform-post)
    )
  )

(defstate die-fast (tpl-break-door-a)
  :virtual #t
  :code (behavior ()
    (suspend)
    (process-entity-status! self (entity-perm-status dead) #t)
    )
  )

(defmethod deactivate ((this tpl-break-door-a))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  (if (nonzero? (-> this part-explode))
      (kill-particles (-> this part-explode))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs tpl-break-door-a.
(defmethod relocate ((this tpl-break-door-a) (offset int))
  (if (nonzero? (-> this part-explode))
      (&+! (-> this part-explode) offset)
      )
  (the-as tpl-break-door-a ((method-of-type process-drawable relocate) this offset))
  )

(defmethod init-from-entity! ((this tpl-break-door-a) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 2)
      (set-vector! (-> s3-0 local-sphere) 0.0 40960.0 0.0 40960.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (set! (-> this entity) arg0)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tpl-break-door-a" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this alt-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this extra-id) (res-lump-value (-> this entity) 'extra-id uint :time -1000000000.0))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 673) this))
  (set! (-> this part-explode) (create-launch-control (-> *part-group-id-table* 674) this))
  (let ((s5-1 (res-lump-struct (-> this entity) 'on-activate structure)))
    (if (and s5-1 (not (script-eval (the-as pair s5-1))))
        (go (method-of-object this die-fast))
        )
    )
  (set! (-> this spawn-part) #f)
  (go (method-of-object this closed))
  )
