;;-*-Lisp-*-
(in-package goal)

;; name: tizard.gc
;; name in dgo: tizard
;; dgos: WWD

;; DECOMP BEGINS

(deftype tizard (process-focusable)
  ((rotation-matrix  matrix  :inline)
   (ground-normal    vector  2 :inline)
   (path-dir         vector  :inline)
   (path-base-u      float)
   (path-u           float)
   (path-du          float)
   (first-run?       symbol)
   )
  (:state-methods
    idle
    walk
    turn
    turning
    die
    )
  (:methods
    (tizard-method-33 (_type_) none)
    (tizard-method-34 (_type_) none)
    (tizard-method-35 (_type_) none)
    )
  )


(defskelgroup skel-tizard tizard tizard-lod0-jg tizard-idle-ja
              ((tizard-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              :shadow tizard-shadow-mg
              )

(defbehavior tizard-event-handler tizard ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (go-virtual die)
     )
    )
  )

(defstate idle (tizard)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (dotimes (gp-0 2)
      (vector-y-quaternion! (-> self ground-normal gp-0) (-> self root quat))
      )
    (let ((v1-8 (-> self draw shadow-ctrl)))
      (logior! (-> v1-8 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :exit (behavior ()
    (let ((v1-1 (-> self draw shadow-ctrl)))
      (logclear! (-> v1-1 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (seconds 0.5))
             (< (vector-vector-xz-distance (target-pos 0) (-> self root trans)) 204800.0)
             )
        (go-virtual walk)
        )
    )
  :code (behavior ()
    (when (-> self first-run?)
      (let ((gp-0 (the int (* 300.0 (rand-vu-float-range 0.05 0.12)))))
        (suspend-for gp-0
          )
        )
      (set! (-> self path-base-u) (the float (rand-vu-int-count (-> self path curve num-cverts))))
      (get-point-in-path! (-> self path) (-> self root trans) (-> self path-base-u) 'interp)
      (tizard-method-34 self)
      (let ((gp-1 (new 'stack-no-clear 'vector)))
        (displacement-between-two-points-normalized! (-> self path) gp-1 (-> self path-base-u))
        (forward-up-nopitch->quaternion (-> self root quat) gp-1 (-> self path-dir))
        )
      (quaternion->matrix (-> self rotation-matrix) (-> self root quat))
      (ja-channel-set! 1)
      (ja-no-eval :group! tizard-walk0-ja :num! zero)
      (transform-post)
      (suspend)
      (set! (-> self first-run?) #f)
      )
    (sleep-code)
    )
  )

(defstate walk (tizard)
  :virtual #t
  :event tizard-event-handler
  :enter (behavior ()
    (set! (-> self path-u) 0.0)
    (let ((gp-0 (-> self path))
          (f28-0 (-> self path-base-u))
          )
      (set! (-> self path-du)
            (* 2.0 (/ 24576.0 (vector-vector-distance
                                (get-point-in-path! gp-0 (new 'stack-no-clear 'vector) f28-0 'interp)
                                (get-point-in-path! gp-0 (new 'stack-no-clear 'vector) (+ 1.0 f28-0) 'interp)
                                )
                      )
               )
            )
      )
    )
  :trans (behavior ()
    (when (>= (-> self path-u) 1.0)
      (tizard-method-33 self)
      (go-virtual turn)
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (until #f
      (ja-no-eval :group! tizard-walk0-ja :num! (seek! max 4.0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 4.0))
        )
      )
    #f
    )
  :post (behavior ()
    (if *display-path-marks*
        (debug-draw (-> self path))
        )
    (get-point-in-path! (-> self path) (-> self root trans) (+ (-> self path-base-u) (-> self path-u)) 'interp)
    (tizard-method-34 self)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (displacement-between-two-points-normalized! (-> self path) gp-0 (+ (-> self path-base-u) (-> self path-u)))
      (let ((s5-0 (new 'stack-no-clear 'quaternion)))
        (quaternion-from-two-vectors-partial! s5-0 (-> self rotation-matrix fvec) gp-0 (* 4.0 (seconds-per-frame)))
        (vector-orient-by-quat! gp-0 (-> self rotation-matrix fvec) s5-0)
        )
      (forward-up-nopitch->quaternion (-> self root quat) gp-0 (-> self path-dir))
      )
    (quaternion->matrix (-> self rotation-matrix) (-> self root quat))
    (seek! (-> self path-u) 1.0 (* (-> self path-du) (seconds-per-frame)))
    (tizard-method-35 self)
    (transform-post)
    )
  )

(defstate turn (tizard)
  :virtual #t
  :event tizard-event-handler
  :code (behavior ()
    (let ((gp-0 (the int (* 300.0 (rand-vu-float-range 1.0 2.0)))))
      (suspend-for gp-0
        )
      )
    (if (< 17294.223 (acos (vector-dot (-> self rotation-matrix fvec) (-> self path-dir))))
        (go-virtual turning)
        )
    (go-virtual walk)
    )
  :post (behavior ()
    (tizard-method-34 self)
    (forward-up-nopitch->quaternion (-> self root quat) (-> self rotation-matrix fvec) (-> self path-dir))
    (quaternion->matrix (-> self rotation-matrix) (-> self root quat))
    (tizard-method-35 self)
    (ja-post)
    )
  )

(defstate turning (tizard)
  :virtual #t
  :event tizard-event-handler
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let* ((gp-0 (-> self root quat))
           (s4-0 (-> self rotation-matrix))
           (s5-0 (> (the int (vector-dot (-> self path-dir) (-> s4-0 rvec))) 0))
           (f30-0 (acos (vector-dot (-> self path-dir) (-> s4-0 fvec))))
           (s4-1
             (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) (-> s4-0 uvec) (* 30720.0 (seconds-per-frame)))
             )
           (s3-0 (quaternion-conjugate! (new 'stack-no-clear 'quaternion) s4-1))
           )
      (quaternion-normalize! s4-1)
      (quaternion-normalize! s3-0)
      (dotimes (s2-0 (the int (/ f30-0 (meters 4))))
        (cond
          (s5-0
            (ja-no-eval :group! tizard-turn-left0-ja :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (quaternion*! gp-0 s4-1 gp-0)
              (suspend)
              (ja :num! (seek!))
              )
            )
          (else
            (ja-no-eval :group! tizard-turn-right0-ja :num! (seek!) :frame-num 0.0)
            (until (ja-done? 0)
              (quaternion*! gp-0 s3-0 gp-0)
              (suspend)
              (ja :num! (seek!))
              )
            )
          )
        (quaternion-normalize! gp-0)
        )
      )
    (go-virtual walk)
    )
  :post (behavior ()
    (tizard-method-34 self)
    (forward-up-nopitch->quaternion (-> self root quat) (-> self rotation-matrix fvec) (-> self path-dir))
    (quaternion->matrix (-> self rotation-matrix) (-> self root quat))
    (ja-post)
    )
  )

(defstate die (tizard)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('death-end)
       (if (-> self skel effect)
           (logior! (-> self skel effect flags) (effect-control-flag ecf2))
           )
       (let ((v0-0 (logior (-> self draw status) (draw-control-status no-draw))))
         (set! (-> self draw status) v0-0)
         v0-0
         )
       )
      )
    )
  :code (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self focus-status) (focus-status dead))
    (when (-> self skel effect)
      (logior! (-> self skel effect flags) (effect-control-flag ecf1))
      (do-effect (-> self skel effect) "death-default" 0.0 -1)
      )
    (ja-channel-push! 1 (seconds 0.02))
    (ja-no-eval :group! tizard-walk0-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (ja-post)
      (suspend)
      (ja :num! (seek!))
      )
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defmethod tizard-method-33 ((this tizard))
  (let ((f30-0 (+ 1.0 (-> this path-base-u)))
        (v1-2 (get-num-segments (-> this path)))
        )
    (set! (-> this path-base-u) (- f30-0 (* (the float (the int (/ f30-0 v1-2))) v1-2)))
    )
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (get-point-in-path! (-> this path) s5-0 (+ 1.0 (-> this path-base-u)) 'interp)
    (vector-! s4-0 s5-0 (-> this root trans))
    (vector-normalize-copy! (-> this path-dir) s4-0 1.0)
    )
  0
  (none)
  )

(defmethod tizard-method-34 ((this tizard))
  (local-vars
    (sv-592 collide-query)
    (sv-596 (inline-array sphere))
    (sv-600 vector)
    (sv-604 matrix)
    (sv-608 pat-surface)
    )
  (set! sv-592 (new 'stack-no-clear 'collide-query))
  (let ((s5-0 (new 'stack-no-clear 'inline-array 'sphere 2)))
    (dotimes (s4-0 2)
      ((method-of-type sphere new) (the-as symbol (-> s5-0 s4-0)) sphere)
      )
    (set! sv-596 s5-0)
    )
  (set! sv-600 (-> this root trans))
  (set! sv-604 (-> this rotation-matrix))
  (set! sv-608 (new 'static 'pat-surface :noentity #x1 :probe #x1 :noendlessfall #x1))
  (vector+float*! (the-as vector (-> sv-596 0)) sv-600 (-> sv-604 fvec) 4096.0)
  (set! (-> sv-596 0 r) 10240.0)
  (vector+float*! (the-as vector (-> sv-596 1)) sv-600 (-> sv-604 fvec) -4096.0)
  (set! (-> sv-596 1 r) 10240.0)
  (let ((v1-19 sv-592))
    (set! (-> v1-19 best-dist) (the-as float sv-596))
    (set! (-> v1-19 best-other-prim) (the-as collide-shape-prim 2))
    (set! (-> v1-19 collide-with) (collide-spec backgnd obstacle))
    (set! (-> v1-19 ignore-process0) this)
    (set! (-> v1-19 ignore-process1) #f)
    (set! (-> v1-19 ignore-pat) sv-608)
    (set! (-> v1-19 best-my-prim) (the-as collide-shape-prim #t))
    (set! (-> v1-19 action-mask) (collide-action solid))
    )
  (fill-using-spheres *collide-cache* sv-592)
  (vector-reset! (-> this path-dir))
  (dotimes (s5-1 2)
    (let ((f0-4 819.2))
      (let ((v1-26 (-> this ground-normal s5-1)))
        (vector+float*! (-> sv-592 start-pos) (the-as vector (-> sv-596 s5-1)) (-> this ground-normal s5-1) 8192.0)
        (vector-float*! (-> sv-592 move-dist) v1-26 -16384.0)
        )
      (let ((v1-27 sv-592))
        (set! (-> v1-27 radius) f0-4)
        (set! (-> v1-27 collide-with) (collide-spec backgnd obstacle))
        (set! (-> v1-27 ignore-process0) #f)
        (set! (-> v1-27 ignore-process1) #f)
        (set! (-> v1-27 ignore-pat) sv-608)
        (set! (-> v1-27 action-mask) (collide-action solid))
        )
      )
    (let ((f0-5 (probe-using-line-sphere *collide-cache* sv-592)))
      (when (>= f0-5 0.0)
        (let ((v1-31 (new 'stack-no-clear 'vector))
              (s4-1 (new 'stack-no-clear 'vector))
              )
          (vector+float*! v1-31 (-> sv-592 start-pos) (-> sv-592 move-dist) f0-5)
          (vector-! s4-1 v1-31 (-> sv-592 best-other-tri intersect))
          (vector-normalize! s4-1 1.0)
          (let ((s3-0 (new 'stack-no-clear 'quaternion)))
            (quaternion-from-two-vectors-partial! s3-0 (-> this ground-normal s5-1) s4-1 (* 4.0 (seconds-per-frame)))
            (vector-orient-by-quat! (-> this ground-normal s5-1) (-> this ground-normal s5-1) s3-0)
            )
          )
        0
        )
      )
    (let ((s4-2 (new 'stack-no-clear 'quaternion)))
      (quaternion-from-two-vectors-partial!
        s4-2
        (-> this ground-normal s5-1)
        (-> sv-604 uvec)
        (* 3.0 (seconds-per-frame))
        )
      (vector-orient-by-quat! (-> this ground-normal s5-1) (-> this ground-normal s5-1) s4-2)
      )
    (vector+! (-> this path-dir) (-> this path-dir) (-> this ground-normal s5-1))
    )
  (vector-normalize! (-> this path-dir) 1.0)
  0
  (none)
  )

;; WARN: Return type mismatch int vs search-info-flag.
(defmethod process-mask->search-info-flag ((this tizard))
  (the-as search-info-flag 8)
  )

(defmethod tizard-method-35 ((this tizard))
  (when (-> this draw shadow-ctrl)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (let ((s4-0 (new 'stack-no-clear 'quaternion)))
        (quaternion-from-two-vectors-max-angle! s4-0 *y-vector* (-> this rotation-matrix uvec) 8192.0)
        (vector-orient-by-quat! s5-0 *y-vector* s4-0)
        )
      (vector-normalize! s5-0 1.0)
      (vector-negate! s5-0 s5-0)
      (shadow-control-method-14
        (-> this draw shadow-ctrl)
        (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data 3))
        s5-0
        24576.0
        -8192.0
        16384.0
        )
      )
    )
  (none)
  )

(defun tizard-tilt-jmod-func ((arg0 cspace) (arg1 transformq))
  (local-vars (sv-32 tizard) (sv-36 int) (sv-40 quaternion))
  (set! sv-32 (the-as tizard (-> arg0 param1)))
  (set! sv-36 (the-as int (-> arg0 param2)))
  (set! sv-40 (new 'stack-no-clear 'quaternion))
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (let ((s2-0 (-> (the-as tizard sv-32) root quat)))
      (vector-inv-orient-by-quat! s4-0 (-> (the-as tizard sv-32) rotation-matrix uvec) s2-0)
      (vector-inv-orient-by-quat! s3-0 (-> (the-as tizard sv-32) ground-normal sv-36) s2-0)
      )
    (quaternion-from-two-vectors! sv-40 s4-0 s3-0)
    )
  (quaternion-normalize! sv-40)
  (quaternion*! (-> arg1 quat) (-> arg1 quat) sv-40)
  (quaternion-normalize! (-> arg1 quat))
  (cspace<-parented-transformq-joint! arg0 arg1)
  0
  (none)
  )

(defmethod run-logic? ((this tizard))
  "Should this process be run? Checked by execute-process-tree."
  (or (-> this first-run?) (< (vector-vector-xz-distance (target-pos 0) (-> this root trans)) 245760.0))
  )

(defmethod init-from-entity! ((this tizard) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list projectile))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 8192.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tizard" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this path) (new 'process 'path-control this 'wall 0.0 (-> this entity) #f))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this path-base-u) 0.0)
  (let ((a0-14 (-> this node-list data 4)))
    (set! (-> a0-14 param0) tizard-tilt-jmod-func)
    (set! (-> a0-14 param1) this)
    (set! (-> a0-14 param2) (the-as basic 0))
    )
  (let ((v1-17 (-> this node-list data 13)))
    (set! (-> v1-17 param0) tizard-tilt-jmod-func)
    (set! (-> v1-17 param1) this)
    (set! (-> v1-17 param2) (the-as basic 1))
    )
  (logior! (-> this skel status) (joint-control-status sync-math))
  (set! (-> this draw shadow-ctrl) (new
                                     'process
                                     'shadow-control
                                     -4096.0
                                     4096.0
                                     614400.0
                                     (the-as vector #f)
                                     (shadow-flags shdf00 shdf04)
                                     245760.0
                                     )
        )
  (set! (-> this first-run?) #t)
  (go (method-of-object this idle))
  )
