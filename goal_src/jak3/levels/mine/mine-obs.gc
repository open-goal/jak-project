;;-*-Lisp-*-
(in-package goal)

;; name: mine-obs.gc
;; name in dgo: mine-obs
;; dgos: MIA

;; DECOMP BEGINS

(defun mineb-activate ()
  (local-vars (sv-16 res-tag))
  (let ((a0-1 (entity-by-name "minb-part-1")))
    (when a0-1
      (let ((gp-0 (the-as (pointer actor-group) #f))
            (s5-0 0)
            )
        (set! sv-16 (new 'static 'res-tag))
        (let ((v1-2 (res-lump-data a0-1 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
          (when (and v1-2 (nonzero? (-> sv-16 elt-count)))
            (set! gp-0 v1-2)
            (set! s5-0 (the-as int (-> sv-16 elt-count)))
            )
          )
        (when (> s5-0 0)
          (dotimes (s5-1 (-> gp-0 0 length))
            (let ((a0-7 (-> gp-0 0 data s5-1 actor)))
              (if a0-7
                  (toggle-status a0-7 (entity-perm-status subtask-complete) #t)
                  )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(deftype rat-light-manager (process)
  ((actor-group        (pointer actor-group))
   (actor-group-count  int32)
   )
  (:state-methods
    idle
    )
  (:methods
    (rat-light-manager-method-15 (_type_ int int symbol) none)
    (rat-light-manager-method-16 (_type_ int symbol) none)
    )
  )


(defstate idle (rat-light-manager)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('enter)
       (rat-light-manager-method-16 self (command-get-int (-> block param 0) 0) #t)
       )
      (('exit)
       (rat-light-manager-method-16 self (command-get-int (-> block param 0) 0) #f)
       )
      )
    )
  :code sleep-code
  )

(defmethod run-logic? ((this rat-light-manager))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defmethod rat-light-manager-method-15 ((this rat-light-manager) (arg0 int) (arg1 int) (arg2 symbol))
  (let ((v1-5 (-> this actor-group 0 data arg0 actor extra perm)))
    (logior! (-> v1-5 status) (entity-perm-status bit-5))
    (set! (-> v1-5 user-object 0) (if arg2
                                      1
                                      0
                                      )
          )
    (if arg2
        (set-mineb-lights! arg1 (if (logtest? (-> v1-5 status) (entity-perm-status subtask-complete))
                                    1.0
                                    0.0
                                    )
                           )
        )
    )
  0
  (none)
  )

(defmethod rat-light-manager-method-16 ((this rat-light-manager) (arg0 int) (arg1 symbol))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (if arg1
           (rat-light-manager-method-15 this 0 0 #t)
           )
       )
      ((= v1-0 1)
       (if arg1
           (rat-light-manager-method-15 this 1 1 #t)
           )
       )
      ((= v1-0 2)
       (if arg1
           (rat-light-manager-method-15 this 2 2 #t)
           )
       )
      ((= v1-0 3)
       (cond
         (arg1
           (rat-light-manager-method-15 this 0 0 #f)
           (rat-light-manager-method-15 this 3 0 #t)
           )
         (else
           (rat-light-manager-method-15 this 0 0 #t)
           (rat-light-manager-method-15 this 3 0 #f)
           )
         )
       )
      ((= v1-0 4)
       (cond
         (arg1
           (rat-light-manager-method-15 this 1 1 #f)
           (rat-light-manager-method-15 this 4 1 #t)
           )
         (else
           (rat-light-manager-method-15 this 1 1 #t)
           (rat-light-manager-method-15 this 4 1 #f)
           )
         )
       )
      )
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this rat-light-manager) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-1 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-1 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-1))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (dotimes (s5-0 5)
    (rat-light-manager-method-16 this s5-0 #f)
    )
  (go (method-of-object this idle))
  )

(deftype min-rat-engine (process-drawable)
  ((root                collide-shape-moving :override)
   (init-quat           quaternion            :inline)
   (force-pos           vector                :inline)
   (actor-group         (pointer actor-group))
   (actor-group-count   int32)
   (rot-speed           float)
   (ang-momentum        float)
   (rat-timer           time-frame)
   (notify-actor        entity-actor)
   (sound-id            sound-id)
   (rat-sound-id        sound-id)
   (rat-wheel-sound-id  sound-id)
   (light-index         uint32)
   (light-target        float)
   (wheel-angle         float)
   (wheel-sound-volume  float)
   (last-turn-time      time-frame)
   (rat-count           uint32)
   )
  (:state-methods
    inactive
    active
    running
    shutdown
    )
  (:methods
    (min-rat-engine-method-24 (_type_) none)
    (min-rat-engine-method-25 (_type_) none)
    (min-rat-engine-method-26 (_type_ float float float float) symbol)
    (min-rat-engine-method-27 (_type_ process focus) none)
    (min-rat-engine-method-28 (_type_) none)
    )
  )


(defskelgroup skel-min-rat-engine min-rat-engine min-rat-engine-lod0-jg min-rat-engine-idle-ja
              ((min-rat-engine-lod0-mg (meters 20)) (min-rat-engine-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 3 11)
              :origin-joint-index 5
              )

;; WARN: Return type mismatch collide-shape vs none.
(defmethod min-rat-engine-method-24 ((this min-rat-engine))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s4-0 local-sphere) 0.0 4096.0 0.0 45056.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid rideable))
      (set! (-> v1-8 transform-index) 6)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 9011.2 30720.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) -13516.8 6553.6 -16384.0 9830.4)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) -1638.4 13926.4 -13926.4 22118.4)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 13516.8 40960.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  (none)
  )

(defbehavior min-rat-engine-handler min-rat-engine ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('ridden)
     (min-rat-engine-method-27 self arg0 (the-as focus (-> arg3 param 0)))
     )
    (('inside?)
     (if (min-rat-engine-method-26 self (the-as float arg0) 25395.2 21299.2 8192.0)
         #t
         )
     )
    (('near?)
     (if (min-rat-engine-method-26 self (the-as float arg0) 30720.0 24780.8 32768.0)
         #t
         )
     )
    (('wait-pos)
     (let ((s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node min-rat-engine-lod0-jg ratrotation)))
           (v1-7 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self init-quat)))
           )
       (vector+float*! (the-as vector (-> arg3 param 0)) s5-0 v1-7 32768.0)
       )
     )
    (('run-dir)
     (vector-normalize!
       (vector-cross!
         (the-as vector (-> arg3 param 0))
         *y-vector*
         (vector-z-quaternion! (the-as vector (-> arg3 param 0)) (-> self root quat))
         )
       1.0
       )
     )
    (('run-pos)
     (let* ((s2-0 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node min-rat-engine-lod0-jg ratrotation)))
            (s1-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self init-quat)))
            (s5-2 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self init-quat)))
            (s3-2 (vector-flatten!
                    (new 'stack-no-clear 'vector)
                    (vector-! (new 'stack-no-clear 'vector) (the-as vector (-> arg3 param 0)) s2-0)
                    s1-0
                    )
                  )
            (gp-0 (the-as object (-> arg3 param 1)))
            )
       (let ((f30-0 2.0))
         (vector+float*! (the-as vector gp-0) s2-0 s1-0 12288.0)
         (+! (-> s3-2 y) -8192.0)
         (vector-normalize! s3-2 20480.0)
         (vector+! (the-as vector gp-0) (the-as vector gp-0) s3-2)
         (vector+float*!
           (the-as vector gp-0)
           (the-as vector gp-0)
           s5-2
           (* 4096.0
              (+ 0.3
                 (* 1.5 (sin (* 65536.0 (/ (the float (mod (current-time) (the int (* 300.0 f30-0)))) (* 300.0 f30-0)))))
                 )
              )
           )
         )
       gp-0
       )
     )
    (('run-up)
     (let* ((a0-28 (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node min-rat-engine-lod0-jg ratrotation)))
            (a1-26 (vector-flatten!
                     (new 'stack-no-clear 'vector)
                     (vector-! (new 'stack-no-clear 'vector) (the-as vector (-> arg3 param 0)) a0-28)
                     (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
                     )
                   )
            )
       (vector-normalize-copy! (the-as vector (-> arg3 param 1)) a1-26 -1.0)
       )
     )
    )
  )

(defbehavior min-rat-engine-post min-rat-engine ()
  (let ((v1-2 (-> self entity extra perm)))
    (when (logtest? (-> v1-2 status) (entity-perm-status bit-5))
      (if (= (-> v1-2 user-object 0) 1)
          (set-mineb-lights! (the-as int (-> self light-index)) (-> self light-target))
          )
      )
    )
  (min-rat-engine-method-28 self)
  (min-rat-engine-method-25 self)
  (rider-post)
  (none)
  )

(defstate inactive (min-rat-engine)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual running)
       )
      (('turn)
       (go-virtual running)
       )
      (('claim-wheel?)
       (let ((v1-6 (+ (-> self rat-count) 1)))
         (set! (-> self rat-count) v1-6)
         (= v1-6 1)
         )
       )
      (else
        (min-rat-engine-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self force-pos quad) (-> self root trans quad))
    )
  :trans (behavior ()
    (if (< (vector-vector-xz-distance (target-pos 0) (-> self root trans)) 204800.0)
        (go-virtual active)
        )
    )
  :code sleep-code
  :post (behavior ()
    (min-rat-engine-method-28 self)
    (if (< 0.0 (-> self ang-momentum))
        (ja-post)
        )
    )
  )

(defstate active (min-rat-engine)
  :virtual #t
  :event (-> (method-of-type min-rat-engine inactive) event)
  :trans (behavior ()
    (set! (-> self force-pos quad) (-> self root trans quad))
    (rider-trans)
    (if (< 245760.0 (vector-vector-xz-distance (target-pos 0) (-> self root trans)))
        (go-virtual inactive)
        )
    )
  :code (behavior ()
    (sleep-code)
    )
  :post (behavior ()
    (min-rat-engine-post)
    )
  )

(defstate running (min-rat-engine)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('turn)
       (let ((f0-0 2.0))
         (seek!
           (-> self ang-momentum)
           (* 8192.0
              (+ -91.68
                 (* 16.68 (sin (* 65536.0 (/ (the float (mod (current-time) (the int (* 300.0 f0-0)))) (* 300.0 f0-0)))))
                 )
              )
           (* 409600.0 (seconds-per-frame))
           )
         )
       (let ((v0-2 (the-as object (current-time))))
         (set! (-> self last-turn-time) (the-as time-frame v0-2))
         v0-2
         )
       )
      (('running?)
       #t
       )
      (else
        (min-rat-engine-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self rot-speed) 0.0)
    (set-time! (-> self state-time))
    (set-time! (-> self last-turn-time))
    (logior! (-> self entity extra perm status) (entity-perm-status subtask-complete))
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'trigger)
      (let ((t9-0 send-event-function)
            (v1-10 (-> self notify-actor))
            )
        (t9-0
          (if v1-10
              (-> v1-10 extra process)
              )
          a1-0
          )
        )
      )
    (dotimes (gp-0 (+ (-> self actor-group-count) -1))
      (let ((s5-0 (-> self actor-group gp-0)))
        (dotimes (s4-0 (-> s5-0 length))
          (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-1 from) (process->ppointer self))
            (set! (-> a1-1 num-params) 0)
            (set! (-> a1-1 message) 'trigger)
            (let ((t9-1 send-event-function)
                  (v1-19 (-> s5-0 data s4-0 actor))
                  )
              (t9-1
                (if v1-19
                    (-> v1-19 extra process)
                    )
                a1-1
                )
              )
            )
          )
        )
      )
    (let ((v1-32 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 3)))
      (set! (-> v1-32 prim-core action) (collide-action solid))
      (set! (-> v1-32 prim-core collide-as) (collide-spec obstacle camera-blocker))
      )
    (sound-play "rat-wheel-raise")
    (set! (-> self wheel-sound-volume) 0.0)
    )
  :trans (behavior ()
    (rider-trans)
    (if (time-elapsed? (-> self last-turn-time) (seconds 0.5))
        (go-virtual shutdown)
        )
    )
  :code (behavior ()
    (ja-no-eval :group! min-rat-engine-raise-ja :num! (seek! max 0.04) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.04))
      )
    (when (not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status bit-13))))
      (if (res-lump-struct (-> self entity) 'camera-name structure)
          (process-spawn
            external-camera-controller
            (-> self entity)
            1200
            #f
            :name "external-camera-controller"
            :to *entity-pool*
            )
          )
      (process-entity-status! self (entity-perm-status bit-13) #t)
      )
    (let ((gp-1 (+ (-> self actor-group-count) -1)))
      (dotimes (s5-0 (-> self actor-group gp-1 length))
        (toggle-status
          (the-as entity-actor (-> self actor-group gp-1 data s5-0 actor))
          (entity-perm-status subtask-complete)
          #f
          )
        )
      )
    (until #f
      (ja-no-eval :group! min-rat-engine-spin-ja :num! (seek! max 0.4) :frame-num 0.0)
      (until (ja-done? 0)
        (seek! (-> self light-target) 1.0 (seconds-per-frame))
        (let ((gp-2 (-> self actor-group (+ (-> self actor-group-count) -1))))
          (dotimes (s5-1 (-> gp-2 length))
            (let ((a1-10 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-10 from) (process->ppointer self))
              (set! (-> a1-10 num-params) 0)
              (set! (-> a1-10 message) 'start)
              (let ((t9-11 send-event-function)
                    (v1-70 (-> gp-2 data s5-1 actor))
                    )
                (t9-11
                  (if v1-70
                      (-> v1-70 extra process)
                      )
                  a1-10
                  )
                )
              )
            )
          )
        (suspend)
        (ja :num! (seek! max 0.4))
        )
      )
    #f
    )
  :post (behavior ()
    (sound-play "rat-whl-squeak" :id (-> self rat-sound-id))
    (sound-play-by-name
      (static-sound-name "rat-wheel-gear")
      (-> self rat-wheel-sound-id)
      (the int (* 1024.0 (-> self wheel-sound-volume)))
      0
      0
      (sound-group)
      #t
      )
    (seek! (-> self wheel-sound-volume) 1.0 (* 2.0 (seconds-per-frame)))
    (min-rat-engine-post)
    )
  )

(defstate shutdown (min-rat-engine)
  :virtual #t
  :event min-rat-engine-handler
  :enter (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 3)))
      (set! (-> v1-3 prim-core action) (collide-action))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      )
    0
    )
  :trans rider-trans
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja-no-eval :group! min-rat-engine-lower-ja :num! (seek! max 0.03) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.03))
      )
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (go-virtual inactive)
    )
  :post (behavior ()
    (seek! (-> self wheel-sound-volume) 1.0 (* 2.0 (seconds-per-frame)))
    (min-rat-engine-post)
    )
  )

;; WARN: Return type mismatch sound-id vs none.
(defmethod min-rat-engine-method-25 ((this min-rat-engine))
  (if (!= (-> this ang-momentum) 0.0)
      (sound-play-by-name
        (static-sound-name "rat-wheel-loop")
        (-> this sound-id)
        (the int (* 1024.0 (lerp-scale 0.0 1.0 (fabs (-> this ang-momentum)) 0.0 409600.0)))
        (the int (* 1524.0 (lerp-scale -1.0 0.0 (fabs (-> this ang-momentum)) 0.0 409600.0)))
        0
        (sound-group)
        #t
        )
      )
  (none)
  )

(defmethod min-rat-engine-method-27 ((this min-rat-engine) (arg0 process) (arg1 focus))
  (when (= arg0 this)
    (let ((a2-1 (handle->process (-> arg1 handle))))
      (if a2-1
          (set! (-> this force-pos quad) (-> (the-as process-focusable a2-1) root trans quad))
          )
      )
    )
  0
  (none)
  )

(defmethod min-rat-engine-method-28 ((this min-rat-engine))
  (let ((a0-2 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> this init-quat)))
        (v1-1 (vector-! (new 'stack-no-clear 'vector) (-> this force-pos) (-> this root trans)))
        )
    (+! (-> this ang-momentum) (* 10.0 (seconds-per-frame) (- (vector-dot a0-2 v1-1))))
    )
  (set! (-> this wheel-angle)
        (the float
             (sar
               (shl
                 (the int (+ (-> this wheel-angle) (* 182.04445 (seconds-per-frame) (* 0.00024414062 (-> this ang-momentum)))))
                 48
                 )
               48
               )
             )
        )
  (set! (-> this ang-momentum) (* 0.99 (-> this ang-momentum)))
  0
  (none)
  )

(defmethod min-rat-engine-method-26 ((this min-rat-engine) (arg0 float) (arg1 float) (arg2 float) (arg3 float))
  (with-pp
    (let ((v1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> v1-0 from) (process->ppointer pp))
      (set! (-> v1-0 num-params) 1)
      (set! (-> v1-0 message) 'trans)
      (set! (-> v1-0 param 0) (the-as uint (new 'stack-no-clear 'vector)))
      (let ((s2-0 (send-event-function (the-as process-tree arg0) v1-0)))
        (when s2-0
          (let* ((s1-0 (-> this root trans))
                 (a2-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
                 (a1-4 (vector-! (new 'stack-no-clear 'vector) (the-as vector s2-0) s1-0))
                 (f30-0 (vector-dot a1-4 a2-2))
                 (s3-1 (vector-flatten! (new 'stack-no-clear 'vector) a1-4 a2-2))
                 )
            (and (< 0.0 f30-0)
                 (< f30-0 arg1)
                 (< (vector-length s3-1) arg2)
                 (< (cos arg3) (fabs (vector-dot s3-1 (vector-negate! (new 'stack-no-clear 'vector) *y-vector*))))
                 )
            )
          )
        )
      )
    )
  )

(defmethod deactivate ((this min-rat-engine))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (-> this sound-id))
  (sound-stop (-> this rat-sound-id))
  (sound-stop (-> this rat-wheel-sound-id))
  (call-parent-method this)
  (none)
  )

(defun joint-mod-rat-engine-callback ((arg0 cspace) (arg1 transformq))
  (let ((v1-0 (-> arg0 param1)))
    (quaternion-rotate-z! (-> arg1 quat) (-> arg1 quat) (-> (the-as min-rat-engine v1-0) wheel-angle))
    )
  (cspace<-parented-transformq-joint! arg0 arg1)
  (none)
  )

(defmethod init-from-entity! ((this min-rat-engine) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (min-rat-engine-method-24 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-min-rat-engine" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (let ((a0-5 (-> this skel root-channel 0)))
    (set! (-> a0-5 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group! a0-5 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
    )
  (transform-post)
  (set! (-> this notify-actor) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-14 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-14 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-14))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (let ((a0-10 (-> this node-list data 6)))
    (set! (-> a0-10 param0) joint-mod-rat-engine-callback)
    (set! (-> a0-10 param1) this)
    )
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this rat-sound-id) (new-sound-id))
  (set! (-> this rat-wheel-sound-id) (new-sound-id))
  (set! (-> this light-index) (res-lump-value (-> this entity) 'extra-id uint :time -1000000000.0))
  (set! (-> this light-target)
        (if (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
            1.0
            0.0
            )
        )
  (set! (-> this wheel-angle) 0.0)
  (set! (-> this rat-count) (the-as uint 0))
  (set! (-> this ang-momentum) 0.0)
  (quaternion-copy! (-> this init-quat) (-> this root quat))
  (go (method-of-object this inactive))
  )

(deftype min-crane (process-drawable)
  ()
  (:state-methods
    idle
    )
  (:methods
    (min-crane-method-21 (_type_) none)
    )
  )


(defskelgroup skel-min-crane min-crane min-crane-lod0-jg min-crane-idle-ja
              ((min-crane-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 12)
              :origin-joint-index 3
              )

(defstate idle (min-crane)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defmethod min-crane-method-21 ((this min-crane))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 9) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 10))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 82.7392 -16090.727 1494.6304 47322.727)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 6)
      (set-vector! (-> v1-8 local-sphere) 8350.516 3842.048 -22282.24 10069.197)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 6)
      (set-vector! (-> v1-10 local-sphere) 8350.516 3842.048 -1823.9489 10069.197)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 5)
      (set-vector! (-> v1-12 local-sphere) 8362.394 -8660.173 -23385.293 18361.959)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 5)
      (set-vector! (-> v1-14 local-sphere) 8362.394 -8660.173 -2926.592 18361.959)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) 9)
      (set-vector! (-> v1-16 local-sphere) -8350.516 -3841.2288 22282.24 10069.197)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 9)
      (set-vector! (-> v1-18 local-sphere) -8350.516 -3841.2288 1823.9489 10069.197)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) 8)
      (set-vector! (-> v1-20 local-sphere) -8362.394 8660.173 23385.293 18361.959)
      )
    (let ((v1-22 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 7) (the-as uint 0))))
      (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-22 prim-core action) (collide-action solid))
      (set! (-> v1-22 transform-index) 8)
      (set-vector! (-> v1-22 local-sphere) -8362.394 8660.173 2926.592 18361.959)
      )
    (let ((v1-24 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 8) (the-as uint 0))))
      (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-24 prim-core action) (collide-action solid))
      (set! (-> v1-24 transform-index) 4)
      (set-vector! (-> v1-24 local-sphere) 0.0 -4455.629 0.0 23633.51)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-27 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this min-crane) (arg0 entity-actor))
  (min-crane-method-21 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-min-crane" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  )

(deftype min-target-sign (mine-platform-base)
  ((off-part        sparticle-launch-control)
   (on-part         sparticle-launch-control)
   (track-pos       vector  :inline)
   (alt-actor       entity-actor)
   (touched-train?  symbol)
   )
  (:state-methods
    dormant
    idle
    lowering
    idle-down
    )
  (:methods
    (spawn-on-off-part (_type_ symbol) object)
    )
  )


(defskelgroup skel-min-target-sign min-target-sign min-target-sign-lod0-jg min-target-sign-idle-ja
              ((min-target-sign-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 3 22)
              )

;; WARN: Return type mismatch symbol vs object.
(defbehavior target-sign-event-handler min-target-sign ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('down?)
     (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete))
     )
    )
  )

(defstate dormant (min-target-sign)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object) eco-door-event-handler)
  :enter (behavior ()
    (setup-masks (-> self draw) 4 10)
    )
  :trans (behavior ()
    (if (task-node-open? (game-task-node mine-blow-resolution))
        (go-virtual idle)
        )
    )
  :code sleep-code
  )

(defstate idle (min-target-sign)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (-> block param 1)
       (let ((gp-0 (the-as touching-shapes-entry (-> block param 0))))
         (cond
           (gp-0
             (let ((s5-0 (-> gp-0 head)))
               (while s5-0
                 (let ((v1-5 (get-touched-prim s5-0 (-> self root) gp-0)))
                   (when (= (-> v1-5 prim-id) #x7400e700)
                     (sound-play "target-hit")
                     (go-virtual lowering)
                     )
                   )
                 (set! s5-0 (-> s5-0 next))
                 )
               )
             #f
             )
           (else
             (sound-play "target-hit")
             (go-virtual lowering)
             )
           )
         )
       )
      (('hit)
       (logior! (-> self entity extra perm status) (entity-perm-status subtask-complete))
       (go-virtual lowering)
       )
      (else
        (target-sign-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self mask) (process-mask enemy))
    (setup-masks (-> self draw) 8 6)
    )
  :trans (behavior ()
    (let ((a0-0 (-> self state parent)))
      (when a0-0
        (let ((t9-0 (-> a0-0 trans)))
          (if t9-0
              (t9-0)
              )
          )
        )
      )
    (spawn-on-off-part self #f)
    )
  :code transform-and-sleep-code
  )

(defstate lowering (min-target-sign)
  :virtual #t
  :parent (min-target-sign plat-base-state)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (when (send-event proc 'go-explode)
         (let ((v0-1 (the-as object #t)))
           (set! (-> self touched-train?) (the-as symbol v0-1))
           v0-1
           )
         )
       )
      (else
        (target-sign-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (setup-masks (-> self draw) 2 12)
    )
  :trans (behavior ()
    (when (>= 2.75 (ja-frame-num 0))
      (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-0 options) (overlaps-others-options))
        (set! (-> a1-0 collide-with-filter) (the-as collide-spec -1))
        (set! (-> a1-0 tlist) *touching-list*)
        (find-overlapping-shapes (-> self root) a1-0)
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (let ((gp-0 0))
      (ja-no-eval :group! min-target-sign-trackdown-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (let ((f30-0 (ja-frame-num 0))
              (s5-0 (ja-num-frames 0))
              )
          (when (and (< 2.75 f30-0)
                     (not (-> self touched-train?))
                     (not (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
                     )
            (logior! (-> self entity extra perm status) (entity-perm-status subtask-complete))
            (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-2 from) (process->ppointer self))
              (set! (-> a1-2 num-params) 0)
              (set! (-> a1-2 message) 'rail-down)
              (let ((t9-4 send-event-function)
                    (v1-27 (-> self alt-actor))
                    )
                (t9-4
                  (if v1-27
                      (-> v1-27 extra process)
                      )
                  a1-2
                  )
                )
              )
            )
          (when (< gp-0 (the int f30-0))
            (if (= (the int f30-0) (+ s5-0 -13))
                (sound-play "track-fall")
                )
            )
          )
        (set! gp-0 (the int (ja-frame-num 0)))
        (spawn-on-off-part self #t)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-virtual idle-down)
    )
  )

(defstate idle-down (min-target-sign)
  :virtual #t
  :parent (min-target-sign plat-base-state)
  :event target-sign-event-handler
  :trans (behavior ()
    (let ((a0-0 (-> self state parent)))
      (when a0-0
        (let ((t9-0 (-> a0-0 trans)))
          (if t9-0
              (t9-0)
              )
          )
        )
      )
    (spawn-on-off-part self #t)
    )
  :code (behavior ()
    (ja :group! min-target-sign-idleb-ja :num! none :frame-num 0.0)
    (transform-and-sleep-code)
    )
  )

(defmethod spawn-on-off-part ((this min-target-sign) (arg0 symbol))
  (spawn
    (if arg0
        (-> this on-part)
        (-> this off-part)
        )
    (-> this node-list data 15 bone transform trans)
    )
  (spawn
    (if arg0
        (-> this on-part)
        (-> this off-part)
        )
    (-> this node-list data 16 bone transform trans)
    )
  )

;; WARN: Return type mismatch mine-platform-base vs min-target-sign.
(defmethod relocate ((this min-target-sign) (offset int))
  (if (nonzero? (-> this off-part))
      (&+! (-> this off-part) offset)
      )
  (if (nonzero? (-> this on-part))
      (&+! (-> this on-part) offset)
      )
  (the-as min-target-sign ((method-of-type mine-platform-base relocate) this offset))
  )

(defmethod deactivate ((this min-target-sign))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this off-part))
      (kill-particles (-> this off-part))
      )
  (if (nonzero? (-> this on-part))
      (kill-particles (-> this on-part))
      )
  ((method-of-type mine-platform-base deactivate) this)
  (none)
  )

(defmethod get-skel ((this min-target-sign))
  (art-group-get-by-name *level* "skel-min-target-sign" (the-as (pointer level) #f))
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod init-collision! ((this min-target-sign))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 5) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 6))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak obstacle hit-by-others-list player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set! (-> s4-0 transform-index) 14)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 24576.0 69632.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-11 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-with) (collide-spec obstacle hit-by-others-list))
      (set! (-> v1-11 prim-core action) (collide-action))
      (set! (-> v1-11 transform-index) 14)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 49152.0 32768.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set! (-> v1-13 transform-index) 14)
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 38912.0 53248.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 -20480.0 4096.0 24576.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint #x7400e700))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core action) (collide-action))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 10240.0 -23756.8 1228.8 10240.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint #x7400e700))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core action) (collide-action))
      (set! (-> v1-19 transform-index) 3)
      (set-vector! (-> v1-19 local-sphere) -10240.0 -23756.8 1228.8 10240.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (set! (-> this root event-self) 'touched)
  (none)
  )

;; WARN: Return type mismatch structure vs vector.
(defmethod get-trans ((this min-target-sign) (arg0 int))
  "Get the `trans` for this process."
  (the-as vector (cond
                   ((= arg0 3)
                    (let* ((s4-0 (-> this root))
                           (gp-0 (-> s4-0 root-prim))
                           )
                      (if (< 0.0 (vector-dot
                                   (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> s4-0 trans))
                                   (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> s4-0 quat))
                                   )
                             )
                          (-> (the-as collide-shape-prim-group gp-0) child 3 prim-core)
                          (-> (the-as collide-shape-prim-group gp-0) child 4 prim-core)
                          )
                      )
                    )
                   (else
                     ((method-of-type process-focusable get-trans) this arg0)
                     )
                   )
          )
  )

;; WARN: Return type mismatch int vs search-info-flag.
(defmethod process-mask->search-info-flag ((this min-target-sign))
  (let ((v0-0 0))
    (if (and (-> this next-state) (= (-> this next-state name) 'idle))
        (set! v0-0 (logior v0-0 40))
        )
    (the-as search-info-flag v0-0)
    )
  )

(defmethod init-from-entity! ((this min-target-sign) (arg0 entity-actor))
  (let ((t9-0 (method-of-type mine-platform-base init-from-entity!)))
    (t9-0 this arg0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this off-part) (create-launch-control (-> *part-group-id-table* 598) this))
  (set! (-> this on-part) (create-launch-control (-> *part-group-id-table* 599) this))
  (set! (-> this alt-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> this touched-train?) #f)
  (let ((v1-11 (-> *game-info* sub-task-list (game-task-node mine-blow-resolution))))
    (when (and v1-11 (< (the-as uint 2) (-> v1-11 death-count)))
      (let ((f0-1 (/ 1.0 (- 1.0 (* 0.04 (the float (max 0 (min 5 (the-as int (+ (-> v1-11 death-count) -2)))))))))
            (v1-15 (the-as collide-shape-prim-group (-> this root root-prim)))
            )
        (set! (-> v1-15 child 3 local-sphere w) (* (-> v1-15 child 3 local-sphere w) f0-1))
        (set! (-> v1-15 child 4 local-sphere w) (* (-> v1-15 child 4 local-sphere w) f0-1))
        )
      )
    )
  (cond
    ((or (task-node-closed? (game-task-node mine-blow-resolution))
         (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
         )
     (let ((a0-23 (-> this skel root-channel 0)))
       (set! (-> a0-23 frame-group) (the-as art-joint-anim (-> this draw art-group data 5)))
       (set! (-> a0-23 frame-num) 0.0)
       (joint-control-channel-group-eval!
         a0-23
         (the-as art-joint-anim (-> this draw art-group data 5))
         num-func-none
         )
       )
     (ja-post)
     (go (method-of-object this idle-down))
     )
    ((task-node-open? (game-task-node mine-blow-resolution))
     (let ((a0-25 (-> this skel root-channel 0)))
       (set! (-> a0-25 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
       (set! (-> a0-25 frame-num) 1.0)
       (joint-control-channel-group-eval!
         a0-25
         (the-as art-joint-anim (-> this draw art-group data 3))
         num-func-none
         )
       )
     (ja-post)
     (go (method-of-object this idle))
     )
    (else
      (let ((a0-26 (-> this skel root-channel 0)))
        (set! (-> a0-26 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
        (set! (-> a0-26 frame-num) 0.0)
        (joint-control-channel-group-eval!
          a0-26
          (the-as art-joint-anim (-> this draw art-group data 2))
          num-func-none
          )
        )
      (ja-post)
      (go (method-of-object this dormant))
      )
    )
  )

(deftype min-bomb-elevator (elevator)
  ((alt-actor          entity-actor)
   (bomb-train-offset  float)
   (wheel-angle        float)
   )
  )


(defskelgroup skel-min-bomb-elevator min-bomb-elevator min-bomb-elevator-lod0-jg min-bomb-elevator-idle-ja
              ((min-bomb-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              )

(defstate waiting (min-bomb-elevator)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (process-grab? *target* #f)
       )
      )
    ((-> (method-of-type elevator waiting) event) proc argc message block)
    )
  :post (behavior ()
    (let ((t9-0 (-> (method-of-type elevator waiting) post)))
      (if t9-0
          ((the-as (function none) t9-0))
          )
      )
    (when (task-node-closed? (game-task-node mine-blow-elevator))
      (send-event self 'jump-to 'top)
      (go-virtual dormant)
      )
    )
  )

(defstate running (min-bomb-elevator)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'music #f 0.0 0)
    (let ((t9-1 (-> (method-of-type elevator running) enter)))
      (if t9-1
          (t9-1)
          )
      )
    )
  :post (behavior ()
    (let ((t9-0 (-> (method-of-type elevator running) post)))
      (if t9-0
          ((the-as (function none) t9-0))
          )
      )
    (let* ((a0-0 (-> self alt-actor))
           (v1-4 (if a0-0
                     (-> a0-0 extra process)
                     )
                 )
           )
      (if v1-4
          (set! (-> (the-as process-drawable v1-4) root trans y) (+ (-> self root trans y) (-> self bomb-train-offset)))
          )
      )
    )
  )

(defstate arrived (min-bomb-elevator)
  :virtual #t
  :enter (behavior ()
    (remove-setting! 'music)
    (let ((t9-1 (-> (method-of-type elevator arrived) enter)))
      (if t9-1
          (t9-1)
          )
      )
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1))
        (suspend)
        )
      )
    (let ((a1-0 (new 'stack-no-clear 'array 'symbol 3)))
      (set! (-> a1-0 2) 'mine6)
      (set! (-> a1-0 1) 'mine5)
      (set! (-> a1-0 0) 'mine4)
      (want-sound-banks *load-state* a1-0)
      )
    (go-virtual dormant)
    )
  )

(defun min-bomb-elevator-callback ((arg0 cspace) (arg1 transformq))
  (let ((v1-0 (the-as min-bomb-elevator (-> arg0 param1))))
    (when (and (-> v1-0 next-state) (= (-> v1-0 next-state name) 'running))
      (set! (-> v1-0 wheel-angle)
            (the float
                 (sar (shl (the int (+ (-> v1-0 wheel-angle) (* -0.52040726 (seconds-per-frame) (-> v1-0 speed)))) 48) 48)
                 )
            )
      (quaternion-rotate-local-x! (-> arg1 quat) (-> arg1 quat) (-> v1-0 wheel-angle))
      (cspace<-parented-transformq-joint! arg0 arg1)
      )
    )
  0
  (none)
  )

(defmethod get-art-group ((this min-bomb-elevator))
  (art-group-get-by-name *level* "skel-min-bomb-elevator" (the-as (pointer level) #f))
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-collision! ((this min-bomb-elevator))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 11) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 12))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 204800.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 3)
      (set-vector! (-> v1-13 local-sphere) 61.0304 4443.7505 -46.6944 153172.38)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 30.72 13204.275 -46.6944 137356.9)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) -7494.0415 18259.148 -1234.1248 130382.234)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-19 prim-core action) (collide-action solid rideable))
      (set! (-> v1-19 transform-index) 3)
      (set-vector! (-> v1-19 local-sphere) 13039.616 18259.148 -1234.1248 130382.234)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-21 prim-core action) (collide-action solid rideable))
      (set! (-> v1-21 transform-index) 3)
      (set-vector! (-> v1-21 local-sphere) -51408.895 58564.61 -18715.443 124619.984)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-23 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-23 prim-core action) (collide-action solid rideable))
      (set! (-> v1-23 transform-index) 3)
      (set-vector! (-> v1-23 local-sphere) 51921.305 58564.61 -18715.443 124619.984)
      )
    (let ((v1-25 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-25 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-25 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-25 prim-core action) (collide-action solid rideable))
      (set! (-> v1-25 transform-index) 3)
      (set-vector! (-> v1-25 local-sphere) 56478.926 37066.344 -122880.0 32969.113)
      )
    (let ((v1-27 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 7) (the-as uint 0))))
      (set! (-> v1-27 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-27 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-27 prim-core action) (collide-action solid rideable))
      (set! (-> v1-27 transform-index) 3)
      (set-vector! (-> v1-27 local-sphere) -56412.98 37066.344 -122880.0 32969.113)
      )
    (let ((v1-29 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 8) (the-as uint 0))))
      (set! (-> v1-29 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-29 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-29 prim-core action) (collide-action solid rideable))
      (set! (-> v1-29 transform-index) 3)
      (set-vector! (-> v1-29 local-sphere) -78.2336 100379.03 -123167.945 81738.14)
      )
    (let ((v1-31 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 9) (the-as uint 0))))
      (set! (-> v1-31 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-31 prim-core collide-with) (collide-spec jak bot player-list pusher))
      (set! (-> v1-31 prim-core action) (collide-action solid rideable))
      (set! (-> v1-31 transform-index) 3)
      (set-vector! (-> v1-31 local-sphere) -78.2336 39539.918 -123167.945 50748.62)
      )
    (let ((v1-34 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 10) (the-as uint (shl #xfe00 16)))))
      (set! (-> v1-34 prim-core action) (collide-action solid))
      (set! (-> v1-34 transform-index) 3)
      (set-vector! (-> v1-34 local-sphere) 0.0 0.0 0.0 204800.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-37 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-37 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-37 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch sound-spec vs none.
(defmethod base-plat-method-34 ((this min-bomb-elevator))
  (set! (-> this bounce-scale) 0.0)
  (set! (-> this alt-actor) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (if (-> this alt-actor)
      (set! (-> this bomb-train-offset) (- (-> this alt-actor extra trans y) (-> this entity extra trans y)))
      )
  (let ((v1-9 (-> this skel root-channel 0)))
    (set! (-> v1-9 frame-group) (if (> (-> this skel active-channels) 0)
                                    (-> this skel root-channel 0 frame-group)
                                    )
          )
    )
  (ja-post)
  (let ((a0-7 (-> this node-list data 4)))
    (set! (-> a0-7 param0) min-bomb-elevator-callback)
    (set! (-> a0-7 param1) this)
    (set! (-> a0-7 param2) (the-as basic 0))
    )
  (set! (-> this sound-running-loop) (static-sound-spec "mine-elev-start" :group 0))
  (set! (-> this sound-arrived) (static-sound-spec "mine-elev-stop" :group 0))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-arrived-or-waiting ((this min-bomb-elevator))
  (if (task-node-closed? (game-task-node mine-blow-introduction))
      (go (method-of-object this waiting))
      )
  (go (method-of-object this dormant))
  (none)
  )

(deftype min-elev-doors (process-drawable)
  ()
  (:state-methods
    idle
    open
    opened
    )
  (:methods
    (min-elev-doors-method-23 (_type_) none)
    )
  )


(defskelgroup skel-min-elev-doors min-elev-doors min-elev-doors-lod0-jg min-elev-doors-idle-ja
              ((min-elev-doors-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              )

(defstate idle (min-elev-doors)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual open)
       )
      (('open?)
       #f
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post transform-post
  )

(defstate open (min-elev-doors)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('open?)
       #t
       )
      )
    )
  :code (behavior ()
    (sound-play "mine-door")
    (ja-no-eval :group! min-elev-doors-open-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (go-virtual opened)
    )
  :post transform-post
  )

(defstate opened (min-elev-doors)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('open?)
       #t
       )
      )
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! min-elev-doors-open-ja :num! (identity (the float (ja-num-frames 0))))
    (transform-post)
    (sleep-code)
    )
  )

(defmethod min-elev-doors-method-23 ((this min-elev-doors))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 409600.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 -40960.0 184320.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 40960.0 184320.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this min-elev-doors) (arg0 entity-actor))
  (min-elev-doors-method-23 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-min-elev-doors" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (if (or (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
          (task-node-open? (game-task-node mine-blow-resolution))
          )
      (go (method-of-object this opened))
      )
  (go (method-of-object this idle))
  )

(deftype min-crane-switch (basebutton)
  ((rog  handle)
   )
  )


(defskelgroup skel-min-crane-switch min-crane-switch min-crane-switch-lod0-jg min-crane-switch-idle-ja
              ((min-crane-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defstate down-idle (min-crane-switch)
  :virtual #t
  :code (behavior ()
    (sound-play "floor-switch")
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 0.5))
        (suspend)
        )
      )
    (when (not (task-node-closed? (game-task-node mine-blow-introduction)))
      (let ((a1-1 (new 'stack-no-clear 'array 'symbol 3)))
        (set! (-> a1-1 2) 'mine6)
        (set! (-> a1-1 1) 'mine5)
        (set! (-> a1-1 0) 'mine10)
        (want-sound-banks *load-state* a1-1)
        )
      (suspend)
      (process-spawn scene-player :init scene-player-init "mine-train-intro" #t #f :name "scene-player")
      )
    (sleep-code)
    )
  )

(defstate up-idle (min-crane-switch)
  :virtual #t
  :exit (behavior ()
    (send-event (handle->process (-> self rog)) 'leave)
    (let ((t9-1 (-> (method-of-type basebutton up-idle) exit)))
      (if t9-1
          (t9-1)
          )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton up-idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (when (and (or (task-node-closed? (game-task-node mine-explore-armor))
                   (and (kiosk?) (task-node-open? (game-task-node mine-explore-armor)))
                   )
               (= (-> self rog) #f)
               )
      (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
        (set! (-> gp-0 pos quad) (-> self root trans quad))
        (quaternion-identity! (-> gp-0 quat))
        (set! (-> gp-0 flags) (task-arrow-flags taf8))
        (set! (-> gp-0 map-icon) (the-as uint 13))
        (set! (-> self rog) (process->handle (task-arrow-spawn gp-0 self)))
        )
      )
    )
  )

(defmethod init-collision! ((this min-crane-switch))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 4096.0 0.0 8192.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 3072.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 3686.4 1843.2 5324.8)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-skel-and-ja! ((this min-crane-switch))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-min-crane-switch" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> this button-status) (button-status pressed))
     (let ((s5-1 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> this draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> this draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (set! (-> this anim-speed) 2.0)
  (set! (-> this rog) (the-as handle #f))
  (transform-post)
  (none)
  )

(defmethod prepare-trigger-event! ((this min-crane-switch))
  (logior! (-> this button-status) (button-status button-status-3))
  0
  (none)
  )

(deftype min-door (process-drawable)
  ()
  (:state-methods
    idle
    exploded
    )
  (:methods
    (min-door-method-22 (_type_) none)
    (min-door-method-23 (_type_) none)
    )
  )


(defskelgroup skel-min-door min-door min-door-lod0-jg min-door-idle-ja
              ((min-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 25)
              )

(defskelgroup skel-min-door-break min-door-break min-door-break-lod0-jg min-door-break-idle-ja
              ((min-door-break-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100)
              :origin-joint-index 3
              )

(defstate idle (min-door)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('subtask-complete)
       (process-entity-status! self (entity-perm-status subtask-complete) #t)
       )
      )
    )
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (transform-and-sleep)
    )
  )

(defstate exploded (min-door)
  :virtual #t
  :code (behavior ()
    (ja :group! (ja-group) :num! min)
    (transform-and-sleep)
    )
  )

(defmethod min-door-method-22 ((this min-door))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 143360.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 143360.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 81920.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod min-door-method-23 ((this min-door))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 163840.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 38912.0 0.0 102400.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) -71680.0 -51200.0 71680.0 40960.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) -61440.0 -51200.0 0.0 61440.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 40960.0 -40960.0 20480.0 81920.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this min-door) (arg0 entity-actor))
  (cond
    ((or (task-node-closed? (game-task-node mine-blow-resolution))
         (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete))
         )
     (min-door-method-23 this)
     (process-drawable-from-entity! this arg0)
     (initialize-skeleton
       this
       (the-as skeleton-group (art-group-get-by-name *level* "skel-min-door-break" (the-as (pointer level) #f)))
       (the-as pair 0)
       )
     (go (method-of-object this exploded))
     )
    (else
      (min-door-method-22 this)
      (process-drawable-from-entity! this arg0)
      (initialize-skeleton
        this
        (the-as skeleton-group (art-group-get-by-name *level* "skel-min-door" (the-as (pointer level) #f)))
        (the-as pair 0)
        )
      (go (method-of-object this idle))
      )
    )
  )

(deftype min-elec-gate (elec-gate)
  ()
  )


(defmethod elec-gate-method-30 ((this min-elec-gate) (arg0 float))
  (let ((v1-1 (level-get *level* 'minec)))
    (when v1-1
      (let ((v1-2 (-> v1-1 mood-context state)))
        (set! (-> v1-2 3) (the-as uint arg0))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs object.
(defmethod go-initial-state ((this min-elec-gate))
  (if (task-node-closed? (game-task-node mine-blow-elevator))
      ((method-of-type elec-gate go-initial-state) this)
      (go (method-of-object this idle))
      )
  0
  )

(deftype min-boss-elev (elevator)
  ((going-down?          symbol)
   (sound-rotating-loop  sound-spec)
   )
  )


(defskelgroup skel-min-boss-elev min-boss-elev min-boss-elev-lod0-jg min-boss-elev-idle-ja
              ((min-boss-elev-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(defstate dormant (min-boss-elev)
  :virtual #t
  :enter (behavior ()
    (quaternion-copy! (-> self root quat) (-> self entity quat))
    )
  )

(defstate running (min-boss-elev)
  :virtual #t
  :post (behavior ()
    (let ((gp-0 (-> self root quat))
          (s5-0 (-> self entity quat))
          )
      (quaternion-pseudo-seek gp-0 gp-0 s5-0 0.005)
      (if (nonzero? (-> self sound-rotating-loop))
          (sound-play-by-spec (-> self sound-rotating-loop) (-> self sound-id) (-> self root trans))
          )
      (cond
        ((< 0.9999976 (fabs (-> (quaternion*!
                                  (new 'stack-no-clear 'quaternion)
                                  (quaternion-inverse! (new 'stack-no-clear 'quaternion) gp-0)
                                  s5-0
                                  )
                                w
                                )
                            )
            )
         (when (not (-> self going-down?))
           (set! (-> self going-down?) #t)
           (sound-stop (-> self sound-id))
           (set! (-> self sound-id) (new-sound-id))
           )
         (let ((t9-6 (-> (method-of-type elevator running) post)))
           (if t9-6
               ((the-as (function none) t9-6))
               )
           )
         )
        (else
          (move-post)
          )
        )
      )
    )
  )

(defmethod get-art-group ((this min-boss-elev))
  (art-group-get-by-name *level* "skel-min-boss-elev" (the-as (pointer level) #f))
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-collision! ((this min-boss-elev))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 2))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 61440.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch sound-spec vs none.
(defmethod base-plat-method-34 ((this min-boss-elev))
  (set! (-> this bounce-scale) 0.0)
  (quaternion-rotate-y! (-> this root quat) (-> this root quat) -11468.8)
  (set! (-> this going-down?) #f)
  (set! (-> this sound-running-loop) (static-sound-spec "boss-elev" :group 0))
  (set! (-> this sound-rotating-loop) (static-sound-spec "platform-turn" :group 0))
  (set! (-> this sound-arrived) (static-sound-spec "boss-elev-end" :group 0))
  (none)
  )

(defskelgroup skel-min-airlock-door min-airlock-door min-airlock-door-lod0-jg min-airlock-door-idle-ja
              ((min-airlock-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 10 0 20)
              )

(deftype min-airlock-door (com-airlock)
  ()
  )


(defmethod init-from-entity! ((this min-airlock-door) (arg0 entity-actor))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 40960.0 0.0 102400.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 51200.0 40960.0 0.0 61440.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) -51200.0 40960.0 0.0 61440.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-min-airlock-door" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-airlock! this)
  (set! (-> this open-frame) 30.0)
  (set! (-> this sound-open) (static-sound-spec "mine-door2" :group 0))
  (set! (-> this sound-close) (static-sound-spec "mine-door2" :group 0))
  (go (method-of-object this close) #t)
  )

(deftype mine-music-manager (task-manager)
  ()
  )


;; WARN: Return type mismatch connection vs none.
(defmethod set-time-limit ((this mine-music-manager))
  ((method-of-type task-manager set-time-limit) this)
  (set-setting! 'music 'minexplr 0.0 0)
  (none)
  )
