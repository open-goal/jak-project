;;-*-Lisp-*-
(in-package goal)

;; name: manta.gc
;; name in dgo: manta
;; dgos: MIA

;; +++manta-flags
(defenum manta-flags
  :type uint16
  :bitfield #t
  (mf0 0)
  (mf1 1)
  )
;; ---manta-flags


;; DECOMP BEGINS

(deftype manta (nav-enemy)
  ((info                      rigid-body-object-constants)
   (move-matrix               matrix  :inline)
   (curve-matrix              matrix  :inline)
   (move-vel                  vector  :inline)
   (move-u                    float)
   (move-du                   float)
   (move-force                float)
   (flags                     manta-flags)
   (go-enable                 symbol)
   (orbit-speed               float)
   (max-time-step             float)
   (gravity                   float)
   (landed-pos                vector  :inline)
   (dest-pos                  vector  :inline)
   (attack-pos                vector  :inline)
   (up-dir                    vector  :inline)
   (forward-dir               vector  :inline)
   (knocked-force             vector  :inline)
   (knocked-force-mult        float)
   (default-y-offset          float)
   (y-offset                  float)
   (last-attack-time          time-frame)
   (attack-y-offset           float)
   (attack-path-blocked-time  time-frame)
   (track-timer               time-frame)
   (angle-to-player           float)
   (offset-difference         float)
   (sound-volume              float)
   (restart-fly-anims         symbol)
   (fly-anim-speed            float)
   (hit-ground-count          uint32)
   (fade-level                float)
   (pad                       uint8   8)
   )
  (:state-methods
    land-approach
    land
    notice-to-fly
    attack
    attack-end
    )
  (:methods
    (manta-method-195 (_type_) none)
    (manta-method-196 (_type_) symbol)
    (manta-method-197 (_type_) none)
    (manta-method-198 (_type_) none)
    (manta-method-199 (_type_) none)
    (manta-method-200 (_type_) none)
    (manta-method-201 (_type_ float) none)
    (do-impact (_type_) none)
    (manta-method-203 (_type_ float) none)
    (manta-method-204 (_type_) none)
    (update-target-pos! (_type_) none)
    (manta-method-206 (_type_) none)
    (alloc-rbody! (_type_ rigid-body-object-constants) none)
    (manta-method-208 (_type_) none)
    )
  )


(define *manta-rigid-body-constants* (new 'static 'rigid-body-object-constants
                                       :info (new 'static 'rigid-body-info
                                         :mass 1.5
                                         :inv-mass 0.6666667
                                         :linear-damping 0.97
                                         :angular-damping 0.94
                                         :bounce-factor 0.75
                                         :friction-factor 0.99
                                         :cm-offset-joint (new 'static 'vector :w 1.0)
                                         :inertial-tensor-box (new 'static 'array meters 3 (meters 2.5) (meters 5) (meters 2.5))
                                         )
                                       :extra (new 'static 'rigid-body-object-extra-info
                                         :max-time-step 0.033333335
                                         :gravity (meters 20)
                                         :idle-distance (meters 200)
                                         :attack-force-scale 2.0
                                         )
                                       :name '*manta-rigid-body-constants*
                                       )
        )

(defskelgroup skel-manta manta manta-lod0-jg manta-idle0-ja
              ((manta-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              :shadow manta-shadow-mg
              :shadow-joint-index 3
              )

(define *fact-info-manta-defaults*
  (new 'static 'fact-info-enemy-defaults :idle-distance (meters 80) :pickup-type 9)
  )

(define *manta-nav-enemy-info* (new 'static 'nav-enemy-info
                                 :use-die-falling #t
                                 :use-victory #f
                                 :use-jump-blocked #f
                                 :debug-draw-neck #f
                                 :jump-debug-draw #f
                                 :move-to-ground #f
                                 :hover-if-no-ground #t
                                 :idle-anim-script #f
                                 :idle-anim 3
                                 :notice-anim 5
                                 :hostile-anim 8
                                 :hit-anim 13
                                 :knocked-anim 13
                                 :knocked-land-anim 13
                                 :die-anim 19
                                 :die-falling-anim 17
                                 :victory-anim 3
                                 :jump-wind-up-anim -1
                                 :jump-in-air-anim -1
                                 :jump-land-anim -1
                                 :neck-joint 6
                                 :look-at-joint 6
                                 :bullseye-joint 3
                                 :sound-hit (static-sound-name "manta-impact")
                                 :notice-distance (meters 60)
                                 :notice-distance-delta (meters 10)
                                 :proximity-notice-distance (meters 15)
                                 :default-hit-points 3.0
                                 :gnd-collide-with (collide-spec backgnd)
                                 :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
                                 :friction 0.8
                                 :attack-shove-back (meters 3)
                                 :attack-shove-up (meters 2)
                                 :attack-mode 'generic
                                 :attack-damage 2
                                 :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
                                 :knocked-can-land-timeout (seconds 0.1)
                                 :knocked-recover-timeout (seconds 2)
                                 :ragdoll-blend-out-time (seconds 0.25)
                                 :ragdoll-rotate-velocity-mult 1.0
                                 :jump-height-min (meters 3)
                                 :jump-height-factor 0.5
                                 :knocked-soft-vxz-lo 72089.6
                                 :knocked-soft-vxz-hi 108134.4
                                 :knocked-soft-vy-lo 81920.0
                                 :knocked-soft-vy-hi 122880.0
                                 :knocked-medium-vxz-lo 147456.0
                                 :knocked-medium-vxz-hi 196608.0
                                 :knocked-medium-vy-lo 135168.0
                                 :knocked-medium-vy-hi 151552.0
                                 :knocked-hard-vxz-lo 78643.2
                                 :knocked-hard-vxz-hi 117964.8
                                 :knocked-hard-vy-lo 183500.8
                                 :knocked-hard-vy-hi 209715.2
                                 :knocked-huge-vxz-lo 164659.2
                                 :knocked-huge-vxz-hi 249036.8
                                 :knocked-huge-vy-lo 183500.8
                                 :knocked-huge-vy-hi 217907.2
                                 :knocked-yellow-vxz-lo 40960.0
                                 :knocked-yellow-vxz-hi 49152.0
                                 :knocked-yellow-vy-lo 57344.0
                                 :knocked-yellow-vy-hi 81920.0
                                 :knocked-red-vxz-lo 57344.0
                                 :knocked-red-vxz-hi 57344.0
                                 :knocked-red-vy-lo 81920.0
                                 :knocked-red-vy-hi 81920.0
                                 :knocked-blue-vxz-lo 40960.0
                                 :knocked-blue-vxz-hi 49152.0
                                 :knocked-blue-vy-lo 24576.0
                                 :knocked-blue-vy-hi 81920.0
                                 :ragdoll-info #f
                                 :shadow-size (meters 2)
                                 :shadow-max-y (meters 10)
                                 :shadow-min-y (meters -40)
                                 :shadow-locus-dist (meters 150)
                                 :gem-joint -1
                                 :gem-offset (new 'static 'sphere :r 163840.0)
                                 :knocked-off #t
                                 :callback-info #f
                                 :use-momentum #f
                                 :use-frustration #t
                                 :use-stop-chase #f
                                 :use-circling #f
                                 :use-pacing #f
                                 :walk-anim 8
                                 :turn-anim -1
                                 :run-anim -1
                                 :taunt-anim -1
                                 :run-travel-speed (meters 12)
                                 :run-acceleration (meters 0.2)
                                 :run-turning-acceleration (meters 8)
                                 :walk-travel-speed (meters 4)
                                 :walk-acceleration (meters 0.1)
                                 :walk-turning-acceleration (meters 4)
                                 :maximum-rotation-rate (degrees 1440)
                                 :notice-nav-radius (meters 3)
                                 :frustration-distance (meters 8)
                                 :frustration-time (seconds 4)
                                 :blocked-time (seconds 0.3)
                                 :circle-dist-lo 20480.0
                                 :circle-dist-hi 61440.0
                                 :nav-mesh #f
                                 )
        )

(set! (-> *manta-nav-enemy-info* fact-defaults) *fact-info-manta-defaults*)

(defmethod init-enemy-collision! ((this manta))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-smack
                                    flut
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 6) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 7))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s4-0 prim-core collide-with) (collide-spec backgnd jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action semi-solid deadly))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 13107.2)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-13 prim-core collide-with) (collide-spec backgnd jak bot player-list))
      (set! (-> v1-13 prim-core action) (collide-action semi-solid))
      (set-vector! (-> v1-13 local-sphere) 0.0 4096.0 0.0 2048.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set-vector! (-> v1-15 local-sphere) 0.0 -4096.0 0.0 4096.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-17 prim-core action) (collide-action semi-solid))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 3481.6)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-19 prim-core action) (collide-action semi-solid))
      (set! (-> v1-19 transform-index) 6)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 0.0 3072.0)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-21 prim-core action) (collide-action deadly))
      (set! (-> v1-21 transform-index) 10)
      (set-vector! (-> v1-21 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-23 prim-core action) (collide-action deadly))
      (set! (-> v1-23 transform-index) 12)
      (set-vector! (-> v1-23 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (set! (-> s5-0 nav-radius) 6144.0)
    (let ((v1-25 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-25 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-25 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defbehavior manta-hostile-post manta ()
  (update-target-pos! self)
  (let* ((s4-0 (-> self root))
         (s3-0 (-> self focus-pos))
         (gp-1 (vector-! (new 'stack-no-clear 'vector) (-> s4-0 trans) s3-0))
         )
    (set! (-> gp-1 y) 0.0)
    (vector-xz-normalize! gp-1 1.0)
    (vector-rotate-y! gp-1 gp-1 (* (-> self orbit-speed) (seconds-per-frame)))
    (vector-xz-normalize! gp-1 81920.0)
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (set! (-> s2-0 quad) (-> s4-0 trans quad))
      (let ((s5-0 (-> self dest-pos)))
        (closest-point-on-mesh (-> self nav) s2-0 (-> s4-0 trans) (the-as nav-poly #f))
        (cond
          ((< (vector-vector-xz-distance (-> s4-0 trans) s2-0) 4096.0)
           (vector+! s5-0 s3-0 gp-1)
           (closest-point-on-mesh (-> self nav) s5-0 s5-0 (the-as nav-poly #f))
           )
          (else
            (vector+!
              s5-0
              (-> s4-0 trans)
              (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s2-0 (-> s4-0 trans)) 32768.0)
              )
            )
          )
        (let ((v1-15 (-> self nav state)))
          (logclear! (-> v1-15 flags) (nav-state-flag directional-mode))
          (logior! (-> v1-15 flags) (nav-state-flag target-poly-dirty))
          (set! (-> v1-15 target-pos quad) (-> s5-0 quad))
          )
        )
      )
    0
    (let ((s5-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))))
      (set! (-> s5-1 y) 0.0)
      (vector-normalize! s5-1 1.0)
      (vector-normalize! gp-1 -1.0)
      (set! (-> self angle-to-player) (acos (vector-dot s5-1 gp-1)))
      )
    )
  0
  (set! (-> self dest-pos y) (+ (-> self root gspot-pos y) (-> self y-offset)))
  (set! (-> self offset-difference) (- (-> self dest-pos y) (-> self root trans y)))
  (vector-! (-> self forward-dir) (-> self focus-pos) (-> self root trans))
  (vector-normalize! (-> self forward-dir) 1.0)
  (set! (-> self up-dir quad) (-> *y-vector* quad))
  (manta-method-200 self)
  (do-impact self)
  (manta-method-203 self -4096.0)
  (nav-enemy-travel-post)
  (none)
  )

(defbehavior manta-attack-post manta ()
  (update-target-pos! self)
  (set! (-> self offset-difference) (- (-> self root trans y) (-> self attack-pos y)))
  (if (time-elapsed? (-> self attack-path-blocked-time) (seconds 1))
      (manta-method-195 self)
      )
  (when (logtest? (enemy-flag ef37) (-> self enemy-flags))
    (let ((s2-0 (-> self curve-matrix))
          (f0-2 (-> self move-u))
          (a1-0 (new 'stack-no-clear 'vector))
          (s3-0 (new 'stack-no-clear 'vector))
          (a0-4 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 x) 0.0)
      (set! (-> s5-0 y) 0.0)
      (set! (-> s5-0 z) 4096.0)
      (set! (-> s5-0 w) 1.0)
      (set-vector! a1-0 (* f0-2 f0-2 f0-2) (* f0-2 f0-2) f0-2 1.0)
      (set-vector! s3-0 (* 3.0 f0-2 f0-2) (* 2.0 f0-2) 1.0 0.0)
      (vector-matrix*! a0-4 a1-0 s2-0)
      (vector-matrix*! s4-0 s3-0 s2-0)
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (let ((f0-6 4.0))
          (vector-float*! gp-0 s4-0 f0-6)
          )
        (vector-orient-by-quat! s3-1 s5-0 (-> self root quat))
        (vector+! s3-1 s3-1 (-> self root trans))
        (apply-impact! (-> self rbody) s3-1 gp-0)
        )
      )
    (seek! (-> self move-u) 1.0 (* (-> self move-du) (seconds-per-frame)))
    )
  (do-impact self)
  (manta-method-203 self -4096.0)
  (nav-enemy-simple-post)
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior manta-fly-code manta ()
  (cond
    ((-> self restart-fly-anims)
     (ja-channel-push! 3 (seconds 0.2))
     (ja :group! manta-flap-ja)
     (let ((v1-6 (-> self skel root-channel 1)))
       (let ((f0-0 0.0))
         (set! (-> v1-6 frame-interp 1) f0-0)
         (set! (-> v1-6 frame-interp 0) f0-0)
         )
       (set! (-> v1-6 frame-group) (the-as art-joint-anim manta-flap-fast-ja))
       )
     (let ((v1-9 (-> self skel root-channel 2)))
       (let ((f0-1 0.0))
         (set! (-> v1-9 frame-interp 1) f0-1)
         (set! (-> v1-9 frame-interp 0) f0-1)
         )
       (set! (-> v1-9 frame-group) (the-as art-joint-anim manta-flap-back-ja))
       )
     (set! (-> self restart-fly-anims) #f)
     )
    (else
      (ja :group! manta-flap-ja)
      (let ((v1-16 (-> self skel root-channel 1)))
        (let ((f0-2 0.0))
          (set! (-> v1-16 frame-interp 1) f0-2)
          (set! (-> v1-16 frame-interp 0) f0-2)
          )
        (set! (-> v1-16 frame-group) (the-as art-joint-anim manta-flap-fast-ja))
        )
      (let ((v1-19 (-> self skel root-channel 2)))
        (let ((f0-3 0.0))
          (set! (-> v1-19 frame-interp 1) f0-3)
          (set! (-> v1-19 frame-interp 0) f0-3)
          )
        (set! (-> v1-19 frame-group) (the-as art-joint-anim manta-flap-back-ja))
        )
      )
    )
  (until #f
    (until (ja-done? 0)
      (set! (-> self go-enable) #t)
      (suspend)
      (set! (-> self go-enable) #f)
      (let ((a0-19 (-> self skel root-channel 0)))
        (let ((f0-4 1.0))
          (set! (-> a0-19 frame-interp 1) f0-4)
          (set! (-> a0-19 frame-interp 0) f0-4)
          )
        (set! (-> a0-19 param 0) (the float (+ (-> a0-19 frame-group frames num-frames) -1)))
        (set! (-> a0-19 param 1) (-> self fly-anim-speed))
        (joint-control-channel-group-eval! a0-19 (the-as art-joint-anim #f) num-func-seek!)
        )
      (let* ((f30-0 (lerp-scale 0.0 1.0 (-> self fly-anim-speed) 1.0 1.5))
             (gp-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self root transv) 1.0))
             (f28-0 (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)) gp-0))
             )
        (let ((a0-23 (-> self skel root-channel 1)))
          (let ((f0-11 (fmax 0.0 (* f28-0 f30-0))))
            (set! (-> a0-23 frame-interp 1) f0-11)
            (set! (-> a0-23 frame-interp 0) f0-11)
            )
          (set! (-> a0-23 param 0) 0.0)
          (joint-control-channel-group-eval! a0-23 (the-as art-joint-anim #f) num-func-chan)
          )
        (let ((a0-24 (-> self skel root-channel 2)))
          (let ((f0-14 (fmax 0.0 (* (- 1.0 f28-0) f30-0))))
            (set! (-> a0-24 frame-interp 1) f0-14)
            (set! (-> a0-24 frame-interp 0) f0-14)
            )
          (set! (-> a0-24 param 0) 0.0)
          (joint-control-channel-group-eval! a0-24 (the-as art-joint-anim #f) num-func-chan)
          )
        )
      )
    (if (rnd-chance? self 0.5)
        (ja-no-eval :group! manta-flap-ja :num! (seek! max (-> self fly-anim-speed)) :frame-num 0.0)
        (ja-no-eval :group! manta-flap1-ja :num! (seek! max (-> self fly-anim-speed)) :frame-num 0.0)
        )
    )
  #f
  (none)
  )

(defstate idle (manta)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-5 (-> self draw shadow-ctrl)))
      (logior! (-> v1-5 settings flags) (shadow-flags disable-draw))
      )
    0
    (try-locate-ground self (meters 10) (meters 10) #t (collide-spec backgnd))
    (set! (-> self landed-pos quad) (-> self root trans quad))
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :exit (behavior ()
    (let ((v1-1 (-> self draw shadow-ctrl)))
      (logclear! (-> v1-1 settings flags) (shadow-flags disable-draw))
      )
    0
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (-> self state-timeout)) (< 1 (the-as int (-> self focus aware))))
        (go-virtual ambush)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (until #f
      (let ((s5-0 (set-reaction-time! self (seconds 0.007) (seconds 0.015)))
            (f28-0 (rnd-float-range self 0.5 0.3))
            (gp-0 (set-reaction-time! self (seconds 0.007) (seconds 0.01)))
            (f30-0 (rnd-float-range self 0.5 0.3))
            )
        (dotimes (s4-0 s5-0)
          (ja-no-eval :group! manta-idle0-ja :num! (seek! max f28-0) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max f28-0))
            )
          )
        (dotimes (s5-1 gp-0)
          (ja-no-eval :group! manta-idle1-ja :num! (seek! max f30-0) :frame-num 0.0)
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      )
    #f
    )
  :post (behavior ()
    (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
        (set-time! (-> self last-draw-time))
        )
    (update-focus self)
    (ja-post)
    )
  )

(defstate land-approach (manta)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logclear! (-> self flags) (manta-flags mf0))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef43))))
    (logclear! (-> self nav flags) (nav-control-flag limit-rotation-rate update-heading-from-facing))
    (set! (-> self dest-pos quad) (-> self landed-pos quad))
    (set! (-> self dest-pos y) (+ 8192.0 (-> self default-y-offset) (-> self landed-pos y)))
    (let ((a0-7 (-> self nav state))
          (v1-9 (-> self dest-pos))
          )
      (logclear! (-> a0-7 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-7 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-7 target-pos quad) (-> v1-9 quad))
      )
    0
    (set! (-> self go-enable) #t)
    (let ((v1-13 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-13 enemy-flags)))
          (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-13 enemy-flags))))
          )
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-13 enemy-flags))))
      (set! (-> v1-13 nav callback-info) (-> v1-13 enemy-info callback-info))
      )
    0
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 target-speed) 24576.0)
      )
    0
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (and (< (vector-vector-xz-distance (-> self root trans) (-> self dest-pos)) 8192.0) (-> self go-enable))
        (go-virtual land)
        )
    (if (and (time-elapsed? (-> self state-time) (-> self state-timeout)) (< 1 (the-as int (-> self focus aware))))
        (go-virtual notice)
        )
    (seek! (-> self fly-anim-speed) 1.0 (seconds-per-frame))
    (vector-! (-> self forward-dir) (-> self dest-pos) (-> self root trans))
    (vector-normalize! (-> self forward-dir) 1.0)
    0
    )
  :code manta-fly-code
  :post (behavior ()
    (do-impact self)
    (manta-method-203 self -4096.0)
    (nav-enemy-travel-post)
    )
  )

(defstate land (manta)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logclear! (-> self flags) (manta-flags mf0))
    (set! (-> self dest-pos quad) (-> self landed-pos quad))
    (set! (-> self dest-pos y) (+ (-> self landed-pos y) (-> self default-y-offset)))
    (set! (-> self restart-fly-anims) #t)
    )
  :exit (behavior ()
    (manta-method-206 self)
    )
  :trans (behavior ()
    (seek! (-> self fly-anim-speed) 1.0 (seconds-per-frame))
    (vector-! (-> self forward-dir) (-> self dest-pos) (-> self root trans))
    (vector-normalize! (-> self forward-dir) 1.0)
    0
    )
  :code (behavior ()
    (ja-no-eval :num! (seek! max (-> self fly-anim-speed)))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (ja-channel-push! 1 0)
    (while (< 2048.0 (vector-vector-distance (-> self root trans) (-> self landed-pos)))
      (ja-no-eval :group! manta-flap-ja :num! (seek! max (-> self fly-anim-speed)) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self fly-anim-speed)))
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! manta-land-ja :num! (seek! max 0.8) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.8))
      )
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! manta-idle0-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual dormant-aware)
    )
  :post (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (a1-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> a1-0 x) 0.0)
      (set! (-> a1-0 y) -819.2)
      (set! (-> a1-0 z) 0.0)
      (set! (-> a1-0 w) 1.0)
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (vector-! gp-0 (-> self landed-pos) (-> self root trans))
        (vector-float*! gp-0 gp-0 2.0)
        (vector-orient-by-quat! s5-0 a1-0 (-> self root quat))
        (vector+! s5-0 s5-0 (-> self root trans))
        (apply-impact! (-> self rbody) s5-0 gp-0)
        )
      )
    (vector-seek! (-> self dest-pos) (-> self landed-pos) (* 8192.0 (seconds-per-frame)))
    (nav-enemy-simple-post)
    )
  )

(defstate active (manta)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logior! (-> self flags) (manta-flags mf0))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef43))))
    (logclear! (-> self nav flags) (nav-control-flag limit-rotation-rate update-heading-from-facing))
    (set! (-> self y-offset) (-> self default-y-offset))
    (set! (-> self orbit-speed) (* 182.04445 (rnd-float-range self 0.5 2.0)))
    (let ((v1-13 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-13 enemy-flags)))
          (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-13 enemy-flags))))
          )
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-13 enemy-flags))))
      (set! (-> v1-13 nav callback-info) (-> v1-13 enemy-info callback-info))
      )
    0
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 target-speed) 49152.0)
      )
    0
    )
  :code manta-fly-code
  :post manta-hostile-post
  )

(defstate ambush (manta)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy ambush) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (try-locate-ground self (meters 10) (meters 10) #t (collide-spec backgnd))
    (set! (-> self landed-pos quad) (-> self root trans quad))
    (manta-method-206 self)
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (logior! (-> self draw status) (draw-control-status force-fade))
    (set! (-> self draw force-fade) (the-as uint 0))
    (set! (-> self fade-level) 0.0)
    )
  :exit (behavior ()
    (logclear! (-> self draw status) (draw-control-status force-fade))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (rnd-float-range self 1.0 1.5)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info notice-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      (ja-no-eval :group! manta-alert-idle-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-virtual notice-to-fly)
    )
  :post (behavior ()
    (seek! (-> self fade-level) 128.0 (* 196.0 (seconds-per-frame)))
    (set! (-> self draw force-fade) (the-as uint (the int (-> self fade-level))))
    (nav-enemy-simple-post)
    )
  )

(defstate notice-to-fly (manta)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((v1-0 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-0 enemy-flags)))
          (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-0 enemy-flags))))
          )
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-0 enemy-flags))))
      (set! (-> v1-0 nav callback-info) (-> v1-0 enemy-info callback-info))
      )
    0
    (let ((v1-3 self))
      (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-3 enemy-flags))))
      )
    0
    (set! (-> self fly-anim-speed) 1.5)
    (set! (-> self y-offset) (-> self default-y-offset))
    (set! (-> self dest-pos quad) (-> self root trans quad))
    (set! (-> self dest-pos y) (+ (-> self root gspot-pos y) (-> self y-offset)))
    )
  :exit (behavior ()
    (set-time! (-> self last-attack-time))
    (set! (-> self restart-fly-anims) #t)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (ja-no-eval :group! manta-alert-to-fly-ja :num! (seek! max (-> self fly-anim-speed)) :frame-num 0.0)
    (until (ja-done? 0)
      (cond
        ((< 15.0 (ja-frame-num 0))
         (do-impact self)
         (manta-method-203 self -4096.0)
         (nav-enemy-simple-post)
         )
        (else
          (nav-enemy-simple-post)
          )
        )
      (suspend)
      (ja :num! (seek! max (-> self fly-anim-speed)))
      )
    (ja-channel-push! 1 (seconds 0.075))
    (dotimes (gp-0 5)
      (ja-no-eval :group! manta-flap-fast-ja :num! (seek! max (-> self fly-anim-speed)) :frame-num 0.0)
      (until (ja-done? 0)
        (seek! (-> self fly-anim-speed) 1.2 (* 0.5 (seconds-per-frame)))
        (do-impact self)
        (manta-method-203 self -4096.0)
        (nav-enemy-simple-post)
        (suspend)
        (ja :num! (seek! max (-> self fly-anim-speed)))
        )
      )
    (go-virtual hostile)
    )
  )

(defstate stare (manta)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy stare) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logior! (-> self flags) (manta-flags mf0))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef43))))
    (logclear! (-> self nav flags) (nav-control-flag limit-rotation-rate update-heading-from-facing))
    (set! (-> self y-offset) (-> self default-y-offset))
    (set! (-> self orbit-speed) (* 182.04445 (rnd-float-range self 0.5 2.0)))
    (let ((v1-13 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-13 enemy-flags)))
          (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-13 enemy-flags))))
          )
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-13 enemy-flags))))
      (set! (-> v1-13 nav callback-info) (-> v1-13 enemy-info callback-info))
      )
    0
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 target-speed) 49152.0)
      )
    0
    )
  :code manta-fly-code
  :post manta-hostile-post
  )

(defstate hostile (manta)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logior! (-> self flags) (manta-flags mf0))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag ef43))))
    (logclear! (-> self nav flags) (nav-control-flag limit-rotation-rate update-heading-from-facing))
    (set! (-> self y-offset) (-> self default-y-offset))
    (set! (-> self orbit-speed) (* 182.04445 (rnd-float-range self 0.8 2.4)))
    (set! (-> self go-enable) #t)
    (let ((v1-14 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-14 enemy-flags)))
          (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-14 enemy-flags))))
          )
      (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-14 enemy-flags))))
      (set! (-> v1-14 nav callback-info) (-> v1-14 enemy-info callback-info))
      )
    0
    (let ((v1-17 (-> self nav)))
      (set! (-> v1-17 target-speed) 49152.0)
      )
    0
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy hostile) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (when (and (-> self go-enable) (< (fabs (- (-> self focus-pos y) (-> self root gspot-pos y))) 16384.0))
      (if (and (time-elapsed? (-> self last-attack-time) (seconds 3))
               (< (fabs (-> self angle-to-player)) 6371.5557)
               (< (-> self offset-difference) 12288.0)
               (< (vector-vector-xz-distance (-> self root trans) (-> self dest-pos)) 28672.0)
               (< (vector-vector-distance (-> self root trans) (-> self focus-pos)) 110592.0)
               (< (vector-length (-> self root transv)) 16384.0)
               (let ((f0-10 (- (-> self root trans y) (-> self focus-pos y))))
                 (and (and (< f0-10 24576.0) (< 0.0 f0-10)) (get-focus! self))
                 )
               )
          (go-virtual attack)
          )
      (if (and (time-elapsed? (-> self last-attack-time) (seconds 1))
               (< (fabs (-> self angle-to-player)) 8192.0)
               (< (current-time) (+ (-> self track-timer) (seconds 0.5)))
               (< (-> self offset-difference) 12288.0)
               (< -4096.0 (-> self root transv y))
               )
          (go-virtual attack)
          )
      )
    )
  :code manta-fly-code
  :post manta-hostile-post
  )

(defstate attack (manta)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-0 nav callback-info) *null-nav-callback-info*)
      )
    0
    (nav-enemy-method-177 self)
    (logior! (-> self focus-status) (focus-status dangerous))
    (set-time! (-> self state-time))
    (set-look-at-mode! self 1)
    (let ((f30-0 1.13))
      (cond
        ((and (get-focus! self) (manta-method-197 self))
         (set! (-> self attack-y-offset) (+ (- 4096.0 (-> self root trans y)) (-> self focus-pos y)))
         (logior! (-> self flags) (manta-flags mf1))
         )
        (else
          (set! (-> self attack-y-offset) 14336.0)
          )
        )
      (let* ((f0-4 (vector-vector-xz-distance (-> self focus-pos) (-> self root trans)))
             (f0-7 (/ (fmin 69632.0 (/ f0-4 f30-0)) f30-0))
             )
        (set! (-> self move-force) (* (-> self info info mass) f0-7))
        )
      (set! (-> self move-u) 0.0)
      (set! (-> self move-du) (* 0.94 f30-0))
      )
    (set! (-> self attack-pos quad) (-> self focus-pos quad))
    (set! (-> self y-offset) (+ 24576.0 (-> self default-y-offset)))
    (set! (-> self move-matrix rvec quad) (-> self root trans quad))
    (manta-method-195 self)
    (dotimes (gp-0 (-> self actor-group-count))
      (let ((s5-0 (-> self actor-group gp-0)))
        (dotimes (s4-0 (-> s5-0 length))
          (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-3 from) (process->ppointer self))
            (set! (-> a1-3 num-params) 0)
            (set! (-> a1-3 message) 'attacking)
            (let ((t9-6 send-event-function)
                  (v1-38 (-> s5-0 data s4-0 actor))
                  )
              (t9-6
                (if v1-38
                    (-> v1-38 extra process)
                    )
                a1-3
                )
              )
            )
          )
        )
      )
    )
  :exit (behavior ()
    (logclear! (-> self flags) (manta-flags mf1))
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (>= 2 (the-as int (-> self focus aware))))
        (go-stare self)
        )
    (if (and (logtest? (-> self flags) (manta-flags mf1))
             (< (vector-vector-xz-distance (-> self root trans) (-> self focus-pos)) 36864.0)
             (< (fabs (- (-> self root trans y) (-> self focus-pos y))) 7782.4)
             )
        (go-virtual attack-end)
        )
    )
  :code (behavior ()
    (let ((f28-0 (-> self fly-anim-speed))
          (f30-0 1.5)
          )
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! manta-flap-fast-ja :num! (seek! max f28-0) :frame-num 0.0)
      (until (ja-done? 0)
        (set! f28-0 (seek f28-0 f30-0 (seconds-per-frame)))
        (suspend)
        (ja :num! (seek! max f28-0))
        )
      (if (logtest? (-> self flags) (manta-flags mf1))
          (sound-play "manta-attack")
          )
      (let ((v1-29 self))
        (if (not (logtest? (enemy-flag ef37) (-> v1-29 enemy-flags)))
            (set! (-> v1-29 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-29 enemy-flags))))
            )
        (set! (-> v1-29 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-29 enemy-flags))))
        (set! (-> v1-29 nav callback-info) (-> v1-29 enemy-info callback-info))
        )
      0
      (ja-no-eval :group! manta-flap-fast-ja :num! (seek! max f28-0) :frame-num 0.0)
      (until (ja-done? 0)
        (set! f28-0 (seek f28-0 f30-0 (seconds-per-frame)))
        (suspend)
        (ja :num! (seek! max f28-0))
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! manta-attack-start-ja :num! (seek! max 1.2) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 1.2))
      )
    (ja-no-eval :group! manta-glide-end-ja :num! (seek! max 1.1) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 1.1))
      )
    (set! (-> self restart-fly-anims) #t)
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (set-time! (-> self last-attack-time))
    (go-virtual hostile)
    )
  :post manta-attack-post
  )

(defstate attack-end (manta)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((a0-0 (-> self root root-prim)))
      (set! (-> (the-as collide-shape-prim-group a0-0) child 1 prim-core action) (collide-action deadly))
      )
    (sound-play "manta-hit-jak")
    )
  :exit (behavior ()
    (set! (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1 prim-core action)
          (collide-action)
          )
    0
    (set! (-> self restart-fly-anims) #t)
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (set-time! (-> self last-attack-time))
    )
  :trans (behavior ()
    (if (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (>= 2 (the-as int (-> self focus aware))))
        (go-stare self)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let ((f30-0 1.0))
      (ja-no-eval :group! manta-attack-end-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-virtual hostile)
    )
  :post manta-attack-post
  )

(defstate knocked (manta)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logior! (-> self rbody flags) (rigid-body-flag enable-collision))
    (manta-method-206 self)
    (set! (-> self restart-fly-anims) #t)
    (set! (-> self gravity) 327680.0)
    (set! (-> self hit-ground-count) (the-as uint 0))
    (set! (-> self knocked-force-mult) 1.0)
    (knocked-handler self (-> self knocked-force))
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self gravity) 81920.0)
    )
  :trans (behavior ()
    (set-time! (-> self attack-path-blocked-time))
    (cond
      ((!= (-> self hit-points) 0.0)
       (if (and (zero? (-> self fated-time))
                (>= (-> self knocked-force-mult) 0.0)
                (or (time-elapsed? (-> self state-time) (seconds 0.8))
                    (and (< (-> self root trans y) (+ 8192.0 (-> self default-y-offset) (-> self root gspot-pos y)))
                         (< (-> self root transv y) 0.0)
                         )
                    )
                )
           (go-virtual knocked-recover)
           )
       )
      (else
        (if (and (< (-> self root trans y) (+ -40960.0 (-> self default-y-offset) (-> self root gspot-pos y)))
                 (< (-> self root transv y) 0.0)
                 )
            (go-die self)
            )
        )
      )
    )
  :post (behavior ()
    (seek! (-> self sound-volume) 0.0 (* 0.5 (seconds-per-frame)))
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 x) (* 4096.0 (rnd-float-range self -0.3 0.3)))
      (set! (-> s5-0 y) 0.0)
      (set! (-> s5-0 z) (* 4096.0 (rnd-float-range self -0.2 0.2)))
      (set! (-> s5-0 w) 1.0)
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (f30-2 4.0)
            )
        (vector-float*! gp-0 (-> self knocked-force) (* 2.0 (-> self knocked-force-mult) f30-2 f30-2))
        (vector-orient-by-quat! s4-0 s5-0 (-> self root quat))
        (vector+! s4-0 s4-0 (-> self root trans))
        (apply-impact! (-> self rbody) s4-0 gp-0)
        (seek! (-> self knocked-force-mult) 0.0 (* f30-2 (seconds-per-frame)))
        )
      )
    (let ((a1-9 (new 'stack-no-clear 'collide-query)))
      (set! (-> a1-9 start-pos quad) (-> self rbody position quad))
      (vector-float*! (-> a1-9 move-dist) (-> self rbody lin-velocity) (seconds-per-frame))
      (let ((v1-21 a1-9))
        (set! (-> v1-21 radius) (+ 4096.0 (-> self root root-prim local-sphere w)))
        (set! (-> v1-21 collide-with) (collide-spec backgnd jak bot obstacle player-list))
        (set! (-> v1-21 ignore-process0) self)
        (set! (-> v1-21 ignore-process1) #f)
        (set! (-> v1-21 ignore-pat) (-> self root pat-ignore-mask))
        (set! (-> v1-21 action-mask) (collide-action solid))
        )
      (fill-using-line-sphere *collide-cache* a1-9)
      )
    (manta-method-203 self 0.0)
    (nav-enemy-simple-post)
    )
  )

(defstate knocked-recover (manta)
  :virtual #t
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked-recover) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (logclear! (-> self rbody flags) (rigid-body-flag enable-collision))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (dotimes (gp-0 2)
      (ja-no-eval :group! manta-flap-fast-ja :num! (seek! max 1.5) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 1.5))
        )
      )
    (if (enemy-method-109 self)
        (go-die self)
        (go-hostile self)
        )
    )
  :post (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'collide-query)))
      (set! (-> a1-0 start-pos quad) (-> self rbody position quad))
      (vector-float*! (-> a1-0 move-dist) (-> self rbody lin-velocity) (seconds-per-frame))
      (let ((v1-3 a1-0))
        (set! (-> v1-3 radius) (+ 4096.0 (-> self root root-prim local-sphere w)))
        (set! (-> v1-3 collide-with) (collide-spec backgnd jak bot obstacle player-list))
        (set! (-> v1-3 ignore-process0) self)
        (set! (-> v1-3 ignore-process1) #f)
        (set! (-> v1-3 ignore-pat) (-> self root pat-ignore-mask))
        (set! (-> v1-3 action-mask) (collide-action solid))
        )
      (fill-using-line-sphere *collide-cache* a1-0)
      )
    (manta-method-203 self 0.0)
    (nav-enemy-simple-post)
    )
  )

(defmethod go-best-state ((this manta))
  (let ((s5-0 (-> this focus aware)))
    (cond
      ((and (= s5-0 (enemy-aware ea3)) (get-focus! this))
       (go-hostile this)
       )
      ((<= (the-as int s5-0) 0)
       (go (method-of-object this land-approach))
       )
      ((>= 1 (the-as int s5-0))
       (go (method-of-object this land-approach))
       )
      ((= s5-0 (enemy-aware ea4))
       (go-flee this)
       )
      (else
        (go-stare this)
        )
      )
    )
  )

(defmethod manta-method-195 ((this manta))
  (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> this focus-pos) (the-as vector (-> this move-matrix)))))
    (set! (-> s5-1 y) (-> this attack-y-offset))
    (vector-normalize! s5-1 (-> this move-force))
    (set! (-> this move-matrix fvec quad) (-> s5-1 quad))
    (vector+! (-> this move-matrix uvec) (the-as vector (-> this move-matrix)) s5-1)
    )
  (vector-! (-> this move-matrix trans) (-> this focus-pos) (-> this move-matrix uvec))
  (vector-normalize! (-> this move-matrix trans) 24576.0)
  (set! (-> this move-matrix trans y) (* -0.5 (-> this move-matrix trans y)))
  (matrix*! (-> this curve-matrix) *hermite-matrix* (-> this move-matrix))
  0
  (none)
  )

(defmethod manta-method-196 ((this manta))
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (set! (-> s3-0 quad) (-> this root trans quad))
    (let* ((s5-0 (new 'stack-no-clear 'vector))
           (s4-0 (closest-point-on-mesh (-> this nav) s5-0 s3-0 (the-as nav-poly #f)))
           )
      (when (and s4-0 (< (vector-vector-xz-distance s5-0 s3-0) 4096.0))
        (let ((s3-2 (vector-! (new 'stack-no-clear 'vector) (-> this focus-pos) s5-0)))
          (vector-length s3-2)
          (let ((s2-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info)))
            (vector-float*! s3-2 s3-2 1.3)
            (clamp-vector-to-mesh-no-gaps (-> this nav) s5-0 s4-0 s3-2 s2-0)
            (if (-> s2-0 found-boundary)
                #f
                #t
                )
            )
          )
        )
      )
    )
  )

(defmethod get-focus! ((this manta))
  (let* ((t9-0 (method-of-type nav-enemy get-focus!))
         (v0-0 (t9-0 this))
         )
    (cond
      ((and v0-0 (time-elapsed? (-> this attack-path-blocked-time) (seconds 1)))
       (empty)
       v0-0
       )
      (else
        (the-as process-focusable #f)
        )
      )
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod manta-method-197 ((this manta))
  (and (logtest? (-> this draw status) (draw-control-status on-screen))
       (let ((gp-0 (camera-matrix)))
         (camera-pos)
         (let* ((s4-0 (-> this focus-pos))
                (gp-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> gp-0 fvec) 1.0))
                (v1-6 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> this root trans) s4-0) 1.0))
                )
           (< 0.0 (vector-dot gp-1 v1-6))
           )
         )
       )
  (none)
  )

(defmethod within-gspot-range? ((this manta))
  #f
  )

(defmethod enemy-method-88 ((this manta) (arg0 enemy-knocked-info))
  (let ((v1-0 (-> this root)))
    (or (>= (-> arg0 on-surface-count) 3)
        (>= (-> this hit-ground-count) (the-as uint 1))
        (and (logtest? (-> v1-0 status) (collide-status on-ground)) (>= 16384.0 (-> v1-0 transv y)))
        )
    )
  )

(defmethod manta-method-198 ((this manta))
  (let ((a1-0 (-> this info name)))
    (when (nonzero? a1-0)
      (set! (-> this info) (the-as rigid-body-object-constants (-> a1-0 value)))
      (set! (-> this rbody info) (-> this info info))
      )
    )
  (rigid-body-info-method-9 (-> this info info))
  0
  (none)
  )

(defmethod manta-method-199 ((this manta))
  0
  (none)
  )

(defmethod manta-method-200 ((this manta))
  (local-vars (a2-5 float) (a2-12 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s5-0 (-> this root root-prim prim-core))
          )
      (set! (-> s3-0 quad) (-> s5-0 world-sphere quad))
      (set! (-> s3-0 w) (-> s5-0 world-sphere w))
      (let ((s4-0 544))
        (set! *actor-list-length* 0)
        (if (logtest? s4-0 512)
            (set! *actor-list-length* (fill-actor-list-for-box *actor-hash* s3-0 *actor-list* 256))
            )
        (when (logtest? s4-0 1024)
          (let ((a0-4 (-> *collide-player-list* alive-list next0)))
            *collide-player-list*
            (let ((v1-14 (-> a0-4 next0)))
              (while (!= a0-4 (-> *collide-player-list* alive-list-end))
                (let* ((a0-5 (-> (the-as connection a0-4) param1))
                       (a1-1 (-> (the-as collide-shape a0-5) root-prim))
                       )
                  (when (logtest? (the-as collide-spec s4-0) (-> a1-1 prim-core collide-as))
                    (let ((a1-2 (-> a1-1 prim-core)))
                      (let ((a2-4 a1-2)
                            (a3-1 s3-0)
                            )
                        (.lvf vf2 (&-> a2-4 world-sphere quad))
                        (.lvf vf3 (&-> a3-1 quad))
                        )
                      (.sub.vf vf1 vf3 vf2)
                      (.mul.vf vf1 vf1 vf1)
                      (.add.y.vf vf1 vf1 vf1 :mask #b1)
                      (.add.z.vf vf1 vf1 vf1 :mask #b1)
                      (.mov a2-5 vf1)
                      (let ((f0-1 a2-5)
                            (f1-1 (+ (-> a1-2 world-sphere w) (-> s3-0 w)))
                            )
                        (when (< f0-1 (* f1-1 f1-1))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-5))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! a0-4 v1-14)
                *collide-player-list*
                (set! v1-14 (-> v1-14 next0))
                )
              )
            )
          )
        (when (logtest? s4-0 256)
          (let ((a0-7 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((v1-22 (-> a0-7 next0)))
              (while (!= a0-7 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((a0-8 (-> (the-as connection a0-7) param1))
                       (a1-13 (-> (the-as collide-shape a0-8) root-prim))
                       )
                  (when (logtest? (the-as collide-spec s4-0) (-> a1-13 prim-core collide-as))
                    (let ((a1-14 (-> a1-13 prim-core)))
                      (let ((a2-11 a1-14)
                            (a3-2 s3-0)
                            )
                        (.lvf vf2 (&-> a2-11 world-sphere quad))
                        (.lvf vf3 (&-> a3-2 quad))
                        )
                      (.sub.vf vf1 vf3 vf2)
                      (.mul.vf vf1 vf1 vf1)
                      (.add.y.vf vf1 vf1 vf1 :mask #b1)
                      (.add.z.vf vf1 vf1 vf1 :mask #b1)
                      (.mov a2-12 vf1)
                      (let ((f0-2 a2-12)
                            (f1-5 (+ (-> a1-14 world-sphere w) (-> s3-0 w)))
                            )
                        (when (< f0-2 (* f1-5 f1-5))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-8))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! a0-7 v1-22)
                *collide-hit-by-player-list*
                (set! v1-22 (-> v1-22 next0))
                )
              )
            )
          )
        (dotimes (s3-1 *actor-list-length*)
          (let ((v1-27 (-> *actor-list* s3-1)))
            (when (logtest? (the-as collide-spec s4-0) (-> v1-27 root-prim prim-core collide-as))
              (when (!= v1-27 (-> this root))
                (let* ((s2-1
                         (vector-! (new 'stack-no-clear 'vector) (the-as vector s5-0) (the-as vector (-> v1-27 root-prim prim-core)))
                         )
                       (f0-3 (vector-length s2-1))
                       )
                  (when (< 40.96 f0-3)
                    (let ((f0-6 (lerp-scale 131072.0 0.0 f0-3 2048.0 (* 1.5 (-> s5-0 world-sphere w)))))
                      (vector-normalize! s2-1 f0-6)
                      )
                    (add-force! (-> this rbody) s2-1)
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod manta-method-201 ((this manta) (arg0 float))
  (let ((gp-0 (new 'stack-no-clear 'inline-array 'matrix 2)))
    (set! (-> gp-0 0 rvec quad) (-> this move-vel quad))
    (vector-normalize!
      (the-as vector (-> gp-0 0))
      (vector-vector-distance (-> this dest-pos) (-> this root trans))
      )
    (let ((v1-2 (-> gp-0 1)))
      (set! (-> v1-2 rvec x) 0.0)
      (set! (-> v1-2 rvec y) 0.0)
      (set! (-> v1-2 rvec z) 4096.0)
      (set! (-> v1-2 rvec w) 1.0)
      )
    (set-vector! (-> gp-0 1 uvec) 0.0 16384.0 0.0 1.0)
    (set! (-> gp-0 0 uvec quad) (-> gp-0 0 rvec quad))
    (set! (-> gp-0 0 uvec y) 0.0)
    (let* ((v1-5 (-> gp-0 0))
           (f30-0 (sqrtf (+ (* (-> v1-5 rvec x) (-> v1-5 rvec x)) (* (-> v1-5 rvec z) (-> v1-5 rvec z)))))
           (f0-13 (lerp-scale 0.0 49152.0 f30-0 4096.0 61440.0))
           (f0-15 (/ (* (-> this info info mass) f0-13 f0-13) (* 2.0 f30-0)))
           )
      (vector-normalize! (-> gp-0 0 uvec) (fmin arg0 f0-15))
      )
    (set! (-> this fly-anim-speed) (lerp-scale 1.0 1.5 (vector-length (-> gp-0 0 uvec)) 0.0 32768.0))
    (if (and (< (vector-dot (-> gp-0 0 uvec) (-> this forward-dir)) 0.0)
             (let ((v1-15 (-> gp-0 0)))
               (< (sqrtf (+ (* (-> v1-15 rvec x) (-> v1-15 rvec x)) (* (-> v1-15 rvec z) (-> v1-15 rvec z)))) 131072.0)
               )
             )
        (set! (-> gp-0 1 rvec z) (* -1.0 (-> gp-0 1 rvec z)))
        )
    (vector-float*! (-> gp-0 0 fvec) (-> gp-0 0 uvec) 4.0)
    (vector-float*! (-> gp-0 0 trans) (-> gp-0 0 uvec) 0.5)
    (vector-orient-by-quat! (-> gp-0 1 fvec) (the-as vector (-> gp-0 1)) (-> this root quat))
    (vector+! (-> gp-0 1 fvec) (-> gp-0 1 fvec) (-> this root trans))
    (apply-impact! (-> this rbody) (-> gp-0 1 fvec) (-> gp-0 0 fvec))
    (vector-orient-by-quat! (-> gp-0 1 fvec) (-> gp-0 1 uvec) (-> this root quat))
    (vector+! (-> gp-0 1 fvec) (-> gp-0 1 fvec) (-> this root trans))
    (apply-impact! (-> this rbody) (-> gp-0 1 fvec) (-> gp-0 0 trans))
    (when (logtest? (-> this flags) (manta-flags mf0))
      (let* ((s4-2 (vector-! (new 'stack-no-clear 'vector) (-> this focus-pos) (-> this root trans)))
             (t9-9 lerp-scale)
             (a0-27 32768.0)
             (a1-16 0.0)
             (v1-36 (-> gp-0 0))
             (f30-1 (t9-9
                      a0-27
                      a1-16
                      (sqrtf (+ (* (-> v1-36 rvec x) (-> v1-36 rvec x)) (* (-> v1-36 rvec z) (-> v1-36 rvec z))))
                      4096.0
                      61440.0
                      )
                    )
             (s3-1 (new 'stack-no-clear 'vector))
             )
        (set! (-> s3-1 x) 0.0)
        (set! (-> s3-1 y) 0.0)
        (set! (-> s3-1 z) 10240.0)
        (set! (-> s3-1 w) 1.0)
        (let ((f30-2
                (* f30-1
                   (lerp-scale
                     0.5
                     1.0
                     (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) (-> this forward-dir))
                     1.0
                     -1.0
                     )
                   )
                )
              )
          (vector-orient-by-quat! (-> gp-0 1 fvec) s3-1 (-> this root quat))
          (vector+! (-> gp-0 1 fvec) (-> gp-0 1 fvec) (-> this root trans))
          (apply-impact!
            (-> this rbody)
            (-> gp-0 1 fvec)
            (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-2 f30-2)
            )
          )
        )
      )
    )
  (none)
  )

(defmethod do-impact ((this manta))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (f0-1 (* (-> this rbody info mass) (-> this gravity)))
        (f1-2 (fmax 0.0 (fmin 1.0 (/ (- (-> this dest-pos y) (-> this root trans y)) (-> this y-offset)))))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s4-0 x) 0.0)
    (set! (-> s4-0 y) 12288.0)
    (set! (-> s4-0 z) 0.0)
    (set! (-> s4-0 w) 1.0)
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (vector-reset! gp-0)
      (set! (-> gp-0 y) (fmax 0.0 (fmin 450560.0 (* 4.0 f0-1 f1-2))))
      (set! (-> this fly-anim-speed) (fmax (lerp-scale 1.0 1.5 f1-2 0.35 0.6) (-> this fly-anim-speed)))
      (vector-orient-by-quat! s3-0 s4-0 (-> this root quat))
      (vector+! s3-0 s3-0 (-> this root trans))
      (apply-impact! (-> this rbody) s3-0 gp-0)
      )
    )
  0
  (none)
  )

(defmethod manta-method-203 ((this manta) (arg0 float))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (v1-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> v1-0 x) 0.0)
    (set! (-> v1-0 y) arg0)
    (set! (-> v1-0 z) 0.0)
    (set! (-> v1-0 w) 1.0)
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (vector-reset! gp-0)
      (set! (-> gp-0 y) (* -1.0 (-> this gravity) (-> this rbody info mass)))
      (vector-orient-by-quat! s4-0 v1-0 (-> this root quat))
      (vector+! s4-0 s4-0 (-> this root trans))
      (apply-impact! (-> this rbody) s4-0 gp-0)
      )
    )
  0
  (none)
  )

(defmethod manta-method-204 ((this manta))
  (rigid-body-control-method-10
    (-> this rbody)
    (the-as rigid-body-object this)
    (seconds-per-frame)
    (-> this max-time-step)
    )
  0
  (none)
  )

(defmethod nav-enemy-method-161 ((this manta) (arg0 nav-control))
  (let ((a2-0 (-> arg0 state)))
    (set! (-> this move-vel quad) (-> a2-0 velocity quad))
    )
  (manta-method-201 this 201326600.0)
  (none)
  )

(defmethod normalize-heading! ((this manta) (arg0 nav-control))
  0
  (none)
  )

(defmethod manta-method-208 ((this manta))
  (cond
    ((and (-> this draw shadow)
          (zero? (-> this draw cur-lod))
          (logtest? (-> this draw status) (draw-control-status on-screen))
          )
     (new 'stack-no-clear 'vector)
     (new 'stack-no-clear 'vector)
     (let ((s4-0 (new 'stack-no-clear 'collide-query))
           (gp-0 (-> this draw shadow-ctrl settings shadow-dir))
           (f30-0 81920.0)
           )
       (set! (-> s4-0 start-pos quad) (-> this root trans quad))
       (vector-normalize-copy! (-> s4-0 move-dist) gp-0 f30-0)
       (let ((v1-12 s4-0))
         (set! (-> v1-12 radius) 3276.8)
         (set! (-> v1-12 collide-with) (collide-spec backgnd))
         (set! (-> v1-12 ignore-process0) this)
         (set! (-> v1-12 ignore-process1) #f)
         (set! (-> v1-12 ignore-pat)
               (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
               )
         (set! (-> v1-12 action-mask) (collide-action solid))
         )
       (let ((f0-1 (fill-and-probe-using-line-sphere *collide-cache* s4-0)))
         (cond
           ((>= f0-1 0.0)
            (let ((v1-16 (-> this draw shadow-ctrl)))
              (logclear! (-> v1-16 settings flags) (shadow-flags disable-draw))
              )
            0
            (-> s4-0 best-other-tri intersect)
            (let ((a1-3 (-> this root trans)))
              (-> a1-3 y)
              (let ((f1-2 (* f0-1 f30-0)))
                (shadow-control-method-14
                  (-> this draw shadow-ctrl)
                  a1-3
                  gp-0
                  (fmax 32768.0 (* 409600.0 f0-1))
                  (+ -12288.0 f1-2)
                  (+ 12288.0 f1-2)
                  )
                )
              )
            )
           (else
             (let ((v1-28 (-> this draw shadow-ctrl)))
               (logior! (-> v1-28 settings flags) (shadow-flags disable-draw))
               )
             0
             )
           )
         )
       )
     )
    (else
      (let ((v1-31 (-> this draw shadow-ctrl)))
        (logior! (-> v1-31 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  0
  (none)
  )

(defmethod enemy-common-post ((this manta))
  (set! (-> this root gspot-pos quad) (-> this root trans quad))
  (cond
    ((and (-> this next-state) (= (-> this next-state name) 'knocked))
     (let ((a1-0 (new 'stack-no-clear 'collide-query)))
       (set-ground-pat!
         this
         a1-0
         (-> this enemy-info recover-gnd-collide-with)
         8192.0
         81920.0
         1024.0
         (the-as process #f)
         )
       )
     )
    (else
      (let ((s5-0 (-> this nav))
            (s3-0 (-> this root trans))
            (s4-0 (new 'stack 'nav-find-poly-parms))
            )
        (vector-! (-> s4-0 point) s3-0 (the-as vector (-> s5-0 state mesh bounds)))
        (set! (-> s4-0 y-threshold) (-> s5-0 nearest-y-threshold))
        (set! (-> s4-0 ignore) (the-as uint 2))
        (nav-mesh-method-46 (-> s5-0 state mesh) (the-as nav-poly s4-0))
        (let ((v1-16 (-> s4-0 poly)))
          (if v1-16
              (set! (-> this root gspot-pos y) (+ (-> v1-16 vertex0 y) (-> this nav state mesh bounds y)))
              )
          )
        )
      )
    )
  (manta-method-204 this)
  (update-rbody-transform! (-> this rbody) (-> this root))
  (manta-method-208 this)
  ((method-of-type nav-enemy enemy-common-post) this)
  (none)
  )

;; WARN: disable def twice: 150. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 100. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod event-handler ((this manta) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-4 object))
  (case arg2
    (('hit 'hit-flinch 'hit-knocked)
     (logclear! (-> this mask) (process-mask actor-pause))
     (logclear! (-> this focus-status) (focus-status dangerous))
     (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance))
     (logior! (-> this enemy-flags) (enemy-flag alert))
     (logior! (-> this focus-status) (focus-status hit))
     (if (= (-> this hit-points) 0.0)
         (logior! (-> this focus-status) (focus-status dead))
         )
     (logclear! (-> this enemy-flags) (enemy-flag lock-focus))
     (enemy-method-69 this)
     (logior! (-> this enemy-flags) (enemy-flag lock-focus))
     (process-contact-action arg0)
     (send-event arg0 'get-attack-count 1)
     (freeze-hit-begin)
     (go (method-of-object this knocked))
     )
    (('impact-impulse)
     (let ((v1-27 (-> arg3 param 0)))
       (when (and (< 0.8 (vector-dot (the-as vector (+ v1-27 16)) *y-vector*))
                  (< (vector-dot (the-as vector (+ v1-27 16)) (the-as vector (+ v1-27 32))) -0.8)
                  )
         (set! v0-4 (+ (-> this hit-ground-count) 1))
         (set! (-> this hit-ground-count) (the-as uint v0-4))
         v0-4
         )
       )
     )
    (('tracked)
     (set! v0-4 (current-time))
     (set! (-> this track-timer) (the-as time-frame v0-4))
     v0-4
     )
    (('cue-chase 'trigger)
     (if (and (-> this next-state) (let ((v1-37 (-> this next-state name)))
                                     (or (= v1-37 'idle) (= v1-37 'dormant-aware) (= v1-37 'dormant))
                                     )
              )
         (go (method-of-object this ambush))
         )
     )
    (('attacking)
     (when (and (!= arg0 this) (time-elapsed? (-> this last-attack-time) (seconds 1)))
       (set! v0-4 (+ (current-time) (seconds -1)))
       (set! (-> this last-attack-time) (the-as time-frame v0-4))
       v0-4
       )
     )
    (else
      ((method-of-type nav-enemy event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod update-target-pos! ((this manta))
  (let ((a0-2 (handle->process (-> this focus handle))))
    (cond
      (a0-2
        (set! (-> this focus-pos quad) (-> (get-trans (the-as process-focusable a0-2) 3) quad))
        (if (not (manta-method-196 this))
            (set-time! (-> this attack-path-blocked-time))
            )
        )
      (else
        (set! (-> this focus-pos quad) (-> (target-pos 0) quad))
        (set! (-> this dest-pos quad) (-> this root trans quad))
        )
      )
    )
  (none)
  )

(defmethod enemy-method-50 ((this manta) (arg0 int))
  (let ((v1-0 arg0))
    (cond
      ((= v1-0 1)
       (let ((v1-2 (-> this root root-prim)))
         (let ((a0-1 v1-2))
           (set! (-> a0-1 prim-core action) (collide-action solid deadly))
           (set! (-> a0-1 prim-core collide-with) (collide-spec backgnd jak bot obstacle hit-by-others-list player-list))
           )
         (let ((v1-4 (-> (the-as collide-shape-prim-group v1-2) child 0)))
           (set! (-> v1-4 prim-core action) (collide-action solid deadly))
           (set! (-> v1-4 prim-core collide-with) (collide-spec backgnd jak bot obstacle hit-by-others-list player-list))
           (set! (-> v1-4 local-sphere w) 6144.0)
           )
         )
       )
      ((or (= v1-0 2) (zero? v1-0))
       (let ((v1-8 (-> this root root-prim)))
         (let ((a0-5 v1-8))
           (set! (-> a0-5 prim-core action) (collide-action semi-solid deadly))
           (set! (-> a0-5 prim-core collide-with) (collide-spec backgnd jak bot player-list))
           )
         (let ((v1-10 (-> (the-as collide-shape-prim-group v1-8) child 0)))
           (set! (-> v1-10 prim-core action) (collide-action semi-solid deadly))
           (set! (-> v1-10 prim-core collide-with) (collide-spec backgnd jak bot player-list))
           (set! (-> v1-10 local-sphere w) 2048.0)
           )
         )
       )
      )
    )
  0
  (none)
  )

(defmethod knocked-anim-handler ((this manta) (arg0 int) (arg1 enemy-knocked-info))
  (case arg0
    ((1)
     (let ((s5-0 (ja-done? 0)))
       (let ((a0-3 (-> this skel root-channel 0)))
         (set! (-> a0-3 param 0) (the float (+ (-> a0-3 frame-group frames num-frames) -1)))
         (set! (-> a0-3 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-3 (the-as art-joint-anim #f) num-func-seek!)
         )
       (when (and s5-0 (= (-> this hit-points) 0.0))
         (let ((a0-4 (-> this skel root-channel 0)))
           (set! (-> a0-4 frame-group) (the-as art-joint-anim (-> this draw art-group data 16)))
           (set! (-> a0-4 param 0)
                 (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 16)) frames num-frames) -1))
                 )
           (set! (-> a0-4 param 1) (-> arg1 anim-speed))
           (set! (-> a0-4 frame-num) 8.0)
           (joint-control-channel-group! a0-4 (the-as art-joint-anim (-> this draw art-group data 16)) num-func-seek!)
           )
         )
       s5-0
       )
     )
    (else
      ((method-of-type nav-enemy knocked-anim-handler) this arg0 arg1)
      )
    )
  )

(defmethod knocked-anim ((this manta) (arg0 enemy-knocked-info))
  (cond
    ((= (-> this hit-points) 0.0)
     (ja-channel-push! 1 (seconds 0.1))
     (set! (-> arg0 anim-speed) 0.5)
     (let ((a0-2 (-> this skel root-channel 0)))
       (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> this draw art-group data 16)))
       (set! (-> a0-2 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 16)) frames num-frames) -1))
             )
       (set! (-> a0-2 param 1) (-> arg0 anim-speed))
       (set! (-> a0-2 frame-num) 0.0)
       (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> this draw art-group data 16)) num-func-seek!)
       )
     #t
     )
    ((let ((v1-15 (-> this incoming knocked-type)))
       (= v1-15 (knocked-type blue-shot))
       )
     (ja-channel-push! 1 0)
     (let ((a0-5 (-> this skel root-channel 0)))
       (set! (-> a0-5 frame-group) (the-as art-joint-anim (-> this draw art-group data 14)))
       (set! (-> a0-5 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 14)) frames num-frames) -1))
             )
       (set! (-> a0-5 param 1) (-> arg0 anim-speed))
       (set! (-> a0-5 frame-num) 0.0)
       (joint-control-channel-group! a0-5 (the-as art-joint-anim (-> this draw art-group data 14)) num-func-seek!)
       )
     #t
     )
    (else
      (ja-channel-push! 1 (seconds 0.1))
      (let ((a0-7 (-> this skel root-channel 0)))
        (set! (-> a0-7 frame-group) (the-as art-joint-anim (-> this draw art-group data 13)))
        (set! (-> a0-7 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 13)) frames num-frames) -1))
              )
        (set! (-> a0-7 param 1) (-> arg0 anim-speed))
        (set! (-> a0-7 frame-num) 0.0)
        (joint-control-channel-group! a0-7 (the-as art-joint-anim (-> this draw art-group data 13)) num-func-seek!)
        )
      #t
      )
    )
  )

(defmethod knocked-land-anim ((this manta) (arg0 enemy-knocked-info))
  (set! (-> arg0 anim-speed) 0.5)
  (ja-channel-push! 1 (seconds 0.1))
  (let ((a0-2 (-> this skel root-channel 0)))
    (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> this draw art-group data 18)))
    (set! (-> a0-2 param 0)
          (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 18)) frames num-frames) -1))
          )
    (set! (-> a0-2 param 1) (-> arg0 anim-speed))
    (set! (-> a0-2 frame-num) 0.0)
    (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> this draw art-group data 18)) num-func-seek!)
    )
  #t
  )

(defmethod manta-method-206 ((this manta))
  (rigid-body-control-method-28 (-> this rbody) (-> this root trans) (-> this root quat))
  (let ((v1-4 (-> this rbody)))
    (set! (-> v1-4 force quad) (the-as uint128 0))
    (set! (-> v1-4 torque quad) (the-as uint128 0))
    )
  0
  (reset-momentum! (-> this rbody))
  0
  (none)
  )

(defmethod alloc-rbody! ((this manta) (arg0 rigid-body-object-constants))
  (set! (-> this info) arg0)
  (set! (-> this rbody) (new 'process 'rigid-body-control this))
  (update-transforms (-> this root))
  (init!
    (-> this rbody)
    (-> this info info)
    (-> this root trans)
    (-> this root quat)
    (the-as (function rigid-body-object float) (method-of-object this manta-method-199))
    )
  (manta-method-198 this)
  (set! (-> this max-time-step) (-> arg0 extra max-time-step))
  (set! (-> this root max-iteration-count) (the-as uint 4))
  0
  (none)
  )

(defmethod init-enemy! ((this manta))
  (local-vars (sv-16 res-tag))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-manta" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (init-enemy-defaults! this *manta-nav-enemy-info*)
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-0)
    )
  (alloc-rbody! this *manta-rigid-body-constants*)
  (set! (-> this flags) (manta-flags))
  (logclear! (-> this nav flags) (nav-control-flag limit-rotation-rate update-heading-from-facing use-momentum))
  (let ((v1-13 (-> this neck)))
    (set! (-> v1-13 up) (the-as uint 1))
    (set! (-> v1-13 nose) (the-as uint 2))
    (set! (-> v1-13 ear) (the-as uint 0))
    (set-vector! (-> v1-13 twist-max) 11832.889 11832.889 0.0 1.0)
    (set! (-> v1-13 ignore-angle) 30947.555)
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-16 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-16 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-16))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this default-y-offset) (res-lump-float (-> this entity) 'y-offset :default 32768.0))
  (set! (-> this root dynam gravity y) 81920.0)
  (set! (-> this root dynam gravity-length) 81920.0)
  (set! (-> this root dynam gravity-max) 81920.0)
  (logclear! (-> this nav flags) (nav-control-flag update-heading-from-facing))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag ef44))))
  (set! (-> this go-enable) #t)
  (set! (-> this up-dir quad) (-> *y-vector* quad))
  (set! (-> this forward-dir quad) (-> *z-vector* quad))
  (set! (-> this last-attack-time) 0)
  (set! (-> this attack-path-blocked-time) 0)
  (set! (-> this track-timer) 0)
  (set! (-> this gravity) 81920.0)
  0
  (none)
  )
