;;-*-Lisp-*-
(in-package goal)

;; name: guard-states.gc
;; name in dgo: guard-states
;; dgos: CWI

;; DECOMP BEGINS

(defstate knocked-recover (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag ef38))))
      )
    0
    (let ((a0-3 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-3 flags) (nav-state-flag directional-mode))
      (set! (-> a0-3 travel quad) (-> v1-3 quad))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (set! (-> self hit-face) (the-as uint -1))
    (let ((t9-1 (-> (find-parent-state) exit)))
      (if t9-1
          (t9-1)
          )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((v1-1 (if (zero? (-> self hit-face))
                    (-> self anim-get-up-front)
                    (-> self anim-get-up-back)
                    )
                )
          )
      (ja-no-eval :group! (-> self draw art-group data v1-1) :num! (seek! max (-> self speed-scale)) :frame-num 0.0)
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (if (enemy-method-109 self)
        (go-die self)
        (go-best-state self)
        )
    )
  )

(defstate get-up-front (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-2 nav callback-info) *null-nav-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag ef38))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (set! (-> self hit-face) (the-as uint -1))
    (enemy-method-50 self 0)
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-front))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (set! (-> self hit-face) (the-as uint -1))
    (go-best-state self)
    )
  :post (behavior ()
    (reset-penetrate! self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (enemy-common-post self)
    )
  )

(defstate get-up-back (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-2 nav callback-info) *null-nav-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag ef38))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (set! (-> self hit-face) (the-as uint -1))
    (enemy-method-50 self 0)
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-back))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (set! (-> self hit-face) (the-as uint -1))
    (go-best-state self)
    )
  :post (behavior ()
    (reset-penetrate! self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (enemy-common-post self)
    )
  )

(defstate knocked (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (if (= (-> self hit-points) 0.0)
        (set! (-> self root penetrated-by) (the-as penetrate -1))
        )
    (set! (-> self hit-face)
          (the-as
            uint
            (if (< (vector-dot (-> self root transv) (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                   0.0
                   )
                1
                0
                )
            )
          )
    )
  :exit (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self root backup-collide-with))
      )
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) exit)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (reset-penetrate! self)
    )
  )

(defstate knocked-off-vehicle (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    '()
    )
  :code (behavior ()
    (suspend)
    (citizen-method-206 self)
    )
  )

(defun debug-active ()
  #f
  )

(defstate active (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (when (not (-> self nav))
      (format #t "++++++++++++++ guard::active : nav = #f +++++++++++++++~%")
      (go-inactive self)
      )
    (let ((t9-2 (-> (method-of-type citizen active) enter)))
      (if t9-2
          (t9-2)
          )
      )
    (logclear! (-> self flags) (citizen-flag in-pursuit hostile))
    (set! (-> self already-shot) #f)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type citizen active) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (when (logtest? (-> self draw status) (draw-control-status on-screen))
      (let ((f0-0 61440.0))
        (cond
          ((< (* f0-0 f0-0) (vector-vector-xz-distance-squared (target-pos 0) (-> self root trans)))
           (speech-control-method-13 *speech-control* self (speech-type guard-chatter) (-> self traffic-id))
           (speech-control-method-17 *speech-control* (speech-type guard-chatter-jak) 0.2)
           )
          (else
            (speech-control-method-13 *speech-control* self (speech-type guard-chatter-jak) (-> self traffic-id))
            (speech-control-method-17 *speech-control* (speech-type guard-chatter) 0.2)
            )
          )
        )
      )
    (crimson-guard-method-270 self)
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (if (handle->process (-> self target-status handle))
          (go-hostile self)
          )
      )
    )
  )

(defstate close-attack-active (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-0 nav callback-info) *null-nav-callback-info*)
      )
    0
    (let ((v1-3 self))
      (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logclear (-> v1-3 enemy-flags) (enemy-flag ef38))))
      )
    0
    (let* ((v1-5 *game-info*)
           (a0-8 (+ (-> v1-5 attack-id) 1))
           )
      (set! (-> v1-5 attack-id) a0-8)
      (set! (-> self attack-id) a0-8)
      )
    (let ((v1-6 (-> self nav)))
      (set! (-> v1-6 target-speed) 0.0)
      )
    0
    (logior! (-> self focus-status) (focus-status dangerous))
    )
  :exit (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 3)))
      (logclear! (-> v1-3 prim-core action) (collide-action deadly))
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-0 #f))
      (ja-no-eval :group! crimson-guard-rifle-butt-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (< 3.5 (ja-frame-num 0)) (not gp-0))
          (let ((v1-22 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 3)))
            (logior! (-> v1-22 prim-core action) (collide-action deadly))
            )
          (set! gp-0 #t)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-virtual active)
    )
  :post (behavior ()
    (nav-enemy-method-187 self)
    )
  )

(defstate inactive (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (let ((t9-0 (-> (method-of-type citizen inactive) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logclear! (-> self flags) (citizen-flag in-pursuit hostile))
    (set! (-> self already-shot) #f)
    )
  )

(defstate search (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-177 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self enemy-info run-travel-speed)))
      )
    0
    (if (zero? (-> self controller branch))
        (citizen-method-208 self (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
        )
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info walk-anim))) 60)
    )
  :post (behavior ()
    (if (and (nonzero? (-> self controller branch))
             (let ((f0-0 (vector-vector-xz-distance-squared (-> self root trans) (-> self dest-point)))
                   (f1-0 16384.0)
                   )
               (< f0-0 (* f1-0 f1-0))
               )
             )
        (vehicle-controller-method-14 (-> self controller) (the-as vehicle self))
        )
    (let ((a0-2 (-> self nav state))
          (v1-9 (-> self dest-point))
          )
      (logclear! (-> a0-2 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-2 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-2 target-pos quad) (-> v1-9 quad))
      )
    0
    (nav-enemy-method-187 self)
    )
  )

;; WARN: Return type mismatch float vs none.
(defmethod crimson-guard-method-251 ((this crimson-guard))
  ((-> (method-of-type nav-enemy hostile) enter))
  (nav-enemy-method-177 this)
  (when (-> this nav)
    (let ((v1-6 (-> this nav)))
      (set! (-> v1-6 target-speed) (* (-> this speed-scale) (-> this enemy-info run-travel-speed)))
      )
    0
    )
  (if (not (logtest? (-> this squad alert-state flags) (squad-alert-flag war)))
      (logior! (-> this flags) (citizen-flag persistent))
      )
  (logclear! (-> this flags) (citizen-flag in-formation))
  (set! (-> this root nav-radius) 6144.0)
  (none)
  )

(defmethod crimson-guard-method-252 ((this crimson-guard))
  (go-active-if-necessary)
  (speech-control-method-17 *speech-control* (speech-type guard-chatter) 0.2)
  (speech-control-method-17 *speech-control* (speech-type guard-chatter-jak) 0.2)
  (cond
    (*guard-died-recently?*
      (speech-control-method-13 *speech-control* this (speech-type guard-witness-death) (-> this traffic-id))
      (set! *guard-died-recently?* #f)
      )
    (else
      (speech-control-method-13 *speech-control* this (speech-type guard-generic-battle) (-> this traffic-id))
      )
    )
  (if (crimson-guard-method-270 this)
      (go-hostile this)
      )
  (let* ((s4-0 (-> this target-status))
         (s3-0 (handle->process (-> s4-0 handle)))
         (s5-0 (if (type? s3-0 process-focusable)
                   s3-0
                   )
               )
         )
    (if (and s5-0 (or (focus-test? (the-as process-focusable s5-0) inactive)
                      (focus-test? (the-as process-focusable s5-0) disable)
                      )
             )
        (set! s5-0 (the-as process #f))
        )
    (cond
      ((not s5-0)
       )
      (else
        (when (and (logtest? (-> this nav state flags) (nav-state-flag at-target))
                   (not (logtest? (-> s4-0 flags) (squad-target-flag visible-recently)))
                   )
          (logclear! (-> this flags) (citizen-flag persistent))
          (citizen-method-208 this (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
          (go (method-of-object this search))
          )
        (when (or (logtest? (-> s4-0 flags) (squad-target-flag visible-recently))
                  (not (logtest? (-> s5-0 mask) (process-mask target)))
                  )
          (cond
            ((focus-test? (the-as process-focusable s5-0) arrestable)
             (if (and (< (-> this target-self-xz-dist) 28672.0)
                      (< (fabs (-> this target-y-angle)) 7281.778)
                      (>= 8192.0 (fabs (- (-> (get-trans (the-as process-focusable s5-0) 1) y) (-> this root trans y))))
                      )
                 (go (method-of-object this arrest))
                 )
             )
            (else
              (if (crimson-guard-method-269 this (the-as process-focusable s5-0))
                  (go (method-of-object this close-attack))
                  )
              )
            )
          )
        (let ((f0-7 (* 2.0 (crimson-guard-method-283 this))))
          (when (and (time-elapsed? (-> this state-time) (seconds 1))
                     (< (* f0-7 f0-7)
                        (vector-vector-xz-distance-squared (-> this root trans) (get-trans (the-as process-focusable s5-0) 0))
                        )
                     )
            (set-time! (-> this state-time))
            (crimson-guard-method-289 this 0.0)
            )
          )
        )
      )
    )
  (none)
  )

(defmethod crimson-guard-method-253 ((this crimson-guard))
  0
  (none)
  )

(defmethod crimson-guard-method-254 ((this crimson-guard))
  (local-vars (sv-112 vector) (sv-128 vector) (sv-144 int))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (handle->process (-> this focus handle))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> this move-position quad))
      (when (< 8192000.0 (-> this target-self-xz-dist))
        (let ((s3-0 (-> this root trans))
              (s2-0 (new 'stack-no-clear 'vector))
              (s1-0 (new 'stack-no-clear 'vector))
              (s0-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              )
          (set! sv-112 (new 'stack-no-clear 'vector))
          (set! (-> s1-0 quad) (-> s5-0 quad))
          (vector-z-quaternion! s2-0 (-> this root quat))
          (let ((f30-0 (* 182.04445 (* 60.0 (the float (- (-> this traffic-id) *guard-min-id-hack*))))))
            (set! sv-128 s0-0)
            (set! (-> sv-128 x) (cos f30-0))
            (set! (-> sv-128 y) 0.0)
            (set! (-> sv-128 z) (sin f30-0))
            )
          (set! (-> sv-128 w) 1.0)
          (let ((a1-2 s1-0))
            (let ((v1-21 s1-0))
              (let ((a0-13 s0-0))
                (let ((a2-1 12288.0))
                  (.mov vf7 a2-1)
                  )
                (.lvf vf5 (&-> a0-13 quad))
                )
              (.lvf vf4 (&-> v1-21 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-2 quad) vf6)
            )
          (let ((f30-2 (* 0.5 (vector-vector-xz-distance s3-0 s1-0))))
            (vector-normalize! s2-0 (/ f30-2 2))
            (vector-normalize! s0-0 (* 2.0 f30-2))
            )
          (set! sv-144 0)
          (while (< sv-144 10)
            (do-spline s4-0 s3-0 s2-0 s1-0 s0-0 (* 0.1 (the float sv-144)))
            (do-spline sv-112 s3-0 s2-0 s1-0 s0-0 (* 0.1 (the float (+ sv-144 1))))
            (add-debug-line #t (bucket-id debug-no-zbuf1) s4-0 sv-112 *color-red* #f (the-as rgba -1))
            (set! sv-144 (+ sv-144 1))
            )
          (do-spline s4-0 s3-0 s2-0 s1-0 s0-0 0.9)
          (set! (-> s4-0 quad) (-> s5-0 quad))
          )
        )
      (let ((v1-39 (-> this nav state)))
        (logclear! (-> v1-39 flags) (nav-state-flag directional-mode))
        (logior! (-> v1-39 flags) (nav-state-flag target-poly-dirty))
        (set! (-> v1-39 target-pos quad) (-> s5-0 quad))
        )
      )
    0
    (nav-enemy-method-187 this)
    (none)
    )
  )

(defstate hostile (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (crimson-guard-method-251 self)
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (crimson-guard-method-252 self)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info walk-anim))) 60)
    )
  :post (behavior ()
    (crimson-guard-method-253 self)
    (crimson-guard-method-254 self)
    )
  )

(defstate close-attack (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag lock-focus))
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((v1-4 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-4 enemy-flags)))
          (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-4 enemy-flags))))
          )
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-4 enemy-flags))))
      (set! (-> v1-4 nav callback-info) (-> v1-4 enemy-info callback-info))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag ef38))))
      )
    0
    (set! (-> self urgent-fire) #f)
    (let* ((v1-9 *game-info*)
           (a0-17 (+ (-> v1-9 attack-id) 1))
           )
      (set! (-> v1-9 attack-id) a0-17)
      (set! (-> self attack-id) a0-17)
      )
    (let ((v1-10 (-> self nav)))
      (set! (-> v1-10 target-speed) 0.0)
      )
    0
    )
  :exit (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 3)))
      (logclear! (-> v1-3 prim-core action) (collide-action deadly))
      )
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    )
  :trans (behavior ()
    (crimson-guard-method-261 self)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-0 #f))
      (ja-no-eval :group! crimson-guard-rifle-butt-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (< 3.5 (ja-frame-num 0)) (not gp-0))
          (let ((v1-22 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 3)))
            (logior! (-> v1-22 prim-core action) (collide-action deadly))
            )
          (set! gp-0 #t)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-hostile self)
    )
  :post (behavior ()
    (nav-enemy-method-187 self)
    )
  )

(defstate flee-danger (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag lock-focus))
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef38) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (set-time! (-> self state-time))
    (nav-enemy-method-177 self)
    (flee-info-method-12 (-> self flee-behavior) self)
    )
  :exit (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    )
  :trans (behavior ()
    (flee-info-method-11 (-> self flee-behavior) self)
    (if (time-elapsed? (-> self state-time) (seconds 4))
        (go-hostile self)
        )
    (if (< 81920.0 (vector-vector-xz-distance (-> self root trans) (-> self danger-pos)))
        (go-virtual active)
        )
    )
  :code (behavior ()
    (loop
      (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info run-anim))) 60)
      )
    )
  :post (behavior ()
    (flee-info-method-13 (-> self flee-behavior) self)
    )
  )

(defstate roll-right (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :code (behavior ()
    (vector-reset! (-> self root transv))
    (vector-x-quaternion! (-> self root transv) (-> self root quat))
    (set! (-> self root transv y) 24576.0)
    (vector-xz-normalize! (-> self root transv) 40960.0)
    (let ((v1-7 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-7 enemy-flags)))
          (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-7 enemy-flags))))
          )
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-7 enemy-flags))))
      (set! (-> v1-7 nav callback-info) (-> v1-7 enemy-info callback-info))
      )
    0
    (ja-channel-push! 1 (seconds 0.1))
    (cond
      ((logtest? (enemy-flag drawn-mirrored) (-> self enemy-flags))
       (ja-no-eval :group! crimson-guard-jump-right-ja :num! (seek! (ja-aframe 6.0 0)) :frame-num (ja-aframe 0.0 0))
       (until (ja-done? 0)
         (let ((a0-20 (the-as process-focusable (handle->process (-> self focus handle)))))
           (if a0-20
               (seek-toward-heading-vec!
                 (-> self root)
                 (vector-! (new 'stack-no-clear 'vector) (get-trans a0-20 0) (-> self root trans))
                 32768.0
                 (seconds 0.05)
                 )
               )
           )
         (suspend)
         (ja :num! (seek! (ja-aframe 6.0 0)))
         )
       )
      (else
        (ja-no-eval :group! crimson-guard-jump-left-ja :num! (seek! (ja-aframe 9.0 0)) :frame-num (ja-aframe 0.0 0))
        (until (ja-done? 0)
          (let ((a0-33 (the-as process-focusable (handle->process (-> self focus handle)))))
            (if a0-33
                (seek-toward-heading-vec!
                  (-> self root)
                  (vector-! (new 'stack-no-clear 'vector) (get-trans a0-33 0) (-> self root trans))
                  32768.0
                  (seconds 0.05)
                  )
                )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 9.0 0)))
          )
        )
      )
    (let ((v1-58 self))
      (set! (-> v1-58 enemy-flags) (the-as enemy-flag (logclear (-> v1-58 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-58 nav callback-info) *null-nav-callback-info*)
      )
    0
    (cond
      ((logtest? (enemy-flag drawn-mirrored) (-> self enemy-flags))
       (ja-no-eval :group! crimson-guard-jump-right-ja :num! (seek! (ja-aframe 11.0 0)) :frame-num (ja-aframe 6.0 0))
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 11.0 0)))
         )
       )
      (else
        (ja-no-eval :group! crimson-guard-jump-left-ja :num! (seek! (ja-aframe 11.0 0)) :frame-num (ja-aframe 9.0 0))
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! (ja-aframe 11.0 0)))
          )
        )
      )
    (go-virtual gun-shoot)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (when (logtest? (enemy-flag ef37) (-> a0-0 enemy-flags))
        (vector-v++!
          (-> self root transv)
          (compute-acc-due-to-gravity (-> self root) (new 'stack-no-clear 'vector) 0.0)
          )
        (let ((a2-1 (new 'stack-no-clear 'collide-query))
              (a0-5 (-> self root))
              )
          (set! (-> a2-1 collide-with) (-> a0-5 root-prim prim-core collide-with))
          (set! (-> a2-1 ignore-process0) self)
          (set! (-> a2-1 ignore-process1) #f)
          (set! (-> a2-1 ignore-pat) (-> a0-5 pat-ignore-mask))
          (set! (-> a2-1 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide a0-5 (-> self root transv) a2-1 (meters 0))
          )
        )
      )
    (nav-enemy-simple-post)
    )
  )

(defstate roll-left (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :code (behavior ()
    (vector-reset! (-> self root transv))
    (vector-x-quaternion! (-> self root transv) (-> self root quat))
    (set! (-> self root transv y) 24576.0)
    (vector-xz-normalize! (-> self root transv) -40960.0)
    (let ((v1-7 self))
      (if (not (logtest? (enemy-flag ef37) (-> v1-7 enemy-flags)))
          (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef39) (-> v1-7 enemy-flags))))
          )
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag ef37) (-> v1-7 enemy-flags))))
      (set! (-> v1-7 nav callback-info) (-> v1-7 enemy-info callback-info))
      )
    0
    (ja-channel-push! 1 (seconds 0.1))
    (cond
      ((logtest? (enemy-flag drawn-mirrored) (-> self enemy-flags))
       (ja-no-eval :group! crimson-guard-jump-left-ja :num! (seek! (ja-aframe 9.0 0)) :frame-num (ja-aframe 0.0 0))
       (until (ja-done? 0)
         (let ((a0-20 (the-as process-focusable (handle->process (-> self focus handle)))))
           (if a0-20
               (seek-toward-heading-vec!
                 (-> self root)
                 (vector-! (new 'stack-no-clear 'vector) (get-trans a0-20 0) (-> self root trans))
                 32768.0
                 (seconds 0.05)
                 )
               )
           )
         (suspend)
         (ja :num! (seek! (ja-aframe 9.0 0)))
         )
       )
      (else
        (ja-no-eval :group! crimson-guard-jump-right-ja :num! (seek! (ja-aframe 6.0 0)) :frame-num (ja-aframe 0.0 0))
        (until (ja-done? 0)
          (let ((a0-33 (the-as process-focusable (handle->process (-> self focus handle)))))
            (if a0-33
                (seek-toward-heading-vec!
                  (-> self root)
                  (vector-! (new 'stack-no-clear 'vector) (get-trans a0-33 0) (-> self root trans))
                  32768.0
                  (seconds 0.05)
                  )
                )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 6.0 0)))
          )
        )
      )
    (let ((v1-58 self))
      (set! (-> v1-58 enemy-flags) (the-as enemy-flag (logclear (-> v1-58 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-58 nav callback-info) *null-nav-callback-info*)
      )
    0
    (cond
      ((logtest? (enemy-flag drawn-mirrored) (-> self enemy-flags))
       (ja-no-eval :group! crimson-guard-jump-left-ja :num! (seek! (ja-aframe 11.0 0)) :frame-num (ja-aframe 9.0 0))
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 11.0 0)))
         )
       )
      (else
        (ja-no-eval :group! crimson-guard-jump-right-ja :num! (seek! (ja-aframe 11.0 0)) :frame-num (ja-aframe 6.0 0))
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! (ja-aframe 11.0 0)))
          )
        )
      )
    (go-virtual gun-shoot)
    )
  :post (-> (method-of-type crimson-guard roll-right) post)
  )

(defstate arrest (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag lock-focus))
    (nav-enemy-method-178 self)
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-4 nav callback-info) *null-nav-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag ef38))))
      )
    0
    (vector-reset! (-> self root transv))
    (let ((a0-9 (-> self nav state))
          (v1-12 *null-vector*)
          )
      (set! (-> a0-9 velocity quad) (-> v1-12 quad))
      )
    0
    (set-time! (-> self state-time))
    (set-time! (-> self last-time-see-target))
    (set! (-> self miss-amount) 0.0)
    (set-time! (-> self next-shot))
    (set! (-> self joint-enable) #t)
    (crimson-guard-method-262 self)
    )
  :exit (behavior ()
    (set! (-> self joint-enable) #f)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    )
  :trans (behavior ()
    (send-event (handle->process (-> self focus handle)) 'arrest)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (ja-no-eval :group! crimson-guard-idle-to-stab-idle-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (seek-toward-heading-vec! (-> self root) (-> self target-self-xz) 65536.0 (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (until #f
      (if (or (not (logtest? (-> self flags) (citizen-flag target-in-sight)))
              (< 49152.0 (-> self target-self-xz-dist))
              (< 10922.667 (fabs (-> self target-y-angle)))
              )
          (goto cfg-17)
          )
      (ja-no-eval :group! crimson-guard-stab-idle-loop-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (label cfg-17)
    (let ((f30-1 (rnd-float-range self 0.9 1.1)))
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! crimson-guard-stab-idle-to-idle-ja :num! (seek! max f30-1) :frame-num 0.0)
      (until (ja-done? 0)
        (seek-toward-heading-vec! (-> self root) (-> self target-self-xz) 65536.0 (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (go-hostile self)
    )
  :post (behavior ()
    (citizen-method-213 self)
    (nav-enemy-simple-post)
    )
  )

(defstate waiting-ambush (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag lock-focus))
    (nav-enemy-method-178 self)
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag ef37))))
      (set! (-> v1-4 nav callback-info) *null-nav-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag ef38))))
      )
    0
    (vector-reset! (-> self root transv))
    (let ((a0-9 (-> self nav state))
          (v1-12 *null-vector*)
          )
      (set! (-> a0-9 velocity quad) (-> v1-12 quad))
      )
    0
    (set-time! (-> self state-time))
    (set! (-> self miss-amount) 0.0)
    (set-time! (-> self next-shot))
    (set! (-> self joint-enable) #t)
    (crimson-guard-method-262 self)
    )
  :exit (behavior ()
    (set! (-> self joint-enable) #f)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (ja-no-eval :group! crimson-guard-idle-to-stab-idle-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (while (not (logtest? (-> self flags) (citizen-flag target-in-sight)))
      (ja-no-eval :group! crimson-guard-stab-idle-loop-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (let ((f30-1 (rnd-float-range self 0.9 1.1)))
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! crimson-guard-stab-idle-to-idle-ja :num! (seek! max f30-1) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (go-hostile self)
    )
  :post (behavior ()
    (seek-toward-heading-vec! (-> self root) (-> self target-self-xz) 65536.0 (seconds 0.02))
    (nav-enemy-simple-post)
    )
  )

(defstate exit-transport (crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self nav flags) (nav-control-flag output-sphere-hash))
    (logclear! (-> self flags) (citizen-flag hostile))
    (nav-enemy-method-177 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self enemy-info run-travel-speed)))
      )
    0
    (set! (-> self already-shot) #f)
    )
  :exit (behavior ()
    (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
    (if (-> self nav)
        (logclear! (-> self nav flags) (nav-control-flag output-sphere-hash))
        )
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (not (-> self already-shot))
        (crimson-guard-method-265 self 1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (set! (-> gp-0 quad) (-> self root trans quad))
          (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                (s5-0 (new 'stack 'collide-query))
                )
            (let ((a0-3 gp-0))
              (let ((v1-8 gp-0))
                (let ((a1-4 20480.0))
                  (.mov vf7 a1-4)
                  )
                (.lvf vf5 (&-> s4-0 quad))
                (.lvf vf4 (&-> v1-8 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a0-3 quad) vf6)
              )
            (if (enemy-above-ground? self s5-0 gp-0 (collide-spec backgnd) 8192.0 81920.0 1024.0)
                (set! (-> gp-0 y) (-> s5-0 best-other-tri intersect y))
                )
            )
          )
        (when (!= (crimson-guard-method-266 self (-> self event-param-point)) 0.0)
          (let* ((v1-16 (-> self nav))
                 (a1-7 (-> self event-param-point))
                 (f0-3 (-> v1-16 extra-nav-sphere w))
                 )
            (set! (-> v1-16 extra-nav-sphere quad) (-> a1-7 quad))
            (set! (-> v1-16 extra-nav-sphere w) f0-3)
            )
          0
          (let ((v1-19 (-> self nav)))
            (set! (-> v1-19 extra-nav-sphere w) (-> self nav-radius-backup))
            )
          0
          (let ((v1-21 (-> self nav)))
            (logior! (-> v1-21 shape nav-flags) (nav-flags has-extra-sphere))
            )
          0
          (set! (-> self already-shot) #t)
          )
        (crimson-guard-method-265 self 0.0)
        )
      )
    )
  :code (behavior ()
    (while (not (-> self already-shot))
      (suspend)
      )
    (set-time! (-> self state-time))
    (ja-channel-set! 1)
    (let ((gp-0 (current-time))
          (s5-0 150)
          (f30-0 2.0)
          )
      (ja-no-eval :group! crimson-guard-run-ja :num! (loop! f30-0) :frame-num 0.0)
      (until (time-elapsed? gp-0 s5-0)
        (crimson-guard-method-265 self (* 0.006666667 (the float (- (current-time) (-> self state-time)))))
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    (set! (-> self enemy-flags)
          (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag jump-check-blocked)))
          )
    (send-event self 'jump 0 (-> self event-param-point))
    (sleep-code)
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; WARN: Return type mismatch int vs object.
(defmethod go-hostile ((this crimson-guard))
  (let ((v1-2 (handle->process (-> this focus handle))))
    (cond
      (v1-2
        (logior! (-> this flags) (citizen-flag hostile))
        (if (and (not (logtest? (-> v1-2 mask) (process-mask target)))
                 (-> this next-state)
                 (= (-> this next-state name) 'active)
                 )
            (speech-control-method-13 *speech-control* this (speech-type guard-go-hostile) (-> this traffic-id))
            )
        (cond
          (#f
            )
          (else
            (case (-> this guard-type)
              (((guard-type rifle))
               (go (method-of-object this rifle-hostile))
               )
              (((guard-type tazer))
               (go (method-of-object this tazer-hostile))
               )
              (((guard-type grenade))
               (go (method-of-object this grenade-hostile))
               )
              )
            )
          )
        )
      (else
        (go (method-of-object this active))
        )
      )
    )
  0
  )
