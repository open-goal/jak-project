;;-*-Lisp-*-
(in-package goal)

;; name: blow-tower-obs2.gc
;; name in dgo: blow-tower-obs2
;; dgos: LCTYBLOW

(define-extern *grunt-jump-curve* curve2d-piecewise)
(define-extern *grunt-dists* curve2d-piecewise)
(define-extern *grunt-idle-shift* curve2d-fast)

;; DECOMP BEGINS

(deftype bt-roboguard (blow-tower-enemy)
  ((focus-pos              vector  :inline)
   (focus                  handle)
   (rotation-matrix        matrix  :inline)
   (me-to-focus-dir        vector  :inline)
   (me-to-focus-angle      float)
   (torso-aim-blend        float)
   (torso-angle            float)
   (torso-seek-speed       float)
   (torso-to-focus-angle   float)
   (last-torso-frame-num   float)
   (stand-angle-threshold  float)
   (fire-time              time-frame)
   (fire-count             int8)
   (fire-delay             time-frame)
   (path-clock-time        time-frame)
   (difficulty             float)
   (active-clock-time      time-frame)
   )
  (:state-methods
    hostile-stand
    shoot-attack
    )
  (:methods
    (bt-roboguard-method-40 (_type_) none)
    (bt-roboguard-method-41 (_type_) none)
    (bt-roboguard-method-42 (_type_) none)
    (fire-shot-from-joint-idx (_type_ int) none)
    (bt-roboguard-method-44 (_type_) none)
    (bt-roboguard-method-45 (_type_) symbol)
    (bt-roboguard-method-46 (_type_) object)
    )
  )


(defmethod init-from-entity! ((this bt-roboguard) (arg0 entity-actor))
  (with-pp
    (set! (-> pp level) (level-get *level* 'lblowtmh))
    (bt-roboguard-method-44 this)
    (process-drawable-from-entity! this arg0)
    (init this)
    (go (method-of-object this idle))
    )
  )

(defbehavior bt-roboguard-init-by-other bt-roboguard ((arg0 vector))
  (set! (-> self level) (level-get *level* 'lblowtmh))
  (bt-roboguard-method-44 self)
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-identity! (-> self root quat))
  (init self)
  (go-virtual idle)
  )

(defmethod bt-roboguard-method-44 ((this bt-roboguard))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec enemy los-blocker))
      (set! (-> v1-6 prim-core collide-with)
            (collide-spec backgnd jak bot enemy obstacle hit-by-others-list player-list)
            )
      (set! (-> v1-6 prim-core action) (collide-action solid semi-solid deadly no-standon))
      (set-vector! (-> v1-6 local-sphere) 0.0 12288.0 0.0 18432.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) 8192.0)
    (let ((v1-8 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-8 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-8 prim-core collide-with))
      )
    (set! (-> s5-0 event-priority) (the-as uint 8))
    (set! (-> s5-0 max-iteration-count) (the-as uint 3))
    (set! (-> this root) s5-0)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod on-death ((this bt-roboguard))
  (cond
    ((logtest? (-> *part-group-id-table* 1460 flags) (sp-group-flag sp13))
     (set! (-> *launch-matrix* trans quad) (-> (get-trans this 3) quad))
     (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1460))
     )
    (else
      (set! (-> *launch-matrix* trans quad) (-> (get-trans this 3) quad))
      (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1460))
      )
    )
  (send-event (handle->process (-> this focus)) 'bt-roboguard-release)
  (sound-play "hc-target-hit")
  (go (method-of-object this dormant))
  )

;; WARN: Return type mismatch focus-status vs none.
(defmethod blow-tower-enemy-method-36 ((this bt-roboguard))
  (set! (-> this focus) (the-as handle #f))
  (set! (-> this hit-points) 3.0)
  (logclear! (-> this focus-status) (focus-status dead))
  (none)
  )

;; WARN: Return type mismatch none vs object.
(defmethod init ((this bt-roboguard))
  (local-vars (a0-19 int))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-bt-roboguard" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set-vector! (-> this root scale) 1.5 1.5 1.5 1.0)
  (call-parent-method this)
  (blow-tower-enemy-method-35 this)
  (logclear! (-> this mask) (process-mask actor-pause))
  (let ((v1-11 (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 3) 2))
        (s5-1 0)
        )
    0
    (let* ((a0-13 10)
           (s3-0 0)
           (s4-1 (+ a0-13 -3))
           )
      (dotimes (a0-14 v1-11)
        (set! s3-0 (logior s3-0 (ash 1 a0-14)))
        )
      (dotimes (s2-0 s4-1)
        (let ((a0-16 (mod (the-as int (rand-uint31-gen *random-generator*)) s4-1))
              (a1-6 (logtest? s3-0 (ash 1 s2-0)))
              )
          (let ((v1-19 (logtest? s3-0 (ash 1 a0-16))))
            (if a1-6
                (set! a0-19 (logior s3-0 (ash 1 a0-16)))
                (set! a0-19 (logclear s3-0 (ash 1 a0-16)))
                )
            (if v1-19
                (set! s3-0 (logior a0-19 (ash 1 s2-0)))
                (set! s3-0 (logclear a0-19 (ash 1 s2-0)))
                )
            )
          )
        )
      (let ((v1-29 0))
        (dotimes (a0-23 s4-1)
          (while (or (= v1-29 0) (= v1-29 1) (= v1-29 4))
            (+! v1-29 1)
            )
          (if (logtest? s3-0 (ash 1 a0-23))
              (set! s5-1 (logior s5-1 (ash 1 v1-29)))
              )
          (+! v1-29 1)
          )
        )
      )
    (let* ((f30-0 0.2)
           (v1-34 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-35 (the-as number (logior #x3f800000 v1-34)))
           (f0-6 (+ -1.0 (the-as float v1-35)))
           )
      (cond
        ((< f0-6 (/ f30-0 2))
         (set! s5-1 (logior s5-1 2))
         )
        ((< f0-6 f30-0)
         (set! s5-1 (logior s5-1 16))
         )
        )
      )
    (setup-masks (-> this draw) -1 0)
    (setup-masks (-> this draw) 0 s5-1)
    )
  (set! (-> this focus) (the-as handle #f))
  (let ((v1-47 (-> this node-list data 4)))
    (set! (-> v1-47 param0)
          (lambda ((arg0 cspace) (arg1 transformq))
            (let ((s3-0 (the-as bt-roboguard (-> arg0 param1)))
                  (gp-0 (new 'stack-no-clear 'quaternion))
                  )
              (cspace<-parented-transformq-joint! arg0 arg1)
              (let ((s1-0 (-> s3-0 rotation-matrix))
                    (s2-1 (vector-! (new 'stack-no-clear 'vector) (-> s3-0 focus-pos) (-> arg0 bone transform trans)))
                    )
                (set! (-> s2-1 y) 0.0)
                (set! (-> s1-0 fvec y) 0.0)
                (set! (-> s1-0 rvec y) 0.0)
                (vector-xz-normalize! s2-1 1.0)
                (vector-xz-normalize! (-> s1-0 fvec) 1.0)
                (vector-xz-normalize! (-> s1-0 rvec) 1.0)
                (let ((f0-5 (acos (fmax 0.0 (vector-dot (-> s1-0 fvec) s2-1)))))
                  (if (< (vector-dot (-> s1-0 rvec) s2-1) 0.0)
                      (set! f0-5 (* -1.0 f0-5))
                      )
                  (set! (-> s3-0 torso-angle)
                        (* (-> s3-0 torso-aim-blend)
                           (seek (-> s3-0 torso-angle) f0-5 (* (-> s3-0 torso-seek-speed) (seconds-per-frame)))
                           )
                        )
                  )
                )
              (quaternion-vector-angle! gp-0 *y-vector* (-> s3-0 torso-angle))
              (quaternion*! (-> arg1 quat) (-> arg1 quat) gp-0)
              )
            (cspace<-parented-transformq-joint! arg0 arg1)
            (none)
            )
          )
    (set! (-> v1-47 param1) this)
    )
  (blow-tower-enemy-method-36 this)
  )

(defmethod bt-roboguard-method-46 ((this bt-roboguard))
  (local-vars (s5-1 object))
  (let* ((s5-0 (handle->process (-> this focus)))
         (a0-5 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (cond
      (a0-5
        (set! s5-1 (-> this focus-pos))
        (set! (-> (the-as vector s5-1) quad) (-> (get-trans (the-as process-focusable a0-5) 3) quad))
        s5-1
        )
      (else
        (when (< (vector-vector-xz-distance (-> this root trans) (camera-pos)) 737280.0)
          (set! s5-1 (-> *blow-tower-targets* target-handles (logand (rand-uint31-gen *random-generator*) 1)))
          (set! (-> this focus) (the-as handle s5-1))
          s5-1
          )
        )
      )
    )
  )

(defmethod blow-tower-enemy-method-34 ((this bt-roboguard))
  (local-vars (sv-16 int) (sv-24 time-frame))
  (bt-roboguard-method-46 this)
  (set! sv-16 (the-as int (- (-> this path-clock-time) (-> this active-clock-time))))
  (set! sv-24 (- (-> *blow-tower-targets* mission-time) (-> this active-clock-time)))
  (cond
    ((= (-> this focus) (-> *blow-tower-targets* pickup))
     (set! sv-16 (max 750 sv-16))
     )
    (else
      (set! sv-16 (max 450 sv-16))
      (set! sv-16 (the int (* 0.75 (the float sv-16))))
      )
    )
  (set! (-> this difficulty) (fmax 0.0 (fmin 1.0 (/ (the float sv-24) (the float sv-16)))))
  (cond
    ((= (-> this focus) (-> *blow-tower-targets* pickup))
     (set! (-> this difficulty) (* (-> this difficulty) (-> this difficulty)))
     )
    (else
      )
    )
  (vector-! (-> this me-to-focus-dir) (-> this focus-pos) (-> this root trans))
  (set! (-> this me-to-focus-dir y) 0.0)
  (vector-xz-normalize! (-> this me-to-focus-dir) 1.0)
  (let* ((a1-5 (-> this rotation-matrix fvec))
         (s5-0 (-> this rotation-matrix))
         (f0-8 (vector-vector-angle-safe (-> this me-to-focus-dir) a1-5))
         )
    (if (< (vector-dot (-> this me-to-focus-dir) (the-as vector s5-0)) 0.0)
        (set! f0-8 (* -1.0 f0-8))
        )
    (set! (-> this me-to-focus-angle) f0-8)
    )
  (quaternion->matrix (-> this rotation-matrix) (-> this root quat))
  (call-parent-method this)
  (set-vector! (-> this draw color-emissive) 0.2 0.2 0.2 1.0)
  (transform-post)
  (none)
  )

(defstate idle (bt-roboguard)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (set! (-> self state-time) 0)
    0
    )
  :trans (behavior ()
    (bt-roboguard-method-46 self)
    (when (handle->process (-> self focus))
      (when (time-elapsed? (-> self state-time) (seconds 0.3))
        (set-time! (-> self state-time))
        (let ((gp-0 (new 'stack-no-clear 'collide-query)))
          (set! (-> gp-0 start-pos quad) (-> self focus-pos quad))
          (vector-! (-> gp-0 move-dist) (get-trans self 3) (-> self focus-pos))
          (let ((v1-13 gp-0))
            (set! (-> v1-13 radius) 409.6)
            (set! (-> v1-13 collide-with) (collide-spec backgnd))
            (set! (-> v1-13 ignore-process0) #f)
            (set! (-> v1-13 ignore-process1) #f)
            (set! (-> v1-13 ignore-pat)
                  (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                  )
            (set! (-> v1-13 action-mask) (collide-action solid))
            )
          (cond
            ((< (fill-and-probe-using-line-sphere *collide-cache* gp-0) 0.0)
             (cond
               ((not (send-event (handle->process (-> self focus)) 'bt-roboguard-attack?))
                (set! (-> self focus) (the-as handle #f))
                )
               (else
                 (set! (-> self active-clock-time) (-> *blow-tower-targets* mission-time))
                 (let ((gp-1 (new 'stack 'blow-tower-path-cursor)))
                   (set! (-> gp-1 path) (the-as blow-tower-path (send-event (handle->process (-> self focus)) 'get-path)))
                   (cond
                     ((-> gp-1 path)
                      (blow-tower-path-cursor-method-11 gp-1 (-> self root trans))
                      (set! (-> self path-clock-time) (-> gp-1 current-time))
                      )
                     (else
                       (set! (-> self focus) (the-as handle #f))
                       )
                     )
                   )
                 (bt-roboguard-method-42 self)
                 )
               )
             )
            (else
              (send-event (handle->process (-> self focus)) 'bt-roboguard-release)
              (set! (-> self focus) (the-as handle #f))
              )
            )
          )
        )
      )
    )
  :code sleep-code
  :post ja-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod bt-roboguard-method-42 ((this bt-roboguard))
  (go (method-of-object this hostile-stand))
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defbehavior bt-roboguard-turret-code bt-roboguard ()
  (ja-channel-push! 1 (seconds 0.2))
  (ja-no-eval :group! bt-roboguard-idle-shoot0-loop-ja :num! zero)
  (suspend-for (seconds 0.2)
    )
  (let ((gp-1
          (lambda ((arg0 bt-roboguard) (arg1 symbol))
            (quaternion-rotate-y! (-> arg0 root quat) (-> arg0 root quat) (* 20480.0 (seconds-per-frame) (if arg1
                                                                                                             1.0
                                                                                                             -1.0
                                                                                                             )
                                                                             )
                                  )
            )
          )
        (f30-0 (-> self stand-angle-threshold))
        )
    (until #f
      (when (< (fabs (-> self me-to-focus-angle)) f30-0)
        (suspend-for (seconds 0.5)
          )
        (while (< (fabs (-> self me-to-focus-angle)) f30-0)
          (suspend)
          )
        )
      (ja-channel-push! 1 0)
      (let ((v1-20 (if (< 0.0 (-> self me-to-focus-angle))
                       6
                       8
                       )
                   )
            (s5-1 (< 0.0 (-> self me-to-focus-angle)))
            )
        (ja-no-eval :group! (-> self draw art-group data v1-20) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (gp-1 self s5-1)
          (suspend)
          (ja :num! (seek!))
          )
        )
      (when (< (fabs (-> self me-to-focus-angle)) f30-0)
        (suspend-for (seconds 0.5)
          )
        (while (< (fabs (-> self me-to-focus-angle)) f30-0)
          (suspend)
          )
        )
      (ja-channel-push! 1 0)
      (let ((v1-40 (if (< 0.0 (-> self me-to-focus-angle))
                       7
                       9
                       )
                   )
            (s5-3 (< 0.0 (-> self me-to-focus-angle)))
            )
        (ja-no-eval :group! (-> self draw art-group data v1-40) :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (gp-1 self s5-3)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    )
  #f
  )

(defbehavior bt-roboguard-turn-torso-post bt-roboguard ()
  (seek! (-> self torso-aim-blend) 1.0 (* 5.0 (seconds-per-frame)))
  (let ((v1-3 (joint-node bt-roboguard-lod0-jg chest))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> gp-0 quad) (-> v1-3 bone transform fvec quad))
    (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self focus-pos) (-> v1-3 bone transform trans))))
      (set! (-> gp-0 y) 0.0)
      (set! (-> s5-1 y) 0.0)
      (vector-xz-normalize! gp-0 1.0)
      (vector-xz-normalize! s5-1 1.0)
      (set! (-> self torso-to-focus-angle) (acos (vector-dot gp-0 s5-1)))
      )
    )
  (if (>= 910.2222 (-> self torso-to-focus-angle))
      (seek! (-> self torso-seek-speed) 163840.0 (* 36408.89 (seconds-per-frame)))
      (seek! (-> self torso-seek-speed) 174762.67 (* 36408.89 (seconds-per-frame)))
      )
  (blow-tower-enemy-method-34 self)
  (none)
  )

(defstate hostile-stand (bt-roboguard)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self stand-angle-threshold) 9102.223)
    )
  :trans (behavior ()
    (if (and (< (-> self path-clock-time) (-> *blow-tower-targets* mission-time)) (not (bt-roboguard-method-45 self)))
        (send-event (handle->process (-> self focus)) 'bt-roboguard-release)
        )
    (vector-vector-distance (-> self root trans) (target-pos 0))
    0.0
    (let ((f30-0 (lerp 1.0 0.75 (-> self difficulty))))
      (if (and (< (fabs (-> self torso-to-focus-angle)) 3640.889)
               (bt-roboguard-method-45 self)
               (time-elapsed? (-> self fire-delay) (the int (* 300.0 f30-0)))
               )
          (go-virtual shoot-attack)
          )
      )
    )
  :code bt-roboguard-turret-code
  :post bt-roboguard-turn-torso-post
  )

(defmethod bt-roboguard-method-45 ((this bt-roboguard))
  (let ((f0-0 (vector-vector-xz-distance (-> this focus-pos) (-> this root trans))))
    (let ((f1-0 655360.0))
      (if (< (-> this path-clock-time) (-> *blow-tower-targets* mission-time))
          (set! f1-0 143360.0)
          )
      (< f0-0 f1-0)
      )
    )
  )

(defstate shoot-attack (bt-roboguard)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self fire-time) 0)
    (set! (-> self last-torso-frame-num) 0.0)
    (set! (-> self stand-angle-threshold) 16384.0)
    (set! (-> self fire-count) 0)
    0
    )
  :trans (behavior ()
    (vector-vector-distance (-> self root trans) (target-pos 0))
    0.0
    (let ((f30-0 0.6))
      (when (time-elapsed? (-> self fire-time) (the int (* 300.0 f30-0)))
        (if (< 5461.3335 (fabs (-> self torso-to-focus-angle)))
            (go-virtual hostile-stand)
            )
        (if (not (bt-roboguard-method-45 self))
            (go-virtual hostile-stand)
            )
        (when (< (the int (lerp 4.0 6.0 (-> self difficulty))) (-> self fire-count))
          (set-time! (-> self fire-delay))
          (go-virtual hostile-stand)
          )
        (set-time! (-> self fire-time))
        )
      (let ((f30-1 (/ (* 0.0033333334 (the float (- (current-time) (-> self fire-time)))) f30-0)))
        (if (and (< 0.0 f30-1) (>= 0.0 (-> self last-torso-frame-num)))
            (fire-shot-from-joint-idx self 11)
            )
        (if (and (< 0.5 f30-1) (>= 0.5 (-> self last-torso-frame-num)))
            (fire-shot-from-joint-idx self 15)
            )
        (set! (-> self last-torso-frame-num) f30-1)
        )
      )
    )
  :code bt-roboguard-turret-code
  :post bt-roboguard-turn-torso-post
  )

(deftype bt-roboguard-shot (guard-shot)
  ()
  )


(defmethod play-impact-sound ((this bt-roboguard-shot) (arg0 projectile-options))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (sound-play "robo-fire")
       )
      ((= v1-0 (projectile-options po0))
       (sound-play "guard-shot-hit")
       )
      )
    )
  0
  (none)
  )

(defun spawn-bt-roboguard-projectile ((arg0 bt-roboguard) (arg1 vector) (arg2 vector) (arg3 float) (arg4 vector))
  (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg2 arg1)))
      (set! (-> gp-0 ent) (-> arg0 entity))
      (set! (-> gp-0 charge) 1.0)
      (set! (-> gp-0 options) (projectile-options))
      (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
      (set! (-> gp-0 notify-handle) (process->handle arg0))
      (set! (-> gp-0 owner-handle) (the-as handle #f))
      (set! (-> gp-0 target-handle) (the-as handle #f))
      (set! (-> gp-0 target-pos quad) (the-as uint128 0))
      (set! (-> gp-0 ignore-handle) (process->handle arg0))
      (let* ((a0-13 *game-info*)
             (a2-12 (+ (-> a0-13 attack-id) 1))
             )
        (set! (-> a0-13 attack-id) a2-12)
        (set! (-> gp-0 attack-id) a2-12)
        )
      (set! (-> gp-0 timeout) (seconds 4))
      (set! (-> gp-0 damage) 0.75)
      (logior! (-> gp-0 options) (projectile-options po14))
      (set! (-> gp-0 vehicle-damage-factor) 4.0)
      (logior! (-> gp-0 options) (projectile-options po15))
      (set! (-> gp-0 vehicle-impulse-factor) 4.0)
      (logior! (-> gp-0 options) (projectile-options po16))
      (if arg4
          (set! (-> gp-0 pos quad) (-> arg4 quad))
          (set! (-> gp-0 pos quad) (-> arg1 quad))
          )
      (vector-normalize-copy! (-> gp-0 vel) v1-1 arg3)
      )
    (spawn-projectile bt-roboguard-shot gp-0 arg0 *default-dead-pool*)
    )
  )

(defbehavior bt-roboguard-fire-backcheck bt-roboguard ((arg0 bt-roboguard) (arg1 vector) (arg2 vector))
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (let ((s5-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg2 1.0)))
      (set! (-> gp-0 start-pos quad) (-> (get-trans arg0 3) quad))
      (vector-! (-> gp-0 move-dist) arg1 (-> gp-0 start-pos))
      (vector+float*! (-> gp-0 move-dist) (-> gp-0 move-dist) s5-0 8192.0)
      )
    (let ((v1-6 gp-0))
      (set! (-> v1-6 radius) 40.96)
      (set! (-> v1-6 collide-with) (collide-spec backgnd hit-by-others-list pusher impenetrable-obj))
      (set! (-> v1-6 ignore-process0) #f)
      (set! (-> v1-6 ignore-process1) #f)
      (set! (-> v1-6 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-6 action-mask) (collide-action solid))
      )
    (if (>= (fill-and-probe-using-line-sphere *collide-cache* gp-0) 0.0)
        #f
        #t
        )
    )
  )

(defmethod fire-shot-from-joint-idx ((this bt-roboguard) (arg0 int))
  (let ((s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data arg0)))
        (v1-3 (-> this node-list data 4))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s4-0 quad) (-> v1-3 bone transform fvec quad))
    (set! (-> s4-0 y) 0.0)
    (let ((f0-1 (vector-vector-xz-distance s5-0 (-> this focus-pos))))
      (vector-normalize! s4-0 f0-1)
      )
    (set! (-> s4-0 y) (- (-> this focus-pos y) (-> s5-0 y)))
    (let* ((f30-0 (lerp 1.0 0.0 (-> this difficulty)))
           (f28-0 20480.0)
           (f26-0 20480.0)
           (v1-10 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-11 (the-as number (logior #x3f800000 v1-10)))
           (f1-2 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-11)))))
           )
      (+! (-> s4-0 y) (* f30-0 f1-2))
      )
    (vector-normalize! s4-0 40960.0)
    (when (bt-roboguard-fire-backcheck this s5-0 s4-0)
      (spawn-bt-roboguard-projectile
        this
        s5-0
        (vector+! (new 'stack-no-clear 'vector) s5-0 s4-0)
        819200.0
        (the-as vector #f)
        )
      (+! (-> this fire-count) 1)
      )
    )
  0
  (none)
  )

(deftype kg-flyer (tower-flyer)
  ()
  )


(defmethod init ((this kg-flyer))
  (set! (-> self level) (level-get *level* 'lblowtkg))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-kg-flyer" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set-vector! (-> this root scale) 2.0 2.0 2.0 1.0)
  (set! (-> this bob-y-scalar) 8192.0)
  (sound-play "kg-flyer-buzz" :id (-> this buzz-sound))
  (call-parent-method this)
  )

(deftype bt-mh-flyer (tower-flyer)
  ((rotation-vec         vector  :inline)
   (xz-dir               vector  :inline)
   (main-joint-movement  vector  3 :inline)
   (thrust               float   2 :offset 768)
   (engine-part          sparticle-launch-control)
   )
  (:methods
    (fly-anim (_type_ int float int int) none)
    (bt-mh-flyer-method-51 (_type_) quaternion)
    (bt-mh-flyer-method-52 (_type_) none)
    )
  )


(defmethod init ((this bt-mh-flyer))
  (set! (-> self level) (level-get *level* 'lblowtkg))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-bt-mh-flyer" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set-vector! (-> this root scale) 0.75 0.75 0.75 1.0)
  (add-connection
    *part-engine*
    this
    7
    this
    468
    (new 'static 'vector :x 1187.84 :y -3112.96 :z 1392.64 :w 163840.0)
    )
  (add-connection
    *part-engine*
    this
    7
    this
    468
    (new 'static 'vector :x -1187.84 :y -3112.96 :z 1392.64 :w 163840.0)
    )
  (add-connection *part-engine* this 7 this 2204 (new 'static 'vector :y 1433.6 :z 1228.8 :w 163840.0))
  (set! (-> this engine-part) (create-launch-control (-> *part-group-id-table* 1462) this))
  (call-parent-method this)
  )

(defmethod fly-anim ((this bt-mh-flyer) (arg0 int) (arg1 float) (arg2 int) (arg3 int))
  (local-vars (v1-1 int))
  0
  (if (< 0.0 arg1)
      (set! v1-1 arg2)
      (set! v1-1 arg3)
      )
  (let ((a3-5 (-> this skel root-channel arg0)))
    (let ((f0-2 (fabs arg1)))
      (set! (-> a3-5 frame-interp 1) f0-2)
      (set! (-> a3-5 frame-interp 0) f0-2)
      )
    (set! (-> a3-5 frame-group) (the-as art-joint-anim (-> this draw art-group data v1-1)))
    (set! (-> a3-5 param 0) 0.0)
    (set! (-> a3-5 frame-num) (-> this skel root-channel 0 frame-num))
    (joint-control-channel-group! a3-5 (the-as art-joint-anim (-> this draw art-group data v1-1)) num-func-chan)
    )
  (none)
  )

(defmethod bt-mh-flyer-method-51 ((this bt-mh-flyer))
  (let ((f30-0 0.3))
    (set! (-> (new 'stack-no-clear 'vector) quad) (-> this bob-vec quad))
    (set! (-> this xz-dir x) (-> this bobbers 0 current-speed))
    (set! (-> this xz-dir z) (/ (-> this bobbers 2 current-speed) 4))
    (let ((f26-0 (lerp-scale 0.0 10922.667 (-> this xz-dir z) f30-0 1.0))
          (f24-0 (lerp-scale 0.0 -10922.667 (-> this xz-dir z) (- f30-0) -1.0))
          (f28-0 (lerp-scale 0.0 -10922.667 (-> this xz-dir x) f30-0 1.0))
          (f30-1 (lerp-scale 0.0 10922.667 (-> this xz-dir x) (- f30-0) -1.0))
          )
      (set! (-> this rotation-vec x)
            (deg-seek (-> this rotation-vec x) (+ f26-0 f24-0) (* 4551.1113 (seconds-per-frame)))
            )
      (set! (-> this rotation-vec z)
            (deg-seek (-> this rotation-vec z) (+ f28-0 f30-1) (* 5461.3335 (seconds-per-frame)))
            )
      )
    )
  (let ((s5-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat))))
    (vector-normalize! s5-0 1.0)
    (set! (-> this rotation-vec y) (vector-y-angle s5-0))
    )
  (let ((s5-1 (new 'stack-no-clear 'matrix)))
    (new 'stack-no-clear 'vector)
    (matrix-rotate-zxy! s5-1 (-> this rotation-vec))
    (matrix->quaternion (-> this root quat) s5-1)
    )
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior bt-mh-flyer-flight-code bt-mh-flyer ()
  (until #f
    (fly-anim self 1 (-> self xz-dir x) 5 4)
    (fly-anim self 2 (-> self xz-dir z) 6 7)
    (suspend)
    (ja :num! (loop!))
    )
  #f
  (none)
  )

(defstate hovering (bt-mh-flyer)
  :virtual #t
  :trans (behavior ()
    (call-parent-state-handler trans)
    (bt-mh-flyer-method-51 self)
    )
  :code (behavior ()
    (ja-channel-push! 3 (seconds 0.2))
    (ja-no-eval :group! bt-wasp-idle-ja :num! (seek!) :frame-num 0.0)
    (let ((a0-2 (-> self skel root-channel 1)))
      (let ((f0-4 0.0))
        (set! (-> a0-2 frame-interp 1) f0-4)
        (set! (-> a0-2 frame-interp 0) f0-4)
        )
      (set! (-> a0-2 frame-group) (the-as art-joint-anim bt-wasp-idle-ja))
      (set! (-> a0-2 param 0) (the float (+ (-> (the-as art-joint-anim bt-wasp-idle-ja) frames num-frames) -1)))
      (set! (-> a0-2 param 1) 1.0)
      (set! (-> a0-2 frame-num) 0.0)
      (joint-control-channel-group! a0-2 (the-as art-joint-anim bt-wasp-idle-ja) num-func-seek!)
      )
    (let ((a0-3 (-> self skel root-channel 2)))
      (let ((f0-9 0.0))
        (set! (-> a0-3 frame-interp 1) f0-9)
        (set! (-> a0-3 frame-interp 0) f0-9)
        )
      (set! (-> a0-3 frame-group) (the-as art-joint-anim bt-wasp-idle-ja))
      (set! (-> a0-3 param 0) (the float (+ (-> (the-as art-joint-anim bt-wasp-idle-ja) frames num-frames) -1)))
      (set! (-> a0-3 param 1) 1.0)
      (set! (-> a0-3 frame-num) 0.0)
      (joint-control-channel-group! a0-3 (the-as art-joint-anim bt-wasp-idle-ja) num-func-seek!)
      )
    (bt-mh-flyer-flight-code)
    )
  :post (behavior ()
    (call-parent-state-handler post)
    (bt-mh-flyer-method-52 self)
    )
  )

(defstate charging (kg-flyer)
  :virtual #t
  :trans (behavior ()
    (sound-play "charge-loop" :id (-> self charge-sound) :position (-> self root trans))
    (call-parent-state-handler trans)
    )
  )

(defstate charging (bt-mh-flyer)
  :virtual #t
  :trans (behavior ()
    (sound-play "charge-loop" :id (-> self charge-sound) :position (-> self root trans))
    (call-parent-state-handler trans)
    (bt-mh-flyer-method-51 self)
    )
  :code bt-mh-flyer-flight-code
  :post (behavior ()
    (call-parent-state-handler post)
    (bt-mh-flyer-method-52 self)
    )
  )

(defstate fleeing (bt-mh-flyer)
  :virtual #t
  :trans (behavior ()
    (call-parent-state-handler trans)
    (bt-mh-flyer-method-51 self)
    )
  :code bt-mh-flyer-flight-code
  :post (behavior ()
    (call-parent-state-handler post)
    (bt-mh-flyer-method-52 self)
    )
  )

(defstate firing (bt-mh-flyer)
  :virtual #t
  :trans (behavior ()
    (call-parent-state-handler trans)
    (bt-mh-flyer-method-51 self)
    )
  :code (behavior ()
    (sound-play "wasp-fire")
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! bt-wasp-shoot0-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (bt-mh-flyer-flight-code)
    )
  :post (behavior ()
    (call-parent-state-handler post)
    (bt-mh-flyer-method-52 self)
    )
  )

(defstate firing (kg-flyer)
  :virtual #t
  :enter (behavior ()
    (sound-play "charge-fire")
    (call-parent-state-handler enter)
    )
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod tower-flyer-bobber-method-10 ((this tower-flyer-bobber))
  (with-pp
    (let* ((f1-2 (/ (the float (-> this current-time)) (the float (-> this total-time))))
           (f30-0 (fmax 0.0 (fmin 1.0 f1-2)))
           )
      (set! (-> this time-scalar) (lerp (-> this start-time-scalar) (-> this desired-time-scalar) f30-0))
      (set! (-> this current-speed) (* (-> this dir) (cos (* 32768.0 f30-0))))
      (let ((f1-4 (sin (* 32768.0 f30-0))))
        (set! (-> this current-val) (+ (-> this start-val) (* (-> this current-size-scalar) f1-4 (-> this dir))))
        )
      )
    (set! (-> this output-val) (* (-> this output-scale) (-> this current-val)))
    (when (< (-> this total-time) (-> this current-time))
      (set! (-> this start-val) (-> this current-val))
      (set! (-> this start-time-scalar) (-> this time-scalar))
      (set! (-> this current-time) 0)
      (tower-flyer-bobber-method-11 this)
      )
    (+! (-> this current-time)
        (max 1 (the int (* (the float (- (current-time) (-> pp clock old-frame-counter))) (-> this time-scalar))))
        )
    (none)
    )
  )

(defmethod init-fields ((this tower-flyer-bobber))
  (set! (-> this start-val) 0.0)
  (set! (-> this current-val) 0.0)
  (set! (-> this dir) 1.0)
  (set! (-> this scale-min) 0.65)
  (set! (-> this scale-max) 1.35)
  (set! (-> this current-size-scalar) 1.0)
  (set! (-> this num-iterations) 1.0)
  (set! (-> this time-scalar) 1.0)
  (set! (-> this start-time-scalar) 1.0)
  (set! (-> this desired-time-scalar) 1.0)
  (set! (-> this output-scale) 6144.0)
  (set! (-> this time-min) 0.7)
  (set! (-> this time-max) 0.8)
  (set! (-> this base-time) 1.0)
  (set! (-> this desired-time-scalar) 0.75)
  (tower-flyer-bobber-method-11 this)
  (none)
  )

(defmethod tower-flyer-bobber-method-11 ((this tower-flyer-bobber))
  (set! (-> this dir) (* -1.0 (-> this dir)))
  (let* ((f28-0 (if (< (-> this dir) 0.0)
                    (+ 1.0 (-> this current-val))
                    (- 1.0 (-> this current-val))
                    )
                )
         (f30-0 (fmin (-> this scale-min) f28-0))
         (v1-5 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
         (v1-6 (the-as number (logior #x3f800000 v1-5)))
         )
    (set! (-> this current-size-scalar)
          (+ f30-0
             (* (+ -1.0 (the-as float v1-6)) (- (fmin (-> this scale-max) f28-0) (fmin (-> this scale-min) f28-0)))
             )
          )
    )
  (let ((f0-13 (-> this current-size-scalar)))
    (set! (-> this total-time)
          (the-as time-frame (the int (* 300.0 (-> this base-time) (-> this num-iterations) f0-13)))
          )
    )
  (none)
  )

(deftype bt-grunt (blow-tower-enemy)
  ((target                        handle)
   (last-parent-xform             matrix                  :inline)
   (idle-time                     time-frame)
   (rider-index                   int16)
   (start-pos                     vector                  :inline)
   (jump-cursor                   blow-tower-path-cursor  :inline)
   (jump-start-pos                vector                  :inline)
   (jump-start-quat               quaternion              :inline)
   (jump-end-pos                  vector                  :inline)
   (jump-end-quat                 quaternion              :inline)
   (apex-height                   float)
   (total-jump-time               time-frame)
   (jump-start-time               time-frame)
   (jump-height-percentage-start  float)
   (jump-height-percentage-end    float)
   (jump-time-offset              float)
   (ragdoll-proc                  handle)
   (no-real-rider?                symbol)
   (jump-time-scalar              float)
   (start-ride-time               time-frame)
   (hit-sound                     sound-id)
   (breathe-sound                 sound-id)
   (landed-on-player?             symbol)
   )
  (:state-methods
    waiting-to-jump
    riding-land
    (riding-idle symbol)
    riding-attack
    jumping
    jumping-start
    riding-idle-ship
    ragdolled
    )
  (:methods
    (bt-grunt-method-46 (_type_) none)
    (riding-trans (_type_) symbol)
    (attack-vehicle (_type_ symbol) object)
    (calculate-jump-trajectory (_type_) float)
    (bt-grunt-method-50 (_type_) none)
    (start-ragdoll (_type_) none)
    (ragdoll-settled? (_type_) object)
    (bt-grunt-method-53 (_type_) none)
    (bt-grunt-method-54 (_type_ vector) vector)
    )
  )


(defbehavior bt-grunt-init-by-other bt-grunt ((arg0 tower-enemy-init-params))
  (set! (-> self level) (level-get *level* 'lblowtmh))
  (bt-grunt-method-46 self)
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (set! (-> self target) (-> arg0 target))
  (quaternion-identity! (-> self root quat))
  (set! (-> self jump-time-offset) (-> arg0 time-offset))
  (if (= (-> self jump-time-offset) 0.0)
      (set! (-> self jump-time-offset) 1.0)
      )
  (set! (-> self jump-time-scalar) 1.0)
  (init self)
  (go-virtual idle)
  )

(defmethod init-from-entity! ((this bt-grunt) (arg0 entity-actor))
  (with-pp
    (set! (-> pp level) (level-get *level* 'lblowtmh))
    (bt-grunt-method-46 this)
    (process-drawable-from-entity! this arg0)
    (set! (-> this target)
          (-> *blow-tower-targets*
              target-handles
              (res-lump-value arg0 'bt-target uint128 :default (the-as uint128 1) :time -1000000000.0)
              )
          )
    (set! (-> this jump-time-offset) (res-lump-float arg0 'trig-dist :default 1.0))
    (set! (-> this jump-time-scalar) (res-lump-float arg0 'jump-time-scalar :default 1.0))
    (init this)
    (go (method-of-object this idle))
    )
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod bt-grunt-method-46 ((this bt-grunt))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-smack
                                    flut
                                    )
          )
    (let ((v1-7 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-7 prim-core collide-with)
            (collide-spec backgnd jak bot crate civilian enemy obstacle hit-by-others-list player-list)
            )
      (set! (-> v1-7 prim-core action) (collide-action solid can-ride deadly no-standon))
      (set-vector! (-> v1-7 local-sphere) 0.0 6144.0 0.0 14336.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) 8192.0)
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> s5-0 max-iteration-count) (the-as uint 3))
    (set! (-> this root) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch vector vs object.
(defmethod init ((this bt-grunt))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-bt-grunt" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (call-parent-method this)
  (set! (-> this landed-on-player?) #f)
  (logclear! (-> this mask) (process-mask actor-pause))
  (blow-tower-enemy-method-35 this)
  (set! (-> this hit-sound) (new-sound-id))
  (set! (-> this breathe-sound) (new-sound-id))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1459) this))
  (let ((v0-8 (-> this start-pos)))
    (set! (-> v0-8 quad) (-> this root trans quad))
    v0-8
    )
  )

;; WARN: Return type mismatch matrix vs none.
(defmethod blow-tower-enemy-method-36 ((this bt-grunt))
  (process-entity-status! this (entity-perm-status no-kill) #t)
  (set! (-> this root trans quad) (-> this start-pos quad))
  (set-vector! (-> this root scale) 1.5 1.5 1.5 1.0)
  (set! (-> this hit-points) 5.0)
  (set! (-> this rider-index) -1)
  (init-fields (-> this jump-cursor))
  (logclear! (-> this focus-status) (focus-status dead))
  (set! (-> this apex-height) 0.0)
  (set! (-> this total-jump-time) 0)
  (set! (-> this jump-start-time) 0)
  (set! (-> this jump-height-percentage-start) 0.0)
  (set! (-> this jump-height-percentage-end) 0.0)
  (matrix-identity! (-> this last-parent-xform))
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior bt-grunt-idle-code bt-grunt ()
  (let ((gp-0 (+ (logand (rand-uint31-gen *random-generator*) 1) 1)))
    (dotimes (s5-0 (the-as int gp-0))
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! bt-grunt-idle-ja :num! (seek! max 6.0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 6.0))
        )
      )
    )
  (let* ((v1-29 (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 3) 1))
         (gp-2 (max 1 (+ v1-29 -1)))
         )
    (dotimes (s5-1 gp-2)
      (ja-channel-push! 1 (seconds 0.2))
      (let ((s4-0 (-> self skel root-channel 0)))
        (set! (-> s4-0 frame-group) (the-as art-joint-anim bt-grunt-idle2-ja))
        (set! (-> s4-0 param 0) (the float (+ (-> (the-as art-joint-anim bt-grunt-idle2-ja) frames num-frames) -1)))
        (let* ((f30-0 1.0)
               (v1-44 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-45 (the-as number (logior #x3f800000 v1-44)))
               )
          (set! (-> s4-0 param 1) (+ f30-0 (+ -1.0 (the-as float v1-45))))
          )
        (set! (-> s4-0 frame-num) 0.0)
        (joint-control-channel-group! s4-0 (the-as art-joint-anim bt-grunt-idle2-ja) num-func-seek!)
        )
      (until (ja-done? 0)
        (suspend)
        (let ((s4-1 (-> self skel root-channel 0)))
          (set! (-> s4-1 param 0) (the float (+ (-> s4-1 frame-group frames num-frames) -1)))
          (let* ((f30-1 1.0)
                 (v1-58 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                 (v1-59 (the-as number (logior #x3f800000 v1-58)))
                 )
            (set! (-> s4-1 param 1) (+ f30-1 (+ -1.0 (the-as float v1-59))))
            )
          (joint-control-channel-group-eval! s4-1 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    )
  (none)
  )

(defstate idle (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    '()
    )
  :trans (behavior ()
    (set-vector! (-> self root scale) 1.5 1.5 1.5 1.0)
    (let ((gp-0 (the-as process-focusable (handle->process (-> self target)))))
      (when gp-0
        (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> gp-0 root trans) (-> self root trans))))
          (set! (-> s5-1 y) 0.0)
          (vector-normalize! s5-1 1.0)
          (quaternion-look-at! (-> self root quat) s5-1 *up-vector*)
          )
        (when (< (vector-vector-xz-distance (-> self root trans) (get-trans gp-0 0)) 491520.0)
          (when (send-event (handle->process (-> self target)) 'predict-position (-> self jump-cursor) (-> self root trans))
            (let ((s5-3 (the int (* 300.0 (-> self jump-time-offset))))
                  (gp-1 60)
                  )
              (let ((f0-9 122880.0))
                (when (= (-> self target) (-> *blow-tower-targets* pickup))
                  (set! f0-9 143360.0)
                  (set! gp-1 0)
                  )
                (let ((f30-0 (/ f0-9 (-> self jump-time-scalar))))
                  (blow-tower-path-cursor-method-9
                    (-> self jump-cursor)
                    (+ gp-1 (- (-> self jump-cursor current-time) (the-as time-frame s5-3)))
                    )
                  (let ((s4-1 (new 'stack 'blow-tower-path-cursor)))
                    (let ((s3-0 90))
                      (if (= (-> self target) (-> *blow-tower-targets* pickup))
                          (set! s3-0 75)
                          )
                      (mem-copy! (the-as pointer s4-1) (the-as pointer (-> self jump-cursor)) 128)
                      (blow-tower-path-cursor-method-9
                        s4-1
                        (the-as int (- (-> self jump-cursor current-time) (the-as time-frame s3-0)))
                        )
                      )
                    (set! (-> self jump-cursor pos quad) (-> s4-1 pos quad))
                    )
                  (let ((s4-2 (new 'stack-no-clear 'vector)))
                    (set! (-> s4-2 quad) (-> self jump-cursor pos quad))
                    (let ((f28-0 (-> s4-2 y)))
                      (set! (-> s4-2 y) (+ f28-0 (the-as float (send-event (handle->process (-> self target)) 'predict-height))))
                      )
                    (let ((f0-12 (vector-vector-distance s4-2 (-> self root trans))))
                      (set! (-> self total-jump-time) (the-as time-frame (the int (* 300.0 (/ f0-12 f30-0)))))
                      (format
                        0
                        "Total jump time ~f, offset ~f, Dist ~m~%"
                        (* 0.0033333334 (the float (-> self total-jump-time)))
                        (* 0.0033333334 (the float s5-3))
                        f0-12
                        )
                      )
                    )
                  )
                )
              (set! (-> self jump-start-time) (- (-> self jump-cursor current-time) (-> self total-jump-time)))
              (set! (-> self jump-start-time) (- (-> self jump-start-time) (the-as time-frame gp-1)))
              )
            (go-virtual waiting-to-jump)
            )
          )
        )
      )
    )
  :code (behavior ()
    (until #f
      (bt-grunt-idle-code)
      )
    #f
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defstate waiting-to-jump (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :trans (behavior ()
    (set-vector! (-> self root scale) 1.5 1.5 1.5 1.0)
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self jump-cursor pos) (-> self root trans))))
      (set! (-> gp-1 y) 0.0)
      (vector-normalize! gp-1 1.0)
      (quaternion-look-at! (-> self root quat) gp-1 *up-vector*)
      )
    (when (and (>= (-> *blow-tower-targets* mission-time) (+ (-> self jump-start-time) (seconds -0.3)))
               (>= (-> self jump-start-time) (-> *blow-tower-targets* mission-time))
               (not (-> *blow-tower-targets* debug?))
               )
      (set! (-> self rider-index)
            (the-as int (send-event (handle->process (-> self target)) 'assign-rider (process->handle self)))
            )
      (cond
        ((>= (-> self rider-index) 0)
         (set! (-> self no-real-rider?) #f)
         (go-virtual jumping-start)
         )
        (else
          (set! (-> self rider-index) 0)
          (set! (-> self no-real-rider?) #t)
          (go-virtual jumping-start)
          )
        )
      )
    )
  :code (behavior ()
    (until #f
      (bt-grunt-idle-code)
      )
    #f
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(when (or (zero? *grunt-jump-curve*) (!= loading-level global))
  (set! *grunt-jump-curve* (new 'loading-level 'curve2d-piecewise))
  (allocate! *grunt-jump-curve* 3 'loading-level #t)
  )

(set! (-> *grunt-jump-curve* pts data 0 first) 0.0)

(set! (-> *grunt-jump-curve* pts data 0 second) 0.0)

(set! (-> *grunt-jump-curve* pts data 1 first) 0.1)

(set! (-> *grunt-jump-curve* pts data 1 second) 0.3)

(set! (-> *grunt-jump-curve* pts data 2 first) 1.0)

(set! (-> *grunt-jump-curve* pts data 2 second) 1.0)

;; WARN: Return type mismatch object vs none.
(defmethod bt-grunt-method-50 ((this bt-grunt))
  (when (-> this no-real-rider?)
    (set! (-> this rider-index)
          (the-as int (send-event (handle->process (-> this target)) 'assign-rider (process->handle this)))
          )
    (if (>= (-> this rider-index) 0)
        (set! (-> this no-real-rider?) #f)
        )
    )
  (let* ((f1-2 (/ (the float (- (-> *blow-tower-targets* mission-time) (-> this jump-start-time)))
                  (the float (-> this total-jump-time))
                  )
               )
         (s5-0 (new 'stack-no-clear 'vector))
         (f30-0 (fmax 0.0 (fmin 1.0 f1-2)))
         )
    (when (and (< 0.95 f30-0) (= (-> this target) (-> *blow-tower-targets* pickup)))
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (let ((s3-0 (new 'stack-no-clear 'quaternion)))
          (send-event (handle->process (-> this target)) 'get-rider-transform (-> this rider-index) s4-0 s3-0)
          (quaternion-slerp! (-> this jump-end-quat) (-> this jump-end-quat) s3-0 (* 10.0 (seconds-per-frame)))
          )
        (vector-lerp! (-> this jump-end-pos) (-> this jump-end-pos) s4-0 (* 10.0 (seconds-per-frame)))
        )
      (let ((t9-4 vector-lerp!)
            (a0-20 (-> this root scale))
            (a1-4 (-> this root scale))
            (a2-4 (new 'stack-no-clear 'vector))
            )
        (set! (-> a2-4 x) 1.1)
        (set! (-> a2-4 y) 1.1)
        (set! (-> a2-4 z) 1.1)
        (set! (-> a2-4 w) 1.0)
        (t9-4 a0-20 a1-4 a2-4 (* 10.0 (seconds-per-frame)))
        )
      )
    (let ((f0-14 f30-0))
      (vector-! s5-0 (-> this jump-end-pos) (-> this jump-start-pos))
      (set! (-> s5-0 y) 0.0)
      (vector+float*! (-> this root trans) (-> this jump-start-pos) s5-0 f0-14)
      )
    (let ((f0-15 f30-0))
      0.0
      (let* ((f0-16 (evaluate *grunt-jump-curve* f0-15 (loop-behavior use-default)))
             (f0-17 (* f0-16 f0-16))
             (f0-18 (lerp (-> this jump-height-percentage-start) (-> this jump-height-percentage-end) f0-17))
             (f0-20 (- (* 2.0 f0-18) (* f0-18 f0-18)))
             (f0-21 (* (-> this apex-height) f0-20))
             )
        (set! (-> this root trans y) (+ (-> this jump-start-pos y) f0-21))
        )
      )
    (let ((f28-0 f30-0))
      (when (< f28-0 0.75)
        (let ((a1-11 (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0))
              (s5-1 (new 'stack-no-clear 'quaternion))
              )
          (quaternion-look-at! s5-1 a1-11 *up-vector*)
          (quaternion-slerp! (-> this jump-start-quat) (-> this jump-start-quat) s5-1 (* 2.0 (seconds-per-frame)))
          )
        )
      (let* ((f1-16 (lerp-scale 0.0 1.0 f28-0 0.75 1.0))
             (f0-27 (fmax 0.0 (fmin 1.0 f1-16)))
             )
        (quaternion-slerp! (-> this root quat) (-> this jump-start-quat) (-> this jump-end-quat) f0-27)
        )
      )
    (if (>= f30-0 1.0)
        (go (method-of-object this riding-land))
        )
    )
  (none)
  )

(defstate jumping-start (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (change-parent self (handle->process (-> self target)))
    (sound-play "grunt-leap" :position (-> self root trans))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! bt-grunt-jump-wind-up-ja :num! (seek! max 2.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 2.0))
      )
    (go-virtual jumping)
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defstate jumping (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (calculate-jump-trajectory self)
    (if (or (< (-> self hit-points) 5.0) (< (-> self total-jump-time) (seconds 0.75)))
        (set! (-> self hit-points) 1.0)
        (set! (-> self hit-points) (fmin 2.0 (-> self hit-points)))
        )
    )
  :trans (behavior ()
    (bt-grunt-method-50 self)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! bt-grunt-jump-in-air-ja :num! (seek! max 0.5) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.5))
      )
    (sleep-code)
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defmethod calculate-jump-trajectory ((this bt-grunt))
  (set! (-> this jump-start-pos quad) (-> this root trans quad))
  (quaternion-copy! (-> this jump-start-quat) (-> this root quat))
  (let ((f30-0 (-> this jump-cursor pos y)))
    (set! (-> this jump-cursor pos y)
          (+ f30-0 (the-as float (send-event (handle->process (-> this target)) 'predict-height)))
          )
    )
  (quaternion-look-at! (-> this jump-end-quat) (-> this jump-cursor norm) *up-vector*)
  (set! (-> this jump-end-pos quad) (-> this jump-cursor pos quad))
  (send-event
    (handle->process (-> this target))
    'rider-predict-transform
    (-> this rider-index)
    (-> this jump-end-pos)
    (-> this jump-end-quat)
    )
  (let* ((f1-1 (- (-> this jump-end-pos y) (-> this jump-start-pos y)))
         (f0-4 (fmax 61440.0 (+ 12288.0 (fabs f1-1))))
         (f2-3 (/ (fabs f1-1) f0-4))
         )
    0.0
    (set! (-> this apex-height) f0-4)
    (let ((f0-5 -1.0)
          (f3-2 2.0)
          (f2-4 (- f2-3))
          )
      (cond
        ((< 0.0 f1-1)
         (set! (-> this jump-height-percentage-start) 0.0)
         (set! (-> this jump-height-percentage-end)
               (/ (- (- f3-2) (sqrtf (- (* f3-2 f3-2) (* 4.0 f2-4 f0-5)))) (* 2.0 f0-5))
               )
         )
        (else
          (let ((f1-5 (-> this jump-end-pos y)))
            (set! (-> this jump-end-pos y) (-> this jump-start-pos y))
            (set! (-> this jump-start-pos y) f1-5)
            )
          (set! (-> this jump-height-percentage-start)
                (/ (+ (- f3-2) (sqrtf (- (* f3-2 f3-2) (* 4.0 f2-4 f0-5)))) (* 2.0 f0-5))
                )
          (set! (-> this jump-height-percentage-end) 2.0)
          )
        )
      )
    )
  )

(when (or (zero? *grunt-dists*) (!= loading-level global))
  (set! *grunt-dists* (new 'loading-level 'curve2d-piecewise))
  (allocate! *grunt-dists* 5 'loading-level #t)
  )

(set! (-> *grunt-dists* pts data 0 first) 0.0)

(set! (-> *grunt-dists* pts data 0 second) 0.0)

(set! (-> *grunt-dists* pts data 1 first) 0.17)

(set! (-> *grunt-dists* pts data 1 second) 0.0)

(set! (-> *grunt-dists* pts data 2 first) 0.2)

(set! (-> *grunt-dists* pts data 2 second) -4096.0)

(set! (-> *grunt-dists* pts data 3 first) 0.66)

(set! (-> *grunt-dists* pts data 3 second) -4096.0)

(set! (-> *grunt-dists* pts data 4 first) 1.0)

(set! (-> *grunt-dists* pts data 4 second) 0.0)

(defstate riding-land (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (set-vector! (-> self root scale) 1.1 1.1 1.1 1.0)
    (cond
      ((= (-> self target) (-> *blow-tower-targets* hellcat))
       (activate! *camera-smush-control* 1638.4 90 150 1.0 0.9 (-> *display* camera-clock))
       (sound-play "grunt-land-ship")
       )
      (else
        (sound-play "grunt-land-ship")
        )
      )
    (set! (-> self entity extra vis-dist) 40960000000000.0)
    (let ((a0-13 (the-as process-focusable (handle->process (-> self target)))))
      (when a0-13
        (let ((gp-3 (vector-! (new 'stack-no-clear 'vector) (get-trans a0-13 3) (get-trans self 3))))
          (vector-normalize! gp-3 12288.0)
          (send-event (handle->process (-> self target)) 'bounce gp-3)
          )
        )
      )
    (cond
      ((-> self no-real-rider?)
       (attack-vehicle self #f)
       (on-death self)
       )
      (else
        (send-event (handle->process (-> self target)) 'grunt-rider-board)
        )
      )
    )
  :trans (behavior ()
    (riding-trans self)
    )
  :code (behavior ()
    (cond
      ((= (-> self target) (-> *blow-tower-targets* pickup))
       (ja-channel-push! 1 (seconds 0.1))
       (let ((f30-0 0.0))
         (ja-no-eval :group! bt-grunt-jump-land-ja :num! (seek! max 0.5) :frame-num 0.0)
         (until (ja-done? 0)
           (let ((f28-0 (ja-frame-num 0)))
             (if (and (< f30-0 1.0) (>= f28-0 1.0))
                 (attack-vehicle self #f)
                 )
             (set! f30-0 f28-0)
             )
           (suspend)
           (ja :num! (seek! max 0.5))
           )
         )
       )
      (else
        (ja-channel-push! 1 (seconds 0.01))
        (let ((f30-1 0.0))
          (ja-no-eval :group! bt-grunt-jump-land-ja :num! (seek! 0.2 0.5) :frame-num 0.0)
          (until (ja-done? 0)
            (let ((f28-1 (ja-frame-num 0)))
              (let ((f26-0 (/ f28-1 (the float (ja-num-frames 0))))
                    (gp-0 (new-stack-vector0))
                    )
                0.0
                (vector-float*!
                  gp-0
                  (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
                  (evaluate *grunt-dists* f26-0 (loop-behavior use-default))
                  )
                (vector+float*! (-> self root trans) (-> self root trans) gp-0 1.0)
                )
              (when (and (< f30-1 1.0) (>= f28-1 1.0))
                )
              (set! f30-1 f28-1)
              )
            (suspend)
            (ja :num! (seek! 0.2 0.5))
            )
          )
        (ja-channel-push! 1 (seconds 0.05))
        (let ((f30-2 0.0))
          (ja-no-eval :group! bt-grunt-close-attack1-ja :num! (seek! max 1.5) :frame-num 11.0)
          (until (ja-done? 0)
            (let* ((f26-1 (ja-frame-num 0))
                   (f0-27 (/ f26-1 (the float (ja-num-frames 0))))
                   (gp-1 (new-stack-vector0))
                   (f28-2 (evaluate *curve-linear-up-down* f0-27 (loop-behavior use-default)))
                   )
              (vector-float*! gp-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)) -1228.8)
              (vector+float*! gp-1 gp-1 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)) -1228.8)
              (vector+float*! (-> self root trans) (-> self root trans) gp-1 f28-2)
              (if (and (< f30-2 12.5) (>= f26-1 12.5))
                  (attack-vehicle self #f)
                  )
              (set! f30-2 f26-1)
              (suspend)
              (ja :num! (seek! max (lerp 2.0 2.0 f28-2)))
              )
            )
          )
        )
      )
    (cond
      ((= (-> self target) (-> *blow-tower-targets* hellcat))
       (set! (-> self hit-points) 5.0)
       (set! (-> self landed-on-player?) #t)
       (go-virtual riding-idle #t)
       )
      (else
        (set! (-> self hit-points) 4.0)
        (set-time! (-> self start-ride-time))
        (go-virtual riding-idle-ship)
        )
      )
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defmethod attack-vehicle ((this bt-grunt) (arg0 symbol))
  (with-pp
    (let ((f0-0 (if (= (-> this target) (-> *blow-tower-targets* hellcat))
                    8.0
                    1.5
                    )
                )
          (a1-1 (new 'stack-no-clear 'event-message-block))
          )
      (set! (-> a1-1 from) (process->ppointer pp))
      (set! (-> a1-1 num-params) 2)
      (set! (-> a1-1 message) 'attack)
      (set! (-> a1-1 param 0) (the-as uint #f))
      (let ((v1-6 (new 'static 'attack-info
                    :mask (attack-mask trans mode control id damage vehicle-damage-factor vehicle-impulse-factor)
                    )
                  )
            )
        (let* ((a0-3 *game-info*)
               (a2-1 (+ (-> a0-3 attack-id) 1))
               )
          (set! (-> a0-3 attack-id) a2-1)
          (set! (-> v1-6 id) a2-1)
          )
        (set! (-> v1-6 damage) f0-0)
        (set! (-> v1-6 vehicle-damage-factor) 1.0)
        (set! (-> v1-6 vehicle-impulse-factor) 1.0)
        (set! (-> v1-6 mode) 'eco-dark)
        (set! (-> v1-6 trans quad) (-> this root trans quad))
        (set! (-> v1-6 control) 0.0)
        (set! (-> a1-1 param 1) (the-as uint v1-6))
        )
      (send-event-function (handle->process (-> this target)) a1-1)
      )
    (cond
      ((= (-> this target) (-> *blow-tower-targets* hellcat))
       (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.4))
       (let* ((a0-16 *screen-filter*)
              (t9-2 (method-of-object a0-16 setup))
              (a1-3 (new 'stack-no-clear 'vector))
              )
         (set! (-> a1-3 x) 128.0)
         (set! (-> a1-3 y) 0.0)
         (set! (-> a1-3 z) 0.0)
         (set! (-> a1-3 w) 128.0)
         (let ((a2-4 (new 'stack-no-clear 'vector)))
           (set! (-> a2-4 x) 128.0)
           (set! (-> a2-4 y) 0.0)
           (set! (-> a2-4 z) 0.0)
           (set! (-> a2-4 w) 0.0)
           (t9-2 a0-16 a1-3 a2-4 (* 2.0 (seconds-per-frame)) (bucket-id tex-hud-pris2) #x3fffff #x33001 #f)
           )
         )
       (if arg0
           (activate! *camera-smush-control* 819.2 45 90 1.0 0.9 (-> *display* camera-clock))
           )
       )
      (else
        (sound-play "gnt-attack-p")
        )
      )
    )
  )

;; TODO
; ;; ERROR: failed type prop at 0: Could not figure out load: (set! v1 (l.d (+ a0 220)))
; ;; ERROR: Unsupported inline assembly instruction kind - [sllv a1, v1, r0]
; (defun grunt-part-callback ((a0-0 bt-grunt))
;   (local-vars
;     (v0-1 none)
;     (v0-2 none)
;     (v0-3 none)
;     (v1-0 none)
;     (v1-1 none)
;     (v1-3 none)
;     (v1-4 none)
;     (v1-5 none)
;     (v1-6 none)
;     (v1-7 none)
;     (v1-9 none)
;     (v1-10 none)
;     (v1-11 none)
;     (a0-1 none)
;     (a1-0 none)
;     (a1-1 none)
;     (a1-2 none)
;     (a1-3 none)
;     (a1-4 none)
;     (a1-5 none)
;     (a1-6 none)
;     (a1-7 none)
;     (a2-0 none)
;     (a2-1 none)
;     (a2-2 none)
;     (a2-3 none)
;     (a2-4 none)
;     (a2-5 none)
;     (a2-6 none)
;     (a2-7 none)
;     (a2-8 none)
;     (a3-0 none)
;     (a3-1 none)
;     (t0-0 none)
;     (t0-1 none)
;     (t1-0 none)
;     (t9-0 none)
;     (t9-1 none)
;     (sp-0 none)
;     (f0-0 none)
;     (f0-1 none)
;     )
;   (with-pp
;     (when (begin
;             (and (begin (set! v1-0 (the-as none (l.d (+ a0-0 220)))) (set! a1-0 (the-as none (subu-s7 v1-0))) (nonzero? a1-0))
;                  (begin
;                    (if (begin
;                          (.sllv a1-2 v1-0 r0)
;                          (set! a2-0 (the-as none (l.wu a1-2)))
;                          (set! a1-3 (the-as none (l.w (+ a2-0 40))))
;                          (set! v1-1 (the-as none (sra v1-0 32)))
;                          (= v1-1 a1-3)
;                          )
;                        (set! a1-1 (the-as none a2-0))
;                        )
;                    (set! v1-2 (the-as none a1-1))
;                    )
;                  )
;             a1-1
;             )
;       (and (begin (set! v1-3 (the-as none (l.wu (+ a1-1 68)))) v1-3) (begin
;                                                                        (set! v1-5 (the-as none (l.wu (+ a1-1 68))))
;                                                                        (set! v1-6 (the-as none (l.wu v1-5)))
;                                                                        (set! a2-1 (the-as none 'riding-idle-ship))
;                                                                        (set! v1-4 (the-as none (= v1-6 a2-1)))
;                                                                        )
;            )
;       (cond
;         ((not v1-4)
;          (set! v1-7 (the-as none (l.wu (+ a0-0 -4))))
;          (set! t9-0 (the-as none (l.wu (+ v1-7 56))))
;          (call!)
;          (set! v1-8 (the-as none v0-1))
;          (set! t9-1 (the-as none enter-state))
;          (set! v1-9 (the-as none empty-state))
;          (s.w! (+ s6-0 68) v1-9)
;          (call!)
;          )
;         (else
;           (set! v1-10 (the-as none (+ sp-0 16)))
;           (set! a2-2 (the-as none (l.wu (+ a1-1 124))))
;           (set! a2-3 (the-as none (+ a2-2 12)))
;           (set! a2-4 (the-as none (l.q a2-3)))
;           (s.q! v1-10 a2-4)
;           (set! a1-4 (the-as none (l.wu (+ a1-1 128))))
;           (set! a1-5 (the-as none (l.wu (+ a1-4 28))))
;           (set! a1-6 (the-as none (+ a1-5 0)))
;           (set! a2-5 (the-as none v1-10))
;           (set! a3-0 (the-as none v1-10))
;           (set! t0-0 (the-as none (+ a1-6 16)))
;           (set! t1-0 (the-as none #x45a66666))
;           (set! f0-0 (the-as none (gpr->fpr t1-0)))
;           (set! a2-6 (the-as none (vecplusfloattimes a2-5 a3-0 t0-0 f0-0)))
;           (set! a2-7 (the-as none v1-10))
;           (set! a3-1 (the-as none v1-10))
;           (set! a1-7 (the-as none (+ a1-6 32)))
;           (set! t0-1 (the-as none #x4599999a))
;           (set! f0-1 (the-as none (gpr->fpr t0-1)))
;           (set! a2-8 (the-as none (vecplusfloattimes a2-7 a3-1 a1-7 f0-1)))
;           (set! a0-1 (the-as none (l.wu (+ a0-0 124))))
;           (set! v0-3 (the-as none (+ a0-1 12)))
;           (set! v1-11 (the-as none (l.q v1-10)))
;           (s.q! v0-3 v1-11)
;           )
;         )
;       )
;     (ret-none)
;     )
;   )

(defmethod bt-grunt-method-54 ((this bt-grunt) (arg0 vector))
  (let ((v1-2 (-> this node-list data 0 bone transform)))
    (set! (-> arg0 quad) (-> this root trans quad))
    (vector+float*! arg0 arg0 (-> v1-2 uvec) 5324.8)
    (vector+float*! arg0 arg0 (-> v1-2 fvec) 4915.2)
    )
  arg0
  )

(defstate riding-idle-ship (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :trans (behavior ()
    (riding-trans self)
    (if (or (time-elapsed? (-> self start-ride-time) (seconds 10))
            (and (time-elapsed? (-> self start-ride-time) (seconds 1))
                 (not (logtest? (-> self draw status) (draw-control-status on-screen)))
                 )
            )
        (on-death self)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let ((gp-0 (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 3) 3)))
      (dotimes (s5-0 gp-0)
        (let ((v1-3 (mod (the-as int (rand-uint31-gen *random-generator*)) 6)))
          -0.1
          (cond
            ((zero? v1-3)
             (ja-no-eval :group! bt-grunt-mech-head-butt-ja :num! (seek! max 0.4) :frame-num 0.0)
             (until (ja-done? 0)
               (if (>= (ja-frame-num 0) 4.0)
                   (spawn (-> self part) (bt-grunt-method-54 self (new 'stack-no-clear 'vector)))
                   )
               ;; og:preserve-this
               ; (gpr->fpr ja-frame-num)
               (suspend)
               (ja :num! (seek! max 0.4))
               )
             )
            ((or (= v1-3 1) (= v1-3 2))
             (ja-no-eval :group! bt-grunt-mech-punch-left-ja :num! (seek! max 0.7) :frame-num 0.0)
             (until (ja-done? 0)
               (if (>= (ja-frame-num 0) 6.0)
                   (spawn (-> self part) (bt-grunt-method-54 self (new 'stack-no-clear 'vector)))
                   )
               ;; og:preserve-this
               ; (gpr->fpr ja-frame-num)
               (suspend)
               (ja :num! (seek! max 0.7))
               )
             )
            ((or (= v1-3 3) (= v1-3 4) (= v1-3 5))
             (ja-no-eval :group! bt-grunt-mech-double-pound-ja :num! (seek! max 0.25) :frame-num 0.0)
             (until (ja-done? 0)
               (if (>= (ja-frame-num 0) 2.1)
                   (spawn (-> self part) (bt-grunt-method-54 self (new 'stack-no-clear 'vector)))
                   )
               ;; og:preserve-this
               ; (gpr->fpr ja-frame-num)
               (suspend)
               (ja :num! (seek! max 0.25))
               )
             )
            ((or (= v1-3 6) (= v1-3 7) (= v1-3 8))
             (ja-no-eval :group! bt-grunt-mech-idle0-ja :num! (seek! max 0.2) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek! max 0.2))
               )
             )
            )
          )
        (sound-play "grunt-punch" :position (-> self root trans))
        (attack-vehicle self #f)
        )
      )
    (ja-channel-push! 1 (seconds 0.2))
    (dotimes (gp-1 1)
      (ja-no-eval :group! bt-grunt-mech-idle0-ja :num! (seek! max 0.1) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.1))
        )
      )
    (go-virtual riding-idle-ship)
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(if #t
    (set! *grunt-idle-shift* (new 'static 'curve2d-fast
                               :xs (new 'static 'vector :y -0.3 :z -0.7 :w -1.0)
                               :ys (new 'static 'vector :y 1.0 :z 1.0)
                               :one-over-x-deltas (new 'static 'vector :x 3.3333333 :z -3.3333333 :w 1.0)
                               )
          )
    )

(defstate riding-idle (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ((arg0 symbol))
    (if arg0
        (set! (-> self idle-time)
              (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 451) 150))
              )
        (set! (-> self idle-time)
              (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 451) 150))
              )
        )
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (sound-stop (-> self breathe-sound))
    )
  :trans (behavior ()
    (sound-play "grunt-breath" :id (-> self breathe-sound) :position (-> self root trans))
    (riding-trans self)
    (if (time-elapsed? (-> self state-time) (-> self idle-time))
        (go-virtual riding-attack)
        )
    (let ((f0-2 (/ (* 0.0033333334 (the float (- (current-time) (-> self state-time))))
                   (* 0.0033333334 (the float (-> self idle-time)))
                   )
                )
          )
      (+! (-> self root trans y) (* 409.6 (evaluate *grunt-idle-shift* f0-2 (loop-behavior use-default))))
      )
    )
  :code (behavior ((arg0 symbol))
    (until #f
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! bt-grunt-closeup-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defmethod bt-enemy-handler ((this bt-grunt) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('rider-eject)
     (on-death this)
     #t
     )
    (('rider-eject-if-boarded)
     (when (and (-> this next-state) (let ((v1-6 (-> this next-state name)))
                                       (or (= v1-6 'riding)
                                           (= v1-6 'ridle-idle-ship)
                                           (= v1-6 'riding-land)
                                           (= v1-6 'riding-idle)
                                           (= v1-6 'riding-attack)
                                           )
                                       )
                )
       (on-death this)
       #t
       )
     )
    (else
      (call-parent-method this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod on-hit ((this bt-grunt) (arg0 float))
  (call-parent-method this arg0)
  (sound-play "grunt-take-hit" :id (-> this hit-sound))
  0
  (none)
  )

(defstate riding-attack (bt-grunt)
  :virtual #t
  :event blow-tower-enemy-handler
  :trans (behavior ()
    (riding-trans self)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (cond
      ((zero? (mod (the-as int (rand-uint31-gen *random-generator*)) 3))
       (let ((f30-0 0.0))
         (ja-no-eval :group! bt-grunt-close-attack0-ja :num! (seek! max 1.5) :frame-num 0.0)
         (until (ja-done? 0)
           (let ((f28-0 (ja-frame-num 0)))
             (when (and (< f30-0 11.0) (>= f28-0 11.0))
               (attack-vehicle self #t)
               (sound-play "grunt-punch")
               )
             (set! f30-0 f28-0)
             )
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
       )
      (else
        (let ((f30-1 0.0))
          (ja-no-eval :group! bt-grunt-close-attack1-ja :num! (seek! max 1.5) :frame-num 0.0)
          (until (ja-done? 0)
            (let ((f28-1 (ja-frame-num 0)))
              (let* ((f0-15 (/ f28-1 (the float (ja-num-frames 0))))
                     (gp-1 (new-stack-vector0))
                     (f26-0 (evaluate *curve-linear-up-down* f0-15 (loop-behavior use-default)))
                     )
                (vector-float*! gp-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)) -1228.8)
                (vector+float*! gp-1 gp-1 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)) -1228.8)
                (vector+float*! (-> self root trans) (-> self root trans) gp-1 f26-0)
                )
              (when (and (< f30-1 12.5) (>= f28-1 12.5))
                (attack-vehicle self #t)
                (sound-play "grunt-bite")
                )
              (set! f30-1 f28-1)
              )
            (suspend)
            (ja :num! (seek! max 1.5))
            )
          )
        )
      )
    (go-virtual riding-idle #f)
    )
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defmethod riding-trans ((this bt-grunt))
  (let ((s4-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'quaternion))
        )
    (cond
      ((send-event (handle->process (-> this target)) 'get-rider-transform (-> this rider-index) s4-0 s5-0)
       (set-vector! (-> this root scale) 1.1 1.1 1.1 1.0)
       (set! (-> this root trans quad) (-> s4-0 quad))
       (quaternion-copy! (-> this root quat) s5-0)
       )
      (else
        (on-death this)
        )
      )
    )
  (quaternion->matrix (new 'stack-no-clear 'matrix) (-> this root quat))
  #f
  )

(defmethod on-death ((this bt-grunt))
  (send-event (handle->process (-> this target)) 'kill-rider (process->handle this))
  (sound-play "grunt-die")
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  (cond
    ((and (and (-> this next-state) (= (-> this next-state name) 'jumping))
          (or (not (logtest? (-> *blow-tower-speech* 9 flags) (speech-info-flag si6)))
              (and (> (-> *blow-tower-speech* 9 play-time) 0)
                   (time-elapsed? (-> *blow-tower-speech* 9 play-time) (seconds 4))
                   )
              )
          )
     (speech-play *blow-tower-speech* 9 *blow-tower-speech-list* (target-pos 0))
     )
    ((and (or (not (logtest? (-> *blow-tower-speech* 18 flags) (speech-info-flag si6)))
              (and (> (-> *blow-tower-speech* 18 play-time) 0)
                   (time-elapsed? (-> *blow-tower-speech* 18 play-time) (seconds 10))
                   )
              )
          (-> this landed-on-player?)
          )
     (speech-play *blow-tower-speech* 18 *blow-tower-speech-list* (target-pos 0))
     )
    )
  (let ((f30-0 (cond
                 ((and (-> this next-state) (let ((v1-49 (-> this next-state name)))
                                              (or (= v1-49 'waiting-to-jump) (= v1-49 'jumping-start))
                                              )
                       )
                  163840.0
                  )
                 ((and (-> this next-state) (= (-> this next-state name) 'jumping))
                  245760.0
                  )
                 ((and (-> this next-state) (= (-> this next-state name) 'riding-idle-ship))
                  204800.0
                  )
                 (else
                   327680.0
                   )
                 )
               )
        )
    (if (and (= (-> this target) (-> *blow-tower-targets* hellcat))
             (and (-> this next-state) (let ((v1-63 (-> this next-state name)))
                                         (or (= v1-63 'riding) (= v1-63 'riding-idle) (= v1-63 'riding-land))
                                         )
                  )
             )
        (vector-float*!
          (-> this last-attack-dir)
          (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat))
          -1.0
          )
        )
    (let ((a0-39 (-> this last-attack-dir)))
      (set! (-> a0-39 quad) (-> this last-attack-dir quad))
      (set! (-> a0-39 y) 0.0)
      (vector-normalize! a0-39 1.0)
      )
    (let ((f0-5 (cond
                  ((= (-> this target) (-> *blow-tower-targets* pickup))
                   (+! (-> this last-attack-dir y) 0.75)
                   (* 0.75 f30-0)
                   )
                  (else
                    (+! (-> this last-attack-dir y) 0.25)
                    (* 0.95 f30-0)
                    )
                  )
                )
          )
      (vector-float*! (-> this root transv) (-> this last-attack-dir) f0-5)
      )
    )
  (go (method-of-object this ragdolled))
  )

(defstate dormant (bt-grunt)
  :virtual #t
  :enter (behavior ()
    (call-parent-state-handler enter)
    (set! (-> self root trans quad) (-> self start-pos quad))
    (set! (-> self entity extra vis-dist) 819200.0)
    )
  :exit (behavior ()
    (initialize (-> self part) (-> *part-group-id-table* 1459) self)
    )
  )

(defmethod deactivate ((this bt-grunt))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (set! (-> this entity extra vis-dist) 819200.0)
  (sound-stop (-> this breathe-sound))
  (call-parent-method this)
  (none)
  )

(defstate ragdolled (bt-grunt)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    (start-ragdoll self)
    )
  :exit (behavior ()
    (let ((a0-1 (handle->process (-> self ragdoll-proc))))
      (if a0-1
          (deactivate a0-1)
          )
      )
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 0.2))
        (logior! (-> self focus-status) (focus-status dead))
        )
    )
  :code (behavior ()
    (suspend-for (seconds 0.3)
      )
    (until #f
      (suspend)
      (when (ragdoll-settled? self)
        (if (-> self skel effect)
            (logior! (-> self skel effect flags) (effect-control-flag ecf1))
            )
        (do-effect (-> self skel effect) "death-default" 0.0 -1)
        (suspend-for (seconds 0.3)
          )
        (logior! (-> self draw status) (draw-control-status no-draw))
        (suspend-for (seconds 0.8)
          )
        (go-virtual dormant)
        )
      )
    #f
    )
  :post transform-post
  )

(deftype bt-missile (blow-tower-enemy)
  ((xforms                   xform               4 :inline)
   (parent-xform             xform               :inline :overlay-at (-> xforms 0))
   (last-parent-quat         quaternion          :inline)
   (local-xform              xform               :inline :overlay-at (-> xforms 1))
   (base-y                   float)
   (bob-xform                xform               :inline :overlay-at (-> xforms 2))
   (bob-orient               xform               :inline :overlay-at (-> xforms 3))
   (bobbers                  tower-flyer-bobber  3 :inline)
   (target                   handle)
   (chase-start-time         time-frame)
   (chase-end-time           time-frame)
   (chase-start-dist         float)
   (preferred-height-offset  float)
   (particle-trail           sparticle-subsampler)
   (travel-sound             uint32)
   (dumb-fire?               symbol)
   (dumb-speed               float)
   (dumb-start               vector              :inline)
   (dumb-dest                vector              :inline)
   )
  (:state-methods
    chasing
    explode
    )
  (:methods
    (chase-trans (_type_) none)
    )
  )


(defbehavior bt-missile-init-by-other bt-missile ((arg0 tower-enemy-init-params))
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-2 prim-core collide-with) (collide-spec obstacle))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (set! (-> self target) (-> arg0 target))
  (set! (-> self chase-start-time) (-> arg0 activate-time))
  (set! (-> self dumb-fire?) (-> arg0 bool-userdata?))
  (let* ((v1-13 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
         (v1-14 (the-as number (logior #x3f800000 v1-13)))
         (f30-0 (+ -1.0 (the-as float v1-14)))
         )
    (set! (-> self chase-end-time)
          (+ (-> self chase-start-time) (the int (* 300.0 (lerp 3.0 3.0 f30-0) (-> arg0 time-offset))))
          )
    (set! (-> self chase-start-dist)
          (+ (* 122880.0 (sqrtf (-> arg0 time-offset))) (* (-> arg0 time-offset) (lerp 0.0 40960.0 f30-0)))
          )
    )
  (when (-> self dumb-fire?)
    (set! (-> self chase-end-time) (+ (-> self chase-start-time) (the int (* 300.0 (-> arg0 time-offset)))))
    (let ((gp-1 (new 'stack 'blow-tower-path-cursor)))
      (when (send-event (handle->process (-> self target)) 'predict-position gp-1 (-> self root trans))
        (blow-tower-path-cursor-method-9 gp-1 (the-as int (-> self chase-end-time)))
        (set! (-> self dumb-dest quad) (-> gp-1 pos quad))
        (+! (-> self dumb-dest y) 8192.0)
        (let ((f30-1 (-> self dumb-dest y)))
          (set! (-> self dumb-dest y)
                (+ f30-1 (the-as float (send-event (handle->process (-> self target)) 'predict-height)))
                )
          )
        (set! (-> self dumb-start quad) (-> self root trans quad))
        )
      )
    )
  (let* ((f30-2 -10240.0)
         (f28-2 22528.0)
         (v1-49 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
         (v1-50 (the-as number (logior #x3f800000 v1-49)))
         )
    (set! (-> self preferred-height-offset) (+ f30-2 (* f28-2 (+ -1.0 (the-as float v1-50)))))
    )
  (init self)
  (go-virtual idle)
  )

;; WARN: Return type mismatch sound-id vs object.
(defmethod init ((this bt-missile))
  (set! (-> self level) (level-get *level* 'lblowtkg))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-bt-missile" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (dotimes (s5-1 3)
    (init-fields (-> this bobbers s5-1))
    )
  (dotimes (s5-2 4)
    (reset (-> this xforms s5-2))
    )
  self
  (set! (-> this particle-trail)
        (new 'process 'sparticle-subsampler *sp-particle-system-2d* (-> *part-id-table* 4806) 4.0)
        )
  (call-parent-method this)
  (set! (-> this hit-points) 2.0)
  (let ((v0-8 (new-sound-id)))
    (set! (-> this travel-sound) (the-as uint v0-8))
    v0-8
    )
  )

(defstate idle (bt-missile)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :trans (behavior ()
    (when (< (-> self chase-start-time) (-> *blow-tower-targets* mission-time))
      (logclear! (-> self draw status) (draw-control-status no-draw))
      (sound-play "missile-launch")
      (go-virtual chasing)
      )
    )
  :code sleep-code
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defstate chasing (bt-missile)
  :virtual #t
  :event blow-tower-enemy-handler
  :enter (behavior ()
    (let* ((gp-0 (handle->process (-> self target)))
           (v1-3 (if (type? gp-0 process-focusable)
                     (the-as process-focusable gp-0)
                     )
                 )
           )
      (when v1-3
        (set! (-> self base-y) (-> v1-3 root trans y))
        (quaternion-copy! (-> self last-parent-quat) (-> v1-3 root quat))
        )
      )
    )
  :trans (behavior ()
    (sound-play "bt-missile" :id (the-as sound-id (-> self travel-sound)) :position (-> self root trans))
    (chase-trans self)
    )
  :code sleep-code
  :post (behavior ()
    (blow-tower-enemy-method-34 self)
    (transform-post)
    )
  )

(defmethod deactivate ((this bt-missile))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (sound-stop (the-as sound-id (-> this travel-sound)))
  (call-parent-method this)
  (none)
  )

;; WARN: Return type mismatch matrix vs none.
(defmethod chase-trans ((this bt-missile))
  (let ((f30-0 (/ (the float (- (-> *blow-tower-targets* mission-time) (-> this chase-start-time)))
                  (the float (- (-> this chase-end-time) (-> this chase-start-time)))
                  )
               )
        )
    (if (>= f30-0 1.0)
        (go (method-of-object this explode))
        )
    (cond
      ((-> this dumb-fire?)
       (quaternion-identity! (-> this local-xform root quat))
       (set! (-> this local-xform root trans quad) (the-as uint128 0))
       (set! (-> this local-xform root trans w) 1.0)
       (let ((s5-0 (-> this xforms))
             (s4-1 (vector-! (new 'stack-no-clear 'vector) (-> this dumb-dest) (-> this dumb-start)))
             (s3-0 (new 'stack-no-clear 'matrix))
             )
         (vector-lerp! (the-as vector (-> s5-0 0)) (-> this dumb-start) (-> this dumb-dest) f30-0)
         (vector-normalize! s4-1 1.0)
         (matrix-f-u-compose s3-0 s4-1 *up-vector*)
         (matrix->quaternion (-> s5-0 0 root quat) s3-0)
         )
       )
      (else
        (set! f30-0 (fmax 0.0 (fmin 1.0 f30-0)))
        (set! (-> this local-xform root trans z) (- (lerp (-> this chase-start-dist) 16384.0 f30-0)))
        (set! (-> this local-xform root trans y) (lerp (-> this preferred-height-offset) 0.0 f30-0))
        (set! (-> this local-xform root trans w) 1.0)
        (let* ((s5-1 (-> this xforms))
               (s3-1 (handle->process (-> this target)))
               (s4-2 (if (type? s3-1 process-focusable)
                         (the-as process-focusable s3-1)
                         )
                     )
               )
          (when s4-2
            (set! (-> s5-1 0 root trans quad) (-> (get-trans s4-2 3) quad))
            (let ((s4-3 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> s4-2 root quat))))
              (set! (-> s4-3 y) 0.0)
              (vector-normalize! s4-3 1.0)
              (quaternion-look-at! (-> s5-1 0 root quat) s4-3 *up-vector*)
              )
            (let* ((f0-12 (lerp 8.0 8.0 f30-0))
                   (f0-14 (fmin 1.0 (* f0-12 (seconds-per-frame))))
                   )
              (quaternion-slerp! (-> s5-1 0 root quat) (-> this last-parent-quat) (-> s5-1 0 root quat) f0-14)
              )
            (quaternion-copy! (-> this last-parent-quat) (-> s5-1 0 root quat))
            (set! (-> s5-1 0 root trans w) 1.0)
            )
          )
        )
      )
    (set! (-> this bobbers 0 output-scale) 8192.0)
    (set! (-> this bobbers 1 output-scale) 16384.0)
    (set! (-> this bobbers 1 base-time) 0.95)
    (set! (-> this bobbers 2 output-scale) 6144.0)
    (set! (-> this bobbers 2 base-time) 1.1)
    (dotimes (s5-2 3)
      (tower-flyer-bobber-method-10 (-> this bobbers s5-2))
      )
    (let ((v1-42 (new 'stack-no-clear 'vector)))
      (set! (-> v1-42 x) (-> this bobbers 0 output-val))
      (set! (-> v1-42 y) (-> this bobbers 1 output-val))
      (set! (-> v1-42 z) (-> this bobbers 2 output-val))
      (set! (-> v1-42 w) 1.0)
      (set! (-> this bob-xform root trans quad) (-> v1-42 quad))
      )
    (when (= (-> this target) (-> *blow-tower-targets* hellcat))
      (let ((f0-26 (- 1.0 (* f30-0 f30-0))))
        (vector-float*! (the-as vector (-> this bob-xform)) (the-as vector (-> this bob-xform)) 2.0)
        (vector-float*! (the-as vector (-> this bob-xform)) (the-as vector (-> this bob-xform)) f0-26)
        )
      )
    )
  (let ((s5-3 (reset (new 'stack-no-clear 'xform))))
    (process-xform-list s5-3 s5-3 (-> this xforms) 2)
    (when (not (-> this dumb-fire?))
      (set! (-> this base-y) (lerp (-> this base-y) (-> s5-3 root trans y) (* 2.0 (seconds-per-frame))))
      (set! (-> s5-3 root trans y) (-> this base-y))
      )
    (process-xform-list s5-3 s5-3 (the-as (inline-array xform) (-> this bob-xform)) 1)
    (set! (-> this root trans quad) (-> s5-3 root trans quad))
    (let ((s3-3 (new 'stack-no-clear 'vector)))
      (set! (-> s3-3 x) (-> this bobbers 0 current-speed))
      (set! (-> s3-3 y) (-> this bobbers 1 current-speed))
      (set! (-> s3-3 z) (-> this bobbers 2 current-speed))
      (set! (-> s3-3 w) 1.0)
      (let ((s4-4 (new 'stack-no-clear 'quaternion)))
        (vector-normalize! s3-3 1.0)
        (+! (-> s3-3 y) 1.0)
        (set! (-> s3-3 y) (/ (-> s3-3 y) 2))
        (+! (-> s3-3 x) 1.0)
        (set! (-> s3-3 x) (/ (-> s3-3 x) 2))
        (quaternion-rotate-x!
          s4-4
          (quaternion-identity! (new 'stack-no-clear 'quaternion))
          (lerp 3640.889 -3640.889 (-> s3-3 y))
          )
        (quaternion-rotate-local-y! s4-4 s4-4 (lerp 3640.889 -3640.889 (-> s3-3 x)))
        (quaternion-slerp!
          (-> this bob-orient root quat)
          (-> this bob-orient root quat)
          s4-4
          (* 2.0 (seconds-per-frame))
          )
        )
      )
    (quaternion*! (-> s5-3 root quat) (-> s5-3 root quat) (-> this bob-orient root quat))
    (quaternion-copy! (-> this root quat) (-> s5-3 root quat))
    )
  (let ((a1-28 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> this root quat))))
    (vector+float*! (-> a1-28 trans) (-> this root trans) (-> a1-28 fvec) -10240.0)
    (init-with-mat! (-> this particle-trail) a1-28)
    )
  (none)
  )

(defmethod relocate ((this bt-missile) (offset int))
  (if (nonzero? (-> this particle-trail))
      (&+! (-> this particle-trail) offset)
      )
  (call-parent-method this offset)
  )

(defstate explode (bt-missile)
  :virtual #t
  :enter (behavior ()
    (sound-stop (the-as sound-id (-> self travel-sound)))
    (sound-play "missile-explode")
    (let ((v1-3 (get-trans self 3)))
      (cond
        ((logtest? (-> *part-group-id-table* 218 flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> v1-3 quad))
         (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 218))
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> v1-3 quad))
          (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 218))
          )
        )
      )
    (let ((f30-0 6.0))
      (when (= (-> self target) (-> *blow-tower-targets* hellcat))
        (sound-play "hellcat-hit")
        (set! f30-0 (cond
                      ((not (time-elapsed? (-> *blow-tower-targets* last-player-attack-time) (seconds 0.75)))
                       2.0
                       )
                      (else
                        (if (and (not (logtest? (rand-uint31-gen *random-generator*) 1))
                                 (or (not (logtest? (-> *blow-tower-speech* 19 flags) (speech-info-flag si6)))
                                     (and (> (-> *blow-tower-speech* 19 play-time) 0)
                                          (time-elapsed? (-> *blow-tower-speech* 19 play-time) (seconds 4))
                                          )
                                     )
                                 )
                            (speech-play *blow-tower-speech* 19 *blow-tower-speech-list* (target-pos 0))
                            )
                        f30-0
                        )
                      )
              )
        (set-time! (-> *blow-tower-targets* last-player-attack-time))
        )
      (format 0 "Damage missile is ~f~%" f30-0)
      (let ((a1-11 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-11 from) (process->ppointer self))
        (set! (-> a1-11 num-params) 2)
        (set! (-> a1-11 message) 'attack)
        (set! (-> a1-11 param 0) (the-as uint #f))
        (let ((v1-59 (new 'static 'attack-info
                       :mask (attack-mask trans mode id damage vehicle-damage-factor vehicle-impulse-factor)
                       )
                     )
              )
          (let* ((a0-35 *game-info*)
                 (a2-15 (+ (-> a0-35 attack-id) 1))
                 )
            (set! (-> a0-35 attack-id) a2-15)
            (set! (-> v1-59 id) a2-15)
            )
          (set! (-> v1-59 damage) f30-0)
          (set! (-> v1-59 vehicle-damage-factor) 1.0)
          (set! (-> v1-59 vehicle-impulse-factor) 1.0)
          (set! (-> v1-59 mode) 'eco-dark)
          (set! (-> v1-59 trans quad) (-> self root trans quad))
          (set! (-> a1-11 param 1) (the-as uint v1-59))
          )
        (send-event-function (handle->process (-> self target)) a1-11)
        )
      )
    )
  :code nothing
  )

;; WARN: Return type mismatch vector vs none.
(defmethod start-ragdoll ((this bt-grunt))
  (set! (-> this ragdoll-proc)
        (ppointer->handle
          (process-spawn ragdoll-proc *bt-grunt-ragdoll-info* :name "ragdoll-proc" :to this :stack-size #x5000)
          )
        )
  (let ((s5-1 (handle->process (-> this ragdoll-proc))))
    (when s5-1
      (when (not s5-1)
        (format 0 "deactivated ~A because a ragdoll allocate failed~%" (-> this name))
        (deactivate this)
        )
      (if (-> (the-as ragdoll-proc s5-1) ragdoll)
          (logior! (-> (the-as ragdoll-proc s5-1) ragdoll ragdoll-flags) (ragdoll-flag rf3 rf4))
          )
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (vector-float*! s4-0 (-> this root transv) (seconds-per-frame))
        (ragdoll-proc-method-15 (the-as ragdoll-proc s5-1) #f (the-as vector #f) #t)
        (ragdoll-method-23 (-> (the-as ragdoll-proc s5-1) ragdoll) (-> this root trans) s4-0 1.0 #t)
        (set! (-> (the-as ragdoll-proc s5-1) ragdoll ragdoll-joints 0 velocity quad) (-> s4-0 quad))
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod ragdoll-settled? ((this bt-grunt))
  (local-vars (f0-0 float))
  (let ((gp-0 (the-as ragdoll-proc (handle->process (-> this ragdoll-proc)))))
    (or (not gp-0)
        (or (ragdoll-proc-method-19 gp-0)
            (and (time-elapsed? (-> this state-time) (seconds 0.5))
                 (let ((f1-0 4096.0))
                   (set! f0-0 364.0889)
                   (< (vector-length (-> gp-0 ragdoll ragdoll-joints 0 velocity)) (* f1-0 (seconds-per-frame)))
                   )
                 (< (cos (* f0-0 (seconds-per-frame))) (-> gp-0 ragdoll rotate-vel w))
                 )
            )
        )
    )
  )

(defmethod run-logic? ((this bt-grunt))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

;; WARN: Return type mismatch float vs none.
(defmethod bt-grunt-method-53 ((this bt-grunt))
  (fmax
    0.0
    (fmin
      1.0
      (lerp-scale-clamp 0.0 1.0 (vector-vector-distance (-> this root trans) (math-camera-pos)) 204800.0 532480.0)
      )
    )
  (vector-vector-distance (-> this root trans) (math-camera-pos))
  (let ((f30-1 0.0))
    (set! (-> this draw color-mult x) (lerp 1.0 2.0 f30-1))
    (set! (-> this draw color-mult y) (lerp 1.0 0.5 f30-1))
    (set! (-> this draw color-mult z) (lerp 1.0 0.6999 f30-1))
    (set! (-> this draw color-emissive x) (* 1.7 f30-1))
    (set! (-> this draw color-emissive y) f30-1)
    (set! (-> this draw color-emissive z) (* 0.6999 f30-1))
    )
  (none)
  )

(defmethod blow-tower-enemy-method-34 ((this bt-grunt))
  (call-parent-method this)
  (bt-grunt-method-53 this)
  (none)
  )

(defmethod blow-tower-enemy-method-34 ((this bt-mh-flyer))
  (logior! (-> this skel status) (joint-control-status sync-math))
  (sound-play "wasp-jets" :id (-> this buzz-sound) :position (-> this root trans))
  (call-parent-method this)
  (none)
  )

(defmethod bt-mh-flyer-method-52 ((this bt-mh-flyer))
  (local-vars (at-0 int) (at-1 int))
  (with-pp
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((a0-2 (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data 3)))
            (v1-1 (new 'stack-no-clear 'vector))
            )
        (let ((a1-1 (new 'stack-no-clear 'vector)))
          (vector-! v1-1 a0-2 (the-as vector (-> this main-joint-movement)))
          (let ((a2-1 v1-1))
            (.lvf vf1 (&-> v1-1 quad))
            (let ((f0-0 (-> pp clock frames-per-second)))
              (.mov at-0 f0-0)
              )
            (.mov vf2 at-0)
            (.mov.vf vf1 vf0 :mask #b1000)
            (.mul.x.vf vf1 vf1 vf2 :mask #b111)
            (.svf (&-> a2-1 quad) vf1)
            )
          (vector-! a1-1 v1-1 (-> this main-joint-movement 1))
          (let ((a2-3 (-> this main-joint-movement 2)))
            (.lvf vf1 (&-> a1-1 quad))
            (let ((f0-1 (-> pp clock frames-per-second)))
              (.mov at-1 f0-1)
              )
            (.mov vf2 at-1)
            (.mov.vf vf1 vf0 :mask #b1000)
            (.mul.x.vf vf1 vf1 vf2 :mask #b111)
            (.svf (&-> a2-3 quad) vf1)
            )
          )
        (set! (-> this main-joint-movement 0 quad) (-> a0-2 quad))
        (set! (-> this main-joint-movement 1 quad) (-> v1-1 quad))
        )
      (let ((s4-0 (-> this main-joint-movement 1))
            (s5-0 (-> this main-joint-movement 2))
            (s3-0
              (lambda ((arg0 bt-mh-flyer) (arg1 cspace) (arg2 float) (arg3 float) (arg4 vector) (arg5 vector) (arg6 int))
                (local-vars (sv-192 float) (sv-208 quaternion) (sv-224 vector))
                (set! sv-192 arg2)
                (let ((s0-0 arg3))
                  (set! sv-224 arg4)
                  (let ((s1-0 arg5)
                        (s3-0 arg6)
                        (s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) arg1))
                        (s5-0 (new 'stack-no-clear 'matrix))
                        (a1-3 (matrix-with-scale->quaternion (new 'stack-no-clear 'quaternion) (-> arg1 bone transform)))
                        )
                    (set! sv-208 (new 'stack-no-clear 'quaternion))
                    (let ((s2-1 (new 'stack-no-clear 'vector)))
                      0.75
                      (quaternion-rotate-local-z! sv-208 a1-3 sv-192)
                      (quaternion->matrix s5-0 sv-208)
                      (set! (-> s2-1 quad) (-> arg0 root scale quad))
                      (scale-matrix! s5-0 s2-1 s5-0)
                      (let* ((s1-1 (vector-inv-orient-by-quat! (new 'stack-no-clear 'vector) s1-0 (-> arg0 root quat)))
                             (t9-6 vector-inv-orient-by-quat!)
                             (a0-10 (new 'stack-no-clear 'vector))
                             (a2-4 (-> arg0 root quat))
                             (v0-6 (t9-6 a0-10 sv-224 a2-4))
                             (f30-0 (* 1638400.0 (seconds-per-frame)))
                             (f28-0 (seek
                                      (-> arg0 thrust s3-0)
                                      (+ (* 0.4 (fmax 0.0 (* (-> v0-6 x) s0-0)))
                                         (fmax 0.0 (-> v0-6 y))
                                         (fabs (/ (-> v0-6 z) 5))
                                         (fmax 0.0 (-> s1-1 y))
                                         )
                                      (/ f30-0 5)
                                      )
                                    )
                             )
                        (let ((f20-0 (lerp-scale 819.2 4096.0 f28-0 1638.4 f30-0))
                              (f26-0 (lerp-scale 4915.2 11468.8 f28-0 1638.4 f30-0))
                              )
                          (lerp-scale 0.0 -4915.2 f28-0 1638.4 f30-0)
                          (let ((f22-0 (lerp-scale 0.5 1.5 f28-0 1638.4 f30-0))
                                (f24-0 (lerp-scale 0.1 1.0 f28-0 1638.4 f30-0))
                                )
                            (lerp-scale 0.1 1.0 f28-0 1638.4 f30-0)
                            (let ((f1-10 (lerp-scale 0.02 0.6 f28-0 1638.4 f30-0))
                                  (f2-6 (fmin 1.0 (-> s2-1 x)))
                                  (f0-15 (fmin 1.0 (-> s2-1 y)))
                                  )
                              (set! (-> *part-id-table* 4817 init-specs 4 initial-valuef) (* f20-0 f2-6))
                              (set! (-> *part-id-table* 4817 init-specs 5 initial-valuef) (* f26-0 f0-15))
                              (set! (-> *part-id-table* 4821 init-specs 3 initial-valuef) (* f22-0 f2-6))
                              (set! (-> *part-id-table* 4818 init-specs 1 initial-valuef) (* f24-0 f0-15))
                              (set! (-> *part-id-table* 4819 init-specs 1 initial-valuef) (* f1-10 f0-15))
                              (set! (-> *part-id-table* 4820 init-specs 0 initial-valuef) (* f24-0 f0-15))
                              (set! (-> arg0 thrust s3-0) f28-0)
                              (let ((f0-16 (* f26-0 f0-15)))
                                (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 uvec) (* 0.3 f0-16))
                                )
                              )
                            )
                          )
                        (set! (-> s5-0 trans quad) (-> s4-0 quad))
                        (spawn-from-mat (-> arg0 engine-part) s5-0)
                        (lerp-scale 0.75 1.0 f28-0 1638.4 f30-0)
                        )
                      )
                    )
                  )
                0
                (none)
                )
              )
            )
        (s3-0 this (-> this node-list data 10) 16384.0 -1.0 s5-0 s4-0 0)
        (s3-0 this (-> this node-list data 13) -16384.0 1.0 s5-0 s4-0 1)
        )
      0
      (none)
      )
    )
  )

(defmethod blow-tower-enemy-method-34 ((this kg-flyer))
  (sound-play "f-turret-engine" :id (-> this buzz-sound) :position (-> this root trans))
  (call-parent-method this)
  (none)
  )

(defmethod on-death ((this bt-missile))
  (logior! (-> this focus-status) (focus-status dead))
  (cond
    ((logtest? (-> *part-group-id-table* 218 flags) (sp-group-flag sp13))
     (set! (-> *launch-matrix* trans quad) (-> (get-trans this 3) quad))
     (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 218))
     )
    (else
      (set! (-> *launch-matrix* trans quad) (-> (get-trans this 3) quad))
      (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 218))
      )
    )
  (sound-play "missile-explode")
  (go empty-state)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod tower-flyer-method-46 ((this bt-mh-flyer))
  (call-parent-method this)
  (set! (-> this main-joint-movement 0 quad) (-> this root trans quad))
  (set! (-> this main-joint-movement 1 quad) (the-as uint128 0))
  (set! (-> this main-joint-movement 2 quad) (the-as uint128 0))
  (none)
  )

(defmethod deactivate ((this bt-mh-flyer))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this engine-part))
      (kill-particles (-> this engine-part))
      )
  (call-parent-method this)
  (none)
  )

(defmethod relocate ((this bt-mh-flyer) (offset int))
  (if (nonzero? (-> this engine-part))
      (&+! (-> this engine-part) offset)
      )
  (call-parent-method this offset)
  )

(deftype kg-bombbot (bombbot)
  ((start-time  time-frame)
   )
  )


(defmethod bombbot-method-207 ((this kg-bombbot))
  #f
  )

(defmethod enemy-common-post ((this kg-bombbot))
  (if (< (seconds 20) (- (-> *blow-tower-targets* mission-time) (-> this start-time)))
      (go empty-state)
      )
  (call-parent-method this)
  (none)
  )

(defmethod init-enemy! ((this kg-bombbot))
  (with-pp
    (set! (-> pp level) (level-get *level* 'lblowtkg))
    (set! (-> this start-time) (-> *blow-tower-targets* mission-time))
    (call-parent-method this)
    (none)
    )
  )

(defun kg-bombbot-find-nearest-nav-mesh ((arg0 kg-bombbot) (arg1 float))
  (local-vars (v1-15 float) (sv-64 nav-poly) (sv-68 nav-mesh) (sv-72 float) (sv-76 kg-bombbot))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (set! sv-64 (new 'stack-no-clear 'nav-poly))
    (set! sv-68 (the-as nav-mesh #f))
    (set! sv-72 arg1)
    (set! sv-76 arg0)
    (set! (-> sv-64 data 20) (the-as uint 7))
    (dotimes (gp-0 (-> *level* length))
      (let ((v1-5 (-> *level* level gp-0)))
        (when (= (-> v1-5 status) 'active)
          (let ((s5-0 (-> v1-5 bsp nav-meshes)))
            (when (nonzero? s5-0)
              (dotimes (s4-0 (-> s5-0 length))
                (let ((s3-0 (-> s5-0 s4-0 nav-mesh)))
                  (when s3-0
                    (vector-! (the-as vector (-> sv-64 vertex)) (the-as vector sv-76) (the-as vector (-> s3-0 bounds)))
                    (.lvf vf1 (&-> (-> sv-64 vertex) 0 quad))
                    (.add.w.vf vf2 vf0 vf0 :mask #b1)
                    (.mul.vf vf1 vf1 vf1)
                    (.mul.x.vf acc vf2 vf1 :mask #b1)
                    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                    (.mov v1-15 vf1)
                    (let ((f0-1 v1-15)
                          (f1-0 (-> s3-0 bounds r))
                          )
                      (when (< f0-1 (* f1-0 f1-0))
                        (set! (-> sv-64 vertex1 x) 4096.0)
                        (nav-mesh-method-46 s3-0 sv-64)
                        (when (>= sv-72 (-> sv-64 vertex1 w))
                          (set! sv-72 (-> sv-64 vertex1 w))
                          (set! sv-68 s3-0)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    sv-68
    )
  )

(defmethod bombbot-method-205 ((this kg-bombbot))
  (when (= (-> this nav state mesh) *default-nav-mesh*)
    (let ((a0-4 (kg-bombbot-find-nearest-nav-mesh (the-as kg-bombbot (-> this root trans)) (the-as float #x7f800000))))
      (when a0-4
        (change-to a0-4 this)
        (dotimes (s5-0 4)
          (let ((s4-0 (-> this feet s5-0)))
            (let ((s3-0 (new 'stack-no-clear 'vector)))
              (vector-orient-by-quat! s3-0 (-> s4-0 pos-offset) (-> this root quat))
              (vector+! s3-0 s3-0 (-> this root trans))
              (set! (-> s4-0 next-position quad) (-> s3-0 quad))
              (set! (-> s4-0 position quad) (-> s3-0 quad))
              )
            (set! (-> s4-0 delta-y) 0.0)
            )
          (set! (-> this legs-strength s5-0) 1.0)
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod bombbot-method-196 ((this kg-bombbot) (arg0 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s4-0
             (handle->process (-> *blow-tower-targets* target-handles (logand (rand-uint31-gen *random-generator*) 1)))
             )
           (s5-0 (if (type? s4-0 process-focusable)
                     (the-as process-focusable s4-0)
                     )
                 )
           )
      (cond
        (s5-0
          (set! (-> this target-pos quad) (-> (get-trans s5-0 3) quad))
          (let ((v1-9 (-> this target-pos)))
            (let ((a0-9 (-> s5-0 root trans)))
              (let ((a1-5 (-> s5-0 root transv)))
                (let ((a2-0 0.0))
                  (.mov vf7 a2-0)
                  )
                (.lvf vf5 (&-> a1-5 quad))
                )
              (.lvf vf4 (&-> a0-9 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-9 quad) vf6)
            )
          (set! (-> this start-target-pos quad) (-> this target-pos quad))
          (set! (-> this start-target-vel quad) (-> s5-0 root transv quad))
          (try-update-focus (-> this focus) s5-0 this)
          )
        (else
          (clear-focused (-> this focus))
          )
        )
      )
    (none)
    )
  )

(defstate hostile (kg-bombbot)
  :virtual #t
  :enter (behavior ()
    (set! (-> self hit-points) 10.0)
    (call-parent-state-handler enter)
    )
  )

(defstate die (kg-bombbot)
  :virtual #t
  :enter (behavior ()
    (sound-play "bb-explode")
    (go-virtual explode)
    )
  )

(defmethod on-hit ((this bt-mh-flyer) (arg0 float))
  ((method-of-type blow-tower-enemy on-hit) this arg0)
  (none)
  )

(defmethod on-death ((this bt-mh-flyer))
  (sound-play "wasp-die")
  (sound-play "hc-target-hit")
  ((method-of-type blow-tower-enemy on-death) this)
  )
