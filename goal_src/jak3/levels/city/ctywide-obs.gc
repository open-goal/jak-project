;;-*-Lisp-*-
(in-package goal)

;; name: ctywide-obs.gc
;; name in dgo: ctywide-obs
;; dgos: CWI

;; DECOMP BEGINS

(deftype security-wall (process-drawable)
  ((root                collide-shape :override)
   (pass                pickup-type)
   (incoming-attack-id  uint32)
   (next-message-time   time-frame)
   (message             int32)
   (plane               plane          :inline)
   (color               vector         :inline)
   (target-pos          vector         :inline)
   (flash               float)
   (touch-count         int32)
   (breach              symbol)
   )
  (:state-methods
    idle-open
    idle-close
    )
  (:methods
    (init-wall (_type_ vector vector float) vector)
    (play-speech (_type_) none)
    (security-wall-method-24 (_type_) none)
    )
  )


(defskelgroup skel-security-wall security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

(defmethod play-speech ((this security-wall))
  (when (< (-> this next-message-time) (current-time))
    (set! (-> this next-message-time) (+ (current-time) (the int (* 300.0 (rand-vu-float-range 2.0 5.0)))))
    (let ((v1-6 (rand-vu-int-count 15)))
      (cond
        ((zero? v1-6)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 1)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 2)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 3)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 4)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 5)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 6)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 7)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 8)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 9)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 10)
         (let ((v1-45 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-45)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-45 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-45 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 11)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (let ((v1-57 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-57)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-57 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-57 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         )
        ((= v1-6 12)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 13)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 14)
         (case (-> this pass)
           (((pickup-type pass-red))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           (((pickup-type pass-green))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           (((pickup-type pass-yellow))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           (((pickup-type pass-blue))
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        )
      )
    (+! (-> this message) 1)
    (when (>= (-> this message) 5)
      (set! (-> this message) 0)
      0
      )
    )
  0
  (none)
  )

(defmethod security-wall-method-24 ((this security-wall))
  (let ((s4-0 *target*))
    (when s4-0
      (let* ((f0-0 (vector-vector-distance-squared (-> this root trans) (-> s4-0 control trans)))
             (f30-0 (+ 40960.0 (-> this root root-prim local-sphere w)))
             (f1-1 f30-0)
             )
        (when (< f0-0 (* f1-1 f1-1))
          (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 1)))
            (set! (-> s5-0 0 quad) (-> s4-0 control trans quad))
            (when (< (vector-vector-distance-squared (-> this root trans) (-> this target-pos)) (* f30-0 f30-0))
              (let ((f0-3 (vector4-dot (-> this target-pos) (the-as vector (-> this plane))))
                    (f1-7 (vector4-dot (-> s5-0 0) (the-as vector (-> this plane))))
                    )
                (if (and (< (fabs f1-7) 16384.0)
                         (< (fabs f0-3) 16384.0)
                         (or (and (< f0-3 0.0) (>= f1-7 0.0)) (and (< f1-7 0.0) (>= f0-3 0.0)))
                         )
                    (set! (-> this breach) #t)
                    )
                )
              )
            (set! (-> this target-pos quad) (-> s5-0 0 quad))
            )
          (when (-> this breach)
            (if (send-event
                  *target*
                  'attack-invinc
                  #f
                  (static-attack-info
                    :mask (vehicle-impulse-factor)
                    ((id (new-attack-id)) (damage 2.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'grenade))
                    )
                  )
                (set! (-> this breach) #f)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate idle-close (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('on)
         (let ((v1-2 (-> self root root-prim)))
           (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
           (let ((v0-0 (the-as object (-> self root backup-collide-with))))
             (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
             v0-0
             )
           )
         )
        (('off)
         (let ((v1-4 (-> self root root-prim)))
           (set! (-> v1-4 prim-core collide-as) (collide-spec))
           (set! (-> v1-4 prim-core collide-with) (collide-spec))
           )
         0
         )
        (('attack)
         (let ((v1-5 (the-as attack-info (-> block param 1))))
           (when (!= (-> v1-5 id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> v1-5 id))
             (let* ((s5-0 proc)
                    (s3-0 (if (type? s5-0 process-drawable)
                              s5-0
                              )
                          )
                    )
               (when s3-0
                 (let ((s5-1 (process-spawn
                               manipy
                               :init manipy-init
                               (-> (the-as process-drawable s3-0) root trans)
                               (-> self entity)
                               (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer level) #f))
                               #f
                               0
                               :name "manipy"
                               :to self
                               :stack-size #x20000
                               )
                             )
                       )
                   (when s5-1
                     (send-event (ppointer->process s5-1) 'anim-mode 'play1)
                     (send-event (ppointer->process s5-1) 'speed 1.5)
                     (send-event (ppointer->process s5-1) 'art-joint-anim "generic-ripples-idle" 0)
                     (set-vector! (-> (the-as process-drawable (-> s5-1 0)) root scale) 1.0 1.0 1.0 1.0)
                     (quaternion-rotate-local-x! (-> (the-as process-drawable (-> s5-1 0)) root quat) (-> self root quat) -16384.0)
                     (let ((v1-43 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                       (let ((a0-29 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a1-11 *up-vector*))
                           (let ((a2-7 8192.0))
                             (.mov vf7 a2-7)
                             )
                           (.lvf vf5 (&-> a1-11 quad))
                           )
                         (.lvf vf4 (&-> a0-29 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> v1-43 quad) vf6)
                       )
                     (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> s5-1 0)) root trans) (the-as vector (-> self plane)))))
                       (let ((v1-50 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-33 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-12 (-> self plane)))
                             (let ((a2-8 (- f0-6)))
                               (.mov vf7 a2-8)
                               )
                             (.lvf vf5 (&-> a1-12 quad))
                             )
                           (.lvf vf4 (&-> a0-33 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-50 quad) vf6)
                         )
                       (let ((v1-53 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-36 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-13 (-> self plane)))
                             (let ((a2-10 (the-as float (if (< 0.0 f0-6)
                                                            -2048.0
                                                            2048.0
                                                            )
                                                  )
                                          )
                                   )
                               (.mov vf7 a2-10)
                               )
                             (.lvf vf5 (&-> a1-13 quad))
                             )
                           (.lvf vf4 (&-> a0-36 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-53 quad) vf6)
                         )
                       )
                     (send-event (ppointer->process s5-1) 'trans-hook (lambda () #f))
                     )
                   )
                 )
               )
             (when (zero? (-> self touch-count))
               (+! (-> self touch-count) 1)
               (set! (-> self flash) 0.375)
               )
             (+! (-> self touch-count) 1)
             (if (and (logtest? (-> proc mask) (process-mask target))
                      (not (logtest? (process-mask projectile) (-> proc mask)))
                      )
                 (play-speech self)
                 )
             )
           )
         )
        (('touched)
         (when (zero? (-> self touch-count))
           (+! (-> self touch-count) 1)
           (set! (-> self flash) 0.375)
           )
         (+! (-> self touch-count) 1)
         (let ((v1-81 (if (type? proc process-focusable)
                          proc
                          )
                      )
               )
           (when v1-81
             (let* ((gp-1 (-> (the-as process-drawable v1-81) root))
                    (a0-45 (if (type? gp-1 collide-shape)
                               gp-1
                               )
                           )
                    )
               (if (and a0-45 (logtest? (-> (the-as collide-shape a0-45) root-prim prim-core collide-as) (collide-spec jak)))
                   (play-speech self)
                   )
               )
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (security-wall-method-24 self)
    )
  :code (behavior ()
    (until #f
      (when (and (logtest? (game-feature feature35) (-> *game-info* features))
                 (= (pickup-type pass-slumb-genb) (-> self pass))
                 )
        (go-virtual idle-open)
        #t
        (b! #t cfg-9 :delay (nop!))
        (the-as none 0)
        )
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-4 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-4 (-> self color) f30-0)
        (set-security-color! a0-4)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (seek! (-> self flash) 0.0 (seconds-per-frame))
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-security-flash! gp-0)
        )
      (suspend)
      )
    #f
    (label cfg-9)
    )
  )

(defstate idle-open (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('on)
       (let ((v1-2 (-> self root root-prim)))
         (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
         (let ((v0-0 (the-as int (-> self root backup-collide-with))))
           (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
           v0-0
           )
         )
       )
      (('off)
       (let ((v1-4 (-> self root root-prim)))
         (set! (-> v1-4 prim-core collide-as) (collide-spec))
         (set! (-> v1-4 prim-core collide-with) (collide-spec))
         )
       0
       )
      )
    )
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    )
  :trans (behavior ()
    (let* ((f28-0 (vector4-dot (the-as vector (-> self plane)) (target-pos 0)))
           (f30-0 (calc-fade-from-fog (-> self root trans)))
           (f28-1 (lerp-scale 0.0 1.0 (fabs f28-0) 163840.0 327680.0))
           (gp-1 (new 'stack-no-clear 'vector))
           )
      (when (= f28-1 0.0)
        (cleanup-for-death self)
        (deactivate self)
        )
      (let ((f0-3 (* f30-0 f28-1)))
        (vector-float*! gp-1 (-> self color) f0-3)
        )
      (set! (-> gp-1 w) 1.0)
      (set-security-color! gp-1)
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  )

(defmethod init-wall ((this security-wall) (arg0 vector) (arg1 vector) (arg2 float))
  0.0
  (* 0.5 (vector-vector-distance arg0 arg1))
  (let ((s2-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-3 (new 'process 'collide-shape-prim-mesh s2-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-3 prim-core collide-as) (collide-spec obstacle blocking-plane camera-blocker))
      (set! (-> v1-3 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-3 prim-core action) (collide-action solid))
      (set! (-> v1-3 transform-index) 3)
      (set! (-> s2-0 total-prims) (the-as uint 1))
      (set! (-> s2-0 root-prim) v1-3)
      )
    (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s2-0 root-prim)))
      (set! (-> s2-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s2-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s2-0)
    )
  (let ((s2-1 (new 'stack-no-clear 'matrix))
        (s1-0 (-> this root))
        )
    (vector+! (-> s1-0 trans) arg0 arg1)
    (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
    (+! (-> s1-0 trans y) (* 0.5 arg2))
    (vector-! (-> s2-1 rvec) arg1 arg0)
    (let ((f30-1 (vector-normalize-ret-len! (-> s2-1 rvec) 1.0)))
      (set! (-> s1-0 scale x) (* 0.00024414062 f30-1))
      (set! (-> s1-0 scale y) (* 0.00024414062 arg2))
      (set! (-> s1-0 scale z) 1.0)
      (set! (-> s2-1 uvec quad) (-> (new 'static 'vector :y 1.0 :w 1.0) quad))
      (vector-cross! (-> s2-1 fvec) (-> s2-1 rvec) (-> s2-1 uvec))
      (vector-normalize! (-> s2-1 fvec) 1.0)
      (matrix->quaternion (-> s1-0 quat) s2-1)
      (set! (-> this plane quad) (-> s2-1 fvec quad))
      (set! (-> this plane w) (- (vector-dot (-> s2-1 fvec) (-> this root trans))))
      (let ((v0-6 (-> this root root-prim local-sphere)))
        (set! (-> v0-6 x) 0.0)
        (set! (-> v0-6 y) (* 0.00024414062 (* 0.5 arg2)))
        (set! (-> v0-6 z) 0.0)
        (let ((f0-20 0.5)
              (f1-7 (* f30-1 f30-1))
              (f2-2 arg2)
              )
          (set! (-> v0-6 w) (* f0-20 (sqrtf (+ f1-7 (* f2-2 f2-2)))))
          )
        v0-6
        )
      )
    )
  )

(defmethod init-from-entity! ((this security-wall) (arg0 entity-actor))
  (ctywide-entity-hack)
  (set! (-> this breach) #f)
  (set! (-> this pass) (res-lump-value arg0 'pickup-type pickup-type :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f)))
    (set! (-> this path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (let ((s5-1 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (get-point-in-path! (-> this path) s5-1 0.0 'exact)
    (get-point-in-path! (-> this path) s4-0 1.0 'exact)
    (init-wall this s5-1 s4-0 122880.0)
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this root event-self) 'touched)
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> this draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> this color) 1.0 1.0 1.0 1.0)
  (cond
    ((= (-> this pass) (pickup-type pass-red))
     (set-vector! (-> this color) 1.0 0.0 0.0 1.0)
     )
    ((= (-> this pass) (pickup-type pass-yellow))
     (set-vector! (-> this color) 1.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) (pickup-type pass-green))
     (set-vector! (-> this color) 0.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) (pickup-type pass-blue))
     (set-vector! (-> this color) 0.0 0.0 1.0 1.0)
     )
    )
  (set-security-color! (-> this color))
  (set-vector! (-> this draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> this draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (cond
    ((logtest? (game-feature feature35) (-> *game-info* features))
     (= (pickup-type pass-slumb-genb) (-> this pass))
     (go (method-of-object this idle-open))
     )
    (else
      (go (method-of-object this idle-close))
      )
    )
  )

(deftype security-wall-child (security-wall)
  ((hidden?  symbol)
   )
  (:state-methods
    hide-wall
    )
  )


(defstate idle-close (security-wall-child)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-1 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-1 (-> self color) f30-0)
        (set-security-color! a0-1)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (seek! (-> self flash) 0.0 (seconds-per-frame))
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-security-flash! gp-0)
        )
      (suspend)
      )
    #f
    )
  )

(defstate hide-wall (security-wall-child)
  :virtual #t
  :parent (security-wall-child idle-close)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       #f
       )
      (else
        ((-> (method-of-type security-wall-child idle-close) event) proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self draw status) (draw-control-status no-draw))
    (ja-post)
    )
  :code sleep-code
  )

(defbehavior security-wall-child-init-by-other security-wall-child ((arg0 vector) (arg1 vector) (arg2 float) (arg3 symbol))
  (ctywide-entity-hack)
  (set! (-> self breach) #f)
  (set! (-> self hidden?) arg3)
  (init-wall self arg0 arg1 arg2)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root event-self) 'touched)
  (logior! (-> self draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> self draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> self color) 1.0 1.0 1.0 1.0)
  (set-vector! (-> self color) 1.0 0.0 0.0 1.0)
  (set-security-color! (-> self color))
  (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> self draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (if (-> self hidden?)
      (go-virtual hide-wall)
      (go-virtual idle-close)
      )
  )

;; WARN: Return type mismatch int vs handle.
(defun spawn-security-wall ((arg0 process) (arg1 vector) (arg2 vector) (arg3 float) (arg4 symbol))
  (the-as handle (ppointer->handle
                   (process-spawn security-wall-child arg1 arg2 arg3 arg4 :name "security-wall-child" :to arg0)
                   )
          )
  )

(deftype parking-spot (process-drawable)
  ((vehicle           handle)
   (spawned           symbol)
   (minimap           connection-minimap)
   (test-sphere       sphere  :inline)
   (expire-time       time-frame)
   (last-update-time  time-frame)
   )
  (:state-methods
    idle
    )
  (:methods
    (parking-spot-method-21 (_type_) none)
    (parking-spot-method-22 (_type_) none)
    (parking-spot-method-23 (_type_ traffic-type) none)
    (parking-spot-method-24 (_type_) none)
    (parking-spot-method-25 (_type_ symbol) symbol)
    (parking-spot-method-26 (_type_) symbol)
    )
  )


;; WARN: disable def twice: 36. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod parking-spot-method-25 ((this parking-spot) (arg0 symbol))
  (local-vars (f30-0 float))
  (and (not (-> *setting-control* user-current disable-parking-spots?))
       (begin
         (set! f30-0 (vector-vector-distance (-> this root trans) (math-camera-pos)))
         (or (< 163840.0 f30-0) arg0)
         )
       (if (sphere-in-view-frustum? (-> this test-sphere))
           (and (or arg0 (< 614400.0 f30-0)) (< f30-0 1024000.0))
           (< f30-0 614400.0)
           )
       )
  )

(defmethod parking-spot-method-26 ((this parking-spot))
  (let ((f30-0 (vector-vector-distance (-> this root trans) (math-camera-pos))))
    (or (< f30-0 163840.0) (and (sphere-in-view-frustum? (-> this test-sphere)) (< f30-0 614400.0)))
    )
  )

(defmethod parking-spot-method-24 ((this parking-spot))
  (let ((gp-0 (new 'stack-no-clear 'cquery-with-vec)))
    (set! (-> gp-0 vec0 quad) (-> this root trans quad))
    (set! (-> gp-0 cquery start-pos quad) (-> gp-0 vec0 quad))
    (vector-reset! (-> gp-0 vec1))
    (set! (-> gp-0 vec1 y) 1.0)
    (set-vector! (-> gp-0 cquery move-dist) 0.0 -40960.0 0.0 1.0)
    (let ((v1-5 (-> gp-0 cquery)))
      (set! (-> v1-5 radius) 1024.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* (-> gp-0 cquery))))
      (when (>= f30-0 0.0)
        (vector+float*! (-> gp-0 vec0) (-> gp-0 cquery start-pos) (-> gp-0 cquery move-dist) f30-0)
        (set! (-> gp-0 vec1 quad) (-> gp-0 cquery best-other-tri normal quad))
        (set! (-> this root trans quad) (-> gp-0 vec0 quad))
        (format #t "parking-spot::find-ground: ground y ~M~%" (-> gp-0 vec0 y))
        )
      (if (< f30-0 0.0)
          (format #t "parking-spot::find-ground: could not find ground~%")
          )
      )
    (set! (-> this root trans quad) (-> gp-0 vec0 quad))
    (forward-up-nopitch->quaternion (-> this root quat) (new 'static 'vector :z 1.0 :w 1.0) (-> gp-0 vec1))
    )
  0
  (none)
  )

(defmethod parking-spot-method-21 ((this parking-spot))
  (with-pp
    (let ((s5-0 (the-as vehicle (handle->process (-> this vehicle)))))
      (cond
        (s5-0
          (cond
            ((or (-> *setting-control* user-current disable-parking-spots?)
                 (focus-test? s5-0 dead inactive)
                 (not (logtest? (vehicle-flag waiting-for-player) (-> s5-0 v-flags)))
                 (let ((f0-0 (-> this test-sphere r)))
                   (< (* f0-0 f0-0) (vector-vector-distance-squared (-> s5-0 root trans) (-> this test-sphere)))
                   )
                 )
             (logclear! (-> s5-0 v-flags) (vehicle-flag persistent))
             (cond
               ((-> *setting-control* user-current disable-parking-spots?)
                (when (or (< (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                          (>= (-> *setting-control* user-current bg-a) 1.0)
                          (>= (-> *setting-control* user-current bg-a-force) 1.0)
                          (let ((f0-5 (-> this test-sphere r)))
                            (and (>= (* f0-5 f0-5) (vector-vector-distance-squared (-> s5-0 root trans) (-> this test-sphere)))
                                 (not (sphere-in-view-frustum? (-> this test-sphere)))
                                 )
                            )
                          )
                  (send-event (handle->process (-> this vehicle)) 'traffic-off-force)
                  (set! (-> this vehicle) (the-as handle #f))
                  )
                )
               (else
                 (set! (-> this vehicle) (the-as handle #f))
                 )
               )
             )
            (else
              (if (not (-> this minimap))
                  (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 11) (the-as int #f) (the-as vector #t) 0))
                  )
              (cond
                ((parking-spot-method-26 this)
                 (logior! (-> s5-0 v-flags) (vehicle-flag persistent))
                 (+! (-> this expire-time) (- (current-time) (-> pp clock old-frame-counter)))
                 )
                (else
                  )
                )
              (when (< (-> this expire-time) (current-time))
                (logclear! (-> s5-0 v-flags) (vehicle-flag persistent))
                (set! (-> this vehicle) (the-as handle #f))
                )
              )
            )
          )
        (else
          (set! (-> this vehicle) (the-as handle #f))
          (set! (-> this spawned) #f)
          (when (-> this minimap)
            (logior! (-> this minimap flags) (minimap-flag fade-out))
            (set! (-> this minimap) #f)
            )
          )
        )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs vehicle.
(defun parking-spot-spawn ((arg0 traffic-object-spawn-params))
  (set! (-> arg0 proc) #f)
  (the-as vehicle (cond
                    ((= (-> arg0 object-type) (traffic-type bike-d))
                     (let ((v0-0 (the-as object (vehicle-spawn (vehicle-type h-bike-d) arg0))))
                       (if (the-as process-drawable v0-0)
                           (logior! (-> (the-as vehicle v0-0) v-flags) (vehicle-flag traffic-managed))
                           )
                       (set! (-> arg0 proc) (the-as vehicle v0-0))
                       v0-0
                       )
                     )
                    (else
                      (send-event *traffic-manager* 'activate-object arg0)
                      )
                    )
          )
  )

(defmethod parking-spot-method-23 ((this parking-spot) (arg0 traffic-type))
  (let ((v1-0 (new 'stack-no-clear 'cquery-with-vec)))
    (let* ((a0-1 (new 'stack-no-clear 'inline-array 'vector 1))
           (a1-2 (the-as uint #xa01013fd))
           (a2-1 (logand -2 a1-2))
           )
      (set! (-> a0-1 0 quad) (-> this test-sphere quad))
      (let ((a1-4 (-> v1-0 cquery)))
        (set! (-> a1-4 best-dist) (the-as float a0-1))
        (set! (-> a1-4 best-other-prim) (the-as collide-shape-prim 1))
        (set! (-> a1-4 collide-with) (the-as collide-spec a2-1))
        (set! (-> a1-4 ignore-process0) #f)
        (set! (-> a1-4 ignore-process1) #f)
        (set! (-> a1-4 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> a1-4 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> a1-4 action-mask) (collide-action solid))
        )
      )
    0
    (when (not (fill-and-probe-using-spheres *collide-cache* (-> v1-0 cquery)))
      (let ((s4-0 (new 'stack 'traffic-object-spawn-params)))
        (set! (-> s4-0 position quad) (-> this root trans quad))
        (mem-copy! (the-as pointer (-> s4-0 rotation)) (the-as pointer (-> this root quat)) 16)
        (+! (-> s4-0 position y) 14336.0)
        (set! (-> s4-0 behavior) (the-as uint 0))
        (set! (-> s4-0 object-type) arg0)
        (set! (-> s4-0 id) (the-as uint 0))
        (set! (-> s4-0 proc) #f)
        (parking-spot-spawn s4-0)
        (when (-> s4-0 proc)
          (let ((v1-9 (-> s4-0 proc)))
            (if v1-9
                (logior! (-> (the-as vehicle v1-9) v-flags) (vehicle-flag persistent))
                )
            )
          (set! (-> this expire-time) (+ (current-time) (seconds 10)))
          (set! (-> this vehicle) (process->handle (-> s4-0 proc)))
          (set! (-> this spawned) #t)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this parking-spot) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this minimap) #f)
  (set! (-> this vehicle) (the-as handle #f))
  (set! (-> this spawned) #f)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause movie))
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (parking-spot-method-24 this)
  (set! (-> this test-sphere quad) (-> this root trans quad))
  (set! (-> this test-sphere r) 24576.0)
  (set-time! (-> this state-time))
  (when (parking-spot-method-25 this #t)
    (let ((s4-0 29))
      (if (nonzero? (res-lump-value arg0 'use-special-bike uint128 :time -1000000000.0))
          (set! s4-0 28)
          )
      (if (= s4-0 29)
          (set! s4-0 (the-as int (get-random-parking-spot-type *traffic-engine*)))
          )
      (if (!= s4-0 29)
          (parking-spot-method-23 this (the-as traffic-type s4-0))
          )
      )
    )
  (go (method-of-object this idle))
  )

(defstate idle (parking-spot)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (parking-spot-method-21 self)
    (send-event (handle->process (-> self vehicle)) 'traffic-off-force)
    )
  :code sleep-code
  :post (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.25))
      (parking-spot-method-21 self)
      (when (time-elapsed? (-> self last-update-time) (seconds 0.2))
        (set-time! (-> self last-update-time))
        (when (and (not (-> self spawned)) (parking-spot-method-25 self #f))
          (let ((a1-1 (get-random-parking-spot-type *traffic-engine*)))
            (if (!= a1-1 (traffic-type max))
                (parking-spot-method-23 self a1-1)
                )
            )
          )
        )
      0
      )
    )
  )

(deftype propa (process-focusable)
  ((sound-id            sound-id)
   (sound-index         uint32)
   (handle              handle)
   (y-rot               float)
   (hit-points          int32)
   (incoming-attack-id  uint32)
   )
  (:state-methods
    idle
    broken
    )
  (:methods
    (propa-method-30 (_type_) none)
    (propa-method-31 (_type_) none)
    (propa-method-32 (_type_ vector) none)
    )
  )


(defskelgroup skel-propa propa 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 3))

(define *propa-sounds* (new 'static 'boxed-array :type string
                         "prop009"
                         "prop010"
                         "prop011"
                         "prop012"
                         "prop013"
                         "prop014"
                         "prop015"
                         "prop016"
                         "prop017"
                         "prop018"
                         "prop019"
                         "prop020"
                         "prop021"
                         "prop022"
                         "prop023"
                         "prop024"
                         "prop025"
                         "prop026"
                         "prop028"
                         "prop027"
                         "prop029"
                         "prop030"
                         "prop031"
                         "prop032"
                         "prop033"
                         "prop034"
                         "prop035"
                         "prop036"
                         "prop037"
                         "prop038"
                         "prop039"
                         "prop040"
                         "prop041"
                         "prop042"
                         "prop043"
                         "prop008"
                         "prop006"
                         "prop005"
                         "prop004"
                         "prop002"
                         "prop003"
                         "bar001"
                         "prop044"
                         "prop045"
                         "prop046"
                         "prop047"
                         "prop048"
                         "prop049"
                         "prop051"
                         "prop052"
                         "prop053"
                         "prop054"
                         "prop055"
                         "prop056"
                         )
        )

(define *propa-sounds-class-3* (new 'static 'boxed-array :type string "cityv177"))

(define *propa-sounds-class-2* (new 'static 'boxed-array :type string "cityv176"))

(define *propa-sounds-class-1* (new 'static 'boxed-array :type string "prop050" "spot004" "cityv175"))

(define *propa-sounds-metalheads* (new 'static 'boxed-array :type string
                                    "prop007"
                                    "prop057"
                                    "cityv096"
                                    "cityv097"
                                    "cityv098"
                                    "cityv099"
                                    "cityv142"
                                    "cityv143"
                                    )
        )

(define *propa-sounds-baron-construction* (new 'static 'boxed-array :type string "prop058"))

;; WARN: Return type mismatch int vs knocked-type.
(defun propa-pu->knocked-type ((arg0 penetrate))
  (the-as knocked-type (cond
                         ((logtest? arg0 (penetrate vehicle))
                          7
                          )
                         ((logtest? (penetrate jak-blue-shot) arg0)
                          6
                          )
                         ((logtest? (penetrate jak-yellow-shot enemy-yellow-shot) arg0)
                          4
                          )
                         ((logtest? (penetrate jak-red-shot) arg0)
                          5
                          )
                         ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg0)
                          2
                          )
                         ((logtest? (penetrate dark-bomb dark-smack) arg0)
                          3
                          )
                         ((logtest? arg0 (penetrate mech-punch))
                          1
                          )
                         (else
                           0
                           )
                         )
          )
  )

(defstate broken (propa)
  :virtual #t
  :code sleep-code
  )

(defstate idle (propa)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('attack)
         (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)
         (let ((v1-2 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-2) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-2) id))
             (let ((s5-1 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)))
               (if (and (not (logtest? (penetrate dark-skin) s5-1)) (zero? (propa-pu->knocked-type s5-1)))
                   (set! (-> self hit-points) (- (-> self hit-points) (the int (penetrate-using->damage s5-1))))
                   (+! (-> self hit-points) -10)
                   )
               )
             (cond
               ((< (-> self hit-points) 3)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 1 0)
                (let* ((a0-9 (the-as collide-shape-prim-group (-> self root root-prim)))
                       (v1-18 (-> a0-9 child 0))
                       )
                  (let ((a0-11 (-> a0-9 child 1)))
                    (set! (-> a0-11 prim-core collide-as) (-> v1-18 prim-core collide-as))
                    (set! (-> a0-11 prim-core collide-with) (-> v1-18 prim-core collide-with))
                    )
                  (set! (-> v1-18 prim-core collide-as) (collide-spec))
                  (set! (-> v1-18 prim-core collide-with) (collide-spec))
                  )
                0
                (cond
                  ((logtest? (-> *part-group-id-table* 224 flags) (sp-group-flag sp13))
                   (let ((v1-25 (-> *launch-matrix* trans))
                         (a0-12 (new 'stack-no-clear 'vector))
                         )
                     (let ((a1-9 (-> self root trans)))
                       (let ((a2-3 *up-vector*))
                         (let ((a3-2 8192.0))
                           (.mov vf7 a3-2)
                           )
                         (.lvf vf5 (&-> a2-3 quad))
                         )
                       (.lvf vf4 (&-> a1-9 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> a0-12 quad) vf6)
                     (set! (-> v1-25 quad) (-> a0-12 quad))
                     )
                   (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 224))
                   )
                  (else
                    (let ((v1-40 (-> *launch-matrix* trans))
                          (a0-17 (new 'stack-no-clear 'vector))
                          )
                      (let ((a1-14 (-> self root trans)))
                        (let ((a2-9 *up-vector*))
                          (let ((a3-6 8192.0))
                            (.mov vf7 a3-6)
                            )
                          (.lvf vf5 (&-> a2-9 quad))
                          )
                        (.lvf vf4 (&-> a1-14 quad))
                        )
                      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                      (.mul.x.vf acc vf5 vf7 :mask #b111)
                      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                      (.svf (&-> a0-17 quad) vf6)
                      (set! (-> v1-40 quad) (-> a0-17 quad))
                      )
                    (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 224))
                    )
                  )
                (go-virtual broken)
                )
               ((< (-> self hit-points) 6)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 2 0)
                )
               )
             )
           )
         )
        )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (sound-stop (-> self sound-id))
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    )
  :code sleep-code
  :post (behavior ()
    (cond
      ((or (not (-> *setting-control* user-current speech-control))
           (< 245760.0 (vector-vector-distance (camera-pos) (-> self root trans)))
           )
       (when (nonzero? (-> self sound-id))
         (set-action!
           *gui-control*
           (gui-action stop)
           (-> self sound-id)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         (set! (-> self sound-id) (new 'static 'sound-id))
         (+! (-> self sound-index) 1)
         (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
           (set! (-> self sound-index) (the-as uint 0))
           0
           )
         )
       )
      ((< (vector-vector-distance (camera-pos) (-> self root trans)) 225280.0)
       (cond
         ((zero? (-> self sound-id))
          (set! (-> self sound-id) (add-process
                                     *gui-control*
                                     self
                                     (gui-channel alert)
                                     (gui-action play)
                                     (-> *propa-sounds* (-> self sound-index))
                                     -99.0
                                     0
                                     )
                )
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (set! (-> a1-4 w) 40960.0)
            (propa-method-32 self a1-4)
            )
          )
         (else
           (when *sound-player-enable*
             (let ((gp-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
               (set! (-> gp-2 command) (sound-command set-param))
               (set! (-> gp-2 id) (-> self sound-id))
               (set! (-> gp-2 params fo-min) 40)
               (set! (-> gp-2 params fo-max) 55)
               (set! (-> gp-2 params fo-curve) 2)
               (let ((a1-5 (-> self root trans)))
                 (let ((s5-0 self))
                   (when (= a1-5 #t)
                     (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root)))
                         (set! a1-5 (-> s5-0 root trans))
                         (set! a1-5 (the-as vector #f))
                         )
                     )
                   )
                 (sound-trans-convert (-> gp-2 params trans) a1-5)
                 )
               (set! (-> gp-2 params mask) (the-as uint 480))
               (-> gp-2 id)
               )
             )
           (when (= (get-status *gui-control* (-> self sound-id)) (gui-status unknown))
             (set! (-> self sound-id) (new 'static 'sound-id))
             (+! (-> self sound-index) 1)
             (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
               (set! (-> self sound-index) (the-as uint 0))
               0
               )
             )
           )
         )
       )
      )
    (let ((s5-1 (matrix->trans (-> self node-list data 3 bone transform) (new 'stack-no-clear 'vector)))
          (s4-0 (new 'stack-no-clear 'vector))
          (gp-3 (new 'stack-no-clear 'matrix))
          )
      (when (and (nonzero? (-> self handle)) (handle->process (-> self handle)))
        (let* ((s3-0 (handle->process (-> self handle)))
               (a0-25 (if (type? s3-0 process-focusable)
                          s3-0
                          )
                      )
               )
          (when a0-25
            (vector-! s4-0 (-> (the-as process-focusable a0-25) root trans) (-> self root trans))
            (set! (-> self y-rot) (deg-seek
                                    (-> self y-rot)
                                    (deg- (vector-y-angle s4-0) (quaternion-y-angle (-> self root quat)))
                                    (* 36408.89 (seconds-per-frame))
                                    )
                  )
            )
          )
        )
      (matrix-rotate-y! gp-3 (-> self y-rot))
      (matrix<-trans gp-3 s5-1)
      (spawn-from-mat (-> self part) gp-3)
      )
    )
  )

(defmethod propa-method-32 ((this propa) (arg0 vector))
  (let ((s5-0 (the-as process-drawable #f)))
    (let ((f30-0 (the-as float #x7f800000))
          (s3-0 (new 'stack-no-clear 'array 'collide-shape 64))
          )
      (countdown (s2-0 (fill-actor-list-for-box *actor-hash* arg0 s3-0 64))
        (let* ((s1-0 (-> s3-0 s2-0))
               (a0-3 (if (type? s1-0 collide-shape)
                         s1-0
                         )
                     )
               )
          (when a0-3
            (let* ((s0-0 (-> a0-3 process))
                   (s1-1 (if (type? s0-0 process-focusable)
                             s0-0
                             )
                         )
                   )
              (when (and s1-1
                         (!= this s1-1)
                         (not (focus-test? (the-as process-focusable s1-1) inactive))
                         (not (focus-test? (the-as process-focusable s1-1) disable))
                         (not (focus-test? (the-as process-focusable s1-1) dead))
                         (not (logtest? (process-mask guard) (-> s1-1 mask)))
                         (not (logtest? (process-mask crate) (-> s1-1 mask)))
                         (not (logtest? (process-mask vehicle) (-> s1-1 mask)))
                         )
                (let ((f0-0 (vector-vector-xz-distance (-> this root trans) (-> s1-1 root trans))))
                  (when (or (not s5-0) (< f0-0 f30-0))
                    (set! s5-0 s1-1)
                    (set! f30-0 f0-0)
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (and *target* (< (vector-vector-distance (target-pos 0) arg0) (-> arg0 w)))
        (set! s5-0 *target*)
        )
    (if s5-0
        (set! (-> this handle) (process->handle s5-0))
        (set! (-> this handle) (the-as handle #f))
        )
    )
  0
  (none)
  )

(defmethod propa-method-30 ((this propa))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod propa-method-31 ((this propa))
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 259) this))
  0
  (none)
  )

(defmethod init-from-entity! ((this propa) (arg0 entity-actor))
  (propa-method-30 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-propa" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (propa-method-31 this)
  (set! (-> this sound-index) (the-as uint (rand-vu-int-count (-> *propa-sounds* length))))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 4 0)
  (set! (-> this hit-points) 10)
  (transform-post)
  (go (method-of-object this idle))
  )

(deftype burning-bush (process-focusable)
  ((task        game-task-control)
   (part-off    sparticle-launch-control)
   (part-alert  sparticle-launch-control)
   (angle       float)
   (time        float)
   (rotmin      float)
   (rotmax      float)
   (bb-perm     entity-perm)
   )
  (:state-methods
    idle
    talking
    menu
    collect-gems
    )
  (:methods
    (burning-bush-method-32 (_type_) none)
    (burning-bush-method-33 (_type_) none)
    (burning-bush-method-34 (_type_) object)
    )
  )


(defstate collect-gems (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (process-release? *target*)
    )
  :code (behavior ()
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (let ((gp-0 (-> (get-current-task-event (-> self task)) tex)))
      (format 0 "skull-cost: ~d~%" gp-0)
      (set! (-> *target* game gem) (- (-> *target* game gem) (the float gp-0)))
      (until (time-elapsed? (-> self state-time) (* 45 (the-as int gp-0)))
        (suspend)
        )
      )
    (go-virtual talking)
    )
  )

(defskelgroup skel-burning-bush burning-bush burning-bush-lod0-jg burning-bush-idle-ja
              ((burning-bush-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 3.5)
              )

(defstate idle (burning-bush)
  :virtual #t
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (let ((gp-0 (get-current-task-event (-> self task))))
      (let ((s5-0 (new 'stack-no-clear 'matrix)))
        (let* ((a2-0 (-> self node-list data 3 bone transform))
               (v1-4 (-> a2-0 rvec quad))
               (a0-1 (-> a2-0 uvec quad))
               (a1-0 (-> a2-0 fvec quad))
               (a2-1 (-> a2-0 trans quad))
               )
          (set! (-> s5-0 rvec quad) v1-4)
          (set! (-> s5-0 uvec quad) a0-1)
          (set! (-> s5-0 fvec quad) a1-0)
          (set! (-> s5-0 trans quad) a2-1)
          )
        (when (< (vector-dot
                   (-> s5-0 fvec)
                   (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans s5-0 (new 'stack-no-clear 'vector)))
                   )
                 0.0
                 )
          )
        (let ((v1-11 (-> self entity extra perm)))
          (logior! (-> v1-11 status) (entity-perm-status bit-5))
          (set! (-> self bb-perm) v1-11)
          (logior! (-> v1-11 status) (entity-perm-status bit-14))
          )
        (cond
          ((= (-> self bb-perm user-object 0) 1)
           (if (nonzero? (-> gp-0 action))
               (spawn-from-mat (-> self part) s5-0)
               )
           )
          ((= (-> gp-0 action) (game-task-action show))
           (spawn-from-mat (-> self part-off) s5-0)
           )
          ((= (-> gp-0 action) (game-task-action play))
           (spawn-from-mat (-> self part-off) s5-0)
           )
          ((= (-> gp-0 action) (game-task-action menu))
           (spawn-from-mat (-> self part) s5-0)
           )
          (else
            )
          )
        )
      (cond
        ((and (or (= (-> gp-0 action) (game-task-action show)) (= (-> gp-0 action) (game-task-action menu)))
              (and (burning-bush-method-34 self) (can-display-query? self (the-as string #f) -99.0))
              )
         (let ((s4-2
                 (new 'stack 'font-context *font-default-matrix* 32 300 0.0 (font-color default) (font-flags shadow kerning))
                 )
               (s5-1 (-> gp-0 tex))
               )
           (set! (-> s4-2 flags) (font-flags shadow kerning large))
           (let ((v1-36 s4-2))
             (set! (-> v1-36 width) (the float 340))
             )
           (let ((v1-37 s4-2))
             (set! (-> v1-37 height) (the float 80))
             )
           (let ((v1-38 s4-2))
             (set! (-> v1-38 scale) 0.6)
             )
           (let ((v1-41 (-> self entity extra perm)))
             (logior! (-> v1-41 status) (entity-perm-status bit-5))
             (set! (-> self bb-perm) v1-41)
             (logior! (-> v1-41 status) (entity-perm-status bit-14))
             )
           (cond
             ((zero? (-> self bb-perm user-object 0))
              (let ((s3-1 print-game-text))
                (format (clear *temp-string*) (lookup-text! *common-text* (text-id text-061d) #f) s5-1)
                (s3-1 *temp-string* s4-2 #f 44 (bucket-id hud-draw-hud-alpha))
                )
              (logior! (-> *hud-skullgem* 0 flags) (hud-flags show))
              )
             (else
               (let ((s3-2 print-game-text))
                 (format (clear *temp-string*) (lookup-text! *common-text* (text-id press-triangle-to-talk) #f))
                 (s3-2 *temp-string* s4-2 #f 44 (bucket-id hud-draw-hud-alpha))
                 )
               )
             )
           (when (cpad-pressed? 0 triangle)
             (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
             (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
             (cond
               ((= (-> gp-0 action) (game-task-action menu))
                (go-virtual menu)
                )
               ((and (zero? (-> self bb-perm user-object 0))
                     (or (= s5-1 (the int (-> *target* game gem)))
                         (< (the-as uint s5-1) (the-as uint (the int (-> *target* game gem))))
                         )
                     )
                (set! (-> self bb-perm user-object 0) 1)
                (go-virtual collect-gems)
                )
               ((= (-> self bb-perm user-object 0) 1)
                (go-virtual talking)
                )
               (else
                 (sound-play "skull-negative")
                 )
               )
             )
           )
         )
        (else
          (if *hud-skullgem*
              (logclear! (-> *hud-skullgem* 0 flags) (hud-flags show))
              )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

(defstate talking (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (process-entity-status! self (entity-perm-status no-kill) #t)
    )
  :exit (behavior ()
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'minimap)
    (set! (-> *part-id-table* 1180 init-specs 4 initial-valuef) 14336.0)
    (set! (-> *part-id-table* 1181 init-specs 4 initial-valuef) 16384.0)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (local-vars
      (sv-272 vector)
      (sv-288 quaternion)
      (sv-304 (function float float float float float float))
      (sv-320 float)
      (sv-336 float)
      )
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (!= (-> self time) -1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (let ((s5-0 gp-0)
                (s4-0 (-> self root trans))
                (s3-0 vector-orient-by-quat!)
                (s2-0 (new 'stack-no-clear 'vector))
                (s1-0 (new 'static 'vector :y 16384.0 :z 40960.0 :w 1.0))
                (s0-0 quaternion-rotate-local-y!)
                )
            (set! sv-272 (new 'stack-no-clear 'vector))
            (set! sv-288 (-> self root quat))
            (set! sv-304 lerp-scale)
            (set! sv-320 (-> self rotmin))
            (set! sv-336 (-> self rotmax))
            (let* ((a2-0 (sin (* 7281.778 (-> self time))))
                   (a3-0 -1.0)
                   (t0-0 1.0)
                   (a2-1 (sv-304 sv-320 sv-336 a2-0 a3-0 t0-0))
                   )
              (vector+! s5-0 s4-0 (s3-0 s2-0 s1-0 (s0-0 (the-as quaternion sv-272) sv-288 a2-1)))
              )
            )
          (set! (-> *camera* slave 0 trans quad) (-> gp-0 quad))
          (let ((t9-4 forward-down->inv-matrix)
                (a0-6 (-> *camera* slave 0 tracking))
                (a1-3 (new 'stack-no-clear 'vector))
                (v1-18 (new 'stack-no-clear 'vector))
                )
            (let ((a2-4 (-> self root trans)))
              (let ((a3-1 *up-vector*))
                (let ((t0-2 20480.0))
                  (.mov vf7 t0-2)
                  )
                (.lvf vf5 (&-> a3-1 quad))
                )
              (.lvf vf4 (&-> a2-4 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-18 quad) vf6)
            (t9-4 (the-as matrix a0-6) (vector-! a1-3 v1-18 gp-0) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-1 (new 'stack-no-clear 'matrix)))
        (let* ((a2-6 (-> self node-list data 3 bone transform))
               (v1-23 (-> a2-6 rvec quad))
               (a0-7 (-> a2-6 uvec quad))
               (a1-5 (-> a2-6 fvec quad))
               (a2-7 (-> a2-6 trans quad))
               )
          (set! (-> gp-1 rvec quad) v1-23)
          (set! (-> gp-1 uvec quad) a0-7)
          (set! (-> gp-1 fvec quad) a1-5)
          (set! (-> gp-1 trans quad) a2-7)
          )
        (if (< (vector-dot
                 (-> gp-1 fvec)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-1 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-1)
            )
        (+! (-> self angle) (* 100.0 (rand-vu)))
        (set! (-> *part-id-table* 1180 init-specs 4 initial-valuef)
              (+ 14336.0 (* 1228.8 (cos (* 182.04445 (-> self angle)))))
              )
        (set! (-> *part-id-table* 1181 init-specs 4 initial-valuef)
              (+ 2048.0 (-> *part-id-table* 1180 init-specs 4 initial-valuef))
              )
        (spawn-from-mat (-> self part) gp-1)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (if *target*
        (set! (-> *target* neck flex-blend) 1.0)
        )
    (add-setting! 'music-volume 'rel (-> *setting-control* user-current music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> *setting-control* user-current sfx-volume-movie) 0)
    (add-setting! 'dialog-volume 'rel (-> *setting-control* user-current dialog-volume-talker) 0)
    (set-time! (-> self state-time))
    (let* ((v1-21 (get-current-task-event (-> self task)))
           (gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) (-> v1-21 scene) -99.0 0))
           )
      (let ((s5-0 (current-time)))
        (while (and (nonzero? (get-status *gui-control* gp-0)) (not (time-elapsed? s5-0 (seconds 60))))
          (set! (-> self time) (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
          (suspend)
          (when (cpad-pressed? 0 triangle)
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
            (sound-play "inter-burn-bush")
            (goto cfg-13)
            )
          )
        )
      (label cfg-13)
      (set-action!
        *gui-control*
        (gui-action stop)
        gp-0
        (gui-channel none)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (task-node-close! (-> self task current-node) 'event)
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

(defstate menu (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (remove-setting! 'minimap)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (time-elapsed? (-> self state-time) (seconds 1.5))
        (let ((gp-0 0)
              (s5-0 0)
              )
          (when (cpad-pressed? 0 down l-analog-down)
            (+! s5-0 1)
            (if (< (+ gp-0 -1) s5-0)
                (set! s5-0 (+ gp-0 -1))
                (sound-play "menu-up-down")
                )
            )
          (when (cpad-pressed? 0 up l-analog-up)
            (+! s5-0 -1)
            (if (< s5-0 0)
                (set! s5-0 0)
                (sound-play "menu-up-down")
                )
            )
          (let* ((s4-2 40)
                 (s3-2 36)
                 (s2-0 (- 228 (* gp-0 (/ s4-2 2))))
                 (v1-19 (new
                          'stack
                          'font-context
                          *font-default-matrix*
                          s3-2
                          s2-0
                          0.0
                          (font-color default)
                          (font-flags shadow kerning)
                          )
                        )
                 )
            (set! (-> v1-19 flags) (font-flags shadow kerning middle middle-vert large))
            (let ((a0-17 v1-19))
              (set! (-> a0-17 width) (the float 440))
              )
            (let ((a0-18 v1-19))
              (set! (-> a0-18 height) (the float 50))
              )
            (let ((a0-19 v1-19))
              (set! (-> a0-19 scale) 1.0)
              )
            (let ((a0-20 v1-19)
                  (a2-3 s3-2)
                  (a1-6 40)
                  )
              (set! (-> a0-20 origin x) (the float a2-3))
              (set! (-> a0-20 origin y) (the float a1-6))
              )
            (let ((a1-7 v1-19))
              (set! (-> a1-7 color) (font-color progress-old-yellow))
              )
            (let ((a0-22 v1-19))
              (set! (-> a0-22 height) (the float s4-2))
              )
            (dotimes (a0-23 gp-0)
              (let ((a1-9 v1-19)
                    (a3-3 s3-2)
                    (a2-4 s2-0)
                    )
                (set! (-> a1-9 origin x) (the float a3-3))
                (set! (-> a1-9 origin y) (the float a2-4))
                )
              (let ((a1-10 v1-19))
                (set! (-> a1-10 scale) (if (= a0-23 s5-0)
                                           0.8
                                           0.6
                                           )
                      )
                )
              (let ((a2-6 v1-19))
                (set! (-> a2-6 color) (if (= a0-23 s5-0)
                                          (font-color progress-old-selected)
                                          (font-color default)
                                          )
                      )
                )
              (+! s2-0 s4-2)
              )
            )
          )
        )
      (when (!= (-> self time) -1.0)
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (vector+! gp-1 (-> self root trans) (vector-orient-by-quat!
                                                (new 'stack-no-clear 'vector)
                                                (new 'static 'vector :y 24166.4 :z 32768.0 :w 1.0)
                                                (-> self root quat)
                                                )
                    )
          (set! (-> *camera* slave 0 trans quad) (-> gp-1 quad))
          (let ((t9-6 forward-down->inv-matrix)
                (a0-27 (-> *camera* slave 0 tracking))
                (a1-13 (new 'stack-no-clear 'vector))
                (v1-35 (new 'stack-no-clear 'vector))
                )
            (let ((a2-9 (-> self root trans)))
              (let ((a3-4 *up-vector*))
                (let ((t0-4 24166.4))
                  (.mov vf7 t0-4)
                  )
                (.lvf vf5 (&-> a3-4 quad))
                )
              (.lvf vf4 (&-> a2-9 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-35 quad) vf6)
            (t9-6 (the-as matrix a0-27) (vector-! a1-13 v1-35 gp-1) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-2 (new 'stack-no-clear 'matrix)))
        (let* ((a2-11 (-> self node-list data 3 bone transform))
               (v1-40 (-> a2-11 rvec quad))
               (a0-28 (-> a2-11 uvec quad))
               (a1-15 (-> a2-11 fvec quad))
               (a2-12 (-> a2-11 trans quad))
               )
          (set! (-> gp-2 rvec quad) v1-40)
          (set! (-> gp-2 uvec quad) a0-28)
          (set! (-> gp-2 fvec quad) a1-15)
          (set! (-> gp-2 trans quad) a2-12)
          )
        (if (< (vector-dot
                 (-> gp-2 fvec)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-2 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-2 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-2)
            )
        (spawn-from-mat (-> self part-off) gp-2)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set! (-> self time) 0.0)
    (let ((s4-0 #f))
      (let ((gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) "cityv174" -99.0 0)))
        (let ((s5-0 (current-time)))
          (while (and (nonzero? (get-status *gui-control* gp-0)) (not (time-elapsed? s5-0 (seconds 60))) (not s4-0))
            (suspend)
            (when (or (cpad-pressed? 0 triangle) (cpad-pressed? 0 confirm))
              (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
              (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
              (sound-play "inter-burn-bush")
              (set! s4-0 #t)
              )
            )
          )
        (set-action!
          *gui-control*
          (gui-action stop)
          gp-0
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
      (when (not s4-0)
        (until #f
          (when (or (cpad-pressed? 0 confirm) (cpad-pressed? 0 triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (sound-play "menu-pick")
            #t
            (goto cfg-23)
            )
          (suspend)
          )
        #f
        )
      )
    (until (process-release? *target*)
      (label cfg-23)
      (suspend)
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

(defmethod burning-bush-method-34 ((this burning-bush))
  (let* ((gp-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> this root trans)))
         (f30-0 (vector-dot (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         (f0-2 (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         )
    (and *target*
         (not (focus-test? *target* pilot))
         (< (fabs f30-0) 10240.0)
         (< 0.0 f0-2)
         (< (fabs f0-2) 20480.0)
         )
    )
  )

(defmethod burning-bush-method-32 ((this burning-bush))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod burning-bush-method-33 ((this burning-bush))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 260) this))
  (set! (-> this part-off) (create-launch-control (-> *part-group-id-table* 261) this))
  (set! (-> this part-alert) (create-launch-control (-> *part-group-id-table* 262) this))
  0
  (none)
  )

;; WARN: Return type mismatch process-focusable vs burning-bush.
(defmethod relocate ((this burning-bush) (offset int))
  (if (nonzero? (-> this task))
      (&+! (-> this task) offset)
      )
  (if (nonzero? (-> this part-off))
      (&+! (-> this part-off) offset)
      )
  (if (nonzero? (-> this part-alert))
      (&+! (-> this part-alert) offset)
      )
  (the-as burning-bush ((method-of-type process-focusable relocate) this offset))
  )

(defmethod deactivate ((this burning-bush))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part-off))
      (kill-particles (-> this part-off))
      )
  (if (nonzero? (-> this part-alert))
      (kill-particles (-> this part-alert))
      )
  ((method-of-type process-focusable deactivate) this)
  (none)
  )

(defmethod run-logic? ((this burning-bush))
  "Should this process be run? Checked by execute-process-tree."
  (or (not (logtest? (-> this mask) (process-mask actor-pause)))
      (or (and (nonzero? (-> this draw))
               (logtest? (-> this draw status) (draw-control-status on-screen))
               (>= (+ (-> *ACTOR-bank* pause-dist) (-> this root pause-adjust-distance))
                   (vector-vector-distance (-> this root trans) (math-camera-pos))
                   )
               )
          (and (nonzero? (-> this skel)) (!= (-> this skel root-channel 0) (-> this skel channel)))
          (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status uninited)))
          )
      )
  )

(defmethod init-from-entity! ((this burning-bush) (arg0 entity-actor))
  (burning-bush-method-32 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-burning-bush" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (burning-bush-method-33 this)
  (set! (-> this rotmin) (res-lump-float arg0 'rotmin :default -5461.3335))
  (set! (-> this rotmax) (res-lump-float arg0 'rotmax :default 5461.3335))
  (let ((f0-2 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-2 0.0)
        (quaternion-rotate-local-y! (-> this root quat) (-> this root quat) f0-2)
        )
    )
  (set! (-> this task)
        (new 'process 'game-task-control (res-lump-value arg0 'task-actor game-task-actor :time -1000000000.0))
        )
  (set! (-> this angle) 0.0)
  (set! (-> this root pause-adjust-distance) 819200.0)
  (transform-post)
  (go (method-of-object this idle))
  )

(deftype city-burning-bush-get-on-info (structure)
  ((trans         vector      :inline)
   (quat          quaternion  :inline)
   (camera-trans  vector      :inline)
   (camera-rot    float       9)
   (time          float)
   (fov           float)
   )
  )


(define *city-burning-bush-get-on-info*
  (new 'static 'boxed-array :type city-burning-bush-get-on-info
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1442120.5 :y 32765.543 :z -412846.9 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0006 :y 0.8826 :z -0.0012 :w -0.4699)
      :camera-trans (new 'static 'vector :x 1458548.4 :y 46188.543 :z -449677.72 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.8889 0.0 0.458 -0.0229 0.9987 0.0444 -0.4574 -0.05 0.8878)
      :time 7500.0
      :fov 12743.111
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 2247272.5 :y 67314.484 :z -1134648.9 :w 1.0)
      :quat (new 'static 'quaternion :x -0.1469 :y 0.0545 :z 0.0068 :w 0.9876)
      :camera-trans (new 'static 'vector :x 2279621.8 :y 74105.24 :z -1128908.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.6307 0.0 0.776 -0.2236 0.9575 -0.1817 -0.743 -0.2881 -0.6039)
      :time 5400.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1438305.1 :y 71998.26 :z -1084914.5 :w 1.0)
      :quat (new 'static 'quaternion :x 0.001 :y -0.9202 :z 0.0002 :w -0.3912)
      :camera-trans (new 'static 'vector :x 1479435.0 :y 85435.59 :z -1095610.4 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.151 0.0 0.9885 0.0056 0.9999 -0.0008 -0.9885 0.0057 0.151)
      :time 5400.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1466428.2 :y 125903.26 :z -1495985.0 :w 1.0)
      :quat (new 'static 'quaternion :y 0.2215 :w 0.9751)
      :camera-trans (new 'static 'vector :x 1465902.8 :y 102859.57 :z -1401041.8 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.9864 0.0 0.1639 0.0493 0.9536 0.2967 -0.1563 0.3008 -0.9407)
      :time 6600.0
      :fov 10922.667
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 634022.3 :y 122880.0 :z -697692.56 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0012 :y 0.6246 :z 0.0009 :w -0.7808)
      :camera-trans (new 'static 'vector :x 684180.7 :y 160337.52 :z -642709.1 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.6785 0.0 0.7345 -0.3495 0.8795 -0.3229 -0.646 -0.4758 -0.5967)
      :time 5100.0
      :fov 10922.667
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1966872.6 :y 47686.86 :z -206054.19 :w 1.0)
      :quat (new 'static 'quaternion :y 0.9988 :w 0.0482)
      :camera-trans (new 'static 'vector :x 1971155.4 :y 38171.44 :z -273855.7 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.9641 0.0 -0.2652 0.0043 0.9998 0.0158 0.2652 -0.0164 0.964)
      :time 6900.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 2645027.2 :y 7752.499 :z -2422284.8 :w 1.0)
      :quat (new 'static 'quaternion :y -0.9993 :w -0.0352)
      :camera-trans (new 'static 'vector :x 2643901.8 :y 20940.8 :z -2451367.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.818 0.0 0.5751 -0.061 0.9943 0.0869 -0.5718 -0.1062 0.8134)
      :time 5400.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 2339761.0 :y 92694.12 :z -3021732.8 :w 1.0)
      :quat (new 'static 'quaternion :y 0.3606 :w -0.9326)
      :camera-trans (new 'static 'vector :x 2329062.2 :y 105224.6 :z -2983756.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.7717 0.0 -0.6359 0.3292 0.8555 -0.3995 0.544 -0.5177 -0.6602)
      :time 6000.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3210766.0 :y 32764.314 :z 787847.2 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0008 :y 0.5021 :z 0.0011 :w -0.8647)
      :camera-trans (new 'static 'vector :x 3185149.2 :y 40500.84 :z 778470.6 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.1119 0.0 -0.9937 0.0693 0.9975 0.0078 0.9912 -0.0697 0.1116)
      :time 6000.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 4139099.2 :y 37910.527 :z 1484301.5 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0002 :y -0.1337 :z 0.0015 :w 0.991)
      :camera-trans (new 'static 'vector :x 4120032.5 :y 53998.387 :z 1506306.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.6088 0.0 -0.7932 0.1409 0.984 -0.1082 0.7806 -0.1777 -0.5991)
      :time 3300.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3936017.2 :y 94799.46 :z 2196627.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0015 :y -0.483 :z -0.0002 :w -0.8755)
      :camera-trans (new 'static 'vector :x 3910655.2 :y 104816.23 :z 2183312.2 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.6539 0.0 -0.7564 0.0916 0.9926 0.0792 0.7509 -0.1211 0.6491)
      :time 4200.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 4434624.0 :y 100512.56 :z 2489095.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0005 :y 0.1411 :w 0.9899)
      :camera-trans (new 'static 'vector :x 4484939.5 :y 121671.27 :z 2430261.2 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.6538 0.0 0.7566 -0.4974 0.7535 0.4298 -0.5701 -0.6573 0.4926)
      :time 3000.0
      :fov 18204.445
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3858326.8 :y 99340.695 :z 3912547.5 :w 1.0)
      :quat (new 'static 'quaternion :y 0.0271 :w 0.9996)
      :camera-trans (new 'static 'vector :x 3848977.5 :y 111943.68 :z 3934181.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.8843 0.0 -0.4667 0.1047 0.9744 -0.1984 0.4548 -0.2243 -0.8618)
      :time 3900.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 3764324.2 :y 98499.79 :z 4562610.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0012 :y 0.0062 :w 0.9999)
      :camera-trans (new 'static 'vector :x 3691300.0 :y 123541.914 :z 4541654.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.2135 0.0 -0.9769 0.2535 0.9657 0.0554 0.9434 -0.2594 0.2062)
      :time 3900.0
      :fov 7281.778
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 4427024.5 :y 74095.414 :z 3948627.5 :w 1.0)
      :quat (new 'static 'quaternion :y -0.972 :w 0.2349)
      :camera-trans (new 'static 'vector :x 4436096.0 :y 88536.266 :z 3978709.8 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.9909 0.0 0.1338 -0.0287 0.9767 -0.2124 -0.1307 -0.2143 -0.9679)
      :time 3900.0
      :fov 18204.445
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1377852.2 :y 76197.89 :z 7083083.0 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0004 :y 0.3829 :z -0.001 :w 0.9237)
      :camera-trans (new 'static 'vector :x 1263103.6 :y 188428.28 :z 6971105.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.5705 0.0 -0.8212 0.5598 0.7316 0.3889 0.6008 -0.6817 0.4174)
      :time 1800.0
      :fov 5461.3335
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x -942875.9 :y 96113.46 :z 6424137.0 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0002 :y 0.9944 :w 0.1048)
      :camera-trans (new 'static 'vector :x -755284.4 :y 180505.81 :z 6304042.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.6079 0.0 0.7939 -0.329 0.9101 0.2519 -0.7225 -0.4143 0.5533)
      :time 2100.0
      :fov 3640.889
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x -1205959.5 :y 114149.375 :z 5692970.5 :w 1.0)
      :quat (new 'static 'quaternion :x -0.0005 :y 0.8807 :z -0.001 :w -0.4736)
      :camera-trans (new 'static 'vector :x -1230954.9 :y 126642.586 :z 5698481.5 :w 1.0)
      :camera-rot (new 'static 'array float 9 -0.1203 0.0 -0.9927 0.4576 0.8874 -0.0554 0.8809 -0.4609 -0.1068)
      :time 6900.0
      :fov 16384.0
      )
    (new 'static 'city-burning-bush-get-on-info
      :trans (new 'static 'vector :x 1641758.8 :y 97295.98 :z 5436796.0 :w 1.0)
      :quat (new 'static 'quaternion :x 0.0001 :y 0.4706 :z 0.0001 :w 0.8823)
      :camera-trans (new 'static 'vector :x 1620224.0 :y 105643.625 :z 5418739.0 :w 1.0)
      :camera-rot (new 'static 'array float 9 0.8069 0.0 -0.5906 0.1079 0.9831 0.1474 0.5807 -0.1826 0.7933)
      :time 4500.0
      :fov 14563.556
      )
    )
  )

(deftype task-manager-ctywide-bbush-get-to (task-manager)
  ((skill  handle)
   )
  (:methods
    (task-manager-ctywide-bbush-get-to-method-32 (_type_) none)
    )
  )


(defmethod task-manager-ctywide-bbush-get-to-method-32 ((this task-manager-ctywide-bbush-get-to))
  (set-setting! 'city-sound '(citybb1) 0.0 2)
  0
  (none)
  )

(defmethod set-time-limit ((this task-manager-ctywide-bbush-get-to))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set-setting! 'airlock #f 0.0 0)
  (task-manager-ctywide-bbush-get-to-method-32 this)
  (when (nonzero? (-> this skill))
    (let ((a0-5 (handle->process (-> this skill))))
      (if a0-5
          (deactivate a0-5)
          )
      )
    )
  (none)
  )

(defstate active (task-manager-ctywide-bbush-get-to)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('notify)
       (case (-> block param 0)
         (('pickup)
          (send-event self 'complete)
          )
         (('die)
          (send-event self 'fail)
          )
         )
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (while (not (process-grab? *target* #f))
      (suspend)
      )
    (let ((t1-1 (new 'stack 'fact-info self (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc)))
          (a0-3 (new 'stack-no-clear 'vector))
          )
      (logior! (-> t1-1 options) (actor-option fade-out))
      (set! (-> t1-1 fade-time)
            (the-as time-frame (the int (-> *city-burning-bush-get-on-info* (-> self info index) time)))
            )
      (set! (-> a0-3 quad) (-> *city-burning-bush-get-on-info* (-> self info index) trans quad))
      (+! (-> a0-3 y) 4096.0)
      (set! (-> self skill)
            (ppointer->handle
              (birth-pickup-at-point a0-3 (pickup-type skill) (-> *FACT-bank* super-skill-inc) #t self t1-1)
              )
            )
      )
    (set-time! (-> self start-time))
    (set! (-> self time-limit)
          (the-as time-frame (the int (+ 300.0 (-> *city-burning-bush-get-on-info* (-> self info index) time))))
          )
    (suspend)
    (send-event (handle->process (-> self skill)) 'get-notify self)
    (set-setting! 'interp-time 'abs 0.0 0)
    (set-setting! 'mode-name 'cam-fixed 0.0 0)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (suspend)
    (let ((f30-0 (-> *camera* settings fov)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 quad) (-> *camera-combiner* trans quad))
        (let ((gp-0 (new 'stack-no-clear 'matrix)))
          (let* ((a2-7 (-> *camera-combiner* inv-camera-rot))
                 (v1-46 (-> a2-7 rvec quad))
                 (a0-15 (-> a2-7 uvec quad))
                 (a1-15 (-> a2-7 fvec quad))
                 (a2-8 (-> a2-7 trans quad))
                 )
            (set! (-> gp-0 rvec quad) v1-46)
            (set! (-> gp-0 uvec quad) a0-15)
            (set! (-> gp-0 fvec quad) a1-15)
            (set! (-> gp-0 trans quad) a2-8)
            )
          (let ((s4-0 (new 'stack 'transformq)))
            (let ((v1-52 (-> *city-burning-bush-get-on-info* (-> self info index)))
                  (a1-17 (new 'stack-no-clear 'matrix))
                  )
              (set! (-> s4-0 trans quad) (-> v1-52 camera-trans quad))
              (set-vector! (-> s4-0 scale) 1.0 1.0 1.0 1.0)
              (set! (-> a1-17 rvec x) (-> v1-52 camera-rot 0))
              (set! (-> a1-17 rvec y) (-> v1-52 camera-rot 1))
              (set! (-> a1-17 rvec z) (-> v1-52 camera-rot 2))
              (set! (-> a1-17 rvec w) 0.0)
              (set! (-> a1-17 uvec x) (-> v1-52 camera-rot 3))
              (set! (-> a1-17 uvec y) (-> v1-52 camera-rot 4))
              (set! (-> a1-17 uvec z) (-> v1-52 camera-rot 5))
              (set! (-> a1-17 uvec w) 0.0)
              (set! (-> a1-17 fvec x) (-> v1-52 camera-rot 6))
              (set! (-> a1-17 fvec y) (-> v1-52 camera-rot 7))
              (set! (-> a1-17 fvec z) (-> v1-52 camera-rot 8))
              (set! (-> a1-17 fvec w) 0.0)
              (set! (-> a1-17 trans x) 0.0)
              (set! (-> a1-17 trans y) 0.0)
              (set! (-> a1-17 trans z) 0.0)
              (set! (-> a1-17 trans w) 1.0)
              (matrix->quaternion (-> s4-0 quat) a1-17)
              )
            (send-event *camera* 'teleport-to-transformq s4-0)
            )
          (let ((s4-1 (current-time)))
            (until (time-elapsed? s4-1 (seconds 3))
              (set! (-> *camera* slave 0 fov) (-> *city-burning-bush-get-on-info* (-> self info index) fov))
              (suspend)
              )
            )
          (set! (-> *camera-combiner* trans quad) (-> s5-0 quad))
          (let ((a2-15 (-> *camera-combiner* inv-camera-rot))
                (v1-74 (-> gp-0 rvec quad))
                (a0-24 (-> gp-0 uvec quad))
                (a1-19 (-> gp-0 fvec quad))
                (a3-5 (-> gp-0 trans quad))
                )
            (set! (-> a2-15 rvec quad) v1-74)
            (set! (-> a2-15 uvec quad) a0-24)
            (set! (-> a2-15 fvec quad) a1-19)
            (set! (-> a2-15 trans quad) a3-5)
            )
          )
        )
      (set! (-> *camera* settings fov) f30-0)
      )
    (remove-setting! 'minimap)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (let ((a0-28 (get-continue-by-name *game-info* (-> self node-info reset fail-info retry continue)))
          (gp-1 (new 'static 'vector :z 1.0))
          )
      (when a0-28
        (move-camera! a0-28)
        (set-vector!
          gp-1
          (-> *camera-combiner* inv-camera-rot uvec x)
          (-> *camera-combiner* inv-camera-rot uvec y)
          (-> *camera-combiner* inv-camera-rot uvec z)
          1.0
          )
        (vector-negate-in-place! gp-1)
        (set-setting! 'string-startup-vector 'abs gp-1 0)
        )
      )
    (persist-with-delay *setting-control* 'interp-time (seconds 0.5) 'interp-time 'abs 0.0 0)
    (remove-setting! 'fov)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    (while (not (process-release? *target*))
      (suspend)
      )
    (until #f
      (hud-timer-handler self)
      (suspend)
      )
    #f
    )
  )

(defmethod gen-static-macro ((this city-race-ring-info) (arg0 object))
  (format arg0 "(static-race-ring-info~%")
  (format arg0 "     :pos (~4,,2M ~4,,2M ~4,,2M)~%" (-> this pos x) (-> this pos y) (-> this pos z))
  (let ((f0-3 (-> this pos w)))
    (format arg0 "     :angle (deg ~f)~%" (* 0.005493164 f0-3))
    )
  (if (!= (-> this boost) 1.0)
      (format arg0 "     :boost ~4,,2f~%" (-> this boost))
      )
  (format arg0 "     :dist (meters ~4,,2M)~%" (-> this dist))
  (format arg0 "     ~%)~%")
  0
  (none)
  )

(defmethod init ((this city-ambush-info) (arg0 traffic-object-spawn-params))
  (set! (-> arg0 position quad) (-> this array 0 pos quad))
  (set! (-> arg0 nav-mesh) (find-nearest-nav-mesh (-> arg0 position) (the-as float #x7f800000)))
  (vector-reset! (-> arg0 velocity))
  (dotimes (s4-0 (-> this count))
    (let ((v1-3 (-> this array s4-0)))
      (set! (-> arg0 position quad) (-> v1-3 pos quad))
      (set! (-> arg0 object-type) (-> v1-3 obj-type))
      )
    (send-event *traffic-manager* 'activate-object arg0)
    0
    )
  0
  (none)
  )

(deftype ctyn-lamp (process-focusable)
  ()
  (:state-methods
    idle
    die
    )
  (:methods
    (ctyn-lamp-method-30 (_type_) none)
    (ctyn-lamp-method-31 (_type_) none)
    )
  )


(defskelgroup skel-ctyn-lamp ctyn-lamp 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 0 0 5))

(defskelgroup skel-ctyn-lamp-explode ctyn-lamp 3 5 ((4 (meters 999999))) :bounds (static-spherem 0 0 0 80))

(define *ctyn-lamp-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      )
    :collide-spec (collide-spec backgnd)
    )
  )

(defstate idle (ctyn-lamp)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (-> block param 1)
       (let ((s5-0 proc)
             (gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1)))
             )
         (set! (-> gp-0 fountain-rand-transv-lo quad) (-> (the-as joint-exploder s5-0) root trans quad))
         (set! (-> gp-0 fountain-rand-transv-hi x) 16384.0)
         (set! (-> gp-0 fountain-rand-transv-hi y) 40960.0)
         (process-spawn
           joint-exploder
           (art-group-get-by-name *level* "skel-ctyn-lamp-explode" (the-as (pointer level) #f))
           5
           gp-0
           *ctyn-lamp-exploder-params*
           :name "joint-exploder"
           :to self
           :unk 0
           )
         )
       (go-virtual die)
       )
      )
    )
  :code sleep-code
  )

(defstate die (ctyn-lamp)
  :virtual #t
  :enter #f
  :exit #f
  :trans #f
  :code (behavior ()
    (sound-play "lamp-hit")
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post #f
  )

(defmethod ctyn-lamp-method-30 ((this ctyn-lamp))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-smack
                                    flut
                                    )
          )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 0)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod ctyn-lamp-method-31 ((this ctyn-lamp))
  (logior! (-> this mask) (process-mask crate))
  0
  (none)
  )

(defmethod init-from-entity! ((this ctyn-lamp) (arg0 entity-actor))
  (ctyn-lamp-method-30 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ctyn-lamp" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (ctyn-lamp-method-31 this)
  (transform-post)
  (go (method-of-object this idle))
  )

(deftype fac-lowrez-move (structure)
  ((light    light-state  :inline)
   (roty     float)
   (rotz     float)
   (rot-bob  float)
   (wobble   float)
   (bob      float)
   )
  :pack-me
  )


(deftype fac-lorez (process-drawable)
  ((move-info  fac-lowrez-move  :inline)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-fac-lorez fac-lorez fac-lorez-lod0-jg fac-lorez-idle-ja
              ((fac-lorez-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 400)
              )

(defmethod init-from-entity! ((this fac-lorez) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fac-lorez" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (go (method-of-object this idle))
  )

(defmethod run-logic? ((this fac-lorez))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defstate idle (fac-lorez)
  :virtual #t
  :trans (behavior ()
    (let ((s5-0 (new 'stack-no-clear 'quaternion))
          (gp-0 (new 'stack-no-clear 'quaternion))
          )
      (quaternion-vector-angle! s5-0 *y-vector* (- (-> self move-info roty)))
      (quaternion-vector-angle! gp-0 *z-vector* (-> self move-info wobble))
      (quaternion*! (-> self root quat) gp-0 s5-0)
      )
    (quaternion-normalize! (-> self root quat))
    (let ((f0-4 (+ (-> self move-info roty) (* 910.2222 (seconds-per-frame)))))
      (set! (-> self move-info roty) (- f0-4 (* (the float (the int (/ f0-4 65536.0))) 65536.0)))
      )
    (let ((f0-7 (+ (-> self move-info rotz) (* 8192.0 (seconds-per-frame)))))
      (set! (-> self move-info rotz) (- f0-7 (* (the float (the int (/ f0-7 65536.0))) 65536.0)))
      )
    (set! (-> self move-info wobble) (* 910.2222 (sin (-> self move-info rotz))))
    (let ((f0-13 (+ (-> self move-info rot-bob) (* 16384.0 (seconds-per-frame)))))
      (set! (-> self move-info rot-bob) (- f0-13 (* (the float (the int (/ f0-13 65536.0))) 65536.0)))
      )
    (set! (-> self move-info bob) (+ -40960.0 (* 40960.0 (sin (-> self move-info rot-bob)))))
    )
  :code sleep-code
  :post ja-post
  )

(deftype flitter-spawner (process-drawable)
  ((actor-group          (pointer actor-group)  :offset 204)
   (actor-group-count    int32)
   (spawner              proc-focusable-spawner)
   (desired-spawn-count  int32)
   (spawn-times          (array time-frame))
   (last-seen-times      (array time-frame))
   )
  (:state-methods
    active
    )
  (:methods
    (spawn-flitter (_type_ entity-actor) object)
    )
  )


(defmethod relocate ((this flitter-spawner) (offset int))
  (if (nonzero? (-> this spawner))
      (&+! (-> this spawner) offset)
      )
  (if (nonzero? (-> this spawn-times))
      (&+! (-> this spawn-times) offset)
      )
  (if (nonzero? (-> this last-seen-times))
      (&+! (-> this last-seen-times) offset)
      )
  (call-parent-method this offset)
  )

(defmethod run-logic? ((this flitter-spawner))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defmethod init-from-entity! ((this flitter-spawner) (arg0 entity-actor))
  (local-vars (sv-16 res-tag))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (set! (-> this entity) arg0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-2 (res-lump-data (-> this entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (cond
      ((and v1-2 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) v1-2)
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-scenecamera" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this desired-spawn-count) 8)
  (when (> (-> this actor-group-count) 0)
    (set! (-> this spawner) (new 'process 'proc-focusable-spawner))
    (set! (-> this spawn-times) (new 'process 'boxed-array time-frame (-> this actor-group-count)))
    (alloc-records! (-> this spawner) (+ (-> this desired-spawn-count) 2) 'process)
    (set! (-> this last-seen-times) (new 'process 'boxed-array time-frame (+ (-> this desired-spawn-count) 2)))
    (dotimes (s5-2 (-> this spawner records length))
      (let ((s4-1 (new 'stack-no-clear 'traffic-object-spawn-params)))
        (set! (-> s4-1 velocity quad) (the-as uint128 0))
        (set! (-> s4-1 behavior) (the-as uint 1))
        (set! (-> s4-1 object-type) (traffic-type metalhead-flitter))
        (set! (-> s4-1 flags) (traffic-spawn-flags tsf0))
        (set! (-> s4-1 nav-branch) #f)
        (set! (-> this spawner records data s5-2 proc)
              (ppointer->handle
                (process-spawn metalhead-flitter :init citizen-init-by-other s4-1 :name "metalhead-flitter" :to this)
                )
              )
        )
      )
    )
  (go (method-of-object this active))
  )

(defmethod spawn-flitter ((this flitter-spawner) (arg0 entity-actor))
  (let ((gp-0 (new 'stack-no-clear 'traffic-object-spawn-params)))
    (set! (-> gp-0 velocity quad) (the-as uint128 0))
    (set! (-> gp-0 position quad) (-> arg0 extra trans quad))
    (quaternion-copy! (-> gp-0 rotation) (-> arg0 quat))
    (set! (-> gp-0 behavior) (the-as uint 2))
    (set! (-> gp-0 object-type) (traffic-type metalhead-flitter))
    (set! (-> gp-0 flags) (traffic-spawn-flags))
    (set! (-> gp-0 user-data) (the-as uint 0))
    (set! (-> gp-0 proc) #f)
    (set! (-> gp-0 nav-branch) #f)
    (let ((s4-0 (-> gp-0 position)))
      (let ((s3-0 (new 'stack-no-clear 'collide-query)))
        (vector+float*! (-> s3-0 start-pos) s4-0 *up-vector* 24576.0)
        (set! (-> s3-0 move-dist quad) (the-as uint128 0))
        (set! (-> s3-0 move-dist y) -81920.0)
        (let ((v1-8 s3-0))
          (set! (-> v1-8 radius) 40.96)
          (set! (-> v1-8 collide-with) (collide-spec backgnd))
          (set! (-> v1-8 ignore-process0) #f)
          (set! (-> v1-8 ignore-process1) #f)
          (set! (-> v1-8 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-8 action-mask) (collide-action solid))
          )
        (if (>= (fill-and-probe-using-line-sphere *collide-cache* s3-0) 0.0)
            (set! (-> s4-0 quad) (-> s3-0 best-other-tri intersect quad))
            )
        )
      (set! (-> gp-0 nav-mesh) (find-nearest-nav-mesh s4-0 (the-as float #x7f800000)))
      )
    (let ((a0-15 (get-last-unused-val! (-> this spawner))))
      (when (>= a0-15 0)
        (let ((v1-18 (-> this spawner records data a0-15 proc)))
          (set-time! (-> this last-seen-times a0-15))
          (send-event (handle->process v1-18) 'traffic-activate gp-0 *traffic-engine*)
          )
        )
      )
    )
  )

(defstate active (flitter-spawner)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 1))
      (set-time! (-> self state-time))
      (let ((gp-0 0))
        (dotimes (s5-0 (-> self spawner records length))
          (let* ((s4-0 (handle->process (-> self spawner records data s5-0 proc)))
                 (v1-11 (if (type? s4-0 process-focusable)
                            s4-0
                            )
                        )
                 )
            (when v1-11
              (if (not (focus-test? (the-as process-focusable v1-11) disable dead inactive))
                  (+! gp-0 1)
                  )
              )
            )
          )
        (when (< gp-0 (-> self desired-spawn-count))
          (let ((gp-1 0))
            (dotimes (s5-1 (length (-> self actor-group 0)))
              (let ((s4-1 (-> self actor-group 0 data s5-1 actor)))
                (when s4-1
                  (if (and (is-object-visible? (-> s4-1 extra level) (-> s4-1 vis-id))
                           (let ((s3-0 sphere-in-view-frustum?)
                                 (a0-13 (new 'stack 'sphere))
                                 )
                             (set! (-> a0-13 quad) (-> s4-1 extra trans quad))
                             (set! (-> a0-13 r) 8192.0)
                             (or (not (s3-0 a0-13)) (< 409600.0 (vector-vector-distance (-> s4-1 extra trans) (camera-pos))))
                             )
                           (time-elapsed? (-> self spawn-times s5-1) (seconds 3))
                           (< 61440.0 (vector-vector-distance (-> s4-1 extra trans) (target-pos 0)))
                           )
                      (set! gp-1 (logior gp-1 (ash 1 s5-1)))
                      )
                  )
                )
              )
            (when (nonzero? gp-1)
              (let* ((a1-10 (lognot gp-1))
                     (v1-52 (rand-vu-int-count-excluding (-> self actor-group 0 length) a1-10))
                     )
                (set-time! (-> self spawn-times v1-52))
                (spawn-flitter self (-> self actor-group 0 data v1-52 actor))
                )
              )
            )
          )
        )
      (check-inactive (-> self spawner))
      (dotimes (gp-2 (-> self last-seen-times length))
        (let* ((s4-3 (handle->process (-> self spawner records data gp-2 proc)))
               (s5-2 (if (type? s4-3 process-focusable)
                         s4-3
                         )
                     )
               (s4-4 (new 'stack 'sphere))
               )
          0.0
          (when (the-as process-focusable s5-2)
            (let ((f30-2 (vector-vector-distance (-> (the-as process-focusable s5-2) root trans) (target-pos 0))))
              (set! (-> s4-4 quad) (-> (the-as process-focusable s5-2) root trans quad))
              (set! (-> s4-4 r) 8192.0)
              (if (or (and (sphere-in-view-frustum? s4-4) (< f30-2 307200.0)) (< f30-2 61440.0))
                  (set-time! (-> self last-seen-times gp-2))
                  )
              (if (and (time-elapsed? (-> self last-seen-times gp-2) (seconds 10))
                       (or (not (sphere-in-view-frustum? s4-4)) (< 409600.0 f30-2))
                       )
                  (send-event s5-2 'traffic-off-force)
                  )
              )
            )
          )
        )
      )
    )
  :code sleep-code
  )

(deftype flitter-point (process-hidden)
  ()
  )


(deftype board-score-hud (hud-goal)
  ()
  )


(defmethod draw ((this board-score-hud))
  (set-hud-piece-position! (the-as hud-sprite (-> this sprites)) 447 70)
  (format (clear (-> this strings 0 text)) "~D" (-> this values 0 current))
  (set-as-offset-from! (the-as hud-sprite (-> this strings 0 pos)) (the-as vector4w (-> this sprites)) 0 -8)
  (set-as-offset-from! (the-as hud-sprite (-> this strings 1 pos)) (the-as vector4w (-> this sprites)) 0 -40)
  ((method-of-type hud draw) this)
  0
  (none)
  )

(defmethod update-values! ((this board-score-hud))
  (set! (-> this values 0 target) (the int (-> *game-info* score)))
  ((method-of-type hud update-values!) this)
  0
  (none)
  )

(defmethod init-callback ((this board-score-hud))
  (set! (-> this gui-id)
        (add-process *gui-control* this (gui-channel hud-upper-right) (gui-action hidden) (-> this name) 81920.0 0)
        )
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this sprites 0 tid) (the-as texture-id (get-texture hud-scoreboard-01 level-default-minimap)))
  (set! (-> this sprites 0 scale-x) 1.2)
  (set! (-> this sprites 0 flags) (hud-sprite-flags hsf3))
  (alloc-string-if-needed this 0)
  (set! (-> this strings 0 scale) 0.5)
  (set! (-> this strings 0 flags) (font-flags kerning middle large))
  (set! (-> this strings 0 color) (font-color red))
  (alloc-string-if-needed this 1)
  (set! (-> this strings 1 scale) 0.75)
  (set! (-> this strings 1 flags) (font-flags kerning middle large))
  (set! (-> this strings 1 color) (font-color red))
  (let ((s5-0 format)
        (gp-1 (clear (-> this strings 1 text)))
        (s4-0 "~S")
        )
    (format (clear *temp-string*) (lookup-text! *common-text* (text-id text-0866) #f))
    (s5-0 gp-1 s4-0 *temp-string*)
    )
  0
  (none)
  )

(deftype task-manager-bbush-board (task-manager)
  ((score            float)
   (challenge-done   symbol)
   (hud-score        handle)
   (hud-goal         handle)
   (game-score       uint8)
   (new-high-score   symbol)
   (goal-cup         uint8)
   (last-cup         uint8)
   (roll-back-task?  symbol)
   )
  (:methods
    (task-manager-bbush-board-method-32 (_type_) none)
    (task-manager-bbush-board-method-33 (_type_) none)
    (task-manager-bbush-board-method-34 (_type_ float) none)
    )
  )


(defmethod task-manager-bbush-board-method-32 ((this task-manager-bbush-board))
  (set-setting! 'music 'cityjetb 0.0 0)
  (set-setting! 'city-sound '(citybb1) 0.0 2)
  0
  (none)
  )

(defmethod set-time-limit ((this task-manager-bbush-board))
  (let ((t9-0 (method-of-type task-manager set-time-limit)))
    (t9-0 this)
    )
  (set-setting! 'airlock #f 0.0 0)
  (set! (-> this game-score) (the-as uint 10))
  (set! (-> this hud-score) (the-as handle #f))
  (set! (-> this hud-goal) (the-as handle #f))
  (if (= (-> this hud-score) #f)
      (set! (-> this hud-score)
            (ppointer->handle (process-spawn board-score-hud :init hud-init-by-other :name "board-score-hud" :to this))
            )
      )
  (if (= (-> this hud-goal) #f)
      (set! (-> this hud-goal)
            (ppointer->handle (process-spawn hud-goal :init hud-init-by-other :name "hud-goal" :to this))
            )
      )
  (set! (-> this roll-back-task?) #f)
  (task-manager-bbush-board-method-32 this)
  (none)
  )

(defmethod task-manager-bbush-board-method-33 ((this task-manager-bbush-board))
  (when (< (-> *game-info* goal) (-> this score))
    (set! (-> this new-high-score) #t)
    (when (>= (the-as uint 3) (-> this goal-cup))
      (sound-play "special-pickup")
      (+! (-> this goal-cup) 1)
      )
    )
  (set! (-> *game-info* goal)
        (game-info-method-31 *game-info* (the-as int (-> this game-score)) (the-as int (-> this goal-cup)))
        )
  (let ((v1-14 (handle->process (-> this hud-goal))))
    (when v1-14
      (let ((s5-1 format)
            (s4-1 (clear (-> (the-as hud v1-14) strings 1 text)))
            (s3-0 "~S")
            )
        (let* ((s2-0 format)
               (s1-0 (clear *temp-string*))
               (a0-13 *common-text*)
               (t9-5 (method-of-object a0-13 lookup-text!))
               (v1-17 (-> this goal-cup))
               )
          (s2-0 s1-0 (t9-5
                       a0-13
                       (cond
                         ((= v1-17 1)
                          (text-id text-0139)
                          )
                         ((= v1-17 2)
                          (text-id text-0138)
                          )
                         ((= v1-17 3)
                          (text-id text-0137)
                          )
                         (else
                           (text-id text-0136)
                           )
                         )
                       #f
                       )
                )
          )
        (s5-1 s4-1 s3-0 *temp-string*)
        )
      )
    )
  0
  (none)
  )

(defmethod task-manager-bbush-board-method-34 ((this task-manager-bbush-board) (arg0 float))
  (set! (-> this roll-back-task?) #t)
  (let* ((s2-0 (-> this game-score))
         (s4-0 (game-info-method-29 *game-info* (the-as int s2-0)))
         (t0-0 (get-highscore-rank *game-info* (the-as int s2-0) arg0))
         (s3-1 (max 0 (- t0-0 s4-0)))
         )
    (let ((t9-2 format)
          (a0-3 #t)
          (a1-3 "report-score ~s ~f my-cup ~d prev-cup ~d eggs ~d~%")
          (v1-4 s2-0)
          )
      (t9-2
        a0-3
        a1-3
        (cond
          ((= v1-4 7)
           "snake-total-jump-distance"
           )
          ((= v1-4 5)
           "snake-total-air-time"
           )
          ((= v1-4 10)
           "hoverboard"
           )
          ((= v1-4 12)
           "gungame-2"
           )
          ((= v1-4 17)
           "arena-training"
           )
          ((= v1-4 8)
           "snake-roll-count"
           )
          ((= v1-4 14)
           "gungame-4"
           )
          ((= v1-4 6)
           "snake-jump-distance"
           )
          ((= v1-4 13)
           "gungame-3"
           )
          ((= v1-4 4)
           "snake-air-time"
           )
          ((= v1-4 9)
           "wascity-gungame-1"
           )
          ((zero? v1-4)
           "none"
           )
          ((= v1-4 15)
           "power-game"
           )
          ((= v1-4 3)
           "snake-race"
           )
          ((= v1-4 1)
           "neo-sat-game"
           )
          ((= v1-4 16)
           "destroy-interceptors"
           )
          ((= v1-4 11)
           "gungame-1"
           )
          ((= v1-4 2)
           "turtle-race"
           )
          (else
            "*unknown*"
            )
          )
        arg0
        t0-0
        s4-0
        s3-1
        )
      )
    (game-info-method-27 *game-info* (the-as game-score s2-0) arg0)
    (let ((v1-7 (new 'static 'fact-info))
          (f30-0 (* (the float s3-1) (the float (-> this info user-count))))
          )
      (set! (-> v1-7 options) (actor-option))
      (logior! (-> v1-7 options) (actor-option suck-in))
      (cond
        ((< (the-as uint s4-0) (the-as uint 3))
         (cond
           ((zero? s3-1)
            (send-event this 'fail)
            )
           (else
             (give *game-info* 'skill f30-0 (the-as handle #f))
             (until (time-elapsed? (-> this state-time) (the int (* 45.0 f30-0)))
               (suspend)
               )
             )
           )
         )
        (else
          (let ((f0-5 (game-info-method-31 *game-info* (the-as int (-> this game-score)) (the-as int (-> this goal-cup)))))
            (if (< arg0 f0-5)
                (send-event this 'fail)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate active (task-manager-bbush-board)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trick-judge)
       (set! (-> self score) (the-as float (-> block param 1)))
       (let ((v0-0 (the-as object #t)))
         (set! (-> self challenge-done) (the-as symbol v0-0))
         v0-0
         )
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :code (behavior ()
    (until #f
      (set! (-> self score) 0.0)
      (set! (-> self challenge-done) #f)
      (send-event *target* 'get-notify self)
      (let ((gp-1 (ppointer->handle (judge-spawn self (target-pos 0) (the-as uint 0) #t))))
        (suspend)
        (while (send-event (handle->process (the-as handle gp-1)) 'waiting)
          (suspend)
          )
        (set! (-> self last-cup) (the-as uint (game-info-method-29 *game-info* (the-as int (-> self game-score)))))
        (format #t "last-cup: ~d~%" (-> self last-cup))
        (set! (-> self goal-cup) (+ (-> self last-cup) 1))
        (suspend)
        (while (send-event (handle->process (the-as handle gp-1)) 'judging)
          (set! (-> self score) (-> *game-info* score))
          (task-manager-bbush-board-method-33 self)
          (suspend)
          )
        )
      (send-event (handle->process (-> self hud-score)) 'hide-and-die)
      (send-event (handle->process (-> self hud-goal)) 'hide-and-die)
      (task-manager-bbush-board-method-34 self (-> self score))
      (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
        (let ((v1-41 (process->ppointer self)))
          (set! (-> a1-9 from) v1-41)
          )
        (set! (-> a1-9 num-params) 0)
        (set! (-> a1-9 message) 'complete)
        (send-event-function self a1-9)
        )
      )
    #f
    )
  )

(defstate resolution (task-manager-bbush-board)
  :virtual #t
  :event task-manager-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :code (behavior ()
    (local-vars (v1-31 object))
    (when (logtest? (-> self info mask) (task-manager-mask resolution-scene))
      (let ((gp-1 (ppointer->handle (process-spawn
                                      scene-player
                                      :init scene-player-init
                                      (-> self info resolution-scene)
                                      #t
                                      (-> self info resolution-scene-continue)
                                      :name "scene-player"
                                      )
                                    )
                  )
            )
        (while (handle->process (the-as handle gp-1))
          (suspend)
          )
        )
      )
    (task-manager-method-27 self)
    (let ((gp-2 (-> self info on-complete)))
      (if gp-2
          (script-eval gp-2)
          )
      )
    (cond
      ((-> self roll-back-task?)
       (let ((a0-13 (-> self node-info parent-node 0)))
         (task-node-open! a0-13 'event)
         )
       )
      (else
        (task-node-close! (-> self info final-node) 'event)
        )
      )
    (remove-setting! 'allow-progress)
    (while (begin
             (set! v1-31 (or (handle->process (-> self arrow)) (begin
                                                                 (countdown (v1-32 4)
                                                                   (when (handle->process (-> self hud v1-32))
                                                                     (set! v1-31 #t)
                                                                     (goto cfg-42)
                                                                     )
                                                                   )
                                                                 #f
                                                                 )
                             )
                   )
             (label cfg-42)
             v1-31
             )
      (suspend)
      )
    )
  )

(defpartgroup group-mh-tower-smoke-cty
  :id 297
  :flags (sp0 sp4 sp11)
  :bounds (static-bspherem 0 0 0 1000)
  :parts ((sp-item 1286 :fade-after (meters 10000) :falloff-to (meters 10000) :flags (sp7)))
  )

(defpart 1286
  :init-specs ((:texture (topglow level-default-sprite))
    (:num 0.001 0.05)
    (:x (meters -10) (meters 20))
    (:y (meters -30))
    (:z (meters -10) (meters 20))
    (:scale-x (meters 40) (meters 10))
    (:rot-z (degrees 160) (degrees 40))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 100.0)
    (:b 10.0)
    (:a 0.0)
    (:vel-y (meters 0.1))
    (:scalevel-x (meters 0.006666667) (meters 0.033333335))
    (:rotvel-z (degrees -0.033333335) (degrees 0.06666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.13333334 0.26666668)
    (:accel-x (meters 0.00016666666))
    (:friction 0.997)
    (:timer (seconds 166.67))
    (:flags (sp-cpuinfo-flag-2 launch-along-z))
    (:next-time (seconds 1))
    (:next-launcher 1287)
    (:rotate-y (degrees 0))
    )
  )

(defpart 1287
  :init-specs ((:scalevel-x (meters 0.026666667) (meters 0.013333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.0)
    (:next-time (seconds 2))
    (:next-launcher 1288)
    )
  )

(defpart 1288
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.01))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.14222223)
    (:fade-g 0.031111112)
    (:fade-b 0.13111112)
    (:next-time (seconds 2))
    (:next-launcher 1289)
    )
  )

(defpart 1289
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -0.006 -0.0024))
  )

(deftype mh-tower-smoke-cty (process-drawable)
  ()
  (:state-methods
    idle
    die
    )
  )


(defmethod deactivate ((this mh-tower-smoke-cty))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this part))
      (kill-particles (-> this part))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defstate idle (mh-tower-smoke-cty)
  :virtual #t
  :code sleep-code
  :post (behavior ()
    (spawn (-> self part) (-> self root trans))
    )
  )

(defstate die (mh-tower-smoke-cty)
  :virtual #t
  :code (behavior ()
    '()
    )
  )

(defmethod run-logic? ((this mh-tower-smoke-cty))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defmethod init-from-entity! ((this mh-tower-smoke-cty) (arg0 entity-actor))
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 297) this))
  (cond
    ((not (task-node-closed? (game-task-node tower-destroy-resolution)))
     (cleanup-for-death this)
     (go (method-of-object this die))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  )
