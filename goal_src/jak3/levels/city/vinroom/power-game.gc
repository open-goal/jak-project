;;-*-Lisp-*-
(in-package goal)

;; name: power-game.gc
;; name in dgo: power-game
;; dgos: VIN

(declare-type power-game-player process-focusable)

;; DECOMP BEGINS

(defpartgroup group-switcher-charge
  :id 907
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 100)
  :parts ((sp-item 3231 :flags (sp3 sp7)))
  )

(defpart 3231
  :init-specs ((:texture (glow-hotdot level-default-sprite))
    (:num 100.0)
    (:z (meters 20))
    (:scale-x (meters 0.5))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:omega (degrees 0.45))
    (:accel-z (meters -0.002))
    (:friction 0.92)
    (:timer (seconds 2.835))
    (:flags (sp-cpuinfo-flag-3))
    (:func 'sparticle-motion-blur)
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpartgroup group-switcher-die
  :id 908
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 100)
  :parts ((sp-item 3232 :flags (sp7) :period (seconds 20) :length (seconds 0.335))
    (sp-item 3233 :flags (sp7) :period (seconds 20) :length (seconds 0.335))
    )
  )

(defpart 3232
  :init-specs ((:texture (common-white common))
    (:num 0.5)
    (:scale-x (meters 2))
    (:scale-y (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 128.0)
    (:vel-z (meters 0.33333334))
    (:scalevel-x (meters 0.1))
    (:scalevel-y (meters 0.0016666667))
    (:fade-g -1.275)
    (:fade-b -2.55)
    (:fade-a -0.64)
    (:friction 0.97)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2))
    (:rotate-y (degrees 0))
    )
  )

(defpart 3233
  :init-specs ((:texture (common-white common))
    (:num 0.5)
    (:scale-x (meters 2))
    (:scale-y (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 128.0)
    (:vel-z (meters -0.33333334))
    (:scalevel-x (meters 0.1))
    (:scalevel-y (meters 0.0016666667))
    (:fade-g -1.275)
    (:fade-b -2.55)
    (:fade-a -0.64)
    (:friction 0.97)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2))
    (:rotate-y (degrees 0))
    )
  )

(defpartgroup group-glyph-charge
  :id 909
  :duration (seconds 218.45)
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 100)
  :parts ((sp-item 3234 :flags (sp7)))
  )

(defpart 3234
  :init-specs ((:texture (starflash level-default-sprite))
    (:num 0.2)
    (:scale-x (meters 1))
    (:rot-x (degrees 45))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0)
    (:g 80.0)
    (:b 128.0)
    (:a 0.0)
    (:omega (degrees 9011.25))
    (:scalevel-x (meters 0.1) (meters 0.1))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 1.0)
    (:timer (seconds 0.667))
    (:flags (sp-cpuinfo-flag-3 glow))
    (:userdata 4096.0)
    (:next-time (seconds 0.335))
    (:next-launcher 3235)
    )
  )

(defpart 3235
  :init-specs ((:fade-a -2.0))
  )

(defpartgroup group-glyph-die
  :id 910
  :linger-duration (seconds 10)
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 100)
  :parts ((sp-item 3236 :flags (is-3d sp7) :period (seconds 20) :length (seconds 1)))
  )

(defpart 3236
  :init-specs ((:texture (ring level-default-sprite))
    (:num 0.25)
    (:y (meters 1))
    (:scale-x (meters 1))
    (:rot-x (degrees 90))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 0.0)
    (:b 0.0)
    (:a 128.0)
    (:scalevel-x (meters 0.33333334))
    (:scalevel-y :copy scalevel-x)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-3))
    (:next-time (seconds 0.035))
    (:next-launcher 3237)
    (:rotate-y (degrees 0))
    )
  )

(defpart 3237
  :init-specs ((:r 0.0 4.0 64.0) (:g 0.0 4.0 64.0) (:b 0.0 4.0 64.0) (:next-time (seconds 0.035)) (:next-launcher 3237))
  )

(defpartgroup group-player-die
  :id 911
  :linger-duration (seconds 10)
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 100)
  :parts ((sp-item 3238 :flags (sp3 sp7)) (sp-item 3239 :flags (sp3 sp6 sp7)))
  )

(defpart 3238
  :init-specs ((:texture (starflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 100))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:fade-a -6.375)
    (:timer (seconds 0.135))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    )
  )

(defpart 3239
  :init-specs ((:texture (middot level-default-sprite))
    (:num 300.0)
    (:scale-x (meters 0.8))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:vel-z (meters 0.16666667) (meters 0.12207031))
    (:fade-a -0.21333334)
    (:friction 0.93)
    (:timer (seconds 2))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085))
    (:next-launcher 3240)
    (:conerot-x (degrees -360) (degrees 720))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 3240
  :init-specs ((:r 0.0 2.0 128.0)
    (:g 0.0 2.0 128.0)
    (:b 0.0 2.0 128.0)
    (:friction 0.95)
    (:next-time (seconds 0.035))
    (:next-launcher 3240)
    )
  )

(defpart 3241
  :init-specs ((:texture (time-bubble-orbiter powergd-sprite))
    (:num 1.0)
    (:y (meters 1))
    (:scale-x (meters 1.5))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 200.0)
    (:b 0.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

(defpartgroup group-power-scoreboard-points
  :id 912
  :duration (seconds 0.017)
  :linger-duration (seconds 2)
  :flags (sp0)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 3242 :flags (is-3d sp7))
    (sp-item 3243 :flags (is-3d sp7))
    (sp-item 3244 :flags (is-3d sp7))
    (sp-item 3245 :flags (is-3d sp7))
    (sp-item 3246 :flags (is-3d sp3 sp6 sp7) :period (seconds 0.267) :length (seconds 0.03))
    (sp-item 3247 :flags (sp6))
    )
  )

(defun birth-func-power-score ((arg0 sparticle-system)
                      (arg1 sparticle-cpuinfo)
                      (arg2 sprite-vec-data-3d)
                      (arg3 sparticle-launcher)
                      (arg4 sparticle-launch-state)
                      )
  (let ((v1-0 (the-as object (-> arg1 user-float))))
    (when (nonzero? (the-as float v1-0))
      (+ (-> (the-as (pointer int32) v1-0) 0) -3)
      (let* ((a0-4 (-> (the-as (pointer int32) v1-0) 3))
             (v1-2 (-> (the-as (pointer int32) (+ (* (+ (mod
                                                          (the int (/ (-> *game-info* score) (cond
                                                                                               ((= a0-4 1)
                                                                                                10.0
                                                                                                )
                                                                                               ((= a0-4 2)
                                                                                                100.0
                                                                                                )
                                                                                               ((= a0-4 3)
                                                                                                1000.0
                                                                                                )
                                                                                               (else
                                                                                                 1.0
                                                                                                 )
                                                                                               )
                                                                      )
                                                               )
                                                          10
                                                          )
                                                        3
                                                        )
                                                     4
                                                     )
                                                  (the-as int v1-0)
                                                  )
                               )
                       3
                       )
                   )
             )
        (if (nonzero? v1-2)
            (particle-adgif-callback (-> arg1 adgif) (the-as texture-id v1-2))
            )
        )
      )
    )
  0
  (none)
  )

(defpart 3242
  :init-specs ((:texture (whack-scoreboard-0 powergd-sprite))
    (:birth-func 'birth-func-power-score)
    (:num 1.0)
    (:x (meters -5))
    (:z (meters 0.01))
    (:scale-x (meters 3))
    (:rot-x (degrees 60))
    (:rot-y (degrees 0))
    (:scale-y (meters 5))
    (:r 64.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata :data (new 'static 'boxed-array :type int32
                       3
                       0
                       0
                       -959447040
                       -959446784
                       -959446528
                       -959446272
                       -959446016
                       -959445760
                       -959445504
                       -959445248
                       -959444992
                       -959444736
                       )
               )
    (:rotate-y (degrees 0))
    )
  )

(defpart 3243
  :init-specs ((:texture (whack-scoreboard-0 powergd-sprite))
    (:birth-func 'birth-func-power-score)
    (:num 1.0)
    (:x (meters -1.7))
    (:z (meters 0.01))
    (:scale-x (meters 3))
    (:rot-x (degrees 60))
    (:rot-y (degrees 0))
    (:scale-y (meters 5))
    (:r 64.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata :data (new 'static 'boxed-array :type int32
                       2
                       0
                       0
                       -959447040
                       -959446784
                       -959446528
                       -959446272
                       -959446016
                       -959445760
                       -959445504
                       -959445248
                       -959444992
                       -959444736
                       )
               )
    (:rotate-y (degrees 0))
    )
  )

(defpart 3244
  :init-specs ((:texture (whack-scoreboard-0 powergd-sprite))
    (:birth-func 'birth-func-power-score)
    (:num 1.0)
    (:x (meters 1.7))
    (:z (meters 0.01))
    (:scale-x (meters 3))
    (:rot-x (degrees 60))
    (:rot-y (degrees 0))
    (:scale-y (meters 5))
    (:r 64.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata :data (new 'static 'boxed-array :type int32
                       1
                       0
                       0
                       -959447040
                       -959446784
                       -959446528
                       -959446272
                       -959446016
                       -959445760
                       -959445504
                       -959445248
                       -959444992
                       -959444736
                       )
               )
    (:rotate-y (degrees 0))
    )
  )

(defpart 3245
  :init-specs ((:texture (whack-scoreboard-0 powergd-sprite))
    (:birth-func 'birth-func-power-score)
    (:num 1.0)
    (:x (meters 5))
    (:z (meters 0.01))
    (:scale-x (meters 3))
    (:rot-x (degrees 60))
    (:rot-y (degrees 0))
    (:scale-y (meters 5))
    (:r 64.0)
    (:g 255.0)
    (:b 255.0)
    (:a 255.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata :data (new 'static 'boxed-array :type int32
                       0
                       0
                       0
                       -959447040
                       -959446784
                       -959446528
                       -959446272
                       -959446016
                       -959445760
                       -959445504
                       -959445248
                       -959444992
                       -959444736
                       )
               )
    (:rotate-y (degrees 0))
    )
  )

(deftype power-game-cell (structure)
  ((up     uint8)
   (right  uint8)
   (down   uint8)
   (left   uint8)
   )
  :pack-me
  )


(define *power-game-track* (new 'static 'inline-array power-game-cell 256
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :left #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :right #x1)
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :left #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :left #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :right #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1 :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1 :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :right #x1 :down #x1 :left #x1)
                             (new 'static 'power-game-cell :left #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :left #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :right #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell :left #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :right #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :left #x1)
                             (new 'static 'power-game-cell :down #x1 :left #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :down #x1)
                             (new 'static 'power-game-cell :up #x1 :down #x1)
                             (new 'static 'power-game-cell :right #x1 :down #x1)
                             (new 'static 'power-game-cell)
                             )
        )

(deftype power-game-cam-info (structure)
  ((cam-pos            vector  :inline)
   (cam-pos-x-angle    degrees)
   (cam-dist           meters)
   (cam-x-angle        degrees)
   (cam-y-angle        degrees)
   (cam-y-angle-dest   degrees)
   (cam-y-angle-speed  degrees)
   )
  )


(deftype power-game (process-drawable)
  ((self             power-game               :override)
   (root             collide-shape-moving     :override)
   (task             game-task-control)
   (lentity          entity-actor)
   (hud-score        handle)
   (hud-goal         handle)
   (base-score       float)
   (score            float)
   (score-time       time-frame)
   (score-met        symbol)
   (game             (inline-array power-game-cell))
   (blockers         (array uint8))
   (dots             (array uint8))
   (miss-max         int32)
   (miss-count       int32)
   (miss-time        time-frame)
   (point-win        float)
   (game-start-time  time-frame)
   (wave-start-time  time-frame)
   (wave-index       int32)
   (difficulty       int32)
   (speech-time      time-frame)
   (speech-count     int32)
   (speech-last      int32                     8)
   (spawn-time       time-frame)
   (center           vector                    :inline)
   (corner           vector                    2 :inline)
   (cam-targ         power-game-cam-info       :inline)
   (cam-cur          power-game-cam-info       :inline)
   (player           handle)
   (chaser           handle)
   (zapper           handle                    5)
   (switcher         handle)
   (switcher-time    time-frame)
   (glyph            handle)
   (score-part       sparticle-launch-control  1)
   )
  (:state-methods
    idle
    hide
    wait-for-start
    (active symbol)
    (lose symbol)
    (win symbol)
    )
  (:methods
    (power-game-active-post (_type_) none)
    (update-score-and-give-orbs (_type_) none)
    (spawn-switcher (_type_) none)
    (update-score-text (_type_) none)
    (update-cam (_type_) none)
    (get-center-pos! (_type_ vector float float) vector)
    (power-game-method-32 (_type_ float float) int)
    (power-game-method-33 (_type_ float float int) uint)
    (power-game-method-34 (_type_ float float) int)
    (power-game-method-35 (_type_ float float int) int)
    (power-game-method-36 (_type_ float float int float float) float)
    (power-game-method-37 (_type_ float float int) float)
    (power-game-method-38 (_type_ vector int) vector)
    (power-game-method-39 (_type_ int) int)
    (power-game-method-40 (_type_ int) symbol)
    (power-game-method-41 (_type_ vector) power-game-cell)
    (power-game-method-42 (_type_ vector int int) symbol)
    (power-game-method-43 (_type_ int) rgba)
    (power-game-method-44 (_type_ float float int int) none)
    (set-last-speech (_type_ int int) int)
    )
  )


(define-perm *power-game* (pointer power-game) #f)

(define *power-game-speech-list* (new 'static 'inline-array talker-speech-class 50
                                   (new 'static 'talker-speech-class :name "none")
                                   (new 'static 'talker-speech-class
                                     :name "powgame1"
                                     :channel (gui-channel message)
                                     :speech #x1
                                     :text-duration (seconds 5)
                                     :neg #x1
                                     :text-message (text-id text-07b9)
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax766"
                                     :channel (gui-channel daxter)
                                     :flags (talker-flags tf0)
                                     :speech #x2
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax767"
                                     :channel (gui-channel daxter)
                                     :flags (talker-flags tf0)
                                     :speech #x3
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax775"
                                     :channel (gui-channel daxter)
                                     :speech #x4
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax776"
                                     :channel (gui-channel daxter)
                                     :speech #x5
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax768"
                                     :channel (gui-channel daxter)
                                     :speech #x6
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax769"
                                     :channel (gui-channel daxter)
                                     :speech #x7
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax770"
                                     :channel (gui-channel daxter)
                                     :speech #x8
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax771"
                                     :channel (gui-channel daxter)
                                     :speech #x9
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax772"
                                     :channel (gui-channel daxter)
                                     :speech #xa
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax773"
                                     :channel (gui-channel daxter)
                                     :speech #xb
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin117"
                                     :channel (gui-channel daxter)
                                     :speech #xc
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin137"
                                     :channel (gui-channel daxter)
                                     :speech #xd
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin103"
                                     :channel (gui-channel daxter)
                                     :speech #xe
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin104"
                                     :channel (gui-channel daxter)
                                     :speech #xf
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin105"
                                     :channel (gui-channel daxter)
                                     :speech #x10
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin106"
                                     :channel (gui-channel daxter)
                                     :speech #x11
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin116"
                                     :channel (gui-channel daxter)
                                     :speech #x12
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin129"
                                     :channel (gui-channel daxter)
                                     :speech #x13
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin130"
                                     :channel (gui-channel daxter)
                                     :speech #x14
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin107"
                                     :channel (gui-channel daxter)
                                     :speech #x15
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin108"
                                     :channel (gui-channel daxter)
                                     :speech #x16
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin135"
                                     :channel (gui-channel daxter)
                                     :speech #x17
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin101"
                                     :channel (gui-channel daxter)
                                     :speech #x18
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin124"
                                     :channel (gui-channel daxter)
                                     :speech #x19
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin125"
                                     :channel (gui-channel daxter)
                                     :speech #x1a
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin126"
                                     :channel (gui-channel daxter)
                                     :speech #x1b
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin127"
                                     :channel (gui-channel daxter)
                                     :speech #x1c
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin128"
                                     :channel (gui-channel daxter)
                                     :speech #x1d
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin109"
                                     :channel (gui-channel daxter)
                                     :speech #x1e
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin110"
                                     :channel (gui-channel daxter)
                                     :speech #x1f
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin111"
                                     :channel (gui-channel daxter)
                                     :speech #x20
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin112"
                                     :channel (gui-channel daxter)
                                     :speech #x21
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin113"
                                     :channel (gui-channel daxter)
                                     :speech #x22
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin115"
                                     :channel (gui-channel daxter)
                                     :speech #x23
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin118"
                                     :channel (gui-channel daxter)
                                     :speech #x24
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin119"
                                     :channel (gui-channel daxter)
                                     :speech #x25
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin120"
                                     :channel (gui-channel daxter)
                                     :speech #x26
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin121"
                                     :channel (gui-channel daxter)
                                     :speech #x27
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin122"
                                     :channel (gui-channel daxter)
                                     :speech #x28
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin123"
                                     :channel (gui-channel daxter)
                                     :speech #x29
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin134"
                                     :channel (gui-channel daxter)
                                     :speech #x2a
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin131"
                                     :channel (gui-channel daxter)
                                     :speech #x2b
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin132"
                                     :channel (gui-channel daxter)
                                     :speech #x2c
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin133"
                                     :channel (gui-channel daxter)
                                     :speech #x2d
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin136"
                                     :channel (gui-channel daxter)
                                     :speech #x2e
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin140"
                                     :channel (gui-channel daxter)
                                     :speech #x2f
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin141"
                                     :channel (gui-channel daxter)
                                     :speech #x30
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "vin139"
                                     :channel (gui-channel daxter)
                                     :speech #x31
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   )
        )

(defmethod init-from-entity! ((this power-game) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle obstacle-for-jak))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid no-standon))
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sidekick" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> this hud-score) (the-as handle #f))
  (set! (-> this hud-goal) (the-as handle #f))
  (set! (-> this player) (the-as handle #f))
  (set! (-> this chaser) (the-as handle #f))
  (dotimes (v1-16 5)
    (set! (-> this zapper v1-16) (the-as handle #f))
    )
  (set! (-> this switcher) (the-as handle #f))
  (set! (-> this glyph) (the-as handle #f))
  (set! (-> *game-info* goal) 252.0)
  (dotimes (v1-21 4)
    (set! (-> this speech-last v1-21) 0)
    )
  (set! (-> this task)
        (new 'process 'game-task-control (res-lump-value arg0 'task-actor game-task-actor :time -1000000000.0))
        )
  (set! (-> this game) *power-game-track*)
  (set! (-> this blockers) (new 'process 'boxed-array uint8 2))
  (set! (-> this dots) (new 'process 'boxed-array uint8 255))
  (set-vector! (-> this center) 4587520.0 -819200.0 4587520.0 1.0)
  (set! (-> this miss-max) 5)
  (set! (-> this point-win) 252.0)
  (set! (-> *game-info* score) 0.0)
  (set! (-> *game-info* goal) (-> this point-win))
  (set! (-> *game-info* miss) 0.0)
  (set! (-> *game-info* miss-max) (the float (-> this miss-max)))
  (set! (-> this score-met) #f)
  (set! (-> this score-part 0) (create-launch-control (-> *part-group-id-table* 912) this))
  (let ((v1-41 (-> this root root-prim)))
    (set! (-> v1-41 prim-core collide-as) (collide-spec))
    (set! (-> v1-41 prim-core collide-with) (collide-spec))
    )
  0
  (set! *power-game* (the-as (pointer power-game) (process->ppointer this)))
  (go (method-of-object this hide))
  )

;; WARN: Return type mismatch process-drawable vs power-game.
(defmethod relocate ((this power-game) (offset int))
  (if (nonzero? (-> this task))
      (&+! (-> this task) offset)
      )
  (if (nonzero? (-> this blockers))
      (&+! (-> this blockers) offset)
      )
  (if (nonzero? (-> this dots))
      (&+! (-> this dots) offset)
      )
  (dotimes (v1-12 1)
    (if (nonzero? (-> this score-part v1-12))
        (&+! (-> this score-part v1-12) offset)
        )
    )
  (the-as power-game ((method-of-type process-drawable relocate) this offset))
  )

(defmethod deactivate ((this power-game))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (dotimes (s5-0 1)
    (if (nonzero? (-> this score-part s5-0))
        (kill-particles (-> this score-part s5-0))
        )
    )
  (set! *power-game* (the-as (pointer power-game) #f))
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

(defmethod set-last-speech ((this power-game) (arg0 int) (arg1 int))
  (let ((v0-1 (mod (+ (-> this speech-last arg0) (rand-vu-int-range 1 2)) arg1)))
    (set! (-> this speech-last arg0) v0-1)
    v0-1
    )
  )

(defmethod power-game-method-32 ((this power-game) (arg0 float) (arg1 float))
  (min (min (min (the int arg0) (the int arg1)) (- 14 (the int arg1))) (- 16 (the int arg0)))
  )

(defmethod get-center-pos! ((this power-game) (arg0 vector) (arg1 float) (arg2 float))
  (set! (-> arg0 quad) (-> this corner 0 quad))
  (+! (-> arg0 x) (* 16384.0 arg1))
  (+! (-> arg0 z) (* 16384.0 arg2))
  arg0
  )

(defmethod power-game-method-33 ((this power-game) (arg0 float) (arg1 float) (arg2 int))
  (let ((v1-1 (the int (fmax 0.0 (fmin 16.0 arg0))))
        (a1-2 (the int (fmax 0.0 (fmin 14.0 arg1))))
        )
    (if (>= arg2 0)
        (set! (-> this dots (+ v1-1 (* 17 a1-2))) (the-as uint arg2))
        )
    (-> this dots (+ v1-1 (* 17 a1-2)))
    )
  )

(defmethod power-game-method-34 ((this power-game) (arg0 float) (arg1 float))
  (cond
    ((>= 7.0 arg1)
     (cond
       ((< arg0 arg1)
        3
        )
       ((< (- 16.0 arg0) arg1)
        1
        )
       (else
         0
         )
       )
     )
    ((< arg1 (- 14.0 arg0))
     3
     )
    ((< arg1 (+ -2.0 arg0))
     1
     )
    (else
      2
      )
    )
  )

(defmethod power-game-method-35 ((this power-game) (arg0 float) (arg1 float) (arg2 int))
  (let ((v1-1 (power-game-method-34 this arg0 arg1)))
    (cond
      ((or (zero? v1-1) (= v1-1 1))
       (if (or (= arg2 1) (= arg2 2))
           1
           -1
           )
       )
      (else
        (let ((v1-5 arg2))
          (if (or (zero? v1-5) (= v1-5 3))
              1
              -1
              )
          )
        )
      )
    )
  )

(defmethod power-game-method-36 ((this power-game) (arg0 float) (arg1 float) (arg2 int) (arg3 float) (arg4 float))
  (local-vars (v1-33 symbol))
  (the int arg0)
  (the int arg1)
  (let ((s4-0 (the int arg3))
        (s3-0 (the int arg4))
        (s2-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s2-0 x) (the float (the int arg0)))
    (set! (-> s2-0 y) 0.0)
    (set! (-> s2-0 z) (the float (the int arg1)))
    (set! (-> s2-0 w) 1.0)
    (let ((f30-0 0.0))
      (until v1-33
        (cond
          ((power-game-method-42 this s2-0 arg2 arg2)
           (vector+! s2-0 s2-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
           (set! f30-0 (+ 1.0 f30-0))
           )
          ((power-game-method-42 this s2-0 arg2 (logand (+ arg2 1) 3))
           (set! arg2 (logand (+ arg2 1) 3))
           (vector+! s2-0 s2-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
           (set! f30-0 (+ 1.0 f30-0))
           )
          ((power-game-method-42 this s2-0 arg2 (logand (+ arg2 3) 3))
           (set! arg2 (logand (+ arg2 3) 3))
           (vector+! s2-0 s2-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
           (set! f30-0 (+ 1.0 f30-0))
           )
          )
        (set! v1-33 (or (and (= (the int (-> s2-0 x)) s4-0) (= (the int (-> s2-0 z)) s3-0)) (>= f30-0 200.0)))
        )
      f30-0
      )
    )
  )

(defmethod power-game-method-37 ((this power-game) (arg0 float) (arg1 float) (arg2 int))
  (the int arg0)
  (the int arg1)
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (set! (-> s4-0 x) (the float (the int arg0)))
    (set! (-> s4-0 y) 0.0)
    (set! (-> s4-0 z) (the float (the int arg1)))
    (set! (-> s4-0 w) 1.0)
    (let ((f30-0 0.0))
      (while (and (power-game-method-42 this s4-0 arg2 arg2) (< f30-0 200.0))
        (vector+! s4-0 s4-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
        (set! f30-0 (+ 1.0 f30-0))
        )
      f30-0
      )
    )
  )

(defmethod power-game-method-38 ((this power-game) (arg0 vector) (arg1 int))
  (local-vars (v0-0 vector))
  (let ((v1-0 arg1))
    (cond
      ((zero? v1-0)
       (set! v0-0 arg0)
       (set! (-> v0-0 quad) (-> (new 'static 'vector :z -1.0 :w 1.0) quad))
       )
      ((= v1-0 1)
       (set! v0-0 arg0)
       (set! (-> v0-0 quad) (-> (new 'static 'vector :x 1.0 :w 1.0) quad))
       )
      ((= v1-0 2)
       (set! v0-0 arg0)
       (set! (-> v0-0 quad) (-> (new 'static 'vector :z 1.0 :w 1.0) quad))
       )
      (else
        (set! v0-0 arg0)
        (set! (-> v0-0 quad) (-> (new 'static 'vector :x -1.0 :w 1.0) quad))
        )
      )
    )
  v0-0
  )

(defmethod power-game-method-39 ((this power-game) (arg0 int))
  (let ((v1-0 arg0))
    (if (or (zero? v1-0) (= v1-0 2))
        2
        0
        )
    )
  )

(defmethod power-game-method-41 ((this power-game) (arg0 vector))
  (let ((v1-0 (the int (-> arg0 x)))
        (a1-1 (the int (-> arg0 z)))
        )
    (-> this game (+ (* 17 a1-1) v1-0))
    )
  )

(defmethod power-game-method-42 ((this power-game) (arg0 vector) (arg1 int) (arg2 int))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> arg0 quad))
    (let ((f0-0 0.0)
          (f1-0 16.0)
          (f2-0 (-> v1-0 x))
          )
      (set! (-> v1-0 x) (fmax f0-0 (fmin f1-0 (the float (the int (+ 0.5 f2-0))))))
      )
    (let ((f0-2 0.0)
          (f1-2 14.0)
          (f2-5 (-> v1-0 z))
          )
      (set! (-> v1-0 z) (fmax f0-2 (fmin f1-2 (the float (the int (+ 0.5 f2-5))))))
      )
    (let ((v1-1 (power-game-method-41 this v1-0)))
      (zero? (-> this blockers (-> (the-as (pointer uint8) (+ arg2 (the-as int v1-1))))))
      )
    )
  )

(defmethod power-game-method-40 ((this power-game) (arg0 int))
  (let ((s3-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (let ((s2-0 (new 'stack-no-clear 'matrix)))
      (set! (-> s3-0 x) (sin (-> *cpad-list* cpads 0 stick0-dir)))
      (set! (-> s3-0 y) 0.0)
      (set! (-> s3-0 z) (cos (-> *cpad-list* cpads 0 stick0-dir)))
      (set! (-> s3-0 w) 0.0)
      (let* ((s1-0 s2-0)
             (a2-0 (matrix-local->world #t #f))
             (v1-4 (-> a2-0 rvec quad))
             (a0-4 (-> a2-0 uvec quad))
             (a1-2 (-> a2-0 fvec quad))
             (a2-1 (-> a2-0 trans quad))
             )
        (set! (-> s1-0 rvec quad) v1-4)
        (set! (-> s1-0 uvec quad) a0-4)
        (set! (-> s1-0 fvec quad) a1-2)
        (set! (-> s1-0 trans quad) a2-1)
        )
      (vector-matrix*! s3-0 s3-0 s2-0)
      (warp-vector-into-surface! gp-0 s3-0 *up-vector* s2-0)
      )
    (vector-float*! gp-0 gp-0 (-> *cpad-list* cpads 0 stick0-speed))
    (let ((v1-8 (power-game-method-38 this (new 'stack-no-clear 'vector) arg0)))
      (< 0.5 (vector-dot gp-0 v1-8))
      )
    )
  )

;; WARN: Return type mismatch uint vs rgba.
(defmethod power-game-method-43 ((this power-game) (arg0 int))
  (let ((v1-0 arg0))
    (the-as rgba (cond
                   ((zero? v1-0)
                    (the-as uint #x8000ff00)
                    )
                   ((= v1-0 1)
                    (the-as uint #x800000ff)
                    )
                   (else
                     (the-as uint #x80ffffff)
                     )
                   )
            )
    )
  )

(defmethod update-score-and-give-orbs ((this power-game))
  (set! (-> this score) -3.0)
  (dotimes (v1-1 (-> this dots length))
    (if (zero? (-> this dots v1-1))
        (+! (-> this score) 1.0)
        )
    )
  (let ((f30-0 (+ (-> this base-score) (-> this score))))
    (cond
      ((>= (-> *game-info* score) f30-0)
       (set! (-> *game-info* score) f30-0)
       )
      ((and (< (-> *game-info* score) f30-0) (time-elapsed? (-> this score-time) (seconds 0.1)))
       (sound-play "point-increase")
       (seek! (-> *game-info* score) f30-0 1.0)
       (set-time! (-> this score-time))
       )
      )
    (cond
      ((not (task-node-closed? (game-task-node city-power-game-resolution)))
       )
      ((not (task-node-closed? (game-task-node city-power-game-bronze)))
       (when (>= f30-0 (game-info-method-31 *game-info* 15 1))
         (sound-play-by-spec (static-sound-spec "skill-pickup" :group 0 :fo-curve 1) (new-sound-id) (the-as vector #t))
         (script-eval '(birth-pickup ("power-game-player" "head") skill FACT_SUPER_SKILL_INC flags (suck-in)))
         (task-node-close! (game-task-node city-power-game-bronze) 'event)
         )
       )
      ((not (task-node-closed? (game-task-node city-power-game-silver)))
       (when (>= f30-0 (game-info-method-31 *game-info* 15 2))
         (sound-play-by-spec (static-sound-spec "skill-pickup" :group 0 :fo-curve 1) (new-sound-id) (the-as vector #t))
         (script-eval '(birth-pickup ("power-game-player" "head") skill FACT_SUPER_SKILL_INC flags (suck-in)))
         (task-node-close! (game-task-node city-power-game-silver) 'event)
         )
       )
      ((not (task-node-closed? (game-task-node city-power-game-gold)))
       (when (>= f30-0 (game-info-method-31 *game-info* 15 3))
         (sound-play-by-spec (static-sound-spec "skill-pickup" :group 0 :fo-curve 1) (new-sound-id) (the-as vector #t))
         (script-eval '(birth-pickup ("power-game-player" "head") skill FACT_SUPER_SKILL_INC flags (suck-in)))
         (task-node-close! (game-task-node city-power-game-gold) 'event)
         )
       )
      )
    )
  (when (and (!= (-> *game-info* miss) (the float (-> this miss-count)))
             (time-elapsed? (-> this miss-time) (seconds 0.25))
             )
    (sound-play "point-decrease")
    (seek! (-> *game-info* miss) (the float (-> this miss-count)) 1.0)
    (set-time! (-> this miss-time))
    )
  0
  (none)
  )

(defmethod power-game-method-44 ((this power-game) (arg0 float) (arg1 float) (arg2 int) (arg3 int))
  (local-vars (sv-128 int) (sv-144 vector))
  (the int arg0)
  (the int arg1)
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (set! (-> s3-0 x) (the float (the int arg0)))
    (set! (-> s3-0 y) 0.0)
    (set! (-> s3-0 z) (the float (the int arg1)))
    (set! (-> s3-0 w) 1.0)
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (set! (-> s2-0 x) (the float (the int arg0)))
      (set! (-> s2-0 y) 0.0)
      (set! (-> s2-0 z) (the float (the int arg1)))
      (set! (-> s2-0 w) 1.0)
      (while (> arg3 0)
        (cond
          ((power-game-method-42 this s3-0 arg2 arg2)
           (vector+! s3-0 s3-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
           )
          ((power-game-method-42 this s3-0 arg2 (logand (+ arg2 1) 3))
           (set! arg2 (logand (+ arg2 1) 3))
           (vector+! s3-0 s3-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
           )
          ((power-game-method-42 this s3-0 arg2 (logand (+ arg2 3) 3))
           (set! arg2 (logand (+ arg2 3) 3))
           (vector+! s3-0 s3-0 (power-game-method-38 this (new 'stack-no-clear 'vector) arg2))
           )
          )
        (let ((s1-3 add-debug-line)
              (s0-6 #t)
              )
          (set! sv-128 577)
          (set! sv-144 (get-center-pos! this (new 'stack-no-clear 'vector) (-> s2-0 x) (-> s2-0 z)))
          (let ((a3-6 (get-center-pos! this (new 'stack-no-clear 'vector) (-> s3-0 x) (-> s3-0 z)))
                (t0-1 (the-as uint #x800000ff))
                (t1-0 #f)
                (t2-0 -1)
                )
            (s1-3 s0-6 (the-as bucket-id sv-128) sv-144 a3-6 (the-as rgba t0-1) t1-0 (the-as rgba t2-0))
            )
          )
        (set! (-> s2-0 quad) (-> s3-0 quad))
        (+! arg3 -1)
        )
      )
    )
  0
  (none)
  )

(defmethod power-game-active-post ((this power-game))
  (set! (-> this game) *power-game-track*)
  (spawn-switcher this)
  (update-score-and-give-orbs this)
  (update-cam this)
  (update-score-text this)
  0
  (none)
  )

(defmethod update-cam ((this power-game))
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 power-game-cam-info))
  (let ((s4-0 (the-as power-game-player (handle->process (-> this player)))))
    (when s4-0
      (let ((s5-0 (get-trans s4-0 9))
            (s4-1 (the int (-> (get-trans s4-0 2) x)))
            )
        (set! sv-48 (vector-! (new 'stack-no-clear 'vector) s5-0 (new 'static 'vector :x 8.0 :z 7.0 :w 1.0)))
        (set! sv-52 (get-center-pos! this (new 'stack-no-clear 'vector) (-> s5-0 x) (-> s5-0 z)))
        (set! sv-56 (-> this cam-targ))
        (* 16384.0 (the float (logand (- 6 (power-game-method-34 this (-> s5-0 x) (-> s5-0 z))) 3)))
        (let ((f30-1 (if (cpad-hold? 0 x)
                         131072.0
                         65536.0
                         )
                     )
              )
          (power-game-method-32 this (-> s5-0 x) (-> s5-0 z))
          (power-game-method-35 this (-> s5-0 x) (-> s5-0 z) s4-1)
          (cond
            ((not (time-elapsed? (-> this game-start-time) (seconds 0.1)))
             (set! (-> sv-56 cam-pos quad) (-> sv-52 quad))
             )
            (else
              (if (< (fabs (-> sv-48 x)) 4.0)
                  (set! (-> sv-56 cam-pos x) (-> sv-52 x))
                  )
              (if (< -1.0 (-> sv-48 z))
                  (set! (-> sv-56 cam-pos z) (-> sv-52 z))
                  )
              )
            )
          (let ((f0-21 (fabs (deg-diff (-> sv-56 cam-y-angle-dest) (-> sv-56 cam-y-angle)))))
            (if (cpad-hold? 0 x)
                (set! (-> sv-56 cam-y-angle-speed) (fmax 12743.111 (fmin 65536.0 f0-21)))
                (set! (-> sv-56 cam-y-angle-speed) (fmax 12743.111 (fmin 32768.0 f0-21)))
                )
            )
          (set! (-> sv-56 cam-y-angle) (-> sv-56 cam-y-angle-dest))
          (set! (-> sv-56 cam-x-angle) (lerp-scale 13653.333 7281.778 (-> s5-0 z) 0.0 14.0))
          (set! (-> sv-56 cam-pos-x-angle) (lerp-scale 13653.333 10012.444 (-> s5-0 z) 0.0 14.0))
          (if (= (-> *setting-control* user-default aspect-ratio) 'aspect16x9)
              (set! (-> sv-56 cam-dist) (lerp-scale 266240.0 225280.0 (-> s5-0 z) 0.0 14.0))
              (set! (-> sv-56 cam-dist) (lerp-scale 204800.0 163840.0 (-> s5-0 z) 0.0 14.0))
              )
          (let ((s5-1 (-> this cam-cur)))
            (cond
              ((not (time-elapsed? (-> this game-start-time) (seconds 0.1)))
               (mem-copy! (the-as pointer (-> this cam-cur)) (the-as pointer sv-56) 40)
               )
              (else
                (seek! (-> s5-1 cam-pos x) (-> sv-56 cam-pos x) (* f30-1 (seconds-per-frame)))
                (seek! (-> s5-1 cam-pos z) (-> sv-56 cam-pos z) (* f30-1 (seconds-per-frame)))
                (seek! (-> s5-1 cam-y-angle) (-> sv-56 cam-y-angle) (* (-> sv-56 cam-y-angle-speed) (seconds-per-frame)))
                (seek! (-> s5-1 cam-x-angle) (-> sv-56 cam-x-angle) (* 1820.4445 (seconds-per-frame)))
                (seek! (-> s5-1 cam-pos-x-angle) (-> sv-56 cam-pos-x-angle) (* 1820.4445 (seconds-per-frame)))
                (seek! (-> s5-1 cam-dist) (-> sv-56 cam-dist) (* 40960.0 (seconds-per-frame)))
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod update-score-text ((this power-game))
  (if (and *cheat-mode* (-> this next-state) (= (-> this next-state name) 'active))
      (format *stdcon* "press L1 to fail, R1 to complete~%")
      )
  (let ((v1-7 (-> this center)))
    (vector+! (the-as vector (-> this corner)) v1-7 (new 'static 'vector :x -131072.0 :z -114688.0 :w 1.0))
    (vector+! (-> this corner 1) v1-7 (new 'static 'vector :x 131072.0 :z 114688.0 :w 1.0))
    )
  (dotimes (s5-0 17)
    (dotimes (s4-0 15)
      (let ((v1-9 (get-center-pos! this (new 'stack-no-clear 'vector) (the float s5-0) (the float s4-0))))
        (if (nonzero? (-> this dots (+ s5-0 (* 17 s4-0))))
            (launch-particles (-> *part-id-table* 3241) v1-9)
            )
        )
      )
    )
  (if (task-node-closed? (game-task-node city-power-game-resolution))
      (spawn
        (-> this score-part 0)
        (vector+! (new 'stack-no-clear 'vector) (-> this center) (new 'static 'vector :y 16384.0 :w 1.0))
        )
      )
  0
  (none)
  )

(deftype power-game-object (process-focusable)
  ((parent       (pointer power-game) :override)
   (local        vector                :inline)
   (dir          int8)
   (next-dir     int8)
   (slide-dir    int8)
   (speed        float)
   (slide-dist   int32)
   (slide-speed  float)
   (slide-count  int32)
   (slide-lock   symbol)
   (slide-dest   vector                :inline)
   (turn-pos     vector                :inline)
   (target       handle)
   (start-time   time-frame)
   )
  (:state-methods
    active
    die
    )
  (:methods
    (power-game-object-method-30 (_type_) none)
    (power-game-object-method-31 (_type_) none)
    )
  )


(defstate active (power-game-object)
  :virtual #t
  :code sleep-code
  )

(defstate die (power-game-object)
  :virtual #t
  :code sleep-code
  )

(defmethod get-trans ((this power-game-object) (arg0 int))
  "Get the `trans` for this process."
  (case arg0
    ((9)
     (-> this local)
     )
    ((2)
     (let ((v0-0 (new 'static 'vector)))
       (set! (-> v0-0 x) (the float (-> this dir)))
       (set! (-> v0-0 y) 0.0)
       (set! (-> v0-0 z) 0.0)
       (set! (-> v0-0 w) 1.0)
       v0-0
       )
     )
    (else
      (-> this root trans)
      )
    )
  )

(defmethod power-game-object-method-30 ((this power-game-object))
  (let ((v1-0 (-> this dir)))
    (cond
      ((zero? v1-0)
       (quaternion-rotate-y! (-> this root quat) *unity-quaternion* 32768.0)
       )
      ((= v1-0 1)
       (quaternion-rotate-y! (-> this root quat) *unity-quaternion* 16384.0)
       )
      ((= v1-0 2)
       (quaternion-rotate-y! (-> this root quat) *unity-quaternion* 0.0)
       )
      ((= v1-0 3)
       (quaternion-rotate-y! (-> this root quat) *unity-quaternion* -16384.0)
       )
      )
    )
  (let ((s5-0 (ppointer->process (-> this parent))))
    (let ((v1-13 (power-game-method-38 s5-0 (new 'stack-no-clear 'vector) (-> this dir)))
          (s4-0 (-> this local))
          (s2-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s2-0 quad) (-> this local quad))
      (vector+float*! (-> this local) (-> this local) v1-13 (* (-> this speed) (seconds-per-frame)))
      (cond
        ((power-game-method-42 s5-0 s2-0 (-> this dir) (-> this dir))
         (set! (-> this next-dir) (-> this dir))
         )
        ((power-game-method-42 s5-0 s2-0 (-> this dir) (logand (+ (-> this dir) 1) 3))
         (set! (-> this next-dir) (logand (+ (-> this dir) 1) 3))
         )
        ((power-game-method-42 s5-0 s2-0 (-> this dir) (logand (+ (-> this dir) 3) 3))
         (set! (-> this next-dir) (logand (+ (-> this dir) 3) 3))
         )
        )
      (let ((s1-0 #f)
            (s3-0 (power-game-method-39 s5-0 (-> this dir)))
            )
        (let ((v1-35 (-> this dir)))
          (cond
            ((or (zero? v1-35) (= v1-35 3))
             (if (or (< (-> s4-0 data s3-0) 0.0) (< (-> s4-0 data s3-0) (floor (-> s2-0 data s3-0))))
                 (set! s1-0 #t)
                 )
             )
            ((= v1-35 1)
             (if (or (>= (-> s4-0 data s3-0) 16.0) (>= (-> s4-0 data s3-0) (the float (+ (the int (-> s2-0 data s3-0)) 1))))
                 (set! s1-0 #t)
                 )
             )
            (else
              (if (or (>= (-> s4-0 data s3-0) 14.0) (>= (-> s4-0 data s3-0) (the float (+ (the int (-> s2-0 data s3-0)) 1))))
                  (set! s1-0 #t)
                  )
              )
            )
          )
        (when (and s1-0 (!= (-> this dir) (-> this next-dir)))
          (set! (-> this dir) (-> this next-dir))
          (let ((f0-9 (-> s4-0 data s3-0)))
            (set! (-> s4-0 data s3-0) (the float (the int (+ 0.5 f0-9))))
            )
          (set! (-> this turn-pos quad) (-> this local quad))
          (set! (-> this slide-lock) #f)
          )
        )
      )
    (when (>= (-> this slide-dir) 0)
      (let ((s5-1 (power-game-method-39 s5-0 (-> this slide-dir))))
        (seek! (-> this local data s5-1) (-> this slide-dest data s5-1) (* (-> this slide-speed) (seconds-per-frame)))
        (when (= (-> this local data s5-1) (-> this slide-dest data s5-1))
          (set! (-> this slide-dir) -1)
          (when (>= (-> this slide-count) (-> this slide-dist))
            (set! (-> this turn-pos quad) (-> this local quad))
            (set! (-> this slide-count) 0)
            (set! (-> this slide-lock) #f)
            )
          )
        )
      )
    )
  (set! (-> this local x) (fmax 0.0 (fmin 16.0 (-> this local x))))
  (set! (-> this local z) (fmax 0.0 (fmin 14.0 (-> this local z))))
  0
  (none)
  )

(defmethod power-game-object-method-31 ((this power-game-object))
  (if (nonzero? (-> this sound))
      (update! (-> this sound))
      )
  (get-center-pos!
    (ppointer->process (-> this parent))
    (-> this root trans)
    (-> this local x)
    (-> this local z)
    )
  (+! (-> this root trans y) 4096.0)
  (cond
    ((= (-> this dir) 3)
     (let ((a0-4 (-> this node-list data 2)))
       (set! (-> a0-4 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint-flip-z!))
       (set! (-> a0-4 param1) #f)
       (set! (-> a0-4 param2) #f)
       )
     )
    (else
      (let ((a0-5 (-> this node-list data 2)))
        (set! (-> a0-5 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint!))
        (set! (-> a0-5 param1) #f)
        (set! (-> a0-5 param2) #f)
        )
      )
    )
  (ja-post)
  0
  (none)
  )

(defskelgroup skel-power-game-player daxter-pac-man daxter-pac-man-lod0-jg -1
              ((daxter-pac-man-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5.5)
              )

(deftype power-game-player (power-game-object)
  ((slide-rel-dir  int32)
   )
  )


(defbehavior power-game-player-post power-game-player ()
  (cond
    ((cpad-hold? 0 x)
     (set! (-> self speed) 8.0)
     (set! (-> self slide-dist) 1)
     )
    (else
      (set! (-> self speed) 4.0)
      (set! (-> self slide-dist) 2)
      )
    )
  (power-game-object-method-30 self)
  (power-game-object-method-31 self)
  0
  (none)
  )

(defstate active (power-game-player)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (go-virtual die)
       )
      )
    )
  :trans (behavior ()
    (if (or (= (-> *cpad-list* cpads 0 stick0-speed) 0.0) (zero? (-> self slide-count)))
        (set! (-> self slide-lock) #f)
        )
    (let ((gp-0 (ppointer->process (-> self parent))))
      (when (and (< (-> self slide-dir) 0)
                 (and (= (-> self dir) (-> self next-dir))
                      (and (>= (vector-vector-xz-distance (-> self turn-pos) (-> self local)) 1.0)
                           (power-game-method-42 gp-0 (-> self local) (-> self dir) (-> self dir))
                           )
                      )
                 )
        (let ((s5-0 (logand (+ (-> self dir) 1) 3))
              (s4-0 (logand (+ (-> self dir) 3) 3))
              )
          (cond
            ((and *cheat-mode* (cpad-pressed? 0 triangle))
             (sound-play "change-directn")
             (set! (-> self dir) (logand (+ (-> self dir) 2) 3))
             )
            ((-> self slide-lock)
             )
            ((power-game-method-40 gp-0 s5-0)
             (set! (-> self slide-dest quad) (-> self local quad))
             (set! (-> self slide-speed) 8.0)
             (when (power-game-method-42 gp-0 (-> self slide-dest) -1 s5-0)
               (power-game-method-39 gp-0 (-> self dir))
               (sound-play "change-track")
               (set! (-> self slide-dir) s5-0)
               (set! (-> self slide-rel-dir) 1)
               (+! (-> self slide-count) 1)
               (vector+float*!
                 (-> self slide-dest)
                 (-> self slide-dest)
                 (power-game-method-38 gp-0 (new 'stack-no-clear 'vector) s5-0)
                 1.0
                 )
               )
             )
            ((power-game-method-40 gp-0 s4-0)
             (set! (-> self slide-dest quad) (-> self local quad))
             (set! (-> self slide-speed) 8.0)
             (when (power-game-method-42 gp-0 (-> self slide-dest) -1 s4-0)
               (power-game-method-39 gp-0 (-> self dir))
               (sound-play "change-track")
               (set! (-> self slide-dir) s4-0)
               (set! (-> self slide-rel-dir) -1)
               (+! (-> self slide-count) 1)
               (vector+float*!
                 (-> self slide-dest)
                 (-> self slide-dest)
                 (power-game-method-38 gp-0 (new 'stack-no-clear 'vector) s4-0)
                 1.0
                 )
               )
             )
            )
          )
        )
      (let ((s5-4 (power-game-method-33 gp-0 (+ 0.5 (-> self local x)) (+ 0.5 (-> self local z)) -1)))
        (if (!= s5-4 (power-game-method-33 gp-0 (+ 0.5 (-> self local x)) (+ 0.5 (-> self local z)) 0))
            (sound-play "pickup-fruit")
            )
        )
      )
    )
  :code (behavior ()
    (let ((f30-0 0.0))
      1.0
      (until #f
        (label cfg-1)
        (let ((v1-3 (ja-group)))
          (cond
            ((and v1-3 (or (= v1-3 daxter-pac-man-zip-down-ja) (= v1-3 daxter-pac-man-zip-up-ja)))
             (ja-no-eval :num! (seek!))
             (while (not (ja-done? 0))
               (suspend)
               (ja-eval)
               )
             )
            ((and (>= (-> self slide-dir) 0) (> (-> self slide-rel-dir) 0))
             (ja-channel-push! 1 (seconds 0.05))
             (ja-no-eval :group! daxter-pac-man-zip-down-ja :num! (seek! (ja-aframe 2.0 0)) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek! (ja-aframe 2.0 0)))
               )
             (while (>= (-> self slide-dir) 0)
               (suspend)
               )
             )
            ((and (>= (-> self slide-dir) 0) (< (-> self slide-rel-dir) 0))
             (ja-channel-push! 1 (seconds 0.05))
             (ja-no-eval :group! daxter-pac-man-zip-up-ja :num! (seek! (ja-aframe 2.0 0)) :frame-num 0.0)
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek! (ja-aframe 2.0 0)))
               )
             (while (>= (-> self slide-dir) 0)
               (suspend)
               )
             (goto cfg-1)
             )
            )
          )
        (let ((v1-58 (ja-group)))
          (when (not (and v1-58 (= v1-58 daxter-pac-man-idle-ja)))
            (ja-channel-push! 2 (seconds 0.05))
            (ja :group! daxter-pac-man-idle-ja)
            (ja :chan 1 :group! daxter-pac-man-idle-fast-ja)
            (set! f30-0 0.0)
            )
          )
        (suspend)
        (let ((f28-0 (lerp-scale 1.0 2.0 (-> self speed) 4.0 8.0)))
          (set! f30-0 (seek f30-0 (lerp-scale 0.0 1.0 (-> self speed) 4.0 8.0) (* 4.0 (seconds-per-frame))))
          (ja :num! (loop! f28-0))
          )
        (ja :chan 1 :num! (chan 0) :frame-interp0 f30-0 :frame-interp1 f30-0)
        )
      )
    #f
    )
  :post (behavior ()
    (power-game-player-post)
    )
  )

(defstate die (power-game-player)
  :virtual #t
  :code (behavior ()
    (sound-play "dax-die")
    (send-event (ppointer->process (-> self parent)) 'die)
    (logior! (-> self focus-status) (focus-status dead))
    (ja-channel-push! 1 (seconds 0.05))
    (cond
      ((rand-vu-percent? 0.5)
       (ja-no-eval :group! daxter-pac-man-death-1-ja :num! (seek!) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      (else
        (ja-no-eval :group! daxter-pac-man-death-2-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (cond
      ((logtest? (-> *part-group-id-table* 911 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 911))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 911))
        )
      )
    (sound-play "magic-poof-die")
    (ja-channel-set! 0)
    (send-event (ppointer->process (-> self parent)) 'fail)
    (sleep-code)
    )
  :post (behavior ()
    (power-game-object-method-31 self)
    )
  )

(defbehavior power-game-player-init power-game-player ((arg0 vector) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-power-game-player" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (logior! (-> self skel status) (joint-control-status sync-math blend-shape eye-anim))
  (set-vector! (-> self root scale) 8.0 8.0 8.0 1.0)
  (set-vector! (-> self local) 8.0 0.0 5.0 1.0)
  (set! (-> self dir) 1)
  (set! (-> self next-dir) (-> self dir))
  (set! (-> self slide-dir) -1)
  (set! (-> self target) (the-as handle #f))
  (set-time! (-> self start-time))
  (set! (-> self slide-lock) #f)
  (if (zero? (set-last-speech (-> self parent 0) 4 2))
      (talker-spawn-func (-> *power-game-speech-list* 12) *entity-pool* (target-pos 0) (the-as region #f))
      (talker-spawn-func (-> *power-game-speech-list* 13) *entity-pool* (target-pos 0) (the-as region #f))
      )
  (let ((v1-27 (-> (process->handle self) process)))
    (set-setting! 'sound-ear v1-27 0.0 (-> v1-27 0 pid))
    )
  (go-virtual active)
  )

(defskelgroup skel-power-game-chaser flitter flitter-lod0-jg -1
              ((flitter-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5.5)
              :shadow flitter-shadow-mg
              :origin-joint-index 3
              )

(deftype power-game-chaser (power-game-object)
  ((targ-dist  float)
   )
  )


(defbehavior power-game-chaser-post power-game-chaser ()
  (power-game-object-method-30 self)
  (power-game-object-method-31 self)
  0
  (none)
  )

(defstate active (power-game-chaser)
  :virtual #t
  :trans (behavior ()
    (let* ((s5-0 (handle->process (-> self target)))
           (gp-0 (if (type? s5-0 power-game-object)
                     (the-as power-game-object s5-0)
                     )
                 )
           (s5-1 (ppointer->process (-> self parent)))
           )
      (when (and gp-0 (not (logtest? (-> gp-0 focus-status) (focus-status dead))))
        (let ((s3-0 (power-game-method-32 s5-1 (-> gp-0 local x) (-> gp-0 local z)))
              (s2-0 (power-game-method-32 s5-1 (-> self local x) (-> self local z)))
              (s0-0 (power-game-method-35 s5-1 (-> self local x) (-> self local z) (-> self dir)))
              )
          (when (and (= (-> self slide-dir) -1)
                     (= (-> self dir) (-> self next-dir))
                     (and (>= (vector-vector-xz-distance (-> self turn-pos) (-> self local)) 1.0)
                          (power-game-method-42 s5-1 (-> self local) (-> self dir) (-> self dir))
                          )
                     )
            (let ((s1-0 (logand (+ (-> self dir) 1) 3))
                  (s4-0 (logand (+ (-> self dir) 3) 3))
                  )
              (cond
                ((!= s0-0 (power-game-method-35 s5-1 (-> gp-0 local x) (-> gp-0 local z) (-> gp-0 dir)))
                 (set! (-> self dir) (logand (+ (-> self dir) 2) 3))
                 )
                ((= s3-0 s2-0)
                 )
                ((or (and (> s0-0 0) (< s2-0 s3-0)) (and (< s0-0 0) (< s3-0 s2-0)))
                 (set! (-> self slide-dest quad) (-> self local quad))
                 (set! (-> self slide-speed) (* 8.0 (the float (-> self slide-dist))))
                 (dotimes (s4-1 (-> self slide-dist))
                   (when (power-game-method-42 s5-1 (-> self slide-dest) -1 s1-0)
                     (power-game-method-39 s5-1 (-> self dir))
                     (set! (-> self slide-dir) s1-0)
                     (vector+float*!
                       (-> self slide-dest)
                       (-> self slide-dest)
                       (power-game-method-38 s5-1 (new 'stack-no-clear 'vector) s1-0)
                       1.0
                       )
                     )
                   )
                 )
                ((or (and (> s0-0 0) (< s3-0 s2-0)) (and (< s0-0 0) (< s2-0 s3-0)))
                 (set! (-> self slide-dest quad) (-> self local quad))
                 (set! (-> self slide-speed) (* 8.0 (the float (-> self slide-dist))))
                 (dotimes (s3-3 (-> self slide-dist))
                   (when (power-game-method-42 s5-1 (-> self slide-dest) -1 s4-0)
                     (power-game-method-39 s5-1 (-> self dir))
                     (set! (-> self slide-dir) s4-0)
                     (vector+float*!
                       (-> self slide-dest)
                       (-> self slide-dest)
                       (power-game-method-38 s5-1 (new 'stack-no-clear 'vector) s4-0)
                       1.0
                       )
                     )
                   )
                 )
                )
              )
            )
          )
        (set! (-> self targ-dist)
              (lerp-scale 10.0 0.0 (the float (- (current-time) (-> self start-time))) 0.0 18000.0)
              )
        (let* ((f0-23 (- (power-game-method-36
                           s5-1
                           (-> self local x)
                           (-> self local z)
                           (-> self dir)
                           (-> gp-0 local x)
                           (-> gp-0 local z)
                           )
                         (-> self targ-dist)
                         )
                      )
               (f0-24 (if (>= f0-23 0.0)
                          (lerp-scale 4.0 24.0 f0-23 0.0 5.0)
                          (lerp-scale 2.0 4.0 f0-23 -5.0 0.0)
                          )
                      )
               )
          (seek! (-> self speed) f0-24 (* 128.0 (seconds-per-frame)))
          )
        (if (< (vector-vector-xz-distance (-> self local) (-> gp-0 local)) 1.0)
            (send-event gp-0 'die)
            )
        )
      )
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (until #f
      (ja-no-eval :group! flitter-walk-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (power-game-chaser-post)
    )
  )

(defbehavior power-game-chaser-init power-game-chaser ((arg0 vector) (arg1 entity-actor) (arg2 handle))
  (process-entity-set! self arg1)
  (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-power-game-chaser" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set-vector! (-> self local) 0.0 0.0 10.0 1.0)
  (set! (-> self next-dir) (-> self dir))
  (set! (-> self slide-dir) -1)
  (set! (-> self speed) 4.0)
  (set! (-> self slide-dist) 1)
  (set! (-> self target) arg2)
  (set-time! (-> self start-time))
  (set! (-> self slide-lock) #f)
  (go-virtual active)
  )

(defskelgroup skel-power-game-switcher switcher switcher-lod0-jg -1
              ((switcher-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5.5)
              :origin-joint-index 3
              )

(deftype power-game-switcher (power-game-object)
  ((targ-dist  float)
   (turn-time  time-frame)
   )
  (:state-methods
    idle
    )
  )


(defbehavior power-game-switcher-post power-game-switcher ()
  (power-game-object-method-30 self)
  (power-game-object-method-31 self)
  0
  (none)
  )

(defstate idle (power-game-switcher)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (go-virtual die)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 4))
        (go-virtual active)
        )
    (let* ((gp-0 (handle->process (-> self target)))
           (v1-10 (if (type? gp-0 power-game-object)
                      (the-as power-game-object gp-0)
                      )
                  )
           )
      (when (and v1-10 (not (logtest? (-> v1-10 focus-status) (focus-status dead))))
        (if (< (vector-vector-xz-distance (-> self local) (-> v1-10 local)) 1.0)
            (go-virtual die)
            )
        )
      )
    )
  :code (behavior ()
    (sound-play "switcher-appear")
    (if (logtest? (-> *part-group-id-table* 907 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 907)
          :duration (seconds 4)
          :target self
          :mat-joint (the-as object 0)
          )
        (part-tracker-spawn
          part-tracker
          :to self
          :group (-> *part-group-id-table* 907)
          :duration (seconds 4)
          :target self
          :mat-joint (the-as object 0)
          )
        )
    (let ((v1-32 (set-last-speech (-> self parent 0) 6 3)))
      (cond
        ((zero? v1-32)
         (talker-spawn-func (-> *power-game-speech-list* 47) *entity-pool* (target-pos 0) (the-as region #f))
         )
        ((= v1-32 1)
         (talker-spawn-func (-> *power-game-speech-list* 46) *entity-pool* (target-pos 0) (the-as region #f))
         )
        (else
          (talker-spawn-func (-> *power-game-speech-list* 48) *entity-pool* (target-pos 0) (the-as region #f))
          )
        )
      )
    (ja-channel-set! 1)
    (until #f
      (ja-no-eval :group! switcher-charge-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post power-game-switcher-post
  )

(defstate active (power-game-switcher)
  :virtual #t
  :event (-> (method-of-type power-game-switcher idle) event)
  :trans (behavior ()
    (let ((gp-0 (ppointer->process (-> self parent))))
      (when (and (= (-> self slide-dir) -1)
                 (and (= (-> self dir) (-> self next-dir))
                      (and (>= (vector-vector-xz-distance (-> self turn-pos) (-> self local)) 1.0)
                           (power-game-method-42 gp-0 (-> self local) (-> self dir) (-> self dir))
                           (time-elapsed? (-> self turn-time) (seconds 2))
                           )
                      )
                 )
        (let ((s5-0 (logand (+ (-> self dir) 1) 3))
              (s4-0 (logand (+ (-> self dir) 3) 3))
              )
          (cond
            ((rand-vu-percent? 0.01)
             (set! (-> self slide-dest quad) (-> self local quad))
             (set! (-> self slide-speed) (* 8.0 (the float (-> self slide-dist))))
             (dotimes (s4-1 (-> self slide-dist))
               (when (power-game-method-42 gp-0 (-> self slide-dest) -1 s5-0)
                 (power-game-method-39 gp-0 (-> self dir))
                 (set-time! (-> self turn-time))
                 (set! (-> self slide-dir) s5-0)
                 (vector+float*!
                   (-> self slide-dest)
                   (-> self slide-dest)
                   (power-game-method-38 gp-0 (new 'stack-no-clear 'vector) s5-0)
                   1.0
                   )
                 )
               )
             )
            ((rand-vu-percent? 0.01)
             (set! (-> self slide-dest quad) (-> self local quad))
             (set! (-> self slide-speed) (* 8.0 (the float (-> self slide-dist))))
             (dotimes (s5-1 (-> self slide-dist))
               (when (power-game-method-42 gp-0 (-> self slide-dest) -1 s4-0)
                 (power-game-method-39 gp-0 (-> self dir))
                 (set-time! (-> self turn-time))
                 (set! (-> self slide-dir) s4-0)
                 (vector+float*!
                   (-> self slide-dest)
                   (-> self slide-dest)
                   (power-game-method-38 gp-0 (new 'stack-no-clear 'vector) s4-0)
                   1.0
                   )
                 )
               )
             )
            )
          )
        )
      (let* ((s5-2 (handle->process (-> self target)))
             (v1-53 (if (type? s5-2 power-game-object)
                        (the-as power-game-object s5-2)
                        )
                    )
             )
        (when (and v1-53 (not (logtest? (-> v1-53 focus-status) (focus-status dead))))
          (if (< (vector-vector-xz-distance (-> self local) (-> v1-53 local)) 1.0)
              (go-virtual die)
              )
          )
        )
      (when (not (and (>= (-> self local z) 7.0)
                      (< (-> self local z) 8.0)
                      (>= (-> self local x) 7.0)
                      (>= 9.0 (-> self local x))
                      )
                 )
        (let ((s5-3 (power-game-method-33 gp-0 (+ 0.5 (-> self local x)) (+ 0.5 (-> self local z)) -1)))
          (if (!= s5-3 (power-game-method-33 gp-0 (+ 0.5 (-> self local x)) (+ 0.5 (-> self local z)) 1))
              (sound-play "switch-fruit")
              )
          )
        )
      )
    )
  :code (behavior ()
    (set! (-> self speed) 3.0)
    (ja-channel-set! 1)
    (until #f
      (ja-no-eval :group! switcher-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post power-game-switcher-post
  )

(defstate die (power-game-switcher)
  :virtual #t
  :code (behavior ()
    (sound-play "switcher-kill")
    (let ((v1-4 (set-last-speech (-> self parent 0) 5 4)))
      (cond
        ((zero? v1-4)
         (talker-spawn-func (-> *power-game-speech-list* 21) *entity-pool* (target-pos 0) (the-as region #f))
         )
        ((= v1-4 1)
         (talker-spawn-func (-> *power-game-speech-list* 22) *entity-pool* (target-pos 0) (the-as region #f))
         )
        ((= v1-4 2)
         (talker-spawn-func (-> *power-game-speech-list* 23) *entity-pool* (target-pos 0) (the-as region #f))
         )
        (else
          (talker-spawn-func (-> *power-game-speech-list* 24) *entity-pool* (target-pos 0) (the-as region #f))
          )
        )
      )
    (cond
      ((logtest? (-> *part-group-id-table* 908 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 908))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 908))
        )
      )
    (logior! (-> self focus-status) (focus-status dead))
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! switcher-die-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    )
  :post (behavior ()
    (power-game-object-method-31 self)
    )
  )

(defbehavior power-game-switcher-init power-game-switcher ((arg0 vector) (arg1 entity-actor) (arg2 handle))
  (local-vars (v1-11 symbol))
  (process-entity-set! self arg1)
  (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-power-game-switcher" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set-vector! (-> self root scale) 1.3 1.3 1.3 1.0)
  (until (not v1-11)
    (set-vector! (-> self local) (the float (rand-vu-int-count 17)) 0.0 (the float (rand-vu-int-count 15)) 1.0)
    (set! v1-11 (and (>= (-> self local z) 6.0)
                     (>= 8.0 (-> self local z))
                     (>= (-> self local x) 6.0)
                     (>= 10.0 (-> self local x))
                     )
          )
    )
  (set! (-> self next-dir) (-> self dir))
  (set! (-> self slide-dir) -1)
  (set! (-> self speed) 0.0)
  (set! (-> self slide-dist) 1)
  (set! (-> self target) arg2)
  (set-time! (-> self start-time))
  (set! (-> self slide-lock) #f)
  (set! (-> self sound) (new 'process 'ambient-sound "switcher-drone" (-> self root trans) 0.0))
  (go-virtual idle)
  )

(defskelgroup skel-power-game-zapper grunt-head grunt-head-lod0-jg -1
              ((grunt-head-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5.5)
              )

(defskelgroup skel-power-game-rings pow-rings pow-rings-lod0-jg pow-rings-idle-ja
              ((pow-rings-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              )

(deftype power-game-zapper (power-game-object)
  ((change-time      time-frame)
   (close-time       time-frame)
   (switch-duration  time-frame)
   (lane-time        time-frame)
   (lane-target      int32)
   (lane-target-old  int32)
   (lane-old         int32)
   (rings            (pointer manipy))
   )
  )


(defbehavior power-game-zapper-post power-game-zapper ()
  (power-game-object-method-30 self)
  (power-game-object-method-31 self)
  (let ((v1-6 (power-game-method-32 (-> self parent 0) (-> self local x) (-> self local z))))
    (cond
      ((= v1-6 6)
       (send-event (ppointer->process (-> self rings)) 'segment 8 1008)
       )
      ((= v1-6 5)
       (send-event (ppointer->process (-> self rings)) 'segment 16 1000)
       )
      ((= v1-6 4)
       (send-event (ppointer->process (-> self rings)) 'segment 32 984)
       )
      ((= v1-6 3)
       (send-event (ppointer->process (-> self rings)) 'segment 64 952)
       )
      ((= v1-6 2)
       (send-event (ppointer->process (-> self rings)) 'segment 128 888)
       )
      ((= v1-6 1)
       (send-event (ppointer->process (-> self rings)) 'segment 256 760)
       )
      ((zero? v1-6)
       (send-event (ppointer->process (-> self rings)) 'segment 512 504)
       )
      )
    )
  0
  (none)
  )

(defstate active (power-game-zapper)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('die)
       (go-virtual die)
       )
      )
    )
  :trans (behavior ()
    (let* ((s5-0 (handle->process (-> self target)))
           (gp-0 (if (type? s5-0 power-game-object)
                     (the-as power-game-zapper s5-0)
                     )
                 )
           (s4-0 (ppointer->process (-> self parent)))
           )
      (when (and gp-0 (not (logtest? (-> gp-0 focus-status) (focus-status dead))))
        (let ((s5-1 (power-game-method-32 s4-0 (-> self local x) (-> self local z))))
          (let ((s3-0 (power-game-method-35 s4-0 (-> self local x) (-> self local z) (-> self dir))))
            (when (time-elapsed? (-> self lane-time) (-> self switch-duration))
              (set! (-> self lane-target) (-> self lane-target-old))
              (set-time! (-> self lane-time))
              (set! (-> self lane-target-old) (power-game-method-32 s4-0 (-> gp-0 local x) (-> gp-0 local z)))
              )
            (when (and (= (-> self slide-dir) -1)
                       (and (= (-> self dir) (-> self next-dir))
                            (and (>= (vector-vector-xz-distance (-> self turn-pos) (-> self local)) 1.0)
                                 (power-game-method-42 s4-0 (-> self local) (-> self dir) (-> self dir))
                                 (time-elapsed? (-> self change-time) (seconds 2))
                                 )
                            )
                       )
              (let ((s1-0 (logand (+ (-> self dir) 1) 3))
                    (s2-0 (logand (+ (-> self dir) 3) 3))
                    )
                (cond
                  ((= s3-0 (power-game-method-35 s4-0 (-> gp-0 local x) (-> gp-0 local z) (-> gp-0 dir)))
                   (set! (-> self dir) (logand (+ (-> self dir) 2) 3))
                   )
                  ((= (-> self lane-target) s5-1)
                   )
                  ((or (and (> s3-0 0) (< s5-1 (-> self lane-target))) (and (< s3-0 0) (< (-> self lane-target) s5-1)))
                   (set! (-> self slide-dest quad) (-> self local quad))
                   (set! (-> self slide-speed) (* 8.0 (the float (-> self slide-dist))))
                   (dotimes (s3-1 (-> self slide-dist))
                     (when (power-game-method-42 s4-0 (-> self slide-dest) -1 s1-0)
                       (power-game-method-39 s4-0 (-> self dir))
                       (set! (-> self slide-dir) s1-0)
                       (vector+float*!
                         (-> self slide-dest)
                         (-> self slide-dest)
                         (power-game-method-38 s4-0 (new 'stack-no-clear 'vector) s1-0)
                         1.0
                         )
                       (set-time! (-> self change-time))
                       )
                     )
                   )
                  ((or (and (> s3-0 0) (< (-> self lane-target) s5-1)) (and (< s3-0 0) (< s5-1 (-> self lane-target))))
                   (set! (-> self slide-dest quad) (-> self local quad))
                   (set! (-> self slide-speed) (* 8.0 (the float (-> self slide-dist))))
                   (dotimes (s3-2 (-> self slide-dist))
                     (when (power-game-method-42 s4-0 (-> self slide-dest) -1 s2-0)
                       (power-game-method-39 s4-0 (-> self dir))
                       (set! (-> self slide-dir) s2-0)
                       (vector+float*!
                         (-> self slide-dest)
                         (-> self slide-dest)
                         (power-game-method-38 s4-0 (new 'stack-no-clear 'vector) s2-0)
                         1.0
                         )
                       (set-time! (-> self change-time))
                       )
                     )
                   )
                  )
                )
              )
            )
          (cond
            ((and (!= (-> self lane-old) s5-1)
                  (= s5-1 (power-game-method-32 s4-0 (-> gp-0 local x) (-> gp-0 local z)))
                  (rand-vu-percent? 0.3)
                  )
             (let ((v1-89 (set-last-speech s4-0 3 3)))
               (cond
                 ((zero? v1-89)
                  (talker-spawn-func (-> *power-game-speech-list* 4) *entity-pool* (target-pos 0) (the-as region #f))
                  )
                 ((= v1-89 1)
                  (talker-spawn-func (-> *power-game-speech-list* 5) *entity-pool* (target-pos 0) (the-as region #f))
                  )
                 (else
                   (talker-spawn-func (-> *power-game-speech-list* 6) *entity-pool* (target-pos 0) (the-as region #f))
                   )
                 )
               )
             )
            ((< (vector-vector-xz-distance (-> self local) (-> gp-0 local)) 2.0)
             (when (time-elapsed? (-> self close-time) (seconds 3))
               (let ((v1-103 (set-last-speech s4-0 7 3)))
                 (cond
                   ((zero? v1-103)
                    (talker-spawn-func (-> *power-game-speech-list* 43) *entity-pool* (target-pos 0) (the-as region #f))
                    )
                   ((= v1-103 1)
                    (talker-spawn-func (-> *power-game-speech-list* 44) *entity-pool* (target-pos 0) (the-as region #f))
                    )
                   ((= v1-103 2)
                    (talker-spawn-func (-> *power-game-speech-list* 45) *entity-pool* (target-pos 0) (the-as region #f))
                    )
                   (else
                     (talker-spawn-func (-> *power-game-speech-list* 46) *entity-pool* (target-pos 0) (the-as region #f))
                     )
                   )
                 )
               )
             (set-time! (-> self close-time))
             )
            )
          (set! (-> self lane-old) s5-1)
          )
        (if (< (vector-vector-xz-distance (-> self local) (-> gp-0 local)) 1.0)
            (send-event gp-0 'die)
            )
        )
      )
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (until #f
      (ja-no-eval :group! grunt-head-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (power-game-zapper-post)
    )
  )

(defstate die (power-game-zapper)
  :virtual #t
  :code (behavior ()
    (if (logtest? (-> *part-group-id-table* 908 flags) (sp-group-flag sp13))
        (part-tracker-spawn
          part-tracker-subsampler
          :to self
          :group (-> *part-group-id-table* 908)
          :target self
          :mat-joint (the-as object 0)
          )
        (part-tracker-spawn
          part-tracker
          :to self
          :group (-> *part-group-id-table* 908)
          :target self
          :mat-joint (the-as object 0)
          )
        )
    (logior! (-> self focus-status) (focus-status dead))
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! grunt-head-idle-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    )
  :post (behavior ()
    (power-game-object-method-31 self)
    )
  )

(defbehavior power-game-zapper-init power-game-zapper ((arg0 vector) (arg1 entity-actor) (arg2 handle) (arg3 int))
  (let ((f30-0 (you-suck-scale *game-info* #f 175)))
    (process-entity-set! self arg1)
    (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
    (set! (-> self root trans quad) (-> arg0 quad))
    (initialize-skeleton
      self
      (the-as skeleton-group (art-group-get-by-name *level* "skel-power-game-zapper" (the-as (pointer level) #f)))
      (the-as pair 0)
      )
    (set-vector! (-> self root scale) 2.5 2.5 2.5 1.0)
    (set! (-> self switch-duration) (the-as time-frame (the int (+ 300.0 (* 900.0 f30-0)))))
    (cond
      ((= arg3 1)
       (set-vector! (-> self local) 1.0 0.0 10.0 1.0)
       (set! (-> self speed) 3.0)
       )
      ((= arg3 2)
       (set-vector! (-> self local) 2.0 0.0 10.0 1.0)
       (set! (-> self speed) 2.0)
       )
      ((= arg3 3)
       (set-vector! (-> self local) 2.0 0.0 10.0 1.0)
       (set! (-> self speed) 5.0)
       )
      ((= arg3 4)
       (set-vector! (-> self local) 3.0 0.0 10.0 1.0)
       (set! (-> self speed) 1.0)
       )
      ((begin
         (set-vector! (-> self local) 0.0 0.0 10.0 1.0)
         (task-node-closed? (game-task-node city-power-game-resolution))
         )
       (set! (-> self speed) 4.0)
       )
      (else
        (set! (-> self speed) (- 4.0 (* 2.0 f30-0)))
        )
      )
    )
  (set! (-> self next-dir) (-> self dir))
  (set! (-> self slide-dir) -1)
  (set! (-> self slide-dist) 1)
  (set! (-> self target) arg2)
  (set-time! (-> self start-time))
  (set! (-> self slide-lock) #f)
  (set! (-> self rings)
        (process-spawn
          manipy
          :init manipy-init
          (vector+! (new 'stack-no-clear 'vector) (-> self parent 0 center) (new 'static 'vector :y 204.8 :w 1.0))
          (-> self entity)
          (art-group-get-by-name *level* "skel-power-game-rings" (the-as (pointer level) #f))
          #f
          0
          :name "pow-rings"
          :to self
          :stack-size #x20000
          )
        )
  (set! (-> self sound) (new 'process 'ambient-sound "zapper-drone" (-> self root trans) 0.0))
  (go-virtual active)
  )

(defskelgroup skel-power-game-glyph cipher cipher-lod0-jg cipher-idle-ja
              ((cipher-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              :origin-joint-index 3
              )

(deftype power-game-glyph (power-game-object)
  ((pickup-type  int32)
   (angle        degrees)
   )
  (:methods
    (power-game-glyph-method-32 (_type_) none)
    )
  )


(defmethod power-game-object-method-31 ((this power-game-glyph))
  (get-center-pos!
    (ppointer->process (-> this parent))
    (-> this root trans)
    (-> this local x)
    (-> this local z)
    )
  (+! (-> this root trans y) 4096.0)
  (let ((t9-1 quaternion-rotate-y!)
        (a0-2 (-> this root quat))
        (a1-1 *unity-quaternion*)
        (f0-5 (+ (-> this angle) (* 40049.777 (seconds-per-frame))))
        )
    (set! (-> this angle) f0-5)
    (t9-1 a0-2 a1-1 f0-5)
    )
  (ja-post)
  (none)
  )

(defbehavior power-game-glyph-post power-game-glyph ()
  (power-game-object-method-30 self)
  (power-game-object-method-31 self)
  0
  (none)
  )

(defstate active (power-game-glyph)
  :virtual #t
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (let* ((gp-0 (handle->process (-> self target)))
           (v1-3 (if (type? gp-0 power-game-object)
                     (the-as power-game-object gp-0)
                     )
                 )
           )
      (when (and v1-3 (not (logtest? (-> v1-3 focus-status) (focus-status dead))))
        (if (< (vector-vector-xz-distance (-> self local) (-> v1-3 local)) 1.0)
            (go-virtual die)
            )
        )
      )
    )
  :code sleep-code
  :post power-game-glyph-post
  )

(defstate die (power-game-glyph)
  :virtual #t
  :code (behavior ()
    (cond
      ((logtest? (-> *part-group-id-table* 910 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 910))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 910))
        )
      )
    (sound-play "glyph-kill")
    (logior! (-> self focus-status) (focus-status dead))
    (send-event (ppointer->process (-> self parent)) 'win)
    )
  :post (behavior ()
    (power-game-object-method-31 self)
    )
  )

(defbehavior power-game-glyph-init power-game-glyph ((arg0 vector) (arg1 entity-actor) (arg2 handle) (arg3 int))
  (set! (-> self pickup-type) arg3)
  (process-entity-set! self arg1)
  (set! (-> self root) (the-as collide-shape (new 'process 'trsqv)))
  (set! (-> self root trans quad) (-> arg0 quad))
  (if (zero? arg3)
      (initialize-skeleton
        self
        (the-as skeleton-group (art-group-get-by-name *level* "skel-power-game-glyph" (the-as (pointer level) #f)))
        (the-as pair 0)
        )
      (initialize-skeleton
        self
        (the-as skeleton-group (art-group-get-by-name *level* "skel-skill" (the-as (pointer level) #f)))
        (the-as pair 0)
        )
      )
  (set-vector! (-> self root scale) 10.0 10.0 10.0 1.0)
  (set-vector! (-> self local) 8.0 0.0 8.0 1.0)
  (set! (-> self next-dir) (-> self dir))
  (set! (-> self slide-dir) -1)
  (set! (-> self speed) 0.0)
  (set! (-> self slide-dist) 1)
  (set! (-> self target) arg2)
  (set-time! (-> self start-time))
  (set! (-> self slide-lock) #f)
  (sound-play "glyph-appear")
  (get-center-pos!
    (ppointer->process (-> self parent))
    (-> self root trans)
    (-> self local x)
    (-> self local z)
    )
  (cond
    ((logtest? (-> *part-group-id-table* 909 flags) (sp-group-flag sp13))
     (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
     (part-tracker-spawn part-tracker-subsampler :to self :group (-> *part-group-id-table* 909))
     )
    (else
      (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
      (part-tracker-spawn part-tracker :to self :group (-> *part-group-id-table* 909))
      )
    )
  (go-virtual active)
  )

(defstate hide (power-game)
  :virtual #t
  :trans (behavior ()
    (when (= (status-of-level-and-borrows *level* 'powergd #f) 'active)
      (case (-> (get-current-task-event (-> self task)) action)
        (((game-task-action idle) (game-task-action talk))
         (go-virtual idle)
         )
        (((game-task-action play))
         (go-virtual wait-for-start)
         )
        )
      )
    )
  :code (behavior ()
    (set! (-> self difficulty) 0)
    (ja-channel-set! 0)
    (ja-post)
    (sleep-code)
    )
  )

(defstate idle (power-game)
  :virtual #t
  :trans (behavior ()
    (case (-> (get-current-task-event (-> self task)) action)
      (((game-task-action hide))
       (go-virtual hide)
       )
      (((game-task-action play))
       (go-virtual wait-for-start)
       )
      (((game-task-action talk))
       (let ((a0-5 (-> self root trans)))
         (when (and (time-elapsed? (-> self state-time) (seconds 3))
                    (and (and *target* (and (>= 40960.0 (vector-vector-distance a0-5 (-> *target* control trans)))
                                            (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                                            )
                              )
                         (not (focus-test? *target* in-head pole flut light board pilot dark))
                         (can-display-query? self "game" -99.0)
                         )
                    )
           (let ((gp-0
                   (new 'stack 'font-context *font-default-matrix* 32 320 0.0 (font-color default) (font-flags shadow kerning))
                   )
                 )
             (let ((v1-22 gp-0))
               (set! (-> v1-22 width) (the float 340))
               )
             (let ((v1-23 gp-0))
               (set! (-> v1-23 height) (the float 80))
               )
             (let ((v1-24 gp-0)
                   (a0-15 (-> *setting-control* user-default language))
                   )
               (set! (-> v1-24 scale) (if (or (= a0-15 (language-enum korean)) (= a0-15 (language-enum russian)))
                                          0.9
                                          0.7
                                          )
                     )
               )
             (set! (-> gp-0 flags) (font-flags shadow kerning large))
             (print-game-text
               (lookup-text! *common-text* (text-id text-0087) #f)
               gp-0
               #f
               44
               (bucket-id hud-draw-hud-alpha)
               )
             )
           (if (cpad-pressed? 0 triangle)
               (go-virtual wait-for-start)
               )
           )
         )
       )
      )
    )
  :code (behavior ()
    (set! (-> self difficulty) 0)
    (sleep-code)
    )
  :post ja-post
  )

(defstate wait-for-start (power-game)
  :virtual #t
  :code (behavior ()
    (set! (-> self difficulty) 0)
    (while (or (not *target*) (not (process-grab? *target* #f)))
      (suspend)
      )
    (send-event *target* 'draw #f)
    (go-virtual active #t)
    )
  )

(defstate active (power-game)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('done)
       (set-time! (-> self miss-time))
       (let ((v0-0 (the-as object (+ (-> self miss-count) 1))))
         (set! (-> self miss-count) (the-as int v0-0))
         v0-0
         )
       )
      (('fail)
       (go-virtual lose #f)
       )
      (('win)
       (go-virtual win #f)
       )
      (('die)
       (let ((v1-9 (set-last-speech self 1 12)))
         (cond
           ((zero? v1-9)
            (talker-spawn-func (-> *power-game-speech-list* 30) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 1)
            (talker-spawn-func (-> *power-game-speech-list* 31) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 2)
            (talker-spawn-func (-> *power-game-speech-list* 32) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 3)
            (talker-spawn-func (-> *power-game-speech-list* 33) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 4)
            (talker-spawn-func (-> *power-game-speech-list* 34) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 5)
            (talker-spawn-func (-> *power-game-speech-list* 35) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 6)
            (talker-spawn-func (-> *power-game-speech-list* 36) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 7)
            (talker-spawn-func (-> *power-game-speech-list* 37) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 8)
            (talker-spawn-func (-> *power-game-speech-list* 38) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 9)
            (talker-spawn-func (-> *power-game-speech-list* 39) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 10)
            (talker-spawn-func (-> *power-game-speech-list* 40) *entity-pool* (target-pos 0) (the-as region #f))
            )
           ((= v1-9 11)
            (talker-spawn-func (-> *power-game-speech-list* 41) *entity-pool* (target-pos 0) (the-as region #f))
            )
           (else
             (talker-spawn-func (-> *power-game-speech-list* 42) *entity-pool* (target-pos 0) (the-as region #f))
             )
           )
         )
       )
      )
    )
  :enter (behavior ((arg0 symbol))
    (when arg0
      (if (zero? (-> self wave-index))
          (talker-spawn-func (-> *power-game-speech-list* 1) *entity-pool* (target-pos 0) (the-as region #f))
          )
      (set! (-> self score) 0.0)
      (set! (-> self score-met) #f)
      (set! (-> self lentity) (entity-actor-from-level-name 'powergd))
      (dotimes (v1-4 (-> self blockers length))
        (set! (-> self blockers v1-4) (the-as uint 0))
        )
      (set! (-> self blockers 1) (the-as uint 1))
      (dotimes (v1-8 (-> self dots length))
        (set! (-> self dots v1-8) (the-as uint 1))
        )
      (power-game-method-33 self 7.0 7.0 0)
      (power-game-method-33 self 8.0 7.0 0)
      (power-game-method-33 self 9.0 7.0 0)
      (send-event *target* 'draw #f)
      (sound-play "zoom-in")
      (add-connection
        *task-manager-engine*
        self
        nothing
        self
        (-> *game-info* sub-task-list (game-task-node city-power-game-resolution))
        #f
        )
      (add-setting! 'music 'waspgame 0.0 0)
      (set-setting! 'mode-name 'cam-power-game 0.0 0)
      (set! (-> self cam-targ cam-pos-x-angle) 13653.333)
      (set! (-> self cam-targ cam-dist) 204800.0)
      (set! (-> self cam-targ cam-x-angle) 13653.333)
      (set! (-> self cam-targ cam-y-angle) 0.0)
      (set! (-> self cam-targ cam-y-angle-speed) 12743.111)
      (mem-copy! (the-as pointer (-> self cam-cur)) (the-as pointer (-> self cam-targ)) 40)
      (set-setting! 'interp-time 'abs 0.0 0)
      (set-setting! 'airlock #f 0.0 0)
      (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
      (set-setting! 'extra-bank '((vinroomh vinroomh powergd1)) 0.0 0)
      (set-setting!
        'faction-command
        '((faction-spawn mh-guard off)
          (faction-spawn mh-ped off)
          (faction-spawn ff-guard off)
          (faction-spawn ff-ped off)
          (faction-spawn kg-guard off)
          (faction-spawn kg-ped off)
          (faction-strength kg -5)
          (faction-strength mh -5)
          (faction-strength ff -5)
          )
        0.0
        0
        )
      (set-time! (-> self game-start-time))
      (set-time! (-> self wave-start-time))
      (send-event *target* 'draw #f)
      (set-setting! 'gun #f 0.0 0)
      (set-setting! 'calm #t 0.0 0)
      (set-setting! 'gem #f 0.0 0)
      (set! (-> self player) (ppointer->handle (process-spawn
                                                 power-game-player
                                                 :init power-game-player-init
                                                 (-> self center)
                                                 (-> self lentity)
                                                 :name "power-game-player"
                                                 :to self
                                                 )
                                               )
            )
      (dotimes (gp-3 (min 5 (+ (/ (-> self difficulty) 3) 1)))
        (set! (-> self zapper gp-3) (ppointer->handle (process-spawn
                                                        power-game-zapper
                                                        :init power-game-zapper-init
                                                        (-> self center)
                                                        (-> self lentity)
                                                        (-> self player)
                                                        gp-3
                                                        :name "power-game-zapper"
                                                        :to self
                                                        )
                                                      )
              )
        )
      (set-time! (-> self switcher-time))
      )
    )
  :exit (behavior ()
    (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                           (or (= v1-3 'win) (= v1-3 'lose))
                                           )
                    )
               )
      (when (not (and (-> self next-state) (= (-> self next-state name) 'active)))
        (format #t "score of ~f~%" (+ (-> self base-score) (-> self score)))
        (game-info-method-27 *game-info* (game-score gs14) (+ (-> self base-score) (-> self score)))
        )
      (remove-from-process *task-manager-engine* self)
      (remove-setting! 'music)
      (send-event (handle->process (-> self hud-score)) 'hide-and-die)
      (send-event (handle->process (-> self hud-goal)) 'hide-and-die)
      (remove-setting! 'entity-name)
      (remove-setting! 'mode-name)
      (if (and *target* (focus-test? *target* grabbed))
          (process-release? *target*)
          )
      (remove-setting! 'airlock)
      (remove-setting! 'borrow)
      (remove-setting! 'minimap)
      (remove-setting! 'gun)
      (remove-setting! 'calm)
      (remove-setting! 'gem)
      (persist-with-delay *setting-control* 'gun (seconds 0.5) 'gun #f 0.0 0)
      (remove-setting! 'extra-bank)
      (remove-setting! 'faction-command)
      (remove-setting! 'interp-time)
      (persist-with-delay *setting-control* 'interp-time (seconds 0.1) 'interp-time 'abs 0.0 0)
      (send-event *target* 'draw #t)
      (let ((a0-37 (handle->process (-> self player))))
        (if a0-37
            (deactivate a0-37)
            )
        )
      (let ((a0-41 (handle->process (-> self chaser))))
        (if a0-41
            (deactivate a0-41)
            )
        )
      (dotimes (gp-0 5)
        (let ((a0-45 (handle->process (-> self zapper gp-0))))
          (if a0-45
              (deactivate a0-45)
              )
          )
        )
      (let ((a0-49 (handle->process (-> self switcher))))
        (if a0-49
            (deactivate a0-49)
            )
        )
      (let ((a0-53 (handle->process (-> self glyph))))
        (if a0-53
            (deactivate a0-53)
            )
        )
      (send-event *target* 'draw #t)
      (logclear!
        (-> *cpad-list* cpads 0 button0-abs 0)
        (pad-buttons up right down left l1 r1 triangle circle x square)
        )
      (logclear!
        (-> *cpad-list* cpads 0 button0-rel 0)
        (pad-buttons up right down left l1 r1 triangle circle x square)
        )
      )
    )
  :trans (behavior ()
    (cond
      ((or (and *cheat-mode* (cpad-pressed? 0 l1)) (>= (-> self miss-count) (-> self miss-max)))
       (go-virtual lose #t)
       )
      ((and (>= (-> self score) (-> self point-win)) (not (-> self score-met)))
       (cond
         ((not (task-node-closed? (game-task-node city-power-game-resolution)))
          (let ((v1-13 (set-last-speech self 0 2)))
            (cond
              ((zero? v1-13)
               (talker-spawn-func (-> *power-game-speech-list* 9) *entity-pool* (target-pos 0) (the-as region #f))
               )
              ((= v1-13 1)
               (talker-spawn-func (-> *power-game-speech-list* 10) *entity-pool* (target-pos 0) (the-as region #f))
               )
              (else
                (talker-spawn-func (-> *power-game-speech-list* 11) *entity-pool* (target-pos 0) (the-as region #f))
                )
              )
            )
          (set! (-> self score-met) #t)
          (set! (-> self glyph) (ppointer->handle (process-spawn
                                                    power-game-glyph
                                                    :init power-game-glyph-init
                                                    (-> self center)
                                                    (-> self lentity)
                                                    (-> self player)
                                                    0
                                                    :name "power-game-glyph"
                                                    :to self
                                                    )
                                                  )
                )
          )
         (else
           (+! (-> self wave-index) 1)
           (+! (-> self difficulty) 1)
           (sound-play "glyph-kill")
           (+! (-> self base-score) (-> self score))
           (go-virtual active #t)
           )
         )
       )
      ((and *cheat-mode* (cpad-pressed? 0 r1))
       (go-virtual win #t)
       )
      )
    )
  :code (behavior ((arg0 symbol))
    (sleep-code)
    )
  :post (behavior ()
    (power-game-active-post self)
    (ja-post)
    )
  )

(defstate lose (power-game)
  :virtual #t
  :exit (-> (method-of-type power-game active) exit)
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (let ((gp-0 (lookup-gui-connection-id *gui-control* (the-as string #f) (gui-channel daxter) (gui-action none)))
            (s5-0 (current-time))
            )
        (while (or (nonzero? (get-status *gui-control* gp-0)) (not (time-elapsed? s5-0 (seconds 2))))
          (suspend)
          )
        )
      )
    (let* ((v1-12 (-> *game-info* sub-task-list (game-task-node city-power-game-resolution)))
           (gp-1 (if (-> v1-12 manager)
                     (-> v1-12 manager manager)
                     (the-as handle #f)
                     )
                 )
           )
      (cond
        ((handle->process gp-1)
         (send-event (handle->process gp-1) 'fail)
         (while (handle->process gp-1)
           (suspend)
           )
         )
        (else
          (auto-save-user)
          (ja-channel-set! 0)
          (ja-post)
          (set-blackout-frames (seconds 0.2))
          )
        )
      )
    )
  :post (behavior ()
    (update-score-text self)
    (ja-post)
    )
  )

(defstate win (power-game)
  :virtual #t
  :exit (-> (method-of-type power-game active) exit)
  :code (behavior ((arg0 symbol))
    (dotimes (s5-0 5)
      (if (-> self zapper s5-0)
          (send-event (handle->process (-> self zapper s5-0)) 'die)
          )
      )
    (when (not arg0)
      (let ((v1-16 (set-last-speech self 2 5)))
        (cond
          ((zero? v1-16)
           (talker-spawn-func (-> *power-game-speech-list* 25) *entity-pool* (target-pos 0) (the-as region #f))
           )
          ((= v1-16 1)
           (talker-spawn-func (-> *power-game-speech-list* 26) *entity-pool* (target-pos 0) (the-as region #f))
           )
          ((= v1-16 2)
           (talker-spawn-func (-> *power-game-speech-list* 27) *entity-pool* (target-pos 0) (the-as region #f))
           )
          ((= v1-16 3)
           (talker-spawn-func (-> *power-game-speech-list* 28) *entity-pool* (target-pos 0) (the-as region #f))
           )
          (else
            (talker-spawn-func (-> *power-game-speech-list* 29) *entity-pool* (target-pos 0) (the-as region #f))
            )
          )
        )
      (let ((gp-6 (lookup-gui-connection-id *gui-control* (the-as string #f) (gui-channel daxter) (gui-action none)))
            (s5-6 (current-time))
            )
        (while (or (nonzero? (get-status *gui-control* gp-6)) (not (time-elapsed? s5-6 (seconds 2))))
          (suspend)
          )
        )
      )
    (let* ((v1-38 (-> *game-info* sub-task-list (game-task-node city-power-game-resolution)))
           (gp-7 (if (-> v1-38 manager)
                     (-> v1-38 manager manager)
                     (the-as handle #f)
                     )
                 )
           )
      (send-event (handle->process gp-7) 'complete)
      (ja-channel-set! 0)
      (ja-post)
      (set-blackout-frames (seconds 0.2))
      (cond
        ((handle->process gp-7)
         )
        (else
          (auto-save-user)
          )
        )
      (while (handle->process gp-7)
        (suspend)
        )
      )
    )
  :post (-> (method-of-type power-game lose) post)
  )

(defmethod spawn-switcher ((this power-game))
  (cond
    ((handle->process (-> this switcher))
     (set-time! (-> this switcher-time))
     (if (-> this score-met)
         (send-event (handle->process (-> this switcher)) 'die)
         )
     )
    ((and (time-elapsed?
            (-> this switcher-time)
            (- (+ (the int (* 9000.0 (you-suck-scale *game-info* #f 175))) 3000) (min 1200 (* 150 (-> this difficulty))))
            )
          (not (-> this score-met))
          )
     (set! (-> this switcher) (ppointer->handle (process-spawn
                                                  power-game-switcher
                                                  :init power-game-switcher-init
                                                  (-> this center)
                                                  (-> this lentity)
                                                  (-> this player)
                                                  :name "power-game-switcher"
                                                  :to this
                                                  )
                                                )
           )
     )
    )
  0
  (none)
  )

(defbehavior cam-power-game-update power-game ()
  (when *power-game*
    (let ((s5-0 (-> *power-game* 0 cam-cur))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> gp-0 x) 0.0)
      (set! (-> gp-0 y) 0.0)
      (set! (-> gp-0 z) (-> *power-game* 0 cam-cur cam-dist))
      (set! (-> gp-0 w) 1.0)
      (let ((f30-0 (-> *power-game* 0 cam-cur cam-y-angle)))
        (vector-rotate-x! gp-0 gp-0 (- (-> *power-game* 0 cam-cur cam-pos-x-angle)))
        (vector-rotate-y! gp-0 gp-0 f30-0)
        (vector+! (the-as vector (&-> self root)) (the-as vector s5-0) gp-0)
        (set-vector! gp-0 0.0 0.0 1.0 1.0)
        (vector-rotate-x! gp-0 gp-0 (-> *power-game* 0 cam-cur cam-x-angle))
        (vector-rotate-y! gp-0 gp-0 (+ 32768.0 f30-0))
        )
      (forward-down->inv-matrix (the-as matrix (&-> self hud-score)) gp-0 (-> *camera* local-down))
      )
    )
  0
  (none)
  )

(defstate cam-power-game (camera-slave)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('teleport)
       #f
       )
      (else
        (cam-standard-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (camera-blend-from-type unknown-1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    )
  :code (behavior ()
    (until #f
      (if (not (paused?))
          ((the-as (function none) cam-power-game-update))
          )
      (suspend)
      )
    #f
    )
  )
