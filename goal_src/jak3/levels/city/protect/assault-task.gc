;;-*-Lisp-*-
(in-package goal)

;; name: assault-task.gc
;; name in dgo: assault-task
;; dgos: LCTYPALT

(declare-type assault-squad-control structure)
(define-extern *assault-squad* assault-squad-control)
(define-extern *port-assault-blur-curve* curve2d-piecewise)

;; DECOMP BEGINS

(deftype ammo-special-info (structure)
  ((ammo-type      int32)
   (gun-type       int32)
   (end-lock-time  time-frame)
   )
  )


(deftype task-manager-city-port-assault (task-manager)
  ((script-command           assault-cmd-context  :inline)
   (door-handle              handle)
   (current-room             assault-room)
   (current-room-index       int8)
   (h-player-controller      handle)
   (spawners                 assault-cmd-context  12 :inline)
   (original-cam-point       vector               :inline :offset 1296)
   (original-cam-quat        quaternion           :inline)
   (ammo-special             ammo-special-info    :inline)
   (torn-h                   handle)
   (next-powerup-spawn-time  time-frame)
   (final-bombbot?           symbol)
   (room-override-index      int8)
   (bombbot-dead?            symbol)
   (cam-pan-sound            sound-id)
   )
  (:state-methods
    transition
    combat
    player-entrance
    player-quickstart
    )
  (:methods
    (parse-cmd (_type_) none)
    (eval-cmd (_type_) symbol)
    (cmd-can-run? (_type_) symbol)
    (advance-script (_type_) none)
    (room-advance (_type_) none)
    (task-manager-city-port-assault-method-41 (_type_ assault-spawn-cmd assault-cmd-context) symbol)
    (spawn-special-pickup (_type_ pickup-type) none)
    (task-manager-city-port-assault-method-43 (_type_ int) int)
    (task-manager-city-port-assault-method-44 (_type_) object)
    (check-for-pickup-spawn (_type_) int)
    (set-next-powerup-spawn-time (_type_) none)
    (spawn-guards (_type_ int) symbol)
    (spawn-citizens (_type_ int) none)
    (task-manager-city-port-assault-method-49 (_type_ int) int)
    (pickup-spawn-chance (_type_ room-powerup-percentage int) float)
    (get-suck-level (_type_) int)
    (task-manager-city-port-assault-method-52 (_type_) none)
    )
  )


(deftype assault-player-controller (player-controller)
  ((collision  assault-room-collision)
   )
  (:methods
    (assault-player-controller-method-36 (_type_) none)
    )
  )


(deftype assault-squad-control (basic)
  ((door-index        int16)
   (spawn-records     (array proc-focusable-spawner))
   (next-spawn-index  int16)
   (door-pos          vector  :inline)
   )
  (:methods
    (init (_type_) none)
    (assault-squad-control-method-10 (_type_ int) int)
    (spawn-enemies (_type_ process) int)
    (init-spawn-records (_type_) symbol)
    (reset-enemies (_type_) none)
    )
  )


(defmethod reset-enemies ((this assault-squad-control))
  (dotimes (s5-0 (-> *assault-squad* spawn-records length))
    (reset-and-kill-all! (-> *assault-squad* spawn-records s5-0))
    )
  (set! (-> this next-spawn-index) 0)
  0
  (none)
  )

(defmethod spawn-enemies ((this assault-squad-control) (arg0 process))
  (cond
    (#f
      (kill-by-name "hip-door-a-6" *active-pool*)
      (kill-by-name "hip-door-a-1" *active-pool*)
      )
    (else
      (set-setting! 'airlock #f 0.0 0)
      )
    )
  (when (< (-> this next-spawn-index) (-> this spawn-records length))
    (dotimes (s4-0 (-> this spawn-records (-> this next-spawn-index) records length))
      (set! (-> this spawn-records (-> this next-spawn-index) records data s4-0 proc)
            (spawn-assault-enemy (the-as assault-target-type (-> this next-spawn-index)) arg0)
            )
      )
    (+! (-> this next-spawn-index) 1)
    (return 0)
    )
  (dotimes (s5-1 (-> this spawn-records length))
    (check-inactive (-> this spawn-records s5-1))
    )
  (the-as int #f)
  )

(defmethod init-spawn-records ((this assault-squad-control))
  (set! (-> this spawn-records) (new 'loading-level 'boxed-array proc-focusable-spawner 19))
  (dotimes (s5-0 19)
    (set! (-> this spawn-records s5-0) (new 'loading-level 'proc-focusable-spawner))
    (alloc-records! (-> this spawn-records s5-0) (-> *assault-object-count* s5-0) 'loading-level)
    )
  #f
  )

(defmethod init ((this assault-squad-control))
  (dotimes (s5-0 19)
    (init-records! (-> this spawn-records s5-0))
    )
  (set! (-> this next-spawn-index) 0)
  0
  (none)
  )

(when (or (zero? *port-assault-blur-curve*) (!= loading-level global))
  (set! *port-assault-blur-curve* (new 'loading-level 'curve2d-piecewise))
  (curve2d-piecewise-method-10 *port-assault-blur-curve* 4 'loading-level (the-as int #t))
  )

(set! (-> *port-assault-blur-curve* pts data 0 first) 0.0)

(set! (-> *port-assault-blur-curve* pts data 0 second) 1.0)

(set! (-> *port-assault-blur-curve* pts data 1 first) 0.25)

(set! (-> *port-assault-blur-curve* pts data 1 second) 0.3)

(set! (-> *port-assault-blur-curve* pts data 2 first) 0.75)

(set! (-> *port-assault-blur-curve* pts data 2 second) 0.3)

(set! (-> *port-assault-blur-curve* pts data 3 first) 1.0)

(set! (-> *port-assault-blur-curve* pts data 3 second) 1.0)

;; WARN: Return type mismatch matrix vs none.
(defmethod task-manager-city-port-assault-method-52 ((this task-manager-city-port-assault))
  (let ((s5-0 *camera*)
        (f0-1 (* 0.0011111111 (the float (- (current-time) (-> this state-time)))))
        )
    0.0
    0.0
    (let* ((f30-0 (- 1.0 (* (- 1.0 f0-1) (- 1.0 f0-1))))
           (f0-2 (sin (lerp -16384.0 16384.0 f0-1)))
           (f0-3 (+ 1.0 f0-2))
           (f0-4 (* 0.5 f0-3))
           )
      (set! (-> *display* force-sync) (the-as uint 2))
      (when s5-0
        (let ((s5-1 (-> s5-0 slave)))
          (when s5-1
            (vector-lerp! (-> s5-1 0 saved-pt) (-> this original-cam-point) (-> this current-room cam-info pos) f0-4)
            (let ((s4-1 (matrix->quaternion (new 'stack-no-clear 'quaternion) (-> this current-room cam-info mat))))
              (let ((s3-0 (new 'stack-no-clear 'quaternion)))
                (let ((s2-1
                        (vector-! (new 'stack-no-clear 'vector) (-> this current-room cam-info pos) (-> this original-cam-point))
                        )
                      )
                  (let ((a0-8 s2-1))
                    (set! (-> a0-8 quad) (-> s2-1 quad))
                    (set! (-> a0-8 y) 0.0)
                    (vector-normalize! a0-8 1.0)
                    )
                  (if (< (vector-dot s2-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this original-cam-quat))) 0.0)
                      (vector-float*! s2-1 s2-1 -1.0)
                      )
                  (quaternion-look-at! s3-0 s2-1 *up-vector*)
                  )
                (let ((f0-9 0.7))
                  (cond
                    ((< f30-0 f0-9)
                     (quaternion-slerp! s4-1 (-> this original-cam-quat) s3-0 (/ f30-0 f0-9))
                     )
                    ((< (- 1.0 f0-9) f30-0)
                     (let* ((f0-12 (/ (- f30-0 f0-9) (- 1.0 f0-9)))
                            (f0-13 (* f0-12 f0-12))
                            )
                       (quaternion-slerp! s4-1 s3-0 s4-1 f0-13)
                       )
                     )
                    (else
                      (quaternion-copy! s4-1 s3-0)
                      )
                    )
                  )
                )
              (quaternion->matrix (the-as matrix (-> s5-1 0 tracking)) s4-1)
              )
            )
          )
        )
      )
    )
  (none)
  )

(defstate transition (task-manager-city-port-assault)
  :virtual #t
  :event task-manager-event-handler
  :enter (behavior ()
    (case (get-status *gui-control* (-> self cam-pan-sound))
      (((gui-status ready))
       (set-action!
         *gui-control*
         (gui-action play)
         (-> self cam-pan-sound)
         (gui-channel none)
         (gui-action none)
         (the-as string #f)
         (the-as (function gui-connection symbol) #f)
         (the-as process #f)
         )
       )
      (else
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self cam-pan-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
      )
    (set-time! (-> self state-time))
    (set-setting! 'blur-a 'abs 0.5 0)
    (let ((v1-10 *camera*))
      (when v1-10
        (let ((v1-11 (-> v1-10 slave)))
          (when v1-11
            (set! (-> self original-cam-point quad) (-> v1-11 0 saved-pt quad))
            (matrix->quaternion (-> self original-cam-quat) (the-as matrix (-> v1-11 0 tracking)))
            )
          )
        )
      )
    (let ((v1-13 (new 'stack-no-clear 'player-controller-init-params)))
      (set! (-> v1-13 mode) 'lock)
      (set! (-> v1-13 flags) (player-controller-flag pc1 lock-features letterbox pc4))
      (logclear! (-> v1-13 flags) (player-controller-flag lock-features))
      (send-event (handle->process (-> self h-player-controller)) 'set-params v1-13)
      )
    )
  :exit (behavior ()
    (set-setting! 'blur-a 'abs 0.0 0)
    )
  :trans (behavior ()
    ((-> (method-of-type task-manager active) trans))
    (task-manager-city-port-assault-method-52 self)
    (if (time-elapsed? (-> self state-time) (seconds 3))
        (go-virtual player-entrance)
        )
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 0.5))
        (suspend)
        )
      )
    (send-event self 'ammo-special 15 29)
    (sleep-code)
    )
  )

(defstate player-quickstart (task-manager-city-port-assault)
  :virtual #t
  :event task-manager-event-handler
  :trans (behavior ()
    ((-> (method-of-type task-manager active) trans))
    )
  :code (behavior ()
    (set-setting! 'interp-time 'abs 0.0 0)
    (if *target*
        (logior! (-> *target* focus-status) (focus-status teleporting))
        )
    (let ((a0-4 *camera*))
      (when a0-4
        (let ((a0-5 (-> a0-4 slave)))
          (when a0-5
            (set! (-> a0-5 0 saved-pt quad) (-> self current-room cam-info pos quad))
            (let* ((v1-11 (-> a0-5 0 tracking))
                   (a3-1 (-> self current-room cam-info mat))
                   (a0-8 (-> a3-1 rvec quad))
                   (a1-5 (-> a3-1 uvec quad))
                   (a2-1 (-> a3-1 fvec quad))
                   (a3-2 (-> a3-1 trans quad))
                   )
              (set! (-> v1-11 inv-mat rvec quad) a0-8)
              (set! (-> v1-11 inv-mat uvec quad) a1-5)
              (set! (-> v1-11 inv-mat fvec quad) a2-1)
              (set! (-> v1-11 inv-mat trans quad) a3-2)
              )
            )
          )
        )
      )
    (when *target*
      (move-to-point! (-> *target* control) (-> self current-room center-pos))
      (process-drawable-reset-all-cloth *target*)
      )
    (suspend)
    (if *target*
        (logclear! (-> *target* focus-status) (focus-status teleporting))
        )
    (remove-setting! 'interp-time)
    (go-virtual combat)
    )
  )

(defstate player-entrance (task-manager-city-port-assault)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('reached-destination)
       (if (and *target* (focus-test? *target* board))
           (send-event *target* 'change-mode 'normal)
           )
       (go-virtual combat)
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-blackout-frames 0)
    (until (process-release? *target*)
      (suspend)
      )
    (set-time! (-> self state-time))
    (set! (-> *display* force-sync) (the-as uint 20))
    (when *target*
      (logior! (-> *target* focus-status) (focus-status teleporting))
      (process-drawable-show-all-cloth *target* #f)
      (logior! (-> *target* draw status) (draw-control-status no-draw))
      (if (and (< 1 (-> self current-room-index))
               (not (logtest? (-> self current-room-index) 1))
               (!= (-> self current-room-index) 4)
               )
          (send-event *target* 'change-mode 'board #f)
          )
      (let ((f30-0 40960000000.0)
            (gp-0 0)
            )
        (dotimes (s5-0 (-> self current-room node-positions length))
          (let ((f0-0 (vector-vector-xz-distance (target-pos 0) (-> self current-room node-positions s5-0))))
            (when (< f0-0 f30-0)
              (set! f30-0 f0-0)
              (set! gp-0 s5-0)
              )
            )
          )
        (let ((a1-5 (new 'stack-no-clear 'vector)))
          (set! (-> a1-5 quad) (-> self current-room node-positions gp-0 quad))
          (move-to-point! (-> *target* control) a1-5)
          )
        )
      )
    (let ((v1-40 *camera*))
      (when v1-40
        (let ((v1-41 (-> v1-40 slave)))
          (when v1-41
            (set! (-> v1-41 0 saved-pt quad) (-> self current-room cam-info pos quad))
            (let* ((v0-9 (-> v1-41 0 tracking))
                   (a2-0 (-> self current-room cam-info mat))
                   (v1-45 (-> a2-0 rvec quad))
                   (a0-20 (-> a2-0 uvec quad))
                   (a1-10 (-> a2-0 fvec quad))
                   (a2-1 (-> a2-0 trans quad))
                   )
              (set! (-> v0-9 inv-mat rvec quad) v1-45)
              (set! (-> v0-9 inv-mat uvec quad) a0-20)
              (set! (-> v0-9 inv-mat fvec quad) a1-10)
              (set! (-> v0-9 inv-mat trans quad) a2-1)
              )
            )
          )
        )
      )
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    ((-> (method-of-type task-manager active) trans))
    )
  :code (behavior ()
    (suspend)
    (when *target*
      (process-drawable-show-all-cloth *target* #t)
      (logclear! (-> *target* draw status) (draw-control-status no-draw))
      )
    (suspend)
    (let ((v1-4 (new 'stack-no-clear 'player-controller-init-params)))
      (set! (-> v1-4 mode) 'active)
      (set! (-> v1-4 flags) (player-controller-flag pc1 lock-features letterbox pc4))
      (set! (-> v1-4 targ-pos quad) (-> self current-room center-pos quad))
      (logclear! (-> v1-4 flags) (player-controller-flag lock-features))
      (set! (-> v1-4 notify-proc) (process->handle self))
      (send-event (handle->process (-> self h-player-controller)) 'set-params v1-4)
      )
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 0.1))
        (suspend)
        )
      )
    (if *target*
        (logclear! (-> *target* focus-status) (focus-status teleporting))
        )
    (sleep-code)
    )
  )

(defstate combat (task-manager-city-port-assault)
  :virtual #t
  :event task-manager-event-handler
  :enter (behavior ()
    (set-setting! 'board #f 0.0 0)
    (set-blackout-frames 0)
    (let ((v1-2 (new 'stack-no-clear 'player-controller-init-params)))
      (set! (-> v1-2 mode) 'active)
      (set! (-> v1-2 flags) (player-controller-flag pc1 lock-features letterbox pc4))
      (set! (-> v1-2 mode) 'clip-to-nav-mesh)
      (logclear! (-> v1-2 flags) (player-controller-flag lock-features))
      (let ((a0-8 (the-as assault-player-controller (handle->process (-> self h-player-controller)))))
        (if a0-8
            (set! (-> a0-8 collision) (-> self current-room collision))
            )
        )
      (send-event (handle->process (-> self h-player-controller)) 'set-params v1-2)
      )
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (remove-setting! 'board)
    (apply-settings *setting-control*)
    )
  :trans (behavior ()
    ((-> (method-of-type task-manager active) trans))
    (check-for-pickup-spawn self)
    (if (and (time-elapsed? (-> self state-time) (seconds 2))
             (= (-> *room-goal* (-> self current-room-index)) 1)
             (<= (task-manager-city-port-assault-method-49 self 2) 0)
             )
        (send-event self 'fail)
        )
    (if (and (time-elapsed? (-> self state-time) (seconds 2))
             (= (-> *room-goal* (-> self current-room-index)) 2)
             (let ((v1-28 (-> *assault-squad* spawn-records 1)))
               0
               (<= (- (-> v1-28 unused-list allocated-length) (-> v1-28 unused-list length)) 0)
               )
             )
        (send-event self 'fail)
        )
    (task-manager-city-port-assault-method-44 self)
    (spawn-enemies *assault-squad* self)
    (dotimes (gp-0 (-> self current-room node-positions length))
      (task-manager-city-port-assault-method-43 self gp-0)
      )
    (let ((v1-47 *camera*))
      (when v1-47
        (let ((v1-48 (-> v1-47 slave)))
          (when v1-48
            (set! (-> v1-48 0 saved-pt quad) (-> self current-room cam-info pos quad))
            (let* ((v0-10 (-> v1-48 0 tracking))
                   (a2-0 (-> self current-room cam-info mat))
                   (v1-52 (-> a2-0 rvec quad))
                   (a0-22 (-> a2-0 uvec quad))
                   (a1-9 (-> a2-0 fvec quad))
                   (a2-1 (-> a2-0 trans quad))
                   )
              (set! (-> v0-10 inv-mat rvec quad) v1-52)
              (set! (-> v0-10 inv-mat uvec quad) a0-22)
              (set! (-> v0-10 inv-mat fvec quad) a1-9)
              (set! (-> v0-10 inv-mat trans quad) a2-1)
              )
            )
          )
        )
      )
    )
  :code (behavior ()
    (until (process-release? *target*)
      (suspend)
      )
    (until #f
      (until (cmd-can-run? self)
        (when (not (eval-cmd self))
          0
          (goto cfg-7)
          )
        (suspend)
        )
      (advance-script self)
      (parse-cmd self)
      )
    #f
    (label cfg-7)
    (send-event self 'complete)
    (sleep-code)
    )
  )

(defun compute-player-ammo ((arg0 pickup-type))
  (case arg0
    (((pickup-type gun-red-1))
     10.0
     )
    (((pickup-type gun-red-2))
     20.0
     )
    (((pickup-type gun-red-3))
     30.0
     )
    (((pickup-type gun-yellow-1))
     200.0
     )
    (((pickup-type gun-yellow-2))
     30.0
     )
    (((pickup-type gun-yellow-3))
     50.0
     )
    (((pickup-type gun-blue-1))
     40.0
     )
    (((pickup-type gun-blue-2))
     50.0
     )
    (((pickup-type gun-blue-3))
     60.0
     )
    (((pickup-type gun-dark-1))
     5.0
     )
    (((pickup-type gun-dark-2))
     0.0
     )
    (((pickup-type gun-dark-3))
     0.0
     )
    (else
      0.0
      )
    )
  )

;; WARN: disable def twice: 36. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 106. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod taskman-event-handler ((this task-manager-city-port-assault) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-2 object))
  (case arg2
    (('restart)
     (let ((v1-2 (task-perm-by-index *game-info* 46)))
       (logior! (-> v1-2 status) (entity-perm-status bit-5))
       (set! (-> v1-2 user-uint64) (the-as uint 0))
       (logior! (-> v1-2 status) (entity-perm-status bit-14))
       )
     (call-parent-method this arg0 arg1 arg2 arg3)
     )
    (('bombbot-death)
     (when (-> this final-bombbot?)
       (set! v0-2 #t)
       (set! (-> this bombbot-dead?) (the-as symbol v0-2))
       v0-2
       )
     )
    (('ammo-special)
     (set! (-> this ammo-special ammo-type) (the-as int (-> arg3 param 0)))
     (set! (-> this ammo-special gun-type) (the-as int (-> arg3 param 1)))
     (if (!= (-> this ammo-special gun-type) 29)
         (speech-play *port-assault-speech* 8 *assault-speech-list* (target-pos 0))
         )
     (let ((s5-2 (new 'static 'boxed-array :type int32 15 16 17 18)))
       (dotimes (s4-2 (-> s5-2 length))
         (adjust-player-ammo -500.0 (the-as pickup-type (-> s5-2 s4-2)))
         )
       )
     (adjust-player-ammo
       (compute-player-ammo (the-as pickup-type (-> this ammo-special gun-type)))
       (the-as pickup-type (-> this ammo-special ammo-type))
       )
     (let ((t1-0 (logclear
                   (game-feature
                     gun-red-1
                     gun-red-2
                     gun-red-3
                     gun-yellow-1
                     gun-yellow-2
                     gun-yellow-3
                     gun-blue-1
                     gun-blue-2
                     gun-blue-3
                     gun-dark-1
                     gun-dark-2
                     gun-dark-3
                     )
                   (gun-pickup-type->game-feature (the-as pickup-type (-> this ammo-special gun-type)))
                   )
                 )
           )
       (set-setting! 'features 'clear (shr (the-as int t1-0) 32) t1-0)
       )
     (apply-settings *setting-control*)
     (when *target*
       (if (= (-> this ammo-special ammo-type) 7)
           (send-event *target* 'change-mode 'darkjak #f (darkjak-stage active))
           (send-event *target* 'change-mode 'gun #f (-> this ammo-special gun-type))
           )
       (cond
         ((= (-> this ammo-special gun-type) 29)
          (set! (-> this ammo-special end-lock-time) 0)
          (set! v0-2 (logior (target-flags tf16) (-> *target* target-flags)))
          (set! (-> *target* target-flags) (the-as target-flags v0-2))
          )
         (else
           (logclear! (-> *target* target-flags) (target-flags tf16))
           (set! v0-2 (current-time))
           (set! (-> this ammo-special end-lock-time) (the-as time-frame v0-2))
           )
         )
       v0-2
       )
     )
    (else
      (call-parent-method this arg0 arg1 arg2 arg3)
      )
    )
  )

(defstate active (task-manager-city-port-assault)
  :virtual #t
  :enter (behavior ()
    (set! (-> self room-override-index) (the-as int (-> (task-perm-by-index *game-info* 46) user-uint64)))
    (speeches-reset *port-assault-speech*)
    (set-setting! 'allow-look-around #f 0.0 0)
    (set-setting! 'gem-seek-target-dir? #t 0.0 0)
    (set-setting! 'disable-parking-spots? #t 0.0 0)
    (set! (-> *game-info* eco-pill-light) 0.0)
    (set-setting! 'pilot #f 0.0 0)
    (set-setting! 'hide-crates? #t 0.0 0)
    (set-setting! 'sound-ear-scale 'abs 0.25 0)
    (set! (-> self bombbot-dead?) #f)
    (set! (-> self final-bombbot?) #f)
    (set-setting! 'city-sound '(citymhf citykgf citypedh cityffh) 0.0 2)
    (send-event (ppointer->process *time-of-day*) 'change 'ratio 0.0)
    (set-setting! 'rain 'abs 0.0 0)
    (set-setting! 'music 'portattk 0.0 0)
    (set-setting! 'exclusive-load '((ignore all)) 0.0 0)
    (set-setting! 'gun-special-mode #t 0.0 0)
    (set-setting! 'calm #f 0.0 0)
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (send-event self 'ammo-special 15 29)
    (set-setting! 'exclusive-task #f 0.0 (-> self node-info task))
    (set! (-> self h-player-controller) (the-as handle #f))
    (set-setting! 'gun-target-guards? #f 0.0 0)
    (reset-hatred *cty-attack-controller*)
    (init *assault-squad*)
    (init-attack-controller *cty-attack-controller*)
    (set! (-> *cty-attack-controller* target-attacker max-num-attackers) (the-as uint 127))
    (set! (-> self h-player-controller) (the-as handle #f))
    (let ((gp-0 (new 'static 'boxed-array :type uint16 #x3 #x4 #x5)))
      (dotimes (s5-0 (-> gp-0 length))
        (dotimes (s4-0 19)
          (let ((v1-56 (get-hatred-at-idx *cty-attack-controller* s5-0 s4-0)))
            (if (nonzero? (-> v1-56 index))
                (set! (-> v1-56 max-consider-dist) 102400.0)
                )
            )
          )
        )
      )
    (set! (-> self torn-h) (the-as handle #f))
    (let ((gp-1 (push-back-hatred *cty-attack-controller*))
          (a2-17 (get-hatred-at-idx *cty-attack-controller* 9 0))
          )
      (set! (-> gp-1 hatred) (-> a2-17 hatred))
      (set! (-> gp-1 max-consider-dist) (-> a2-17 max-consider-dist))
      (set! (-> gp-1 hatred-dist) (-> a2-17 hatred-dist))
      (set! (-> gp-1 dist-scale) (-> a2-17 dist-scale))
      (set! (-> gp-1 attacker-scale) (-> a2-17 attacker-scale))
      (set-hatred-indices-for-all *cty-attack-controller* 0 a2-17 gp-1 14)
      )
    (let ((gp-2 (push-back-hatred *cty-attack-controller*)))
      (set! (-> gp-2 hatred) 0.8)
      (set! (-> gp-2 max-consider-dist) 245760.0)
      (set! (-> gp-2 hatred-dist) 245760.0)
      (set! (-> gp-2 dist-scale) 0.1)
      (set! (-> gp-2 attacker-scale) 1.0)
      (set-hatred-indices *cty-attack-controller* gp-2 4 13)
      (set-hatred-indices *cty-attack-controller* gp-2 3 13)
      (set-hatred-indices *cty-attack-controller* gp-2 5 13)
      )
    (let ((v1-79 (get-hatred-at-idx *cty-attack-controller* 9 1)))
      (set! (-> v1-79 hatred) 1.5)
      (set! (-> v1-79 attacker-scale) 0.0)
      )
    )
  :trans (behavior ()
    (let ((t9-1 (-> (find-parent-state) trans)))
      (if t9-1
          (t9-1)
          )
      )
    (spawn-enemies *assault-squad* self)
    )
  :code (behavior ()
    (while (< (-> *assault-squad* next-spawn-index) (-> *assault-squad* spawn-records length))
      (suspend)
      )
    (set! (-> self current-room-index) -1)
    (let ((gp-0 (new 'stack-no-clear 'player-controller-init-params)))
      (set! (-> gp-0 mode) 'active)
      (set! (-> gp-0 flags) (player-controller-flag pc1 lock-features letterbox pc4))
      (set! (-> gp-0 mode) 'clip-to-nav-mesh)
      (logclear! (-> gp-0 flags) (player-controller-flag lock-features))
      (set! (-> self h-player-controller) (ppointer->handle (process-spawn
                                                              assault-player-controller
                                                              :init player-controller-init-by-other
                                                              gp-0
                                                              :name "assault-player-controller"
                                                              :to self
                                                              )
                                                            )
            )
      )
    (room-advance self)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defun lctypalt-login ((arg0 level))
  (set! *assault-squad* (new 'loading-level 'assault-squad-control))
  (init-spawn-records *assault-squad*)
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun lctypalt-logout ((arg0 level))
  (set! *assault-squad* #f)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod advance-script ((this task-manager-city-port-assault))
  (set! (-> this script-command script) (the-as pair (-> this script-command script cdr)))
  (none)
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod parse-cmd ((this task-manager-city-port-assault))
  (format 0 "Parsing command ~s~%" (-> this script-command script car))
  (parse-assault-command
    (the-as pair (-> this script-command script car))
    (-> this script-command current-command)
    )
  (set-time! (-> this script-command start-time))
  (set! (-> this script-command state-time)
        (- (current-time) (-> this script-command current-command spawn-delay))
        )
  (none)
  )

(defmethod task-manager-city-port-assault-method-43 ((this task-manager-city-port-assault) (arg0 int))
  (when (and (-> this final-bombbot?) (-> this bombbot-dead?))
    (set! (-> this spawners arg0 current-command count) 0)
    (return 0)
    )
  (let ((s4-0 (the-as assault-spawn-cmd (+ (the-as uint (-> this spawners 0 current-command)) (* 80 arg0)))))
    (set! (-> s4-0 spawner-index) arg0)
    (when (> (-> s4-0 count) 0)
      (when (time-elapsed? (-> this spawners arg0 state-time) (-> s4-0 spawn-delay))
        (when (or (task-manager-city-port-assault-method-41 this s4-0 (-> this spawners arg0))
                  (= (-> s4-0 spawn-type) (assault-cmd-spawn-type cmd3))
                  (= (-> s4-0 spawn-type) (assault-cmd-spawn-type cmd4))
                  (= (-> s4-0 spawn-type) (assault-cmd-spawn-type cmd5))
                  (-> *setting-control* user-current nuke-active?)
                  )
          (set-time! (-> this spawners arg0 state-time))
          (let ((v0-0 (+ (-> s4-0 count) -1)))
            (set! (-> s4-0 count) v0-0)
            v0-0
            )
          )
        )
      )
    )
  )

(defmethod eval-cmd ((this task-manager-city-port-assault))
  (let ((s5-0 (-> this script-command current-command)))
    (case (-> s5-0 command)
      (((assault-cmd queue))
       (set! (-> this cam-pan-sound)
             (add-process *gui-control* this (gui-channel background) (gui-action queue) "cam-pan" -99.0 0)
             )
       )
      (((assault-cmd other))
       (return #f)
       )
      (((assault-cmd torn))
       (send-event
         (handle->process (-> this torn-h))
         (-> s5-0 msg)
         (-> s5-0 event0)
         (-> s5-0 event1)
         (-> s5-0 event2)
         )
       )
      (((assault-cmd final-bombbot))
       (set! (-> this final-bombbot?) #t)
       )
      (((assault-cmd load-continue))
       (set! (-> this room-override-index) (the-as int (-> (task-perm-by-index *game-info* 46) user-uint64)))
       (if (!= (-> this room-override-index) (-> this current-room-index))
           (room-advance this)
           )
       )
      (((assault-cmd save-continue))
       (let ((v1-18 (task-perm-by-index *game-info* 46)))
         (logior! (-> v1-18 status) (entity-perm-status bit-5))
         (set! (-> v1-18 user-uint64) (the-as uint (-> this current-room-index)))
         (logior! (-> v1-18 status) (entity-perm-status bit-14))
         )
       )
      (((assault-cmd advance))
       (room-advance this)
       )
      (((assault-cmd pickup))
       (spawn-special-pickup this (the-as pickup-type (-> s5-0 gun-pickup-type)))
       )
      (((assault-cmd spawn))
       (let ((v1-21 (-> s5-0 spawner-index)))
         (when (= v1-21 -1)
           (let ((a1-5 (current-time)))
             (set! v1-21 -1)
             (let ((a0-44 -1))
               (dotimes (a2-2 (-> this current-room node-positions length))
                 (let ((a3-4 (-> this spawners a2-2)))
                   (when (zero? (-> a3-4 current-command count))
                     (set! a0-44 a2-2)
                     (when (< (-> a3-4 state-time) a1-5)
                       (set! a1-5 (-> a3-4 state-time))
                       (set! v1-21 a2-2)
                       )
                     )
                   )
                 )
               (if (= v1-21 -1)
                   (set! v1-21 a0-44)
                   )
               )
             )
           (set! (-> s5-0 spawner-index) v1-21)
           )
         (when (and (< -1 v1-21) (zero? (-> this spawners v1-21 current-command count)))
           (mem-copy! (the-as pointer (-> this spawners v1-21)) (the-as pointer (-> this script-command)) 72)
           (set! (-> s5-0 count) 0)
           0
           )
         )
       )
      )
    )
  #t
  )

(defmethod cmd-can-run? ((this task-manager-city-port-assault))
  (let ((gp-0 (-> this script-command current-command)))
    (case (-> gp-0 command)
      (((assault-cmd spawn))
       (zero? (-> gp-0 count))
       )
      (((assault-cmd torn))
       #t
       )
      (((assault-cmd speech))
       #t
       )
      (((assault-cmd queue))
       #t
       )
      (((assault-cmd final-bombbot))
       #t
       )
      (((assault-cmd pickup))
       #t
       )
      (((assault-cmd advance))
       #f
       )
      (((assault-cmd other))
       #f
       )
      (((assault-cmd load-continue) (assault-cmd save-continue))
       #t
       )
      (((assault-cmd wait))
       (case (-> gp-0 wait-type)
         (((assault-cmd-wait-type spawn-delay))
          (time-elapsed? (-> this script-command start-time) (-> gp-0 spawn-delay))
          )
         (((assault-cmd-wait-type cmd2))
          (let ((v1-9 (+ (task-manager-city-port-assault-method-49 this 1) (task-manager-city-port-assault-method-49 this 3)))
                )
            (>= (-> gp-0 count) v1-9)
            )
          )
         (((assault-cmd-wait-type cmd1))
          (>= (-> gp-0 count) (task-manager-city-port-assault-method-49 this (the-as int (-> gp-0 faction-type))))
          )
         )
       )
      )
    )
  )

(defmethod task-manager-city-port-assault-method-49 ((this task-manager-city-port-assault) (arg0 int))
  0
  (let ((v0-0 (assault-squad-control-method-10 *assault-squad* arg0)))
    (dotimes (v1-2 12)
      (if (= (-> *assault-faction-lookup* (-> this spawners v1-2 current-command spawn-type)) arg0)
          (+! v0-0 (-> this spawners v1-2 current-command count))
          )
      )
    v0-0
    )
  )

(defmethod assault-squad-control-method-10 ((this assault-squad-control) (arg0 int))
  (let ((v0-0 0))
    (dotimes (v1-0 (-> this spawn-records length))
      (if (= (-> *assault-faction-lookup* v1-0) arg0)
          (+! v0-0
              (- (-> this spawn-records v1-0 unused-list allocated-length) (-> this spawn-records v1-0 unused-list length))
              )
          )
      )
    v0-0
    )
  )

(defmethod spawn-guards ((this task-manager-city-port-assault) (arg0 int))
  (local-vars (sv-848 vector) (sv-864 vector) (sv-880 assault-object-spawn-params))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> *x-vector* quad))
      (let ((s3-0 (new 'stack-no-clear 'vector))
            (f30-0 (/ 65536.0 (the float arg0)))
            (s2-0 (new 'stack-no-clear 'vector))
            )
        (dotimes (s1-0 arg0)
          (let ((s0-0 s3-0))
            (set! sv-848 (-> this current-room center-pos))
            (set! sv-864 s4-0)
            (let* ((f28-0 24576.0)
                   (f26-0 0.0)
                   (v1-6 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                   (v1-7 (the-as number (logior #x3f800000 v1-6)))
                   (f0-5 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-7)))))
                   )
              (.lvf vf2 (&-> sv-864 quad))
              (.lvf vf1 (&-> sv-848 quad))
              (let ((v1-11 f0-5))
                (.mov vf3 v1-11)
                )
              )
            (.add.x.vf vf4 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf2 vf3)
            (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
            (.svf (&-> s0-0 quad) vf4)
            )
          (let ((v1-12 (new 'stack-no-clear 'vector))
                (s0-1 (new 'stack-no-clear 'collide-query))
                )
            (set! (-> v1-12 quad) (-> s3-0 quad))
            (vector+float*! (-> s0-1 start-pos) s3-0 *up-vector* 24576.0)
            (set! (-> s0-1 move-dist quad) (the-as uint128 0))
            (set! (-> s0-1 move-dist y) -49152.0)
            (let ((v1-17 s0-1))
              (set! (-> v1-17 radius) 409.6)
              (set! (-> v1-17 collide-with) (collide-spec backgnd))
              (set! (-> v1-17 ignore-process0) #f)
              (set! (-> v1-17 ignore-process1) #f)
              (set! (-> v1-17 ignore-pat)
                    (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                    )
              (set! (-> v1-17 action-mask) (collide-action solid))
              )
            (if (>= (fill-and-probe-using-line-sphere *collide-cache* s0-1) 0.0)
                (set! (-> s3-0 quad) (-> s0-1 best-other-tri intersect quad))
                )
            )
          (vector-! s2-0 s3-0 (-> this current-room center-pos))
          (set! (-> s2-0 y) 0.0)
          (vector-normalize! s2-0 1.0)
          (let ((s0-2 (get-last-unused-handle! (-> *assault-squad* spawn-records 3))))
            (when (handle->process s0-2)
              (set! sv-880 (new 'stack 'assault-object-spawn-params))
              (set! (-> sv-880 flags) (traffic-spawn-flags))
              (set! (-> sv-880 position quad) (-> s3-0 quad))
              (set! (-> sv-880 behavior) (the-as uint 2))
              (set! (-> sv-880 flags) (traffic-spawn-flags))
              (set! (-> sv-880 suck-level) (get-suck-level this))
              (set! (-> sv-880 user-data) (the-as uint (-> this current-room center-pos)))
              (logior! (-> sv-880 flags) (traffic-spawn-flags tsf7))
              (set! (-> sv-880 velocity quad) (the-as uint128 0))
              (quaternion-identity! (-> sv-880 rotation))
              (quaternion-look-at! (-> sv-880 rotation) s2-0 *up-vector*)
              (set! (-> sv-880 nav-mesh) (find-nearest-nav-mesh (-> sv-880 position) (the-as float #x7f800000)))
              (set! (-> sv-880 nav-branch) #f)
              (set! (-> sv-880 guard-type) (the-as uint 1))
              (send-event (handle->process s0-2) 'traffic-activate sv-880 *traffic-engine*)
              )
            )
          (vector-rotate-around-y! s4-0 s4-0 f30-0)
          )
        )
      )
    #f
    )
  )

(defmethod spawn-citizens ((this task-manager-city-port-assault) (arg0 int))
  (local-vars
    (v1-65 int)
    (sv-848 vector)
    (sv-864 vector)
    (sv-880 assault-object-spawn-params)
    (sv-896 (function quaternion quaternion float quaternion))
    (sv-912 quaternion)
    (sv-928 quaternion)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> *x-vector* quad))
      (let ((s3-0 (new 'stack-no-clear 'vector))
            (f30-0 (/ 65536.0 (the float arg0)))
            (s2-0 (new 'stack-no-clear 'vector))
            )
        (dotimes (s1-0 arg0)
          (let ((s0-0 s3-0))
            (set! sv-848 (-> this current-room center-pos))
            (set! sv-864 s4-0)
            (let* ((f28-0 10240.0)
                   (f26-0 47104.0)
                   (v1-7 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                   (v1-8 (the-as number (logior #x3f800000 v1-7)))
                   (f0-5 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-8)))))
                   )
              (.lvf vf2 (&-> sv-864 quad))
              (.lvf vf1 (&-> sv-848 quad))
              (let ((v1-12 f0-5))
                (.mov vf3 v1-12)
                )
              )
            (.add.x.vf vf4 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf2 vf3)
            (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
            (.svf (&-> s0-0 quad) vf4)
            )
          (let ((v1-13 (new 'stack-no-clear 'vector))
                (s0-1 (new 'stack-no-clear 'collide-query))
                )
            (set! (-> v1-13 quad) (-> s3-0 quad))
            (vector+float*! (-> s0-1 start-pos) s3-0 *up-vector* 24576.0)
            (set! (-> s0-1 move-dist quad) (the-as uint128 0))
            (set! (-> s0-1 move-dist y) -49152.0)
            (let ((v1-18 s0-1))
              (set! (-> v1-18 radius) 409.6)
              (set! (-> v1-18 collide-with) (collide-spec backgnd))
              (set! (-> v1-18 ignore-process0) #f)
              (set! (-> v1-18 ignore-process1) #f)
              (set! (-> v1-18 ignore-pat)
                    (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                    )
              (set! (-> v1-18 action-mask) (collide-action solid))
              )
            (if (>= (fill-and-probe-using-line-sphere *collide-cache* s0-1) 0.0)
                (set! (-> s3-0 quad) (-> s0-1 best-other-tri intersect quad))
                )
            )
          (vector-! s2-0 s3-0 (-> this current-room center-pos))
          (set! (-> s2-0 y) 0.0)
          (vector-normalize! s2-0 1.0)
          (let ((s0-2 (get-last-unused-handle! (-> *assault-squad* spawn-records 1))))
            (when (handle->process s0-2)
              (set! sv-880 (new 'stack 'assault-object-spawn-params))
              (set! (-> sv-880 flags) (traffic-spawn-flags))
              (set! (-> sv-880 position quad) (-> s3-0 quad))
              (set! (-> sv-880 behavior) (the-as uint 2))
              (set! (-> sv-880 flags) (traffic-spawn-flags))
              (set! (-> sv-880 suck-level) (get-suck-level this))
              (set! (-> sv-880 user-data) (the-as uint (-> this current-room center-pos)))
              (logior! (-> sv-880 flags) (traffic-spawn-flags tsf7))
              (set! (-> sv-880 velocity quad) (the-as uint128 0))
              (quaternion-identity! (-> sv-880 rotation))
              (quaternion-look-at! (-> sv-880 rotation) s2-0 *up-vector*)
              (set! (-> sv-880 nav-mesh) (find-nearest-nav-mesh (-> sv-880 position) (the-as float #x7f800000)))
              (set! (-> sv-880 nav-branch) #f)
              (set! sv-896 quaternion-rotate-y!)
              (set! sv-912 (-> sv-880 rotation))
              (set! sv-928 (-> sv-880 rotation))
              (let* ((f28-1 65536.0)
                     (v1-56 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                     (v1-57 (the-as number (logior #x3f800000 v1-56)))
                     (a2-2 (* f28-1 (+ -1.0 (the-as float v1-57))))
                     )
                (sv-896 sv-912 sv-928 a2-2)
                )
              (+! (-> sv-880 position y) 409.6)
              (cond
                ((= (-> this current-room-index) (-> (task-perm-by-index *game-info* 46) user-uint64))
                 (set! v1-65 600)
                 (set! (-> sv-880 flee-time) (the-as time-frame v1-65))
                 )
                (else
                  (set! v1-65 2100)
                  (set! (-> sv-880 flee-time) (the-as time-frame v1-65))
                  )
                )
              (set! (-> sv-880 flee-time) (the-as time-frame v1-65))
              (send-event (handle->process s0-2) 'traffic-activate sv-880 *traffic-engine*)
              )
            )
          (vector-rotate-around-y! s4-0 s4-0 f30-0)
          )
        )
      )
    0
    (none)
    )
  )

(defmethod task-manager-city-port-assault-method-41 ((this task-manager-city-port-assault) (arg0 assault-spawn-cmd) (arg1 assault-cmd-context))
  (if (logtest? (process-mask enemy guard) (-> *kernel-context* prevent-from-run))
      (return #f)
      )
  (if (-> *setting-control* user-current nuke-active?)
      (return #f)
      )
  (let ((s1-0 (-> arg0 spawner-index))
        (s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        (s2-0 (the-as int (-> arg0 spawn-type)))
        )
    (if (= s1-0 -1)
        (set! s1-0 0)
        )
    (set! (-> s5-0 quad) (-> this current-room node-positions s1-0 quad))
    (vector-! s4-0 (-> this current-room center-pos) s5-0)
    (set! (-> s4-0 y) 0.0)
    (vector-normalize! s4-0 1.0)
    (let ((v1-14 (new 'stack-no-clear 'vector))
          (s0-0 (new 'stack-no-clear 'collide-query))
          )
      (set! (-> v1-14 quad) (-> s5-0 quad))
      (vector+float*! (-> s0-0 start-pos) s5-0 *up-vector* 16384.0)
      (set! (-> s0-0 move-dist quad) (the-as uint128 0))
      (set! (-> s0-0 move-dist y) -32768.0)
      (let ((v1-19 s0-0))
        (set! (-> v1-19 radius) 40.96)
        (set! (-> v1-19 collide-with) (collide-spec backgnd))
        (set! (-> v1-19 ignore-process0) #f)
        (set! (-> v1-19 ignore-process1) #f)
        (set! (-> v1-19 ignore-pat)
              (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
              )
        (set! (-> v1-19 action-mask) (collide-action solid))
        )
      (when (>= (fill-and-probe-using-line-sphere *collide-cache* s0-0) 0.0)
        (set! (-> s5-0 quad) (-> s0-0 best-other-tri intersect quad))
        (+! (-> s5-0 y) 8192.0)
        )
      )
    (case (the-as assault-cmd-spawn-type s2-0)
      (((assault-cmd-spawn-type cmd4) (assault-cmd-spawn-type cmd5))
       (set! s2-0 3)
       )
      (((assault-cmd-spawn-type cmd12))
       (set! s2-0 9)
       )
      )
    (cond
      ((= s2-0 13)
       (let ((s3-1 (get-last-unused-val! (-> *assault-squad* spawn-records s2-0))))
         (when (>= s3-1 0)
           (let ((s1-1 (new 'stack 'assault-bombbot-spawn-params)))
             (set! (-> s1-1 position quad) (-> s5-0 quad))
             (quaternion-look-at! (-> s1-1 quat) s4-0 *up-vector*)
             (set! (-> s1-1 path) (-> *assault-bombbot-paths* 0))
             (set! (-> s1-1 path node 0 position quad) (-> s5-0 quad))
             (set! (-> s1-1 first-node) (the-as uint 0))
             (set! (-> s1-1 stop-offset) 36000.0)
             (set! (-> s1-1 is-final?) (-> this final-bombbot?))
             (set! (-> s1-1 suck-level) (get-suck-level this))
             (set! (-> *assault-squad* spawn-records s2-0 records data s3-1 proc)
                   (ppointer->handle (process-spawn assault-bombbot s1-1 :name "assault-bombbot" :to this))
                   )
             )
           (return #t)
           )
         )
       )
      (else
        (let ((s2-1 (get-last-unused-handle! (-> *assault-squad* spawn-records s2-0))))
          (when (handle->process s2-1)
            (let ((s0-1 (new 'stack 'assault-object-spawn-params)))
              (set! (-> s0-1 flags) (traffic-spawn-flags))
              (set! (-> s0-1 position quad) (-> s5-0 quad))
              (set! (-> s0-1 behavior) (the-as uint 2))
              (when (and (< 2 s1-0) (= (-> this current-room-index) 4))
                (+! (-> s0-1 position y) 61440.0)
                (set! (-> s0-1 behavior) (the-as uint 6))
                )
              (set! (-> s0-1 flags) (traffic-spawn-flags))
              (logior! (-> s0-1 flags) (traffic-spawn-flags tsf7))
              (set! (-> s0-1 velocity quad) (the-as uint128 0))
              (set! (-> s0-1 user-data) (the-as uint (-> this current-room center-pos)))
              (quaternion-identity! (-> s0-1 rotation))
              (quaternion-look-at! (-> s0-1 rotation) s4-0 *up-vector*)
              (let ((v1-74 (-> arg0 spawn-type)))
                (set! (-> s0-1 guard-type) (the-as uint (cond
                                                          ((= v1-74 (assault-cmd-spawn-type cmd4))
                                                           1
                                                           )
                                                          ((= v1-74 (assault-cmd-spawn-type cmd5))
                                                           2
                                                           )
                                                          ((= v1-74 (assault-cmd-spawn-type cmd12))
                                                           7
                                                           )
                                                          (else
                                                            0
                                                            )
                                                          )
                                                   )
                      )
                )
              (set! (-> s0-1 nav-mesh) (find-nearest-nav-mesh s5-0 (the-as float #x7f800000)))
              (set! (-> s0-1 nav-branch) #f)
              (send-event (handle->process s2-1) 'traffic-activate s0-1 *traffic-engine*)
              )
            (process-spawn assault-cleanup s2-1 :name "assault-cleanup" :to (handle->process s2-1))
            (return #t)
            )
          )
        )
      )
    )
  #f
  )

(defmethod task-manager-method-25 ((this task-manager-city-port-assault))
  (reset-enemies *assault-squad*)
  (if *target*
      (logclear! (-> *target* target-flags) (target-flags tf16))
      )
  (send-event (ppointer->process *time-of-day*) 'change 'ratio 1.0)
  (call-parent-method this)
  (none)
  )

(defmethod room-advance ((this task-manager-city-port-assault))
  (let ((a1-0 (new 'stack-no-clear 'array 'symbol 10)))
    (set! (-> a1-0 9) #f)
    (set! (-> a1-0 8) #f)
    (set! (-> a1-0 7) #f)
    (set! (-> a1-0 6) #f)
    (set! (-> a1-0 5) #f)
    (set! (-> a1-0 4) #f)
    (set! (-> a1-0 3) #f)
    (set! (-> a1-0 2) 'hiphog)
    (set! (-> a1-0 1) 'ctyport)
    (set! (-> a1-0 0) 'ctywide-ff)
    (want-levels *load-state* a1-0)
    )
  (want-display-level *load-state* 'ctyport 'display)
  (want-display-level *load-state* 'hiphog 'display)
  (kill-by-type barge *active-pool*)
  (kill-by-name "hip-door-a-6" *active-pool*)
  (kill-by-name "hip-door-a-1" *active-pool*)
  (if (> (-> this room-override-index) 0)
      (set! (-> this current-room-index) (-> this room-override-index))
      (+! (-> this current-room-index) 1)
      )
  (set-next-powerup-spawn-time this)
  (if (= (-> this current-room-index) 3)
      (set-setting! 'city-sound '(cityalth citymhf citykgf) 0.0 2)
      (set-setting! 'city-sound '(citymhf citykgf citypedh cityffh) 0.0 2)
      )
  (if (= (-> this current-room-index) 2)
      (set-setting! 'gem-pool-index #f 0.0 -1)
      (set-setting! 'gem-pool-index #f 0.0 1)
      )
  (cond
    ((= (-> this current-room-index) (-> *assault-scripts* length))
     (send-event this 'complete)
     )
    (else
      (if (> (-> this current-room-index) 0)
          (sound-play "room-advance")
          )
      (set! (-> this current-room) (-> *assault-rooms* (-> this current-room-index)))
      (set! (-> this script-command script) (-> *assault-scripts* (-> this current-room-index)))
      (parse-cmd this)
      (let ((v1-45 (the-as assault-player-controller (handle->process (-> this h-player-controller)))))
        (if v1-45
            (set! (-> v1-45 collision) (-> this current-room collision))
            )
        )
      (set-setting! 'mode-name 'cam-fixed 0.0 0)
      (remove-setting! 'entity-name)
      (dotimes (s5-1 (-> *assault-squad* spawn-records length))
        (when (!= s5-1 1)
          (dotimes (s4-1 (-> *assault-squad* spawn-records s5-1 records length))
            (send-event
              (handle->process (-> *assault-squad* spawn-records s5-1 records data s4-1 proc))
              'traffic-off-force
              )
            )
          )
        )
      (spawn-guards this (-> *assault-guard-count* (-> this current-room-index)))
      (let ((s5-2 (-> *assault-citizen-count* (-> this current-room-index))))
        (cond
          ((> s5-2 0)
           (let ((a1-19 (+ s5-2 (the int (fmin 2.0 (lerp-scale-clamp 0.0 2.0 (the float (get-suck-level this)) 7.0 14.0))))))
             (spawn-citizens this a1-19)
             )
           )
          (else
            (process-spawn-function
              process
              (lambda :behavior process
                ()
                (let ((gp-0 (current-time)))
                  (until (time-elapsed? gp-0 (seconds 1))
                    (suspend)
                    )
                  )
                (dotimes (gp-1 (-> *assault-squad* spawn-records 1 records length))
                  (send-event (handle->process (-> *assault-squad* spawn-records 1 records data gp-1 proc)) 'traffic-off-force)
                  )
                #f
                )
              :to this
              )
            )
          )
        )
      (dotimes (v1-96 12)
        (set! (-> this spawners v1-96 current-command count) 0)
        )
      (cond
        ((> (-> this room-override-index) 0)
         (set! (-> this room-override-index) -1)
         (go (method-of-object this player-quickstart))
         )
        ((> (-> this current-room-index) 0)
         (go (method-of-object this transition))
         )
        (else
          (go (method-of-object this combat))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod assault-player-controller-method-36 ((this assault-player-controller))
  (let ((s4-0 (matrix-transpose! (new 'stack-no-clear 'matrix) (-> this collision cam-matrix)))
        (s5-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> this collision cam-pos)))
        )
    (set! (-> s5-1 w) 0.0)
    (vector-matrix*! s5-1 s5-1 s4-0)
    (set! (-> s5-1 y)
          (fmax (fmin (-> s5-1 y) (-> this collision clip-dists dist1)) (- (-> this collision clip-dists dist0)))
          )
    (set! (-> s5-1 x) (fmax
                        (fmin (-> s5-1 x) (* 0.75 (-> this collision hoz-clip-dist)))
                        (- (* 0.75 (-> this collision hoz-clip-dist)))
                        )
          )
    (vector-matrix*! s5-1 s5-1 (-> this collision cam-matrix))
    (vector+! s5-1 s5-1 (-> this collision cam-pos))
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (set! (-> gp-1 x) (-> s5-1 x))
      (set! (-> gp-1 y) (-> (target-pos 0) y))
      (set! (-> gp-1 z) (-> s5-1 z))
      (set! (-> gp-1 w) 1.0)
      (let ((s5-2 (new 'stack-no-clear 'collide-query)))
        (vector+float*! (-> s5-2 start-pos) gp-1 *up-vector* 20480.0)
        (set! (-> s5-2 move-dist quad) (the-as uint128 0))
        (set! (-> s5-2 move-dist y) -61440.0)
        (let ((v1-15 s5-2))
          (set! (-> v1-15 radius) 0.0)
          (set! (-> v1-15 collide-with) (collide-spec backgnd))
          (set! (-> v1-15 ignore-process0) #f)
          (set! (-> v1-15 ignore-process1) #f)
          (set! (-> v1-15 ignore-pat)
                (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                )
          (set! (-> v1-15 action-mask) (collide-action solid))
          )
        (when (>= (fill-and-probe-using-line-sphere *collide-cache* s5-2) 0.0)
          (if (< (fabs (- (-> gp-1 y) (-> s5-2 best-other-tri intersect y))) 6144.0)
              (set! (-> gp-1 y) (fmax (-> gp-1 y) (-> s5-2 best-other-tri intersect y)))
              )
          )
        )
      (move-to-point! (-> *target* control) gp-1)
      )
    )
  (none)
  )

(defstate wait (task-manager-city-port-assault)
  :virtual #t
  :code (behavior ()
    (if (> (-> (task-perm-by-index *game-info* 46) user-uint64) 0)
        (set-blackout-frames (seconds 100))
        )
    (while (or (not *target*)
               (not *spawn-actors*)
               (!= (status-of-level-and-borrows *level* 'ctypesa #f) 'active)
               (!= (status-of-level-and-borrows *level* 'ctypesb #f) 'active)
               (!= (status-of-level-and-borrows *level* 'ctypesc #f) 'active)
               (!= (status-of-level-and-borrows *level* 'lctypalt #f) 'active)
               )
      (suspend)
      )
    (set-time-limit self)
    (go-virtual active)
    )
  )

(defstate clip-to-nav-mesh (assault-player-controller)
  :virtual #t
  :trans (behavior ()
    (let ((t9-1 (-> (find-parent-state) trans)))
      (if t9-1
          (t9-1)
          )
      )
    (assault-player-controller-method-36 self)
    )
  )

(defmethod spawn-special-pickup ((this task-manager-city-port-assault) (arg0 pickup-type))
  (when (or (= arg0 (pickup-type health)) (logtest? (-> *game-info* features) (gun-pickup-type->game-feature arg0)))
    (set-next-powerup-spawn-time this)
    (let* ((s4-2 (-> this current-room center-pos))
           (f30-0 0.75)
           (v1-9 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-10 (the-as number (logior #x3f800000 v1-9)))
           (f30-1
             (+ f30-0
                (* (+ -1.0 (the-as float v1-10))
                   (+ -0.75
                      (* 0.95
                         (fmin (-> this current-room collision clip-dists dist0) (-> this current-room collision clip-dists dist1))
                         )
                      )
                   )
                )
             )
           )
      0.0
      (let ((s2-1 (vector-! (new 'stack-no-clear 'vector) (-> *target* control trans) (-> this current-room center-pos)))
            (s3-1 (new 'stack-no-clear 'vector))
            )
        (let ((a0-9 s2-1))
          (set! (-> a0-9 quad) (-> s2-1 quad))
          (set! (-> a0-9 y) 0.0)
          (vector-normalize! a0-9 1.0)
          )
        (let* ((f28-0 20024.889)
               (f26-0 25486.22)
               (v1-26 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-27 (the-as number (logior #x3f800000 v1-26)))
               (f0-11 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-27))) (vector-y-angle s2-1)))
               )
          (vector-rotate-around-y! s3-1 *z-vector* f0-11)
          )
        (vector+float*! s3-1 s4-2 s3-1 f30-1)
        (let ((s4-3 (new 'stack-no-clear 'vector))
              (a0-17 (find-nearest-nav-mesh s3-1 (the-as float #x7f800000)))
              )
          (when a0-17
            (when (nav-mesh-method-10 a0-17 s4-3 s3-1 (the-as nav-poly #f))
              (set! (-> s4-3 y) (-> s3-1 y))
              (set! (-> s3-1 quad) (-> s4-3 quad))
              )
            )
          )
        (sound-play "pickup-spawn")
        (case arg0
          (((pickup-type health))
           (process-spawn special-health s3-1 :name "special-health" :to this)
           )
          (else
            (process-spawn ammo-special-pickup s3-1 arg0 :name "ammo-special-pickup" :to this)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod task-manager-city-port-assault-method-44 ((this task-manager-city-port-assault))
  (when *target*
    (let ((s4-0 (new 'static 'boxed-array :type int32 15 16 17 18))
          (s5-0 0)
          )
      (dotimes (s3-0 (-> s4-0 length))
        (+! s5-0 (the int (get-remaining-player-ammo (the-as pickup-type (-> s4-0 s3-0)))))
        )
      (if (and (or (= s5-0 0)
                   (and (< s5-0 2) (= (-> this ammo-special gun-type) 30))
                   (and (< s5-0 11) (= (-> this ammo-special gun-type) 31))
                   )
               (not (and (focus-test? *target* dark) (nonzero? (-> *target* darkjak))))
               )
          (send-event this 'ammo-special 15 29)
          )
      )
    (when (and (or (> (-> this ammo-special end-lock-time) 0) (!= (-> *game-info* gun-type) (-> this ammo-special gun-type)))
               (and (time-elapsed? (-> this ammo-special end-lock-time) (seconds 0.1))
                    (!= (-> this ammo-special ammo-type) 7)
                    (not (and (focus-test? *target* dark) (nonzero? (-> *target* darkjak))))
                    )
               )
      (set! (-> this ammo-special end-lock-time) 0)
      (send-event *target* 'change-mode 'gun #f (-> this ammo-special gun-type))
      )
    )
  )

(defmethod pickup-spawn-chance ((this task-manager-city-port-assault) (arg0 room-powerup-percentage) (arg1 int))
  (case arg1
    ((20)
     (let ((f0-1 (/ (-> *target* fact health) (-> *target* fact health-max))))
       0.0
       (let* ((f0-2 (- 1.0 f0-1))
              (f0-3 (* f0-2 f0-2))
              (f0-4 (lerp 0.0 7.0 f0-3))
              )
         (* (-> arg0 percentages arg1) f0-4)
         )
       )
     )
    (else
      (-> arg0 percentages arg1)
      )
    )
  )

(defmethod check-for-pickup-spawn ((this task-manager-city-port-assault))
  (when (< (-> this next-powerup-spawn-time) (current-time))
    (let* ((f30-0 0.0)
           (v1-2 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-3 (the-as number (logior #x3f800000 v1-2)))
           (f28-0 (+ -1.0 (the-as float v1-3)))
           )
      (dotimes (s5-0 51)
        (+! f30-0 (pickup-spawn-chance this (-> *room-powerups* (-> this current-room-index)) s5-0))
        )
      (let ((f30-1 (* f28-0 f30-0))
            (f28-1 0.0)
            (s5-1 0)
            )
        (while (< s5-1 51)
          (+! f28-1 (pickup-spawn-chance this (-> *room-powerups* (-> this current-room-index)) s5-1))
          (when (< f30-1 f28-1)
            (spawn-special-pickup this (the-as pickup-type s5-1))
            (return 0)
            )
          (set! s5-1 (+ s5-1 1))
          )
        )
      )
    (the-as int #f)
    )
  )

;; WARN: Return type mismatch uint vs int.
(defmethod get-suck-level ((this task-manager-city-port-assault))
  (the-as int (-> *game-info* sub-task-list (game-task-node city-port-assault-resolution) death-count))
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod set-next-powerup-spawn-time ((this task-manager-city-port-assault))
  (let ((f30-0 0.0)
        (f28-0 10.0)
        )
    (dotimes (s5-0 (the int f28-0))
      (let* ((f26-0 1.0)
             (v1-3 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-4 (the-as number (logior #x3f800000 v1-3)))
             )
        (set! f30-0 (+ f26-0 (+ -1.0 (the-as float v1-4)) f30-0))
        )
      )
    (let* ((f30-1 (/ (- f30-0 f28-0) f28-0))
           (f0-8 (lerp-scale-clamp 1.0 2.5 (the float (get-suck-level this)) 0.0 12.0))
           (f28-1 (fmax 1.0 (fmin 2.5 f0-8)))
           )
      (format 0 "Powerup frequency scalar : ~f~%" f28-1)
      (let* ((f0-10 (/ f30-1 f28-1))
             (s5-2 (the int (* 2.0 (the float (-> *room-powerups* (-> this current-room-index) avg-spawn-rate)) f0-10)))
             )
        (format 0 "Spawning in ~f seconds~%" (* 0.0033333334 (the float s5-2)))
        (set! (-> this next-powerup-spawn-time) (+ (current-time) s5-2))
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch entity-perm-status vs none.
(defun skip-to-room ((arg0 uint))
  (let ((v1-1 (task-perm-by-index *game-info* 46)))
    (logior! (-> v1-1 status) (entity-perm-status bit-5))
    (set! (-> v1-1 user-uint64) arg0)
    (logior! (-> v1-1 status) (entity-perm-status bit-14))
    )
  (none)
  )
