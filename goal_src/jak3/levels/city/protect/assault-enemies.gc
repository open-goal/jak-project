;;-*-Lisp-*-
(in-package goal)

;; name: assault-enemies.gc
;; name in dgo: assault-enemies
;; dgos: LCTYPALT

;; +++assault-target-type
(defenum assault-target-type
  :copy-entries city-target-type
  (assault-citizen-norm 1)
  (assault-grunt 6)
  (assault-metalhead-predator 8)
  (other 11)
  (assault-bombbot 13)
  )
;; ---assault-target-type


(define-extern *curve-assault-bombbot-shot-color-blue* curve-color-fast)
(define-extern *curve-assault-bombbot-shot-width* curve2d-fast)
(define-extern *assault-bombbot-trail* light-trail-composition)
(define-extern *assault-bombbot-trail-2* light-trail-composition)
(define-extern *look-time* time-frame)

;; DECOMP BEGINS

(deftype assault-object-spawn-params (traffic-object-spawn-params)
  ((lev         symbol)
   (suck-level  int32)
   (flee-time   time-frame)
   )
  )


(defbehavior assault-enemy-init-by-other citizen ((arg0 assault-object-spawn-params))
  (set! (-> self level) (level-get *level* (-> arg0 lev)))
  (citizen-init-by-other arg0)
  )

(deftype assault-metalhead-grunt (metalhead-grunt)
  ()
  (:state-methods
    exit-transport
    )
  )


(deftype assault-metalhead-flitter (metalhead-flitter)
  ()
  (:state-methods
    exit-transport
    )
  )


(deftype assault-metalhead-predator (metalhead-predator)
  ()
  )


(deftype assault-roboguard (roboguard-city)
  ((shoot-wait-time  time-frame)
   )
  (:state-methods
    roll-initial
    )
  (:methods
    (go-from-behavior (_type_ assault-object-spawn-params) object :replace)
    )
  )


(deftype assault-spydroid (spydroid)
  ()
  )


(deftype assault-flying-turret (flying-turret)
  ()
  )


(deftype assault-crimson-guard (crimson-guard)
  ((center-pos  vector  :inline)
   )
  (:state-methods
    wait-for-enemies
    )
  (:methods
    (go-from-behavior (_type_ assault-object-spawn-params) object :replace)
    )
  )


(deftype assault-citizen-norm (citizen-norm)
  ((center-pos     vector  :inline)
   (min-flee-time  time-frame)
   )
  (:state-methods
    flee-madly
    flee-to-center
    )
  (:methods
    (go-from-behavior (_type_ assault-object-spawn-params) object :replace)
    )
  )


;; WARN: Return type mismatch object vs none.
(defmethod go-from-behavior ((this assault-metalhead-flitter) (arg0 traffic-object-spawn-params))
  (case (-> arg0 behavior)
    ((6)
     (set! (-> this root trans quad) (-> arg0 position quad))
     (go (method-of-object this exit-transport))
     )
    (else
      (call-parent-method this arg0)
      )
    )
  (none)
  )

(defstate exit-transport (assault-metalhead-flitter)
  :virtual #t
  :enter (behavior ()
    (nav-enemy-method-182 self)
    (logclear! (-> self root status) (collide-status on-surface touch-surface impact-surface))
    )
  :trans (behavior ()
    (if (logtest? (-> self root status) (collide-status on-surface touch-surface impact-surface))
        (go-virtual hostile)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja-no-eval :group! (-> self draw art-group data 14) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    )
  :post (behavior ()
    (enemy-falling-post)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-from-behavior ((this assault-metalhead-grunt) (arg0 traffic-object-spawn-params))
  (case (-> arg0 behavior)
    ((6)
     (set! (-> this root trans quad) (-> arg0 position quad))
     (go (method-of-object this exit-transport))
     )
    (else
      (call-parent-method this arg0)
      )
    )
  (none)
  )

(defstate exit-transport (assault-metalhead-grunt)
  :virtual #t
  :enter (behavior ()
    (nav-enemy-method-182 self)
    (logclear! (-> self root status) (collide-status on-surface touch-surface impact-surface))
    )
  :trans (behavior ()
    (if (logtest? (-> self root status) (collide-status on-surface touch-surface impact-surface))
        (go-virtual hostile)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja-no-eval :group! (-> self draw art-group data 11) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    )
  :post (behavior ()
    (enemy-falling-post)
    )
  )

(defstate knocked-recover (assault-citizen-norm)
  :virtual #t
  :enter (behavior ()
    (call-parent-state-handler enter)
    (logclear! (-> self enemy-flags) (enemy-flag vulnerable))
    (if (< (vector-vector-xz-distance (-> self root trans) (-> self center-pos)) 16384.0)
        (go-virtual cower-ground)
        )
    )
  :exit (behavior ()
    (let ((t9-1 (-> (find-parent-state) exit)))
      (if t9-1
          (t9-1)
          )
      )
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self enemy-flags) (enemy-flag vulnerable))
    )
  :code (behavior ()
    (let ((v1-1 (if (zero? (-> self hit-face))
                    (-> self anim-get-up-front)
                    (-> self anim-get-up-back)
                    )
                )
          )
      (start-ragdoll self (the-as art-joint-anim (-> self draw art-group data v1-1)))
      )
    (ja-no-eval :num! (seek! max (* 2.0 (-> self speed-scale))))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (cond
      ((enemy-method-109 self)
       (go-die self)
       )
      ((< (vector-vector-xz-distance (-> self root trans) (-> self center-pos)) 16384.0)
       (go-virtual cower-ground)
       )
      (else
        (go-virtual flee-to-center)
        )
      )
    )
  )

(defmethod get-run-anim ((this assault-citizen-norm))
  (if (and (-> this next-state) (let ((v1-3 (-> this next-state name)))
                                  (or (= v1-3 'flee) (= v1-3 'flee-to-center) (= v1-3 'flee-madly))
                                  )
           )
      (-> this anim-panic-run)
      (-> this anim-run)
      )
  )

(defmethod go-from-behavior ((this assault-citizen-norm) (arg0 assault-object-spawn-params))
  (set! (-> this root trans quad) (-> arg0 position quad))
  (set! (-> this hit-points)
        (the float (the int (lerp-scale-clamp 10.0 20.0 (the float (-> arg0 suck-level)) 4.0 12.0)))
        )
  (set! (-> this attacker-info max-num-attackers) (the-as uint 1))
  (set! (-> this center-pos quad) (-> (the-as vector (-> arg0 user-data)) quad))
  (set! (-> this min-flee-time) (-> arg0 flee-time))
  (go (method-of-object this flee-madly))
  )

(defstate flee-to-center (assault-citizen-norm)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (nav-enemy-method-181 self)
    (nav-enemy-method-183 self)
    (nav-enemy-method-177 self)
    (let ((v1-8 (-> self nav)))
      (set! (-> v1-8 target-speed) (* (-> self speed-scale) (-> self speed-run)))
      )
    0
    (let ((a0-3 (-> self nav state))
          (v1-11 (-> self center-pos))
          )
      (logclear! (-> a0-3 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-3 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-3 target-pos quad) (-> v1-11 quad))
      )
    0
    )
  :trans (behavior ()
    (if (< (vector-vector-xz-distance (-> self root trans) (-> self center-pos)) 16384.0)
        (go-virtual cower-ground)
        )
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self anim-panic-run))) 30)
    )
  :post (behavior ()
    (nav-enemy-method-187 self)
    )
  )

(defstate flee-madly (assault-citizen-norm)
  :virtual #t
  :parent (assault-citizen-norm flee-to-center)
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (-> self min-flee-time))
        (go-virtual flee-to-center)
        )
    (let ((t9-1 vector-vector-xz-distance)
          (a0-2 (-> self root trans))
          (a2-0 (-> self nav state))
          (a1-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> a1-0 quad) (-> a2-0 target-pos quad))
      (when (< (t9-1 a0-2 a1-0) 12288.0)
        (let* ((gp-0 vector-rotate-around-y!)
               (s5-0 (new 'stack-no-clear 'vector))
               (s4-0 *x-vector*)
               (f30-0 65536.0)
               (v1-13 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-14 (the-as number (logior #x3f800000 v1-13)))
               (gp-1 (gp-0 s5-0 s4-0 (* f30-0 (+ -1.0 (the-as float v1-14)))))
               )
          (let* ((s5-1 gp-1)
                 (s4-1 (-> self center-pos))
                 (s3-0 gp-1)
                 (f30-1 8192.0)
                 (f28-0 40960.0)
                 (v1-19 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                 (v1-20 (the-as number (logior #x3f800000 v1-19)))
                 )
            (vector+float*! s5-1 s4-1 s3-0 (+ f30-1 (* f28-0 (+ -1.0 (the-as float v1-20)))))
            )
          (let ((v1-23 (-> self nav state)))
            (logclear! (-> v1-23 flags) (nav-state-flag directional-mode))
            (logior! (-> v1-23 flags) (nav-state-flag target-poly-dirty))
            (set! (-> v1-23 target-pos quad) (-> gp-1 quad))
            )
          )
        0
        )
      )
    )
  )

(defmethod event-handler ((this assault-citizen-norm) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (let ((a0-3 (find-offending-process-focusable arg0 (the-as attack-info (-> arg3 param 1)))))
       (if (!= (-> a0-3 type) target)
           (call-parent-method this arg0 arg1 arg2 arg3)
           )
       )
     )
    (else
      (call-parent-method this arg0 arg1 arg2 arg3)
      )
    )
  )

(defstate cower-ground (assault-citizen-norm)
  :virtual #t
  :trans (behavior ()
    (call-parent-state-handler trans)
    (if (enemy-method-109 self)
        (go-virtual die)
        )
    )
  :code (behavior ()
    (local-vars (v1-40 enemy-flag) (v1-42 enemy-flag) (v1-44 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-start))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (let ((v1-29 (-> self root root-prim)))
      (set! (-> v1-29 prim-core collide-as) (collide-spec))
      (set! (-> v1-29 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self enemy-flags) (enemy-flag vulnerable))
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-39 (-> self enemy-flags)))
      (if (logtest? v1-39 (enemy-flag vulnerable-backup))
          (set! v1-40 (logior v1-39 (enemy-flag vulnerable)))
          (set! v1-40 (logclear v1-39 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-40)
    (let ((v1-41 (-> self enemy-flags)))
      (if (logtest? v1-41 (enemy-flag attackable-backup))
          (set! v1-42 (logior v1-41 (enemy-flag attackable)))
          (set! v1-42 (logclear v1-41 (enemy-flag attackable)))
          )
      )
    (set! (-> self enemy-flags) v1-42)
    (let ((v1-43 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-43)
          (set! v1-44 (logior (enemy-flag trackable) v1-43))
          (set! v1-44 (logclear v1-43 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-44)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self focus-status) (focus-status hit))
    (let ((v1-50 (-> self root root-prim)))
      (set! (-> v1-50 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-50 prim-core collide-with) (-> self root backup-collide-with))
      )
    (logand! (-> self root root-prim prim-core collide-with) (collide-spec jak player-list))
    (set! (-> self root penetrated-by) (the-as penetrate -1))
    (until #f
      (let ((gp-0 (-> self skel root-channel 0)))
        (set! (-> gp-0 frame-group)
              (the-as art-joint-anim (-> self draw art-group data (-> self info anim-cover-head-loop)))
              )
        (set! (-> gp-0 param 0)
              (the float
                   (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self info anim-cover-head-loop)))
                          frames
                          num-frames
                          )
                      -1
                      )
                   )
              )
        (let* ((f30-0 0.1)
               (f28-0 0.20000002)
               (v1-74 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-75 (the-as number (logior #x3f800000 v1-74)))
               )
          (set! (-> gp-0 param 1) (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-75)))))
          )
        (set! (-> gp-0 frame-num) 0.0)
        (joint-control-channel-group!
          gp-0
          (the-as art-joint-anim (-> self draw art-group data (-> self info anim-cover-head-loop)))
          num-func-seek!
          )
        )
      (until (ja-done? 0)
        (suspend)
        (let ((gp-1 (-> self skel root-channel 0)))
          (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
          (let* ((f30-1 0.1)
                 (f28-1 0.20000002)
                 (v1-91 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                 (v1-92 (the-as number (logior #x3f800000 v1-91)))
                 )
            (set! (-> gp-1 param 1) (+ f30-1 (* f28-1 (+ -1.0 (the-as float v1-92)))))
            )
          (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
          )
        )
      )
    #f
    )
  )

(defmethod go-from-behavior ((this assault-roboguard) (arg0 assault-object-spawn-params))
  (case (-> arg0 behavior)
    ((6)
     (set! (-> this root trans quad) (-> arg0 position quad))
     (go (method-of-object this exit-transport))
     )
    (else
      (set! (-> this move-dest quad) (-> (the-as vector (-> arg0 user-data)) quad))
      (go (method-of-object this roll-initial))
      )
    )
  )

(defstate hostile-stand (assault-roboguard)
  :virtual #t
  :trans (behavior ()
    (local-vars (v0-5 enemy-flag))
    (let ((v1-1 (roboguard-city-method-236 self)))
      (cond
        ((= v1-1 4)
         (go-virtual close-attack)
         )
        ((= v1-1 5)
         (if (time-elapsed? (-> self shoot-wait-time) (seconds 2))
             (go-virtual shoot-attack)
             )
         )
        ((= v1-1 1)
         (go-virtual roll-enter)
         )
        ((zero? v1-1)
         (if (time-elapsed? (-> self state-time) (-> self reaction-time))
             (go-virtual hostile)
             )
         )
        )
      )
    (let ((v1-23 (-> self enemy-flags)))
      (if (logtest? v1-23 (enemy-flag vulnerable-backup))
          (set! v0-5 (logior v1-23 (enemy-flag vulnerable)))
          (set! v0-5 (logclear v1-23 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v0-5)
    )
  )

(defstate shoot-attack (assault-roboguard)
  :virtual #t
  :exit (behavior ()
    (set-time! (-> self shoot-wait-time))
    (let ((t9-1 (-> (find-parent-state) exit)))
      (if t9-1
          (t9-1)
          )
      )
    )
  )

(defstate roll-initial (assault-roboguard)
  :virtual #t
  :enter (behavior ()
    (let ((a0-0 (new 'stack-no-clear 'vector)))
      (set! (-> a0-0 quad)
            (-> (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans)) quad)
            )
      (set! (-> a0-0 y) 0.0)
      (let ((a1-3 (vector-normalize! a0-0 1.0)))
        (quaternion-look-at! (-> self root quat) a1-3 *up-vector*)
        )
      )
    (let ((a0-2 (-> self nav state))
          (v1-5 (-> self move-dest))
          )
      (logclear! (-> a0-2 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-2 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-2 target-pos quad) (-> v1-5 quad))
      )
    0
    (nav-enemy-method-181 self)
    (logior! (-> self flags) (citizen-flag in-pursuit))
    (if (not (logtest? (-> self squad alert-state flags) (squad-alert-flag war)))
        (logior! (-> self flags) (citizen-flag persistent))
        )
    (let ((v1-18 (-> self nav)))
      (set! (-> v1-18 acceleration) 16384.0)
      )
    0
    (nav-enemy-method-181 self)
    (nav-enemy-method-183 self)
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((gp-0 (-> self nav state))
          (v1-28 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
          )
      (set! (-> gp-0 heading quad) (-> v1-28 quad))
      )
    0
    (let ((f30-0 81920.0))
      (let ((s5-0 (-> self nav state))
            (gp-2 (vector-float*!
                    (new 'stack-no-clear 'vector)
                    (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))
                    f30-0
                    )
                  )
            )
        (set! (-> s5-0 velocity quad) (-> gp-2 quad))
        )
      0
      (let ((v1-37 (-> self nav)))
        (set! (-> v1-37 target-speed) f30-0)
        )
      0
      (set! (-> self nav state speed) f30-0)
      )
    0
    (let ((v1-42 (-> self nav)))
      (set! (-> v1-42 turning-acceleration) 20480.0)
      )
    0
    (logior! (-> self robo-flags) (robo-flag r2))
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (when (or (logtest? (-> self nav flags) (nav-control-flag ncf9))
              (< (vector-vector-xz-distance (-> self root trans) (-> self move-dest)) 32768.0)
              )
      (set-time! (-> self shoot-wait-time))
      (go-virtual roll-exit)
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! (-> self draw art-group data 13))
    (until #f
      (let ((a0-4 (-> self skel root-channel 0)))
        (let ((f0-0 0.000024414063)
              (a2-0 (-> self nav state))
              (v1-7 (new 'stack-no-clear 'vector))
              )
          (set! (-> v1-7 quad) (-> a2-0 velocity quad))
          (set! (-> a0-4 param 0) (* f0-0 (sqrtf (+ (* (-> v1-7 x) (-> v1-7 x)) (* (-> v1-7 z) (-> v1-7 z))))))
          )
        (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-loop!)
        )
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (nav-enemy-method-187 self)
    )
  )

(defstate in-ditch (assault-spydroid)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate in-ditch (assault-flying-turret)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate in-ditch (assault-roboguard)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate in-ditch (assault-crimson-guard)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate in-ditch (assault-metalhead-flitter)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate in-ditch (assault-metalhead-predator)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate die-fast (assault-spydroid)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate die-fast (assault-flying-turret)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate die-fast (assault-roboguard)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate die-fast (assault-crimson-guard)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate die-fast (assault-metalhead-flitter)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defstate die-fast (assault-metalhead-predator)
  :virtual #t
  :enter (behavior ()
    (go-inactive self)
    )
  )

(defun assault-type->type ((arg0 assault-target-type))
  (case arg0
    (((assault-target-type guard-tazer) (assault-target-type guard-rifle) (assault-target-type guard-grenade))
     assault-crimson-guard
     )
    (((assault-target-type assault-citizen-norm))
     assault-citizen-norm
     )
    (((assault-target-type assault-grunt))
     assault-metalhead-grunt
     )
    (((assault-target-type flitter))
     assault-metalhead-flitter
     )
    (((assault-target-type assault-metalhead-predator))
     assault-metalhead-predator
     )
    (((assault-target-type roboguard))
     assault-roboguard
     )
    (((assault-target-type roboguard-giant))
     roboguard-city
     )
    (((assault-target-type turret))
     assault-flying-turret
     )
    (((assault-target-type other))
     assault-spydroid
     )
    (else
      (the-as type #f)
      )
    )
  )

(deftype assault-cleanup (process)
  ((offscreen-time  time-frame)
   (parent-hand     handle)
   )
  (:state-methods
    tracking
    )
  )


(defbehavior assault-cleanup-init-by-other assault-cleanup ((arg0 handle))
  (set! (-> self parent-hand) arg0)
  (go-virtual tracking)
  )

(defstate tracking (assault-cleanup)
  :virtual #t
  :code (behavior ()
    (suspend-for (seconds 5))
    (set-time! (-> self offscreen-time))
    (until #f
      (suspend)
      (let* ((gp-1 (handle->process (-> self parent-hand)))
             (v1-10 (if (type? gp-1 process-focusable)
                        (the-as process-focusable gp-1)
                        )
                    )
             )
        (cond
          ((and v1-10 (not (logtest? (-> v1-10 focus-status) (focus-status disable dead inactive))))
           (if (not (or (not (logtest? (-> v1-10 draw status) (draw-control-status on-screen)))
                        (not (sphere-in-view-frustum? (the-as sphere (-> v1-10 root root-prim prim-core))))
                        )
                    )
               (set-time! (-> self offscreen-time))
               )
           (if (time-elapsed? (-> self offscreen-time) (seconds 3))
               (send-event (handle->process (-> self parent-hand)) 'traffic-off-force)
               )
           )
          (else
            (return 0)
            )
          )
        )
      )
    #f
    )
  )

(define *assault-levels* (new 'static 'boxed-array :type symbol :length 13 :allocated-length 19
                           '#f
                           'lctyass
                           'ctypepa
                           'ctypesa
                           'ctypesa
                           'ctypesa
                           'ctypesb
                           'ctypesb
                           'ctypepb
                           'ctypesc
                           'ctypesc
                           'ctypesc
                           'ctypesc
                           )
        )

;; WARN: Return type mismatch int vs handle.
(defun spawn-assault-enemy ((arg0 assault-target-type) (arg1 process))
  (let ((s5-0 (new 'stack 'assault-object-spawn-params))
        (s4-0 (assault-type->type arg0))
        )
    (if (not s4-0)
        (return (the-as handle #f))
        )
    (quaternion-identity! (-> s5-0 rotation))
    (set! (-> s5-0 position quad) (-> (target-pos 0) quad))
    (set! (-> s5-0 lev) (-> *assault-levels* arg0))
    (set! (-> s5-0 velocity quad) (the-as uint128 0))
    (set! (-> s5-0 behavior) (the-as uint 1))
    (set! (-> s5-0 flags) (traffic-spawn-flags tsf0))
    (set! (-> s5-0 nav-branch) #f)
    (set! (-> s5-0 guard-type) (the-as uint 0))
    (logior! (-> s5-0 flags) (traffic-spawn-flags tsf7))
    (let ((s4-1 (get-process *default-dead-pool* s4-0 #x4000 1)))
      (the-as handle (ppointer->handle (when s4-1
                                         (let ((t9-5 (method-of-type process activate)))
                                           (t9-5 s4-1 arg1 "assault-enemy" (the-as pointer #x70004000))
                                           )
                                         (run-now-in-process s4-1 assault-enemy-init-by-other s5-0)
                                         (-> s4-1 ppointer)
                                         )
                                       )
              )
      )
    )
  )

(defmethod go-from-behavior ((this assault-crimson-guard) (arg0 assault-object-spawn-params))
  (set! (-> this center-pos quad) (-> (the-as vector (-> arg0 user-data)) quad))
  (call-parent-method this arg0)
  )

;; WARN: Return type mismatch float vs none.
(defmethod citizen-method-194 ((this assault-crimson-guard))
  (call-parent-method this)
  (set! (-> this hit-points) 10.0)
  (none)
  )

(defmethod go-inactive ((this assault-crimson-guard))
  (with-pp
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer pp))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'guard-death)
      (let ((t9-0 send-event-function)
            (v1-4 (-> *game-info* sub-task-list (game-task-node city-port-assault-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-4 manager)
                               (-> v1-4 manager manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (call-parent-method this)
    (none)
    )
  )

(defmethod event-handler ((this assault-crimson-guard) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('weaken)
     (set! (-> this hit-points) (fmin 1.0 (-> this hit-points)))
     )
    (else
      (call-parent-method this arg0 arg1 arg2 arg3)
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod enemy-common-post ((this assault-crimson-guard))
  (call-parent-method this)
  (when (and (or (not (logtest? (-> this draw status) (draw-control-status on-screen)))
                 (< 102400.0 (vector-vector-xz-distance (-> this root trans) (-> this center-pos)))
                 )
             (-> this next-state)
             (= (-> this next-state name) 'hostile)
             )
    (nav-enemy-method-177 this)
    (add-debug-sphere #t (bucket-id debug) (-> this center-pos) (meters 2) *color-red*)
    (go (method-of-object this active))
    )
  (none)
  )

(defstate active (assault-crimson-guard)
  :virtual #t
  :enter (behavior ()
    (logclear! (-> self flags) (citizen-flag in-pursuit hostile))
    (set! (-> self already-shot) #f)
    (set! (-> self attacker-info callback)
          (lambda ((arg0 assault-crimson-guard) (arg1 city-attacker-info))
            (let* ((s5-0 (handle->process (-> arg1 proc)))
                   (s4-0 (if (type? s5-0 process-focusable)
                             (the-as process-focusable s5-0)
                             )
                         )
                   (s5-1 (new 'stack 'sphere))
                   )
              (set! (-> s5-1 quad) (-> s4-0 root root-prim prim-core world-sphere quad))
              (set! (-> s5-1 r) 409.6)
              (the-as
                int
                (and (sphere-in-view-frustum? s5-1) (< (vector-vector-xz-distance s5-1 (-> arg0 center-pos)) 98304.0))
                )
              )
            )
          )
    (set-time! (-> self state-time))
    (nav-enemy-method-181 self)
    (nav-enemy-method-183 self)
    (nav-enemy-method-177 self)
    (let ((a0-5 (-> self nav state))
          (v1-12 (-> self center-pos))
          )
      (logclear! (-> a0-5 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-5 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-5 target-pos quad) (-> v1-12 quad))
      )
    0
    )
  :trans (behavior ()
    (let ((gp-0 (-> self center-pos)))
      0.0
      (if (< (vector-vector-xz-distance (-> self root trans) gp-0) 40960.0)
          (go-virtual wait-for-enemies)
          )
      (when #f
        (let ((a0-2 (the-as process-focusable (handle->process (-> self target-status handle)))))
          (when a0-2
            (if (< (vector-vector-xz-distance (get-trans a0-2 0) gp-0) 102400.0)
                (go-hostile self)
                )
            )
          )
        )
      )
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info run-anim))) 300)
    )
  :post (behavior ()
    (nav-enemy-method-187 self)
    )
  )

(defstate wait-for-enemies (assault-crimson-guard)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (nav-enemy-method-182 self)
    (nav-enemy-method-184 self)
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (let ((a0-3 (the-as process-focusable (handle->process (-> self target-status handle)))))
        (when a0-3
          (if (< (vector-vector-xz-distance (get-trans a0-3 0) (-> self center-pos)) 122880.0)
              (go-hostile self)
              )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                  :num! (seek! max (-> self speed-scale))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self speed-scale)))
        )
      )
    #f
    )
  :post (behavior ()
    (enemy-common-post self)
    )
  )

(deftype special-health (health)
  ()
  )


;; WARN: Return type mismatch vector vs none.
(defmethod initialize-allocations ((this special-health))
  (call-parent-method this)
  (set-vector! (-> this root scale) 1.5 1.5 1.5 1.0)
  (none)
  )

(defbehavior special-health-init-by-other special-health ((arg0 vector))
  (set! (-> self pickup-amount) (-> *FACT-bank* health-default-inc))
  (set! (-> self pickup-type) (pickup-type health))
  (initialize-allocations self)
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-effects self (-> self pickup-type))
  (initialize-options self 0 1024.0 (the-as fact-info #f))
  (update-transforms (-> self root))
  (logior! (-> self flags) (collectable-flag fadeout no-distance-check-fadeout))
  (set! (-> self fadeout-timeout) (seconds 5))
  (go-to-initial-state self)
  )

(deftype ammo-special-pickup (process-focusable)
  ((ammo-type       pickup-type)
   (gun-type        pickup-type)
   (collect-effect  sparticle-launch-group)
   (ammo-effect     sparticle-launch-group)
   (anim-index      int32)
   )
  (:state-methods
    wait
    pickup
    )
  (:methods
    (init-pickup (_type_ vector pickup-type pickup-type) object)
    )
  )


(defbehavior ammo-special-pickup-init-by-other ammo-special-pickup ((arg0 pickup-type) (arg1 pickup-type))
  (stack-size-set! (-> self main-thread) 128)
  (let ((a2-0 (gun->ammo arg1)))
    (if (= a2-0 (pickup-type none))
        (set! a2-0 arg1)
        )
    (init-pickup self (the-as vector arg0) a2-0 arg1)
    )
  )

(defskelgroup skel-ammo-special-gun gun gun-lod0-jg -1
              ((gun-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1.5)
              :sort 1
              :origin-joint-index 3
              )

(defmethod init-pickup ((this ammo-special-pickup) (arg0 vector) (arg1 pickup-type) (arg2 pickup-type))
  (with-pp
    (logclear! (-> this mask) (process-mask actor-pause))
    (let ((s2-0 (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
      (set! (-> s2-0 dynam) (copy *standard-dynamics* 'process))
      (set! (-> s2-0 reaction) cshape-reaction-default)
      (set! (-> s2-0 no-reaction)
            (the-as (function collide-shape-moving collide-query vector vector object) nothing)
            )
      (let ((v1-8 (new 'process 'collide-shape-prim-sphere s2-0 (the-as uint 0))))
        (set! (-> v1-8 prim-core collide-as) (collide-spec collectable))
        (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list tobot))
        (set-vector! (-> v1-8 local-sphere) 0.0 3276.8 0.0 6553.6)
        (set! (-> s2-0 total-prims) (the-as uint 1))
        (set! (-> s2-0 root-prim) v1-8)
        )
      (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
      (let ((v1-11 (-> s2-0 root-prim)))
        (set! (-> s2-0 backup-collide-as) (-> v1-11 prim-core collide-as))
        (set! (-> s2-0 backup-collide-with) (-> v1-11 prim-core collide-with))
        )
      (set! (-> this root) s2-0)
      )
    (set! (-> this root trans quad) (-> arg0 quad))
    (set! (-> this ammo-type) arg1)
    (set! (-> this gun-type) arg2)
    (quaternion-rotate-y! (-> this root quat) (-> this root quat) (rand-vu-float-range 0.0 65536.0))
    (case (-> this ammo-type)
      (((pickup-type ammo-yellow))
       (set! (-> this collect-effect) (-> *part-group-id-table* 136))
       )
      (((pickup-type ammo-red))
       (set! (-> this collect-effect) (-> *part-group-id-table* 137))
       )
      (((pickup-type ammo-blue))
       (set! (-> this collect-effect) (-> *part-group-id-table* 138))
       )
      (((pickup-type ammo-dark))
       (set! (-> this collect-effect) (-> *part-group-id-table* 139))
       )
      (((pickup-type eco-pill-dark))
       (set! (-> this collect-effect) (-> *part-group-id-table* 140))
       (set! (-> this part) (create-launch-control (-> *part-group-id-table* 128) this))
       )
      )
    (case (-> this ammo-type)
      (((pickup-type ammo-red) (pickup-type ammo-yellow) (pickup-type ammo-blue) (pickup-type ammo-dark))
       (set! (-> pp level) (-> *target* level))
       (initialize-skeleton
         this
         (the-as skeleton-group (art-group-get-by-name *level* "skel-ammo-special-gun" (the-as (pointer level) #f)))
         (the-as pair 0)
         )
       (ja-channel-push! 1 0)
       (let ((a1-15 (cond
                      ((= arg2 (pickup-type gun-yellow-1))
                       (-> this draw art-group data 19)
                       )
                      ((= arg2 (pickup-type gun-yellow-2))
                       (-> this draw art-group data 20)
                       )
                      ((= arg2 (pickup-type gun-yellow-3))
                       (-> this draw art-group data 21)
                       )
                      ((= arg2 (pickup-type gun-red-1))
                       (-> this draw art-group data 13)
                       )
                      ((= arg2 (pickup-type gun-red-2))
                       (-> this draw art-group data 14)
                       )
                      ((= arg2 (pickup-type gun-red-3))
                       (-> this draw art-group data 15)
                       )
                      ((= arg2 (pickup-type gun-blue-1))
                       (-> this draw art-group data 22)
                       )
                      ((= arg2 (pickup-type gun-blue-2))
                       (-> this draw art-group data 23)
                       )
                      ((= arg2 (pickup-type gun-blue-3))
                       (-> this draw art-group data 24)
                       )
                      ((= arg2 (pickup-type gun-dark-2))
                       (-> this draw art-group data 17)
                       )
                      ((= arg2 (pickup-type gun-dark-3))
                       (-> this draw art-group data 18)
                       )
                      (else
                        (-> this draw art-group data 16)
                        )
                      )
                    )
             (a0-30 (-> this skel root-channel 0))
             )
         (set! (-> a0-30 frame-group) (the-as art-joint-anim a1-15))
         (joint-control-channel-group-eval! a0-30 (the-as art-joint-anim a1-15) num-func-identity)
         )
       (set-vector! (-> this root scale) 2.0 2.0 2.0 1.0)
       )
      )
    (case (-> this ammo-type)
      (((pickup-type ammo-yellow))
       (set! (-> this ammo-effect) (-> *part-group-id-table* 164))
       )
      (((pickup-type ammo-red))
       (set! (-> this ammo-effect) (-> *part-group-id-table* 158))
       )
      (((pickup-type ammo-blue))
       (set! (-> this ammo-effect) (-> *part-group-id-table* 154))
       )
      (((pickup-type ammo-dark))
       (set! (-> this ammo-effect) (-> *part-group-id-table* 129))
       )
      )
    (update-transforms (-> this root))
    (go (method-of-object this wait))
    )
  )

(defstate wait (ammo-special-pickup)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (when (and (or (= message 'touch) (= message 'attack))
               (not (and (-> self next-state) (= (-> self next-state name) 'pickup)))
               )
      (process-contact-action proc)
      (go-virtual pickup)
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (nonzero? (-> self part))
        (spawn (-> self part) (-> self root trans))
        )
    (when (nonzero? (-> self draw))
      (let* ((f1-2 (lerp-scale-clamp 0.0 1.0 (* 0.0033333334 (the float (- (current-time) (-> self state-time)))) 3.0 5.0))
             (f0-3 (fmax 0.0 (fmin 1.0 f1-2)))
             )
        (logior! (-> self draw status) (draw-control-status force-fade))
        (set! (-> self draw force-fade) (the-as uint (the int (lerp 128.0 0.0 f0-3))))
        )
      )
    (if (time-elapsed? (-> self state-time) (seconds 5))
        (go empty-state)
        )
    )
  :code sleep-code
  :post (behavior ()
    (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* 40049.777 (seconds-per-frame)))
    (ja-post)
    )
  )

(defstate pickup (ammo-special-pickup)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (if (nonzero? (-> self draw))
        (logior! (-> self draw status) (draw-control-status no-draw))
        )
    (sound-play "ammo-pickup")
    (send-event (ppointer->process (-> self parent)) 'ammo-special (-> self ammo-type) (-> self gun-type))
    (when (nonzero? (-> self collect-effect))
      (cond
        ((logtest? (-> self collect-effect flags) (sp-group-flag sp13))
         (set! (-> *launch-matrix* trans quad) (-> self root root-prim prim-core world-sphere quad))
         (part-tracker-spawn
           part-tracker-subsampler
           :to *target*
           :group (-> self collect-effect)
           :callback part-tracker-track-target
           )
         )
        (else
          (set! (-> *launch-matrix* trans quad) (-> self root root-prim prim-core world-sphere quad))
          (part-tracker-spawn
            part-tracker
            :to *target*
            :group (-> self collect-effect)
            :callback part-tracker-track-target
            )
          )
        )
      )
    )
  :code (behavior ()
    (while (-> self child)
      (suspend)
      )
    (go empty-state)
    )
  )

(deftype assault-bombbot (bombbot)
  ((next-node                 int32)
   (new-point-choose-time     time-frame)
   (max-hp                    float  :offset 1532)
   (is-final?                 symbol)
   (last-charge-player-count  uint32)
   (suck-level                int32)
   )
  (:methods
    (assault-bombbot-method-209 (_type_) int)
    )
  )


(defstate explode (assault-bombbot)
  :virtual #t
  :enter (behavior ()
    (send-event (ppointer->process (-> self parent)) 'bombbot-death)
    (let ((gp-0 (new 'stack 'sphere)))
      (set! (-> gp-0 quad) (-> self root trans quad))
      (set! (-> gp-0 r) 409600.0)
      (let ((s5-0 (new 'stack-no-clear 'array 'collide-shape 384)))
        (countdown (s4-0 (fill-actor-list-for-box *actor-hash* gp-0 s5-0 384))
          (let* ((s3-0 (-> s5-0 s4-0))
                 (v1-11 (if (type? s3-0 collide-shape)
                            s3-0
                            )
                        )
                 )
            (when v1-11
              (let* ((s3-1 (-> v1-11 process))
                     (a0-9 (if (type? s3-1 process-focusable)
                               s3-1
                               )
                           )
                     )
                (when a0-9
                  (if (and a0-9 (logtest? (process-mask guard) (-> a0-9 mask)) (not (logtest? (process-mask enemy) (-> a0-9 mask))))
                      (send-event
                        a0-9
                        'attack
                        #f
                        (static-attack-info
                          :mask (vehicle-impulse-factor)
                          ((id (new-attack-id)) (damage 16.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'explode))
                          )
                        )
                      )
                  )
                )
              )
            )
          )
        )
      (let* ((s4-1 *target*)
             (s5-1 (if (type? s4-1 process-focusable)
                       s4-1
                       )
                   )
             )
        (when (and s5-1 (< (vector-vector-distance (get-trans s5-1 0) gp-0) (-> gp-0 r)))
          (if (and s5-1 (logtest? (process-mask guard) (-> s5-1 mask)) (not (logtest? (process-mask enemy) (-> s5-1 mask))))
              (send-event
                s5-1
                'attack
                #f
                (static-attack-info
                  :mask (vehicle-impulse-factor)
                  ((id (new-attack-id)) (damage 16.0) (vehicle-damage-factor 1.0) (vehicle-impulse-factor 1.0) (mode 'explode))
                  )
                )
              )
          )
        )
      )
    (call-parent-state-handler enter)
    )
  )

(defmethod enemy-common-post ((this assault-bombbot))
  (call-parent-method this)
  (none)
  )

(deftype assault-bombbot-spawn-params (bombbot-spawn-params)
  ((is-final?   symbol)
   (suck-level  int32)
   )
  )


(defbehavior assault-bombbot-init-by-other assault-bombbot ((arg0 assault-bombbot-spawn-params))
  (set! (-> self is-final?) (-> arg0 is-final?))
  (set! (-> self suck-level) (-> arg0 suck-level))
  (bombbot-init-by-other arg0)
  )

;; WARN: Return type mismatch float vs none.
(defmethod init-enemy! ((this assault-bombbot))
  (with-pp
    (set! (-> pp level) (level-get *level* 'lctyass))
    (call-parent-method this)
    (cond
      ((-> this is-final?)
       (set! (-> this max-hp) 61.0)
       )
      (else
        0.0
        (let* ((f1-0 (lerp-scale-clamp 1.0 0.5 (the float (-> this suck-level)) 5.0 10.0))
               (f0-5 (fmax 0.0 (fmin 1.0 f1-0)))
               )
          (set! (-> this max-hp) (* 250.0 f0-5))
          )
        (format 0 "Max hp ~f~%" (-> this max-hp))
        )
      )
    (set! (-> this hit-points) (-> this max-hp))
    (none)
    )
  )

(defmethod bombbot-method-205 ((this assault-bombbot))
  (when (= (-> this nav state mesh) *default-nav-mesh*)
    (let ((a0-4 (find-nearest-nav-mesh (-> this root trans) (the-as float #x7f800000))))
      (when a0-4
        (change-to a0-4 this)
        (dotimes (s5-0 4)
          (let ((s4-0 (-> this feet s5-0)))
            (let ((s3-0 (new 'stack-no-clear 'vector)))
              (vector-orient-by-quat! s3-0 (-> s4-0 pos-offset) (-> this root quat))
              (vector+! s3-0 s3-0 (-> this root trans))
              (set! (-> s4-0 next-position quad) (-> s3-0 quad))
              (set! (-> s4-0 position quad) (-> s3-0 quad))
              )
            (set! (-> s4-0 delta-y) 0.0)
            )
          (set! (-> this legs-strength s5-0) 1.0)
          )
        )
      )
    )
  0
  (none)
  )

(deftype assault-bombbot-shot (bombbot-shot)
  ()
  )


(if #t
    (set! *curve-assault-bombbot-shot-color-blue* (new 'static 'curve-color-fast
                                                    :xs (new 'static 'vector :y -1.0 :z -2.0 :w -3.0)
                                                    :ys (new 'static 'inline-array vector 4
                                                      (new 'static 'vector :z 1.0 :w 128.0)
                                                      (new 'static 'vector :z 1.0 :w 128.0)
                                                      (new 'static 'vector :z 1.0 :w 128.0)
                                                      (new 'static 'vector :z 1.0 :w 128.0)
                                                      )
                                                    :one-over-x-deltas (new 'static 'vector :x 1.0 :y 1.0 :z 1.0 :w 1.0)
                                                    )
          )
    )

(if #t
    (set! *curve-assault-bombbot-shot-width* (new 'static 'curve2d-fast
                                               :xs (new 'static 'vector :y -1.0 :z -2.0 :w -3.0)
                                               :ys (new 'static 'vector :x 0.5 :y 1.0 :z 2.0 :w 3.0)
                                               :one-over-x-deltas (new 'static 'vector :x 0.5 :y 1.0 :z 1.0 :w 1.0)
                                               )
          )
    )

(if (or (zero? *assault-bombbot-trail*) (!= loading-level global))
    (set! *assault-bombbot-trail* (new 'loading-level 'light-trail-composition))
    )

(set! (-> *assault-bombbot-trail* color-mode) (the-as uint 0))

(set! (-> *assault-bombbot-trail* color-repeat-dist) 4096.0)

(set! (-> *assault-bombbot-trail* alpha-1-mode) (the-as uint 0))

(set! (-> *assault-bombbot-trail* alpha-2-mode) (the-as uint 6))

(set! (-> *assault-bombbot-trail* base-alpha) 1.0)

(set! (-> *assault-bombbot-trail* alpha-repeat-dist) 4096.0)

(set! (-> *assault-bombbot-trail* width-mode) (the-as uint 1))

(set! (-> *assault-bombbot-trail* base-width) 819.2)

(set! (-> *assault-bombbot-trail* width-repeat-dist) 8192.0)

(set! (-> *assault-bombbot-trail* uv-mode) (the-as uint 3))

(set! (-> *assault-bombbot-trail* uv-repeat-dist) 4096000.0)

(set! (-> *assault-bombbot-trail* lie-mode) (lie-mode appearance0))

(set! (-> *assault-bombbot-trail* max-age) (seconds 0.1))

(if #f
    (set! (-> *assault-bombbot-trail* tex-id) (lookup-texture-id-by-name (the-as string #f) (the-as string #f)))
    (set! (-> *assault-bombbot-trail* tex-id) (new 'static 'texture-id :index #x3 :page #x1))
    )

(set! (-> *assault-bombbot-trail* width-curve) (the-as curve2d-piecewise *curve-assault-bombbot-shot-width*))

(set! (-> *assault-bombbot-trail* color-curve) (the-as curve-color-piecewise *trail-color-curve-white*))

(set! (-> *assault-bombbot-trail* alpha-curve-1) (the-as curve2d-piecewise *curve-linear-down*))

(set! (-> *assault-bombbot-trail* alpha-curve-2) #f)

(set! (-> *assault-bombbot-trail* zbuffer?) #f)

(set! (-> *assault-bombbot-trail* lie-vector quad) (-> *up-vector* quad))

(set! (-> *assault-bombbot-trail* use-tape-mode?) #f)

(set! (-> *assault-bombbot-trail* blend-mode) (the-as uint 1))

(set! (-> *assault-bombbot-trail* frame-stagger) (the-as uint 1))

(if (or (zero? *assault-bombbot-trail-2*) (!= loading-level global))
    (set! *assault-bombbot-trail-2* (new 'loading-level 'light-trail-composition))
    )

(set! (-> *assault-bombbot-trail-2* color-mode) (the-as uint 0))

(set! (-> *assault-bombbot-trail-2* color-repeat-dist) 4096.0)

(set! (-> *assault-bombbot-trail-2* alpha-1-mode) (the-as uint 0))

(set! (-> *assault-bombbot-trail-2* alpha-2-mode) (the-as uint 6))

(set! (-> *assault-bombbot-trail-2* base-alpha) 1.0)

(set! (-> *assault-bombbot-trail-2* alpha-repeat-dist) 4096.0)

(set! (-> *assault-bombbot-trail-2* width-mode) (the-as uint 1))

(set! (-> *assault-bombbot-trail-2* base-width) 3276.8)

(set! (-> *assault-bombbot-trail-2* width-repeat-dist) 8192.0)

(set! (-> *assault-bombbot-trail-2* uv-mode) (the-as uint 3))

(set! (-> *assault-bombbot-trail-2* uv-repeat-dist) 4096000.0)

(set! (-> *assault-bombbot-trail-2* lie-mode) (lie-mode appearance0))

(set! (-> *assault-bombbot-trail-2* max-age) (seconds 0.1))

(if #f
    (set! (-> *assault-bombbot-trail-2* tex-id) (lookup-texture-id-by-name (the-as string #f) (the-as string #f)))
    (set! (-> *assault-bombbot-trail-2* tex-id) (new 'static 'texture-id :index #x3 :page #x1))
    )

(set! (-> *assault-bombbot-trail-2* width-curve)
      (the-as curve2d-piecewise *curve-assault-bombbot-shot-width*)
      )

(set! (-> *assault-bombbot-trail-2* color-curve)
      (the-as curve-color-piecewise *curve-assault-bombbot-shot-color-blue*)
      )

(set! (-> *assault-bombbot-trail-2* alpha-curve-1) (the-as curve2d-piecewise *curve-linear-down*))

(set! (-> *assault-bombbot-trail-2* alpha-curve-2) #f)

(set! (-> *assault-bombbot-trail-2* zbuffer?) #f)

(set! (-> *assault-bombbot-trail-2* lie-vector quad) (-> *up-vector* quad))

(set! (-> *assault-bombbot-trail-2* use-tape-mode?) #f)

(set! (-> *assault-bombbot-trail-2* blend-mode) (the-as uint 1))

(set! (-> *assault-bombbot-trail-2* frame-stagger) (the-as uint 1))

(defpartgroup group-dummy-explode-assault-bombbot-explode
  :id 1435
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 4717 :flags (sp7) :period (seconds 20) :length (seconds 0.035))
    (sp-item 4718 :flags (sp7) :period (seconds 20) :length (seconds 0.035))
    (sp-item 4719 :flags (is-3d sp7) :period (seconds 20) :length (seconds 0.035))
    )
  )

(defpart 4717
  :init-specs ((:texture (colorflash level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 2) (meters 6))
    (:rot-x (degrees 22.5))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 128.0)
    (:scalevel-x (meters -0.033333335))
    (:scalevel-y :copy scalevel-x)
    (:timer (seconds 0.067))
    (:flags (sp-cpuinfo-flag-3 glow))
    (:rotate-y (degrees 0))
    )
  )

(defpart 4718
  :init-specs ((:texture (ring level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 10))
    (:rot-x (degrees 22.5))
    (:scale-y :copy scale-x)
    (:r 0.0)
    (:g 32.0)
    (:b 128.0)
    (:a 8.0)
    (:timer (seconds 0.035))
    (:flags (sp-cpuinfo-flag-3 glow))
    (:rotate-y (degrees 0))
    )
  )

(defpart 4719
  :init-specs ((:texture (glow-soft level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 20))
    (:scale-y :copy scale-x)
    (:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:a 64.0)
    (:fade-a -3.2)
    (:timer (seconds 0.067))
    (:flags (sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0))
    )
  )

(defmethod projectile-method-26 ((this assault-bombbot-shot))
  (cond
    ((logtest? (-> *part-group-id-table* 1435 flags) (sp-group-flag sp13))
     (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
     (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 1435))
     )
    (else
      (set! (-> *launch-matrix* trans quad) (-> this root trans quad))
      (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 1435))
      )
    )
  ((method-of-type guard-shot projectile-method-26) this)
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod init-proj-settings! ((this assault-bombbot-shot))
  (call-parent-method this)
  (let ((gp-0 (new 'stack-no-clear 'light-trail-tracker-spawn-params)))
    (set! (-> gp-0 tracked-obj) (process->handle this))
    (set! (-> gp-0 appearance) *assault-bombbot-trail*)
    (set! (-> gp-0 max-num-crumbs) (the int (* 0.25 (the float (-> gp-0 appearance max-age)))))
    (set! (-> gp-0 track-immediately?) #t)
    (let* ((v1-11 (estimate-light-trail-mem-usage
                    (the-as uint (-> gp-0 max-num-crumbs))
                    (the-as uint (= (-> gp-0 appearance lie-mode) (lie-mode use-two-strips)))
                    )
                  )
           (s5-1 (get-process *default-dead-pool* light-trail-tracker-projectile (+ v1-11 8192) 1))
           (v1-12 (when s5-1
                    (let ((t9-4 (method-of-type process activate)))
                      (t9-4 s5-1 *target* "light-trail" (the-as pointer #x70004000))
                      )
                    (run-now-in-process s5-1 light-trail-tracker-init-by-other gp-0)
                    (-> s5-1 ppointer)
                    )
                  )
           )
      (if v1-12
          (-> v1-12 0 self)
          )
      )
    (set! (-> gp-0 appearance) *assault-bombbot-trail-2*)
    (let* ((v1-20 (estimate-light-trail-mem-usage
                    (the-as uint (-> gp-0 max-num-crumbs))
                    (the-as uint (= (-> gp-0 appearance lie-mode) (lie-mode use-two-strips)))
                    )
                  )
           (s5-2 (get-process *default-dead-pool* light-trail-tracker-projectile (+ v1-20 8192) 1))
           (v1-21 (when s5-2
                    (let ((t9-8 (method-of-type process activate)))
                      (t9-8 s5-2 *target* "light-trail" (the-as pointer #x70004000))
                      )
                    (run-now-in-process s5-2 light-trail-tracker-init-by-other gp-0)
                    (-> s5-2 ppointer)
                    )
                  )
           )
      (if v1-21
          (-> v1-21 0 self)
          )
      )
    )
  (none)
  )

(defmethod projectile-method-25 ((this assault-bombbot-shot))
  0
  (none)
  )

;; WARN: Return type mismatch (pointer process) vs (pointer projectile).
(defmethod fire-shot ((this assault-bombbot) (arg0 vector) (arg1 vector))
  (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0)))
      819200.0
      (let ((f0-1 2.0))
        (set! (-> gp-0 ent) (-> this entity))
        (set! (-> gp-0 charge) 1.0)
        (set! (-> gp-0 options) (projectile-options))
        (logclear! (-> gp-0 options) (projectile-options po14 po15 po16))
        (set! (-> gp-0 notify-handle) (process->handle this))
        (set! (-> gp-0 owner-handle) (the-as handle #f))
        (set! (-> gp-0 target-handle) (the-as handle #f))
        (set! (-> gp-0 target-pos quad) (the-as uint128 0))
        (set! (-> gp-0 ignore-handle) (process->handle this))
        (let* ((a0-15 *game-info*)
               (a2-12 (+ (-> a0-15 attack-id) 1))
               )
          (set! (-> a0-15 attack-id) a2-12)
          (set! (-> gp-0 attack-id) a2-12)
          )
        (set! (-> gp-0 timeout) (seconds 4))
        (set! (-> gp-0 damage) f0-1)
        )
      (logior! (-> gp-0 options) (projectile-options po14))
      (set! (-> gp-0 pos quad) (-> arg0 quad))
      (vector-normalize-copy! (-> gp-0 vel) v1-1 1.0)
      )
    (the-as (pointer projectile) (spawn-projectile assault-bombbot-shot gp-0 this *default-dead-pool*))
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod bombbot-method-196 ((this assault-bombbot) (arg0 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s4-0 *target*)
           (gp-0 (if (type? s4-0 process-focusable)
                     s4-0
                     )
                 )
           )
      (cond
        (gp-0
          (set! (-> this target-pos quad) (-> (get-trans gp-0 3) quad))
          (let ((v1-3 (-> this target-pos)))
            (let ((a0-4 (-> gp-0 control trans)))
              (let ((a1-4 (-> gp-0 control transv)))
                (let ((a2-0 0.0))
                  (.mov vf7 a2-0)
                  )
                (.lvf vf5 (&-> a1-4 quad))
                )
              (.lvf vf4 (&-> a0-4 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-3 quad) vf6)
            )
          (set! (-> this start-target-pos quad) (-> this target-pos quad))
          (set! (-> this start-target-vel quad) (-> gp-0 control transv quad))
          (try-update-focus (-> this focus) gp-0 this)
          )
        (else
          (clear-focused (-> this focus))
          )
        )
      )
    (none)
    )
  )

(defmethod assault-bombbot-method-209 ((this assault-bombbot))
  (local-vars (s4-1 object))
  (let ((s5-0 (rand-vu-int-count-excluding
                (the-as int (+ (-> this city-path node-count) -1))
                (the-as int (-> this current-node))
                )
              )
        )
    (+! (-> this last-charge-player-count) 1)
    (let ((s4-0 (handle->process (-> this focus handle))))
      (when (or (not (and (if (type? s4-0 process-focusable)
                              s4-0
                              )
                          (begin
                            (let* ((s4-2 #t)
                                   (s3-0 (handle->process (-> this focus handle)))
                                   (v1-13 (the-as focus-status (logand (-> (the-as process-focusable (if (type? s3-0 process-focusable)
                                                                                                         (the-as process-focusable s3-0)
                                                                                                         )
                                                                                   )
                                                                           focus-status
                                                                           )
                                                                       (focus-status disable dead ignore grabbed)
                                                                       )
                                                  )
                                          )
                                   )
                              (cmove-#f-nonzero s4-1 v1-13 s4-2)
                              )
                            s4-1
                            )
                          )
                     )
                (logtest? (-> this last-charge-player-count) 1)
                )
        (set! s5-0 s5-0)
        (goto cfg-36)
        )
      )
    (let ((s4-4 (vector-! (new 'stack-no-clear 'vector) (-> this target-pos) (-> this root trans))))
      0.0
      (set! (-> s4-4 y) 0.0)
      (vector-normalize-ret-len! s4-4 1.0)
      (let ((f30-0 0.3))
        (dotimes (s3-1 (the-as int (-> this city-path node-count)))
          (when (!= s3-1 (-> this current-node))
            (let ((s2-1
                    (vector-! (new 'stack-no-clear 'vector) (the-as vector (-> this city-path node s3-1)) (-> this root trans))
                    )
                  )
              0.0
              (set! (-> s2-1 y) 0.0)
              (vector-normalize! s2-1 1.0)
              (let ((f28-0 (vector-dot s4-4 s2-1)))
                (when (and (< f30-0 f28-0)
                           (< 40960.0 (vector-vector-xz-distance (-> this root trans) (the-as vector (-> this city-path node s3-1))))
                           )
                  (set! f30-0 f28-0)
                  (set! s5-0 s3-1)
                  )
                )
              )
            )
          )
        )
      )
    (label cfg-36)
    s5-0
    )
  )

(define *bombbot-bomb-hp-thresholds* (new 'static 'boxed-array :type float 0.7 0.4))

(defstate drop-bombs (assault-bombbot)
  :virtual #t
  :enter (behavior ()
    (call-parent-state-handler enter)
    (set! (-> self drop-num) (the-as uint 3))
    )
  )

(defmethod bombbot-method-208 ((this assault-bombbot) (arg0 vector) (arg1 vector))
  (set! (-> arg1 quad) (-> this target-pos quad))
  (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0)))
    0.0
    (let* ((f0-1 (vector-normalize-ret-len! s4-1 1.0))
           (f0-2 (fmin 30720.0 f0-1))
           )
      (vector+float*! arg1 arg0 s4-1 f0-2)
      )
    )
  arg1
  )

(define *look-time* (seconds 4))

(defstate hostile (assault-bombbot)
  :virtual #t
  :enter (behavior ()
    (set! (-> self attacker-info) (allocate-attacker *cty-attack-controller*))
    (init! (-> self attacker-info) self 13)
    (set! (-> self next-node) (the-as int (-> self current-node)))
    (set-time! (-> self state-time))
    (set-time! (-> self stop-shoot))
    (call-parent-state-handler enter)
    )
  :exit (behavior ()
    (remove-attacker *cty-attack-controller* (-> self attacker-info))
    (let ((t9-2 (-> (find-parent-state) exit)))
      (if t9-2
          (t9-2)
          )
      )
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (not (-> self is-final?))
        (let ((f30-0 (/ (-> self hit-points) (-> self max-hp))))
          (when (time-elapsed? (-> self stop-shoot) (seconds 6))
            (dotimes (gp-0 (-> *bombbot-bomb-hp-thresholds* length))
              (if (and (>= (-> *bombbot-bomb-hp-thresholds* gp-0) f30-0)
                       (>= f30-0 (+ -0.1 (-> *bombbot-bomb-hp-thresholds* gp-0)))
                       )
                  (go-virtual drop-bombs)
                  )
              )
            )
          )
        )
      (when (< (-> self next-target) (current-time))
        (let ((a1-0 (new 'stack-no-clear 'vector)))
          (set! (-> a1-0 quad) (-> self root trans quad))
          (set! (-> a1-0 w) 204800.0)
          (bombbot-method-196 self a1-0)
          )
        (set! (-> self next-target) (+ (current-time) (seconds 8)))
        (set! (-> self gun-type) (the-as uint 0))
        0
        )
      (let ((v1-33 (the-as process-focusable (handle->process (-> self focus handle)))))
        (when v1-33
          (when (< (current-time) (+ (-> self next-target) (seconds -2)))
            (set-time! (-> self start-target))
            (set! (-> self start-target-pos quad) (-> v1-33 root trans quad))
            (set! (-> self start-target-vel quad) (-> v1-33 root transv quad))
            (vector-! (-> self target-delta) (-> v1-33 root trans) (-> self root trans))
            )
          (let ((a2-2 (-> self target-pos)))
            (let ((a0-23 (-> self start-target-pos)))
              (let ((a1-12 (-> self start-target-vel)))
                (let ((a3-4 (* 0.0033333334 (the float (- (current-time) (-> self start-target))))))
                  (.mov vf7 a3-4)
                  )
                (.lvf vf5 (&-> a1-12 quad))
                )
              (.lvf vf4 (&-> a0-23 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a2-2 quad) vf6)
            )
          (if (= (-> v1-33 type) target)
              (set! (-> self target-pos quad) (-> self start-target-pos quad))
              )
          (if (< (+ (-> self next-target) (seconds -1)) (current-time))
              (bombbot-method-197 self)
              (bombbot-method-204 self)
              )
          )
        )
      (bombbot-method-205 self)
      (new 'stack-no-clear 'vector)
      (let ((f0-8 (* 0.25 (+ (-> self feet 0 next-position y)
                             (-> self feet 1 next-position y)
                             (-> self feet 2 next-position y)
                             (-> self feet 3 next-position y)
                             )
                     )
                  )
            )
        (if (!= (-> self nav state mesh) *default-nav-mesh*)
            (+! (-> self root trans y) (* 4.0 (seconds-per-frame) (- f0-8 (-> self root trans y))))
            )
        )
      (if (= (vector-length (-> self root transv)) 0.0)
          (set-time! (-> self state-time))
          )
      (bombbot-method-202 self)
      (bombbot-method-195 self)
      )
    )
  :post (behavior ()
    (let ((v1-0 1200))
      (if (= (logand (-> self last-charge-player-count) 1) 1)
          (set! v1-0 600)
          )
      (when (and (time-elapsed? (-> self new-point-choose-time) v1-0)
                 (>= (+ (-> self next-target) (seconds -1)) (current-time))
                 )
        (set! (-> self next-node) (assault-bombbot-method-209 self))
        (set-time! (-> self new-point-choose-time))
        )
      )
    (-> self current-node)
    (let ((gp-0 (-> self next-node)))
      (cond
        ((= (-> self nav state mesh) *default-nav-mesh*)
         (vector-v+!
           (-> self root trans)
           (-> self root trans)
           (vector-normalize!
             (vector-! (new 'stack-no-clear 'vector) (the-as vector (-> self city-path node gp-0)) (-> self root trans))
             (-> *bombbot-nav-enemy-info* run-travel-speed)
             )
           )
         (seek! (-> self root trans y) (-> self city-path node gp-0 position y) (* 16384.0 (seconds-per-frame)))
         (enemy-common-post self)
         (update-transforms (-> self root))
         )
        (else
          (let ((v1-29 (-> self nav state))
                (a0-20 (-> self city-path node gp-0))
                )
            (logclear! (-> v1-29 flags) (nav-state-flag directional-mode))
            (logior! (-> v1-29 flags) (nav-state-flag target-poly-dirty))
            (set! (-> v1-29 target-pos quad) (-> a0-20 position quad))
            )
          0
          (nav-enemy-method-187 self)
          )
        )
      (when (< (vector-vector-xz-distance (-> self root trans) (the-as vector (-> self city-path node gp-0))) 24576.0)
        (set! (-> self current-node) (the-as uint gp-0))
        (set! (-> self next-node) (assault-bombbot-method-209 self))
        )
      )
    )
  )
