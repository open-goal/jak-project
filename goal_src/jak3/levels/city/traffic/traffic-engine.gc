;;-*-Lisp-*-
(in-package goal)

;; name: traffic-engine.gc
;; name in dgo: traffic-engine
;; dgos: DESRESC, WWD, CWI

(deftype traffic-engine-stack-var0 (structure)
  ((params traffic-object-spawn-params :inline :offset 0)
   (vec0   vector                      :inline :offset 128)
   (vec1   vector                      :inline :offset 144)
   (vec2   vector                      :inline :offset 160)
   (vec3   vector                      :inline :offset 176)
   )
  )

(declare-type hvehicle vehicle)

;; DECOMP BEGINS

(define *traffic-suppress-activation* #f)

(defun get-level-nav-graph-by-id ((arg0 int))
  (dotimes (v1-0 (-> *level* length))
    (let ((a1-3 (-> *level* level v1-0)))
      (when (= (-> a1-3 status) 'active)
        (when (and (!= (-> a1-3 bsp city-level-info) 0) (!= (-> a1-3 bsp city-level-info nav-graph) 0))
          (let ((a1-6 (-> a1-3 bsp city-level-info nav-graph)))
            (if (and (!= a1-6 0) (= (-> a1-6 id) arg0))
                (return a1-6)
                )
            )
          )
        )
      )
    )
  (the-as nav-graph #f)
  )

(defmethod for-all-active-processes ((this traffic-tracker) (arg0 (function process-focusable traffic-object-type-info none)))
  (let ((s4-0 (-> this traffic)))
    (countdown (s3-0 (-> this active-object-count))
      (let ((a1-1 (-> s4-0 object-type-info-array (-> this active-object-type-list s3-0)))
            (a0-2 (handle->process (-> this active-object-list s3-0)))
            )
        (if (not (focus-test? (the-as process-focusable a0-2) inactive))
            (arg0 (the-as process-focusable a0-2) a1-1)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod for-all-active-processes-of-type ((this traffic-tracker) (arg0 traffic-type) (arg1 (function process-focusable traffic-object-type-info none)))
  (let ((s3-0 (-> this traffic)))
    (countdown (s2-0 (-> this active-object-count))
      (let ((a0-1 (-> this active-object-type-list s2-0)))
        (when (= a0-1 arg0)
          (let ((a1-1 (-> s3-0 object-type-info-array a0-1))
                (a0-3 (handle->process (-> this active-object-list s2-0)))
                )
            (if (not (focus-test? (the-as process-focusable a0-3) inactive))
                (arg1 (the-as process-focusable a0-3) a1-1)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod add-active-process ((this traffic-tracker) (arg0 traffic-type) (arg1 handle))
  (let ((v1-0 (-> this active-object-count)))
    (when (< v1-0 (the-as uint 126))
      (set! (-> this active-object-list v1-0) arg1)
      (set! (-> this active-object-type-list v1-0) arg0)
      (+! (-> this active-object-count) 1)
      (let ((v1-6 (-> this traffic object-type-info-array arg0)))
        (+! (-> v1-6 active-count) 1)
        )
      )
    )
  0
  (none)
  )

(defmethod remove-active-process ((this traffic-tracker) (arg0 int))
  (let ((v0-0 (-> this active-object-list arg0)))
    (let ((v1-3 (-> this active-object-type-list arg0))
          (a2-1 (+ (-> this active-object-count) -1))
          )
      (when (>= a2-1 0)
        (set! (-> this active-object-list arg0) (-> this active-object-list a2-1))
        (set! (-> this active-object-type-list arg0) (-> this active-object-type-list a2-1))
        (+! (-> this active-object-count) -1)
        (let ((v1-6 (-> this traffic object-type-info-array v1-3)))
          (+! (-> v1-6 active-count) -1)
          )
        )
      )
    v0-0
    )
  )

(defmethod add-reserved-process ((this traffic-tracker) (arg0 traffic-type) (arg1 handle))
  (let* ((v1-2 (-> this traffic object-type-info-array arg0))
         (a1-2 (-> v1-2 inactive-count))
         )
    (when (< a1-2 20)
      (set! (-> v1-2 array a1-2) arg1)
      (+! (-> v1-2 inactive-count) 1)
      (+! (-> v1-2 reserve-count) 1)
      (+! (-> this inactive-object-count) 1)
      )
    )
  0
  (none)
  )

(defmethod get-from-inactive-by-type ((this traffic-tracker) (arg0 traffic-type))
  (let ((v1-2 (-> this traffic object-type-info-array arg0))
        (a1-2 0)
        (v0-0 (the-as handle #f))
        )
    (let ((a2-1 (+ (-> v1-2 inactive-count) -1)))
      (when (>= a2-1 0)
        (set! v0-0 (-> v1-2 array a1-2))
        (set! (-> v1-2 array a1-2) (-> v1-2 array a2-1))
        (+! (-> v1-2 inactive-count) -1)
        (+! (-> v1-2 reserve-count) -1)
        (+! (-> this inactive-object-count) -1)
        )
      )
    v0-0
    )
  )

(defmethod get-from-inactive-by-handle ((this traffic-tracker) (arg0 traffic-type) (arg1 handle))
  (let ((v1-2 (-> this traffic object-type-info-array arg0))
        (v0-0 (the-as handle #f))
        )
    (let* ((a3-0 (+ (-> v1-2 inactive-count) -1))
           (a1-3 a3-0)
           )
      (while (and (>= a1-3 0) (!= (-> v1-2 array a1-3) arg1))
        (+! a1-3 -1)
        )
      (when (>= a1-3 0)
        (set! v0-0 (-> v1-2 array a1-3))
        (set! (-> v1-2 array a1-3) (-> v1-2 array a3-0))
        (+! (-> v1-2 inactive-count) -1)
        (+! (-> this inactive-object-count) -1)
        )
      )
    v0-0
    )
  )

(defmethod deactivate-object ((this traffic-tracker) (arg0 int) (arg1 symbol))
  (with-pp
    (let* ((s3-0 (-> this active-object-type-list arg0))
           (s5-0 'traffic-off)
           (s2-0 (remove-active-process this arg0))
           (s1-0 (handle->process s2-0))
           (v1-5 (the-as object #t))
           )
      (when s1-0
        (when (not (focus-test? (the-as process-focusable s1-0) inactive))
          (if arg1
              (set! s5-0 'traffic-off-force)
              )
          (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-2 from) (process->ppointer pp))
            (set! (-> a1-2 num-params) 0)
            (set! (-> a1-2 message) s5-0)
            (set! v1-5 (send-event-function s1-0 a1-2))
            )
          )
        (cond
          (v1-5
            (add-reserved-process this s3-0 s2-0)
            )
          (else
            (add-active-process this s3-0 s2-0)
            (when *debug-segment*
              (when arg1
                (format 0 "traffic-engine::deactivate-object: ~s event refused~%" s5-0)
                (format 0 "obj ~s~%" s1-0)
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod set-process-to-killed ((this traffic-tracker) (arg0 process))
  (let ((v1-0 -1))
    (let ((a0-3 (process->handle arg0))
          (a1-4 (-> this active-object-count))
          )
      (b! #t cfg-8 :delay (nop!))
      (label cfg-6)
      (+! a1-4 -1)
      (b! (!= (-> this active-object-list a1-4) a0-3) cfg-8 :delay (empty-form))
      (set! v1-0 (the-as int a1-4))
      (b! #t cfg-10 :delay (nop!))
      (label cfg-8)
      (b! (nonzero? a1-4) cfg-6 :delay (nop!))
      )
    (label cfg-10)
    (when (!= v1-0 -1)
      (let ((s5-0 (-> this active-object-type-list v1-0)))
        (let ((a2-4 (remove-active-process this v1-0)))
          (add-reserved-process this s5-0 a2-4)
          )
        (let ((v1-5 (-> this traffic object-type-info-array s5-0)))
          (+! (-> v1-5 killed-count) 1)
          (+! (-> v1-5 reserve-count) -1)
          )
        )
      #t
      )
    )
  0
  (none)
  )

(defmethod deactivate-all-of-type ((this traffic-tracker) (arg0 traffic-type) (arg1 symbol))
  (countdown (s3-0 (-> this active-object-count))
    (if (= (-> this active-object-type-list s3-0) arg0)
        (deactivate-object this (the-as int s3-0) arg1)
        )
    )
  0
  (none)
  )

(defmethod deactivate-all ((this traffic-tracker) (arg0 symbol))
  (countdown (s4-0 (-> this active-object-count))
    (deactivate-object this (the-as int s4-0) arg0)
    )
  0
  (none)
  )

;; WARN: Function (method 21 traffic-tracker) has a return type of none, but the expression builder found a return statement.
(defmethod activate-from-params ((this traffic-tracker) (arg0 traffic-object-spawn-params))
  (local-vars (sv-16 handle))
  (let ((gp-0 (-> arg0 object-type)))
    (b! (logtest? (process-mask enemy guard) (-> *kernel-context* prevent-from-run)) cfg-21 :delay (nop!))
    (set! (-> arg0 proc) #f)
    (let ((v1-5 (-> this traffic object-type-info-array gp-0)))
      (when (and (> (-> v1-5 inactive-count) 0) (> (-> v1-5 reserve-count) 0))
        (set! sv-16 (get-from-inactive-by-type this gp-0))
        (let ((s3-0 (handle->process sv-16)))
          (when s3-0
            (when (= gp-0 (traffic-type formation))
              (when (not (rigid-body-object-method-30 (the-as vehicle s3-0)))
                (add-reserved-process this gp-0 sv-16)
                (return 0)
                )
              )
            (cond
              ((send-event s3-0 'traffic-activate arg0 (-> this traffic))
               (set! (-> arg0 proc) s3-0)
               (add-active-process this gp-0 sv-16)
               0
               )
              (else
                (add-reserved-process this gp-0 sv-16)
                )
              )
            )
          )
        0
        )
      )
    )
  (label cfg-21)
  0
  (none)
  )

;; WARN: Function (method 22 traffic-tracker) has a return type of none, but the expression builder found a return statement.
(defmethod activate-by-type ((this traffic-tracker) (arg0 traffic-type) (arg1 nav-segment) (arg2 float))
  (let ((s1-0 (-> this traffic object-type-info-array arg0)))
    (when (and (> (-> s1-0 inactive-count) 0)
               (> (-> s1-0 reserve-count) 0)
               (or (< (-> s1-0 active-count) (-> s1-0 target-count)) (< (the-as uint arg0) (the-as uint 17)))
               (logtest? (-> s1-0 flags) (traffic-type-flag ttf2))
               (logtest? (-> s1-0 flags) (traffic-type-flag ttf3))
               (not (logtest? (-> s1-0 flags) (traffic-type-flag ttf4)))
               (< (-> s1-0 active-count) (-> s1-0 want-count))
               )
      (when *cty-faction-manager*
        (if (not (cty-faction-manager-method-23 *cty-faction-manager* (the-as uint (-> arg1 branch clock-mask))))
            (return #f)
            )
        (if (not (logtest? (cty-faction-manager-method-9 *cty-faction-manager* (the-as int (-> arg1 branch clock-type)) (-> s1-0 level))
                           2
                           )
                 )
            (return #f)
            )
        )
      (let ((s4-0 (new 'stack-no-clear 'traffic-engine-stack-var0)))
        (let ((s0-0 (-> arg1 branch)))
          (set! (-> s4-0 params object-type) arg0)
          (set! (-> s4-0 params flags) (traffic-spawn-flags))
          (set! (-> s4-0 params guard-type) (-> s1-0 guard-type))
          (set! (-> s4-0 params nav-branch) s0-0)
          (let ((v1-29 s0-0))
            (set! (-> s4-0 vec2 x) (* 1024.0 (the float (-> v1-29 speed-limit))))
            )
          (vector-! (-> s4-0 vec0) (-> arg1 vertex 1) (the-as vector (-> arg1 vertex)))
          (vector-normalize! (-> s4-0 vec0) 1.0)
          (vector+float*! (-> s4-0 params position) (the-as vector (-> arg1 vertex)) (-> s4-0 vec0) arg2)
          (let ((f0-6 (* (+ -0.5 (rand-vu)) (* 256.0 (the float (-> s0-0 width))))))
            (+! (-> s4-0 params position x) (* -1.0 (-> s4-0 vec0 z) f0-6))
            (+! (-> s4-0 params position z) (* (-> s4-0 vec0 x) f0-6))
            )
          )
        (set! (-> s4-0 vec2 y)
              (+ (* 0.5 (-> s4-0 vec2 x)) (* (-> this rand) (-> this traffic inv-density-factor) (-> arg1 spawn-spacing)))
              )
        (vector-float*! (-> s4-0 params velocity) (-> s4-0 vec0) (-> s4-0 vec2 x))
        (vector-float*! (-> s4-0 vec1) (-> s4-0 vec0) (-> s4-0 vec2 y))
        (when (not (add-sphere-with-mask-and-id (-> this object-hash) (-> s4-0 params position) (-> s4-0 vec1) 20480.0 -1))
          (set! (-> s4-0 params behavior) (the-as uint 2))
          (set! (-> s4-0 params nav-mesh) #f)
          (-> arg1 nav-mesh-id)
          (if (= (-> arg1 tracker-id) 1)
              (set! (-> s4-0 params nav-mesh) (get-nav-mesh (the-as actor-id (-> arg1 nav-mesh-id))))
              )
          (forward-up-nopitch->quaternion (-> s4-0 params rotation) (-> s4-0 vec0) (new 'static 'vector :y 1.0 :w 1.0))
          (set! (-> this rand) (rand-vu))
          (activate-from-params this (-> s4-0 params))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod activate-by-handle ((this traffic-tracker) (arg0 traffic-object-spawn-params))
  (local-vars (sv-16 handle))
  (let ((gp-0 (-> arg0 object-type)))
    (set! (-> arg0 proc) #f)
    (when (> (-> this traffic object-type-info-array gp-0 inactive-count) 0)
      (set! sv-16 (get-from-inactive-by-handle this gp-0 (-> arg0 handle)))
      (let ((s3-0 (handle->process sv-16)))
        (when s3-0
          (cond
            ((send-event s3-0 'traffic-activate arg0 (-> this traffic))
             (set! (-> arg0 proc) s3-0)
             (add-active-process this gp-0 sv-16)
             0
             )
            (else
              (add-reserved-process this gp-0 sv-16)
              )
            )
          )
        )
      0
      )
    )
  0
  (none)
  )

(defmethod reset ((this traffic-tracker) (arg0 uint) (arg1 traffic-engine))
  (set! (-> this traffic) arg1)
  (set! (-> this object-hash) (-> arg1 object-hash))
  (set! (-> this rand) 0.5)
  (set! (-> this id) arg0)
  (set! (-> this active-object-count) (the-as uint 0))
  (set! (-> this inactive-object-count) 0)
  0
  (none)
  )

(defmethod reset-and-init-from-manager ((this traffic-engine) (arg0 process))
  (set! (-> this allow-spawning?) #t)
  (set! (-> this manager) (process->handle arg0))
  (set! (-> this flags) (the-as uint 0))
  (set! (-> this danger-sphere-count) 0)
  (set! (-> *game-info* wanted-flash) #f)
  (let ((v1-5 (-> this inactive-object-array)))
    (dotimes (a0-5 29)
      (let ((a1-3 (-> this object-type-info-array a0-5)))
        (set! (-> a1-3 flags) (traffic-type-flag ttf1 ttf2))
        (set! (-> a1-3 inactive-count) 0)
        (set! (-> a1-3 active-count) 0)
        (set! (-> a1-3 target-count) 20)
        (set! (-> a1-3 reserve-count) (the-as uint #x7d00))
        (set! (-> a1-3 killed-count) (the-as uint 0))
        (set! (-> a1-3 array) v1-5)
        (set! (-> a1-3 level) #f)
        )
      (set! v1-5 (&-> v1-5 20))
      )
    )
  (set! (-> this object-type-info-array 6 guard-type) (the-as uint 0))
  (set! (-> this object-type-info-array 14 guard-type) (the-as uint 6))
  (set! (-> this object-type-info-array 15 guard-type) (the-as uint 9))
  (set! (-> this object-type-info-array 16 guard-type) (the-as uint 8))
  (set! (-> this object-type-info-array 26 level) 'ctywide)
  (set! (-> this object-type-info-array 28 level) 'ctywide)
  (let ((v1-13 17))
    (dotimes (a0-6 12)
      (set! (-> this object-type-info-array v1-13 tracker-index) (the-as uint 0))
      (+! v1-13 1)
      )
    )
  (let ((v1-16 0))
    (dotimes (a0-7 17)
      (set! (-> this object-type-info-array v1-16 tracker-index) (the-as uint 1))
      (+! v1-16 1)
      )
    )
  (dotimes (s5-0 2)
    (reset (-> this tracker-array s5-0) (the-as uint s5-0) this)
    )
  (reset-boxes (-> this suppressor))
  (set! (-> this object-hash object-count) 0)
  (clear-bucket-array (-> this object-hash))
  (dotimes (s5-1 2)
    (reset! (-> this level-data-array s5-1))
    )
  (dotimes (s5-2 (-> *level* length))
    (let ((a1-9 (-> *level* level s5-2)))
      (if (= (-> a1-9 status) 'active)
          (level-link this a1-9)
          )
      )
    )
  (dotimes (v1-49 4)
    (set! (-> this squad-control-array v1-49) #f)
    )
  0
  (none)
  )

(defmethod squad-stop-alarm-sound ((this traffic-engine))
  (dotimes (s5-0 4)
    (let ((a0-1 (-> this squad-control-array s5-0)))
      (if a0-1
          (stop-alarm-sound a0-1)
          )
      )
    )
  0
  (none)
  )

(defmethod level-link ((this traffic-engine) (arg0 level))
  (format #t "traffic-engine: level birth ~S~%" (-> arg0 nickname))
  (cond
    ((or (not *debug-segment*)
         (not (and (get-nav-graph-editor) (= (-> (get-nav-graph-editor) nav-graph nav_graph_id) 1)))
         )
     (when (and (nonzero? (-> arg0 bsp city-level-info)) (nonzero? (-> arg0 bsp city-level-info nav-graph)))
       (let ((s4-0 (-> arg0 bsp city-level-info)))
         (let ((v1-13 (-> arg0 bsp city-level-info nav-graph)))
           (when (not (-> v1-13 patched))
             (dotimes (a0-8 (the-as int (-> s4-0 cell-count)))
               (let ((a1-3 (-> s4-0 cell-array a0-8)))
                 (set! (-> a1-3 nav-territories) (the-as uint 0))
                 (set! (-> a1-3 segment-array)
                       (the-as (inline-array nav-segment) (-> s4-0 segment-array (the-as int (the-as uint (-> a1-3 segment-array)))))
                       )
                 )
               )
             (dotimes (a0-11 (-> s4-0 segment-count))
               (let ((a1-6 (-> s4-0 segment-array a0-11)))
                 (set! (-> a1-6 branch)
                       (the-as
                         nav-branch
                         (+ (the-as uint (the-as nav-branch (-> v1-13 branch-array))) (* (the-as int (-> a1-6 branch)) 16))
                         )
                       )
                 (logior!
                   (-> s4-0 cell-array (-> a1-6 cell-id) nav-territories)
                   (ash 1 (the-as int (-> a1-6 branch clock-type)))
                   )
                 )
               )
             (dotimes (a0-14 (-> v1-13 node-count))
               (let ((a1-12 (-> v1-13 node-array a0-14)))
                 (set! (-> a1-12 branch-array)
                       (the-as
                         (inline-array nav-branch)
                         (+ (the-as uint (-> v1-13 branch-array)) (* (the-as int (-> a1-12 branch-array)) 16))
                         )
                       )
                 )
               )
             (dotimes (a0-17 (-> v1-13 branch-count))
               (let* ((a1-15 (-> v1-13 branch-array a0-17))
                      (t0-4 (the-as object (-> a1-15 src-node)))
                      (a2-17 (the-as object (-> a1-15 dest-node)))
                      )
                 (set! (-> a1-15 src-node) (the-as nav-node (+ (the-as uint (-> v1-13 node-array)) (* (the-as int t0-4) 32))))
                 (cond
                   ((< #x186a0 (the-as int a2-17))
                    (let ((a2-18 (- (the-as uint #xffffffff) (the-as uint a2-17))))
                      (set! (-> a1-15 dest-node) (-> v1-13 link-array a2-18 dummy-node))
                      )
                    )
                   (else
                     (set! (-> a1-15 dest-node)
                           (the-as nav-node (+ (the-as uint (-> v1-13 node-array)) (* (the-as int a2-17) 32)))
                           )
                     )
                   )
                 )
               )
             (set! (-> v1-13 patched) #t)
             )
           (dotimes (a0-21 (-> v1-13 branch-count))
             (set! (-> v1-13 branch-array a0-21 user-count) (the-as uint 0))
             0
             )
           )
         (dotimes (v1-16 (the-as int (-> s4-0 cell-count)))
           (let ((a0-23 (-> s4-0 cell-array v1-16)))
             (set! (-> a0-23 flags) (vis-cell-flag))
             (set! (-> a0-23 prev-flags) (vis-cell-flag))
             )
           0
           )
         (let ((s3-0 0))
           (dotimes (s2-0 (-> s4-0 segment-count))
             (let ((s1-0 (-> s4-0 segment-array s2-0)))
               (vector-vector-distance (the-as vector (-> s1-0 vertex)) (-> s1-0 vertex 1))
               (when (< (-> s1-0 spawn-spacing) 0.0)
                 (inspect s1-0)
                 #t
                 (+! s3-0 1)
                 (set! (-> s1-0 spawn-spacing) (fabs (-> s1-0 spawn-spacing)))
                 )
               )
             )
           (format #t "birth-level ~s found ~d bad segs~%" arg0 s3-0)
           )
         )
       )
     )
    (else
      0
      )
    )
  (let ((s4-1 (the-as traffic-level-data #f)))
    (dotimes (v1-31 2)
      (let ((a0-34 (-> this level-data-array v1-31)))
        (if (zero? (-> a0-34 city-info))
            (set! s4-1 a0-34)
            )
        )
      )
    (if (not s4-1)
        (format 0 "level-data not found~%")
        )
    (when s4-1
      (set! (-> s4-1 city-info) (-> arg0 bsp city-level-info))
      (set! (-> s4-1 active-cell-count) (the-as uint 0))
      0
      )
    )
  (dotimes (gp-1 (-> *level* length))
    (let ((v1-43 (-> *level* level gp-1)))
      (when (= (-> v1-43 status) 'active)
        (when (nonzero? (-> v1-43 bsp city-level-info))
          (let ((s5-1 (-> v1-43 bsp city-level-info nav-graph)))
            (when (and (nonzero? s5-1) (-> s5-1 patched))
              (dotimes (s4-2 (-> s5-1 link-count))
                (let ((s3-1 (-> s5-1 link-array s4-2)))
                  (when (not (-> s3-1 dest-graph))
                    (let ((s2-1 (get-level-nav-graph-by-id (the-as int (-> s3-1 dest-graph-id)))))
                      (when (and s2-1 (-> s2-1 patched))
                        (dotimes (s1-1 (-> s2-1 node-count))
                          (when (= (-> s3-1 dest-node-id) (-> s2-1 node-array s1-1 id))
                            (set! (-> s3-1 dest-graph) s2-1)
                            (set-dst-node (-> s5-1 branch-array (-> s3-1 src-branch-id)) (-> s2-1 node-array s1-1))
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod level-unlink ((this traffic-engine) (arg0 level))
  (let ((s4-0 (-> arg0 bsp city-level-info nav-graph)))
    (dotimes (v1-2 2)
      (let ((a0-4 (-> this level-data-array v1-2)))
        (when (= (-> a0-4 city-info) (-> arg0 bsp city-level-info))
          (set! (-> a0-4 city-info) (the-as city-level-info 0))
          0
          )
        )
      )
    (when (nonzero? s4-0)
      (dotimes (s3-0 (-> *level* length))
        (let ((v1-9 (-> *level* level s3-0)))
          (when (= (-> v1-9 status) 'active)
            (when (and (!= arg0 v1-9) (!= (-> v1-9 bsp city-level-info) 0))
              (let ((s2-0 (-> v1-9 bsp city-level-info nav-graph)))
                (when (nonzero? s2-0)
                  (dotimes (s1-0 (-> s2-0 link-count))
                    (let ((s0-0 (-> s2-0 link-array s1-0)))
                      (when (= (-> s0-0 dest-graph) s4-0)
                        (set! (-> s0-0 dest-graph) (get-level-nav-graph-by-id (the-as int (-> s0-0 dest-graph-id))))
                        (when (-> s0-0 dest-graph)
                          (set-dst-node (-> s2-0 branch-array (-> s0-0 src-branch-id)) (-> s0-0 dummy-node))
                          (set! (-> s0-0 dest-graph) #f)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (let ((s4-1 (-> arg0 bsp city-level-info nav-graph)))
    (dotimes (s3-1 (-> s4-1 link-count))
      (let ((s2-1 (-> s4-1 link-array s3-1)))
        (set-dst-node (-> s4-1 branch-array (-> s2-1 src-branch-id)) (-> s2-1 dummy-node))
        (set! (-> s2-1 dest-graph) #f)
        )
      )
    )
  (deactivate-all-from-level this (-> arg0 name))
  0
  (none)
  )

(defmethod for-all-active-processes ((this traffic-engine) (arg0 (function process-focusable traffic-object-type-info none)))
  (dotimes (s4-0 2)
    (for-all-active-processes (-> this tracker-array s4-0) arg0)
    )
  0
  (none)
  )

(defmethod add-object ((this traffic-engine) (arg0 traffic-type) (arg1 process))
  (add-reserved-process
    (-> this tracker-array (-> this object-type-info-array arg0 tracker-index))
    arg0
    (process->handle arg1)
    )
  0
  (none)
  )

(defmethod child-killed ((this traffic-engine) (arg0 process))
  (cond
    ((type? arg0 citizen)
     (set-process-to-killed (-> this tracker1) arg0)
     )
    ((type? arg0 vehicle)
     (set-process-to-killed (-> this tracker0) arg0)
     )
    (else
      0
      )
    )
  0
  (none)
  )

(defmethod activate-one-citizen ((this traffic-engine) (arg0 nav-segment) (arg1 float))
  (let ((a1-1 (+ (rand-vu-int-count 12) 17)))
    (activate-by-type (-> this tracker0) (the-as traffic-type a1-1) arg0 arg1)
    )
  0
  (none)
  )

;; WARN: Function (method 16 traffic-engine) has a return type of none, but the expression builder found a return statement.
(defmethod activate-one-vehicle ((this traffic-engine) (arg0 nav-segment) (arg1 float))
  (if (-> *setting-control* user-current nuke-active?)
      (return 0)
      )
  (when (not *cty-faction-manager*)
    (let ((a1-1 0))
      (dotimes (v1-6 17)
        (let ((a0-3 (-> this object-type-info-array v1-6)))
          (if (or (zero? (-> a0-3 inactive-count)) (zero? (-> a0-3 reserve-count)))
              (set! a1-1 (logior a1-1 (ash 1 v1-6)))
              )
          )
        )
      (let ((a1-2 (rand-vu-int-count-excluding 17 a1-1)))
        (activate-by-type (-> this tracker1) (the-as traffic-type a1-2) arg0 arg1)
        )
      )
    (return 0)
    )
  (let ((s3-0 -1))
    (let ((f30-0 -1.0))
      (dotimes (s2-0 17)
        (let ((v1-15 (-> this object-type-info-array s2-0)))
          (when (and (> (-> v1-15 inactive-count) 0) (> (-> v1-15 reserve-count) 0))
            (let ((s1-0 (-> this object-type-info-array s2-0)))
              (when (-> s1-0 level)
                (let ((s0-0
                        (-> s1-0
                            target-counts
                            (cty-faction-manager-method-10 *cty-faction-manager* (the-as int (-> arg0 branch clock-type)) (-> s1-0 level))
                            )
                        )
                      )
                  (when (< (-> s1-0 active-count) s0-0)
                    (when (logtest? (cty-faction-manager-method-9 *cty-faction-manager* (the-as int (-> arg0 branch clock-type)) (-> s1-0 level))
                                    2
                                    )
                      (let* ((f0-2 (/ (the float (-> s1-0 active-count)) (the float s0-0)))
                             (f0-3 (- 1.0 f0-2))
                             )
                        (when (< f30-0 f0-3)
                          (set! f30-0 f0-3)
                          (set! s3-0 s2-0)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (>= s3-0 0)
        (activate-by-type (-> this tracker1) (the-as traffic-type s3-0) arg0 arg1)
        )
    )
  0
  (none)
  )

(defmethod handle-new-vis-cell ((this traffic-engine) (arg0 vis-cell))
  (dotimes (s4-0 (-> arg0 segment-count))
    (let* ((s3-0 (-> arg0 segment-array s4-0))
           (s1-0 (-> s3-0 tracker-id))
           )
      (when (and (logtest? (logxor (-> arg0 flags) (the-as uint (-> arg0 prev-flags))) (ash 1 s1-0))
                 (and (not (logtest? (-> arg0 flags) (vis-cell-flag suppress)))
                      (not (or (can-dest-be-used? this (-> s3-0 branch)) (let ((a0-7 (-> s3-0 branch)))
                                                                           (>= (-> a0-7 user-count) (-> a0-7 max-user-count))
                                                                           )
                               )
                           )
                      )
                 )
        (let* ((s2-0 (-> this tracker-array s1-0))
               (f30-0 (* (-> s2-0 rand) (-> this inv-density-factor) (-> s3-0 spawn-spacing)))
               )
          (cond
            ((= s1-0 1)
             (when (nonzero? (-> s3-0 nav-mesh-id))
               (while (and (< f30-0 (-> s3-0 length))
                           (> (-> s2-0 inactive-object-count) 0)
                           (< (-> s3-0 branch density) (the-as uint 128))
                           )
                 (activate-one-vehicle this s3-0 f30-0)
                 (set! f30-0 (+ 24576.0 (* (-> s2-0 rand) (-> this inv-density-factor) (-> s3-0 spawn-spacing)) f30-0))
                 )
               )
             )
            (else
              (while (and (< f30-0 (-> s3-0 length))
                          (> (-> s2-0 inactive-object-count) 0)
                          (< (-> s3-0 branch density) (the-as uint 128))
                          )
                (activate-one-citizen this s3-0 f30-0)
                (set! f30-0 (+ 49152.0 (* (-> s2-0 rand) (-> this inv-density-factor) (-> s3-0 spawn-spacing)) f30-0))
                )
              )
            )
          (if (>= f30-0 (-> s3-0 length))
              (set! (-> s2-0 rand)
                    (fmax 0.0 (- (-> s2-0 rand) (/ (-> s3-0 length) (* (-> s3-0 spawn-spacing) (-> this inv-density-factor)))))
                    )
              )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod stub ((this traffic-engine))
  (when #f
    )
  0
  (none)
  )

(defmethod sphere-in-loaded-city-infos? ((this traffic-engine) (arg0 vector) (arg1 int))
  (dotimes (s3-0 2)
    (let ((v1-3 (-> this level-data-array s3-0)))
      (when (nonzero? (-> v1-3 city-info))
        (if (sphere-in-grid? (-> v1-3 city-info) arg0 arg1)
            (return #t)
            )
        )
      )
    )
  #f
  )

(defmethod can-dest-be-used? ((this traffic-engine) (arg0 nav-branch))
  (let ((v1-0 (-> arg0 src-node)))
    (or (logtest? (-> arg0 flags) (nav-branch-flags nabflags-0))
        (logtest? (-> v1-0 flags) (nav-node-flag-byte blocked))
        (not (-> arg0 dest-node))
        (>= (-> arg0 user-count) (-> arg0 max-user-count))
        )
    )
  )

(defmethod init-sync-masks ((this traffic-engine))
  (+! (-> this sync-clock) 1)
  (set! (-> this sync-mask-8) (the-as uint (ash 1 (the-as int (logand (-> this sync-clock) 7)))))
  (set! (-> this sync-mask-16) (the-as uint (ash 1 (the-as int (logand (-> this sync-clock) 15)))))
  (set! (-> this sync-mask-32) (the-as uint (ash 1 (the-as int (logand (-> this sync-clock) 31)))))
  (let ((v1-10 (/ (current-time) 300)))
    (set! (-> this sync-array 0) (the-as uint 255))
    (let ((a1-12 (mod v1-10 20)))
      (set! (-> this sync-array 1) (the-as uint (cond
                                                  ((>= 6 a1-12)
                                                   1
                                                   )
                                                  ((>= 9 a1-12)
                                                   2
                                                   )
                                                  ((>= 16 a1-12)
                                                   4
                                                   )
                                                  (else
                                                    8
                                                    )
                                                  )
                                           )
            )
      )
    (let ((a1-15 (mod v1-10 30)))
      (set! (-> this sync-array 2) (the-as uint (cond
                                                  ((>= 6 a1-15)
                                                   1
                                                   )
                                                  ((>= 9 a1-15)
                                                   2
                                                   )
                                                  ((>= 16 a1-15)
                                                   4
                                                   )
                                                  ((>= 19 a1-15)
                                                   8
                                                   )
                                                  ((>= 26 a1-15)
                                                   16
                                                   )
                                                  (else
                                                    32
                                                    )
                                                  )
                                           )
            )
      )
    (let ((v1-11 (mod v1-10 40)))
      (set! (-> this sync-array 3) (the-as uint (cond
                                                  ((>= 6 v1-11)
                                                   1
                                                   )
                                                  ((>= 9 v1-11)
                                                   2
                                                   )
                                                  ((>= 16 v1-11)
                                                   4
                                                   )
                                                  ((>= 19 v1-11)
                                                   8
                                                   )
                                                  ((>= 26 v1-11)
                                                   16
                                                   )
                                                  ((>= 29 v1-11)
                                                   32
                                                   )
                                                  ((>= 36 v1-11)
                                                   64
                                                   )
                                                  (else
                                                    128
                                                    )
                                                  )
                                           )
            )
      )
    )
  0
  (none)
  )

(defmethod update-danger-from-target ((this traffic-engine))
  (local-vars (v1-20 float) (v1-32 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 *target*))
      (when s5-0
        (let ((v1-1 (-> this danger-sphere-array)))
          (set! (-> v1-1 0 handle) (process->handle s5-0))
          (let ((a0-4 (-> s5-0 focus-status))
                (f0-0 0.0)
                (f1-0 0.0)
                (f3-0 1.0)
                (f2-0 0.0)
                )
            (cond
              ((logtest? (focus-status mech dark shooting) a0-4)
               (set! f0-0 245760.0)
               (set! f1-0 163840.0)
               (set! f2-0 1.0)
               (set! f3-0 0.0)
               )
              ((logtest? (focus-status gun) a0-4)
               (set! f0-0 102400.0)
               (set! f1-0 61440.0)
               (set! f2-0 0.5)
               (set! f3-0 0.5)
               )
              ((logtest? (focus-status flut board pilot) a0-4)
               (set! f0-0 40960.0)
               (set! f1-0 24576.0)
               (set! f2-0 0.5)
               )
              ((logtest? a0-4 (focus-status dangerous))
               (set! f0-0 61440.0)
               (set! f1-0 40960.0)
               (set! f3-0 0.0)
               (set! f2-0 0.5)
               )
              (else
                (set! f3-0 1.5)
                )
              )
            (set! (-> v1-1 0 decay-rate) (* 0.1 f3-0))
            (when (< (-> v1-1 0 danger-level) f2-0)
              (set! (-> v1-1 0 danger-level) f2-0)
              (set! (-> v1-1 0 sphere r) f1-0)
              (set! (-> v1-1 0 notify-radius) f0-0)
              )
            )
          (let ((f0-1 (-> v1-1 0 sphere r)))
            (set! (-> v1-1 0 sphere quad) (-> s5-0 control trans quad))
            (set! (-> v1-1 0 sphere r) f0-1)
            )
          (set! (-> v1-1 0 velocity quad) (-> s5-0 control transv quad))
          (let ((f0-3 (- (-> v1-1 0 danger-level) (* (-> v1-1 0 decay-rate) (seconds-per-frame)))))
            (set! (-> v1-1 0 danger-level) (fmax 0.0 f0-3))
            )
          )
        (let ((s3-0 (-> s5-0 focus-status))
              (f30-0 0.0)
              (s4-0 (new 'stack-no-clear 'inline-array 'traffic-suppression-box 2))
              )
          (set! (-> s4-0 0 bbox max quad) (-> s5-0 control transv quad))
          (vector-z-quaternion! (the-as vector (-> s4-0 1)) (get-quat s5-0 3))
          (set! (-> s4-0 1 data 16) (the-as uint 3))
          (cond
            ((logtest? (focus-status shooting) s3-0)
             (vector-float*! (the-as vector (-> s4-0 0)) (the-as vector (-> s4-0 1)) 409600.0)
             (set! f30-0 4096.0)
             (set! (-> s4-0 1 data 16) (the-as uint 0))
             0
             )
            ((and (logtest? (focus-status gun) s3-0)
                  (not (and (logtest? (focus-status pilot) s3-0) (let* ((v1-19 (-> s4-0 0 bbox max))
                                                                        (f0-6 40960.0)
                                                                        (f0-8 (* f0-6 f0-6))
                                                                        )
                                                                   (.lvf vf1 (&-> v1-19 quad))
                                                                   (.add.w.vf vf2 vf0 vf0 :mask #b1)
                                                                   (.mul.vf vf1 vf1 vf1)
                                                                   (.mul.x.vf acc vf2 vf1 :mask #b1)
                                                                   (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                                                                   (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                                                                   (.mov v1-20 vf1)
                                                                   (< f0-8 v1-20)
                                                                   )
                            )
                       )
                  )
             (vector-float*! (the-as vector (-> s4-0 0)) (the-as vector (-> s4-0 1)) 163840.0)
             (set! f30-0 8192.0)
             (set! (-> s4-0 1 data 16) (the-as uint 1))
             )
            ((logtest? (focus-status dangerous flut board pilot) s3-0)
             (vector-float*! (the-as vector (-> s4-0 0)) (-> s4-0 0 bbox max) 2.0)
             (let* ((v1-31 (-> s4-0 0))
                    (f0-11 20480.0)
                    (f0-13 (* f0-11 f0-11))
                    )
               (.lvf vf1 (&-> v1-31 bbox min quad))
               (.add.w.vf vf2 vf0 vf0 :mask #b1)
               (.mul.vf vf1 vf1 vf1)
               (.mul.x.vf acc vf2 vf1 :mask #b1)
               (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
               (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
               (.mov v1-32 vf1)
               (if (< f0-13 v1-32)
                   (set! f30-0 20480.0)
                   )
               )
             (set! (-> s4-0 1 data 16) (the-as uint (cond
                                                      ((logtest? (focus-status pilot) s3-0)
                                                       3
                                                       )
                                                      ((logtest? (focus-status flut board) s3-0)
                                                       2
                                                       )
                                                      ((logtest? s3-0 (focus-status dangerous))
                                                       4
                                                       )
                                                      (else
                                                        5
                                                        )
                                                      )
                                               )
                   )
             )
            )
          (when (< 0.0 f30-0)
            (let ((s3-1 (new 'stack-no-clear 'array 'collide-shape 40))
                  (s2-1 (new 'stack 'traffic-danger-info))
                  )
              (set! (-> s2-1 sphere quad) (-> s5-0 control trans quad))
              (set! (-> s2-1 danger-type) (-> s4-0 1 data 16))
              (set! (-> s2-1 sphere r) f30-0)
              (set! (-> s2-1 velocity quad) (-> s4-0 0 bbox min quad))
              (let ((gp-1 (fill-actor-list-for-sphere
                            (-> this object-hash)
                            (-> s2-1 sphere)
                            (-> s2-1 velocity)
                            (-> s2-1 sphere r)
                            s3-1
                            40
                            -1
                            )
                          )
                    )
                (dotimes (s5-1 gp-1)
                  (let* ((s4-1 (-> s3-1 s5-1))
                         (a0-52 (if (type? s4-1 citizen)
                                    s4-1
                                    )
                                )
                         )
                    (if a0-52
                        (send-event (the-as process-tree a0-52) 'clear-path s2-1)
                        )
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod update-danger ((this traffic-engine))
  (update-danger-from-target this)
  (dotimes (s5-0 (-> this danger-sphere-count))
    (let ((s4-0 (-> this danger-sphere-array s5-0)))
      (when (< 0.0 (-> s4-0 danger-level))
        (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 40))
              (a1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-0 quad) (-> s4-0 sphere quad))
          (set! (-> a1-0 w) (-> s4-0 notify-radius))
          (let ((s2-0 (fill-actor-list-for-box (-> this object-hash) a1-0 s3-0 40)))
            (dotimes (s1-0 s2-0)
              (let* ((s0-0 (-> s3-0 s1-0))
                     (a0-6 (if (type? s0-0 citizen)
                               s0-0
                               )
                           )
                     )
                (when a0-6
                  (if (= (-> s4-0 danger-type) 8)
                      (send-event (the-as process-tree a0-6) 'clear-path s4-0)
                      (send-event
                        (the-as process-tree a0-6)
                        (if (< 0.5 (-> s4-0 danger-level))
                            'panic
                            'avoid
                            )
                        s4-0
                        )
                      )
                  )
                )
              )
            )
          )
        )
      )
    )
  (set! (-> this danger-sphere-count) 1)
  0
  (none)
  )

(defmethod add-danger ((this traffic-engine) (arg0 traffic-danger-info))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (new 'stack-no-clear 'traffic-danger-info)))
      (let ((a0-1 (-> a1-1 sphere)))
        (let ((v1-0 (-> arg0 sphere)))
          (let ((a2-0 (- (-> arg0 notify-radius))))
            (.mov vf6 a2-0)
            )
          (.lvf vf4 (&-> v1-0 quad))
          )
        (.add.x.vf vf5 vf0 vf0 :mask #b1000)
        (.add.x.vf vf5 vf4 vf6 :mask #b111)
        (.svf (&-> a0-1 quad) vf5)
        )
      (let ((a0-2 (-> a1-1 velocity)))
        (let ((v1-1 (-> arg0 sphere)))
          (let ((a2-1 (-> arg0 notify-radius)))
            (.mov vf6 a2-1)
            )
          (.lvf vf4 (&-> v1-1 quad))
          )
        (.add.x.vf vf5 vf0 vf0 :mask #b1000)
        (.add.x.vf vf5 vf4 vf6 :mask #b111)
        (.svf (&-> a0-2 quad) vf5)
        )
      (set! (-> a1-1 handle) (new 'static 'handle :process #x5dc :u64 #x5dc))
      (new-suppression-box this (the-as traffic-suppression-params a1-1))
      )
    (let ((v1-5 (-> this danger-sphere-count)))
      (when (< v1-5 4)
        (let ((a0-5 (-> this danger-sphere-array v1-5)))
          (mem-copy! (the-as pointer a0-5) (the-as pointer arg0) 54)
          )
        (+! (-> this danger-sphere-count) 1)
        )
      )
    0
    (none)
    )
  )

(defmethod kill-traffic-sphere ((this traffic-engine) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'array 'collide-shape 64)))
    (countdown (s5-0 (fill-actor-list-for-box *actor-hash* arg0 gp-0 64))
      (let* ((s4-0 (-> gp-0 s5-0))
             (v1-3 (if (type? s4-0 collide-shape)
                       s4-0
                       )
                   )
             )
        (if v1-3
            (send-event (-> v1-3 process) 'traffic-off-force)
            )
        )
      )
    )
  0
  (none)
  )

;; WARN: Function (method 52 traffic-engine) has a return type of none, but the expression builder found a return statement.
(defmethod update-traffic-amount ((this traffic-engine))
  (local-vars (sv-48 int) (sv-64 nav-segment))
  (if (not (-> this allow-spawning?))
      (return 0)
      )
  (set! (-> this object-hash object-count) 0)
  (clear-bucket-array (-> this object-hash))
  (new 'stack-no-clear 'vector)
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let ((a2-0 *target*))
      (when a2-0
        (cond
          ((focus-test? a2-0 pilot)
           (when (nonzero? (-> a2-0 pilot))
             (let ((a2-1 (handle->process (-> a2-0 pilot vehicle))))
               (when a2-1
                 (set! (-> s5-0 quad) (-> (the-as process-focusable a2-1) root root-prim prim-core world-sphere quad))
                 (fill-actor-list-for-vec+r (-> this object-hash) s5-0 (the-as (pointer collide-shape) a2-1))
                 )
               )
             )
           )
          (else
            (set! (-> s5-0 quad) (-> a2-0 control trans quad))
            (set! (-> s5-0 w) 20480.0)
            (fill-actor-list-for-vec+r (-> this object-hash) s5-0 (the-as (pointer collide-shape) a2-0))
            )
          )
        )
      )
    (countdown (s4-0 (-> this tracker0 active-object-count))
      (let ((s3-0 (handle->process (-> this tracker0 active-object-list s4-0))))
        (cond
          (s3-0
            (cond
              ((focus-test? (the-as process-focusable s3-0) inactive)
               (deactivate-object (-> this tracker0) (the-as int s4-0) #f)
               )
              ((begin
                 (let ((v1-32 (-> (the-as process-focusable s3-0) root)))
                   (set! (-> s5-0 quad) (-> v1-32 trans quad))
                   (set! (-> s5-0 w) (-> v1-32 root-prim prim-core world-sphere w))
                   )
                 (sphere-in-loaded-city-infos? this s5-0 0)
                 )
               (set! (-> (the-as vehicle s3-0) traffic-hash-id)
                     (fill-actor-list-for-vec+r (-> this object-hash) s5-0 (the-as (pointer collide-shape) s3-0))
                     )
               )
              (else
                (deactivate-object (-> this tracker0) (the-as int s4-0) #f)
                )
              )
            )
          (else
            (remove-active-process (-> this tracker0) (the-as int s4-0))
            )
          )
        )
      )
    (countdown (s4-1 (-> this tracker1 active-object-count))
      (let ((s3-1 (handle->process (-> this tracker1 active-object-list s4-1))))
        (cond
          (s3-1
            (cond
              ((focus-test? (the-as process-focusable s3-1) inactive)
               (deactivate-object (-> this tracker1) (the-as int s4-1) #f)
               )
              (else
                (let ((v1-53 (-> (the-as process-focusable s3-1) root)))
                  (set! (-> s5-0 quad) (-> v1-53 trans quad))
                  (set! (-> s5-0 w) (-> v1-53 root-prim prim-core world-sphere w))
                  )
                (when (logtest? (-> (the-as citizen s3-1) flags) (citizen-flag in-formation))
                  )
                (if (sphere-in-loaded-city-infos? this s5-0 1)
                    (fill-actor-list-for-vec+r (-> this object-hash) s5-0 (the-as (pointer collide-shape) s3-1))
                    (deactivate-object (-> this tracker1) (the-as int s4-1) #f)
                    )
                )
              )
            )
          (else
            (remove-active-process (-> this tracker1) (the-as int s4-1))
            )
          )
        )
      )
    )
  (dotimes (s5-1 2)
    (let ((s4-2 (-> this level-data-array s5-1)))
      (when (nonzero? (-> s4-2 city-info))
        (dotimes (s3-2 (the-as int (-> s4-2 newly-active-cell-count)))
          (let ((a1-19 (-> s4-2 newly-active-cell-list s3-2)))
            (handle-new-vis-cell this a1-19)
            )
          )
        (dotimes (s3-3 2)
          (when (> (-> this tracker-array s3-3 inactive-object-count) 0)
            (let ((s2-0 (the-as nav-segment #f)))
              (let ((f30-0 10000000000000000000000000000000000000.0))
                (dotimes (s1-0 (the-as int (-> s4-2 active-cell-count)))
                  (let ((s0-0 (-> s4-2 active-cell-list s1-0)))
                    (when (and (logtest? (-> s0-0 flags) (ash 1 s3-3)) (not (logtest? (-> s0-0 flags) (vis-cell-flag suppress))))
                      (set! sv-48 0)
                      (while (< sv-48 (-> s0-0 incoming-segment-count))
                        (set! sv-64 (-> s0-0 segment-array sv-48))
                        (when (= (-> sv-64 tracker-id) s3-3)
                          (when (and (not (logtest? (-> s4-2 city-info cell-array (-> sv-64 from-cell-id) flags) (ash 1 s3-3)))
                                     (< (-> sv-64 branch density) (the-as uint 128))
                                     )
                            (let ((f0-3 (rand-vu)))
                              (when (< f0-3 f30-0)
                                (set! f30-0 f0-3)
                                (set! s2-0 sv-64)
                                )
                              )
                            )
                          )
                        (set! sv-48 (+ sv-48 1))
                        )
                      )
                    )
                  )
                )
              (when s2-0
                (let ((a0-46 (-> s2-0 branch)))
                  (when (not (or (>= (-> a0-46 user-count) (-> a0-46 max-user-count)) (can-dest-be-used? this (-> s2-0 branch))))
                    (cond
                      ((= s3-3 1)
                       (if (nonzero? (-> s2-0 nav-mesh-id))
                           (activate-one-vehicle this s2-0 0.0)
                           )
                       )
                      (else
                        (activate-one-citizen this s2-0 0.0)
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod update-traffic ((this traffic-engine))
  (init-sync-masks this)
  (update-suppressor this)
  (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
    (set-vector!
      (-> s5-0 min)
      10000000000000000000000000000000000000.0
      10000000000000000000000000000000000000.0
      10000000000000000000000000000000000000.0
      1.0
      )
    (set-vector!
      (-> s5-0 max)
      -10000000000000000000000000000000000000.0
      -10000000000000000000000000000000000000.0
      -10000000000000000000000000000000000000.0
      1.0
      )
    (dotimes (s4-0 2)
      (let ((s3-0 (-> this level-data-array s4-0)))
        (when (nonzero? (-> s3-0 city-info))
          (per-frame-cell-update s3-0)
          (add-box! s5-0 (-> s3-0 active-cell-box))
          0
          )
        )
      )
    (update-grid-for-objects-in-box (-> this object-hash) 253 (-> s5-0 min) (-> s5-0 max))
    )
  (when *cty-faction-manager*
    (let ((a1-2 0))
      (dotimes (v1-22 2)
        (let ((a0-17 (-> this level-data-array v1-22)))
          (when (nonzero? (-> a0-17 city-info))
            (dotimes (a2-3 (the-as int (-> a0-17 active-cell-count)))
              (set! a1-2 (logior a1-2 (-> a0-17 active-cell-list a2-3 nav-territories)))
              )
            )
          )
        )
      (cty-faction-manager-method-20 *cty-faction-manager* (the-as uint a1-2))
      )
    (cty-faction-manager-method-13 *cty-faction-manager*)
    )
  (if *cty-attack-controller*
      (mission-squad-control-method-16 *cty-attack-controller*)
      )
  (update-traffic-amount this)
  (dotimes (s5-1 4)
    (let ((a0-23 (-> this squad-control-array s5-1)))
      (if a0-23
          (update a0-23)
          )
      )
    )
  (update-danger this)
  0
  (none)
  )

(defmethod callback-on-nav-segments-in-sphere ((this traffic-engine)
                                              (arg0 vector)
                                              (arg1 int)
                                              (arg2 traffic-find-segment-struct)
                                              (arg3 (function traffic-find-segment-struct nav-segment none))
                                              )
  (dotimes (s1-0 2)
    (let ((v1-3 (-> this level-data-array s1-0)))
      (if (nonzero? (-> v1-3 city-info))
          (callback-on-nav-segments-in-sphere (-> v1-3 city-info) arg0 arg1 arg2 arg3)
          )
      )
    )
  0
  (none)
  )

(deftype traffic-find-segment-struct (structure)
  ((best-seg     nav-segment)
   (best-rating  float)
   (dir          vector  :inline)
   )
  )


(defmethod find-best-segment ((this traffic-engine) (arg0 vector) (arg1 vector) (arg2 int))
  (let ((gp-0 (new 'stack-no-clear 'traffic-find-segment-struct)))
    (set! (-> gp-0 dir quad) (-> arg1 quad))
    (set! (-> gp-0 best-rating) -10000000000000000000000000000000000000.0)
    (set! (-> gp-0 best-seg) #f)
    (callback-on-nav-segments-in-sphere
      this
      arg0
      arg2
      gp-0
      (lambda ((arg0 traffic-find-segment-struct) (arg1 nav-segment))
        (let ((v1-0 (new 'stack-no-clear 'vector)))
          (vector-! v1-0 (-> arg1 vertex 1) (the-as vector (-> arg1 vertex)))
          (let ((a2-1 v1-0)
                (a3-1 v1-0)
                (f0-0 (-> arg1 length))
                )
            (vector-float*! a2-1 a3-1 (/ 1.0 f0-0))
            )
          (let ((f0-4 (vector-dot v1-0 (-> arg0 dir))))
            (when (< (-> arg0 best-rating) f0-4)
              (set! (-> arg0 best-rating) f0-4)
              (set! (-> arg0 best-seg) arg1)
              )
            )
          )
        (none)
        )
      )
    (-> gp-0 best-seg)
    )
  )

(defmethod target-count ((this traffic-engine) (arg0 float))
  (dotimes (v1-0 29)
    (let ((a2-2 (-> this object-type-info-array v1-0)))
      (set! (-> a2-2 target-count) (the int (* arg0 (the float (max 0 (+ (-> a2-2 want-count) -1))))))
      )
    )
  0
  (none)
  )

(defmethod restore-default-settings ((this traffic-engine))
  (let ((t9-0 (-> *traffic-info* restore-speech-callback)))
    (if t9-0
        (t9-0)
        )
    )
  (target-count this 1.0)
  (set! (-> this inv-density-factor) 5.0)
  (let ((v1-6 32))
    (dotimes (a0-2 29)
      (let ((a1-3 (-> this object-type-info-array a0-2)))
        (set! (-> a1-3 flags) (traffic-type-flag ttf1 ttf2))
        (set! (-> a1-3 reserve-count) (the-as uint (max 1000 (min #xfde8 (* 1000 (-> a1-3 want-count))))))
        (set! (-> a1-3 killed-count) (the-as uint 0))
        (set! (-> a1-3 parking-spot-prob)
              (the-as uint (if (and (zero? (-> a1-3 tracker-index))
                                    (not (logtest? (-> a1-3 flags) (traffic-type-flag ttf0)))
                                    (!= a0-2 27)
                                    (!= a0-2 26)
                                    )
                               v1-6
                               0
                               )
                      )
              )
        (let ((a2-9 a0-2))
          (if (or (= a2-9 17) (or (= a2-9 18) (= a2-9 19) (= a2-9 28)))
              (set! (-> a1-3 parking-spot-prob) (the-as uint 128))
              )
          )
        )
      )
    )
  (let ((v1-9 (-> this object-type-info-array 6)))
    (logior! (-> v1-9 flags) (traffic-type-flag ttf0))
    )
  (let ((v1-10 (-> this object-type-info-array 7)))
    (logior! (-> v1-10 flags) (traffic-type-flag ttf0))
    )
  (let ((v1-11 (-> this object-type-info-array 24)))
    (logior! (-> v1-11 flags) (traffic-type-flag ttf0))
    )
  (let ((v1-12 (-> this object-type-info-array 25)))
    (logior! (-> v1-12 flags) (traffic-type-flag ttf0))
    )
  (let ((v1-13 (-> this object-type-info-array 26)))
    (logior! (-> v1-13 flags) (traffic-type-flag ttf0))
    )
  (let ((v1-14 (-> this object-type-info-array 5)))
    (set! (-> v1-14 target-count) 0)
    (logclear! (-> v1-14 flags) (traffic-type-flag ttf1 ttf2))
    )
  (let ((v1-15 (-> this object-type-info-array 3)))
    (set! (-> v1-15 target-count) 0)
    (logclear! (-> v1-15 flags) (traffic-type-flag ttf2))
    )
  (let ((v1-16 (-> this object-type-info-array 4)))
    (set! (-> v1-16 target-count) 0)
    (logclear! (-> v1-16 flags) (traffic-type-flag ttf2))
    )
  (let ((v1-17 (-> this object-type-info-array 23)))
    (set! (-> v1-17 target-count) 0)
    (logclear! (-> v1-17 flags) (traffic-type-flag ttf1 ttf2))
    )
  (let ((v1-18 (-> this object-type-info-array 28)))
    (set! (-> v1-18 target-count) 0)
    (logclear! (-> v1-18 flags) (traffic-type-flag ttf2))
    (logior! (-> v1-18 flags) (traffic-type-flag ttf3))
    )
  (dotimes (s5-0 4)
    (let ((a0-25 (-> this squad-control-array s5-0)))
      (if a0-25
          (init-alert a0-25)
          )
      )
    )
  0
  (none)
  )

(defmethod deactivate-all ((this traffic-engine))
  (deactivate-all (-> this tracker0) #t)
  (deactivate-all (-> this tracker1) #t)
  0
  (none)
  )

(defmethod deactivate-by-type ((this traffic-engine) (arg0 traffic-type))
  (let ((a2-0 (-> this object-type-info-array arg0)))
    (deactivate-all-of-type (-> this tracker-array (-> a2-0 tracker-index)) arg0 #t)
    )
  0
  (none)
  )

(defmethod deactivate-all-from-level ((this traffic-engine) (arg0 symbol))
  (local-vars (v1-6 nav-branch))
  (countdown (s4-0 (-> this tracker0 active-object-count))
    (let ((v1-3 (handle->process (-> this tracker0 active-object-list s4-0))))
      (when v1-3
        (cond
          ((focus-test? (the-as process-focusable v1-3) inactive)
           (deactivate-object (-> this tracker0) (the-as int s4-0) #f)
           )
          ((begin (set! v1-6 (-> (the-as hvehicle v1-3) controller branch)) (and v1-6 (nonzero? v1-6)))
           (let ((v1-7 (-> v1-6 dest-node)))
             (cond
               (v1-7
                 (if (= arg0 (-> v1-7 level))
                     (deactivate-object (-> this tracker0) (the-as int s4-0) #t)
                     )
                 )
               (else
                 0
                 )
               )
             )
           )
          (else
            0
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod set-object-auto-activate ((this traffic-engine) (arg0 int) (arg1 symbol))
  (let ((v1-2 (-> this object-type-info-array arg0)))
    (if arg1
        (logior! (-> v1-2 flags) (traffic-type-flag ttf2))
        (logclear! (-> v1-2 flags) (traffic-type-flag ttf2))
        )
    )
  0
  (none)
  )

(defmethod set-object-target-level ((this traffic-engine) (arg0 int) (arg1 float))
  (let ((v1-2 (-> this object-type-info-array arg0)))
    (set! (-> v1-2 target-count) (the int (* arg1 (the float (max 0 (+ (-> v1-2 want-count) -1))))))
    )
  0
  (none)
  )

(defmethod set-object-target-count ((this traffic-engine) (arg0 int) (arg1 int))
  (set! (-> this object-type-info-array arg0 target-count) arg1)
  0
  (none)
  )

(defmethod set-object-reserve-count ((this traffic-engine) (arg0 int) (arg1 uint))
  (set! (-> this object-type-info-array arg0 reserve-count) arg1)
  0
  (none)
  )

(defmethod get-object-reserve-count ((this traffic-engine) (arg0 int))
  (-> this object-type-info-array arg0 reserve-count)
  )

(defmethod get-object-remaining-count ((this traffic-engine) (arg0 int))
  (let ((a0-1 (-> this object-type-info-array arg0)))
    (+ (-> a0-1 active-count) (-> a0-1 reserve-count))
    )
  )

(defmethod set-parking-spot-prob ((this traffic-engine) (arg0 int) (arg1 float))
  (let ((v1-2 (-> this object-type-info-array arg0)))
    (set! (-> v1-2 parking-spot-prob) (the-as uint (min 255 (the int (* 256.0 arg1)))))
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs traffic-type.
(defmethod get-random-parking-spot-type ((this traffic-engine))
  (let ((s4-0 0)
        (s5-0 0)
        )
    (let ((s3-0 17)
          (s2-0 28)
          )
      (while (>= (the-as uint s2-0) (the-as uint s3-0))
        (let ((s1-0 (-> this object-type-info-array s3-0)))
          (if (and (logtest? (-> s1-0 flags) (traffic-type-flag ttf3))
                   (= (status-of-level-and-borrows *level* (-> s1-0 level) 'ignore-borrow) 'active)
                   )
              (+! s4-0 (-> s1-0 parking-spot-prob))
              )
          )
        (+! s3-0 1)
        )
      )
    (let ((s4-1 (mod (the-as int (rand-uint31-gen *random-generator*)) (+ s4-0 1)))
          (s3-1 17)
          (s2-1 28)
          )
      (while (>= (the-as uint s2-1) (the-as uint s3-1))
        (let ((s1-1 (-> this object-type-info-array s3-1)))
          (when (and (logtest? (-> s1-1 flags) (traffic-type-flag ttf3))
                     (= (status-of-level-and-borrows *level* (-> s1-1 level) #f) 'active)
                     )
            (+! s5-0 (-> s1-1 parking-spot-prob))
            (if (< s4-1 s5-0)
                (return (the-as traffic-type s3-1))
                )
            )
          )
        (+! s3-1 1)
        )
      )
    )
  (the-as traffic-type 29)
  )

(defmethod activate-object ((this traffic-engine) (arg0 traffic-object-spawn-params))
  (let ((a2-0 (-> this object-type-info-array (-> arg0 object-type))))
    (activate-from-params (-> this tracker-array (-> a2-0 tracker-index)) arg0)
    )
  0
  (none)
  )

(defmethod activate-by-handle ((this traffic-engine) (arg0 traffic-object-spawn-params))
  (let ((a2-0 (-> this object-type-info-array (-> arg0 object-type))))
    (activate-by-handle (-> this tracker-array (-> a2-0 tracker-index)) arg0)
    )
  0
  (none)
  )

(defmethod new-suppression-box ((this traffic-engine) (arg0 traffic-suppression-params))
  (add-new-supression-box (-> this suppressor) arg0)
  (none)
  )

(defmethod remove-suppression-box ((this traffic-engine) (arg0 traffic-suppression-params))
  (remove-box-by-id (-> this suppressor) (the-as int arg0))
  (none)
  )

(defmethod update-suppression-box ((this traffic-engine) (arg0 traffic-suppression-params))
  (update-box-from-params (-> this suppressor) arg0)
  (none)
  )

(defmethod update-suppressor ((this traffic-engine))
  (let ((v1-3 (- (-> *display* game-clock frame-counter) (-> *display* game-clock old-frame-counter))))
    (dotimes (a1-3 16)
      (let ((a2-2 (-> this suppressor array a1-3)))
        (when (logtest? (-> a2-2 flags) (traffic-suppression-box-flag in-use))
          (let ((a3-3 (-> a2-2 duration)))
            (cond
              ((< a3-3 (the-as uint v1-3))
               (logclear! (-> a2-2 flags) (traffic-suppression-box-flag in-use))
               (logior! (-> this suppressor flags) (traffic-suppressor-flag needs-update))
               )
              (else
                (set! (-> a2-2 duration) (- a3-3 (the-as uint v1-3)))
                )
              )
            )
          )
        )
      )
    )
  (when (logtest? (-> this suppressor flags) (traffic-suppressor-flag needs-update))
    (logclear! (-> this suppressor flags) (traffic-suppressor-flag needs-update))
    (recompute-suppressions this)
    )
  0
  (none)
  )

(defmethod recompute-suppressions ((this traffic-engine))
  (dotimes (s5-0 2)
    (let ((v1-3 (-> this level-data-array s5-0)))
      (if (nonzero? (-> v1-3 city-info))
          (update-suppressions-from-traffic-engine (-> v1-3 city-info) this)
          )
      )
    )
  0
  (none)
  )

(defmethod add-squad-ctrl ((this traffic-engine) (arg0 squad-control))
  (let ((v1-0 0))
    (b! #t cfg-4 :delay (nop!))
    (label cfg-1)
    (b! (-> this squad-control-array v1-0) cfg-3 :delay (empty-form))
    (set! (-> this squad-control-array v1-0) arg0)
    (b! #t cfg-6 :delay (nop!))
    (label cfg-3)
    (+! v1-0 1)
    (label cfg-4)
    (b! (< v1-0 4) cfg-1)
    )
  (label cfg-6)
  0
  (none)
  )

(defmethod check-proc-in-tracker ((this traffic-engine) (arg0 process) (arg1 int))
  (let ((v1-3 (-> this tracker-array arg1))
        (a0-3 (process->handle arg0))
        )
    (dotimes (a3-4 (the-as int (-> v1-3 active-object-count)))
      (b! (= (-> v1-3 active-object-list a3-4) a0-3) cfg-10 :delay (nop!))
      )
    )
  (format *stdebug* "proc pid ~d (~a) not found in tracker ~d~%" (-> arg0 pid) arg0 arg1)
  (label cfg-10)
  0
  0
  (none)
  )

(defmethod new traffic-engine ((allocation symbol) (type-to-make type))
  (let ((s5-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> s5-0 object-hash) ((method-of-type spatial-hash new) allocation spatial-hash #xc1c0 253))
    s5-0
    )
  )
