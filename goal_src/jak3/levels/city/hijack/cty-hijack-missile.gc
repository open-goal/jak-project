;;-*-Lisp-*-
(in-package goal)

;; name: cty-hijack-missile.gc
;; name in dgo: cty-hijack-missile
;; dgos: LCTYHIJK

;; DECOMP BEGINS

(defpart 4710
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:birth-func 'birth-func-texture-group)
    (:num 1.0)
    (:scale-x (meters 0.5) (meters 0.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 150.0)
    (:g 150.0)
    (:b 150.0)
    (:a 30.0 30.0)
    (:scalevel-x (meters 0.01))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.2 -0.2)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-13))
    (:userdata :data (new 'static 'boxed-array :type int32 20 1 0 #x400000 #x405c00))
    (:rotate-y (degrees 0))
    )
  )

(defpart 4711
  :init-specs ((:texture (bigpuff level-default-sprite))
    (:birth-func 'birth-func-texture-group)
    (:num 1.0)
    (:scale-x (meters 1) (meters 0.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 250.0)
    (:g 80.0)
    (:b 0.0)
    (:a 30.0 30.0)
    (:scalevel-x (meters 0.01))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -2.0)
    (:fade-g 1.4)
    (:fade-b 3.0)
    (:fade-a -0.2 -0.2)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2))
    (:userdata :data (new 'static 'boxed-array :type int32 50 1 0 #x400000 #x405c00))
    (:next-time (seconds 0.167))
    (:next-launcher 4712)
    (:rotate-y (degrees 0))
    )
  )

(defpart 4712
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

(defpartgroup group-missile-thruster-fire
  :id 1432
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 640)
  :parts ((sp-item 4713 :flags (is-3d sp7)) (sp-item 4714 :flags (sp6 sp7)))
  )

(defpart 4713
  :init-specs ((:texture (gun-yellow-muzzleflash level-default-sprite))
    (:num 4.0)
    (:z (meters -0.4) 1 (meters -0.5))
    (:scale-x (meters 0.1) 1 (meters 2))
    (:rot-x (degrees 180))
    (:rot-y (degrees 0))
    (:rot-z (degrees 0) 1 (degrees 90))
    (:scale-y (meters 2) 1 (meters 2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 20.0 40.0)
    (:fade-a -0.6)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:conerot-z (degrees 0))
    (:rotate-x (degrees 0))
    (:rotate-y (degrees 0))
    )
  )

(defpart 4714
  :init-specs ((:texture (glow level-default-sprite))
    (:num 1.0)
    (:y (meters 0.25))
    (:scale-x (meters 1.5) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 100.0)
    (:b 0.0)
    (:a 40.0 10.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:conerot-z (degrees 0))
    (:rotate-y (degrees 0))
    )
  )

(defskelgroup skel-cty-hijack-missile cty-homing-missile cty-homing-missile-lod0-jg cty-homing-missile-idle-ja
              ((cty-homing-missile-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              :origin-joint-index 3
              )

(deftype cty-hijack-missile-init-params (structure)
  ((pos         vector      :inline)
   (quat        quaternion  :inline)
   (track-obj   handle)
   (is-leader?  symbol)
   )
  )


(deftype evasive-compare-params (structure)
  ((data              float  3)
   (y-val             float  :overlay-at (-> data 0))
   (angular-velocity  float  :overlay-at (-> data 1))
   (speed             float  :overlay-at (-> data 2))
   )
  :pack-me
  )


(deftype evasive-action-info (structure)
  ((start-values  evasive-compare-params  :inline)
   (max-values    evasive-compare-params  :inline)
   (difficulty    float)
   (evaded?       symbol)
   )
  (:methods
    (init! (_type_ evasive-compare-params evasive-compare-params float) none)
    (evaded? (_type_ evasive-compare-params) symbol)
    )
  )


(deftype hijack-missile-bobber (structure)
  ((start-val            float)
   (current-val          float)
   (total-time           time-frame)
   (current-time         time-frame)
   (current-size-scalar  float)
   (dir                  float)
   (num-iterations       float)
   (time-scalar          float)
   (start-time-scalar    float)
   (desired-time-scalar  float)
   (scale-min            float)
   (scale-max            float)
   (time-min             float)
   (time-max             float)
   (base-time            float)
   (current-speed        float)
   (output-scale         float)
   (output-val           float)
   (charge-time          time-frame)
   (wait-time            time-frame)
   (turning?             symbol)
   )
  :pack-me
  (:methods
    (init! (_type_) none)
    (hijack-missile-bobber-method-10 (_type_) time-frame)
    (hijack-missile-bobber-method-11 (_type_) time-frame)
    )
  )


;; WARN: Return type mismatch pointer vs none.
(defmethod init! ((this evasive-action-info) (arg0 evasive-compare-params) (arg1 evasive-compare-params) (arg2 float))
  (set! (-> this evaded?) #f)
  (set! (-> this difficulty) arg2)
  (mem-copy! (the-as pointer (-> this start-values)) (the-as pointer arg1) 12)
  (mem-copy! (the-as pointer (-> this max-values)) (the-as pointer arg0) 12)
  (none)
  )

(defmethod evaded? ((this evasive-action-info) (arg0 evasive-compare-params))
  (local-vars (v0-0 symbol))
  0.0
  (dotimes (v1-0 3)
    (let ((f0-4 (/ (fabs (- (-> arg0 data v1-0) (-> this start-values data v1-0))) (-> this max-values data v1-0))))
      (when (< (-> this difficulty) f0-4)
        (set! (-> this evaded?) #t)
        (return (-> this evaded?))
        )
      )
    )
  (return (-> this evaded?))
  v0-0
  )

(deftype cty-hijack-missile (process-focusable)
  ((root                      collide-shape-moving  :override)
   (tracked-player-positions  vector-array)
   (current-track-index       uint32)
   (last-record-time          time-frame)
   (track-obj                 handle)
   (current-speed             float)
   (target-speed              float)
   (lunge-speed               float)
   (temp-vec                  vector                 :inline)
   (evasive-info              evasive-action-info    :inline)
   (target-pos                vector                 :inline)
   (flee-vec                  vector                 :inline)
   (is-leader?                symbol)
   (offset-dist               float)
   (vel-factor                float)
   (original-quat             quaternion             :inline)
   (rotate-deg                float)
   (basetrans                 vector                 :inline)
   (lisa                      lissajous-interp       :inline)
   (next-lisa-time            time-frame)
   (lisa-pt                   vector                 :inline)
   (circle-mag                float)
   (last-trans                vector                 :inline)
   (min-chase-speed           float)
   (min-targ-chase-speed      float)
   (max-chase-speed           float)
   (targ-scale-factor         float)
   (scale-factor              float)
   (missile-dist              float)
   (stage                     int8)
   (particle-trail            sparticle-subsampler)
   (particle-trail-thrust     sparticle-subsampler)
   (peel-off-sound            sound-id)
   (bobber                    hijack-missile-bobber  :inline)
   )
  (:state-methods
    idle
    undefined0
    chasing
    explode
    undefined1
    undefined2
    undefined3
    lunge-prepare
    lure
    lure-die
    chasing-2
    die
    explode-tiny
    initial-launch
    fake-chase
    )
  (:methods
    (go-idle (_type_) object)
    (cty-hijack-missile-method-44 (_type_) none)
    (probe-ground (_type_ vector vector) symbol)
    (get-tracked-obj-pos (_type_ vector) vector)
    (cty-hijack-missile-method-47 (_type_ vector int) vector)
    (cty-hijack-missile-method-48 (_type_ vector) vector)
    (cty-hijack-missile-method-49 (_type_) none)
    (event-handler (_type_ process int symbol event-message-block) object)
    (cty-hijack-missile-method-51 (_type_) none)
    (cty-hijack-missile-method-52 (_type_ symbol) float)
    (cty-hijack-missile-method-53 (_type_) none)
    )
  )


(define *missile-dist-near* 31129.6)

(define *missile-dist-far* 86016.0)

(defbehavior cty-hijack-missile-init-by-other cty-hijack-missile ((arg0 cty-hijack-missile-init-params))
  (set! (-> self level) (level-get *level* 'lctyhijk))
  (stack-size-set! (-> self main-thread) 256)
  (logclear! (-> self mask) (process-mask actor-pause))
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-12 prim-core collide-with) (collide-spec hit-by-others-list))
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 8192.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-12)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-hijack-missile" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (quaternion-copy! (-> self root quat) (-> arg0 quat))
  self
  (set! (-> self particle-trail)
        (new 'process 'sparticle-subsampler *sp-particle-system-2d* (-> *part-id-table* 4710) 8.0)
        )
  self
  (set! (-> self particle-trail-thrust)
        (new 'process 'sparticle-subsampler *sp-particle-system-2d* (-> *part-id-table* 4711) 8.0)
        )
  (set! (-> self tracked-player-positions) (new 'process 'vector-array 250))
  (set! (-> self tracked-player-positions length) 0)
  (set! (-> self last-record-time) 0)
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 1432) self))
  (set! (-> self is-leader?) (-> arg0 is-leader?))
  (set! (-> self track-obj) (-> arg0 track-obj))
  (set-vector! (-> self root scale) 0.8 0.8 0.9 1.0)
  (go-idle self)
  )

(defmethod go-idle ((this cty-hijack-missile))
  (set! (-> this peel-off-sound) (new-sound-id))
  (set! (-> this current-track-index) (the-as uint -1))
  (logior! (-> this draw status) (draw-control-status no-draw))
  (set! (-> this stage) 0)
  (init! (-> this bobber))
  (ja-post)
  (go (method-of-object this idle))
  )

(defmethod get-tracked-obj-pos ((this cty-hijack-missile) (arg0 vector))
  (let* ((s5-0 (handle->process (-> this track-obj)))
         (a0-5 (if (type? s5-0 process-focusable)
                   (the-as process-focusable s5-0)
                   )
               )
         )
    (if a0-5
        (set! (-> arg0 quad) (-> (get-trans a0-5 3) quad))
        )
    )
  arg0
  )

(defmethod probe-ground ((this cty-hijack-missile) (arg0 vector) (arg1 vector))
  (let ((v1-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> v1-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> v1-0 move-dist) arg1 (-> v1-0 start-pos))
    (let ((a0-4 v1-0))
      (set! (-> a0-4 radius) 8192.0)
      (set! (-> a0-4 collide-with) (collide-spec backgnd))
      (set! (-> a0-4 ignore-process0) #f)
      (set! (-> a0-4 ignore-process1) #f)
      (set! (-> a0-4 ignore-pat)
            (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
            )
      (set! (-> a0-4 action-mask) (collide-action solid))
      )
    (< (fill-and-probe-using-line-sphere *collide-cache* v1-0) 0.0)
    )
  )

;; WARN: Return type mismatch object vs none.
;; WARN: Function (method 44 cty-hijack-missile) has a return type of none, but the expression builder found a return statement.
(defmethod cty-hijack-missile-method-44 ((this cty-hijack-missile))
  (let ((v1-1 (-> this tracked-player-positions length)))
    (-> this tracked-player-positions)
    (when (>= v1-1 (-> this tracked-player-positions allocated-length))
      (break!)
      0
      )
    )
  (let ((s5-0 (get-tracked-obj-pos this (new 'stack-no-clear 'vector))))
    (if (>= 40.96 (vector-vector-distance
                    (-> this tracked-player-positions data (+ (-> this tracked-player-positions length) -1))
                    s5-0
                    )
            )
        (return 0)
        )
    (if (probe-ground
          this
          (-> this tracked-player-positions data (+ (-> this tracked-player-positions length) -2))
          s5-0
          )
        (set! (-> this tracked-player-positions data (+ (-> this tracked-player-positions length) -1) quad)
              (-> s5-0 quad)
              )
        (push-back (-> this tracked-player-positions) s5-0)
        )
    )
  (none)
  )

(defmethod relocate ((this cty-hijack-missile) (offset int))
  (if (nonzero? (-> this tracked-player-positions))
      (&+! (-> this tracked-player-positions) offset)
      )
  (if (nonzero? (-> this particle-trail))
      (&+! (-> this particle-trail) offset)
      )
  (if (nonzero? (-> this particle-trail-thrust))
      (&+! (-> this particle-trail-thrust) offset)
      )
  (call-parent-method this offset)
  )

(defmethod cty-hijack-missile-method-52 ((this cty-hijack-missile) (arg0 symbol))
  (set! (-> this min-chase-speed) 221184.0)
  (set! (-> this min-targ-chase-speed) 221184.0)
  (set! (-> this max-chase-speed) 253952.0)
  (set! (-> this missile-dist) *missile-dist-near*)
  (set! (-> this offset-dist) *missile-dist-near*)
  (set! (-> this stage) 2)
  (set! (-> this targ-scale-factor) 1.0)
  (if arg0
      (set! (-> this scale-factor) (-> this targ-scale-factor))
      )
  )

(defstate idle (cty-hijack-missile)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('chase-2)
       (when (time-elapsed? (-> self state-time) (seconds 1))
         (cty-hijack-missile-method-52 self #t)
         (go-virtual chasing-2)
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self missile-dist) *missile-dist-far*)
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (when (not (task-node-closed? (game-task-node city-hijack-vehicle-escape)))
      (set! (-> self targ-scale-factor) 0.6)
      (set! (-> self scale-factor) (-> self targ-scale-factor))
      (set! (-> self min-chase-speed) 114688.0)
      (set! (-> self min-targ-chase-speed) 221184.0)
      (set! (-> self max-chase-speed) 0.0)
      (go-virtual initial-launch)
      )
    )
  :code sleep-code
  )

(defstate initial-launch (cty-hijack-missile)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('begin-moving)
       (go-virtual fake-chase)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logclear! (-> self draw status) (draw-control-status no-draw))
    )
  :trans (behavior ()
    (cty-hijack-missile-method-49 self)
    (if (and (time-elapsed? (-> self state-time) (seconds 0.6))
             (or (time-elapsed? (-> self state-time) (seconds 1.5))
                 (not (logtest? (-> self draw status) (draw-control-status on-screen)))
                 )
             )
        (go-virtual fake-chase)
        )
    (let ((v1-15 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))))
      (* 0.0022222223 (the float (- (current-time) (-> self state-time))))
      (let ((f0-2 163840.0))
        (if (time-elapsed? (-> self state-time) (seconds 0.6))
            (set! f0-2 4096.0)
            )
        (vector+float*! (-> self root trans) (-> self root trans) v1-15 (* f0-2 (seconds-per-frame)))
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    )
  )

(defstate die (cty-hijack-missile)
  :virtual #t
  :code nothing
  )

(defstate explode-tiny (cty-hijack-missile)
  :virtual #t
  :enter (behavior ()
    (cond
      ((logtest? (-> *part-group-id-table* 217 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 217))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 217))
        )
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    '()
    )
  )

(defstate explode (cty-hijack-missile)
  :virtual #t
  :enter (behavior ()
    (sound-play "hj-explode")
    (logior! (-> self draw status) (draw-control-status no-draw))
    (cond
      ((logtest? (-> *part-group-id-table* 296 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 296))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 296))
        )
      )
    (send-event
      (handle->process (-> self track-obj))
      'attack
      #f
      (static-attack-info :mask (vehicle-impulse-factor) ((id (new-attack-id))
                                                          (damage 32.0)
                                                          (vehicle-damage-factor 2.0)
                                                          (vehicle-impulse-factor 0.0)
                                                          (mode 'eco-dark)
                                                          (penetrate-using (penetrate explode))
                                                          )
                          )
      )
    )
  :code (behavior ()
    '()
    )
  )

(defmethod cty-hijack-missile-method-47 ((this cty-hijack-missile) (arg0 vector) (arg1 int))
  (let* ((s3-0 (handle->process (-> this track-obj)))
         (s2-0 (if (type? s3-0 process-focusable)
                   (the-as h-kg-pickup s3-0)
                   )
               )
         (s3-1 (get-tracked-obj-pos this (new 'stack-no-clear 'vector)))
         (s5-1 (new 'stack-no-clear 'vector))
         )
    (let ((s0-0 (new 'stack-no-clear 'vector)))
      (set! (-> s0-0 quad) (-> s2-0 root transv quad))
      (let ((v1-8 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> s2-0 root quat)))
            (s1-0 (new 'stack-no-clear 'vector))
            )
        0.0
        (set! (-> v1-8 y) 0.0)
        (set! (-> s0-0 y) 0.0)
        (cond
          (#f
            (let ((f30-0 (* 0.41380316 (vector-length s0-0) (/ 32768.0 (fabs (-> s2-0 turn-rate)))))
                  (s0-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) s0-0 1.0))
                  )
              (let ((f0-5 16384.0))
                (if (< (-> s2-0 turn-rate) 0.0)
                    (set! f0-5 (* -1.0 f0-5))
                    )
                (vector-rotate-y! s0-1 s0-1 f0-5)
                )
              (vector+float*! s1-0 s3-1 s0-1 f30-0)
              )
            (let ((f0-8 (* 0.0033333334 (the float arg1) (-> s2-0 turn-rate)))
                  (s4-2 (vector-! (new 'stack-no-clear 'vector) s3-1 s1-0))
                  )
              (vector-rotate-around-y! s4-2 s4-2 f0-8)
              (vector+! s5-1 s1-0 s4-2)
              )
            )
          (else
            (vector+float*! s5-1 s3-1 s0-0 (* 0.0033333334 (the float arg1)))
            )
          )
        )
      )
    (set! (-> arg0 quad) (-> s5-1 quad))
    )
  (add-debug-sphere #t (bucket-id debug) arg0 (meters 2) *color-yellow*)
  arg0
  )

(defstate lunge-prepare (cty-hijack-missile)
  :virtual #t
  :code sleep-code
  )

(defmethod cty-hijack-missile-method-48 ((this cty-hijack-missile) (arg0 vector))
  (let* ((s5-0 (handle->process (-> this track-obj)))
         (v1-3 (if (type? s5-0 process-focusable)
                   (the-as h-kg-pickup s5-0)
                   )
               )
         )
    (when v1-3
      (set! (-> arg0 x) (-> v1-3 root trans y))
      (set! (-> arg0 y) (-> v1-3 turn-rate))
      (set! (-> arg0 z) (vector-length (-> v1-3 root transv)))
      )
    )
  arg0
  )

(defstate lure-die (cty-hijack-missile)
  :virtual #t
  :enter (behavior ()
    (sound-stop (-> self peel-off-sound))
    (logior! (-> self draw status) (draw-control-status no-draw))
    (cond
      ((logtest? (-> *part-group-id-table* 88 flags) (sp-group-flag sp13))
       (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
       (part-tracker-spawn part-tracker-subsampler :to *entity-pool* :group (-> *part-group-id-table* 88))
       )
      (else
        (set! (-> *launch-matrix* trans quad) (-> self root trans quad))
        (part-tracker-spawn part-tracker :to *entity-pool* :group (-> *part-group-id-table* 88))
        )
      )
    (send-event (handle->process (-> self track-obj)) 'missile-hit)
    (send-event (ppointer->process (-> self parent)) 'missile-die)
    )
  :code nothing
  )

(defstate lure (cty-hijack-missile)
  :virtual #t
  :enter (behavior ()
    (set! (-> self current-speed) 389120.0)
    (set-time! (-> self state-time))
    (sound-play "missil-peel-off" :id (-> self peel-off-sound))
    )
  :trans (behavior ()
    (cty-hijack-missile-method-49 self)
    (get-tracked-obj-pos self (-> self target-pos))
    (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self target-pos) (-> self root trans))))
      0.0
      (if (< (vector-normalize-ret-len! s5-1 1.0) 20480.0)
          (go-virtual lure-die)
          )
      (cond
        ((not (time-elapsed? (-> self state-time) (seconds 0.2)))
         (* 0.016666668 (the float (- (current-time) (-> self state-time))))
         (quaternion-slerp!
           (-> self root quat)
           (-> self root quat)
           (-> self original-quat)
           (* 3.0 (seconds-per-frame))
           )
         )
        (else
          (let* ((gp-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                 (f0-7 (vector-dot s5-1 gp-0))
                 )
            (when (< f0-7 0.999)
              (let ((s4-1 (vector-cross! (new 'stack-no-clear 'vector) gp-0 s5-1))
                    (f30-0 (acos f0-7))
                    (f28-0 32768.0)
                    )
                (if (time-elapsed? (-> self state-time) (seconds 1.5))
                    (set! f28-0 (* 0.0033333334 (the float (- (current-time) (-> self state-time))) f28-0))
                    )
                (vector-normalize! s4-1 1.0)
                (let ((f0-12 (fmin f30-0 (* f28-0 (seconds-per-frame)))))
                  (vector-rotate-around-axis! gp-0 (the-as quaternion gp-0) f0-12 s4-1)
                  )
                )
              (quaternion-look-at! (-> self root quat) gp-0 *up-vector*)
              )
            )
          )
        )
      )
    (let ((v1-42 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))))
      (vector+float*!
        (-> self root trans)
        (-> self root trans)
        v1-42
        (* (-> self current-speed) (seconds-per-frame))
        )
      )
    )
  :code sleep-code
  :post ja-post
  )

(defmethod cty-hijack-missile-method-49 ((this cty-hijack-missile))
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (matrix-f-u-compose gp-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) *up-vector*)
    (set! (-> gp-0 trans quad) (-> this root trans quad))
    (vector+float*! (-> gp-0 trans) (-> gp-0 trans) (-> gp-0 fvec) -3686.4)
    (spawn-from-mat (-> this part) gp-0)
    (vector+float*! (-> gp-0 trans) (-> gp-0 trans) (-> gp-0 fvec) -4096.0)
    (if (and (-> this next-state) (= (-> this next-state name) 'lure))
        (init-with-mat! (-> this particle-trail-thrust) gp-0)
        (init-with-mat! (-> this particle-trail) gp-0)
        )
    )
  0
  (none)
  )

(defun compute-target-speed ()
  (* 204800.0 (compute-suck-speed-scalar))
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod event-handler ((this cty-hijack-missile) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('die)
     (go (method-of-object this die))
     )
    (('explode)
     (if (not (and (-> this next-state) (= (-> this next-state name) 'explode)))
         (go (method-of-object this explode))
         )
     )
    (('get-closer)
     (set! (-> this missile-dist) 31129.6)
     (set! (-> this target-speed) (compute-target-speed))
     )
    (('chase-2)
     (cty-hijack-missile-method-52 this #f)
     (if (and (-> this next-state) (= (-> this next-state name) 'chasing))
         (go (method-of-object this chasing-2))
         )
     )
    (('lure)
     (when (-> this is-leader?)
       (let ((s4-0 (new 'stack-no-clear 'vector)))
         (let ((s3-0 arg0))
           (set! (-> s4-0 quad) (-> (get-trans
                                      (the-as process-focusable (if (type? s3-0 process-focusable)
                                                                    (the-as process-focusable s3-0)
                                                                    )
                                              )
                                      3
                                      )
                                    quad
                                    )
                 )
           )
         (let ((s3-1 (get-tracked-obj-pos this (new 'stack-no-clear 'vector))))
           0.0
           (let ((a0-17 (new 'stack-no-clear 'vector)))
             (vector-! a0-17 s4-0 s3-1)
             (let ((f0-3 (vector-normalize-ret-len! a0-17 1.0)))
               (when (and (< 192512.0 f0-3) (< f0-3 286720.0))
                 (format 0 "Player dist ~m~%" f0-3)
                 (let ((s2-0 (handle->process (-> this track-obj))))
                   (when (if (type? s2-0 process-focusable)
                             s2-0
                             )
                     (let ((s2-2 (vector-! (new 'stack-no-clear 'vector) s4-0 (-> this root trans))))
                       0.0
                       (let ((s1-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat))))
                         (vector-normalize-ret-len! s2-2 1.0)
                         (when (< 0.707 (vector-dot s1-0 s2-2))
                           (let* ((s2-4 (vector-! (new 'stack-no-clear 'vector) s4-0 s3-1))
                                  (s4-1 vector-z-quaternion!)
                                  (s3-2 (new 'stack-no-clear 'vector))
                                  (s1-1 (handle->process (-> this track-obj)))
                                  (s4-2 (s4-1 s3-2 (-> (the-as process-focusable (if (type? s1-1 process-focusable)
                                                                                     (the-as process-focusable s1-1)
                                                                                     )
                                                               )
                                                       root
                                                       quat
                                                       )
                                              )
                                        )
                                  )
                             (set! (-> s4-2 y) 0.0)
                             (vector-normalize! s4-2 1.0)
                             (set! (-> s2-4 y) 0.0)
                             (vector-normalize! s2-4 1.0)
                             (vector-cross! s2-4 s2-4 *up-vector*)
                             (let ((f0-10 (vector-dot s4-2 s2-4))
                                   (f30-0 9102.223)
                                   )
                               (if (< f0-10 0.0)
                                   (set! f30-0 (* -1.0 f30-0))
                                   )
                               (let ((s4-3 quaternion-rotate-y!)
                                     (s3-3 (-> this original-quat))
                                     (s2-5 (handle->process (-> this track-obj)))
                                     )
                                 (s4-3
                                   s3-3
                                   (-> (the-as process-focusable (if (type? s2-5 process-focusable)
                                                                     (the-as process-focusable s2-5)
                                                                     )
                                               )
                                       root
                                       quat
                                       )
                                   f30-0
                                   )
                                 )
                               (set! (-> this rotate-deg) f30-0)
                               )
                             )
                           (set! (-> this track-obj) (process->handle arg0))
                           (send-event arg0 'missile-attract)
                           (go (method-of-object this lure))
                           )
                         )
                       )
                     )
                   )
                 )
               )
             )
           )
         )
       )
     )
    (('set-leader)
     (set! (-> this is-leader?) #t)
     )
    )
  #t
  )

(defbehavior cty-hijack-missile-chase-event-handler cty-hijack-missile ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (event-handler self arg0 arg1 arg2 arg3)
  )

(define *k0* 12.0)

(define *k1* 1.0)

(define *missile-dist-start* 81920.0)

(define *accel-scalar* 0.5)

;; WARN: Return type mismatch object vs none.
;; WARN: Function (method 51 cty-hijack-missile) has a return type of none, but the expression builder found a return statement.
(defmethod cty-hijack-missile-method-51 ((this cty-hijack-missile))
  (local-vars (sv-64 float) (sv-68 float) (sv-72 float) (sv-76 vector) (sv-80 float))
  (let* ((s4-0 (handle->process (-> this track-obj)))
         (s5-0 (if (type? s4-0 process-focusable)
                   (the-as process-focusable s4-0)
                   )
               )
         (s4-1 (new 'stack-no-clear 'vector))
         (a0-5 (new 'stack-no-clear 'vector))
         )
    0.0
    (if (not s5-0)
        (return 0)
        )
    (set! (-> a0-5 quad) (-> s5-0 root transv quad))
    (let ((f30-0 (vector-normalize-ret-len! a0-5 1.0)))
      (set! (-> s4-1 quad) (-> this target-pos quad))
      (when #t
        (seek! (-> this offset-dist) (-> this missile-dist) (* 20480.0 (seconds-per-frame)))
        (seek! (-> this vel-factor) *k1* (* 2.0 (seconds-per-frame)))
        (if (< (vector-vector-xz-distance (-> this basetrans) (get-trans s5-0 0)) 61440.0)
            (set! (-> this vel-factor) *k1*)
            )
        )
      (set! sv-64 (-> this offset-dist))
      (set! sv-68 (-> this current-speed))
      (set! sv-72 (the-as float 0.0))
      (set! sv-76 (vector-! (new 'stack-no-clear 'vector) s4-1 (-> this basetrans)))
      (set! sv-80 (the-as float 0.0))
      (set! sv-72 (vector-normalize-ret-len! sv-76 1.0))
      (if (and (-> this is-leader?) (< (vector-vector-xz-distance (-> this basetrans) s4-1) 18432.0))
          (go (method-of-object this explode))
          )
      (cond
        ((< 409.6 sv-72)
         (set! sv-80 (+ (* (- sv-72 sv-64) *k0*) (* (- f30-0 sv-68) (-> this vel-factor))))
         (set! sv-80 (* sv-80 *accel-scalar*))
         (+! (-> this current-speed) (* sv-80 (seconds-per-frame)))
         (when (-> this is-leader?)
           )
         (seek! (-> this min-chase-speed) (-> this min-targ-chase-speed) (* 6144.0 (seconds-per-frame)))
         (set! (-> this current-speed) (fmax (-> this current-speed) (-> this target-speed)))
         (cond
           ((>= 0.0 (-> this max-chase-speed))
            (when (< (vector-vector-xz-distance (-> this basetrans) (get-trans s5-0 0)) 32768.0)
              )
            )
           ((< (vector-vector-xz-distance (-> this basetrans) (get-trans s5-0 0)) 81920.0)
            (set! (-> this current-speed)
                  (fmax (fmin (-> this current-speed) (-> this max-chase-speed)) (-> this min-chase-speed))
                  )
            )
           )
         (when (-> this is-leader?)
           )
         (quaternion-look-at! (-> this root quat) sv-76 *up-vector*)
         (vector+float*! (-> this basetrans) (-> this basetrans) sv-76 (* (-> this current-speed) (seconds-per-frame)))
         )
        (else
          (vector+float*!
            (-> this basetrans)
            (-> this basetrans)
            (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat))
            (* (-> this current-speed) (seconds-per-frame))
            )
          )
        )
      )
    )
  (when (< (-> this next-lisa-time) (current-time))
    (let* ((f30-1 30720.0)
           (f28-0 6144.0)
           (v1-57 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-58 (the-as number (logior #x3f800000 v1-57)))
           )
      (set! (-> this circle-mag) (+ f30-1 (* f28-0 (+ -1.0 (the-as float v1-58)))))
      )
    (cond
      ((!= (-> this stage) 1)
       (let* ((f30-2 43690.668)
              (f28-1 10922.664)
              (v1-64 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
              (v1-65 (the-as number (logior #x3f800000 v1-64)))
              )
         (set! (-> this lisa rate theta) (* (+ f30-2 (* f28-1 (+ -1.0 (the-as float v1-65)))) (seconds-per-frame)))
         )
       (let* ((f30-3 9216.0)
              (f28-2 7987.199)
              (v1-71 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
              (v1-72 (the-as number (logior #x3f800000 v1-71)))
              )
         (set! (-> this lisa dest x-mag) (+ f30-3 (* f28-2 (+ -1.0 (the-as float v1-72)))))
         )
       (let* ((f30-4 9216.0)
              (f28-3 7987.199)
              (v1-77 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
              (v1-78 (the-as number (logior #x3f800000 v1-77)))
              )
         (set! (-> this lisa dest y-mag) (+ f30-4 (* f28-3 (+ -1.0 (the-as float v1-78)))))
         )
       (let* ((f30-5 0.5)
              (f28-4 0.75)
              (v1-83 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
              (v1-84 (the-as number (logior #x3f800000 v1-83)))
              )
         (set! (-> this lisa dest theta-rate) (+ f30-5 (* f28-4 (+ -1.0 (the-as float v1-84)))))
         )
       )
      (else
        (let* ((f30-6 32768.0)
               (f28-5 10922.668)
               (v1-90 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-91 (the-as number (logior #x3f800000 v1-90)))
               )
          (set! (-> this lisa rate theta) (* (+ f30-6 (* f28-5 (+ -1.0 (the-as float v1-91)))) (seconds-per-frame)))
          )
        (let* ((f30-7 5120.0)
               (f28-6 5120.0)
               (v1-97 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-98 (the-as number (logior #x3f800000 v1-97)))
               )
          (set! (-> this lisa dest x-mag) (+ f30-7 (* f28-6 (+ -1.0 (the-as float v1-98)))))
          )
        (let* ((f30-8 9216.0)
               (f28-7 1024.0)
               (v1-103 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-104 (the-as number (logior #x3f800000 v1-103)))
               )
          (set! (-> this lisa dest y-mag) (+ f30-8 (* f28-7 (+ -1.0 (the-as float v1-104)))))
          )
        (let* ((f30-9 0.5)
               (f28-8 0.75)
               (v1-109 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-110 (the-as number (logior #x3f800000 v1-109)))
               )
          (set! (-> this lisa dest theta-rate) (+ f30-9 (* f28-8 (+ -1.0 (the-as float v1-110)))))
          )
        )
      )
    (set! (-> this next-lisa-time)
          (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 601) 150 (current-time)))
          )
    )
  (let ((v1-118 (the-as vehicle (handle->process (-> this track-obj)))))
    (when v1-118
      (when (and (< 0.75 (fabs (-> v1-118 controls steering))) (!= (-> this stage) 1))
        (seek! (-> this lisa dest x-mag) (-> this circle-mag) (* 18432.0 (seconds-per-frame)))
        (seek! (-> this lisa dest y-mag) (-> this circle-mag) (* 18432.0 (seconds-per-frame)))
        )
      )
    )
  (set! (-> this lisa dest wx) 1.0)
  (set! (-> this lisa dest wy) 1.2)
  (set! (-> this lisa rate wx) 10.0)
  (set! (-> this lisa rate wy) 10.0)
  (set! (-> this lisa rate x-mag) (* 10240.0 (seconds-per-frame)))
  (set! (-> this lisa rate y-mag) (* 10240.0 (seconds-per-frame)))
  (set! (-> this lisa rate period-shift) (* 16384.0 (seconds-per-frame)))
  (set! (-> this lisa dest period-shift) 16384.0)
  (lissajous-interp-method-10 (-> this lisa))
  (let ((s5-3 (lissajous-interp-method-9 (-> this lisa) (new 'stack-no-clear 'vector))))
    (vector-float*! s5-3 s5-3 0.5)
    (vector-lerp! (-> this lisa-pt) (-> this lisa-pt) s5-3 1.0)
    (let ((a2-9 (matrix-f-u-compose (matrix-identity! (new 'stack-no-clear 'matrix)) sv-76 *up-vector*)))
      (vector-matrix*! s5-3 (-> this lisa-pt) a2-9)
      )
    (vector+! (-> this root trans) (-> this basetrans) s5-3)
    )
  (let ((v1-147 (the-as vehicle (handle->process (-> this track-obj)))))
    (when v1-147
      (if (< 0.75 (fabs (-> v1-147 controls steering)))
          (set! (-> this bobber turning?) #t)
          (set! (-> this bobber turning?) #f)
          )
      )
    )
  (if (= (-> this stage) 1)
      (set! (-> this bobber output-scale) 4096.0)
      (set! (-> this bobber output-scale) 16384.0)
      )
  (hijack-missile-bobber-method-10 (-> this bobber))
  (let ((f0-118 (- (-> this bobber output-val) (* 0.8 (-> this bobber output-scale)))))
    (vector+float*! (-> this root trans) (-> this root trans) sv-76 f0-118)
    )
  (let ((s5-5 (vector-! (new 'stack-no-clear 'vector) (-> this root trans) (-> this last-trans))))
    (vector-normalize! s5-5 1.0)
    (quaternion-look-at! (-> this root quat) s5-5 *up-vector*)
    )
  (set! (-> this last-trans quad) (-> this root trans quad))
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod cty-hijack-missile-method-53 ((this cty-hijack-missile))
  (set! (-> this next-lisa-time) 0)
  (let* ((f30-0 72817.78)
         (v1-2 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
         (v1-3 (the-as number (logior #x3f800000 v1-2)))
         )
    (set! (-> this lisa current theta) (* f30-0 (+ -1.0 (the-as float v1-3))))
    )
  (set! (-> this lisa current theta-rate) 1.0)
  (set! (-> this lisa rate theta-rate) (seconds-per-frame))
  (set! (-> this lisa current x-mag) 20480.0)
  (set! (-> this lisa current y-mag) 20480.0)
  (set! (-> this lisa dest theta) (if (not (logtest? (rand-uint31-gen *random-generator*) 1))
                                      1820444400.0
                                      -1820444400.0
                                      )
        )
  (set! (-> this lisa dest x-mag) 20480.0)
  (set! (-> this lisa dest y-mag) 20480.0)
  (set! (-> this next-lisa-time) 0)
  (set! (-> this lisa dest wx) 1.0)
  (set! (-> this lisa dest wy) 1.2)
  (set! (-> this lisa dest period-shift) 16384.0)
  (set! (-> this basetrans quad) (-> this root trans quad))
  (none)
  )

(defstate fake-chase (cty-hijack-missile)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('begin-moving)
       (set! (-> self target-speed) 143360.0)
       )
      (('full-chase)
       (set! (-> self missile-dist) *missile-dist-far*)
       (set! (-> self offset-dist) *missile-dist-far*)
       (set! (-> self stage) 1)
       (set! (-> self targ-scale-factor) 0.6)
       (set! (-> self scale-factor) (-> self targ-scale-factor))
       (set! (-> self min-chase-speed) 114688.0)
       (set! (-> self min-targ-chase-speed) 221184.0)
       (set! (-> self max-chase-speed) 0.0)
       (set! (-> self current-speed) (-> self min-chase-speed))
       (set! (-> self target-speed) (-> self min-chase-speed))
       (go-virtual chasing-2)
       )
      (else
        (cty-hijack-missile-chase-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self target-speed) 0.0)
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (cty-hijack-missile-method-53 self)
    )
  :trans (behavior ()
    (local-vars (gp-4 symbol))
    (if (< 40960.0 (-> self min-chase-speed))
        (seek! (-> self min-chase-speed) 40960.0 (* 40960.0 (seconds-per-frame)))
        )
    (seek! (-> self scale-factor) (-> self targ-scale-factor) (seconds-per-frame))
    (let ((v1-7 (-> self root scale))
          (a0-2 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-2 x) 0.8)
      (set! (-> a0-2 y) 0.8)
      (set! (-> a0-2 z) 0.9)
      (set! (-> a0-2 w) 1.0)
      (vector-float*! v1-7 a0-2 (-> self scale-factor))
      )
    (cty-hijack-missile-method-49 self)
    (get-tracked-obj-pos self (-> self target-pos))
    (when (< (-> self next-lisa-time) (current-time))
      (let* ((f30-0 30720.0)
             (f28-0 6144.0)
             (v1-18 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-19 (the-as number (logior #x3f800000 v1-18)))
             )
        (set! (-> self circle-mag) (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-19)))))
        )
      (let* ((f30-1 43690.668)
             (f28-1 10922.664)
             (v1-24 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-25 (the-as number (logior #x3f800000 v1-24)))
             )
        (set! (-> self lisa rate theta) (* (+ f30-1 (* f28-1 (+ -1.0 (the-as float v1-25)))) (seconds-per-frame)))
        )
      (let* ((f30-2 9216.0)
             (f28-2 7987.199)
             (v1-31 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-32 (the-as number (logior #x3f800000 v1-31)))
             )
        (set! (-> self lisa dest x-mag) (+ f30-2 (* f28-2 (+ -1.0 (the-as float v1-32)))))
        )
      (let* ((f30-3 9216.0)
             (f28-3 7987.199)
             (v1-37 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-38 (the-as number (logior #x3f800000 v1-37)))
             )
        (set! (-> self lisa dest y-mag) (+ f30-3 (* f28-3 (+ -1.0 (the-as float v1-38)))))
        )
      (let* ((f30-4 0.5)
             (f28-4 0.75)
             (v1-43 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-44 (the-as number (logior #x3f800000 v1-43)))
             )
        (set! (-> self lisa dest theta-rate) (+ f30-4 (* f28-4 (+ -1.0 (the-as float v1-44)))))
        )
      (set! (-> self next-lisa-time)
            (the-as time-frame (+ (mod (the-as int (rand-uint31-gen *random-generator*)) 601) 150 (current-time)))
            )
      )
    (set! (-> self lisa dest wx) 1.0)
    (set! (-> self lisa dest wy) 1.2)
    (set! (-> self lisa rate wx) 10.0)
    (set! (-> self lisa rate wy) 10.0)
    (set! (-> self lisa rate x-mag) (* 10240.0 (seconds-per-frame)))
    (set! (-> self lisa rate y-mag) (* 10240.0 (seconds-per-frame)))
    (set! (-> self lisa rate period-shift) (* 16384.0 (seconds-per-frame)))
    (set! (-> self lisa dest period-shift) 16384.0)
    (lissajous-interp-method-10 (-> self lisa))
    (let ((gp-0 (lissajous-interp-method-9 (-> self lisa) (new 'stack-no-clear 'vector))))
      (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self target-pos) (-> self basetrans))))
        (vector-normalize! s5-1 1.0)
        (vector-float*! gp-0 gp-0 0.5)
        (vector-lerp! (-> self lisa-pt) (-> self lisa-pt) gp-0 1.0)
        (let ((a2-4 (matrix-f-u-compose (matrix-identity! (new 'stack-no-clear 'matrix)) s5-1 *up-vector*)))
          (vector-matrix*! gp-0 (-> self lisa-pt) a2-4)
          )
        (vector+float*! (-> self basetrans) (-> self basetrans) s5-1 (* (-> self target-speed) (seconds-per-frame)))
        )
      (vector+! (-> self root trans) (-> self basetrans) gp-0)
      )
    (let ((gp-2 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (-> self last-trans))))
      (vector-normalize! gp-2 1.0)
      (quaternion-look-at! (-> self root quat) gp-2 *up-vector*)
      )
    (set! (-> self last-trans quad) (-> self root trans quad))
    (if (and (< (vector-vector-distance (-> self root trans) (get-tracked-obj-pos self (new 'stack-no-clear 'vector)))
                20480.0
                )
             (-> self is-leader?)
             )
        (go-virtual explode)
        )
    (if (or (not (handle->process (-> self track-obj)))
            (begin
              (let* ((gp-5 #t)
                     (s5-3 (handle->process (-> self track-obj)))
                     (v1-94 (the-as focus-status (logand (-> (the-as process-focusable (if (type? s5-3 process-focusable)
                                                                                           (the-as process-focusable s5-3)
                                                                                           )
                                                                     )
                                                             focus-status
                                                             )
                                                         (focus-status dead)
                                                         )
                                    )
                            )
                     )
                (cmove-#f-zero gp-4 v1-94 gp-5)
                )
              gp-4
              )
            )
        (go-virtual explode-tiny)
        )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    )
  )

(defstate chasing-2 (cty-hijack-missile)
  :virtual #t
  :event cty-hijack-missile-chase-event-handler
  :enter (behavior ()
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (set! (-> self target-speed) 122880.0)
    (set! (-> self current-speed) 122880.0)
    (set! (-> self vel-factor) 10.0)
    (cty-hijack-missile-method-53 self)
    )
  :trans (behavior ()
    (local-vars (gp-0 symbol))
    (seek! (-> self scale-factor) (-> self targ-scale-factor) (seconds-per-frame))
    (let ((v1-2 (-> self root scale))
          (a0-1 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-1 x) 0.8)
      (set! (-> a0-1 y) 0.8)
      (set! (-> a0-1 z) 0.9)
      (set! (-> a0-1 w) 1.0)
      (vector-float*! v1-2 a0-1 (-> self scale-factor))
      )
    (cty-hijack-missile-method-49 self)
    (get-tracked-obj-pos self (-> self target-pos))
    (cty-hijack-missile-method-51 self)
    (if (or (not (handle->process (-> self track-obj)))
            (begin
              (let* ((gp-1 #t)
                     (s5-0 (handle->process (-> self track-obj)))
                     (v1-18 (the-as focus-status (logand (-> (the-as process-focusable (if (type? s5-0 process-focusable)
                                                                                           (the-as process-focusable s5-0)
                                                                                           )
                                                                     )
                                                             focus-status
                                                             )
                                                         (focus-status dead)
                                                         )
                                    )
                            )
                     )
                (cmove-#f-zero gp-0 v1-18 gp-1)
                )
              gp-0
              )
            )
        (go-virtual explode-tiny)
        )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    )
  )

(define *use-lunging* #f)

(defstate chasing (cty-hijack-missile)
  :virtual #t
  :event cty-hijack-missile-chase-event-handler
  :enter (behavior ()
    (set! (-> self current-track-index) (the-as uint 1))
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (set! (-> self current-speed) 122880.0)
    (set! (-> self target-speed) (compute-target-speed))
    )
  :trans (behavior ()
    (cond
      ((-> self is-leader?)
       (logclear! (-> self draw status) (draw-control-status no-draw))
       (cty-hijack-missile-method-49 self)
       )
      (else
        (logior! (-> self draw status) (draw-control-status no-draw))
        )
      )
    (cty-hijack-missile-method-44 self)
    (seek! (-> self current-speed) (-> self target-speed) (* 16384.0 (seconds-per-frame)))
    (if (and (< (vector-vector-distance (-> self root trans) (get-tracked-obj-pos self (new 'stack-no-clear 'vector)))
                20480.0
                )
             (-> self is-leader?)
             )
        (go-virtual explode)
        )
    (let* ((a1-3 (-> self tracked-player-positions data (-> self current-track-index)))
           (f0-6 (vector-vector-distance-squared (-> self root trans) a1-3))
           (f1-2 819.2)
           )
      (when (< f0-6 (* f1-2 f1-2))
        (if (< (-> self current-track-index) (the-as uint (+ (-> self tracked-player-positions length) -1)))
            (+! (-> self current-track-index) 1)
            )
        )
      )
    (let ((gp-1 (+ (-> self tracked-player-positions length) -2)))
      (until #f
        (when (< gp-1 (the-as int (+ (-> self current-track-index) 1)))
          0
          (goto cfg-21)
          )
        (when (probe-ground self (-> self root trans) (-> self tracked-player-positions data gp-1))
          (set! (-> self current-track-index) (the-as uint gp-1))
          0
          (goto cfg-21)
          )
        (+! gp-1 -1)
        )
      )
    #f
    (label cfg-21)
    (let ((v1-52 (-> self tracked-player-positions data (+ (-> self current-track-index) -1)))
          (s5-1 (-> self tracked-player-positions data (-> self current-track-index)))
          (a0-19 (new 'stack-no-clear 'vector))
          (gp-2 (new 'stack-no-clear 'vector))
          )
      0.0
      (vector-! a0-19 s5-1 v1-52)
      (vector-normalize! a0-19 1.0)
      (vector-! gp-2 s5-1 (-> self root trans))
      (let* ((f0-8 (vector-normalize-ret-len! gp-2 1.0))
             (f0-9 (fmin (* (-> self current-speed) (seconds-per-frame)) f0-8))
             )
        (vector+float*! (-> self root trans) (-> self root trans) gp-2 f0-9)
        )
      (quaternion-look-at! (-> self root quat) gp-2 *up-vector*)
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    )
  )

(defmethod hijack-missile-bobber-method-10 ((this hijack-missile-bobber))
  (with-pp
    (let* ((f1-2 (/ (the float (-> this current-time)) (the float (-> this total-time))))
           (f30-0 (fmax 0.0 (fmin 1.0 f1-2)))
           )
      (set! (-> this time-scalar) (lerp (-> this start-time-scalar) (-> this desired-time-scalar) f30-0))
      (set! (-> this current-speed) (* (-> this dir) (cos (* 32768.0 f30-0))))
      (let ((f1-4 (sin (* 32768.0 f30-0))))
        (set! (-> this current-val) (+ (-> this start-val) (* (-> this current-size-scalar) f1-4 (-> this dir))))
        )
      )
    (set! (-> this output-val) (* (-> this output-scale) (-> this current-val)))
    (when (< (-> this total-time) (-> this current-time))
      (set! (-> this start-val) (-> this current-val))
      (set! (-> this start-time-scalar) (-> this time-scalar))
      (set! (-> this current-time) 0)
      (hijack-missile-bobber-method-11 this)
      )
    (let ((v0-4
            (+ (-> this current-time)
               (max 1 (the int (* (the float (- (current-time) (-> pp clock old-frame-counter))) (-> this time-scalar))))
               )
            )
          )
      (set! (-> this current-time) v0-4)
      v0-4
      )
    )
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod init! ((this hijack-missile-bobber))
  (set! (-> this start-val) 0.0)
  (set! (-> this current-val) 0.0)
  (set! (-> this dir) 1.0)
  (set! (-> this scale-min) 0.65)
  (set! (-> this scale-max) 1.35)
  (set! (-> this current-size-scalar) 1.0)
  (set! (-> this num-iterations) 1.0)
  (set! (-> this time-scalar) 1.0)
  (set! (-> this start-time-scalar) 1.0)
  (set! (-> this desired-time-scalar) 1.0)
  (set! (-> this output-scale) 6144.0)
  (set! (-> this time-min) 0.7)
  (set! (-> this time-max) 0.8)
  (set! (-> this base-time) 1.0)
  (set! (-> this desired-time-scalar) 0.75)
  (set! (-> this turning?) #f)
  (hijack-missile-bobber-method-11 this)
  (none)
  )

;; WARN: Return type mismatch int vs time-frame.
(defmethod hijack-missile-bobber-method-11 ((this hijack-missile-bobber))
  (cond
    (#f
      (set! (-> this base-time) 0.25)
      )
    (else
      (let* ((f30-0 0.4)
             (f28-0 0.20000002)
             (v1-5 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-6 (the-as number (logior #x3f800000 v1-5)))
             )
        (set! (-> this base-time) (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-6)))))
        )
      )
    )
  (set! (-> this dir) (* -1.0 (-> this dir)))
  (let* ((f28-1 (if (< (-> this dir) 0.0)
                    (+ 1.0 (-> this current-val))
                    (- 1.0 (-> this current-val))
                    )
                )
         (f30-1 (fmin (-> this scale-min) f28-1))
         (v1-14 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
         (v1-15 (the-as number (logior #x3f800000 v1-14)))
         )
    (set! (-> this current-size-scalar)
          (+ f30-1
             (* (+ -1.0 (the-as float v1-15)) (- (fmin (-> this scale-max) f28-1) (fmin (-> this scale-min) f28-1)))
             )
          )
    )
  (let* ((f0-19 (-> this current-size-scalar))
         (v0-2 (the int (* 300.0 (-> this base-time) (-> this num-iterations) f0-19)))
         )
    (set! (-> this total-time) (the-as time-frame v0-2))
    (the-as time-frame v0-2)
    )
  )
