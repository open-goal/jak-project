;;-*-Lisp-*-
(in-package goal)

;; name: cty-hijack.gc
;; name in dgo: cty-hijack
;; dgos: LCTYHIJK

;; +++hijack-speech-info-flag
(defenum hijack-speech-info-flag
  :type uint64
  :bitfield #t
  (hsi0 0)
  (hsi1 1)
  (hsi2 2)
  (hsi3 3)
  (hsi4 4)
  (hsi5 5)
  )
;; ---hijack-speech-info-flag


;; DECOMP BEGINS

(define *cty-hijack-speech-list* (new 'static 'inline-array talker-speech-class 52
                                   (new 'static 'talker-speech-class :name "none")
                                   (new 'static 'talker-speech-class
                                     :name "dax372"
                                     :channel (gui-channel daxter)
                                     :speech #x1
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax373"
                                     :channel (gui-channel daxter)
                                     :flags (talker-flags tf0)
                                     :speech #x2
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax374"
                                     :channel (gui-channel daxter)
                                     :speech #x3
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax375"
                                     :channel (gui-channel daxter)
                                     :speech #x4
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax376"
                                     :channel (gui-channel daxter)
                                     :speech #x5
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax377"
                                     :channel (gui-channel daxter)
                                     :speech #x6
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax378"
                                     :channel (gui-channel daxter)
                                     :speech #x7
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax379"
                                     :channel (gui-channel daxter)
                                     :speech #x8
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax380"
                                     :channel (gui-channel daxter)
                                     :speech #x9
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax381"
                                     :channel (gui-channel daxter)
                                     :flags (talker-flags tf0)
                                     :speech #xa
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax382"
                                     :channel (gui-channel daxter)
                                     :speech #xb
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax383"
                                     :channel (gui-channel daxter)
                                     :speech #xc
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax384"
                                     :channel (gui-channel daxter)
                                     :speech #xd
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax385"
                                     :channel (gui-channel daxter)
                                     :speech #xe
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax386"
                                     :channel (gui-channel daxter)
                                     :speech #xf
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax387"
                                     :channel (gui-channel daxter)
                                     :speech #x10
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax388"
                                     :channel (gui-channel daxter)
                                     :speech #x11
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax389"
                                     :channel (gui-channel daxter)
                                     :speech #x12
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax390"
                                     :channel (gui-channel daxter)
                                     :speech #x13
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax391"
                                     :channel (gui-channel daxter)
                                     :speech #x14
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax392"
                                     :channel (gui-channel daxter)
                                     :speech #x15
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax393"
                                     :channel (gui-channel daxter)
                                     :speech #x16
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax394"
                                     :channel (gui-channel daxter)
                                     :speech #x17
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "dax395"
                                     :channel (gui-channel daxter)
                                     :speech #x18
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak101"
                                     :channel (gui-channel jak)
                                     :speech #x19
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak102"
                                     :channel (gui-channel jak)
                                     :speech #x1a
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak103"
                                     :channel (gui-channel jak)
                                     :flags (talker-flags tf0)
                                     :speech #x1b
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak104"
                                     :channel (gui-channel jak)
                                     :speech #x1c
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak105"
                                     :channel (gui-channel jak)
                                     :speech #x1d
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak106"
                                     :channel (gui-channel jak)
                                     :speech #x1e
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak107"
                                     :channel (gui-channel jak)
                                     :flags (talker-flags tf0)
                                     :speech #x1f
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak108"
                                     :channel (gui-channel jak)
                                     :speech #x20
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak109"
                                     :channel (gui-channel jak)
                                     :speech #x21
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak110"
                                     :channel (gui-channel jak)
                                     :flags (talker-flags tf0)
                                     :speech #x22
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak111"
                                     :channel (gui-channel jak)
                                     :speech #x23
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "jak112"
                                     :channel (gui-channel jak)
                                     :flags (talker-flags tf0)
                                     :speech #x24
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn149"
                                     :channel (gui-channel voicebox)
                                     :flags (talker-flags tf0)
                                     :speech #x25
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn150"
                                     :channel (gui-channel voicebox)
                                     :speech #x26
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn151"
                                     :channel (gui-channel voicebox)
                                     :speech #x27
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn152"
                                     :channel (gui-channel voicebox)
                                     :speech #x28
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn153"
                                     :channel (gui-channel voicebox)
                                     :flags (talker-flags tf0)
                                     :speech #x29
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn154"
                                     :channel (gui-channel voicebox)
                                     :speech #x2a
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn155"
                                     :channel (gui-channel voicebox)
                                     :speech #x2b
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn156"
                                     :channel (gui-channel voicebox)
                                     :speech #x2c
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn157"
                                     :channel (gui-channel voicebox)
                                     :speech #x2d
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn158"
                                     :channel (gui-channel voicebox)
                                     :speech #x2e
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn159"
                                     :channel (gui-channel voicebox)
                                     :speech #x2f
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn160"
                                     :channel (gui-channel voicebox)
                                     :speech #x30
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn161"
                                     :channel (gui-channel voicebox)
                                     :speech #x31
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn162"
                                     :channel (gui-channel voicebox)
                                     :speech #x32
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   (new 'static 'talker-speech-class
                                     :name "torn163"
                                     :channel (gui-channel voicebox)
                                     :speech #x33
                                     :neg #x1
                                     :on-close #f
                                     :camera #f
                                     )
                                   )
        )

(deftype cty-hijack-manager (task-manager)
  ((hpickup                      handle)
   (missiles                     (array handle))
   (current-leader-missile       int8)
   (task-arrow                   handle)
   (alert-expire-time            time-frame)
   (lure-hit-time                time-frame  :offset 280)
   (naughty-ottsel-lure          handle)
   (missile-sound                sound-id)
   (vehicle-is-visible?          symbol)
   (last-check-vehicle-vis-time  time-frame)
   )
  (:state-methods
    player-riding
    decoy-stage
    show-missile-launch
    )
  (:methods
    (cty-hijack-manager-method-35 (_type_) none)
    (spawn-missile (_type_ vector quaternion int) handle)
    (spawn-missiles-from-launcher (_type_ int) none)
    (guide-arrow-spawn (_type_) symbol)
    (cty-hijack-manager-method-39 (_type_ int) none)
    (reset-hijack-speech (_type_) symbol)
    )
  )


(defstate fail (cty-hijack-manager)
  :virtual #t
  :enter (behavior ((arg0 resetter-params))
    (sound-stop (-> self missile-sound))
    (let* ((t9-1 find-parent-method)
           (a0-2 cty-hijack-manager)
           (t9-2 (-> (the-as (state resetter-params cty-hijack-manager) (t9-1 a0-2 18)) enter))
           )
      (if t9-2
          (t9-2 (the-as resetter-params a0-2))
          )
      )
    )
  )

(define *pickup-start-pos* (new 'static 'vector :x 3964271.5 :y 43008.0 :z 2372759.5 :w 1.0))

(define *pickup-start-angle* 16384.0)

(deftype hijack-speech-instance (speech-instance)
  ()
  )


(deftype hijack-speech-info (structure)
  ((speeches   (array hijack-speech-instance))
   (flags      hijack-speech-info-flag)
   (play-time  time-frame)
   )
  )


(defpartgroup group-lure-sirens
  :id 1433
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 4715 :flags (sp6 sp7)))
  )

(defpartgroup group-lure-sirens-dim
  :id 1434
  :flags (sp0 sp4)
  :bounds (static-bspherem 0 0 0 20)
  :parts ((sp-item 4716 :flags (sp6 sp7)))
  )

(defpart 4716
  :init-specs ((:texture (glow level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 8))
    (:rot-x (degrees 6.7500005))
    (:scale-y :copy scale-x)
    (:r 0.0)
    (:g 32.0)
    (:b 128.0)
    (:a 128.0)
    (:omega (degrees 18011.25))
    (:timer (seconds 0.017))
    (:flags (glow))
    (:userdata 409.6)
    )
  )

(defpart 4715
  :init-specs ((:texture (glow level-default-sprite))
    (:num 1.0)
    (:scale-x (meters 8))
    (:rot-x (degrees 6.7500005))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 80.0)
    (:b 0.0)
    (:a 255.0)
    (:omega (degrees 18011.25))
    (:timer (seconds 0.017))
    (:flags (glow))
    (:userdata 409.6)
    )
  )

(define *hijack-speech* (new 'static 'boxed-array :type hijack-speech-info
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x1f :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x3 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0 hsi3)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x2 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x23 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0 hsi3)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x1b :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x20 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x1a :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x1 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x6 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x7 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x4 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0 hsi3)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x25 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x5 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x27 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0 hsi3)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x22 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x8 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x9 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #xa :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x29 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi2)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #xb :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x2d :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi2)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #xc :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x2e :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #xe :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #xf :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x2a :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi2)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #xd :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x2b :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x28 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x2f :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x31 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi2)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x13 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x14 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x15 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x16 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x17 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x18 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x1e :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x1c :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi2)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x2c :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x10 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x11 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x32 :probability 1.0)
                              (new 'static 'hijack-speech-instance :speech #x7 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi2)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x12 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          (new 'static 'hijack-speech-info
                            :speeches (new 'static 'boxed-array :type hijack-speech-instance
                              (new 'static 'hijack-speech-instance :speech #x33 :probability 1.0)
                              )
                            :flags (hijack-speech-info-flag hsi0)
                            )
                          )
        )

(defmethod reset-hijack-speech ((this cty-hijack-manager))
  (dotimes (v1-0 (-> *hijack-speech* length))
    (logclear! (-> *hijack-speech* v1-0 flags) (hijack-speech-info-flag hsi4))
    (set! (-> *hijack-speech* v1-0 play-time) 0)
    )
  #f
  )

(defun debug-reset-hijack-speech ()
  (dotimes (v1-0 (-> *hijack-speech* length))
    (logclear! (-> *hijack-speech* v1-0 flags) (hijack-speech-info-flag hsi4 hsi5))
    (set! (-> *hijack-speech* 0 play-time) 0)
    )
  #f
  )

;; WARN: Function (method 39 cty-hijack-manager) has a return type of none, but the expression builder found a return statement.
(defmethod cty-hijack-manager-method-39 ((this cty-hijack-manager) (arg0 int))
  (let ((s4-0 (-> *hijack-speech* arg0))
        (v1-2 #xf4240)
        (a1-1 0)
        (s5-0 #f)
        )
    (if (and (logtest? (-> s4-0 flags) (hijack-speech-info-flag hsi0))
             (logtest? (-> s4-0 flags) (hijack-speech-info-flag hsi4))
             )
        (return 0)
        )
    (when (and (logtest? (-> s4-0 flags) (hijack-speech-info-flag hsi3))
               (logtest? (-> s4-0 flags) (hijack-speech-info-flag hsi5))
               )
      (set! s5-0 #t)
      (set! s4-0 (-> *hijack-speech* (+ arg0 1)))
      )
    (if (and (logtest? (-> s4-0 flags) (hijack-speech-info-flag hsi0))
             (logtest? (-> s4-0 flags) (hijack-speech-info-flag hsi4))
             )
        (return 0)
        )
    (dotimes (a0-21 (-> s4-0 speeches length))
      (set! v1-2 (min (-> s4-0 speeches a0-21 num-play-times) v1-2))
      )
    (dotimes (a0-24 (-> s4-0 speeches length))
      (if (< v1-2 (-> s4-0 speeches a0-24 num-play-times))
          (set! a1-1 (logior a1-1 (ash 1 a0-24)))
          )
      )
    (let ((s3-0 (rand-vu-int-count-excluding (-> s4-0 speeches length) a1-1)))
      (logior! (-> s4-0 flags) (hijack-speech-info-flag hsi4 hsi5))
      (talker-spawn-func
        (-> *cty-hijack-speech-list* (-> s4-0 speeches s3-0 speech))
        *entity-pool*
        (target-pos 0)
        (the-as region #f)
        )
      (+! (-> s4-0 speeches s3-0 num-play-times) 1)
      )
    (set-time! (-> s4-0 play-time))
    (if s5-0
        (set-time! (-> *hijack-speech* arg0 play-time))
        )
    )
  (none)
  )

(deftype cty-missile-lure-init-params (structure)
  ((pos                 vector      :inline)
   (orient              quaternion  :inline)
   (is-naughty-ottsel?  symbol)
   )
  )


(deftype cty-missile-lure (process-focusable)
  ((minimap             connection-minimap  :offset 216)
   (is-naughty-ottsel?  symbol)
   (lock-open?          symbol)
   (hum-sound           sound-id)
   (sirens2             sparticle-launch-control)
   (raise-sound         sound-id)
   )
  (:state-methods
    idle
    active
    complete
    closing
    opening
    naughty-ottsel-wait
    naughty-ottsel-lure
    )
  (:methods
    (go-idle (_type_) object)
    (find-and-lure-missiles (_type_) symbol)
    )
  )


(defskelgroup skel-cty-missile-lure cty-decoy cty-decoy-lod0-jg cty-decoy-idle-ja
              ((cty-decoy-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 12.5)
              )

(defmethod get-trans ((this cty-missile-lure) (arg0 int))
  "Get the `trans` for this process."
  (cond
    ((= arg0 3)
     (let ((gp-1 (new 'static 'vector)))
       (if (-> this is-naughty-ottsel?)
           (set! (-> gp-1 quad) (-> this root trans quad))
           (vector<-cspace! gp-1 (-> this node-list data 16))
           )
       gp-1
       )
     )
    (else
      (call-parent-method this arg0)
      )
    )
  )

(defbehavior cty-missile-lure-init-by-other cty-missile-lure ((arg0 cty-missile-lure-init-params))
  (stack-size-set! (-> self main-thread) 256)
  (logclear! (-> self mask) (process-mask actor-pause))
  (logior! (-> self mask) (process-mask enemy))
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 7) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 8))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 4)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-21 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> v1-21 prim-core action) (collide-action solid))
      (set! (-> v1-21 transform-index) 5)
      (set-vector! (-> v1-21 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-23 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> v1-23 prim-core action) (collide-action solid))
      (set! (-> v1-23 transform-index) 6)
      (set-vector! (-> v1-23 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-25 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-25 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-25 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> v1-25 prim-core action) (collide-action solid))
      (set! (-> v1-25 transform-index) 7)
      (set-vector! (-> v1-25 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-27 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-27 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-27 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> v1-27 prim-core action) (collide-action solid))
      (set! (-> v1-27 transform-index) 8)
      (set-vector! (-> v1-27 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-29 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-29 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-29 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list projectile tobot)
            )
      (set! (-> v1-29 prim-core action) (collide-action solid))
      (set! (-> v1-29 transform-index) 9)
      (set-vector! (-> v1-29 local-sphere) 0.0 0.0 0.0 40960.0)
      )
    (let ((v1-31 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-31 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-31 prim-core collide-with)
            (collide-spec jak vehicle-sphere hit-by-others-list player-list tobot)
            )
      (set! (-> v1-31 prim-core action) (collide-action solid))
      (set! (-> v1-31 transform-index) 3)
      (set-vector! (-> v1-31 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-34 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-34 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-34 prim-core collide-with))
      )
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> self root) s5-0)
    )
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-missile-lure" (the-as (pointer level) #f)))
    (the-as pair 0)
    )
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (quaternion-copy! (-> self root quat) (-> arg0 orient))
  (set-vector! (-> self root scale) 3.0 3.0 3.0 1.0)
  (set! (-> self is-naughty-ottsel?) (-> arg0 is-naughty-ottsel?))
  (set! (-> self lock-open?) #f)
  (go-idle self)
  )

(defstate naughty-ottsel-lure (cty-missile-lure)
  :virtual #t
  :enter (behavior ()
    (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 12) (the-as int #f) (the-as vector #t) 0))
    )
  :trans (behavior ()
    (when (< (vector-vector-xz-distance (-> self root trans) (target-pos 0)) 491520.0)
      (send-event (ppointer->process (-> self parent)) 'complete)
      (go-virtual complete)
      )
    )
  :code sleep-code
  )

(defstate naughty-ottsel-wait (cty-missile-lure)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('wake-up)
       (go-virtual naughty-ottsel-lure)
       )
      )
    )
  :code sleep-code
  )

(defstate idle (cty-missile-lure)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (send-event (ppointer->process (-> self parent)) 'lure-hit)
       (go-virtual opening)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self minimap) (add-icon! *minimap* self (the-as uint 12) (the-as int #f) (the-as vector #t) 0))
    )
  :trans (behavior ()
    (spawn-from-cspace (-> self sirens2) (-> self node-list data 17))
    (spawn-from-cspace (-> self sirens2) (-> self node-list data 18))
    (spawn-from-cspace (-> self sirens2) (-> self node-list data 19))
    )
  :code transform-and-sleep-code
  :post transform-post
  )

(defmethod deactivate ((this cty-missile-lure))
  "Make a process dead, clean it up, remove it from the active pool, and return to dead pool."
  (if (nonzero? (-> this sirens2))
      (kill-particles (-> this sirens2))
      )
  (call-parent-method this)
  (none)
  )

(defmethod relocate ((this cty-missile-lure) (offset int))
  (if (nonzero? (-> this sirens2))
      (&+! (-> this sirens2) offset)
      )
  (call-parent-method this offset)
  )

(defmethod go-idle ((this cty-missile-lure))
  (set! (-> this hum-sound) (new-sound-id))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1433) this))
  (set! (-> this sirens2) (create-launch-control (-> *part-group-id-table* 1434) this))
  (set! (-> this raise-sound) (new-sound-id))
  (cond
    ((-> this is-naughty-ottsel?)
     (logior! (-> this draw status) (draw-control-status no-draw))
     (go (method-of-object this naughty-ottsel-wait))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  )

(defmethod find-and-lure-missiles ((this cty-missile-lure))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> this root trans quad))
    (set! (-> v1-0 w) 327680.0)
    )
  (when #f
    (let ((v1-3 (-> *collide-player-list* alive-list next0)))
      *collide-player-list*
      (let ((gp-0 (-> v1-3 next0)))
        (while (!= v1-3 (-> *collide-player-list* alive-list-end))
          (let ((v1-4 (the-as collide-shape (-> (the-as connection v1-3) param1))))
            (when (logtest? (-> v1-4 root-prim prim-core collide-as) (collide-spec enemy hit-by-others-list))
              (let* ((s5-0 (-> v1-4 process))
                     (a0-12 (if (type? s5-0 process-focusable)
                                s5-0
                                )
                            )
                     )
                (if (= (-> a0-12 type) cty-hijack-missile)
                    (send-event a0-12 'lure)
                    )
                )
              )
            )
          (set! v1-3 gp-0)
          *collide-player-list*
          (set! gp-0 (-> gp-0 next0))
          )
        )
      )
    )
  (when #t
    (when #f
      (let ((v1-15 (-> *collide-hit-by-player-list* alive-list next0)))
        *collide-hit-by-player-list*
        (let ((gp-1 (-> v1-15 next0)))
          (while (!= v1-15 (-> *collide-hit-by-player-list* alive-list-end))
            (let ((v1-16 (the-as collide-shape (-> (the-as connection v1-15) param1))))
              (when (logtest? (-> v1-16 root-prim prim-core collide-as) (collide-spec enemy hit-by-others-list))
                (let* ((s5-1 (-> v1-16 process))
                       (a0-24 (if (type? s5-1 process-focusable)
                                  s5-1
                                  )
                              )
                       )
                  (if (= (-> a0-24 type) cty-hijack-missile)
                      (send-event a0-24 'lure)
                      )
                  )
                )
              )
            (set! v1-15 gp-1)
            *collide-hit-by-player-list*
            (set! gp-1 (-> gp-1 next0))
            )
          )
        )
      )
    (when #t
      (let ((v1-26 (-> *collide-hit-by-others-list* alive-list next0)))
        *collide-hit-by-others-list*
        (let ((gp-2 (-> v1-26 next0)))
          (while (!= v1-26 (-> *collide-hit-by-others-list* alive-list-end))
            (let ((v1-27 (the-as collide-shape (-> (the-as connection v1-26) param1))))
              (when (logtest? (-> v1-27 root-prim prim-core collide-as) (collide-spec enemy hit-by-others-list))
                (let* ((s5-2 (-> v1-27 process))
                       (a0-36 (if (type? s5-2 process-focusable)
                                  s5-2
                                  )
                              )
                       )
                  (if (= (-> a0-36 type) cty-hijack-missile)
                      (send-event a0-36 'lure)
                      )
                  )
                )
              )
            (set! v1-26 gp-2)
            *collide-hit-by-others-list*
            (set! gp-2 (-> gp-2 next0))
            )
          )
        )
      #f
      )
    )
  )

(defstate complete (cty-missile-lure)
  :virtual #t
  :enter (behavior ()
    (sound-stop (-> self hum-sound))
    (if (not (-> self is-naughty-ottsel?))
        (sound-play "decoy-explode" :position (-> self root trans))
        )
    (sound-stop (-> self raise-sound))
    (kill-callback (-> *minimap* engine) (-> self minimap))
    )
  :code nothing
  )

(defstate opening (cty-missile-lure)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('missile-hit)
       (go-virtual complete)
       )
      (('missile-attract)
       (set! (-> self lock-open?) #t)
       (send-event (ppointer->process (-> self parent)) 'missile-attract)
       )
      )
    )
  :enter (behavior ()
    (sound-play "decoy-activate" :id (-> self raise-sound) :position (-> self root trans))
    )
  :exit (behavior ()
    (sound-stop (-> self raise-sound))
    )
  :trans (behavior ()
    (spawn-from-cspace (-> self part) (-> self node-list data 17))
    (spawn-from-cspace (-> self part) (-> self node-list data 18))
    (spawn-from-cspace (-> self part) (-> self node-list data 19))
    (find-and-lure-missiles self)
    )
  :code (behavior ()
    (sound-play "hj-decoy-lights" :id (-> self hum-sound))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! max 2.0) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((f0-6 (/ (ja-frame-num 0) (the float (ja-num-frames 0)))))
        (vector-lerp!
          (-> self draw color-emissive)
          (new 'static 'vector :w 1.0)
          (new 'static 'vector :x 0.5 :w 1.0)
          f0-6
          )
        )
      (set! (-> self draw color-emissive w) 0.0)
      (suspend)
      (ja :num! (seek! max 2.0))
      )
    (go-virtual active)
    )
  :post transform-post
  )

(defstate closing (cty-missile-lure)
  :virtual #t
  :enter (behavior ()
    (send-event (ppointer->process (-> self parent)) 'lure-lower)
    (sound-stop (-> self hum-sound))
    )
  :trans (behavior ()
    (spawn-from-cspace (-> self sirens2) (-> self node-list data 17))
    (spawn-from-cspace (-> self sirens2) (-> self node-list data 18))
    (spawn-from-cspace (-> self sirens2) (-> self node-list data 19))
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! 0.0 2.0) :frame-num max)
    (until (ja-done? 0)
      (let ((f0-6 (/ (ja-frame-num 0) (the float (ja-num-frames 0)))))
        (vector-lerp!
          (-> self draw color-emissive)
          (new 'static 'vector :w 1.0)
          (new 'static 'vector :x 0.5 :w 1.0)
          f0-6
          )
        )
      (set! (-> self draw color-emissive w) 0.0)
      (ja :num! (seek! 0.0))
      (suspend)
      )
    (go-virtual idle)
    )
  :post transform-post
  )

(defstate active (cty-missile-lure)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('missile-hit)
       (go-virtual complete)
       )
      (('missile-attract)
       (send-event (ppointer->process (-> self parent)) 'missile-attract)
       (let ((v0-0 (the-as object #t)))
         (set! (-> self lock-open?) (the-as symbol v0-0))
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (sound-play "hj-decoy-lights" :id (-> self hum-sound))
    (let* ((f0-0 0.5)
           (f1-1 (+ 0.5 (* 0.0033333334 (the float (- (current-time) (-> self state-time))))))
           (f0-1 (* f0-0 (- f1-1 (* (the float (the int (/ f1-1 2.0))) 2.0))))
           )
      0.0
      (let* ((f0-3 (sin (* 65536.0 f0-1)))
             (f0-4 (* 0.125 f0-3))
             )
        (set! (-> self draw color-emissive x) (+ 0.375 f0-4))
        )
      )
    (spawn-from-cspace (-> self part) (-> self node-list data 17))
    (spawn-from-cspace (-> self part) (-> self node-list data 18))
    (spawn-from-cspace (-> self part) (-> self node-list data 19))
    (find-and-lure-missiles self)
    (if (and (not (-> self lock-open?))
             (not (-> self is-naughty-ottsel?))
             (time-elapsed? (-> self state-time) (seconds 6))
             (>= (the-as uint 3)
                 (-> *game-info* sub-task-list (game-task-node city-hijack-vehicle-resolution) death-count)
                 )
             )
        (go-virtual closing)
        )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post transform-post
  )

(deftype cty-lure-info (structure)
  ((pos  vector  :inline)
   )
  )


(define *cty-hijack-lure-positions*
  (new 'static 'boxed-array :type cty-lure-info
    (new 'static 'cty-lure-info :pos (new 'static 'vector :x 1963376.6 :y 6144.0 :z 6455214.0 :w 1.0))
    (new 'static 'cty-lure-info :pos (new 'static 'vector :x 668016.6 :y 6144.0 :z 7583047.5 :w 1.0))
    (new 'static 'cty-lure-info :pos (new 'static 'vector :x -318054.4 :y 6144.0 :z 7174676.5 :w 1.0))
    (new 'static 'cty-lure-info :pos (new 'static 'vector :x -174694.4 :y 6144.0 :z 6374564.0 :w 1.0))
    (new 'static 'cty-lure-info :pos (new 'static 'vector :x 764354.56 :y 6144.0 :z 5801574.5 :w 1.0))
    (new 'static 'cty-lure-info :pos (new 'static 'vector :x 1914757.1 :y 6144.0 :z 5914255.5 :w 1.0))
    )
  )

(define *naughty-ottsel-pos* (new 'static 'vector :x -271073.28 :y 121978.88 :z 5468487.5 :w 1.0))

(define *ctyport-hijack-fail*
  (new 'static 'resetter-params
    :flags (resetter-flag auto-reset text-message)
    :fail (new 'static 'resetter-spec :continue "ctyindb-hijack-vehicle" :reset-mode 'life :execute #f)
    :retry (new 'static 'resetter-spec :continue #f :reset-mode 'try :execute #f)
    :reset-delay (seconds 3)
    )
  )

(defmethod relocate ((this cty-hijack-manager) (offset int))
  (if (nonzero? (-> this missiles))
      (&+! (-> this missiles) offset)
      )
  (call-parent-method this offset)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod init! ((this cty-hijack-manager))
  (call-parent-method this)
  (set! (-> this missile-sound) (new-sound-id))
  (set-setting! 'city-sound '(hijack1) 0.0 2)
  (set! (-> this hud-timer) (the-as handle #f))
  (set! (-> this missiles) (new 'process 'boxed-array handle (+ (-> *cty-hijack-lure-positions* length) 1)))
  (set! (-> this missiles length) 0)
  (set! (-> this current-leader-missile) 0)
  (set! (-> this task-arrow) (the-as handle #f))
  (reset-hijack-speech this)
  (dotimes (v1-8 (-> this missiles allocated-length))
    (set! (-> this missiles v1-8) (the-as handle #f))
    )
  (none)
  )

(defstate wait (cty-hijack-manager)
  :virtual #t
  :code (behavior ()
    (while (or (not *target*)
               (not *spawn-actors*)
               (and (task-node-closed? (game-task-node city-hijack-vehicle-escape)) (zero? (-> *target* pilot)))
               )
      (suspend)
      )
    (set-time-limit self)
    (cond
      ((task-node-closed? (game-task-node city-hijack-vehicle-escape))
       (if (nonzero? (-> *target* pilot))
           (set! (-> self hpickup) (-> *target* pilot vehicle))
           )
       (adjust-player-ammo 200.0 (pickup-type ammo-yellow))
       (dotimes (gp-0 (-> self missiles allocated-length))
         (spawn-missile self (target-pos 0) (quaternion-identity! (new 'stack-no-clear 'quaternion)) gp-0)
         )
       (set! (-> self missiles length) (-> self missiles allocated-length))
       (go-virtual player-riding)
       )
      (else
        (go-virtual active)
        )
      )
    )
  )

(defmethod task-manager-method-25 ((this cty-hijack-manager))
  (when (nonzero? (-> this hpickup))
    (send-event (handle->process (-> this hpickup)) 'override-camera #f)
    (let ((a0-7 (handle->process (-> this hpickup))))
      (if a0-7
          (deactivate a0-7)
          )
      )
    )
  (let ((a0-11 (handle->process (-> this hud-timer))))
    (if a0-11
        (deactivate a0-11)
        )
    )
  (call-parent-method this)
  (none)
  )

(define *pre-hijack-kg-squad-member-settings* (new 'static 'kg-squad-member-settings
                                                :object-type (traffic-type roboguard)
                                                :max-target-count #x7f
                                                :enemy-type (traffic-type guard-a)
                                                )
        )

(defstate active (cty-hijack-manager)
  :virtual #t
  :enter (behavior ()
    (set! (-> self vehicle-is-visible?) #f)
    (let ((t9-1 (-> (find-parent-state) enter)))
      (if t9-1
          (t9-1)
          )
      )
    (task-node-close! (game-task-node city-vehicle-training-hover-zone-1) 'event)
    (set-setting! 'kg-difficulty #f 1.5 0)
    (set-setting! 'exclusive-load '((ignore lctyhijk)) 0.0 0)
    (let ((gp-0 (new 'stack 'traffic-object-spawn-params)))
      (set! (-> gp-0 flags) (traffic-spawn-flags))
      (set! (-> gp-0 position quad) (-> *pickup-start-pos* quad))
      (quaternion-identity! (-> gp-0 rotation))
      (quaternion-rotate-y! (-> gp-0 rotation) (-> gp-0 rotation) *pickup-start-angle*)
      (set! (-> gp-0 velocity quad) (the-as uint128 0))
      (set! (-> gp-0 behavior) (the-as uint 0))
      (let ((s5-0 (get-process *default-dead-pool* h-kg-pickup #x4000 1)))
        (set! (-> self hpickup)
              (process->handle
                (-> (when s5-0
                      (let ((t9-9 (method-of-type h-kg-pickup activate)))
                        (t9-9 (the-as h-kg-pickup s5-0) *vehicle-manager* "pickup" (the-as pointer #x70004000))
                        )
                      (run-now-in-process s5-0 vehicle-init-by-other 11 gp-0)
                      (-> s5-0 ppointer)
                      )
                    0
                    )
                )
              )
        )
      )
    (let ((gp-1 (new 'stack-no-clear 'task-arrow-params)))
      (set! (-> gp-1 pos quad) (-> *pickup-start-pos* quad))
      (quaternion-identity! (-> gp-1 quat))
      (set! (-> gp-1 flags) (task-arrow-flags taf8))
      (set! (-> gp-1 map-icon) (the-as uint 12))
      (logior! (-> gp-1 flags) (task-arrow-flags taf3))
      (set! (-> self task-arrow) (process->handle (task-arrow-spawn gp-1 self)))
      )
    )
  :trans (behavior ()
    (local-vars (gp-1 symbol))
    (when (not (-> self vehicle-is-visible?))
      (let* ((s5-0 (handle->process (-> self hpickup)))
             (gp-0 (if (type? s5-0 process-focusable)
                       (the-as process-focusable s5-0)
                       )
                   )
             )
        (when gp-0
          (when (logtest? (-> gp-0 draw status) (draw-control-status on-screen))
            (when (time-elapsed? (-> self last-check-vehicle-vis-time) (seconds 0.5))
              (set-time! (-> self last-check-vehicle-vis-time))
              (let ((s5-1 (new 'stack-no-clear 'collide-query)))
                (set! (-> s5-1 start-pos quad) (-> (target-pos 0) quad))
                (vector-! (-> s5-1 move-dist) (get-trans gp-0 0) (-> s5-1 start-pos))
                (let ((v1-20 s5-1))
                  (set! (-> v1-20 radius) 40.96)
                  (set! (-> v1-20 collide-with) (collide-spec backgnd))
                  (set! (-> v1-20 ignore-process0) #f)
                  (set! (-> v1-20 ignore-process1) #f)
                  (set! (-> v1-20 ignore-pat)
                        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1 :board #x1)
                        )
                  (set! (-> v1-20 action-mask) (collide-action solid))
                  )
                (if (= (fill-and-probe-using-line-sphere *collide-cache* s5-1) -100000000.0)
                    (set! (-> self vehicle-is-visible?) #t)
                    )
                )
              )
            )
          )
        )
      )
    (if (or (not (handle->process (-> self hpickup)))
            (begin
              (let* ((gp-2 #t)
                     (s5-2 (handle->process (-> self hpickup)))
                     (v1-34 (the-as focus-status (logand (-> (the-as process-focusable (if (type? s5-2 process-focusable)
                                                                                           (the-as process-focusable s5-2)
                                                                                           )
                                                                     )
                                                             focus-status
                                                             )
                                                         (focus-status dead)
                                                         )
                                    )
                            )
                     )
                (cmove-#f-zero gp-1 v1-34 gp-2)
                )
              gp-1
              )
            )
        (send-event self 'fail)
        )
    (let* ((s5-3 (handle->process (-> self hpickup)))
           (gp-3 (if (type? s5-3 process-focusable)
                     (the-as process-focusable s5-3)
                     )
                 )
           )
      (cond
        ((and gp-3 (and (< 184320.0 (vector-vector-xz-distance (target-pos 0) (get-trans gp-3 0)))
                        (> (get-alert-level1 *kg-squad-control*) 0)
                        )
              )
         )
        (else
          (when (and (logtest? (-> gp-3 draw status) (draw-control-status on-screen)) (-> self vehicle-is-visible?))
            (cty-hijack-manager-method-39 self 0)
            (task-node-close! (game-task-node city-hijack-vehicle-infiltrate) 'event)
            )
          (set-time! (-> self alert-expire-time))
          )
        )
      )
    (when (and *target* (focus-test? *target* pilot-riding) (let ((gp-4 type?))
                                                              (gp-4 (send-event *target* 'get-vehicle) h-kg-pickup)
                                                              )
               )
      (task-node-close! (game-task-node city-hijack-vehicle-infiltrate) 'event)
      (go-virtual show-missile-launch)
      )
    (let ((t9-18 (-> (find-parent-state) trans)))
      (if t9-18
          (t9-18)
          )
      )
    )
  )

(define *post-hijack-kg-squad-member-settings* (new 'static 'kg-squad-member-settings
                                                 :object-type (traffic-type roboguard)
                                                 :max-target-count #x7f
                                                 :target-count 7
                                                 :enemy-type (traffic-type guard-a)
                                                 )
        )

(defstate decoy-stage (cty-hijack-manager)
  :virtual #t
  :parent (cty-hijack-manager active)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-4 object))
    (case message
      (('complete)
       (send-event (handle->process (-> self missiles (-> self current-leader-missile))) 'die)
       (deactivate (handle->process (-> self missiles (-> self current-leader-missile))))
       (set-blackout-frames (seconds 0.3))
       (send-event (handle->process (-> self hpickup)) 'die)
       (task-manager-event-handler proc argc message block)
       )
      (('missile-attract)
       (cond
         ((< (-> self current-leader-missile) 1)
          (cty-hijack-manager-method-39 self 13)
          )
         (else
           (set! v0-4 (+ (current-time) (seconds -2)))
           (set! (-> *hijack-speech* 13 play-time) (the-as time-frame v0-4))
           v0-4
           )
         )
       )
      (('lure-hit)
       (set! v0-4 (current-time))
       (set! (-> self lure-hit-time) (the-as time-frame v0-4))
       v0-4
       )
      (('lure-lower)
       (cty-hijack-manager-method-39 self 12)
       )
      (('wrong-way)
       (send-event self 'fail)
       )
      (('missile-die)
       (+! (-> self current-leader-missile) 1)
       (send-event (handle->process (-> self missiles (-> self current-leader-missile))) 'set-leader)
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-setting! 'disable-guard-chatter? #t 0.0 0)
    (set-time! (-> self state-time))
    (set! (-> self hud-timer)
          (ppointer->handle (process-spawn hud-timer :init hud-init-by-other :name "hud-timer" :to self))
          )
    (set-alert-level1 *kg-squad-control* 1)
    (cty-hijack-manager-method-39 self 9)
    (set-setting! 'music 'hijack 0.0 0)
    (send-event *target* 'change-mode 'gun #f (pickup-type gun-yellow-1))
    (auto-save-user)
    )
  :trans (behavior ()
    (local-vars (gp-1 symbol))
    ((-> (method-of-type task-manager active) trans))
    (let ((v1-6 (handle->process (-> self missiles (-> self current-leader-missile)))))
      (if v1-6
          (sound-play
            "hj-missile"
            :id (-> self missile-sound)
            :position (-> (the-as process-focusable v1-6) root trans)
            )
          )
      )
    (dotimes (gp-0 (-> self missiles length))
      (send-event (handle->process (-> self missiles gp-0)) 'chase-2)
      )
    (if (not (time-elapsed? (-> self state-time) (seconds 0.1)))
        (send-event (handle->process (-> self hpickup)) 'boost)
        )
    (send-event (handle->process (-> self hpickup)) 'override-camera #t)
    (set-setting! 'string-min-length 'abs (meters 18) 0)
    (set-setting! 'string-max-length 'abs (meters 19) 0)
    (set-setting! 'string-min-height 'abs (meters 6) 0)
    (set-setting! 'string-max-height 'abs (meters 6) 0)
    (if (time-elapsed? (-> self state-time) (seconds 6))
        (cty-hijack-manager-method-39 self 11)
        )
    (when (and (> (-> *hijack-speech* 13 play-time) 0) (time-elapsed? (-> *hijack-speech* 13 play-time) (seconds 3)))
      (set! (-> *hijack-speech* 13 play-time) 0)
      (cond
        ((>= 1 (-> self current-leader-missile))
         (cty-hijack-manager-method-39 self 14)
         )
        ((= (-> self current-leader-missile) (+ (-> self missiles length) -1))
         (cty-hijack-manager-method-39 self 19)
         )
        (else
          (cty-hijack-manager-method-39 self 15)
          )
        )
      )
    (when (and (> (-> *hijack-speech* 19 play-time) 0) (time-elapsed? (-> *hijack-speech* 19 play-time) (seconds 3)))
      (send-event (handle->process (-> self naughty-ottsel-lure)) 'wake-up)
      (cty-hijack-manager-method-39 self 20)
      )
    (when (and (and (> (-> *hijack-speech* 14 play-time) 0) (time-elapsed? (-> *hijack-speech* 14 play-time) (seconds 10)))
               (and (not (logtest? (-> *hijack-speech* 19 flags) (hijack-speech-info-flag hsi4)))
                    (and (or (and (> (-> *hijack-speech* 15 play-time) 0) (time-elapsed? (-> *hijack-speech* 15 play-time) (seconds 10)))
                             (not (logtest? (-> *hijack-speech* 15 flags) (hijack-speech-info-flag hsi4)))
                             )
                         (time-elapsed? (-> self lure-hit-time) (seconds 8))
                         )
                    )
               )
      (set! (-> *hijack-speech* 14 play-time) 0)
      (set! (-> *hijack-speech* 15 play-time) 0)
      (cty-hijack-manager-method-39 self 16)
      )
    (if (and *target*
             (time-elapsed? (-> self state-time) (seconds 5))
             (and (< (vector-length (get-transv *target*)) 221184.0)
                  (or (and (> (-> *hijack-speech* 17 play-time) 0) (time-elapsed? (-> *hijack-speech* 17 play-time) (seconds 4)))
                      (not (logtest? (-> *hijack-speech* 17 flags) (hijack-speech-info-flag hsi4)))
                      )
                  )
             )
        (cty-hijack-manager-method-39 self 17)
        )
    (let ((v1-141 #x6978))
      (let ((a0-80 (-> *game-info* sub-task-list (game-task-node city-hijack-vehicle-resolution) death-count)))
        (when (< (the-as uint 2) a0-80)
          (let ((a0-83 (+ v1-141 (* 4500 (the-as int (+ a0-80 -1))))))
            (set! v1-141 (min #x1a5e0 a0-83))
            )
          )
        )
      (set! (-> *game-info* timer)
            (the-as time-frame (- (the-as time-frame v1-141) (- (current-time) (-> self state-time))))
            )
      )
    (if (< (-> *game-info* timer) 0)
        (send-event (handle->process (-> self missiles (-> self current-leader-missile))) 'explode)
        )
    (if (or (not (handle->process (-> self hpickup)))
            (begin
              (let* ((gp-2 #t)
                     (s5-0 (handle->process (-> self hpickup)))
                     (v1-164 (the-as focus-status (logand (-> (the-as process-focusable (if (type? s5-0 process-focusable)
                                                                                            (the-as process-focusable s5-0)
                                                                                            )
                                                                      )
                                                              focus-status
                                                              )
                                                          (focus-status dead)
                                                          )
                                     )
                             )
                     )
                (cmove-#f-zero gp-1 v1-164 gp-2)
                )
              gp-1
              )
            )
        (send-event self 'fail)
        )
    )
  )

(define *missile-fire-order* (new 'static 'boxed-array :type int32 0 1 2 0 2 0 2))

(define *missile-fire-frames* (new 'static 'boxed-array :type float 12.0 14.0 16.0 21.0 23.0 25.0 31.0 31.0))

(defstate show-missile-launch (cty-hijack-manager)
  :virtual #t
  :event task-manager-event-handler
  :enter (behavior ()
    (set-setting! 'allow-look-around #f 0.0 0)
    (set-time! (-> self state-time))
    (set-setting! 'entity-name "camera-320" 0.0 0)
    )
  :trans (behavior ()
    ((-> (method-of-type task-manager active) trans))
    )
  :code (behavior ()
    (local-vars (v1-2 object))
    (until v1-2
      (suspend)
      (set! v1-2 (and (-> *target* next-state) (= (-> *target* next-state name) 'target-pilot-stance)))
      )
    (until (process-grab? *target* #f)
      (suspend)
      )
    (let ((gp-0 (current-time)))
      (until (time-elapsed? gp-0 (seconds 1.5))
        (suspend)
        )
      )
    (send-event (handle->process (-> self hpickup)) 'flight-up)
    (let ((gp-1 (-> self missiles allocated-length))
          (s5-0 0)
          )
      (let ((s4-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> s4-0 from) (process->ppointer self))
        (set! (-> s4-0 num-params) 0)
        (set! (-> s4-0 message) 'recoil)
        (let ((s3-0 send-event-function)
              (v1-22 (entity-by-name "cty-missile-launcher-1"))
              )
          (s3-0
            (if v1-22
                (-> v1-22 extra process)
                )
            s4-0
            )
          )
        )
      (while (> gp-1 0)
        (let* ((v1-25 (entity-by-name "cty-missile-launcher-1"))
               (f30-0 (-> (the-as process-focusable (if v1-25
                                                        (the-as process-focusable (-> v1-25 extra process))
                                                        )
                                  )
                          skel
                          root-channel
                          0
                          frame-num
                          )
                      )
               (s4-1 s5-0)
               (s3-1 (+ (-> *missile-fire-frames* length) -2))
               )
          (while (>= s3-1 s4-1)
            (when (< (-> *missile-fire-frames* s4-1) f30-0)
              (spawn-missiles-from-launcher self (-> *missile-fire-order* s4-1))
              (+! s5-0 1)
              (+! gp-1 -1)
              )
            (+! s4-1 1)
            )
          )
        (suspend)
        )
      )
    (sound-play "hj-missile" :id (-> self missile-sound))
    (let ((gp-2 (current-time)))
      (until (time-elapsed? gp-2 (seconds 0.5))
        (suspend)
        )
      )
    (dotimes (gp-3 (-> self missiles length))
      (send-event (handle->process (-> self missiles gp-3)) 'begin-moving)
      )
    (suspend)
    (dotimes (gp-4 (-> self missiles length))
      (send-event (handle->process (-> self missiles gp-4)) 'begin-moving)
      )
    (cty-hijack-manager-method-39 self 1)
    (let ((gp-5 (current-time)))
      (until (time-elapsed? gp-5 (seconds 0.2))
        (suspend)
        )
      )
    (remove-setting! 'entity-name)
    (let ((gp-6 (current-time)))
      (until (time-elapsed? gp-6 (seconds 1))
        (suspend)
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (go-virtual player-riding)
    )
  )

;; WARN: Return type mismatch int vs handle.
(defmethod spawn-missile ((this cty-hijack-manager) (arg0 vector) (arg1 quaternion) (arg2 int))
  (let ((s4-0 (new 'stack-no-clear 'cty-hijack-missile-init-params)))
    (if (zero? arg2)
        (set! (-> s4-0 is-leader?) #t)
        (set! (-> s4-0 is-leader?) #f)
        )
    (set! (-> s4-0 pos quad) (-> arg0 quad))
    (quaternion-copy! (-> s4-0 quat) arg1)
    (set! (-> s4-0 track-obj) (-> this hpickup))
    (let* ((s3-0 (get-process *default-dead-pool* cty-hijack-missile #x4000 1))
           (v0-4 (process->handle
                   (-> (when s3-0
                         (let ((t9-2 (method-of-type cty-hijack-missile activate)))
                           (t9-2 (the-as cty-hijack-missile s3-0) this "cty-hijack-missile" (the-as pointer #x70004000))
                           )
                         (run-now-in-process s3-0 cty-hijack-missile-init-by-other s4-0)
                         (-> s3-0 ppointer)
                         )
                       0
                       )
                   )
                 )
           )
      (set! (-> this missiles arg2) (the-as handle v0-4))
      (the-as handle v0-4)
      )
    )
  )

(defstate player-riding (cty-hijack-manager)
  :virtual #t
  :parent (cty-hijack-manager active)
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('vehicle-bump)
       (if (and (time-elapsed? (-> self state-time) (seconds 5))
                (or (and (> (-> *hijack-speech* 17 play-time) 0) (time-elapsed? (-> *hijack-speech* 17 play-time) (seconds 4)))
                    (not (logtest? (-> *hijack-speech* 17 flags) (hijack-speech-info-flag hsi4)))
                    )
                )
           (cty-hijack-manager-method-39 self 17)
           )
       )
      (('wrong-way)
       (send-event self 'fail)
       )
      (('stage-2)
       (task-node-close! (game-task-node city-hijack-vehicle-escape) 'event)
       )
      (else
        (task-manager-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-setting! 'disable-parking-spots? #t 0.0 0)
    (set-setting! 'music 'hijack 0.0 0)
    (set-setting! 'stop-boats? #t 0.0 0)
    (kill-by-type barge *active-pool*)
    (let* ((v1-6 (entity-by-name "boat-manager-1"))
           (a0-5 (if v1-6
                     (-> v1-6 extra process)
                     )
                 )
           )
      (if a0-5
          (boat-manager-method-16 (the-as boat-manager a0-5))
          )
      )
    (when *target*
      (hide-hud 'hud-health)
      (hide-hud 'hud-gun)
      (set! (-> *target* fact health) (-> *target* fact health-max))
      (set! (-> *game-info* gun-ammo 0) (fmax (-> *game-info* gun-ammo 0) (-> *FACT-bank* ammo-yellow-start)))
      )
    (set-setting! 'exclusive-task #f 0.0 (-> self node-info task))
    (send-event (handle->process (-> self hpickup)) 'set-taskman (process->handle self))
    (guide-arrow-spawn self)
    (set-setting! 'exclusive-load '((ignore all) (allow lctyhijk)) 0.0 0)
    (let ((gp-0 (new 'stack-no-clear 'cty-missile-lure-init-params)))
      (dotimes (s5-0 (-> *cty-hijack-lure-positions* length))
        (let ((a0-21 (-> *cty-hijack-lure-positions* s5-0)))
          (set! (-> gp-0 pos quad) (-> a0-21 pos quad))
          )
        (quaternion-identity! (-> gp-0 orient))
        (set! (-> gp-0 is-naughty-ottsel?) #f)
        (process-spawn cty-missile-lure gp-0 :name "cty-missile-lure" :to self)
        )
      )
    (let ((gp-1 (new 'stack-no-clear 'cty-missile-lure-init-params)))
      (set! (-> gp-1 pos quad) (-> *naughty-ottsel-pos* quad))
      (quaternion-identity! (-> gp-1 orient))
      (set! (-> gp-1 is-naughty-ottsel?) #t)
      (let ((s5-1 (get-process *default-dead-pool* cty-missile-lure #x4000 1)))
        (set! (-> self naughty-ottsel-lure)
              (process->handle
                (-> (when s5-1
                      (let ((t9-18 (method-of-type cty-missile-lure activate)))
                        (t9-18 (the-as cty-missile-lure s5-1) self "cty-missile-lure" (the-as pointer #x70004000))
                        )
                      (run-now-in-process s5-1 cty-missile-lure-init-by-other gp-1)
                      (-> s5-1 ppointer)
                      )
                    0
                    )
                )
              )
        )
      )
    (send-event (handle->process (-> self task-arrow)) 'leave)
    (set-alert-level1 *kg-squad-control* 1)
    (let ((v1-66 (-> self hpickup process)))
      (set-setting! 'kg-primary-target v1-66 1.0 (-> v1-66 0 pid))
      )
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (local-vars (gp-1 symbol))
    (let ((v1-4 (handle->process (-> self missiles (-> self current-leader-missile)))))
      (if v1-4
          (sound-play
            "hj-missile"
            :id (-> self missile-sound)
            :position (-> (the-as process-focusable v1-4) root trans)
            )
          )
      )
    (when (time-elapsed? (-> self state-time) (seconds 3.5))
      (dotimes (gp-0 (-> self missiles length))
        (send-event (handle->process (-> self missiles gp-0)) 'full-chase)
        )
      )
    (if (and (> (-> *hijack-speech* 1 play-time) 0) (time-elapsed? (-> *hijack-speech* 1 play-time) (seconds 3)))
        (cty-hijack-manager-method-39 self 3)
        )
    (if (and (> (-> *hijack-speech* 5 play-time) 0) (time-elapsed? (-> *hijack-speech* 5 play-time) (seconds 7)))
        (cty-hijack-manager-method-39 self 6)
        )
    (if (and (> (-> *hijack-speech* 6 play-time) 0) (time-elapsed? (-> *hijack-speech* 6 play-time) (seconds 6)))
        (cty-hijack-manager-method-39 self 8)
        )
    (cty-hijack-manager-method-35 self)
    (when (task-node-closed? (game-task-node city-hijack-vehicle-escape))
      (set-setting! 'exclusive-load '((ignore all) (allow lctyhijk)) 0.0 0)
      (go-virtual decoy-stage)
      )
    (if (or (not (handle->process (-> self hpickup)))
            (begin
              (let* ((gp-2 #t)
                     (s5-0 (handle->process (-> self hpickup)))
                     (v1-69 (the-as focus-status (logand (-> (the-as process-focusable (if (type? s5-0 process-focusable)
                                                                                           (the-as process-focusable s5-0)
                                                                                           )
                                                                     )
                                                             focus-status
                                                             )
                                                         (focus-status dead)
                                                         )
                                    )
                            )
                     )
                (cmove-#f-zero gp-1 v1-69 gp-2)
                )
              gp-1
              )
            )
        (send-event self 'fail)
        )
    )
  )

(deftype cty-missile-launcher (process-drawable)
  ()
  (:state-methods
    idle
    recoil
    )
  )


(defskelgroup skel-cty-missile-launcher cty-missile-launcher cty-missile-launcher-lod0-jg cty-missile-launcher-idle-ja
              ((cty-missile-launcher-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              :origin-joint-index 3
              )

(defmethod init-from-entity! ((this cty-missile-launcher) (arg0 entity-actor))
  (stack-size-set! (-> this main-thread) 128)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle impenetrable-obj))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 5)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set! (-> v1-13 transform-index) 3)
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 6)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-cty-missile-launcher" (the-as (pointer level) #f))
      )
    (the-as pair 0)
    )
  (let ((a0-28 (-> this skel root-channel 0)))
    (set! (-> a0-28 frame-group) (the-as art-joint-anim (-> this draw art-group data 3)))
    (joint-control-channel-group-eval!
      a0-28
      (the-as art-joint-anim (-> this draw art-group data 3))
      num-func-identity
      )
    )
  (go (method-of-object this idle))
  )

(defstate recoil (cty-missile-launcher)
  :virtual #t
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! cty-missile-launcher-recoil-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    )
  :post transform-post
  )

(defstate idle (cty-missile-launcher)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('recoil)
       (go-virtual recoil)
       )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! cty-missile-launcher-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post transform-post
  )

(define *missile-closer-chase-normal* (new 'static 'vector :x -0.9951 :z 0.0976 :w 1.0))

(define *missile-closer-chase-pos* (new 'static 'vector :x 4090870.2 :y 32741.785 :z 2592906.5 :w 1.0))

;; WARN: Return type mismatch symbol vs none.
(defmethod cty-hijack-manager-method-35 ((this cty-hijack-manager))
  (when (< (vector-vector-xz-distance (target-pos 0) *missile-closer-chase-pos*) 81920.0)
    (let ((f0-2 (vector-dot
                  (vector-! (new 'stack-no-clear 'vector) (target-pos 0) *missile-closer-chase-pos*)
                  *missile-closer-chase-normal*
                  )
                )
          )
      (when (< 0.0 f0-2)
        (dotimes (s5-3 (-> this missiles length))
          (cty-hijack-manager-method-39 this 5)
          (send-event (handle->process (-> this missiles s5-3)) 'get-closer)
          )
        )
      )
    )
  (none)
  )

(defmethod spawn-missiles-from-launcher ((this cty-hijack-manager) (arg0 int))
  (sound-play "missile-launch")
  (let* ((v1-1 (entity-by-name "cty-missile-launcher-1"))
         (s4-1 (if v1-1
                   (-> v1-1 extra process)
                   )
               )
         )
    (when s4-1
      (let ((s5-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> (the-as process-focusable s4-1) node-list data 6)))
            (s4-2 (matrix->quaternion
                    (new 'stack-no-clear 'quaternion)
                    (-> (the-as process-focusable s4-1) node-list data 6 bone transform)
                    )
                  )
            )
        (vector+float*! s5-1 s5-1 (vector-y-quaternion! (new 'stack-no-clear 'vector) s4-2) 5120.0)
        (cond
          ((= arg0 2)
           (vector+float*! s5-1 s5-1 (vector-x-quaternion! (new 'stack-no-clear 'vector) s4-2) 6553.6)
           )
          ((zero? arg0)
           (vector+float*! s5-1 s5-1 (vector-x-quaternion! (new 'stack-no-clear 'vector) s4-2) -6553.6)
           )
          )
        (spawn-missile this s5-1 s4-2 (-> this missiles length))
        )
      (+! (-> this missiles length) 1)
      )
    )
  (none)
  )

(deftype guide-arrow-info (structure)
  ((pos     vector  :inline)
   (facing  vector  :inline)
   )
  )


(define *guide-arrow-list* (new 'static 'boxed-array :type guide-arrow-info
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 4629187.0 :y 55781.785 :z 2322673.2 :w 1.0)
                               :facing (new 'static 'vector :x 0.1975 :z 0.9803 :w 1.0)
                               )
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 4619754.5 :y 71141.79 :z 2787199.8 :w 1.0)
                               :facing (new 'static 'vector :x -0.9725 :z -0.2328 :w 1.0)
                               )
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 3561828.0 :y 61127.477 :z 2600695.0 :w 1.0)
                               :facing (new 'static 'vector :x 0.2231 :z 0.9747 :w 1.0)
                               )
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 3558417.5 :y 64115.508 :z 3482799.0 :w 1.0)
                               :facing (new 'static 'vector :x 0.9886 :z -0.15 :w 1.0)
                               )
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 3895419.0 :y 60577.793 :z 3534492.5 :w 1.0)
                               :facing (new 'static 'vector :x 0.1378 :z 0.9904 :w 1.0)
                               )
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 3924504.5 :y 63866.47 :z 4484548.0 :w 1.0)
                               :facing (new 'static 'vector :x -0.9991 :z -0.0421 :w 1.0)
                               )
                             (new 'static 'guide-arrow-info
                               :pos (new 'static 'vector :x 3363461.5 :y 57093.734 :z 4522630.5 :w 1.0)
                               :facing (new 'static 'vector :x -0.1454 :z 0.9893 :w 1.0)
                               )
                             )
        )

(defmethod guide-arrow-spawn ((this cty-hijack-manager))
  (dotimes (s5-0 (-> *guide-arrow-list* length))
    (let ((a0-1 (new 'stack-no-clear 'guide-arrow-init-params)))
      (let ((v1-0 (new 'stack-no-clear 'vector)))
        (set! (-> v1-0 quad) (-> *guide-arrow-list* s5-0 pos quad))
        (let ((a1-5 (new 'stack-no-clear 'vector)))
          (set! (-> a1-5 quad) (-> *guide-arrow-list* s5-0 facing quad))
          (set! (-> a0-1 pos quad) (-> v1-0 quad))
          (set! (-> a0-1 facing quad) (-> a1-5 quad))
          )
        )
      (set! (-> a0-1 xz?) #t)
      (set! (-> a0-1 twist) 0.0)
      (spawn-guide-arrow a0-1 this)
      )
    )
  #f
  )
