;;-*-Lisp-*-
(in-package goal)

(defun get-widest-entry ((entries (array popup-menu-entry)) (title string) (font-ctx font-context) (start-index int) (end-index int))
  (let ((max-len 0.0))
    (dotimes (i (- end-index start-index))
      (let ((label-len (-> (get-string-length (-> entries (+ start-index i) label) font-ctx) length)))
        (when (> label-len max-len)
          (set! max-len label-len))))
    (let ((title-len (-> (get-string-length title font-ctx) length)))
      (when (> title-len max-len)
        (set! max-len title-len)))
    (the int max-len)))

(defun get-widest-dynamic-entry ((get-entry-label (function int string none)) (title string) (font-ctx font-context) (start-index int) (end-index int))
  (let ((max-len 0.0))
    (dotimes (i (- end-index start-index))
      (get-entry-label (+ start-index i) *pc-encoded-temp-string*)
      (let ((label-len (-> (get-string-length *pc-encoded-temp-string* font-ctx) length)))
        (when (> label-len max-len)
          (set! max-len label-len))))
    (let ((title-len (-> (get-string-length title font-ctx) length)))
      (when (> title-len max-len)
        (set! max-len title-len)))
    (the int max-len)))

(defmethod draw-entry ((this popup-menu-entry) (font-ctx font-context) (dma-buf dma-buffer) (hovering? symbol))
  (let ((old-x (-> font-ctx origin x))
        (old-y (-> font-ctx origin y))
        (old-color (-> font-ctx color)))
    (pc-encode-utf8-string (-> this label) *pc-encoded-temp-string*)
    (when hovering?
      (set! (-> font-ctx color) (font-color cyan)))
    (when (and (nonzero? (-> this entry-disabled?)) ((-> this entry-disabled?)))
      (set! (-> font-ctx color) (font-color menu-parent)))
    (draw-string-adv *pc-encoded-temp-string* dma-buf font-ctx)
    (set! (-> font-ctx origin x) old-x)
    (set! (-> font-ctx origin y) old-y)
    (set! (-> font-ctx color) old-color))
  (none))

(defmethod draw-entry ((this popup-menu-flag) (font-ctx font-context) (dma-buf dma-buffer) (hovering? symbol))
  (let ((old-x (-> font-ctx origin x))
        (old-y (-> font-ctx origin y))
        (old-color (-> font-ctx color)))
    (when ((-> this is-toggled?))
      (set! (-> font-ctx color) (font-color green))
      (set! (-> font-ctx origin x) (- old-x 6.0))
      (draw-string-adv "\c86" dma-buf font-ctx)
      (set! (-> font-ctx origin x) old-x)
      (set! (-> font-ctx origin y) old-y)
      (set! (-> font-ctx color) old-color))
    (pc-encode-utf8-string (-> this label) *pc-encoded-temp-string*)
    (when hovering?
      (set! (-> font-ctx color) (font-color cyan)))
    (draw-string-adv *pc-encoded-temp-string* dma-buf font-ctx)
    (set! (-> font-ctx origin x) old-x)
    (set! (-> font-ctx origin y) old-y)
    (set! (-> font-ctx color) old-color))
  (none))

(defun draw-dynamic-entry ((entry-id int) (get-label (function int string none)) (entry-selected? (function int symbol)) (font-ctx font-context) (dma-buf dma-buffer) (hovering? symbol))
  (let ((old-x (-> font-ctx origin x))
        (old-y (-> font-ctx origin y))
        (old-color (-> font-ctx color)))
    (when (entry-selected? entry-id)
      (set! (-> font-ctx color) (font-color green))
      (set! (-> font-ctx origin x) (- old-x 6.0))
      (draw-string-adv "\c86" dma-buf font-ctx)
      (set! (-> font-ctx origin x) old-x)
      (set! (-> font-ctx origin y) old-y)
      (set! (-> font-ctx color) old-color))
    (clear *pc-encoded-temp-string*)
    (get-label entry-id *pc-encoded-temp-string*)
    (pc-encode-utf8-string *pc-encoded-temp-string* *pc-encoded-temp-string*)
    (when hovering?
      (set! (-> font-ctx color) (font-color cyan)))
    (draw-string-adv *pc-encoded-temp-string* dma-buf font-ctx)
    (set! (-> font-ctx origin x) old-x)
    (set! (-> font-ctx origin y) old-y)
    (set! (-> font-ctx color) old-color))
  (none))

(defmethod draw-menu ((this popup-menu))
  (let ((font-ctx (new 'debug 'font-context *font-default-matrix* 0 0 0.0 (font-color default) (font-flags shadow kerning large)))
        (page-title (-> this menu-states (-> this curr-state-index) title))
        (dynamic-menu? (-> this menu-states (-> this curr-state-index) dynamic-menu?))
        (can-reset? (and (nonzero? (-> this menu-states (-> this curr-state-index) on-dynamic-menu-reset))
                         (-> this menu-states (-> this curr-state-index) on-dynamic-menu-reset))))
    (set! (-> font-ctx scale) 0.25)
    (set! (-> font-ctx origin x) 15.0)
    (set! (-> font-ctx origin y) 75.0)
    (let* ((entry-count (if dynamic-menu?
                            ((-> this menu-states (-> this curr-state-index) get-dynamic-menu-length))
                            (-> this menu-states (-> this curr-state-index) entries length)))
           (current-index (-> this menu-states (-> this curr-state-index) entry-index))
           (start-index (* (/ current-index 15) 15))
           (end-index (min (+ start-index 15) entry-count))
           (entry-count-to-render (- end-index start-index))
           (menu-rows (if (< end-index entry-count) (inc entry-count-to-render) entry-count-to-render))
           (widest-entry (if dynamic-menu?
                             (get-widest-dynamic-entry (-> this menu-states (-> this curr-state-index) get-dynamic-menu-entry-label) page-title font-ctx start-index end-index)
                             (get-widest-entry (-> this menu-states (-> this curr-state-index) entries) page-title font-ctx start-index end-index))))
      (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf2))
        ;; background border
        (draw-sprite2d-xy buf
                          6
                          64
                          (+ 17 widest-entry) ;; width
                          (+ 17 (* 15 (inc menu-rows))) ;; height
                          (new 'static 'rgba :r 255 :g 255 :b 255 :a 75))
        ;; background
        (draw-sprite2d-xy buf
                          7
                          65
                          (+ 15 widest-entry) ;; width
                          (+ 15 (* 15 (inc menu-rows))) ;; height
                          (new 'static 'rgba :r 0 :g 0 :b 0 :a 255))
        ;; title
        ;; TODO - function
        (pc-encode-utf8-string page-title *pc-encoded-temp-string*)
        (set! (-> font-ctx color) (font-color menu-parent))
        (let ((old-x (-> font-ctx origin x))
              (old-y (-> font-ctx origin y)))
          (draw-string-adv *pc-encoded-temp-string* buf font-ctx)
          (set! (-> font-ctx origin x) old-x)
          (set! (-> font-ctx origin y) old-y))
        (set! (-> font-ctx color) (font-color default))
        (set! (-> font-ctx origin y) (+ 15.0 (-> font-ctx origin y)))
        ;; menu contents
        (dotimes (i entry-count-to-render)
          (if dynamic-menu?
            (draw-dynamic-entry (+ i start-index)
                                (-> this menu-states (-> this curr-state-index) get-dynamic-menu-entry-label)
                                (-> this menu-states (-> this curr-state-index) dynamic-menu-entry-selected?)
                                font-ctx
                                buf
                                (= (+ i start-index) current-index))
            (draw-entry (-> (-> this menu-states (-> this curr-state-index) entries) i) font-ctx buf (= (+ i start-index) current-index)))
          (set! (-> font-ctx origin y) (+ 15.0 (-> font-ctx origin y))))
        (when (< end-index entry-count)
          (clear *pc-encoded-temp-string*)
          (format *pc-encoded-temp-string* "~D more..." (- entry-count end-index))
          (pc-encode-utf8-string *pc-encoded-temp-string* *pc-encoded-temp-string*)
          (set! (-> font-ctx color) (font-color menu-parent))
          (let ((old-x (-> font-ctx origin x))
                (old-y (-> font-ctx origin y)))
            (draw-string-adv *pc-encoded-temp-string* buf font-ctx)
            (set! (-> font-ctx origin x) old-x)
            (set! (-> font-ctx origin y) old-y))
          (set! (-> font-ctx color) (font-color default))
          (set! (-> font-ctx origin y) (+ 15.0 (-> font-ctx origin y))))
        ;; button prompts
        (cond
          ((= (-> this curr-state-index) 0)
            (pc-encode-utf8-string "<PAD_CIRCLE> Exit" *pc-encoded-temp-string*)
            )
          ((and dynamic-menu? can-reset?)
            (pc-encode-utf8-string "<PAD_SQUARE> Reset / <PAD_CIRCLE> Back" *pc-encoded-temp-string*))
          (else
            (pc-encode-utf8-string "<PAD_CIRCLE> Back" *pc-encoded-temp-string*))
          )
        (set! (-> font-ctx origin x) (- 25.0 (-> font-ctx origin x)))
        (set! (-> font-ctx origin y) (+ 10.0 (-> font-ctx origin y)))
        (let ((old-x (-> font-ctx origin x))
              (old-y (-> font-ctx origin y)))
          (draw-string-adv *pc-encoded-temp-string* buf font-ctx)
          (set! (-> font-ctx origin x) old-x)
          (set! (-> font-ctx origin y) old-y))
        )))
  (none))

(defmethod move-up! ((this popup-menu) (amount int))
  (let* ((curr-state (-> this menu-states (-> this curr-state-index)))
         (new-index (max 0 (-! (-> curr-state entry-index) amount))))
    ;; dynamic menus don't have options that are disabled (just dont include them)
    (when (not (-> curr-state dynamic-menu?))
      (let ((entry (-> curr-state entries new-index)))
        (when (and (nonzero? (-> entry entry-disabled?)) ((-> entry entry-disabled?)))
          (set! new-index (max 0 (dec new-index))))))
    (set! (-> curr-state entry-index) new-index))
  (none))

(defmethod move-down! ((this popup-menu) (amount int))
  (let* ((curr-state (-> this menu-states (-> this curr-state-index)))
         (max-entries (if (-> curr-state dynamic-menu?)
                         ((-> curr-state get-dynamic-menu-length))
                         (-> curr-state entries length)))
         (new-index (min (dec max-entries) (+! (-> curr-state entry-index) amount))))
    ;; dynamic menus don't have options that are disabled (just dont include them)
    (when (not (-> curr-state dynamic-menu?))
      (let ((entry (-> curr-state entries new-index)))
        (when (and (nonzero? (-> entry entry-disabled?)) ((-> entry entry-disabled?)))
          (set! new-index (min (dec max-entries) (inc new-index))))))
    (set! (-> curr-state entry-index) new-index))
  (none))

(defmethod confirm! ((this popup-menu))
  (let* ((menu-state (-> this menu-states (-> this curr-state-index)))
         (dynamic-menu? (-> menu-state dynamic-menu?)))
    (if dynamic-menu?
      ((-> menu-state on-dynamic-menu-entry-confirm) (-> menu-state entry-index))
      (let ((entry (-> menu-state entries (-> menu-state entry-index))))
        (cond
          ((type? entry popup-menu-dynamic-submenu)
           ;; TODO - dont allow more than 10 nested menus
           (inc! (-> this curr-state-index))
           (set! (-> this menu-states (-> this curr-state-index) entry-index) 0)
           (set! (-> this menu-states (-> this curr-state-index) title) (-> entry label))
           (set! (-> this menu-states (-> this curr-state-index) dynamic-menu?) #t)
           (set! (-> this menu-states (-> this curr-state-index) get-dynamic-menu-length) (-> (the-as popup-menu-dynamic-submenu entry) get-length))
           (set! (-> this menu-states (-> this curr-state-index) get-dynamic-menu-entry-label) (-> (the-as popup-menu-dynamic-submenu entry) get-entry-label))
           (set! (-> this menu-states (-> this curr-state-index) on-dynamic-menu-entry-confirm) (-> (the-as popup-menu-dynamic-submenu entry) on-entry-confirm))
           (set! (-> this menu-states (-> this curr-state-index) dynamic-menu-entry-selected?) (-> (the-as popup-menu-dynamic-submenu entry) entry-selected?))
           (set! (-> this menu-states (-> this curr-state-index) on-dynamic-menu-reset) (-> (the-as popup-menu-dynamic-submenu entry) on-reset)))
          ((type? entry popup-menu-submenu)
           ;; TODO - dont allow more than 10 nested menus
           (inc! (-> this curr-state-index))
           (set! (-> this menu-states (-> this curr-state-index) entry-index) 0)
           (set! (-> this menu-states (-> this curr-state-index) dynamic-menu?) #f)
           (set! (-> this menu-states (-> this curr-state-index) title) (-> entry label))
           (set! (-> this menu-states (-> this curr-state-index) entries) (-> (the-as popup-menu-submenu entry) entries)))
          (else
           ((-> entry on-confirm)))))))
  (sound-play "menu-pick")
  (none))

(defmethod reset! ((this popup-menu))
  (let* ((menu-state (-> this menu-states (-> this curr-state-index))))
    (when (and (-> menu-state dynamic-menu?)
               (nonzero? (-> menu-state on-dynamic-menu-reset))
               (-> menu-state on-dynamic-menu-reset)) ;; dont call if theres no function defined
      ((-> menu-state on-dynamic-menu-reset))
      (sound-play "menu-pick")))
  (none))

(defmethod back! ((this popup-menu))
  (sound-play "menu-pick")
  (cond
    ((<= (-> this curr-state-index) 0)
     #t)
    (else
     (dec! (-> this curr-state-index))
     #f)))

(defbehavior popup-menu-init popup-menu ((title string) (entries (array popup-menu-entry)))
  (set! (-> self curr-state-index) 0)
  (set! (-> self menu-states 0 title) title)
  (set! (-> self menu-states 0 entries) entries)
  (set! (-> self menu-states 0 entry-index) 0)
  (set! (-> self menu-states 0 dynamic-menu?) #f)
  (set! (-> self draw?) #f)
  (go-virtual closed)
  (none))

(defbehavior popup-menu-event-handler popup-menu ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
  (case event-type
    (('open-menu)
      (set! (-> self draw?) #t)
      (set! *popup-menu-open* #t)
      (sound-play "menu-pick")
      (go-virtual opened))
    (('close-menu)
      (set! (-> self draw?) #f)
      (set! *popup-menu-open* #f)
      (go-virtual closed)))
    (the-as object 0))

(defmethod update-menu! ((this popup-menu))
  "This can't be done inside a state because the popup-menu is used when the game is paused
   during which time, processes are not executed."
  (when (-> this draw?)
    ;; handle input
    (cond
      ((cpad-pressed? 0 select)
       (send-event this 'close-menu))
      ((cpad-pressed? 0 up)
       (move-up! this 1))
      ((cpad-pressed? 0 down)
       (move-down! this 1))
      ((cpad-pressed? 0 left)
       (move-up! this 5))
      ((cpad-pressed? 0 right)
       (move-down! this 5))
      ((cpad-pressed? 0 x)
       (confirm! this))
      ((cpad-pressed? 0 square)
       (reset! this))
      ((cpad-pressed? 0 triangle circle)
       (when (back! this)
         (send-event this 'close-menu))))
    (draw-menu this))
  (none))

(defstate closed (popup-menu)
  :virtual #t
  :event popup-menu-event-handler
  :trans (behavior ()
    (none))
  :code (behavior ()
    (until #f (suspend))
    (none))
  :post (behavior ()
    (none)))

(defstate opened (popup-menu)
  :virtual #t
  :event popup-menu-event-handler
  :trans (behavior ()
    (none))
  :code (behavior ()
    (until #f (suspend))
    (none))
  :post (behavior ()
    (none)))
