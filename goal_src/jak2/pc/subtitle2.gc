;;-*-Lisp-*-
(in-package goal)

#|

  Code for subtitles for the PC port. A PC actor pool is provided, and the subtitle2 process lives there.
  Jak 2 has subtitles, but only for cutscenes and only for the actual spoken text.
  The subtitle process automatically looks for currently-playing audio in the gui control.
  It looks for specific channels there, NOT including the movie or subtitle channel.

  This updated subtitle system has a few different features than the Jak 1 subtitle system:
  - you can have multiple playing subtitles at once. Additional subtitles are rendered above the older ones,
    just like real subtitles. This goes for both multiple subtitles within the same scene, and also multiple scenes
    playing at once.
  - it can "merge" with the pre-existing subtitle system. Some code in scene.gc is changed to redirect subtitles
    to here to do that.
  - you supply the start AND end times as opposed to just the start time.
  - the speaker names are color-coded.
  Note that subtitle images are NOT supported with this! Merge mode will also NOT work with subtitle images.

  Similarly to the generic text file, only one subtitles text file is loaded at once, stored in a specific
  heap.

 |#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; constants
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defconstant PC_SUBTITLE_FILE_SIZE (* 192 1024)) ;; 192K heap for subtitles. adjust later if necessary.
(defconstant PC_SUBTITLE_FILE_NAME "subti2")
(defconstant PC_SUBTITLE_QUEUE_SIZE 5) ;; up to 8 things that display subtitles can be detected at once
(defconstant PC_SUBTITLE_QUEUE_MAX_LINES 2) ;; up to 2 lines can be queued per queueable thing
(defconstant PC_SUBTITLE_MAX_LINES 10) ;; max subtitles that can be displayed at once: queue-size * queue-lines
(defconstant PC_SUBTITLE_Y_RECALC -99.0)

(defconstant PC_SUB_DBG_Y 32)
(defconstant PC_SUB_DBG_CHECK_GROUP_SIZE 22)
(defglobalconstant PC_SUBTITLE_DEBUG #f)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; types and enums
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;------------------------
;;  data
;;;------------------------


(defenum pc-subtitle2-flags
  :bitfield #t
  :type uint16
  (offscreen) ;; speaker is offscreen.
  )

;; the list of available speakers for subtitles
(defenum pc-subtitle2-speaker
  :type uint16
  (none) ;; won't display a speaker - use this for tutorial messages etc.

  (computer)
  (jak)
  (darkjak)
  (daxter)
  (samos)
  (keira)
  (keira-before-class-3)
  (kid)
  (kor)
  (metalkor)
  (baron)
  (errol)
  (torn)
  (tess)
  (guard)
  (guard-a)
  (guard-b)
  (krew)
  (sig)
  (brutter)
  (vin)
  (youngsamos)
  (youngsamos-before-rescue)
  (pecker)
  (onin)
  (ashelin)
  (jinx)
  (mog)
  (grim)
  (agent)
  (citizen-male)
  (citizen-female)
  (oracle)
  (precursor)

  (max))

;; information about a single line of subtitles
(deftype subtitle2-line (structure)
  (
   (start-frame  float)  ;; the first frame to show the line on
   (end-frame    float)  ;; the last frame to show the line on
   (text     string)     ;; the text for the subtitle2 line
   (speaker  pc-subtitle2-speaker) ;; who the line speaker is
   (flags    pc-subtitle2-flags)   ;; flags
   )
  :pack-me
  )

;; an individual entry to a subtitle2 text making up a "scene" (audio file, spool), comprised of a series of lines
(deftype subtitle2-scene (structure)
  (
   ;; the name of the spool-anim or audio file
   (name  string)
   ;; the amount of lines
   (length int32)
   ;; line data
   (lines (inline-array subtitle2-line))
   )
  :pack-me
  :size-assert #xc  ;; compact!

  (:methods
    (get-line-at-pos (_type_ float int) subtitle2-line)
    )
  )

;; the global subtitle2 text info bank
(deftype subtitle2-text-info (basic)
  ((length  int16)
   (version int16)
   (lang    pc-subtitle-lang)
   (speaker-length  int16)
   (speaker-names   (pointer string))
   (data    subtitle2-scene :inline :dynamic)
   )

  (:methods
    (get-speaker (_type_ pc-subtitle2-speaker) string)
    (get-scene-by-name (_type_ string) subtitle2-scene)
    )
  )


(defmacro subtitle2-flags? (sub &rest flags)
  `(logtest? (-> ,sub flags) (pc-subtitle2-flags ,@flags)))


(defmethod inspect subtitle2-text-info ((obj subtitle2-text-info))
  (if (not obj)
      (return (the subtitle2-text-info #f)))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tlength: ~D~%" (-> obj length))
  (format #t "~1Tversion: ~D~%" (-> obj version))
  (format #t "~1Tlang: ~D~%" (-> obj lang))
  (format #t "~1Tspeaker-names[~D] @ #x~x~%" (-> obj speaker-length) (-> obj speaker-names))
  (dotimes (i (-> obj speaker-length))
    (format #t "~2T[~D]: ~A~%" i (-> obj speaker-names i)))
  (format #t "~1Tdata[0] @ #x~x~%" (-> obj data))
  (dotimes (i (-> obj length))
    (format #t "~2T--------~%")
    (format #t "~2Tname: ~A~%" (-> obj data i name))
    (format #t "~2Tlines[~D] @ #x~x~%" (-> obj data i length) (-> obj data i lines))
    (dotimes (ii (-> obj data i length))
      (format #t "~3T[~f to ~f] (#x~x)(~S) ~A~%" (-> obj data i lines ii start-frame) (-> obj data i lines ii end-frame)
                                                 (-> obj data i lines ii flags)
                                                 (enum->string pc-subtitle2-speaker (-> obj data i lines ii speaker))
                                                 (-> obj data i lines ii text)))
    )
  obj)


;;;----------------------------------
;;  process type
;;;----------------------------------


;; graphic parameters for subtitles
(deftype subtitle2-bank (structure)
  (
   (scale float)
   (width float)
   (lines float)
   )
  )

(define *SUBTITLE2-bank*
    (new 'static 'subtitle2-bank
                  :scale 0.9
                  :width 0.65
                  :lines 2.0
                  ))


(deftype subtitle2-queue-element (structure)
  ((id    sound-id)
   (gui   gui-connection)
   )
  :pack-me
  
  (:methods
    (clear-line (_type_) int))
  )

(deftype subtitle2-line-queue-element (structure)
  ((line  subtitle2-line)
   (y     float)
   )
  :pack-me
  )

;; the subtitle2 process! it lives on the PC actor pool
(deftype subtitle2 (process)
  (
   (font font-context) ;; the font to use for the subtitles.
   
   (have-message? symbol) ;; if there is a message displaying at the bottom, move subtitles up
   (have-minimap? symbol) ;; if there is a minimap displaying at the bottom, shrink subtitles
   (have-subtitles? symbol) ;; #t if we rendered any subtitles on the last frame.

   (gui-id sound-id)
   ;; store the gui id of channels with subtitles that we find.
   ;; that way if subtitle B appears above A, it wont move back down
   ;; if A ends before B
   (queue    subtitle2-queue-element       PC_SUBTITLE_QUEUE_SIZE :inline)
   (lines-0  subtitle2-line-queue-element  PC_SUBTITLE_MAX_LINES  :inline)
   (lines-1  subtitle2-line-queue-element  PC_SUBTITLE_MAX_LINES  :inline)
   (line-queue-idx int8)
   )

  (:methods
    (clear-queue (_type_) int)
    (update-gui-connections (_type_) int)
    (get-empty-queue (_type_) int)
    (gui-queued? (_type_ gui-connection) symbol)
    (get-active-subtitles (_type_) int)
    (subtitle-format (_type_ subtitle2-line) string)
    (draw-subtitles (_type_) int)
    (debug-print-queue (_type_) int)
    (debug-print-speakers (_type_) int)
    (start-gui (_type_) sound-id)
    (stop-gui (_type_) sound-id)
    )
  )




;;;----------------------------------------------
;;  globals
;;;----------------------------------------------


;; the subtitle2 process.
(define *subtitle2* (the (pointer subtitle2) #f))

;; subtitle2 text data
(define *subtitle2-text* (the subtitle2-text-info #f))
(kheap-alloc (define *subtitle2-text-heap* (new 'global 'kheap)) PC_SUBTITLE_FILE_SIZE)

;; temp strings for name look-up
(define *vag-temp-string* (new 'global 'string 8 (the string #f)))
(define *vag-temp-string-2* (new 'global 'string 8 (the string #f)))

;; speaker color table
(define *subtitle2-speaker-color-table* (the (pointer rgba) (malloc 'global (* (size-of rgba) (pc-subtitle2-speaker max)))))

;; debug option
(define *display-subtitle-speakers* #f)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  access subtitle heap
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defmethod get-speaker subtitle2-text-info ((obj subtitle2-text-info) (speaker pc-subtitle2-speaker))
  "get the translated string for that speaker"
  (if (and (> speaker (pc-subtitle2-speaker none)) (< speaker (-> obj speaker-length)))
      (-> obj speaker-names speaker)
      (the string #f))
  )

(defmethod get-scene-by-name subtitle2-text-info ((obj subtitle2-text-info) (name string))
  "get a subtitle scene info with the corresponding name. #f = none found"

  ;; invalid name so return invalid scene.
  (if (not name)
      (return (the subtitle2-scene #f)))

  ;; uppercase the string so we have a consistent name format
  (string-upcase name *vag-temp-string*)
  (dotimes (i (length obj))
    ;; name and kind matches, return that!
    (string-upcase (-> obj data i name) *vag-temp-string-2*)
    (when (string= *vag-temp-string-2* *vag-temp-string*)
      (return (-> obj data i)))
    )

  (the subtitle2-scene #f))


(defmethod get-line-at-pos subtitle2-scene ((obj subtitle2-scene) (pos float) (index int))
  "return the subtitle line at that position. #f = none found
   index is which line to return, since you can have multiple lines that cover the same position."
   
  (let ((found 0))

      (dotimes (i (length obj))
        (when (and (>= pos (-> obj lines i start-frame))
                   (< pos (-> obj lines i end-frame)))
          (when (= found index)
            (return (-> obj lines i)))
          (1+! found)
          )))
  
  (the subtitle2-line #f))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  loading files
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun load-subtitle2-text-info ((txt-name string) (curr-text symbol) (heap kheap))
  "load a subtitles text file onto a heap.
   txt-name = file name suffix
   curr-text = a symbol to a subtitle2-text-info to link the file to
   heap = the text heap to load the file onto"

  (let ((heap-sym-heap (the-as subtitle2-text-info (-> curr-text value)))
        (lang (-> *setting-control* user-current subtitle-language))
        (load-status 0)
        (heap-free (&- (-> heap top) (the-as uint (-> heap base)))))

    ;; current text has nothing loaded, or language doesn't match.
    (when (or (= heap-sym-heap #f)
              (!= (-> heap-sym-heap lang) lang))
      ;; so reload.

      ;; reset the text heap.
      (kheap-reset heap)

      ;; try to load load...
      (while (not (str-load (string-format "~D~S.TXT" lang txt-name) -1 (logand -64 (&+ (-> heap current) 63)) (&- (-> heap top) (-> heap current))))
          (return 0)
          )
      ;; load succeeded. check status.

      (label retry)
      (let ((status (str-load-status (the-as (pointer int32) (& load-status)))))
        (when (= status 'error)
          (format 0 "Error loading subtitle2~%")
          (return 0)
          (goto loaded)
          )
        (cond
          ((>= load-status (+ heap-free -300))
           (format 0 "Game subtitle2 heap overrun!~%")
           (return 0)
           )
          ((= status 'busy)
           ;; still loading.
           (goto retry)
           )
          )
        )
      (label loaded)

      ;; link the text file!
      (let ((new-mem (logand -64 (&+ (-> heap current) 63))))
          (flush-cache 0)
          (set! (-> curr-text value) (link new-mem (-> (string-format "~D~S.TXT" lang txt-name) data) load-status heap 0))
          )
      ;; if linking failed just make the text invalid.
      (if (<= (the-as int (-> curr-text value)) 0)
          (set! (-> curr-text value) (the-as object #f))
          )
      ))
  0)

(defun load-level-subtitle2-files ((idx int))
  "Load the subtitle2 files needed for level idx.
   This function made more sense back when text files were split up, but in the end they put everything
   in a single text group and file."

  ;; just load common.
  (if (or *level-text-file-load-flag* (>= idx 0))
      (load-subtitle2-text-info PC_SUBTITLE_FILE_NAME '*subtitle2-text* *subtitle2-text-heap*)
      )

  (none))


(defmacro reload-subtitles ()
  "rebuild and reload subtitles."
  `(begin
      (asm-text-file subtitle2 :files ("game/assets/jak2/game_subtitle.gp"))
      (if *subtitle2-text*
          (+! (-> *subtitle2-text* lang) 1))
      (load-level-subtitle2-files 0)))

(defmacro reload-text ()
  "rebuild and reload text."
  `(begin
      (mng)
      (if *common-text*
          (+! (-> *common-text* language-id) 1))
      (load-level-text-files 0)))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  subtitle2 queue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun subtitle-channel? ((ch gui-channel))
  "can this gui channel be checked for subtitles?"
  (and (>= ch (gui-channel jak)) (<= ch (gui-channel krew)))
  )

(defun valid-subtitle-gui? ((gui gui-connection))
  "is this gui connection valid for checking subtitles?"
  (and gui  (nonzero? (-> gui id))
            (subtitle-channel? (-> gui channel))
            (or (= (-> gui action) (gui-action playing))
                (= (-> gui action) (gui-action play)))
            (let ((status (get-status *gui-control* (-> gui id))))
            (or (= status (gui-status ready))
                (= status (gui-status active)))))
  )

(defun subtitle-bump-up? ()
  "should subtitles be moved up?"
  ;; have a query or message up?
  (or (nonzero? (lookup-gui-connection-id *gui-control* (the string #f) (gui-channel query) (gui-action playing)))
      (nonzero? (lookup-gui-connection-id *gui-control* (the string #f) (gui-channel message) (gui-action playing)))
      )
  )


(defmethod clear-line subtitle2-queue-element ((obj subtitle2-queue-element))
  "make this queue element invalid"

  (set! (-> obj gui) #f)
  (set! (-> obj id) (new 'static 'sound-id))
  0)

(defmethod clear-queue subtitle2 ((obj subtitle2))
  "mark all slots in the gui queue as available"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (clear-line (-> obj queue i)))
  0)

(defmethod update-gui-connections subtitle2 ((obj subtitle2))
  "mark all inactive slots in the gui queue as available"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)

    (let ((gui (lookup-gui-connection *gui-control* (the process #f) (gui-channel none) (the string #f) (-> obj queue i id))))

      (if (not (valid-subtitle-gui? gui))
          (clear-line (-> obj queue i)))))
  0)

(defmethod gui-queued? subtitle2 ((obj subtitle2) (gui gui-connection))
  "return #t is the gui is in the queue"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (if (= (-> gui id) (-> obj queue i id))
        (return #t)))
  #f)

(defmethod get-empty-queue subtitle2 ((obj subtitle2))
  "return the first available gui queue slot"

  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (if (not (-> obj queue i gui))
        (return i)))
  (format #t "ran out of subtitle queue slots!")
  0
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;  subtitle2 process and drawing!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defun set-speaker-color ((speaker pc-subtitle2-speaker))
  "set the color for the speaker font color"
  (let ((spk-col (-> *subtitle2-speaker-color-table* speaker)))
    (set-font-color (font-color progress-selected) 0  (new 'static 'rgba :r (-> spk-col r))
                                                      (new 'static 'rgba :r (-> spk-col g))
                                                      (new 'static 'rgba :r (-> spk-col b)))
    (set-font-color (font-color progress-selected) 1  (new 'static 'rgba :r (-> spk-col r))
                                                      (new 'static 'rgba :r (-> spk-col g))
                                                      (new 'static 'rgba :r (-> spk-col b))))
  speaker)


(defmethod get-active-subtitles subtitle2 ((obj subtitle2))
  "collect active subtitles and add them to the queue
   if a gui connection is already in the queue,
   it will stay in the same slot when it was first added"

  ;; todo
  (-> *gui-control* engine)
  (let ((current (-> *gui-control* engine alive-list-end prev0)))
    (-> *gui-control* engine)
    (let ((next (-> current prev0)))
      (while (!= current (-> *gui-control* engine alive-list))
        (let ((gui-conn (the gui-connection current)))
          (when (valid-subtitle-gui? gui-conn)

            (when (not (gui-queued? obj gui-conn))
                (let ((slot (get-empty-queue obj)))
                    (set! (-> obj queue slot id) (-> gui-conn id))
                    (set! (-> obj queue slot gui) gui-conn)
                    )
                )
            )
          )
        (set! current next)
        (-> *gui-control* engine)
        (set! next (-> next prev0))
        )
      )
    )
  0)


(defmethod subtitle-format subtitle2 ((obj subtitle2) (line subtitle2-line))
  "format the string for a subtitle line to *temp-string*"

  (cond
    ((= (pc-subtitle2-speaker none) (-> line speaker))
     ;; there's no speaker so who cares.
     (string-format "~S" (-> line text)))
    ((or (= #t (-> *pc-settings* subtitle-speaker?))
         (and (= 'auto (-> *pc-settings* subtitle-speaker?)) (subtitle2-flags? line offscreen)))
     ;; there is a speaker and we do want it.
     ;; we use color 33 which gets set at runtime to any color we want
     (string-format "~33L~S:~0L ~S" (get-speaker *subtitle2-text* (-> line speaker)) (-> line text)))
    (else
     (string-format "~S" (-> line text)))
    )
  *temp-string*)

(defun current-subtitle2-pos ((id sound-id))
  "get the str position for this sound id in a 30/sec measurement"
  (let ((pos (the float (current-str-pos id))))
    (if (< pos 0.0) -1.0 (/ pos (/ 1024.0 30)))))


(defbehavior setup-subtitle2-font subtitle2 ((font font-context))
  "setup a font and parameters for the subtitle2 subtitles."

  ;; set font settings.
  (if (!= (language-enum japanese) (-> *setting-control* user-current subtitle-language))
      (set-scale! font (* 0.5 (-> *SUBTITLE2-bank* scale)))
      (set-scale! font (* 0.5 (-> *SUBTITLE2-bank* scale) 1.15)))
  (set-width! font (the int (* (-> *SUBTITLE2-bank* width) 0.91 512)))
  (set-origin! font (the int (/ (- 512.0 (-> font width)) 2))
                    (the int (* (if (-> self have-message?) 0.524 0.698) 416)))
  (set-height! font (the int (* (-> *SUBTITLE2-bank* lines) 44)))
  
  ;; if we have the minimap, set the right border to 74.4% of screen width. shrink if larger than that.
  ;; TODO scale this with aspect.
  (when (and (-> self have-minimap?)
             (< (get-screen-x 0.744) (+ (-> font width) (-> font origin x))))
    (let ((new-width (- (get-screen-x 0.744) (-> font origin x))))
      (set-scale! font (* (-> font scale) (/ (the float new-width) (-> font width))))
      (set-width! font new-width)))
  )


(defmethod draw-subtitles subtitle2 ((self subtitle2))
  "do the subtitle drawing"
  
  ;; check the gui queue for lines to add to the line queue
  (let ((line-queue-old (if (zero? (-> self line-queue-idx)) (-> self lines-0) (-> self lines-1)))
        (line-queue     (if (zero? (-> self line-queue-idx)) (-> self lines-1) (-> self lines-0)))

        (find-line (lambda ((queue (inline-array subtitle2-line-queue-element)) (line subtitle2-line))
                       (dotimes (i PC_SUBTITLE_MAX_LINES)
                         (if (= line (-> queue i line))
                             (return i)))
                       -1)))
  (logxor! (-> self line-queue-idx) 1)
  ;; clear the queue we're writing to first
  (dotimes (i PC_SUBTITLE_MAX_LINES)
    (set! (-> line-queue i line) #f)
    (set! (-> line-queue i y) PC_SUBTITLE_Y_RECALC)
    )

  ;; we won't be able to render any subtitles with no text loaded.
  (when (not *subtitle2-text*)
      (false! (-> self have-subtitles?))
      (return 0))

  ;; set up our font to the initial parameters
  (set! (-> self have-message?) (or (subtitle-bump-up?) (and (-> self have-message?) (-> self have-subtitles?))))
  (set! (-> self have-minimap?) (logtest? (minimap-flag minimap) (-> *setting-control* user-current minimap)))
  (setup-subtitle2-font (-> self font))

  ;; do two passes - on the first one we add lines that were already being used,
  ;; on the second pass we add new lines
  (dotimes (q 2)
  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (when (-> self queue i gui)
      (let ((pos (current-subtitle2-pos (-> self queue i id))))
        (when (and (zero? q) *debug-segment*)
            (format *stdcon* "subtitle pos: ~3L~D~0L~%" (the int pos)))

        (dotimes (ii PC_SUBTITLE_QUEUE_MAX_LINES)
          (let ((scene (get-scene-by-name *subtitle2-text* (-> self queue i gui name))))
          (when scene
            (awhen (get-line-at-pos scene pos ii)
              (case q
                ((0)
                  (let ((index-in-old (find-line line-queue-old it)))
                    (when (!= -1 index-in-old)
                        ;; this line exists in the previous frame, put it in the new queue at the same spot
                        (set! (-> line-queue index-in-old line) it)
                        (set! (-> line-queue index-in-old y) (-> line-queue-old index-in-old y)))))
                ((1)
                  (when (= -1 (find-line line-queue it))
                    ;; line not in the queue. find empty spot.
                    (let ((index-empty (find-line line-queue (the subtitle2-line #f))))
                        (if (!= -1 index-empty)
                            (set! (-> line-queue index-empty line) it)))
                    ))
                )
              )
            ))
          )
        )
      )
    ))

  (let ((cur-y (-> self font origin y)) ;; the current y for the text
        (start-y (-> self font origin y)) ;; the starting y for the text
        (last-height 0.0) ;; the height of the previous subtitle
        (this-height 0.0) ;; the height of the current subtitle
        (lines-done 0)
        (subtitles-drawn? #f)
        )

  (dotimes (i PC_SUBTITLE_QUEUE_MAX_LINES)
    (when (-> line-queue i line)

      (subtitle-format self (-> line-queue i line))
      (set! this-height (print-game-text *temp-string* (-> self font) #t 44 (bucket-id debug-no-zbuf2)))

      ;; push subtitle up since we are not the first one
      (when (nonzero? lines-done)
        (-! cur-y (/ last-height 2))
        (-! cur-y (/ this-height 2))
        )

      ;; set the current y and draw line
      (if (= (-> line-queue i y) PC_SUBTITLE_Y_RECALC)
          (set! (-> line-queue i y) (- start-y cur-y))
          (set! cur-y (min cur-y (- start-y (-> line-queue i y)))))
      (set! (-> self font origin y) cur-y)

      (when (-> *setting-control* user-current subtitle)
        (true! subtitles-drawn?)
        (if (zero? (-> self gui-id))
            (start-gui self))

        (when (= (gui-status active) (get-status *gui-control* (-> self gui-id)))
            (protect (*display-text-box*)
            (set! *display-text-box* (or *display-text-box* PC_SUBTITLE_DEBUG))
            (set-speaker-color (-> line-queue i line speaker))
            (true! (-> self have-subtitles?))
            (print-game-text *temp-string* (-> self font) #f 44 (bucket-id debug-no-zbuf2))))
        )

      ;; save this for later usage
      (set! last-height this-height)
      (1+! lines-done)
      )
    )
  
  (when (and (nonzero? (-> self gui-id)) (not subtitles-drawn?))
    (stop-gui self))))
  
  0)

(defmethod debug-print-queue subtitle2 ((self subtitle2))
  "print the queue to *stdcon*"
  
  (format *stdcon* "q: ~%")
  (dotimes (i PC_SUBTITLE_QUEUE_SIZE)
    (if (-> self queue i gui)
        (format *stdcon* "~D: ~S ~3L~D~0L ~D ~`gui-connection`P~%" i
                                                                   (-> self queue i gui name)
                                                                   (the int (current-subtitle2-pos (-> self queue i id)))
                                                                   (-> self queue i id)
                                                                   (-> self queue i gui))))

  (format *stdcon* "l: ~%")
  (let ((line-queue (if (zero? (-> self line-queue-idx)) (-> self lines-0) (-> self lines-1))))
      (dotimes (i PC_SUBTITLE_MAX_LINES)
        (format *stdcon* "~D: ~D ~S~%" i (the int (-> line-queue i y)) (aif (-> line-queue i line) (-> it text)))))

  0)

(defmethod debug-print-speakers subtitle2 ((self subtitle2))
  "print all speakers onscreen"
  
  (if (not *subtitle2-text*)
      (return 0))

  (let ((font (new 'stack 'font-context *font-default-matrix* 0 0 0.0 (font-color default) (font-flags shadow kerning large)))
        (col-wid (/ 512.0 3)))
  (set-width! font (the int col-wid))
  (set-height! font 44)
  (set-scale! font 0.5)

  (dotimes (i (-> *subtitle2-text* speaker-length))
    (set-speaker-color (the pc-subtitle2-speaker i))
    (+! (-> font origin y) (print-game-text (string-format "~33L~S" (get-speaker *subtitle2-text* (the pc-subtitle2-speaker i)))
                                            font #f 44 (bucket-id debug-no-zbuf2)))
    (when (< 416.0 (-> font origin y))
        (set! (-> font origin y) 0.0)
        (+! (-> font origin x) col-wid))
    ))

  0)

(defmethod start-gui subtitle2 ((self subtitle2))
  "start gui queueing"
  (set! (-> self gui-id) (add-process *gui-control* self (gui-channel subtitle-pc) (gui-action play) "subtitle2" -10.0 0))
  )

(defmethod stop-gui subtitle2 ((self subtitle2))
  "stop gui queueing"
  (set-action! *gui-control* (gui-action stop) (-> self gui-id)
                             (gui-channel none)
                             (gui-action none)
                             (the-as string #f)
                             (the-as (function gui-connection symbol) #f)
                             (the-as process #f))
  (set! (-> self gui-id) (new 'static 'sound-id))
  )

(defstate subtitle2-process (subtitle2)

  :event (behavior ((from process) (argc int) (msg symbol) (block event-message-block))
    (case msg
      (('debug)
       ;(go subtitle2-debug)
       #f)
      )
    )

  :code (behavior ()
    (loop
      (suspend))
    )

  :trans (behavior ()
    (load-level-subtitle2-files 0)

    ;; get subtitles
    (update-gui-connections self)
    (get-active-subtitles self)

    (when *debug-segment*
        (when (and (cpad-hold? 0 l3) (cpad-pressed? 0 r3))
            (cpad-clear! 0 start)
            (send-event self 'debug)
            )

        )

    (none))

  :post (behavior ()

    (draw-subtitles self)
    
    (when *debug-segment*
      (if *display-subtitle-speakers*
          (debug-print-speakers self))
      (if PC_SUBTITLE_DEBUG
          (debug-print-queue self))
      )
    0)
  
  :exit (behavior ()
    
    (stop-gui self)

    (none))

  )




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; helper functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defmethod length subtitle2-text-info ((obj subtitle2-text-info))
  "Get the length (number of subtitle2 scenes) in a subtitle2-text-info."
  (-> obj length)
  )

(defmethod length subtitle2-scene ((obj subtitle2-scene))
  "Get the length (number of subtitle2 lines) in a subtitle2-scene."
  (-> obj length)
  )


(defbehavior subtitle2-init-by-other subtitle2 ()
  "external initializer for subtitle2 process"

  (set! (-> self font) (new 'process 'font-context *font-default-matrix*
                            0 0 0.0 (font-color default) (font-flags shadow kerning left middle large)))
  (clear-queue self)
  (dotimes (i PC_SUBTITLE_MAX_LINES)
    (set! (-> self lines-0 i line) #f)
    (set! (-> self lines-0 i y) PC_SUBTITLE_Y_RECALC)
    (set! (-> self lines-1 i line) #f)
    (set! (-> self lines-1 i y) PC_SUBTITLE_Y_RECALC)
    )

  (set! (-> self have-message?) #f)
  (set! (-> self have-minimap?) #f)
  (set! (-> self have-subtitles?) #f)

  (go subtitle2-process)
  )


(defun subtitle2-stop ()
  "kill the subtitle2 process"

  (kill-by-type subtitle2 *display-pool*)
  (set! *subtitle2* (the (pointer subtitle2) #f)))

(defun subtitle2-start ()
  "start the subtitle2 process"

  (when *subtitle2*
    (subtitle2-stop)
    )

  (set! *subtitle2* (process-spawn subtitle2 :from *pc-dead-pool* :to *display-pool*))
  )


(defmacro set-subtitle-speaker-color! (speaker color)
  "macro for setting a color in *subtitle2-speaker-color-table*"
  `(set! (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker ,speaker)) ,color))

(defun set-subtitle-speaker-colors ()
  "fill the subtitle speaker color table"

  (dotimes (i (pc-subtitle2-speaker max))
    (set! (-> *subtitle2-speaker-color-table* i) (-> *font-work* color-table (font-color red) color 0))
    )
  
  (set-subtitle-speaker-color! computer (static-rgba #x60 #x60 #x60 #x80))
  (set-subtitle-speaker-color! baron    (static-rgba #x60 #x00 #x00 #x80))
  (set-subtitle-speaker-color! ashelin  (static-rgba #x80 #x18 #x18 #x80))
  (set-subtitle-speaker-color! vin      (static-rgba #x38 #x80 #x80 #x80))
  (set-subtitle-speaker-color! oracle   (static-rgba #x80 #x40 #x00 #x80))
  (set-subtitle-speaker-color! brutter  (static-rgba #x58 #x00 #x18 #x80))
  (set-subtitle-speaker-color! guard    (static-rgba #x70 #x00 #x00 #x80))
  (set-subtitle-speaker-color! krew     (static-rgba #x10 #x48 #x10 #x80))
  (set-subtitle-speaker-color! keira    (static-rgba #x00 #x40 #x28 #x80))
  (set-subtitle-speaker-color! tess     (static-rgba #x80 #x80 #x38 #x80))
  ;; temp
  (set-subtitle-speaker-color! samos    (static-rgba #x00 #x80 #x00 #x80))
  (set-subtitle-speaker-color! kor      (static-rgba #x00 #x00 #x80 #x80))
  
  (set-subtitle-speaker-color! guard-a (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker guard)))
  (set-subtitle-speaker-color! guard-b (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker guard)))
  (set-subtitle-speaker-color! keira-before-class-3 (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker keira)))
  (set-subtitle-speaker-color! youngsamos-before-rescue (-> *subtitle2-speaker-color-table* (pc-subtitle2-speaker youngsamos)))
  )

;; fill the subtitle speaker table
(set-subtitle-speaker-colors)

;; start the subtitle2 process when this file loads.
(subtitle2-start)



