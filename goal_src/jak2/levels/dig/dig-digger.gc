;;-*-Lisp-*-
(in-package goal)

;; name: dig-digger.gc
;; name in dgo: dig-digger
;; dgos: DG1, D3A

;; DECOMP BEGINS

(defpartgroup group-dig-clasp-break
  :id 1142
  :duration (seconds 0.05)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 4937 :fade-after (meters 50) :falloff-to (meters 100) :period (seconds 2) :length (seconds 0.035))
    (sp-item 4938 :fade-after (meters 50) :period (seconds 2) :length (seconds 0.017))
    )
  )

(defpart 4937
  :init-specs ((:texture (new 'static 'texture-id :index #x92 :page #xc))
    (:num 8.0 8.0)
    (:scale-x (meters 2.5))
    (:rot-x 4)
    (:scale-y (meters 0.07) (meters 0.03))
    (:r 255.0)
    (:g 128.0 128.0)
    (:b 0.0 128.0)
    (:a 128.0)
    (:omega (degrees 0.01125) (degrees 0.01125))
    (:vel-y (meters 0.1) (meters 0.06666667))
    (:fade-g -2.55 -2.55)
    (:fade-b -8.0)
    (:fade-a -0.64 -0.64)
    (:friction 0.85 0.02)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:func 'sparticle-motion-blur)
    (:conerot-x (degrees 0) (degrees 80))
    (:conerot-y (degrees 0) (degrees 3600))
    )
  )

(defpart 4938
  :init-specs ((:texture (new 'static 'texture-id :index #xbb :page #xc))
    (:num 1.0)
    (:scale-x (meters 3))
    (:rot-x (degrees 0.225))
    (:rot-z (degrees 0) (degrees 3600))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0 128.0)
    (:b 0.0)
    (:a 96.0 16.0)
    (:omega (degrees 1136.25))
    (:scalevel-x (meters 0.08))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -10.2)
    (:fade-a -4.48)
    (:timer (seconds 0.085))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 0.0)
    )
  )

(defpartgroup group-dig-digger-smoke
  :id 1143
  :duration (seconds 0.017)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 16)
  :parts ((sp-item 4939 :fade-after (meters 200) :falloff-to (meters 300))
    (sp-item 4940 :fade-after (meters 200) :flags (bit6))
    (sp-item 4941 :fade-after (meters 200) :flags (bit6))
    )
  )

(defpart 4940
  :init-specs ((:texture (new 'static 'texture-id :index #xca :page #xc))
    (:num 1.0)
    (:y (meters 0) (meters 1))
    (:scale-x (meters 24) (meters 0.1))
    (:rot-x (degrees 6.7500005))
    (:rot-z (degrees -4) (degrees 8))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0 128.0)
    (:b 0.0 128.0)
    (:a 12.0 4.0)
    (:omega (degrees 4518))
    (:fade-a -1.0666667)
    (:timer (seconds 0.05))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 6144.0)
    )
  )

(defpart 4941
  :init-specs ((:texture (new 'static 'texture-id :index #xbb :page #xc))
    (:num 1.0)
    (:y (meters 0))
    (:scale-x (meters 6) (meters 2))
    (:rot-x (degrees 6.7500005))
    (:rot-z (degrees -4) (degrees 8))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0 128.0)
    (:b 0.0 128.0)
    (:a 20.0 4.0)
    (:omega (degrees 4518))
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:userdata 6144.0)
    )
  )

(defpart 4939
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:birth-func 'birth-func-texture-group)
    (:num 0.0 1.0)
    (:scale-x (meters 2) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.06) (meters 0.01))
    (:scalevel-x (meters 0.026666667) (meters 0.02))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a -0.047407407 -0.047407407)
    (:accel-x (meters -0.00066666666) (meters -0.00033333333))
    (:accel-y (meters 0.0001) (meters 0.0001))
    (:friction 0.96)
    (:timer (seconds 8))
    (:flags (sp-cpuinfo-flag-2))
    (:userdata :data (new 'static 'boxed-array :type int32 40 1 0 #xc00000 #xc00000 #xc03300))
    (:next-time (seconds 0.085))
    (:next-launcher 4942)
    )
  )

(defpart 4942
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:next-time (seconds 0.035) (seconds 0.13)) (:next-launcher 4943))
  )

(defpart 4943
  :init-specs ((:scalevel-x (meters 0.013333334) (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.85333335)
    (:fade-g -0.79333335)
    (:fade-b -0.14)
    (:next-time (seconds 0.5))
    (:next-launcher 4944)
    )
  )

(defpart 4944
  :init-specs ((:r 128.0)
    (:g 128.0)
    (:b 128.0)
    (:fade-r 0.0 -0.256)
    (:fade-g :copy fade-r)
    (:fade-b :copy fade-g)
    (:fade-a -0.072)
    )
  )

;; ERROR: Bad vector register dependency: vf4
;; ERROR: Bad vector register dependency: vf5
;; ERROR: Bad vector register dependency: vf6
;; ERROR: Bad vector register dependency: vf30
;; ERROR: Bad vector register dependency: vf31
(defun birth-func-dig-digger-collide ((arg0 sparticle-system)
                             (arg1 sparticle-cpuinfo)
                             (arg2 sprite-vec-data-3d)
                             (arg3 sparticle-launcher)
                             (arg4 sparticle-launch-state)
                             )
  (local-vars (v1-11 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf30 :class vf)
         (vf31 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 5)))
      (.svf (&-> s5-0 0 quad) vf4)
      (.svf (&-> s5-0 1 quad) vf5)
      (.svf (&-> s5-0 2 quad) vf6)
      (.svf (&-> s5-0 3 quad) vf30)
      (.svf (&-> s5-0 4 quad) vf31)
      (let ((s3-0 (the-as object (-> (the-as process (-> arg4 control)) brother)))
            (s4-0 (new 'stack-no-clear 'collide-query))
            )
        (let ((s2-0 (new 'stack-no-clear 'vector)))
          (set! (-> s4-0 start-pos quad) (-> (the-as process-drawable s3-0) root trans quad))
          (set! (-> s4-0 start-pos y) (+ 61440.0 (-> s4-0 start-pos y)))
          (set! (-> s2-0 x) (-> arg1 vel-sxvel x))
          (set! (-> s2-0 z) (-> arg1 vel-sxvel z))
          (vector-normalize! s2-0 1.0)
          (let ((a0-5 (-> s4-0 start-pos)))
            (let ((v1-3 (-> s4-0 start-pos)))
              (let ((a1-5 (* 245760.0 (- 0.2 (- 0.8 (-> arg1 friction))))))
                (.mov vf7 a1-5)
                )
              (.lvf vf5 (&-> s2-0 quad))
              (.lvf vf4 (&-> v1-3 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-5 quad) vf6)
            )
          )
        (set-vector! (-> s4-0 move-dist) 0.0 -81920.0 0.0 1.0)
        (let ((v1-5 s4-0))
          (set! (-> v1-5 radius) 1228.8)
          (set! (-> v1-5 collide-with) (collide-spec backgnd obstacle hit-by-player-list hit-by-others-list))
          (set! (-> v1-5 ignore-process0) (the-as process-tree s3-0))
          (set! (-> v1-5 ignore-process1) #f)
          (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-5 action-mask) (collide-action solid))
          )
        (if (>= (fill-and-probe-using-line-sphere *collide-cache* s4-0) 0.0)
            (set! (-> arg1 user-float) (+ 1024.0 (-> s4-0 best-other-tri intersect y)))
            )
        )
      (.lvf vf4 (&-> s5-0 0 quad))
      (.lvf vf5 (&-> s5-0 1 quad))
      (.lvf vf6 (&-> s5-0 2 quad))
      (.lvf vf30 (&-> s5-0 3 quad))
      (.lvf vf31 (&-> s5-0 4 quad))
      )
    (.mov v1-11 vf31)
    0
    (none)
    )
  )

(defpartgroup group-dig-digger-digging
  :id 1144
  :duration (seconds 0.017)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 64)
  :parts ((sp-item 4945 :falloff-to (meters 200))
    (sp-item 4946 :falloff-to (meters 100))
    (sp-item 4947 :falloff-to (meters 200))
    (sp-item 4948 :falloff-to (meters 200))
    (sp-item 4949 :falloff-to (meters 300))
    )
  )

(defpart 4945
  :init-specs ((:texture (new 'static 'texture-id :page #x973))
    (:birth-func 'birth-func-dig-digger-collide)
    (:num 2.0)
    (:x (meters 8))
    (:scale-x (meters 0.2) (meters 0.3))
    (:rot-z (degrees 0) (degrees 3600))
    (:scale-y (meters 0.2) (meters 0.3))
    (:r 180.0 32.0)
    (:g 150.0 32.0)
    (:b 130.0 32.0)
    (:a 128.0)
    (:vel-x (meters 0.083333336) (meters 0.01))
    (:vel-y (meters 0.16666667) (meters 0.033333335))
    (:scalevel-x (meters -0.00008333333))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:scalevel-y :copy scalevel-x)
    (:accel-y (meters -0.003))
    (:friction 0.95 0.04)
    (:timer (seconds 4))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:func 'check-drop-level-dig-digger-rubble-sparks)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defun check-drop-level-dig-digger-rubble-sparks ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 vector))
  (when (and (< (-> arg2 y) (-> arg1 user-float)) (< (-> arg1 vel-sxvel y) 0.0))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (sp-kill-particle arg0 arg1)
      (set-vector! gp-0 (-> arg2 x) (-> arg1 user-float) (-> arg2 z) 1.0)
      (let ((t9-1 sp-launch-particles-var)
            (a0-2 *sp-particle-system-2d*)
            (a1-2 (-> *part-id-table* 4950))
            (a2-1 *launch-matrix*)
            )
        (set! (-> a2-1 trans quad) (-> gp-0 quad))
        (t9-1 a0-2 a1-2 a2-1 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
        )
      (let ((t9-2 sp-launch-particles-var)
            (a0-3 *sp-particle-system-2d*)
            (a1-3 (-> *part-id-table* 4951))
            (a2-2 *launch-matrix*)
            )
        (set! (-> a2-2 trans quad) (-> gp-0 quad))
        (t9-2 a0-3 a1-3 a2-2 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
        )
      (let ((t9-3 sp-launch-particles-var)
            (a0-4 *sp-particle-system-2d*)
            (a1-4 (-> *part-id-table* 4952))
            (a2-3 *launch-matrix*)
            )
        (set! (-> a2-3 trans quad) (-> gp-0 quad))
        (t9-3 a0-4 a1-4 a2-3 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
        )
      )
    )
  (none)
  )

(defpart 4948
  :init-specs ((:texture (new 'static 'texture-id :index #xbb :page #xc))
    (:num 6.0)
    (:x (meters 9))
    (:y (meters 1) (meters 1))
    (:scale-x (meters 4) (meters 6))
    (:rot-x (degrees 11.25))
    (:rot-z (degrees 0) (degrees 3600))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0 128.0)
    (:b 0.0 128.0)
    (:a 0.0)
    (:fade-g -3.2)
    (:fade-b -3.2)
    (:fade-a 0.8)
    (:timer (seconds 0.135))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-14 glow))
    (:userdata 4096.0)
    (:next-time (seconds 0.067))
    (:next-launcher 4953)
    (:rotate-y (degrees -45) (degrees 135))
    )
  )

(defpart 4953
  :init-specs ((:fade-a -0.8))
  )

(defpart 4946
  :init-specs ((:texture (new 'static 'texture-id :index #x92 :page #xc))
    (:num 3.0)
    (:x (meters 8))
    (:scale-x (meters 0.075) (meters 0.02))
    (:rot-x 4)
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 128.0 128.0)
    (:b 0.0 128.0)
    (:a 128.0)
    (:omega (degrees 0.01125) (degrees 0.01125))
    (:vel-x (meters 0.23333333) (meters 0.1))
    (:vel-y (meters 0.4) (meters 0.033333335))
    (:fade-g -0.85333335)
    (:fade-b -1.7066667)
    (:accel-y (meters -0.003))
    (:friction 0.9 0.04)
    (:timer (seconds 0.335) (seconds 0.165))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:func 'sparticle-motion-blur)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 4947
  :init-specs ((:texture (new 'static 'texture-id :page #x973))
    (:birth-func 'birth-func-texture-group)
    (:num 3.0)
    (:x (meters 8))
    (:scale-x (meters 0.2) (meters 0.3))
    (:rot-x 4)
    (:scale-y (meters 0.2) (meters 0.3))
    (:r 180.0 32.0)
    (:g 150.0 32.0)
    (:b 130.0 32.0)
    (:a 128.0)
    (:omega (degrees 0.0225) (degrees 0.0225))
    (:vel-x (meters 0.083333336) (meters 0.01))
    (:vel-y (meters 0.16666667) (meters 0.033333335))
    (:scalevel-x (meters -0.00008333333))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.14222223 -0.21333334)
    (:accel-y (meters -0.003))
    (:friction 0.95 0.04)
    (:timer (seconds 3))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:userdata
      :data (new 'static 'boxed-array :type int32 40 1 0 -1758461952 -1758461696 -1758461440 -1758461184 -1758460928)
      )
    (:func 'sparticle-motion-blur)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 4949
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 1.0 1.0)
    (:x (meters 9))
    (:scale-x (meters 3) (meters 3))
    (:rot-z (degrees 0) (degrees 3600))
    (:scale-y (meters 3) (meters 3))
    (:r 80.0 16.0)
    (:g 70.0 16.0)
    (:b 70.0 16.0)
    (:a 96.0 32.0)
    (:vel-x (meters 0.11333334))
    (:vel-y (meters 0.16666667) (meters 0.033333335))
    (:scalevel-x (meters 0.01) (meters 0.011666667))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.21333334 -0.21333334)
    (:accel-y (meters -0.00033333333) (meters -0.00066666666))
    (:friction 0.9 0.04)
    (:timer (seconds 8))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 4950
  :init-specs ((:texture (new 'static 'texture-id :page #x973))
    (:birth-func 'birth-func-texture-group)
    (:num 1.0 3.0)
    (:scale-x (meters 0.1) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.2))
    (:r 180.0 32.0)
    (:g 150.0 32.0)
    (:b 130.0 32.0)
    (:a 96.0 32.0)
    (:vel-y (meters 0.006666667) (meters 0.026666667))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:fade-a -0.42666668 -0.85333335)
    (:accel-y (meters -0.00066666666))
    (:timer (seconds 2))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:userdata
      :data (new 'static 'boxed-array :type int32 40 1 0 -1758461952 -1758461696 -1758461440 -1758461184 -1758460928)
      )
    (:conerot-x (degrees 10) (degrees 60))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 4951
  :init-specs ((:texture (new 'static 'texture-id :page #x973))
    (:birth-func 'birth-func-texture-group)
    (:num 1.0 1.0)
    (:scale-x (meters 0.1) (meters 0.2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.2))
    (:r 180.0 32.0)
    (:g 150.0 32.0)
    (:b 130.0 32.0)
    (:a 96.0 32.0)
    (:vel-y (meters 0) (meters 0.04))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:friction 0.94 0.02)
    (:timer (seconds 8))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:userdata
      :data (new 'static 'boxed-array :type int32 40 1 0 -1758461952 -1758461696 -1758461440 -1758461184 -1758460928)
      )
    (:next-time (seconds 0.5) (seconds 0.997))
    (:next-launcher 4954)
    (:conerot-x (degrees 90))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 4954
  :init-specs ((:rotvel-z (degrees 0)) (:fade-a -0.28444445 -0.28444445))
  )

(defpart 4952
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.5 1.0)
    (:scale-x (meters 1) (meters 1))
    (:scale-y (meters 1) (meters 1))
    (:r 80.0 16.0)
    (:g 70.0 16.0)
    (:b 70.0 16.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.013333334) (meters 0.026666667))
    (:scalevel-x (meters 0.0033333334) (meters 0.0016666667))
    (:scalevel-y (meters 0.0033333334) (meters 0.0016666667))
    (:fade-a -0.053333335 -0.053333335)
    (:accel-y (meters 0) (meters 0.00033333333))
    (:friction 0.9 0.05)
    (:timer (seconds 8))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:conerot-x (degrees 70) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defmethod draw hud-dig-clasp ((obj hud-dig-clasp))
  (set-hud-piece-position!
    (the-as hud-sprite (-> obj sprites))
    (the int (+ 457.0 (* 130.0 (-> obj offset))))
    210
    )
  (format (clear (-> obj strings 0 text)) "~D" (-> obj values 0 current))
  (set-as-offset-from! (the-as hud-sprite (-> obj strings 0 pos)) (the-as vector4w (-> obj sprites)) -18 29)
  ((method-of-type hud draw) obj)
  0
  (none)
  )

(defmethod update-values hud-dig-clasp ((obj hud-dig-clasp))
  (set! (-> obj values 0 target) (the int (-> *game-info* counter)))
  ((method-of-type hud update-values) obj)
  0
  (none)
  )

(defmethod init-callback hud-dig-clasp ((obj hud-dig-clasp))
  (set! (-> obj level) (level-get *level* 'dig1))
  (set! (-> obj gui-id)
        (add-process *gui-control* obj (gui-channel hud-middle-right) (gui-action hidden) (-> obj name) 81920.0 0)
        )
  (logior! (-> obj flags) (hud-flags show))
  (set! (-> obj sprites 0 tex) (lookup-texture-by-id (new 'static 'texture-id :page #xb1c)))
  (set! (-> obj sprites 0 flags) (the-as uint 4))
  (set! (-> obj sprites 0 scale-x) 1.2)
  (set! (-> obj sprites 0 scale-y) 1.2)
  (alloc-string-if-needed obj 0)
  (set! (-> obj strings 0 scale) 0.6)
  (set! (-> obj strings 0 flags) (font-flags kerning middle large))
  0
  (none)
  )

(deftype dig-clasp (process-drawable)
  ((b    basic               :offset-assert 200)
   (conn connection-minimap  :offset-assert 204)
   )
  :heap-base #x50
  :method-count-assert 24
  :size-assert         #xd0
  :flag-assert         #x18005000d0
  (:methods
    (broken () _type_ :state 20)
    (break-it () _type_ :state 21)
    (idle () _type_ :state 22)
    (dig-clasp-method-23 (_type_ vector) vector 23)
    )
  )


(defskelgroup skel-dig-clasp dig-clasp dig-clasp-lod0-jg dig-clasp-idle-ja
              ((dig-clasp-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defskelgroup skel-dig-clasp-explode dig-clasp dig-clasp-explode-lod0-jg dig-clasp-explode-idle-ja
              ((dig-clasp-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(defskelgroup skel-dig-clasp-b dig-clasp-b dig-clasp-b-lod0-jg dig-clasp-b-idle-ja
              ((dig-clasp-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(define *dig-clasp-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(defmethod dig-clasp-method-23 dig-clasp ((obj dig-clasp) (arg0 vector))
  (if (-> obj b)
      (vector<-cspace! arg0 (-> obj node-list data 3))
      (vector<-cspace! arg0 (-> obj node-list data 6))
      )
  )

(defstate broken (dig-clasp)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('broken?)
                      #t
                      )
                     )
            )
    )
  :enter (behavior ()
    (when (-> self conn)
      (kill-callback (-> *minimap* engine) (-> self conn))
      (set! (-> self conn) #f)
      )
    (cond
      ((-> self b)
       (ja :group! dig-digger-idle-ja
           :num! (identity (the float (+ (-> (the-as art-joint-anim dig-digger-idle-ja) frames num-frames) -1)))
           )
       (setup-masks (-> self draw) 0 2)
       )
      (else
        (ja :group! dig-digger-idle-ja
            :num! (identity (the float (+ (-> (the-as art-joint-anim dig-digger-idle-ja) frames num-frames) -1)))
            )
        (setup-masks (-> self draw) 0 2)
        )
      )
    (ja-post)
    (none)
    )
  :code (the-as (function none :behavior dig-clasp) sleep-code)
  )

(defstate break-it (dig-clasp)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('broken?)
                      #t
                      )
                     )
            )
    )
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (sound-play "dig-tether-snap")
    (play-communicator-speech! (-> *talker-speech* 191))
    (play-communicator-speech! (-> *talker-speech* 192))
    (cond
      ((-> self b)
       (ja :group! dig-digger-idle-ja :num! min)
       (setup-masks (-> self draw) 0 2)
       )
      (else
        (ja :group! dig-digger-idle-ja :num! min)
        (setup-masks (-> self draw) 0 2)
        )
      )
    (let ((gp-3 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-dig-clasp-explode" (the-as (pointer uint32) #f))
        5
        gp-3
        *dig-clasp-exploder-params*
        :to self
        )
      )
    (none)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (if (nonzero? (-> self part))
        (spawn (-> self part) (dig-clasp-method-23 self (new 'stack-no-clear 'vector)))
        )
    (if (ja-done? 0)
        (go-virtual broken)
        )
    (none)
    )
  :code (the-as (function none :behavior dig-clasp) sleep-code)
  :post (the-as (function none :behavior dig-clasp) ja-post)
  )

(defstate idle (dig-clasp)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('tether-position)
       (dig-clasp-method-23 self (the-as vector (-> event param 0)))
       )
      (('attack)
       (let ((v1-2 (the-as attack-info (-> event param 1))))
         (when (and (logtest? (-> v1-2 mask) (attack-info-mask mode)) (= (-> v1-2 mode) 'board))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 85 (seconds 0.1))
           (go-virtual break-it)
           )
         )
       )
      (('break)
       (go-virtual break-it)
       )
      )
    )
  :enter (behavior ()
    (ja-post)
    (none)
    )
  :code (the-as (function none :behavior dig-clasp) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-clasp ((obj dig-clasp) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 transform-index) 6)
      (set-vector! (-> v1-2 local-sphere) 0.0 -3072.0 0.0 4096.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-clasp" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj draw light-index) (the-as uint 1))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 1142) obj))
  (set! (-> obj b) #f)
  (set! (-> obj conn) (add-icon! *minimap* obj (the-as uint 16) (the-as int #f) (the-as vector #t) 0))
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object obj broken))
      (go (method-of-object obj idle))
      )
  (none)
  )

(deftype dig-clasp-b (dig-clasp)
  ()
  :heap-base #x50
  :method-count-assert 24
  :size-assert         #xd0
  :flag-assert         #x18005000d0
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-clasp-b ((obj dig-clasp-b) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (when (not (task-node-closed? (game-task-node dig-knock-down-resolution)))
    (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
      (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
        (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-2 transform-index) 3)
        (set-vector! (-> v1-2 local-sphere) 0.0 -3072.0 0.0 4096.0)
        (set! (-> s4-0 total-prims) (the-as uint 1))
        (set! (-> s4-0 root-prim) v1-2)
        )
      (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
      (let ((v1-5 (-> s4-0 root-prim)))
        (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
        (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
        )
      (set! (-> obj root) s4-0)
      )
    (process-drawable-from-entity! obj arg0)
    (initialize-skeleton
      obj
      (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-clasp-b" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (set! (-> obj draw light-index) (the-as uint 1))
    (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 1142) obj))
    (set! (-> obj b) (the-as basic #t))
    (set! (-> obj conn) (add-icon! *minimap* obj (the-as uint 16) (the-as int #f) (the-as vector #t) 0))
    (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
        (go (method-of-object obj broken))
        (go (method-of-object obj idle))
        )
    )
  (none)
  )

(deftype dig-tether-chain (structure)
  ((position  vector    :inline :offset-assert   0)
   (velocity  vector    :inline :offset-assert  16)
   (joint-mod joint-mod         :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  )


(deftype dig-tether (process-drawable)
  ((clasp             entity-actor                  :offset-assert 200)
   (clasp-info-ok     symbol                        :offset-assert 204)
   (clasp-pos         vector              :inline   :offset-assert 208)
   (digger-pos        vector              :inline   :offset-assert 224)
   (digger-vertical   vector              :inline   :offset-assert 240)
   (frame             oscillating-float   :inline   :offset-assert 256)
   (frame-kicker      delayed-rand-float  :inline   :offset-assert 280)
   (old-dist          float                         :offset-assert 308)
   (chain-joints      dig-tether-chain    8 :inline :offset-assert 320)
   (chain-offset-rand delayed-rand-vector :inline   :offset-assert 704)
   (chain-offset      oscillating-vector  :inline   :offset-assert 752)
   (joint-one         joint-mod                     :offset-assert 812)
   (snapped-look      lod-set             :inline   :offset-assert 816)
   )
  :heap-base #x2f0
  :method-count-assert 25
  :size-assert         #x361
  :flag-assert         #x1902f00361
  (:methods
    (broken () _type_ :state 20)
    (idle () _type_ :state 21)
    (dig-tether-method-22 (_type_) none 22)
    (dig-tether-method-23 (_type_) none 23)
    (dig-tether-method-24 (_type_) none 24)
    )
  )


(defskelgroup skel-dig-tether-unsnapped dig-tether dig-tether-unsnapped-lod0-jg dig-tether-idle-ja
              ((dig-tether-unsnapped-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

(defskelgroup skel-dig-tether-snapped dig-tether dig-tether-snapped-lod0-jg dig-tether-idle-ja
              ((dig-tether-snapped-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

(defmethod dig-tether-method-22 dig-tether ((obj dig-tether))
  (with-pp
    (when (-> obj clasp)
      (let* ((s4-0 (-> obj clasp extra process))
             (s5-0 (if (type? s4-0 dig-clasp)
                       s4-0
                       )
                   )
             (a1-1 (new 'stack-no-clear 'event-message-block))
             )
        (set! (-> a1-1 from) (process->ppointer pp))
        (set! (-> a1-1 num-params) 0)
        (set! (-> a1-1 message) 'broken?)
        (cond
          ((or (send-event-function s5-0 a1-1)
               (logtest? (-> obj clasp extra perm status) (entity-perm-status subtask-complete))
               )
           (go (method-of-object obj broken))
           )
          (s5-0
            (send-event s5-0 'tether-position (-> obj clasp-pos))
            (set! (-> obj clasp-info-ok) #t)
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod dig-tether-method-23 dig-tether ((obj dig-tether))
  (set-params! (-> obj chain-offset-rand) 75 150 2048.0 204.8)
  (set-params! (-> obj chain-offset) (the-as vector #f) 4.096 20.48 0.9)
  (mode-set! (-> obj joint-one) (joint-mod-mode joint-set-world))
  (dotimes (s5-0 7)
    (cond
      ((-> obj clasp-info-ok)
       (vector<-cspace! (the-as vector (-> obj chain-joints s5-0)) (-> obj chain-joints s5-0 joint-mod joint))
       )
      (else
        (set! (-> obj chain-joints s5-0 position quad) (-> obj root trans quad))
        (set! (-> obj chain-joints s5-0 position y)
              (- (-> obj chain-joints s5-0 position y) (* 4096.0 (the float s5-0)))
              )
        )
      )
    ;; original
    ;; (vector-reset! (+ (the-as uint (-> obj chain-joints 0 velocity)) (* 48 s5-0)))
    (vector-reset! (-> obj chain-joints s5-0 velocity)) ;; hack
    (mode-set! (-> obj chain-joints s5-0 joint-mod) (joint-mod-mode joint-set-world))
    )
  (set! (-> obj chain-joints 7 position quad) (-> obj chain-joints 6 position quad))
  (vector-reset! (-> obj chain-joints 7 velocity))
  (lods-assign! (-> obj draw) (-> obj snapped-look))
  (none)
  )

(defmethod dig-tether-method-24 dig-tether ((obj dig-tether))
  (local-vars (sv-144 dig-tether-chain) (sv-160 vector))
  (update-with-delay! (-> obj chain-offset-rand))
  (update! (-> obj chain-offset) (-> obj chain-offset-rand value))
  (let ((s5-0 (new 'stack-no-clear 'matrix))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s4-0 quad) (-> obj root trans quad))
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (f30-0 0.2)
          (s2-0 (-> obj chain-offset))
          (f28-0 0.1)
          (s1-0 (new 'stack-no-clear 'vector))
          )
      (vector-! (-> s5-0 vector 2) (the-as vector (-> obj chain-joints)) (-> obj root trans))
      (vector-normalize! (-> s5-0 vector 2) 1.0)
      (vector-cross! (the-as vector (-> s5-0 vector)) (-> obj digger-vertical) (-> s5-0 vector 2))
      (vector-normalize! (the-as vector (-> s5-0 vector)) 1.0)
      (vector-cross! (-> s5-0 vector 1) (-> s5-0 vector 2) (the-as vector (-> s5-0 vector)))
      (matrix->quaternion (-> obj root quat) s5-0)
      (set! (-> obj joint-one trans quad) (-> obj root trans quad))
      (quaternion-copy! (-> obj joint-one quat) (-> obj root quat))
      (set! (-> s3-0 quad) (-> s5-0 vector 1 quad))
      (dotimes (s0-0 8)
        (set! sv-144 (-> obj chain-joints s0-0))
        (set! sv-160 (new 'stack-no-clear 'vector))
        (let ((v1-23 (-> sv-144 position quad)))
          (set! (-> sv-160 quad) v1-23)
          )
        (set! (-> sv-160 y) (+ -2048.0 (-> sv-160 y)))
        (vector+float*! sv-160 sv-160 (the-as vector s2-0) f28-0)
        (set! f28-0 (fmin 1.0 (+ 0.2 f28-0)))
        (when (< s0-0 7)
          (vector+float*!
            sv-160
            sv-160
            (the-as vector (+ (the-as uint (-> obj chain-joints 0 velocity)) (* 48 (+ s0-0 1))))
            f30-0
            )
          (set! f30-0 (fmin 0.9 (+ 0.2 f30-0)))
          )
        (vector-! s1-0 sv-160 s4-0)
        (vector-normalize! s1-0 12288.0)
        (vector+! sv-160 s1-0 s4-0)
        (vector-! s1-0 sv-160 (-> obj digger-pos))
        (vector-flatten! s1-0 s1-0 (-> obj digger-vertical))
        (let ((f0-6 (vector-normalize-ret-len! s1-0 1.0)))
          (if (< f0-6 73728.0)
              (vector+float*! sv-160 sv-160 s1-0 (- 73728.0 f0-6))
              )
          )
        (vector-! (-> sv-144 velocity) sv-160 (-> sv-144 position))
        (vector-float*! (-> sv-144 velocity) (-> sv-144 velocity) 0.75)
        (let ((f0-9 (vector-length (-> sv-144 velocity))))
          (if (< 6144.0 f0-9)
              (vector-float*! (-> sv-144 velocity) (-> sv-144 velocity) (/ 2048.0 f0-9))
              )
          )
        (vector+! sv-160 (-> sv-144 position) (-> sv-144 velocity))
        (set! (-> sv-144 position quad) (-> sv-160 quad))
        (if (-> sv-144 joint-mod)
            (set! (-> sv-144 joint-mod trans quad) (-> sv-160 quad))
            )
        (when (< s0-0 7)
          (vector-! (-> s5-0 vector 2) (the-as vector (-> obj chain-joints (+ s0-0 1))) sv-160)
          (vector-normalize! (-> s5-0 vector 2) 1.0)
          (vector-cross! (the-as vector (-> s5-0 vector)) s3-0 (-> s5-0 vector 2))
          (vector-normalize! (the-as vector (-> s5-0 vector)) 1.0)
          (vector-cross! (-> s5-0 vector 1) (-> s5-0 vector 2) (the-as vector (-> s5-0 vector)))
          (matrix->quaternion (-> sv-144 joint-mod quat) s5-0)
          (set! (-> s3-0 quad) (-> s5-0 vector 1 quad))
          )
        (set! (-> s4-0 quad) (-> sv-160 quad))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch vector vs object.
(defbehavior dig-tether-handler dig-tether ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (the-as object (case arg2
                   (('set-pos)
                    (set! (-> self root trans quad) (-> (the-as vector (-> arg3 param 0)) quad))
                    (set! (-> self digger-pos quad) (-> (the-as vector (-> arg3 param 1)) quad))
                    (let ((v0-0 (-> self digger-vertical)))
                      (set! (-> v0-0 quad) (-> (the-as vector (-> arg3 param 2)) quad))
                      v0-0
                      )
                    )
                   )
          )
  )

(defstate broken (dig-tether)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('broken?)
       #t
       )
      (else
        (dig-tether-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (dig-tether-method-23 self)
    (none)
    )
  :trans (behavior ()
    (dig-tether-method-24 self)
    (none)
    )
  :code (the-as (function none :behavior dig-tether) sleep-code)
  :post (the-as (function none :behavior dig-tether) ja-post)
  )

(defstate idle (dig-tether)
  :virtual #t
  :event dig-tether-handler
  :enter (behavior ()
    (set! (-> self clasp-info-ok) #f)
    (set-params! (-> self frame) 0.5 0.01 0.02 0.97)
    (set-params! (-> self frame-kicker) 9 30 0.4)
    (set! (-> self old-dist) 0.0)
    (none)
    )
  :trans (behavior ()
    (dig-tether-method-22 self)
    (when (-> self clasp-info-ok)
      (let* ((v1-4 (vector-! (new 'stack-no-clear 'vector) (-> self clasp-pos) (-> self root trans)))
             (f30-0 (vector-length v1-4))
             )
        (let ((gp-0 (new 'stack-no-clear 'matrix)))
          (vector-float*! (-> gp-0 vector 2) v1-4 (/ 1.0 f30-0))
          (set-vector! (-> gp-0 vector 0) (-> gp-0 vector 2 z) 0.0 (- (-> gp-0 vector 2 x)) 1.0)
          (vector-normalize! (the-as vector (-> gp-0 vector)) 1.0)
          (vector-cross! (-> gp-0 vector 1) (-> gp-0 vector 2) (the-as vector (-> gp-0 vector)))
          (vector-reset! (-> gp-0 trans))
          (set! (-> gp-0 vector 0 w) 0.0)
          (set! (-> gp-0 vector 1 w) 0.0)
          (set! (-> gp-0 vector 2 w) 0.0)
          (matrix->quaternion (-> self root quat) gp-0)
          )
        (set! (-> self root scale z) (* 0.000003937752 f30-0))
        (when (!= (-> self old-dist) 0.0)
          (let ((f2-0 (fabs (- f30-0 (-> self old-dist)))))
            (set! (-> self frame target) (fmin 1.0 (fmax 0.0 (* 0.0008719308 (- 573.44 f2-0)))))
            )
          )
        (set! (-> self old-dist) f30-0)
        )
      (update! (-> self frame-kicker))
      (update! (-> self frame) (-> self frame-kicker value))
      (ja :num-func num-func-identity :frame-num (* 10.0 (-> self frame value)))
      )
    (none)
    )
  :code (the-as (function none :behavior dig-tether) sleep-code)
  :post (the-as (function none :behavior dig-tether) ja-post)
  )

;; WARN: Return type mismatch process-drawable vs dig-tether.
(defmethod relocate dig-tether ((obj dig-tether) (arg0 int))
  (if (nonzero? (-> obj joint-one))
      (&+! (-> obj joint-one) arg0)
      )
  (dotimes (v1-4 7)
    (if (nonzero? (-> obj chain-joints v1-4 joint-mod))
        (&+! (-> obj chain-joints v1-4 joint-mod) arg0)
        )
    )
  (the-as dig-tether ((method-of-type process-drawable relocate) obj arg0))
  )

;; WARN: Return type mismatch object vs none.
(defbehavior dig-tether-init-by-other dig-tether ((arg0 vector) (arg1 entity))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-tether-snapped" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> self draw light-index) (the-as uint 1))
  (set! (-> self clasp) (the-as entity-actor arg1))
  (set! (-> self root pause-adjust-distance) 819200.0)
  (set! (-> self joint-one) (new 'process 'joint-mod (joint-mod-mode flex-blend) self 3))
  (set! (-> self joint-one track-mode) (track-mode no-scale))
  (dotimes (gp-1 7)
    (set! (-> self chain-joints gp-1 joint-mod)
          (new 'process 'joint-mod (joint-mod-mode flex-blend) self (+ gp-1 4))
          )
    (set! (-> self chain-joints gp-1 joint-mod track-mode) (track-mode no-scale))
    )
  (set! (-> self chain-joints 7 joint-mod) #f)
  (setup-lods!
    (-> self snapped-look)
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-tether-snapped" (the-as (pointer uint32) #f)))
    (-> self draw art-group)
    (-> self entity)
    )
  (go-virtual idle)
  (none)
  )

(deftype dig-digger-tether-info (structure)
  ((rp       int32   :offset-assert   0)
   (handle   handle  :offset-assert   8)
   (broken-x float   :offset-assert  16)
   (broken-z float   :offset-assert  20)
   )
  :method-count-assert 9
  :size-assert         #x18
  :flag-assert         #x900000018
  )


(deftype dig-digger (process-drawable)
  ((actor-group       (pointer actor-group)               :offset-assert 200)
   (actor-group-count int32                               :offset-assert 204)
   (tethers           dig-digger-tether-info   24 :inline :offset-assert 208)
   (vertical          oscillating-vector       :inline    :offset-assert 976)
   (vertical-rand     delayed-rand-vector      :inline    :offset-assert 1040)
   (start-y           float                               :offset-assert 1088)
   (y-offset          bouncing-float           :inline    :offset-assert 1092)
   (y-offset-kicker   delayed-rand-float       :inline    :offset-assert 1136)
   (twist             oscillating-float        :inline    :offset-assert 1164)
   (twist-kicker      delayed-rand-float       :inline    :offset-assert 1192)
   (smoke-part        sparticle-launch-control            :offset-assert 1220)
   (motor-sound       sound-id                            :offset-assert 1224)
   (bit-sound         sound-id                            :offset-assert 1228)
   (movie-handle      handle                              :offset-assert 1232)
   (hud-counter       handle                              :offset-assert 1240)
   (speech-time       time-frame                          :offset-assert 1248)
   (speech-count      int32                               :offset-assert 1256)
   )
  :heap-base #x470
  :method-count-assert 25
  :size-assert         #x4ec
  :flag-assert         #x19047004ec
  (:methods
    (idle () _type_ :state 20)
    (hidden () _type_ :state 21)
    (dig-digger-method-22 (_type_ int) entity 22)
    (dig-digger-method-23 (_type_) none 23)
    (dig-digger-method-24 (_type_) none 24)
    )
  )


(defskelgroup skel-dig-digger dig-digger dig-digger-lod0-jg dig-digger-idle-ja
              ((dig-digger-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 36 0 40)
              :origin-joint-index 3
              )

(defmethod dig-digger-method-22 dig-digger ((obj dig-digger) (arg0 int))
  (if (and (> (-> obj actor-group-count) 0) (< arg0 (-> obj actor-group 0 length)))
      (-> obj actor-group 0 data arg0 actor)
      (the-as entity #f)
      )
  )

(defmethod dig-digger-method-23 dig-digger ((obj dig-digger))
  (dotimes (s5-0 24)
    (let ((s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data (-> obj tethers s5-0 rp))))
          (s3-0 (dig-digger-method-22 obj s5-0))
          )
      (if (and s3-0 (not (handle->process (-> obj tethers s5-0 handle))))
          (set! (-> obj tethers s5-0 handle) (ppointer->handle (process-spawn dig-tether s4-0 s3-0 :to obj)))
          )
      )
    )
  0
  (none)
  )

(defmethod dig-digger-method-24 dig-digger ((obj dig-digger))
  (set! (-> obj vertical target x) 0.0)
  (set! (-> obj vertical target z) 0.0)
  (let ((s4-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (the-as vector (-> obj vertical)) 1.0))
        (s5-0 0)
        )
    (dotimes (s3-0 24)
      (let* ((s2-0 (-> obj tethers s3-0))
             (s1-0 (handle->process (-> s2-0 handle)))
             )
        (cond
          (s1-0
            (let ((v1-10 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data (-> obj tethers s3-0 rp)))))
              (send-event s1-0 'set-pos v1-10 (-> obj root trans) s4-0)
              )
            (cond
              ((send-event s1-0 'broken?)
               (+! (-> obj vertical target x) (-> s2-0 broken-x))
               (+! (-> obj vertical target z) (-> s2-0 broken-z))
               )
              (else
                (+! s5-0 1)
                )
              )
            )
          (else
            (+! (-> obj vertical target x) (-> s2-0 broken-x))
            (+! (-> obj vertical target z) (-> s2-0 broken-z))
            )
          )
        )
      )
    (set! (-> *game-info* counter) (the float s5-0))
    (when (and (= s5-0 24)
               (>= (- (current-time) (-> obj speech-time)) (seconds 20))
               *target*
               (and (>= 409600.0 (vector-vector-distance (-> obj root trans) (-> *target* control trans)))
                    (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                    )
               )
      (let ((v1-37 (logand (-> obj speech-count) 1)))
        (cond
          ((zero? v1-37)
           (talker-spawn-func (-> *talker-speech* 191) *entity-pool* (target-pos 0) (the-as region #f))
           (if (and *target* (not (logtest? (focus-status board) (-> *target* focus-status))))
               (talker-spawn-func (-> *talker-speech* 115) *entity-pool* (target-pos 0) (the-as region #f))
               )
           )
          ((= v1-37 1)
           (talker-spawn-func (-> *talker-speech* 192) *entity-pool* (target-pos 0) (the-as region #f))
           )
          )
        )
      (set! (-> obj speech-time) (current-time))
      (+! (-> obj speech-count) 1)
      )
    (cond
      ((zero? s5-0)
       (send-event (handle->process (-> obj hud-counter)) 'hide-and-die)
       (set! (-> obj hud-counter) (the-as handle #f))
       (when (= (-> obj movie-handle) #f)
         (set! (-> obj movie-handle)
               (ppointer->handle (process-spawn scene-player :init scene-player-init "dig-digger-explode" #t #f))
               )
         (if (handle->process (-> obj movie-handle))
             (cleanup-for-death obj)
             )
         )
       )
      ((>= 4 s5-0)
       (script-eval '(want-anim "dig-digger-explode"))
       )
      )
    )
  0
  (none)
  )

(defstate idle (dig-digger)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (when ((method-of-type touching-shapes-entry prims-touching?)
              (the-as touching-shapes-entry (-> event param 0))
              (the-as collide-shape (-> self root))
              (the-as uint 1)
              )
         (let ((a0-7 (if (type? proc process-focusable)
                         proc
                         )
                     )
               )
           (when a0-7
             (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
               (set! (-> a1-4 from) (process->ppointer self))
               (set! (-> a1-4 num-params) 2)
               (set! (-> a1-4 message) 'attack)
               (set! (-> a1-4 param 0) (-> event param 0))
               (let ((a2-3 (new 'static 'attack-info :mask (attack-info-mask id))))
                 (let* ((v1-7 *game-info*)
                        (a3-2 (+ (-> v1-7 attack-id) 1))
                        )
                   (set! (-> v1-7 attack-id) a3-2)
                   (set! (-> a2-3 id) a3-2)
                   )
                 (set! (-> a1-4 param 1) (the-as uint a2-3))
                 )
               (if (send-event-function a0-7 a1-4)
                   #f
                   )
               )
             )
           )
         )
       )
      (('hide)
       (go-virtual hidden)
       )
      )
    )
  :enter (behavior ()
    (set-params! (-> self vertical) (new 'static 'vector :y 16.0) 0.01 0.1 0.9)
    (set-params! (-> self vertical-rand) 15 75 1.0 0.0)
    (set-params! (-> self y-offset) 0.0 1.0 0.0 0.7 0.08 0.3 0.97)
    (set-params! (-> self y-offset-kicker) 18 30 1.0)
    (set-params! (-> self twist) 0.0 0.01 0.1 0.9)
    (set-params! (-> self twist-kicker) 24 75 1.0)
    (ja-post)
    (dig-digger-method-23 self)
    (set! (-> self motor-sound) (new-sound-id))
    (set! (-> self bit-sound) (new-sound-id))
    (none)
    )
  :exit (behavior ()
    (sound-stop (-> self motor-sound))
    (sound-stop (-> self bit-sound))
    (send-event (handle->process (-> self hud-counter)) 'hide-and-die)
    (set! (-> self hud-counter) (the-as handle #f))
    (none)
    )
  :trans (behavior ()
    (let ((f0-0 (vector-vector-distance-squared (ear-trans 0) (-> self root trans)))
          (f1-0 1228800.0)
          )
      (when (< f0-0 (* f1-0 f1-0))
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (vector<-cspace! gp-1 (-> self node-list data 29))
          (sound-play "digger-motor" :id (-> self motor-sound) :position gp-1)
          )
        (sound-play "digger-bit" :id (-> self bit-sound) :position (-> self root trans))
        )
      )
    (ja :num! (loop!))
    (update-with-delay! (-> self vertical-rand))
    (update! (-> self vertical) (-> self vertical-rand value))
    (update-and-clear! (-> self twist-kicker))
    (if (!= (-> self twist-kicker value) 0.0)
        (set! (-> self twist-kicker value) 1.0)
        )
    (update! (-> self twist) (fabs (-> self twist-kicker value)))
    (let ((gp-2 (new 'stack-no-clear 'matrix)))
      (vector-normalize-copy! (-> gp-2 vector 1) (the-as vector (-> self vertical)) 1.0)
      (set-vector!
        (-> gp-2 vector 0)
        (cos (* 32768.0 (-> self twist value)))
        0.0
        (sin (* 32768.0 (-> self twist value)))
        1.0
        )
      (vector-cross! (-> gp-2 vector 2) (the-as vector (-> gp-2 vector)) (-> gp-2 vector 1))
      (vector-normalize! (-> gp-2 vector 2) 1.0)
      (vector-cross! (the-as vector (-> gp-2 vector)) (-> gp-2 vector 1) (-> gp-2 vector 2))
      (vector-reset! (-> gp-2 trans))
      (set! (-> gp-2 vector 0 w) 0.0)
      (set! (-> gp-2 vector 1 w) 0.0)
      (set! (-> gp-2 vector 2 w) 0.0)
      (matrix->quaternion (-> self root quat) gp-2)
      )
    (update! (-> self y-offset-kicker))
    (update! (-> self y-offset) (-> self y-offset-kicker value))
    (set! (-> self root trans y) (+ (-> self start-y) (* 4096.0 (-> self y-offset osc value))))
    (when (nonzero? (-> self smoke-part))
      (spawn-with-cspace (-> self smoke-part) (-> self node-list data 28))
      (spawn-with-cspace (-> self smoke-part) (-> self node-list data 29))
      (spawn-with-cspace (-> self smoke-part) (-> self node-list data 30))
      (spawn-with-cspace (-> self smoke-part) (-> self node-list data 31))
      )
    (if (nonzero? (-> self part))
        (spawn (-> self part) (-> self root trans))
        )
    (none)
    )
  :code (the-as (function none :behavior dig-digger) sleep-code)
  :post (behavior ()
    (transform-post)
    (dig-digger-method-24 self)
    (none)
    )
  )

(defstate hidden (dig-digger)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type)
          (a0-1 'explode)
          )
      (the-as object (if (= v1-0 a0-1)
                         (set-dig1-explosion! (the-as float a0-1))
                         )
              )
      )
    )
  :enter (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (none)
    )
  :code (the-as (function none :behavior dig-digger) sleep-code)
  )

(defmethod deactivate dig-digger ((obj dig-digger))
  (if (nonzero? (-> obj smoke-part))
      (kill-and-free-particles (-> obj smoke-part))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs dig-digger.
(defmethod relocate dig-digger ((obj dig-digger) (arg0 int))
  (when (nonzero? (-> obj smoke-part))
    (if (nonzero? (-> obj smoke-part))
        (&+! (-> obj smoke-part) arg0)
        )
    )
  (the-as dig-digger ((method-of-type process-drawable relocate) obj arg0))
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-digger ((obj dig-digger) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 10) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 11))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid deadly))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 143360.0 0.0 159744.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 9) (the-as uint 1))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid deadly))
      (set! (-> v1-13 transform-index) 3)
      (set-vector! (-> v1-13 local-sphere) 0.0 36864.0 0.0 65536.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 172032.0 0.0 86016.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 151552.0 0.0 86016.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 3)
      (set-vector! (-> v1-19 local-sphere) 0.0 110592.0 0.0 69632.0)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-21 prim-core action) (collide-action solid))
      (set! (-> v1-21 transform-index) 3)
      (set-vector! (-> v1-21 local-sphere) 0.0 73728.0 0.0 65536.0)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-23 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-23 prim-core action) (collide-action solid))
      (set! (-> v1-23 transform-index) 3)
      (set-vector! (-> v1-23 local-sphere) 0.0 266240.0 0.0 40960.0)
      )
    (let ((v1-25 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-25 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-25 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-25 prim-core action) (collide-action solid))
      (set! (-> v1-25 transform-index) 3)
      (set-vector! (-> v1-25 local-sphere) 16384.0 249856.0 -16384.0 20480.0)
      )
    (let ((v1-27 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-27 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-27 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-27 prim-core action) (collide-action solid))
      (set! (-> v1-27 transform-index) 3)
      (set-vector! (-> v1-27 local-sphere) 8192.0 245760.0 24576.0 16384.0)
      )
    (let ((v1-29 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 7) (the-as uint 0))))
      (set! (-> v1-29 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-29 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-29 prim-core action) (collide-action solid))
      (set! (-> v1-29 transform-index) 3)
      (set-vector! (-> v1-29 local-sphere) -61440.0 102400.0 0.0 20480.0)
      )
    (let ((v1-31 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 8) (the-as uint 0))))
      (set! (-> v1-31 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-31 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-31 prim-core action) (collide-action solid))
      (set! (-> v1-31 transform-index) 3)
      (set-vector! (-> v1-31 local-sphere) -57344.0 81920.0 0.0 16384.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-34 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-34 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-34 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (set! (-> obj root pause-adjust-distance) 819200.0)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-digger" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj draw light-index) (the-as uint 1))
  (logior! (-> obj skel status) (joint-control-status sync-math))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-46 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-46 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-46))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (dotimes (v1-52 24)
    (set! (-> obj tethers v1-52 handle) (the-as handle #f))
    (let ((a0-77 v1-52))
      (cond
        ((zero? a0-77)
         (set! (-> obj tethers v1-52 rp) 18)
         (set! (-> obj tethers v1-52 broken-x) 0.0)
         (set! (-> obj tethers v1-52 broken-z) -1.0)
         )
        ((= a0-77 1)
         (set! (-> obj tethers v1-52 rp) 16)
         (set! (-> obj tethers v1-52 broken-x) 0.0)
         (set! (-> obj tethers v1-52 broken-z) -1.0)
         )
        ((= a0-77 2)
         (set! (-> obj tethers v1-52 rp) 17)
         (set! (-> obj tethers v1-52 broken-x) 0.0)
         (set! (-> obj tethers v1-52 broken-z) -1.0)
         )
        ((= a0-77 3)
         (set! (-> obj tethers v1-52 rp) 24)
         (set! (-> obj tethers v1-52 broken-x) -1.0)
         (set! (-> obj tethers v1-52 broken-z) 0.0)
         )
        ((= a0-77 4)
         (set! (-> obj tethers v1-52 rp) 22)
         (set! (-> obj tethers v1-52 broken-x) -1.0)
         (set! (-> obj tethers v1-52 broken-z) 0.0)
         )
        ((= a0-77 5)
         (set! (-> obj tethers v1-52 rp) 23)
         (set! (-> obj tethers v1-52 broken-x) -1.0)
         (set! (-> obj tethers v1-52 broken-z) 0.0)
         )
        ((= a0-77 6)
         (set! (-> obj tethers v1-52 rp) 6)
         (set! (-> obj tethers v1-52 broken-x) 0.0)
         (set! (-> obj tethers v1-52 broken-z) 1.0)
         )
        ((= a0-77 7)
         (set! (-> obj tethers v1-52 rp) 4)
         (set! (-> obj tethers v1-52 broken-x) 0.0)
         (set! (-> obj tethers v1-52 broken-z) 1.0)
         )
        ((= a0-77 8)
         (set! (-> obj tethers v1-52 rp) 5)
         (set! (-> obj tethers v1-52 broken-x) 0.0)
         (set! (-> obj tethers v1-52 broken-z) 1.0)
         )
        ((= a0-77 9)
         (set! (-> obj tethers v1-52 rp) 12)
         (set! (-> obj tethers v1-52 broken-x) 1.0)
         (set! (-> obj tethers v1-52 broken-z) 0.0)
         )
        ((= a0-77 10)
         (set! (-> obj tethers v1-52 rp) 10)
         (set! (-> obj tethers v1-52 broken-x) 1.0)
         (set! (-> obj tethers v1-52 broken-z) 0.0)
         )
        ((= a0-77 11)
         (set! (-> obj tethers v1-52 rp) 11)
         (set! (-> obj tethers v1-52 broken-x) 1.0)
         (set! (-> obj tethers v1-52 broken-z) 0.0)
         )
        ((= a0-77 12)
         (set! (-> obj tethers v1-52 rp) 25)
         (set! (-> obj tethers v1-52 broken-x) -0.707)
         (set! (-> obj tethers v1-52 broken-z) 0.707)
         )
        ((= a0-77 13)
         (set! (-> obj tethers v1-52 rp) 26)
         (set! (-> obj tethers v1-52 broken-x) -0.707)
         (set! (-> obj tethers v1-52 broken-z) 0.707)
         )
        ((= a0-77 14)
         (set! (-> obj tethers v1-52 rp) 27)
         (set! (-> obj tethers v1-52 broken-x) -0.707)
         (set! (-> obj tethers v1-52 broken-z) 0.707)
         )
        ((= a0-77 15)
         (set! (-> obj tethers v1-52 rp) 19)
         (set! (-> obj tethers v1-52 broken-x) -0.707)
         (set! (-> obj tethers v1-52 broken-z) -0.707)
         )
        ((= a0-77 16)
         (set! (-> obj tethers v1-52 rp) 21)
         (set! (-> obj tethers v1-52 broken-x) -0.707)
         (set! (-> obj tethers v1-52 broken-z) -0.707)
         )
        ((= a0-77 17)
         (set! (-> obj tethers v1-52 rp) 20)
         (set! (-> obj tethers v1-52 broken-x) -0.707)
         (set! (-> obj tethers v1-52 broken-z) -0.707)
         )
        ((= a0-77 18)
         (set! (-> obj tethers v1-52 rp) 14)
         (set! (-> obj tethers v1-52 broken-x) 0.707)
         (set! (-> obj tethers v1-52 broken-z) -0.707)
         )
        ((= a0-77 19)
         (set! (-> obj tethers v1-52 rp) 13)
         (set! (-> obj tethers v1-52 broken-x) 0.707)
         (set! (-> obj tethers v1-52 broken-z) -0.707)
         )
        ((= a0-77 20)
         (set! (-> obj tethers v1-52 rp) 15)
         (set! (-> obj tethers v1-52 broken-x) 0.707)
         (set! (-> obj tethers v1-52 broken-z) -0.707)
         )
        ((= a0-77 21)
         (set! (-> obj tethers v1-52 rp) 8)
         (set! (-> obj tethers v1-52 broken-x) 0.707)
         (set! (-> obj tethers v1-52 broken-z) 0.707)
         )
        ((= a0-77 22)
         (set! (-> obj tethers v1-52 rp) 7)
         (set! (-> obj tethers v1-52 broken-x) 0.707)
         (set! (-> obj tethers v1-52 broken-z) 0.707)
         )
        ((= a0-77 23)
         (set! (-> obj tethers v1-52 rp) 9)
         (set! (-> obj tethers v1-52 broken-x) 0.707)
         (set! (-> obj tethers v1-52 broken-z) 0.707)
         )
        (else
          (set! (-> obj tethers v1-52 rp) 3)
          (set! (-> obj tethers v1-52 broken-x) 0.0)
          (set! (-> obj tethers v1-52 broken-z) 0.0)
          )
        )
      )
    )
  (set! (-> obj start-y) (-> obj root trans y))
  (set! (-> obj smoke-part) (create-launch-control (-> *part-group-id-table* 1143) obj))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 1144) obj))
  (set! (-> obj motor-sound) (new 'static 'sound-id))
  (set! (-> obj bit-sound) (new 'static 'sound-id))
  (set! (-> obj movie-handle) (the-as handle #f))
  (set! (-> obj hud-counter) (ppointer->handle (process-spawn hud-dig-clasp :init hud-init-by-other :to obj)))
  (go (method-of-object obj idle))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defun-debug bustclasp ((arg0 int))
  (format (clear *temp-string*) "dig-clasp-~S" arg0)
  (let ((v1-0 (entity-by-name *temp-string*)))
    (when v1-0
      (send-event
        (if v1-0
            (-> v1-0 extra process)
            )
        'break
        )
      (format #t "found clasp ~D~%" arg0)
      )
    )
  (none)
  )
