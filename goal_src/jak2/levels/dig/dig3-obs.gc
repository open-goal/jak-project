;;-*-Lisp-*-
(in-package goal)

;; name: dig3-obs.gc
;; name in dgo: dig3-obs
;; dgos: DG1, D3A

;; DECOMP BEGINS

(defpartgroup group-dig-spikey-sphere-bounce
  :id 1148
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 4978) (sp-item 4979) (sp-item 4980))
  )

(defpart 4978
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 16.0)
    (:scale-x (meters 3) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 96.0)
    (:g :copy r)
    (:b :copy g)
    (:a 16.0 32.0)
    (:vel-y (meters 0.026666667) (meters 0.06666667))
    (:scalevel-x (meters 0.0033333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters -0.00033333333))
    (:friction 0.92 0.03)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:conerot-x (degrees 65) (degrees 10))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 4980
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 16.0)
    (:x (meters 0) (meters 3))
    (:scale-x (meters 3) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 96.0)
    (:g :copy r)
    (:b :copy g)
    (:a 16.0 32.0)
    (:vel-y (meters -0.026666667) (meters -0.06666667))
    (:scalevel-x (meters 0.0033333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.08 -0.08)
    (:accel-y (meters -0.00033333333))
    (:friction 0.92 0.03)
    (:timer (seconds 2))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 4979
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 16.0)
    (:scale-x (meters 1.5) (meters 0.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 96.0)
    (:g :copy r)
    (:b :copy g)
    (:a 16.0 16.0)
    (:vel-y (meters 0.10666667) (meters 0.053333335))
    (:scalevel-x (meters 0.0016666667))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.21333334)
    (:accel-y (meters -0.00033333333))
    (:friction 0.95)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:conerot-x (degrees 60) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-dig-spikey-sphere-break
  :id 1149
  :duration (seconds 2)
  :linger-duration (seconds 3)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 4978 :period (seconds 5) :length (seconds 0.05))
    (sp-item 4979 :period (seconds 5) :length (seconds 0.05))
    (sp-item 4982 :period (seconds 5) :length (seconds 0.05))
    (sp-item 4983 :fade-after (meters 130) :falloff-to (meters 130) :flags (is-3d) :period (seconds 5) :length (seconds 0.05) :binding 4981)
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    (sp-item 4981 :fade-after (meters 90) :falloff-to (meters 90) :flags (start-dead))
    )
  )

(defpart 4982
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 32.0)
    (:y (meters 3))
    (:scale-x (meters 2.5) (meters 2.5))
    (:scale-y (meters 2.5) (meters 2.5))
    (:r 32.0 96.0)
    (:g :copy r)
    (:b :copy g)
    (:a 16.0 16.0)
    (:vel-y (meters 0.033333335) (meters 0.13333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:fade-a -0.04 -0.04)
    (:accel-y (meters -0.00033333333) (meters -0.000033333334))
    (:friction 0.9 0.02)
    (:timer (seconds 2.667))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:conerot-x (degrees 30) (degrees 70))
    (:conerot-y (degrees 0) (degrees 3600))
    (:conerot-radius (meters 0) (meters 1))
    )
  )

(defpart 4981
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 1.0)
    (:scale-x (meters 1) (meters 0.1))
    (:rot-z (degrees 0) (degrees 3600))
    (:scale-y :copy scale-x)
    (:r 32.0 96.0)
    (:g :copy r)
    (:b :copy g)
    (:a 16.0 16.0)
    (:scalevel-x (meters 0.006666667) (meters 0.0033333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.10666667 -0.21333334)
    (:accel-y (meters 0) (meters -0.0005))
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 use-global-acc))
    )
  )

(defpart 4983
  :init-specs ((:texture (new 'static 'texture-id :index #xc :page #xc))
    (:num 16.0)
    (:y (meters 3))
    (:scale-x (meters 0.5) (meters 0.2))
    (:scale-y (meters 0.5) (meters 0.2))
    (:r 0.0 32.0)
    (:g :copy r)
    (:b :copy g)
    (:a 128.0)
    (:vel-y (meters 0.1) (meters 0.2))
    (:rotvel-x (degrees -4.8) (degrees 9.6))
    (:rotvel-y (degrees -4.8) (degrees 9.6))
    (:rotvel-z (degrees -4.8) (degrees 9.6))
    (:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.95 0.02)
    (:timer (seconds 1.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:next-time (seconds 0.335) (seconds 0.665))
    (:next-launcher 237)
    (:conerot-x (degrees 30) (degrees 70))
    (:conerot-y (degrees 0) (degrees 3600))
    (:conerot-radius (meters 0) (meters 2))
    )
  )

(defpart 4984
  :init-specs ((:fade-a -1.28 -1.28))
  )

(deftype dig-spikey-step (process-drawable)
  ((smush         smush-control :inline :offset-assert 200)
   (init-quat     quaternion    :inline :offset-assert 240)
   (shudder-angle float                 :offset-assert 256)
   (rot-angle     float                 :offset-assert 260)
   (cycle-time    float                 :offset-assert 264)
   (cycle-offset  float                 :offset-assert 268)
   )
  :heap-base #x90
  :method-count-assert 21
  :size-assert         #x110
  :flag-assert         #x1500900110
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-dig-spikey-step dig-spikey-step dig-spikey-step-lod0-jg dig-spikey-step-idle-ja
              ((dig-spikey-step-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 6 9)
              )

(defstate idle (dig-spikey-step)
  :virtual #t
  :trans (the-as (function none :behavior dig-spikey-step) rider-trans)
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until (>= (- (current-time) gp-0) (the int (-> self cycle-offset)))
        (suspend)
        )
      )
    (until #f
      (let ((gp-1 (current-time)))
        (until (>= (- (current-time) gp-1) (the int (-> self cycle-time)))
          (suspend)
          )
        )
      (activate! (-> self smush) -1.0 60 225 1.0 1.0 (-> self clock))
      (sound-play "spikey-shake" :position (-> self root trans))
      (let ((gp-3 (current-time)))
        (until (>= (- (current-time) gp-3) (seconds 0.75))
          (set! (-> self shudder-angle) (* 364.0889 (update! (-> self smush))))
          (suspend)
          )
        )
      (set! (-> self shudder-angle) 0.0)
      (set-zero! (-> self smush))
      (let ((gp-4 (current-time)))
        (until (>= (- (current-time) gp-4) (seconds 0.25))
          (suspend)
          )
        )
      (sound-play "spikey-turn" :position (-> self root trans))
      (let* ((f0-7 1.0)
             (f30-1 (* 65536.0 f0-7))
             (gp-6 (current-time))
             )
        (until (>= (- (current-time) gp-6) (seconds 1))
          (set! (-> self rot-angle)
                (the float (sar (shl (the int (+ (-> self rot-angle) (* f30-1 (-> self clock seconds-per-frame)))) 48) 48))
                )
          (suspend)
          )
        )
      (let ((v1-42 #x10000))
        (if (< (-> self rot-angle) 0.0)
            (set! (-> self rot-angle)
                  (the float (sar (shl (* v1-42 (/ (- (the int (-> self rot-angle)) (/ v1-42 2)) v1-42)) 48) 48))
                  )
            (set! (-> self rot-angle)
                  (the float (sar (shl (* v1-42 (/ (+ (the int (-> self rot-angle)) (/ v1-42 2)) v1-42)) 48) 48))
                  )
            )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (let ((a2-1 (quaternion-vector-angle!
                  (new 'stack-no-clear 'quaternion)
                  *z-vector*
                  (+ (-> self rot-angle) (-> self shudder-angle))
                  )
                )
          )
      (quaternion*! (-> self root quat) (-> self init-quat) a2-1)
      )
    (rider-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-spikey-step ((obj dig-spikey-step) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 int))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 24576.0 36864.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-spikey-step" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (quaternion-copy! (-> obj init-quat) (-> obj root quat))
  (let ((f28-0 4.0)
        (f30-0 0.0)
        )
    (set! sv-16 0)
    (let ((v1-20 (res-lump-data arg0 'cycle-speed (pointer float) :tag-ptr (the-as (pointer res-tag) (& sv-16)))))
      (when v1-20
        (set! f28-0 (-> v1-20 0))
        (set! f30-0 (-> v1-20 1))
        )
      )
    (set! (-> obj cycle-time) (the float (max 0 (+ (the int (* 300.0 f28-0)) -525))))
    (set! (-> obj cycle-offset) (the float (the int (* 300.0 f30-0))))
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype dig-spikey-sphere (projectile-bounce)
  ((death-height  float  :offset-assert 496)
   (pad-i1hb23h1b float  :offset-assert 500)
   )
  :heap-base #x180
  :method-count-assert 42
  :size-assert         #x1f8
  :flag-assert         #x2a018001f8
  )


(defskelgroup skel-dig-spikey-sphere dig-spikey-sphere dig-spikey-sphere-lod0-jg dig-spikey-sphere-idle-ja
              ((dig-spikey-sphere-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.2)
              :shadow dig-spikey-sphere-shadow-mg
              )

(defskelgroup skel-dig-spikey-sphere-explode dig-spikey-sphere dig-spikey-sphere-explode-lod0-jg dig-spikey-sphere-explode-idle-ja
              ((dig-spikey-sphere-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.2)
              )

(define *dig-spikey-sphere-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      )
    :collide-spec #x1
    :art-level #f
    )
  )

(defstate die (dig-spikey-sphere)
  :virtual #t
  :enter (behavior ()
    (send-event (ppointer->process (-> self parent)) 'died)
    (let ((v1-6 (-> self root-override root-prim)))
      (set! (-> v1-6 prim-core collide-as) (collide-spec))
      (set! (-> v1-6 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-dig-spikey-sphere-explode" (the-as (pointer uint32) #f))
        6
        gp-0
        *dig-spikey-sphere-exploder-params*
        :to self
        )
      )
    (sound-play "spikey-break")
    (suspend)
    (let ((gp-2 (current-time)))
      (until (>= (- (current-time) gp-2) (seconds 4))
        (suspend)
        )
      )
    (let ((t9-7 (-> (method-of-type projectile-bounce die) code)))
      (if t9-7
          ((the-as (function none) t9-7))
          )
      )
    (none)
    )
  )

(defun spikey-sphere-update-velocity ((arg0 dig-spikey-sphere))
  (with-pp
    (set! (-> arg0 root-override transv y)
          (- (-> arg0 root-override transv y) (* 327680.0 (-> pp clock seconds-per-frame)))
          )
    0
    (none)
    )
  )

(defbehavior spikey-sphere-reaction dig-spikey-sphere ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (let ((f30-0 (vector-dot arg3 (-> arg0 surface-normal)))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (sound-play "spikey-bounce")
    (vector-float*! s3-0 (-> arg0 surface-normal) (* 1.6 f30-0))
    (vector-! arg2 arg3 s3-0)
    )
  (-> arg0 status)
  )

(defmethod init-proj-collision! dig-spikey-sphere ((obj dig-spikey-sphere))
  "Init the [[projectile]]'s [[collide-shape]]"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) spikey-sphere-reaction)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec backgnd player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defun spikey-sphere-move ((arg0 dig-spikey-sphere))
  (quaternion*! (-> arg0 root-override quat) (-> arg0 tumble-quat) (-> arg0 root-override quat))
  (projectile-move-fill-all-dirs arg0)
  (none)
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod play-impact-sound! dig-spikey-sphere ((obj dig-spikey-sphere))
  "Plays impact sound"
  (let* ((a0-1 (-> obj root-override))
         (s5-0 (-> a0-1 status))
         )
    (when (logtest? s5-0 (collide-status touch-surface))
      (vector-float*! (-> a0-1 transv) (-> a0-1 transv) 0.9)
      (cond
        ((< (-> obj root-override trans y) (-> obj pad-i1hb23h1b))
         (let ((s4-0 (get-process *default-dead-pool* part-tracker #x4000)))
           (when s4-0
             (let ((t9-1 (method-of-type part-tracker activate)))
               (t9-1
                 (the-as part-tracker s4-0)
                 *entity-pool*
                 (symbol->string (-> part-tracker symbol))
                 (the-as pointer #x70004000)
                 )
               )
             (let ((t9-2 run-function-in-process)
                   (a0-5 s4-0)
                   (a1-3 part-tracker-init)
                   (a2-4 (-> *part-group-id-table* 1149))
                   (a3-1 0)
                   (t0-0 #f)
                   (t1-0 #f)
                   (t2-0 #f)
                   (t3-0 *launch-matrix*)
                   )
               (set! (-> t3-0 trans quad) (-> obj root-override grount-touch-point quad))
               ((the-as (function object object object object object object object object none) t9-2)
                a0-5
                a1-3
                a2-4
                a3-1
                t0-0
                t1-0
                t2-0
                t3-0
                )
               )
             (-> s4-0 ppointer)
             )
           )
         (go (method-of-object obj die))
         )
        (else
          (let ((s4-1 (get-process *default-dead-pool* part-tracker #x4000)))
            (when s4-1
              (let ((t9-5 (method-of-type part-tracker activate)))
                (t9-5
                  (the-as part-tracker s4-1)
                  *entity-pool*
                  (symbol->string (-> part-tracker symbol))
                  (the-as pointer #x70004000)
                  )
                )
              (let ((t9-6 run-function-in-process)
                    (a0-8 s4-1)
                    (a1-6 part-tracker-init)
                    (a2-9 (-> *part-group-id-table* 1148))
                    (a3-3 0)
                    (t0-1 #f)
                    (t1-1 #f)
                    (t2-1 #f)
                    (t3-1 *launch-matrix*)
                    )
                (set! (-> t3-1 trans quad) (-> obj root-override grount-touch-point quad))
                ((the-as (function object object object object object object object object none) t9-6)
                 a0-8
                 a1-6
                 a2-9
                 a3-3
                 t0-1
                 t1-1
                 t2-1
                 t3-1
                 )
                )
              (-> s4-1 ppointer)
              )
            )
          )
        )
      )
    (if (and (logtest? s5-0 (collide-status impact-surface))
             (>= (- (current-time) (-> obj played-bounce-time)) (seconds 0.3))
             )
        (set! (-> obj played-bounce-time) (current-time))
        )
    )
  (none)
  )

(defmethod init-proj-settings! dig-spikey-sphere ((obj dig-spikey-sphere))
  "Init relevant settings for the [[projectile]] such as gravity, speed, timeout, etc"
  (with-pp
    (set! (-> obj attack-mode) 'eco-dark)
    (initialize-skeleton
      obj
      (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-spikey-sphere" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (let ((t9-2 (method-of-type projectile-bounce init-proj-settings!)))
      (t9-2 obj)
      )
    (set! (-> obj max-speed) 163840.0)
    (set! (-> obj timeout) (seconds 8))
    (logclear! (-> obj mask) (process-mask actor-pause))
    (set! (-> obj notify-handle) (the-as handle #f))
    (set! (-> obj update-velocity) spikey-sphere-update-velocity)
    (set! (-> obj max-hits) #xffff)
    (set! (-> obj move) spikey-sphere-move)
    (set-vector! (-> obj root-override quat) 0.0 0.0 0.0 1.0)
    (set! (-> obj pad-i1hb23h1b) (+ -204800.0 (-> obj root-override trans y)))
    (let ((v1-16 (-> obj starting-dir)))
      (quaternion-axis-angle!
        (-> obj tumble-quat)
        (-> v1-16 z)
        (-> v1-16 y)
        (-> v1-16 x)
        (* -65536.0 (-> pp clock seconds-per-frame))
        )
      )
    (set! (-> obj draw light-index) (the-as uint 4))
    (sound-play "spikey-roll")
    0
    (none)
    )
  )

(deftype dig-spikey-sphere-door (process-drawable)
  ((sync      sync-linear :inline :offset-assert 200)
   (prev-sync float               :offset-assert 216)
   )
  :heap-base #x60
  :method-count-assert 22
  :size-assert         #xdc
  :flag-assert         #x16006000dc
  (:methods
    (idle () _type_ :state 20)
    (active () _type_ :state 21)
    )
  )


(defskelgroup skel-dig-spikey-sphere-door dig-spikey-sphere-door dig-spikey-sphere-door-lod0-jg dig-spikey-sphere-door-idle-ja
              ((dig-spikey-sphere-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -4 0 7)
              :origin-joint-index 4
              )

(defstate idle (dig-spikey-sphere-door)
  :virtual #t
  :trans (behavior ()
    (let ((f30-0 (-> self prev-sync))
          (f0-0 (get-norm! (-> self sync) 0))
          )
      (set! (-> self prev-sync) f0-0)
      (if (< f0-0 f30-0)
          (go-virtual active)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior dig-spikey-sphere-door) sleep-code)
  )

(defstate active (dig-spikey-sphere-door)
  :virtual #t
  :code (behavior ()
    (sound-play "spikey-door")
    (let ((gp-1 (current-time)))
      (until (>= (- (current-time) gp-1) (seconds 0.1))
        (suspend)
        )
      )
    (let ((gp-2 (new 'stack-no-clear 'vector))
          (s5-1 (new 'static 'vector :x -16384.0 :y -16384.0))
          )
      (vector-z-quaternion! gp-2 (-> self root quat))
      (let ((v1-7 (new 'stack-no-clear 'projectile-init-by-other-params)))
        (set! (-> v1-7 ent) (-> self entity))
        (set! (-> v1-7 charge) 1.0)
        (set! (-> v1-7 options) (projectile-options))
        (set! (-> v1-7 notify-handle) (the-as handle #f))
        (set! (-> v1-7 owner-handle) (the-as handle #f))
        (set! (-> v1-7 ignore-handle) (process->handle self))
        (let* ((a0-8 *game-info*)
               (a1-6 (+ (-> a0-8 attack-id) 1))
               )
          (set! (-> a0-8 attack-id) a1-6)
          (set! (-> v1-7 attack-id) a1-6)
          )
        (set! (-> v1-7 timeout) (seconds 4))
        (vector+! (-> v1-7 pos) (-> self root trans) s5-1)
        (vector-float*! (-> v1-7 vel) gp-2 163840.0)
        (spawn-projectile
          dig-spikey-sphere
          (the-as projectile-init-by-other-params (&-> v1-7 ent))
          self
          *default-dead-pool*
          )
        )
      )
    (ja-no-eval :group! (ja-group)
                :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle)
    (none)
    )
  :post (the-as (function none :behavior dig-spikey-sphere-door) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-spikey-sphere-door ((obj dig-spikey-sphere-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-dig-spikey-sphere-door" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (let ((a1-5 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-4 0))
      (if #f
          (set! v1-4 (logior v1-4 1))
          )
      (set! (-> a1-5 sync-type) 'sync-linear)
      (set! (-> a1-5 sync-flags) (the-as sync-flags v1-4))
      )
    (set! (-> a1-5 entity) arg0)
    (set! (-> a1-5 period) (the-as uint 1200))
    (set! (-> a1-5 percent) 0.0)
    (initialize! (-> obj sync) a1-5)
    )
  (set! (-> obj prev-sync) (get-norm! (-> obj sync) 0))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj draw light-index) (the-as uint 3))
  (go (method-of-object obj idle))
  (none)
  )

(defskelgroup skel-dig-balloon-lurker-trapeze dig-balloon-lurker dig-balloon-lurker-trapeze-lod0-jg dig-balloon-lurker-trapeze-jak-off-ja
              ((dig-balloon-lurker-trapeze-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 20)
              :shadow dig-balloon-lurker-trapeze-shadow-mg
              )

(defskelgroup skel-dig-balloon-lurker dig-balloon-lurker dig-balloon-lurker-lod0-jg dig-balloon-lurker-idle-ja
              ((dig-balloon-lurker-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 8 0 16)
              )

(deftype dig-balloon-lurker (process-drawable)
  ((init-quat        quaternion    :inline :offset-assert 208)
   (sync             sync-eased    :inline :offset-assert 224)
   (swing-sync       sync-linear   :inline :offset-assert 272)
   (smush            smush-control :inline :offset-assert 288)
   (pov-cam-offset   vector        :inline :offset-assert 320)
   (options          int32                 :offset-assert 336)
   (bouncing         basic                 :offset-assert 340)
   (bounce-scale     meters                :offset-assert 344)
   (bob-counter      float                 :offset-assert 348)
   (forward-backward basic                 :offset-assert 352)
   (grabbed          basic                 :offset-assert 356)
   (trapeze-grabbed  basic                 :offset-assert 360)
   (pedal-anim-frame float                 :offset-assert 364)
   (pedal-anim-speed float                 :offset-assert 368)
   (pedal-sound-id   sound-id              :offset-assert 372)
   )
  :heap-base #x100
  :method-count-assert 21
  :size-assert         #x178
  :flag-assert         #x1501000178
  (:methods
    (idle () _type_ :state 20)
    )
  )


(deftype dig-balloon-lurker-trapeze (process-drawable)
  ((parent-ptr       (pointer dig-balloon-lurker)  :offset         16)
   (swing-type       float                         :offset-assert 200)
   (swing-pole       (pointer swingpole)           :offset-assert 204)
   (swing-anim-frame float                         :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 22
  :size-assert         #xd4
  :flag-assert         #x16006000d4
  (:methods
    (idle () _type_ :state 20)
    (dig-balloon-lurker-trapeze-method-21 (_type_) none 21)
    )
  )


;; WARN: Return type mismatch object vs none.
(defbehavior dig-balloon-lurker-trapeze-init-by-other dig-balloon-lurker-trapeze ((arg0 entity-actor))
  (set! (-> self root) (new 'process 'trsqv))
  (process-drawable-from-entity! self arg0)
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-dig-balloon-lurker-trapeze" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self swing-type) 0.0)
  (set! (-> self swing-pole) (process-spawn swingpole :init swingpole-init 11 :to self))
  (set! (-> self swing-anim-frame) 0.0)
  (set! (-> self draw shadow-ctrl) (new
                                     'process
                                     'shadow-control
                                     0.0
                                     0.0
                                     614400.0
                                     (shadow-flags disable-fade shdf02 shdf03 shdf04 shdf07)
                                     491520.0
                                     )
        )
  (go-virtual idle)
  (none)
  )

(defstate idle (dig-balloon-lurker-trapeze)
  :virtual #t
  :code (behavior ()
    (ja-channel-push! 2 0)
    (ja :group! (-> self draw art-group data 6) :num! min)
    (ja :chan 1 :group! (-> self draw art-group data 7) :num! min)
    (until #f
      (ja :num-func num-func-identity :frame-num (-> self swing-anim-frame))
      (let ((a0-4 (-> self skel root-channel 1)))
        (let ((f0-4 (* 0.6 (-> self swing-type))))
          (set! (-> a0-4 frame-interp 1) f0-4)
          (set! (-> a0-4 frame-interp 0) f0-4)
          )
        (set! (-> a0-4 param 0) 0.0)
        (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-chan)
        )
      (let* ((f30-0 (the float (ja-num-frames 0)))
             (f0-10
               (+ (* 1.5 f30-0 (get-norm! (-> self parent-ptr 0 swing-sync) 0)) (if (= (-> self parent-ptr 0 options) 1)
                                                                                    (* 0.5 f30-0)
                                                                                    0.0
                                                                                    )
                  )
               )
             )
        (set! (-> self swing-anim-frame) (- f0-10 (* (the float (the int (/ f0-10 f30-0))) f30-0)))
        )
      (set! (-> self root trans quad) (-> self parent-ptr 0 root trans quad))
      (quaternion-copy! (-> self root quat) (-> self parent-ptr 0 root quat))
      (let ((v1-36 (and (-> self swing-pole 0 next-state) (= (-> self swing-pole 0 next-state name) 'active))))
        (set! (-> self parent-ptr 0 trapeze-grabbed) (the-as basic v1-36))
        )
      (seek!
        (-> self swing-type)
        (if (-> self parent-ptr 0 trapeze-grabbed)
            1.0
            0.0
            )
        (* 0.02 (-> self clock time-adjust-ratio))
        )
      (dig-balloon-lurker-trapeze-method-21 self)
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior dig-balloon-lurker-trapeze) ja-post)
  )

(defmethod dig-balloon-lurker-trapeze-method-21 dig-balloon-lurker-trapeze ((obj dig-balloon-lurker-trapeze))
  (cond
    ((and (-> obj draw shadow)
          (zero? (-> obj draw cur-lod))
          (logtest? (-> obj draw status) (draw-control-status on-screen))
          )
     (let ((s5-0 (new 'stack-no-clear 'collide-query)))
       (vector<-cspace! (-> s5-0 start-pos) (-> obj node-list data 11))
       (set! (-> s5-0 start-pos y) (+ -24576.0 (-> obj root trans y)))
       (set-vector! (-> s5-0 move-dist) 0.0 -34816.0 0.0 1.0)
       (let ((v1-10 s5-0))
         (set! (-> v1-10 radius) 8192.0)
         (set! (-> v1-10 collide-with) (collide-spec backgnd))
         (set! (-> v1-10 ignore-process0) obj)
         (set! (-> v1-10 ignore-process1) #f)
         (set! (-> v1-10 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
         (set! (-> v1-10 action-mask) (collide-action solid))
         )
       (cond
         ((>= (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
          (-> s5-0 best-other-tri intersect)
          (let ((v1-15 (-> obj draw shadow-ctrl)))
            (logclear! (-> v1-15 settings flags) (shadow-flags disable-draw))
            )
          0
          (let ((v1-18 (-> obj draw shadow-ctrl)))
            (set! (-> v1-18 settings bot-plane w) (- (+ -6144.0 (-> s5-0 best-other-tri intersect y))))
            )
          0
          (let ((v1-21 (-> obj draw shadow-ctrl)))
            (set! (-> v1-21 settings top-plane w) (- (+ 6144.0 (-> s5-0 best-other-tri intersect y))))
            )
          0
          (let* ((f1-4 (vector-vector-distance (-> s5-0 best-other-tri intersect) (-> obj root trans)))
                 (f0-15 (* 0.000030517578 (fmin 32768.0 (fmax 0.0 (+ -57344.0 f1-4)))))
                 )
            (set! (-> obj draw shadow-ctrl settings shadow-dir w) (lerp 409600.0 40960.0 f0-15))
            )
          )
         (else
           (let ((v1-31 (-> obj draw shadow-ctrl)))
             (logior! (-> v1-31 settings flags) (shadow-flags disable-draw))
             )
           0
           )
         )
       )
     )
    (else
      (let ((v1-34 (-> obj draw shadow-ctrl)))
        (logior! (-> v1-34 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-balloon-lurker ((obj dig-balloon-lurker) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 61440.0 0.0 61440.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 4096.0 0.0 28672.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 4096.0 36864.0 16384.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 4096.0 -36864.0 20480.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-balloon-lurker" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (process-spawn dig-balloon-lurker-trapeze arg0 :to obj)
  (quaternion-copy! (-> obj init-quat) (-> obj root quat))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj options) (res-lump-value arg0 'options int :time -1000000000.0))
  (set! (-> obj path) (new 'process 'curve-control obj 'path -1000000000.0))
  (set! (-> obj bouncing) #f)
  (set! (-> obj bounce-scale) 1228.8)
  (set! (-> obj bob-counter) (if (= (-> obj options) 1)
                                 145.0
                                 0.0
                                 )
        )
  (set! (-> obj forward-backward) #f)
  (set! (-> obj grabbed) #f)
  (set! (-> obj trapeze-grabbed) #f)
  (set! (-> obj pedal-anim-frame) 0.0)
  (set! (-> obj pedal-anim-speed) 0.5)
  (set-vector! (-> obj pov-cam-offset) 0.0 -20480.0 0.0 1.0)
  (set! (-> obj pedal-sound-id) (new-sound-id))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((a1-23 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-39 0))
      (if #t
          (set! v1-39 (logior v1-39 1))
          )
      (set! (-> a1-23 sync-type) 'sync-eased)
      (set! (-> a1-23 sync-flags) (the-as sync-flags v1-39))
      )
    (set! (-> a1-23 period) (the-as uint 3600))
    (set! (-> a1-23 entity) arg0)
    (set! (-> a1-23 percent) 0.0)
    (set! (-> a1-23 ease-in) 0.15)
    (set! (-> a1-23 ease-out) 0.15)
    (set! (-> a1-23 pause-in) 0.0)
    (set! (-> a1-23 pause-out) 0.0)
    (initialize! (-> obj sync) a1-23)
    )
  (let ((a1-24 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-46 0))
      (if #t
          (set! v1-46 (logior v1-46 1))
          )
      (set! (-> a1-24 sync-type) 'sync-linear)
      (set! (-> a1-24 sync-flags) (the-as sync-flags v1-46))
      )
    (set! (-> a1-24 entity) arg0)
    (set! (-> a1-24 period) (the-as uint 3600))
    (set! (-> a1-24 percent) 0.0)
    (initialize! (-> obj swing-sync) a1-24)
    )
  (go (method-of-object obj idle))
  (none)
  )

(defmethod deactivate dig-balloon-lurker ((obj dig-balloon-lurker))
  (sound-stop (-> obj pedal-sound-id))
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defstate idle (dig-balloon-lurker)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((f30-0 (get-norm! (-> self sync) 0)))
        (cond
          ((-> self forward-backward)
           (if (< 0.9 f30-0)
               (set! (-> self forward-backward) #f)
               )
           )
          (else
            (if (< f30-0 0.1)
                (set! (-> self forward-backward) (the-as basic #t))
                )
            )
          )
        (seek!
          (-> self pedal-anim-speed)
          (if (-> self forward-backward)
              -0.5
              0.5
              )
          (* 0.01 (-> self clock time-adjust-ratio))
          )
        (let ((f0-7 (+ -1.0 (fabs (* 2.0 (-> self pedal-anim-speed)))))
              (f1-5 (* 2.0 (fabs (-> self pedal-anim-speed))))
              )
          (sound-play-by-name
            (static-sound-name "balon-lurk-loop")
            (-> self pedal-sound-id)
            (the int (* 1024.0 f1-5))
            (the int (* 1524.0 f0-7))
            0
            (sound-group sfx)
            #t
            )
          )
        (ja :num-func num-func-identity :frame-num (-> self pedal-anim-frame))
        (+! (-> self pedal-anim-frame) (* (-> self pedal-anim-speed) (-> self clock time-adjust-ratio)))
        (cond
          ((>= (-> self pedal-anim-frame) (the float (ja-num-frames 0)))
           (set! (-> self pedal-anim-frame) (- (-> self pedal-anim-frame) (the float (ja-num-frames 0))))
           )
          ((< (-> self pedal-anim-frame) 0.0)
           (+! (-> self pedal-anim-frame) (the float (ja-num-frames 0)))
           )
          )
        (cond
          ((-> self trapeze-grabbed)
           (when (not (-> self grabbed))
             (set-setting! 'mode-name 'cam-pov-track 0.0 0)
             (let ((v1-33 (process->ppointer self)))
               (set-setting! 'pov-handle v1-33 3.0 (-> v1-33 0 pid))
               )
             (set! (-> self pov-cam-offset z)
                   (if (< 0.0 (vector-dot (-> self node-list data 0 bone transform vector 2) (-> (camera-matrix) vector 2)))
                       -81920.0
                       81920.0
                       )
                   )
             (set-setting! 'pov-offset 'asdf (-> self pov-cam-offset) 0)
             (set! (-> self grabbed) (the-as basic #t))
             )
           (when (not (-> self bouncing))
             (activate! (-> self smush) -1.0 210 600 1.0 1.0 (-> self clock))
             (set! (-> self bouncing) (the-as basic #t))
             (cond
               ((< (-> self bob-counter) 90.0)
                (set! (-> self bob-counter) (- 180.0 (-> self bob-counter)))
                )
               ((< 270.0 (-> self bob-counter))
                (set! (-> self bob-counter) (- 540.0 (-> self bob-counter)))
                )
               )
             )
           (seek! (-> self bob-counter) 270.0 (* 3.0 (-> self clock time-adjust-ratio)))
           )
          (else
            (when (-> self grabbed)
              (remove-setting! 'pov-handle)
              (remove-setting! 'mode-name)
              (remove-setting! 'pov-offset)
              (set! (-> self grabbed) #f)
              )
            (+! (-> self bob-counter) (* 3.0 (-> self clock time-adjust-ratio)))
            (if (< 360.0 (-> self bob-counter))
                (set! (-> self bob-counter) (+ -360.0 (-> self bob-counter)))
                )
            (if (not (!= (-> self smush amp) 0.0))
                (set! (-> self bouncing) #f)
                )
            )
          )
        (get-point-at-percent-along-path! (-> self path) (-> self root trans) f30-0 'interp)
        (+! (-> self root trans y) (+ (* 2048.0 (sin (* 182.04445 (the float (the int (-> self bob-counter))))))
                                      (* (-> self bounce-scale) (update! (-> self smush)))
                                      )
            )
        (when (= (-> self options) 1)
          (let ((a2-12 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) *y-vector* (* 182.04445 (* 70.0 f30-0)))))
            (quaternion*! (-> self root quat) (-> self init-quat) a2-12)
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior dig-balloon-lurker) transform-post)
  )

(deftype dig-wheel-step (process-drawable)
  ((anim-speed     float     :offset-assert 200)
   (wheel-sound-id sound-id  :offset-assert 204)
   )
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xd0
  :flag-assert         #x15005000d0
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-dig-wheel-step dig-wheel-step dig-wheel-step-lod0-jg dig-wheel-step-idle-ja
              ((dig-wheel-step-lod0-mg (meters 999999)))
              :bounds (static-spherem 2 0 0 14)
              )

(defstate idle (dig-wheel-step)
  :virtual #t
  :trans (behavior ()
    (sound-play "wheel-plat-loop" :id (-> self wheel-sound-id))
    (rider-trans)
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)) (-> self anim-speed))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self anim-speed)))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior dig-wheel-step) rider-post)
  )

(defmethod deactivate dig-wheel-step ((obj dig-wheel-step))
  (sound-stop (-> obj wheel-sound-id))
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-wheel-step ((obj dig-wheel-step) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 8192.0 0.0 0.0 57344.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid rideable))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 24576.0 0.0 0.0 24576.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 5)
      (set-vector! (-> v1-13 local-sphere) 24576.0 0.0 0.0 24576.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 43008.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-wheel-step" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj wheel-sound-id) (new-sound-id))
  (set! (-> obj draw light-index) (the-as uint 5))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (let* ((a0-30 (-> obj entity))
         (f0-18 ((method-of-object a0-30 get-property-value-float)
                 a0-30
                 'rotspeed
                 'interp
                 -1000000000.0
                 8192.0
                 (the-as (pointer res-tag) #f)
                 *res-static-buf*
                 )
                )
         )
    (set! (-> obj anim-speed) (* 0.000015258789 f0-18))
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype dig-tipping-rock (rigid-body-platform)
  ((anchor-point      vector     :inline :offset-assert 384)
   (last-ridden-time  time-frame         :offset-assert 400)
   (surface-height    float              :offset-assert 408)
   (bubbling-sound-id sound-id           :offset-assert 412)
   )
  :heap-base #x120
  :method-count-assert 57
  :size-assert         #x1a0
  :flag-assert         #x39012001a0
  )


(define *dig-tipping-rock-constants* (new 'static 'rigid-body-platform-constants
                                       :info (new 'static 'rigid-body-info
                                         :mass 4.0
                                         :inv-mass 0.25
                                         :linear-damping 0.9
                                         :angular-damping 0.48
                                         :friction-factor 0.1
                                         :cm-offset-joint (new 'static 'vector :z -24576.0 :w 1.0)
                                         :inertial-tensor-box (new 'static 'array meters 3 (meters 4) (meters 3) (meters 21))
                                         )
                                       :extra (new 'static 'rigid-body-object-extra-info
                                         :max-time-step 0.02
                                         :gravity (meters 80)
                                         :idle-distance (meters 50)
                                         :attack-force-scale 1.0
                                         )
                                       :name '*dig-tipping-rock-constants*
                                       :drag-factor 2.0
                                       :buoyancy-factor 1.2
                                       :max-buoyancy-depth (meters 2)
                                       :player-weight (meters 80)
                                       :player-bonk-factor 0.5
                                       :player-dive-factor 1.0
                                       :player-force-distance (meters 30)
                                       :player-force-clamp (meters 1000000)
                                       :player-force-timeout #x1e
                                       :explosion-force (meters 1000)
                                       :control-point-count 4
                                       :platform #t
                                       :sound-name "mud-plat"
                                       )
        )

(defskelgroup skel-dig-tipping-rock dig-tipping-rock dig-tipping-rock-lod0-jg dig-tipping-rock-idle-ja
              ((dig-tipping-rock-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 14.5)
              :origin-joint-index 3
              )

(defmethod rigid-body-object-method-37 dig-tipping-rock ((obj dig-tipping-rock))
  (let ((t9-0 (method-of-type rigid-body-platform rigid-body-object-method-37)))
    (t9-0 obj)
    )
  (cond
    ((>= (- (current-time) (-> obj last-ridden-time)) (seconds 0.5))
     (when (nonzero? (-> obj bubbling-sound-id))
       (let ((v1-5 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
         (set! (-> v1-5 command) (sound-command set-param))
         (set! (-> v1-5 id) (-> obj bubbling-sound-id))
         (set! (-> v1-5 params volume) -4)
         (set! (-> v1-5 auto-time) 120)
         (set! (-> v1-5 auto-from) 2)
         (set! (-> v1-5 params mask) (the-as uint 17))
         (-> v1-5 id)
         )
       (set! (-> obj bubbling-sound-id) (new 'static 'sound-id))
       0
       )
     )
    (else
      (if (zero? (-> obj bubbling-sound-id))
          (set! (-> obj bubbling-sound-id) (sound-play "lava-plat-tip"))
          )
      )
    )
  (none)
  )

(defstate idle (dig-tipping-rock)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('ridden)
       (set! (-> self last-ridden-time) (current-time))
       )
      )
    (rigid-body-object-event-handler proc arg1 event-type event)
    )
  :trans (the-as (function none :behavior dig-tipping-rock) rider-trans)
  :code (the-as (function none :behavior dig-tipping-rock) sleep-code)
  :post (behavior ()
    (rigid-body-object-method-37 self)
    (none)
    )
  )

(defstate active (dig-tipping-rock)
  :virtual #t
  :event (-> (method-of-type dig-tipping-rock idle) event)
  )

(defmethod rigid-body-object-method-29 dig-tipping-rock ((obj dig-tipping-rock) (arg0 float))
  ((the-as (function rigid-body-platform float none) (find-parent-method dig-tipping-rock 29)) obj arg0)
  (rigid-body-platform-method-56 obj (-> obj anchor-point))
  0
  (none)
  )

(defmethod allocate-and-init-cshape dig-tipping-rock ((obj dig-tipping-rock))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 4096.0 59392.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root-override-2) s5-0)
    )
  0
  (none)
  )

(defmethod rigid-body-platform-method-53 dig-tipping-rock ((obj dig-tipping-rock) (arg0 vector))
  (-> obj surface-height)
  )

(defmethod init-skel-and-rigid-body dig-tipping-rock ((obj dig-tipping-rock))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-tipping-rock" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (quaternion-rotate-local-x! (-> obj root-override-2 quat) (-> obj root-override-2 quat) -2555.2202)
  (alloc-and-init-rigid-body-control obj *dig-tipping-rock-constants*)
  (set! (-> obj anchor-point quad) (-> obj rbody state position quad))
  (let ((v1-8 (-> obj control-point-array)))
    (let ((a0-8 (-> v1-8 data)))
      (set! (-> a0-8 0 local-pos x) 0.0)
      (set! (-> a0-8 0 local-pos y) 0.0)
      (set! (-> a0-8 0 local-pos z) -8192.0)
      (set! (-> a0-8 0 local-pos w) 1.0)
      )
    (let ((a0-9 (-> v1-8 data 1)))
      (set! (-> a0-9 local-pos x) 0.0)
      (set! (-> a0-9 local-pos y) 8192.0)
      (set! (-> a0-9 local-pos z) -40960.0)
      (set! (-> a0-9 local-pos w) 1.0)
      )
    (let ((a0-10 (-> v1-8 data 2)))
      (set! (-> a0-10 local-pos x) 40960.0)
      (set! (-> a0-10 local-pos y) 4096.0)
      (set! (-> a0-10 local-pos z) -24576.0)
      (set! (-> a0-10 local-pos w) 1.0)
      )
    (let ((v1-9 (-> v1-8 data 3)))
      (set! (-> v1-9 local-pos x) -40960.0)
      (set! (-> v1-9 local-pos y) 4096.0)
      (set! (-> v1-9 local-pos z) -24576.0)
      (set! (-> v1-9 local-pos w) 1.0)
      )
    )
  (set! (-> obj surface-height) (+ 6144.0 (-> obj root-override-2 trans y)))
  (set! (-> obj bubbling-sound-id) (new 'static 'sound-id))
  0
  (none)
  )

(defskelgroup skel-dig-wall-bouncer dig-wall-bouncer 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 1 4 5.5)
              )

(deftype dig-wall-bouncer (bouncer)
  ()
  :heap-base #x60
  :method-count-assert 25
  :size-assert         #xd4
  :flag-assert         #x19006000d4
  )


(defmethod init-skeleton! dig-wall-bouncer ((obj dig-wall-bouncer))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-wall-bouncer" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  0
  (none)
  )

(defmethod bouncer-method-24 dig-wall-bouncer ((obj dig-wall-bouncer))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 5) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 6))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 4096.0 16384.0 22528.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 1))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 0)
      (set-vector! (-> v1-8 local-sphere) 0.0 6144.0 16384.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 3) (the-as uint 2))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 0)
      (set-vector! (-> v1-10 local-sphere) 0.0 4096.0 28672.0 12288.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 0)
      (set-vector! (-> v1-12 local-sphere) 12288.0 4096.0 16384.0 20480.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 2))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 0)
      (set-vector! (-> v1-14 local-sphere) -12288.0 4096.0 16384.0 20480.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 4))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action))
      (set! (-> v1-16 transform-index) 3)
      (set-vector! (-> v1-16 local-sphere) 0.0 18432.0 16384.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-19 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-19 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-19 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(deftype dig-stomp-block (rigid-body-object)
  ((desty float  :offset-assert 272)
   (flag  basic  :offset-assert 276)
   )
  :heap-base #xa0
  :method-count-assert 55
  :size-assert         #x118
  :flag-assert         #x3700a00118
  (:methods
    (waiting () _type_ :state 53)
    (hit () _type_ :state 54)
    )
  )


(defskelgroup skel-dig-stomp-block dig-stomp-block dig-stomp-block-lod0-jg dig-stomp-block-idle-ja
              ((dig-stomp-block-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -3 0 5.5)
              )

(define *dig-stomp-block-constants* (new 'static 'rigid-body-object-constants
                                      :info (new 'static 'rigid-body-info
                                        :mass 1.0
                                        :inv-mass 1.0
                                        :linear-damping 0.99
                                        :angular-damping 0.9
                                        :bounce-factor 0.5
                                        :friction-factor 0.1
                                        :cm-offset-joint (new 'static 'vector :w 1.0)
                                        :inertial-tensor-box (new 'static 'array meters 3 (meters 1) (meters 3) (meters 1))
                                        )
                                      :extra (new 'static 'rigid-body-object-extra-info
                                        :max-time-step 0.02
                                        :gravity (meters 80)
                                        :idle-distance (meters 200)
                                        :attack-force-scale 1.0
                                        )
                                      :name '*dig-stomp-block-constants*
                                      )
        )

(defstate waiting (dig-stomp-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('set-flag)
       (let ((v0-0 (the-as object #t)))
         (set! (-> self flag) (the-as basic v0-0))
         v0-0
         )
       )
      (('clear-flag)
       (set! (-> self flag) #f)
       #f
       )
      (('attack)
       (case (-> (the-as attack-info (-> event param 1)) mode)
         (('flop)
          (when (not (-> self flag))
            (set! (-> self desty) (+ -12288.0 (-> self root-override-2 trans y)))
            (send-event (ppointer->process (-> self parent)) 'set-flag)
            (go-virtual hit)
            'solid
            )
          )
         )
       )
      (('broken)
       (go-virtual active)
       )
      )
    )
  :code (the-as (function none :behavior dig-stomp-block) sleep-code)
  :post (the-as (function none :behavior dig-stomp-block) ja-post)
  )

(defstate hit (dig-stomp-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('broken)
       (go-virtual active)
       )
      )
    )
  :code (behavior ()
    (sound-play "stomp-block")
    (while (< (-> self desty) (-> self root-override-2 trans y))
      (set! (-> self root-override-2 trans y) (seek-with-smooth
                                                (-> self root-override-2 trans y)
                                                (-> self desty)
                                                (* 24576.0 (-> self clock seconds-per-frame))
                                                0.25
                                                1.0
                                                )
            )
      (suspend)
      )
    (set! (-> self flag) #f)
    (send-event (ppointer->process (-> self parent)) 'clear-flag)
    (go-virtual waiting)
    (none)
    )
  :post (the-as (function none :behavior dig-stomp-block) transform-post)
  )

(defstate active (dig-stomp-block)
  :virtual #t
  :enter (behavior ()
    (rigid-body-object-method-38 self)
    (let ((s5-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 x) (rand-vu-float-range -40960.0 40960.0))
      (set! (-> s5-0 y) (rand-vu-float-range -40960.0 0.0))
      (set! (-> s5-0 z) (rand-vu-float-range -40960.0 40960.0))
      (vector-float*! (-> self rbody state lin-momentum) s5-0 (-> self info info mass))
      (set! (-> gp-0 x) (rand-vu-float-range -10000.0 10000.0))
      (set! (-> gp-0 y) (rand-vu-float-range -10000.0 10000.0))
      (set! (-> gp-0 z) (rand-vu-float-range -10000.0 10000.0))
      (vector-float*! (-> self rbody state ang-momentum) gp-0 (-> self info info mass))
      )
    (none)
    )
  )

(defmethod rigid-body-object-method-37 dig-stomp-block ((obj dig-stomp-block))
  (with-pp
    (let ((a1-0 (new 'stack-no-clear 'collide-query)))
      (set! (-> a1-0 start-pos quad) (-> obj rbody state position quad))
      (vector-float*! (-> a1-0 move-dist) (-> obj rbody state lin-velocity) (-> pp clock seconds-per-frame))
      (let ((v1-3 a1-0))
        (set! (-> v1-3 radius) (+ 4096.0 (-> obj root-override-2 root-prim local-sphere w)))
        (set! (-> v1-3 collide-with) (-> obj root-override-2 root-prim prim-core collide-with))
        (set! (-> v1-3 ignore-process0) obj)
        (set! (-> v1-3 ignore-process1) #f)
        (set! (-> v1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-3 action-mask) (collide-action solid))
        )
      (fill-using-line-sphere *collide-cache* a1-0)
      )
    (let* ((a0-15 *collide-cache*)
           (v1-6 (the-as object (-> a0-15 tris)))
           )
      (countdown (a0-16 (-> a0-15 num-tris))
        (when (= (-> (the-as collide-cache-tri v1-6) pat event) (pat-event endlessfall))
          (set! (-> (the-as collide-cache-tri v1-6) vertex 0 y)
                (+ 409600.0 (-> (the-as collide-cache-tri v1-6) vertex 0 y))
                )
          (set! (-> (the-as collide-cache-tri v1-6) vertex 1 y)
                (+ 409600.0 (-> (the-as collide-cache-tri v1-6) vertex 1 y))
                )
          (set! (-> (the-as collide-cache-tri v1-6) vertex 2 y)
                (+ 409600.0 (-> (the-as collide-cache-tri v1-6) vertex 2 y))
                )
          )
        (set! v1-6 (-> (the-as (inline-array collide-cache-tri) v1-6) 1))
        )
      )
    (if *display-collide-cache*
        (debug-draw *collide-cache*)
        )
    (rigid-body-object-method-30 obj)
    (set! (-> obj root-override-2 transv quad) (-> obj rbody state lin-velocity quad))
    (quaternion-copy! (-> obj root-override-2 quat) (-> obj rbody state rotation))
    (rigid-body-method-24 (-> obj rbody state))
    (let ((v1-22 (-> obj rbody))
          (a1-8 (-> obj root-override-2 trans))
          )
      (rigid-body-method-23 (-> v1-22 state) a1-8)
      )
    (set! (-> obj node-list data 0 bone transform trans quad) (-> obj root-override-2 trans quad))
    (transform-post)
    0
    (none)
    )
  )

(defmethod allocate-and-init-cshape dig-stomp-block ((obj dig-stomp-block))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 9) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 10))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak obstacle hit-by-others-list player-list pusher)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 -12288.0 0.0 22528.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 0)
      (set-vector! (-> v1-14 local-sphere) -6144.0 -6144.0 -6144.0 6144.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-16 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) 0)
      (set-vector! (-> v1-16 local-sphere) -6144.0 -6144.0 6144.0 6144.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-18 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 0)
      (set-vector! (-> v1-18 local-sphere) 6144.0 -6144.0 -6144.0 6144.0)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-20 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) 0)
      (set-vector! (-> v1-20 local-sphere) 6144.0 -6144.0 6144.0 6144.0)
      )
    (let ((v1-22 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-22 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-22 prim-core action) (collide-action solid))
      (set! (-> v1-22 transform-index) 0)
      (set-vector! (-> v1-22 local-sphere) -6144.0 -18432.0 -6144.0 6144.0)
      )
    (let ((v1-24 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-24 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-24 prim-core action) (collide-action solid))
      (set! (-> v1-24 transform-index) 0)
      (set-vector! (-> v1-24 local-sphere) -6144.0 -18432.0 6144.0 6144.0)
      )
    (let ((v1-26 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-26 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-26 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-26 prim-core action) (collide-action solid))
      (set! (-> v1-26 transform-index) 0)
      (set-vector! (-> v1-26 local-sphere) 6144.0 -18432.0 -6144.0 6144.0)
      )
    (let ((v1-28 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-28 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-28 prim-core collide-with) (collide-spec backgnd obstacle hit-by-others-list))
      (set! (-> v1-28 prim-core action) (collide-action solid))
      (set! (-> v1-28 transform-index) 0)
      (set-vector! (-> v1-28 local-sphere) 6144.0 -18432.0 6144.0 6144.0)
      )
    (let ((v1-30 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-30 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-30 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-30 prim-core action) (collide-action solid))
      (set! (-> v1-30 transform-index) 3)
      (set-vector! (-> v1-30 local-sphere) 0.0 -12288.0 0.0 22528.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-33 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-33 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-33 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> obj root-override-2) s5-0)
    )
  0
  (none)
  )

(defmethod init-skel-and-rigid-body dig-stomp-block ((obj dig-stomp-block))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-stomp-block" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (alloc-and-init-rigid-body-control obj *dig-stomp-block-constants*)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (logior! (-> obj rbody state flags) (rigid-body-flag enable-collision))
  (set! (-> obj draw light-index) (the-as uint 10))
  (set! (-> obj flag) #f)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior dig-stomp-block-init-by-other dig-stomp-block ((arg0 vector))
  (set! (-> self mask) (logior (process-mask platform) (-> self mask)))
  (allocate-and-init-cshape self)
  (set! (-> self root-override-2 trans quad) (-> arg0 quad))
  (set-vector! (-> self root-override-2 quat) 0.0 1.0 0.0 0.0)
  (init-skel-and-rigid-body self)
  (transform-post)
  (go-virtual waiting)
  (none)
  )

(deftype dig-stomp-block-controller (process-drawable)
  ((stomp-blocks (pointer dig-stomp-block) 4 :offset-assert 200)
   (played-fall? symbol                      :offset-assert 216)
   )
  :heap-base #x60
  :method-count-assert 21
  :size-assert         #xdc
  :flag-assert         #x15006000dc
  (:methods
    (idle () _type_ :state 20)
    )
  )


(define *dig-stomp-block-table* (new 'static 'vector :x 36864.0 :y 12288.0 :z -12288.0 :w -36864.0))

(defstate idle (dig-stomp-block-controller)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('set-flag)
                      (dotimes (gp-0 4)
                        (if (-> self stomp-blocks gp-0)
                            (send-event (ppointer->process (-> self stomp-blocks gp-0)) 'set-flag)
                            )
                        )
                      #f
                      )
                     (('clear-flag)
                      (dotimes (gp-1 4)
                        (if (-> self stomp-blocks gp-1)
                            (send-event (ppointer->process (-> self stomp-blocks gp-1)) 'clear-flag)
                            )
                        )
                      #f
                      )
                     )
            )
    )
  :enter (behavior ()
    (change-parent self *pusher-pool*)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (dotimes (s5-0 4)
        (set! (-> gp-0 quad) (-> self root trans quad))
        (+! (-> gp-0 x) (-> *dig-stomp-block-table* data s5-0))
        (set! (-> self stomp-blocks s5-0) (process-spawn dig-stomp-block gp-0 :to self))
        )
      )
    (none)
    )
  :code (the-as (function none :behavior dig-stomp-block-controller) sleep-code)
  :post (behavior ()
    (dotimes (v1-0 4)
      (when (-> self stomp-blocks v1-0)
        )
      )
    (let ((v1-3 #f))
      (dotimes (a0-5 3)
        (let ((a1-2 (-> self stomp-blocks a0-5))
              (a2-3 (-> self stomp-blocks (+ a0-5 1)))
              )
          (when (and a1-2 a2-3)
            (if (< 20480.0 (fabs (- (-> a1-2 0 root-override-2 trans y) (-> a2-3 0 root-override-2 trans y))))
                (set! v1-3 #t)
                )
            )
          )
        )
      (when v1-3
        (when (not (-> self played-fall?))
          (set! (-> self played-fall?) #t)
          (sound-play "blocks-fall")
          )
        (dotimes (gp-1 4)
          (if (-> self stomp-blocks gp-1)
              (send-event (ppointer->process (-> self stomp-blocks gp-1)) 'broken)
              )
          )
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-stomp-block-controller ((obj dig-stomp-block-controller) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj played-fall?) #f)
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (go (method-of-object obj idle))
  (none)
  )

(deftype dig-totem (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-dig-totem-entity dig-totem dig-totem-lod0-jg dig-totem-idle-ja
              ((dig-totem-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 13 0 14.5)
              )

(defmethod run-logic? dig-totem ((obj dig-totem))
  #t
  )

(defstate idle (dig-totem)
  :virtual #t
  :code (the-as (function none :behavior dig-totem) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! dig-totem ((obj dig-totem) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 53248.0 0.0 59392.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-dig-totem-entity" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )
