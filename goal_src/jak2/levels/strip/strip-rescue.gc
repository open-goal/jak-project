;;-*-Lisp-*-
(in-package goal)

;; name: strip-rescue.gc
;; name in dgo: strip-rescue
;; dgos: STR

;; DECOMP BEGINS

(defskelgroup skel-cntrlrm-door cntrlrm-door cntrlrm-door-lod0-jg cntrlrm-door-idle-ja
              ((cntrlrm-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.8 0 3.6)
              )

(deftype cntrlrm-door (process-drawable)
  ((root-override           collide-shape    :offset        128)
   (unknown-pad-k1jhb2n3k1j int32         52 :offset-assert 200)
   )
  :heap-base #x120
  :method-count-assert 22
  :size-assert         #x198
  :flag-assert         #x1601200198
  (:methods
    (idle () _type_ :state 20)
    (opened () _type_ :state 21)
    )
  )


(defstate idle (cntrlrm-door)
  :virtual #t
  :code (behavior ()
    (dotimes (gp-0 2)
      (transform-post)
      (suspend)
      )
    (sleep-code)
    (none)
    )
  )

(defstate opened (cntrlrm-door)
  :virtual #t
  :code (behavior ()
    (ja :group! (-> self draw art-group data 3))
    (dotimes (gp-0 2)
      (transform-post)
      (suspend)
      )
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cntrlrm-door ((obj cntrlrm-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 4))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 10240.0 0.0 16384.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 -3072.0 0.0 8192.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 6144.0 0.0 10240.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 4)
      (set-vector! (-> v1-12 local-sphere) 0.0 7168.0 0.0 10240.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cntrlrm-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (if (task-node-closed? (game-task-node strip-rescue-resolution))
      (go (method-of-object obj opened))
      (go (method-of-object obj idle))
      )
  (none)
  )

(defskelgroup skel-cntrlrm-button cntrlrm-button cntrlrm-button-lod0-jg cntrlrm-button-idle-ja
              ((cntrlrm-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              )

(deftype cntrlrm-button (process-drawable)
  ((root-override            collide-shape    :offset        128)
   (unknown-pad-n12jn3123123 int32         52 :offset-assert 200)
   )
  :heap-base #x120
  :method-count-assert 21
  :size-assert         #x198
  :flag-assert         #x1501200198
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defstate idle (cntrlrm-button)
  :virtual #t
  :code (behavior ()
    (dotimes (gp-0 2)
      (transform-post)
      (suspend)
      )
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cntrlrm-button ((obj cntrlrm-button) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 3276.8)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 2867.2)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 1638.4)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cntrlrm-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )
