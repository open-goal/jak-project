;;-*-Lisp-*-
(in-package goal)

;; name: under-obs.gc
;; name in dgo: under-obs
;; dgos: UNB

;; DECOMP BEGINS

(defpartgroup group-bubbler-streams
  :id 500
  :bounds (static-bspherem 0 8 0 16)
  :parts ((sp-item 2197 :flags (is-3d bit6))
    (sp-item 2198 :flags (bit6))
    (sp-item 2199 :fade-after (meters 80) :falloff-to (meters 160))
    (sp-item 2200 :flags (is-3d bit6))
    (sp-item 2201 :fade-after (meters 160) :falloff-to (meters 40) :period (seconds 3.3) :length (seconds 0.017) :binding 2195)
    (sp-item 2201 :fade-after (meters 160) :falloff-to (meters 40) :period (seconds 4.6) :length (seconds 0.017) :binding 2195)
    (sp-item 2201 :fade-after (meters 160) :falloff-to (meters 40) :period (seconds 6.7) :length (seconds 0.017) :binding 2195)
    (sp-item 2201 :fade-after (meters 160) :falloff-to (meters 40) :period (seconds 13.1) :length (seconds 0.017) :binding 2195)
    (sp-item 2201 :fade-after (meters 160) :falloff-to (meters 40) :period (seconds 2) :length (seconds 0.017) :binding 2195)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2195 :flags (bit1 start-dead launch-asap) :binding 2196)
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2196 :fade-after (meters 100) :falloff-to (meters 100) :flags (bit1 start-dead))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    (sp-item 2202 :fade-after (meters 100) :falloff-to (meters 100))
    )
  )

(defpart 2199
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 8.0)
    (:x (meters 0) (meters 2.7))
    (:y (meters 0) (meters 32))
    (:scale-x (meters 0.25))
    (:scale-y (meters 0.25) (meters 0.1))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.0016666667) (meters 0.0016666667))
    (:fade-a 0.4)
    (:timer (seconds 0.535))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    (:next-time (seconds 0.267))
    (:next-launcher 2203)
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 2203
  :init-specs ((:fade-a -0.4))
  )

(defpart 2197
  :init-specs ((:texture (new 'static 'texture-id :index #xd3 :page #xc))
    (:birth-func 'birth-func-camera-orient)
    (:num 1.0)
    (:y (meters 299))
    (:scale-x (meters 6))
    (:rot-x (degrees 90))
    (:rot-z (degrees 0))
    (:scale-y (meters 600))
    (:r 255.0)
    (:g 255.0)
    (:b 0.0 128.0)
    (:a 32.0 4.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    )
  )

(defpart 2200
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:y (meters 0.1))
    (:scale-x (meters 16))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 0.0 128.0)
    (:a 128.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    )
  )

(defpart 2198
  :init-specs ((:texture (new 'static 'texture-id :index #xca :page #xc))
    (:num 1.0)
    (:y (meters 1))
    (:scale-x (meters 12) (meters 0.1))
    (:rot-x (degrees 33.75))
    (:scale-y (meters 20) (meters 0.1))
    (:r 255.0)
    (:g 255.0)
    (:b 0.0 128.0)
    (:a 20.0)
    (:timer (seconds 0.017))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 glow))
    (:userdata 16384.0)
    )
  )

(defpart 2202
  :init-specs ((:texture (new 'static 'texture-id :index #x21 :page #xc))
    (:num 0.1)
    (:x (meters -0.5) (meters 1.5))
    (:scale-x (meters 0.3) (meters 0.15))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.016666668) (meters 0.01))
    (:fade-a 0.16)
    (:timer (seconds 16))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata 0.0)
    (:func 'check-water-level-above-and-die)
    (:next-time (seconds 0.33) (seconds 0.657))
    (:next-launcher 2204)
    (:rotate-y (degrees 0) (degrees 3600))
    )
  )

(defpart 2204
  :init-specs ((:fade-a 0.0) (:next-time (seconds 1) (seconds 5.997)) (:next-launcher 2205))
  )

(defpart 2205
  :init-specs ((:scalevel-x (meters -0.00033333333) (meters -0.00066666666))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.16)
    (:accel-y (meters -0.0001) (meters -0.0001))
    )
  )

(defpart 2201
  :init-specs ((:texture (new 'static 'texture-id :index #x21 :page #xc))
    (:num 1.0)
    (:scale-x (meters 0.3))
    (:scale-y :copy scale-x)
    (:r 0.0)
    (:a 128.0)
    (:vel-y (meters 0.016666668) (meters 0.01))
    (:timer (seconds 10))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:rotate-y (degrees 0))
    )
  )

(defpart 2195
  :init-specs ((:texture (new 'static 'texture-id :index #x21 :page #xc))
    (:num 1.0)
    (:x (meters 0) (meters 16))
    (:y (meters 0) (meters 16))
    (:z (meters 0.1))
    (:scale-x (meters 1.5))
    (:scale-y (meters 0.9))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:omega (degrees 0))
    (:vel-x (meters -0.21333334) 1 (meters 0.42666668))
    (:vel-y (meters 0))
    (:vel-z (meters 0))
    (:scalevel-x (meters -0.0050000004))
    (:scalevel-y (meters 0.0016666667))
    (:fade-a 1.6)
    (:timer (seconds 8) (seconds 1.997))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 ready-to-launch))
    (:userdata 0.0)
    (:func 'check-water-level-above-and-die)
    (:next-time (seconds 0.1))
    (:next-launcher 2206)
    )
  )

(defpart 2206
  :init-specs ((:scale-x (meters 1.2))
    (:scale-y (meters 1))
    (:scalevel-x (meters 0.010000001))
    (:scalevel-y (meters -0.0033333334))
    (:fade-a 0.0)
    (:next-time (seconds 0.1))
    (:next-launcher 2207)
    )
  )

(defpart 2207
  :init-specs ((:scale-x (meters 1.5))
    (:scale-y (meters 0.9))
    (:scalevel-x (meters -0.010000001))
    (:scalevel-y (meters 0.0033333334))
    (:next-time (seconds 0.1))
    (:next-launcher 2206)
    )
  )

(defpart 2196
  :init-specs ((:texture (new 'static 'texture-id :index #x21 :page #xc))
    (:num 0.0 0.5)
    (:x (meters -0.25) (meters 0.5))
    (:y (meters 0.1))
    (:z (meters -0.25) (meters 0.5))
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:scalevel-x (meters -0.00033333333) (meters -0.00066666666))
    (:scalevel-y :copy scalevel-x)
    (:fade-a 0.53333336)
    (:timer (seconds 8))
    (:flags (sp-cpuinfo-flag-0 sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:userdata 0.0)
    (:func 'check-water-level-above-and-die)
    (:next-time (seconds 0.017))
    (:next-launcher 2208)
    (:conerot-x (degrees 110) (degrees 50.000004))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0.4))
    )
  )

(defpart 2208
  :init-specs ((:vel-y (meters 0.013333334) (meters 0.0033333334))
    (:accel-y (meters -0.00006666667))
    (:next-time (seconds 0.25))
    (:next-launcher 2209)
    )
  )

(defpart 2209
  :init-specs ((:fade-a -0.08))
  )

(deftype bubbler (process-drawable)
  ((rod-of-god-scale   float       :offset-assert 200)
   (ambient-id         sound-id    :offset-assert 204)
   (last-recharge-time time-frame  :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 22
  :size-assert         #xd8
  :flag-assert         #x16006000d8
  (:methods
    (idle () _type_ :state 20)
    (hidden () _type_ :state 21)
    )
  )


(defstate hidden (bubbler)
  :virtual #t
  :trans (behavior ()
    (if (send-event (ppointer->process *underb-master*) 'query 'bubbler)
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior bubbler) sleep-code)
  )

(defstate idle (bubbler)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('untrigger)
       (go-virtual idle)
       )
      )
    )
  :trans (behavior ()
    (if (not (send-event (ppointer->process *underb-master*) 'query 'bubbler))
        (go-virtual hidden)
        )
    (set! (-> *part-id-table* 2197 init-specs 4 initial-valuef) (* 16384.0 (-> self rod-of-god-scale)))
    (set! (-> *part-id-table* 2197 init-specs 8 initial-valuef) 0.0)
    (set! (-> *part-id-table* 2197 init-specs 9 initial-valuef) 96.0)
    (set! (-> *part-id-table* 2197 init-specs 10 initial-valuef) 255.0)
    (set! (-> *part-id-table* 2200 init-specs 3 initial-valuef) (* 65536.0 (-> self rod-of-god-scale)))
    (set! (-> *part-id-table* 2200 init-specs 2 initial-valuef) 3686.4)
    (set! (-> *part-id-table* 2200 init-specs 5 initial-valuef) 0.0)
    (set! (-> *part-id-table* 2200 init-specs 6 initial-valuef) 96.0)
    (set! (-> *part-id-table* 2200 init-specs 7 initial-valuef) 255.0)
    (set! (-> *part-id-table* 2198 init-specs 9 initial-valuef) (* 25.0 (-> self rod-of-god-scale)))
    (set! (-> *part-id-table* 2198 init-specs 6 initial-valuef) 0.0)
    (set! (-> *part-id-table* 2198 init-specs 7 initial-valuef) 96.0)
    (set! (-> *part-id-table* 2198 init-specs 8 initial-valuef) 255.0)
    (spawn (-> self part) (-> self root trans))
    (sound-play "bubbler" :id (-> self ambient-id) :position (-> self root trans))
    (let ((a0-4 *target*))
      (when a0-4
        (let ((a0-5 (get-trans a0-4 0)))
          (when (and (>= (- (-> a0-5 y) (-> self root trans y)) -6144.0)
                     (let ((f0-18 11264.0))
                       (>= (* f0-18 f0-18) (vector-vector-xz-distance-squared a0-5 (-> self root trans)))
                       )
                     )
            (if (>= (- (current-time) (-> self last-recharge-time)) (seconds 1))
                (sound-play "oxygen-recharge")
                )
            (set! (-> self last-recharge-time) (current-time))
            (send-event (ppointer->process *underb-master*) 'bubbler)
            )
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior bubbler) sleep-code)
  )

(defmethod deactivate bubbler ((obj bubbler))
  (sound-stop (-> obj ambient-id))
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! bubbler ((obj bubbler) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 500) obj))
  (set! (-> obj rod-of-god-scale) 1.0)
  (set! (-> obj ambient-id) (sound-play "bubbler" :position (-> obj root trans)))
  (go (method-of-object obj idle))
  (none)
  )

(deftype under-rise-plat (process-drawable)
  ((up-y           float       :offset-assert 200)
   (down-y         float       :offset-assert 204)
   (delta-y        float       :offset-assert 208)
   (up-threshold   float       :offset-assert 212)
   (down-threshold float       :offset-assert 216)
   (last-ridden    time-frame  :offset-assert 224)
   (ridden         symbol      :offset-assert 232)
   (rider-started  basic       :offset-assert 236)
   (extra-id       int32       :offset-assert 240)
   )
  :heap-base #x80
  :method-count-assert 26
  :size-assert         #xf4
  :flag-assert         #x1a008000f4
  (:methods
    (idle-up () _type_ :state 20)
    (wait-up () _type_ :state 21)
    (going-down () _type_ :state 22)
    (idle-down () _type_ :state 23)
    (wait-down () _type_ :state 24)
    (going-up () _type_ :state 25)
    )
  )


(defskelgroup skel-under-rise-plat under-rise-plat under-rise-plat-lod0-jg under-rise-plat-idle-ja
              ((under-rise-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 14)
              )

(defbehavior under-rise-plat-event-handler under-rise-plat ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('ridden)
     (set! (-> self ridden) #t)
     (let ((v0-0 (the-as object (current-time))))
       (set! (-> self last-ridden) (the-as time-frame v0-0))
       v0-0
       )
     )
    (('big-room)
     (send-event (ppointer->process *underb-master*) 'request 'big-room 'status (-> arg3 param 0))
     )
    )
  )

(defstate wait-up (under-rise-plat)
  :virtual #t
  :event under-rise-plat-event-handler
  :enter (behavior ()
    (set! (-> self rider-started) #f)
    (set! (-> self ridden) #f)
    (if (= (-> self extra-id) 1)
        (send-event (ppointer->process *underb-master*) 'request 'big-room 'under-plat 'up #t)
        )
    0
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (when (not (-> self ridden))
      (if (= (-> self extra-id) 1)
          (send-event (ppointer->process *underb-master*) 'request 'big-room 'under-plat 'player #f)
          )
      (go-virtual idle-up)
      )
    (set! (-> self ridden) #f)
    (none)
    )
  :code (the-as (function none :behavior under-rise-plat) sleep-code)
  :post (the-as (function none :behavior under-rise-plat) rider-post)
  )

(defstate idle-up (under-rise-plat)
  :virtual #t
  :event under-rise-plat-event-handler
  :enter (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    0
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (if (-> self ridden)
        (go-virtual going-down)
        )
    (let* ((a0-1 (target-pos 0))
           (v1-6 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) a0-1))
           )
      (set! (-> v1-6 y) (+ 58000.0 (-> v1-6 y)))
      (if (< (-> self down-threshold) (-> v1-6 y))
          (go-virtual going-down)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior under-rise-plat) sleep-code)
  :post (the-as (function none :behavior under-rise-plat) rider-post)
  )

(defstate going-down (under-rise-plat)
  :virtual #t
  :event under-rise-plat-event-handler
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self root transv y) -20480.0)
    (if (= (-> self extra-id) 1)
        (send-event (ppointer->process *underb-master*) 'request 'big-room 'under-plat 'up #f)
        )
    0
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (let ((gp-0 (-> self root)))
      (if (>= (-> self down-y) (-> gp-0 trans y))
          (go-virtual wait-down)
          )
      (vector-v++! (-> gp-0 trans) (-> gp-0 transv))
      (if (>= (-> self down-y) (-> gp-0 trans y))
          (set! (-> gp-0 trans y) (-> self down-y))
          )
      )
    (none)
    )
  :code (the-as (function none :behavior under-rise-plat) sleep-code)
  :post (the-as (function none :behavior under-rise-plat) rider-post)
  )

(defstate wait-down (under-rise-plat)
  :virtual #t
  :event under-rise-plat-event-handler
  :enter (behavior ()
    (set! (-> self rider-started) #f)
    (set! (-> self ridden) #f)
    0
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (when (not (-> self ridden))
      (if (= (-> self extra-id) 1)
          (send-event (ppointer->process *underb-master*) 'request 'big-room 'under-plat 'player #f)
          )
      (go-virtual idle-down)
      )
    (set! (-> self ridden) #f)
    (none)
    )
  :code (the-as (function none :behavior under-rise-plat) sleep-code)
  :post (the-as (function none :behavior under-rise-plat) rider-post)
  )

(defstate idle-down (under-rise-plat)
  :virtual #t
  :event under-rise-plat-event-handler
  :enter (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    0
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (when (-> self ridden)
      (if (= (-> self extra-id) 1)
          (send-event (ppointer->process *underb-master*) 'request 'big-room 'under-plat 'player #t)
          )
      (set! (-> self rider-started) (the-as basic #t))
      (go-virtual going-up)
      )
    (let* ((a0-4 (target-pos 0))
           (v1-19 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) a0-4))
           )
      (set! (-> v1-19 y) (+ 58000.0 (-> v1-19 y)))
      (if (< (-> v1-19 y) (-> self up-threshold))
          (go-virtual going-up)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior under-rise-plat) sleep-code)
  :post (the-as (function none :behavior under-rise-plat) rider-post)
  )

(defstate going-up (under-rise-plat)
  :virtual #t
  :event under-rise-plat-event-handler
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self root transv y) 20480.0)
    (set! (-> self ridden) #f)
    0
    (none)
    )
  :trans (behavior ()
    (rider-trans)
    (when (-> self rider-started)
      (when (and (not (-> self ridden)) (>= (- (current-time) (-> self last-ridden)) (seconds 2)))
        (if (= (-> self extra-id) 1)
            (send-event (ppointer->process *underb-master*) 'request 'big-room 'under-plat 'player #f)
            )
        (go-virtual going-down)
        )
      )
    (set! (-> self ridden) #f)
    (let ((gp-0 (-> self root)))
      (if (>= (-> gp-0 trans y) (-> self up-y))
          (go-virtual wait-up)
          )
      (vector-v++! (-> gp-0 trans) (-> gp-0 transv))
      (if (>= (-> gp-0 trans y) (-> self up-y))
          (set! (-> gp-0 trans y) (-> self up-y))
          )
      )
    (none)
    )
  :code (the-as (function none :behavior under-rise-plat) sleep-code)
  :post (the-as (function none :behavior under-rise-plat) rider-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-rise-plat ((obj under-rise-plat) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 -40960.0 0.0 57344.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (-> obj root)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-16 (res-lump-data arg0 'trans-offset (pointer float) :tag-ptr (& sv-16))))
    (when v1-16
      (+! (-> obj root trans x) (-> v1-16 0))
      (+! (-> obj root trans y) (-> v1-16 1))
      (+! (-> obj root trans z) (-> v1-16 2))
      )
    )
  (set! (-> obj extra-id) (res-lump-value arg0 'extra-id int :time -1000000000.0))
  (set! (-> obj delta-y) (res-lump-float arg0 'height :default 92160.0))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-rise-plat" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((v1-23 (-> obj root)))
    (set! (-> obj down-y) (-> v1-23 trans y))
    (+! (-> v1-23 trans y) (-> obj delta-y))
    (set! (-> obj up-y) (-> v1-23 trans y))
    (set! (-> obj down-threshold) (* 0.6666667 (-> obj delta-y)))
    (set! (-> obj up-threshold) (- (-> obj down-threshold)))
    (vector-reset! (-> v1-23 transv))
    )
  (set! (-> obj ridden) #f)
  (set! (-> obj rider-started) #f)
  (set! (-> obj draw light-index) (the-as uint 2))
  (go (method-of-object obj idle-up))
  (none)
  )

(deftype under-buoy-base (process-drawable)
  ((release         symbol  :offset-assert 200)
   (open-anim-frame float   :offset-assert 204)
   )
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xd0
  :flag-assert         #x16005000d0
  (:methods
    (idle () _type_ :state 20)
    (opened () _type_ :state 21)
    )
  )


(defskelgroup skel-under-buoy-base under-buoy-base under-buoy-base-lod0-jg under-buoy-base-idle-ja
              ((under-buoy-base-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

(defstate idle (under-buoy-base)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (case (-> (the-as attack-info (-> event param 1)) mode)
         (('mech-punch 'crush)
          (let ((a0-5 (ppointer->process (-> self parent))))
            (send-event a0-5 'base-hit)
            )
          )
         )
       )
      (('release)
       (let ((v0-0 (the-as object #t)))
         (set! (-> self release) (the-as symbol v0-0))
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    0
    (none)
    )
  :trans (behavior ()
    (when (-> self release)
      (ja :num-func num-func-identity :frame-num (-> self open-anim-frame))
      (set! (-> self open-anim-frame) (+ 0.2 (-> self open-anim-frame)))
      (if (< 17.0 (-> self open-anim-frame))
          (go-virtual opened)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior under-buoy-base) sleep-code)
  :post (the-as (function none :behavior under-buoy-base) ja-post)
  )

(defstate opened (under-buoy-base)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (none)
    )
  :code (the-as (function none :behavior under-buoy-base) sleep-code)
  :post (the-as (function none :behavior under-buoy-base) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior under-buoy-base-init-by-other under-buoy-base ((arg0 object) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (let ((s5-0 (new 'process 'collide-shape self (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 3) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 4))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 20480.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 6)
      (set-vector! (-> v1-12 local-sphere) 0.0 8192.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-buoy-base" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (process-drawable-from-entity! self arg1)
  (set! (-> self release) #f)
  (logior! (-> self mask) (process-mask actor-pause))
  (set! (-> self draw light-index) (the-as uint 2))
  (cond
    ((and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
     (set! (-> self open-anim-frame) 17.0)
     (ja-no-eval :group! (-> self draw art-group data 2) :num! (identity (-> self open-anim-frame)))
     (go-virtual opened)
     )
    (else
      (set! (-> self open-anim-frame) 0.0)
      (ja-no-eval :group! (-> self draw art-group data 2) :num! (identity (-> self open-anim-frame)))
      (go-virtual idle)
      )
    )
  (none)
  )

(deftype under-buoy-chain (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-under-buoy-chain under-buoy-chain under-buoy-chain-lod0-jg under-buoy-chain-idle-ja
              ((under-buoy-chain-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -10 0 14)
              )

(defstate idle (under-buoy-chain)
  :virtual #t
  :enter (behavior ()
    0
    (none)
    )
  :trans (behavior ()
    (let ((v1-0 (ppointer->process (-> self parent))))
      (set! (-> self root trans quad) (-> (the-as process-drawable v1-0) root trans quad))
      )
    (none)
    )
  :code (the-as (function none :behavior under-buoy-chain) sleep-code)
  :post (the-as (function none :behavior under-buoy-chain) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior under-buoy-chain-init-by-other under-buoy-chain ((arg0 object) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 4)
      (set-vector! (-> v1-6 local-sphere) 0.0 -40960.0 0.0 57344.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> self root) s5-0)
    )
  (process-drawable-from-entity! self arg1)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-buoy-chain" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> self draw light-index) (the-as uint 2))
  (logior! (-> self mask) (process-mask actor-pause))
  (go-virtual idle)
  (none)
  )

(deftype under-buoy-plat (rigid-body-platform)
  ((orig-trans     vector                    :inline :offset-assert 384)
   (surface-height float                             :offset-assert 400)
   (anchor-point   vector                    :inline :offset-assert 416)
   (base           (pointer under-buoy-base)         :offset-assert 432)
   )
  :heap-base #x140
  :method-count-assert 59
  :size-assert         #x1b4
  :flag-assert         #x3b014001b4
  (:methods
    (waiting () _type_ :state 57)
    (running () _type_ :state 58)
    )
  )


(defskelgroup skel-under-buoy-plat under-buoy-plat under-buoy-plat-lod0-jg under-buoy-plat-idle-ja
              ((under-buoy-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

(defmethod rigid-body-object-method-29 under-buoy-plat ((obj under-buoy-plat) (arg0 float))
  ((the-as (function rigid-body-object float none) (find-parent-method under-buoy-plat 29)) obj arg0)
  (rigid-body-platform-method-56 obj (-> obj orig-trans))
  0
  (none)
  )

(defmethod allocate-and-init-cshape under-buoy-plat ((obj under-buoy-plat))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 4)
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root-override-2) s5-0)
    )
  0
  (none)
  )

(define *under-buoy-plat-platform-constants*
  (new 'static 'rigid-body-platform-constants
    :info (new 'static 'rigid-body-info
      :mass 1.48
      :inv-mass 0.6756757
      :linear-damping 0.8
      :angular-damping 0.5
      :friction-factor 0.1
      :cm-offset-joint (new 'static 'vector :w 1.0)
      :inertial-tensor-box (new 'static 'array meters 3 (meters 5) (meters 1) (meters 5))
      )
    :extra (new 'static 'rigid-body-object-extra-info
      :max-time-step 0.02
      :gravity (meters 80)
      :idle-distance (meters 50)
      :attack-force-scale 1.0
      )
    :name '*under-buoy-plat-platform-constants*
    :drag-factor 2.0
    :buoyancy-factor 2.3
    :max-buoyancy-depth (meters 1.5)
    :player-weight (meters 150)
    :player-bonk-factor 0.5
    :player-dive-factor 1.0
    :player-force-distance (meters 2)
    :player-force-clamp (meters 1000000)
    :player-force-timeout #x1e
    :explosion-force (meters 1000)
    :control-point-count 5
    :platform #t
    :sound-name "ruins-plat"
    )
  )

(defmethod rigid-body-platform-method-53 under-buoy-plat ((obj under-buoy-plat) (arg0 vector))
  -220341.05
  )

(defmethod rigid-body-platform-method-56 under-buoy-plat ((obj under-buoy-plat) (arg0 vector))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (vector-! v1-0 arg0 (-> obj rbody state position))
    (set! (-> v1-0 y) 0.0)
    (let* ((f0-1 (vector-length v1-0))
           (f1-1 (* 4.0 (fmax 0.0 (fmin 4096.0 (+ -819.2 f0-1)))))
           )
      (when (< 0.0 f1-1)
        (vector-float*! v1-0 v1-0 (/ f1-1 f0-1))
        (rigid-body-method-20 (-> obj rbody state) v1-0)
        )
      )
    )
  0
  (none)
  )

(defmethod init-skel-and-rigid-body under-buoy-plat ((obj under-buoy-plat))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-buoy-plat" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (alloc-and-init-rigid-body-control obj *under-buoy-plat-platform-constants*)
  (set! (-> obj orig-trans quad) (-> obj root-override-2 trans quad))
  (set! (-> obj anchor-point quad) (-> obj root-override-2 trans quad))
  (set! (-> obj surface-height) (-> obj root-override-2 trans y))
  (set! (-> obj info-override info cm-offset-joint y) 6144.0)
  (let ((s5-1 (-> obj info-override control-point-count)))
    (dotimes (s4-1 s5-1)
      (let ((s3-0 (-> obj control-point-array data s4-1)))
        (let ((f30-0 (* 65536.0 (/ (the float s4-1) (the float s5-1)))))
          (set! (-> s3-0 local-pos x) (* 12288.0 (sin f30-0)))
          (set! (-> s3-0 local-pos y) 8192.0)
          (set! (-> s3-0 local-pos z) (* 12288.0 (cos f30-0)))
          )
        (set! (-> s3-0 local-pos w) 1.0)
        )
      )
    )
  (process-spawn under-buoy-chain (target-pos 0) (-> obj entity) :to obj)
  (set! (-> obj base) (process-spawn under-buoy-base (target-pos 0) (-> obj entity) :to obj))
  (logior! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj draw light-index) (the-as uint 2))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod rigid-body-object-method-34 under-buoy-plat ((obj under-buoy-plat))
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object obj running))
      (go (method-of-object obj waiting))
      )
  (none)
  )

(defstate waiting (under-buoy-plat)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (case (-> (the-as attack-info (-> event param 1)) mode)
         (('mech-punch 'crush)
          (go-virtual running)
          )
         )
       )
      (('base-hit)
       (go-virtual running)
       )
      )
    )
  :enter (behavior ()
    0
    (none)
    )
  :code (the-as (function none :behavior under-buoy-plat) sleep-code)
  :post (the-as (function none :behavior under-buoy-plat) ja-post)
  )

(defstate running (under-buoy-plat)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior under-buoy-plat)
    rigid-body-object-event-handler
    )
  :enter (behavior ()
    (sound-play "break-chain")
    (send-event (ppointer->process (-> self base)) 'release)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (rigid-body-object-method-37 self)
    (none)
    )
  )

(defskelgroup skel-under-mine under-mine under-mine-lod0-jg under-mine-idle-ja
              ((under-mine-lod0-mg (meters 20)) (under-mine-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 9)
              :shadow under-mine-shadow-mg
              :origin-joint-index 12
              )

(defskelgroup skel-under-mine-explode under-mine under-mine-explode-lod0-jg under-mine-explode-idle-ja
              ((under-mine-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 9)
              :origin-joint-index 11
              )

(deftype under-mine-chain-physics (chain-physics)
  ()
  :method-count-assert 18
  :size-assert         #x570
  :flag-assert         #x1200000570
  )


(defmethod apply-gravity under-mine-chain-physics ((obj under-mine-chain-physics) (arg0 vector) (arg1 int) (arg2 process-drawable))
  (local-vars (v1-7 vector) (v1-11 vector) (a0-17 float) (a0-26 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (vector-float*! arg0 (-> obj gravity) (* 81.92 (-> self clock time-adjust-ratio)))
    (cond
      ((= arg1 (+ (-> obj num-joints) -1))
       (let ((v1-4 (new 'stack-no-clear 'vector)))
         (set! (-> v1-4 quad) (-> arg2 entity trans quad))
         (vector-! v1-4 v1-4 (the-as vector (-> obj chain-joints arg1)))
         (vector+float*! arg0 arg0 v1-4 1.0)
         )
       )
      (else
        (cond
          ((>= arg1 (the-as int (+ (-> obj num-joints) -1)))
           (set! v1-7 (new 'stack-no-clear 'vector))
           (set! (-> v1-7 quad) (-> arg2 entity trans quad))
           (set! (-> v1-7 y) (+ 8192.0 (-> v1-7 y)))
           )
          (else
            (set! v1-7 (new 'stack-no-clear 'vector))
            (set! (-> v1-7 quad) (-> obj chain-joints (+ arg1 1) position quad))
            )
          )
        (vector-! v1-7 v1-7 (the-as vector (-> obj chain-joints arg1)))
        (.lvf vf1 (&-> v1-7 quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov a0-17 vf1)
        (let ((f0-6 (sqrtf a0-17)))
          (vector+float*! arg0 arg0 v1-7 (/ (* 1.1 (- f0-6 (-> obj joint-length))) f0-6))
          )
        (set! v1-11
              (cond
                ((zero? arg1)
                 (vector<-cspace! (new 'stack-no-clear 'vector) (-> arg2 node-list data (-> obj root-joint-index)))
                 )
                (else
                  (set! v1-11 (new 'stack-no-clear 'vector))
                  (set! (-> v1-11 quad) (-> obj chain-joints (+ arg1 -1) position quad))
                  v1-11
                  )
                )
              )
        (vector-! v1-11 v1-11 (the-as vector (-> obj chain-joints arg1)))
        (.lvf vf1 (&-> v1-11 quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov a0-26 vf1)
        (let ((f0-9 (sqrtf a0-26)))
          (vector+float*! arg0 arg0 v1-11 (/ (* 1.1 (- f0-9 (-> obj joint-length))) f0-9))
          )
        )
      )
    0
    (none)
    )
  )

(defmethod chain-physics-method-14 under-mine-chain-physics ((obj under-mine-chain-physics) (arg0 vector) (arg1 int))
  (vector-reset! arg0)
  0
  (none)
  )

;; WARN: Return type mismatch int vs vector.
(defmethod clamp-length under-mine-chain-physics ((obj under-mine-chain-physics) (arg0 vector) (arg1 vector) (arg2 object) (arg3 process-drawable))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> arg3 entity trans quad))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> v1-0 y) (+ -19660.8 (-> v1-0 y)))
      (vector-! s5-0 arg0 v1-0)
      (let ((f0-2 (vector-normalize-ret-len! s5-0 1.0)))
        (if (< f0-2 20480.0)
            (vector+float*! arg0 arg0 s5-0 (- 20480.0 f0-2))
            )
        )
      )
    )
  (the-as vector 0)
  )

(defmethod chain-physics-method-16 under-mine-chain-physics ((obj under-mine-chain-physics) (arg0 int))
  21845.334
  )

(deftype under-mine (process-drawable)
  ((root-override     collide-shape-moving      :offset        128)
   (chain             under-mine-chain-physics  :offset-assert 200)
   (chain-initialized symbol                    :offset-assert 204)
   (main-mod          joint-mod                 :offset-assert 208)
   (head-mod          joint-mod                 :offset-assert 212)
   )
  :heap-base #x60
  :method-count-assert 22
  :size-assert         #xd8
  :flag-assert         #x16006000d8
  (:methods
    (explode () _type_ :state 20)
    (idle () _type_ :state 21)
    )
  )


(define *under-mine-chain-setup* (new 'static 'boxed-array :type chain-physics-setup
                                   (new 'static 'chain-physics-setup :joint-index 14)
                                   (new 'static 'chain-physics-setup :joint-index 13)
                                   (new 'static 'chain-physics-setup :joint-index 12)
                                   (new 'static 'chain-physics-setup :joint-index 11)
                                   (new 'static 'chain-physics-setup :joint-index 10)
                                   (new 'static 'chain-physics-setup :joint-index 9)
                                   (new 'static 'chain-physics-setup :joint-index 8)
                                   (new 'static 'chain-physics-setup :joint-index 7)
                                   (new 'static 'chain-physics-setup :joint-index 6)
                                   (new 'static 'chain-physics-setup :joint-index 5)
                                   (new 'static 'chain-physics-setup :joint-index 4)
                                   )
        )

(define *under-mine-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index 4)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index 5)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index 7)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index 9)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index 10)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index 11)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index 12)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index 13)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index 14)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index 15)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index 15)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index 15)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index 15)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index 15)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index 15)
      )
    :collide-spec #x1
    )
  )

(defstate explode (under-mine)
  :virtual #t
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-3 (-> self root-override root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (let ((gp-0 (new 'stack-no-clear 'explosion-init-params)))
      (let ((v1-9
              (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self chain root-joint-index)))
              )
            )
        (vector+float*!
          v1-9
          v1-9
          (-> self node-list data (-> self chain root-joint-index) bone transform vector 1)
          10240.0
          )
        (set! (-> gp-0 spawn-point quad) (-> v1-9 quad))
        )
      (quaternion-copy! (-> gp-0 spawn-quat) (-> self root-override quat))
      (set! (-> gp-0 radius) 16384.0)
      (set! (-> gp-0 group) (-> *part-group-id-table* 501))
      (set! (-> gp-0 collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> gp-0 penetrate-using) (penetrate explode))
      (explosion-spawn (the-as process-drawable *default-pool*) explosion gp-0)
      )
    (let ((gp-1 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (set! (-> gp-1 duration) (seconds 4))
      (set! (-> gp-1 gravity) -20480.0)
      (set! (-> gp-1 rot-speed) 4.2)
      (set-vector! (-> gp-1 fountain-rand-transv-lo) -40960.0 20480.0 -40960.0 1.0)
      (set-vector! (-> gp-1 fountain-rand-transv-hi) 40960.0 49152.0 40960.0 1.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-under-mine-explode" (the-as (pointer uint32) #f))
        7
        gp-1
        *under-mine-exploder-params*
        :to self
        )
      )
    (sound-play "buoy-explode")
    (activate! *camera-smush-control* 819.2 37 210 1.0 0.995 (-> self clock))
    (ja-channel-set! 0)
    (ja-post)
    (none)
    )
  :trans (behavior ()
    (when (not (-> self child))
      (cleanup-for-death self)
      (deactivate self)
      )
    (none)
    )
  :code (the-as (function none :behavior under-mine) sleep-code)
  )

(defstate idle (under-mine)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack 'bonk 'touched)
       (go-virtual explode)
       )
      )
    )
  :trans (behavior ()
    (local-vars (a0-8 float))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (ja :num! (loop!))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (set! (-> gp-0 quad) (-> self entity trans quad))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (cond
            (*target*
              (set! (-> s5-0 quad) (-> (get-trans *target* 3) quad))
              (set! (-> s5-0 y) (+ -28672.0 (-> s5-0 y)))
              )
            (else
              (set! (-> s5-0 quad) (-> gp-0 quad))
              (set! (-> s5-0 y) (+ -1024.0 (-> s5-0 y)))
              )
            )
          (set! (-> gp-0 y) (+ -28672.0 (-> gp-0 y)))
          (vector-seek-3d-smooth! (-> self root-override trans) s5-0 (* 204.8 (-> self clock time-adjust-ratio)) 0.25)
          )
        (let ((v1-21 (vector-! (new 'stack-no-clear 'vector) (-> self root-override trans) gp-0)))
          (.lvf vf1 (&-> v1-21 quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov a0-8 vf1)
          (let ((f0-9 a0-8)
                (f1-4 28672.0)
                )
            (if (< (* f1-4 f1-4) f0-9)
                (vector-float*! v1-21 v1-21 (/ 28672.0 (sqrtf f0-9)))
                )
            )
          (vector+! (-> self root-override trans) gp-0 v1-21)
          )
        (set! (-> self root-override trans y) (fmax (-> self root-override trans y) (+ 409.6 (-> gp-0 y))))
        )
      (when (-> self chain-initialized)
        (let ((s5-1 (new-stack-vector0))
              (gp-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self head-mod quat)))
              )
          (dotimes (v1-27 (min 8 (the-as int (-> self chain num-joints))))
            (vector+! s5-1 s5-1 (the-as vector (-> self chain chain-joints v1-27)))
            )
          (vector-float*! s5-1 s5-1 (/ 1.0 (the float (min 8 (the-as int (-> self chain num-joints))))))
          (vector-!
            s5-1
            (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self chain root-joint-index)))
            s5-1
            )
          (vector-normalize! s5-1 1.0)
          (vector-seek-3d-smooth! (-> gp-1 vector 1) s5-1 (* 0.5 (-> self clock time-adjust-ratio)) 0.5)
          (vector-normalize! s5-1 1.0)
          (quaternion-from-two-vectors-partial!
            (-> self head-mod quat)
            (new 'static 'vector :y 1.0)
            (-> gp-1 vector 1)
            0.25
            )
          )
        (update (-> self chain) self)
        )
      (none)
      )
    )
  :code (the-as (function none :behavior under-mine) sleep-code)
  :post (behavior ()
    (transform-post)
    (if *nav-network*
        (nav-network-method-25 *nav-network* self (-> self root-override root-prim prim-core))
        )
    (when (not (-> self chain-initialized))
      (set! (-> self chain-initialized) #t)
      (initialize-chain-joints (-> self chain))
      )
    (none)
    )
  )

;; WARN: Return type mismatch process-drawable vs under-mine.
(defmethod relocate under-mine ((obj under-mine) (arg0 int))
  (if (nonzero? (-> obj main-mod))
      (&+! (-> obj main-mod) arg0)
      )
  (if (nonzero? (-> obj head-mod))
      (&+! (-> obj head-mod) arg0)
      )
  (if (nonzero? (-> obj chain))
      (&+! (-> obj chain) arg0)
      )
  (the-as under-mine ((method-of-type process-drawable relocate) obj arg0))
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-mine ((obj under-mine) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy camera-blocker))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 15)
      (set-vector! (-> v1-2 local-sphere) 0.0 12288.0 0.0 10240.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> obj root-override) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-mine" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj chain-initialized) #f)
  (set! (-> obj chain) (new 'process 'under-mine-chain-physics))
  (chain-physics-initialize obj (-> obj chain) 15 1843.2 *under-mine-chain-setup*)
  (set! (-> obj chain negate-y) #t)
  (set! (-> obj chain axial-slop) 1820.4445)
  (set! (-> obj chain maximum-stretch) 100.0)
  (set! (-> obj chain stretch-vel) 0.7)
  (set! (-> obj chain stretch-vel-parallel) 0.9)
  (set! (-> obj chain compress-vel) 0.85)
  (set! (-> obj chain compress-vel-parallel) 0.9)
  (set! (-> obj main-mod) (new 'process 'joint-mod (joint-mod-mode flex-blend) obj 3))
  (set! (-> obj main-mod track-mode) (track-mode no-rotate no-scale))
  (mode-set! (-> obj main-mod) (joint-mod-mode joint-set-world))
  (set! (-> obj main-mod trans quad) (-> obj entity trans quad))
  (set! (-> obj head-mod) (new 'process 'joint-mod (joint-mod-mode flex-blend) obj 15))
  (set! (-> obj head-mod track-mode) (track-mode no-trans no-scale))
  (mode-set! (-> obj head-mod) (joint-mod-mode joint-set*))
  (quaternion-identity! (-> obj head-mod quat))
  (set! (-> obj draw light-index) (the-as uint 10))
  (go (method-of-object obj idle))
  (none)
  )

(deftype under-lift (elevator)
  ((sound-id sound-id  :offset-assert 368)
   )
  :heap-base #x100
  :method-count-assert 50
  :size-assert         #x174
  :flag-assert         #x3201000174
  (:methods
    (under-lift-method-49 (_type_ symbol) none 49)
    )
  )


(defskelgroup skel-under-lift under-lift under-lift-lod0-jg under-lift-idle-ja
              ((under-lift-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 5.6 9.2)
              )

(defmethod get-art-group under-lift ((obj under-lift))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-under-lift" (the-as (pointer uint32) #f))
  )

(defmethod move-between-points under-lift ((obj under-lift) (arg0 vector) (arg1 float) (arg2 float))
  "Move between two points on the elevator's path
@param vec TODO not sure
@param point-a The first point fetched from the elevator's path
@param point-b The second point fetched from the path
@see [[path-control]] and [[elevator]]"
  (let ((s4-0 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) arg1 'interp))
        (a0-3 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) arg2 'interp))
        (v1-3 (-> obj root-override trans))
        )
    (when (and (< (-> a0-3 y) (-> s4-0 y)) (< (-> arg0 y) (+ -8192.0 (-> v1-3 y))))
      (let ((s4-2 (vector-! (new 'stack-no-clear 'vector) arg0 v1-3)))
        (vector-inv-orient-by-quat! s4-2 s4-2 (-> obj root-override quat))
        (and (< (fabs (-> s4-2 x)) 24576.0) (< 0.0 (-> s4-2 z)) (< (-> s4-2 z) 49152.0))
        )
      )
    )
  )

(defmethod commited-to-ride? under-lift ((obj under-lift))
  "@returns if the target is considered within the elevator area enough to begin descending/ascending"
  (let* ((gp-0 *target*)
         (a0-2 (if (type? gp-0 process-focusable)
                   gp-0
                   )
               )
         )
    (when a0-2
      (let* ((v1-1 (get-trans a0-2 0))
             (gp-2 (vector-! (new 'stack-no-clear 'vector) v1-1 (-> obj root-override trans)))
             )
        (vector-inv-orient-by-quat! gp-2 gp-2 (-> obj root-override quat))
        (and (< (fabs (-> gp-2 x)) 20480.0) (< 0.0 (-> gp-2 z)) (< (-> gp-2 z) 40960.0))
        )
      )
    )
  )

(defmethod under-lift-method-49 under-lift ((obj under-lift) (arg0 symbol))
  (let ((v1-3 (-> (the-as collide-shape-prim-group (-> obj root-override root-prim)) child 1)))
    (cond
      (arg0
        (set! (-> v1-3 prim-core collide-as) (collide-spec obstacle pusher))
        (set! (-> v1-3 prim-core collide-with) (collide-spec jak player-list))
        )
      (else
        (set! (-> v1-3 prim-core collide-as) (collide-spec))
        (set! (-> v1-3 prim-core collide-with) (collide-spec))
        0
        )
      )
    )
  (none)
  )

(defstate running (under-lift)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator running) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (when (and (logtest? (-> self elevator-status) (elevator-status waiting-to-descend))
               (logtest? (elevator-flags airlock-opened) (-> self params flags))
               )
      (under-lift-method-49 self #t)
      (set-setting! 'jump #f 0.0 0)
      )
    (none)
    )
  :post (behavior ()
    (let ((t9-0 (-> (method-of-type elevator running) post)))
      (if t9-0
          ((the-as (function none) t9-0))
          )
      )
    (sound-play "under-lift-lp" :id (-> self sound-id) :position (-> self root-override trans))
    (none)
    )
  )

(defstate arrived (under-lift)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator arrived) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (sound-stop (-> self sound-id))
    (sound-play "sew-elev-stop")
    (when (and (logtest? (-> self elevator-status) (elevator-status waiting-to-descend))
               (logtest? (elevator-flags airlock-opened) (-> self params flags))
               )
      (under-lift-method-49 self #f)
      (remove-setting! 'jump)
      )
    (none)
    )
  )

(defmethod deactivate under-lift ((obj under-lift))
  (sound-stop (-> obj sound-id))
  ((the-as (function process-drawable none) (find-parent-method under-lift 10)) obj)
  (none)
  )

(defmethod init-plat! under-lift ((obj under-lift))
  "Does any necessary initial platform setup.
For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (set! (-> obj sound-id) (new-sound-id))
  (set! (-> obj draw light-index) (the-as uint 4))
  0
  (none)
  )

(defmethod init-plat-collision! under-lift ((obj under-lift))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 22937.6 37683.2)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 22937.6 37683.2)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 22937.6 39321.6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-20 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-20 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-20 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (under-lift-method-49 obj #f)
  (none)
  )

(deftype under-break-door (process-focusable)
  ((anim         art-joint-anim  :offset-assert 204)
   (art-name     string          :offset-assert 208)
   (collide-mesh int32           :offset-assert 212)
   )
  :heap-base #x60
  :method-count-assert 29
  :size-assert         #xd8
  :flag-assert         #x1d006000d8
  (:methods
    (hit (symbol) _type_ :state 27)
    (idle () _type_ :state 28)
    )
  )


(defskelgroup skel-under-break-door under-break-door under-break-door-lod0-jg -1
              ((under-break-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 14)
              :origin-joint-index 3
              )

(defstate idle (under-break-door)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (go-virtual hit #f)
       )
      (('attack)
       (case (-> (the-as attack-info (-> event param 1)) mode)
         (('mech-punch 'crush)
          (go-virtual hit #f)
          )
         )
       )
      (('combo)
       #t
       )
      )
    )
  :code (behavior ()
    (add-process
      *gui-control*
      self
      (gui-channel art-load)
      (gui-action queue)
      (the-as string (-> self anim extra))
      -99.0
      0
      )
    (until #f
      (transform-post)
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate hit (under-break-door)
  :virtual #t
  :exit (behavior ()
    (ja-abort-spooled-anim (the-as spool-anim (-> self anim)) (the-as art-joint-anim #f) -1)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (set! (-> self draw force-lod) 0)
    (-> self draw bounds w)
    (let ((v1-3 (-> self root-override root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self draw bounds w) 573440.0)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let* ((s5-0 (-> self draw art-group))
           (s4-0 (method-of-object s5-0 get-art-by-name-method))
           )
      (format (clear *temp-string*) "~S-end" (-> self art-name))
      (let ((s5-1 (s4-0 s5-0 *temp-string* art-joint-anim)))
        (if (not arg0)
            (ja-play-spooled-anim
              (the-as spool-anim (-> self anim))
              (ja-group)
              (the-as art-joint-anim s5-1)
              (the-as (function process-drawable symbol) false-func)
              )
            )
        (ja-channel-set! 1)
        (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim s5-1))
        )
      )
    (suspend)
    (logior! (-> self mask) (process-mask sleep))
    (suspend)
    0
    (none)
    )
  :post (the-as (function none :behavior under-break-door) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-break-door ((obj under-break-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 512)
  (set! (-> obj mask) (logior (process-mask collectable) (-> obj mask)))
  (let ((s3-0 ((method-of-type res-lump get-property-struct)
               (-> obj entity)
               'art-name
               'interp
               -1000000000.0
               "under-break-door-1"
               (the-as (pointer res-tag) #f)
               *res-static-buf*
               )
              )
        (s4-0 (art-group-get-by-name *level* "skel-under-break-door" (the-as (pointer uint32) #f)))
        )
    (set! (-> obj art-name) (the-as string s3-0))
    (let ((s2-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
      (let ((v1-8 (new 'process 'collide-shape-prim-mesh s2-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-8 prim-core action) (collide-action solid))
        (set! (-> v1-8 transform-index) 3)
        (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 57344.0)
        (set! (-> s2-0 total-prims) (the-as uint 1))
        (set! (-> s2-0 root-prim) v1-8)
        )
      (set! (-> s2-0 nav-radius) (* 0.75 (-> s2-0 root-prim local-sphere w)))
      (let ((v1-11 (-> s2-0 root-prim)))
        (set! (-> s2-0 backup-collide-as) (-> v1-11 prim-core collide-as))
        (set! (-> s2-0 backup-collide-with) (-> v1-11 prim-core collide-with))
        )
      (set! (-> obj root-override) s2-0)
      )
    (cond
      ((string= (-> obj art-name) "under-break-door-1")
       (set! (-> obj anim)
             (the-as
               art-joint-anim
               (new 'static 'spool-anim :name "under-break-door-1" :anim-name "1-break" :parts 1 :command-list '())
               )
             )
       )
      ((string= (-> obj art-name) "under-break-door-2")
       (set! (-> obj anim)
             (the-as
               art-joint-anim
               (new 'static 'spool-anim :name "under-break-door-2" :anim-name "2-break" :parts 1 :command-list '())
               )
             )
       )
      ((string= (-> obj art-name) "under-break-door-3")
       (set! (-> obj anim)
             (the-as
               art-joint-anim
               (new 'static 'spool-anim :name "under-break-door-3" :anim-name "3-break" :parts 2 :command-list '())
               )
             )
       )
      ((string= (-> obj art-name) "under-break-door-4")
       (set! (-> obj anim)
             (the-as
               art-joint-anim
               (new 'static 'spool-anim :name "under-break-door-4" :anim-name "4-break" :parts 1 :command-list '())
               )
             )
       )
      (else
        (go process-drawable-art-error (the-as string s3-0))
        )
      )
    (process-drawable-from-entity! obj arg0)
    (initialize-skeleton obj (the-as skeleton-group s4-0) (the-as pair 0))
    )
  (ja-channel-set! 1)
  (let* ((s5-1 (-> obj skel root-channel 0))
         (s4-1 (-> obj draw art-group))
         (s3-1 (method-of-object s4-1 get-art-by-name-method))
         )
    (format (clear *temp-string*) "~S-idle" (-> obj art-name))
    (set! (-> s5-1 frame-group) (the-as art-joint-anim (s3-1 s4-1 *temp-string* (the-as type #f))))
    )
  (set! (-> obj draw light-index) (the-as uint 10))
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object obj hit) #t)
      (go (method-of-object obj idle))
      )
  (none)
  )

(deftype under-seaweed-a (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-under-seaweed-a under-seaweed-a under-seaweed-a-lod0-jg under-seaweed-a-idle-ja
              ((under-seaweed-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 3)
              )

(defstate idle (under-seaweed-a)
  :virtual #t
  :enter (behavior ()
    0
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior under-seaweed-a) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-seaweed-a ((obj under-seaweed-a) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 5))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 22937.6 37683.2)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 0.0 8192.0 0.0 12288.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 8192.0 0.0 12288.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-19 transform-index) 3)
      (set-vector! (-> v1-19 local-sphere) 0.0 8192.0 0.0 12288.0)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle camera-blocker))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-21 transform-index) 3)
      (set-vector! (-> v1-21 local-sphere) 0.0 8192.0 0.0 12288.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-24 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-24 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-24 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-seaweed-a" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype under-seaweed-b (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-under-seaweed-b under-seaweed-b under-seaweed-b-lod0-jg under-seaweed-b-idle-ja
              ((under-seaweed-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 5)
              )

(defstate idle (under-seaweed-b)
  :virtual #t
  :enter (behavior ()
    0
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior under-seaweed-b) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-seaweed-b ((obj under-seaweed-b) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-seaweed-b" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype under-seaweed-c (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-under-seaweed-c under-seaweed-c under-seaweed-c-lod0-jg under-seaweed-c-idle-ja
              ((under-seaweed-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 4)
              )

(defstate idle (under-seaweed-c)
  :virtual #t
  :enter (behavior ()
    0
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior under-seaweed-c) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-seaweed-c ((obj under-seaweed-c) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-seaweed-c" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype under-seaweed-d (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-under-seaweed-d under-seaweed-d under-seaweed-d-lod0-jg under-seaweed-d-idle-ja
              ((under-seaweed-d-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 7)
              )

(defstate idle (under-seaweed-d)
  :virtual #t
  :enter (behavior ()
    0
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior under-seaweed-d) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-seaweed-d ((obj under-seaweed-d) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-seaweed-d" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(defmethod draw hud-mech-air-tank ((obj hud-mech-air-tank))
  (set-hud-piece-position!
    (the-as hud-sprite (-> obj sprites))
    (the int (+ 472.0 (* 100.0 (-> obj offset))))
    208
    )
  (set-as-offset-from! (-> obj sprites 1) (the-as vector4w (-> obj sprites)) 0 51)
  (set! (-> obj sprites 0 scale-x) 0.8)
  (set! (-> obj sprites 0 scale-y) 0.8)
  (set! (-> obj sprites 1 scale-x) 0.8)
  (set! (-> obj sprites 1 scale-y) 0.8)
  (set! (-> obj sprites 3 scale-x) 0.8)
  (set! (-> obj sprites 3 scale-y) 0.8)
  (set! (-> obj sprites 2 scale-x) 3.2)
  (set! (-> obj sprites 2 scale-y) (* 4.56 (- 1.0 (-> *game-info* air-supply))))
  (set-as-offset-from! (-> obj sprites 2) (the-as vector4w (-> obj sprites)) 0 2)
  (set-as-offset-from! (-> obj sprites 3) (the-as vector4w (-> obj sprites)) -30 -20)
  ((method-of-type hud draw) obj)
  0
  (none)
  )

(defmethod update-values hud-mech-air-tank ((obj hud-mech-air-tank))
  (set! (-> obj values 0 target) (the int (-> *game-info* air-supply)))
  (logclear! (-> obj flags) (hud-flags disable))
  ((method-of-type hud update-values) obj)
  0
  (none)
  )

(defmethod init-callback hud-mech-air-tank ((obj hud-mech-air-tank))
  (set! (-> obj gui-id)
        (add-process *gui-control* obj (gui-channel hud-middle-right) (gui-action hidden) (-> obj name) 81920.0 0)
        )
  (logior! (-> obj flags) (hud-flags show))
  (set! (-> obj sprites 0 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x2 :page #xd55)))
  (set! (-> obj sprites 1 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3 :page #xd55)))
  (set! (-> obj sprites 2 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x4 :page #xd55)))
  (set! (-> obj sprites 3 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x1 :page #xd55)))
  0
  (none)
  )
