;;-*-Lisp-*-
(in-package goal)

;; name: underb-master.gc
;; name in dgo: underb-master
;; dgos: UNB

;; DECOMP BEGINS

(deftype under-warp (process-drawable)
  ((interp float  :offset-assert 200)
   )
  :heap-base #x50
  :method-count-assert 23
  :size-assert         #xcc
  :flag-assert         #x17005000cc
  (:methods
    (idle () _type_ :state 20)
    (die-fast () _type_ :state 21)
    (under-warp-method-22 (_type_) none 22)
    )
  )


(defskelgroup skel-under-warp under-warp under-warp-lod0-jg under-warp-idle-ja
              ((under-warp-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 8)
              )

(defstate idle (under-warp)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('die-fast)
       (set-under-fog-interp! 0.0)
       (go-virtual die-fast)
       )
      )
    )
  :code (behavior ()
    (until #f
      (let ((v1-2 (-> self skel root-channel 1))
            (f0-0 (-> self interp))
            )
        (set! (-> v1-2 frame-interp 1) f0-0)
        (set! (-> v1-2 frame-interp 0) f0-0)
        )
      (ja :num! (loop!))
      (ja :chan 1 :num! (chan 0))
      (ja-no-eval :group! (-> self draw art-group data 2)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (under-warp-method-22 self)
    (ja-post)
    (none)
    )
  )

(defstate die-fast (under-warp)
  :virtual #t
  :code (the-as (function none :behavior under-warp) nothing)
  )

(defmethod under-warp-method-22 under-warp ((obj under-warp))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s3-0 (camera-matrix))
          (s5-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'vector))
          (f30-0 4096.0)
          )
      (let ((f0-4 (* 0.00013563369 (tan (* 0.5 (-> *math-camera* fov))) f30-0)))
        (set-vector! (-> obj root scale) f0-4 f0-4 f0-4 1.0)
        )
      (set! (-> gp-0 quad) (-> (camera-pos) quad))
      (vector-normalize-copy! s5-0 (-> s3-0 vector 2) 1.0)
      (matrix->quaternion (-> obj root quat) s3-0)
      (let ((v1-10 (-> obj root trans)))
        (let ((a0-5 f30-0))
          (.mov vf7 a0-5)
          )
        (.lvf vf5 (&-> s5-0 quad))
        (.lvf vf4 (&-> gp-0 quad))
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-10 quad) vf6)
        )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior under-warp-init-by-other under-warp ((arg0 vector) (arg1 quaternion) (arg2 entity-actor))
  (set! (-> self level) (the-as level arg2))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-copy! (-> self root quat) arg1)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-warp" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> self interp) 0.5)
  (ja-channel-push! 2 (seconds 0.3))
  (ja-no-eval :group! (-> self draw art-group data 2) :num! (loop!))
  (let ((gp-2 (-> self skel root-channel 1)))
    (let ((f0-2 (-> self interp)))
      (set! (-> gp-2 frame-interp 1) f0-2)
      (set! (-> gp-2 frame-interp 0) f0-2)
      )
    (joint-control-channel-group! gp-2 (the-as art-joint-anim (-> self draw art-group data 3)) num-func-identity)
    (set! (-> gp-2 frame-num) 0.0)
    )
  (logior! (-> self skel status) (joint-control-status blend-shape))
  (go-virtual idle)
  (none)
  )

(deftype underb-master (process)
  ((warp-handle           handle      :offset-assert 128)
   (tank-handle           handle      :offset-assert 136)
   (underwater-time       time-frame  :offset-assert 144)
   (last-air-beep-time    time-frame  :offset-assert 152)
   (ambient-sound-id      sound-id    :offset-assert 160)
   (air-supply            float       :offset-assert 164)
   (air-charge-up?        symbol      :offset-assert 168)
   (under-water-pitch-mod float       :offset-assert 172)
   (big-room-entered      symbol      :offset-assert 176)
   (big-room-timer        time-frame  :offset-assert 184)
   (under-plat-player-on  symbol      :offset-assert 192)
   (under-plat-is-up      symbol      :offset-assert 196)
   )
  :heap-base #x50
  :method-count-assert 24
  :size-assert         #xc8
  :flag-assert         #x18005000c8
  (:methods
    (idle () _type_ :state 14)
    (big-room-player-under () _type_ :state 15)
    (big-room-player-plat () _type_ :state 16)
    (underb-master-method-17 () none 17)
    (big-room-player-above () _type_ :state 18)
    (big-room-player-falling () _type_ :state 19)
    (big-room-player-exiting () _type_ :state 20)
    (big-room-player-done () _type_ :state 21)
    (under-warp-check (_type_) symbol 22)
    (spawn-air-tank-hud (_type_ symbol) none 23)
    )
  )


(define *underb-master* (the-as (pointer underb-master) #f))

(defmethod deactivate underb-master ((obj underb-master))
  (sound-stop (-> obj ambient-sound-id))
  (send-event (handle->process (-> obj warp-handle)) 'die-fast)
  (set! *underb-master* (the-as (pointer underb-master) #f))
  ((method-of-type process deactivate) obj)
  (none)
  )

;; WARN: disable def twice: 121. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defbehavior underb-master-event-handler underb-master ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (case arg2
    (('query)
     (case (-> arg3 param 0)
       (('mech)
        (not (-> *setting-control* user-current pilot-exit))
        )
       (('bubbler)
        ;; TODO warp effect
        (and ;; (handle->process (-> self warp-handle))
             (or (and (-> self next-state) (= (-> self next-state name) 'idle)) (not (under-warp-check self)))
             )
        )
       )
     )
    (('request)
     (case (-> arg3 param 0)
       (('mech)
        (cond
          ((-> arg3 param 1)
           (cond
             ((-> *setting-control* user-current pilot-exit)
              (let ((a1-2 *target*))
                (when (and a1-2 (focus-test? a1-2 mech))
                  (set-setting! 'pilot-exit #f 0 0)
                  (apply-settings *setting-control*)
                  #t
                  )
                )
              )
             (else
               #t
               )
             )
           )
          ((-> *setting-control* user-current pilot-exit)
           #t
           )
          (else
            (remove-setting! 'pilot-exit)
            (apply-settings *setting-control*)
            (not (-> *setting-control* user-current pilot-exit))
            )
          )
        )
       (('under-warp)
        (cond
          ((-> arg3 param 1)
           (set-under-fog-interp! 1.0)
           (when (not (handle->process (-> self warp-handle)))
             ;; TODO warp effect
             ;; (let ((s2-0 (camera-matrix))
             ;;       (s3-0 (new 'stack-no-clear 'vector))
             ;;       (gp-0 (new 'stack-no-clear 'vector))
             ;;       (s5-0 (new 'stack-no-clear 'quaternion))
             ;;       )
             ;;   (set! (-> gp-0 quad) (-> (camera-pos) quad))
             ;;   (vector-normalize-copy! s3-0 (-> s2-0 vector 2) 1.0)
             ;;   (matrix->quaternion s5-0 s2-0)
             ;;   (set! (-> self warp-handle)
             ;;         (ppointer->handle (process-spawn under-warp gp-0 s5-0 (-> self level) :to *display-pool*))
             ;;         )
             ;;   )
             (set! v0-0 (sound-play "mech-under-amb"))
             (set! (-> self ambient-sound-id) (the-as sound-id v0-0))
             v0-0
             )
           )
          (else
            (set-under-fog-interp! 0.0)
            (let ((a0-41 (handle->process (-> self warp-handle))))
              (when a0-41
                (send-event a0-41 'die-fast)
                (set! (-> self warp-handle) (the-as handle #f))
                (sound-stop (-> self ambient-sound-id))
                (set! (-> self ambient-sound-id) (new 'static 'sound-id))
                0
                )
              )
            )
          )
        )
       (('big-room)
        (case (-> arg3 param 1)
          (('status)
           (cond
             ((-> arg3 param 2)
              (set! v0-0 #t)
              (set! (-> self big-room-entered) (the-as symbol v0-0))
              v0-0
              )
             (else
               (set! (-> self big-room-entered) #f)
               #f
               )
             )
           )
          (('under-plat)
           (case (-> arg3 param 2)
             (('player)
              (cond
                ((-> arg3 param 3)
                 (set! v0-0 #t)
                 (set! (-> self under-plat-player-on) (the-as symbol v0-0))
                 v0-0
                 )
                (else
                  (set! (-> self under-plat-player-on) #f)
                  #f
                  )
                )
              )
             (('up)
              (cond
                ((-> arg3 param 3)
                 (set! v0-0 #t)
                 (set! (-> self under-plat-is-up) (the-as symbol v0-0))
                 v0-0
                 )
                (else
                  (set! (-> self under-plat-is-up) #f)
                  #f
                  )
                )
              )
             )
           )
          )
        )
       )
     )
    (('bubbler)
     (set! v0-0 #t)
     (set! (-> self air-charge-up?) (the-as symbol v0-0))
     v0-0
     )
    )
  )

(defmethod under-warp-check underb-master ((obj underb-master))
  "Used to check whether the underwater warp effect should be drawn."
  (let ((target-pos (target-pos 0))
        (tpos-offset (new 'stack-no-clear 'vector))
        (a1-0 (new 'stack-no-clear 'vector))
        (v1-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> tpos-offset x) (+ -827392.0 (-> target-pos x)))
    (set! (-> tpos-offset y) 0.0)
    (set! (-> tpos-offset z) (+ -7671808.0 (-> target-pos z)))
    (set! (-> a1-0 x) -94208.0)
    (set! (-> a1-0 y) 0.0)
    (set! (-> a1-0 z) -143360.0)
    (vector-cross! v1-0 tpos-offset a1-0)
    (< (-> v1-0 y) 0.0)
    )
  )

(defmethod spawn-air-tank-hud underb-master ((obj underb-master) (arg0 symbol))
  "Spawns or hides the air tank HUD bar."
  (cond
    (arg0
      (if (not (handle->process (-> obj tank-handle)))
          (set! (-> obj tank-handle)
                (ppointer->handle (process-spawn hud-mech-air-tank :init hud-init-by-other :to obj))
                )
          )
      )
    (else
      (send-event (handle->process (-> obj tank-handle)) 'hide-and-die)
      (set! (-> obj tank-handle) (the-as handle #f))
      )
    )
  (none)
  )

(defbehavior underb-master-post underb-master ()
  #t
  (let ((gp-0 *target*))
    (let ((f30-0 0.0))
      (when (and gp-0 (not (-> *setting-control* user-current pilot-exit)))
        (let ((s5-0 (new 'stack-no-clear 'water-info)))
          (water-info-init! (-> gp-0 control) s5-0 (collide-action solid semi-solid))
          (let ((v1-7 (-> s5-0 flags)))
            (if (logtest? (water-flags touch-water) v1-7)
                (set! f30-0 (lerp-scale 0.0 1.0 (- (-> gp-0 control trans y) (-> s5-0 trans y)) -4096.0 -20480.0))
                )
            )
          )
        )
      (when (!= f30-0 (-> self under-water-pitch-mod))
        (set! (-> self under-water-pitch-mod) f30-0)
        (if (= f30-0 0.0)
            (remove-setting! 'under-water-pitch-mod)
            (set-setting! 'under-water-pitch-mod 'abs f30-0 0)
            )
        )
      )
    (if (or (not gp-0) (not (logtest? (-> gp-0 water flags) (water-flags under-water))))
        (set! (-> self air-charge-up?) #t)
        (set! (-> self underwater-time) (-> self clock frame-counter))
        )
    )
  (cond
    ((-> self air-charge-up?)
     (set! (-> self air-supply)
           (seek-with-smooth (-> self air-supply) 1.0 (* 2.0 (-> self clock seconds-per-frame)) 0.125 0.01)
           )
     (when (= (-> self air-supply) 1.0)
       (set! (-> self air-charge-up?) #f)
       (set! (-> self air-supply) 1.01)
       (set! (-> self last-air-beep-time) 0)
       0
       )
     )
    (else
      (seek! (-> self air-supply) 0.0 (* 0.04 (-> self clock seconds-per-frame)))
      (cond
        ((= (-> self air-supply) 0.0)
         (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-6 from) (process->ppointer self))
           (set! (-> a1-6 num-params) 2)
           (set! (-> a1-6 message) 'attack)
           (set! (-> a1-6 param 0) (the-as uint #f))
           (let ((v1-35 (new 'static 'attack-info :mask (attack-info-mask mode id))))
             (let* ((a0-11 *game-info*)
                    (a2-7 (+ (-> a0-11 attack-id) 1))
                    )
               (set! (-> a0-11 attack-id) a2-7)
               (set! (-> v1-35 id) a2-7)
               )
             (set! (-> v1-35 mode) 'air)
             (set! (-> a1-6 param 1) (the-as uint v1-35))
             )
           (send-event-function *target* a1-6)
           )
         )
        (else
          (when (>= 0.4 (-> self air-supply))
            (let ((v1-39 (the int (lerp-scale 90.0 300.0 (-> self air-supply) 0.0 0.4))))
              (when (>= (- (-> self clock frame-counter) (-> self last-air-beep-time)) v1-39)
                (set! (-> self last-air-beep-time) (-> self clock frame-counter))
                (sound-play "oxygen-warning")
                )
              )
            )
          )
        )
      )
    )
  (set! (-> *game-info* air-supply) (fmin 1.0 (-> self air-supply)))
  (if (or (and *target* (not (logtest? (focus-status mech) (-> *target* focus-status))))
          (and (>= (-> self air-supply) 1.0)
               (>= (- (-> self clock frame-counter) (-> self underwater-time)) (seconds 3))
               )
          )
      (spawn-air-tank-hud self #f)
      (spawn-air-tank-hud self #t)
      )
  (none)
  )

(defstate idle (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    0
    (none)
    )
  :trans (behavior ()
    (if (-> self big-room-entered)
        (go-virtual big-room-player-under)
        )
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

(defstate big-room-player-under (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    0
    (none)
    )
  :trans (behavior ()
    (if (-> self under-plat-player-on)
        (go-virtual big-room-player-plat)
        )
    (if (not (-> self big-room-entered))
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

(defstate big-room-player-plat (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    (set-setting! 'entity-name "camera-239" 0 0)
    (send-event (ppointer->process *underb-master*) 'request 'under-warp #f)
    (none)
    )
  :exit (behavior ()
    (remove-setting! 'entity-name)
    (none)
    )
  :trans (behavior ()
    (let ((gp-0 (target-pos 0)))
      (if (or (and (-> self under-plat-is-up) (-> self under-plat-player-on)) (< -245760.0 (-> gp-0 y)))
          (go-virtual big-room-player-above)
          )
      (if (and (not (-> self under-plat-player-on)) (< (-> gp-0 y) -245760.0))
          (go-virtual big-room-player-falling)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

(defstate big-room-player-above (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    (persist-with-delay *setting-control* 'interp-time (seconds 0.05) 'interp-time 'abs 600.0 0)
    (remove-setting! 'mode-name)
    (none)
    )
  :trans (behavior ()
    (if (< (-> (target-pos 0) y) -245760.0)
        (go-virtual big-room-player-falling)
        )
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

(defstate big-room-player-falling (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    (set-setting! 'mode-name 'cam-endlessfall 0 0)
    (none)
    )
  :exit (behavior ()
    (send-event (ppointer->process *underb-master*) 'request 'under-warp #t)
    (persist-with-delay *setting-control* 'interp-time (seconds 0.05) 'interp-time 'abs 0.0 0)
    (remove-setting! 'mode-name)
    (none)
    )
  :trans (behavior ()
    (cond
      ((not *target*)
       (go-virtual idle)
       )
      ((under-warp-check self)
       (if (< (-> (target-pos 0) y) -258048.0)
           (go-virtual big-room-player-exiting)
           )
       )
      (else
        (if (< (-> (target-pos 0) y) -278528.0)
            (go-virtual big-room-player-under)
            )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

(defstate big-room-player-exiting (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    (persist-with-delay *setting-control* 'interp-time (seconds 0.05) 'interp-time 'abs 0.0 0)
    (set-setting! 'entity-name "camera-244" 0 0)
    (set! (-> self big-room-timer) (-> self clock frame-counter))
    (send-event (ppointer->process *underb-master*) 'request 'under-warp #t)
    (none)
    )
  :exit (behavior ()
    (persist-with-delay *setting-control* 'interp-time (seconds 0.05) 'interp-time 'abs 600.0 0)
    (remove-setting! 'entity-name)
    (none)
    )
  :trans (behavior ()
    (if (>= (- (-> self clock frame-counter) (-> self big-room-timer)) (seconds 1))
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

(defstate big-room-player-done (underb-master)
  :virtual #t
  :event underb-master-event-handler
  :enter (behavior ()
    (go-virtual idle)
    (none)
    )
  :code (the-as (function none :behavior underb-master) sleep-code)
  :post underb-master-post
  )

;; WARN: Return type mismatch object vs none.
(defbehavior underb-master-init-by-other underb-master ((arg0 level))
  (set! *underb-master* (the-as (pointer underb-master) (process->ppointer self)))
  (set! (-> self warp-handle) (the-as handle #f))
  (set! (-> self tank-handle) (the-as handle #f))
  (set! (-> self level) arg0)
  (set! (-> self air-supply) 1.0)
  (set! (-> self air-charge-up?) #f)
  (set! (-> self ambient-sound-id) (new 'static 'sound-id))
  (set! (-> self big-room-entered) #f)
  (set! (-> self under-plat-player-on) #f)
  (set! (-> self under-plat-is-up) #f)
  (go-virtual idle)
  (none)
  )

(defun underb-login ((arg0 level))
  (set! *nav-network* (new 'loading-level 'nav-network))
  (nav-network-method-9 *nav-network*)
  0
  (none)
  )

(defun underb-deactivate ((arg0 level))
  (set! *nav-network* (the-as nav-network 0))
  0
  (none)
  )

(defun underb-activate ((arg0 level))
  (nav-network-method-10 *nav-network* arg0 *under-adjacency*)
  (let ((v1-3 (process-spawn underb-master arg0 :to *entity-pool*)))
    (if v1-3
        (set! (-> v1-3 0 level) arg0)
        )
    )
  0
  (none)
  )

(deftype under-locking (process-drawable)
  ((id                  int8                      :offset-assert 200)
   (up-y                float                     :offset-assert 204)
   (down-y              float                     :offset-assert 208)
   (mode                uint64                    :offset-assert 216)
   (which-reminder?     symbol                    :offset-assert 224)
   (spooled-sound-id    uint32                    :offset-assert 228)
   (draining-part       sparticle-launch-control  :offset-assert 232)
   (actor-group         (pointer actor-group)     :offset-assert 236)
   (spooled-sound-delay int32                     :offset-assert 240)
   (last-reminder-time  time-frame                :offset        256)
   )
  :heap-base #x90
  :method-count-assert 24
  :size-assert         #x108
  :flag-assert         #x1800900108
  (:methods
    (startup () _type_ :state 20)
    (active () _type_ :state 21)
    (filling () _type_ :state 22)
    (draining () _type_ :state 23)
    )
  )


;; WARN: Return type mismatch process-drawable vs under-locking.
(defmethod relocate under-locking ((obj under-locking) (arg0 int))
  (if (nonzero? (-> obj draining-part))
      (&+! (-> obj draining-part) arg0)
      )
  (the-as under-locking ((method-of-type process-drawable relocate) obj arg0))
  )

(defmethod deactivate under-locking ((obj under-locking))
  (if (nonzero? (-> obj draining-part))
      (kill-and-free-particles (-> obj draining-part))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

(defstate startup (under-locking)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('test)
                      #f
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (none)
    )
  :trans (behavior ()
    (let ((v1-0 (-> self actor-group)))
      (cond
        ((and v1-0
              (let ((a0-2 (-> v1-0 0 data 0 actor)))
                (if a0-2
                    (-> a0-2 extra process)
                    )
                )
              (let ((a0-5 (-> v1-0 0 data 1 actor)))
                (if a0-5
                    (-> a0-5 extra process)
                    )
                )
              (let ((a1-2 (-> v1-0 0 data 2 actor)))
                (if a1-2
                    (-> a1-2 extra process)
                    )
                )
              )
         (when (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.1))
           (let ((a0-13 (-> v1-0 0 data 0 actor)))
             (if a0-13
                 (-> a0-13 extra process)
                 )
             )
           (let ((v1-2 (-> v1-0 0 data 1 actor)))
             (if v1-2
                 (-> v1-2 extra process)
                 )
             )
           (let ((a1-6 *target*))
             (cond
               ((and a1-6 (focus-test? a1-6 mech))
                (set! (-> self mode) (the-as uint 3))
                (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
                  (set! (-> a1-8 from) (process->ppointer self))
                  (set! (-> a1-8 num-params) 1)
                  (set! (-> a1-8 message) 'move-to-y)
                  (set! (-> a1-8 param 0) (the-as uint (-> self up-y)))
                  (let ((t9-0 send-event-function)
                        (v1-13 (-> self actor-group 0 data 2 actor))
                        )
                    (t9-0
                      (if v1-13
                          (-> v1-13 extra process)
                          )
                      a1-8
                      )
                    )
                  )
                )
               (else
                 (set! (-> self mode) (the-as uint 0))
                 (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
                   (set! (-> a1-9 from) (process->ppointer self))
                   (set! (-> a1-9 num-params) 1)
                   (set! (-> a1-9 message) 'move-to-y)
                   (set! (-> a1-9 param 0) (the-as uint (-> self down-y)))
                   (let ((t9-1 send-event-function)
                         (v1-22 (-> self actor-group 0 data 2 actor))
                         )
                     (t9-1
                       (if v1-22
                           (-> v1-22 extra process)
                           )
                       a1-9
                       )
                     )
                   )
                 )
               )
             )
           (go-virtual active)
           )
         )
        (else
          (set! (-> self state-time) (-> self clock frame-counter))
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior under-locking) sleep-code)
  )

(defstate active (under-locking)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('test)
       (let ((v1-1 (-> self mode)))
         (cond
           ((-> event param 0)
            (when (or (zero? v1-1) (= v1-1 5))
              (let ((a0-4 *target*))
                (and a0-4 (not (logtest? (focus-status mech) (-> a0-4 focus-status))))
                )
              )
            )
           (else
             (or (= v1-1 2) (= v1-1 3))
             )
           )
         )
       )
      )
    )
  :trans (behavior ()
    (let ((v1-0 (-> self mode)))
      (cond
        ((zero? v1-0)
         (let ((v1-1 *target*)
               (a0-1 (-> self actor-group))
               )
           (when (and v1-1 a0-1)
             (if (and (-> a0-1 0 data 0 actor)
                      (focus-test? v1-1 mech)
                      (send-event (ppointer->process *underb-master*) 'request 'mech #t)
                      )
                 (set! (-> self mode) (the-as uint 1))
                 )
             )
           )
         )
        ((= v1-0 1)
         (if (not (logtest? (-> self actor-group 0 data 0 actor extra perm status) (entity-perm-status subtask-complete)))
             (go-virtual filling)
             )
         )
        ((= v1-0 2)
         (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-2 from) (process->ppointer self))
           (set! (-> a1-2 num-params) 0)
           (set! (-> a1-2 message) 'front)
           (let ((t9-2 send-event-function)
                 (v1-24 (-> self actor-group 0 data 1 actor))
                 )
             (if (not (t9-2
                        (if v1-24
                            (-> v1-24 extra process)
                            )
                        a1-2
                        )
                      )
                 (set! (-> self mode) (the-as uint 3))
                 )
             )
           )
         )
        ((= v1-0 3)
         (if (>= 20480.0 (vector-vector-xz-distance (target-pos 0) (-> self root trans)))
             (set! (-> self mode) (the-as uint 4))
             )
         )
        ((= v1-0 4)
         (go-virtual draining)
         )
        ((= v1-0 5)
         (let ((a1-4 *target*))
           (when (or (not a1-4) (not (logtest? (focus-status mech) (-> a1-4 focus-status))))
             (set! (-> self mode) (the-as uint 0))
             0
             )
           )
         (when (>= (- (-> self clock frame-counter) (-> self last-reminder-time)) (seconds 9))
           (set! (-> self last-reminder-time) (-> self clock frame-counter))
           (add-process
             *gui-control*
             self
             (gui-channel ashelin)
             (gui-action play)
             (if (-> self which-reminder?)
                 "cityv193"
                 "cityv192"
                 )
             -99.0
             0
             )
           (set! (-> self which-reminder?) (not (-> self which-reminder?)))
           )
         )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior under-locking) sleep-code)
  )

(defstate filling (under-locking)
  :virtual #t
  :event (-> (method-of-type under-locking active) event)
  :enter (behavior ()
    (set! (-> self spooled-sound-id)
          (the-as uint (add-process *gui-control* self (gui-channel ashelin) (gui-action queue) "wtrfill" -99.0 0))
          )
    (set! (-> self state-time) 0)
    (set! (-> self spooled-sound-delay) (if (= (-> self id) 1)
                                            120
                                            0
                                            )
          )
    (none)
    )
  :trans (behavior ()
    (when (and (zero? (-> self state-time))
               ;; TODO remove when gui-control works
               ;; (= (get-status *gui-control* (the-as sound-id (-> self spooled-sound-id))) (gui-status ready))
               )
      (set! (-> self state-time) (-> self clock frame-counter))
      (set! (-> self last-reminder-time) (-> self clock frame-counter))
      )
    (when (nonzero? (-> self state-time))
      (when (and (>= (-> self spooled-sound-delay) 0)
                 (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self spooled-sound-delay))
                 )
        (set-action!
          *gui-control*
          (gui-action play)
          (the-as sound-id (-> self spooled-sound-id))
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        (set! (-> self spooled-sound-delay) -1)
        )
      (let* ((v1-21 (-> self actor-group 0 data 2 actor))
             (gp-0 (if v1-21
                       (-> v1-21 extra process)
                       )
                   )
             )
        (when gp-0
          (let ((f0-0 (-> (the-as water-anim gp-0) root trans y)))
            (when (!= f0-0 (-> self up-y))
              (let ((f0-4 (seek f0-0 (-> self up-y) (* 12288.0 (-> self clock seconds-per-frame)))))
                (send-event gp-0 'move-to-y f0-4)
                )
              )
            )
          (if (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 2))
              (spawn (-> self part) (-> self root trans))
              )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (while (zero? (-> self state-time))
      (suspend)
      )
    (until #f
      (let* ((v1-4 (-> self actor-group 0 data 2 actor))
             (gp-0 (if v1-4
                       (-> v1-4 extra process)
                       )
                   )
             )
        (when gp-0
          (if (< (- (-> (camera-pos) y) (-> (the-as water-anim gp-0) root trans y)) 22528.0)
              (goto cfg-11)
              )
          )
        )
      (suspend)
      )
    #f
    (label cfg-11)
    (let ((a3-1 (res-lump-struct (-> self entity) 'camera-name structure)))
      (if a3-1
          (set-setting! 'entity-name a3-1 0 0)
          )
      )
    (until #f
      (let* ((a0-2 (-> self actor-group 0 data 2 actor))
             (v1-19 (if a0-2
                        (-> a0-2 extra process)
                        )
                    )
             )
        (when v1-19
          (when (= (-> (the-as water-anim v1-19) root trans y) (-> self up-y))
            (persist-with-delay *setting-control* 'interp-time (seconds 0.05) 'interp-time 'abs 0.0 0)
            (remove-setting! 'entity-name)
            (send-event (ppointer->process *underb-master*) 'request 'under-warp #t)
            (set! (-> self mode) (the-as uint 2))
            (go-virtual active)
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate draining (under-locking)
  :virtual #t
  :event (-> (method-of-type under-locking active) event)
  :enter (behavior ()
    (set! (-> self spooled-sound-id)
          (the-as uint (add-process *gui-control* self (gui-channel ashelin) (gui-action queue) "wtrdrain" -99.0 0))
          )
    (set! (-> self state-time) 0)
    0
    (none)
    )
  :trans (behavior ()
    (when (and (zero? (-> self state-time))
               ;; TODO this always returns false?
               ;; (= (get-status *gui-control* (the-as sound-id (-> self spooled-sound-id))) (gui-status ready))
               )
      (set! (-> self state-time) (-> self clock frame-counter))
      (set! (-> self last-reminder-time) (-> self clock frame-counter))
      (set-action!
        *gui-control*
        (gui-action play)
        (the-as sound-id (-> self spooled-sound-id))
        (gui-channel none)
        (gui-action none)
        (the-as string #f)
        (the-as (function gui-connection symbol) #f)
        (the-as process #f)
        )
      )
    (when (nonzero? (-> self state-time))
      (let* ((v1-14 (-> self actor-group 0 data 2 actor))
             (gp-0 (if v1-14
                       (-> v1-14 extra process)
                       )
                   )
             )
        (when gp-0
          (let ((f0-0 (-> (the-as water-anim gp-0) root trans y)))
            (when (!= f0-0 (-> self down-y))
              (let ((f0-4 (seek f0-0 (-> self down-y) (* 12288.0 (-> self clock seconds-per-frame)))))
                (send-event gp-0 'move-to-y f0-4)
                )
              )
            )
          (if (< (- (-> self clock frame-counter) (-> self state-time)) (seconds 1))
              (spawn (-> self draining-part) (-> self root trans))
              )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (while (zero? (-> self state-time))
      (suspend)
      )
    (let ((a3-1 (res-lump-struct (-> self entity) 'camera-name structure)))
      (if a3-1
          (set-setting! 'entity-name a3-1 0 0)
          )
      )
    (send-event (ppointer->process *underb-master*) 'request 'under-warp #f)
    (until #f
      (let* ((a0-3 (-> self actor-group 0 data 2 actor))
             (v1-15 (if a0-3
                        (-> a0-3 extra process)
                        )
                    )
             )
        (when v1-15
          (if (< (-> (the-as water-anim v1-15) root trans y) (+ 10240.0 (-> (target-pos 0) y)))
              (goto cfg-17)
              )
          )
        )
      (suspend)
      )
    #f
    (label cfg-17)
    (remove-setting! 'entity-name)
    (until #f
      (let* ((a0-8 (-> self actor-group 0 data 2 actor))
             (v1-26 (if a0-8
                        (-> a0-8 extra process)
                        )
                    )
             )
        (when v1-26
          (when (= (-> (the-as water-anim v1-26) root trans y) (-> self down-y))
            (set! (-> self mode) (the-as uint 5))
            (send-event (ppointer->process *underb-master*) 'request 'mech #f)
            (set! (-> self which-reminder?) #f)
            (go-virtual active)
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-locking ((obj under-locking) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (set! (-> obj which-reminder?) #f)
  (set! (-> obj spooled-sound-id) (the-as uint 0))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (set! (-> obj id) (res-lump-value arg0 'extra-id int :time -1000000000.0))
  (let ((f0-0 (-> obj root trans y)))
    (set! (-> obj up-y) (+ 49152.0 f0-0))
    (set! (-> obj down-y) (+ f0-0 (if (= (-> obj id) 2)
                                      -16384.0
                                      -20480.0
                                      )
                             )
          )
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((a0-6 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (if (and a0-6 (nonzero? (-> sv-16 elt-count)))
        (set! (-> obj actor-group) (the-as (pointer actor-group) a0-6))
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        )
    )
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 498) obj))
  (set! (-> obj draining-part) (create-launch-control (-> *part-group-id-table* 499) obj))
  (go (method-of-object obj startup))
  (none)
  )

(deftype water-anim-under (water-anim)
  ()
  :heap-base #x80
  :method-count-assert 29
  :size-assert         #x100
  :flag-assert         #x1d00800100
  )


(define ripple-for-water-anim-under (new 'static 'ripple-wave-set
                                      :count 3
                                      :converted #f
                                      :normal-scale 1.0
                                      :wave (new 'static 'inline-array ripple-wave 4
                                        (new 'static 'ripple-wave :scale 40.0 :xdiv 1 :speed 1.5)
                                        (new 'static 'ripple-wave :scale 40.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                        (new 'static 'ripple-wave :scale 20.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                        (new 'static 'ripple-wave)
                                        )
                                      )
        )

(defmethod init-water! water-anim-under ((obj water-anim-under))
  "Initialize a [[water-anim]]'s default settings, this may include applying a [[riple-control]]"
  (let ((t9-0 (method-of-type water-anim init-water!)))
    (t9-0 obj)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> obj draw ripple) v1-2)
    (set-vector! (-> obj draw color-mult) 0.01 0.45 0.5 0.75)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-water-anim-under)
    )
  0
  (none)
  )
