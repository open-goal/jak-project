;;-*-Lisp-*-
(in-package goal)

;; name: metalkor-extras.gc
;; name in dgo: metalkor-extras
;; dgos: NEB

;; DECOMP BEGINS

(defbehavior metalkor-egg-handler metalkor-egg ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('track)
     #f
     )
    (('bonk)
     (go-virtual egg-pop)
     )
    (('attack)
     (go-virtual egg-pop)
     )
    )
  )

(defstate egg-pop (metalkor-egg)
  :virtual #t
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 5)))
         (ja :num! (seek!))
         (if (ja-done? 0)
             (deactivate self)
             )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! (-> self draw art-group data 5))
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    (do-push-aways (-> self root))
    )
  )

(defstate hatch (metalkor-egg)
  :virtual #t
  :enter (behavior ()
    (send-event (ppointer->process (-> self parent)) 'setup-flitter-gem)
    (let ((s5-0 (new 'stack-no-clear 'enemy-init-by-other-params)))
      (set! (-> s5-0 trans quad) (-> self root trans quad))
      (quaternion-copy! (-> s5-0 quat) (-> self root quat))
      (set! (-> s5-0 entity) (-> self entity))
      (set! (-> s5-0 directed?) #f)
      (set! (-> s5-0 no-initial-move-to-ground?) #f)
      (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> gp-0 from) (process->ppointer self))
        (set! (-> gp-0 num-params) 2)
        (set! (-> gp-0 message) 'hatch)
        (set! (-> gp-0 param 0) (the-as uint (-> self flitter-slot)))
        (let ((s4-0 (get-process *default-dead-pool* metalkor-flitter #x4000)))
          (set! (-> gp-0 param 1)
                (the-as uint (ppointer->handle (when s4-0
                                                 (let ((t9-3 (method-of-type process activate)))
                                                   (t9-3
                                                     s4-0
                                                     (ppointer->process (-> self parent))
                                                     (symbol->string (-> metalkor-flitter symbol))
                                                     (the-as pointer #x70004000)
                                                     )
                                                   )
                                                 (run-now-in-process s4-0 enemy-init-by-other self s5-0)
                                                 (-> s4-0 ppointer)
                                                 )
                                               )
                        )
                )
          )
        (send-event-function (ppointer->process (-> self parent)) gp-0)
        )
      )
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 5)))
         (ja :num! (seek!))
         (if (ja-done? 0)
             (deactivate self)
             )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! (-> self draw art-group data 5))
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    (do-push-aways (-> self root))
    )
  )

(defstate fall (metalkor-egg)
  :virtual #t
  :event metalkor-egg-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (local-vars (v1-5 float) (v1-27 float) (v1-34 float))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (set! (-> gp-0 quad) (-> self root transv quad))
        (.lvf vf1 (&-> (-> self root transv) quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov v1-5 vf1)
        (let ((f0-0 v1-5)
              (f1-0 409.6)
              )
          (cond
            ((< f0-0 (* f1-0 f1-0))
             (go-virtual idle)
             )
            ((time-elapsed? (-> self state-time) (seconds 4))
             (go-virtual hatch)
             )
            (else
              (vector-v++!
                (-> self root transv)
                (compute-acc-due-to-gravity (the-as collide-shape-moving (-> self root)) (new-stack-vector0) 1.0)
                )
              (let ((a2-1 (new 'stack-no-clear 'collide-query)))
                (set! (-> a2-1 collide-with) (collide-spec backgnd enemy obstacle hit-by-others-list pusher))
                (set! (-> a2-1 ignore-process0) self)
                (set! (-> a2-1 ignore-process1) #f)
                (set! (-> a2-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                (set! (-> a2-1 action-mask) (collide-action solid))
                (fill-cache-integrate-and-collide
                  (the-as collide-shape-moving (-> self root))
                  (-> (the-as collide-shape-moving (-> self root)) transv)
                  a2-1
                  (meters 0)
                  )
                )
              )
            )
          )
        (let* ((f0-1 81920.0)
               (f0-3 (* f0-1 f0-1))
               )
          (.lvf vf1 (&-> gp-0 quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov v1-27 vf1)
          (cond
            ((and (< f0-3 v1-27) (let* ((f0-4 81920.0)
                                        (f0-6 (* f0-4 f0-4))
                                        )
                                   (.lvf vf1 (&-> (-> self root transv) quad))
                                   (.add.w.vf vf2 vf0 vf0 :mask #b1)
                                   (.mul.vf vf1 vf1 vf1)
                                   (.mul.x.vf acc vf2 vf1 :mask #b1)
                                   (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                                   (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                                   (.mov v1-34 vf1)
                                   (>= f0-6 v1-34)
                                   )
                  )
             (ja-channel-push! 1 (seconds 0.1))
             (ja :group! (-> self draw art-group data 4))
             )
            (else
              (let ((v1-40 (ja-group)))
                (cond
                  ((and v1-40 (= v1-40 (-> self draw art-group data 4)))
                   (ja :num! (seek!))
                   (when (ja-done? 0)
                     (ja-channel-push! 1 (seconds 0.1))
                     (ja :group! (-> self draw art-group data 3))
                     )
                   )
                  (else
                    (ja :num! (loop!))
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

(defstate idle (metalkor-egg)
  :virtual #t
  :event metalkor-egg-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (time-elapsed? (-> self state-time) (seconds 3))
        (go-virtual hatch)
        )
    (let ((v1-9 (ja-group)))
      (cond
        ((and v1-9 (= v1-9 (-> self draw art-group data 3)))
         (ja :num! (loop!))
         )
        ((let ((v1-17 (ja-group)))
           (and v1-17 (or (= v1-17 (-> self draw art-group data 7)) (= v1-17 (-> self draw art-group data 4))))
           )
         (ja :num! (seek!))
         (when (ja-done? 0)
           (ja-channel-push! 1 (seconds 0.1))
           (ja :group! (-> self draw art-group data 3))
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! (-> self draw art-group data 4))
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (ja-post)
    (do-push-aways (-> self root))
    )
  )

(defun metalkor-shot-move ((arg0 metalkor-shot))
  (set! (-> arg0 old-transv quad) (-> arg0 root transv quad))
  (projectile-move-fill-line-sphere arg0)
  (let ((s5-0 (-> arg0 root)))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (vector-! s4-0 (-> arg0 tail-pos) (-> s5-0 trans))
      (let ((f0-0 (vector-length s4-0)))
        (when (< 49152.0 f0-0)
          (vector-normalize! s4-0 49152.0)
          (vector+! (-> arg0 tail-pos) (-> s5-0 trans) s4-0)
          )
        )
      )
    (if (logtest? (-> s5-0 status) (collide-status touch-surface))
        (go (method-of-object arg0 impact))
        )
    )
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod init-proj-settings! metalkor-shot ((this metalkor-shot))
  "Init relevant settings for the [[projectile]] such as gravity, speed, timeout, etc"
  (set! (-> this tail-pos quad) (-> this root trans quad))
  (set! (-> this attack-mode) 'metalhead-shot)
  (set! (-> this max-speed) 532480.0)
  (set! (-> this move) metalkor-shot-move)
  (set! (-> this timeout) (seconds 0.767))
  (set-gravity-length (-> this root dynam) 573440.0)
  (set! (-> this old-transv quad) (-> this root transv quad))
  (none)
  )

(defmethod spawn-shell-particles metalkor-shot ((this metalkor-shot))
  "TODO - confirm"
  (local-vars
    (sv-224 (function vector entity-actor skeleton-group vector object none :behavior manipy))
    (sv-240 vector)
    (sv-256 entity-actor)
    )
  (let* ((s4-0 (-> this root))
         (v0-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> this tail-pos) (-> s4-0 trans)) 2048.0))
         (gp-0 (new 'stack-no-clear 'vector))
         )
    (set! (-> gp-0 quad) (-> s4-0 trans quad))
    (vector+! gp-0 gp-0 v0-0)
    (let ((s4-1 (get-process *default-dead-pool* part-tracker #x4000)))
      (when s4-1
        (let ((t9-2 (method-of-type part-tracker activate)))
          (t9-2
            (the-as part-tracker s4-1)
            *entity-pool*
            (symbol->string (-> part-tracker symbol))
            (the-as pointer #x70004000)
            )
          )
        (let ((t9-3 run-function-in-process)
              (a0-7 s4-1)
              (a1-5 part-tracker-init)
              (a2-4 (-> *part-group-id-table* 141))
              (a3-1 0)
              (t0-0 #f)
              (t1-0 #f)
              (t2-0 #f)
              (t3-0 *launch-matrix*)
              )
          (set! (-> t3-0 trans quad) (-> gp-0 quad))
          ((the-as (function object object object object object object object object none) t9-3)
           a0-7
           a1-5
           a2-4
           a3-1
           t0-0
           t1-0
           t2-0
           t3-0
           )
          )
        (-> s4-1 ppointer)
        )
      )
    )
  (let ((s4-2 (new 'stack-no-clear 'vector)))
    (set! (-> s4-2 quad) (-> this root trans quad))
    (let ((gp-1 (new 'stack-no-clear 'quaternion)))
      (let ((s3-0 (lambda :behavior metalkor-shot
                    ()
                    (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 1.0)
                    (cond
                      ((>= 10.0 (ja-aframe-num 0))
                       (let ((v0-1 (the-as vector (-> self draw color-emissive))))
                         (set! (-> (the-as rgbaf v0-1) x) 1.0)
                         (set! (-> (the-as rgbaf v0-1) y) 1.0)
                         (set! (-> (the-as rgbaf v0-1) z) 1.0)
                         (set! (-> (the-as rgbaf v0-1) w) 1.0)
                         v0-1
                         )
                       )
                      ((>= 20.0 (ja-aframe-num 0))
                       (vector-lerp!
                         (-> self draw color-emissive)
                         (new 'static 'vector :x 1.0 :y 1.0 :z 1.0 :w 1.0)
                         (new 'static 'vector :x 0.5 :z 0.5 :w 1.0)
                         (lerp-scale 0.0 1.0 (ja-aframe-num 0) 10.0 20.0)
                         )
                       )
                      (else
                        (vector-lerp!
                          (-> self draw color-emissive)
                          (new 'static 'vector :x 0.5 :z 0.5 :w 1.0)
                          (new 'static 'vector :w 1.0)
                          (lerp-scale 0.0 1.0 (ja-aframe-num 0) 20.0 30.0)
                          )
                        )
                      )
                    )
                  )
            )
        (let ((s2-0 (new 'stack-no-clear 'matrix)))
          (vector-normalize-copy! (-> s2-0 vector 1) (-> this old-transv) -1.0)
          (cond
            ((and (< (fabs (-> s2-0 vector 1 y)) (fabs (-> s2-0 vector 1 x)))
                  (< (fabs (-> s2-0 vector 1 y)) (fabs (-> s2-0 vector 1 z)))
                  )
             (set-vector! (-> s2-0 vector 2) (-> s2-0 vector 1 z) 0.0 (- (-> s2-0 vector 1 x)) 1.0)
             )
            ((< (fabs (-> s2-0 vector 1 z)) (fabs (-> s2-0 vector 1 x)))
             (set-vector! (-> s2-0 vector 2) (-> s2-0 vector 1 y) (- (-> s2-0 vector 1 x)) 0.0 1.0)
             )
            (else
              (set-vector! (-> s2-0 vector 2) 0.0 (-> s2-0 vector 1 z) (- (-> s2-0 vector 1 y)) 0.0)
              )
            )
          (vector-normalize! (-> s2-0 vector 2) 1.0)
          (vector-cross! (the-as vector (-> s2-0 vector)) (-> s2-0 vector 1) (-> s2-0 vector 2))
          (matrix->quaternion gp-1 s2-0)
          )
        (sound-play "nboss-shoot-hit")
        (let* ((s1-1 (get-process *default-dead-pool* manipy #x4000))
               (s2-2
                 (when s1-1
                   (let ((t9-10 (method-of-type manipy activate)))
                     (t9-10 (the-as manipy s1-1) *default-pool* (symbol->string (-> manipy symbol)) (the-as pointer #x70004000))
                     )
                   (let ((s2-3 run-function-in-process)
                         (s0-0 s1-1)
                         )
                     (set! sv-224 manipy-init)
                     (set! sv-240 s4-2)
                     (set! sv-256 (-> this entity))
                     (let ((t0-2 (art-group-get-by-name *level* "skel-bomb-blast" (the-as (pointer uint32) #f)))
                           (t1-2 #f)
                           (t2-2 0)
                           )
                       ((the-as (function object object object object object object object none) s2-3)
                        s0-0
                        sv-224
                        sv-240
                        sv-256
                        t0-2
                        t1-2
                        t2-2
                        )
                       )
                     )
                   (-> s1-1 ppointer)
                   )
                 )
               )
          (when s2-2
            (send-event (ppointer->process s2-2) 'anim-mode 'play1)
            (send-event (ppointer->process s2-2) 'anim "idle")
            (set-vector! (-> (the-as process-drawable (-> s2-2 0)) root scale) 0.4 1.0 0.4 1.0)
            (send-event (ppointer->process s2-2) 'trans-hook s3-0)
            (send-event (ppointer->process s2-2) 'rot-quat gp-1)
            )
          )
        )
      (let ((s3-1 (process-spawn
                    manipy
                    :init manipy-init
                    s4-2
                    (-> this entity)
                    (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer uint32) #f))
                    #f
                    0
                    )
                  )
            )
        (when s3-1
          (send-event (ppointer->process s3-1) 'anim-mode 'play1)
          (send-event (ppointer->process s3-1) 'anim "idle")
          (set-vector! (-> (the-as process-drawable (-> s3-1 0)) root scale) 0.4 1.0 0.4 1.0)
          (send-event (ppointer->process s3-1) 'rot-quat gp-1)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod get-trans metalkor-legs ((this metalkor-legs) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (cond
    ((or (= arg0 2) (= arg0 3))
     (let ((v0-0 (new 'static 'vector :w 1.0)))
       (set! (-> v0-0 quad)
             (-> (the-as collide-shape-prim-group (-> this root root-prim)) child 0 prim-core world-sphere quad)
             )
       (+! (-> v0-0 y) 32768.0)
       v0-0
       )
     )
    (else
      ((method-of-type process-focusable get-trans) this arg0)
      )
    )
  )

;; WARN: Return type mismatch process-focusable vs metalkor-legs.
(defmethod relocate metalkor-legs ((this metalkor-legs) (arg0 int))
  (dotimes (v1-0 6)
    (if (nonzero? (-> this joint-ik v1-0))
        (&+! (-> this joint-ik v1-0) arg0)
        )
    )
  (the-as metalkor-legs ((method-of-type process-focusable relocate) this arg0))
  )

(defbehavior metalkor-legs-handler metalkor-legs ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (case arg2
    (('track)
     (-> self trackable)
     )
    (('attack)
     (let ((v1-1 (new 'stack-no-clear 'event-message-block)))
       (set! (-> v1-1 from) (process->ppointer arg0))
       (set! (-> v1-1 num-params) arg1)
       (set! (-> v1-1 message) arg2)
       (set! (-> v1-1 param 0) (-> arg3 param 0))
       (set! (-> v1-1 param 1) (-> arg3 param 1))
       (set! (-> v1-1 param 2) (-> arg3 param 2))
       (set! (-> v1-1 param 3) (-> arg3 param 3))
       (set! (-> v1-1 param 4) (-> arg3 param 4))
       (set! (-> v1-1 param 5) (-> arg3 param 5))
       (send-event-function (ppointer->process (-> self parent)) v1-1)
       )
     )
    (('color)
     (set! (-> self draw color-mult quad) (-> (the-as rgbaf (-> arg3 param 0)) quad))
     (set! v0-0 (-> self draw color-emissive))
     (set! (-> (the-as rgbaf v0-0) quad) (-> (the-as rgbaf (-> arg3 param 1)) quad))
     v0-0
     )
    (('trackable)
     (set! v0-0 (-> arg3 param 0))
     (set! (-> self trackable) (the-as symbol v0-0))
     v0-0
     )
    (('ja-float)
     (dotimes (s5-0 3)
       (when (not (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim))
         (set! (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim)
               (get-art-by-name (-> self draw art-group) (the-as string (-> arg3 param 0)) art-joint-anim)
               )
         (set! (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 channel-index)
               (the-as int (-> arg3 param 1))
               )
         (return #t)
         )
       )
     #f
     )
    )
  )

(defbehavior ik-adjust metalkor-legs ()
  (let* ((f0-1 (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
         (f0-2 (* 9102.223 f0-1))
         (f0-3 (- f0-2 (* (the float (the int (/ f0-2 65536.0))) 65536.0)))
         (f0-4 (sin f0-3))
         )
    (* 8192.0 f0-4)
    )
  )

(defbehavior metalkor-update-ik metalkor-legs ()
  (local-vars (sv-736 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-query))
          (s5-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat)))
          )
      (let ((v1-1 (-> gp-0 bbox))
            (a0-2 (-> self root trans))
            (a1-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-1 x) 32768.0)
        (set! (-> a1-1 y) 32768.0)
        (set! (-> a1-1 z) 32768.0)
        (set! (-> a1-1 w) 1.0)
        (vector-! (the-as vector v1-1) a0-2 a1-1)
        )
      (let ((v1-3 (-> gp-0 bbox max))
            (a0-4 (-> self root trans))
            (a1-2 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-2 x) 32768.0)
        (set! (-> a1-2 y) 32768.0)
        (set! (-> a1-2 z) 32768.0)
        (set! (-> a1-2 w) 1.0)
        (vector+! v1-3 a0-4 a1-2)
        )
      (set! (-> gp-0 collide-with) (collide-spec backgnd))
      (set! (-> gp-0 ignore-process0) #f)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (fill-using-bounding-box *collide-cache* gp-0)
      (dotimes (s4-0 6)
        (-> self joint-ik s4-0 shoulder-matrix-no-ik)
        (let ((a2-8 (-> self joint-ik s4-0 elbow-matrix-no-ik))
              (s2-0 (new 'stack-no-clear 'vector))
              (v1-15 (new 'stack-no-clear 'vector))
              )
          (set! (-> v1-15 quad) (-> (new 'static 'vector :y 1.0) quad))
          (new 'stack-no-clear 'vector)
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (let ((a1-4 s2-0))
              (let ((a0-9 (-> a2-8 trans)))
                (let ((a2-9 (-> a2-8 vector 1)))
                  (let ((a3-3 (-> *metalkor-ik-setup* s4-0 hand-dist)))
                    (.mov vf7 a3-3)
                    )
                  (.lvf vf5 (&-> a2-9 quad))
                  )
                (.lvf vf4 (&-> a0-9 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-4 quad) vf6)
              )
            (set! (-> s3-0 quad) (-> s2-0 quad))
            (let ((a2-10 (-> gp-0 start-pos)))
              (let ((a0-11 s3-0))
                (let ((a1-7 v1-15))
                  (let ((a3-5 24576.0))
                    (.mov vf7 a3-5)
                    )
                  (.lvf vf5 (&-> a1-7 quad))
                  )
                (.lvf vf4 (&-> a0-11 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a2-10 quad) vf6)
              )
            (vector-float*! (-> gp-0 move-dist) v1-15 -73728.0)
            (let ((v1-16 gp-0))
              (set! (-> v1-16 radius) 40.96)
              (set! (-> v1-16 collide-with) (collide-spec backgnd))
              (set! (-> v1-16 ignore-process0) #f)
              (set! (-> v1-16 ignore-process1) #f)
              (set! (-> v1-16 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-16 action-mask) (collide-action solid))
              )
            (let ((f0-12 (probe-using-line-sphere *collide-cache* gp-0)))
              (when (>= f0-12 0.0)
                (let ((f1-2 (vector-dot (-> s5-0 vector 1) (vector-! (new 'stack-no-clear 'vector) s2-0 (-> self root trans)))))
                  (cond
                    ((>= 409.6 f1-2)
                     (vector+float*! s3-0 (-> gp-0 start-pos) (-> gp-0 move-dist) f0-12)
                     (set! (-> self foot-locks s4-0 lock target) 1.0)
                     )
                    (else
                      (vector+float*! s3-0 (-> gp-0 start-pos) (-> gp-0 move-dist) (- f0-12 (* 0.000013563368 f1-2)))
                      (set! (-> self foot-locks s4-0 lock target) 0.0)
                      )
                    )
                  )
                )
              )
            ((method-of-type cam-float-seeker update!) (the-as cam-float-seeker (-> self foot-locks s4-0)) 0.0)
            (cond
              ((-> self foot-locks s4-0 initialized)
               (let ((s2-1 vector-lerp!)
                     (s1-0 s3-0)
                     (s0-0 s3-0)
                     )
                 (set! sv-736 (the-as vector (+ (the-as uint (-> self foot-locks 0 old-position)) (* s4-0 64))))
                 (let ((a3-6 (parameter-ease-sin-clamp (-> self foot-locks s4-0 lock value))))
                   (s2-1 s1-0 s0-0 sv-736 a3-6)
                   )
                 )
               )
              (else
                (set! (-> self foot-locks s4-0 initialized) #t)
                )
              )
            (handle-copy! (-> self joint-ik s4-0) s3-0)
            (set! (-> (the-as (pointer uint128) (+ (the-as uint (-> self foot-locks 0 old-position)) (* s4-0 64))))
                  (-> s3-0 quad)
                  )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defstate idle (metalkor-legs)
  :virtual #t
  :event metalkor-legs-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (dotimes (gp-0 6)
      (enable-set! (-> self joint-ik gp-0) #t)
      ((method-of-type cam-float-seeker init) (the-as cam-float-seeker (-> self foot-locks gp-0)) 0.0 0.1 0.3 0.9)
      (set! (-> self foot-locks gp-0 initialized) #f)
      )
    )
  :trans (behavior ()
    (clone-anim-once (ppointer->handle (-> self parent)) #t (-> self prefix))
    (let ((gp-0 (ppointer->process (-> self parent))))
      (when gp-0
        (dotimes (s5-0 3)
          (when (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim)
            (let ((v1-11 (ja-channel-float!
                           (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim)
                           0.0
                           0.0
                           0.0
                           )
                         )
                  )
              (when v1-11
                (let ((a0-11 (-> (the-as process-drawable gp-0)
                                 skel
                                 channel
                                 (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 channel-index)
                                 )
                             )
                      )
                  (set! (-> v1-11 frame-num) (-> a0-11 frame-num))
                  (set! (-> v1-11 frame-interp 0) (-> a0-11 frame-interp 0))
                  (set! (-> v1-11 frame-interp 1) (-> a0-11 frame-interp 1))
                  )
                (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
                )
              )
            (set! (-> (the-as metalkor-legs (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim) #f)
            )
          )
        )
      )
    (metalkor-update-ik)
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

(define *metalkor-lowtorso-spinner-setup*
  (new 'static 'boxed-array :type metalkor-spinner-info
    (new 'static 'metalkor-spinner-info :joint-index 41 :launch-angle 18204.445)
    (new 'static 'metalkor-spinner-info :joint-index 30 :launch-angle 25486.223)
    (new 'static 'metalkor-spinner-info :joint-index 38 :launch-angle -18204.445)
    (new 'static 'metalkor-spinner-info :joint-index 33 :launch-angle -25486.223)
    )
  )

;; WARN: Function metalkor-lowtorso-start-spinner has a return type of none, but the expression builder found a return statement.
(defbehavior metalkor-lowtorso-start-spinner metalkor-lowtorso ((arg0 int) (arg1 vector))
  (when (< arg0 4)
    (if (handle->process (-> self spinners arg0))
        (return #f)
        )
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (let ((f30-0 (sin (-> *metalkor-lowtorso-spinner-setup* arg0 launch-angle)))
            (f0-2 (cos (-> *metalkor-lowtorso-spinner-setup* arg0 launch-angle)))
            )
        (set-vector!
          s5-0
          (+ (* f0-2 (-> arg1 x)) (* f30-0 (-> arg1 z)))
          0.0
          (- (* f0-2 (-> arg1 z)) (* f30-0 (-> arg1 x)))
          1.0
          )
        )
      (vector-normalize! s5-0 (* 81920.0 (cos 10922.667)))
      (+! (-> s5-0 y) (* 81920.0 (sin 10922.667)))
      (+! (-> s5-0 y) 12288.0)
      (vector+! s5-0 s5-0 (-> self entity trans))
      (set! (-> self spinners arg0)
            (ppointer->handle
              (process-spawn metalkor-spinner s5-0 (-> *metalkor-lowtorso-spinner-setup* arg0 joint-index) :to self)
              )
            )
      )
    )
  (none)
  )

(defun ja-aframe-num-of-proc ((arg0 process-drawable) (arg1 int))
  (let* ((a0-2 (-> arg0 skel root-channel arg1))
         (v1-2 (-> a0-2 frame-group))
         )
    (if (and v1-2 (nonzero? v1-2))
        (+ (* (-> a0-2 frame-num) (-> v1-2 artist-step)) (-> v1-2 artist-base))
        0.0
        )
    )
  )

(defmethod apply-gravity metalkor-chain-physics ((this metalkor-chain-physics) (arg0 vector) (arg1 int) (arg2 process-drawable))
  (local-vars (f0-16 float) (f0-31 float))
  (cond
    ((zero? arg1)
     (set! (-> this joint-length) 8192.0)
     )
    ((= arg1 1)
     (set! (-> this joint-length) 12288.0)
     )
    ((= arg1 2)
     (set! (-> this joint-length) 8192.0)
     )
    (else
      (let ((v1-8 (-> arg2 parent)))
        (if (and (-> (the-as metalkor (if v1-8
                                          (the-as metalkor (-> v1-8 0 self))
                                          )
                             )
                     next-state
                     )
                 (let ((v1-12 (-> arg2 parent)))
                   (= (-> (the-as metalkor (if v1-12
                                               (the-as metalkor (-> v1-12 0 self))
                                               )
                                  )
                          next-state
                          name
                          )
                      'hang-shoot-n-launch
                      )
                   )
                 )
            (set! (-> this joint-length) 5734.4)
            (set! (-> this joint-length) 5324.8)
            )
        )
      )
    )
  (vector-float*!
    arg0
    (-> this gravity)
    (* 4096.0 (-> self clock time-adjust-ratio) (lerp-scale 0.2 0.1 (the float arg1) 0.0 20.0))
    )
  (vector-float*! arg0 arg0 0.75)
  (set! (-> this axial-slop) (* 364.0889 (the float arg1)))
  (let ((f26-0 (-> this prev-rotation))
        (f28-0 (-> this prev-y-rotation))
        (f30-1 (ja-aframe-num-of-proc (the-as process-drawable (ppointer->process (-> arg2 parent))) 0))
        )
    (let* ((v1-27 (-> arg2 parent))
           (s2-2 (and (and (-> (the-as metalkor (if v1-27
                                                    (the-as metalkor (-> v1-27 0 self))
                                                    )
                                       )
                               next-state
                               )
                           (let ((v1-31 (-> arg2 parent)))
                             (= (-> (the-as metalkor (if v1-31
                                                         (the-as metalkor (-> v1-31 0 self))
                                                         )
                                            )
                                    next-state
                                    name
                                    )
                                'tail-attack
                                )
                             )
                           )
                      (< 20.0 f30-1)
                      (< f30-1 39.0)
                      )
                 )
           )
      (let ((v1-38 (-> arg2 parent)))
        (set! f28-0
              (cond
                ((and (and (-> (the-as metalkor (if v1-38
                                                    (the-as metalkor (-> v1-38 0 self))
                                                    )
                                       )
                               next-state
                               )
                           (let ((v1-42 (-> arg2 parent)))
                             (= (-> (the-as metalkor (if v1-42
                                                         (the-as metalkor (-> v1-42 0 self))
                                                         )
                                            )
                                    next-state
                                    name
                                    )
                                'start-second-stage
                                )
                             )
                           )
                      (< f30-1 60.0)
                      )
                 (set! f26-0 0.0)
                 0.0
                 )
                ((let ((v1-49 (-> arg2 parent)))
                   (and (-> (the-as metalkor (if v1-49
                                                 (the-as metalkor (-> v1-49 0 self))
                                                 )
                                    )
                            next-state
                            )
                        (let* ((v1-53 (-> arg2 parent))
                               (v1-56 (-> (the-as metalkor (if v1-53
                                                               (the-as metalkor (-> v1-53 0 self))
                                                               )
                                                  )
                                          next-state
                                          name
                                          )
                                      )
                               )
                          (or (= v1-56 'hang-shoot-n-launch) (= v1-56 'start-second-stage))
                          )
                        )
                   )
                 (let ((f1-3 (cond
                               ((zero? arg1)
                                (set! f0-16 -9102.223)
                                0.0
                                )
                               ((< arg1 9)
                                (set! f0-16 (+ 2002.4889 f26-0))
                                (+ 546.13336 f28-0)
                                )
                               ((< arg1 12)
                                (set! f0-16 (+ 2730.6667 f26-0))
                                (+ 2002.4889 f28-0)
                                )
                               ((< arg1 15)
                                (set! f0-16 (+ 910.2222 f26-0))
                                (+ -5461.3335 f28-0)
                                )
                               (else
                                 (set! f0-16 (+ -3640.889 f26-0))
                                 (+ -5461.3335 f28-0)
                                 )
                               )
                             )
                       )
                   (set! f26-0 (+ f0-16 (* 182.04445 (-> this osc-z value))))
                   (+ f1-3 (* 182.04445 (-> this osc-y value)))
                   )
                 )
                (else
                  (cond
                    (s2-2
                      (cond
                        ((zero? arg1)
                         (set! f26-0 -16384.0)
                         (set! f28-0 0.0)
                         (set! s2-2 #f)
                         )
                        ((< arg1 9)
                         (set! f26-0 (cond
                                       ((or (< f30-1 25.0) (< 38.0 f30-1))
                                        (+ -4733.156 f26-0)
                                        )
                                       ((< f30-1 31.0)
                                        (+ -6371.5557 f26-0)
                                        )
                                       (else
                                         (+ -2912.7112 f26-0)
                                         )
                                       )
                               )
                         (set! s2-2 #f)
                         )
                        (else
                          (vector-! arg0 (target-pos 0) (the-as vector (-> this chain-joints arg1)))
                          (vector-normalize! arg0 12288.0)
                          )
                        )
                      )
                    (else
                      (let ((v1-90 (-> arg2 parent)))
                        (cond
                          ((and (-> (the-as metalkor (if v1-90
                                                         (the-as metalkor (-> v1-90 0 self))
                                                         )
                                            )
                                    next-state
                                    )
                                (let* ((v1-94 (-> arg2 parent))
                                       (v1-97 (-> (the-as metalkor (if v1-94
                                                                       (the-as metalkor (-> v1-94 0 self))
                                                                       )
                                                          )
                                                  next-state
                                                  name
                                                  )
                                              )
                                       )
                                  (or (= v1-97 'fall-down) (= v1-97 'collapse) (= v1-97 'last-gasp) (= v1-97 'fly-to-ring) (= v1-97 'explode))
                                  )
                                )
                           (cond
                             ((zero? arg1)
                              (set! f26-0 -3640.889)
                              (set! f28-0 0.0)
                              )
                             (else
                               (* 0.5 f26-0)
                               )
                             )
                           )
                          (else
                            (cond
                              ((zero? arg1)
                               (set! f0-31 -16384.0)
                               (set! f28-0 0.0)
                               )
                              ((< arg1 9)
                               (set! f0-31 (+ -4187.0225 f26-0))
                               )
                              ((< arg1 12)
                               (set! f0-31 (+ 8556.089 f26-0))
                               )
                              ((< arg1 15)
                               (set! f0-31 (+ -910.2222 f26-0))
                               )
                              ((< arg1 18)
                               (set! f0-31 (+ -10012.444 f26-0))
                               )
                              (else
                                (set! f0-31 (+ 910.2222 f26-0))
                                )
                              )
                            (set! f26-0 (+ f0-31 (* 182.04445 (-> this osc-z value))))
                            (+! f28-0 (* 182.04445 (-> this osc-y value)))
                            )
                          )
                        )
                      )
                    )
                  f28-0
                  )
                )
              )
        )
      (set! (-> this prev-rotation) f26-0)
      (set! (-> this prev-y-rotation) f28-0)
      (when (not s2-2)
        (let ((a1-11 (-> arg2 node-list data 3 bone transform))
              (s2-3 (new 'stack-no-clear 'matrix))
              )
          (matrix-axis-angle! s2-3 (the-as vector a1-11) f26-0)
          (vector-matrix*! arg0 arg0 s2-3)
          (let ((a1-13 (-> arg2 node-list data 3 bone transform vector 1)))
            (matrix-axis-angle! s2-3 a1-13 f28-0)
            )
          (vector-matrix*! arg0 arg0 s2-3)
          )
        (vector+float*!
          arg0
          arg0
          (the-as vector (+ (the-as uint (-> this chain-joints 0 velocity)) (* arg1 64)))
          (lerp-scale 0.9 0.5 (the float arg1) 0.0 20.0)
          )
        )
      )
    (let ((v1-124 (-> arg2 parent)))
      (if (and (-> (the-as metalkor (if v1-124
                                        (the-as metalkor (-> v1-124 0 self))
                                        )
                           )
                   next-state
                   )
               (let* ((v1-128 (-> arg2 parent))
                      (v1-131 (-> (the-as metalkor (if v1-128
                                                       (the-as metalkor (-> v1-128 0 self))
                                                       )
                                          )
                                  next-state
                                  name
                                  )
                              )
                      )
                 (or (= v1-131 'fall-down) (= v1-131 'collapse) (= v1-131 'start-second-stage))
                 )
               )
          (vector-float*! arg0 arg0 1.1)
          )
      )
    (let ((v1-135 (-> arg2 parent)))
      (cond
        ((and (and (-> (the-as metalkor (if v1-135
                                            (the-as metalkor (-> v1-135 0 self))
                                            )
                               )
                       next-state
                       )
                   (let ((v1-139 (-> arg2 parent)))
                     (= (-> (the-as metalkor (if v1-139
                                                 (the-as metalkor (-> v1-139 0 self))
                                                 )
                                    )
                            next-state
                            name
                            )
                        'tail-attack
                        )
                     )
                   )
              (< 18.0 f30-1)
              (and (< f30-1 39.0) (> arg1 0) (< arg1 9))
              )
         (vector+float*!
           arg0
           arg0
           (the-as vector (+ (the-as uint (-> this chain-joints 0 velocity)) (* (+ arg1 -1) 64)))
           0.9
           )
         )
        ((-> this move-with-parent)
         (vector+float*!
           arg0
           arg0
           (the-as vector (+ (the-as uint (-> this chain-joints 0 velocity)) (* (+ arg1 -1) 64)))
           0.8
           )
         )
        )
      )
    )
  0
  (none)
  )

(defmethod chain-physics-method-16 metalkor-chain-physics ((this metalkor-chain-physics) (arg0 int))
  10922.667
  )

(defmethod chain-physics-method-14 metalkor-chain-physics ((this metalkor-chain-physics) (arg0 vector) (arg1 int))
  (vector-reset! arg0)
  0
  (none)
  )

(defmethod clamp-length metalkor-chain-physics ((this metalkor-chain-physics) (arg0 vector) (arg1 vector) (arg2 object) (arg3 process-drawable))
  ((method-of-type chain-physics clamp-length) this arg0 arg1 arg2 arg3)
  (when (< 5 (the-as int arg2))
    (let ((a0-2 (vector<-cspace! (new 'stack-no-clear 'vector) (-> arg3 node-list data 3)))
          (s5-1 (new 'stack-no-clear 'vector))
          )
      (vector-! s5-1 arg0 a0-2)
      (let ((f0-0 (vector-normalize-ret-len! s5-1 1.0)))
        (if (< f0-0 32768.0)
            (vector+float*! arg0 arg0 s5-1 (- 32768.0 f0-0))
            )
        )
      )
    )
  )

(defmethod gravity-update metalkor-chain-physics ((this metalkor-chain-physics) (arg0 process-drawable))
  (let ((t9-0 (method-of-type chain-physics gravity-update)))
    (t9-0 this arg0)
    )
  (update! (-> this rand-y))
  (update! (-> this rand-z))
  (update! (-> this osc-y) (-> this rand-y value))
  (update! (-> this osc-z) (-> this rand-z value))
  (let ((s5-1 (new 'stack-no-clear 'collide-query)))
    (let ((s4-0 (new 'stack-no-clear 'bounding-box)))
      (let ((s3-0 (new 'stack-no-clear 'sphere)))
        (vector<-cspace! s3-0 (-> arg0 node-list data 19))
        (set! (-> s3-0 r) 61440.0)
        (set-from-sphere! s4-0 s3-0)
        )
      (set! (-> s5-1 collide-with) (collide-spec player-list special-obstacle))
      (set! (-> s5-1 ignore-process0) #f)
      (set! (-> s5-1 ignore-process1) #f)
      (set! (-> s5-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> s5-1 action-mask) (collide-action solid))
      (mem-copy! (the-as pointer (-> s5-1 bbox)) (the-as pointer s4-0) 32)
      )
    (fill-using-bounding-box *collide-cache* s5-1)
    )
  0
  (none)
  )

(defmethod chain-physics-method-17 metalkor-chain-physics ((this metalkor-chain-physics) (arg0 vector) (arg1 int))
  (local-vars (v1-26 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let* ((s5-0 (new 'stack-no-clear 'collide-query))
           (v1-2 (-> this chain-joints arg1))
           (s4-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> v1-2 position)))
           (s3-0 0)
           )
      (set! (-> arg0 quad) (-> v1-2 position quad))
      (until (or (< 6 s3-0) (begin
                              (.lvf vf1 (&-> s4-1 quad))
                              (.add.w.vf vf2 vf0 vf0 :mask #b1)
                              (.mul.vf vf1 vf1 vf1)
                              (.mul.x.vf acc vf2 vf1 :mask #b1)
                              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                              (.mov v1-26 vf1)
                              (let ((f0-7 v1-26)
                                    (f1-5 409.6)
                                    )
                                (< f0-7 (* f1-5 f1-5))
                                )
                              )
                 )
        (+! s3-0 1)
        (set! (-> s5-0 start-pos quad) (-> arg0 quad))
        (set! (-> s5-0 move-dist quad) (-> s4-1 quad))
        (let ((v1-7 s5-0))
          (set! (-> v1-7 radius) 4096.0)
          (set! (-> v1-7 collide-with) (collide-spec special-obstacle))
          (set! (-> v1-7 ignore-process0) #f)
          (set! (-> v1-7 ignore-process1) #f)
          (set! (-> v1-7 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-7 action-mask) (collide-action solid))
          )
        (set! (-> s5-0 num-spheres) (the-as uint #f))
        (let ((f0-1 (probe-using-line-sphere *collide-cache* s5-0)))
          (cond
            ((>= f0-1 0.0)
             (let ((f0-2 (fmin 1.0 f0-1)))
               (vector+float*! arg0 arg0 s4-1 f0-2)
               (vector-float*! s4-1 s4-1 (- 1.0 f0-2))
               )
             (let ((f0-5 (vector-dot s4-1 (-> s5-0 best-other-tri normal))))
               (vector--float*! s4-1 s4-1 (-> s5-0 best-other-tri normal) (* 1.2 f0-5))
               )
             )
            (else
              (vector+! arg0 arg0 s4-1)
              (goto cfg-11)
              )
            )
          )
        )
      )
    (label cfg-11)
    0
    (none)
    )
  )

;; WARN: Return type mismatch process-focusable vs metalkor-lowtorso.
(defmethod relocate metalkor-lowtorso ((this metalkor-lowtorso) (arg0 int))
  (if (nonzero? (-> this tail))
      (&+! (-> this tail) arg0)
      )
  (if (nonzero? (-> this egg-toss-joint-1))
      (&+! (-> this egg-toss-joint-1) arg0)
      )
  (if (nonzero? (-> this egg-toss-joint-2))
      (&+! (-> this egg-toss-joint-2) arg0)
      )
  (if (nonzero? (-> this egg-toss-joint-3))
      (&+! (-> this egg-toss-joint-3) arg0)
      )
  (the-as metalkor-lowtorso ((method-of-type process-focusable relocate) this arg0))
  )

(defstate idle (metalkor-lowtorso)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 object))
    (case message
      (('egg-toss)
       (set! (-> self egg-toss-joint-angle target) (the-as float (-> block param 0)))
       )
      (('color)
       (set! (-> self draw color-mult quad) (-> (the-as rgbaf (-> block param 0)) quad))
       (set! v0-0 (-> self draw color-emissive))
       (set! (-> (the-as rgbaf v0-0) quad) (-> (the-as rgbaf (-> block param 1)) quad))
       v0-0
       )
      (('move-chain)
       (let ((v1-7 (-> block param 0))
             (a0-9 (-> self tail))
             )
         (dotimes (a1-1 (the-as int (-> a0-9 num-joints)))
           (vector+!
             (the-as vector (-> a0-9 chain-joints a1-1))
             (the-as vector (-> a0-9 chain-joints a1-1))
             (the-as vector v1-7)
             )
           )
         )
       #f
       )
      (('spinner)
       (let ((v1-10 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
         (metalkor-lowtorso-start-spinner (the-as int (-> block param 0)) (-> v1-10 vector 2))
         )
       )
      (('spinner-off)
       (let ((gp-1 (-> block param 0)))
         (when (< (the-as int gp-1) 4)
           (let ((a0-17 (handle->process (-> self spinners gp-1))))
             (when a0-17
               (send-event a0-17 'break)
               (set! (-> self spinners gp-1) (the-as handle #f))
               #f
               )
             )
           )
         )
       )
      (('ja-float)
       (dotimes (s5-1 3)
         (when (not (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-1 16))) ja-float-info 0 float-anim))
           (set! (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-1 16))) ja-float-info 0 float-anim)
                 (get-art-by-name (-> self draw art-group) (the-as string (-> block param 0)) art-joint-anim)
                 )
           (set! (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-1 16))) ja-float-info 0 channel-index)
                 (the-as int (-> block param 1))
                 )
           (set! v0-0 #t)
           (goto cfg-31)
           )
         )
       (set! v0-0 #f)
       (label cfg-31)
       v0-0
       )
      (('attack)
       (let ((v1-32 (new 'stack-no-clear 'event-message-block)))
         (set! (-> v1-32 from) (process->ppointer proc))
         (set! (-> v1-32 num-params) argc)
         (set! (-> v1-32 message) message)
         (set! (-> v1-32 param 0) (-> block param 0))
         (set! (-> v1-32 param 1) (-> block param 1))
         (set! (-> v1-32 param 2) (-> block param 2))
         (set! (-> v1-32 param 3) (-> block param 3))
         (set! (-> v1-32 param 4) (-> block param 4))
         (set! (-> v1-32 param 5) (-> block param 5))
         (send-event-function (ppointer->process (-> self parent)) v1-32)
         )
       )
      (('touch)
       (let ((s4-0 (new 'stack-no-clear 'vector)))
         (set! (-> s4-0 quad) (-> self entity trans quad))
         (let* ((s3-0 proc)
                (v1-36 (if (type? s3-0 process-drawable)
                           s3-0
                           )
                       )
                )
           (when v1-36
             (let ((s3-2 (vector-! (new 'stack-no-clear 'vector) (-> (the-as process-drawable v1-36) root trans) s4-0))
                   (s4-2
                     (vector-! (new 'stack-no-clear 'vector) (-> (the-as process-drawable v1-36) root trans) (-> self root trans))
                     )
                   )
               (set! (-> s3-2 y) 0.0)
               (set! (-> s4-2 y) 0.0)
               (when (< (vector-dot s3-2 s4-2) 0.0)
                 (vector-normalize! s3-2 1.0)
                 (vector-normalize! s4-2 1.0)
                 (vector-flatten! s4-2 s4-2 s3-2)
                 )
               (vector-normalize! s4-2 32768.0)
               (when (send-event
                       proc
                       'attack
                       (-> block param 0)
                       (static-attack-info ((id (new-attack-id)) (mode 'deadly) (vector s4-2) (shove-up (meters 4))))
                       )
                 (set-time! (-> self no-collision-timer))
                 (let ((v1-52 (-> self root root-prim)))
                   (set! (-> v1-52 prim-core collide-as) (collide-spec))
                   (set! (-> v1-52 prim-core collide-with) (collide-spec))
                   )
                 0
                 )
               )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set-params! (-> self egg-toss-joint-angle) 0.0 0.05 0.3 0.9)
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self no-collision-timer) (seconds 0.1))
      (let ((v1-5 (-> self root root-prim)))
        (set! (-> v1-5 prim-core collide-as) (-> self root backup-collide-as))
        (set! (-> v1-5 prim-core collide-with) (-> self root backup-collide-with))
        )
      )
    (clone-anim-once (ppointer->handle (-> self parent)) #t (-> self prefix))
    (let ((gp-0 (ppointer->process (-> self parent))))
      (when gp-0
        (dotimes (s5-0 3)
          (when (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim)
            (let ((v1-17 (ja-channel-float!
                           (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim)
                           0.0
                           0.0
                           0.0
                           )
                         )
                  )
              (when v1-17
                (let ((a0-16 (-> (the-as process-drawable gp-0)
                                 skel
                                 channel
                                 (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 channel-index)
                                 )
                             )
                      )
                  (set! (-> v1-17 frame-num) (-> a0-16 frame-num))
                  (set! (-> v1-17 frame-interp 0) (-> a0-16 frame-interp 0))
                  (set! (-> v1-17 frame-interp 1) (-> a0-16 frame-interp 1))
                  )
                (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
                )
              )
            (set! (-> (the-as metalkor-lowtorso (+ (the-as uint self) (* s5-0 16))) ja-float-info 0 float-anim) #f)
            )
          )
        )
      )
    (update! (-> self egg-toss-joint-angle) 0.0)
    (let ((f30-0 (* 910.2222 (-> self egg-toss-joint-angle value))))
      (quaternion-set! (-> self egg-toss-joint-1 quat) 0.0 0.0 (sin f30-0) (cos f30-0))
      (quaternion-set! (-> self egg-toss-joint-2 quat) 0.0 0.0 (sin f30-0) (cos f30-0))
      (quaternion-set! (-> self egg-toss-joint-3 quat) 0.0 0.0 (sin f30-0) (cos f30-0))
      )
    (when (not (-> self tail-initialized))
      (set! (-> self tail-initialized) #t)
      (initialize-chain-joints (-> self tail))
      )
    (let ((v1-38 (ja-group)))
      (set! (-> self tail move-with-parent)
            (the-as symbol (and (and v1-38 (or (= v1-38 (-> self draw art-group data 18))
                                               (= v1-38 (-> self draw art-group data 19))
                                               (= v1-38 (-> self draw art-group data 20))
                                               )
                                     )
                                (< (ja-aframe-num 0) 45.0)
                                )
                    )
            )
      )
    (update (-> self tail) self)
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    )
  )

(deftype nestb-formation (hover-formation)
  ()
  :heap-base #x10
  :method-count-assert 16
  :size-assert         #x90
  :flag-assert         #x1000100090
  )


(defmethod hover-formation-method-15 nestb-formation ((this nestb-formation) (arg0 vector) (arg1 vector))
  (logior! (-> this formation flags) 2)
  0
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod init-enemy! metalkor-flitter ((this metalkor-flitter))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-flitter" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-enemy-behaviour-and-stats! this *metalkor-flitter-nav-enemy-info*)
  (set! (-> this move-angle) 10922.667)
  (set! (-> this heading) (the-as basic (if (= (rand-vu-int-range 0 1) 1)
                                            #t
                                            #f
                                            )
                                  )
        )
  (set! (-> this change-dir-time) 0)
  (set! (-> this off-screen-timer) (the-as uint 0))
  (set! (-> this amb-sound-timer) (the-as uint 0))
  (add-connection
    *part-engine*
    this
    28
    this
    318
    (new 'static 'vector :x 942.08 :y -860.16 :z 1269.76 :w 163840.0)
    )
  (add-connection
    *part-engine*
    this
    28
    this
    318
    (new 'static 'vector :x -942.08 :y -860.16 :z 1269.76 :w 163840.0)
    )
  (set-gravity-length (-> this root dynam) 491520.0)
  (set! (-> this minimap) #f)
  (none)
  )

(defmethod dispose! metalkor-flitter ((this metalkor-flitter))
  "Cleans-up the enemy and any associated resources. Potentially spawns skull gems"
  (with-pp
    (when (not (logtest? (enemy-flag recover-applied-velocity) (-> this enemy-flags)))
      (when (and (>= (-> this enemy-info gem-joint) 0)
                 (not (logtest? (enemy-flag cam-attack-mode) (-> this enemy-flags)))
                 (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
                   (set! (-> a1-0 from) (process->ppointer pp))
                   (set! (-> a1-0 num-params) 0)
                   (set! (-> a1-0 message) 'have-gem?)
                   (or (send-event-function (ppointer->process (-> this parent)) a1-0)
                       (task-node-closed? (game-task-node city-win-introduction))
                       (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                       )
                   )
                 )
        (logior! (-> this enemy-flags) (enemy-flag cam-attack-mode))
        (remove-from-process *part-engine* this)
        (setup-masks
          (-> this draw)
          (the-as int (-> this enemy-info gem-no-seg))
          (the-as int (-> this enemy-info gem-seg))
          )
        (let ((v1-30
                (ppointer->process
                  (birth-pickup-at-point
                    (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data (-> this enemy-info gem-joint)))
                    (pickup-type gem)
                    1.0
                    #t
                    (ppointer->process (-> this parent))
                    (-> this fact)
                    )
                  )
                )
              )
          (send-event (ppointer->process (-> this parent)) 'flitter-change-gem this v1-30)
          )
        )
      )
    ((method-of-type flitter dispose!) this)
    (none)
    )
  )

(defmethod dispose! metalkor-wasp ((this metalkor-wasp))
  "Cleans-up the enemy and any associated resources. Potentially spawns skull gems"
  (with-pp
    (when (not (logtest? (enemy-flag recover-applied-velocity) (-> this enemy-flags)))
      (when (and (>= (-> this enemy-info gem-joint) 0)
                 (not (logtest? (enemy-flag cam-attack-mode) (-> this enemy-flags)))
                 (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
                   (set! (-> a1-0 from) (process->ppointer pp))
                   (set! (-> a1-0 num-params) 0)
                   (set! (-> a1-0 message) 'have-gem?)
                   (or (send-event-function (ppointer->process (-> this parent)) a1-0)
                       (task-node-closed? (game-task-node city-win-introduction))
                       (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                       )
                   )
                 )
        (logior! (-> this enemy-flags) (enemy-flag cam-attack-mode))
        (remove-from-process *part-engine* this)
        (setup-masks
          (-> this draw)
          (the-as int (-> this enemy-info gem-no-seg))
          (the-as int (-> this enemy-info gem-seg))
          )
        (let ((v1-28
                (ppointer->process
                  (birth-pickup-at-point
                    (vector<-cspace! (new 'stack-no-clear 'vector) (-> this node-list data (-> this enemy-info gem-joint)))
                    (pickup-type gem)
                    1.0
                    #t
                    *entity-pool*
                    (-> this fact)
                    )
                  )
                )
              )
          (send-event (ppointer->process (-> this parent)) 'wasp-change-gem this v1-28)
          )
        )
      )
    ((method-of-type wasp dispose!) this)
    (none)
    )
  )

(defskelgroup skel-rift-ring-ingame rift-ring-in-game rift-ring-in-game-lod0-jg rift-ring-in-game-idle-ja
              ((rift-ring-in-game-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 40)
              )

(deftype rift-ring-ingame (process-drawable)
  ((anim-speed         delayed-rand-float :inline :offset-assert 200)
   (stutter            symbol                     :offset-assert 228)
   (spin-sound         sound-id                   :offset-assert 232)
   (spin-sound-playing symbol                     :offset-assert 236)
   )
  :heap-base #x70
  :method-count-assert 21
  :size-assert         #xf0
  :flag-assert         #x15007000f0
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defstate idle (rift-ring-ingame)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stutter)
       (set! (-> self stutter) (the-as symbol (-> block param 0)))
       (set-params! (-> self anim-speed) 3 15 0.25)
       (reset! (-> self anim-speed))
       (set! (-> self anim-speed value) -0.25)
       )
      )
    )
  :trans (behavior ()
    (cond
      ((-> self stutter)
       (update! (-> self anim-speed))
       (ja :num! (loop! (+ 0.125 (-> self anim-speed value))))
       )
      (else
        (ja :num! (loop!))
        )
      )
    (sound-play "warp-ring" :id (-> self spin-sound) :position (-> self root trans))
    (set! (-> self spin-sound-playing) #t)
    )
  :code sleep-code
  :post (behavior ()
    (spawn (-> self part) (-> self root trans))
    (ja-post)
    )
  )

(defmethod deactivate rift-ring-ingame ((this rift-ring-ingame))
  (if (-> this spin-sound-playing)
      (sound-stop (-> this spin-sound))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! rift-ring-ingame ((this rift-ring-ingame) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-rift-ring-ingame" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1236) this))
  (set! (-> this draw light-index) (the-as uint 10))
  (set! (-> this stutter) #f)
  (set! (-> this spin-sound) (new-sound-id))
  (set! (-> this spin-sound-playing) #f)
  (go (method-of-object this idle))
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod apply-gravity metalkor-spinner-chain-physics ((this metalkor-spinner-chain-physics) (arg0 vector) (arg1 int) (arg2 process-drawable))
  (vector-float*! arg0 (-> this gravity) (-> this gravity-mult))
  (vector+float*!
    arg0
    arg0
    (the-as vector (+ (the-as uint (-> this chain-joints 0 velocity)) (* arg1 64)))
    (-> this velocity-mult)
    )
  (none)
  )

(defmethod chain-physics-method-14 metalkor-spinner-chain-physics ((this metalkor-spinner-chain-physics) (arg0 vector) (arg1 int))
  (vector-reset! arg0)
  0
  (none)
  )

;; WARN: Return type mismatch process-drawable vs metalkor-spinner.
(defmethod relocate metalkor-spinner ((this metalkor-spinner) (arg0 int))
  (if (nonzero? (-> this chain))
      (&+! (-> this chain) arg0)
      )
  (the-as metalkor-spinner ((method-of-type process-drawable relocate) this arg0))
  )

(defstate break-it (metalkor-spinner)
  :virtual #t
  :enter (behavior ()
    (set! (-> self chain joint-length) (* 12288.0 (-> self root scale y)))
    (set! (-> self root scale y) 1.0)
    (initialize-chain-joints (-> self chain))
    (set-time! (-> self state-time))
    (let* ((f30-0 0.9)
           (f28-0 0.2)
           (v1-12 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-13 (the-as number (logior #x3f800000 v1-12)))
           )
      (set! (-> self anim-speed) (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-13)))))
      )
    (turn-off (-> self chain) (the-as time-frame (the int (* 300.0 (rand-vu-float-range 0.9 1.2)))))
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data 52) :num! min)
    )
  :trans (behavior ()
    (let* ((v1-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat)))
           (a2-1 (quaternion-from-two-vectors-partial!
                   (new 'stack-no-clear 'quaternion)
                   (-> v1-1 vector 1)
                   (new 'static 'vector :y 1.0)
                   0.1
                   )
                 )
           )
      (quaternion*! (-> self root quat) (-> self root quat) a2-1)
      )
    (quaternion-normalize! (-> self root quat))
    (update (-> self chain) self)
    (cond
      ((not (time-elapsed? (-> self state-time) (seconds 1)))
       )
      ((let ((v1-13 (ja-group)))
         (and v1-13 (= v1-13 (-> self draw art-group data 53)))
         )
       (ja :num! (seek! max (-> self anim-speed)))
       (if (ja-done? 0)
           (deactivate self)
           )
       )
      (else
        (ja-channel-push! 1 (seconds 0.1))
        (ja :group! (-> self draw art-group data 53) :num! min)
        )
      )
    )
  :code sleep-code
  :post ja-post
  )

(defstate idle (metalkor-spinner)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('break)
       (go-virtual break-it)
       )
      )
    )
  :enter (behavior ()
    (ja :group! (-> self draw art-group data 50))
    )
  :trans (behavior ()
    (ja :num! (loop!))
    (let* ((t9-1 vector<-cspace!)
           (a0-1 (new 'stack-no-clear 'vector))
           (v1-6 (+ (* (-> self parent-joint-index) 32) 12))
           (a1-1 (-> self parent))
           (v1-7 (t9-1
                   a0-1
                   (the-as
                     cspace
                     (+ v1-6 (the-as int (-> (the-as process-drawable (if a1-1
                                                                          (the-as process-drawable (-> a1-1 0 self))
                                                                          )
                                                     )
                                             node-list
                                             )
                                     )
                        )
                     )
                   )
                 )
           (gp-1 (vector-! (new 'stack-no-clear 'vector) v1-7 (-> self root trans)))
           (f30-0 (vector-normalize-ret-len! gp-1 1.0))
           )
      (quaternion-from-two-vectors! (-> self root quat) (new 'static 'vector :y -1.0) gp-1)
      (set! (-> self root scale y) (* 0.000009042245 f30-0))
      )
    )
  :code sleep-code
  :post ja-post
  )

(defstate shoot-out (metalkor-spinner)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('break)
       (deactivate self)
       )
      )
    )
  :enter (behavior ()
    (let* ((f30-0 0.9)
           (f28-0 0.2)
           (v1-3 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-4 (the-as number (logior #x3f800000 v1-3)))
           )
      (set! (-> self anim-speed) (+ f30-0 (* f28-0 (+ -1.0 (the-as float v1-4)))))
      )
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 51)))
         (ja :num! (seek! max (-> self anim-speed)))
         (when (ja-done? 0)
           (set! (-> self root trans quad) (-> self target-pos quad))
           (go-virtual idle)
           )
         )
        (else
          (ja :group! (-> self draw art-group data 51) :num! min)
          )
        )
      )
    (let* ((t9-4 vector<-cspace!)
           (a0-9 (new 'stack-no-clear 'vector))
           (v1-25 (+ (* (-> self parent-joint-index) 32) 12))
           (a1-2 (-> self parent))
           (s5-0 (t9-4
                   a0-9
                   (the-as cspace (+ v1-25 (the-as int (-> (the-as metalkor (if a1-2
                                                                                (the-as metalkor (-> a1-2 0 self))
                                                                                )
                                                                   )
                                                           node-list
                                                           )
                                                   )
                                     )
                           )
                   )
                 )
           (gp-2 (vector-! (new 'stack-no-clear 'vector) s5-0 (-> self target-pos)))
           )
      (let ((f0-4 (vector-normalize-ret-len! gp-2 1.0)))
        (set! (-> self root scale y) (* 0.000009042245 f0-4))
        (vector+float*! (-> self root trans) s5-0 gp-2 (- f0-4))
        )
      (quaternion-from-two-vectors! (-> self root quat) (new 'static 'vector :y -1.0) gp-2)
      )
    )
  :code sleep-code
  :post ja-post
  )

(defskelgroup skel-nest-break-precipice nest-break-precipice nest-break-precipice-lod0-jg nest-break-precipice-idle-ja
              ((nest-break-precipice-lod0-mg (meters 999999)))
              :bounds (static-spherem -28 20 30 24)
              )

(deftype nest-break-precipice (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (idle () _type_ :state 20)
    (die () _type_ :state 21)
    )
  )


(defstate idle (nest-break-precipice)
  :virtual #t
  :enter (behavior ()
    (ja-post)
    )
  :code sleep-code
  )

(defstate die (nest-break-precipice)
  :virtual #t
  :trans (behavior ()
    (cleanup-for-death self)
    (deactivate self)
    )
  :code sleep-code
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! nest-break-precipice ((this nest-break-precipice) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-nest-break-precipice" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> this draw light-index) (the-as uint 17))
  (if (task-node-closed? (game-task-node nest-boss-introduction))
      (go (method-of-object this die))
      (go (method-of-object this idle))
      )
  (none)
  )

(defmethod draw hud-metalkor ((this hud-metalkor))
  (set-hud-piece-position! (-> this sprites 1) (the int (+ 462.0 (* 130.0 (-> this offset)))) 350)
  (set-as-offset-from! (the-as hud-sprite (-> this sprites)) (the-as vector4w (-> this sprites 1)) -32 0)
  (set-as-offset-from! (-> this sprites 5) (the-as vector4w (-> this sprites 1)) -62 14)
  (set-as-offset-from! (-> this sprites 6) (the-as vector4w (-> this sprites 1)) -32 14)
  (let ((s5-0 (-> this values 0 current))
        (f30-0 (* 0.01 (the float (-> this values 1 current))))
        )
    (set-as-offset-from! (-> this sprites 4) (the-as vector4w (-> this sprites 1)) -92 15)
    (cond
      ((= s5-0 1)
       (set! (-> this sprites 4 color x) 0)
       (set! (-> this sprites 4 color y) 255)
       (set! f30-0 (+ 2.0 f30-0))
       )
      ((= s5-0 2)
       (set! (-> this sprites 4 color y) 255)
       (set! (-> this sprites 4 color x) 255)
       (set! f30-0 (+ 1.0 f30-0))
       )
      ((= s5-0 3)
       (set! (-> this sprites 4 color x) 255)
       (set! (-> this sprites 4 color y) 0)
       0
       )
      (else
        (set! f30-0 0.0)
        )
      )
    (set! (-> this sprites 4 scale-x) (* -7.25 f30-0))
    )
  ((method-of-type hud draw) this)
  0
  (none)
  )

(defmethod init-callback hud-metalkor ((this hud-metalkor))
  (set! (-> this gui-id)
        (add-process *gui-control* this (gui-channel hud-middle-right) (gui-action hidden) (-> this name) 81920.0 0)
        )
  (set! (-> this values 0 target) 1)
  (set! (-> this values 1 target) 100)
  (logior! (-> this flags) (hud-flags show))
  (set! (-> this sprites 0 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3b :page #x67a)))
  (set! (-> this sprites 0 flags) (the-as uint 4))
  (set! (-> this sprites 1 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3c :page #x67a)))
  (set! (-> this sprites 1 flags) (the-as uint 4))
  (set! (-> this sprites 5 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3d :page #x67a)))
  (set! (-> this sprites 5 scale-x) 0.5)
  (set! (-> this sprites 5 flags) (the-as uint 4))
  (set! (-> this sprites 6 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3d :page #x67a)))
  (set! (-> this sprites 6 scale-x) 0.5)
  (set! (-> this sprites 6 flags) (the-as uint 4))
  (set! (-> this sprites 4 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x41 :page #x67a)))
  (set! (-> this sprites 4 scale-y) 3.25)
  (set! (-> this sprites 4 color z) 0)
  (set! (-> this sprites 4 flags) (the-as uint 4))
  (set! (-> this sprites 3 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x41 :page #x67a)))
  (set! (-> this sprites 3 scale-y) 1.5)
  (set! (-> this sprites 3 color z) 0)
  (set! (-> this sprites 3 flags) (the-as uint 4))
  0
  (none)
  )

(defstate idle (nestb-tail-bound)
  :virtual #t
  :code sleep-code
  )

(defstate idle (metalkor-kid)
  :virtual #t
  :trans (behavior ()
    (ja :num! (loop!))
    (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 3)))
    )
  :code sleep-code
  :post ja-post
  )

(defstate idle (metalkor-wings)
  :virtual #t
  :trans (behavior ()
    (clone-anim-once (ppointer->handle (-> self parent)) #t (-> self prefix))
    )
  :code sleep-code
  :post ja-post
  )

(defbehavior metalkor-distort-update metalkor-distort ()
  (let ((s5-0 (camera-matrix))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (let ((f30-0 4096.0))
      (let ((f28-1 (* 0.00013563369 (tan (* 0.5 (-> *math-camera* fov))) f30-0)))
        (matrix->quaternion (-> self root quat) s5-0)
        (set-vector! (-> self root scale) f28-1 f28-1 f28-1 1.0)
        )
      (let ((t9-3 vector<-cspace!)
            (a0-3 gp-0)
            (v1-7 (-> self parent))
            )
        (t9-3 a0-3 (-> (the-as process-drawable (if v1-7
                                                    (the-as process-drawable (-> v1-7 0 self))
                                                    )
                               )
                       node-list
                       data
                       7
                       )
              )
        )
      (vector-! gp-0 gp-0 (camera-pos))
      (vector-normalize! gp-0 f30-0)
      )
    (vector+! (-> self root trans) (camera-pos) gp-0)
    )
  0
  (none)
  )

(defstate idle (metalkor-distort)
  :virtual #t
  :enter (behavior ()
    (metalkor-distort-update)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (if (ja-done? 0)
        (deactivate self)
        )
    )
  :code sleep-code
  :post ja-post
  )

(defskelgroup skel-metalkor-rays metalkor-rays metalkor-rays-lod0-jg metalkor-rays-idle-ja
              ((metalkor-rays-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 30)
              )

(deftype metalkor-rays (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defstate idle (metalkor-rays)
  :virtual #t
  :enter (behavior ()
    (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 0.0)
    )
  :trans (behavior ()
    (clone-anim-once (ppointer->handle (-> self parent)) #t "")
    (let ((f0-0 (calc-fade-from-fog (-> self root trans))))
      (set-vector! (-> self draw color-emissive) f0-0 f0-0 f0-0 1.0)
      )
    )
  :code sleep-code
  :post ja-post
  )

;; WARN: Return type mismatch object vs none.
(defbehavior metalkor-rays-init-by-other metalkor-rays ((arg0 vector) (arg1 quaternion))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (quaternion-copy! (-> self root quat) arg1)
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-metalkor-rays" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go-virtual idle)
  (none)
  )

(set! (-> *lightning-spec-id-table* 29) (new 'static 'lightning-spec
                                          :name "lightning-metalkor-explode"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 8192.0
                                          :merge-factor 0.6
                                          :merge-count 2
                                          :radius 3276.8
                                          :duration 45.0
                                          :duration-rand 60.0
                                          :sound #f
                                          )
      )

(set! (-> *lightning-spec-id-table* 30) (new 'static 'lightning-spec
                                          :name "lightning-metalkor-explode-thick"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                                          :reduction 0.42
                                          :num-points 32
                                          :box-size 40960.0
                                          :merge-factor 0.6
                                          :merge-count 2
                                          :radius 12288.0
                                          :duration 60.0
                                          :sound #f
                                          )
      )

(defstate idle (metalkor-explode)
  :virtual #t
  :enter (behavior ()
    (process-spawn metalkor-rays (-> self root trans) (-> self root quat) :to self)
    )
  :trans (behavior ()
    (local-vars (sv-384 symbol) (sv-400 symbol) (sv-416 vector) (sv-432 matrix))
    (let ((f30-0 (ja-aframe-num 0)))
      (ja :num! (seek!))
      (when (and (< f30-0 40.0) (>= (ja-aframe-num 0) 40.0))
        (send-event (ppointer->process (-> self parent)) 'exploding)
        (activate! *camera-smush-control* 1638.4 37 210 1.0 0.995 (-> self clock))
        (let ((gp-0 (get-process *default-dead-pool* part-tracker #x4000)))
          (when gp-0
            (let ((t9-6 (method-of-type part-tracker activate)))
              (t9-6
                (the-as part-tracker gp-0)
                *entity-pool*
                (symbol->string (-> part-tracker symbol))
                (the-as pointer #x70004000)
                )
              )
            (let ((s5-0 run-function-in-process)
                  (s4-0 gp-0)
                  (s3-0 part-tracker-init)
                  (s2-0 (-> *part-group-id-table* 1238))
                  (s1-0 0)
                  (s0-0 #f)
                  )
              (set! sv-384 (the-as symbol #f))
              (set! sv-400 (the-as symbol #f))
              (set! sv-432 *launch-matrix*)
              (set! sv-416 (-> sv-432 trans))
              (let ((v1-27 (-> (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 3)) quad)))
                (set! (-> sv-416 quad) v1-27)
                )
              ((the-as (function object object object object object object object object none) s5-0)
               s4-0
               s3-0
               s2-0
               s1-0
               s0-0
               sv-384
               sv-400
               sv-432
               )
              )
            (-> gp-0 ppointer)
            )
          )
        )
      )
    (when (< 40.0 (ja-aframe-num 0))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 70)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 71)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 20)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 59)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 60)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 22)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 24)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 54)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 53)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 57)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 56)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 28)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 46)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 48)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 44)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 50)))
      (spawn (-> self part) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 3)))
      )
    (if (ja-done? 0)
        (send-event (ppointer->process (-> self parent)) 'explode-done)
        )
    (process-drawable-shock-effect
      self
      (-> *lightning-spec-id-table* 29)
      lightning-probe-callback
      (-> *part-id-table* 429)
      0
      0
      40960.0
      )
    (let ((a0-51 (handle->process (-> self ring))))
      (if a0-51
          (process-drawable2-shock-effect
            (the-as process-drawable a0-51)
            self
            (-> *lightning-spec-id-table* 30)
            lightning-probe-callback
            (-> *part-id-table* 429)
            )
          )
      )
    )
  :code sleep-code
  :post ja-post
  )

(defstate idle (rift-occlude)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('movie-pos)
       (format 0 "changing to movie position~%")
       (let ((a2-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
         (vector+!
           (-> self root trans)
           (-> self original-trans)
           (vector-matrix*! (new 'stack-no-clear 'vector) (new 'static 'vector :x -10240.0 :y -7168.0 :z 11264.0) a2-1)
           )
         )
       (ja-post)
       )
      )
    )
  :enter (behavior ()
    (set-vector! (-> self draw color-mult) 0.0 0.0 0.0 0.0)
    (ja-post)
    )
  :trans (behavior ()
    (let ((f0-0 (calc-fade-from-fog (-> self root trans))))
      (set-vector! (-> self draw color-emissive) f0-0 f0-0 f0-0 1.0)
      )
    )
  :code sleep-code
  )

;; WARN: Return type mismatch process-drawable vs metalkor-bomb.
(defmethod relocate metalkor-bomb ((this metalkor-bomb) (arg0 int))
  (dotimes (v1-0 (min 49 (-> *metalkor-bomb-probe-joints* length)))
    (when (nonzero? (-> this joint-mods v1-0))
      (if (nonzero? (-> this joint-mods v1-0))
          (&+! (-> this joint-mods v1-0) arg0)
          )
      )
    )
  (the-as metalkor-bomb ((method-of-type process-drawable relocate) this arg0))
  )

(define *metalkor-bomb-collide-joints* (new 'static 'boxed-array :type int8
                                         5
                                         8
                                         11
                                         14
                                         17
                                         20
                                         23
                                         26
                                         29
                                         32
                                         35
                                         38
                                         41
                                         44
                                         47
                                         50
                                         53
                                         56
                                         59
                                         62
                                         65
                                         68
                                         71
                                         74
                                         77
                                         80
                                         83
                                         86
                                         89
                                         92
                                         )
        )

(defbehavior metalkor-bomb-collide metalkor-bomb ()
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-query)))
      (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
        (let ((a1-0 (new 'stack-no-clear 'sphere)))
          (set! (-> a1-0 quad) (-> self root trans quad))
          (set! (-> a1-0 r) 204800.0)
          (set-from-sphere! s5-0 a1-0)
          )
        (set! (-> gp-0 collide-with) (collide-spec jak crate enemy hit-by-others-list player-list pusher))
        (set! (-> gp-0 ignore-process0) #f)
        (set! (-> gp-0 ignore-process1) #f)
        (set! (-> gp-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> gp-0 action-mask) (collide-action solid))
        (mem-copy! (the-as pointer (-> gp-0 bbox)) (the-as pointer s5-0) 32)
        )
      (fill-using-bounding-box *collide-cache* gp-0)
      )
    (let ((s5-1 (new 'stack-no-clear 'vector))
          (gp-1 (new 'stack-no-clear 'vector))
          )
      (set! (-> gp-1 quad) (-> self root trans quad))
      (vector<-cspace!
        (-> self root trans)
        (-> self node-list data (-> *metalkor-bomb-collide-joints* (+ (-> *metalkor-bomb-collide-joints* length) -1)))
        )
      (dotimes (s4-0 (-> *metalkor-bomb-collide-joints* length))
        (vector<-cspace! s5-1 (-> self node-list data (-> *metalkor-bomb-collide-joints* s4-0)))
        (vector-! s5-1 s5-1 (-> self root trans))
        (let ((v1-26 s5-1))
          (.lvf vf1 (&-> s5-1 quad))
          (let ((f0-1 (-> self clock frames-per-second)))
            (.mov at-0 f0-1)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-26 quad) vf1)
          )
        (integrate-and-collide! (-> self root) s5-1)
        )
      (let ((v0-6 (-> self root trans)))
        (set! (-> v0-6 quad) (-> gp-1 quad))
        v0-6
        )
      )
    )
  )

(defbehavior metalkor-bomb-ground-check metalkor-bomb ()
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
      (let ((a1-0 (new 'stack-no-clear 'sphere)))
        (set! (-> a1-0 quad) (-> self root trans quad))
        (set! (-> a1-0 r) 204800.0)
        (set-from-sphere! s5-0 a1-0)
        )
      (set! (-> gp-0 collide-with) (collide-spec player-list special-obstacle))
      (set! (-> gp-0 ignore-process0) #f)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> gp-0 action-mask) (collide-action solid))
      (mem-copy! (the-as pointer (-> gp-0 bbox)) (the-as pointer s5-0) 32)
      )
    (fill-using-bounding-box *collide-cache* gp-0)
    (dotimes (s5-1 (min 49 (-> *metalkor-bomb-probe-joints* length)))
      (let ((s4-0 (vector<-cspace!
                    (new 'stack-no-clear 'vector)
                    (-> self node-list data (-> *metalkor-bomb-probe-joints* s5-1))
                    )
                  )
            )
        (set! (-> gp-0 start-pos quad) (-> s4-0 quad))
        (+! (-> gp-0 start-pos y) 81920.0)
        (set! (-> gp-0 move-dist quad) (-> (new 'static 'vector :y -163840.0) quad))
        (let ((v1-17 gp-0))
          (set! (-> v1-17 radius) 4096.0)
          (set! (-> v1-17 collide-with) (collide-spec special-obstacle))
          (set! (-> v1-17 ignore-process0) #f)
          (set! (-> v1-17 ignore-process1) #f)
          (set! (-> v1-17 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-17 action-mask) (collide-action solid))
          )
        (let ((f0-4 (probe-using-line-sphere *collide-cache* gp-0)))
          (cond
            ((>= f0-4 0.0)
             (let* ((f1-3 (* -163840.0 (+ -0.5 f0-4)))
                    (f0-8 (- (fmin 139264.0 (fmax 83558.4 (+ (-> s4-0 y) f1-3))) (-> s4-0 y)))
                    )
               (if (nonzero? (-> self joint-mods s5-1))
                   (+! (-> self joint-mods s5-1 trans y) f0-8)
                   )
               )
             )
            (else
              )
            )
          )
        )
      )
    )
  #f
  )

(defstate idle (metalkor-bomb)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched 'touch)
       (send-event
         proc
         'attack
         (-> block param 0)
         (static-attack-info ((id (new-attack-id)) (mode 'deadly) (shove-back (meters 0)) (shove-up (meters 4))))
         )
       )
      )
    )
  :trans (behavior ()
    (ja :num! (seek! max 0.25))
    (if (ja-done? 0)
        (deactivate self)
        )
    (metalkor-bomb-ground-check)
    (metalkor-bomb-collide)
    )
  :code sleep-code
  :post ja-post
  )
