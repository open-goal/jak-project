;;-*-Lisp-*-
(in-package goal)

;; name: metalkor-states.gc
;; name in dgo: metalkor-states
;; dgos: NEB

;; DECOMP BEGINS

(define *metalkor-spinner-setup*
  (new 'static 'boxed-array :type metalkor-spinner-info
    (new 'static 'metalkor-spinner-info :joint-index #x43 :launch-angle 7281.778)
    (new 'static 'metalkor-spinner-info :joint-index #x40 :launch-angle 14563.556)
    (new 'static 'metalkor-spinner-info :joint-index #x46 :launch-angle -7281.778)
    (new 'static 'metalkor-spinner-info :joint-index #x3d :launch-angle -14563.556)
    )
  )

;; WARN: Return type mismatch int vs handle.
(defbehavior metalkor-start-spinner metalkor ((arg0 int) (arg1 vector))
  (the-as
    handle
    (when (< arg0 4)
      (if (handle->process (-> self spinners arg0))
          (return (the-as handle #f))
          )
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((f30-0 (sin (-> *metalkor-spinner-setup* arg0 launch-angle)))
              (f0-2 (cos (-> *metalkor-spinner-setup* arg0 launch-angle)))
              )
          (set-vector!
            s5-0
            (+ (* f0-2 (-> arg1 x)) (* f30-0 (-> arg1 z)))
            0.0
            (- (* f0-2 (-> arg1 z)) (* f30-0 (-> arg1 x)))
            1.0
            )
          )
        (vector-normalize! s5-0 (* 81920.0 (cos 10922.667)))
        (+! (-> s5-0 y) (* 81920.0 (sin 10922.667)))
        (set! (-> s5-0 y) (+ 12288.0 (-> s5-0 y)))
        (vector+! s5-0 s5-0 (-> self entity trans))
        (let ((v0-0 (ppointer->handle
                      (process-spawn metalkor-spinner s5-0 (-> *metalkor-spinner-setup* arg0 joint-index) :to self)
                      )
                    )
              )
          (set! (-> self spinners arg0) (the-as handle v0-0))
          v0-0
          )
        )
      )
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior metalkor-spinners-off metalkor ()
  (dotimes (gp-0 4)
    (let ((a0-1 (handle->process (-> self spinners gp-0))))
      (when a0-1
        (send-event a0-1 'break)
        (set! (-> self spinners gp-0) (the-as handle #f))
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior metalkor-lowtorso-spinners-off metalkor ()
  (let ((gp-0 (handle->process (-> self lowtorso))))
    (when gp-0
      (dotimes (s5-0 4)
        (send-event gp-0 'spinner-off s5-0)
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch handle vs none.
(defbehavior metalkor-spinner-check metalkor ((arg0 int) (arg1 float) (arg2 vector))
  (if (and (not (handle->process (-> self spinners arg0))) (< arg1 (ja-aframe-num 0)))
      (metalkor-start-spinner arg0 arg2)
      )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior metalkor-lowtorso-spinner-check metalkor ((arg0 metalkor-lowtorso) (arg1 float) (arg2 float))
  (when (and (>= arg1 arg2) (< arg1 (ja-aframe-num 0)))
    (let ((a0-3 (handle->process (-> self lowtorso))))
      (if a0-3
          (send-event a0-3 'spinner arg0)
          )
      )
    )
  (none)
  )

(defbehavior metalkor-update-hud metalkor ()
  (let ((v1-1 (handle->process (-> self hud))))
    (when v1-1
      (set! (-> (the-as hud-metalkor v1-1) values 0 target) (-> self stage))
      (set! (-> (the-as hud-metalkor v1-1) values 1 target) (the int (* 100.0 (-> self stage-hit-points))))
      )
    )
  (none)
  )

(defbehavior metalkor-all-spinners-on metalkor ()
  (let ((gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat))))
    (dotimes (s5-0 4)
      (metalkor-start-spinner s5-0 (-> gp-0 vector 2))
      )
    )
  (dotimes (gp-1 4)
    (let ((a0-3 (handle->process (-> self lowtorso))))
      (if a0-3
          (send-event a0-3 'spinner gp-1)
          )
      )
    )
  #f
  )

(defbehavior metalkor-ja-float metalkor ((arg0 art-joint-anim) (arg1 float) (arg2 float) (arg3 float))
  (dotimes (v1-0 (the-as int (+ (-> self skel active-channels) (-> self skel float-channels))))
    (let ((a1-3 (-> self skel channel v1-0 frame-group)))
      (if (and a1-3 (nonzero? a1-3) (= (-> self skel channel v1-0 command) (joint-control-command float)) (= a1-3 arg0))
          (return (the-as joint-control-channel #f))
          )
      )
    )
  (let ((v1-3 (ja-channel-float! arg0 0.0 0.0 0.0)))
    (when v1-3
      (set! (-> v1-3 param 0) arg1)
      (set! (-> v1-3 param 1) arg2)
      (set! (-> v1-3 param 2) arg3)
      (set! (-> v1-3 num-func) num-func-interp-play!)
      v1-3
      )
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior metalkor-ja-float-stop metalkor ((arg0 art-joint-anim))
  (countdown (s5-0 (-> self skel float-channels))
    (let* ((v1-3 (+ s5-0 (-> self skel active-channels)))
           (a0-3 (-> self skel channel v1-3 frame-group))
           )
      (if (and a0-3 (nonzero? a0-3) (= (-> self skel channel v1-3 command) (joint-control-command float)) (= a0-3 arg0))
          (joint-channel-float-delete! (-> self skel channel v1-3))
          )
      )
    )
  (none)
  )

(defbehavior metalkor-ja-float-children metalkor ()
  (dotimes (gp-0 (the-as int (+ (-> self skel active-channels) (-> self skel float-channels))))
    (let ((v1-2 (-> self skel channel gp-0 frame-group)))
      (cond
        ((or (not v1-2) (zero? v1-2) (!= (-> self skel channel gp-0 command) 42))
         )
        ((= v1-2 (-> self draw art-group data 23))
         (send-event (handle->process (-> self lowtorso)) 'ja-float "hang-pre-shot" gp-0)
         )
        ((= v1-2 (-> self draw art-group data 32))
         (send-event (handle->process (-> self legs)) 'ja-float "pre-shot" gp-0)
         (send-event (handle->process (-> self lowtorso)) 'ja-float "pre-shot" gp-0)
         )
        ((= v1-2 (-> self draw art-group data 34))
         (send-event (handle->process (-> self legs)) 'ja-float "hit" gp-0)
         (send-event (handle->process (-> self lowtorso)) 'ja-float "hit" gp-0)
         )
        ((= v1-2 (-> self draw art-group data 35))
         (send-event (handle->process (-> self legs)) 'ja-float "hit-left" gp-0)
         (send-event (handle->process (-> self lowtorso)) 'ja-float "hit-left" gp-0)
         )
        ((= v1-2 (-> self draw art-group data 36))
         (send-event (handle->process (-> self legs)) 'ja-float "hit-right" gp-0)
         (send-event (handle->process (-> self lowtorso)) 'ja-float "hit-right" gp-0)
         )
        )
      )
    )
  #f
  )

(defbehavior metalkor-ja-float-group? metalkor ((arg0 art-joint-anim))
  (countdown (v1-1 (-> self skel float-channels))
    (let* ((a1-2 (+ v1-1 (-> self skel active-channels)))
           (a2-2 (-> self skel channel a1-2 frame-group))
           )
      (if (and a2-2 (nonzero? a2-2) (= (-> self skel channel a1-2 command) (joint-control-command float)) (= a2-2 arg0))
          (return (the-as int a1-2))
          )
      )
    )
  -1
  )

;; WARN: Check prologue - tricky store of r0
(defun metalkor-get-ring ((arg0 metalkor))
  (local-vars (sv-16 res-tag))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-1 (res-lump-data (-> arg0 entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
    (when (and v1-1 (< (the-as uint 2) (-> sv-16 elt-count)))
      (let ((v1-2 (-> v1-1 2)))
        (if (>= (-> v1-2 length) 1)
            (return (-> v1-2 data 0 actor))
            )
        )
      )
    )
  (the-as entity #f)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior metalkor-common metalkor ()
  (cond
    ((and (= (ja-group-size) 9) (= (if (> (-> self skel active-channels) 0)
                                       (-> self skel root-channel 8 frame-group)
                                       )
                                   (-> self draw art-group data 41)
                                   )
          )
     (let ((v1-8 (-> self skel effect)))
       (set! (-> v1-8 channel-offset) 8)
       )
     0
     )
    (else
      (let ((v1-11 (-> self skel effect)))
        (set! (-> v1-11 channel-offset) 0)
        )
      0
      )
    )
  (if (and (nonzero? (-> self next-stage-timer)) (>= (- (current-time) (-> self next-stage-timer)) 0))
      (metalkor-go-next-stage)
      )
  (when (>= (- (current-time) (-> self no-collision-timer)) (seconds 0.1))
    (let ((v1-25 (-> self root-override root-prim)))
      (set! (-> v1-25 prim-core collide-as) (-> self root-override backup-collide-as))
      (set! (-> v1-25 prim-core collide-with) (-> self root-override backup-collide-with))
      )
    )
  (case (-> self stage)
    ((2)
     (script-eval '(want-anim "nest-kor-boss-fight-mid"))
     )
    ((3)
     (script-eval '(want-anim "outro-nest"))
     )
    )
  (when (nonzero? (-> self neck))
    (let* ((gp-0 *target*)
           (a0-20 (if (type? gp-0 process-focusable)
                      gp-0
                      )
                  )
           )
      (if a0-20
          (target-set! (-> self neck) (get-trans a0-20 2))
          )
      )
    )
  (set! (-> self trackable) #t)
  (let ((t0-2 (new 'static 'vector)))
    (set! (-> t0-2 quad) (-> self root-override trans quad))
    (set! (-> t0-2 y) (+ 16384.0 (-> t0-2 y)))
    (set-setting! 'point-of-interest 'abs t0-2 0)
    )
  (set! (-> self live-flitters) 0)
  (dotimes (gp-2 10)
    (let ((a0-24 (handle->process (-> self flitters gp-2))))
      (when a0-24
        (if (< (-> (the-as process-drawable a0-24) root trans y) (+ -204800.0 (-> self root-override trans y)))
            (send-event a0-24 'die-fast)
            (+! (-> self live-flitters) 1)
            )
        )
      )
    )
  (set! (-> self live-wasps) 0)
  (dotimes (v1-65 3)
    (if (handle->process (-> self wasps v1-65))
        (+! (-> self live-wasps) 1)
        )
    )
  (metalkor-ja-float-children)
  (none)
  )

(defmethod deactivate metalkor ((obj metalkor))
  (if (-> obj wing-sound-playing)
      (sound-stop (-> obj wing-sound))
      )
  ((method-of-type process-focusable deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch process-focusable vs metalkor.
(defmethod relocate metalkor ((obj metalkor) (arg0 int))
  (if (nonzero? (-> obj shot-anticipate))
      (&+! (-> obj shot-anticipate) arg0)
      )
  (if (nonzero? (-> obj neck))
      (&+! (-> obj neck) arg0)
      )
  (the-as metalkor ((method-of-type process-focusable relocate) obj arg0))
  )

(defmethod get-trans metalkor ((obj metalkor) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (local-vars (s5-0 vector))
  (cond
    ((or (= arg0 2) (= arg0 3))
     (set! s5-0 (new 'static 'vector))
     (set! (-> s5-0 quad)
           (-> (the-as collide-shape-prim-group (-> obj root-override root-prim)) child 0 prim-core world-sphere quad)
           )
     (set! (-> s5-0 w) 61440.0)
     s5-0
     )
    ((= arg0 4)
     (set! s5-0 (new 'static 'vector))
     (cond
       ((zero? (-> obj skel active-channels))
        )
       ((or (and (-> obj next-state) (= (-> obj next-state name) 'explode))
            (and (and (-> obj next-state) (= (-> obj next-state name) 'fly-to-ring)) (-> obj been-to-entity))
            )
        (vector<-cspace! s5-0 (-> obj node-list data 3))
        )
       (else
         (set! (-> s5-0 quad) (-> obj root-override trans quad))
         (set! (-> s5-0 y) (+ 8192.0 (-> s5-0 y)))
         )
       )
     (when (< 0.0 (-> obj ring-cam-pos value))
       (let ((a0-15 (metalkor-get-ring obj))
             (a2-0 (new 'stack-no-clear 'vector))
             )
         (set! (-> a2-0 quad) (-> a0-15 trans quad))
         (set! (-> a2-0 y) (+ -65536.0 (-> a2-0 y)))
         (vector-lerp! s5-0 s5-0 a2-0 (-> obj ring-cam-pos value))
         )
       )
     s5-0
     )
    (else
      ((method-of-type process-focusable get-trans) obj arg0)
      )
    )
  )

(defbehavior set-countdown-to-roar metalkor ()
  (case (-> self stage)
    ((1)
     (set! (-> self countdown-to-roar) (rand-vu-int-range 2 5))
     )
    (else
      (set! (-> self countdown-to-roar) (rand-vu-int-range 1 3))
      )
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior metalkor-go-next-stage metalkor ()
  (let ((v1-1 (-> self skel effect)))
    (set! (-> v1-1 channel-offset) 0)
    )
  0
  (set! (-> self stage) (min 5 (+ (-> self stage) 1)))
  (if (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
      (set! (-> self stage) (max 3 (-> self stage)))
      )
  (if (task-node-closed? (game-task-node nest-boss-resolution))
      (set! (-> self stage) (max 5 (-> self stage)))
      )
  (set! (-> self stage-hit-points) 1.0)
  (set! (-> self next-stage-timer) 0)
  (init (-> self ring-cam-pos) 0.0 0.01 0.1 0.9)
  (when (not (handle->process (-> self rift-occlude)))
    (if (metalkor-get-ring self)
        (set! (-> self rift-occlude)
              (ppointer->handle (process-spawn rift-occlude (metalkor-get-ring self) :to self))
              )
        )
    )
  (let ((v1-28 (-> self stage)))
    (cond
      ((zero? v1-28)
       (set! (-> self root-override trans y) (+ -12288.0 (-> self entity trans y)))
       (go-virtual hidden)
       )
      ((= v1-28 1)
       (set-setting! 'music 'danger4 0.0 0)
       (set! (-> self hud) (ppointer->handle (process-spawn hud-metalkor :init hud-init-by-other :to self)))
       (metalkor-update-hud)
       (set! (-> self lowtorso)
             (ppointer->handle (process-spawn metalkor-lowtorso "" (-> self root-override trans) :to self))
             )
       (set! (-> self kid) (ppointer->handle (process-spawn metalkor-kid (-> self entity trans) :to self)))
       (let ((gp-4 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat))))
         (dotimes (s5-1 4)
           (metalkor-start-spinner s5-1 (-> gp-4 vector 2))
           )
         )
       (dotimes (gp-5 4)
         (let ((a0-44 (handle->process (-> self lowtorso))))
           (if a0-44
               (send-event a0-44 'spinner gp-5)
               )
           )
         )
       (set-countdown-to-roar)
       (set-setting! 'fov 'abs (degrees 84.0) 0)
       (ja :group! (-> self draw art-group data 9) :num! min)
       (go-virtual hang-shoot-n-launch)
       )
      ((= v1-28 2)
       (set-setting! 'music 'danger4 0.0 0)
       (set-countdown-to-roar)
       (go-virtual start-second-stage)
       )
      ((= v1-28 3)
       (set-setting! 'music 'danger4 0.0 0)
       (set! (-> self last-close-attack) 0)
       (set! (-> self last-standing-attack) 0)
       (cond
         ((not (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
               )
          (go-virtual play-drop-movie)
          )
         ((zero? (-> self nav))
          (format 0 "ERROR<GMJ>: metalkor nav mesh not found~%")
          (go-virtual beaten (not (task-node-closed? (game-task-node nest-boss-resolution))))
          )
         (else
           (metalkor-spinners-off)
           (metalkor-lowtorso-spinners-off)
           (dotimes (gp-8 3)
             (let ((a0-61 (handle->process (-> self wasps gp-8))))
               (if a0-61
                   (send-event a0-61 'die-fast)
                   )
               )
             )
           (let ((v1-106 (new 'stack-no-clear 'vector)))
             (set! (-> v1-106 quad) (-> self entity trans quad))
             (set! (-> v1-106 x) (+ 90112.0 (-> v1-106 x)))
             (set! (-> v1-106 z) (+ -90112.0 (-> v1-106 z)))
             (set! (-> self root-override trans quad) (-> v1-106 quad))
             )
           (when (not (handle->process (-> self hud)))
             (set! (-> self hud) (ppointer->handle (process-spawn hud-metalkor :init hud-init-by-other :to self)))
             (metalkor-update-hud)
             )
           (if (not (handle->process (-> self lowtorso)))
               (set! (-> self lowtorso)
                     (ppointer->handle (process-spawn metalkor-lowtorso "" (-> self root-override trans) :to self))
                     )
               )
           (if (not (handle->process (-> self kid)))
               (set! (-> self kid) (ppointer->handle (process-spawn metalkor-kid (-> self entity trans) :to self)))
               )
           (set! (-> self legs)
                 (ppointer->handle (process-spawn metalkor-legs "" (-> self root-override trans) :to self))
                 )
           (set-setting! 'fov 'abs (degrees 84.0) 0)
           (go-virtual chase-target)
           )
         )
       )
      ((= v1-28 4)
       (set-setting! 'music 'danger4 0.0 0)
       (set! (-> self wings)
             (ppointer->handle (process-spawn metalkor-wings "" (-> self root-override trans) :to self))
             )
       (send-event (handle->process (-> self hud)) 'hide-and-die)
       (go-virtual last-gasp)
       )
      (else
        (go-virtual beaten (not (task-node-closed? (game-task-node nest-boss-resolution))))
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defbehavior metalkor-setup-hit-anim metalkor ((arg0 attack-info) (arg1 process-drawable) (arg2 art-element) (arg3 art-element) (arg4 float))
  (ja-channel-push! 2 0)
  (ja :group! arg2 :num! min)
  (let* ((f30-0 -0.5)
         (v1-5 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
         (v1-6 (the-as number (logior #x3f800000 v1-5)))
         (f30-1 (+ f30-0 (+ -1.0 (the-as float v1-6))))
         (s2-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
         (s1-1 (new 'stack-no-clear 'attack-info))
         )
    (attack-info-method-9 arg0 s1-1 arg1 self)
    (vector-flatten! (-> s1-1 trans) (-> s1-1 trans) (-> s2-1 vector 1))
    (let ((f30-2 (fmax -1.0 (fmin 1.0 (+ f30-1 (vector-dot (-> s1-1 trans) (the-as vector (-> s2-1 vector))))))))
      (set! f30-2 (cond
                    ((>= f30-2 0.0)
                     (ja :chan 1 :group! arg3 :num! min)
                     f30-2
                     )
                    (else
                      (ja :chan 1 :group! arg4 :num! min)
                      (- f30-2)
                      )
                    )
            )
      (let ((v1-24 (-> self skel root-channel 1)))
        (set! (-> v1-24 frame-interp 1) f30-2)
        (set! (-> v1-24 frame-interp 0) f30-2)
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch process vs none.
(defbehavior metalkor-get-gem-tracker metalkor ((arg0 process-focusable))
  (cond
    ((type? arg0 metalkor-wasp)
     (handle->process (-> self wasp-gem-tracker))
     )
    ((type? arg0 metalkor-flitter)
     (handle->process (-> self flitter-gem-tracker))
     )
    (else
      )
    )
  (none)
  )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 72]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 107]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 143]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 173]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 254]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 266]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 291]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 489]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 571]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 580]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 666]
(defbehavior metalkor-handler metalkor ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-2 none))
  (the-as
    object
    (case arg2
      (('skip)
       (dotimes (gp-1 10)
         (let ((a0-4 (handle->process (-> self flitters gp-1))))
           (if a0-4
               (send-event a0-4 'die-fast)
               )
           )
         )
       (dotimes (gp-2 3)
         (let ((a0-8 (handle->process (-> self wasps gp-2))))
           (if a0-8
               (send-event a0-8 'die-fast)
               )
           )
         )
       (metalkor-go-next-stage)
       )
      (('track)
       (-> self trackable)
       )
      (('flitter-change-gem)
       (let ((v1-23 (new 'stack-no-clear 'event-message-block)))
         (set! (-> v1-23 from) (process->ppointer arg0))
         (set! (-> v1-23 num-params) arg1)
         (set! (-> v1-23 message) arg2)
         (set! (-> v1-23 param 0) (-> arg3 param 0))
         (set! (-> v1-23 param 1) (-> arg3 param 1))
         (set! (-> v1-23 param 2) (-> arg3 param 2))
         (set! (-> v1-23 param 3) (-> arg3 param 3))
         (set! (-> v1-23 param 4) (-> arg3 param 4))
         (set! (-> v1-23 param 5) (-> arg3 param 5))
         (send-event-function (handle->process (-> self flitter-gem-tracker)) v1-23)
         )
       )
      (('wasp-change-gem)
       (let ((v1-24 (new 'stack-no-clear 'event-message-block)))
         (set! (-> v1-24 from) (process->ppointer arg0))
         (set! (-> v1-24 num-params) arg1)
         (set! (-> v1-24 message) arg2)
         (set! (-> v1-24 param 0) (-> arg3 param 0))
         (set! (-> v1-24 param 1) (-> arg3 param 1))
         (set! (-> v1-24 param 2) (-> arg3 param 2))
         (set! (-> v1-24 param 3) (-> arg3 param 3))
         (set! (-> v1-24 param 4) (-> arg3 param 4))
         (set! (-> v1-24 param 5) (-> arg3 param 5))
         (send-event-function (handle->process (-> self wasp-gem-tracker)) v1-24)
         )
       )
      (('have-gem?)
       (let ((s4-0 (new 'stack-no-clear 'event-message-block)))
         (set! (-> s4-0 from) (process->ppointer arg0))
         (set! (-> s4-0 num-params) arg1)
         (set! (-> s4-0 message) arg2)
         (set! (-> s4-0 param 0) (-> arg3 param 0))
         (set! (-> s4-0 param 1) (-> arg3 param 1))
         (set! (-> s4-0 param 2) (-> arg3 param 2))
         (set! (-> s4-0 param 3) (-> arg3 param 3))
         (set! (-> s4-0 param 4) (-> arg3 param 4))
         (set! (-> s4-0 param 5) (-> arg3 param 5))
         (send-event-function (the-as process-tree (metalkor-get-gem-tracker (the-as process-focusable arg0))) s4-0)
         )
       )
      (('setup-flitter-gem)
       (let ((gp-3 (-> self entity extra)))
         (cond
           ((send-event (handle->process (-> self flitter-gem-tracker)) 'spawn-with-gem?)
            (set! v0-2 (the-as none (logclear (-> gp-3 perm status) (entity-perm-status save))))
            (set! (-> gp-3 perm status) (the-as entity-perm-status v0-2))
            )
           (else
             (set! v0-2 (the-as none (logior (-> gp-3 perm status) (entity-perm-status save))))
             (set! (-> gp-3 perm status) (the-as entity-perm-status v0-2))
             )
           )
         )
       v0-2
       )
      (('hatch)
       (let ((v1-41 (-> arg3 param 0)))
         (set! (-> self flitters v1-41) (the-as handle (-> arg3 param 1)))
         (send-event
           (handle->process (-> self flitter-gem-tracker))
           'change-gem
           #f
           (handle->process (-> self flitters v1-41))
           )
         )
       )
      (('child-die)
       (cond
         ((not (and (-> self next-state) (= (-> self next-state name) 'hang-shoot-n-launch)))
          #f
          )
         ((>= 1 (-> self countdown-to-roar))
          (set-countdown-to-roar)
          (ja-channel-push! 1 (seconds 0.2))
          (ja :group! (-> self draw art-group data 21) :num! min)
          (metalkor-all-spinners-on)
          )
         (else
           (set! v0-2 (the-as none (+ (-> self countdown-to-roar) -1)))
           (set! (-> self countdown-to-roar) (the-as int v0-2))
           v0-2
           )
         )
       )
      (('attack)
       (let ((f28-0 1.0)
             (s5-2 (the-as object (-> arg3 param 1)))
             (f30-0 (* 0.2 (the float (the int (* 4.99 (-> self stage-hit-points))))))
             )
         (when (!= (-> self stage-hit-points) 0.0)
           (when (or (not (logtest? (-> (the-as attack-info s5-2) mask) (attack-info-mask id)))
                     (!= (-> self last-attack-id) (-> (the-as attack-info s5-2) id))
                     )
             (if (logtest? (-> (the-as attack-info s5-2) mask) (attack-info-mask id))
                 (set! (-> self last-attack-id) (-> (the-as attack-info s5-2) id))
                 )
             (if (logtest? (attack-info-mask damage) (-> (the-as attack-info s5-2) mask))
                 (set! f28-0 (-> (the-as attack-info s5-2) damage))
                 )
             (let* ((s4-1 arg0)
                    (f0-4 (cond
                            ((if (type? s4-1 gun-blue-shot)
                                 s4-1
                                 )
                             (if (= (-> self stage) 3)
                                 (* 0.0012 f28-0)
                                 (* 0.0024 f28-0)
                                 )
                             )
                            (else
                              (let ((s4-2 arg0))
                                (cond
                                  ((if (type? s4-2 gun-dark-shot)
                                       s4-2
                                       )
                                   (if (= (-> self stage) 3)
                                       (* 0.003 f28-0)
                                       (* 0.006 f28-0)
                                       )
                                   )
                                  ((= (-> self stage) 3)
                                   (* 0.004 f28-0)
                                   )
                                  (else
                                    (* 0.008 f28-0)
                                    )
                                  )
                                )
                              )
                            )
                          )
                    )
               (if (and (logtest? (attack-info-mask penetrate-using) (-> (the-as attack-info s5-2) mask))
                        (logtest? (penetrate dark-bomb) (-> (the-as attack-info s5-2) penetrate-using))
                        )
                   (set! f0-4 0.5)
                   )
               (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                   (set! f0-4 (* 0.6666667 f0-4))
                   )
               (if (not (and (-> self next-state) (let ((v1-109 (-> self next-state name)))
                                                    (or (= v1-109 'fall-down)
                                                        (= v1-109 'overload-recover)
                                                        (= v1-109 'tail-attack)
                                                        (= v1-109 'foot-attack)
                                                        (= v1-109 'start-second-stage)
                                                        )
                                                    )
                             )
                        )
                   (set! (-> self stage-hit-points) (fmax 0.0 (- (-> self stage-hit-points) f0-4)))
                   )
               )
             (metalkor-update-hud)
             (cond
               ((and (logtest? (attack-info-mask penetrate-using) (-> (the-as attack-info s5-2) mask))
                     (logtest? (penetrate dark-bomb) (-> (the-as attack-info s5-2) penetrate-using))
                     (= (-> self stage-hit-points) 0.0)
                     )
                (set! v0-2 (the-as none (+ (current-time) (seconds 1))))
                (set! (-> self next-stage-timer) (the-as time-frame v0-2))
                v0-2
                )
               ((= (-> self stage-hit-points) 0.0)
                (metalkor-go-next-stage)
                )
               ((and (-> self next-state) (= (-> self next-state name) 'hang-shoot-n-launch))
                (metalkor-setup-hit-anim
                  (the-as attack-info s5-2)
                  (the-as process-drawable arg0)
                  (-> self draw art-group data 18)
                  (-> self draw art-group data 20)
                  (the-as float (-> self draw art-group data 19))
                  )
                (metalkor-all-spinners-on)
                )
               ((and (and (-> self next-state) (= (-> self next-state name) 'fall-down))
                     (let ((v1-139 (ja-group)))
                       (or (not (and v1-139 (= v1-139 (-> self draw art-group data 7)))) (>= (ja-aframe-num 0) 10.0))
                       )
                     )
                (metalkor-setup-hit-anim
                  (the-as attack-info s5-2)
                  (the-as process-drawable arg0)
                  (-> self draw art-group data 25)
                  (-> self draw art-group data 27)
                  (the-as float (-> self draw art-group data 26))
                  )
                )
               ((and (-> self next-state) (let ((v1-153 (-> self next-state name)))
                                            (or (= v1-153 'chase-target)
                                                (= v1-153 'standing-shot)
                                                (= v1-153 'overload-recover)
                                                (= v1-153 'tail-attack)
                                                (= v1-153 'foot-attack)
                                                (= v1-153 'get-close)
                                                )
                                            )
                     )
                (if (< (-> self stage-hit-points) f30-0)
                    (go-virtual fall-down)
                    (metalkor-ja-float (the-as art-joint-anim (-> self draw art-group data 34)) 1.0 0.25 2.0)
                    )
                )
               )
             )
           )
         )
       )
      (('touch)
       (when ((method-of-type touching-shapes-entry prims-touching?)
              (the-as touching-shapes-entry (-> arg3 param 0))
              (-> self root-override)
              (the-as uint 1)
              )
         (let* ((s4-3 arg0)
                (gp-5 (if (type? s4-3 process-focusable)
                          s4-3
                          )
                      )
                )
           (when gp-5
             (let ((s3-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
                   (s4-4 (new 'stack-no-clear 'vector))
                   )
               (if (>= (metalkor-ja-float-group? (the-as art-joint-anim (-> self draw art-group data 42))) 0)
                   (vector+! s4-4 (-> s3-0 vector 2) (the-as vector (-> s3-0 vector)))
                   (vector-! s4-4 (-> s3-0 vector 2) (the-as vector (-> s3-0 vector)))
                   )
               (set! (-> s4-4 y) 0.0)
               (vector-normalize! s4-4 32768.0)
               (set! (-> s4-4 y) 24576.0)
               (let ((a1-43 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> a1-43 from) (process->ppointer self))
                 (set! (-> a1-43 num-params) 2)
                 (set! (-> a1-43 message) 'attack)
                 (set! (-> a1-43 param 0) (-> arg3 param 0))
                 (let ((v1-170 (new 'static 'attack-info :mask (attack-info-mask vector shove-up id))))
                   (let* ((a0-116 *game-info*)
                          (a2-15 (+ (-> a0-116 attack-id) 1))
                          )
                     (set! (-> a0-116 attack-id) a2-15)
                     (set! (-> v1-170 id) a2-15)
                     )
                   (set! (-> v1-170 vector quad) (-> s4-4 quad))
                   (set! (-> v1-170 shove-up) 24576.0)
                   (set! (-> a1-43 param 1) (the-as uint v1-170))
                   )
                 (when (send-event-function gp-5 a1-43)
                   (set! (-> self no-collision-timer) (current-time))
                   (let ((v1-175 (-> self root-override root-prim)))
                     (set! (-> v1-175 prim-core collide-as) (collide-spec))
                     (set! (-> v1-175 prim-core collide-with) (collide-spec))
                     )
                   0
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  )

(defbehavior metalkor-start-egg metalkor ()
  (if (nonzero? (-> self egg-timer))
      (return #f)
      )
  (dotimes (v1-3 10)
    (when (not (handle->process (-> self flitters v1-3)))
      (new 'stack-no-clear 'vector)
      (let ((f0-1 (* 182.04445 (rand-vu-float-range 70.0 290.0))))
        (set! (-> self egg-timer) (current-time))
        (set! (-> self egg-angle) f0-1)
        (if (< 32768.0 f0-1)
            (send-event (handle->process (-> self lowtorso)) 'egg-toss 1.0)
            (send-event (handle->process (-> self lowtorso)) 'egg-toss -1.0)
            )
        )
      (return #f)
      )
    )
  #f
  )

(defbehavior metalkor-check-egg metalkor ()
  (local-vars (v0-0 symbol))
  (if (zero? (-> self egg-timer))
      (return #f)
      )
  (if (< (- (current-time) (-> self egg-timer)) (seconds 0.2))
      (return #t)
      )
  (dotimes (gp-0 10)
    (when (not (handle->process (-> self flitters gp-0)))
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> s5-0 quad) (-> self root-override trans quad))
        (let ((v1-19 (handle->process (-> self lowtorso))))
          (if v1-19
              (vector<-cspace! s5-0 (-> (the-as process-focusable v1-19) node-list data 11))
              )
          )
        (let ((s2-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat))))
          (set-vector! s4-0 (* 102400.0 (sin (-> self egg-angle))) 81920.0 (* 102400.0 (cos (-> self egg-angle))) 1.0)
          (vector-matrix*! s4-0 s4-0 s2-0)
          )
        (when (-> self entity)
          (let ((v1-31 (-> self entity extra)))
            (logior! (-> v1-31 perm status) (entity-perm-status save))
            )
          )
        (sound-play "nboss-spawn")
        (set! (-> self flitters gp-0) (ppointer->handle (process-spawn metalkor-egg s5-0 s4-0 gp-0 :to self)))
        )
      (send-event (handle->process (-> self lowtorso)) 'egg-toss 0)
      (set! (-> self egg-timer) 0)
      (return #f)
      )
    )
  (return #f)
  v0-0
  )

(defbehavior metalkor-shoot-projectile metalkor ()
  (let ((gp-0 (new 'stack-no-clear 'projectile-init-by-other-params)))
    (set! (-> gp-0 ent) (-> self entity))
    (set! (-> gp-0 charge) 1.0)
    (set! (-> gp-0 options) (projectile-options))
    (set! (-> gp-0 notify-handle) (the-as handle #f))
    (set! (-> gp-0 owner-handle) (the-as handle #f))
    (set! (-> gp-0 ignore-handle) (process->handle self))
    (let* ((v1-5 *game-info*)
           (a0-5 (+ (-> v1-5 attack-id) 1))
           )
      (set! (-> v1-5 attack-id) a0-5)
      (set! (-> gp-0 attack-id) a0-5)
      )
    (set! (-> gp-0 timeout) (seconds 4))
    (vector<-cspace! (-> gp-0 pos) (-> self node-list data 7))
    (vector-! (-> gp-0 vel) (target-pos 0) (-> gp-0 pos))
    (vector-normalize! (-> gp-0 vel) 491520.0)
    (if (spawn-projectile metalkor-shot gp-0 self *default-dead-pool*)
        (+! (-> self shots-fired) 1)
        )
    )
  (none)
  )

(defbehavior metalkor-face-to-vector metalkor ((arg0 vector) (arg1 float) (arg2 float))
  (let ((s4-0 (new 'stack-no-clear 'matrix))
        (s5-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
        (gp-0 (new 'stack-no-clear 'matrix))
        )
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (vector-! s3-0 arg0 (-> self root-override trans))
      (vector-flatten! s3-0 s3-0 (-> s5-0 vector 1))
      (vector-normalize! s3-0 1.0)
      (matrix-from-two-vectors-max-angle-partial!
        s4-0
        (-> s5-0 vector 2)
        s3-0
        (* arg1 (-> self clock time-adjust-ratio))
        (* arg2 (-> self clock time-adjust-ratio))
        )
      )
    (matrix*! gp-0 s5-0 s4-0)
    (matrix-remove-z-rot gp-0 (new 'static 'vector :y -1.0))
    (set! (-> self last-rotation) (acos (vector-dot (-> s5-0 vector 2) (-> gp-0 vector 2))))
    (if (< (vector-dot (-> gp-0 vector 2) (the-as vector (-> s5-0 vector))) 0.0)
        (set! (-> self last-rotation) (- (-> self last-rotation)))
        )
    (cond
      ((< (fabs (-> self last-rotation)) 20.024889)
       (set! (-> self last-rotation) 0.0)
       )
      (else
        (matrix->quaternion (-> self root-override quat) gp-0)
        (quaternion-normalize! (-> self root-override quat))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defbehavior update-walk-anim metalkor ((arg0 vector) (arg1 symbol))
  (local-vars (f24-0 float))
  (let ((v1-2 (ja-group)))
    (cond
      ((and (and v1-2 (= v1-2 (-> self draw art-group data 33))) (begin (ja :num! (seek!)) (not (ja-done? 0))))
       )
      (else
        (let* ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self root-override trans) arg0))
               (v1-16 s5-1)
               (f26-0 (sqrtf (+ (* (-> v1-16 x) (-> v1-16 x)) (* (-> v1-16 z) (-> v1-16 z)))))
               (v1-19 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
               )
          0.0
          (let ((f30-0 0.0)
                (f28-0 0.0)
                )
            0.0
            (let ((f0-11 (* 0.000024414063
                            (the float (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames))
                            f26-0
                            )
                         )
                  (f26-1 (* 0.000015258789
                            (the float (-> (the-as art-joint-anim (-> self draw art-group data 6)) frames num-frames))
                            f26-0
                            )
                         )
                  )
              (cond
                ((or (< 1.0 f26-1) arg1)
                 (set! f24-0 0.0)
                 )
                ((< f0-11 1.0)
                 (set! f24-0 1.0)
                 (set! f26-1 f0-11)
                 )
                (else
                  (set! f24-0 (/ (- 1.0 f26-1) (- f0-11 f26-1)))
                  (set! f26-1 1.0)
                  )
                )
              (let ((f0-15 (* 0.000045776367
                              (the float (-> (the-as art-joint-anim (-> self draw art-group data 37)) frames num-frames))
                              (-> self last-rotation)
                              )
                           )
                    )
                (when (and (< (vector-dot s5-1 (-> v1-19 vector 2)) 0.0) (not arg1))
                  (set! f26-1 (- f26-1))
                  (set! f0-15 (- f0-15))
                  )
                (if (< f0-15 0.0)
                    (set! f30-0 1.0)
                    )
                (when (and (< (fabs f26-1) (fabs f0-15)) (not arg1))
                  (set! f26-1 f0-15)
                  (set! f28-0 1.0)
                  )
                )
              (let ((f22-0 (if (and (= f26-1 0.0) (not arg1))
                               1.0
                               0.0
                               )
                           )
                    )
                (let ((v1-41 (ja-group)))
                  (cond
                    ((not (and v1-41 (= v1-41 (-> self draw art-group data 6))))
                     (ja-channel-push! 9 (seconds 0.5))
                     (ja :group! (-> self draw art-group data 6) :num! min)
                     (ja :chan 1 :group! (-> self draw art-group data 40) :num! min)
                     (set! (-> self skel root-channel 2 command) (joint-control-command push))
                     (ja :chan 2 :group! (-> self draw art-group data 5) :num! min)
                     (ja :chan 3 :group! (-> self draw art-group data 39) :num! min)
                     (set! (-> self skel root-channel 4 command) (joint-control-command stack))
                     (set! (-> self skel root-channel 5 command) (joint-control-command push))
                     (ja :chan 5 :group! (-> self draw art-group data 37) :num! min)
                     (ja :chan 6 :group! (-> self draw art-group data 38) :num! min)
                     (set! (-> self skel root-channel 7 command) (joint-control-command stack))
                     (let* ((v1-79 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                            (v1-80 (the-as number (logior #x3f800000 v1-79)))
                            )
                       (cond
                         ((< (+ -1.0 (the-as float v1-80)) 0.2)
                          (ja :chan 8 :group! (-> self draw art-group data 4) :num! min)
                          )
                         (else
                           (ja :chan 8 :group! (-> self draw art-group data 3) :num! min)
                           (set! (-> self reps-till-idle-alt) (rand-vu-int-range 0 1))
                           )
                         )
                       )
                     (init
                       (-> self for-back-interp)
                       (if (< f26-1 0.0)
                           1.0
                           0.0
                           )
                       0.01
                       0.1
                       0.9
                       )
                     (init (-> self run-walk-interp) f24-0 0.01 0.1 0.9)
                     (init (-> self left-right-interp) f30-0 0.01 0.1 0.9)
                     (init (-> self walk-turn-interp) f28-0 0.01 0.1 0.9)
                     (init (-> self idle-interp) f22-0 0.01 0.1 0.9)
                     )
                    ((= (if (> (-> self skel active-channels) 0)
                            (-> self skel root-channel 8 frame-group)
                            )
                        (-> self draw art-group data 41)
                        )
                     (ja :chan 8 :num! (seek!))
                     (when (ja-done? 8)
                       (let* ((v1-117 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                              (v1-118 (the-as number (logior #x3f800000 v1-117)))
                              )
                         (cond
                           ((< (+ -1.0 (the-as float v1-118)) 0.2)
                            (ja :chan 8 :group! (-> self draw art-group data 4) :num! min)
                            )
                           (else
                             (ja :chan 8 :group! (-> self draw art-group data 3) :num! min)
                             (set! (-> self reps-till-idle-alt) (rand-vu-int-range 0 1))
                             )
                           )
                         )
                       )
                     )
                    ((= (if (> (-> self skel active-channels) 0)
                            (-> self skel root-channel 8 frame-group)
                            )
                        (-> self draw art-group data 4)
                        )
                     (ja :chan 8 :num! (seek!))
                     (when (ja-done? 8)
                       (ja :chan 8 :group! (-> self draw art-group data 3) :num! min)
                       (set! (-> self reps-till-idle-alt) (rand-vu-int-range 2 4))
                       )
                     )
                    ((zero? (-> self reps-till-idle-alt))
                     (ja :chan 8 :num! (seek!))
                     (if (ja-done? 8)
                         (ja :chan 8 :group! (-> self draw art-group data 4) :num! min)
                         )
                     )
                    (else
                      (let ((f20-0 (ja-aframe-num 8)))
                        (ja :chan 8 :num! (loop!))
                        (if (< (ja-aframe-num 8) f20-0)
                            (+! (-> self reps-till-idle-alt) -1)
                            )
                        )
                      )
                    )
                  )
                (let ((a0-94 (-> self skel root-channel 0)))
                  (set! (-> a0-94 param 0) f26-1)
                  (joint-control-channel-group-eval! a0-94 (the-as art-joint-anim #f) num-func-loop-speedless!)
                  )
                (ja :chan 1 :num! (chan 0))
                (ja :chan 2 :num! (chan 0))
                (ja :chan 3 :num! (chan 0))
                (ja :chan 5 :num! (chan 0))
                (ja :chan 6 :num! (chan 0))
                (set! (-> self for-back-interp target) (if (< f26-1 0.0)
                                                           1.0
                                                           0.0
                                                           )
                      )
                (set! (-> self run-walk-interp target) f24-0)
                (set! (-> self left-right-interp target) f30-0)
                (set! (-> self walk-turn-interp target) f28-0)
                (cond
                  ((or (< 0.5 (-> self idle-interp target)) (< f22-0 0.5))
                   (set! (-> self idle-interp target) f22-0)
                   )
                  ((< (-> self idle-interp value) 0.01)
                   (ja :chan 8 :group! (-> self draw art-group data 41) :num! min)
                   (set! (-> self idle-interp target) f22-0)
                   )
                  )
                )
              )
            )
          )
        (update! (-> self for-back-interp) 0.0)
        (update! (-> self run-walk-interp) 0.0)
        (update! (-> self left-right-interp) 0.0)
        (update! (-> self walk-turn-interp) 0.0)
        (update! (-> self idle-interp) 0.0)
        (let ((v1-217 (-> self skel root-channel 1))
              (f0-58 (-> self for-back-interp value))
              )
          (set! (-> v1-217 frame-interp 1) f0-58)
          (set! (-> v1-217 frame-interp 0) f0-58)
          )
        (let ((v1-221 (-> self skel root-channel 3))
              (f0-59 (-> self for-back-interp value))
              )
          (set! (-> v1-221 frame-interp 1) f0-59)
          (set! (-> v1-221 frame-interp 0) f0-59)
          )
        (let ((v1-225 (-> self skel root-channel 4))
              (f0-60 (-> self run-walk-interp value))
              )
          (set! (-> v1-225 frame-interp 1) f0-60)
          (set! (-> v1-225 frame-interp 0) f0-60)
          )
        (let ((v1-229 (-> self skel root-channel 6))
              (f0-61 (-> self left-right-interp value))
              )
          (set! (-> v1-229 frame-interp 1) f0-61)
          (set! (-> v1-229 frame-interp 0) f0-61)
          )
        (let ((v1-233 (-> self skel root-channel 7))
              (f0-62 (-> self walk-turn-interp value))
              )
          (set! (-> v1-233 frame-interp 1) f0-62)
          (set! (-> v1-233 frame-interp 0) f0-62)
          )
        (let ((v1-237 (-> self skel root-channel 8))
              (f0-63 (-> self idle-interp value))
              )
          (set! (-> v1-237 frame-interp 1) f0-63)
          (set! (-> v1-237 frame-interp 0) f0-63)
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior rotate-and-update-hang-anim metalkor ()
  (let ((s5-0 (new 'stack-no-clear 'matrix))
        (gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (set! (-> s3-0 quad) (-> (target-pos 0) quad))
      (vector-! s4-0 s3-0 (-> self root-override trans))
      )
    (vector-flatten! s4-0 s4-0 (-> gp-0 vector 1))
    (vector-normalize! s4-0 1.0)
    (let ((f26-0 (acos (vector-dot s4-0 (-> gp-0 vector 2))))
          (f30-0 0.0)
          )
      (let ((f28-0 (ja-aframe-num 0)))
        (set! (-> self target-angle) f26-0)
        (if (< 0.0 (vector-dot s4-0 (the-as vector (-> gp-0 vector))))
            (set! f26-0 (- f26-0))
            )
        (let ((v1-12 (ja-group)))
          (cond
            ((and (and v1-12 (or (= v1-12 (-> self draw art-group data 18))
                                 (= v1-12 (-> self draw art-group data 21))
                                 (= v1-12 (-> self draw art-group data 24))
                                 )
                       )
                  (begin (ja :num! (seek!)) (not (ja-done? 0)))
                  )
             )
            ((and (< 8738.134 f26-0)
                  (let ((v1-30 (ja-group)))
                    (not (and v1-30 (or (= v1-30 (-> self draw art-group data 10)) (= v1-30 (-> self draw art-group data 11)))))
                    )
                  )
             (ja-channel-push! 1 (seconds 0.2))
             (ja :group! (-> self draw art-group data 10) :num! min)
             (metalkor-spinners-off)
             )
            ((and (< f26-0 -8738.134)
                  (let ((v1-44 (ja-group)))
                    (not (and v1-44 (or (= v1-44 (-> self draw art-group data 13)) (= v1-44 (-> self draw art-group data 14)))))
                    )
                  )
             (ja-channel-push! 1 (seconds 0.2))
             (ja :group! (-> self draw art-group data 13) :num! min)
             (metalkor-spinners-off)
             )
            (else
              (let ((v1-55 (ja-group)))
                (cond
                  ((and v1-55 (= v1-55 (-> self draw art-group data 10)))
                   (ja :num! (seek!))
                   (metalkor-spinner-check 0 10.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 1 11.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 3 12.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 2 13.0 (-> gp-0 vector 2))
                   (if (and (>= 20.0 f28-0) (< 20.0 (ja-aframe-num 0)))
                       (metalkor-lowtorso-spinners-off)
                       )
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 2) 30.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 3) 31.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 1) 32.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 0) 33.0 f28-0)
                   (set! f30-0 (/ 12288.0 (the float (ja-num-frames 0))))
                   (cond
                     ((not (ja-done? 0))
                      )
                     ((< 8738.134 f26-0)
                      (ja :group! (-> self draw art-group data 11) :num! min)
                      )
                     (else
                       (ja :group! (-> self draw art-group data 12) :num! min)
                       )
                     )
                   )
                  ((let ((v1-87 (ja-group)))
                     (and v1-87 (= v1-87 (-> self draw art-group data 11)))
                     )
                   (if (< 8738.134 f26-0)
                       (ja :num! (loop!))
                       (ja :num! (seek!))
                       )
                   (if (and (>= 40.0 f28-0) (< 40.0 (ja-aframe-num 0)))
                       (metalkor-spinners-off)
                       )
                   (metalkor-spinner-check 0 50.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 1 51.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 3 52.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 2 53.0 (-> gp-0 vector 2))
                   (if (and (>= 60.0 f28-0) (< 60.0 (ja-aframe-num 0)))
                       (metalkor-lowtorso-spinners-off)
                       )
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 2) 70.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 3) 71.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 1) 72.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 0) 73.0 f28-0)
                   (set! f30-0 (/ 16384.0 (the float (ja-num-frames 0))))
                   (if (ja-done? 0)
                       (ja :group! (-> self draw art-group data 12) :num! min)
                       )
                   )
                  ((let ((v1-124 (ja-group)))
                     (and v1-124 (= v1-124 (-> self draw art-group data 12)))
                     )
                   (ja :num! (seek!))
                   (if (and (>= 80.0 f28-0) (< 80.0 (ja-aframe-num 0)))
                       (metalkor-spinners-off)
                       )
                   (metalkor-spinner-check 0 90.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 1 91.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 3 92.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 2 93.0 (-> gp-0 vector 2))
                   (if (< (ja-aframe-num 0) 100.0)
                       (set! f30-0 (/ 4096.0 (the float (/ (ja-num-frames 0) 2))))
                       )
                   (if (ja-done? 0)
                       (ja :group! (-> self draw art-group data 9) :num! min)
                       )
                   )
                  ((let ((v1-154 (ja-group)))
                     (and v1-154 (= v1-154 (-> self draw art-group data 13)))
                     )
                   (ja :num! (seek!))
                   (metalkor-spinner-check 2 10.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 3 11.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 1 12.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 0 13.0 (-> gp-0 vector 2))
                   (if (and (>= 20.0 f28-0) (< 20.0 (ja-aframe-num 0)))
                       (metalkor-lowtorso-spinners-off)
                       )
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 0) 30.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 1) 31.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 3) 32.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 2) 33.0 f28-0)
                   (set! f30-0 (/ -12288.0 (the float (ja-num-frames 0))))
                   (cond
                     ((not (ja-done? 0))
                      )
                     ((< f26-0 -8738.134)
                      (ja :group! (-> self draw art-group data 14) :num! min)
                      )
                     (else
                       (ja :group! (-> self draw art-group data 15) :num! min)
                       )
                     )
                   )
                  ((let ((v1-186 (ja-group)))
                     (and v1-186 (= v1-186 (-> self draw art-group data 14)))
                     )
                   (if (< f26-0 -8738.134)
                       (ja :num! (loop!))
                       (ja :num! (seek!))
                       )
                   (if (and (>= 40.0 f28-0) (< 40.0 (ja-aframe-num 0)))
                       (metalkor-spinners-off)
                       )
                   (metalkor-spinner-check 2 50.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 3 51.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 1 52.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 0 53.0 (-> gp-0 vector 2))
                   (if (and (>= 60.0 f28-0) (< 60.0 (ja-aframe-num 0)))
                       (metalkor-lowtorso-spinners-off)
                       )
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 0) 70.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 1) 71.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 3) 72.0 f28-0)
                   (metalkor-lowtorso-spinner-check (the-as metalkor-lowtorso 2) 73.0 f28-0)
                   (set! f30-0 (/ -16384.0 (the float (ja-num-frames 0))))
                   (if (ja-done? 0)
                       (ja :group! (-> self draw art-group data 15) :num! min)
                       )
                   )
                  ((let ((v1-223 (ja-group)))
                     (and v1-223 (= v1-223 (-> self draw art-group data 15)))
                     )
                   (ja :num! (seek!))
                   (if (and (>= 80.0 f28-0) (< 80.0 (ja-aframe-num 0)))
                       (metalkor-spinners-off)
                       )
                   (metalkor-spinner-check 2 90.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 3 91.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 1 92.0 (-> gp-0 vector 2))
                   (metalkor-spinner-check 0 93.0 (-> gp-0 vector 2))
                   (if (< (ja-aframe-num 0) 80.0)
                       (set! f30-0 (/ -4096.0 (the float (/ (ja-num-frames 0) 2))))
                       )
                   (if (ja-done? 0)
                       (ja :group! (-> self draw art-group data 9) :num! min)
                       )
                   )
                  (else
                    (let ((v1-253 (ja-group)))
                      (cond
                        ((and v1-253 (= v1-253 (-> self draw art-group data 9)))
                         (ja :num! (loop!))
                         )
                        (else
                          (ja-channel-push! 1 (seconds 0.2))
                          (ja :group! (-> self draw art-group data 9) :num! min)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (when (!= f30-0 0.0)
        (matrix-axis-angle! s5-0 (-> gp-0 vector 1) (* 0.5 (-> self clock time-adjust-ratio) f30-0))
        (matrix*! gp-0 gp-0 s5-0)
        (matrix-remove-z-rot gp-0 (new 'static 'vector :y -1.0))
        (matrix->quaternion (-> self root-override quat) gp-0)
        (quaternion-normalize! (-> self root-override quat))
        )
      )
    )
  (dotimes (gp-1 (ja-group-size))
    (if (nonzero? gp-1)
        (ja :chan gp-1 :num! (loop!))
        )
    )
  (none)
  )

(defstate beaten (metalkor)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('occlude-off)
                      (let ((a0-3 (handle->process (-> self rift-occlude))))
                        (if a0-3
                            (the-as symbol (deactivate a0-3))
                            )
                        )
                      )
                     )
            )
    )
  :enter (behavior ((arg0 symbol))
    (ja-channel-set! 0)
    (ja-post)
    (send-event (handle->process (-> self hud)) 'hide-and-die)
    (set! (-> self hud) (the-as handle #f))
    (remove-setting! 'point-of-interest)
    (remove-setting! 'fov)
    (when arg0
      (remove-setting! 'music)
      (send-event (handle->process (-> self rift-occlude)) 'movie-pos)
      (outro-play)
      )
    (none)
    )
  :exit (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data 3) :num! min)
    (none)
    )
  :code (the-as (function symbol none :behavior metalkor) sleep-code)
  )

(defstate explode (metalkor)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('exploding)
                      (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
                        (set! (-> gp-0 from) (process->ppointer self))
                        (set! (-> gp-0 num-params) 1)
                        (set! (-> gp-0 message) 'stutter)
                        (set! (-> gp-0 param 0) (the-as uint #f))
                        (let ((s5-0 send-event-function)
                              (v1-4 (metalkor-get-ring self))
                              )
                          (s5-0
                            (if v1-4
                                (-> v1-4 extra process)
                                )
                            gp-0
                            )
                          )
                        )
                      )
                     (('explode-done)
                      (the-as object (metalkor-go-next-stage))
                      )
                     )
            )
    )
  :enter (behavior ()
    (process-grab? *target* #f)
    (set-setting! 'entity-name "camera-271" 0.0 0)
    (send-event *camera* 'change-target self)
    (none)
    )
  :exit (behavior ()
    (process-release? *target*)
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer self))
      (set! (-> gp-0 num-params) 1)
      (set! (-> gp-0 message) 'stutter)
      (set! (-> gp-0 param 0) (the-as uint #f))
      (let ((s5-0 send-event-function)
            (v1-3 (metalkor-get-ring self))
            )
        (s5-0
          (if v1-3
              (-> v1-3 extra process)
              )
          gp-0
          )
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data 3) :num! min)
    (let ((a0-7 (handle->process (-> self explode))))
      (if a0-7
          (deactivate a0-7)
          )
      )
    (remove-setting! 'entity-name)
    (send-event *camera* 'change-target #f)
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> self explode)))
      (let ((v1-4 (the-as entity-actor (metalkor-get-ring self))))
        (when v1-4
          (let ((s5-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> v1-4 quat)))
                (gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
                )
            (let ((s4-0 (new 'stack-no-clear 'matrix)))
              (vector-negate! (-> s5-0 vector 2) (-> s5-0 vector 2))
              (matrix-from-two-vectors-max-angle-partial! s4-0 (-> gp-0 vector 2) (-> s5-0 vector 2) 273.06668 0.75)
              (matrix*! gp-0 gp-0 s4-0)
              )
            (matrix-remove-z-rot gp-0 (new 'static 'vector :y -1.0))
            (matrix->quaternion (-> self root-override quat) gp-0)
            (quaternion-normalize! (-> self root-override quat))
            (let ((f0-1 (vector-dot (-> gp-0 vector 1) (new 'static 'vector :y 1.0))))
              (let* ((f1-0 1.0)
                     (f2-0 f0-1)
                     (f1-2 (sqrtf (- f1-0 (* f2-0 f2-0))))
                     )
                (vector+float*!
                  (-> self root-override trans)
                  (-> self hit-ring-trans)
                  (-> self hit-ring-offset)
                  (* 73728.0 f1-2)
                  )
                )
              (+! (-> self root-override trans y) (* 73728.0 (- 1.0 f0-1)))
              )
            )
          )
        )
      (let ((v1-21 (ja-group)))
        (cond
          ((and v1-21 (= v1-21 (-> self draw art-group data 47)))
           (let ((f30-0 (ja-aframe-num 0)))
             (ja :num! (seek!))
             (if (and (< f30-0 16.0) (>= (ja-aframe-num 0) 16.0))
                 (set-action!
                   *gui-control*
                   (gui-action play)
                   (-> self explode-sound)
                   (gui-channel none)
                   (gui-action none)
                   (the-as string #f)
                   (the-as (function gui-connection symbol) #f)
                   (the-as process #f)
                   )
                 )
             )
           (when (ja-done? 0)
             (ja-channel-set! 0)
             (set! (-> self explode) (ppointer->handle (process-spawn
                                                         metalkor-explode
                                                         (-> self root-override trans)
                                                         (-> self root-override quat)
                                                         (process->handle (-> (metalkor-get-ring self) extra process))
                                                         :to self
                                                         )
                                                       )
                   )
             )
           )
          (else
            (ja :group! (-> self draw art-group data 47) :num! min)
            (let ((gp-3 (new 'stack-no-clear 'event-message-block)))
              (set! (-> gp-3 from) (process->ppointer self))
              (set! (-> gp-3 num-params) 1)
              (set! (-> gp-3 message) 'stutter)
              (set! (-> gp-3 param 0) (the-as uint #t))
              (let ((s5-2 send-event-function)
                    (v1-61 (metalkor-get-ring self))
                    )
                (s5-2
                  (if v1-61
                      (-> v1-61 extra process)
                      )
                  gp-3
                  )
                )
              )
            (process-spawn metalkor-distort (-> self root-override trans) (-> self root-override quat) :to self)
            )
          )
        )
      )
    (update! (-> self ring-cam-pos) 0.0)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate fly-to-ring (metalkor)
  :virtual #t
  :enter (behavior ()
    (process-grab? *target* #f)
    (set! (-> self been-to-entity) #f)
    (sound-play "nboss-hover" :id (-> self wing-sound) :position (-> self root-override trans))
    (set! (-> self wing-sound-playing) #t)
    (init (-> self flying-speed) 0.0 0.01 0.1 0.9)
    (set! (-> self flying-speed target) 1.0)
    (let ((a0-6 (metalkor-get-ring self)))
      (cond
        (a0-6
          (set! (-> self hit-ring-trans quad) (-> a0-6 trans quad))
          (set! (-> self hit-ring-trans y) (+ -110592.0 (-> self hit-ring-trans y)))
          (vector-! (-> self hit-ring-offset) (-> self hit-ring-trans) (-> self entity trans))
          (set! (-> self hit-ring-offset y) 0.0)
          (vector-normalize! (-> self hit-ring-offset) 1.0)
          (vector+float*! (-> self hit-ring-trans) (-> self hit-ring-trans) (-> self hit-ring-offset) -16384.0)
          )
        (else
          (set! (-> self hit-ring-trans quad) (-> self entity trans quad))
          (set-vector! (-> self hit-ring-offset) 1.0 0.0 0.0 1.0)
          )
        )
      )
    (set-setting! 'entity-name "camera-272" 0.0 0)
    (send-event *camera* 'change-target self)
    (set! (-> self need-teleport) #f)
    (set-setting! 'teleport-on-entity-change 'abs #t 0)
    (if (nonzero? (-> self neck))
        (set! (-> self neck flex-blend) 1.0)
        )
    (set! (-> self explode-sound)
          (add-process *gui-control* self (gui-channel jak) (gui-action queue) "nbexplo" -99.0 0)
          )
    (none)
    )
  :exit (behavior ()
    (process-release? *target*)
    (when (-> self wing-sound-playing)
      (sound-stop (-> self wing-sound))
      (set! (-> self wing-sound-playing) #f)
      )
    (vector+float*! (-> self hit-ring-trans) (-> self hit-ring-trans) (-> self hit-ring-offset) 32768.0)
    (set! (-> self root-override trans quad) (-> self hit-ring-trans quad))
    (remove-setting! 'entity-name)
    (send-event *camera* 'change-target #f)
    (remove-setting! 'teleport-on-entity-change)
    (if (nonzero? (-> self neck))
        (set! (-> self neck flex-blend) 0.0)
        )
    (none)
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 46)))
         (ja :num! (loop!))
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! (-> self draw art-group data 46) :num! min)
          )
        )
      )
    (update! (-> self flying-speed) 0.0)
    (metalkor-face-to-vector (-> self hit-ring-trans) 728.1778 0.005)
    (cond
      ((-> self been-to-entity)
       (vector-seek-3d-smooth!
         (-> self root-override trans)
         (-> self hit-ring-trans)
         (* 3072.0 (-> self flying-speed value))
         0.5
         )
       (let ((f0-4 (vector-vector-distance-squared (-> self root-override trans) (-> self hit-ring-trans)))
             (f1-1 4096.0)
             )
         (cond
           ((< f0-4 (* f1-1 f1-1))
            (go-virtual explode)
            )
           ((let ((f1-4 40960.0))
              (< f0-4 (* f1-4 f1-4))
              )
            (set! (-> self ring-cam-pos target) 1.0)
            )
           )
         )
       )
      (else
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (set! (-> gp-1 quad) (-> self entity trans quad))
          (set! (-> gp-1 y) (+ -61440.0 (-> gp-1 y)))
          (vector-seek-3d-smooth! (-> self root-override trans) gp-1 (* 3072.0 (-> self flying-speed value)) 0.5)
          (let ((f0-10 (vector-vector-distance-squared (-> self root-override trans) gp-1))
                (f1-9 12288.0)
                )
            (when (< f0-10 (* f1-9 f1-9))
              (set! (-> self been-to-entity) #t)
              (set-setting! 'entity-name "camera-271" 0.0 0)
              )
            )
          )
        )
      )
    (when (nonzero? (-> self neck))
      (let ((v1-46 (metalkor-get-ring self)))
        (if v1-46
            (target-set! (-> self neck) (-> v1-46 trans))
            )
        )
      )
    (update! (-> self ring-cam-pos) 0.0)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate last-gasp (metalkor)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'music #f 0.0 0)
    (process-grab? *target* #f)
    (set-setting! 'entity-name "camera-272" 0.0 0)
    (remove-setting! 'point-of-interest)
    (send-event *camera* 'change-target self)
    (if (nonzero? (-> self neck))
        (set! (-> self neck flex-blend) 0.0)
        )
    (none)
    )
  :exit (behavior ()
    (process-release? *target*)
    (remove-setting! 'entity-name)
    (send-event *camera* 'change-target #f)
    (none)
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 7)))
         (ja :num! (seek! max 0.5))
         (when (ja-done? 0)
           (ja-channel-push! 1 (seconds 0.1))
           (ja :group! (-> self draw art-group data 45) :num! min)
           )
         )
        ((let ((v1-21 (ja-group)))
           (and v1-21 (= v1-21 (-> self draw art-group data 45)))
           )
         (ja :num! (seek!))
         (if (and (< 218.0 (ja-aframe-num 0)) (nonzero? (-> self neck)))
             (set! (-> self neck flex-blend) 1.0)
             )
         (if (ja-done? 0)
             (go-virtual fly-to-ring)
             )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (ja :group! (-> self draw art-group data 7) :num! min)
          )
        )
      )
    (when (nonzero? (-> self neck))
      (let ((v1-50 (metalkor-get-ring self)))
        (if v1-50
            (target-set! (-> self neck) (-> v1-50 trans))
            )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate overload-recover (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data 30) :num! min)
    (none)
    )
  :exit (behavior ()
    (if (nonzero? (-> self neck))
        (set! (-> self neck flex-blend) 1.0)
        )
    (none)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (if (ja-done? 0)
        (go-virtual get-close)
        )
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior set-color-vectors metalkor ((arg0 float))
  (vector-lerp!
    (-> self draw color-mult)
    (new 'static 'vector :x 1.0 :y 1.0 :z 1.0)
    (new 'static 'vector)
    (fmin 1.0 arg0)
    )
  (set! (-> self draw color-mult w) 1.0)
  (vector-lerp!
    (-> self draw color-emissive)
    (new 'static 'vector)
    (new 'static 'vector :x 1.0 :y 1.0 :z 1.0)
    arg0
    )
  (send-event (handle->process (-> self legs)) 'color (-> self draw color-mult) (-> self draw color-emissive))
  (send-event
    (handle->process (-> self lowtorso))
    'color
    (-> self draw color-mult)
    (-> self draw color-emissive)
    )
  (none)
  )

(defstate fall-down (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self min-state-hit-points) (+ -0.34 (-> self stage-hit-points)))
    (if (nonzero? (-> self neck))
        (set! (-> self neck flex-blend) 0.0)
        )
    (set! (-> self bomb-sound)
          (add-process *gui-control* self (gui-channel jak) (gui-action queue) "nbshock" -99.0 0)
          )
    (set! (-> self stop-bomb-sound) #t)
    (none)
    )
  :exit (behavior ()
    (if (-> self stop-bomb-sound)
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self bomb-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
    (none)
    )
  :trans (behavior ()
    (if (or (>= (- (current-time) (-> self state-time)) (seconds 1))
            (>= (-> self min-state-hit-points) (-> self stage-hit-points))
            )
        (go-virtual overload-recover)
        )
    (let ((v1-10 (ja-group)))
      (cond
        ((and v1-10 (or (= v1-10 (-> self draw art-group data 7)) (= v1-10 (-> self draw art-group data 25))))
         (let ((f30-0 (ja-aframe-num 0)))
           (let ((a0-10 (-> self skel root-channel 0)))
             (set! (-> a0-10 param 0) (the float (+ (-> a0-10 frame-group frames num-frames) -1)))
             (let ((v1-21 (ja-group)))
               (set! (-> a0-10 param 1) (if (and v1-21 (= v1-21 (-> self draw art-group data 7)))
                                            0.5
                                            1.0
                                            )
                     )
               )
             (joint-control-channel-group-eval! a0-10 (the-as art-joint-anim #f) num-func-seek!)
             )
           (when (and (< f30-0 6.0) (>= (ja-aframe-num 0) 6.0))
             (process-spawn metalkor-bomb (-> self root-override trans) (-> self entity) :to self :stack-size #x6000)
             (set-action!
               *gui-control*
               (gui-action play)
               (-> self bomb-sound)
               (gui-channel none)
               (gui-action none)
               (the-as string #f)
               (the-as (function gui-connection symbol) #f)
               (the-as process #f)
               )
             (set! (-> self stop-bomb-sound) #f)
             )
           )
         (if (ja-done? 0)
             (ja :group! (-> self draw art-group data 8) :num! min)
             )
         )
        (else
          (let ((v1-49 (ja-group)))
            (cond
              ((and v1-49 (= v1-49 (-> self draw art-group data 8)))
               (ja :num! (loop!))
               )
              (else
                (ja-channel-push! 1 (seconds 0.2))
                (ja :group! (-> self draw art-group data 7) :num! min)
                )
              )
            )
          )
        )
      )
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate play-drop-movie (metalkor)
  :virtual #t
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (process-spawn scene-player :init scene-player-init "nest-kor-boss-fight-mid" #t "nestb-boss")
    (none)
    )
  :trans (behavior ()
    (if (>= (- (current-time) (-> self state-time)) (seconds 0.5))
        (deactivate self)
        )
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
;; WARN: Function metalkor-walk-the-walk has a return type of none, but the expression builder found a return statement.
(defbehavior metalkor-walk-the-walk metalkor ((arg0 float) (arg1 symbol))
  (local-vars (v1-32 float) (v1-38 float) (v1-80 float) (sv-864 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-2 (ja-group)))
      (if (and (and v1-2 (= v1-2 (-> self draw art-group data 33))) (begin (ja :num! (seek!)) (not (ja-done? 0))))
          (return #f)
          )
      )
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> self root-override trans quad))
      (set! sv-864 (target-pos 0))
      (metalkor-face-to-vector sv-864 546.13336 0.005)
      (when (and (nonzero? (-> self previous-flat-travel-long-timer))
                 (>= (+ (current-time) (seconds -1.2)) (-> self previous-flat-travel-long-timer))
                 )
        (set! (-> self previous-flat-travel-long-timer) 0)
        (set! (-> self previous-flat-travel-timer) 0)
        0
        )
      (let ((s2-0 (new 'stack-no-clear 'clamp-travel-vector-to-mesh-return-info))
            (s4-0 (new 'stack-no-clear 'vector))
            )
        (let ((s3-0 (new 'stack-no-clear 'vector)))
          (let ((f30-0 (* 4096.0 (* 0.25 (-> self clock time-adjust-ratio))))
                (s1-0 #f)
                )
            (set! (-> s3-0 quad) (-> self root-override trans quad))
            (vector-! s4-0 s3-0 sv-864)
            (set! (-> s4-0 y) 0.0)
            (let* ((f0-5 arg0)
                   (f0-7 (* f0-5 f0-5))
                   )
              (.lvf vf1 (&-> s4-0 quad))
              (.add.w.vf vf2 vf0 vf0 :mask #b1)
              (.mul.vf vf1 vf1 vf1)
              (.mul.x.vf acc vf2 vf1 :mask #b1)
              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
              (.mov v1-32 vf1)
              (if (< f0-7 v1-32)
                  (set! s1-0 #t)
                  )
              )
            (vector-normalize! s4-0 arg0)
            (let ((v1-35 s4-0))
              (let ((a0-15 s4-0))
                (.mov.vf vf6 vf0 :mask #b1000)
                (.lvf vf4 (&-> a0-15 quad))
                )
              (.lvf vf5 (&-> sv-864 quad))
              (.add.vf vf6 vf4 vf5 :mask #b111)
              (.svf (&-> v1-35 quad) vf6)
              )
            (vector-! s4-0 s4-0 s3-0)
            (set! (-> s4-0 y) 0.0)
            (.lvf vf1 (&-> s4-0 quad))
            (.add.w.vf vf2 vf0 vf0 :mask #b1)
            (.mul.vf vf1 vf1 vf1)
            (.mul.x.vf acc vf2 vf1 :mask #b1)
            (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
            (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
            (.mov v1-38 vf1)
            (let ((f0-9 v1-38)
                  (f1-3 f30-0)
                  )
              (if (< (* f1-3 f1-3) f0-9)
                  (vector-float*! s4-0 s4-0 (/ f30-0 (sqrtf f0-9)))
                  )
              )
            (set! (-> s2-0 poly) (-> self current-nav-poly))
            (dotimes (s0-1 5)
              (let ((f30-1 (vector-length s4-0)))
                (clamp-vector-to-mesh-no-gaps (-> self nav state mesh) s3-0 (-> s2-0 poly) s4-0 s2-0)
                (cond
                  ((-> s2-0 found-boundary)
                   (set-normals-from-adjacent-bounds (-> self nav state mesh) s2-0)
                   (let ((f28-0 (vector-length s4-0)))
                     (vector-flatten! s4-0 s4-0 (-> s2-0 boundary-normal))
                     (let ((f0-12 (- f30-1 f28-0)))
                       (vector-normalize! s4-0 f0-12)
                       )
                     )
                   (if (and (< (+ (current-time) (seconds -0.1)) (-> self previous-flat-travel-timer))
                            (< (vector-dot s4-0 (-> self previous-flat-travel)) 0.0)
                            )
                       (vector-negate! s4-0 s4-0)
                       )
                   (set! (-> s3-0 x) (-> s2-0 intersection x))
                   (set! (-> s3-0 z) (-> s2-0 intersection z))
                   (vector-! s3-0 s3-0 (-> s2-0 boundary-normal))
                   (when (or s1-0 (> s0-1 0) (< (+ (current-time) (seconds -0.1)) (-> self previous-flat-travel-timer)))
                     (set! (-> self previous-flat-travel quad) (-> s4-0 quad))
                     (set! (-> self previous-flat-travel-timer) (current-time))
                     (if (zero? (-> self previous-flat-travel-long-timer))
                         (set! (-> self previous-flat-travel-long-timer) (current-time))
                         )
                     )
                   )
                  (else
                    (goto cfg-43)
                    )
                  )
                )
              )
            )
          (label cfg-43)
          (vector+! s4-0 s3-0 s4-0)
          )
        (vector-! s4-0 s4-0 (-> self root-override trans))
        (.lvf vf1 (&-> s4-0 quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov v1-80 vf1)
        (let ((f0-17 v1-80)
              (f1-7 40.96)
              )
          (if (< f0-17 (* f1-7 f1-7))
              (vector-reset! s4-0)
              )
          )
        (vector+! (-> self root-override trans) (-> self root-override trans) s4-0)
        )
      (set! (-> self current-nav-poly) (cloest-point-on-mesh
                                         (-> self nav)
                                         (-> self root-override trans)
                                         (-> self root-override trans)
                                         (-> self current-nav-poly)
                                         )
            )
      (let ((s4-1 (new 'stack 'collide-query)))
        (if (above-ground?
              (-> self root-override)
              s4-1
              (-> self root-override trans)
              (collide-spec backgnd)
              12288.0
              122880.0
              1024.0
              )
            (set! (-> self root-override trans y) (-> s4-1 best-other-tri intersect y))
            )
        )
      (update-walk-anim s5-0 arg1)
      (let ((v1-98 (vector-! (new 'stack-no-clear 'vector) (-> self root-override trans) s5-0)))
        (vector-float*! v1-98 v1-98 0.5)
        (set! (-> v1-98 y) 0.0)
        (send-event (handle->process (-> self lowtorso)) 'move-chain v1-98)
        )
      )
    (none)
    )
  )

(defstate tail-attack (metalkor)
  :virtual #t
  :event metalkor-handler
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 31)))
         (ja :num! (seek!))
         (if (ja-done? 0)
             (go-virtual chase-target)
             )
         )
        (else
          (ja-channel-push! 1 (seconds 0.2))
          (ja :group! (-> self draw art-group data 31) :num! min)
          )
        )
      )
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defbehavior metalkor-set-deadly metalkor ((arg0 metalkor) (arg1 symbol) (arg2 int))
  (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root-override root-prim)) child arg2)))
    (cond
      (arg1
        (set! (-> v1-3 prim-core collide-as) (collide-spec enemy))
        (set! (-> v1-3 prim-core collide-with) (collide-spec jak bot player-list))
        )
      (else
        (set! (-> v1-3 prim-core collide-as) (collide-spec))
        (set! (-> v1-3 prim-core collide-with) (collide-spec))
        0
        )
      )
    )
  (none)
  )

(defstate foot-attack (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (let ((s5-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
          (gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root-override trans) (-> self entity trans)))
          )
      (vector-flatten! gp-1 gp-1 (-> s5-0 vector 1))
      (cond
        ((< (vector-dot gp-1 (the-as vector (-> s5-0 vector))) 0.0)
         (metalkor-ja-float (the-as art-joint-anim (-> self draw art-group data 43)) 1.0 1.0 4.0)
         (metalkor-set-deadly self #t 2)
         )
        (else
          (metalkor-ja-float (the-as art-joint-anim (-> self draw art-group data 42)) 1.0 1.0 4.0)
          (metalkor-set-deadly self #t 3)
          )
        )
      )
    (set! (-> self arm-frame) -1000.0)
    (none)
    )
  :exit (behavior ()
    (metalkor-set-deadly self #f 2)
    (metalkor-set-deadly self #f 3)
    (none)
    )
  :trans (behavior ()
    (local-vars (a0-10 int))
    -1
    (let ((a0-1 (metalkor-ja-float-group? (the-as art-joint-anim (-> self draw art-group data 42)))))
      (cond
        ((>= a0-1 0)
         (let ((f30-0 (ja-aframe-num a0-1)))
           (if (< f30-0 10.0)
               (metalkor-walk-the-walk 36864.0 #t)
               )
           (cond
             ((and (< (-> self arm-frame) 12.9) (>= f30-0 12.9))
              (sound-play "nboss-arm")
              )
             ((and (< (-> self arm-frame) 15.9) (>= f30-0 15.9))
              (sound-play "nboss-growl")
              )
             )
           (set! (-> self arm-frame) f30-0)
           )
         )
        ((begin
           (set! a0-10 (metalkor-ja-float-group? (the-as art-joint-anim (-> self draw art-group data 43))))
           (>= a0-10 0)
           )
         (let ((f30-1 (ja-aframe-num a0-10)))
           (if (< f30-1 52.0)
               (metalkor-walk-the-walk 36864.0 #t)
               )
           (cond
             ((and (< (-> self arm-frame) 54.4) (>= f30-1 54.4))
              (sound-play "nboss-arm")
              )
             ((and (< (-> self arm-frame) 56.9) (>= f30-1 56.9))
              (sound-play "nboss-growl")
              )
             )
           (set! (-> self arm-frame) f30-1)
           )
         )
        (else
          (go-virtual chase-target)
          )
        )
      )
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate get-close (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (cond
      ((>= (- (current-time) (-> self state-time)) (seconds 4))
       (go-virtual chase-target)
       )
      ((let ((f0-0 57344.0))
         (< (* f0-0 f0-0) (vector-vector-xz-distance-squared (-> self root-override trans) (target-pos 0)))
         )
       )
      ((or (< (-> self last-close-attack) -1)
           (and (< (-> self last-close-attack) 2)
                (let* ((v1-14 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                       (v1-15 (the-as number (logior #x3f800000 v1-14)))
                       )
                  (< (+ -1.0 (the-as float v1-15)) 0.5)
                  )
                )
           )
       (set! (-> self last-close-attack) (max 1 (+ (-> self last-close-attack) 1)))
       (go-virtual foot-attack)
       )
      (else
        (set! (-> self last-close-attack) (min -1 (+ (-> self last-close-attack) -1)))
        (go-virtual tail-attack)
        )
      )
    (metalkor-walk-the-walk 53248.0 #f)
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate standing-shot (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self shots-fired) 0)
    (set! (-> self current-nav-poly) (cloest-point-on-mesh
                                       (-> self nav)
                                       (-> self root-override trans)
                                       (-> self root-override trans)
                                       (-> self current-nav-poly)
                                       )
          )
    (none)
    )
  :exit (behavior ()
    (metalkor-ja-float-stop (the-as art-joint-anim (-> self draw art-group data 32)))
    (none)
    )
  :trans (behavior ()
    (if (>= (-> self shots-fired) (-> self stage))
        (go-virtual chase-target)
        )
    (metalkor-walk-the-walk 122880.0 #f)
    (spawn (-> self shot-anticipate) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 7)))
    (let* ((a0-4 (-> self draw art-group data 32))
           (f0-2
             (/ (the float (-> (the-as art-joint-anim a0-4) frames num-frames)) (-> (the-as art-joint-anim a0-4) speed))
             )
           (f1-1 45.0)
           )
      (if (zero? (-> self shots-fired))
          (set! f1-1 75.0)
          )
      (if (metalkor-ja-float (the-as art-joint-anim a0-4) (/ f0-2 f1-1) 1.0 f0-2)
          (sound-play "nboss-pre-shot")
          )
      )
    (when (or (>= (- (current-time) (-> self state-time)) (seconds 1.25))
              (and (>= (- (current-time) (-> self state-time)) (seconds 0.75)) (nonzero? (-> self shots-fired)))
              )
      (set! (-> self state-time) (current-time))
      (metalkor-shoot-projectile)
      (set-nestb-purple! (fmax 1.0 (get-nestb-purple)))
      (metalkor-ja-float-stop (the-as art-joint-anim (-> self draw art-group data 32)))
      (ja-channel-push! 1 (seconds 0.05))
      (ja :group! (-> self draw art-group data 33) :num! min)
      )
    (if (zero? (-> self shots-fired))
        (set-nestb-purple!
          (fmax (get-nestb-purple) (* 0.0013333333 (the float (- (current-time) (-> self state-time)))))
          )
        (set-nestb-purple!
          (fmax (get-nestb-purple) (* 0.0022222223 (the float (- (current-time) (-> self state-time)))))
          )
        )
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate chase-target (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self current-nav-poly) (cloest-point-on-mesh
                                       (-> self nav)
                                       (-> self root-override trans)
                                       (-> self root-override trans)
                                       (-> self current-nav-poly)
                                       )
          )
    (none)
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (when (and (not (and v1-2 (= v1-2 (-> self draw art-group data 33))))
                 (>= (- (current-time) (-> self state-time)) (seconds 3))
                 )
        (cond
          ((or (< (-> self last-standing-attack) -1)
               (and (< (-> self last-standing-attack) 2)
                    (let* ((v1-14 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                           (v1-15 (the-as number (logior #x3f800000 v1-14)))
                           )
                      (< (+ -1.0 (the-as float v1-15)) 0.5)
                      )
                    )
               )
           (set! (-> self last-standing-attack) (max 1 (+ (-> self last-standing-attack) 1)))
           (go-virtual get-close)
           )
          (else
            (set! (-> self last-standing-attack) (min -1 (+ (-> self last-standing-attack) -1)))
            (go-virtual standing-shot)
            )
          )
        )
      )
    (metalkor-walk-the-walk 122880.0 #f)
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate start-second-stage (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data 44) :num! min)
    (metalkor-spinners-off)
    (dotimes (gp-1 4)
      (let ((a0-3 (handle->process (-> self lowtorso))))
        (if a0-3
            (send-event a0-3 'spinner gp-1)
            )
        )
      )
    (none)
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 21)))
         (ja :num! (seek!))
         (if (ja-done? 0)
             (go-virtual hang-shoot-n-launch)
             )
         )
        ((let ((v1-17 (ja-group)))
           (and v1-17 (= v1-17 (-> self draw art-group data 44)))
           )
         (let ((f30-0 (ja-aframe-num 0)))
           (ja :num! (seek!))
           (cond
             ((and (< f30-0 84.0) (>= (ja-aframe-num 0) 84.0))
              (let ((gp-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat))))
                (metalkor-start-spinner 1 (-> gp-0 vector 2))
                (metalkor-start-spinner 3 (-> gp-0 vector 2))
                )
              )
             ((and (< f30-0 85.0) (>= (ja-aframe-num 0) 85.0))
              (let ((gp-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat))))
                (metalkor-start-spinner 0 (-> gp-1 vector 2))
                (metalkor-start-spinner 2 (-> gp-1 vector 2))
                )
              )
             )
           )
         (when (ja-done? 0)
           (ja-channel-push! 1 (seconds 0.2))
           (ja :group! (-> self draw art-group data 21) :num! min)
           )
         )
        (else
          (ja :group! (-> self draw art-group data 44) :num! min)
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate hang-shoot-n-launch (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self shoot-timer) (current-time))
    (set! (-> self shots-fired) 0)
    (set! (-> self wave-timer) 0)
    (set! (-> self in-wave) #f)
    (set! (-> self flitter-timer) 0)
    (set! (-> self wasp-timer) 0)
    (set! (-> self launching-flitters) #f)
    (set! (-> self launching-wasps) #f)
    (set! (-> self egg-timer) 0)
    0
    (none)
    )
  :exit (behavior ()
    (send-event (handle->process (-> self lowtorso)) 'egg-toss 0)
    (metalkor-ja-float-stop (the-as art-joint-anim (-> self draw art-group data 23)))
    (none)
    )
  :trans (behavior ()
    (local-vars (sv-16 res-tag))
    (let ((v1-0 7500))
      (if (and (-> self in-wave) (= (-> self stage) 1))
          (set! v1-0 3000)
          )
      (when (>= (- (current-time) (-> self wave-timer)) v1-0)
        (set! (-> self in-wave) (not (-> self in-wave)))
        (set! (-> self wave-timer) (current-time))
        )
      )
    (cond
      ((or (!= (-> self stage) 2) (not (-> self in-wave)) (>= (-> self live-wasps) 3))
       (set! (-> self launching-wasps) #f)
       )
      ((< (-> self live-wasps) 2)
       (set! (-> self launching-wasps) #t)
       )
      )
    (when (and (-> self launching-wasps) (>= (- (current-time) (-> self wasp-timer)) (seconds 1.5)))
      (set! (-> self wasp-timer) (current-time))
      (dotimes (gp-0 3)
        (when (not (handle->process (-> self wasps gp-0)))
          (set! sv-16 (new 'static 'res-tag))
          (let ((v1-31 (res-lump-data (-> self entity) 'actor-groups (pointer actor-group) :tag-ptr (& sv-16))))
            (when (and v1-31 (< (the-as uint 1) (-> sv-16 elt-count)))
              (let ((v1-32 (-> v1-31 1)))
                (+! (-> self last-wasp-launched) 1)
                (when (>= (-> self last-wasp-launched) (-> v1-32 length))
                  (set! (-> self last-wasp-launched) 0)
                  0
                  )
                (when (< (-> self last-wasp-launched) (-> v1-32 length))
                  (let ((s4-0 (-> v1-32 data (-> self last-wasp-launched) actor))
                        (s5-0 (new 'stack-no-clear 'enemy-init-by-other-params))
                        )
                    (when (not (-> s4-0 extra process))
                      (let ((s3-0 (-> s4-0 extra)))
                        (if (send-event (handle->process (-> self wasp-gem-tracker)) 'spawn-with-gem?)
                            (logclear! (-> s3-0 perm status) (entity-perm-status save))
                            (logior! (-> s3-0 perm status) (entity-perm-status save))
                            )
                        )
                      (set! (-> s5-0 trans quad) (-> s4-0 trans quad))
                      (quaternion-copy! (-> s5-0 quat) (-> self root-override quat))
                      (set! (-> s5-0 entity) s4-0)
                      (set! (-> s5-0 directed?) #f)
                      (set! (-> s5-0 no-initial-move-to-ground?) #f)
                      (let ((s4-1 (get-process *default-dead-pool* metalkor-wasp #x4000)))
                        (set! (-> self wasps gp-0)
                              (ppointer->handle (when s4-1
                                                  (let ((t9-4 (method-of-type process activate)))
                                                    (t9-4 s4-1 self (symbol->string (-> metalkor-wasp symbol)) (the-as pointer #x70004000))
                                                    )
                                                  (run-now-in-process s4-1 enemy-init-by-other self s5-0)
                                                  (-> s4-1 ppointer)
                                                  )
                                                )
                              )
                        )
                      (send-event
                        (handle->process (-> self wasp-gem-tracker))
                        'change-gem
                        #f
                        (handle->process (-> self wasps gp-0))
                        )
                      (goto cfg-69)
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (label cfg-69)
    (cond
      ((< (-> self live-flitters) 3)
       (set! (-> self launching-flitters) #t)
       )
      ((or (!= (-> self stage) 1) (not (-> self in-wave)) (>= (-> self live-flitters) 10))
       (set! (-> self launching-flitters) #f)
       )
      ((< (-> self live-flitters) 5)
       (set! (-> self launching-flitters) #t)
       )
      )
    (rotate-and-update-hang-anim)
    (if (and (< 10922.667 (-> self target-angle))
             (< (- (current-time) (-> self shoot-timer)) (seconds 3.75))
             (zero? (mod (-> self shots-fired) (-> self stage)))
             )
        (set! (-> self shoot-timer)
              (the-as time-frame (max (-> self shoot-timer) (+ (current-time) (seconds -2.75))))
              )
        )
    (cond
      ((metalkor-check-egg)
       (set! (-> self shoot-timer) (current-time))
       )
      ((or (>= (- (current-time) (-> self shoot-timer)) (seconds 3.75))
           (nonzero? (mod (-> self shots-fired) (-> self stage)))
           )
       (set! (-> self flitter-timer) (current-time))
       (spawn (-> self shot-anticipate) (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 7)))
       (if (zero? (mod (-> self shots-fired) (-> self stage)))
           (set-nestb-purple!
             (fmax
               (get-nestb-purple)
               (* 0.0013333333 (the float (+ (- (seconds -3.75) (-> self shoot-timer)) (current-time))))
               )
             )
           (set-nestb-purple!
             (fmax (get-nestb-purple) (* 0.0022222223 (the float (- (current-time) (-> self shoot-timer)))))
             )
           )
       (let* ((v1-123 (the-as art-joint-anim (-> self draw art-group data 23)))
              (f0-7 (/ (the float (-> v1-123 frames num-frames)) (-> v1-123 speed)))
              (f1-6 45.0)
              )
         (if (zero? (mod (-> self shots-fired) (-> self stage)))
             (set! f1-6 75.0)
             )
         (if (metalkor-ja-float (the-as art-joint-anim (-> self draw art-group data 23)) (/ f0-7 f1-6) 1.0 f0-7)
             (sound-play "nboss-pre-shot")
             )
         )
       (when (or (>= (- (current-time) (-> self shoot-timer)) (seconds 5))
                 (and (>= (- (current-time) (-> self shoot-timer)) (seconds 0.75))
                      (nonzero? (mod (-> self shots-fired) (-> self stage)))
                      )
                 )
         (set! (-> self shoot-timer) (current-time))
         (metalkor-shoot-projectile)
         (set-nestb-purple! (fmax 1.0 (get-nestb-purple)))
         (metalkor-ja-float-stop (the-as art-joint-anim (-> self draw art-group data 23)))
         (ja-channel-push! 1 (seconds 0.05))
         (ja :group! (-> self draw art-group data 24) :num! min)
         (metalkor-all-spinners-on)
         )
       )
      ((and (-> self launching-flitters) (>= (+ (current-time) (seconds -0.5)) (-> self flitter-timer)))
       (set! (-> self flitter-timer) (current-time))
       (set! (-> self shoot-timer) (current-time))
       (metalkor-start-egg)
       )
      )
    (metalkor-common)
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )

(defstate hidden (metalkor)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('occlude-off)
                      (let ((a0-3 (handle->process (-> self rift-occlude))))
                        (if a0-3
                            (the-as symbol (deactivate a0-3))
                            )
                        )
                      )
                     )
            )
    )
  :trans (behavior ()
    (if (task-node-closed? (game-task-node nest-boss-introduction))
        (metalkor-go-next-stage)
        )
    (none)
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  )

(defstate test (metalkor)
  :virtual #t
  :event metalkor-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self current-nav-poly) (cloest-point-on-mesh
                                       (-> self nav)
                                       (-> self root-override trans)
                                       (-> self root-override trans)
                                       (-> self current-nav-poly)
                                       )
          )
    (ja :group! (-> self draw art-group data 5))
    (none)
    )
  :trans (behavior ()
    (local-vars (v1-72 float))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (if (and (>= (- (current-time) (-> self state-time)) (seconds 0.017)) (cpad-hold? 1 x))
          (go-virtual test)
          )
      (let ((s4-0 (new-stack-vector0))
            (s2-0 (new-stack-vector0))
            (s5-0 (new 'stack-no-clear 'matrix))
            (s1-0 (new 'stack-no-clear 'matrix))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> gp-0 quad) (-> self root-override trans quad))
        (set! (-> s4-0 y) (analog-input (the-as int (-> *cpad-list* cpads 1 rightx)) 128.0 48.0 110.0 1.0))
        (set! (-> s2-0 z) (analog-input (the-as int (-> *cpad-list* cpads 1 lefty)) 128.0 48.0 110.0 1.0))
        (vector-float*! s4-0 s4-0 -364.0889)
        (quaternion->matrix s1-0 (-> self root-override quat))
        (matrix-rotate-y! s5-0 (-> s4-0 y))
        (set! (-> self last-rotation) (-> s4-0 y))
        (matrix*! s1-0 s5-0 s1-0)
        (matrix-remove-z-rot s1-0 (new 'static 'vector :y -1.0))
        (matrix->quaternion (-> self root-override quat) s1-0)
        (quaternion-normalize! (-> self root-override quat))
        (when (and (nonzero? (-> self previous-flat-travel-long-timer))
                   (>= (+ (current-time) (seconds -1.2)) (-> self previous-flat-travel-long-timer))
                   )
          (set! (-> self previous-flat-travel-long-timer) 0)
          (set! (-> self previous-flat-travel-timer) 0)
          0
          )
        (let ((s3-0 (new 'stack-no-clear 'clamp-travel-vector-to-mesh-return-info))
              (s5-1 (new 'stack-no-clear 'vector))
              )
          (let ((s4-1 (new 'stack-no-clear 'vector)))
            (let ((f0-5 2048.0))
              (set! (-> s4-1 quad) (-> self root-override trans quad))
              (vector-float*! s5-1 (-> s1-0 vector 2) (* (-> s2-0 z) (- f0-5)))
              )
            (set! (-> s5-1 y) 0.0)
            (set! (-> s3-0 poly) (-> self current-nav-poly))
            (dotimes (s2-1 5)
              (let ((f30-0 (vector-length s5-1)))
                (clamp-vector-to-mesh-no-gaps (-> self nav state mesh) s4-1 (-> s3-0 poly) s5-1 s3-0)
                (cond
                  ((-> s3-0 found-boundary)
                   (set-normals-from-adjacent-bounds (-> self nav state mesh) s3-0)
                   (let ((f28-0 (vector-length s5-1)))
                     (vector-flatten! s5-1 s5-1 (-> s3-0 boundary-normal))
                     (let ((f0-9 (- f30-0 f28-0)))
                       (vector-normalize! s5-1 f0-9)
                       )
                     )
                   (if (and (< (+ (current-time) (seconds -0.1)) (-> self previous-flat-travel-timer))
                            (< (vector-dot s5-1 (-> self previous-flat-travel)) 0.0)
                            )
                       (vector-negate! s5-1 s5-1)
                       )
                   (set! (-> s4-1 x) (-> s3-0 intersection x))
                   (set! (-> s4-1 z) (-> s3-0 intersection z))
                   (vector-! s4-1 s4-1 (-> s3-0 boundary-normal))
                   (when (or (> s2-1 0) (< (+ (current-time) (seconds -0.1)) (-> self previous-flat-travel-timer)))
                     (set! (-> self previous-flat-travel quad) (-> s5-1 quad))
                     (set! (-> self previous-flat-travel-timer) (current-time))
                     (if (zero? (-> self previous-flat-travel-long-timer))
                         (set! (-> self previous-flat-travel-long-timer) (current-time))
                         )
                     )
                   )
                  (else
                    (goto cfg-30)
                    )
                  )
                )
              )
            (label cfg-30)
            (vector+! s5-1 s4-1 s5-1)
            )
          (vector-! s5-1 s5-1 (-> self root-override trans))
          (.lvf vf1 (&-> s5-1 quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov v1-72 vf1)
          (let ((f0-14 v1-72)
                (f1-2 1024.0)
                )
            (if (< (* f1-2 f1-2) f0-14)
                (vector-float*! s5-1 s5-1 (/ 1024.0 (sqrtf f0-14)))
                )
            )
          (vector+! (-> self root-override trans) (-> self root-override trans) s5-1)
          )
        (set! (-> self current-nav-poly) (cloest-point-on-mesh
                                           (-> self nav)
                                           (-> self root-override trans)
                                           (-> self root-override trans)
                                           (-> self current-nav-poly)
                                           )
              )
        (let ((s5-2 (new 'stack 'collide-query)))
          (if (above-ground?
                (-> self root-override)
                s5-2
                (-> self root-override trans)
                (collide-spec backgnd)
                12288.0
                122880.0
                1024.0
                )
              (set! (-> self root-override trans y) (-> s5-2 best-other-tri intersect y))
              )
          )
        (update-walk-anim gp-0 #f)
        )
      (let ((s4-2 (new 'stack-no-clear 'clamp-travel-vector-to-mesh-return-info))
            (v1-94 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root-override quat)))
            (s3-1 (new 'stack-no-clear 'vector))
            (s5-3 (new 'stack-no-clear 'vector))
            (gp-1 (new 'stack-no-clear 'vector))
            )
        (let ((f0-18 81920.0))
          (set! (-> gp-1 quad) (-> self root-override trans quad))
          (set! (-> s5-3 quad) (-> v1-94 vector 2 quad))
          (set! (-> s5-3 y) 0.0)
          (vector-normalize! s5-3 f0-18)
          )
        (set! (-> s4-2 poly) (-> self current-nav-poly))
        (dotimes (s2-2 5)
          (let ((f30-1 (vector-length s5-3)))
            (clamp-vector-to-mesh-no-gaps (-> self nav state mesh) gp-1 (-> s4-2 poly) s5-3 s4-2)
            (cond
              ((-> s4-2 found-boundary)
               (set-normals-from-adjacent-bounds (-> self nav state mesh) s4-2)
               (camera-line (-> s4-2 vert-prev) (-> s4-2 vert-0) (new 'static 'vector4w :x #xff :w #x80))
               (camera-line (-> s4-2 vert-0) (-> s4-2 vert-1) (new 'static 'vector4w :y #xff :w #x80))
               (camera-line (-> s4-2 vert-1) (-> s4-2 vert-next) (new 'static 'vector4w :z #xff :w #x80))
               (camera-line-rel gp-1 s5-3 (new 'static 'vector4w :x #xff :w #x80))
               (let ((f28-1 (vector-length s5-3)))
                 (vector-flatten! s5-3 s5-3 (-> s4-2 boundary-normal))
                 (let ((f0-19 (- f30-1 f28-1)))
                   (vector-normalize! s5-3 f0-19)
                   )
                 )
               (set! (-> gp-1 x) (-> s4-2 intersection x))
               (set! (-> gp-1 z) (-> s4-2 intersection z))
               (vector-! gp-1 gp-1 (-> s4-2 boundary-normal))
               (vector+! s3-1 (-> s4-2 vert-prev) (-> s4-2 vert-0))
               (vector-float*! s3-1 s3-1 0.5)
               (camera-line-rel-len s3-1 (-> s4-2 prev-normal) 12288.0 (new 'static 'vector4w :x #xff :w #x80))
               (vector+! s3-1 (-> s4-2 vert-0) (-> s4-2 vert-1))
               (vector-float*! s3-1 s3-1 0.5)
               (camera-line-rel-len s3-1 (-> s4-2 boundary-normal) 12288.0 (new 'static 'vector4w :y #xff :w #x80))
               (vector+! s3-1 (-> s4-2 vert-1) (-> s4-2 vert-next))
               (vector-float*! s3-1 s3-1 0.5)
               (camera-line-rel-len s3-1 (-> s4-2 next-normal) 12288.0 (new 'static 'vector4w :z #xff :w #x80))
               )
              (else
                (goto cfg-42)
                )
              )
            )
          )
        (label cfg-42)
        (camera-line-rel gp-1 s5-3 (new 'static 'vector4w :x #xff :w #x80))
        )
      (metalkor-common)
      (none)
      )
    )
  :code (the-as (function none :behavior metalkor) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root-override))
    (none)
    )
  )
