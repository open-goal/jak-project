;;-*-Lisp-*-
(in-package goal)

;; name: mantis.gc
;; name in dgo: mantis
;; dgos: NESTT, NES

;; +++mantis:mantis-flag
(defenum mantis-flag
  :type uint16
  :bitfield #t
  (tracked 0)
  (attack1-enabled 1)
  )
;; ---mantis:mantis-flag

;; DECOMP BEGINS

(defpartgroup group-mantis-dust-puff
  :id 1221
  :duration (seconds 0.017)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 8)
  :parts ((sp-item 5221))
  )

(defpart 5221
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 6.0)
    (:scale-x (meters 0.6) (meters 0.4))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 32.0 8.0)
    (:g 16.0 8.0)
    (:b 16.0 8.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.01) (meters 0.0026666666))
    (:scalevel-x (meters 0.0016666667))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.35555556)
    (:fade-g -0.35555556)
    (:fade-b -0.35555556)
    (:fade-a -0.30476192)
    (:accel-y (meters -0.00033333333))
    (:timer (seconds 0.4))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.2))
    (:next-launcher 642)
    (:conerot-x (degrees 60) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    (:rotate-y (degrees 0) (degrees 180))
    )
  )

(defpartgroup group-mantis-birth-nest
  :id 1222
  :duration (seconds 7.335)
  :linger-duration (seconds 4)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 3 0 8)
  :parts ((sp-item 5224 :fade-after (meters 100) :falloff-to (meters 100) :period (seconds 7.335) :length (seconds 0.835) :binding 5222)
    (sp-item 5224 :fade-after (meters 100) :falloff-to (meters 100) :period (seconds 7.335) :length (seconds 0.667) :binding 5222)
    (sp-item 5224 :fade-after (meters 100) :falloff-to (meters 100) :period (seconds 7.335) :length (seconds 0.5) :binding 5222)
    (sp-item 5224 :fade-after (meters 100) :falloff-to (meters 100) :period (seconds 7.335) :length (seconds 0.335) :binding 5222)
    (sp-item 5225 :fade-after (meters 100) :falloff-to (meters 100) :period (seconds 7.335) :length (seconds 0.4) :binding 5223)
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5223 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5222 :flags (bit1 start-dead))
    (sp-item 5226 :fade-after (meters 100) :falloff-to (meters 100) :period (seconds 7.335) :length (seconds 1.067))
    )
  )

(defpart 5224
  :init-specs ((:texture (new 'static 'texture-id :index #x3 :page #xd15))
    (:birth-func 'birth-func-texture-group)
    (:num 0.1 0.5)
    (:x (meters 0) (meters 1))
    (:scale-x (meters 0.1) (meters 0.1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.1) (meters 0.1))
    (:r 200.0 55.0)
    (:g :copy r)
    (:b :copy g)
    (:a 128.0)
    (:vel-y (meters 0.06666667) (meters 0.033333335))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:accel-y (meters -0.002) (meters -0.002))
    (:friction 0.98)
    (:timer (seconds 1.167))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:userdata
      :data (new 'static 'boxed-array :type int32 40 1 0 -783285504 -783285248 -783284992 -783284736 -783284480)
      )
    (:func 'check-drop-level-mantis-dirt-rubble-nest)
    (:conerot-x (degrees 0) (degrees 15))
    (:conerot-y (degrees 0) (degrees 360))
    (:rotate-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0.1))
    )
  )

(defpart 5223
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.0 0.2)
    (:sound (static-sound-spec "debris-fall" :num 0.01 :volume 100.0))
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y (meters 1) (meters 0.2))
    (:r 160.0 16.0)
    (:g 130.0 32.0)
    (:b 110.0 16.0)
    (:a 16.0 16.0)
    (:vel-y (meters 0) (meters -0.0033333334))
    (:scalevel-x (meters 0.0033333334) (meters 0.0016666667))
    (:scalevel-y (meters 0) (meters 0.00033333333))
    (:fade-a -0.042666666 -0.064)
    (:accel-y (meters -0.00033333333) (meters -0.00033333333))
    (:timer (seconds 0.835))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:func 'check-drop-group-center)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 5222
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 0.0 0.2)
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y (meters 1) (meters 0.2))
    (:r 160.0 16.0)
    (:g 130.0 32.0)
    (:b 110.0 16.0)
    (:a 16.0 16.0)
    (:vel-y (meters 0) (meters -0.0033333334))
    (:scalevel-x (meters 0.0033333334) (meters 0.0016666667))
    (:scalevel-y (meters 0) (meters 0.00033333333))
    (:fade-a -0.042666666 -0.064)
    (:accel-y (meters -0.00033333333) (meters -0.00033333333))
    (:timer (seconds 2.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:func 'check-drop-group-center)
    (:rotate-y (degrees 0) (degrees 360))
    )
  )

(defpart 5226
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 0.5))
    (:scale-y (meters 1) (meters 0.5))
    (:r 160.0 16.0)
    (:g 130.0 32.0)
    (:b 110.0 16.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.026666667) (meters 0.026666667))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:scalevel-y (meters 0.0033333334) (meters 0.0016666667))
    (:fade-a -0.053333335 -0.053333335)
    (:accel-y (meters 0) (meters 0.00033333333))
    (:friction 0.85 0.05)
    (:timer (seconds 8))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12))
    (:conerot-x (degrees 0) (degrees 90))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0) (meters 0.5))
    )
  )

(deftype mantis-jump-info (structure)
  ((distance    float          :offset-assert   0)
   (search-step uint32         :offset-assert   4)
   (destination vector :inline :offset-assert  16)
   (direction   uint16         :offset-assert  32)
   (start-anim  uint32         :offset-assert  36)
   (air-anim    uint32         :offset-assert  40)
   (land-anim   uint32         :offset-assert  44)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )


(deftype mantis (nav-enemy)
  ((base-height  float                    :offset-assert 604)
   (flags        mantis-flag              :offset-assert 608)
   (attack-timer time-frame               :offset-assert 616)
   (track-timer  time-frame               :offset-assert 624)
   (gspot-timer  time-frame               :offset-assert 632)
   (gspot-normal vector           :inline :offset-assert 640)
   (my-up-vector vector           :inline :offset-assert 656)
   (jump         mantis-jump-info :inline :offset-assert 672)
   )
  :heap-base #x250
  :method-count-assert 195
  :size-assert         #x2d0
  :flag-assert         #xc3025002d0
  (:methods
    (crawl () _type_ :state 178)
    (attack0 () _type_ :state 179)
    (attack1 () _type_ :state 180)
    (ambush-crawling () _type_ :state 181)
    (ambush-jumping () _type_ :state 182)
    (mantis-method-183 () none 183)
    (roll-right () _type_ :state 184)
    (roll-left () _type_ :state 185)
    (hop-away () _type_ :state 186)
    (mantis-method-187 (_type_) none 187)
    (mantis-method-188 (_type_) none 188)
    (mantis-method-189 (_type_ vector vector) symbol 189)
    (mantis-method-190 (_type_ vector vector) none 190)
    (mantis-method-191 (_type_ vector vector) int 191)
    (mantis-method-192 (_type_ vector vector) none 192)
    (mantis-method-193 (_type_ vector) none 193)
    (mantis-method-194 (_type_) symbol 194)
    )
  )


(defskelgroup skel-mantis mantis mantis-lod0-jg mantis-idle0-ja
              ((mantis-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 4)
              :shadow mantis-shadow-mg
              )

(define *mantis-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #f
    :use-victory #f
    :use-jump-blocked #f
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #t
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'array idle-control-frame 8
      (new 'static 'idle-control-frame :command (ic-cmd push) :param0 #x1e)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x5 :param0 #x2 :param1 #x5)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x7 :param0 #x1 :param1 #x1)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x6 :param0 #x1 :param1 #x1)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x8 :param0 #x1 :param1 #x1)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      )
    :idle-anim 5
    :notice-anim 5
    :hostile-anim 9
    :hit-anim 5
    :knocked-anim 10
    :knocked-land-anim 11
    :die-anim 26
    :die-falling-anim -1
    :victory-anim 5
    :jump-wind-up-anim -1
    :jump-in-air-anim -1
    :jump-land-anim -1
    :neck-joint -1
    :sound-hit (static-sound-name "mantis-hit")
    :sound-die (static-sound-name "mantis-die")
    :notice-distance (meters 50)
    :notice-distance-delta (meters 10)
    :proximity-notice-distance (meters 2)
    :default-hit-points 2
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
    :movement-gravity (meters -100)
    :friction 0.8
    :attack-shove-back (meters 3)
    :attack-shove-up (meters 2)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :jump-height-min (meters 3)
    :jump-height-factor 0.3
    :knocked-seek-ry-clamp 2730.6667
    :knocked-soft-vxz-lo 72089.6
    :knocked-soft-vxz-hi 108134.4
    :knocked-soft-vy-lo 81920.0
    :knocked-soft-vy-hi 122880.0
    :knocked-medium-vxz-lo 147456.0
    :knocked-medium-vxz-hi 196608.0
    :knocked-medium-vy-lo 135168.0
    :knocked-medium-vy-hi 151552.0
    :knocked-hard-vxz-lo 78643.2
    :knocked-hard-vxz-hi 117964.8
    :knocked-hard-vy-lo 183500.8
    :knocked-hard-vy-hi 209715.2
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 40960.0
    :knocked-yellow-vxz-hi 49152.0
    :knocked-yellow-vy-lo 57344.0
    :knocked-yellow-vy-hi 81920.0
    :knocked-red-vxz-lo 106496.0
    :knocked-red-vxz-hi 106496.0
    :knocked-red-vy-lo 55296.0
    :knocked-red-vy-hi 55296.0
    :knocked-blue-vxz-lo 40960.0
    :knocked-blue-vxz-hi 49152.0
    :knocked-blue-vy-lo 24576.0
    :knocked-blue-vy-hi 81920.0
    :shadow-size (meters 1)
    :shadow-max-y (meters 1)
    :shadow-min-y (meters -1)
    :shadow-locus-dist (meters 150)
    :gem-joint 7
    :gem-seg #x2
    :gem-no-seg #x4
    :gem-offset (new 'static 'sphere :y 1286.144 :z 122.88 :r 327680.0)
    :callback-info #f
    :use-momentum #f
    :use-frustration #t
    :use-stop-chase #f
    :use-circling #t
    :use-pacing #t
    :walk-anim 9
    :turn-anim 5
    :run-anim 9
    :taunt-anim -1
    :run-travel-speed (meters 6)
    :run-acceleration (meters 1)
    :run-turning-acceleration (meters 50)
    :walk-travel-speed (meters 3)
    :walk-acceleration (meters 1)
    :walk-turning-acceleration (meters 20)
    :maximum-rotation-rate (degrees 720.0)
    :notice-nav-radius (meters 1)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

(set! (-> *mantis-nav-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

(defstate active (mantis)
  :virtual #t
  :trans (behavior ()
    (let ((t9-1 (-> (the-as (state enemy) (find-parent-method mantis 32)) trans)))
      (if t9-1
          (t9-1)
          )
      )
    (if (logtest? (-> self flags) (mantis-flag tracked))
        (mantis-method-187 self)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (let ((gp-0 (get-rand-int-range self 3 5)))
        (dotimes (s5-0 gp-0)
          (ja-no-eval :group! mantis-idle0-ja
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-idle0-ja) frames num-frames) -1)))
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
        )
      (ja-no-eval :group! mantis-idle0-to-idle1-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-idle0-to-idle1-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (let ((gp-1 (get-rand-int self 3)))
        (dotimes (s5-1 gp-1)
          (ja-no-eval :group! mantis-idle1-ja
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-idle1-ja) frames num-frames) -1)))
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
        )
      (ja-no-eval :group! mantis-idle1-to-idle0-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-idle1-to-idle0-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mantis) nav-enemy-face-focus-post)
  )

(defstate ambush (mantis)
  :virtual #t
  :enter (behavior ()
    (when (logtest? (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
      (logclear! (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
      (let ((gp-0 (-> self on-notice)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root-override2 trans))
            )
        )
      )
    (let ((v1-12 (-> self root-override2 root-prim)))
      (set! (-> v1-12 prim-core collide-as) (collide-spec))
      (set! (-> v1-12 prim-core collide-with) (collide-spec))
      )
    0
    (let ((gp-1 (new 'stack-no-clear 'collide-query)))
      (if (enemy-above-ground? self gp-1 (-> self root-override2 trans) (collide-spec backgnd) 8192.0 81920.0 1024.0)
          (set! (-> self base-height) (-> gp-1 best-other-tri intersect y))
          (set! (-> self base-height) (-> self root-override2 trans y))
          )
      )
    (let* ((gp-2 *target*)
           (a0-5 (if (type? gp-2 process-focusable)
                     gp-2
                     )
                 )
           )
      (when a0-5
        (let* ((gp-3 (-> self root-override2))
               (s3-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (get-trans a0-5 0) (-> gp-3 trans)) 1.0))
               (f0-2 (deg-diff (quaternion-y-angle (-> gp-3 quat)) (vector-y-angle s3-0)))
               )
          (quaternion-rotate-y! (-> gp-3 quat) (-> gp-3 quat) f0-2)
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self root-override2 trans quad))
      (set! (-> gp-0 y) (+ -18841.6 (-> gp-0 y)))
      (let ((s5-0 (get-process *default-dead-pool* part-tracker #x4000)))
        (when s5-0
          (let ((t9-1 (method-of-type part-tracker activate)))
            (t9-1
              (the-as part-tracker s5-0)
              *entity-pool*
              (symbol->string (-> part-tracker symbol))
              (the-as pointer #x70004000)
              )
            )
          (let ((t9-2 run-function-in-process)
                (a0-2 s5-0)
                (a1-2 part-tracker-init)
                (a2-4 (-> *part-group-id-table* 1222))
                (a3-1 0)
                (t0-0 #f)
                (t1-0 #f)
                (t2-0 #f)
                (t3-0 *launch-matrix*)
                )
            (set! (-> t3-0 trans quad) (-> gp-0 quad))
            ((the-as (function object object object object object object object object none) t9-2)
             a0-2
             a1-2
             a2-4
             a3-1
             t0-0
             t1-0
             t2-0
             t3-0
             )
            )
          (-> s5-0 ppointer)
          )
        )
      )
    (let ((gp-1 (current-time)))
      (until (>= (- (current-time) gp-1) (seconds 0.6))
        (suspend)
        )
      )
    (logior! (-> self draw status) (draw-control-status no-draw))
    (let ((gp-2 (current-time)))
      (until (>= (- (current-time) gp-2) (the int (* 300.0 (get-rand-float-range self 0.0 0.6))))
        (suspend)
        )
      )
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (if (rng-hit? self 0.5)
        (go-virtual ambush-jumping)
        (go-virtual ambush-crawling)
        )
    (none)
    )
  )

(defstate ambush-crawling (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :code (behavior ()
    (look-at-target! self (enemy-flag lock-focus))
    (set! (-> self root-override2 trans y) (-> self base-height))
    (ja-channel-push! 1 0)
    (ja-no-eval :group! mantis-ground-crawl-out-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-ground-crawl-out-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-28 (-> self root-override2 root-prim)))
      (set! (-> v1-28 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-28 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (go-virtual hostile)
    (none)
    )
  :post (the-as (function none :behavior mantis) nav-enemy-simple-post)
  )

(defstate ambush-jumping (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :enter (behavior ()
    (let ((v1-0 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-0 enemy-flags)))
          (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-0 enemy-flags))))
          )
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-0 enemy-flags))))
      (set! (-> v1-0 nav callback-info) (-> v1-0 enemy-info-override callback-info))
      )
    0
    (let ((v1-3 self))
      (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-3 enemy-flags))))
      )
    0
    (look-at-target! self (enemy-flag lock-focus))
    (set! (-> self state-time) (current-time))
    (set! (-> self root-override2 trans y) (+ -18841.6 (-> self base-height)))
    (let ((gp-0 (-> self root-override2)))
      (let ((v1-11 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> gp-0 quat))))
        (vector-reset! (-> gp-0 transv))
        (set! (-> v1-11 y) 0.0)
        )
      (vector-reset! (-> gp-0 transv))
      (set! (-> gp-0 transv y) (* 4096.0 (get-rand-float-range self 28.0 32.0)))
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! mantis-ground-jump-out-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-ground-jump-out-ja) frames num-frames) -1)))
                )
    (until #f
      (if (< (-> self base-height) (-> self root-override2 trans y))
          (goto cfg-5)
          )
      (suspend)
      (ja :num! (seek!))
      )
    #f
    (until #f
      (label cfg-5)
      (when (< (+ 819.2 (-> self base-height)) (-> self root-override2 trans y))
        (let ((v1-32 (-> self root-override2 root-prim)))
          (set! (-> v1-32 prim-core collide-as) (-> self root-override2 backup-collide-as))
          (set! (-> v1-32 prim-core collide-with) (-> self root-override2 backup-collide-with))
          )
        (goto cfg-9)
        )
      (suspend)
      (ja :num! (seek!))
      )
    #f
    (until #f
      (label cfg-9)
      (if (or (and (>= (fabs (* 4096.0 (-> self clock seconds-per-frame))) (-> self root-override2 transv y))
                   (>= (-> self base-height) (-> self root-override2 trans y))
                   )
              (logtest? (-> self root-override2 status) (collide-status on-ground))
              )
          (goto cfg-24)
          )
      (suspend)
      (if (not (ja-done? 0))
          (ja :num! (seek!))
          )
      )
    #f
    (label cfg-24)
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! mantis-ground-jump-out-land-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-ground-jump-out-land-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-0 (current-time)))
      (until (>= (- (current-time) gp-0) (seconds 1))
        (if (logtest? (-> self root-override2 status) (collide-status on-ground))
            (goto cfg-32)
            )
        (suspend)
        )
      )
    (label cfg-32)
    (go-virtual hostile)
    (none)
    )
  :post (the-as (function none :behavior mantis) nav-enemy-falling-post)
  )

(defstate hostile (mantis)
  :virtual #t
  :exit (behavior ()
    (logclear! (-> self flags) (mantis-flag attack1-enabled))
    (none)
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let ((t9-0 (-> (method-of-type nav-enemy hostile) trans)))
        (if t9-0
            (t9-0)
            )
        )
      (let ((gp-0 (handle->process (-> self focus handle))))
        (when gp-0
          (let* ((s4-0 (-> self focus-pos))
                 (s5-1 (vector-! (new 'stack-no-clear 'vector) s4-0 (-> self root-override2 trans)))
                 )
            (let ((s2-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (get-quat (the-as process-focusable gp-0) 0)))
                  (s1-0 s5-1)
                  )
              (let ((s3-1 s5-1))
                (let ((v1-14 (* 2.0 (vector-length (get-transv (the-as process-focusable gp-0))))))
                  (.mov vf7 v1-14)
                  )
                (.lvf vf5 (&-> s2-1 quad))
                (.lvf vf4 (&-> s3-1 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> s1-0 quad) vf6)
              )
            (let ((f30-1 (vector-length s5-1)))
              (when (not (logtest? (-> self flags) (mantis-flag tracked)))
                (cond
                  ((< (- (current-time) (-> self attack-timer)) (seconds 5))
                   (if (and (< 73728.0 f30-1) (mantis-method-194 self))
                       (go-virtual crawl)
                       )
                   )
                  ((< 40960.0 f30-1)
                   (mantis-method-190 self (the-as vector gp-0) s5-1)
                   )
                  )
                )
              (when (and (and gp-0
                              (not (logtest? (-> (the-as process-focusable gp-0) focus-status) (focus-status disable dead ignore grabbed)))
                              )
                         (and (>= (- (current-time) (-> self attack-timer)) (seconds 5))
                              (enemy-method-95 self s4-0 8192.0)
                              (< f30-1 32768.0)
                              )
                         )
                (cond
                  ((< 24576.0 f30-1)
                   (if (logtest? (-> self flags) (mantis-flag attack1-enabled))
                       (go-virtual attack1)
                       )
                   )
                  ((< 16384.0 f30-1)
                   (go-virtual attack0)
                   )
                  )
                )
              )
            (if (enemy-method-95 self s4-0 10922.667)
                (mantis-method-187 self)
                )
            (if (logtest? (-> self flags) (mantis-flag tracked))
                (mantis-method-192 self (the-as vector gp-0) s5-1)
                (mantis-method-191 self (the-as vector gp-0) s5-1)
                )
            )
          )
        )
      (none)
      )
    )
  )

(defstate crawl (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (change-to (nav-mesh-from-res-tag (-> self entity) 'nav-mesh-actor 1) self)
    (nav-enemy-method-166 self)
    (let ((v1-6 (-> self nav)))
      (set! (-> v1-6 max-rotation-rate) 21845.334)
      )
    0
    (none)
    )
  :exit (behavior ()
    (change-to (nav-mesh-from-res-tag (-> self entity) 'nav-mesh-actor 0) self)
    (let ((v1-2 (-> self nav)))
      (set! (-> v1-2 max-rotation-rate) (-> self enemy-info-override maximum-rotation-rate))
      )
    0
    (none)
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (logtest? (-> self flags) (mantis-flag tracked))
        (go-virtual hostile)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-channel-push! 1 (seconds 0.3))
      (let ((v1-0 self))
        (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag enemy-flag36))))
        (set! (-> v1-0 nav callback-info) *nav-enemy-null-callback-info*)
        )
      0
      (dotimes (gp-0 (get-rand-int-range self 1 2))
        (ja-no-eval :group! mantis-idle0-ja
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-idle0-ja) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      (let ((gp-1 (handle->process (-> self focus handle))))
        (cond
          ((or (not gp-1) (< (the-as int (-> self focus aware)) 1))
           (go-virtual idle)
           )
          (else
            (let* ((s5-0 (-> self root-override2 trans))
                   (s4-1 (vector-! (new 'stack-no-clear 'vector) (-> self focus-pos) s5-0))
                   (s0-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat)))
                   (s2-0 (new 'stack-no-clear 'vector))
                   (s3-0 (new 'stack-no-clear 'vector))
                   )
              (let ((f30-1 (* 4096.0 (get-rand-float-range self 8.0 12.0)))
                    (s1-0 (cloest-point-on-mesh (-> self nav) s5-0 s5-0 (the-as nav-poly #f)))
                    )
                (vector-normalize-copy! s2-0 s4-1 1.0)
                (vector-rotate-around-y! s2-0 s2-0 (if (< 0.0 (vector-dot s2-0 s0-0))
                                                       -16384.0
                                                       16384.0
                                                       )
                                         )
                (vector-float*! s3-0 s2-0 f30-1)
                (clamp-vector-to-mesh-cross-gaps
                  (-> self nav)
                  s5-0
                  s1-0
                  s3-0
                  204.8
                  #f
                  (the-as clamp-travel-vector-to-mesh-return-info #f)
                  )
                (when (< (vector-length s3-0) (+ -819.2 f30-1))
                  (vector-float*! s3-0 s2-0 (- f30-1))
                  (clamp-vector-to-mesh-cross-gaps
                    (-> self nav)
                    s5-0
                    s1-0
                    s3-0
                    204.8
                    #f
                    (the-as clamp-travel-vector-to-mesh-return-info #f)
                    )
                  (if (< (vector-length s3-0) (+ -819.2 f30-1))
                      (mantis-method-190 self (the-as vector gp-1) s4-1)
                      )
                  )
                )
              (vector+! (-> self move-dest) s5-0 s3-0)
              )
            (let ((a0-21 (-> self nav state))
                  (v1-70 (-> self move-dest))
                  )
              (logclear! (-> a0-21 flags) (nav-state-flag directional-mode))
              (logior! (-> a0-21 flags) (nav-state-flag target-poly-dirty))
              (set! (-> a0-21 target-post quad) (-> v1-70 quad))
              )
            0
            )
          )
        )
      (ja-channel-push! 1 (seconds 0.3))
      (let ((v1-73 self))
        (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-73 enemy-flags)))
            (set! (-> v1-73 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-73 enemy-flags))))
            )
        (set! (-> v1-73 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-73 enemy-flags))))
        (set! (-> v1-73 nav callback-info) (-> v1-73 enemy-info-override callback-info))
        )
      0
      (dotimes (gp-2 (get-rand-int-range self 3 5))
        (ja-no-eval :group! mantis-run0-ja
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-run0-ja) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (if (and (>= (- (current-time) (-> self attack-timer)) (seconds 5)) (< 1 (the-as int (-> self focus aware))))
            (go-virtual hostile)
            )
        (if (< (vector-vector-xz-distance (-> self root-override2 trans) (-> self move-dest)) 13107.2)
            (goto cfg-38)
            )
        )
      (label cfg-38)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mantis) nav-enemy-travel-post)
  )

(defstate attack0 (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info-override callback-info))
      )
    0
    (set! (-> self attack-timer) (current-time))
    (none)
    )
  :exit (behavior ()
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :code (behavior ()
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((v1-2 (-> self nav)))
      (set! (-> v1-2 target-speed) 81920.0)
      )
    0
    (ja-no-eval :group! mantis-attack0-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-attack0-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-34 self))
      (set! (-> v1-34 enemy-flags) (the-as enemy-flag (logclear (-> v1-34 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-34 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (ja-no-eval :group! mantis-attack0-land-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-attack0-land-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (nav-enemy-method-166 self)
    (let ((v1-63 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-63 enemy-flags)))
          (set! (-> v1-63 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-63 enemy-flags))))
          )
      (set! (-> v1-63 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-63 enemy-flags))))
      (set! (-> v1-63 nav callback-info) (-> v1-63 enemy-info-override callback-info))
      )
    0
    (go-hostile self)
    (none)
    )
  :post (the-as (function none :behavior mantis) nav-enemy-chase-post)
  )

(defstate attack1 (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self attack-timer) (current-time))
    (none)
    )
  :exit (behavior ()
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :code (behavior ()
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-0 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (ja-no-eval :group! mantis-attack1-wind-up-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-attack1-wind-up-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (let ((a0-5 (handle->process (-> self focus handle))))
        (if a0-5
            (seek-to-point-toward-point!
              (-> self root-override2)
              (get-trans (the-as process-focusable a0-5) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-36 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-36 enemy-flags)))
          (set! (-> v1-36 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-36 enemy-flags))))
          )
      (set! (-> v1-36 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-36 enemy-flags))))
      (set! (-> v1-36 nav callback-info) (-> v1-36 enemy-info-override callback-info))
      )
    0
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((v1-41 (-> self nav)))
      (set! (-> v1-41 target-speed) 286720.0)
      )
    0
    (ja-no-eval :group! mantis-attack1-go-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-attack1-go-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-73 self))
      (set! (-> v1-73 enemy-flags) (the-as enemy-flag (logclear (-> v1-73 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-73 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (ja-no-eval :group! mantis-attack1-land-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-attack1-land-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (nav-enemy-method-166 self)
    (let ((v1-102 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-102 enemy-flags)))
          (set! (-> v1-102 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-102 enemy-flags))))
          )
      (set! (-> v1-102 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-102 enemy-flags))))
      (set! (-> v1-102 nav callback-info) (-> v1-102 enemy-info-override callback-info))
      )
    0
    (go-hostile self)
    (none)
    )
  :post (the-as (function none :behavior mantis) nav-enemy-chase-post)
  )

(defstate roll-right (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :code (behavior ()
    (vector-reset! (-> self root-override2 transv))
    (vector-x-quaternion! (-> self root-override2 transv) (-> self root-override2 quat))
    (set! (-> self root-override2 transv y) 0.0)
    (vector-normalize! (-> self root-override2 transv) -88064.0)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info-override callback-info))
      )
    0
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! mantis-roll-right-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-roll-right-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-33 self))
      (set! (-> v1-33 enemy-flags) (the-as enemy-flag (logclear (-> v1-33 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-33 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (ja-no-eval :group! mantis-roll-right-land-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-roll-right-land-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (logior! (-> self flags) (mantis-flag attack1-enabled))
    (go-hostile self)
    (none)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (when (logtest? (enemy-flag enemy-flag36) (-> a0-0 enemy-flags))
        (vector-v++!
          (-> self root-override2 transv)
          (compute-acc-due-to-gravity (-> self root-override2) (new 'stack-no-clear 'vector) 0.0)
          )
        (let ((a2-1 (new 'stack-no-clear 'collide-query))
              (a0-5 (-> self root-override2))
              )
          (set! (-> a2-1 collide-with) (-> a0-5 root-prim prim-core collide-with))
          (set! (-> a2-1 ignore-process0) self)
          (set! (-> a2-1 ignore-process1) #f)
          (set! (-> a2-1 ignore-pat) (-> a0-5 pat-ignore-mask))
          (set! (-> a2-1 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide a0-5 (-> self root-override2 transv) a2-1 (meters 0))
          )
        )
      )
    (nav-enemy-simple-post)
    (none)
    )
  )

(defstate roll-left (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :code (behavior ()
    (vector-reset! (-> self root-override2 transv))
    (vector-x-quaternion! (-> self root-override2 transv) (-> self root-override2 quat))
    (set! (-> self root-override2 transv y) 27443.2)
    (vector-xz-normalize! (-> self root-override2 transv) 102400.0)
    (let ((v1-7 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-7 enemy-flags)))
          (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-7 enemy-flags))))
          )
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-7 enemy-flags))))
      (set! (-> v1-7 nav callback-info) (-> v1-7 enemy-info-override callback-info))
      )
    0
    (ja-channel-push! 1 (seconds 0.067))
    (ja-no-eval :group! mantis-hop-left-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-hop-left-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-34 self))
      (set! (-> v1-34 enemy-flags) (the-as enemy-flag (logclear (-> v1-34 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-34 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (ja-no-eval :group! mantis-hop-left-land-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-hop-left-land-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-hostile self)
    (none)
    )
  :post (-> (method-of-type mantis roll-right) post)
  )

(defstate hop-away (mantis)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mantis) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (look-at-target! self (enemy-flag lock-focus))
    (logior! (-> self enemy-flags) (enemy-flag use-notice-distance))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info-override callback-info))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-11 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self starting-time) (current-time))
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (ja-channel-push! 1 (seconds 0.2))
      (until #f
        (let ((gp-0 (handle->process (-> self focus handle))))
          (when gp-0
            (let* ((v1-5 (-> self focus-pos))
                   (s5-1 (vector-! (new 'stack-no-clear 'vector) v1-5 (-> self root-override2 trans)))
                   )
              (let ((s4-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (get-quat (the-as process-focusable gp-0) 0))))
                (if (and (>= (vector-length s5-1) 122880.0) (mantis-method-194 self))
                    (go-virtual crawl)
                    )
                (let ((s2-0 s5-1))
                  (let ((s3-1 s5-1))
                    (let ((v1-21 (* 0.2 (vector-length (get-transv (the-as process-focusable gp-0))))))
                      (.mov vf7 v1-21)
                      )
                    (.lvf vf5 (&-> s4-1 quad))
                    (.lvf vf4 (&-> s3-1 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> s2-0 quad) vf6)
                  )
                )
              (if (not (or (mantis-method-191 self (the-as vector gp-0) s5-1) (not (mantis-method-194 self))))
                  (go-virtual crawl)
                  )
              )
            (if (and (>= (- (current-time) (-> self state-time)) (-> self reaction-time))
                     (>= (the-as int (-> self focus aware)) 3)
                     (get-enemy-target self)
                     )
                (go-hostile self)
                )
            )
          )
        (dotimes (gp-1 (get-rand-int-range self 2 4))
          (ja-no-eval :group! mantis-idle0-ja
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim mantis-idle0-ja) frames num-frames) -1)))
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
        )
      #f
      (none)
      )
    )
  :post (the-as (function none :behavior mantis) nav-enemy-face-focus-post)
  )

(defmethod general-event-handler mantis ((obj mantis) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (case arg2
    (('track)
     (if (and (-> arg3 param 0) (>= (- (current-time) (-> obj track-timer)) (seconds 0.5)))
         'abort
         #t
         )
     )
    (('tracked)
     (logior! (-> obj flags) (mantis-flag tracked))
     (let ((v0-0 (the-as object (current-time))))
       (set! (-> obj track-timer) (the-as time-frame v0-0))
       v0-0
       )
     )
    (('hit 'hit-knocked)
     (logclear! (-> obj mask) (process-mask actor-pause))
     (logclear! (-> obj focus-status) (focus-status dangerous))
     (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice))
     (logior! (-> obj enemy-flags) (enemy-flag chase-startup))
     (logior! (-> obj focus-status) (focus-status hit))
     (if (zero? (-> obj hit-points))
         (logior! (-> obj focus-status) (focus-status dead))
         )
     (logclear! (-> obj enemy-flags) (enemy-flag actor-pause-backup))
     (enemy-method-62 obj)
     (set! (-> obj enemy-flags) (logior (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
     (process-contact-action arg0)
     (send-event arg0 'get-attack-count 1)
     (cond
       ((zero? (-> obj hit-points))
        (let ((s5-1 (-> obj incoming knocked-type)))
          (cond
            ((and (= s5-1 (knocked-type knocked-type-4))
                  (not (and (-> obj next-state) (let ((v1-41 (-> obj next-state name)))
                                                  (or (= v1-41 'knocked) (= v1-41 'jump) (= v1-41 'jump-land))
                                                  )
                            )
                       )
                  (zero? (get-rand-int obj 3))
                  (let ((f0-0 (vector-vector-distance-squared (-> obj root-override2 trans) (target-pos 0)))
                        (f1-0 32768.0)
                        )
                    (>= f0-0 (* f1-0 f1-0))
                    )
                  )
             (kill-prefer-falling obj)
             )
            ((or (= s5-1 (knocked-type knocked-type-4)) (= s5-1 (knocked-type knocked-type-6)))
             (set! (-> obj incoming knocked-type) (knocked-type knocked-type-0))
             (go (method-of-object obj knocked))
             )
            (else
              (go (method-of-object obj knocked))
              )
            )
          )
        )
       (else
         (go (method-of-object obj knocked))
         )
       )
     #t
     )
    (else
      ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod enemy-method-77 mantis ((obj mantis) (arg0 (pointer float)))
  (case (-> obj incoming knocked-type)
    (((knocked-type knocked-type-6))
     (ja-channel-push! 1 (seconds 0.02))
     (let ((a0-3 (-> obj skel root-channel 0)))
       (set! (-> a0-3 frame-group) (the-as art-joint-anim (-> obj draw art-group data 27)))
       (set! (-> a0-3 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 27)) frames num-frames) -1))
             )
       (set! (-> a0-3 param 1) (-> arg0 0))
       (set! (-> a0-3 frame-num) 0.0)
       (joint-control-channel-group! a0-3 (the-as art-joint-anim (-> obj draw art-group data 27)) num-func-seek!)
       )
     #t
     )
    (else
      (ja-channel-push! 1 (seconds 0.2))
      (let ((a0-5 (-> obj skel root-channel 0)))
        (set! (-> a0-5 frame-group) (the-as art-joint-anim (-> obj draw art-group data 10)))
        (set! (-> a0-5 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 10)) frames num-frames) -1))
              )
        (set! (-> a0-5 param 1) (-> arg0 0))
        (set! (-> a0-5 frame-num) 0.0)
        (joint-control-channel-group! a0-5 (the-as art-joint-anim (-> obj draw art-group data 10)) num-func-seek!)
        )
      #t
      )
    )
  )

(defmethod enemy-method-78 mantis ((obj mantis) (arg0 (pointer float)))
  (cond
    ((zero? (-> obj hit-points))
     (ja-channel-push! 1 (seconds 0.1))
     (let ((a0-2 (-> obj skel root-channel 0)))
       (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> obj draw art-group data 26)))
       (set! (-> a0-2 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 26)) frames num-frames) -1))
             )
       (set! (-> a0-2 param 1) (-> arg0 0))
       (set! (-> a0-2 frame-num) 0.0)
       (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> obj draw art-group data 26)) num-func-seek!)
       )
     #t
     )
    ((let ((v1-15 (-> obj incoming knocked-type)))
       (= v1-15 (knocked-type knocked-type-6))
       )
     (let ((a0-4 (-> obj skel root-channel 0)))
       (set! (-> a0-4 frame-group) (the-as art-joint-anim (-> obj draw art-group data 28)))
       (set! (-> a0-4 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 28)) frames num-frames) -1))
             )
       (set! (-> a0-4 param 1) (-> arg0 0))
       (set! (-> a0-4 frame-num) 0.0)
       (joint-control-channel-group! a0-4 (the-as art-joint-anim (-> obj draw art-group data 28)) num-func-seek!)
       )
     #t
     )
    (else
      (ja-channel-push! 1 (seconds 0.1))
      (let ((a0-6 (-> obj skel root-channel 0)))
        (set! (-> a0-6 frame-group) (the-as art-joint-anim (-> obj draw art-group data 11)))
        (set! (-> a0-6 param 0)
              (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 11)) frames num-frames) -1))
              )
        (set! (-> a0-6 param 1) (-> arg0 0))
        (set! (-> a0-6 frame-num) 0.0)
        (joint-control-channel-group! a0-6 (the-as art-joint-anim (-> obj draw art-group data 11)) num-func-seek!)
        )
      #t
      )
    )
  )

;; WARN: Return type mismatch symbol vs pat-surface.
(defmethod enemy-method-125 mantis ((obj mantis) (arg0 collide-query) (arg1 collide-spec) (arg2 float) (arg3 float) (arg4 float))
  (the-as
    pat-surface
    (when (find-ground (-> obj root-override2) arg0 arg1 arg2 arg3 arg4)
      (set! (-> obj root-override2 ground-pat) (-> arg0 best-other-tri pat))
      (when (>= (- (current-time) (-> obj gspot-timer)) (seconds 0.2))
        (let ((a1-2 (new 'stack-no-clear 'collide-query)))
          (set! (-> a1-2 start-pos quad) (-> obj root-override2 gspot-pos quad))
          (set! (-> a1-2 start-pos y) (+ 2048.0 (-> a1-2 start-pos y)))
          (set-vector! (-> a1-2 move-dist) 0.0 -6144.0 0.0 0.0)
          (let ((v1-10 a1-2))
            (set! (-> v1-10 radius) 4915.2)
            (set! (-> v1-10 collide-with) arg1)
            (set! (-> v1-10 ignore-process0) obj)
            (set! (-> v1-10 ignore-process1) #f)
            (set! (-> v1-10 ignore-pat) (-> obj root-override2 pat-ignore-mask))
            (set! (-> v1-10 action-mask) (collide-action solid))
            )
          (fill-using-line-sphere *collide-cache* a1-2)
          )
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (vector-reset! s5-1)
          (dotimes (s4-1 (-> *collide-cache* num-tris))
            (let* ((v1-16 (-> *collide-cache* tris s4-1))
                   (s2-1 (vector-! (new 'stack-no-clear 'vector) (-> v1-16 vertex 1) (the-as vector (-> v1-16 vertex))))
                   (s1-1 (vector-! (new 'stack-no-clear 'vector) (-> v1-16 vertex 2) (the-as vector (-> v1-16 vertex))))
                   (s3-0 (new 'stack-no-clear 'vector))
                   )
              (vector-normalize! s2-1 1.0)
              (vector-normalize! s1-1 1.0)
              (vector-cross! s3-0 s2-1 s1-1)
              (if (< (cos 10922.667) (vector-dot s3-0 *y-vector*))
                  (vector+! s5-1 s5-1 s3-0)
                  )
              )
            )
          (vector-normalize-copy! (-> obj gspot-normal) s5-1 1.0)
          )
        (set! (-> obj gspot-timer) (current-time))
        )
      #t
      )
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defmethod mantis-method-194 mantis ((obj mantis))
  (let ((a0-2 (nav-mesh-from-res-tag (-> obj entity) 'nav-mesh-actor 1))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (the-as symbol (and a0-2
                        (nav-mesh-method-10 a0-2 gp-0 (-> obj root-override2 trans) (the-as nav-poly #f))
                        (< (vector-vector-xz-distance gp-0 (-> obj root-override2 trans)) 2048.0)
                        )
            )
    )
  )

(defmethod mantis-method-193 mantis ((obj mantis) (arg0 vector))
  (with-pp
    (cond
      ((= (-> obj root-override2 gspot-pos y) -40959590.0)
       (set! (-> arg0 y) 0.0)
       (vector-normalize! arg0 1.0)
       (quaternion-set! (-> obj root-override2 quat) 0.0 (-> arg0 x) 0.0 (+ 1.0 (-> arg0 z)))
       (quaternion-normalize! (-> obj root-override2 quat))
       )
      (else
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (set! (-> s4-0 quad) (-> *up-vector* quad))
          (let ((s3-0 (new 'stack-no-clear 'quaternion)))
            (quaternion-from-two-vectors-max-angle! s3-0 s4-0 (-> obj gspot-normal) 10922.667)
            (vector-orient-by-quat! s4-0 s4-0 s3-0)
            )
          (let ((s3-1 (-> obj my-up-vector)))
            (vector-deg-seek s3-1 s3-1 s4-0 (* 8192.0 (-> pp clock seconds-per-frame)))
            (vector-normalize! s3-1 1.0)
            (set! (-> arg0 y) 0.0)
            (vector-normalize! arg0 1.0)
            (forward-up-nopitch->quaternion (-> obj root-override2 quat) arg0 s3-1)
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod nav-enemy-method-142 mantis ((obj mantis) (arg0 nav-control))
  (let ((t9-0 (method-of-object obj mantis-method-193))
        (a2-0 (-> arg0 state))
        (a1-1 (new 'stack-no-clear 'vector))
        )
    (set! (-> a1-1 quad) (-> a2-0 heading quad))
    (t9-0 obj a1-1)
    )
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod track-target! mantis ((obj mantis))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (local-vars (s5-0 vector))
  (let ((t9-0 (method-of-type nav-enemy track-target!)))
    (t9-0 obj)
    )
  (logclear! (-> obj flags) (mantis-flag tracked))
  (let ((a0-4 (handle->process (-> obj focus handle))))
    (set! s5-0 (when a0-4
                 (set! s5-0 (-> obj focus-pos))
                 (set! (-> s5-0 quad) (-> (get-trans (the-as process-focusable a0-4) 0) quad))
                 s5-0
                 )
          )
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod mantis-method-187 mantis ((obj mantis))
  (let ((s3-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
        (s4-0 (-> obj root-override2))
        (s5-0 (lambda ((arg0 mantis) (arg1 collide-shape-moving) (arg2 vector))
                (let ((s3-0 (new 'stack-no-clear 'vector))
                      (f30-0 (vector-length arg2))
                      )
                  (clamp-vector-to-mesh-cross-gaps
                    (-> arg0 nav)
                    (-> arg1 trans)
                    (-> arg0 nav state current-poly)
                    arg2
                    204.8
                    #f
                    (the-as clamp-travel-vector-to-mesh-return-info #f)
                    )
                  (vector+! s3-0 (-> arg1 trans) arg2)
                  (cond
                    ((< (vector-vector-xz-distance (-> arg1 trans) s3-0) (+ -8192.0 f30-0))
                     #f
                     )
                    ((let ((a1-5 (new 'stack-no-clear 'vector)))
                       (set! (-> a1-5 quad) (-> s3-0 quad))
                       (set! (-> a1-5 w) (-> arg0 root-override2 nav-radius))
                       (add-root-sphere-to-hash! (-> arg0 nav) a1-5 1134)
                       )
                     #f
                     )
                    (else
                      (let ((a1-6 (new 'stack-no-clear 'collide-query)))
                        (set! (-> a1-6 start-pos quad) (-> arg1 trans quad))
                        (set! (-> a1-6 move-dist quad) (-> arg2 quad))
                        (let ((v1-14 a1-6))
                          (set! (-> v1-14 radius) 2048.0)
                          (set! (-> v1-14 collide-with) (-> arg1 root-prim prim-core collide-with))
                          (set! (-> v1-14 ignore-process0) arg0)
                          (set! (-> v1-14 ignore-process1) #f)
                          (set! (-> v1-14 ignore-pat) (-> arg1 pat-ignore-mask))
                          (set! (-> v1-14 action-mask) (collide-action solid))
                          )
                        (if (>= (fill-and-probe-using-line-sphere *collide-cache* a1-6) 0.0)
                            #f
                            #t
                            )
                        )
                      )
                    )
                  )
                )
              )
        )
    (cond
      ((s5-0 obj s4-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 -40960.0))
       (go (method-of-object obj roll-right))
       )
      ((s5-0 obj s4-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 34160.64))
       (go (method-of-object obj roll-left))
       )
      )
    )
  (none)
  )

(defmethod mantis-method-188 mantis ((obj mantis))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (handle->process (-> obj focus handle))))
      (when s5-0
        (let* ((v1-4 (-> obj focus-pos))
               (s4-1 (vector-! (new 'stack-no-clear 'vector) v1-4 (-> obj root-override2 trans)))
               )
          (let ((s2-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (get-quat (the-as process-focusable s5-0) 0)))
                (s1-0 s4-1)
                )
            (let ((s3-1 s4-1))
              (let ((v1-10 (* 0.2 (vector-length (get-transv (the-as process-focusable s5-0))))))
                (.mov vf7 v1-10)
                )
              (.lvf vf5 (&-> s2-1 quad))
              (.lvf vf4 (&-> s3-1 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> s1-0 quad) vf6)
            )
          (mantis-method-191 obj (the-as vector s5-0) s4-1)
          )
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-stare mantis ((obj mantis))
  (let ((a0-2 (handle->process (-> obj focus handle))))
    (if (and a0-2
             (and (< 81920.0
                     (vector-vector-xz-distance (-> obj root-override2 trans) (get-trans (the-as process-focusable a0-2) 0))
                     )
                  (mantis-method-194 obj)
                  )
             )
        (go (method-of-object obj crawl))
        )
    )
  (go (method-of-object obj hop-away))
  (none)
  )

(defmethod mantis-method-190 mantis ((obj mantis) (arg0 vector) (arg1 vector))
  (let ((s5-0 (-> obj jump)))
    (let* ((f0-0 (vector-length arg1))
           (f0-1 (if (< 102400.0 f0-0)
                     81920.0
                     (+ -20480.0 f0-0)
                     )
                 )
           )
      (vector-normalize! arg1 f0-1)
      )
    (when (mantis-method-189 obj (-> s5-0 destination) arg1)
      (set! (-> s5-0 direction) (the-as uint 0))
      (set! (-> s5-0 start-anim) (the-as uint 12))
      (set! (-> s5-0 air-anim) (the-as uint 13))
      (set! (-> s5-0 land-anim) (the-as uint 0))
      (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag vulnerable))))
      (send-event obj 'jump 0 (-> s5-0 destination))
      )
    )
  0
  (none)
  )

(defmethod mantis-method-191 mantis ((obj mantis) (arg0 vector) (arg1 vector))
  (let ((s5-0 (-> obj jump)))
    (vector-length arg1)
    (vector-normalize! arg1 1.0)
    (vector-rotate-y! arg1 arg1 (* 182.04445 (get-rand-float-range obj -45.0 45.0)))
    (let ((a2-5
            (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 (* 4096.0 (get-rand-float-range obj -4.0 -6.0)))
            )
          )
      (when (mantis-method-189 obj (-> s5-0 destination) a2-5)
        (set! (-> s5-0 direction) (the-as uint 1))
        (set! (-> s5-0 start-anim) (the-as uint 14))
        (set! (-> s5-0 air-anim) (the-as uint 15))
        (set! (-> s5-0 land-anim) (the-as uint 16))
        (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag vulnerable))))
        (send-event obj 'jump 0 (-> s5-0 destination))
        )
      )
    )
  0
  )

(defmethod mantis-method-192 mantis ((obj mantis) (arg0 vector) (arg1 vector))
  (let ((s5-0 (-> obj jump)))
    (vector-length arg1)
    (vector-normalize! arg1 1.0)
    (vector-rotate-y! arg1 arg1 (* 182.04445 (get-rand-float-range obj -45.0 45.0)))
    (let ((a2-5
            (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 (* 4096.0 (get-rand-float-range obj -15.0 -22.0)))
            )
          )
      (when (mantis-method-189 obj (-> s5-0 destination) a2-5)
        (set! (-> s5-0 direction) (the-as uint 1))
        (set! (-> s5-0 start-anim) (the-as uint 20))
        (set! (-> s5-0 air-anim) (the-as uint 21))
        (set! (-> s5-0 land-anim) (the-as uint 22))
        (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag vulnerable))))
        (send-event obj 'jump 0 (-> s5-0 destination))
        )
      )
    )
  0
  (none)
  )

(defmethod mantis-method-189 mantis ((obj mantis) (arg0 vector) (arg1 vector))
  (let* ((s4-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) arg1 1.0))
         (f30-0 (vector-length arg1))
         (f28-0 3640.889)
         (f26-0 f28-0)
         (s3-1
           (lambda ((arg0 mantis) (arg1 vector) (arg2 float) (arg3 float) (arg4 vector))
             (local-vars (v0-3 vector))
             (let* ((s3-0 (-> arg0 root-override2 trans))
                    (a0-2 (vector-rotate-y! (new 'stack-no-clear 'vector) arg1 arg3))
                    (s5-1 (vector+float*! (new 'stack-no-clear 'vector) s3-0 a0-2 arg2))
                    (s2-0 (new 'stack-no-clear 'vector))
                    )
               (cloest-point-on-mesh (-> arg0 nav) s5-1 s5-1 (the-as nav-poly #f))
               (vector-! s2-0 s5-1 s3-0)
               (clamp-vector-to-mesh-cross-gaps
                 (-> arg0 nav)
                 s3-0
                 (-> arg0 nav state current-poly)
                 s2-0
                 204.8
                 #f
                 (the-as clamp-travel-vector-to-mesh-return-info #f)
                 )
               (when (< 0.8 (/ (vector-length s2-0) arg2))
                 (vector+! s5-1 s3-0 s2-0)
                 (let ((a1-7 (new 'stack-no-clear 'collide-query)))
                   (set! (-> a1-7 start-pos quad) (-> s3-0 quad))
                   (set! (-> a1-7 move-dist quad) (-> s2-0 quad))
                   (+! (-> a1-7 start-pos y) (* 1.5 (-> arg0 enemy-info-override jump-height-min)))
                   (let ((v1-17 a1-7))
                     (set! (-> v1-17 radius) 409.6)
                     (set! (-> v1-17 collide-with) (collide-spec backgnd))
                     (set! (-> v1-17 ignore-process0) #f)
                     (set! (-> v1-17 ignore-process1) #f)
                     (set! (-> v1-17 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                     (set! (-> v1-17 action-mask) (collide-action solid))
                     )
                   (when (< (fill-and-probe-using-line-sphere *collide-cache* a1-7) 0.0)
                     (set! (-> s5-1 w) (-> arg0 root-override2 nav-radius))
                     (when (not (add-root-sphere-to-hash! (-> arg0 nav) s5-1 #x8046e))
                       (set! (-> arg4 quad) (-> s5-1 quad))
                       (return arg4)
                       v0-3
                       )
                     )
                   )
                 )
               )
             )
           )
         )
    (cond
      ((s3-1 obj s4-0 f30-0 0.0 arg0)
       #t
       )
      (else
        (dotimes (s2-0 2)
          (if (or (s3-1 obj s4-0 f30-0 f26-0 arg0) (s3-1 obj s4-0 f30-0 (- f26-0) arg0))
              (return #t)
              )
          (+! f26-0 f28-0)
          )
        #f
        )
      )
    )
  )

(defmethod enemy-method-89 mantis ((obj mantis) (arg0 enemy-jump-info))
  (ja-channel-push! 1 (seconds 0.1))
  (let ((a1-2 (-> obj draw art-group data (-> obj jump start-anim)))
        (a0-4 (-> obj skel root-channel 0))
        )
    (set! (-> a0-4 frame-group) (the-as art-joint-anim a1-2))
    (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim a1-2) frames num-frames) -1)))
    (set! (-> a0-4 param 1) (-> arg0 anim-speed))
    (set! (-> a0-4 frame-num) 0.0)
    (joint-control-channel-group! a0-4 (the-as art-joint-anim a1-2) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-87 mantis ((obj mantis) (arg0 enemy-jump-info))
  (ja-channel-push! 1 (seconds 0.1))
  (let ((a1-2 (-> obj draw art-group data (-> obj jump air-anim)))
        (a0-4 (-> obj skel root-channel 0))
        )
    (set! (-> a0-4 frame-group) (the-as art-joint-anim a1-2))
    (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim a1-2) frames num-frames) -1)))
    (set! (-> a0-4 param 1) (-> arg0 anim-speed))
    (set! (-> a0-4 frame-num) 0.0)
    (joint-control-channel-group! a0-4 (the-as art-joint-anim a1-2) num-func-seek!)
    )
  #t
  )

;; WARN: Return type mismatch quaternion vs none.
(defmethod enemy-method-92 mantis ((obj mantis) (arg0 int) (arg1 nav-poly))
  "TODO - nav-poly is a guess
@abstract"
  (let ((v1-0 arg0))
    (when (or (zero? v1-0) (= v1-0 1) (= v1-0 2) (= v1-0 3))
      (let ((a0-4 obj))
        (when (logtest? (enemy-flag enemy-flag37) (-> a0-4 enemy-flags))
          (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> arg1 vertex2) (-> obj root-override2 trans))))
            (vector-normalize! s5-1 1.0)
            (let ((v1-5 (-> obj jump direction)))
              (cond
                ((zero? v1-5)
                 )
                ((= v1-5 1)
                 (vector-negate! s5-1 s5-1)
                 )
                ((= v1-5 2)
                 (vector-rotate-y! s5-1 s5-1 -16384.0)
                 )
                ((= v1-5 3)
                 (vector-rotate-y! s5-1 s5-1 16384.0)
                 )
                )
              )
            (seek-toward-heading-vec! (-> obj root-override2) s5-1 (-> obj nav max-rotation-rate) (seconds 0.02))
            )
          )
        )
      )
    )
  (none)
  )

(defmethod enemy-method-88 mantis ((obj mantis) (arg0 enemy-jump-info))
  (cond
    ((zero? (-> obj jump land-anim))
     #f
     )
    (else
      (ja-channel-push! 1 (seconds 0.075))
      (let ((a1-2 (-> obj draw art-group data (-> obj jump land-anim)))
            (a0-4 (-> obj skel root-channel 0))
            )
        (set! (-> a0-4 frame-group) (the-as art-joint-anim a1-2))
        (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim a1-2) frames num-frames) -1)))
        (set! (-> a0-4 param 1) (-> arg0 anim-speed))
        (set! (-> a0-4 frame-num) 0.0)
        (joint-control-channel-group! a0-4 (the-as art-joint-anim a1-2) num-func-seek!)
        )
      #t
      )
    )
  )

(defmethod coin-flip? mantis ((obj mantis))
  "@returns The result of a 50/50 RNG roll"
  #f
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-enemy-collision! mantis ((obj mantis))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 8) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 9))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak bot crate obstacle hit-by-others-list player-list)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid can-ride deadly no-standon))
      (set-vector! (-> s4-0 local-sphere) 0.0 6144.0 0.0 17408.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-13 prim-core collide-with)
            (collide-spec backgnd jak bot crate obstacle hit-by-others-list player-list)
            )
      (set! (-> v1-13 prim-core action) (collide-action solid can-ride deadly no-standon))
      (set-vector! (-> v1-13 local-sphere) 0.0 4915.2 0.0 4915.2)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 7)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 13)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 10)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-21 prim-core action) (collide-action solid deadly))
      (set! (-> v1-21 transform-index) 24)
      (set-vector! (-> v1-21 local-sphere) 0.0 0.0 0.0 2457.6)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-23 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-23 prim-core action) (collide-action solid deadly))
      (set! (-> v1-23 transform-index) 19)
      (set-vector! (-> v1-23 local-sphere) 0.0 0.0 0.0 2457.6)
      )
    (let ((v1-25 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-25 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-25 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-25 prim-core action) (collide-action solid deadly))
      (set! (-> v1-25 transform-index) 27)
      (set-vector! (-> v1-25 local-sphere) 0.0 0.0 0.0 1228.8)
      )
    (let ((v1-27 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-27 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-27 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-27 prim-core action) (collide-action solid deadly))
      (set! (-> v1-27 transform-index) 28)
      (set-vector! (-> v1-27 local-sphere) 0.0 0.0 0.0 2048.0)
      )
    (set! (-> s5-0 nav-radius) 8192.0)
    (let ((v1-29 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-29 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-29 prim-core collide-with))
      )
    (set! (-> obj root-override2) s5-0)
    )
  (none)
  )

(defmethod init-enemy! mantis ((obj mantis))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mantis" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-enemy-behaviour-and-stats! obj *mantis-nav-enemy-info*)
  (set! (-> obj flags) (mantis-flag))
  (set! (-> obj my-up-vector quad) (-> *y-vector* quad))
  (set! (-> obj gspot-normal quad) (-> *y-vector* quad))
  (set! (-> obj gspot-timer) 0)
  (set! (-> obj attack-timer) (+ (current-time) (seconds -5)))
  (set! (-> obj track-timer) 0)
  (set! (-> obj draw light-index) (the-as uint 30))
  (none)
  )
