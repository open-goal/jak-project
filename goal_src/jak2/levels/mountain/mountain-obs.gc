;;-*-Lisp-*-
(in-package goal)

;; name: mountain-obs.gc
;; name in dgo: mountain-obs
;; dgos: MTN

(defenum mtn-plat-flags
  :bitfield #t
  :type uint16
  (mtpflags-0)
  (mtpflags-1)
  (mtpflags-2)
  (mtpflags-3)
  )

;; DECOMP BEGINS

(define *dice-back-way-num* 0)

(define *dice-back-way* (new 'static 'boxed-array :type vector
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          )
        )

(defskelgroup skel-mtn-dice-button mtn-dice-button mtn-dice-button-lod0-jg mtn-dice-button-idle-ja
              ((mtn-dice-button-lod0-mg (meters 20)) (mtn-dice-button-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1)
              )

(deftype mtn-dice-button (basebutton)
  ()
  )


(defmethod basebutton-method-33 ((this mtn-dice-button))
  "TODO - joint stuff"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-dice-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> this button-status) (button-status pressed))
     (let ((s5-1 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> this draw art-group data 3))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 3)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> this draw art-group data 3))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (transform-post)
  (none)
  )

(defmethod basebutton-method-34 ((this mtn-dice-button))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod prepare-trigger-event! ((this mtn-dice-button))
  "Sets `event-going-down` to `'trigger`"
  (logior! (-> this button-status) (button-status button-status-4))
  (logior! (-> this button-status) (button-status pressed))
  (set! (-> this event-going-down) 'trigger)
  0
  (none)
  )

(defstate down-idle (mtn-dice-button)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton down-idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton down-idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (if (and (not (task-node-closed? (game-task-node mountain-shard-dice))) (< 1 *dice-back-way-num*))
        (go-virtual going-up)
        )
    )
  )

(defstate going-down (mtn-dice-button)
  :virtual #t
  :enter (behavior ()
    (sound-play "dice-button")
    (press! self #t)
    )
  )

(define *dice-position-array* (new 'static 'boxed-array :type vector
                                (new 'static 'vector :z 8192.0 :w 1.0)
                                (new 'static 'vector :z -8192.0 :w 1.0)
                                (new 'static 'vector :x 8192.0 :w 1.0)
                                (new 'static 'vector :x -8192.0 :w 1.0)
                                (new 'static 'vector :y -8192.0 :w 1.0)
                                (new 'static 'vector :y 8192.0 :w 1.0)
                                )
        )

(define *dice-angle-array* (new 'static 'boxed-array :type vector
                             (new 'static 'vector :y 16384.0)
                             (new 'static 'vector :y -16384.0)
                             (new 'static 'vector :z 32768.0)
                             (new 'static 'vector)
                             (new 'static 'vector :z 16384.0)
                             (new 'static 'vector :z -16384.0)
                             )
        )

(define *dice-offset-x* -663)

(define *dice-offset-z* -30)

(define *dice-world-array* (new 'static 'boxed-array :type uint16
                             #xffff
                             #xffc7
                             #x8007
                             #x7
                             #x3
                             #x3
                             #x7
                             #x8007
                             #xc007
                             #xe003
                             #xe003
                             #xe003
                             #xe003
                             #xe003
                             #xc003
                             #x8003
                             #x7
                             #xf
                             #xf
                             #xf00f
                             #xfc1f
                             #xfe3f
                             #xff3f
                             #xff3f
                             )
        )

(define *dice-good-way-array* (new 'static 'boxed-array :type uint16
                                #x0
                                #x100
                                #x100
                                #x1e0
                                #xe0
                                #xf0
                                #x30
                                #x38
                                #x18
                                #x18
                                #x78
                                #x70
                                #x70
                                #x40
                                #xc0
                                #x80
                                #x80
                                #x80
                                #x3c0
                                #x780
                                #x3e0
                                #x100
                                #x0
                                #x0
                                )
        )

(define *dice-blocked-array* (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 26))

(define *dice-last-safe-position* (new 'static 'vector :x -2603417.5 :y 384983.03 :z -107683.84 :w 1.0))

(defpart 1491
  :init-specs ((:texture (glow-hotdot effects))
    (:num 1.0)
    (:scale-x (meters 1))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 128.0 64.0)
    (:b 128.0 64.0)
    (:a 128.0)
    (:vel-x (meters -0.006666667) (meters 0.006666667))
    (:vel-z (meters -0.006666667) (meters 0.006666667))
    (:rotvel-z (degrees 0.3))
    (:fade-g -0.4)
    (:fade-b -0.4)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    )
  )

(defun dice-wrong-way? ()
  (dotimes (v1-0 24)
    (if (nonzero? (logclear (-> *dice-blocked-array* v1-0) (-> *dice-good-way-array* v1-0)))
        (return #t)
        )
    )
  #f
  )

(deftype mtn-dice (process-drawable)
  ((root                collide-shape-moving :override)
   (incoming-attack-id  uint32)
   (watervol            entity-actor)
   (face-matrix         matrix                6 :inline)
   (face-matrix-back    matrix                6 :inline)
   (face-status         int32                 6)
   (time-anim           float)
   (speed-anim          float)
   (rot-axis            vector                :inline)
   (rot-org             vector                :inline)
   (first               uint32)
   (active              uint32)
   (free-face           uint32)
   (color               vector                :inline)
   (punch-anim          symbol)
   (first-touch-time    time-frame)
   (curtime             time-frame)
   (hint-count          float)
   )
  (:state-methods
    idle
    idle-done
    animate
    fall
    restart
    )
  (:methods
    (mtn-dice-method-25 (_type_ int) none)
    (mtn-dice-method-26 (_type_ process-focusable touching-shapes-entry) touching-prims-entry)
    (mtn-dice-method-27 (_type_ collide-shape process-focusable touching-shapes-entry) none)
    )
  )


(defskelgroup skel-mtn-dice mtn-dice mtn-dice-lod0-jg mtn-dice-idle-ja
              ((mtn-dice-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100)
              )

(defmethod mtn-dice-method-25 ((this mtn-dice) (arg0 int))
  (let ((s4-0 (-> this face-matrix arg0)))
    (dotimes (s3-0 6)
      (let* ((v1-4 (-> this face-matrix s3-0))
             (f0-2 (fabs (vector-dot (the-as vector s4-0) (the-as vector v1-4))))
             )
        (when (and (!= s3-0 arg0) (zero? (-> this face-status s3-0)) (< f0-2 0.001))
          (set! (-> this face-status s3-0) 1)
          (mtn-dice-method-25 this s3-0)
          )
        )
      )
    )
  0
  (none)
  )

(defstate restart (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self time-anim) 0.0)
    (set! (-> self speed-anim) 0.0)
    (dotimes (v1-0 6)
      (let* ((a0-2 (-> self face-matrix-back v1-0))
             (t0-0 (-> self face-matrix v1-0))
             (a1-2 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-2 quad 0) a1-2)
        (set! (-> a0-2 quad 1) a2-0)
        (set! (-> a0-2 quad 2) a3-0)
        (set! (-> a0-2 trans quad) t0-1)
        )
      )
    (sound-play "dice-sink")
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (cond
      ((time-elapsed? (-> self state-time) (seconds 0.5))
       (+! (-> self speed-anim) (* -0.5 (seconds-per-frame) (-> self time-anim)))
       (+! (-> self speed-anim) (* -6.0 (seconds-per-frame) (-> self speed-anim)))
       (+! (-> self time-anim) (-> self speed-anim))
       )
      (else
        (set! (-> self draw color-mult quad) (-> self color quad))
        (set! (-> self speed-anim) (- (-> self speed-anim) (* 2.0 (seconds-per-frame))))
        (+! (-> self time-anim) (-> self speed-anim))
        (set! (-> self active) (the-as uint 3))
        )
      )
    (when (and (time-elapsed? (-> self state-time) (seconds 0.5)) (!= (-> self active) 2))
      (set! (-> self active) (the-as uint 2))
      (dotimes (gp-0 6)
        (matrix-rotate-xyz! (-> self face-matrix gp-0) (-> *dice-angle-array* gp-0))
        (set! (-> self face-matrix gp-0 trans quad) (-> *dice-position-array* gp-0 quad))
        (vector+! (-> self face-matrix gp-0 trans) (-> self face-matrix gp-0 trans) (-> self root trans))
        (+! (-> self face-matrix gp-0 trans y) 8192.0)
        (let* ((v1-40 (-> self face-matrix-back gp-0))
               (a3-0 (-> self face-matrix gp-0))
               (a0-18 (-> a3-0 quad 0))
               (a1-5 (-> a3-0 quad 1))
               (a2-0 (-> a3-0 quad 2))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> v1-40 quad 0) a0-18)
          (set! (-> v1-40 quad 1) a1-5)
          (set! (-> v1-40 quad 2) a2-0)
          (set! (-> v1-40 trans quad) a3-1)
          )
        (set! (-> self face-status gp-0) 0)
        (let ((v1-44 (-> self root root-prim)))
          (logclear! (-> (the-as collide-shape-prim-group v1-44) child gp-0 prim-core action) (collide-action rideable))
          )
        )
      (set-vector! (-> self color) 0.5 0.5 0.5 1.0)
      (set! (-> self free-face) (the-as uint 6))
      )
    (dotimes (v1-51 6)
      (set! (-> self face-matrix v1-51 trans y)
            (+ (-> self face-matrix-back v1-51 trans y) (* 4096.0 (-> self time-anim)))
            )
      )
    (when (time-elapsed? (-> self state-time) (seconds 2))
      (set! (-> self active) (-> self first))
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post transform-post
  )

(defmethod mtn-dice-method-26 ((this mtn-dice) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (sv-96 vector) (sv-112 vector) (sv-128 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s3-0 (-> arg0 root))
           (s4-0 (if (type? s3-0 collide-shape)
                     s3-0
                     )
                 )
           )
      (when s4-0
        (let ((s3-1 (new 'stack-no-clear 'vector))
              (f30-0 -0.71)
              (s2-0 (the-as touching-prims-entry #f))
              )
          (let ((s0-0 vector-z-quaternion!))
            (set! sv-96 s3-1)
            (let ((a1-3 (get-quat arg0 2)))
              (s0-0 sv-96 a1-3)
              )
            )
          (let ((s1-1 (-> arg1 head)))
            (while s1-1
              (let ((v1-4 (get-touched-prim s1-1 (-> this root) arg1)))
                (-> v1-4 cshape)
                (set! sv-128 (new 'stack-no-clear 'vector))
                (set! (-> sv-128 quad) (the-as uint128 0))
                (set! sv-112 (new 'stack-no-clear 'vector))
                (let ((s0-1 (new 'stack-no-clear 'vector)))
                  (new 'stack-no-clear 'vector)
                  (when (>= (-> this face-status (-> v1-4 prim-id)) 0)
                    (set! (-> sv-128 quad) (-> this face-matrix (-> v1-4 prim-id) quad 0))
                    (set! (-> sv-128 w) (- (vector-dot (-> this face-matrix (-> v1-4 prim-id) trans) sv-128)))
                    (set! (-> sv-112 quad) (-> this face-matrix (-> v1-4 prim-id) trans quad))
                    (let ((f0-4 (vector4-dot sv-128 (-> s4-0 trans)))
                          (f28-0 (vector-dot sv-128 s3-1))
                          )
                      (when (< f0-4 0.0)
                        (let ((a2-2 s0-1))
                          (let ((a0-28 sv-112))
                            (let ((a1-18 sv-128))
                              (let ((a3-1 -8192.0))
                                (.mov vf7 a3-1)
                                )
                              (.lvf vf5 (&-> a1-18 quad))
                              )
                            (.lvf vf4 (&-> a0-28 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a2-2 quad) vf6)
                          )
                        (let* ((a0-30 (the int (/ (-> s0-1 x) METER_LENGTH)))
                               (a1-20 (the int (/ (-> s0-1 z) METER_LENGTH)))
                               (a0-32 (/ (- *dice-offset-x* a0-30) -4))
                               )
                          (if (not (logtest? (-> *dice-blocked-array* (/ (- *dice-offset-z* a1-20) -4)) (ash 1 (- 15 a0-32))))
                              (set! f28-0 -2.0)
                              )
                          )
                        (let ((a0-40 sv-112))
                          (let ((v1-8 (-> this face-matrix (-> v1-4 prim-id) trans)))
                            (let ((a1-26 sv-128))
                              (let ((a2-10 16384.0))
                                (.mov vf7 a2-10)
                                )
                              (.lvf vf5 (&-> a1-26 quad))
                              )
                            (.lvf vf4 (&-> v1-8 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a0-40 quad) vf6)
                          )
                        (vector-negate-in-place! sv-128)
                        (set! f28-0 (- f28-0))
                        (if (!= (-> this free-face) 5)
                            (set! f28-0 1.0)
                            )
                        )
                      (let ((v1-13 s0-1))
                        (let ((a0-44 -8192.0))
                          (.mov vf7 a0-44)
                          )
                        (.lvf vf5 (&-> sv-128 quad))
                        (.lvf vf4 (&-> sv-112 quad))
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> v1-13 quad) vf6)
                        )
                      (let* ((v1-15 (the int (/ (-> s0-1 x) METER_LENGTH)))
                             (a0-48 (the int (/ (-> s0-1 z) METER_LENGTH)))
                             (v1-17 (/ (- *dice-offset-x* v1-15) -4))
                             (a1-31 (/ (- *dice-offset-z* a0-48) -4))
                             )
                        (when (and (< f28-0 f30-0) (not (logtest? (-> *dice-world-array* a1-31) (ash 1 (- 15 v1-17)))))
                          (set! f30-0 f28-0)
                          (set! s2-0 s1-1)
                          )
                        )
                      )
                    )
                  )
                )
              (set! s1-1 (-> s1-1 next))
              )
            )
          s2-0
          )
        )
      )
    )
  )

(defmethod mtn-dice-method-27 ((this mtn-dice) (arg0 collide-shape) (arg1 process-focusable) (arg2 touching-shapes-entry))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s3-0 (-> arg1 root))
           (s0-0 (if (type? s3-0 collide-shape)
                     s3-0
                     )
                 )
           )
      (when s0-0
        (let ((s5-1 ((method-of-type touching-prims-entry get-touched-prim)
                     (the-as touching-prims-entry arg0)
                     (-> this root)
                     arg2
                     )
                    )
              )
          (-> s5-1 cshape)
          (let ((s1-0 (new-stack-vector0))
                (s2-0 (new-stack-vector0))
                (s3-1 (new 'stack-no-clear 'vector))
                (s4-1 (new 'stack-no-clear 'vector))
                )
            (let ((v1-6 (-> this face-matrix (-> s5-1 prim-id))))
              (set! (-> s1-0 quad) (-> v1-6 vector 0 quad))
              (set! (-> s1-0 w) (- (vector-dot (-> v1-6 trans) s1-0)))
              (set! (-> s4-1 quad) (-> v1-6 trans quad))
              (when (< (vector4-dot s1-0 (-> s0-0 trans)) 0.0)
                (let ((a0-10 s4-1))
                  (let ((v1-7 (-> v1-6 trans)))
                    (let ((a1-9 s1-0))
                      (let ((a2-3 16384.0))
                        (.mov vf7 a2-3)
                        )
                      (.lvf vf5 (&-> a1-9 quad))
                      )
                    (.lvf vf4 (&-> v1-7 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a0-10 quad) vf6)
                  )
                (vector-negate-in-place! s1-0)
                )
              )
            (+! (-> s4-1 y) -8192.0)
            (set! (-> s2-0 y) 1.0)
            (vector-cross! s3-1 s2-0 s1-0)
            (vector-normalize! s3-1 1.0)
            (set! (-> this rot-axis quad) (-> s3-1 quad))
            (set! (-> this rot-org quad) (-> s4-1 quad))
            )
          (set! (-> this face-status (-> s5-1 prim-id)) 1)
          (mtn-dice-method-25 this (the-as int (-> s5-1 prim-id)))
          )
        )
      )
    0
    (none)
    )
  )

(deftype mtn-dice-info (structure)
  ((mat  float  12)
   )
  )


(define *mtn-dice-done-info*
  (new 'static 'boxed-array :type mtn-dice-info
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2584575.8 376831.97 172032.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 -0.9999 -0.9999 0.0 0.0 -2617343.2 376831.5 204800.06)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2600959.5 376831.66 204800.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2600959.8 376831.75 172032.06)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2584575.8 376832.0 155648.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2600959.5 376831.72 188416.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2600959.8 376831.97 -73728.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2568191.5 376832.0 -73727.945)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 -1.0 -1.0 0.0 0.0 -2584575.8 376832.0 -73727.96)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2551807.2 376832.0 -73727.9)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2600959.8 376832.0 -90112.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2551807.2 376832.25 -57343.875)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2551807.8 376832.0 -24576.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2519039.2 376832.0 -8191.963)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 -1.0 -1.0 0.0 0.0 -2535423.5 376832.0 -24575.994)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2519039.2 376831.97 8192.031)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2551807.8 376832.0 -40960.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 -0.9999 -0.9999 0.0 0.0 -2535423.5 376831.97 -8191.9688)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2519039.8 376832.0 40960.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2551807.5 376832.0 40960.047)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2568191.2 376831.75 57344.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2535423.5 376832.0 40960.004)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2519039.8 376832.0 24576.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 1.0 -2551807.5 376831.97 57344.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2568191.8 376831.97 90112.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.9999 0.0 0.0 0.0 0.0 -0.9999 -2584575.8 376831.72 122880.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2584575.5 376831.72 139264.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.9999 0.0 0.0 0.0 0.0 -0.9999 -2584575.8 376831.75 106496.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2568191.8 376832.0 73728.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.9999 0.0 0.0 0.0 0.0 -1.0 -2568191.8 376831.94 106496.0)
      )
    )
  )

(defstate idle (mtn-dice)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (sv-192 vector))
    (cond
      ((= message 'print-info)
       (dotimes (gp-1 6)
         (let ((s5-1 (-> self face-matrix gp-1)))
           (format #t "(static-mtn-dice-info (")
           (format #t "~F ~F ~F " (-> s5-1 vector 0 x) (-> s5-1 vector 0 y) (-> s5-1 vector 0 z))
           (format #t "~F ~F ~F " (-> s5-1 vector 1 x) (-> s5-1 vector 1 y) (-> s5-1 vector 1 z))
           (format #t "~F ~F ~F " (-> s5-1 vector 2 x) (-> s5-1 vector 2 y) (-> s5-1 vector 2 z))
           (format #t "~F ~F ~F " (-> s5-1 trans x) (-> s5-1 trans y) (-> s5-1 trans z))
           )
         (format #t "))~%")
         )
       #f
       )
      ((= message 'trigger)
       (mem-set32! (the-as pointer *dice-blocked-array*) 13 0)
       (set! (-> *dice-blocked-array* 1) (the-as uint 256))
       (set! *dice-back-way-num* 0)
       (set-vector! *dice-last-safe-position* -2603417.5 384983.03 -107683.84 1.0)
       (if (and (= (-> self free-face) 5) (= (-> self active) 1))
           (set! (-> self active) (-> self first))
           )
       (if (or (< (-> self free-face) (the-as uint 5)) (= (-> self active) 3))
           (go-virtual restart)
           )
       )
      ((= message 'hint)
       (when (>= (-> self hint-count) 0.0)
         (+! (-> self hint-count) (seconds-per-frame))
         (if (< 6.0 (-> self hint-count))
             (talker-spawn-func (-> *talker-speech* 61) *entity-pool* (target-pos 0) (the-as region #f))
             )
         )
       )
      ((= message 'touch)
       (let* ((s3-0 proc)
              (s2-0 proc)
              (s4-1 (if (type? s2-0 process-focusable)
                        (the-as process-focusable s2-0)
                        )
                    )
              (s2-1 (-> (the-as process-focusable s3-0) root))
              (s3-1 (if (type? s2-1 collide-shape)
                        s2-1
                        )
                    )
              )
         (when s3-1
           (let* ((s2-2 (the-as object (-> block param 0)))
                  (s1-0 (-> (the-as touching-shapes-entry s2-2) head))
                  )
             (while s1-0
               (let ((s0-0 (get-touched-tri s1-0 (-> self root) (the-as touching-shapes-entry s2-2)))
                     (a1-13 (get-touched-prim s1-0 (-> self root) (the-as touching-shapes-entry s2-2)))
                     (v1-30 (new 'stack-no-clear 'matrix))
                     )
                 (let* ((a3-6 (-> self node-list data (+ (-> a1-13 prim-id) 4) bone transform))
                        (a0-26 (-> a3-6 quad 0))
                        (a1-17 (-> a3-6 quad 1))
                        (a2-9 (-> a3-6 quad 2))
                        (a3-7 (-> a3-6 trans quad))
                        )
                   (set! (-> v1-30 quad 0) a0-26)
                   (set! (-> v1-30 quad 1) a1-17)
                   (set! (-> v1-30 quad 2) a2-9)
                   (set! (-> v1-30 trans quad) a3-7)
                   )
                 (when s0-0
                   (when (and (< 0.9 (-> s0-0 normal y)) (< (-> v1-30 vector 0 y) -0.9))
                     (when (< (vector-dot
                                (vector-! (new 'stack-no-clear 'vector) (-> s3-1 trans) (the-as vector (-> s0-0 vertex)))
                                (-> s0-0 normal)
                                )
                              409.6
                              )
                       (when s4-1
                         (let ((s0-1 (new 'stack-no-clear 'vector)))
                           (set! sv-192 *dice-last-safe-position*)
                           (let* ((v1-42 (get-trans s4-1 0))
                                  (s0-2 (vector-! s0-1 sv-192 v1-42))
                                  )
                             (vector-float*! s0-2 s0-2 0.5)
                             (send-event proc 'shove (-> block param 0) (static-attack-info ((id (new-attack-id)) (vector s0-2))))
                             )
                           )
                         )
                       )
                     )
                   )
                 )
               (set! s1-0 (-> s1-0 next))
               )
             )
           #f
           )
         )
       )
      ((= message 'attack)
       (when (= (-> self active) 1)
         (let ((v1-56 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-56) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-56) id))
             (let ((s3-2 proc)
                   (s4-2 (if (type? proc process-focusable)
                             (the-as process-focusable proc)
                             )
                         )
                   )
               (let ((s5-3 (-> (the-as process-focusable s3-2) root)))
                 (if (type? s5-3 collide-shape)
                     (empty)
                     )
                 )
               (let* ((gp-3 (-> block param 0))
                      (a1-26 (mtn-dice-method-26 self s4-2 (the-as touching-shapes-entry gp-3)))
                      )
                 (cond
                   (a1-26
                     (mtn-dice-method-27 self (the-as collide-shape a1-26) s4-2 (the-as touching-shapes-entry gp-3))
                     (set! (-> self punch-anim) #t)
                     (sound-play "dice-hit")
                     (set! (-> self hint-count) -1.0)
                     (go-virtual animate)
                     'push
                     )
                   (else
                     (set! (-> self incoming-attack-id) (the-as uint 0))
                     #f
                     )
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self curtime) 0)
    (set! (-> self first-touch-time) 0)
    0
    )
  :trans (behavior ()
    (if (nonzero? (-> self curtime))
        (set-time! (-> self first-touch-time))
        )
    (set-time! (-> self curtime))
    (when (and (zero? (-> self active)) (dice-wrong-way?))
      )
    )
  :code sleep-code
  :post (behavior ()
    (rider-trans)
    (if (= (-> self active) 1)
        (set! (-> self color x) (fmin 1.0 (+ (-> self color x) (* 2.0 (seconds-per-frame)))))
        (set! (-> self color x) (fmax 0.5 (- (-> self color x) (* 2.0 (seconds-per-frame)))))
        )
    (set! (-> self color y) (-> self color x))
    (set! (-> self color z) (-> self color x))
    (set! (-> self draw color-mult quad) (-> self color quad))
    (when (zero? (-> self active))
      (let* ((v1-15 (the int (/ (-> self root trans x) METER_LENGTH)))
             (a0-5 (the int (/ (-> self root trans z) METER_LENGTH)))
             (s5-0 (/ (- *dice-offset-x* v1-15) -4))
             (gp-0 (/ (- *dice-offset-z* a0-5) -4))
             )
        (when (or (logtest? (-> *dice-blocked-array* (+ gp-0 1)) (ash 1 (- 15 s5-0)))
                  (logtest? (-> *dice-blocked-array* (+ gp-0 -1)) (ash 1 (- 15 s5-0)))
                  (logtest? (-> *dice-blocked-array* gp-0) (ash 1 (- 15 (+ s5-0 1))))
                  (logtest? (-> *dice-blocked-array* gp-0) (ash 1 (- 15 (+ s5-0 -1))))
                  )
          (when (> *dice-back-way-num* 0)
            (set! (-> *dice-last-safe-position* quad) (-> *dice-back-way* (+ *dice-back-way-num* -1) quad))
            (+! (-> *dice-last-safe-position* y) 8192.0)
            )
          (when (not (dice-wrong-way?))
            (set! (-> *dice-back-way* *dice-back-way-num* quad) (-> self root trans quad))
            (set! *dice-back-way-num* (+ *dice-back-way-num* 1))
            )
          (set! (-> *dice-blocked-array* gp-0)
                (the-as uint (logior (ash 1 (- 15 s5-0)) (-> *dice-blocked-array* gp-0)))
                )
          (set! (-> self active) (the-as uint 1))
          )
        )
      )
    (when (= (-> self first) 1)
      )
    (rider-post)
    )
  )

(defstate idle-done (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self curtime) 0)
    (set! (-> self first-touch-time) 0)
    0
    )
  :trans (behavior ()
    '()
    )
  :code sleep-code
  :post (behavior ()
    (rider-trans)
    (rider-post)
    )
  )

(defstate animate (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (dotimes (v1-0 6)
      (let* ((a0-2 (-> self face-matrix-back v1-0))
             (t0-0 (-> self face-matrix v1-0))
             (a1-2 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-2 quad 0) a1-2)
        (set! (-> a0-2 quad 1) a2-0)
        (set! (-> a0-2 quad 2) a3-0)
        (set! (-> a0-2 trans quad) t0-1)
        )
      )
    (set-time! (-> self state-time))
    (set! (-> self time-anim) 1.0)
    (set! (-> self speed-anim) -0.5)
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (cond
      ((-> self punch-anim)
       (+! (-> self speed-anim) (* -4.0 (seconds-per-frame) (-> self time-anim)))
       (+! (-> self speed-anim) (* -16.0 (seconds-per-frame) (-> self speed-anim)))
       )
      (else
        (+! (-> self speed-anim) (* -3.0 (seconds-per-frame) (-> self time-anim)))
        (+! (-> self speed-anim) (* -20.0 (seconds-per-frame) (-> self speed-anim)))
        )
      )
    (+! (-> self time-anim) (-> self speed-anim))
    (when (< (-> self time-anim) 0.0)
      (set! (-> self time-anim) 0.0)
      (set! (-> self speed-anim) (- (-> self speed-anim)))
      )
    (if (time-elapsed? (-> self state-time) (seconds 0.7))
        (set! (-> self time-anim) 0.0)
        )
    (let ((s4-0 (new 'stack-no-clear 'matrix))
          (s5-0 (new 'stack-no-clear 'matrix))
          (gp-0 (new 'stack-no-clear 'matrix))
          )
      (let ((f0-16 (- 1.0 (-> self time-anim)))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (matrix-axis-angle! s4-0 (-> self rot-axis) (* 16384.0 f0-16))
        (vector-negate! s3-0 (-> self rot-org))
        (matrix-translate! s5-0 s3-0)
        )
      (matrix<-trans s4-0 (-> self rot-org))
      (matrix*! gp-0 s5-0 s4-0)
      (dotimes (s5-1 6)
        (if (= (-> self face-status s5-1) 1)
            (matrix*! (-> self face-matrix s5-1) (-> self face-matrix-back s5-1) gp-0)
            )
        )
      )
    (when (time-elapsed? (-> self state-time) (seconds 0.7))
      (dotimes (v1-34 6)
        (when (= (-> self face-status v1-34) 1)
          (set! (-> self face-status v1-34) 0)
          0
          )
        )
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post (behavior ()
    (transform-post)
    )
  )

(defstate fall (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self time-anim) 0.0)
    (set! (-> self speed-anim) 0.0)
    (set-time! (-> self state-time))
    (sound-play "dice-sink")
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (set! (-> self speed-anim) (- (-> self speed-anim) (* 0.05 (seconds-per-frame))))
    (+! (-> self time-anim) (-> self speed-anim))
    (set! (-> self active) (the-as uint 3))
    (dotimes (v1-5 6)
      (+! (-> self face-matrix v1-5 trans y) (* 4096.0 (-> self time-anim)))
      )
    (when (time-elapsed? (-> self state-time) (seconds 1))
      (dotimes (v1-11 6)
        (when (= (-> self face-status v1-11) 1)
          (set! (-> self face-status v1-11) 0)
          0
          )
        )
      (go-virtual idle)
      )
    )
  :code sleep-code
  :post transform-post
  )

(defun dice-joint-callback ((arg0 draw-control) (arg1 cspace-array) (arg2 joint-control))
  (local-vars
    (sv-544 int)
    (sv-560 vector)
    (sv-576 vector)
    (sv-592 vector)
    (sv-608 vector)
    (sv-624 vector)
    (sv-640 vector)
    (sv-656 matrix)
    (sv-672 matrix)
    (sv-688 vector)
    (sv-704 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (the-as mtn-dice (-> arg0 process))))
      (new 'stack-no-clear 'vector)
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set-vector! s4-0 4095996000.0 4095996000.0 4095996000.0 1.0)
        (set-vector! s5-0 -4095996000.0 -4095996000.0 -4095996000.0 1.0)
        (dotimes (s2-0 6)
          (let ((s1-0 (-> arg1 data (+ s2-0 4) bone transform)))
            (new-stack-matrix0)
            (let* ((v1-9 s1-0)
                   (a3-0 (-> gp-0 face-matrix s2-0))
                   (a0-11 (-> a3-0 quad 0))
                   (a1-1 (-> a3-0 quad 1))
                   (a2-1 (-> a3-0 quad 2))
                   (a3-1 (-> a3-0 trans quad))
                   )
              (set! (-> v1-9 quad 0) a0-11)
              (set! (-> v1-9 quad 1) a1-1)
              (set! (-> v1-9 quad 2) a2-1)
              (set! (-> v1-9 trans quad) a3-1)
              )
            (let ((v1-12 (the int (+ 2.0 (/ (-> s1-0 trans x) METER_LENGTH))))
                  (a0-14 (the int (+ 2.0 (/ (-> s1-0 trans z) METER_LENGTH))))
                  )
              (set! sv-544 (/ (- *dice-offset-x* v1-12) -4))
              (let ((s0-0 (/ (- *dice-offset-z* a0-14) -4)))
                (when (and (= (-> gp-0 face-status s2-0) -1) (= (-> gp-0 active) 1))
                  (when (and (= (-> gp-0 active) 1) (not (logtest? (-> *dice-blocked-array* s0-0) (ash 1 (- 15 sv-544)))))
                    (when (> *dice-back-way-num* 0)
                      (set! (-> *dice-last-safe-position* quad) (-> *dice-back-way* (+ *dice-back-way-num* -1) quad))
                      (+! (-> *dice-last-safe-position* y) 8192.0)
                      )
                    (when (not (dice-wrong-way?))
                      (set! (-> *dice-back-way* *dice-back-way-num* quad) (-> s1-0 trans quad))
                      (set! *dice-back-way-num* (+ *dice-back-way-num* 1))
                      )
                    (set! (-> *dice-blocked-array* s0-0)
                          (the-as uint (logior (ash 1 (- 15 sv-544)) (-> *dice-blocked-array* s0-0)))
                          )
                    )
                  )
                )
              )
            (cond
              ((>= (-> gp-0 face-status s2-0) 0)
               (when (and (< 0.8 (-> s1-0 vector 0 y)) (zero? (-> gp-0 face-status s2-0)))
                 (+! (-> gp-0 free-face) -1)
                 (set! (-> gp-0 face-status s2-0) -1)
                 )
               (let* ((v1-59 (-> gp-0 face-matrix s2-0))
                      (a3-3 s1-0)
                      (a0-45 (-> a3-3 quad 0))
                      (a1-11 (-> a3-3 quad 1))
                      (a2-5 (-> a3-3 quad 2))
                      (a3-4 (-> a3-3 trans quad))
                      )
                 (set! (-> v1-59 quad 0) a0-45)
                 (set! (-> v1-59 quad 1) a1-11)
                 (set! (-> v1-59 quad 2) a2-5)
                 (set! (-> v1-59 trans quad) a3-4)
                 )
               )
              (else
                (when (!= (-> gp-0 free-face) 5)
                  (let ((a0-47 (-> gp-0 root root-prim)))
                    (logior! (-> (the-as collide-shape-prim-group a0-47) child s2-0 prim-core action) (collide-action rideable))
                    )
                  )
                )
              )
            (when (-> gp-0 watervol)
              (let* ((v1-70 (-> gp-0 watervol))
                     (s0-1 (if v1-70
                               (the-as water-anim (-> v1-70 extra process))
                               )
                           )
                     )
                (when s0-1
                  (set! sv-560 (new 'stack-no-clear 'vector))
                  (set! sv-576 (new 'stack-no-clear 'vector))
                  (set! sv-608 (new 'stack-no-clear 'vector))
                  (set! sv-592 (new 'stack-no-clear 'vector))
                  (set! sv-672 (new 'stack-no-clear 'matrix))
                  (set! sv-640 (new 'stack-no-clear 'vector))
                  (let ((a1-15 sv-560))
                    (let ((v1-79 (-> s1-0 trans)))
                      (let ((a0-50 (-> s1-0 vector)))
                        (let ((a2-7 8192.0))
                          (.mov vf7 a2-7)
                          )
                        (.lvf vf5 (&-> a0-50 0 quad))
                        )
                      (.lvf vf4 (&-> v1-79 quad))
                      )
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a1-15 quad) vf6)
                    )
                  (set! (-> sv-640 quad) (-> sv-560 quad))
                  (set! (-> sv-576 quad) (-> sv-560 quad))
                  (+! (-> sv-576 x) 8192.0)
                  (set! (-> sv-608 quad) (-> sv-560 quad))
                  (+! (-> sv-608 z) 8192.0)
                  (set! (-> sv-560 y) (get-ripple-height s0-1 sv-560))
                  (set! (-> sv-576 y) (get-ripple-height s0-1 sv-576))
                  (set! (-> sv-608 y) (get-ripple-height s0-1 sv-608))
                  (vector-! sv-576 sv-576 sv-560)
                  (vector-! sv-608 sv-608 sv-560)
                  (set! (-> sv-576 y) (/ (-> sv-576 y) 2))
                  (set! (-> sv-608 y) (/ (-> sv-608 y) 2))
                  (set! (-> sv-576 w) 0.0)
                  (set! (-> sv-592 w) 0.0)
                  (set! (-> sv-608 w) 0.0)
                  (vector-normalize! sv-576 1.0)
                  (vector-normalize! sv-608 1.0)
                  (vector-cross! sv-592 sv-608 sv-576)
                  (vector-normalize! sv-592 1.0)
                  (vector-cross! sv-608 sv-576 sv-592)
                  (vector-normalize! sv-608 1.0)
                  (matrix-identity! sv-672)
                  (set! (-> sv-672 vector 0 quad) (-> sv-576 quad))
                  (set! (-> sv-672 vector 1 quad) (-> sv-592 quad))
                  (set! (-> sv-672 vector 2 quad) (-> sv-608 quad))
                  (set! sv-624 (new 'stack-no-clear 'vector))
                  (set! sv-656 (new 'stack-no-clear 'matrix))
                  (set! sv-688 (new 'stack-no-clear 'vector))
                  (vector-negate! sv-624 sv-640)
                  (matrix-translate! sv-656 sv-624)
                  (matrix<-trans sv-672 sv-640)
                  (matrix*! (the-as matrix sv-688) sv-656 sv-672)
                  (matrix*! s1-0 s1-0 (the-as matrix sv-688))
                  (+! (-> s1-0 trans y) (* 0.5 (- (-> sv-560 y) (-> s0-1 water-height))))
                  (+! (-> s1-0 trans y) 8192.0)
                  (set! (-> s4-0 x) (fmin (-> s4-0 x) (-> s1-0 trans x)))
                  (set! (-> s4-0 y) (fmin (-> s4-0 y) (-> s1-0 trans y)))
                  (set! (-> s4-0 z) (fmin (-> s4-0 z) (-> s1-0 trans z)))
                  (set! (-> s5-0 x) (fmax (-> s5-0 x) (-> s1-0 trans x)))
                  (set! (-> s5-0 y) (fmax (-> s5-0 y) (-> s1-0 trans y)))
                  (set! (-> s5-0 z) (fmax (-> s5-0 z) (-> s1-0 trans z)))
                  )
                )
              )
            (let ((s0-2 (new 'stack-no-clear 'vector)))
              (set! (-> s0-2 quad) (-> s1-0 vector 0 quad))
              (set! sv-704 (new 'stack-no-clear 'vector))
              (let ((v1-125 (-> s1-0 trans quad)))
                (set! (-> sv-704 quad) v1-125)
                )
              (let ((a1-36 sv-704))
                (let ((v1-126 sv-704))
                  (let ((a0-81 s0-2))
                    (let ((a2-11 8192.0))
                      (.mov vf7 a2-11)
                      )
                    (.lvf vf5 (&-> a0-81 quad))
                    )
                  (.lvf vf4 (&-> v1-126 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-36 quad) vf6)
                )
              (let ((f30-0 0.0)
                    (s1-1 (new 'stack-no-clear 'vector))
                    (v0-14 (camera-pos))
                    )
                (cond
                  ((< f30-0 (vector-dot s0-2 (vector-! s1-1 sv-704 v0-14)))
                   (let ((v1-129 s2-0))
                     (cond
                       ((zero? v1-129)
                        (setup-masks (-> gp-0 draw) 2 0)
                        )
                       ((= v1-129 1)
                        (setup-masks (-> gp-0 draw) 4 0)
                        )
                       ((= v1-129 2)
                        (setup-masks (-> gp-0 draw) 8 0)
                        )
                       ((= v1-129 3)
                        (setup-masks (-> gp-0 draw) 16 0)
                        )
                       ((= v1-129 4)
                        (setup-masks (-> gp-0 draw) 32 0)
                        )
                       ((= v1-129 5)
                        (setup-masks (-> gp-0 draw) 64 0)
                        )
                       )
                     )
                   )
                  (else
                    (let ((v1-143 s2-0))
                      (cond
                        ((zero? v1-143)
                         (setup-masks (-> gp-0 draw) 0 2)
                         )
                        ((= v1-143 1)
                         (setup-masks (-> gp-0 draw) 0 4)
                         )
                        ((= v1-143 2)
                         (setup-masks (-> gp-0 draw) 0 8)
                         )
                        ((= v1-143 3)
                         (setup-masks (-> gp-0 draw) 0 16)
                         )
                        ((= v1-143 4)
                         (setup-masks (-> gp-0 draw) 0 32)
                         )
                        ((= v1-143 5)
                         (setup-masks (-> gp-0 draw) 0 64)
                         )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (let ((s2-1 (new 'stack-no-clear 'vector))
              (s3-1 (new 'stack-no-clear 'vector))
              )
          (vector-average! s2-1 s4-0 s5-0)
          (vector-! s2-1 s2-1 (-> gp-0 root trans))
          (vector-! s3-1 s5-0 s4-0)
          (set! (-> gp-0 draw bounds quad) (-> s2-1 quad))
          (set! (-> gp-0 draw bounds w) (+ 16384.0 (* 0.5 (vector-length s3-1))))
          )
        )
      (set! (-> (the-as collide-shape (-> gp-0 root)) root-prim local-sphere quad) (-> gp-0 draw bounds quad))
      (vector-rotate90-around-y! (-> gp-0 draw bounds) (-> gp-0 draw bounds))
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-dice) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 6) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 7))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 5)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 6)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 3))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) 7)
      (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 4))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 8)
      (set-vector! (-> v1-18 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 5))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) 9)
      (set-vector! (-> v1-20 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-23 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-23 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-23 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-dice" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this skel postbind-function) dice-joint-callback)
  (set! (-> this first) (the-as uint 0))
  (let ((v1-30 (res-lump-value arg0 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
    (if (= (the-as uint v1-30) 2)
        (set! (-> this first) (the-as uint 1))
        )
    )
  (let* ((a0-48 (the int (/ (-> this root trans x) METER_LENGTH)))
         (v1-37 (the int (/ (-> this root trans y) METER_LENGTH)))
         (a1-21 (the int (/ (-> this root trans z) METER_LENGTH)))
         (a0-49 (- a0-48 *dice-offset-x*))
         (a2-13 (- a1-21 *dice-offset-z*))
         (a1-22 (+ a0-49 1))
         (a0-50 (+ a2-13 1))
         (a1-23 (logand -4 a1-22))
         (v1-38 (logand -2 v1-37))
         (a0-51 (logand -4 a0-50))
         (a1-24 (+ a1-23 *dice-offset-x*))
         (a0-52 (+ a0-51 *dice-offset-z*))
         )
    (set! (-> this root trans x) (* 4096.0 (the float a1-24)))
    (set! (-> this root trans y) (* 4096.0 (the float v1-38)))
    (set! (-> this root trans z) (* 4096.0 (the float a0-52)))
    )
  (dotimes (s4-2 6)
    (matrix-rotate-xyz! (-> this face-matrix s4-2) (-> *dice-angle-array* s4-2))
    (set! (-> this face-matrix s4-2 trans quad) (-> *dice-position-array* s4-2 quad))
    (vector+! (-> this face-matrix s4-2 trans) (-> this face-matrix s4-2 trans) (-> this root trans))
    (+! (-> this face-matrix s4-2 trans y) 8192.0)
    )
  (mem-set32! (the-as pointer *dice-blocked-array*) 13 0)
  (set! (-> *dice-blocked-array* 1) (the-as uint 256))
  (set! *dice-back-way-num* 0)
  (set-vector! *dice-last-safe-position* -2603417.5 384983.03 -107683.84 1.0)
  (set-vector! (-> this color) 0.5 0.5 0.5 1.0)
  (set! (-> this free-face) (the-as uint 6))
  (set! (-> this watervol) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (set! (-> this hint-count) 0.0)
  (set! (-> this active) (-> this first))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 1 0)
  (cond
    ((task-node-closed? (game-task-node mountain-shard-dice))
     (let ((v1-71 (res-lump-value arg0 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
       (dotimes (a0-76 6)
         (let ((a1-42 (-> *mtn-dice-done-info* (+ a0-76 (* 6 (the-as int (+ v1-71 -1)))))))
           (set! (-> this face-matrix a0-76 vector 0 x) (-> a1-42 mat 0))
           (set! (-> this face-matrix a0-76 vector 0 y) (-> a1-42 mat 1))
           (set! (-> this face-matrix a0-76 vector 0 z) (-> a1-42 mat 2))
           (set! (-> this face-matrix a0-76 vector 0 w) 0.0)
           (set! (-> this face-matrix a0-76 vector 1 x) (-> a1-42 mat 3))
           (set! (-> this face-matrix a0-76 vector 1 y) (-> a1-42 mat 4))
           (set! (-> this face-matrix a0-76 vector 1 z) (-> a1-42 mat 5))
           (set! (-> this face-matrix a0-76 vector 1 w) 0.0)
           (set! (-> this face-matrix a0-76 vector 2 x) (-> a1-42 mat 6))
           (set! (-> this face-matrix a0-76 vector 2 y) (-> a1-42 mat 7))
           (set! (-> this face-matrix a0-76 vector 2 z) (-> a1-42 mat 8))
           (set! (-> this face-matrix a0-76 vector 2 w) 0.0)
           (set! (-> this face-matrix a0-76 trans x) (-> a1-42 mat 9))
           (set! (-> this face-matrix a0-76 trans y) (-> a1-42 mat 10))
           (set! (-> this face-matrix a0-76 trans z) (-> a1-42 mat 11))
           )
         (set! (-> this face-matrix a0-76 trans w) 1.0)
         )
       )
     (go (method-of-object this idle-done))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  (none)
  )

(deftype mtn-plat-elevator (elevator)
  ()
  )


(defskelgroup skel-mtn-plat-elevator mtn-plat-elevator mtn-plat-elevator-lod0-jg mtn-plat-elevator-idle-ja
              ((mtn-plat-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7)
              )

(defmethod get-art-group ((this mtn-plat-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-mtn-plat-elevator" (the-as (pointer uint32) #f))
  )

(defmethod set-ambient-sound! ((this mtn-plat-elevator))
  "Sets the elevator's [[ambient-sound]] up"
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "mtn-elevator-lp" :fo-max 70) (-> this root trans))
        )
  0
  (none)
  )

(defmethod move-between-points ((this mtn-plat-elevator) (arg0 vector) (arg1 float) (arg2 float))
  "Move between two points on the elevator's path
   @param vec TODO not sure
   @param point-a The first point fetched from the elevator's path
   @param point-b The second point fetched from the path
   @see [[path-control]] and [[elevator]]"
  (let ((s4-0 (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) arg1 'interp))
        (a0-3 (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) arg2 'interp))
        )
    (and (< (-> a0-3 y) (-> s4-0 y))
         (< (-> arg0 y) (+ -4096.0 (-> this root trans y)))
         (< (vector-vector-xz-distance a0-3 arg0) 24576.0)
         )
    )
  )

(defmethod init-plat-collision! ((this mtn-plat-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 28672.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

(deftype mtn-plat-updown (base-plat)
  ((sync      sync-eased  :inline)
   (path-pos  float)
   )
  (:state-methods
    idle
    active
    )
  )


(defskelgroup skel-mtn-plat-updown mtn-plat-updown mtn-plat-updown-lod0-jg mtn-plat-updown-idle-ja
              ((mtn-plat-updown-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defstate idle (mtn-plat-updown)
  :virtual #t
  :code sleep-code
  :post ja-post
  )

(defstate active (mtn-plat-updown)
  :virtual #t
  :event plat-event
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (plat-trans)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post plat-post
  )

(defmethod init-plat-collision! ((this mtn-plat-updown))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-plat-updown) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-updown" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((a0-5 (-> this skel root-channel 0)))
    (set! (-> a0-5 frame-group) (if (> (-> this skel active-channels) 0)
                                    (-> this skel root-channel 0 frame-group)
                                    )
          )
    (set! (-> a0-5 param 0) 1.0)
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group!
      a0-5
      (if (> (-> this skel active-channels) 0)
          (-> this skel root-channel 0 frame-group)
          )
      num-func-loop!
      )
    )
  (ja-post)
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 arg0 #f))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-7 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if (not (logtest? (-> this fact options) (actor-option loop)))
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-7 sync-type) 'sync-eased)
      (set! (-> a1-7 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-7 period) (the-as uint 1800))
    (set! (-> a1-7 entity) arg0)
    (set! (-> a1-7 percent) 0.0)
    (set! (-> a1-7 ease-in) 0.15)
    (set! (-> a1-7 ease-out) 0.15)
    (set! (-> a1-7 pause-in) 0.2)
    (set! (-> a1-7 pause-out) 0.0)
    (initialize! (-> this sync) a1-7)
    )
  (cond
    ((logtest? (-> this path flags) (path-control-flag not-found))
     (go (method-of-object this idle))
     )
    ((> (-> this sync period) 0)
     (go (method-of-object this active))
     )
    (else
      (go (method-of-object this idle))
      )
    )
  (none)
  )

(deftype mtn-plat-eject (process-drawable)
  ((dest-pos  vector  :inline)
   )
  (:state-methods
    wait
    eject
    )
  (:methods
    (mtn-plat-eject-method-22 (_type_) none)
    )
  )


(defskelgroup skel-mtn-plat-eject mtn-plat-eject mtn-plat-eject-lod0-jg mtn-plat-eject-idle-ja
              ((mtn-plat-eject-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 4 7.1)
              )

(defstate wait (mtn-plat-eject)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('eject)
       (go-virtual eject)
       )
      )
    )
  :code sleep-code
  )

(defstate eject (mtn-plat-eject)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! mtn-plat-eject-idle-ja :num! (loop!) :frame-num 0.0)
    )
  :code sleep-code
  :post (behavior ()
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self dest-pos) (-> self root trans))))
      (vector-normalize! gp-1 (* 0.25 (vector-length gp-1)))
      (vector+! (-> self root trans) (-> self root trans) gp-1)
      )
    (transform-post)
    )
  )

(defmethod mtn-plat-eject-method-22 ((this mtn-plat-eject))
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 16384.0 29081.6)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-plat-eject) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (mtn-plat-eject-method-22 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-eject" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this dest-pos quad) (-> this root trans quad))
  (let ((s5-2 (new 'stack-no-clear 'vector)))
    (set! (-> s5-2 x) 0.0)
    (set! (-> s5-2 y) 0.0)
    (set! (-> s5-2 z) -40960.0)
    (set! (-> s5-2 w) 1.0)
    (vector-orient-by-quat! s5-2 s5-2 (-> this root quat))
    (vector+! (-> this root trans) (-> this root trans) s5-2)
    )
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this eject))
      (go (method-of-object this wait))
      )
  (none)
  )

(deftype mtn-plat-long (base-plat)
  ((sync  sync-linear  :inline)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-mtn-plat-long mtn-plat-long mtn-plat-long-lod0-jg mtn-plat-long-idle-ja
              ((mtn-plat-long-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15.5)
              )

(defstate idle (mtn-plat-long)
  :virtual #t
  :event plat-event
  :trans plat-trans
  :code (behavior ()
    (until #f
      (let ((f0-1 (* (get-current-phase-no-mod (-> self sync)) (the float (+ (-> (ja-group) frames num-frames) -1))))
            (a0-1 (-> self skel root-channel 0))
            )
        (let ((v1-14 (ja-group)))
          (set! (-> a0-1 frame-group) v1-14)
          )
        (set! (-> a0-1 param 0) 1.0)
        (set! (-> a0-1 frame-num) f0-1)
        (joint-control-channel-group! a0-1 (ja-group) num-func-loop!)
        )
      (suspend)
      )
    #f
    )
  :post plat-post
  )

(defmethod init-plat-collision! ((this mtn-plat-long))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 63488.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-plat-long) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-long" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! this)
  (update-transforms (-> this root))
  (base-plat-method-32 this)
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-5 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-13 0))
      (if (not (logtest? (-> this fact options) (actor-option loop)))
          (set! v1-13 (logior v1-13 1))
          )
      (set! (-> a1-5 sync-type) 'sync-linear)
      (set! (-> a1-5 sync-flags) (the-as sync-flags v1-13))
      )
    (set! (-> a1-5 entity) arg0)
    (set! (-> a1-5 period) (the-as uint 1200))
    (set! (-> a1-5 percent) 0.0)
    (initialize! (-> this sync) a1-5)
    )
  (go (method-of-object this idle))
  (none)
  )

(deftype mtn-gate (process-drawable)
  ()
  (:state-methods
    idle
    open
    )
  )


(defskelgroup skel-mtn-gate mtn-gate mtn-gate-lod0-jg mtn-gate-idle-ja
              ((mtn-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 18)
              )

(defstate idle (mtn-gate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code sleep-code
  )

(defstate open (mtn-gate)
  :virtual #t
  :code (behavior ()
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set-setting! 'entity-name "camera-259" 0.0 0)
    (suspend-for (seconds 1)
      )
    (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (suspend-for (seconds 1)
      )
    (until (process-release? *target*)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post transform-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-gate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set-vector! (-> s3-0 local-sphere) 0.0 24576.0 -2457.6 49152.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 4)
      (set-vector! (-> v1-7 local-sphere) -16384.0 16384.0 0.0 32768.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 5)
      (set-vector! (-> v1-9 local-sphere) 16384.0 16384.0 0.0 32768.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-gate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-push! 1 0)
  (let ((s5-2 (-> this skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-2
      (the-as art-joint-anim (-> this draw art-group data 3))
      num-func-identity
      )
    (set! (-> s5-2 frame-num) 0.0)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype mtn-aval-rocks (process-drawable)
  ((art-name   symbol)
   (anim       spool-anim)
   (rock-data  vector-array)
   (loop-id    sound-id)
   (volume     float)
   )
  (:state-methods
    fall
    idle
    )
  )


;; WARN: Return type mismatch process-drawable vs mtn-aval-rocks.
(defmethod relocate ((this mtn-aval-rocks) (offset int))
  (if (nonzero? (-> this rock-data))
      (&+! (-> this rock-data) offset)
      )
  (the-as mtn-aval-rocks ((method-of-type process-drawable relocate) this offset))
  )

(deftype mtn-aval-rocks-shadow (process-drawable)
  ((parent-ptr    (pointer mtn-aval-rocks)  :overlay-at parent)
   (parent-joint  int32)
   (update-time   time-frame)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-mtn-aval-rocks-1 mtn-aval-rocks mtn-aval-rocks-1-lod0-jg mtn-aval-rocks-1-idle-ja
              ((mtn-aval-rocks-1-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 -100 140)
              )

(defskelgroup skel-mtn-aval-rocks-shadow mtn-aval-rocks mtn-aval-rocks-shadow-lod0-jg mtn-aval-rocks-shadow-idle-ja
              ((mtn-aval-rocks-shadow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1.5 0 2)
              :shadow mtn-aval-rocks-shadow-shadow-mg
              )

(define *mtn-aval-rocks-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 245760.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0)
                                           :fade-dist 409600.0
                                           )
                               )
  )

(defstate idle (mtn-aval-rocks-shadow)
  :virtual #t
  :code sleep-code
  :post (behavior ()
    (let ((s5-0 (-> (the-as process-drawable (-> self parent-ptr 0)) node-list data (-> self parent-joint)))
          (gp-0 (-> self draw shadow-ctrl))
          )
      (vector<-cspace! (-> self root trans) s5-0)
      (let ((f0-1 (/ (-> s5-0 bone scale y) 2)))
        (set-vector! (-> self root scale) f0-1 f0-1 f0-1 1.0)
        )
      (cond
        ((or (< (vector-vector-distance (math-camera-pos) (-> self root trans)) (-> gp-0 settings fade-dist))
             (and PC_PORT (not (-> *pc-settings* ps2-shadow?)))) ;; og:preserve-this extended shadow
         (let ((s5-2 (new 'stack-no-clear 'collide-query)))
           (set! (-> s5-2 start-pos quad) (-> self root trans quad))
           (+! (-> s5-2 start-pos z) -8192.0)
           (set-vector! (-> s5-2 move-dist) 0.0 -81920.0 0.0 1.0)
           (let ((v1-13 s5-2))
             (set! (-> v1-13 radius) 819.2)
             (set! (-> v1-13 collide-with) (collide-spec backgnd))
             (set! (-> v1-13 ignore-process0) self)
             (set! (-> v1-13 ignore-process1) #f)
             (set! (-> v1-13 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
             (set! (-> v1-13 action-mask) (collide-action solid))
             )
           (cond
             ((>= (fill-and-probe-using-line-sphere *collide-cache* s5-2) 0.0)
              (let ((v1-16 gp-0))
                (logclear! (-> v1-16 settings flags) (shadow-flags disable-draw))
                )
              0
              (set! (-> gp-0 settings bot-plane w)
                    (- (- (+ (- 4096.0 (-> s5-2 best-other-tri intersect y)) (-> self root trans y))))
                    )
              0
              )
             (else
               (let ((v1-21 gp-0))
                 (logior! (-> v1-21 settings flags) (shadow-flags disable-draw))
                 )
               0
               )
             )
           )
         )
        (else
          (let ((v1-23 gp-0))
            (logior! (-> v1-23 settings flags) (shadow-flags disable-draw))
            )
          0
          )
        )
      )
    (ja-post)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior mtn-aval-rocks-shadow-init-by-other mtn-aval-rocks-shadow ((arg0 int))
  (stack-size-set! (-> self main-thread) 128)
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self parent-joint) arg0)
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> self parent-ptr 0 root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-mtn-aval-rocks-shadow" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> self draw shadow-ctrl) (copy *mtn-aval-rocks-shadow-control* 'process))
  (go-virtual idle)
  (none)
  )

(defpartgroup group-aval-rock-hit
  :id 352
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 112) (sp-item 113) (sp-item 104))
  )

(defstate idle (mtn-aval-rocks)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('draw)
       (if (-> block param 0)
           (go-virtual fall)
           )
       )
      )
    )
  :trans (behavior ()
    (cond
      ((not *target*)
       )
      ((string= (-> *game-info* current-continue name) "mountain-aval")
       (go-virtual fall)
       )
      )
    )
  :code (behavior ()
    (ja-channel-set! 0)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    )
  )

(defstate fall (mtn-aval-rocks)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (a2-3 int))
    (case message
      (('touch 'attack)
       (let ((s3-0 (-> block param 0))
             (s4-0 0)
             )
         (when s3-0
           (let ((a0-6 ((method-of-type touching-shapes-entry prims-touching?)
                        (the-as touching-shapes-entry s3-0)
                        (the-as collide-shape (-> self root))
                        (the-as uint -1)
                        )
                       )
                 )
             (when a0-6
               (let ((a0-7 (get-touched-prim a0-6 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s3-0))))
                 (if a0-7
                     (set! s4-0 (the-as int (-> a0-7 prim-id)))
                     )
                 )
               )
             )
           )
         (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-4 from) (process->ppointer self))
           (set! (-> a1-4 num-params) 2)
           (set! (-> a1-4 message) 'attack)
           (set! (-> a1-4 param 0) (-> block param 0))
           (let ((v1-11 (new 'static 'attack-info :mask (attack-mask shove-up id damage))))
             (set! a2-3 (cond
                          ((nonzero? s4-0)
                           (+ s4-0 10)
                           )
                          (else
                            (let ((a0-9 *game-info*))
                              (set! a2-3 (the-as int (+ (-> a0-9 attack-id) 1)))
                              (set! (-> a0-9 attack-id) (the-as uint a2-3))
                              )
                            a2-3
                            )
                          )
                   )
             (set! (-> v1-11 id) (the-as uint a2-3))
             (set! (-> v1-11 shove-up) 12288.0)
             (set! (-> v1-11 damage) 1.0)
             (set! (-> a1-4 param 1) (the-as uint v1-11))
             )
           (send-event-function proc a1-4)
           )
         )
       )
      (('draw)
       (if (not (-> block param 0))
           (go-virtual idle)
           )
       )
      )
    )
  :exit (behavior ()
    (when (= (-> *setting-control* user-current spooling) (process->ppointer self))
      (ja-abort-spooled-anim (-> self anim) (the-as art-joint-anim #f) -1)
      (ja-channel-set! 0)
      )
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (remove-process *gui-control* self (gui-channel art-load-next))
    (let ((v1-10 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-10 command) (sound-command set-param))
      (set! (-> v1-10 id) (-> self loop-id))
      (set! (-> v1-10 params volume) -4)
      (set! (-> v1-10 auto-time) 240)
      (set! (-> v1-10 auto-from) 2)
      (set! (-> v1-10 params mask) (the-as uint 17))
      (-> v1-10 id)
      )
    )
  :code (behavior ()
    (let ((gp-0 2)
          (s5-0 (+ (-> self node-list length) -1))
          )
      (while (>= s5-0 gp-0)
        (process-spawn mtn-aval-rocks-shadow gp-0 :to self)
        (+! gp-0 1)
        )
      )
    (let ((gp-1
            (add-process *gui-control* self (gui-channel art-load-next) (gui-action queue) (-> self anim name) -1.0 0)
            )
          )
      (while (!= (get-status *gui-control* gp-1) (gui-status ready))
        (suspend)
        )
      )
    (until #f
      (let ((v1-16
              (lookup-gui-connection
                *gui-control*
                self
                (gui-channel art-load-next)
                (the-as string #f)
                (new 'static 'sound-id)
                )
              )
            )
        (if v1-16
            (set! (-> v1-16 channel) (gui-channel art-load))
            )
        )
      (add-process *gui-control* self (gui-channel art-load-next) (gui-action queue) (-> self anim name) -1.0 0)
      (ja-play-spooled-anim
        (-> self anim)
        (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
        (the-as art-joint-anim #f)
        (the-as (function process-drawable symbol) false-func)
        )
      )
    #f
    )
  :post (behavior ()
    (local-vars (sv-16 vector-array) (sv-20 vector) (sv-48 float) (sv-52 symbol))
    (transform-post)
    (if (= (-> *setting-control* user-current music) 'mountain)
        (seek! (-> self volume) 0.6 (* 0.2 (seconds-per-frame)))
        (seek! (-> self volume) 1.0 (* 0.5 (seconds-per-frame)))
        )
    (sound-play-by-name
      (static-sound-name "mtn-aval-loop")
      (-> self loop-id)
      (the int (* 1024.0 (-> self volume)))
      0
      0
      (sound-group sfx)
      (-> self draw origin)
      )
    (set! sv-16 (-> self rock-data))
    (set! sv-20 (target-pos 0))
    (dotimes (gp-0 (-> self node-list length))
      (let* ((a1-3 (-> self node-list data gp-0))
             (s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) a1-3))
             )
        (+! (-> s5-0 y) -4096.0)
        (set! sv-48 (* (- (-> s5-0 y) (-> sv-16 data gp-0 x)) (-> self clock frames-per-second)))
        (set! sv-52 (the-as symbol #f))
        (when (and (< (-> sv-16 data gp-0 y) -24576.0) (< (* 0.45 (-> sv-16 data gp-0 y)) sv-48))
          (set! sv-52 #t)
          (let ((f30-0 (vector-vector-distance sv-20 s5-0)))
            (when (< f30-0 204800.0)
              (let ((s4-0 (get-process *default-dead-pool* part-tracker #x4000)))
                (when s4-0
                  (let ((t9-8 (method-of-type part-tracker activate)))
                    (t9-8
                      (the-as part-tracker s4-0)
                      *entity-pool*
                      (symbol->string (-> part-tracker symbol))
                      (the-as pointer #x70004000)
                      )
                    )
                  (let ((t9-9 run-function-in-process)
                        (a0-16 s4-0)
                        (a1-7 part-tracker-init)
                        (a2-7 (-> *part-group-id-table* 352))
                        (a3-2 0)
                        (t0-1 #f)
                        (t1-1 #f)
                        (t2-1 #f)
                        (t3-0 *launch-matrix*)
                        )
                    (set! (-> t3-0 trans quad) (-> s5-0 quad))
                    ((the-as (function object object object object object object object object none) t9-9)
                     a0-16
                     a1-7
                     a2-7
                     a3-2
                     t0-1
                     t1-1
                     t2-1
                     t3-0
                     )
                    )
                  (-> s4-0 ppointer)
                  )
                )
              (when (= (-> sv-16 data gp-0 w) 0.0)
                (sound-play-by-name
                  (static-sound-name "mtn-boulder")
                  (new-sound-id)
                  (the int
                       (* 1024.0 (* (lerp-scale 0.3 1.0 (fabs (- (-> sv-16 data gp-0 y) sv-48)) 0.0 40960.0) (-> self volume)))
                       )
                  0
                  0
                  (sound-group sfx)
                  s5-0
                  )
                (set! (-> sv-16 data gp-0 w) 20.0)
                )
              )
            (when (< f30-0 122880.0)
              (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 (the int (* 255.0 (- 1.0 (/ f30-0 (meters 30))))) (seconds 0.2))
              (activate!
                *camera-smush-control*
                (lerp-scale 1638.4 0.0 f30-0 0.0 122880.0)
                15
                75
                1.0
                0.9
                (-> *display* camera-clock)
                )
              )
            )
          )
        (set! (-> sv-16 data gp-0 y) sv-48)
        (set! (-> sv-16 data gp-0 x) (-> s5-0 y))
        )
      (seek! (-> sv-16 data gp-0 w) 0.0 1.0)
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-aval-rocks) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (local-vars (sv-16 collide-shape-prim-sphere) (sv-48 collide-shape-prim-sphere) (sv-64 vector))
  (stack-size-set! (-> this main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 49) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 50))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 -409600.0 573440.0)
      (set! (-> s4-0 root-prim) s3-0)
      (pusher-init s4-0)
      (let* ((s2-0 1)
             (s1-0
               '((3 9011)
                 (4 9011)
                 (5 9011)
                 (6 9011)
                 (13 9011)
                 (14 9011)
                 (15 9011)
                 (16 9011)
                 (22 9011)
                 (23 9011)
                 (42 9011)
                 (26 9011)
                 (27 9011)
                 (35 9011)
                 (36 9011)
                 (37 9011)
                 (45 9011)
                 (46 9011)
                 (47 9011)
                 (48 9011)
                 (7 6144)
                 (8 6144)
                 (9 6144)
                 (10 6144)
                 (17 6144)
                 (18 6144)
                 (49 6144)
                 (19 6144)
                 (20 6144)
                 (21 6144)
                 (11 6144)
                 (12 6144)
                 (24 3686)
                 (25 3686)
                 (32 3686)
                 (33 3686)
                 (34 3686)
                 (43 3686)
                 (44 3686)
                 (50 3686)
                 (38 3686)
                 (38 3686)
                 (40 3686)
                 (39 3686)
                 (41 3686)
                 (28 3686)
                 (29 3686)
                 (30 3686)
                 (31 3686)
                 )
               )
             (s0-0 (car s1-0))
             )
        (while (not (null? s1-0))
          (set! sv-16 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0)))
          (set! sv-48 sv-16)
          (set! (-> sv-48 prim-core collide-as) (-> s3-0 prim-core collide-as))
          (set! (-> sv-48 prim-core collide-with) (-> s3-0 prim-core collide-with))
          (set! (-> sv-48 prim-core action) (-> s3-0 prim-core action))
          (set! (-> sv-48 transform-index) (command-get-int (car s0-0) 0))
          (set! (-> sv-48 prim-id) (the-as uint s2-0))
          (+! s2-0 1)
          (set! sv-64 (-> sv-16 local-sphere))
          (set! (-> sv-64 x) 0.0)
          (set! (-> sv-64 y) 0.0)
          (set! (-> sv-64 z) 0.0)
          (set! (-> sv-64 w) (command-get-float (car (cdr s0-0)) 0.0))
          (set! s1-0 (cdr s1-0))
          (set! s0-0 (car s1-0))
          )
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-27 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (quaternion-rotate-y! (-> this root quat) (-> this root quat) 32768.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-aval-rocks-1" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> this skel status) (joint-control-status sync-math))
  (set! (-> this art-name) (the-as symbol "mtn-aval-rocks-1"))
  (set! (-> this anim)
        (new 'static 'spool-anim :name "mtn-aval-rocks-1" :anim-name "1-fall" :parts 8 :command-list '())
        )
  (set! (-> this loop-id) (new-sound-id))
  (set! (-> this rock-data) (new 'process 'vector-array (-> this node-list length)))
  (dotimes (v1-42 (-> this node-list length))
    (let* ((a0-21 *game-info*)
           (a1-13 (the-as number (+ (-> a0-21 attack-id) 1)))
           )
      (set! (-> a0-21 attack-id) (the-as uint a1-13))
      (set! (-> this rock-data data v1-42 z) (the-as float a1-13))
      )
    (set! (-> this rock-data data v1-42 w) 0.0)
    )
  (let ((a2-7
          (matrix<-transformq! (-> this node-list data 0 bone transform) (the-as transformq (-> this root trans)))
          )
        (a1-17 (new 'stack-no-clear 'vector))
        )
    (set! (-> a1-17 quad) (-> this draw bounds quad))
    (set! (-> a1-17 w) 1.0)
    (vector-matrix*! (-> this draw origin) a1-17 a2-7)
    )
  (set! (-> this draw origin w) (-> this draw bounds w))
  (go (method-of-object this idle))
  (none)
  )

(deftype mtn-plat-return (base-plat)
  ((ride-timer  time-frame)
   (flags       mtn-plat-flags)
   (path-pos    float)
   (dest-pos    float)
   (path-speed  float)
   )
  (:state-methods
    waiting
    running
    waiting-for-no-player
    )
  (:methods
    (mtn-plat-return-method-37 (_type_) none)
    )
  )


(defskelgroup skel-mtn-plat-return mtn-plat-return mtn-plat-return-lod0-jg mtn-plat-return-idle-ja
              ((mtn-plat-return-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.8)
              )

(defstate waiting (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) (mtn-plat-flags mtpflags-0)))))
         (set! (-> self flags) (the-as mtn-plat-flags v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set-time! (-> self ride-timer))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    )
  :trans (behavior ()
    (logclear! (-> self flags) (mtn-plat-flags mtpflags-0))
    (plat-trans)
    (if (not (logtest? (-> self flags) (mtn-plat-flags mtpflags-0)))
        (set-time! (-> self ride-timer))
        )
    (let ((v1-10 (and (time-elapsed? (-> self ride-timer) (seconds 0.5))
                      (logtest? (-> self flags) (mtn-plat-flags mtpflags-0))
                      (if (logtest? (-> self flags) (mtn-plat-flags mtpflags-1))
                          (and *target* (process-grab? *target* #f))
                          #t
                          )
                      )
                 )
          )
      (when v1-10
        (if (= (-> self path-pos) 0.0)
            (set! (-> self dest-pos) 1.0)
            (set! (-> self dest-pos) 0.0)
            )
        (go-virtual running)
        )
      )
    )
  :code sleep-code
  :post plat-post
  )

(defstate running (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) (mtn-plat-flags mtpflags-0)))))
         (set! (-> self flags) (the-as mtn-plat-flags v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (if (= (-> self path-pos) (-> self dest-pos))
        (go-virtual waiting-for-no-player)
        )
    (plat-trans)
    )
  :code sleep-code
  :post (behavior ()
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    )
  )

(defstate waiting-for-no-player (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (let ((v0-0 (the-as object (current-time))))
         (set! (-> self ride-timer) (the-as time-frame v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :trans (behavior ()
    (plat-trans)
    (when (time-elapsed? (-> self ride-timer) (seconds 1))
      (cond
        ((= (-> self path-pos) 1.0)
         (set! (-> self dest-pos) 0.0)
         (go-virtual running)
         )
        (else
          (go-virtual waiting)
          )
        )
      )
    )
  :code sleep-code
  :post plat-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod mtn-plat-return-method-37 ((this mtn-plat-return))
  (go (method-of-object this waiting))
  (none)
  )

(defmethod init-plat-collision! ((this mtn-plat-return))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 19660.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> this root) (the-as collide-shape-moving s5-0))
    )
  0
  (none)
  )

(defmethod init-from-entity! ((this mtn-plat-return) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (init-plat-collision! this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-return" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! this)
  (set! (-> this flags) (mtn-plat-flags))
  (set! (-> this path-pos) 0.0)
  (set! (-> this path) (new 'process 'curve-control this 'path -1000000000.0))
  (if (logtest? (-> this path flags) (path-control-flag not-found))
      (go process-drawable-art-error "error in path")
      )
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((f30-0 (total-distance (-> this path))))
    (set! (-> this path-speed) (/ (res-lump-float arg0 'speed :default 40960.0) f30-0))
    (set! (-> this root pause-adjust-distance) (+ 204800.0 f30-0))
    )
  (set! (-> this sound)
        (new 'process 'ambient-sound (static-sound-spec "mtn-plat-lp" :fo-max 70) (-> this root trans))
        )
  (init-plat! this)
  (mtn-plat-return-method-37 this)
  (none)
  )

(deftype mtn-plat-gap (mtn-plat-return)
  ()
  )


(defstate running (mtn-plat-gap)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (plat-event proc argc message block)
    )
  :trans (behavior ()
    (plat-trans)
    )
  :code sleep-code
  :post (behavior ()
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    )
  )

(defstate waiting (mtn-plat-gap)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (set! (-> self dest-pos) 0.0)
       (go-virtual running)
       )
      (else
        (plat-event proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self path-pos) 1.0)
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    )
  :trans (behavior ()
    (plat-trans)
    )
  :code sleep-code
  :post plat-post
  )

(deftype mtn-button (process-drawable)
  ((on-activate  symbol)
   )
  (:state-methods
    idle
    open
    waiting
    (pressed symbol)
    )
  )


(defskelgroup skel-mtn-button mtn-button mtn-button-lod0-jg mtn-button-open-ja
              ((mtn-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defstate idle (mtn-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code sleep-code
  )

(defstate open (mtn-button)
  :virtual #t
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! mtn-button-open-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual waiting)
    )
  :post rider-post
  )

(defstate waiting (mtn-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('bonk)
       (go-virtual pressed #f)
       )
      )
    )
  :enter (behavior ()
    (ja-no-eval :group! mtn-button-press-ja :num! (seek!) :frame-num 0.0)
    (transform-post)
    )
  :code sleep-code
  )

(defstate pressed (mtn-button)
  :virtual #t
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (let ((gp-0 (-> self on-activate)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root trans))
            )
        )
      (ja-no-eval :group! mtn-button-press-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (transform-post)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja :group! mtn-button-press-ja :num! max)
    (transform-post)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (sleep-code)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-button) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid rideable))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 12288.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 4)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 10240.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this on-activate) (res-lump-struct (-> this entity) 'on-activate symbol))
  (let ((a0-22 (-> this skel root-channel 0)))
    (set! (-> a0-22 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-22 param 0) 1.0)
    (set! (-> a0-22 frame-num) 0.0)
    (joint-control-channel-group! a0-22 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-loop!)
    )
  (transform-post)
  (if (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object this pressed) #t)
      (go (method-of-object this idle))
      )
  (none)
  )

(deftype mtn-gear-device (process-drawable)
  ()
  (:state-methods
    idle
    idle-collapsed
    )
  )


(defskelgroup skel-mtn-gear-device mtn-gear-device mtn-gear-device-lod0-jg mtn-gear-device-idle-ja
              ((mtn-gear-device-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 9 0 16)
              :origin-joint-index 3
              )

(defskelgroup skel-mtn-gear-device-collapse mtn-gear-device mtn-gear-device-collapse-lod0-jg mtn-gear-device-collapse-idle-ja
              ((mtn-gear-device-collapse-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 9 0 40)
              :origin-joint-index 33
              )

(defstate idle (mtn-gear-device)
  :virtual #t
  :code (behavior ()
    (add-process *gui-control* self (gui-channel art-load) (gui-action queue) "mountain-gear-res" -99.0 0)
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (update! (-> self sound))
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

(defstate idle-collapsed (mtn-gear-device)
  :virtual #t
  :code transform-and-sleep-code
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this mtn-gear-device) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (cond
    ((task-complete? *game-info* (game-task mountain-gear))
     (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
       (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 9) 0)))
         (set! (-> s4-0 total-prims) (the-as uint 10))
         (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
         (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> s3-0 prim-core action) (collide-action solid))
         (set! (-> s3-0 transform-index) 0)
         (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 73728.0)
         (set! (-> s4-0 root-prim) s3-0)
         )
       (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-10 prim-core action) (collide-action solid))
         (set! (-> v1-10 transform-index) 7)
         (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
         (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-12 prim-core action) (collide-action solid))
         (set! (-> v1-12 transform-index) 8)
         (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
         (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-14 prim-core action) (collide-action solid))
         (set! (-> v1-14 transform-index) 9)
         (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
         (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-16 prim-core action) (collide-action solid))
         (set! (-> v1-16 transform-index) 12)
         (set-vector! (-> v1-16 local-sphere) 2048.0 0.0 0.0 10240.0)
         )
       (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
         (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-18 prim-core action) (collide-action solid))
         (set! (-> v1-18 transform-index) 23)
         (set-vector! (-> v1-18 local-sphere) 0.0 0.0 -8192.0 45056.0)
         )
       (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 5) (the-as uint 0))))
         (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-20 prim-core action) (collide-action solid))
         (set! (-> v1-20 transform-index) 24)
         (set-vector! (-> v1-20 local-sphere) 0.0 -4096.0 0.0 16384.0)
         )
       (let ((v1-22 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 6) (the-as uint 0))))
         (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-22 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-22 prim-core action) (collide-action solid))
         (set! (-> v1-22 transform-index) 25)
         (set-vector! (-> v1-22 local-sphere) 0.0 -4096.0 0.0 16384.0)
         )
       (let ((v1-24 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 7) (the-as uint 0))))
         (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-24 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-24 prim-core action) (collide-action solid))
         (set! (-> v1-24 transform-index) 34)
         (set-vector! (-> v1-24 local-sphere) 0.0 0.0 0.0 13312.0)
         )
       (let ((v1-26 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 8) (the-as uint 0))))
         (set! (-> v1-26 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-26 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-26 prim-core action) (collide-action solid))
         (set! (-> v1-26 transform-index) 38)
         (set-vector! (-> v1-26 local-sphere) 0.0 0.0 0.0 22528.0)
         )
       (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
       (let ((v1-29 (-> s4-0 root-prim)))
         (set! (-> s4-0 backup-collide-as) (-> v1-29 prim-core collide-as))
         (set! (-> s4-0 backup-collide-with) (-> v1-29 prim-core collide-with))
         )
       (set! (-> this root) s4-0)
       )
     (process-drawable-from-entity! this arg0)
     (initialize-skeleton
       this
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-mtn-gear-device-collapse" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (go (method-of-object this idle-collapsed))
     )
    (else
      (let ((s4-2 (new 'process 'collide-shape this (collide-list-enum hit-by-player))))
        (let ((v1-38 (new 'process 'collide-shape-prim-sphere s4-2 (the-as uint 0))))
          (set! (-> v1-38 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-38 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-38 prim-core action) (collide-action solid))
          (set! (-> v1-38 transform-index) 0)
          (set-vector! (-> v1-38 local-sphere) 0.0 36864.0 0.0 65536.0)
          (set! (-> s4-2 total-prims) (the-as uint 1))
          (set! (-> s4-2 root-prim) v1-38)
          )
        (set! (-> s4-2 nav-radius) (* 0.75 (-> s4-2 root-prim local-sphere w)))
        (let ((v1-41 (-> s4-2 root-prim)))
          (set! (-> s4-2 backup-collide-as) (-> v1-41 prim-core collide-as))
          (set! (-> s4-2 backup-collide-with) (-> v1-41 prim-core collide-with))
          )
        (set! (-> this root) s4-2)
        )
      (process-drawable-from-entity! this arg0)
      (initialize-skeleton
        this
        (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-gear-device" (the-as (pointer uint32) #f)))
        (the-as pair 0)
        )
      (set! (-> this root pause-adjust-distance) 450560.0)
      (add-connection *part-engine* this 24 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 25 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 21 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 22 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 14 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 13 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 15 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 16 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 17 this 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* this 18 this 1492 (new 'static 'vector :w 163840.0))
      (set! (-> this sound)
            (new 'process 'ambient-sound (static-sound-spec "mtn-gear-device" :fo-max 90) (-> this root trans))
            )
      (go (method-of-object this idle))
      )
    )
  (none)
  )

(deftype water-anim-mountain (water-anim)
  ()
  )


(define ripple-for-water-anim-mountain (new 'static 'ripple-wave-set
                                         :count 3
                                         :converted #f
                                         :normal-scale 1.0
                                         :wave (new 'static 'inline-array ripple-wave 4
                                           (new 'static 'ripple-wave :scale 40.0 :xdiv 1 :speed 1.5)
                                           (new 'static 'ripple-wave :scale 40.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                           (new 'static 'ripple-wave :scale 20.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                           (new 'static 'ripple-wave)
                                           )
                                         )
        )

(defmethod init-water! ((this water-anim-mountain))
  "Initialize a [[water-anim]]'s default settings, this may include applying a [[riple-control]]"
  (let ((t9-0 (method-of-type water-anim init-water!)))
    (t9-0 this)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> this draw ripple) v1-2)
    (set-vector! (-> this draw color-mult) 0.01 0.45 0.5 0.75)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-water-anim-mountain)
    )
  0
  (none)
  )

(deftype trans-plat (mtn-plat-return)
  ()
  (:state-methods
    rising
    )
  )


(defstate rising (trans-plat)
  :virtual #t
  :event plat-event
  :code (behavior ()
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (let ((f30-0 (-> self basetrans y))
          (f28-0 24576.0)
          )
      (while (< 0.0 f28-0)
        (set! (-> self basetrans y) (- f30-0 f28-0))
        (plat-trans)
        (set! f28-0 (seek-ease f28-0 0.0 (* 40960.0 (seconds-per-frame)) 2048.0 (* 4096.0 (seconds-per-frame))))
        (suspend)
        )
      )
    (go-virtual waiting)
    )
  :post plat-post
  )

(defstate waiting (trans-plat)
  :virtual #t
  :enter (behavior ()
    (when (not (or (not (task-node-closed? (game-task-node forest-scouts-introduction)))
                   (task-node-closed? (game-task-node forest-scouts-pegasus))
                   (!= (-> self path-pos) 0.0)
                   )
               )
      (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
        (set! (-> gp-0 pos quad) (-> self root trans quad))
        (quaternion-identity! (-> gp-0 quat))
        (set! (-> gp-0 flags) (task-arrow-flags))
        (set! (-> gp-0 map-icon) (the-as uint 15))
        (task-arrow-spawn gp-0 self)
        )
      )
    (let ((t9-5 (-> (the-as state (find-parent-state)) enter)))
      (if t9-5
          ((the-as (function none) t9-5))
          )
      )
    )
  :exit (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (let ((t9-2 (-> (the-as state (find-parent-state)) exit)))
      (if t9-2
          (t9-2)
          )
      )
    )
  :trans (behavior ()
    (cond
      ((task-node-closed? (game-task-node forest-scouts-introduction))
       (logclear! (-> self draw status) (draw-control-status no-draw))
       (let ((v1-3 (-> self root root-prim)))
         (set! (-> v1-3 prim-core collide-as) (-> self root backup-collide-as))
         (set! (-> v1-3 prim-core collide-with) (-> self root backup-collide-with))
         )
       )
      (else
        (logior! (-> self draw status) (draw-control-status no-draw))
        (let ((v1-8 (-> self root root-prim)))
          (set! (-> v1-8 prim-core collide-as) (collide-spec))
          (set! (-> v1-8 prim-core collide-with) (collide-spec))
          )
        0
        )
      )
    (let ((t9-2 (-> (the-as state (find-parent-state)) trans)))
      (if t9-2
          (t9-2)
          )
      )
    )
  )

(defstate running (trans-plat)
  :virtual #t
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type mtn-plat-return running) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (if (logtest? (-> self flags) (mtn-plat-flags mtpflags-0))
        (process-release? *target*)
        )
    )
  )

(defstate waiting-for-no-player (trans-plat)
  :virtual #t
  :trans (behavior ()
    (plat-trans)
    (if (time-elapsed? (-> self ride-timer) (seconds 1))
        (go-virtual waiting)
        )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod mtn-plat-return-method-37 ((this trans-plat))
  (go (method-of-object this rising))
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod init-plat! ((this trans-plat))
  "Does any necessary initial platform setup.
   For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (logior! (-> this flags) (mtn-plat-flags mtpflags-1))
  (let* ((s5-0 *target*)
         (a0-2 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (when a0-2
      (let ((s4-0 (get-trans a0-2 0))
            (s3-0 (-> this path))
            (f28-0 0.0)
            (f30-0 -1.0)
            (s5-1 (-> this path curve num-cverts))
            )
        (dotimes (s2-0 s5-1)
          (let ((f0-2
                  (vector-vector-distance s4-0 (get-point-in-path! s3-0 (new 'stack-no-clear 'vector) (the float s2-0) 'interp))
                  )
                )
            (when (or (= f30-0 -1.0) (< f0-2 f28-0))
              (set! f28-0 f0-2)
              (set! f30-0 (the float s2-0))
              )
            )
          )
        (if (!= f30-0 -1.0)
            (set! (-> this path-pos) (/ f30-0 (+ -1.0 (the float s5-1))))
            )
        )
      )
    )
  (none)
  )
