;;-*-Lisp-*-
(in-package goal)

;; name: race-manager.gc
;; name in dgo: race-manager
;; dgos: STD, STC, LERLCHAL, STB, LPRTRACE

(define-extern race-start (function int symbol symbol process))
(define-extern race-vehicle-entity-hack (function none))
(define-extern start-pilot-recorder (function none))
(declare-type race-bike-a vehicle-city-racer)
(declare-type race-bike-b vehicle-city-racer)
(declare-type race-bike-c vehicle-city-racer)
(declare-type race-bike-d vehicle-race-bike)
(declare-type race-bike-e vehicle-race-bike)
(declare-type bikea bike-base)

;; DECOMP BEGINS

(defun race-find-ground ((arg0 vector) (arg1 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'collide-query)))
      (set! (-> s5-0 start-pos quad) (-> arg1 quad))
      (vector-reset! (-> s5-0 move-dist))
      (set! (-> s5-0 move-dist y) -81920.0)
      (let ((v1-3 s5-0))
        (set! (-> v1-3 radius) 2048.0)
        (set! (-> v1-3 collide-with) (collide-spec backgnd))
        (set! (-> v1-3 ignore-process0) #f)
        (set! (-> v1-3 ignore-process1) #f)
        (set! (-> v1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-3 action-mask) (collide-action solid))
        )
      (let ((f0-2 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
        (when (>= f0-2 0.0)
          (let ((v1-6 (-> s5-0 start-pos)))
            (let ((a0-8 (-> s5-0 move-dist)))
              (let ((a1-2 f0-2))
                (.mov vf7 a1-2)
                )
              (.lvf vf5 (&-> a0-8 quad))
              )
            (.lvf vf4 (&-> v1-6 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> arg0 quad) vf6)
          #t
          )
        )
      )
    )
  )

(defmethod race-info-method-9 race-info ((obj race-info))
  (let ((v1-0 (entity-by-name (-> obj race-mesh-name))))
    (cond
      (v1-0
        (let ((gp-0 (-> (the-as entity-race-mesh v1-0) race-mesh)))
          (set! (-> obj mesh) gp-0)
          (when gp-0
            (let ((s4-0 (-> gp-0 edges 0)))
              (vector-average! (-> obj start-sphere) (-> s4-0 left) (-> s4-0 right))
              (set! (-> obj start-sphere y) (+ 40960.0 (-> obj start-sphere y)))
              (race-find-ground (-> obj start-sphere) (-> obj start-sphere))
              (set! (-> obj start-sphere y) (+ 8192.0 (-> obj start-sphere y)))
              (set! (-> obj start-sphere r) (* 0.5 (vector-vector-distance (-> s4-0 left) (-> s4-0 right))))
              (let ((v1-6 (new 'stack-no-clear 'vector)))
                (vector-! v1-6 (-> s4-0 right) (-> s4-0 left))
                (set-vector! (-> obj start-dir) (-> v1-6 z) 0.0 (- (-> v1-6 x)) 1.0)
                )
              )
            (vector-normalize! (-> obj start-dir) 1.0)
            (let* ((a0-8 (+ (-> gp-0 edge-count) -1))
                   (s4-1 (-> gp-0 edges a0-8))
                   )
              (vector-average! (-> obj finish-sphere) (-> s4-1 left) (-> s4-1 right))
              (set! (-> obj finish-sphere r) (* 0.75 (vector-vector-distance (-> s4-1 left) (-> s4-1 right))))
              (let ((v1-12 (new 'stack-no-clear 'vector)))
                (vector-! v1-12 (-> s4-1 right) (-> s4-1 left))
                (set-vector! (-> obj finish-dir) (-> v1-12 z) 0.0 (- (-> v1-12 x)) 1.0)
                )
              )
            (vector-normalize! (-> obj finish-dir) 1.0)
            (let ((f0-18 (vector-vector-distance-squared (-> obj start-sphere) (-> obj finish-sphere)))
                  (f1-2 163840.0)
                  )
              (if (< f0-18 (* f1-2 f1-2))
                  (logior! (-> gp-0 flags) 1)
                  )
              )
            )
          )
        )
      (else
        (set! (-> obj mesh) #f)
        )
      )
    )
  0
  (none)
  )

(defmethod begin-lap racer-state ((obj racer-state) (arg0 race-state))
  (format #t "begin-lap racer ~d~%" (-> obj rank))
  (set! (-> obj lap-start) (-> arg0 current-time))
  (logior! (-> obj flags) 1)
  0
  (none)
  )

(defmethod end-lap racer-state ((obj racer-state) (arg0 race-state))
  (+! (-> obj lap-count) 1)
  (format #t "end-lap ~d racer ~d~%" (-> obj lap-count) (-> obj rank))
  (let ((v1-2 4)
        (a0-2 3)
        )
    (while (>= a0-2 0)
      (set! (-> obj lap-time-array v1-2) (-> obj lap-time-array a0-2))
      (+! a0-2 -1)
      (+! v1-2 -1)
      )
    )
  (let ((v1-5 (- (-> arg0 current-time) (-> obj lap-start))))
    (set! (-> obj best-lap-time) (the-as uint (min (the-as int (-> obj best-lap-time)) (the-as int v1-5))))
    (set! (-> obj lap-time-array 0) (the-as float v1-5))
    )
  (when (= (-> obj lap-count) (-> arg0 info lap-count))
    (logior! (-> obj flags) 2)
    (set! (-> obj finish-time) (-> arg0 current-time))
    (set! (-> obj finish-count) (-> arg0 finished-count))
    (+! (-> arg0 finished-count) 1)
    (send-event (handle->process (-> obj racer)) 'race-finished (-> arg0 info safe-paths))
    (let ((s4-0 (handle->process (-> obj racer))))
      (cond
        ((zero? (-> obj finish-count))
         (let ((v1-28 (-> obj rider)))
           (cond
             ((zero? v1-28)
              (format #t "racer-state::end-lap: play speech race-jak-win~%")
              (speech-control-method-12
                *speech-control*
                (the-as process-drawable s4-0)
                (speech-type speech-type-1 speech-type-2 speech-type-5)
                )
              )
             ((= v1-28 1)
              (format #t "racer-state::end-lap: play speech race-daxter-win~%")
              (speech-control-method-12
                *speech-control*
                (the-as process-drawable s4-0)
                (speech-type speech-type-0 speech-type-1 speech-type-2 speech-type-3 speech-type-5)
                )
              )
             ((= v1-28 2)
              (format #t "racer-state::end-lap: play speech race-errol-win~%")
              (speech-control-method-12
                *speech-control*
                (the-as process-drawable s4-0)
                (speech-type speech-type-0 speech-type-1 speech-type-2 speech-type-4 speech-type-5)
                )
              )
             )
           )
         )
        (else
          (case (-> obj rider)
            ((2)
             (format #t "racer-state::end-lap: play speech race-errol-lose~%")
             (speech-control-method-12
               *speech-control*
               (the-as process-drawable s4-0)
               (speech-type speech-type-3 speech-type-4 speech-type-5)
               )
             )
            )
          )
        )
      )
    )
  (when (and (> (-> obj lap-count) 0) (= (-> obj lap-count) (+ (-> arg0 info lap-count) -1)))
    (let ((s5-1 (handle->process (-> obj racer)))
          (v1-47 (-> obj rider))
          )
      (cond
        ((zero? v1-47)
         (format #t "racer-state::end-lap: play speech race-jak-last-lap~%")
         (speech-control-method-12 *speech-control* (the-as process-drawable s5-1) (speech-type speech-type-5))
         )
        ((= v1-47 1)
         (format #t "racer-state::end-lap: play speech race-daxter-last-lap~%")
         (speech-control-method-12
           *speech-control*
           (the-as process-drawable s5-1)
           (speech-type speech-type-0 speech-type-3 speech-type-5)
           )
         )
        ((= v1-47 2)
         (format #t "racer-state::end-lap: play speech race-errol-last-lap~%")
         (speech-control-method-12
           *speech-control*
           (the-as process-drawable s5-1)
           (speech-type speech-type-0 speech-type-4 speech-type-5)
           )
         )
        )
      )
    )
  0
  (none)
  )

(defmethod racer-state-method-9 racer-state ((obj racer-state) (arg0 race-state))
  (local-vars (a0-29 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((s5-0 (new 'stack-no-clear 'matrix3)))
        (-> arg0 info)
        (let ((v1-2 (handle->process (-> obj racer))))
          (cond
            (v1-2
              (if (focus-test? (the-as process-focusable v1-2) dead inactive)
                  (logior! (-> obj flags) 4)
                  )
              (set! (-> s5-0 vector 0 quad) (-> (the-as process-focusable v1-2) root-override trans quad))
              (when (not (logtest? (-> obj flags) 6))
                (let ((s3-0 (new 'stack-no-clear 'race-mesh-slice-query)))
                  (set! (-> s3-0 search-sphere quad) (-> s5-0 vector 0 quad))
                  (set! (-> s3-0 search-sphere r) 0.0)
                  (race-mesh-method-13 (-> arg0 info mesh) (the-as race-mesh-slice-query (&-> s3-0 slice-id)))
                  (set! (-> obj lap-distance-prev) (-> obj lap-distance))
                  (cond
                    ((>= (-> s3-0 slice-id) 0)
                     (set! (-> obj lap-distance) (-> s3-0 lap-dist))
                     (if (not (logtest? (-> obj flags) 64))
                         (set! (-> obj lap-distance-prev) (-> obj lap-distance))
                         )
                     (logior! (-> obj flags) 64)
                     )
                    (else
                      (set! (-> obj flags) (logand -65 (-> obj flags)))
                      )
                    )
                  (cond
                    ((logtest? (-> arg0 info mesh flags) 1)
                     (when (>= (-> s3-0 slice-id) 0)
                       (let ((v1-29 (min 3 (the int (* 4.0 (-> s3-0 lap-dist))))))
                         (when (= v1-29 (logand (+ (-> obj lap-quadrant) 1) 3))
                           (set! (-> obj lap-quadrant) v1-29)
                           (when (zero? v1-29)
                             (if (logtest? (-> obj flags) 1)
                                 (end-lap obj arg0)
                                 (begin-race arg0)
                                 )
                             (begin-lap obj arg0)
                             )
                           )
                         )
                       )
                     )
                    ((logtest? (-> obj flags) 1)
                     (let ((v1-39 (new 'stack-no-clear 'vector)))
                       (vector-! (the-as vector (&-> v1-39 x)) (-> obj position) (the-as vector (-> arg0 info finish-sphere)))
                       (.lvf vf1 (&-> (the-as vector (&-> v1-39 x)) quad))
                       (.add.w.vf vf2 vf0 vf0 :mask #b1)
                       (.mul.vf vf1 vf1 vf1)
                       (.mul.x.vf acc vf2 vf1 :mask #b1)
                       (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                       (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                       (.mov a0-29 vf1)
                       (let ((f0-7 a0-29)
                             (f1-1 (-> arg0 info finish-sphere r))
                             )
                         (if (and (< f0-7 (* f1-1 f1-1)) (< 0.0 (vector-dot (the-as vector (&-> v1-39 x)) (-> arg0 info finish-dir))))
                             (end-lap obj arg0)
                             )
                         )
                       )
                     )
                    (else
                      (when (< 0.0 (-> obj lap-distance))
                        (begin-race arg0)
                        (begin-lap obj arg0)
                        )
                      )
                    )
                  )
                (let ((f0-10 (-> arg0 info ai-max-speed-factor)))
                  (if (< (+ (-> arg0 target-pos) (-> obj target-pos-offset)) (-> obj pos))
                      (set! f0-10 (-> arg0 info ai-min-speed-factor))
                      )
                  (seek! (-> obj speed-factor) f0-10 (* 0.2 (-> pp clock seconds-per-frame)))
                  )
                0
                )
              (if (logtest? (-> obj flags) 2)
                  (seek! (-> obj speed-factor) 0.9 (* 0.2 (-> pp clock seconds-per-frame)))
                  )
              (when (logtest? (-> obj flags) 1)
                (dotimes (s3-1 (-> arg0 info decision-point-count))
                  (let ((v1-70 (-> arg0 info decision-point-array s3-1)))
                    (if (and (< (-> obj lap-distance-prev) (-> v1-70 pos)) (>= (-> obj lap-distance) (-> v1-70 pos)))
                        (send-event (handle->process (-> obj racer)) 'race-decision-point v1-70)
                        )
                    )
                  )
                (set! (-> obj pos) (+ (-> obj lap-distance) (the float (-> obj lap-count))))
                )
              (set! (-> obj position quad) (-> s5-0 vector 0 quad))
              )
            (else
              (logior! (-> obj flags) 4)
              )
            )
          )
        )
      (when (logtest? (-> obj flags) 128)
        )
      0
      (none)
      )
    )
  )

(defmethod print-laps racer-state ((obj racer-state) (arg0 race-state) (arg1 string))
  (let ((s4-0 (- (-> arg0 current-time) (-> obj lap-start))))
    (format arg1 "lap count ~d~%" (-> obj lap-count))
    (format arg1 "best lap ")
    (print-time arg1 (the-as time-frame (-> obj best-lap-time)))
    (format arg1 "~%~%")
    (when (logtest? (-> obj flags) 1)
      (format arg1 "this lap ")
      (print-time arg1 (the-as time-frame s4-0))
      )
    )
  (format arg1 "~%")
  (let ((s4-2 (min 5 (-> obj lap-count))))
    (dotimes (s3-0 s4-2)
      (format arg1 "lap ~d " s3-0)
      (print-time arg1 (the-as time-frame (-> obj lap-time-array s3-0)))
      (format arg1 "~%")
      )
    )
  0
  (none)
  )

(defmethod init-racer! racer-state ((obj racer-state) (arg0 process-drawable))
  (set! (-> obj racer) (process->handle arg0))
  (set! (-> obj position quad) (-> arg0 root trans quad))
  (set! (-> obj flags) (the-as uint 128))
  (set! (-> obj lap-count) 0)
  (set! (-> obj lap-distance) 0.0)
  (set! (-> obj lap-quadrant) 3)
  (set! (-> obj finish-time) (the-as uint 0))
  (set! (-> obj pos) 0.0)
  (set! (-> obj target-pos-offset) 0.0)
  (set! (-> obj speed-factor) 1.0)
  (set! (-> obj finish-count) -1)
  (set! (-> obj best-lap-time) (the-as uint #x2dc6c0))
  0
  (none)
  )

(defmethod init-racers! race-state ((obj race-state) (arg0 process-drawable))
  (let ((v1-0 (-> obj racer-count)))
    (when (< v1-0 10)
      (+! (-> obj racer-count) 1)
      (init-racer! (-> obj racer-array v1-0) arg0)
      )
    )
  0
  (none)
  )

(defmethod begin-race race-state ((obj race-state))
  (format #t "begin-race~%")
  (when (not (logtest? (-> obj flags) 1))
    (logior! (-> obj flags) 1)
    (race-state-method-17 obj)
    (send-event (handle->process (-> obj manager)) 'begin-race)
    (set-setting! 'sound-mode #f 0.0 0)
    (remove-setting! 'allow-progress)
    (set! (-> obj race-start-time) (-> obj current-time))
    (let ((s5-0 (handle->process (-> obj manager))))
      (set! (-> obj hud-timer) (ppointer->handle (process-spawn hud-race-timer :init hud-init-by-other :to s5-0)))
      (set! (-> obj hud-position)
            (ppointer->handle (process-spawn hud-race-position :init hud-init-by-other :to s5-0))
            )
      (if (< 1 (-> obj info lap-count))
          (set! (-> obj hud-lap-counter)
                (ppointer->handle (process-spawn hud-race-lap-counter :init hud-init-by-other :to s5-0))
                )
          )
      (when (logtest? (-> obj info flags) 16)
        (set! (-> obj hud-turbo-counter)
              (ppointer->handle (process-spawn hud-race-turbo-counter :init hud-init-by-other :to s5-0))
              )
        (set-setting! 'race-minimap #f 0.0 (-> obj info map-index))
        )
      )
    (dotimes (s5-1 (-> obj racer-count))
      (let ((v1-61 (-> obj racer-array s5-1)))
        (send-event (handle->process (-> v1-61 racer)) 'begin-race)
        )
      )
    (send-event (handle->process (-> obj race-signal)) 'count-go)
    (when (nonzero? (-> obj info go-speech))
      (format #t "playing speech ~d~%" (-> obj info go-speech))
      (talker-spawn-func
        (-> *talker-speech* (-> obj info go-speech))
        *entity-pool*
        (target-pos 0)
        (the-as region #f)
        )
      )
    )
  0
  (none)
  )

(defmethod race-state-method-12 race-state ((obj race-state))
  (let ((v1-0 (new 'stack-no-clear 'array 'float 10)))
    (dotimes (a0-1 (-> obj racer-count))
      (let ((a1-3 (-> obj racer-array a0-1)))
        (cond
          ((logtest? (-> a1-3 flags) 2)
           (set! (-> v1-0 a0-1) (the float (- 1000 (-> a1-3 finish-count))))
           )
          ((logtest? (-> a1-3 flags) 1)
           (set! (-> v1-0 a0-1) (+ (the float (-> a1-3 lap-count)) (-> a1-3 lap-distance)))
           )
          (else
            (set! (-> v1-0 a0-1) 0.0)
            )
          )
        )
      )
    (let ((a0-4 0)
          (a1-16 1)
          )
      (while (< a1-16 (-> obj racer-count))
        (let ((a2-7 (-> obj rankings a0-4))
              (a3-1 (-> obj rankings a1-16))
              )
          (when (< (-> v1-0 a2-7) (-> v1-0 a3-1))
            (set! (-> obj rankings a0-4) a3-1)
            (set! (-> obj rankings a1-16) a2-7)
            )
          )
        (+! a0-4 1)
        (+! a1-16 1)
        )
      )
    )
  (dotimes (s5-0 (-> obj racer-count))
    (let* ((v1-3 (-> obj rankings s5-0))
           (s4-0 (-> obj racer-array v1-3))
           )
      (if (and (zero? s5-0) (nonzero? (-> s4-0 rank)))
          (send-event (handle->process (-> s4-0 racer)) 'race-pass)
          )
      (if (and (nonzero? s5-0) (zero? (-> s4-0 rank)))
          (send-event (handle->process (-> s4-0 racer)) 'race-got-passed)
          )
      (set! (-> s4-0 rank) s5-0)
      )
    )
  0
  (none)
  )

(defmethod race-state-method-13 race-state ((obj race-state))
  (dotimes (s5-0 (-> obj racer-count))
    (let* ((s4-0 (-> obj rankings s5-0))
           (s3-0 (-> obj racer-array s4-0))
           )
      (when (not (logtest? (-> s3-0 flags) 4))
        (if (= s4-0 (-> obj i-player))
            (format *stdcon* ">>>")
            (format *stdcon* "   ")
            )
        (cond
          ((logtest? (-> s3-0 flags) 2)
           (format *stdcon* " #~d  finished " (+ s4-0 1))
           (cond
             ((zero? s5-0)
              (let ((a1-3 (- (-> s3-0 finish-time) (-> obj race-start-time))))
                (print-time *stdcon* (the-as time-frame a1-3))
                )
              )
             (else
               (format *stdcon* "+")
               (let ((a1-7 (- (- (-> s3-0 finish-time) (-> obj race-start-time))
                              (- (-> obj racer-array (-> obj rankings 0) finish-time) (-> obj race-start-time))
                              )
                           )
                     )
                 (print-time *stdcon* (the-as time-frame a1-7))
                 )
               )
             )
           (format *stdcon* "~%")
           )
          (else
            (format *stdcon* " #~d  lap ~d  ~f~%" (+ s4-0 1) (+ (-> s3-0 lap-count) 1) (-> s3-0 lap-distance))
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod race-state-method-14 race-state ((obj race-state))
  (let ((s5-0 0))
    (dotimes (s4-0 (-> obj racer-count))
      (let ((s3-0 (-> obj racer-array s4-0)))
        (racer-state-method-9 s3-0 obj)
        (if (not (logtest? (-> s3-0 flags) 6))
            (+! s5-0 1)
            )
        )
      0
      )
    (if (zero? s5-0)
        (set! (-> obj state) (the-as uint 8))
        )
    )
  0
  (none)
  )

(defmethod race-state-method-18 race-state ((obj race-state))
  (set-setting! 'allow-progress #f 0.0 0)
  (send-event (handle->process (-> obj arrow)) 'leave)
  (when (logtest? (-> obj info flags) 16)
    (send-event *traffic-manager* 'set-target-level 0)
    (send-event *traffic-manager* 'set-alert-level 0)
    )
  (send-event (handle->process (-> obj race-signal)) 'ready)
  (let ((v1-27 (new 'stack-no-clear 'matrix)))
    (vector-reset! (-> v1-27 vector 2))
    (vector-reset! (-> v1-27 trans))
    (let ((a0-21 (-> obj racer-array (-> obj i-player))))
      (let ((a3-1 (handle->process (-> a0-21 racer))))
        (if a3-1
            (set! (-> v1-27 vector 0 quad) (-> (the-as process-drawable a3-1) root trans quad))
            )
        )
      (set! (-> v1-27 vector 1 quad) (-> a0-21 start-position quad))
      )
    (cubic-curve-method-9
      (-> obj player-intro-curve)
      (the-as vector (-> v1-27 vector))
      (-> v1-27 vector 2)
      (-> v1-27 vector 1)
      (-> v1-27 trans)
      )
    )
  (let ((a0-25 (-> obj info hatch-actor-name)))
    (when a0-25
      (let ((a0-26 (process-by-name a0-25 *active-pool*)))
        (send-event a0-26 'open)
        )
      )
    )
  (set! (-> obj countdown-start-time) (-> obj current-time))
  0
  (none)
  )

(defmethod race-state-method-11 race-state ((obj race-state))
  (set! (-> obj current-time) (the-as uint (current-time)))
  (let ((v1-2 (-> obj state)))
    (cond
      ((zero? v1-2)
       (let ((v1-3 (the-as object #t)))
         (when (not (logtest? (-> obj flags) 4))
           (dotimes (s5-0 (-> obj racer-count))
             (let ((a0-7 (-> obj racer-array s5-0)))
               (set! v1-3 (and v1-3 (send-event (handle->process (-> a0-7 racer)) 'test-ready)))
               )
             )
           )
         (when (and v1-3 (not (logtest? (-> obj info flags) 1)))
           (race-state-method-15 obj)
           (set! v1-3 (handle->process (-> obj race-signal)))
           )
         (when v1-3
           (race-state-method-18 obj)
           (set! (-> obj state) (the-as uint (if (or (logtest? (-> obj flags) 2) (logtest? (-> obj info flags) 1))
                                                 5
                                                 1
                                                 )
                                        )
                 )
           )
         )
       )
      ((= v1-2 1)
       (let* ((f30-0 (* 0.0033333334 (the float (- (-> obj current-time) (-> obj countdown-start-time)))))
              (s4-0 (handle->process (-> obj racer-array (-> obj i-player) racer)))
              (s5-1 (if (type? s4-0 process-focusable)
                        s4-0
                        )
                    )
              )
         (cond
           ((< f30-0 1.0)
            (when s5-1
              (cubic-curve-method-10
                (-> obj player-intro-curve)
                (-> (the-as process-focusable s5-1) root-override trans)
                f30-0
                )
              (cubic-curve-method-11
                (-> obj player-intro-curve)
                (-> (the-as process-focusable s5-1) root-override transv)
                f30-0
                )
              (when (< 0.4 f30-0)
                (when (-> obj info start-camera)
                  (set-setting! 'entity-name (-> obj info start-camera) 0.0 0)
                  (if (logtest? (-> obj info flags) 64)
                      (talker-spawn-func (-> *talker-speech* 377) *entity-pool* (target-pos 0) (the-as region #f))
                      )
                  )
                )
              )
            )
           (else
             (set! (-> obj state) (the-as uint 2))
             )
           )
         )
       )
      ((= v1-2 2)
       (let* ((s4-2 (handle->process (-> obj racer-array (-> obj i-player) racer)))
              (s5-3 (if (type? s4-2 process-focusable)
                        s4-2
                        )
                    )
              )
         (when s5-3
           (cubic-curve-method-10
             (-> obj player-intro-curve)
             (-> (the-as process-focusable s5-3) root-override trans)
             1.0
             )
           (vector-reset! (-> (the-as process-focusable s5-3) root-override transv))
           )
         )
       (let ((a0-48 (-> obj info hatch-actor-name)))
         (when a0-48
           (let ((a0-49 (process-by-name a0-48 *active-pool*)))
             (send-event a0-49 'close)
             )
           )
         )
       (set! (-> obj countdown-start-time) (-> obj current-time))
       (set! (-> obj state) (the-as uint (if (-> obj info countdown-scene)
                                             3
                                             5
                                             )
                                    )
             )
       )
      ((= v1-2 3)
       (when (>= (the-as uint (- (current-time) (the-as int (-> obj countdown-start-time)))) (the-as uint 300))
         (set! (-> obj state) (the-as uint 4))
         (set! (-> obj scene-player)
               (ppointer->handle (process-spawn scene-player :init scene-player-init (-> obj info countdown-scene) #t #f))
               )
         )
       )
      ((= v1-2 4)
       (cond
         ((handle->process (-> obj scene-player))
          (let ((s5-5 (-> obj info)))
            (dotimes (s4-3 (-> s5-5 racer-count))
              (let ((v1-95 (-> obj racer-array s4-3)))
                (if (logtest? (-> s5-5 racer-array s4-3 flags) 1)
                    (send-event (handle->process (-> v1-95 racer)) 'hide)
                    )
                )
              )
            )
          )
         (else
           (let ((s5-6 (-> obj info)))
             (dotimes (s4-4 (-> s5-6 racer-count))
               (let ((v1-105 (-> obj racer-array s4-4)))
                 (if (logtest? (-> s5-6 racer-array s4-4 flags) 1)
                     (send-event (handle->process (-> v1-105 racer)) 'unhide)
                     )
                 )
               )
             )
           (set! (-> obj state) (the-as uint 5))
           )
         )
       )
      ((= v1-2 5)
       (set! (-> obj i-countdown) 4)
       (set! (-> obj state) (the-as uint 6))
       (set! (-> obj countdown-start-time) (-> obj current-time))
       (remove-setting! 'entity-name)
       )
      ((= v1-2 6)
       (let ((f0-3 3.0))
         (if (logtest? (-> obj info flags) 1)
             (set! f0-3 0.2)
             )
         (let ((v1-127 (+ (the int (* 300.0 f0-3)) (- (-> obj countdown-start-time) (-> obj current-time)))))
           (cond
             ((>= v1-127 (the int (* 225.0 f0-3)))
              )
             ((>= v1-127 (the int (* 150.0 f0-3)))
              (when (!= (-> obj i-countdown) 3)
                (set! (-> obj i-countdown) 3)
                (send-event (handle->process (-> obj race-signal)) 'count-3)
                )
              )
             ((>= v1-127 (the int (* 75.0 f0-3)))
              (when (!= (-> obj i-countdown) 2)
                (set! (-> obj i-countdown) 2)
                (send-event (handle->process (-> obj race-signal)) 'count-2)
                )
              )
             ((< (the int (* 0.0 f0-3)) v1-127)
              (when (!= (-> obj i-countdown) 1)
                (set! (-> obj i-countdown) 1)
                (send-event (handle->process (-> obj race-signal)) 'count-1)
                )
              )
             (else
               (set! (-> obj i-countdown) 0)
               (set! (-> obj state) (the-as uint 7))
               (begin-race obj)
               )
             )
           )
         )
       (race-state-method-14 obj)
       )
      ((= v1-2 7)
       (race-state-method-14 obj)
       (race-state-method-12 obj)
       )
      ((= v1-2 8)
       )
      (else
        )
      )
    )
  (dotimes (s5-7 (-> obj info turbo-pad-count))
    (let ((s4-5 (-> obj info turbo-pad-array s5-7)))
      (if (not (handle->process (-> s4-5 handle)))
          (set! (-> s4-5 handle)
                (process->handle (turbo-pickup-spawn (handle->process (-> obj manager)) (-> s4-5 position)))
                )
          )
      )
    )
  0
  (none)
  )

(defmethod race-state-method-15 race-state ((obj race-state))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (when (= (level-status *level* 'lracelit) 'active)
      (let ((s3-0 (-> obj info))
            (s5-1 (handle->process (-> obj manager)))
            (s4-0 (new 'stack-no-clear 'matrix))
            )
        (vector-float*! (-> s4-0 vector 2) (-> s3-0 start-dir) -1.0)
        (forward-up-nopitch->quaternion
          (the-as quaternion (-> s4-0 vector 1))
          (-> s4-0 vector 2)
          (new 'static 'vector :y 1.0 :w 1.0)
          )
        (let ((a0-7 (-> s4-0 vector)))
          (let ((v1-8 (-> s3-0 start-sphere)))
            (let ((a1-4 (-> s3-0 start-dir)))
              (let ((a2-2 49152.0))
                (.mov vf7 a2-2)
                )
              (.lvf vf5 (&-> a1-4 quad))
              )
            (.lvf vf4 (&-> v1-8 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a0-7 0 quad) vf6)
          )
        (set! (-> s4-0 vector 0 y) (+ 22528.0 (-> s4-0 vector 0 y)))
        (set! (-> obj race-signal)
              (process->handle
                (race-signal-spawn s5-1 (the-as vector (-> s4-0 vector)) (the-as quaternion (-> s4-0 vector 1)))
                )
              )
        )
      )
    0
    (none)
    )
  )

(defmethod initialize race-state ((obj race-state) (arg0 process) (arg1 race-info))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s3-0 (-> obj flags)))
      (mem-set32! (the-as pointer obj) 324 0)
      (set! (-> obj flags) s3-0)
      )
    (set! (-> obj info) arg1)
    (set! (-> obj manager) (process->handle arg0))
    (set! (-> obj scene-player) (the-as handle #f))
    (set! (-> obj hud-timer) (the-as handle #f))
    (set! (-> obj hud-lap-counter) (the-as handle #f))
    (set! (-> obj hud-turbo-counter) (the-as handle #f))
    (set! (-> obj hud-position) (the-as handle #f))
    (set! (-> obj arrow) (the-as handle #f))
    (set! (-> obj state) (the-as uint 0))
    (set! (-> obj racer-count) 0)
    (set! (-> obj finished-count) 0)
    (let ((v1-3 (new 'stack-no-clear 'mystery-race-manager-type)))
      (set! (-> v1-3 vec1 z) 81920.0)
      (set! (-> v1-3 word) 4)
      (set! (-> v1-3 vec0 z) (* -0.5 (-> v1-3 vec1 z)))
      (set! (-> v1-3 vec0 w) -20480.0)
      (set! (-> v1-3 vec1 x) (/ (-> v1-3 vec1 z) (the float (+ (-> v1-3 word) -1))))
      (set! (-> v1-3 vec1 y) -40960.0)
      (set! (-> v1-3 mat quad 0) (-> arg1 start-sphere quad))
      (set! (-> v1-3 mat vector 1 quad) (-> arg1 start-dir quad))
      (set-vector! (-> v1-3 mat vector 2) (-> v1-3 mat vector 1 z) 0.0 (- (-> v1-3 mat vector 1 x)) 1.0)
      (dotimes (a0-15 (-> arg1 racer-count))
        (let ((a1-8 (/ a0-15 (-> v1-3 word))))
          (let ((a2-4 (- a0-15 (* a1-8 (-> v1-3 word)))))
            (set! (-> v1-3 vec0 x) (+ (-> v1-3 vec0 z) (* (-> v1-3 vec1 x) (the float a2-4))))
            )
          (set! (-> v1-3 vec0 y) (+ (-> v1-3 vec0 w) (* (-> v1-3 vec1 y) (the float a1-8))))
          )
        (let ((a1-13 (-> obj racer-array a0-15)))
          (-> arg1 racer-array a0-15)
          (set! (-> v1-3 mat trans quad) (-> v1-3 mat quad 0))
          (let ((t0-0 (-> v1-3 mat trans)))
            (let ((a2-8 (-> v1-3 mat trans)))
              (let ((a3-3 (-> v1-3 mat vector 1)))
                (let ((t1-0 (-> v1-3 vec0 y)))
                  (.mov vf7 t1-0)
                  )
                (.lvf vf5 (&-> a3-3 quad))
                )
              (.lvf vf4 (&-> a2-8 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> t0-0 quad) vf6)
            )
          (let ((t0-1 (-> v1-3 mat trans)))
            (let ((a2-9 (-> v1-3 mat trans)))
              (let ((a3-4 (-> v1-3 mat vector 2)))
                (let ((t1-1 (-> v1-3 vec0 x)))
                  (.mov vf7 t1-1)
                  )
                (.lvf vf5 (&-> a3-4 quad))
                )
              (.lvf vf4 (&-> a2-9 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> t0-1 quad) vf6)
            )
          (set! (-> a1-13 start-position quad) (-> v1-3 mat trans quad))
          (set! (-> a1-13 rank) a0-15)
          (set! (-> a1-13 speed-factor) 1.0)
          )
        (set! (-> obj rankings a0-15) a0-15)
        )
      )
    (dotimes (v1-6 (-> obj info turbo-pad-count))
      (set! (-> obj info turbo-pad-array v1-6 handle) (the-as handle #f))
      )
    (let ((v1-12 (-> *game-info* sub-task-list (-> arg1 task-node))))
      (set! (-> obj suck-factor) 0.0)
      (if (not (logtest? (-> arg1 flags) 32))
          (set! (-> obj suck-factor) (fmax 0.0 (fmin 1.0 (* 0.2 (+ -4.0 (the float (-> v1-12 death-count)))))))
          )
      (format
        #t
        "race-state::initialize: death-count ~d, suck-factor ~f~%"
        (-> v1-12 death-count)
        (-> obj suck-factor)
        )
      )
    0
    (none)
    )
  )

(define *race-state* (new 'static 'race-state))

(define *race-rigid-body-queue* (new 'static 'rigid-body-queue))

(defmethod race-manager-method-20 race-manager ((obj race-manager))
  (let ((s5-0 *display-race-marks*))
    (when (logtest? s5-0 (race-marks-controls rmc2040))
      (let ((a0-3 (entity-by-name (-> *race-info-array* *select-race* race-mesh-name))))
        (when a0-3
          (let ((s4-0 (-> (the-as entity-race-mesh a0-3) race-mesh)))
            (when s4-0
              (let ((s3-0 8))
                (dotimes (s2-0 8)
                  (if (logtest? s5-0 s3-0)
                      (debug-draw-path-from-history s4-0 s2-0 0)
                      )
                  (set! s3-0 (* s3-0 2))
                  )
                )
              )
            )
          )
        )
      )
    )
  (let ((v1-14 (new 'stack-no-clear 'inline-array 'vector 5)))
    (let ((a0-6 (-> obj race-state info)))
      (set! (-> v1-14 0 quad) (-> a0-6 start-sphere quad))
      (set! (-> v1-14 1 quad) (-> a0-6 start-dir quad))
      )
    (set! (-> v1-14 2 y) 0.0)
    (set! (-> v1-14 2 x) (- (-> v1-14 1 z)))
    (set! (-> v1-14 2 z) (-> v1-14 1 x))
    (vector-float*! (-> v1-14 3) (-> v1-14 2) (-> v1-14 0 w))
    (vector+! (-> v1-14 4) (-> v1-14 0) (-> v1-14 3))
    (vector-! (-> v1-14 5) (-> v1-14 0) (-> v1-14 3))
    )
  0
  (race-state-method-11 (-> obj race-state))
  0
  (none)
  )

(defmethod race-manager-method-22 race-manager ((obj race-manager))
  0
  (none)
  )

(defmethod race-manager-method-23 race-manager ((obj race-manager))
  (let ((s5-0 (-> obj race-state info)))
    (race-info-method-9 s5-0)
    (initialize (-> obj race-state) obj s5-0)
    )
  (let ((v1-5 *game-info*))
    (set! (-> v1-5 race-position) 0)
    (set! (-> v1-5 race-current-lap-count) 0)
    (set! (-> v1-5 race-total-lap-count) 0)
    (set! (-> v1-5 race-timer) (the-as uint 0))
    (set! (-> v1-5 race-number-turbos) 0)
    )
  0
  0
  (none)
  )

;; ERROR: Unsupported inline assembly instruction kind - [mfc0 v1, Count]
(defmethod initialize-state race-manager ((obj race-manager))
  (local-vars
    (v1-0 int)
    (sv-352 task-arrow-params)
    (sv-368 (function process type traffic-object-spawn-params process-drawable))
    (sv-384 race-manager)
    (sv-400 process-drawable)
    (sv-416 int)
    )
  (.mfc0 v1-0 Count)
  (rigid-body-queue-manager-spawn *race-rigid-body-queue* obj)
  (let* ((gp-0 (-> obj race-state))
         (s3-0 (-> gp-0 info))
         )
    (if (or (logtest? (-> s3-0 flags) 2) (logtest? (continue-flags pilot) (-> *game-info* last-continue flags)))
        (logior! (-> gp-0 flags) 2)
        )
    (let ((s4-0 (new 'stack-no-clear 'mystery-traffic-object-spawn-params)))
      (set! (-> s4-0 vector 0 quad) (-> gp-0 info start-sphere quad))
      (set! (-> s4-0 vector 1 quad) (-> gp-0 info start-dir quad))
      (set-vector! (-> s4-0 vector 2) (-> s4-0 vector 1 z) 0.0 (- (-> s4-0 vector 1 x)) 1.0)
      (set! (-> s4-0 params object-type) (traffic-type tt17))
      (set! (-> s4-0 params behavior) (the-as uint 10))
      (set! (-> s4-0 params id) (the-as uint 0))
      (set! (-> s4-0 params nav-mesh) #f)
      (set! (-> s4-0 params nav-branch) #f)
      (set! (-> s4-0 params proc) #f)
      (set! (-> s4-0 params handle) (the-as handle #f))
      (set! (-> s4-0 params user-data) (the-as uint 0))
      (set! (-> s4-0 params flags) (traffic-spawn-flags))
      (set! (-> s4-0 params guard-type) (the-as uint 7))
      (vector-reset! (-> s4-0 params velocity))
      (set! (-> gp-0 i-player) 0)
      (forward-up-nopitch->quaternion
        (-> s4-0 params rotation)
        (-> s4-0 vector 1)
        (new 'static 'vector :y 1.0 :w 1.0)
        )
      (set! (-> gp-0 race-signal) (the-as handle #f))
      (cond
        ((and *debug-segment* *target* *race-record-path*)
         (let ((s2-0 (the-as race-racer-info #f)))
           (dotimes (v1-18 (-> s3-0 racer-count))
             (let* ((a0-13 (-> s3-0 racer-array v1-18))
                    (a1-6 (-> a0-13 rider))
                    )
               (if (or (zero? a1-6) (= a1-6 1))
                   (set! s2-0 a0-13)
                   )
               )
             )
           (if (not s2-0)
               (format 0 "race-manager::initialize-state: no player found~%")
               )
           (when s2-0
             (set! (-> s4-0 params id) (the-as uint 0))
             (set! (-> gp-0 i-player) 0)
             (set! (-> s4-0 params position quad) (-> *target* control trans quad))
             (quaternion-copy! (-> s4-0 params rotation) (-> *target* control quat))
             (set! (-> s4-0 params position y) (+ 12288.0 (-> s4-0 params position y)))
             (set! (-> s4-0 params behavior) (the-as uint 4))
             (logclear! (-> s4-0 params flags) (traffic-spawn-flags trsflags-01))
             (let ((s5-1 (vehicle-spawn obj (type-from-race-vehicle-type (-> s2-0 vehicle)) (-> s4-0 params))))
               (when s5-1
                 (init-racers! gp-0 s5-1)
                 (send-event *target* 'change-mode 'pilot s5-1 0 #t)
                 (start-pilot-recorder)
                 )
               (if (not s5-1)
                   (format 0 "failed to spawn racebike~%")
                   )
               )
             )
           )
         )
        (else
          (set! (-> gp-0 racer-count) (-> s3-0 racer-count))
          (dotimes (s2-1 (-> s3-0 racer-count))
            (let ((s0-0 (-> gp-0 racer-array s2-1))
                  (s1-0 (-> s3-0 racer-array s2-1))
                  )
              36
              (set! (-> s4-0 params position quad) (-> s0-0 start-position quad))
              (set! (-> s4-0 params id) (the-as uint s2-1))
              (set! (-> s4-0 params user-data) (-> s1-0 rider))
              (logior! (-> s4-0 params flags) (traffic-spawn-flags trsflags-01))
              (let ((v1-48 (-> s1-0 rider)))
                (cond
                  ((or (zero? v1-48) (= v1-48 1))
                   (set! (-> gp-0 i-player) s2-1)
                   (when (not (or (logtest? (-> gp-0 flags) 10) (logtest? (-> s3-0 flags) 1)))
                     (set! sv-352 (new 'stack-no-clear 'task-arrow-params))
                     (set! (-> sv-352 pos quad) (-> gp-0 info player-intro-pos quad))
                     (quaternion-identity! (-> sv-352 quat))
                     (set! (-> sv-352 flags) (task-arrow-flags))
                     (set! (-> sv-352 map-icon) (the-as uint 15))
                     (let ((t9-11 task-arrow-spawn)
                           (a1-17 obj)
                           )
                       (set! (-> gp-0 arrow) (process->handle (t9-11 sv-352 (the-as task-arrow a1-17))))
                       )
                     (set! (-> s4-0 params position quad) (-> gp-0 info player-intro-pos quad))
                     (set! (-> s4-0 params position y) (+ 12288.0 (-> s4-0 params position y)))
                     )
                   (logclear! (-> s4-0 params flags) (traffic-spawn-flags trsflags-01))
                   (set! sv-416 37)
                   sv-416
                   )
                  ((= v1-48 2)
                   (set! sv-416 38)
                   sv-416
                   )
                  (else
                    (set! sv-416 36)
                    sv-416
                    )
                  )
                )
              (when (not (and (logtest? (-> gp-0 flags) 8) (logtest? (-> s1-0 flags) 1)))
                (set! sv-368 vehicle-spawn)
                (set! sv-384 obj)
                (let ((a1-18 (type-from-race-vehicle-type (-> s1-0 vehicle)))
                      (a2-3 (-> s4-0 params))
                      )
                  (set! sv-400 (sv-368 sv-384 a1-18 a2-3))
                  )
                (when sv-400
                  (let ((a0-52 *minimap*)
                        (t9-14 (method-of-type minimap add-icon!))
                        (a1-19 sv-400)
                        (a3-0 #f)
                        (t0-0 #t)
                        (t1-0 0)
                        )
                    (t9-14 a0-52 a1-19 (the-as uint sv-416) (the-as int a3-0) (the-as vector t0-0) t1-0)
                    )
                  (init-racer! s0-0 sv-400)
                  (set! (-> s0-0 rider) (-> s1-0 rider))
                  (set! (-> s0-0 target-pos-offset)
                        (* (-> s3-0 ai-spread-factor) (+ (the float (-> s1-0 seek-offset)) (* -3.33 (-> gp-0 suck-factor))))
                        )
                  (when (and (= s2-1 (-> gp-0 i-player)) (logtest? (-> gp-0 flags) 2))
                    (let ((v1-91 'pilot))
                      (if (= (-> s1-0 rider) 1)
                          (set! v1-91 'pilot-daxter)
                          )
                      (send-event *target* 'change-mode v1-91 sv-400 0 #t)
                      )
                    )
                  )
                (if (not sv-400)
                    (format 0 "failed to spawn racebike~%")
                    )
                )
              )
            )
          )
        )
      )
    )
  0
  0
  (none)
  )

(defmethod race-manager-method-26 race-manager ((obj race-manager) (arg0 float))
  (local-vars (sv-32 int))
  (let* ((s5-0 (-> obj race-state info score))
         (s3-0 0)
         (s2-0 (-> *highscore-info-array* s5-0))
         )
    (let ((s0-0 (get-game-score-ref *game-info* (the-as int s5-0)))
          (s1-0 (new 'stack-no-clear 'array 'int8 4))
          )
      (dotimes (v1-5 4)
        (set! (-> s1-0 v1-5) 0)
        )
      (set! sv-32 0)
      (while (< sv-32 8)
        (let ((v1-13 (get-rank s2-0 (-> s0-0 sv-32))))
          (+! (-> s1-0 v1-13) 1)
          )
        (set! sv-32 (+ sv-32 1))
        )
      (dotimes (v1-20 4)
        (if (< 1 (-> s1-0 v1-20))
            (set! s3-0 v1-20)
            )
        )
      )
    (let* ((v1-24 (get-rank s2-0 arg0))
           (s2-2 (max 0 (- v1-24 s3-0)))
           )
      (when (> (the-as uint s2-2) 0)
        (set! (-> obj finish-sound-id) (the-as sound-id 1))
        (cond
          ((= v1-24 3)
           (talker-spawn-func (-> *talker-speech* 374) *entity-pool* (target-pos 0) (the-as region #f))
           )
          ((= v1-24 2)
           (talker-spawn-func (-> *talker-speech* 375) *entity-pool* (target-pos 0) (the-as region #f))
           )
          ((= v1-24 1)
           (talker-spawn-func (-> *talker-speech* 376) *entity-pool* (target-pos 0) (the-as region #f))
           )
          )
        )
      (game-info-method-28 *game-info* (the-as game-score s5-0) arg0)
      ;; pc port note : just give the skill directly
      (#cond
        (PC_PORT
          (send-event *target* 'get-pickup (pickup-type skill) (* (the float s2-2) (-> *FACT-bank* super-skill-inc))))
        (#t
          (let ((gp-1 (new 'static 'fact-info)))
            (set! (-> gp-1 options) (actor-option))
            (logior! (-> gp-1 options) (actor-option suck-in))
            (birth-pickup-at-point
              (camera-pos)
              (pickup-type skill)
              (* (the float s2-2) (-> *FACT-bank* super-skill-inc))
              #t
              *entity-pool*
              gp-1
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod race-manager-method-27 race-manager ((obj race-manager))
  (set-action!
    *gui-control*
    (gui-action stop)
    (the-as sound-id 1)
    (gui-channel guard)
    (gui-action none)
    (the-as string #f)
    (the-as (function gui-connection symbol) #f)
    (the-as process #f)
    )
  (set-action!
    *gui-control*
    (gui-action stop)
    (the-as sound-id 1)
    (gui-channel background)
    (gui-action none)
    (the-as string #f)
    (the-as (function gui-connection symbol) #f)
    (the-as process #f)
    )
  0
  (none)
  )

(defmethod race-manager-method-24 race-manager ((obj race-manager))
  (when (= (get-status *gui-control* (-> obj message-id)) (gui-status active))
    (let ((gp-1
            (new 'stack 'font-context *font-default-matrix* 70 20 0.0 (font-color orange) (font-flags shadow kerning))
            )
          )
      (let ((v1-4 gp-1))
        (set! (-> v1-4 scale) 0.7)
        )
      (let ((v1-5 gp-1))
        (set! (-> v1-5 width) (the float 225))
        )
      (let ((v1-6 gp-1))
        (set! (-> v1-6 height) (the float 70))
        )
      (set! (-> gp-1 origin x) (the float (- 256 (the int (* 0.5 (-> gp-1 width))))))
      (set! (-> gp-1 origin y) 320.0)
      (set! (-> gp-1 flags) (font-flags shadow kerning middle left large))
      (let ((s5-0 print-game-text))
        (format (clear *temp-string*) (lookup-text! *common-text* (text-id progress-x-to-continue) #f) 1)
        (s5-0 *temp-string* gp-1 #f 44 (bucket-id progress))
        )
      )
    )
  0
  (none)
  )

(defmethod race-manager-method-25 race-manager ((obj race-manager))
  (when (= (get-status *gui-control* (-> obj message-id)) (gui-status active))
    (let ((gp-1
            (new 'stack 'font-context *font-default-matrix* 70 20 0.0 (font-color orange) (font-flags shadow kerning))
            )
          )
      (let ((v1-4 gp-1))
        (set! (-> v1-4 scale) 0.7)
        )
      (let ((v1-5 gp-1))
        (set! (-> v1-5 width) (the float 240))
        )
      (let ((v1-6 gp-1))
        (set! (-> v1-6 height) (the float 35))
        )
      (set! (-> gp-1 origin x) (the float (- 256 (the int (* 0.5 (-> gp-1 width))))))
      (set! (-> gp-1 origin y) 320.0)
      (set! (-> gp-1 flags) (font-flags shadow kerning middle left large))
      (let ((s5-0 print-game-text))
        (format (clear *temp-string*) (lookup-text! *common-text* (text-id try-again?) #f) 1)
        (s5-0 *temp-string* gp-1 #f 44 (bucket-id progress))
        )
      (set! (-> gp-1 origin y) (+ 35.0 (-> gp-1 origin y)))
      (let ((s5-1 print-game-text))
        (format (clear *temp-string*) (lookup-text! *common-text* (text-id yes-no-prompt) #f) 1)
        (s5-1 *temp-string* gp-1 #f 44 (bucket-id progress))
        )
      )
    )
  0
  (none)
  )

(defbehavior race-manager-event-handler race-manager ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('die)
     (go-virtual die)
     )
    (('force-start)
     (let ((v0-0 (the-as object (logior (-> self race-state flags) 4))))
       (set! (-> self race-state flags) (the-as uint v0-0))
       v0-0
       )
     )
    (('begin-race)
     (send-event (ppointer->process (-> self parent)) 'fail-on-death #t)
     )
    (('win)
     0
     )
    (('lose)
     0
     )
    )
  )

(defstate idle (race-manager)
  :virtual #t
  :event race-manager-event-handler
  :code (behavior ()
    (cond
      ((logtest? (-> self race-state flags) 8)
       (race-manager-method-23 self)
       (initialize-state self)
       (until #f
         (suspend)
         )
       #f
       )
      (else
        (set-setting! 'music 'race 0.0 0)
        (set-setting! 'sound-mode #f 0.0 2)
        (let ((gp-0 (-> self race-state info)))
          (when (logtest? (-> gp-0 flags) 16)
            (set-setting! 'borrow (-> gp-0 borrow) 0.0 0)
            (while (!= (level-status *level* 'lracelit) 'active)
              (suspend)
              )
            (while (!= (level-status *level* (-> gp-0 borrow-level)) 'active)
              (suspend)
              )
            )
          )
        (while (not (and *target* (or (not (focus-test? *target* teleporting)) (focus-test? *target* pilot))))
          (suspend)
          )
        (race-manager-method-23 self)
        (initialize-state self)
        (suspend)
        (let ((gp-1 (-> self race-state info)))
          (when (and (-> gp-1 countdown-scene) (not (logtest? (-> self race-state flags) 2)))
            (dotimes (s5-2 (-> gp-1 racer-count))
              (let ((v1-42 (-> self race-state racer-array s5-2)))
                (if (and (logtest? (-> gp-1 racer-array s5-2 flags) 1) (!= s5-2 (-> self race-state i-player)))
                    (send-event (handle->process (-> v1-42 racer)) 'hide)
                    )
                )
              )
            )
          )
        (when (and *debug-segment* *target* *race-record-path*)
          (until #f
            (race-manager-method-20 self)
            (suspend)
            )
          #f
          )
        )
      )
    (go-virtual active)
    (none)
    )
  )

(defstate active (race-manager)
  :virtual #t
  :event race-manager-event-handler
  :code (the-as (function none :behavior race-manager) sleep-code)
  :post (behavior ()
    (race-manager-method-20 self)
    (let ((gp-0 (-> self race-state racer-array (-> self race-state i-player)))
          (s5-0 (-> self race-state))
          )
      (set! (-> s5-0 target-pos) (-> gp-0 pos))
      (let ((v1-5 *game-info*))
        (set! (-> v1-5 race-position) (-> gp-0 rank))
        (set! (-> v1-5 race-current-lap-count) (min (+ (-> gp-0 lap-count) 1) (-> self race-state info lap-count)))
        (set! (-> v1-5 race-total-lap-count) (-> self race-state info lap-count))
        (let ((a0-12 (-> s5-0 current-time)))
          (if (logtest? (-> gp-0 flags) 2)
              (set! a0-12 (-> gp-0 finish-time))
              )
          (let ((a0-13 (the-as int (- a0-12 (-> s5-0 race-start-time)))))
            (if (not (logtest? (-> s5-0 flags) 1))
                (set! a0-13 0)
                )
            (set! (-> v1-5 race-timer) (the-as uint a0-13))
            )
          )
        )
      (when (logtest? (-> gp-0 flags) 1)
        (cond
          ((logtest? (-> gp-0 flags) 64)
           (set! (-> self player-on-track-time) (current-time))
           )
          (else
            (when (>= (- (current-time) (-> self player-on-track-time)) (seconds 1))
              (let ((v1-16 (handle->process (-> gp-0 racer))))
                (when v1-16
                  (when (logtest? (-> (the-as vehicle-racer v1-16) flags) (rigid-body-object-flag on-ground))
                    (let ((a1-13 (new 'stack-no-clear 'event-message-block)))
                      (set! (-> a1-13 from) (process->ppointer self))
                      (set! (-> a1-13 num-params) 2)
                      (set! (-> a1-13 message) 'attack-invinc)
                      (set! (-> a1-13 param 0) (the-as uint #f))
                      (let ((v1-23 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                        (let* ((a0-24 *game-info*)
                               (a2-1 (+ (-> a0-24 attack-id) 1))
                               )
                          (set! (-> a0-24 attack-id) a2-1)
                          (set! (-> v1-23 id) a2-1)
                          )
                        (set! (-> v1-23 mode) 'instant-death)
                        (set! (-> a1-13 param 1) (the-as uint v1-23))
                        )
                      (if (send-event-function *target* a1-13)
                          (go-virtual fail)
                          )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (if (or (logtest? (-> gp-0 flags) 4) (not *target*) (focus-test? *target* dead))
          (go-virtual fail)
          )
      (when (logtest? (-> gp-0 flags) 2)
        (when (not (logtest? (-> gp-0 flags) 32))
          (logior! (-> gp-0 flags) 32)
          (let ((f0-2 (* 0.0033333334 (the float (- (-> gp-0 finish-time) (-> s5-0 race-start-time))))))
            (race-manager-method-26 self f0-2)
            )
          )
        (send-event (ppointer->process (-> self parent)) 'allow-fail #f)
        (if (not (logtest? (-> self race-state info flags) 16))
            (set-setting! 'sound-mode #f 0.0 2)
            )
        (set! (-> self message-id)
              (add-process *gui-control* self (gui-channel supertitle) (gui-action play) "fail" 81920.0 0)
              )
        (when #t
          (if (zero? (-> gp-0 finish-count))
              (go-virtual win)
              (go-virtual lose)
              )
          )
        )
      )
    (none)
    )
  )

(defstate win (race-manager)
  :virtual #t
  :event race-manager-event-handler
  :code (behavior ()
    (if (zero? (-> self finish-sound-id))
        (set! (-> self finish-sound-id)
              (add-process *gui-control* *target* (gui-channel background) (gui-action play) "miss001" -99.0 0)
              )
        )
    (send-event (ppointer->process (-> self parent)) 'race-win)
    (send-event (handle->process (-> self race-state hud-timer)) 'force-hide)
    (send-event (handle->process (-> self race-state hud-lap-counter)) 'force-hide)
    (send-event (handle->process (-> self race-state hud-turbo-counter)) 'force-hide)
    (process-spawn hud-race-final-stats :init hud-init-by-other :to self)
    (set! (-> self state-time) (current-time))
    (when (logtest? (-> self race-state info flags) 4)
      (send-event (ppointer->process (-> self parent)) 'complete)
      (sleep-code)
      )
    (#when PC_PORT
      ;; auto-save when a race is won
      (auto-save-user))
    (until #f
      (cond
        ((logtest? (-> self race-state info flags) 8)
         (race-manager-method-25 self)
         (when (>= (- (current-time) (-> self state-time)) (seconds 0.5))
           (cond
             ((logtest? (pad-buttons confirm) (-> *cpad-list* cpads 0 button0-rel 0))
              (race-manager-method-27 self)
              (send-event (ppointer->process (-> self parent)) 'retry-immediately)
              (sleep-code)
              )
             ((cpad-pressed? 0 triangle)
              (race-manager-method-27 self)
              (send-event (ppointer->process (-> self parent)) 'fail-immediately)
              (sleep-code)
              )
             )
           )
         )
        (else
          (race-manager-method-24 self)
          (when (>= (- (current-time) (-> self state-time)) (seconds 0.5))
            (when (logtest? (pad-buttons confirm) (-> *cpad-list* cpads 0 button0-rel 0))
              (race-manager-method-27 self)
              (send-event (ppointer->process (-> self parent)) 'complete)
              (sleep-code)
              )
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (race-manager-method-20 self)
    (none)
    )
  )

(defstate lose (race-manager)
  :virtual #t
  :event race-manager-event-handler
  :code (behavior ()
    (if (zero? (-> self finish-sound-id))
        (set! (-> self finish-sound-id)
              (add-process *gui-control* *target* (gui-channel background) (gui-action play) "lose1" -99.0 0)
              )
        )
    (send-event (ppointer->process (-> self parent)) 'race-lose)
    (send-event (handle->process (-> self race-state hud-timer)) 'force-hide)
    (send-event (handle->process (-> self race-state hud-lap-counter)) 'force-hide)
    (send-event (handle->process (-> self race-state hud-turbo-counter)) 'force-hide)
    (process-spawn hud-race-final-stats :init hud-init-by-other :to self)
    (set! (-> self state-time) (current-time))
    (until #f
      (race-manager-method-25 self)
      (-> self race-state info)
      (when (>= (- (current-time) (-> self state-time)) (seconds 0.5))
        (cond
          ((logtest? (pad-buttons confirm) (-> *cpad-list* cpads 0 button0-rel 0))
           (race-manager-method-27 self)
           (send-event (ppointer->process (-> self parent)) 'retry-immediately)
           (sleep-code)
           )
          ((cpad-pressed? 0 triangle)
           (race-manager-method-27 self)
           (send-event (ppointer->process (-> self parent)) 'fail-immediately)
           (sleep-code)
           )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (race-manager-method-20 self)
    (none)
    )
  )

(defstate fail (race-manager)
  :virtual #t
  :event race-manager-event-handler
  :code (behavior ()
    (send-event (handle->process (-> self race-state hud-timer)) 'force-hide)
    (send-event (handle->process (-> self race-state hud-lap-counter)) 'force-hide)
    (send-event (handle->process (-> self race-state hud-turbo-counter)) 'force-hide)
    (set! (-> self state-time) (current-time))
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate die (race-manager)
  :virtual #t
  :code (behavior ()
    '()
    (none)
    )
  )

(define *race-manager* (the-as (pointer race-manager) #f))

(defmethod deactivate race-manager ((obj race-manager))
  (persist-with-delay *setting-control* 'music-volume (seconds 3) 'music-volume 'abs 0.0 0)
  (send-event *traffic-manager* 'restore-default-settings)
  ((the-as (function process none) (find-parent-method race-manager 10)) obj)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior race-manager-init-by-other race-manager ((arg0 race-info) (arg1 symbol))
  (stack-size-set! (-> self main-thread) 1024) ;; changed
  (race-vehicle-entity-hack)
  (set! (-> self race-state) *race-state*)
  (set! (-> self race-state info) arg0)
  (set! (-> self race-state flags) (the-as uint 0))
  (set! *race-manager* (the-as (pointer race-manager) (process->ppointer self)))
  (set! (-> arg0 manager) (process->handle self))
  (set! (-> self finish-sound-id) (new 'static 'sound-id))
  (if arg1
      (logior! (-> self race-state flags) 8)
      )
  (go-virtual idle)
  (none)
  )

;; ERROR: Unsupported inline assembly instruction kind - [mfc0 s5, Count]
;; ERROR: Unsupported inline assembly instruction kind - [mfc0 v1, Count]
(defun race-start ((arg0 int) (arg1 symbol) (arg2 symbol))
  (local-vars (v1-13 int) (s5-0 int))
  (let ((s2-0 (-> *race-info-array* arg0))
        (gp-0 (the-as process #f))
        )
    (.mfc0 s5-0 Count)
    (when (not (handle->process (-> s2-0 manager)))
      (format #t "starting race-manager~%")
      (if (not arg1)
          (set! arg1 (the-as symbol *entity-pool*))
          )
      (let ((v1-9 (process-spawn race-manager s2-0 arg2 :to (the-as process-tree arg1))))
        (when v1-9
          (set! gp-0 (-> v1-9 0))
          (.mfc0 v1-13 Count)
          (format #t "race-manager started in ~f ms~%" (* 0.0000033333333 (the float (- v1-13 s5-0))))
          )
        )
      )
    gp-0
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defun race-kill ()
  (kill-by-type race-manager *active-pool*)
  (none)
  )

(defun type-from-race-vehicle-type ((arg0 uint))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       race-bike-a
       )
      ((= v1-0 1)
       race-bike-b
       )
      ((= v1-0 2)
       race-bike-c
       )
      ((= v1-0 3)
       race-bike-d
       )
      ((= v1-0 4)
       race-bike-e
       )
      (else
        bikea
        )
      )
    )
  )

(defun race-vehicle-entity-hack ()
  (with-pp
    (let ((a1-0 *race-vehicle-entity*)
          (a0-0 pp)
          )
      (process-entity-set! a0-0 a1-0)
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch entity vs none.
(defun race-level-activate ((arg0 level))
  (format 0 "race-level-activate~%")
  (cond
    ((> (-> arg0 entity length) 0)
     (set! *race-vehicle-entity* (the-as entity-actor (-> arg0 entity data 0 entity)))
     )
    (else
      (dotimes (s5-0 10)
        (format 0 "ERROR: race-level-startup: level ~s has no entities!!~%" (-> arg0 name))
        )
      (set! *race-vehicle-entity* #f)
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defun race-level-deactivate ()
  (set! *race-vehicle-entity* #f)
  (none)
  )
