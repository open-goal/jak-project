;;-*-Lisp-*-
(in-package goal)

;; name: race-mesh.gc
;; name in dgo: race-mesh
;; dgos: STD, STC, LERLCHAL, STB, LPRTRACE

;; DECOMP BEGINS

(deftype race-mesh-hash-search (structure)
  ((best-dist             float                    :offset-assert   0)
   (debug-cells-searched  int32                    :offset-assert   4)
   (debug-slices-searched int32                    :offset-assert   8)
   (bounds                bounding-box4w :inline   :offset-assert  16)
   (cell-quads            vector         2 :inline :offset-assert  48)
   (slice-quads           vector         4 :inline :offset-assert  80)
   (cell-bits             vector16ub     2 :inline :offset         48)
   (slice-bits            vector16ub     4 :inline :offset         80)
   )
  :method-count-assert 9
  :size-assert         #x90
  :flag-assert         #x900000090
  )


(deftype race-mesh-slice-query (structure)
  ((slice-id      int16            :offset-assert   0)
   (lap-dist      float            :offset-assert   4)
   (pt-on-slice   vector :inline   :offset-assert  16)
   (slice-corners vector 4 :inline :offset-assert  32)
   (search-sphere sphere :inline   :offset-assert  96)
   )
  :method-count-assert 9
  :size-assert         #x70
  :flag-assert         #x900000070
  )


(deftype race-path-edge-info (structure)
  ((sample-t float  :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(deftype race-path-sample (structure)
  ((bytes    uint8      32      :offset-assert   0)
   (pos      vector     :inline :offset          0)
   (quat     quaternion :inline :offset         16)
   (stick-x  int8               :offset         12)
   (stick-y  int8               :offset         13)
   (throttle uint8              :offset         14)
   (flags    uint8              :offset         15)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(deftype race-path (structure)
  ((sample-count uint16                              :offset-assert   0)
   (record-id    int8                                :offset-assert   2)
   (pad          uint8                               :offset-assert   3)
   (samples      (inline-array race-path-sample)     :offset-assert   4)
   (edge-infos   (inline-array race-path-edge-info)  :offset-assert   8)
   )
  :method-count-assert 13
  :size-assert         #xc
  :flag-assert         #xd0000000c
  (:methods
    (draw-path-debug (_type_ rgba rgba) none 9)
    (race-path-method-10 (_type_ vector float float) none 10)
    (race-path-method-11 (_type_ race-path-sample vector float) none 11)
    (race-path-method-12 (_type_ vector float float) float 12)
    )
  )


(deftype race-path-group (structure)
  ((name       string                     :offset-assert   0)
   (path-count int8                       :offset-assert   4)
   (pad        uint8                    3 :offset-assert   5)
   (paths      (inline-array race-path)   :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(deftype race-mesh-edge (structure)
  ((left     vector :inline :offset-assert   0)
   (right    vector :inline :offset-assert  16)
   (lap-dist float          :offset         12)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(deftype race-mesh-slice (structure)
  ((edge-index-array uint16 2 :offset-assert   0)
   (start-edge       int16    :offset          0)
   (end-edge         int16    :offset          2)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  :pack-me
  )


(deftype race-mesh-hash-cell (structure)
  ((first-slice int16  :offset-assert   0)
   (slice-count uint8  :offset-assert   2)
   (pad         uint8  :offset-assert   3)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(deftype race-mesh-hash (structure)
  ((cells-wide  int8                                       :offset-assert   0)
   (cells-tall  int8                                       :offset-assert   1)
   (cell-length float                                      :offset-assert   4)
   (cells       (inline-array race-mesh-hash-cell)         :offset-assert   8)
   (slice-table (inline-array race-mesh-slice)             :offset-assert  12)
   (origin      vector                             :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(deftype race-mesh (basic)
  ((version          uint8                            :offset-assert   4)
   (path-group-count uint8                            :offset-assert   5)
   (flags            uint8                            :offset-assert   6)
   (pad              uint8                          1 :offset-assert   7)
   (slice-count      int16                            :offset-assert   8)
   (edge-count       int16                            :offset-assert  10)
   (slices           (inline-array race-mesh-slice)   :offset-assert  12)
   (edges            (inline-array race-mesh-edge)    :offset-assert  16)
   (hash             race-mesh-hash                   :offset-assert  20)
   (path-groups      (inline-array race-path-group)   :offset-assert  24)
   )
  :method-count-assert 20
  :size-assert         #x1c
  :flag-assert         #x140000001c
  (:methods
    (debug-draw-path (_type_ int int rgba rgba) none 9)
    (debug-draw-path-from-history (_type_ int int) symbol 10)
    (debug-draw-slice (_type_ int) none 11)
    (debug-draw-edges (_type_) none 12)
    (race-mesh-method-13 (_type_ race-mesh-slice-query) none 13)
    (race-mesh-method-14 (_type_ race-mesh-slice-query) none 14)
    (race-mesh-method-15 (_type_ int race-mesh-slice-query) none 15)
    (race-mesh-method-16 (_type_ race-mesh-slice-query) none 16)
    (race-mesh-method-17 (_type_ race-mesh-slice-query) symbol 17)
    (race-mesh-method-18 (_type_ race-mesh-hash-search int int race-mesh-slice-query) none 18)
    (race-mesh-method-19 (_type_ int race-mesh-slice-query) symbol 19)
    )
  )


(defmethod race-path-method-10 race-path ((obj race-path) (arg0 vector) (arg1 float) (arg2 float))
  (let ((v1-0 (new 'stack-no-clear 'inline-array 'vector 4))
        (a3-1 (the int arg1))
        )
    (set! (-> v1-0 0 quad) (-> obj samples a3-1 pos quad))
    (set! (-> v1-0 1 quad) (-> obj samples (+ a3-1 1) pos quad))
    (let ((f0-3 (- arg1 (the float a3-1))))
      (vector-lerp! arg0 (-> v1-0 0) (-> v1-0 1) f0-3)
      )
    )
  0
  (none)
  )

(defmethod race-path-method-11 race-path ((obj race-path) (arg0 race-path-sample) (arg1 vector) (arg2 float))
  (let ((gp-0 (new 'stack-no-clear 'inline-array 'race-path-sample 6)))
    (let ((f0-1 (the float (-> obj sample-count))))
      (if (< f0-1 arg2)
          (set! arg2 (- arg2 f0-1))
          )
      (if (< arg2 0.0)
          (set! arg2 (+ arg2 f0-1))
          )
      )
    (let ((s1-0 (the int arg2)))
      (mem-copy! (the-as pointer (-> gp-0 0)) (the-as pointer (-> obj samples s1-0)) 32)
      (mem-copy! (the-as pointer (-> gp-0 1)) (the-as pointer (-> obj samples (+ s1-0 1))) 32)
      (let ((v1-7 (+ s1-0 2)))
        (if (< (the-as int (-> obj sample-count)) v1-7)
            (set! v1-7 (- v1-7 (the-as int (-> obj sample-count))))
            )
        (mem-copy! (the-as pointer (-> gp-0 2)) (the-as pointer (-> obj samples v1-7)) 32)
        )
      (let ((f30-0 (- arg2 (the float s1-0))))
        (vector-lerp! (the-as vector (-> arg0 bytes)) (the-as vector (-> gp-0 0)) (the-as vector (-> gp-0 1)) f30-0)
        (quaternion-slerp! (-> arg0 quat) (-> gp-0 0 quat) (-> gp-0 1 quat) f30-0)
        (set! (-> arg0 stick-x)
              (the int (+ 0.5 (* (the float (-> gp-0 1 stick-x)) f30-0) (* (the float (-> gp-0 0 stick-x)) (- 1.0 f30-0))))
              )
        (set! (-> arg0 stick-y) (-> gp-0 0 stick-y))
        (set! (-> arg0 throttle)
              (the-as
                uint
                (the int
                     (+ 0.5 (* (the float (-> gp-0 1 throttle)) f30-0) (* (the float (-> gp-0 0 throttle)) (- 1.0 f30-0)))
                     )
                )
              )
        (set! (-> arg0 flags) (-> gp-0 0 flags))
        (vector-! (the-as vector (-> gp-0 4)) (the-as vector (-> gp-0 1)) (the-as vector (-> gp-0 0)))
        (vector-float*! (the-as vector (-> gp-0 3)) (the-as vector (-> gp-0 4)) 15.0)
        (vector-! (the-as vector (-> gp-0 4)) (the-as vector (-> gp-0 2)) (the-as vector (-> gp-0 1)))
        (vector-float*! (the-as vector (-> gp-0 3 quat)) (the-as vector (-> gp-0 4)) 15.0)
        (vector-lerp! arg1 (the-as vector (-> gp-0 3)) (the-as vector (-> gp-0 3 quat)) f30-0)
        )
      )
    )
  0
  0
  (none)
  )

(defmethod race-path-method-12 race-path ((obj race-path) (arg0 vector) (arg1 float) (arg2 float))
  (local-vars (v1-15 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 arg2)
          (s4-0 (new 'stack-no-clear 'matrix))
          (f30-0 (the float (-> obj sample-count)))
          )
      (if (< f30-0 gp-0)
          (set! gp-0 (- gp-0 f30-0))
          )
      (if (< arg1 0.0)
          (set! arg1 (+ arg1 f30-0))
          )
      (race-path-method-10 obj (the-as vector (-> s4-0 vector)) arg1 arg2)
      (race-path-method-10 obj (-> s4-0 vector 1) gp-0 arg2)
      (vector-! (-> s4-0 vector 2) (-> s4-0 vector 1) (the-as vector (-> s4-0 vector)))
      (vector-! (-> s4-0 trans) arg0 (the-as vector (-> s4-0 vector)))
      (let ((f0-7 0.0)
            (f1-1 1.0)
            (f2-1 (vector-dot (-> s4-0 vector 2) (-> s4-0 trans)))
            )
        (.lvf vf1 (&-> (-> s4-0 vector 2) quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov v1-15 vf1)
        (let ((f0-8 (fmax f0-7 (fmin f1-1 (/ f2-1 v1-15)))))
          (if (< gp-0 arg1)
              (set! gp-0 (+ gp-0 f30-0))
              )
          (let ((f0-10 (+ (* arg1 (- 1.0 f0-8)) (* gp-0 f0-8))))
            (if (< f30-0 f0-10)
                (set! f0-10 (- f0-10 f30-0))
                )
            (if (< f0-10 0.0)
                (+! f0-10 f30-0)
                )
            f0-10
            )
          )
        )
      )
    )
  )

(defmethod draw-path-debug race-path ((obj race-path) (arg0 rgba) (arg1 rgba))
  (let ((s1-0 0)
        (s3-0 1)
        (s2-0 (+ (-> obj sample-count) -1))
        )
    (set! (-> (new 'stack-no-clear 'vector) quad) (-> (camera-pos) quad))
    (while (< s1-0 (the-as int s2-0))
      (let ((v1-4 (-> obj samples s1-0))
            (a3-0 (-> obj samples s3-0))
            )
        (add-debug-line
          #t
          (bucket-id debug2)
          (the-as vector (-> v1-4 bytes))
          (the-as vector (-> a3-0 bytes))
          arg0
          #f
          arg1
          )
        )
      (set! s1-0 s3-0)
      (set! s3-0 (min (+ s3-0 1) (the-as int s2-0)))
      )
    )
  0
  (none)
  )

(defmethod debug-draw-path race-mesh ((obj race-mesh) (arg0 int) (arg1 int) (arg2 rgba) (arg3 rgba))
  (when (< arg1 (the-as int (-> obj path-group-count)))
    (let ((v1-2 (-> obj path-groups arg1)))
      (if (< arg0 (-> v1-2 path-count))
          (draw-path-debug (-> v1-2 paths arg0) arg2 arg3)
          )
      )
    )
  (none)
  )

(defmethod debug-draw-path-from-history race-mesh ((obj race-mesh) (arg0 int) (arg1 int))
  (when (< arg1 (the-as int (-> obj path-group-count)))
    (let ((v1-2 (-> obj path-groups arg1)))
      (countdown (a2-1 (-> v1-2 path-count))
        (let ((a0-3 (-> v1-2 paths a2-1)))
          (when (= (-> a0-3 record-id) arg0)
            (let ((v1-3 (new 'static 'array rgba 16
                          (new 'static 'rgba :r #x40 :a #x80)
                          (new 'static 'rgba :r #xff :g #x30 :b #x30 :a #x80)
                          (new 'static 'rgba :g #xff :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          (new 'static 'rgba :b #xff :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          (new 'static 'rgba :r #x60 :g #x60 :b #x60 :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :a #x80)
                          (new 'static 'rgba :g #xff :b #xff :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          (new 'static 'rgba :r #xff :b #xff :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          (new 'static 'rgba :r #xff :g #x80 :b #x40 :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          (new 'static 'rgba :a #x80)
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          )
                        )
                  (a2-2 (* arg0 2))
                  )
              (draw-path-debug a0-3 (-> v1-3 a2-2) (-> v1-3 (+ a2-2 1)))
              )
            (return #f)
            )
          )
        )
      )
    #f
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod debug-draw-slice race-mesh ((obj race-mesh) (arg0 int))
  (let* ((v1-1 (-> obj slices arg0))
         (s3-0 (-> obj edges (-> v1-1 start-edge)))
         (s4-0 (-> obj edges (-> v1-1 end-edge)))
         )
    (add-debug-line
      #t
      (bucket-id debug-no-zbuf1)
      (-> s3-0 left)
      (-> s3-0 right)
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      #f
      (the-as rgba -1)
      )
    (add-debug-line
      #t
      (bucket-id debug-no-zbuf1)
      (-> s3-0 right)
      (-> s4-0 right)
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      #f
      (the-as rgba -1)
      )
    (add-debug-line
      #t
      (bucket-id debug-no-zbuf1)
      (-> s4-0 right)
      (-> s4-0 left)
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      #f
      (the-as rgba -1)
      )
    (add-debug-line
      #t
      (bucket-id debug-no-zbuf1)
      (-> s4-0 left)
      (-> s3-0 left)
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      #f
      (the-as rgba -1)
      )
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (vector+! s5-0 (-> s3-0 left) (-> s3-0 right))
      (vector+! s5-0 s5-0 (-> s4-0 left))
      (vector+! s5-0 s5-0 (-> s4-0 right))
      (vector-float*! s5-0 s5-0 0.25)
      (let ((s4-1 add-debug-text-3d)
            (s3-1 #t)
            (s2-0 318)
            )
        (format (clear *temp-string*) "~D" arg0)
        (s4-1 s3-1 (the-as bucket-id s2-0) *temp-string* s5-0 (font-color white) (the-as vector2h #f))
        )
      )
    )
  (none)
  )

(defmethod debug-draw-edges race-mesh ((obj race-mesh))
  (let ((idx 0)
        (slice-cnt (+ (-> obj slice-count) -1))
        )
    (while (>= slice-cnt idx)
      (let* ((v1-2 (the-as object (+ (the-as uint (-> obj slices)) (* idx 4))))
             (s3-0 (-> obj edges (-> (the-as (pointer int16) v1-2))))
             (s2-0 (-> obj edges (-> (the-as race-mesh-slice v1-2) end-edge)))
             )
        (add-debug-line #t (bucket-id debug-no-zbuf1) (-> s3-0 left) (-> s2-0 left) *color-white* #f (the-as rgba -1))
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> s3-0 right)
          (-> s2-0 right)
          *color-white*
          #f
          (the-as rgba -1)
          )
        (add-debug-line #t (bucket-id debug-no-zbuf1) (-> s2-0 left) (-> s2-0 right) *color-gray* #f (the-as rgba -1))
        )
      (+! idx 1)
      )
    )
  (let ((v1-8 (-> obj edges 0)))
    (add-debug-line
      #t
      (bucket-id debug-no-zbuf1)
      (-> v1-8 left)
      (-> v1-8 right)
      *color-green*
      #f
      (the-as rgba -1)
      )
    )
  (let ((s5-1 (+ (-> obj edge-count) -1)))
    (let ((v1-12 (-> obj edges s5-1)))
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (-> v1-12 left)
        (-> v1-12 right)
        *color-red*
        #f
        (the-as rgba -1)
        )
      )
    (format *stdcon* "edge-count ~d last-edge ~d~%" (-> obj edge-count) s5-1)
    )
  0
  (none)
  )

(defmethod race-mesh-method-19 race-mesh ((obj race-mesh) (arg0 int) (arg1 race-mesh-slice-query))
  (set! (-> arg1 slice-id) -1)
  (let* ((v1-2 (the-as object (+ (the-as uint (-> obj slices)) (* arg0 4))))
         (a1-3 (-> obj edges (-> (the-as (pointer int16) v1-2))))
         (v1-5 (-> obj edges (-> (the-as race-mesh-slice v1-2) end-edge)))
         )
    (set! (-> arg1 slice-corners 0 quad) (-> a1-3 left quad))
    (set! (-> arg1 slice-corners 1 quad) (-> a1-3 right quad))
    (set! (-> arg1 slice-corners 2 quad) (-> v1-5 right quad))
    (set! (-> arg1 slice-corners 3 quad) (-> v1-5 left quad))
    )
  (let ((v1-8 (new 'stack-no-clear 'vector))
        (a0-6 (new 'stack-no-clear 'vector))
        )
    (countdown (a1-8 4)
      (vector-! a0-6 (-> arg1 slice-corners (logand (+ a1-8 1) 3)) (-> arg1 slice-corners a1-8))
      (vector-! v1-8 (the-as vector (-> arg1 search-sphere)) (-> arg1 slice-corners a1-8))
      (if (< (- (* (-> a0-6 z) (-> v1-8 x)) (* (-> a0-6 x) (-> v1-8 z))) 0.0)
          (return #f)
          )
      )
    )
  (let ((v1-11 (new 'stack-no-clear 'vector))
        (a0-7 (new 'stack-no-clear 'vector))
        )
    (vector-! v1-11 (-> arg1 slice-corners 2) (the-as vector (-> arg1 slice-corners)))
    (vector-! a0-7 (the-as vector (-> arg1 search-sphere)) (the-as vector (-> arg1 slice-corners)))
    (let ((f0-5 (- (* (-> v1-11 z) (-> a0-7 x)) (* (-> v1-11 x) (-> a0-7 z))))
          (s4-0 (new 'stack-no-clear 'vector))
          (s3-0 (new 'stack-no-clear 'vector))
          )
      (cond
        ((< f0-5 0.0)
         (vector-! s4-0 (-> arg1 slice-corners 1) (the-as vector (-> arg1 slice-corners)))
         (vector-cross! s3-0 s4-0 v1-11)
         )
        (else
          (vector-! s4-0 (-> arg1 slice-corners 3) (the-as vector (-> arg1 slice-corners)))
          (vector-cross! s3-0 v1-11 s4-0)
          )
        )
      (vector-normalize! s3-0 1.0)
      (set-vector! s4-0 0.0 -1.0 0.0 1.0)
      (let ((f0-10 (intersect-ray-plane (-> arg1 search-sphere) s4-0 (the-as vector (-> arg1 slice-corners)) s3-0)))
        (vector+float*! (-> arg1 pt-on-slice) (the-as vector (-> arg1 search-sphere)) s4-0 f0-10)
        )
      )
    )
  (if (< (- (-> arg1 search-sphere y) (-> arg1 pt-on-slice y)) -8192.0)
      (return #f)
      )
  (set! (-> arg1 slice-id) arg0)
  #t
  )

(defmethod race-mesh-method-17 race-mesh ((obj race-mesh) (slice-query race-mesh-slice-query))
  (set! (-> slice-query slice-id) -1)
  (let* ((race-hash (-> obj hash))
         (v1-2
           (max
             0
             (min
               (the int (/ (- (-> slice-query search-sphere x) (-> race-hash origin x)) (-> race-hash cell-length)))
               (+ (-> race-hash cells-wide) -1)
               )
             )
           )
         (a0-4
           (max
             0
             (min
               (the int (/ (- (-> slice-query search-sphere z) (-> race-hash origin z)) (-> race-hash cell-length)))
               (+ (-> race-hash cells-tall) -1)
               )
             )
           )
         (s3-0
           (the-as object (+ (the-as uint (-> race-hash cells)) (* (+ (* a0-4 (-> race-hash cells-wide)) v1-2) 4)))
           )
         (s1-0 (-> (the-as race-mesh-hash-cell s3-0) slice-count))
         )
    (when (nonzero? s1-0)
      (let ((s2-0 (new 'stack-no-clear 'race-mesh-slice-query)))
        (mem-copy! (the-as pointer s2-0) (the-as pointer slice-query) 112)
        (while (nonzero? s1-0)
          (+! s1-0 -1)
          (let ((a1-7 (-> (&-> (-> race-hash slice-table) 0 edge-index-array (+ (-> (the-as (pointer int16) s3-0)) s1-0)) 0))
                )
            (when (race-mesh-method-19 obj (the-as int a1-7) s2-0)
              (if (or (= (-> slice-query slice-id) -1)
                      (< (vector-vector-distance-squared (-> s2-0 pt-on-slice) (-> slice-query search-sphere))
                         (vector-vector-distance-squared (-> slice-query pt-on-slice) (-> slice-query search-sphere))
                         )
                      )
                  (mem-copy! (the-as pointer slice-query) (the-as pointer s2-0) 112)
                  )
              )
            )
          )
        )
      #f
      )
    )
  )

;; WARN: Return type mismatch vector vs none.
(defmethod race-mesh-method-15 race-mesh ((obj race-mesh) (id int) (slice-query race-mesh-slice-query))
  (local-vars (v1-8 symbol))
  (set! (-> slice-query slice-id) id)
  (let* ((v1-1 (the-as object (+ (the-as uint (-> obj slices)) (* id 4))))
         (a1-3 (-> obj edges (-> (the-as (pointer int16) v1-1))))
         (v1-4 (-> obj edges (-> (the-as race-mesh-slice v1-1) end-edge)))
         )
    (set! (-> slice-query slice-corners 0 quad) (-> a1-3 left quad))
    (set! (-> slice-query slice-corners 1 quad) (-> a1-3 right quad))
    (set! (-> slice-query slice-corners 2 quad) (-> v1-4 right quad))
    (set! (-> slice-query slice-corners 3 quad) (-> v1-4 left quad))
    )
  (let ((v1-7 (new 'stack-no-clear 'vector))
        (a0-6 (new 'stack-no-clear 'vector))
        )
    (countdown (a1-8 4)
      (vector-! a0-6 (-> slice-query slice-corners (logand (+ a1-8 1) 3)) (-> slice-query slice-corners a1-8))
      (vector-! v1-7 (the-as vector (-> slice-query search-sphere)) (-> slice-query slice-corners a1-8))
      (when (< (- (* (-> a0-6 z) (-> v1-7 x)) (* (-> a0-6 x) (-> v1-7 z))) 0.0)
        (set! v1-8 #f)
        (goto cfg-6)
        )
      )
    )
  (set! v1-8 #t)
  (label cfg-6)
  (cond
    (v1-8
      (let ((v1-11 (new 'stack-no-clear 'vector))
            (a0-7 (new 'stack-no-clear 'vector))
            )
        (vector-! v1-11 (-> slice-query slice-corners 2) (the-as vector (-> slice-query slice-corners)))
        (vector-! a0-7 (the-as vector (-> slice-query search-sphere)) (the-as vector (-> slice-query slice-corners)))
        (let ((f0-5 (- (* (-> v1-11 z) (-> a0-7 x)) (* (-> v1-11 x) (-> a0-7 z))))
              (s5-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              )
          (cond
            ((< f0-5 0.0)
             (vector-! s5-0 (-> slice-query slice-corners 1) (the-as vector (-> slice-query slice-corners)))
             (vector-cross! s4-0 s5-0 v1-11)
             )
            (else
              (vector-! s5-0 (-> slice-query slice-corners 3) (the-as vector (-> slice-query slice-corners)))
              (vector-cross! s4-0 v1-11 s5-0)
              )
            )
          (vector-normalize! s4-0 1.0)
          (set-vector! s5-0 0.0 -1.0 0.0 1.0)
          (let ((f0-10
                  (intersect-ray-plane (-> slice-query search-sphere) s5-0 (the-as vector (-> slice-query slice-corners)) s4-0)
                  )
                )
            (vector+float*! (-> slice-query pt-on-slice) (the-as vector (-> slice-query search-sphere)) s5-0 f0-10)
            )
          )
        )
      )
    (else
      (let ((s5-1 (new 'stack-no-clear 'vector))
            (f30-0 -1.0)
            )
        (countdown (s4-1 4)
          (let ((f0-11 (vector-segment-distance-point!
                         (-> slice-query search-sphere)
                         (-> slice-query slice-corners s4-1)
                         (-> slice-query slice-corners (logand (+ s4-1 1) 3))
                         s5-1
                         )
                       )
                )
            (when (or (< f30-0 0.0) (< f0-11 f30-0))
              (set! f30-0 f0-11)
              (set! (-> slice-query pt-on-slice quad) (-> s5-1 quad))
              )
            )
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod race-mesh-method-18 race-mesh ((obj race-mesh) (arg0 race-mesh-hash-search) (arg1 int) (arg2 int) (arg3 race-mesh-slice-query))
  (let* ((v1-3 (+ (* arg2 (-> obj hash cells-wide)) arg1))
         (a0-1 (/ v1-3 8))
         (a1-2 (ash 1 (logand v1-3 7)))
         (a2-4 (-> (the-as race-mesh-hash-search (+ a0-1 (the-as int arg0))) cell-bits 0 data 0))
         )
    (when (not (logtest? a2-4 a1-2))
      (set! (-> arg0 cell-bits 0 data a0-1) (logior a2-4 a1-2))
      (let* ((v1-5 (the-as object (+ (the-as uint (-> obj hash cells)) (* v1-3 4))))
             (s3-0 (&-> (-> obj hash slice-table) 0 edge-index-array (-> (the-as (pointer int16) v1-5))))
             (s1-0 (-> (the-as race-mesh-hash-cell v1-5) slice-count))
             )
        (when (nonzero? s1-0)
          (let ((s2-0 (new 'stack-no-clear 'race-mesh-slice-query)))
            (mem-copy! (the-as pointer s2-0) (the-as pointer arg3) 112)
            (while (nonzero? s1-0)
              (+! s1-0 -1)
              (let* ((a1-7 (-> s3-0 0))
                     (v1-6 (shr a1-7 3))
                     (a0-10 (ash 1 (logand a1-7 7)))
                     (a2-9 (-> arg0 slice-bits 0 data v1-6))
                     )
                (when (not (logtest? a2-9 a0-10))
                  (set! (-> arg0 slice-bits 0 data v1-6) (logior a2-9 a0-10))
                  (race-mesh-method-15 obj (the-as int a1-7) s2-0)
                  (let ((f0-0 (vector-vector-distance-squared (-> s2-0 pt-on-slice) (-> arg3 search-sphere))))
                    (when (or (= (-> arg3 slice-id) -1) (< f0-0 (-> arg0 best-dist)))
                      (set! (-> arg0 best-dist) f0-0)
                      (mem-copy! (the-as pointer arg3) (the-as pointer s2-0) 112)
                      )
                    )
                  )
                )
              (set! s3-0 (&-> s3-0 1))
              )
            )
          )
        )
      )
    )
  (none)
  )

(defmethod race-mesh-method-16 race-mesh ((obj race-mesh) (arg0 race-mesh-slice-query))
  (set! (-> arg0 slice-id) -1)
  (let ((s4-0 (-> obj hash))
        (s3-0 (new 'stack-no-clear 'race-mesh-hash-search))
        )
    (let ((v1-3 (/ (+ (-> obj slice-count) 127) 128)))
      (when (< 4 v1-3)
        (break!)
        0
        )
      (while (nonzero? v1-3)
        (+! v1-3 -1)
        (set! (-> s3-0 slice-bits v1-3 quad) (the-as uint128 0))
        )
      )
    (set! (-> s3-0 cell-bits 0 quad) (the-as uint128 0))
    (set! (-> s3-0 cell-bits 1 quad) (the-as uint128 0))
    (let ((f0-1 (/ 1.0 (-> s4-0 cell-length)))
          (f1-2 (fmin (-> arg0 search-sphere r) (* 0.5 (-> s4-0 cell-length))))
          )
      (let ((f3-1 (- (-> arg0 search-sphere x) f1-2))
            (f2-4 (- (-> arg0 search-sphere z) f1-2))
            )
        (set! (-> s3-0 bounds min x)
              (max 0 (min (the int (* (- f3-1 (-> s4-0 origin x)) f0-1)) (+ (-> s4-0 cells-wide) -1)))
              )
        (set! (-> s3-0 bounds min z)
              (max 0 (min (the int (* (- f2-4 (-> s4-0 origin z)) f0-1)) (+ (-> s4-0 cells-tall) -1)))
              )
        )
      (let ((f2-9 (+ (-> arg0 search-sphere x) f1-2))
            (f1-3 (+ (-> arg0 search-sphere z) f1-2))
            )
        (set! (-> s3-0 bounds max x)
              (max 0 (min (the int (* (- f2-9 (-> s4-0 origin x)) f0-1)) (+ (-> s4-0 cells-wide) -1)))
              )
        (set! (-> s3-0 bounds max z)
              (max 0 (min (the int (* (- f1-3 (-> s4-0 origin z)) f0-1)) (+ (-> s4-0 cells-tall) -1)))
              )
        )
      )
    (let ((s2-0 (-> s3-0 bounds min z)))
      (until (< (-> s3-0 bounds max z) s2-0)
        (let ((s1-0 (-> s3-0 bounds min x)))
          (until (< (-> s3-0 bounds max x) s1-0)
            (race-mesh-method-18 obj s3-0 s1-0 s2-0 arg0)
            (+! s1-0 1)
            )
          )
        (+! s2-0 1)
        )
      )
    (when (and (= (-> arg0 slice-id) -1) (< (* 0.5 (-> s4-0 cell-length)) (-> arg0 search-sphere r)))
      (while (= (-> arg0 slice-id) -1)
        (set! (-> s3-0 bounds min x) (max 0 (+ (-> s3-0 bounds min x) -1)))
        (set! (-> s3-0 bounds min z) (max 0 (+ (-> s3-0 bounds min z) -1)))
        (set! (-> s3-0 bounds max x) (min (+ (-> s3-0 bounds max x) 1) (+ (-> s4-0 cells-wide) -1)))
        (set! (-> s3-0 bounds max z) (min (+ (-> s3-0 bounds max z) 1) (+ (-> s4-0 cells-tall) -1)))
        (let ((s2-1 (-> s3-0 bounds min x)))
          (until (< (-> s3-0 bounds max x) s2-1)
            (race-mesh-method-18 obj s3-0 s2-1 (-> s3-0 bounds min z) arg0)
            (race-mesh-method-18 obj s3-0 s2-1 (-> s3-0 bounds max z) arg0)
            (+! s2-1 1)
            )
          )
        (let ((s2-2 (-> s3-0 bounds min z)))
          (until (< (-> s3-0 bounds max z) s2-2)
            (race-mesh-method-18 obj s3-0 (-> s3-0 bounds min x) s2-2 arg0)
            (race-mesh-method-18 obj s3-0 (-> s3-0 bounds max x) s2-2 arg0)
            (+! s2-2 1)
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod race-mesh-method-14 race-mesh ((obj race-mesh) (arg0 race-mesh-slice-query))
  (let* ((f30-0 (vector-line-distance-point!
                  (-> arg0 pt-on-slice)
                  (the-as vector (-> arg0 slice-corners))
                  (-> arg0 slice-corners 1)
                  (the-as vector #f)
                  )
                )
         (f1-0 (vector-line-distance-point!
                 (-> arg0 pt-on-slice)
                 (-> arg0 slice-corners 2)
                 (-> arg0 slice-corners 3)
                 (the-as vector #f)
                 )
               )
         (f0-0 (+ f30-0 f1-0))
         (v1-1 (the-as race-mesh-slice (+ (the-as uint (-> obj slices)) (* (-> arg0 slice-id) 4))))
         (f2-0 (-> obj edges (-> v1-1 start-edge) left w))
         (f3-0 (-> obj edges (-> v1-1 end-edge) left w))
         )
    (set! (-> arg0 lap-dist) (+ (* (/ f1-0 f0-0) f2-0) (* (/ f30-0 f0-0) f3-0)))
    )
  (none)
  )

(defmethod race-mesh-method-13 race-mesh ((obj race-mesh) (arg0 race-mesh-slice-query))
  (race-mesh-method-17 obj arg0)
  (if (and (= (-> arg0 slice-id) -1) (< 0.0 (-> arg0 search-sphere r)))
      (race-mesh-method-16 obj arg0)
      )
  (when (!= (-> arg0 slice-id) -1)
    (race-mesh-method-14 obj arg0)
    0
    )
  (none)
  )
