;;-*-Lisp-*-
(in-package goal)

;; name: vehicle-racer.gc
;; name in dgo: vehicle-racer
;; dgos: STD, STC, LERLCHAL, STB, LPRTRACE

(define-extern *race-state* race-state)

;; DECOMP BEGINS

(deftype race-control (structure)
  ((state        race-state               :offset-assert   0)
   (mesh         race-mesh                :offset-assert   4)
   (path-select  int8                     :offset-assert   8)
   (path-group   race-path-group          :offset-assert  12)
   (path         race-path                :offset-assert  16)
   (path-t       float                    :offset-assert  20)
   (racer-state  racer-state              :offset-assert  24)
   (path-sample  race-path-sample :inline :offset-assert  32)
   (lin-velocity vector           :inline :offset-assert  64)
   (ang-velocity vector           :inline :offset-assert  80)
   )
  :method-count-assert 13
  :size-assert         #x60
  :flag-assert         #xd00000060
  (:methods
    (race-control-method-9 (_type_ int vector) none 9)
    (race-control-method-10 (_type_ race-state racer-state) none 10)
    (race-control-method-11 (_type_ float) none 11)
    (race-control-method-12 (_type_ vector) none 12)
    )
  )


(defmethod race-control-method-12 race-control ((this race-control) (arg0 vector))
  (let* ((f0-0 (-> this path-t))
         (f0-2 (race-path-method-12 (-> this path) arg0 (+ -1.0 f0-0) (+ 1.0 f0-0)))
         )
    (set! (-> this path-t) f0-2)
    (race-path-method-11 (-> this path) (-> this path-sample) (-> this lin-velocity) f0-2)
    )
  0
  (none)
  )

(defmethod race-control-method-11 race-control ((this race-control) (arg0 float))
  (let ((f0-1 (+ (-> this path-t) (* 15.0 arg0))))
    (set! f0-1 (cond
                 ((logtest? (-> this mesh flags) (race-mesh-flags racemeshflag-0))
                  (let ((f1-3 (the float (-> this path sample-count))))
                    (if (>= f0-1 f1-3)
                        (set! f0-1 (- f0-1 f1-3))
                        )
                    )
                  f0-1
                  )
                 (else
                   (fmin f0-1 (the float (+ (-> this path sample-count) -1)))
                   )
                 )
          )
    (set! (-> this path-t) f0-1)
    (race-path-method-11 (-> this path) (-> this path-sample) (-> this lin-velocity) f0-1)
    )
  (vector-reset! (-> this ang-velocity))
  0
  (none)
  )

(defmethod race-control-method-9 race-control ((this race-control) (arg0 int) (arg1 vector))
  (let ((v1-1 (-> this path-group path-count)))
    (if (>= arg0 v1-1)
        (set! arg0 0)
        )
    (set! (-> this path-select) arg0)
    (cond
      ((> v1-1 0)
       (let ((s4-0 (-> this path-group paths arg0)))
         (set! (-> this path) s4-0)
         (let ((s3-0 (new 'stack-no-clear 'race-mesh-slice-query)))
           (set! (-> s3-0 search-sphere quad) (-> arg1 quad))
           (set! (-> s3-0 search-sphere r) 61440.0)
           (race-mesh-method-13 (-> this mesh) (the-as race-mesh-slice-query (&-> s3-0 slice-id)))
           (when (!= (-> s3-0 slice-id) -1)
             (let* ((v1-12 (-> this mesh slices (-> s3-0 slice-id)))
                    (f0-1 (-> (the-as (pointer float) (+ (* (-> v1-12 start-edge) 4) (the-as int (-> s4-0 edge-infos))))))
                    (f1-0
                      (-> (the-as race-path-edge-info (+ (* (-> v1-12 end-edge) 4) (the-as int (-> s4-0 edge-infos)))) sample-t)
                      )
                    )
               (when (and (>= f0-1 0.0) (>= f1-0 0.0))
                 (let ((f0-2 (race-path-method-12 s4-0 arg1 f0-1 f1-0)))
                   (set! (-> this path-t) f0-2)
                   (race-path-method-11 (-> this path) (-> this path-sample) (-> this lin-velocity) f0-2)
                   )
                 )
               )
             )
           )
         )
       )
      (else
        (set! (-> this path) #f)
        )
      )
    )
  0
  (none)
  )

(defmethod race-control-method-10 race-control ((this race-control) (arg0 race-state) (arg1 racer-state))
  (set! (-> this state) arg0)
  (set! (-> this mesh) (-> arg0 info mesh))
  (if (-> this mesh)
      (set! (-> this path-group) (-> this mesh path-groups 0))
      )
  (set! (-> this racer-state) arg1)
  0
  (none)
  )

(deftype vehicle-racer (vehicle)
  ((race                  race-control       :inline :offset-assert 880)
   (ai-controls           vehicle-controls   :inline :offset-assert 976)
   (rider-hand-joint      int8                       :offset-assert 992)
   (turbo-pickup-count    int8                       :offset-assert 993)
   (minimap               connection-minimap         :offset-assert 996)
   (shortcut-speed-factor float                      :offset-assert 1000)
   (path-deviation        float                      :offset-assert 1004)
   (shortcut-time         time-frame                 :offset-assert 1008)
   )
  :heap-base #x380
  :method-count-assert 156
  :size-assert         #x3f8
  :flag-assert         #x9c038003f8
  (:methods
    (waiting-race () _type_ :state 144)
    (waiting-for-start () _type_ :state 145)
    (racing () _type_ :state 146)
    (race-finished () _type_ :state 147)
    (vehicle-racer-method-148 (_type_ race-path race-mesh-slice) none 148)
    (vehicle-racer-method-149 (_type_) none 149)
    (select-path-randomly-from-mask (_type_ uint) none 150)
    (vehicle-racer-method-151 (_type_) none 151)
    (vehicle-racer-method-152 (_type_) none 152)
    (physics-post (_type_) none 153)
    (vehicle-racer-method-154 (_type_) none 154)
    (vehicle-racer-method-155 (_type_) none 155)
    )
  )


(defmethod vehicle-method-117 vehicle-racer ((this vehicle-racer) (arg0 vector) (arg1 int) (arg2 int))
  (vector-matrix*!
    arg0
    (-> this info rider-hand-offset arg2)
    (-> this node-list data (-> this rider-hand-joint) bone transform)
    )
  0
  (none)
  )

(defmethod vehicle-method-137 vehicle-racer ((this vehicle-racer) (arg0 traffic-object-spawn-params))
  (let ((t9-0 vehicle-rider-spawn)
        (v1-0 (-> arg0 user-data))
        )
    (t9-0
      this
      (if (= v1-0 2)
          errol-rider
          stadium-racer
          )
      arg0
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch number vs none.
(defmethod vehicle-racer-method-148 vehicle-racer ((this vehicle-racer) (arg0 race-path) (arg1 race-mesh-slice))
  (let ((f26-0 (the-as number 0.0))
        (gp-0 (new 'stack-no-clear 'vehicle-physics-work))
        (f30-0 (-> (the-as (pointer float) (+ (* (-> arg1 start-edge) 4) (the-as int (-> arg0 edge-infos))))))
        (f28-0 (-> (the-as (pointer float) (+ (* (-> arg1 end-edge) 4) (the-as int (-> arg0 edge-infos))))))
        )
    (when (and (>= f30-0 0.0) (>= f28-0 0.0))
      (let ((f26-1 1.0))
        (set! (-> gp-0 mat trans quad) (-> this root trans quad))
        (set! (-> gp-0 velocity quad) (-> this root transv quad))
        (quaternion-copy! (the-as quaternion (-> gp-0 force)) (-> this root quat))
        (let* ((f0-2 (race-path-method-12 arg0 (-> gp-0 mat trans) f30-0 f28-0))
               (a0-4 arg0)
               (t9-2 (method-of-type race-path race-path-method-11))
               (a1-11 (-> gp-0 steering-axis))
               (a2-2 (-> gp-0 mat vector 2))
               (a3-1 f0-2)
               )
          (t9-2 a0-4 (the-as race-path-sample a1-11) a2-2 a3-1)
          (let* ((f1-0 (vector-vector-distance-squared (-> gp-0 steering-axis) (-> gp-0 mat trans)))
                 (f0-3 0.0)
                 (f2-0 32768.0)
                 (f1-1 (- (* f2-0 f2-0) f1-0))
                 (f2-3 1.0)
                 (f3-0 32768.0)
                 (f26-2 (* f26-1 (fmax f0-3 (* f1-1 (/ f2-3 (* f3-0 f3-0))))))
                 )
            0
            (let* ((f0-5 (vector-vector-distance (-> gp-0 mat vector 2) (-> gp-0 velocity)))
                   (f26-3 (* f26-2 (fmax 0.1 (* 0.000012207031 (- 81920.0 f0-5)))))
                   )
              0
              (quaternion-conjugate! (the-as quaternion (-> gp-0 local-pos)) (the-as quaternion (-> gp-0 force)))
              (quaternion*!
                (the-as quaternion (-> gp-0 world-normal))
                (the-as quaternion (-> gp-0 local-pos))
                (the-as quaternion (-> gp-0 lift-dir))
                )
              (set! f26-0 (* f26-3 (fabs (-> gp-0 world-normal w))))
              )
            )
          0
          0
          (race-path-method-10 arg0 (the-as vector (-> gp-0 mat)) f30-0 a3-1)
          (race-path-method-10 arg0 (-> gp-0 mat vector 1) f28-0 a3-1)
          )
        )
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (the-as vector (-> gp-0 mat))
        (-> gp-0 mat vector 1)
        *color-cyan*
        #f
        (the-as rgba -1)
        )
      )
    )
  (none)
  )

(defmethod vehicle-method-120 vehicle-racer ((this vehicle-racer))
  (when (logtest? (-> this flags) (rigid-body-object-flag player-driving))
    (set! (-> *game-info* race-number-turbos) (-> this turbo-pickup-count))
    0
    )
  (logior! (-> this skel status) (joint-control-status sync-math))
  (let ((t9-0 (method-of-type vehicle vehicle-method-120)))
    (t9-0 this)
    )
  (let ((v1-10 (-> this root trans-old-old quad)))
    (set! (-> this root trans-old-old-old quad) v1-10)
    )
  (let ((v1-12 (-> this root trans-old quad)))
    (set! (-> this root trans-old-old quad) v1-12)
    )
  (let ((v1-14 (-> this root trans quad)))
    (set! (-> this root trans-old quad) v1-14)
    )
  0
  (none)
  )

(defmethod vehicle-method-66 vehicle-racer ((this vehicle-racer))
  (when (and (not (logtest? (rigid-body-object-flag turbo-boost) (-> this flags))) (> (-> this turbo-pickup-count) 0))
    (+! (-> this turbo-pickup-count) -1)
    (set-time! (-> this turbo-boost-time))
    (set! (-> this turbo-boost-factor) 1.0)
    (set! (-> this turbo-boost-duration) (the-as uint 150))
    (logior! (-> this flags) (rigid-body-object-flag turbo-boost))
    (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
        (sound-play "turbo-boost")
        )
    )
  0
  (none)
  )

(defmethod vehicle-method-136 vehicle-racer ((this vehicle-racer) (arg0 traffic-object-spawn-params))
  (set! (-> this draw lod-set lod 1 dist) 819200.0)
  (set! (-> this draw lod-set lod 2 dist) 1228800.0)
  (let* ((a1-1 *race-state*)
         (a2-0 (-> a1-1 racer-array (-> arg0 id)))
         )
    (race-control-method-10 (-> this race) a1-1 a2-0)
    )
  (set! (-> this shortcut-speed-factor) 0.0)
  (case (-> arg0 behavior)
    ((10)
     (when (not (-> this race mesh))
       (format #t "ERROR: vehicle-racer::go-start-state: no race-mesh found~%")
       (go (method-of-object this die))
       )
     (when (-> this race mesh)
       (race-control-method-9 (-> this race) (-> this traffic-priority-id) (-> this root trans))
       (cond
         ((logtest? (-> arg0 flags) (traffic-spawn-flags trsflags-01))
          (logior! (-> this flags) (rigid-body-object-flag riding ai-driving))
          (cond
            ((-> this race path)
             (go (method-of-object this waiting-for-start))
             )
            (else
              (format 0 "vehicle-racer::go-start-state: ERROR, no race-paths found~%")
              (go (method-of-object this die))
              )
            )
          )
         (else
           (logior! (-> this flags) (rigid-body-object-flag waiting-for-player))
           (logior! (-> this focus-status) (focus-status grabbed))
           (go (method-of-object this waiting-race))
           )
         )
       )
     )
    (else
      ((method-of-type vehicle vehicle-method-136) this arg0)
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-138 vehicle-racer ((this vehicle-racer))
  (if (focus-test? this grabbed)
      (go (method-of-object this waiting-for-start))
      (go (method-of-object this player-control))
      )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod rigid-body-object-method-45 vehicle-racer ((this vehicle-racer) (arg0 rigid-body-impact))
  (let ((t9-0 (method-of-type vehicle rigid-body-object-method-45)))
    (t9-0 this arg0)
    )
  (when (and (logtest? (-> this flags) (rigid-body-object-flag player-driving))
             (< 40960.0 (-> arg0 impulse))
             (< 0.0 (-> this hit-points))
             )
    (cond
      ((-> arg0 rbody)
       (dotimes (s4-0 (-> this info seat-count))
         (send-event (handle->process (-> this rider-array s4-0)) 'vehicle-got-hit arg0)
         )
       )
      (else
        (dotimes (s4-1 (-> this info seat-count))
          (send-event (handle->process (-> this rider-array s4-1)) 'vehicle-hit arg0)
          )
        )
      )
    )
  (none)
  )

;; WARN: disable def twice: 12. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod rigid-body-object-method-46 vehicle-racer ((this vehicle-racer) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('test-ready)
     (and (and (-> this next-state) (= (-> this next-state name) 'waiting-for-start))
          (logtest? (-> this flags) (rigid-body-object-flag riding))
          )
     )
    (('begin-race)
     (logclear! (-> this focus-status) (focus-status grabbed))
     (when (and (-> this next-state) (= (-> this next-state name) 'waiting-for-start))
       (cond
         ((logtest? (-> this flags) (rigid-body-object-flag player-driving))
          (set! (-> this flags)
                (the-as rigid-body-object-flag (logclear (-> this flags) (rigid-body-object-flag player-grabbed)))
                )
          (go (method-of-object this player-control))
          )
         (else
           (go (method-of-object this racing))
           )
         )
       )
     )
    (('turbo-pickup)
     (when (< (-> this turbo-pickup-count) 3)
       (sound-play "turbo-pickup")
       (when (logtest? (-> this flags) (rigid-body-object-flag player-driving))
         (sound-play "turbo-pickup-pl")
         (send-event *target* 'color-effect 'eco-pill-dark (seconds 0.2))
         )
       (+! (-> this turbo-pickup-count) 1)
       #t
       )
     )
    (('race-decision-point)
     (when (logtest? (rigid-body-object-flag ai-driving) (-> this flags))
       (let* ((v1-37 (the-as race-decision-point (-> arg3 param 0)))
              (a0-16 (-> v1-37 decision-type))
              )
         (cond
           ((zero? a0-16)
            (cond
              ((and (nonzero? (-> v1-37 shortcuts))
                    (>= (-> this race racer-state speed-factor) (-> this race state info ai-max-speed-factor))
                    (< 0.1 (- (+ (-> this race state target-pos) (-> this race racer-state target-pos-offset))
                              (-> this race racer-state pos)
                              )
                       )
                    )
               (select-path-randomly-from-mask this (-> v1-37 shortcuts))
               (set-time! (-> this shortcut-time))
               (set! (-> this shortcut-speed-factor) 1.0)
               )
              (else
                (select-path-randomly-from-mask this (-> v1-37 safe-paths))
                (set! (-> this shortcut-speed-factor) 0.0)
                )
              )
            )
           ((= a0-16 1)
            (when (and (> (-> this turbo-pickup-count) 0)
                       (< (-> this path-deviation) 1.0)
                       (>= (-> this race racer-state speed-factor) (-> this race state info ai-max-speed-factor))
                       )
              (rigid-body-object-method-38 this)
              (vehicle-method-66 this)
              )
            )
           )
         )
       )
     )
    (('hide)
     (logior! (-> this draw status) (draw-control-status no-draw))
     (send-event (ppointer->process (-> this child)) 'hide)
     )
    (('unhide)
     (logclear! (-> this draw status) (draw-control-status no-draw))
     (send-event (ppointer->process (-> this child)) 'unhide)
     )
    (('race-pass)
     (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
         (speech-control-method-12 *speech-control* this (if (-> *target* pilot as-daxter?)
                                                             (speech-type speech-type-45)
                                                             (speech-type speech-type-36)
                                                             )
                                   )
         (send-event (ppointer->process (-> this child)) 'race-pass)
         )
     )
    (('race-got-passed)
     (if (not (logtest? (-> this flags) (rigid-body-object-flag player-driving)))
         (send-event (ppointer->process (-> this child)) 'race-got-passed)
         )
     )
    (('race-finished)
     (let ((s5-2 (-> arg3 param 0)))
       (select-path-randomly-from-mask this s5-2)
       (set! (-> this damage-factor) 0.0)
       (cond
         ((logtest? (-> this flags) (rigid-body-object-flag player-driving))
          (set! (-> this flags)
                (the-as rigid-body-object-flag (logior (rigid-body-object-flag player-grabbed) (-> this flags)))
                )
          (when (zero? s5-2)
            (set! (-> this race path) #f)
            #f
            )
          )
         (else
           (go (method-of-object this race-finished))
           )
         )
       )
     )
    (else
      ((method-of-type vehicle rigid-body-object-method-46) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod select-path-randomly-from-mask vehicle-racer ((this vehicle-racer) (arg0 uint))
  (let ((a0-1 0)
        (v1-0 0)
        (s5-0 (new 'stack-no-clear 'array 'int8 12))
        )
    (let ((a1-1 (logand arg0 255)))
      (while (nonzero? a1-1)
        (set! (-> s5-0 a0-1) v1-0)
        (+! a0-1 (logand a1-1 1))
        (+! v1-0 1)
        (set! a1-1 (shr a1-1 1))
        )
      )
    (when (> a0-1 0)
      (let ((s5-1 (-> s5-0 (rand-vu-int-count a0-1))))
        (format #t "vehicle-racer::select-path-randomly-from-mask:  switching to path-~d~%" s5-1)
        (race-control-method-9 (-> this race) s5-1 (-> this root trans))
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-racer-method-151 vehicle-racer ((this vehicle-racer))
  (local-vars (v1-18 float) (v1-28 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> this race)))
      (when (nonzero? s5-0)
        (race-control-method-11 s5-0 0.0)
        (let ((s4-0 (-> this rbody))
              (f30-0 (seconds-per-frame))
              )
          1.0
          (let ((s3-0 (new 'stack-no-clear 'inline-array 'matrix 9))
                (f28-0
                  (fmin
                    (* (+ (vector-length (-> s4-0 state lin-velocity)) (* 163840.0 f30-0))
                       (/ 1.0 (fmax 1.0 (vector-length (-> s5-0 lin-velocity))))
                       )
                    (-> s5-0 racer-state speed-factor)
                    )
                  )
                )
            (set! (-> s3-0 1 vector 1 x) 819200.0)
            (quaternion-copy! (the-as quaternion (-> s3-0 1)) (-> s5-0 path-sample quat))
            (vector-float*! (-> s3-0 0 vector 2) (-> s5-0 lin-velocity) f28-0)
            (vector-! (-> s3-0 0 trans) (the-as vector (-> s5-0 path-sample)) (-> s4-0 state position))
            (.lvf vf1 (&-> (-> s3-0 0 trans) quad))
            (.add.w.vf vf2 vf0 vf0 :mask #b1)
            (.mul.vf vf1 vf1 vf1)
            (.mul.x.vf acc vf2 vf1 :mask #b1)
            (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
            (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
            (.mov v1-18 vf1)
            (let ((f0-6 v1-18)
                  (f1-5 1.0)
                  (f2-2 40960.0)
                  )
              (set! (-> this path-deviation) (* f0-6 (/ f1-5 (* f2-2 f2-2))))
              )
            (let ((a1-4 (-> s3-0 0 vector 2)))
              (let ((v1-22 (-> s3-0 0 vector 2)))
                (let ((a0-5 (-> s3-0 0 trans)))
                  (let ((a2-1 1.0))
                    (.mov vf7 a2-1)
                    )
                  (.lvf vf5 (&-> a0-5 quad))
                  )
                (.lvf vf4 (&-> v1-22 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-4 quad) vf6)
              )
            (vector-! (the-as vector (-> s3-0 0)) (-> s3-0 0 vector 2) (-> s4-0 state lin-velocity))
            (vector-float*! (the-as vector (-> s3-0 0)) (the-as vector (-> s3-0 0)) 16.0)
            (let* ((f0-10 (-> s3-0 1 vector 1 x))
                   (f0-12 (* f0-10 f0-10))
                   )
              (.lvf vf1 (&-> (-> s3-0 0) quad 0))
              (.add.w.vf vf2 vf0 vf0 :mask #b1)
              (.mul.vf vf1 vf1 vf1)
              (.mul.x.vf acc vf2 vf1 :mask #b1)
              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
              (.mov v1-28 vf1)
              (if (< f0-12 v1-28)
                  (vector-normalize! (the-as vector (-> s3-0 0)) (-> s3-0 1 vector 1 x))
                  )
              )
            (let ((a1-9 (-> s4-0 state lin-velocity)))
              (let ((v1-31 (-> s4-0 state lin-velocity)))
                (let ((a0-9 (-> s3-0 0)))
                  (let ((a2-2 f30-0))
                    (.mov vf7 a2-2)
                    )
                  (.lvf vf5 (&-> a0-9 quad 0))
                  )
                (.lvf vf4 (&-> v1-31 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-9 quad) vf6)
              )
            (let ((a1-10 (-> s4-0 state position)))
              (let ((v1-32 (-> s4-0 state position)))
                (let ((a0-10 (-> s4-0 state lin-velocity)))
                  (let ((a2-3 f30-0))
                    (.mov vf7 a2-3)
                    )
                  (.lvf vf5 (&-> a0-10 quad))
                  )
                (.lvf vf4 (&-> v1-32 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-10 quad) vf6)
              )
            (quaternion-pseudo-seek
              (-> s4-0 state rotation)
              (-> s4-0 state rotation)
              (the-as quaternion (-> s3-0 1))
              (* 10.0 f30-0)
              )
            (vector-float*! (-> s4-0 state lin-momentum) (-> s4-0 state lin-velocity) (-> this info info mass))
            (vector-reset! (-> s4-0 state ang-momentum))
            (rigid-body-method-24 (-> s4-0 state))
            (rigid-body-method-13 (-> s4-0 state))
            (set! (-> this root transv quad) (-> s4-0 state lin-velocity quad))
            (quaternion-copy! (-> this root quat) (-> s4-0 state rotation))
            (let ((v1-46 s4-0)
                  (a1-14 (-> this root trans))
                  )
              (rigid-body-method-23 (-> v1-46 state) a1-14)
              )
            (let* ((v1-51 (-> this node-list data 0 bone transform))
                   (a3-1 (-> s4-0 state matrix))
                   (a0-20 (-> a3-1 quad 0))
                   (a1-15 (-> a3-1 quad 1))
                   (a2-5 (-> a3-1 quad 2))
                   (a3-2 (-> a3-1 trans quad))
                   )
              (set! (-> v1-51 quad 0) a0-20)
              (set! (-> v1-51 quad 1) a1-15)
              (set! (-> v1-51 quad 2) a2-5)
              (set! (-> v1-51 trans quad) a3-2)
              )
            (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
            (race-control-method-11 s5-0 (* f30-0 f28-0))
            )
          )
        )
      )
    (vehicle-method-119 this)
    (vehicle-method-120 this)
    (update-transforms (-> this root))
    (let ((a1-17 (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> a1-17 options) (overlaps-others-options))
      (set! (-> a1-17 collide-with-filter) (collide-spec civilian enemy obstacle))
      (set! (-> a1-17 tlist) *touching-list*)
      (find-overlapping-shapes (-> this root) a1-17)
      )
    0
    (none)
    )
  )

(defmethod physics-post vehicle-racer ((this vehicle-racer))
  (local-vars (v1-35 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> this race)))
      (let ((s4-0 (new 'stack-no-clear 'inline-array 'matrix 9)))
        (set! (-> s4-0 0 quad 0) (-> this rbody state position quad))
        (set! (-> s4-0 0 vector 1 quad) (-> this rbody state lin-velocity quad))
        (set! (-> s4-0 3 vector 1 y) 0.0)
        (set! (-> s4-0 1 vector 1 quad) (-> this rbody state matrix quad 0))
        (set! (-> s4-0 1 vector 1 y) 0.0)
        (vector-normalize! (-> s4-0 1 vector 1) 1.0)
        (set! (-> s4-0 1 vector 2 quad) (-> this rbody state matrix vector 2 quad))
        (set! (-> s4-0 3 vector 0 x)
              (* (-> this rbody state ang-velocity y) (vector-length (-> this rbody state lin-velocity)))
              )
        (set! (-> s4-0 3 vector 1 x) (seconds-per-frame))
        (race-control-method-12 s5-0 (the-as vector (-> s4-0 0)))
        (set! (-> s4-0 3 vector 0 y) (vector-length (-> s4-0 0 vector 1)))
        (set! (-> s4-0 3 vector 0 z) (vector-length (-> s5-0 lin-velocity)))
        (set! (-> s4-0 3 vector 0 w)
              (* (-> s4-0 3 vector 0 z) (fmax (-> s5-0 racer-state speed-factor) (-> this shortcut-speed-factor)))
              )
        (if (logtest? (rigid-body-object-flag in-air turbo-boost) (-> this flags))
            (set! (-> s4-0 3 vector 0 w) (* 2.0 (-> s4-0 3 vector 0 w)))
            )
        (let ((v1-21 (-> s5-0 path-sample)))
          (set! (-> s4-0 2 vector 0 x) (* 0.007874016 (the float (-> v1-21 stick-x))))
          (set! (-> s4-0 2 vector 0 w) (* 0.007874016 (the float (-> v1-21 stick-y))))
          (set! (-> s4-0 2 vector 0 y) (* 0.003921569 (the float (-> v1-21 throttle))))
          (set! (-> s4-0 2 vector 0 z) (if (logtest? (-> v1-21 flags) 1)
                                           1.0
                                           0.0
                                           )
                )
          )
        (let ((f0-19 (+ (-> s5-0 path-t) (* 1.875 (/ 1.0 (-> s4-0 3 vector 0 z)) (-> s4-0 3 vector 0 y)))))
          (race-path-method-11 (-> s5-0 path) (the-as race-path-sample (-> s4-0 2 vector 1)) (-> s4-0 2 trans) f0-19)
          )
        (vector-! (-> s4-0 0 trans) (the-as vector (-> s5-0 path-sample)) (the-as vector (-> s4-0 0)))
        (let* ((f0-20 (-> s4-0 3 vector 1 y))
               (f1-13 1.0)
               (f2-4 40960.0)
               (f1-14 (/ f1-13 (* f2-4 f2-4)))
               )
          (.lvf vf1 (&-> (-> s4-0 0 trans) quad))
          (.add.w.vf vf2 vf0 vf0 :mask #b1)
          (.mul.vf vf1 vf1 vf1)
          (.mul.x.vf acc vf2 vf1 :mask #b1)
          (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
          (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
          (.mov v1-35 vf1)
          (set! (-> s4-0 3 vector 1 y) (+ f0-20 (* f1-14 v1-35)))
          )
        (let ((f30-0 (-> s4-0 3 vector 1 y))
              (f0-22 1.0)
              (f1-16 40960.0)
              )
          (set! (-> s4-0 3 vector 1 y)
                (+ f30-0
                   (* (/ f0-22 (* f1-16 f1-16)) (vector-vector-distance-squared (-> s5-0 lin-velocity) (-> s4-0 0 vector 1)))
                   )
                )
          )
        (set! (-> this path-deviation) (-> s4-0 3 vector 1 y))
        (let ((a1-6 (-> s4-0 0 vector 2)))
          (let ((v1-39 (-> s4-0 2 trans)))
            (let ((a0-25 (-> s4-0 0 trans)))
              (let ((a2-2 1.0))
                (.mov vf7 a2-2)
                )
              (.lvf vf5 (&-> a0-25 quad))
              )
            (.lvf vf4 (&-> v1-39 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-6 quad) vf6)
          )
        (vector-! (the-as vector (-> s4-0 1)) (-> s4-0 0 vector 2) (-> s4-0 0 vector 1))
        (vector-float*! (-> s4-0 1 trans) (the-as vector (-> s4-0 1)) 1.5)
        (let ((f1-22 (* 0.00036621094 (- (-> s4-0 3 vector 0 w) (-> s4-0 3 vector 0 y)) (-> s4-0 3 vector 1 x))))
          (set! (-> this ai-controls throttle) (fmax 0.0 (fmin 1.0 (+ (-> this ai-controls throttle) f1-22))))
          )
        (set! (-> this ai-controls brake)
              (fmax 0.0 (fmin 1.0 (* 0.000048828126 (+ (- -4096.0 (-> s4-0 3 vector 0 w)) (-> s4-0 3 vector 0 y)))))
              )
        (+! (-> this ai-controls brake) (* (- (-> this ai-controls brake)) (fmin 1.0 (* 8.0 (-> s4-0 3 vector 1 x)))))
        (set! (-> this ai-controls steering)
              (fmax -1.0 (fmin 1.0 (* 0.000000000048894434
                                      (+ 40960.0 (-> s4-0 3 vector 0 y))
                                      (vector-dot (-> s4-0 1 vector 1) (-> s4-0 1 trans))
                                      )
                               )
                    )
              )
        (set! (-> s4-0 3 vector 1 y) (fmin 1.0 (-> s4-0 3 vector 1 y)))
        (set! (-> s4-0 2 vector 0 x) (+ (* (-> s4-0 2 vector 0 x) (- 1.0 (-> s4-0 3 vector 1 y)))
                                        (* (-> this ai-controls steering) (-> s4-0 3 vector 1 y))
                                        )
              )
        (set! (-> s4-0 2 vector 0 y) (-> this ai-controls throttle))
        (set! (-> s4-0 2 vector 0 z) (-> this ai-controls brake))
        (vehicle-method-95 this (the-as vector (-> s4-0 2)))
        )
      (when (logtest? (-> s5-0 path-sample flags) 2)
        (start-jump this)
        0
        )
      )
    (vehicle-method-121 this)
    (when (< (-> this rbody state position y) -409600.0)
      (format
        #t
        "vehicle-racer::physics-post:  pid ~d fell to death from path-id ~d~%"
        (-> this pid)
        (-> this race path record-id)
        )
      (go (method-of-object this explode))
      )
    0
    (none)
    )
  )

(defmethod vehicle-racer-method-154 vehicle-racer ((this vehicle-racer))
  (cond
    ((logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
     (if (and (logtest? (-> this flags) (rigid-body-object-flag on-ground))
              (not (logtest? (rigid-body-object-flag turbo-boost) (-> this flags)))
              (let ((f0-0 368640.0))
                (or (< (* f0-0 f0-0) (-> this player-dist2))
                    (let ((f0-3 102400.0))
                      (and (< (* f0-3 f0-3) (-> this player-dist2))
                           (not (logtest? (-> this draw status) (draw-control-status on-screen)))
                           )
                      )
                    )
                )
              )
         (rigid-body-object-method-39 this)
         )
     )
    (else
      (let ((f0-6 (-> this player-dist2))
            (f1-2 348160.0)
            )
        (if (and (< f0-6 (* f1-2 f1-2)) (let ((f0-7 (-> this player-dist2))
                                              (f1-5 81920.0)
                                              )
                                          (or (< f0-7 (* f1-5 f1-5))
                                              (logtest? (-> this draw status) (draw-control-status on-screen))
                                              (logtest? (rigid-body-object-flag turbo-boost) (-> this flags))
                                              )
                                          )
                 )
            (rigid-body-object-method-38 this)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-racer-method-152 vehicle-racer ((this vehicle-racer))
  (let ((s5-0 (new 'stack-no-clear 'matrix3)))
    (set! (-> s5-0 vector 0 quad) (-> this rbody state position quad))
    (set! (-> this camera-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (camera-pos)))
    (set! (-> this player-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (target-pos 0)))
    )
  (if (time-elapsed? (-> this shortcut-time) (seconds 5))
      (set! (-> this shortcut-speed-factor) 0.0)
      )
  (vehicle-racer-method-154 this)
  (if (logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
      (physics-post this)
      (vehicle-racer-method-151 this)
      )
  0
  (none)
  )

(defmethod vehicle-racer-method-155 vehicle-racer ((this vehicle-racer))
  (let ((s5-0 (new 'stack-no-clear 'matrix3)))
    (set! (-> s5-0 vector 0 quad) (-> this rbody state position quad))
    (set! (-> this camera-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (camera-pos)))
    (set! (-> this player-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (target-pos 0)))
    )
  (set! (-> this shortcut-speed-factor) 0.0)
  (vehicle-racer-method-154 this)
  (if (and (logtest? (-> this flags) (rigid-body-object-flag player-driving))
           (not (logtest? (-> this rbody state flags) (rigid-body-flag enable-physics)))
           )
      (rigid-body-object-method-38 this)
      )
  (if (logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
      (physics-post this)
      (vehicle-racer-method-151 this)
      )
  0
  (none)
  )

(defmethod vehicle-method-124 vehicle-racer ((this vehicle-racer))
  (cond
    ((and (logtest? (rigid-body-object-flag player-grabbed) (-> this flags)) (-> this race path))
     (vehicle-racer-method-155 this)
     )
    (else
      (vehicle-method-94 this)
      (vehicle-method-121 this)
      )
    )
  (vehicle-method-97 this)
  0
  (none)
  )

(defstate waiting-race (vehicle-racer)
  :virtual #t
  :event vehicle-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self flags) (rigid-body-object-flag ignition))
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    (set! (-> self damage-factor) 0.0)
    (vehicle-method-83 self)
    (vehicle-method-143 self)
    (let ((v1-9 (find-prim-by-id-logtest (-> self root) (the-as uint 32))))
      (when v1-9
        (set! (-> v1-9 prim-core collide-with) (collide-spec))
        (set! (-> v1-9 prim-core collide-as) (collide-spec))
        0
        )
      )
    )
  :exit (behavior ()
    (set! (-> self hit-points) 1.0)
    (logclear! (-> self flags) (rigid-body-object-flag waiting-for-player))
    (let ((v1-4 (find-prim-by-id-logtest (-> self root) (the-as uint 32))))
      (when v1-4
        (set! (-> v1-4 prim-core collide-with) (collide-spec
                                                 backgnd
                                                 crate
                                                 civilian
                                                 enemy
                                                 obstacle
                                                 vehicle-sphere
                                                 hit-by-player-list
                                                 hit-by-others-list
                                                 collectable
                                                 pusher
                                                 )
              )
        (set! (-> v1-4 prim-core collide-as) (collide-spec vehicle-sphere))
        )
      )
    )
  :trans #f
  :code sleep-code
  :post (behavior ()
    (when (logtest? (-> self flags) (rigid-body-object-flag waiting-for-player))
      (set! (-> self camera-dist2) (vector-vector-distance-squared (-> self root trans) (camera-pos)))
      (set! (-> self player-dist2) (vector-vector-distance-squared (-> self root trans) (target-pos 0)))
      (check-player-get-on self)
      )
    (vector-reset! (-> self target-acceleration))
    (vehicle-method-120 self)
    (update-transforms (-> self root))
    (vehicle-method-119 self)
    (rigid-body-object-method-39 self)
    )
  )

(defstate waiting-for-start (vehicle-racer)
  :virtual #t
  :event vehicle-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self damage-factor) (-> self info damage-factor))
    (vehicle-method-143 self)
    (logior! (-> self flags) (rigid-body-object-flag ignition))
    )
  :code sleep-code
  :post (behavior ()
    (vector-reset! (-> self target-acceleration))
    (logclear! (-> self flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    (let ((v1-4 (-> self rbody state)))
      (set! (-> v1-4 force quad) (the-as uint128 0))
      (set! (-> v1-4 torque quad) (the-as uint128 0))
      )
    0
    (clear-momentum! (-> self rbody state))
    (vehicle-method-120 self)
    (vehicle-method-119 self)
    )
  )

(defstate racing (vehicle-racer)
  :virtual #t
  :event vehicle-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (logior! (-> self flags) (rigid-body-object-flag riding ignition))
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (rigid-body-object-flag waiting-for-player))
    (let ((v1-3 (find-prim-by-id-logtest (-> self root) (the-as uint 32))))
      (when v1-3
        (set! (-> v1-3 prim-core collide-with) (collide-spec
                                                 backgnd
                                                 crate
                                                 civilian
                                                 enemy
                                                 obstacle
                                                 vehicle-sphere
                                                 hit-by-player-list
                                                 hit-by-others-list
                                                 collectable
                                                 pusher
                                                 )
              )
        (set! (-> v1-3 prim-core collide-as) (collide-spec vehicle-sphere))
        )
      )
    )
  :trans #f
  :code sleep-code
  :post (behavior ()
    (vehicle-racer-method-152 self)
    )
  )

(defstate race-finished (vehicle-racer)
  :virtual #t
  :event vehicle-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self flags) (the-as
                            rigid-body-object-flag
                            (logior (rigid-body-object-flag persistent riding nav-spheres) (-> self flags))
                            )
          )
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    )
  :trans #f
  :code sleep-code
  :post (behavior ()
    (vehicle-racer-method-155 self)
    )
  )
