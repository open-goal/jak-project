;;-*-Lisp-*-
(in-package goal)

;; name: vehicle-racer.gc
;; name in dgo: vehicle-racer
;; dgos: STD, STC, LERLCHAL, STB, LPRTRACE

(define-extern *race-state* race-state)

;; DECOMP BEGINS

(deftype race-control (structure)
  ((state        race-state               :offset-assert   0)
   (mesh         race-mesh                :offset-assert   4)
   (path-select  int8                     :offset-assert   8)
   (path-group   race-path-group          :offset-assert  12)
   (path         race-path                :offset-assert  16)
   (path-t       float                    :offset-assert  20)
   (racer-state  racer-state              :offset-assert  24)
   (path-sample  race-path-sample :inline :offset-assert  32)
   (lin-velocity vector           :inline :offset-assert  64)
   (ang-velocity vector           :inline :offset-assert  80)
   )
  :method-count-assert 13
  :size-assert         #x60
  :flag-assert         #xd00000060
  (:methods
    (race-control-method-9 (_type_ int vector) none 9)
    (race-control-method-10 (_type_ race-state racer-state) none 10)
    (race-control-method-11 (_type_ float) none 11)
    (race-control-method-12 (_type_ vector) none 12)
    )
  )


(defmethod race-control-method-12 race-control ((obj race-control) (arg0 vector))
  (let* ((f0-0 (-> obj path-t))
         (f0-2 (race-path-method-12 (-> obj path) arg0 (+ -1.0 f0-0) (+ 1.0 f0-0)))
         )
    (set! (-> obj path-t) f0-2)
    (race-path-method-11 (-> obj path) (-> obj path-sample) (-> obj lin-velocity) f0-2)
    )
  0
  (none)
  )

(defmethod race-control-method-11 race-control ((obj race-control) (arg0 float))
  (let ((f0-1 (+ (-> obj path-t) (* 15.0 arg0))))
    (set! f0-1 (cond
                 ((logtest? (-> obj mesh flags) (race-mesh-flags racemeshflag-0))
                  (let ((f1-3 (the float (-> obj path sample-count))))
                    (if (>= f0-1 f1-3)
                        (set! f0-1 (- f0-1 f1-3))
                        )
                    )
                  f0-1
                  )
                 (else
                   (fmin f0-1 (the float (+ (-> obj path sample-count) -1)))
                   )
                 )
          )
    (set! (-> obj path-t) f0-1)
    (race-path-method-11 (-> obj path) (-> obj path-sample) (-> obj lin-velocity) f0-1)
    )
  (vector-reset! (-> obj ang-velocity))
  0
  (none)
  )

(defmethod race-control-method-9 race-control ((obj race-control) (arg0 int) (arg1 vector))
  (let ((v1-1 (-> obj path-group path-count)))
    (if (>= arg0 v1-1)
        (set! arg0 0)
        )
    (set! (-> obj path-select) arg0)
    (cond
      ((> v1-1 0)
       (let ((s4-0 (-> obj path-group paths arg0)))
         (set! (-> obj path) s4-0)
         (let ((s3-0 (new 'stack-no-clear 'race-mesh-slice-query)))
           (set! (-> s3-0 search-sphere quad) (-> arg1 quad))
           (set! (-> s3-0 search-sphere r) 61440.0)
           (race-mesh-method-13 (-> obj mesh) (the-as race-mesh-slice-query (&-> s3-0 slice-id)))
           (when (!= (-> s3-0 slice-id) -1)
             (let* ((v1-12 (-> obj mesh slices (-> s3-0 slice-id)))
                    (f0-1 (-> (the-as (pointer float) (+ (* (-> v1-12 start-edge) 4) (the-as int (-> s4-0 edge-infos))))))
                    (f1-0
                      (-> (the-as race-path-edge-info (+ (* (-> v1-12 end-edge) 4) (the-as int (-> s4-0 edge-infos)))) sample-t)
                      )
                    )
               (when (and (>= f0-1 0.0) (>= f1-0 0.0))
                 (let ((f0-2 (race-path-method-12 s4-0 arg1 f0-1 f1-0)))
                   (set! (-> obj path-t) f0-2)
                   (race-path-method-11 (-> obj path) (-> obj path-sample) (-> obj lin-velocity) f0-2)
                   )
                 )
               )
             )
           )
         )
       )
      (else
        (set! (-> obj path) #f)
        )
      )
    )
  0
  (none)
  )

(defmethod race-control-method-10 race-control ((obj race-control) (arg0 race-state) (arg1 racer-state))
  (set! (-> obj state) arg0)
  (set! (-> obj mesh) (-> arg0 info mesh))
  (if (-> obj mesh)
      (set! (-> obj path-group) (-> obj mesh path-groups 0))
      )
  (set! (-> obj racer-state) arg1)
  0
  (none)
  )

(deftype vehicle-racer (vehicle)
  ((race                  race-control       :inline :offset-assert 880)
   (ai-controls           vehicle-controls   :inline :offset-assert 976)
   (rider-hand-joint      int8                       :offset-assert 992)
   (turbo-pickup-count    int8                       :offset-assert 993)
   (minimap               connection-minimap         :offset-assert 996)
   (shortcut-speed-factor float                      :offset-assert 1000)
   (path-deviation        float                      :offset-assert 1004)
   (shortcut-time         time-frame                 :offset-assert 1008)
   )
  :heap-base #x380
  :method-count-assert 156
  :size-assert         #x3f8
  :flag-assert         #x9c038003f8
  (:methods
    (waiting-race () _type_ :state 144)
    (waiting-for-start () _type_ :state 145)
    (racing () _type_ :state 146)
    (race-finished () _type_ :state 147)
    (vehicle-racer-method-148 (_type_ race-path race-mesh-slice) none 148)
    (vehicle-racer-method-149 (_type_) none 149)
    (select-path-randomly-from-mask (_type_ uint) none 150)
    (vehicle-racer-method-151 (_type_) none 151)
    (vehicle-racer-method-152 (_type_) none 152)
    (physics-post (_type_) none 153)
    (vehicle-racer-method-154 (_type_) none 154)
    (vehicle-racer-method-155 (_type_) none 155)
    )
  )


(defmethod vehicle-method-117 vehicle-racer ((obj vehicle-racer) (arg0 vector) (arg1 int) (arg2 int))
  (vector-matrix*!
    arg0
    (-> obj info rider-hand-offset arg2)
    (-> obj node-list data (-> obj rider-hand-joint) bone transform)
    )
  0
  (none)
  )

(defmethod vehicle-method-137 vehicle-racer ((obj vehicle-racer) (arg0 traffic-object-spawn-params))
  (let ((t9-0 vehicle-rider-spawn)
        (v1-0 (-> arg0 user-data))
        )
    (t9-0
      obj
      (if (= v1-0 2)
          errol-rider
          stadium-racer
          )
      arg0
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch number vs none.
(defmethod vehicle-racer-method-148 vehicle-racer ((obj vehicle-racer) (arg0 race-path) (arg1 race-mesh-slice))
  (let ((f26-0 (the-as number 0.0))
        (gp-0 (new 'stack-no-clear 'vehicle-physics-work))
        (f30-0 (-> (the-as (pointer float) (+ (* (-> arg1 start-edge) 4) (the-as int (-> arg0 edge-infos))))))
        (f28-0 (-> (the-as (pointer float) (+ (* (-> arg1 end-edge) 4) (the-as int (-> arg0 edge-infos))))))
        )
    (when (and (>= f30-0 0.0) (>= f28-0 0.0))
      (let ((f26-1 1.0))
        (set! (-> gp-0 mat trans quad) (-> obj root trans quad))
        (set! (-> gp-0 velocity quad) (-> obj root transv quad))
        (quaternion-copy! (the-as quaternion (-> gp-0 force)) (-> obj root quat))
        (let* ((f0-2 (race-path-method-12 arg0 (-> gp-0 mat trans) f30-0 f28-0))
               (a0-4 arg0)
               (t9-2 (method-of-type race-path race-path-method-11))
               (a1-11 (-> gp-0 steering-axis))
               (a2-2 (-> gp-0 mat vector 2))
               (a3-1 f0-2)
               )
          (t9-2 a0-4 (the-as race-path-sample a1-11) a2-2 a3-1)
          (let* ((f1-0 (vector-vector-distance-squared (-> gp-0 steering-axis) (-> gp-0 mat trans)))
                 (f0-3 0.0)
                 (f2-0 32768.0)
                 (f1-1 (- (* f2-0 f2-0) f1-0))
                 (f2-3 1.0)
                 (f3-0 32768.0)
                 (f26-2 (* f26-1 (fmax f0-3 (* f1-1 (/ f2-3 (* f3-0 f3-0))))))
                 )
            0
            (let* ((f0-5 (vector-vector-distance (-> gp-0 mat vector 2) (-> gp-0 velocity)))
                   (f26-3 (* f26-2 (fmax 0.1 (* 0.000012207031 (- 81920.0 f0-5)))))
                   )
              0
              (quaternion-conjugate! (the-as quaternion (-> gp-0 local-pos)) (the-as quaternion (-> gp-0 force)))
              (quaternion*!
                (the-as quaternion (-> gp-0 world-normal))
                (the-as quaternion (-> gp-0 local-pos))
                (the-as quaternion (-> gp-0 lift-dir))
                )
              (set! f26-0 (* f26-3 (fabs (-> gp-0 world-normal w))))
              )
            )
          0
          0
          (race-path-method-10 arg0 (the-as vector (-> gp-0 mat)) f30-0 a3-1)
          (race-path-method-10 arg0 (-> gp-0 mat vector 1) f28-0 a3-1)
          )
        )
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (the-as vector (-> gp-0 mat))
        (-> gp-0 mat vector 1)
        *color-cyan*
        #f
        (the-as rgba -1)
        )
      )
    )
  (none)
  )

(defmethod vehicle-method-120 vehicle-racer ((obj vehicle-racer))
  (when (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
    (set! (-> *game-info* race-number-turbos) (-> obj turbo-pickup-count))
    0
    )
  (logior! (-> obj skel status) (joint-control-status sync-math))
  (let ((t9-0 (method-of-type vehicle vehicle-method-120)))
    (t9-0 obj)
    )
  (let ((v1-10 (-> obj root trans-old-old quad)))
    (set! (-> obj root trans-old-old-old quad) v1-10)
    )
  (let ((v1-12 (-> obj root trans-old quad)))
    (set! (-> obj root trans-old-old quad) v1-12)
    )
  (let ((v1-14 (-> obj root trans quad)))
    (set! (-> obj root trans-old quad) v1-14)
    )
  0
  (none)
  )

(defmethod vehicle-method-66 vehicle-racer ((obj vehicle-racer))
  (when (and (not (logtest? (rigid-body-object-flag turbo-boost) (-> obj flags))) (> (-> obj turbo-pickup-count) 0))
    (+! (-> obj turbo-pickup-count) -1)
    (set! (-> obj turbo-boost-time) (current-time))
    (set! (-> obj turbo-boost-factor) 1.0)
    (set! (-> obj turbo-boost-duration) (the-as uint 150))
    (logior! (-> obj flags) (rigid-body-object-flag turbo-boost))
    (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
        (sound-play "turbo-boost")
        )
    )
  0
  (none)
  )

(defmethod vehicle-method-136 vehicle-racer ((obj vehicle-racer) (arg0 traffic-object-spawn-params))
  (set! (-> obj draw lod-set lod 1 dist) 819200.0)
  (set! (-> obj draw lod-set lod 2 dist) 1228800.0)
  (let* ((a1-1 *race-state*)
         (a2-0 (-> a1-1 racer-array (-> arg0 id)))
         )
    (race-control-method-10 (-> obj race) a1-1 a2-0)
    )
  (set! (-> obj shortcut-speed-factor) 0.0)
  (case (-> arg0 behavior)
    ((10)
     (when (not (-> obj race mesh))
       (format #t "ERROR: vehicle-racer::go-start-state: no race-mesh found~%")
       (go (method-of-object obj die))
       )
     (when (-> obj race mesh)
       (race-control-method-9 (-> obj race) (-> obj traffic-priority-id) (-> obj root trans))
       (cond
         ((logtest? (-> arg0 flags) (traffic-spawn-flags trsflags-01))
          (logior! (-> obj flags) (rigid-body-object-flag riding ai-driving))
          (cond
            ((-> obj race path)
             (go (method-of-object obj waiting-for-start))
             )
            (else
              (format 0 "vehicle-racer::go-start-state: ERROR, no race-paths found~%")
              (go (method-of-object obj die))
              )
            )
          )
         (else
           (logior! (-> obj flags) (rigid-body-object-flag waiting-for-player))
           (logior! (-> obj focus-status) (focus-status grabbed))
           (go (method-of-object obj waiting-race))
           )
         )
       )
     )
    (else
      ((method-of-type vehicle vehicle-method-136) obj arg0)
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-138 vehicle-racer ((obj vehicle-racer))
  (if (focus-test? obj grabbed)
      (go (method-of-object obj waiting-for-start))
      (go (method-of-object obj player-control))
      )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod rigid-body-object-method-45 vehicle-racer ((obj vehicle-racer) (arg0 rigid-body-impact))
  (let ((t9-0 (method-of-type vehicle rigid-body-object-method-45)))
    (t9-0 obj arg0)
    )
  (when (and (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (< 40960.0 (-> arg0 impulse))
             (< 0.0 (-> obj hit-points))
             )
    (cond
      ((-> arg0 rbody)
       (dotimes (s4-0 (-> obj info seat-count))
         (send-event (handle->process (-> obj rider-array s4-0)) 'vehicle-got-hit arg0)
         )
       )
      (else
        (dotimes (s4-1 (-> obj info seat-count))
          (send-event (handle->process (-> obj rider-array s4-1)) 'vehicle-hit arg0)
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 16]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 43]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 49]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 108]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 156]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 166]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 275]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 295]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 318]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 324]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 329]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 219]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 242]
;; WARN: disable def twice: 12. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod rigid-body-object-method-46 vehicle-racer ((obj vehicle-racer) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v1-0 arg2))
    (the-as
      object
      (cond
        ((= v1-0 'test-ready)
         (and (and (-> obj next-state) (= (-> obj next-state name) 'waiting-for-start))
              (logtest? (-> obj flags) (rigid-body-object-flag riding))
              )
         )
        ((= v1-0 'begin-race)
         (logclear! (-> obj focus-status) (focus-status grabbed))
         (when (and (-> obj next-state) (= (-> obj next-state name) 'waiting-for-start))
           (cond
             ((logtest? (-> obj flags) (rigid-body-object-flag player-driving))
              (set! (-> obj flags)
                    (the-as rigid-body-object-flag (logclear (-> obj flags) (rigid-body-object-flag player-grabbed)))
                    )
              (go (method-of-object obj player-control))
              )
             (else
               (go (method-of-object obj racing))
               )
             )
           )
         )
        ((= v1-0 'turbo-pickup)
         (when (< (-> obj turbo-pickup-count) 3)
           (sound-play "turbo-pickup")
           (when (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (sound-play "turbo-pickup-pl")
             (send-event *target* 'color-effect 'eco-pill-dark (seconds 0.2))
             )
           (+! (-> obj turbo-pickup-count) 1)
           #t
           )
         )
        ((= v1-0 'race-decision-point)
         (when (logtest? (rigid-body-object-flag ai-driving) (-> obj flags))
           (let* ((v1-37 (the-as race-decision-point (-> arg3 param 0)))
                  (a0-16 (-> v1-37 decision-type))
                  )
             (cond
               ((zero? a0-16)
                (cond
                  ((and (nonzero? (-> v1-37 shortcuts))
                        (>= (-> obj race racer-state speed-factor) (-> obj race state info ai-max-speed-factor))
                        (< 0.1 (- (+ (-> obj race state target-pos) (-> obj race racer-state target-pos-offset))
                                  (-> obj race racer-state pos)
                                  )
                           )
                        )
                   (select-path-randomly-from-mask obj (-> v1-37 shortcuts))
                   (set! (-> obj shortcut-time) (current-time))
                   (set! (-> obj shortcut-speed-factor) 1.0)
                   )
                  (else
                    (select-path-randomly-from-mask obj (-> v1-37 safe-paths))
                    (set! (-> obj shortcut-speed-factor) 0.0)
                    )
                  )
                )
               ((= a0-16 1)
                (when (and (> (-> obj turbo-pickup-count) 0)
                           (< (-> obj path-deviation) 1.0)
                           (>= (-> obj race racer-state speed-factor) (-> obj race state info ai-max-speed-factor))
                           )
                  (rigid-body-object-method-38 obj)
                  (vehicle-method-66 obj)
                  )
                )
               )
             )
           )
         )
        ((= v1-0 'hide)
         (logior! (-> obj draw status) (draw-control-status no-draw))
         (send-event (ppointer->process (-> obj child)) 'hide)
         )
        ((= v1-0 'unhide)
         (logclear! (-> obj draw status) (draw-control-status no-draw))
         (send-event (ppointer->process (-> obj child)) 'unhide)
         )
        ((= v1-0 'race-pass)
         (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (speech-control-method-12 *speech-control* obj (if (-> *target* pilot as-daxter?)
                                                                (speech-type speech-type-45)
                                                                (speech-type speech-type-36)
                                                                )
                                       )
             (send-event (ppointer->process (-> obj child)) 'race-pass)
             )
         )
        ((= v1-0 'race-got-passed)
         (if (not (logtest? (-> obj flags) (rigid-body-object-flag player-driving)))
             (send-event (ppointer->process (-> obj child)) 'race-got-passed)
             )
         )
        ((= v1-0 'race-finished)
         (let ((s5-2 (-> arg3 param 0)))
           (select-path-randomly-from-mask obj s5-2)
           (set! (-> obj damage-factor) 0.0)
           (cond
             ((logtest? (-> obj flags) (rigid-body-object-flag player-driving))
              (set! (-> obj flags)
                    (the-as rigid-body-object-flag (logior (rigid-body-object-flag player-grabbed) (-> obj flags)))
                    )
              (when (zero? s5-2)
                (set! (-> obj race path) #f)
                #f
                )
              )
             (else
               (go (method-of-object obj race-finished))
               )
             )
           )
         )
        (else
          ((method-of-type vehicle rigid-body-object-method-46) obj arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defmethod select-path-randomly-from-mask vehicle-racer ((obj vehicle-racer) (arg0 uint))
  (let ((a0-1 0)
        (v1-0 0)
        (s5-0 (new 'stack-no-clear 'array 'int8 12))
        )
    (let ((a1-1 (logand arg0 255)))
      (while (nonzero? a1-1)
        (set! (-> s5-0 a0-1) v1-0)
        (+! a0-1 (logand a1-1 1))
        (+! v1-0 1)
        (set! a1-1 (shr a1-1 1))
        )
      )
    (when (> a0-1 0)
      (let ((s5-1 (-> s5-0 (rand-vu-int-count a0-1))))
        (format #t "vehicle-racer::select-path-randomly-from-mask:  switching to path-~d~%" s5-1)
        (race-control-method-9 (-> obj race) s5-1 (-> obj root trans))
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-racer-method-151 vehicle-racer ((obj vehicle-racer))
  (local-vars (v1-18 float) (v1-28 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let ((s5-0 (-> obj race)))
        (when (nonzero? s5-0)
          (race-control-method-11 s5-0 0.0)
          (let ((s4-0 (-> obj rbody))
                (f30-0 (-> pp clock seconds-per-frame))
                )
            1.0
            (let ((s3-0 (new 'stack-no-clear 'inline-array 'matrix 9))
                  (f28-0
                    (fmin
                      (* (+ (vector-length (-> s4-0 state lin-velocity)) (* 163840.0 f30-0))
                         (/ 1.0 (fmax 1.0 (vector-length (-> s5-0 lin-velocity))))
                         )
                      (-> s5-0 racer-state speed-factor)
                      )
                    )
                  )
              (set! (-> s3-0 1 vector 1 x) 819200.0)
              (quaternion-copy! (the-as quaternion (-> s3-0 1)) (-> s5-0 path-sample quat))
              (vector-float*! (-> s3-0 0 vector 2) (-> s5-0 lin-velocity) f28-0)
              (vector-! (-> s3-0 0 trans) (the-as vector (-> s5-0 path-sample)) (-> s4-0 state position))
              (.lvf vf1 (&-> (-> s3-0 0 trans) quad))
              (.add.w.vf vf2 vf0 vf0 :mask #b1)
              (.mul.vf vf1 vf1 vf1)
              (.mul.x.vf acc vf2 vf1 :mask #b1)
              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
              (.mov v1-18 vf1)
              (let ((f0-6 v1-18)
                    (f1-5 1.0)
                    (f2-2 40960.0)
                    )
                (set! (-> obj path-deviation) (* f0-6 (/ f1-5 (* f2-2 f2-2))))
                )
              (let ((a1-4 (-> s3-0 0 vector 2)))
                (let ((v1-22 (-> s3-0 0 vector 2)))
                  (let ((a0-5 (-> s3-0 0 trans)))
                    (let ((a2-1 1.0))
                      (.mov vf7 a2-1)
                      )
                    (.lvf vf5 (&-> a0-5 quad))
                    )
                  (.lvf vf4 (&-> v1-22 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-4 quad) vf6)
                )
              (vector-! (the-as vector (-> s3-0 0)) (-> s3-0 0 vector 2) (-> s4-0 state lin-velocity))
              (vector-float*! (the-as vector (-> s3-0 0)) (the-as vector (-> s3-0 0)) 16.0)
              (let* ((f0-10 (-> s3-0 1 vector 1 x))
                     (f0-12 (* f0-10 f0-10))
                     )
                (.lvf vf1 (&-> (-> s3-0 0) quad 0))
                (.add.w.vf vf2 vf0 vf0 :mask #b1)
                (.mul.vf vf1 vf1 vf1)
                (.mul.x.vf acc vf2 vf1 :mask #b1)
                (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                (.mov v1-28 vf1)
                (if (< f0-12 v1-28)
                    (vector-normalize! (the-as vector (-> s3-0 0)) (-> s3-0 1 vector 1 x))
                    )
                )
              (let ((a1-9 (-> s4-0 state lin-velocity)))
                (let ((v1-31 (-> s4-0 state lin-velocity)))
                  (let ((a0-9 (-> s3-0 0)))
                    (let ((a2-2 f30-0))
                      (.mov vf7 a2-2)
                      )
                    (.lvf vf5 (&-> a0-9 quad 0))
                    )
                  (.lvf vf4 (&-> v1-31 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-9 quad) vf6)
                )
              (let ((a1-10 (-> s4-0 state position)))
                (let ((v1-32 (-> s4-0 state position)))
                  (let ((a0-10 (-> s4-0 state lin-velocity)))
                    (let ((a2-3 f30-0))
                      (.mov vf7 a2-3)
                      )
                    (.lvf vf5 (&-> a0-10 quad))
                    )
                  (.lvf vf4 (&-> v1-32 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-10 quad) vf6)
                )
              (quaternion-pseudo-seek
                (-> s4-0 state rotation)
                (-> s4-0 state rotation)
                (the-as quaternion (-> s3-0 1))
                (* 10.0 f30-0)
                )
              (vector-float*! (-> s4-0 state lin-momentum) (-> s4-0 state lin-velocity) (-> obj info info mass))
              (vector-reset! (-> s4-0 state ang-momentum))
              (rigid-body-method-24 (-> s4-0 state))
              (rigid-body-method-13 (-> s4-0 state))
              (set! (-> obj root transv quad) (-> s4-0 state lin-velocity quad))
              (quaternion-copy! (-> obj root quat) (-> s4-0 state rotation))
              (let ((v1-46 s4-0)
                    (a1-14 (-> obj root trans))
                    )
                (rigid-body-method-23 (-> v1-46 state) a1-14)
                )
              (let* ((v1-51 (-> obj node-list data 0 bone transform))
                     (a3-1 (-> s4-0 state matrix))
                     (a0-20 (-> a3-1 quad 0))
                     (a1-15 (-> a3-1 quad 1))
                     (a2-5 (-> a3-1 quad 2))
                     (a3-2 (-> a3-1 trans quad))
                     )
                (set! (-> v1-51 quad 0) a0-20)
                (set! (-> v1-51 quad 1) a1-15)
                (set! (-> v1-51 quad 2) a2-5)
                (set! (-> v1-51 trans quad) a3-2)
                )
              (set! (-> obj node-list data 0 bone transform trans quad) (-> obj root trans quad))
              (race-control-method-11 s5-0 (* f30-0 f28-0))
              )
            )
          )
        )
      (vehicle-method-119 obj)
      (vehicle-method-120 obj)
      (update-transforms (-> obj root))
      (let ((a1-17 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a1-17 options) (overlaps-others-options))
        (set! (-> a1-17 collide-with-filter) (collide-spec civilian enemy obstacle))
        (set! (-> a1-17 tlist) *touching-list*)
        (find-overlapping-shapes (-> obj root) a1-17)
        )
      0
      (none)
      )
    )
  )

(defmethod physics-post vehicle-racer ((obj vehicle-racer))
  (local-vars (v1-35 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let ((s5-0 (-> obj race)))
        (let ((s4-0 (new 'stack-no-clear 'inline-array 'matrix 9)))
          (set! (-> s4-0 0 quad 0) (-> obj rbody state position quad))
          (set! (-> s4-0 0 vector 1 quad) (-> obj rbody state lin-velocity quad))
          (set! (-> s4-0 3 vector 1 y) 0.0)
          (set! (-> s4-0 1 vector 1 quad) (-> obj rbody state matrix quad 0))
          (set! (-> s4-0 1 vector 1 y) 0.0)
          (vector-normalize! (-> s4-0 1 vector 1) 1.0)
          (set! (-> s4-0 1 vector 2 quad) (-> obj rbody state matrix vector 2 quad))
          (set! (-> s4-0 3 vector 0 x)
                (* (-> obj rbody state ang-velocity y) (vector-length (-> obj rbody state lin-velocity)))
                )
          (set! (-> s4-0 3 vector 1 x) (-> pp clock seconds-per-frame))
          (race-control-method-12 s5-0 (the-as vector (-> s4-0 0)))
          (set! (-> s4-0 3 vector 0 y) (vector-length (-> s4-0 0 vector 1)))
          (set! (-> s4-0 3 vector 0 z) (vector-length (-> s5-0 lin-velocity)))
          (set! (-> s4-0 3 vector 0 w)
                (* (-> s4-0 3 vector 0 z) (fmax (-> s5-0 racer-state speed-factor) (-> obj shortcut-speed-factor)))
                )
          (if (logtest? (rigid-body-object-flag in-air turbo-boost) (-> obj flags))
              (set! (-> s4-0 3 vector 0 w) (* 2.0 (-> s4-0 3 vector 0 w)))
              )
          (let ((v1-21 (-> s5-0 path-sample)))
            (set! (-> s4-0 2 vector 0 x) (* 0.007874016 (the float (-> v1-21 stick-x))))
            (set! (-> s4-0 2 vector 0 w) (* 0.007874016 (the float (-> v1-21 stick-y))))
            (set! (-> s4-0 2 vector 0 y) (* 0.003921569 (the float (-> v1-21 throttle))))
            (set! (-> s4-0 2 vector 0 z) (if (logtest? (-> v1-21 flags) 1)
                                             1.0
                                             0.0
                                             )
                  )
            )
          (let ((f0-19 (+ (-> s5-0 path-t) (* 1.875 (/ 1.0 (-> s4-0 3 vector 0 z)) (-> s4-0 3 vector 0 y)))))
            (race-path-method-11 (-> s5-0 path) (the-as race-path-sample (-> s4-0 2 vector 1)) (-> s4-0 2 trans) f0-19)
            )
          (vector-! (-> s4-0 0 trans) (the-as vector (-> s5-0 path-sample)) (the-as vector (-> s4-0 0)))
          (let* ((f0-20 (-> s4-0 3 vector 1 y))
                 (f1-13 1.0)
                 (f2-4 40960.0)
                 (f1-14 (/ f1-13 (* f2-4 f2-4)))
                 )
            (.lvf vf1 (&-> (-> s4-0 0 trans) quad))
            (.add.w.vf vf2 vf0 vf0 :mask #b1)
            (.mul.vf vf1 vf1 vf1)
            (.mul.x.vf acc vf2 vf1 :mask #b1)
            (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
            (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
            (.mov v1-35 vf1)
            (set! (-> s4-0 3 vector 1 y) (+ f0-20 (* f1-14 v1-35)))
            )
          (let ((f30-0 (-> s4-0 3 vector 1 y))
                (f0-22 1.0)
                (f1-16 40960.0)
                )
            (set! (-> s4-0 3 vector 1 y)
                  (+ f30-0
                     (* (/ f0-22 (* f1-16 f1-16)) (vector-vector-distance-squared (-> s5-0 lin-velocity) (-> s4-0 0 vector 1)))
                     )
                  )
            )
          (set! (-> obj path-deviation) (-> s4-0 3 vector 1 y))
          (let ((a1-6 (-> s4-0 0 vector 2)))
            (let ((v1-39 (-> s4-0 2 trans)))
              (let ((a0-25 (-> s4-0 0 trans)))
                (let ((a2-2 1.0))
                  (.mov vf7 a2-2)
                  )
                (.lvf vf5 (&-> a0-25 quad))
                )
              (.lvf vf4 (&-> v1-39 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-6 quad) vf6)
            )
          (vector-! (the-as vector (-> s4-0 1)) (-> s4-0 0 vector 2) (-> s4-0 0 vector 1))
          (vector-float*! (-> s4-0 1 trans) (the-as vector (-> s4-0 1)) 1.5)
          (let ((f1-22 (* 0.00036621094 (- (-> s4-0 3 vector 0 w) (-> s4-0 3 vector 0 y)) (-> s4-0 3 vector 1 x))))
            (set! (-> obj ai-controls throttle) (fmax 0.0 (fmin 1.0 (+ (-> obj ai-controls throttle) f1-22))))
            )
          (set! (-> obj ai-controls brake)
                (fmax 0.0 (fmin 1.0 (* 0.000048828126 (+ (- -4096.0 (-> s4-0 3 vector 0 w)) (-> s4-0 3 vector 0 y)))))
                )
          (+! (-> obj ai-controls brake) (* (- (-> obj ai-controls brake)) (fmin 1.0 (* 8.0 (-> s4-0 3 vector 1 x)))))
          (set! (-> obj ai-controls steering)
                (fmax -1.0 (fmin 1.0 (* 0.000000000048894434
                                        (+ 40960.0 (-> s4-0 3 vector 0 y))
                                        (vector-dot (-> s4-0 1 vector 1) (-> s4-0 1 trans))
                                        )
                                 )
                      )
                )
          (set! (-> s4-0 3 vector 1 y) (fmin 1.0 (-> s4-0 3 vector 1 y)))
          (set! (-> s4-0 2 vector 0 x) (+ (* (-> s4-0 2 vector 0 x) (- 1.0 (-> s4-0 3 vector 1 y)))
                                          (* (-> obj ai-controls steering) (-> s4-0 3 vector 1 y))
                                          )
                )
          (set! (-> s4-0 2 vector 0 y) (-> obj ai-controls throttle))
          (set! (-> s4-0 2 vector 0 z) (-> obj ai-controls brake))
          (vehicle-method-95 obj (the-as vector (-> s4-0 2)))
          )
        (when (logtest? (-> s5-0 path-sample flags) 2)
          (start-jump obj)
          0
          )
        )
      (vehicle-method-121 obj)
      (when (< (-> obj rbody state position y) -409600.0)
        (format
          #t
          "vehicle-racer::physics-post:  pid ~d fell to death from path-id ~d~%"
          (-> obj pid)
          (-> obj race path record-id)
          )
        (go (method-of-object obj explode))
        )
      0
      (none)
      )
    )
  )

(defmethod vehicle-racer-method-154 vehicle-racer ((obj vehicle-racer))
  (cond
    ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
     (if (and (logtest? (-> obj flags) (rigid-body-object-flag on-ground))
              (not (logtest? (rigid-body-object-flag turbo-boost) (-> obj flags)))
              (let ((f0-0 368640.0))
                (or (< (* f0-0 f0-0) (-> obj player-dist2))
                    (let ((f0-3 102400.0))
                      (and (< (* f0-3 f0-3) (-> obj player-dist2))
                           (not (logtest? (-> obj draw status) (draw-control-status on-screen)))
                           )
                      )
                    )
                )
              )
         (rigid-body-object-method-39 obj)
         )
     )
    (else
      (let ((f0-6 (-> obj player-dist2))
            (f1-2 348160.0)
            )
        (if (and (< f0-6 (* f1-2 f1-2)) (let ((f0-7 (-> obj player-dist2))
                                              (f1-5 81920.0)
                                              )
                                          (or (< f0-7 (* f1-5 f1-5))
                                              (logtest? (-> obj draw status) (draw-control-status on-screen))
                                              (logtest? (rigid-body-object-flag turbo-boost) (-> obj flags))
                                              )
                                          )
                 )
            (rigid-body-object-method-38 obj)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-racer-method-152 vehicle-racer ((obj vehicle-racer))
  (let ((s5-0 (new 'stack-no-clear 'matrix3)))
    (set! (-> s5-0 vector 0 quad) (-> obj rbody state position quad))
    (set! (-> obj camera-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (camera-pos)))
    (set! (-> obj player-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (target-pos 0)))
    )
  (if (>= (- (current-time) (-> obj shortcut-time)) (seconds 5))
      (set! (-> obj shortcut-speed-factor) 0.0)
      )
  (vehicle-racer-method-154 obj)
  (if (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
      (physics-post obj)
      (vehicle-racer-method-151 obj)
      )
  0
  (none)
  )

(defmethod vehicle-racer-method-155 vehicle-racer ((obj vehicle-racer))
  (let ((s5-0 (new 'stack-no-clear 'matrix3)))
    (set! (-> s5-0 vector 0 quad) (-> obj rbody state position quad))
    (set! (-> obj camera-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (camera-pos)))
    (set! (-> obj player-dist2) (vector-vector-distance-squared (the-as vector (-> s5-0 vector)) (target-pos 0)))
    )
  (set! (-> obj shortcut-speed-factor) 0.0)
  (vehicle-racer-method-154 obj)
  (if (and (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
           (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
           )
      (rigid-body-object-method-38 obj)
      )
  (if (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
      (physics-post obj)
      (vehicle-racer-method-151 obj)
      )
  0
  (none)
  )

(defmethod vehicle-method-124 vehicle-racer ((obj vehicle-racer))
  (cond
    ((and (logtest? (rigid-body-object-flag player-grabbed) (-> obj flags)) (-> obj race path))
     (vehicle-racer-method-155 obj)
     )
    (else
      (vehicle-method-94 obj)
      (vehicle-method-121 obj)
      )
    )
  (vehicle-method-97 obj)
  0
  (none)
  )

(defstate waiting-race (vehicle-racer)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-racer)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logior! (-> self flags) (rigid-body-object-flag ignition))
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    (set! (-> self damage-factor) 0.0)
    (vehicle-method-83 self)
    (vehicle-method-143 self)
    (let ((v1-9 (find-prim-by-id-logtest (-> self root) (the-as uint 32))))
      (when v1-9
        (set! (-> v1-9 prim-core collide-with) (collide-spec))
        (set! (-> v1-9 prim-core collide-as) (collide-spec))
        0
        )
      )
    (none)
    )
  :exit (behavior ()
    (set! (-> self hit-points) 1.0)
    (logclear! (-> self flags) (rigid-body-object-flag waiting-for-player))
    (let ((v1-4 (find-prim-by-id-logtest (-> self root) (the-as uint 32))))
      (when v1-4
        (set! (-> v1-4 prim-core collide-with) (collide-spec
                                                 backgnd
                                                 crate
                                                 civilian
                                                 enemy
                                                 obstacle
                                                 vehicle-sphere
                                                 hit-by-player-list
                                                 hit-by-others-list
                                                 collectable
                                                 pusher
                                                 )
              )
        (set! (-> v1-4 prim-core collide-as) (collide-spec vehicle-sphere))
        )
      )
    (none)
    )
  :trans (the-as (function none :behavior vehicle-racer) #f)
  :code (the-as (function none :behavior vehicle-racer) sleep-code)
  :post (behavior ()
    (when (logtest? (-> self flags) (rigid-body-object-flag waiting-for-player))
      (set! (-> self camera-dist2) (vector-vector-distance-squared (-> self root trans) (camera-pos)))
      (set! (-> self player-dist2) (vector-vector-distance-squared (-> self root trans) (target-pos 0)))
      (check-player-get-on self)
      )
    (vector-reset! (-> self target-acceleration))
    (vehicle-method-120 self)
    (update-transforms (-> self root))
    (vehicle-method-119 self)
    (rigid-body-object-method-39 self)
    (none)
    )
  )

(defstate waiting-for-start (vehicle-racer)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-racer)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self damage-factor) (-> self info damage-factor))
    (vehicle-method-143 self)
    (logior! (-> self flags) (rigid-body-object-flag ignition))
    (none)
    )
  :code (the-as (function none :behavior vehicle-racer) sleep-code)
  :post (behavior ()
    (vector-reset! (-> self target-acceleration))
    (logclear! (-> self flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    (let ((v1-4 (-> self rbody state)))
      (set! (-> v1-4 force quad) (the-as uint128 0))
      (set! (-> v1-4 torque quad) (the-as uint128 0))
      )
    0
    (clear-momentum! (-> self rbody state))
    (vehicle-method-120 self)
    (vehicle-method-119 self)
    (none)
    )
  )

(defstate racing (vehicle-racer)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-racer)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logior! (-> self flags) (rigid-body-object-flag riding ignition))
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (rigid-body-object-flag waiting-for-player))
    (let ((v1-3 (find-prim-by-id-logtest (-> self root) (the-as uint 32))))
      (when v1-3
        (set! (-> v1-3 prim-core collide-with) (collide-spec
                                                 backgnd
                                                 crate
                                                 civilian
                                                 enemy
                                                 obstacle
                                                 vehicle-sphere
                                                 hit-by-player-list
                                                 hit-by-others-list
                                                 collectable
                                                 pusher
                                                 )
              )
        (set! (-> v1-3 prim-core collide-as) (collide-spec vehicle-sphere))
        )
      )
    (none)
    )
  :trans (the-as (function none :behavior vehicle-racer) #f)
  :code (the-as (function none :behavior vehicle-racer) sleep-code)
  :post (behavior ()
    (vehicle-racer-method-152 self)
    (none)
    )
  )

(defstate race-finished (vehicle-racer)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-racer)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self flags) (the-as
                            rigid-body-object-flag
                            (logior (rigid-body-object-flag persistent riding nav-spheres) (-> self flags))
                            )
          )
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    (none)
    )
  :trans (the-as (function none :behavior vehicle-racer) #f)
  :code (the-as (function none :behavior vehicle-racer) sleep-code)
  :post (behavior ()
    (vehicle-racer-method-155 self)
    (none)
    )
  )
