;;-*-Lisp-*-
(in-package goal)

;; name: gun-buoy.gc
;; name in dgo: gun-buoy
;; dgos: ATO, NESTT, NES, LPROTECT

(defenum gun-buoy-flags
  :bitfield #t
  :type uint16
  (gubflags-0)
  (gubflags-1)
  (gubflags-2)
  (gubflags-3)
  (gubflags-4)
  (gubflags-5)
  (gubflags-6)
  (gubflags-7)
  )

;; DECOMP BEGINS

(defskelgroup skel-gun-buoy gun-buoy gun-buoy-lod0-jg gun-buoy-idle-ja
              ((gun-buoy-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.3 -0.4 3)
              )

(deftype gun-buoy-shot (guard-shot)
  ()
  :heap-base #x170
  :method-count-assert 40
  :size-assert         #x1f0
  :flag-assert         #x28017001f0
  )


(defmethod play-impact-sound gun-buoy-shot ((obj gun-buoy-shot) (arg0 projectile-options))
  (if (zero? arg0)
      (sound-play "buoy-shot")
      )
  0
  (none)
  )

(defun gun-buoy-shot-move ((arg0 gun-buoy-shot))
  (local-vars (at-0 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> arg0 root)))
      (let ((s3-0 (new 'stack-no-clear 'collide-query))
            (s2-0 (-> s5-0 root-prim))
            (s4-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> s4-0 quad) (-> s5-0 transv quad))
        (let* ((f30-0 (vector-length s4-0))
               (s1-0 *target*)
               (a0-2 (if (type? s1-0 process-focusable)
                         s1-0
                         )
                     )
               )
          (when a0-2
            (let ((s1-1 (new 'stack-no-clear 'vector)))
              (set! (-> s1-1 quad) (-> (get-trans a0-2 0) quad))
              (+! (-> s1-1 y) 8192.0)
              (vector-! s4-0 s1-1 (-> s5-0 trans))
              )
            (vector-normalize! s4-0 f30-0)
            )
          )
        (set! (-> s3-0 start-pos quad) (-> s5-0 trans quad))
        (let ((v1-12 (-> s3-0 move-dist)))
          (.lvf vf1 (&-> s4-0 quad))
          (let ((f0-2 (seconds-per-frame)))
            (.mov at-0 f0-2)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-12 quad) vf1)
          )
        (let ((v1-13 s3-0))
          (set! (-> v1-13 radius) (-> s2-0 prim-core world-sphere w))
          (set! (-> v1-13 collide-with) (-> s2-0 prim-core collide-with))
          (set! (-> v1-13 ignore-process0) arg0)
          (set! (-> v1-13 ignore-process1) (ppointer->process (-> arg0 parent)))
          (set! (-> v1-13 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-13 action-mask) (collide-action solid))
          )
        (set! (-> *actor-hash* debug-draw) #t)
        (fill-using-line-sphere *collide-cache* s3-0)
        (set! (-> *actor-hash* debug-draw) #f)
        (integrate-and-collide! s5-0 s4-0)
        )
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (vector-! s4-1 (-> arg0 tail-pos) (-> s5-0 trans))
        (let ((f0-4 (vector-length s4-1)))
          (when (< 36864.0 f0-4)
            (vector-normalize! s4-1 36864.0)
            (vector+! (-> arg0 tail-pos) (-> s5-0 trans) s4-1)
            )
          )
        )
      (when (logtest? (-> s5-0 status) (collide-status touch-surface))
        (if (logtest? (-> arg0 root status) (collide-status touch-actor))
            (set! (-> arg0 hit-actor?) #t)
            )
        (go (method-of-object arg0 impact))
        )
      )
    0
    (none)
    )
  )

(defmethod init-proj-collision! gun-buoy-shot ((obj gun-buoy-shot))
  "Init the [[projectile]]'s [[collide-shape]]"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction)
          (the-as (function control-info collide-query vector vector collide-status) cshape-reaction-just-move)
          )
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate enemy-yellow-shot))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec projectile))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 2457.6)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid deadly))
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 819.2)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action deadly))
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 2457.6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-18 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-18 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-18 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 1))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> obj root) s5-0)
    )
  (set! (-> obj root pat-ignore-mask)
        (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1)
        )
  0
  (none)
  )

(defmethod init-proj-settings! gun-buoy-shot ((obj gun-buoy-shot))
  "Init relevant settings for the [[projectile]] such as gravity, speed, timeout, etc"
  (set! (-> obj hit-actor?) #f)
  (set! (-> obj tail-pos quad) (-> obj root trans quad))
  (set! (-> obj attack-mode) 'explode)
  (set! (-> obj max-speed) 737280.0)
  (set! (-> obj move) gun-buoy-shot-move)
  (set! (-> obj timeout) (seconds 2.78))
  (set! (-> obj damage) 1024.0)
  (logior! (-> obj options) (projectile-options deal-damage ignore-impact))
  (set-gravity-length (-> obj root dynam) 573440.0)
  (none)
  )

(define *gun-buoy-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #f
    :use-victory #f
    :use-jump-blocked #f
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #f
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'array idle-control-frame 4
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x2 :param0 #x1 :param1 #x1)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      )
    :idle-anim 2
    :notice-anim 3
    :hostile-anim 2
    :hit-anim 2
    :knocked-anim -1
    :knocked-land-anim -1
    :die-anim 2
    :die-falling-anim 2
    :victory-anim 2
    :jump-wind-up-anim -1
    :jump-in-air-anim -1
    :jump-land-anim -1
    :neck-joint -1
    :notice-distance (meters 1000)
    :notice-distance-delta (meters 10)
    :proximity-notice-distance (meters 30)
    :default-hit-points 12
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
    :movement-gravity (meters -100)
    :friction 0.8
    :attack-shove-back (meters 3)
    :attack-shove-up (meters 2)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :jump-height-min (meters 3)
    :jump-height-factor 0.5
    :knocked-seek-ry-clamp 2730.6667
    :knocked-soft-vxz-lo 72089.6
    :knocked-soft-vxz-hi 108134.4
    :knocked-soft-vy-lo 81920.0
    :knocked-soft-vy-hi 122880.0
    :knocked-medium-vxz-lo 147456.0
    :knocked-medium-vxz-hi 196608.0
    :knocked-medium-vy-lo 135168.0
    :knocked-medium-vy-hi 151552.0
    :knocked-hard-vxz-lo 78643.2
    :knocked-hard-vxz-hi 117964.8
    :knocked-hard-vy-lo 183500.8
    :knocked-hard-vy-hi 209715.2
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 40960.0
    :knocked-yellow-vxz-hi 49152.0
    :knocked-yellow-vy-lo 57344.0
    :knocked-yellow-vy-hi 81920.0
    :knocked-red-vxz-lo 24576.0
    :knocked-red-vxz-hi 196608.0
    :knocked-red-vy-lo 94208.0
    :knocked-red-vy-hi 151552.0
    :knocked-blue-vxz-lo 40960.0
    :knocked-blue-vxz-hi 49152.0
    :knocked-blue-vy-lo 24576.0
    :knocked-blue-vy-hi 81920.0
    :shadow-size (meters 1)
    :shadow-max-y (meters 1)
    :shadow-min-y (meters -1)
    :shadow-locus-dist (meters 150)
    :gem-joint -1
    :gem-offset (new 'static 'sphere :r 163840.0)
    :callback-info #f
    :use-momentum #f
    :use-frustration #f
    :use-stop-chase #f
    :use-circling #f
    :use-pacing #f
    :walk-anim 2
    :turn-anim 2
    :run-anim 2
    :taunt-anim 2
    :run-travel-speed (meters 28)
    :run-acceleration (meters 4)
    :run-turning-acceleration (meters 16.800001)
    :walk-travel-speed (meters 6)
    :walk-acceleration (meters 10)
    :walk-turning-acceleration (meters 20)
    :maximum-rotation-rate (degrees 2160)
    :notice-nav-radius (meters 4)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

(set! (-> *gun-buoy-nav-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

(deftype gun-buoy (nav-enemy)
  ((gun-elev-jmod      joint-mod              :offset-assert 604)
   (start-pos          vector         :inline :offset-assert 608)
   (aim-dir            vector         :inline :offset-assert 624)
   (banking-quat       quaternion     :inline :offset        656)
   (offset-from-player vector         :inline :offset-assert 672)
   (offset-y-angular   float                  :offset-assert 688)
   (elev-angle         float                  :offset-assert 692)
   (y-final            float                  :offset-assert 696)
   (y-offset           float                  :offset-assert 700)
   (y-bob              float                  :offset-assert 704)
   (y-speed            float                  :offset-assert 708)
   (warning-interval   time-frame             :offset-assert 712)
   (warning-timer      time-frame             :offset-assert 720)
   (splash-timer       time-frame             :offset-assert 728)
   (stare-down-timer   time-frame             :offset-assert 736)
   (warning-id         sound-id               :offset-assert 744)
   (voice-id           sound-id               :offset-assert 748)
   (flags              gun-buoy-flags         :offset-assert 752)
   )
  :heap-base #x280
  :method-count-assert 184
  :size-assert         #x2f2
  :flag-assert         #xb8028002f2
  (:methods
    (attack () _type_ :state 178)
    (exit-ambush () _type_ :state 179)
    (warning () _type_ :state 180)
    (stare-down () _type_ :state 181)
    (open-guns () _type_ :state 182)
    (gun-buoy-method-183 (_type_ process-focusable) none 183)
    )
  )


(define *gun-buoy-warning-speech* (new 'static 'boxed-array :type string "cityv047" "cityv048"))

(define *gun-buoy-warning-index* 0)

(define *gun-buoy-victory-speech* (new 'static 'boxed-array :type string "cityv050" "cityv051"))

(define *gun-buoy-victory-index* 0)

(defbehavior gun-buoy-chase-post gun-buoy ()
  (let ((gp-0 (handle->process (-> self focus handle))))
    (when gp-0
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (set! (-> s4-0 quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
        (let ((v1-8 (-> self offset-from-player))
              (a0-4 (-> self focus-pos))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> a0-4 quad) (-> s4-0 quad))
          (set! (-> s4-0 y) (fmax (-> s4-0 y) (-> (the-as process-focusable gp-0) water height)))
          (vector+! s5-0 s4-0 v1-8)
          (cond
            ((logtest? (-> self flags) (gun-buoy-flags gubflags-0))
             (cloest-point-on-mesh (-> self nav) s5-0 s5-0 (the-as nav-poly #f))
             (let ((v1-14 (-> self root trans)))
               (vector-length (vector-! (new 'stack-no-clear 'vector) v1-14 s5-0))
               )
             (let ((v1-17 (-> self nav state)))
               (logclear! (-> v1-17 flags) (nav-state-flag directional-mode))
               (logior! (-> v1-17 flags) (nav-state-flag target-poly-dirty))
               (set! (-> v1-17 target-post quad) (-> s5-0 quad))
               )
             0
             )
            (else
              (let ((v1-21 (-> self nav state))
                    (a0-16 (-> self root trans))
                    )
                (logclear! (-> v1-21 flags) (nav-state-flag directional-mode))
                (logior! (-> v1-21 flags) (nav-state-flag target-poly-dirty))
                (set! (-> v1-21 target-post quad) (-> a0-16 quad))
                )
              0
              )
            )
          )
        )
      0
      (let ((s3-0 (new 'stack-no-clear 'vector))
            (s5-1 (-> self aim-dir))
            )
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          (set! (-> s3-0 quad) (-> self root trans quad))
          (+! (-> s3-0 y) 4096.0)
          (vector-! s4-1 (get-trans (the-as process-focusable gp-0) 3) s3-0)
          (vector-normalize! s4-1 1.0)
          (vector-lerp! s5-1 s5-1 s4-1 0.99)
          )
        (when (< 0.95 (fabs (vector-dot s5-1 *y-vector*)))
          (set! (-> s5-1 y) (* 0.95 (-> s5-1 y)))
          (vector-normalize! s5-1 1.0)
          )
        )
      )
    )
  (let ((s5-2 (new 'stack-no-clear 'vector)))
    (set! (-> s5-2 quad) (-> self root trans quad))
    (let ((gp-1 (new 'stack 'water-info)))
      (water-info-init! (-> self root) gp-1 (collide-action solid semi-solid))
      (get-height *ocean* s5-2 #t)
      (seek! (-> self y-final) (+ -3276.8 (-> gp-1 trans y)) (* 3276.8 (seconds-per-frame)))
      )
    )
  0
  (set! (-> self root trans y) (+ (-> self y-final) (-> self y-offset) (-> self y-bob)))
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defstate dormant-aware (gun-buoy)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('kill-player)
       (logior! (-> self flags) (gun-buoy-flags gubflags-2))
       (go-virtual ambush)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self root trans quad) (-> self start-pos quad))
    (logclear! (-> self flags) (gun-buoy-flags gubflags-1))
    (logclear! (-> self flags) (gun-buoy-flags gubflags-2))
    (none)
    )
  :trans (behavior ()
    (when (and (>= (- (current-time) (-> self state-time)) (-> self state-timeout))
               (< 2 (the-as int (-> self focus aware)))
               (-> *setting-control* user-current gun-buoy)
               )
      (if (logtest? (-> self fact enemy-options) (enemy-option user0))
          (logior! (-> self flags) (gun-buoy-flags gubflags-2))
          )
      (go-ambush self)
      )
    (none)
    )
  )

(defstate ambush (gun-buoy)
  :virtual #t
  :enter (behavior ()
    (local-vars (sv-80 vector))
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-0 enemy-flags))))
      )
    0
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (nav-enemy-method-166 self)
    (logior! (-> self flags) (gun-buoy-flags gubflags-0))
    (logior! (-> self water flags) (water-flags touch-water))
    (let* ((gp-0 *target*)
           (s3-0 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           )
      (cond
        (s3-0
          (let ((s4-0 (new 'stack-no-clear 'vector)))
            (set! (-> s4-0 quad) (-> (get-trans s3-0 1) quad))
            (let ((gp-2 (focus-test? s3-0 board))
                  (s5-0 (-> self offset-from-player))
                  )
              (set! (-> s4-0 y) (fmax (-> s4-0 y) (-> s3-0 water height)))
              (let ((s2-0 vector-xz-normalize-copy!)
                    (s1-0 s5-0)
                    (s0-0 vector-z-quaternion!)
                    )
                (set! sv-80 (new 'stack-no-clear 'vector))
                (let ((a1-7 (get-quat s3-0 2)))
                  (s2-0 s1-0 (s0-0 sv-80 a1-7) 81920.0)
                  )
                )
              (set! (-> s5-0 y) -819.2)
              (let ((s3-2 (vector+! (new 'stack-no-clear 'vector) s4-0 s5-0)))
                (cloest-point-on-mesh (-> self nav) s3-2 s3-2 (the-as nav-poly #f))
                (set! (-> self root trans quad) (-> s3-2 quad))
                )
              (set! (-> self y-final) (-> self root trans y))
              (set! (-> self y-offset) (if gp-2
                                           -36864.0
                                           -81920.0
                                           )
                    )
              (set! (-> self y-bob) 0.0)
              (set! (-> self y-speed) (if gp-2
                                          196608.0
                                          65536.0
                                          )
                    )
              (set! (-> self offset-y-angular) 0.0)
              (let ((a0-28 (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)))
                (set! (-> self nav state heading quad) (-> a0-28 quad))
                )
              )
            )
          0
          (vector-reset! (-> self root transv))
          )
        (else
          (go-virtual dormant-aware)
          )
        )
      )
    (none)
    )
  :trans (behavior ()
    (when (< (fabs (-> self y-offset)) 409.6)
      (set! (-> self y-offset) 0.0)
      (when (not (logtest? (-> self flags) (gun-buoy-flags gubflags-2)))
        (set! *gun-buoy-warning-index* (rand-vu-int-range 0 (+ (-> *gun-buoy-warning-speech* length) -1)))
        (let ((t0-0 (-> *gun-buoy-warning-speech* *gun-buoy-warning-index*)))
          (set! (-> self voice-id) (add-process *gui-control* self (gui-channel guard) (gui-action play) t0-0 -99.0 0))
          )
        )
      (go-virtual open-guns)
      )
    (none)
    )
  :code (the-as (function none :behavior gun-buoy) sleep-code)
  :post (behavior ()
    (set! (-> self y-offset) (seek-ease
                               (-> self y-offset)
                               0.0
                               (* (-> self y-speed) (seconds-per-frame))
                               12288.0
                               (* 40.96 (seconds-per-frame))
                               )
          )
    (let ((f30-0 (- 1.0 (fabs (* 0.000012207031 (-> self y-offset))))))
      (let ((f0-7 (* f30-0 f30-0)))
        (set-vector! (-> self root scale) f30-0 f30-0 f30-0 1.0)
        (let ((t9-1 vector-lerp!)
              (a0-2 (-> self draw color-mult))
              (a1-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-1 x) 0.3)
          (set! (-> a1-1 y) 0.4)
          (set! (-> a1-1 z) 0.0)
          (set! (-> a1-1 w) 1.0)
          (t9-1 a0-2 a1-1 *identity-vector* f0-7)
          )
        )
      (update-vol! (-> self sound) f30-0)
      )
    (gun-buoy-chase-post)
    (none)
    )
  )

(defstate exit-ambush (gun-buoy)
  :virtual #t
  :enter (behavior ()
    (logclear! (-> self flags) (gun-buoy-flags gubflags-0))
    (none)
    )
  :exit (behavior ()
    (nav-enemy-method-167 self)
    (none)
    )
  :trans (behavior ()
    (if (< (-> self y-offset) -81510.4)
        (go-virtual dormant-aware)
        )
    (none)
    )
  :code (the-as (function none :behavior gun-buoy) sleep-code)
  :post (behavior ()
    (seek! (-> self y-offset) -81920.0 (* 49152.0 (seconds-per-frame)))
    (let ((f30-0 (- 1.0 (fabs (* 0.000012207031 (-> self y-offset))))))
      (let ((f0-5 (* f30-0 f30-0)))
        (set-vector! (-> self root scale) f30-0 f30-0 f30-0 1.0)
        (let ((t9-1 vector-lerp!)
              (a0-2 (-> self draw color-mult))
              (a1-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-1 x) 0.3)
          (set! (-> a1-1 y) 0.4)
          (set! (-> a1-1 z) 0.0)
          (set! (-> a1-1 w) 1.0)
          (t9-1 a0-2 a1-1 *identity-vector* f0-5)
          )
        )
      (update-vol! (-> self sound) f30-0)
      )
    (gun-buoy-chase-post)
    (none)
    )
  )

(defstate open-guns (gun-buoy)
  :virtual #t
  :trans (behavior ()
    (if (not (-> *setting-control* user-current gun-buoy))
        (go-virtual exit-ambush)
        )
    (if (and *target* (< 102400.0 (vector-length (get-transv *target*))))
        (go-virtual attack)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2)))
      (new 'stack-no-clear 'vector)
      (let* ((gp-0 (handle->process (-> self focus handle)))
             (a0-6 (if (type? gp-0 process-focusable)
                       gp-0
                       )
                   )
             )
        (if (and a0-6 (focus-test? (the-as process-focusable a0-6) board))
            (set! f30-0 (* 2.0 f30-0))
            )
        )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info notice-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info notice-anim))) frames num-frames)
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (set! (-> self gun-elev-jmod mode) (the-as joint-mod-mode #t))
    (if (logtest? (-> self flags) (gun-buoy-flags gubflags-2))
        (go-virtual attack)
        )
    (case (-> self focus aware)
      (((enemy-aware enemy-aware-3))
       (go-hostile self)
       )
      (((enemy-aware enemy-aware-2))
       (go-virtual warning)
       )
      (else
        (go-virtual exit-ambush)
        )
      )
    (none)
    )
  :post gun-buoy-chase-post
  )

(defstate stare-down (gun-buoy)
  :virtual #t
  :enter (behavior ()
    (set! (-> self stare-down-timer) (current-time))
    (none)
    )
  :trans (behavior ()
    (let ((v1-0 (-> self focus aware)))
      (cond
        ((< 2 (the-as int v1-0))
         (go-virtual open-guns)
         )
        ((or (< (the-as int v1-0) 2)
             (not (-> *setting-control* user-current gun-buoy))
             (>= (- (current-time) (-> self stare-down-timer)) (seconds 6))
             )
         (go-virtual exit-ambush)
         )
        )
      )
    (none)
    )
  :code (behavior ()
    (sound-play "buoy-guns-in")
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2)))
      (ja-no-eval :group! gun-buoy-close-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim gun-buoy-close-ja) frames num-frames) -1)) f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (set! (-> self gun-elev-jmod mode) (the-as joint-mod-mode #f))
    (sleep-code)
    (none)
    )
  :post gun-buoy-chase-post
  )

(defstate warning (gun-buoy)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('kill-player)
       (logior! (-> self flags) (gun-buoy-flags gubflags-2))
       (go-virtual attack)
       )
      )
    )
  :enter (behavior ()
    (cond
      ((logtest? (-> self flags) (gun-buoy-flags gubflags-1))
       (set! (-> self warning-interval) (seconds 0.1))
       )
      (else
        (let* ((gp-0 (handle->process (-> self focus handle)))
               (v1-6 (if (type? gp-0 process-focusable)
                         gp-0
                         )
                     )
               )
          (cond
            ((focus-test? (the-as process-focusable v1-6) board)
             (set! (-> self warning-interval) (seconds 0.5))
             )
            (else
              (set! (-> self voice-id)
                    (add-process *gui-control* self (gui-channel guard) (gui-action play) "cityv052" -99.0 0)
                    )
              (set! (-> self warning-interval) (seconds 4))
              )
            )
          )
        )
      )
    (set! (-> self warning-timer) (current-time))
    (set! (-> self warning-id) (sound-play "buoy-alarm"))
    (none)
    )
  :exit (behavior ()
    (when (nonzero? (-> self warning-id))
      (sound-stop (-> self warning-id))
      (set! (-> self warning-id) (the-as sound-id -1))
      )
    (none)
    )
  :trans (behavior ()
    (let ((gp-0 (-> self focus aware)))
      (when (>= (- (current-time) (-> self warning-timer)) (-> self warning-interval))
        (cond
          ((>= (the-as int gp-0) 3)
           (logior! (-> self flags) (gun-buoy-flags gubflags-1))
           (go-hostile self)
           )
          (else
            (go-virtual stare-down)
            )
          )
        )
      (cond
        ((= gp-0 (enemy-aware enemy-aware-2))
         (go-virtual stare-down)
         )
        ((or (< (the-as int gp-0) 2) (not (-> *setting-control* user-current gun-buoy)))
         (go-virtual exit-ambush)
         )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior gun-buoy) sleep-code)
  :post (behavior ()
    (sound-play "buoy-alarm" :id (-> self warning-id))
    (when *sound-player-enable*
      (let ((v1-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-3 command) (sound-command set-param))
        (set! (-> v1-3 id) (-> self voice-id))
        (set! (-> v1-3 params volume) 1024)
        (set! (-> v1-3 params mask) (the-as uint 1))
        (-> v1-3 id)
        )
      )
    (gun-buoy-chase-post)
    (none)
    )
  )

(defstate hostile (gun-buoy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-4 enemy-flags)))
          (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-4 enemy-flags))))
          )
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-4 enemy-flags))))
      (set! (-> v1-4 nav callback-info) (-> v1-4 enemy-info callback-info))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-7 enemy-flags))))
      )
    0
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (-> self reaction-time))
      (let ((v1-3 (-> self focus aware)))
        (cond
          ((= v1-3 (enemy-aware enemy-aware-2))
           (go-virtual warning)
           )
          ((or (< (the-as int v1-3) 2) (not (-> *setting-control* user-current gun-buoy)))
           (go-virtual exit-ambush)
           )
          )
        )
      (let ((gp-0 *target*))
        (if (if (type? gp-0 process-focusable)
                gp-0
                )
            (go-virtual attack)
            )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior gun-buoy) sleep-code)
  :post gun-buoy-chase-post
  )

(defstate attack (gun-buoy)
  :virtual #t
  :trans (behavior ()
    (let ((v1-0 (-> self focus aware)))
      (when (not (logtest? (-> self flags) (gun-buoy-flags gubflags-2)))
        (if (>= 2 (the-as int v1-0))
            (go-virtual hostile)
            )
        )
      )
    (let* ((s5-0 (handle->process (-> self focus handle)))
           (gp-0 (if (type? s5-0 process-focusable)
                     s5-0
                     )
                 )
           )
      (if (and gp-0 (focus-test? (the-as process-focusable gp-0) dead))
          (go-virtual victory)
          )
      (if (not (and gp-0 (-> *setting-control* user-current gun-buoy)))
          (go-virtual exit-ambush)
          )
      )
    (none)
    )
  :code (behavior ()
    (dotimes (gp-0 4)
      (let* ((s5-0 *target*)
             (a1-1 (if (type? s5-0 process-focusable)
                       s5-0
                       )
                   )
             )
        (if a1-1
            (gun-buoy-method-183 self a1-1)
            )
        )
      (let ((s5-1 (current-time)))
        (until (>= (- (current-time) s5-1) (seconds 0.75))
          (suspend)
          )
        )
      )
    (go-virtual hostile)
    (none)
    )
  :post gun-buoy-chase-post
  )

(defstate victory (gun-buoy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy victory) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  :code (behavior ()
    (set! *gun-buoy-victory-index* (rand-vu-int-range 0 (+ (-> *gun-buoy-victory-speech* length) -1)))
    (let ((t0-0 (-> *gun-buoy-victory-speech* *gun-buoy-victory-index*)))
      (set! (-> self voice-id) (add-process *gui-control* self (gui-channel guard) (gui-action play) t0-0 -99.0 0))
      )
    (ja-no-eval :group! gun-buoy-close-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim gun-buoy-close-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-0 (current-time)))
      (until (>= (- (current-time) gp-0) (seconds 2))
        (suspend)
        )
      )
    (go-virtual exit-ambush)
    (none)
    )
  :post gun-buoy-chase-post
  )

(defstate active (gun-buoy)
  :virtual #t
  :code (behavior ()
    (go-virtual idle)
    (none)
    )
  )

(defmethod general-event-handler gun-buoy ((obj gun-buoy) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (case arg2
    (('jump)
     #f
     )
    (else
      ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod track-target! gun-buoy ((obj gun-buoy))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (-> obj root)
  (let* ((s4-0 *target*)
         (s5-0 (if (type? s4-0 process-focusable)
                   s4-0
                   )
               )
         )
    (cond
      (s5-0
        (let* ((s2-1 (vector-normalize-copy!
                       (new 'stack-no-clear 'vector)
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (get-quat s5-0 2))
                       1.0
                       )
                     )
               (f28-0 (-> obj offset-y-angular))
               (s4-2 (-> obj offset-from-player))
               (s3-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-2 1.0))
               (f30-0 (vector-y-angle s3-1))
               (f0-0 (vector-y-angle s2-1))
               (f30-1 (+ (* 0.15 f28-0) (* 0.8 (seconds-per-frame) (deg-diff f30-0 f0-0))))
               )
          (vector-rotate-y! s3-1 s3-1 f30-1)
          (vector-normalize! s3-1 (vector-length s4-2))
          (set! (-> s4-2 quad) (-> s3-1 quad))
          (set! (-> obj offset-y-angular) f30-1)
          )
        (let* ((f30-2 1.1)
               (v1-10 (get-transv s5-0))
               (f30-3 (* f30-2 (sqrtf (+ (* (-> v1-10 x) (-> v1-10 x)) (* (-> v1-10 z) (-> v1-10 z))))))
               (f0-8 (vector-length (vector-! (new 'stack-no-clear 'vector) (get-trans s5-0 0) (-> obj root trans))))
               (f0-10 (fabs (+ -81920.0 f0-8)))
               (f1-7 (-> obj nav target-speed))
               (f0-11 (fmax f30-3 f0-10))
               )
          (set! (-> obj nav target-speed) (if (< f1-7 f0-11)
                                              (seek f1-7 f0-11 (* 163840.0 (seconds-per-frame)))
                                              (seek f1-7 f0-11 (* 143360.0 (seconds-per-frame)))
                                              )
                )
          )
        0
        )
      (else
        (let ((v1-26 (-> obj nav)))
          (set! (-> v1-26 target-speed) 0.0)
          )
        0
        )
      )
    )
  0
  (let ((v1-30 (current-time))
        (f0-18 4.83)
        )
    (set! (-> obj y-bob)
          (* 1228.8 (cos (* 65536.0 (/ (the float (mod v1-30 (the int (* 300.0 f0-18)))) (* 300.0 f0-18)))))
          )
    )
  (water-control-method-10 (-> obj water))
  (update-trans! (-> obj sound) (-> obj root trans))
  (update! (-> obj sound))
  ((method-of-type nav-enemy track-target!) obj)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-hostile gun-buoy ((obj gun-buoy))
  (if (logtest? (-> obj flags) (gun-buoy-flags gubflags-1))
      (go (method-of-object obj hostile))
      (go (method-of-object obj warning))
      )
  (none)
  )

(defmethod enemy-method-61 gun-buoy ((obj gun-buoy) (arg0 int))
  arg0
  )

;; WARN: Return type mismatch object vs symbol.
;; WARN: disable def twice: 40. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod in-aggro-range? gun-buoy ((obj gun-buoy) (arg0 process-focusable) (arg1 vector))
  "Should the enemy activate.
- if `activate-distance` is `0.0`, always true
- otherwise, check if the provided process is close enough
@param proc The process used to distance check
@returns true/false"
  (local-vars (v1-19 process-focusable) (f30-1 meters))
  (if (and arg0 (not arg1))
      (set! arg1 (get-trans arg0 0))
      )
  (the-as
    symbol
    (when arg1
      (let ((s4-0 (-> obj root))
            (f30-0 (-> arg1 y))
            (f28-0 (-> obj root trans y))
            )
        (-> obj fact)
        (let ((v1-10
                (or (not (and (-> obj next-state) (= (-> obj next-state name) 'dormant-aware)))
                    (let ((s2-0 arg0))
                      (cond
                        ((if (type? s2-0 target)
                             s2-0
                             )
                         (let ((v1-12 arg0))
                           (and v1-12
                                (or (focus-test? v1-12 on-water under-water)
                                    (= (-> (the-as collide-shape-moving (-> v1-12 root)) ground-pat material) (pat-material waterbottom))
                                    )
                                )
                           )
                         )
                        (else
                          (< f30-0 (+ 16384.0 f28-0))
                          )
                        )
                      )
                    )
                )
              )
          (and v1-10
               (begin
                 (set! f30-1 (-> obj enemy-info notice-nav-radius))
                 (set! v1-19 (if (type? arg0 target)
                                 arg0
                                 )
                       )
                 v1-19
                 )
               (and (and v1-19
                         (or (focus-test? v1-19 on-water under-water)
                             (= (-> (the-as collide-shape-moving (-> v1-19 root)) ground-pat material) (pat-material waterbottom))
                             )
                         )
                    (let ((f0-2 f30-1))
                      (or (>= (* f0-2 f0-2) (vector-vector-xz-distance-squared (-> s4-0 trans) arg1))
                          (is-in-mesh? (-> obj nav) arg1 f30-1)
                          )
                      )
                    )
               )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defmethod gun-buoy-method-183 gun-buoy ((obj gun-buoy) (arg0 process-focusable))
  (let ((s2-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 8)))
        (s3-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 10)))
        (s4-0 (new 'stack-no-clear 'projectile-init-by-other-params))
        )
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> (get-trans arg0 0) quad))
      (+! (-> s5-0 y) 8192.0)
      (set! (-> s4-0 ent) (-> obj entity))
      (set! (-> s4-0 charge) 1.0)
      (set! (-> s4-0 options) (projectile-options))
      (set! (-> s4-0 notify-handle) (the-as handle #f))
      (set! (-> s4-0 owner-handle) (the-as handle #f))
      (set! (-> s4-0 ignore-handle) (process->handle obj))
      (let* ((v1-11 *game-info*)
             (a0-9 (+ (-> v1-11 attack-id) 1))
             )
        (set! (-> v1-11 attack-id) a0-9)
        (set! (-> s4-0 attack-id) a0-9)
        )
      (set! (-> s4-0 timeout) (seconds 4))
      (set! (-> s4-0 pos quad) (-> s2-0 quad))
      (vector-! (-> s4-0 vel) s5-0 (-> s4-0 pos))
      (vector-normalize! (-> s4-0 vel) 737280.0)
      (spawn-projectile gun-buoy-shot s4-0 obj *default-dead-pool*)
      (set! (-> s4-0 pos quad) (-> s3-0 quad))
      (vector-! (-> s4-0 vel) s5-0 (-> s4-0 pos))
      )
    (vector-normalize! (-> s4-0 vel) 737280.0)
    (spawn-projectile gun-buoy-shot s4-0 obj *default-dead-pool*)
    )
  (none)
  )

(defmethod nav-enemy-method-142 gun-buoy ((obj gun-buoy) (arg0 nav-control))
  (local-vars (a0-19 int) (a0-21 int))
  (let* ((v1-1 (-> *perf-stats* data 33))
         (a0-1 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-1) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-1)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (forward-up-nopitch->quaternion (-> obj root quat) (-> obj aim-dir) *y-vector*)
  (seek! (-> obj elev-angle) (- (vector-x-angle (-> obj aim-dir))) (* 10922.667 (seconds-per-frame)))
  (let* ((s5-1 (new 'stack-no-clear 'quaternion))
         (s4-1 (-> obj root quat))
         (f1-1 (-> obj elev-angle))
         (f0-7 (fmax -728.1778 (fmin 728.1778 f1-1)))
         (f1-2 (- f1-1 f0-7))
         (f2-3 (* 0.2 f1-2))
         (f30-0 (+ f0-7 (* 0.8 f1-2)))
         )
    (quaternion-vector-angle! s5-1 *x-vector* f2-3)
    (quaternion-normalize! (quaternion*! s4-1 s4-1 s5-1))
    (quaternion-vector-angle! (the-as quaternion (-> obj gun-elev-jmod target)) *x-vector* f30-0)
    )
  (let* ((s2-0 (vector-inv-orient-by-quat! (new 'stack-no-clear 'vector) (-> obj root transv) (-> obj root quat)))
         (v1-15 (vector-normalize-copy! (new 'stack-no-clear 'vector) s2-0 1.0))
         (s3-1 (new 'stack-no-clear 'vector))
         )
    0.0
    (let ((s5-2 (new 'stack-no-clear 'quaternion))
          (s4-2 (-> obj root quat))
          (gp-1 (-> obj banking-quat))
          )
      (vector-normalize! (vector-cross! s3-1 v1-15 *y-vector*) 1.0)
      (let ((f0-9 (lerp-scale 0.0 1638.4 (vector-length s2-0) 0.0 81920.0)))
        (quaternion-vector-angle! s5-2 s3-1 (- f0-9))
        )
      (quaternion-slerp! gp-1 gp-1 s5-2 (* 2.0 (seconds-per-frame)))
      (quaternion*! s4-2 s4-2 gp-1)
      )
    )
  (let ((v1-20 (-> *perf-stats* data 33)))
    (b! (zero? (-> v1-20 ctrl)) cfg-4 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-19 pcr0)
    (+! (-> v1-20 accum0) a0-19)
    (.mfpc a0-21 pcr1)
    (+! (-> v1-20 accum1) a0-21)
    )
  (label cfg-4)
  0
  0
  (none)
  )

;; WARN: Return type mismatch nav-enemy vs gun-buoy.
(defmethod relocate gun-buoy ((obj gun-buoy) (arg0 int))
  (if (nonzero? (-> obj gun-elev-jmod))
      (&+! (-> obj gun-elev-jmod) arg0)
      )
  (the-as gun-buoy ((method-of-type nav-enemy relocate) obj arg0))
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod init-enemy-collision! gun-buoy ((obj gun-buoy))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 1) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 2))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak bot crate obstacle hit-by-others-list player-list)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid deadly no-standon))
      (set-vector! (-> s4-0 local-sphere) 0.0 5324.8 -1638.4 13926.4)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-13 prim-core collide-with)
            (collide-spec backgnd jak bot crate obstacle hit-by-others-list player-list)
            )
      (set! (-> v1-13 prim-core action) (collide-action solid deadly no-standon))
      (set-vector! (-> v1-13 local-sphere) 0.0 5324.8 -1638.4 12288.0)
      )
    (set! (-> s5-0 nav-radius) 24576.0)
    (let ((v1-15 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  (none)
  )

(defmethod init-enemy! gun-buoy ((obj gun-buoy))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-gun-buoy" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-enemy-behaviour-and-stats! obj *gun-buoy-nav-enemy-info*)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (process-entity-status! obj (entity-perm-status no-kill) #t)
  (set! (-> obj start-pos quad) (-> obj root trans quad))
  (set! (-> obj flags) (gun-buoy-flags))
  (set! (-> obj gun-elev-jmod) (the-as joint-mod (new 'process 'joint-mod-rotate-local obj 6 #f)))
  (quaternion-copy! (the-as quaternion (-> obj gun-elev-jmod target)) *unity-quaternion*)
  (set! (-> obj water) (new 'process 'water-control obj 3 8192.0 8192.0 2048.0))
  (set! (-> obj water flags)
        (water-flags
          active
          use-ocean
          use-water-anim
          touch-water
          part-splash
          part-drip
          part-rings
          part-water
          find-water
          )
        )
  (set! (-> obj water height) (res-lump-float (-> obj entity) 'water-height))
  (set! (-> obj water ripple-size) 24576.0)
  (set! (-> obj water wake-size) 12288.0)
  (quaternion-copy! (-> obj banking-quat) *unity-quaternion*)
  (logclear! (-> obj nav flags) (nav-control-flag update-heading-from-facing))
  (let ((s5-1 (new 'stack-no-clear 'vector)))
    (vector-z-quaternion! s5-1 (-> obj root quat))
    (set! (-> obj nav state heading quad) (-> s5-1 quad))
    )
  0
  (vector-reset! (-> obj offset-from-player))
  (set! (-> obj offset-y-angular) 0.0)
  (set! (-> obj elev-angle) 0.0)
  (set-vector! (-> obj aim-dir) 0.0 0.0 1.0 0.0)
  (set! (-> obj splash-timer) 0)
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "gun-buoy-steady" :fo-max 80) (-> obj root trans))
        )
  (update-vol! (-> obj sound) 0.0)
  (set! (-> obj warning-id) (the-as sound-id -1))
  (none)
  )
