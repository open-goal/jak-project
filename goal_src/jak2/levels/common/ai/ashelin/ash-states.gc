;;-*-Lisp-*-
(in-package goal)

;; name: ash-states.gc
;; name in dgo: ash-states
;; dgos: ATE, CTYASHA

;; DECOMP BEGINS

(defstate waiting-idle (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (look-at-target! self (enemy-flag lock-focus))
    (set! (-> self travel-anim-interp) 0.0)
    )
  :trans (behavior ()
    (bot-method-223 self #f)
    (when (not (focus-test? self grabbed))
      (cond
        ((bot-method-214 self)
         (go-hostile self)
         )
        ((not (outside-spot-radius? self (the-as bot-spot #f) (the-as vector #f) #f))
         (go-virtual traveling)
         )
        )
      )
    0
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 ashelin-idle0-ja))
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-16 (ja-group)))
           (and v1-16 (= v1-16 ashelin-standing-idle-ja))
           )
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         (ja-channel-push! 1 (seconds 0.03))
         (ja-no-eval :group! ashelin-standing-to-waiting-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (ja-channel-push! 1 (seconds 0.03))
         )
        (else
          (let ((v1-55 (ja-group)))
            (cond
              ((and v1-55 (= v1-55 ashelin-standing-to-waiting-ja))
               (ja-no-eval :num! (seek!))
               (while (not (ja-done? 0))
                 (suspend)
                 (ja-eval)
                 )
               (ja-channel-push! 1 (seconds 0.03))
               )
              (else
                (ja-channel-push! 1 (seconds 0.2))
                )
              )
            )
          )
        )
      )
    (until #f
      (ja-no-eval :group! ashelin-idle0-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post nav-enemy-simple-post
  )

(defstate standing-idle (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (look-at-target! self (enemy-flag lock-focus))
    (set! (-> self travel-anim-interp) 0.0)
    (logclear! (-> self bot-flags) (bot-flags bf21))
    )
  :trans (behavior ()
    (bot-method-223 self #t)
    (cond
      ((bot-method-214 self)
       (cond
         ((ashelin-method-238 self #t #t)
          (when (and (ashelin-method-235 self #t) (let ((v1-11 (ja-group)))
                                                    (and v1-11 (= v1-11 ashelin-standing-idle-ja))
                                                    )
                     )
            (cond
              ((and (-> self focus-info fproc) (< 8192.0 (fabs (-> self focus-info ry-diff))))
               (go-virtual standing-turn)
               )
              ((ashelin-method-235 self #f)
               (go-virtual standing-blast)
               )
              (else
                (let ((a1-4 (ashelin-method-242 self)))
                  (if (nonzero? a1-4)
                      (ashelin-method-240 self a1-4)
                      )
                  )
                )
              )
            )
          (let ((a1-5 (ashelin-method-246 self)))
            (cond
              ((nonzero? a1-5)
               (ashelin-method-240 self a1-5)
               )
              ((and (-> self focus-info fproc) (< 8192.0 (fabs (-> self focus-info ry-diff))))
               (go-virtual standing-turn)
               )
              )
            )
          )
         (else
           (let ((a1-6 (ashelin-method-246 self)))
             (cond
               ((nonzero? a1-6)
                (ashelin-method-240 self a1-6)
                )
               (else
                 (if (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (ashelin-method-247 self))
                     (go-virtual chase)
                     )
                 )
               )
             )
           )
         )
       (when (logtest? (bot-flags bf21) (-> self bot-flags))
         (logclear! (-> self bot-flags) (bot-flags bf21))
         (let ((a1-7 (ashelin-method-241 self)))
           (if (nonzero? a1-7)
               (ashelin-method-240 self a1-7)
               )
           )
         )
       )
      (else
        (if (time-elapsed? (-> self state-time) (-> self reaction-time))
            (ashelin-method-239 self)
            )
        )
      )
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 ashelin-standing-idle-ja))
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-16 (ja-group)))
           (and v1-16 (or (= v1-16 ashelin-waiting-to-standing-ja)
                          (= v1-16 ashelin-standing-turn-left-ja)
                          (= v1-16 ashelin-standing-turn-right-ja)
                          )
                )
           )
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         (ja-channel-push! 1 (seconds 0.03))
         )
        ((let ((v1-31 (ja-group)))
           (and v1-31 (= v1-31 ashelin-idle0-ja))
           )
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! ashelin-waiting-to-standing-ja :num! (seek!) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (ja-channel-push! 1 (seconds 0.03))
         )
        (else
          (ja-channel-push! 1 (seconds 0.2))
          )
        )
      )
    (until #f
      (ja-no-eval :group! ashelin-standing-idle-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post nav-enemy-simple-post
  )

(defstate standing-turn (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (look-at-target! self (enemy-flag lock-focus))
    (set! (-> self travel-anim-interp) 0.0)
    (logclear! (-> self bot-flags) (bot-flags bf21))
    )
  :trans (behavior ()
    (bot-method-223 self #f)
    (when (bot-method-214 self)
      (let ((a1-1 (ashelin-method-246 self)))
        (if (nonzero? a1-1)
            (ashelin-method-240 self a1-1)
            )
        )
      (when (logtest? (bot-flags bf21) (-> self bot-flags))
        (logclear! (-> self bot-flags) (bot-flags bf21))
        (let ((a1-2 (ashelin-method-241 self)))
          (if (nonzero? a1-2)
              (ashelin-method-240 self a1-2)
              )
          )
        )
      )
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'bot-turn-info)))
      (let ((s5-0 (-> self focus-info fproc)))
        (if (not s5-0)
            (ashelin-method-239 self)
            )
        (turn-to-target self gp-0 s5-0 0.335)
        )
      (let ((s4-0 (-> self draw art-group data (if (>= (-> gp-0 predicted-ry-diff) 0.0)
                                                   31
                                                   32
                                                   )
                      )
                  )
            )
        (ja-channel-push! 1 (seconds 0.1))
        (let ((s5-1 (new 'stack-no-clear 'quaternion))
              (f0-1 (-> gp-0 predicted-ry-diff))
              (f30-0 0.0)
              (f28-0 10.0)
              )
          (quaternion-rotate-y! s5-1 (-> gp-0 src-quat) f0-1)
          (ja-no-eval :group! s4-0 :num! (seek! max 2.0) :frame-num 0.0)
          (until (ja-done? 0)
            (let ((f0-6 (ja-aframe-num 0)))
              (cond
                ((< f0-6 f28-0)
                 (if (>= f0-6 f30-0)
                     (quaternion-slerp! (-> self root quat) (-> gp-0 src-quat) s5-1 (/ (- f0-6 f30-0) (- f28-0 f30-0)))
                     )
                 )
                (else
                  (quaternion-copy! (-> self root quat) s5-1)
                  )
                )
              )
            (suspend)
            (ja :num! (seek! max 2.0))
            )
          )
        )
      )
    (go-virtual standing-idle)
    )
  :post nav-enemy-simple-post
  )

(defstate traveling (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (stop-looking-at-target! self)
    (nav-enemy-method-165 self)
    (set! (-> self player-blocking) 0.0)
    )
  :trans (behavior ()
    (if (focus-test? self grabbed)
        (go-virtual waiting-idle)
        )
    (bot-method-223 self #f)
    (cond
      ((bot-method-214 self)
       (go-hostile self)
       )
      ((outside-spot-radius? self (the-as bot-spot #f) (the-as vector #f) #t)
       (ashelin-method-239 self)
       )
      ((and (time-elapsed? (-> self state-time) (seconds 0.5)) (bot-method-208 self))
       (go-virtual traveling-blocked)
       )
      ((and (nav-enemy-method-163 self) (time-elapsed? (-> self state-time) (-> self reaction-time)))
       (go-stare2 self)
       )
      )
    0
    )
  :code (behavior ()
    (until #f
      (ashelin-method-249 self)
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self spot))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 center quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate traveling-blocked (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (look-at-target! self (enemy-flag lock-focus))
    (set! (-> self travel-anim-interp) 0.0)
    )
  :trans (behavior ()
    (bot-method-223 self #f)
    (cond
      ((bot-method-214 self)
       (go-hostile self)
       )
      ((and (time-elapsed? (-> self state-time) (seconds 1)) (not (bot-method-208 self)))
       (go-virtual traveling)
       )
      )
    )
  :code (-> (method-of-type ashelin waiting-idle) code)
  :post nav-enemy-simple-post
  )

(defstate stare (ashelin)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type bot stare) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (set! (-> self travel-anim-interp) 0.0)
    )
  :trans (behavior ()
    (bot-method-223 self #f)
    (when (time-elapsed? (-> self state-time) (seconds 0.1))
      (when (bot-method-214 self)
        (if (ashelin-method-238 self #t #f)
            (go-virtual standing-idle)
            )
        )
      (if (not (nav-enemy-method-163 self))
          (go-virtual traveling)
          )
      )
    )
  :code (-> (method-of-type ashelin waiting-idle) code)
  )

(defstate standing-blast (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    ((-> (method-of-type nav-enemy hostile) enter))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (logior! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (if (not (handle->process (-> self focus handle)))
        (react-to-focus self)
        )
    (set! (-> self travel-anim-interp) 0.0)
    )
  :exit (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    )
  :code (behavior ()
    (bot-method-223 self #t)
    (if (or (not (bot-method-214 self)) (not (ashelin-method-235 self #f)))
        (react-to-focus self)
        )
    (let ((v1-12 (ja-group)))
      (if (and v1-12 (or (= v1-12 ashelin-standing-idle-ja) (= v1-12 ashelin-standing-fire-ja)))
          (ja-channel-push! 1 (seconds 0.03))
          (ja-channel-push! 1 (seconds 0.08))
          )
      )
    (let ((gp-0 #f))
      (ja-no-eval :group! ashelin-standing-fire-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (when (and (not gp-0) (>= (ja-aframe-num 0) 7.0))
          (set! gp-0 #t)
          (fire-projectile self (-> self focus-info bullseye))
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (cond
      ((logtest? (-> self bot-flags) (bot-flags attacked))
       (logclear! (-> self enemy-flags) (enemy-flag look-at-focus))
       (reset-attacker! self)
       )
      ((logtest? (-> self enemy-flags) (enemy-flag look-at-focus))
       (ashelin-method-245 self)
       )
      )
    (react-to-focus self)
    )
  :post nav-enemy-simple-post
  )

(defstate chase (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    ((-> (method-of-type nav-enemy hostile) enter))
    (nav-enemy-method-166 self)
    )
  :trans (behavior ()
    (bot-method-223 self #t)
    (cond
      ((and (nav-enemy-method-163 self) (time-elapsed? (-> self state-time) (-> self reaction-time)))
       (go-stare2 self)
       )
      ((not (bot-method-214 self))
       (go-virtual traveling)
       )
      )
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (if (or (ashelin-method-238 self #t #f) (ashelin-method-248 self))
          (go-virtual standing-idle)
          )
      )
    (let ((gp-0 (-> self nav)))
      (set! (-> gp-0 target-speed) (lerp-scale
                                     (-> self enemy-info walk-travel-speed)
                                     (-> self enemy-info run-travel-speed)
                                     (-> self focus-info bullseye-xz-dist)
                                     81920.0
                                     92160.0
                                     )
            )
      )
    0
    )
  :code (behavior ()
    (until #f
      (ashelin-method-249 self)
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (let ((gp-0 (-> self nav state))
          (v1-6 (get-trans (the-as process-focusable (handle->process (-> self focus handle))) 0))
          )
      (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
      (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> gp-0 target-post quad) (-> v1-6 quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate back-spring (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (stop-looking-at-target! self)
    (nav-enemy-method-167 self)
    (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
    (set! (-> self travel-anim-interp) 0.0)
    )
  :exit (behavior ()
    (if (logtest? (enemy-flag enemy-flag43) (-> self enemy-flags))
        (logior! (-> self nav flags) (nav-control-flag update-heading-from-facing))
        (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (-> self move-dest))))
      (let ((s5-0 (new 'stack-no-clear 'quaternion))
            (s4-0 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-copy! s5-0 (-> self root quat))
        (quaternion<-rotate-y-vector s4-0 gp-1)
        (ja-no-eval :group! ashelin-back-spring-start-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (quaternion-slerp! (-> self root quat) s5-0 s4-0 (/ (ja-frame-num 0) (the float (ja-num-frames 0))))
          (suspend)
          (ja :num! (seek!))
          )
        )
      (logior! (-> self focus-status) (focus-status dangerous))
      (let* ((v1-30 *game-info*)
             (a0-11 (+ (-> v1-30 attack-id) 1))
             )
        (set! (-> v1-30 attack-id) a0-11)
        (set! (-> self attack-id) a0-11)
        )
      (countdown (s5-1 2)
        (vector-! gp-1 (-> self move-dest) (-> self root trans))
        (let ((a0-14 (-> self nav state))
              (v1-33 gp-1)
              )
          (set! (-> a0-14 heading quad) (-> v1-33 quad))
          )
        0
        (let ((v1-36 (-> self nav)))
          (set! (-> v1-36 acceleration) 1638400.0)
          )
        0
        (let ((v1-38 (-> self nav)))
          (set! (-> v1-38 turning-acceleration) 1638400.0)
          )
        0
        (let ((v1-40 self))
          (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-40 enemy-flags)))
              (set! (-> v1-40 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-40 enemy-flags))))
              )
          (set! (-> v1-40 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-40 enemy-flags))))
          (set! (-> v1-40 nav callback-info) (-> v1-40 enemy-info callback-info))
          )
        0
        (let ((f0-13 (* 1.6153771 (vector-length gp-1))))
          (let ((v1-46 (-> self nav)))
            (set! (-> v1-46 target-speed) f0-13)
            )
          0
          (set! (-> self nav state speed) f0-13)
          )
        0
        (ja-no-eval :group! ashelin-back-spring-loop-ja :num! (seek! max 1.4) :frame-num 0.0)
        (until (ja-done? 0)
          (let ((a1-12 (-> self nav state)))
            (set! (-> gp-1 quad) (-> a1-12 heading quad))
            )
          (set! (-> gp-1 y) 0.0)
          (vector-normalize! gp-1 1.0)
          (vector-negate! gp-1 gp-1)
          (quaternion-set! (-> self root quat) 0.0 (-> gp-1 x) 0.0 (+ 1.0 (-> gp-1 z)))
          (quaternion-normalize! (-> self root quat))
          (suspend)
          (ja :num! (seek! max 1.4))
          )
        (bot-method-223 self #f)
        (if (or (not (bot-method-214 self)) (!= (ashelin-method-246 self) 1))
            (goto cfg-15)
            )
        )
      )
    (label cfg-15)
    (let ((v1-92 self))
      (set! (-> v1-92 enemy-flags) (the-as enemy-flag (logclear (-> v1-92 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-92 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (ja-no-eval :group! ashelin-back-spring-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (react-to-focus self)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self move-dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate cartwheel-left (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (stop-looking-at-target! self)
    (nav-enemy-method-167 self)
    (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
    (set! (-> self travel-anim-interp) 0.0)
    )
  :exit (behavior ()
    (if (logtest? (enemy-flag enemy-flag43) (-> self enemy-flags))
        (logior! (-> self nav flags) (nav-control-flag update-heading-from-facing))
        (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans))))
      (let ((s5-0 (new 'stack-no-clear 'quaternion))
            (s4-0 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-copy! s5-0 (-> self root quat))
        (quaternion<-rotate-y-vector s4-0 gp-1)
        (quaternion-rotate-y! s4-0 s4-0 -16384.0)
        (ja-no-eval :group! ashelin-cartwheel-left-start-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (quaternion-slerp! (-> self root quat) s5-0 s4-0 (/ (ja-frame-num 0) (the float (ja-num-frames 0))))
          (suspend)
          (ja :num! (seek!))
          )
        )
      (logior! (-> self focus-status) (focus-status dangerous))
      (let* ((v1-29 *game-info*)
             (a0-13 (+ (-> v1-29 attack-id) 1))
             )
        (set! (-> v1-29 attack-id) a0-13)
        (set! (-> self attack-id) a0-13)
        )
      (let ((a0-14 (-> self nav state))
            (v1-31 gp-1)
            )
        (set! (-> a0-14 heading quad) (-> v1-31 quad))
        )
      0
      (let ((v1-34 (-> self nav)))
        (set! (-> v1-34 acceleration) 1638400.0)
        )
      0
      (let ((v1-36 (-> self nav)))
        (set! (-> v1-36 turning-acceleration) 1638400.0)
        )
      0
      (let ((v1-38 self))
        (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-38 enemy-flags)))
            (set! (-> v1-38 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-38 enemy-flags))))
            )
        (set! (-> v1-38 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-38 enemy-flags))))
        (set! (-> v1-38 nav callback-info) (-> v1-38 enemy-info callback-info))
        )
      0
      (let ((f0-13 (* 1.0714335 (vector-length gp-1))))
        (let ((v1-44 (-> self nav)))
          (set! (-> v1-44 target-speed) f0-13)
          )
        0
        (set! (-> self nav state speed) f0-13)
        )
      0
      (ja-no-eval :group! ashelin-cartwheel-left-loop-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (let ((a1-11 (-> self nav state)))
          (set! (-> gp-1 quad) (-> a1-11 heading quad))
          )
        (set! (-> gp-1 y) 0.0)
        (vector-normalize! gp-1 1.0)
        (vector-rotate-around-y! gp-1 gp-1 -16384.0)
        (quaternion-set! (-> self root quat) 0.0 (-> gp-1 x) 0.0 (+ 1.0 (-> gp-1 z)))
        (quaternion-normalize! (-> self root quat))
        (suspend)
        (ja :num! (seek!))
        )
      )
    (let ((v1-78 self))
      (set! (-> v1-78 enemy-flags) (the-as enemy-flag (logclear (-> v1-78 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-78 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (ja-no-eval :group! ashelin-cartwheel-left-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (react-to-focus self)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self move-dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate tumble-right (ashelin)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (stop-looking-at-target! self)
    (nav-enemy-method-167 self)
    (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
    (set! (-> self travel-anim-interp) 0.0)
    )
  :exit (behavior ()
    (if (logtest? (enemy-flag enemy-flag43) (-> self enemy-flags))
        (logior! (-> self nav flags) (nav-control-flag update-heading-from-facing))
        (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans))))
      (let ((s5-0 (new 'stack-no-clear 'quaternion))
            (s4-0 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-copy! s5-0 (-> self root quat))
        (quaternion<-rotate-y-vector s4-0 gp-1)
        (quaternion-rotate-y! s4-0 s4-0 16384.0)
        (ja-no-eval :group! ashelin-tumble-right-start-ja :num! (seek!) :frame-num 0.0)
        (until (ja-done? 0)
          (quaternion-slerp! (-> self root quat) s5-0 s4-0 (/ (ja-frame-num 0) (the float (ja-num-frames 0))))
          (suspend)
          (ja :num! (seek!))
          )
        )
      (logior! (-> self focus-status) (focus-status dangerous))
      (let* ((v1-29 *game-info*)
             (a0-13 (+ (-> v1-29 attack-id) 1))
             )
        (set! (-> v1-29 attack-id) a0-13)
        (set! (-> self attack-id) a0-13)
        )
      (let ((a0-14 (-> self nav state))
            (v1-31 gp-1)
            )
        (set! (-> a0-14 heading quad) (-> v1-31 quad))
        )
      0
      (let ((v1-34 (-> self nav)))
        (set! (-> v1-34 acceleration) 1638400.0)
        )
      0
      (let ((v1-36 (-> self nav)))
        (set! (-> v1-36 turning-acceleration) 1638400.0)
        )
      0
      (let ((v1-38 self))
        (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-38 enemy-flags)))
            (set! (-> v1-38 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-38 enemy-flags))))
            )
        (set! (-> v1-38 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-38 enemy-flags))))
        (set! (-> v1-38 nav callback-info) (-> v1-38 enemy-info callback-info))
        )
      0
      (let ((f0-13 (* 1.8749386 (vector-length gp-1))))
        (let ((v1-44 (-> self nav)))
          (set! (-> v1-44 target-speed) f0-13)
          )
        0
        (set! (-> self nav state speed) f0-13)
        )
      0
      (ja-no-eval :group! ashelin-tumble-right-loop-ja :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (let ((a1-11 (-> self nav state)))
          (set! (-> gp-1 quad) (-> a1-11 heading quad))
          )
        (set! (-> gp-1 y) 0.0)
        (vector-normalize! gp-1 1.0)
        (vector-rotate-around-y! gp-1 gp-1 16384.0)
        (quaternion-set! (-> self root quat) 0.0 (-> gp-1 x) 0.0 (+ 1.0 (-> gp-1 z)))
        (quaternion-normalize! (-> self root quat))
        (suspend)
        (ja :num! (seek!))
        )
      )
    (let ((v1-78 self))
      (set! (-> v1-78 enemy-flags) (the-as enemy-flag (logclear (-> v1-78 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-78 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (ja-no-eval :group! ashelin-tumble-right-land-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (react-to-focus self)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self move-dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate hit (ashelin)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type bot hit) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self travel-anim-interp) 0.0)
    (set! (-> self last-fire-time) 0)
    0
    )
  :code (behavior ()
    (local-vars (v1-7 enemy-flag) (v1-15 enemy-flag))
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-6 (-> self enemy-flags)))
      (if (logtest? v1-6 (enemy-flag checking-water))
          (set! v1-7 (logior v1-6 (enemy-flag enable-on-active)))
          (set! v1-7 (logclear v1-6 (enemy-flag enable-on-active)))
          )
      )
    (set! (-> self enemy-flags) v1-7)
    (if (logtest? (-> self enemy-flags) (enemy-flag look-at-move-dest))
        (logior! (-> self mask) (process-mask collectable))
        (logclear! (-> self mask) (process-mask collectable))
        )
    (let ((v1-14 (-> self enemy-flags)))
      (if (logtest? (enemy-flag no-initial-move-to-ground) v1-14)
          (set! v1-15 (logior (enemy-flag check-water-backup) v1-14))
          (set! v1-15 (logclear v1-14 (enemy-flag check-water-backup)))
          )
      )
    (set! (-> self enemy-flags) v1-15)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (logclear! (-> self focus-status) (focus-status hit))
    (react-to-focus self)
    )
  )

(defstate knocked (ashelin)
  :virtual #t
  :enter (behavior ()
    (set! (-> self travel-anim-interp) 0.0)
    (set! (-> self last-fire-time) 0)
    (let ((t9-0 (-> (method-of-type bot knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logclear! (-> self bot-flags) (bot-flags bf23))
    (when (and (nonzero? (-> self hit-points)) (zero? (-> self fated-time)))
      (if (logtest? (-> self bot-flags) (bot-flags bf04))
          (logior! (-> self bot-flags) (bot-flags bf12))
          (logior! (-> self bot-flags) (bot-flags bf23))
          )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type bot knocked) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (when (and (logtest? (bot-flags bf23) (-> self bot-flags)) (!= (-> self state-time) (current-time)))
      (logclear! (-> self bot-flags) (bot-flags bf23))
      (ashelin-method-244 self)
      )
    )
  )

(defstate die-falling (ashelin)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type bot die-falling) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self travel-anim-interp) 0.0)
    )
  :code (behavior ()
    (let ((v1-1 (get-rand-int self 3)))
      (cond
        ((zero? v1-1)
         (play-death-sound self "asha057")
         )
        ((= v1-1 1)
         (play-death-sound self "asha055")
         )
        (else
          (play-death-sound self "asha056")
          )
        )
      )
    (let ((v1-10 (ja-group)))
      (cond
        ((and v1-10 (or (= v1-10 ashelin-knocked-back-die0-ja) (= v1-10 ashelin-knocked-right-die0-ja)))
         (ja-no-eval :num! (seek!))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (let ((gp-0 (-> self draw art-group data (if (enemy-method-133 self)
                                                       (-> self enemy-info die-falling-anim)
                                                       (-> self enemy-info die-anim)
                                                       )
                          )
                      )
                (f30-0 (get-rand-float-range self 0.8 1.2))
                )
            (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          )
        )
      )
    (until #f
      (if (and (logtest? (-> self bot-flags) (bot-flags failed)) (reset? *fail-mission-control*))
          (reset! *fail-mission-control*)
          )
      (suspend)
      )
    #f
    )
  )

(defstate failed (ashelin)
  :virtual #t
  :enter (behavior ()
    (go-virtual die-falling)
    )
  )
