;;-*-Lisp-*-
(in-package goal)

;; name: flamer.gc
;; name in dgo: flamer
;; dgos: FOR, DMI, FRA, STR, NEB, D3A, UNB

;; DECOMP BEGINS

(deftype flying-formation (hover-formation)
  ()
  :heap-base #x10
  :method-count-assert 16
  :size-assert         #x90
  :flag-assert         #x1000100090
  )


(deftype flamer (nav-enemy)
  ((shot-trajectory   trajectory   :inline :offset-assert 608)
   (last-fire-time    time-frame           :offset-assert 648)
   (sync-off          uint32               :offset-assert 656)
   (base-pos          vector       :inline :offset-assert 672)
   (idle-pos          vector       :inline :offset-assert 688)
   (offset            vector       :inline :offset-assert 704)
   (dest-pos          vector       :inline :offset-assert 720)
   (zone-to-world     matrix       :inline :offset-assert 736)
   (world-to-zone     matrix       :inline :offset-assert 800)
   (formation-entity  entity-actor         :offset-assert 864)
   (flit-joint        joint-mod            :offset-assert 868)
   (flit-angle        float                :offset-assert 872)
   (flit-timer        time-frame           :offset-assert 880)
   (path-pos          float                :offset-assert 888)
   (sound-volume      float                :offset-assert 892)
   (scale             float                :offset-assert 896)
   (hit-surface?      symbol               :offset-assert 900)
   (ground-mode       int8                 :offset-assert 904)
   (init-quat         quaternion   :inline :offset-assert 912)
   (surface-normal    vector       :inline :offset-assert 928)
   (main-joint-pos    vector       :inline :offset-assert 944)
   (main-joint-vel    vector       :inline :offset-assert 960)
   (main-joint-acc    vector       :inline :offset-assert 976)
   (main-acceleration float                :offset-assert 992)
   (fly-dir           vector       :inline :offset-assert 1008)
   )
  :heap-base #x380
  :method-count-assert 192
  :size-assert         #x400
  :flag-assert         #xc003800400
  (:methods
    (attack () _type_ :state 178)
    (wait-for-formation () _type_ :state 179)
    (exit-ambush () _type_ :state 180)
    (exit-ambush-path () _type_ :state 181)
    (flamer-method-182 (_type_ vector process-focusable) none 182)
    (flamer-method-183 (_type_) symbol 183)
    (flamer-method-184 (_type_) none 184)
    (flamer-method-185 (_type_) none 185)
    (flamer-method-186 (_type_ float) vector 186)
    (flamer-method-187 (_type_) none 187)
    (flamer-method-188 (_type_ int float int int) none 188)
    (flamer-method-189 (_type_) none 189)
    (flamer-method-190 (_type_) none 190)
    (flamer-method-191 (_type_) none 191)
    )
  )


(defskelgroup skel-flamer flamer flamer-lod0-jg -1
              ((flamer-lod0-mg (meters 20)) (flamer-lod1-mg (meters 40)) (flamer-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7.5)
              :shadow flamer-shadow-mg
              :origin-joint-index 3
              :shadow-joint-index 3
              )

(defskelgroup skel-flamer-explode flamer flamer-explode-lod0-jg flamer-explode-idle-ja
              ((flamer-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7.5)
              :origin-joint-index 3
              )

(define *flamer-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(define *flamer-fact-defaults* (new 'static 'fact-info-enemy-defaults :idle-distance (meters 80)))

(define *flamer-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #t
    :use-victory #f
    :use-jump-blocked #f
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #f
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'array idle-control-frame 4
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x5 :param0 #x1 :param1 #x1)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      )
    :idle-anim 5
    :notice-anim 5
    :hostile-anim 5
    :hit-anim 13
    :knocked-anim 14
    :knocked-land-anim 16
    :die-anim 17
    :die-falling-anim 17
    :victory-anim 5
    :jump-wind-up-anim 5
    :jump-in-air-anim 5
    :jump-land-anim 5
    :neck-joint 19
    :look-at-joint 19
    :bullseye-joint 3
    :sound-hit (static-sound-name "flamer-hit")
    :sound-die (static-sound-name "flamer-die")
    :notice-distance (meters 70)
    :notice-distance-delta (meters 10)
    :proximity-notice-distance (meters 55)
    :default-hit-points 4
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
    :friction 0.8
    :attack-shove-back (meters 3)
    :attack-shove-up (meters 2)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :jump-height-min (meters 3)
    :jump-height-factor 0.5
    :knocked-soft-vxz-lo 72089.6
    :knocked-soft-vxz-hi 108134.4
    :knocked-soft-vy-lo 81920.0
    :knocked-soft-vy-hi 122880.0
    :knocked-medium-vxz-lo 147456.0
    :knocked-medium-vxz-hi 196608.0
    :knocked-medium-vy-lo 135168.0
    :knocked-medium-vy-hi 151552.0
    :knocked-hard-vxz-lo 78643.2
    :knocked-hard-vxz-hi 117964.8
    :knocked-hard-vy-lo 183500.8
    :knocked-hard-vy-hi 209715.2
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 40960.0
    :knocked-yellow-vxz-hi 49152.0
    :knocked-yellow-vy-lo 57344.0
    :knocked-yellow-vy-hi 81920.0
    :knocked-red-vxz-lo 24576.0
    :knocked-red-vxz-hi 196608.0
    :knocked-red-vy-lo 94208.0
    :knocked-red-vy-hi 151552.0
    :knocked-blue-vxz-lo 40960.0
    :knocked-blue-vxz-hi 90112.0
    :knocked-blue-vy-lo 90112.0
    :knocked-blue-vy-hi 172032.0
    :shadow-size (meters 2)
    :shadow-max-y (meters 10)
    :shadow-min-y (meters -40)
    :shadow-locus-dist (meters 150)
    :gem-joint 19
    :gem-seg #x2
    :gem-no-seg #x4
    :gem-offset (new 'static 'sphere :y 450.56 :z 1638.4 :r 163840.0)
    :callback-info #f
    :use-momentum #f
    :use-frustration #t
    :use-stop-chase #f
    :use-circling #f
    :use-pacing #f
    :walk-anim 5
    :turn-anim 5
    :run-anim 5
    :taunt-anim -1
    :run-travel-speed (meters 16)
    :run-acceleration (meters 1)
    :run-turning-acceleration (meters 50)
    :walk-travel-speed (meters 12)
    :walk-acceleration (meters 1)
    :walk-turning-acceleration (meters 50)
    :maximum-rotation-rate (degrees 360.0)
    :notice-nav-radius (meters 55)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

(set! (-> *flamer-nav-enemy-info* fact-defaults) *flamer-fact-defaults*)

(defmethod general-event-handler flamer ((obj flamer) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (case arg2
    (('hit 'hit-flinch 'hit-knocked)
     (logclear! (-> obj mask) (process-mask actor-pause))
     (logclear! (-> obj focus-status) (focus-status dangerous))
     (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice))
     (logior! (-> obj enemy-flags) (enemy-flag chase-startup))
     (logior! (-> obj focus-status) (focus-status hit))
     (if (zero? (-> obj hit-points))
         (logior! (-> obj focus-status) (focus-status dead))
         )
     (logclear! (-> obj enemy-flags) (enemy-flag actor-pause-backup))
     (enemy-method-62 obj)
     (set! (-> obj enemy-flags) (logior (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
     (process-contact-action arg0)
     (send-event arg0 'get-attack-count 1)
     (go (method-of-object obj knocked))
     )
    (('update-formation)
     (let ((v0-3 (the-as object (-> obj offset))))
       (set! (-> (the-as vector v0-3) quad) (-> (the-as vector (-> arg3 param 0)) quad))
       v0-3
       )
     )
    (else
      ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod flamer-method-189 flamer ((obj flamer))
  (with-pp
    (let ((v1-0 (-> obj formation-entity)))
      (when (if v1-0
                (-> v1-0 extra process)
                )
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer pp))
          (set! (-> a1-1 num-params) 0)
          (set! (-> a1-1 message) 'join)
          (let ((t9-0 send-event-function)
                (v1-5 (-> obj formation-entity))
                )
            (t9-0
              (if v1-5
                  (-> v1-5 extra process)
                  )
              a1-1
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod flamer-method-190 flamer ((obj flamer))
  (with-pp
    (let ((v1-0 (-> obj formation-entity)))
      (when (if v1-0
                (-> v1-0 extra process)
                )
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer pp))
          (set! (-> a1-1 num-params) 0)
          (set! (-> a1-1 message) 'leave)
          (let ((t9-0 send-event-function)
                (v1-5 (-> obj formation-entity))
                )
            (t9-0
              (if v1-5
                  (-> v1-5 extra process)
                  )
              a1-1
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod nav-enemy-method-142 flamer ((obj flamer) (arg0 nav-control))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-! gp-0 (target-pos 0) (-> obj root-override2 trans))
    (seek-toward-heading-vec! (-> obj root-override2) gp-0 131072.0 (seconds 0.5))
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod flamer-method-182 flamer ((obj flamer) (arg0 vector) (arg1 process-focusable))
  (with-pp
    (set! arg0 (cond
                 ((and *target* (-> obj next-state) (let ((v1-4 (-> obj next-state name)))
                                                      (or (= v1-4 'hostile) (= v1-4 'attack) (= v1-4 'hit))
                                                      )
                       )
                  (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
                    (set! (-> a1-3 from) (process->ppointer pp))
                    (set! (-> a1-3 num-params) 0)
                    (set! (-> a1-3 message) 'get-formation)
                    (let* ((t9-0 send-event-function)
                           (v1-7 (-> obj formation-entity))
                           (s2-0 (the-as hover-formation-control (t9-0
                                                                   (if v1-7
                                                                       (-> v1-7 extra process)
                                                                       )
                                                                   a1-3
                                                                   )
                                         )
                                 )
                           (s4-0 (new 'stack-no-clear 'vector))
                           )
                      (cond
                        ((and s2-0 (not (is-formation-type-in-range s2-0)))
                         (hover-formation-control-method-15 s2-0 arg0 (-> obj offset))
                         )
                        (else
                          (cond
                            (s2-0
                              (hover-formation-control-method-13 s2-0 s4-0)
                              )
                            (else
                              (let ((s1-0 (new 'stack-no-clear 'vector)))
                                (set! (-> s1-0 quad) (-> (get-trans arg1 0) quad))
                                (let ((s3-1 (new 'stack-no-clear 'vector)))
                                  (let ((s2-1 (new 'stack-no-clear 'vector)))
                                    (vector-! s3-1 s1-0 (-> obj root-override2 trans))
                                    (vector-flatten! s2-1 s3-1 (-> obj zone-to-world vector 2))
                                    (vector-float*! s2-1 s2-1 -0.9)
                                    (vector+! s3-1 s3-1 s2-1)
                                    )
                                  (vector+! s4-0 (-> obj root-override2 trans) s3-1)
                                  )
                                )
                              )
                            )
                          (vector-matrix*! arg0 s4-0 (-> obj world-to-zone))
                          (vector+! arg0 arg0 (-> obj offset))
                          (vector-matrix*! arg0 arg0 (-> obj zone-to-world))
                          )
                        )
                      )
                    )
                  (let* ((v1-30 (+ (current-time) (the-as time-frame (-> obj sync-off))))
                         (f0-5 (+ (-> arg0 x) (* 614.4 (cos (* 54.613335 (the float (mod v1-30 1200)))))))
                         )
                    (set! (-> arg0 x) f0-5)
                    (the-as vector f0-5)
                    )
                  )
                 (else
                   (set! (-> arg0 quad) (-> obj idle-pos quad))
                   arg0
                   )
                 )
          )
    (none)
    )
  )

(defbehavior flamer-attack-post flamer ()
  (let ((a2-0 (handle->process (-> self focus handle))))
    (when a2-0
      (flamer-method-182 self (-> self dest-pos) (the-as process-focusable a2-0))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (vector-matrix*! gp-0 (-> self dest-pos) (-> self world-to-zone))
        (if (< (-> gp-0 z) 0.0)
            (set! (-> gp-0 z) 0.0)
            )
        (vector-matrix*! (-> self dest-pos) gp-0 (-> self zone-to-world))
        )
      )
    )
  (cloest-point-on-mesh (-> self nav) (-> self dest-pos) (-> self dest-pos) (the-as nav-poly #f))
  (if #f
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (-> self root-override2 trans)
        (-> self dest-pos)
        (new 'static 'rgba :r #xff :g #xff :b #xff :a #xff)
        #f
        (the-as rgba -1)
        )
      )
  (let ((a0-8 (-> self nav state))
        (v1-16 (-> self dest-pos))
        )
    (logclear! (-> a0-8 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-8 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-8 target-post quad) (-> v1-16 quad))
    )
  0
  (flamer-method-184 self)
  (nav-enemy-travel-post)
  (none)
  )

(defbehavior flamer-flit-post flamer ()
  (when (>= (- (current-time) (-> self flit-timer)) (rand-vu-int-range (seconds 1.2) (seconds 3)))
    (set! (-> self flit-angle)
          (the float
               (sar (shl (the int (+ (-> self flit-angle) (* 182.04445 (rand-vu-float-range 160.0 200.0)))) 48) 48)
               )
          )
    (set! (-> self flit-timer) (current-time))
    )
  (flamer-attack-post)
  (none)
  )

;; WARN: Return type mismatch object vs symbol.
;; WARN: disable def twice: 22. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
;; WARN: disable def twice: 45. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod flamer-method-183 flamer ((obj flamer))
  (with-pp
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer pp))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'get-formation)
      (let* ((t9-0 send-event-function)
             (v1-2 (-> obj formation-entity))
             (a0-3 (the-as hover-formation-control (t9-0
                                                     (if v1-2
                                                         (-> v1-2 extra process)
                                                         )
                                                     a1-0
                                                     )
                           )
                   )
             )
        (the-as
          symbol
          (cond
            (a0-3
              (and (hover-formation-control-method-16 a0-3) (>= (the-as int (-> obj focus aware)) 3))
              )
            (*target*
              (let ((a1-1 (target-pos 0)))
                (-> obj root-override2 trans)
                (let ((s5-0 (new 'stack-no-clear 'vector)))
                  (vector-matrix*! s5-0 a1-1 (-> obj world-to-zone))
                  (and (>= (-> obj enemy-info-override notice-distance) (-> s5-0 z)) (>= (the-as int (-> obj focus aware)) 3))
                  )
                )
              )
            (else
              #f
              )
            )
          )
        )
      )
    )
  )

(defmethod flamer-method-188 flamer ((obj flamer) (arg0 int) (arg1 float) (arg2 int) (arg3 int))
  (local-vars (v1-1 int))
  0
  (if (< 0.0 arg1)
      (set! v1-1 arg2)
      (set! v1-1 arg3)
      )
  (let ((a3-5 (-> obj skel root-channel arg0)))
    (let ((f0-2 (fabs arg1)))
      (set! (-> a3-5 frame-interp 1) f0-2)
      (set! (-> a3-5 frame-interp 0) f0-2)
      )
    (set! (-> a3-5 frame-group) (the-as art-joint-anim (-> obj draw art-group data v1-1)))
    (set! (-> a3-5 param 0) 0.0)
    (set! (-> a3-5 frame-num) (-> obj skel root-channel 0 frame-num))
    (joint-control-channel-group! a3-5 (the-as art-joint-anim (-> obj draw art-group data v1-1)) num-func-chan)
    )
  (none)
  )

(defmethod flamer-method-187 flamer ((obj flamer))
  (local-vars (at-0 int) (at-1 int))
  (with-pp
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((a1-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 3)))
            (a0-2 (new 'stack-no-clear 'vector))
            (v1-1 (new 'stack-no-clear 'vector))
            )
        (new 'stack-no-clear 'vector)
        (vector-! a0-2 a1-1 (-> obj main-joint-pos))
        (let ((a2-2 a0-2))
          (.lvf vf1 (&-> a0-2 quad))
          (let ((f0-0 (-> pp clock frames-per-second)))
            (.mov at-0 f0-0)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> a2-2 quad) vf1)
          )
        (vector-! v1-1 a0-2 (-> obj main-joint-vel))
        (let ((a2-4 v1-1))
          (.lvf vf1 (&-> v1-1 quad))
          (let ((f0-1 (-> pp clock frames-per-second)))
            (.mov at-1 f0-1)
            )
          (.mov vf2 at-1)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> a2-4 quad) vf1)
          )
        (set! (-> obj main-joint-pos quad) (-> a1-1 quad))
        (let* ((f0-2 0.4)
               (f1-1 (- 1.0 f0-2))
               (a1-5 (-> obj main-joint-vel))
               )
          (set! (-> a1-5 x) (+ (* f0-2 (-> a0-2 x)) (* f1-1 (-> a1-5 x))))
          (set! (-> a1-5 y) (+ (* f0-2 (-> a0-2 y)) (* f1-1 (-> a1-5 y))))
          (set! (-> a1-5 z) (+ (* f0-2 (-> a0-2 z)) (* f1-1 (-> a1-5 z))))
          )
        (set! (-> obj main-joint-acc quad) (-> v1-1 quad))
        )
      0
      0
      (none)
      )
    )
  )

(defmethod track-target! flamer ((obj flamer))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (update-vol! (-> obj sound) (-> obj sound-volume))
  (flamer-method-191 obj)
  ((method-of-type nav-enemy track-target!) obj)
  (none)
  )

(defmethod flamer-method-191 flamer ((obj flamer))
  (cond
    ((and (-> obj draw shadow)
          (zero? (-> obj draw cur-lod))
          (logtest? (-> obj draw status) (draw-control-status on-screen))
          )
     (new 'stack-no-clear 'vector)
     (new 'stack-no-clear 'vector)
     (let ((s4-0 (new 'stack-no-clear 'collide-query))
           (gp-0 (-> obj draw shadow-ctrl settings shadow-dir))
           (f30-0 122880.0)
           )
       (set! (-> s4-0 start-pos quad) (-> obj root-override2 trans quad))
       (vector-normalize-copy! (-> s4-0 move-dist) gp-0 f30-0)
       (let ((v1-12 s4-0))
         (set! (-> v1-12 radius) 3276.8)
         (set! (-> v1-12 collide-with) (collide-spec backgnd))
         (set! (-> v1-12 ignore-process0) obj)
         (set! (-> v1-12 ignore-process1) #f)
         (set! (-> v1-12 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
         (set! (-> v1-12 action-mask) (collide-action solid))
         )
       (let ((f0-1 (fill-and-probe-using-line-sphere *collide-cache* s4-0)))
         (cond
           ((>= f0-1 0.0)
            (let ((v1-16 (-> obj draw shadow-ctrl)))
              (logclear! (-> v1-16 settings flags) (shadow-flags disable-draw))
              )
            0
            (-> s4-0 best-other-tri intersect)
            (let ((a1-3 (-> obj root-override2 trans)))
              (-> a1-3 y)
              (let ((f1-2 (* f0-1 f30-0)))
                (shadow-control-method-14
                  (-> obj draw shadow-ctrl)
                  a1-3
                  gp-0
                  (fmax 32768.0 (* 409600.0 f0-1))
                  (+ -12288.0 f1-2)
                  (+ 12288.0 f1-2)
                  )
                )
              )
            )
           (else
             (let ((v1-27 (-> obj draw shadow-ctrl)))
               (logior! (-> v1-27 settings flags) (shadow-flags disable-draw))
               )
             0
             )
           )
         )
       )
     )
    (else
      (let ((v1-29 (-> obj draw shadow-ctrl)))
        (logior! (-> v1-29 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defbehavior flamer-fly-code flamer ()
  (let ((v1-2 (ja-group)))
    (if (not (and v1-2 (= v1-2 flamer-idle-ja)))
        (ja-channel-push! 3 (seconds 0.2))
        (ja-channel-set! 3)
        )
    )
  (ja-no-eval :group! flamer-idle-ja
              :num! (seek! (the float (+ (-> (the-as art-joint-anim flamer-idle-ja) frames num-frames) -1)))
              :frame-num 0.0
              )
  (let ((a0-7 (-> self skel root-channel 1)))
    (let ((f0-4 0.0))
      (set! (-> a0-7 frame-interp 1) f0-4)
      (set! (-> a0-7 frame-interp 0) f0-4)
      )
    (set! (-> a0-7 frame-group) (the-as art-joint-anim flamer-idle-ja))
    (set! (-> a0-7 param 0) (the float (+ (-> (the-as art-joint-anim flamer-idle-ja) frames num-frames) -1)))
    (set! (-> a0-7 param 1) 1.0)
    (set! (-> a0-7 frame-num) 0.0)
    (joint-control-channel-group! a0-7 (the-as art-joint-anim flamer-idle-ja) num-func-seek!)
    )
  (let ((a0-8 (-> self skel root-channel 2)))
    (let ((f0-9 0.0))
      (set! (-> a0-8 frame-interp 1) f0-9)
      (set! (-> a0-8 frame-interp 0) f0-9)
      )
    (set! (-> a0-8 frame-group) (the-as art-joint-anim flamer-idle-ja))
    (set! (-> a0-8 param 0) (the float (+ (-> (the-as art-joint-anim flamer-idle-ja) frames num-frames) -1)))
    (set! (-> a0-8 param 1) 1.0)
    (set! (-> a0-8 frame-num) 0.0)
    (joint-control-channel-group! a0-8 (the-as art-joint-anim flamer-idle-ja) num-func-seek!)
    )
  (until #f
    (let ((gp-0 (vector-inv-orient-by-quat!
                  (new 'stack-no-clear 'vector)
                  (-> self main-joint-vel)
                  (-> self root-override2 quat)
                  )
                )
          )
      (vector-float*! gp-0 gp-0 (/ 1.0 (-> self enemy-info-override run-travel-speed)))
      (flamer-method-188 self 1 (-> gp-0 x) 7 6)
      (flamer-method-188 self 2 (-> gp-0 z) 8 9)
      )
    (suspend)
    (ja :num! (loop!))
    (seek! (-> self sound-volume) 1.0 (* 0.5 (-> self clock seconds-per-frame)))
    )
  #f
  )

(defmethod flamer-method-184 flamer ((obj flamer))
  (with-pp
    (let ((v1-0 (-> obj ground-mode)))
      (cond
        ((= v1-0 1)
         (seek! (-> obj base-pos y) (-> obj dest-pos y) (* 40960.0 (-> pp clock seconds-per-frame)))
         )
        ((zero? v1-0)
         (let ((a1-1 (new 'stack-no-clear 'collide-query)))
           (cond
             ((enemy-method-125 obj a1-1 (collide-spec backgnd) 8192.0 26624.0 1024.0)
              (set! (-> obj base-pos y) (+ 22528.0 (-> obj root-override2 gspot-pos y)))
              )
             (else
               (let ((s4-0 (-> obj nav))
                     (s3-0 (-> obj base-pos))
                     (s5-0 (new 'stack 'nav-find-poly-parms))
                     )
                 (vector-! (-> s5-0 point) s3-0 (-> s4-0 state mesh bounds))
                 (set! (-> s5-0 y-threshold) (-> s4-0 nearest-y-threshold))
                 (set! (-> s5-0 ignore) (the-as uint 2))
                 (find-nearest-poly-to-point-local (-> s4-0 state mesh) s5-0)
                 (let ((v1-13 (-> s5-0 poly)))
                   (if v1-13
                       (set! (-> obj base-pos y) (+ 22528.0 (-> obj nav state mesh bounds y) (-> v1-13 vertex0 y)))
                       )
                   )
                 )
               )
             )
           )
         )
        )
      )
    (let ((v1-16 (+ (current-time) (the-as time-frame (-> obj sync-off)))))
      (seek!
        (-> obj root-override2 trans y)
        (+ (-> obj base-pos y) (* 1228.8 (cos (* 100.66974 (the float (mod v1-16 651))))))
        (* 16384.0 (-> pp clock seconds-per-frame))
        )
      )
    (let ((s5-2 (new 'stack-no-clear 'vector)))
      (set! (-> s5-2 quad) (-> *up-vector* quad))
      (vector-normalize! s5-2 6144.0)
      (vector/! s5-2 s5-2 (-> obj root-override2 scale))
      (vector-rotate-around-z! s5-2 s5-2 (-> obj flit-angle))
      (vector-seek! (-> obj flit-joint target) s5-2 (* 32768.0 (-> pp clock seconds-per-frame)))
      )
    (update-trans! (-> obj sound) (-> obj root-override2 trans))
    (update! (-> obj sound))
    (none)
    )
  )

(defmethod go-stare flamer ((obj flamer))
  (go-hostile obj)
  (none)
  )

(defstate wait-for-formation (flamer)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior flamer) enemy-event-handler)
  :enter (-> (method-of-type flamer idle) enter)
  :trans (-> (method-of-type flamer idle) trans)
  :code (behavior ()
    (until #f
      (let ((v1-0 (-> self formation-entity)))
        (if (if v1-0
                (-> v1-0 extra process)
                )
            (go-virtual idle)
            )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (-> (method-of-type flamer idle) post)
  )

(defstate dormant (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy dormant) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self root-override2 trans quad) (-> self idle-pos quad))
    (none)
    )
  )

(defstate dormant-aware (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy dormant-aware) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self root-override2 trans quad) (-> self idle-pos quad))
    (none)
    )
  :trans (behavior ()
    (when (and (>= (- (current-time) (-> self state-time)) (-> self state-timeout)) (flamer-method-183 self))
      (if (logtest? (enemy-option ambush) (-> self fact-info-override enemy-options))
          (go-virtual ambush)
          (go-virtual active)
          )
      )
    (none)
    )
  )

(defstate idle (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (flamer-method-190 self)
    (set! (-> self ground-mode) 0)
    0
    (none)
    )
  :trans (behavior ()
    (if (flamer-method-183 self)
        (go-virtual active)
        )
    (flamer-method-184 self)
    (none)
    )
  )

(defstate active (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self ground-mode) 0)
    0
    (none)
    )
  :trans (behavior ()
    (if (flamer-method-183 self)
        (go-virtual hostile)
        )
    (if (>= 819.2 (vector-vector-xz-distance (-> self root-override2 trans) (-> self idle-pos)))
        (go-virtual idle)
        )
    (none)
    )
  :post flamer-attack-post
  )

(defstate ambush (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy ambush) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logclear! (-> self mask) (process-mask actor-pause))
    (logclear! (-> self enemy-flags) (enemy-flag notice))
    (if (not (-> self path))
        (go-virtual notice)
        )
    (let ((v1-13 self))
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logclear (-> v1-13 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-13 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-16 self))
      (set! (-> v1-16 enemy-flags) (the-as enemy-flag (logclear (-> v1-16 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (set! (-> self flit-joint twist-min-y) (the-as float #f))
    (vector-reset! (-> self flit-joint target))
    (vector<-cspace! (-> self main-joint-pos) (-> self node-list data 3))
    (vector-reset! (-> self main-joint-vel))
    (vector-reset! (-> self main-joint-acc))
    (set! (-> self main-acceleration) 0.0)
    (vector-reset! (-> self fly-dir))
    (sound-play "flamer-ambush")
    (quaternion-copy! (-> self root-override2 quat) (-> self init-quat))
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy ambush) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (logior! (-> self mask) (process-mask actor-pause))
    (logior! (-> self enemy-flags) (enemy-flag notice))
    (set! (-> self flit-joint twist-min-y) (the-as float #t))
    (set! (-> self last-fire-time) (+ (current-time) (seconds -1.5)))
    (none)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy ambush) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (+! (-> self path-pos) (* 0.85 (-> self clock seconds-per-frame)))
    (let ((f30-0 (-> self path-pos)))
      (when (>= f30-0 1.0)
        (set! (-> self path-pos) 1.0)
        (get-point-at-percent-along-path! (-> self path) (-> self root-override2 trans) f30-0 'interp)
        (go-virtual notice)
        )
      (get-point-at-percent-along-path! (-> self path) (-> self root-override2 trans) f30-0 'interp)
      (let ((a1-3 (displacement-between-points-at-percent-normalized! (-> self path) (new 'stack-no-clear 'vector) f30-0))
            )
        (forward-up->quaternion (-> self root-override2 quat) a1-3 *up-vector*)
        )
      (flamer-method-186 self f30-0)
      )
    (none)
    )
  :code (the-as (function none :behavior flamer) flamer-fly-code)
  :post (behavior ()
    (flamer-method-187 self)
    (nav-enemy-simple-post)
    (none)
    )
  )

(defstate exit-ambush (flamer)
  :virtual #t
  :enter (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (logclear! (-> self enemy-flags) (enemy-flag notice))
    (if (not (-> self path))
        (go-virtual active)
        )
    (let ((v1-9 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-9 enemy-flags)))
          (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-9 enemy-flags))))
          )
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-9 enemy-flags))))
      (set! (-> v1-9 nav callback-info) (-> v1-9 enemy-info-override callback-info))
      )
    0
    (let ((v1-12 self))
      (set! (-> v1-12 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-12 enemy-flags))))
      )
    0
    (get-point-at-percent-along-path! (-> self path) (-> self dest-pos) 1.0 'interp)
    (let ((a0-18 (-> self nav state))
          (v1-17 (-> self dest-pos))
          )
      (logclear! (-> a0-18 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-18 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-18 target-post quad) (-> v1-17 quad))
      )
    0
    (set! (-> self ground-mode) 1)
    (none)
    )
  :trans (behavior ()
    (if (< (vector-vector-xz-distance (-> self root-override2 trans) (-> self dest-pos)) 409.6)
        (go-virtual exit-ambush-path)
        )
    (none)
    )
  :code (the-as (function none :behavior flamer) flamer-fly-code)
  :post (behavior ()
    (flamer-method-187 self)
    (flamer-flit-post)
    (none)
    )
  )

(defstate exit-ambush-path (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-0 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-3 self))
      (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logclear (-> v1-3 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (logior! (-> self mask) (process-mask actor-pause))
    (logior! (-> self enemy-flags) (enemy-flag notice))
    (none)
    )
  :trans (behavior ()
    (set! (-> self path-pos) (- (-> self path-pos) (* 0.33333334 (-> self clock seconds-per-frame))))
    (let ((f30-0 (-> self path-pos)))
      (when (>= 0.0 f30-0)
        (set! (-> self path-pos) 0.0)
        (get-point-at-percent-along-path! (-> self path) (-> self root-override2 trans) f30-0 'interp)
        (cond
          ((logtest? (enemy-option dormant) (-> self fact-info-override enemy-options))
           (go-virtual dormant)
           )
          ((logtest? (enemy-option dormant-aware) (-> self fact-info-override enemy-options))
           (go-virtual dormant-aware)
           )
          (else
            (go-virtual active)
            )
          )
        )
      (get-point-at-percent-along-path! (-> self path) (-> self base-pos) f30-0 'interp)
      (flamer-method-186 self f30-0)
      )
    (none)
    )
  :code (the-as (function none :behavior flamer) flamer-fly-code)
  :post (behavior ()
    (flamer-method-187 self)
    (when (>= (- (current-time) (-> self flit-timer)) (rand-vu-int-range (seconds 1.2) (seconds 3)))
      (set! (-> self flit-angle) (* 182.04445 (rand-vu-float-range 0.0 360.0)))
      (set! (-> self flit-timer) (current-time))
      )
    (vector-seek! (-> self root-override2 trans) (-> self base-pos) (* 16384.0 (-> self clock seconds-per-frame)))
    (flamer-method-184 self)
    (nav-enemy-simple-post)
    (none)
    )
  )

(defstate notice (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy notice) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (go-virtual hostile)
    (none)
    )
  )

(defun vector-square! ((arg0 vector) (arg1 vector))
  (set! (-> arg0 x) (* (-> arg1 x) (-> arg1 x)))
  (set! (-> arg0 y) (* (-> arg1 y) (-> arg1 y)))
  (set! (-> arg0 z) (* (-> arg1 z) (-> arg1 z)))
  arg0
  )

(defstate hostile (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (flamer-method-189 self)
    (set! (-> self ground-mode) 0)
    (set! (-> self flit-timer) (+ (current-time) (seconds -3)))
    (none)
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (when (or (not a0-1)
                (and a0-1
                     (< 491520.0 (vector-vector-distance (-> self idle-pos) (get-trans (the-as process-focusable a0-1) 0)))
                     (not (flamer-method-183 self))
                     )
                )
        (if (logtest? (enemy-option ambush) (-> self fact-info-override enemy-options))
            (go-virtual exit-ambush)
            (go-virtual active)
            )
        )
      )
    (let ((gp-1 (get-enemy-target self)))
      (if (and gp-1
               (>= (- (current-time) (-> self last-fire-time)) (the int (* 300.0 (rand-vu-float-range 3.0 6.0))))
               (< (vector-vector-distance (get-trans gp-1 3) (-> self root-override2 trans)) 245760.0)
               )
          (go-virtual attack)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior flamer) flamer-fly-code)
  :post (behavior ()
    (flamer-method-187 self)
    (flamer-flit-post)
    (none)
    )
  )

(defstate attack (flamer)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('event-attack)
       (let ((s5-0 (handle->process (-> self focus handle))))
         (when s5-0
           (let ((gp-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 9))))
             (let ((a2-1 (get-trans (the-as process-focusable s5-0) 3))
                   (s5-1 (new 'stack-no-clear 'vector))
                   )
               (setup-from-to-xz-vel! (-> self shot-trajectory) gp-0 a2-1 122880.0 -102400.0)
               (set! (-> s5-1 quad) (-> self shot-trajectory initial-velocity quad))
               (vector-normalize! s5-1 1638.4)
               (vector+! gp-0 gp-0 s5-1)
               )
             (let ((a1-6 (new 'stack-no-clear 'projectile-init-by-other-params)))
               (set! (-> a1-6 ent) (-> self entity))
               (set! (-> a1-6 charge) 1.0)
               (set! (-> a1-6 options) (projectile-options))
               (set! (-> a1-6 pos quad) (-> gp-0 quad))
               (set! (-> a1-6 vel quad) (-> self shot-trajectory initial-velocity quad))
               (set! (-> a1-6 notify-handle) (process->handle self))
               (set! (-> a1-6 owner-handle) (the-as handle #f))
               (set! (-> a1-6 ignore-handle) (process->handle self))
               (let* ((v1-21 *game-info*)
                      (a0-24 (+ (-> v1-21 attack-id) 1))
                      )
                 (set! (-> v1-21 attack-id) a0-24)
                 (set! (-> a1-6 attack-id) a0-24)
                 )
               (set! (-> a1-6 timeout) (seconds 4))
               (spawn-projectile metalhead-grenade-shot a1-6 self *default-dead-pool*)
               )
             )
           )
         )
       )
      (else
        (enemy-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (cond
      ((zero? (rand-vu-int-range 0 2))
       (ja-no-eval :group! flamer-shoot1-ja
                   :num! (seek! (the float (+ (-> (the-as art-joint-anim flamer-shoot1-ja) frames num-frames) -1)))
                   :frame-num 0.0
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      (else
        (ja-no-eval :group! flamer-shoot-ja
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim flamer-shoot-ja) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (set! (-> self last-fire-time) (current-time))
    (go-virtual hostile)
    (none)
    )
  :post flamer-attack-post
  )

(defmethod enemy-method-46 flamer ((obj flamer) (arg0 int))
  "@abstract"
  (let ((v1-0 arg0))
    (cond
      ((= v1-0 1)
       (let ((v1-2 (-> obj root-override2 root-prim)))
         (let ((a0-1 v1-2))
           (set! (-> a0-1 prim-core action) (collide-action solid deadly))
           (set! (-> a0-1 prim-core collide-with) (collide-spec backgnd jak bot obstacle hit-by-others-list player-list))
           )
         (let ((a0-2 (-> (the-as collide-shape-prim-group v1-2) child 0)))
           (set! (-> a0-2 prim-core action) (collide-action solid deadly))
           (set! (-> a0-2 prim-core collide-with) (collide-spec backgnd jak bot obstacle hit-by-others-list player-list))
           )
         )
       )
      ((or (= v1-0 2) (zero? v1-0))
       (let ((v1-8 (-> obj root-override2 root-prim)))
         (let ((a0-3 v1-8))
           (set! (-> a0-3 prim-core action) (collide-action semi-solid deadly))
           (set! (-> a0-3 prim-core collide-with) (collide-spec jak bot player-list))
           )
         (let ((a0-4 (-> (the-as collide-shape-prim-group v1-8) child 0)))
           (set! (-> a0-4 prim-core action) (collide-action semi-solid deadly))
           (set! (-> a0-4 prim-core collide-with) (collide-spec jak bot player-list))
           )
         )
       )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs symbol.
;; WARN: Using new Jak 2 rtype-of
(defmethod enemy-method-77 flamer ((obj flamer) (arg0 (pointer float)))
  (let ((v1-0 (-> obj incoming knocked-type)))
    (the-as
      symbol
      (cond
        ((= v1-0 (knocked-type knocked-type-6))
         (let* ((a0-2 '((flamer-blue-hit0-ja) (flamer-blue-hit1-ja) (flamer-blue-hit2-ja)))
                (a1-3 ((method-of-type (rtype-of a0-2) length) a0-2))
                (s4-0 (new 'static 'array uint64 3 #x12 #x13 #x14))
                (s3-0 (new 'static 'array int32 4 0 0 0 0))
                (a2-0 (ash 1 (-> s3-0 0)))
                (v1-6 (enemy-method-120 obj a1-3 a2-0))
                (s4-1 (-> obj draw art-group data (-> (the-as (pointer int32) (+ (* v1-6 8) (the-as int s4-0))))))
                )
           (set! (-> s3-0 0) v1-6)
           (let ((v1-9 (if (> (-> obj skel active-channels) 0)
                           (-> obj skel root-channel 0 frame-group)
                           )
                       )
                 )
             (if (and v1-9 (= v1-9 (-> obj draw art-group data 16)))
                 (ja-channel-push! 1 (seconds 0.17))
                 (ja-channel-push! 1 (seconds 0.02))
                 )
             )
           (let ((a0-17 (-> obj skel root-channel 0)))
             (set! (-> a0-17 frame-group) (the-as art-joint-anim s4-1))
             (set! (-> a0-17 param 0) (the float (+ (-> (the-as art-joint-anim s4-1) frames num-frames) -1)))
             (set! (-> a0-17 param 1) (-> arg0 0))
             (set! (-> a0-17 frame-num) 0.0)
             (joint-control-channel-group! a0-17 (the-as art-joint-anim s4-1) num-func-seek!)
             )
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (let ((a1-10 (-> obj draw art-group data (-> obj enemy-info-override knocked-anim)))
                (a0-21 (-> obj skel root-channel 0))
                )
            (set! (-> a0-21 frame-group) (the-as art-joint-anim a1-10))
            (set! (-> a0-21 param 0) (the float (+ (-> (the-as art-joint-anim a1-10) frames num-frames) -1)))
            (set! (-> a0-21 param 1) (-> arg0 0))
            (set! (-> a0-21 frame-num) 0.0)
            (joint-control-channel-group! a0-21 (the-as art-joint-anim a1-10) num-func-seek!)
            )
          #t
          )
        )
      )
    )
  )

(defstate knocked (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set-gravity-length (-> self root-override2 dynam) 368640.0)
    (set! (-> self hit-surface?) #f)
    (none)
    )
  :trans (behavior ()
    (let ((gp-0 (-> self root-override2)))
      (when (logtest? (-> gp-0 status) (collide-status on-surface))
        (when (not (-> self hit-surface?))
          (set! (-> self hit-surface?) #t)
          (set! (-> self surface-normal quad) (-> gp-0 poly-normal quad))
          )
        )
      (when (and (-> self hit-surface?) (zero? (-> self hit-points)))
        (let ((s4-0 (new 'stack-no-clear 'quaternion)))
          (let ((s5-0 (new 'stack-no-clear 'vector)))
            (vector-z-quaternion! s5-0 (-> gp-0 quat))
            (forward-up->quaternion s4-0 s5-0 (-> self surface-normal))
            )
          (quaternion-slerp! (-> gp-0 quat) (-> gp-0 quat) s4-0 0.25)
          )
        )
      (when (and (nonzero? (-> self hit-points))
                 (zero? (-> self fated-time))
                 (or (>= (- (current-time) (-> self state-time)) (seconds 0.5))
                     (and (< (-> self root-override2 trans y) (+ 18432.0 (-> self root-override2 gspot-pos y)))
                          (< (-> self root-override2 transv y) 0.0)
                          )
                     )
                 )
        (set-gravity-length (-> gp-0 dynam) 225280.0)
        (vector-reset! (-> gp-0 transv))
        (go-hostile self)
        )
      )
    (none)
    )
  :post (behavior ()
    (seek! (-> self sound-volume) 0.0 (* 0.5 (-> self clock seconds-per-frame)))
    (flamer-method-187 self)
    (let ((t9-2 (-> (method-of-type nav-enemy knocked) post)))
      (if t9-2
          ((the-as (function none) t9-2))
          )
      )
    (none)
    )
  )

(defstate die-falling (flamer)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root-override2 root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self hit-points) 0)
    (if (logtest? (enemy-option knocked-into-water) (-> self fact-info-override enemy-options))
        (set! (-> self enemy-flags) (logior (enemy-flag trackable-backup) (-> self enemy-flags)))
        )
    (let ((v1-8 self))
      (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-8 enemy-flags))))
      )
    0
    (let ((v1-10 self))
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logclear (-> v1-10 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-10 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (enemy-method-103 self)
    (none)
    )
  )

(defmethod dispose! flamer ((obj flamer))
  "Cleans-up the enemy and any associated resources. Potentially spawns skull gems"
  (let ((s5-1 (logtest? (enemy-flag recover-applied-velocity) (-> obj enemy-flags))))
    (let ((t9-0 (method-of-type nav-enemy dispose!)))
      (t9-0 obj)
      )
    (if (not s5-1)
        (flamer-method-190 obj)
        )
    )
  (none)
  )

(defmethod flamer-method-186 flamer ((obj flamer) (arg0 float))
  (let ((f0-1 (* (-> obj scale) arg0))
        (v0-0 (-> obj root-override2 scale))
        )
    (set! (-> v0-0 x) f0-1)
    (set! (-> v0-0 y) f0-1)
    (set! (-> v0-0 z) f0-1)
    (set! (-> v0-0 w) 1.0)
    v0-0
    )
  )

(defmethod coin-flip? flamer ((obj flamer))
  "@returns The result of a 50/50 RNG roll"
  #f
  )

(defmethod init-enemy-collision! flamer ((obj flamer))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action semi-solid deadly))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 26624.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-14 prim-core action) (collide-action semi-solid deadly))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 3481.6)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-16 prim-core action) (collide-action semi-solid deadly))
      (set! (-> v1-16 transform-index) 19)
      (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 3072.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-18 prim-core action) (collide-action deadly))
      (set! (-> v1-18 transform-index) 6)
      (set-vector! (-> v1-18 local-sphere) 0.0 0.0 0.0 3072.0)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-20 prim-core action) (collide-action deadly))
      (set! (-> v1-20 transform-index) 9)
      (set-vector! (-> v1-20 local-sphere) 0.0 0.0 0.0 3072.0)
      )
    (set! (-> s5-0 nav-radius) 6144.0)
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 3))
    (set! (-> obj root-override2) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch process-drawable vs flamer.
(defmethod relocate flamer ((obj flamer) (arg0 int))
  (if (nonzero? (-> obj flit-joint))
      (&+! (-> obj flit-joint) arg0)
      )
  (the-as
    flamer
    ((the-as (function process-drawable int process-drawable) (find-parent-method flamer 7)) obj arg0)
    )
  )

(defmethod init-enemy! flamer ((obj flamer))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-flamer" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-enemy-behaviour-and-stats! obj *flamer-nav-enemy-info*)
  (set! (-> obj neck up) (the-as uint 1))
  (set! (-> obj neck nose) (the-as uint 2))
  (set! (-> obj neck ear) (the-as uint 0))
  (set! (-> obj scale) 1.6)
  (flamer-method-186 obj 1.0)
  (logclear! (-> obj nav flags) (nav-control-flag limit-rotation-rate))
  (set! (-> obj sync-off) (the-as uint (get-rand-int obj 600)))
  (set! (-> obj flit-angle) 0.0)
  (set! (-> obj flit-timer) 0)
  (set! (-> obj root-override2 dynam gravity y) 225280.0)
  (set! (-> obj root-override2 dynam gravity-length) 225280.0)
  (set! (-> obj root-override2 dynam gravity-max) 225280.0)
  (let ((v1-25 (-> obj root-override2 trans)))
    (set! (-> obj base-pos quad) (-> v1-25 quad))
    (set! (-> v1-25 y) (+ 22528.0 (-> v1-25 y)))
    (set! (-> obj idle-pos quad) (-> v1-25 quad))
    )
  (set! (-> obj flit-joint) (the-as joint-mod (new 'process 'joint-mod-set-local obj 3 #t #f #f)))
  (set! (-> obj flit-joint twist-min-y) (the-as float #t))
  (let ((f0-7 (res-lump-float (-> obj entity) 'rotoffset)))
    (if (!= f0-7 0.0)
        (quaternion-rotate-y! (-> obj root-override2 quat) (-> obj root-override2 quat) f0-7)
        )
    )
  (let ((f0-8 (quaternion-y-angle (-> obj root-override2 quat))))
    (matrix-rotate-y! (-> obj zone-to-world) f0-8)
    )
  (set! (-> obj zone-to-world trans quad) (-> obj root-override2 trans quad))
  (matrix-inverse-of-rot-trans! (-> obj world-to-zone) (-> obj zone-to-world))
  (set! (-> obj formation-entity) (entity-actor-lookup (-> obj entity) 'alt-actor 0))
  (set-vector! (-> obj offset) 0.0 0.0 94208.0 1.0)
  (set! (-> obj path) (new 'process 'path-control obj 'intro 0.0 (-> obj entity) #f))
  (set! (-> obj path-pos) 0.0)
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "flamer-loop" :fo-max 80) (-> obj root-override2 trans))
        )
  (set! (-> obj enemy-flags) (logior (enemy-flag multi-focus) (-> obj enemy-flags)))
  (let ((v1-45 (-> obj nav)))
    (set! (-> v1-45 sphere-mask) (the-as uint 0))
    )
  0
  (let ((v1-47 (-> obj nav)))
    (set! (-> v1-47 nearest-y-threshold) 63488.0)
    )
  0
  (quaternion-copy! (-> obj init-quat) (-> obj root-override2 quat))
  (add-connection
    *part-engine*
    obj
    19
    obj
    318
    (new 'static 'vector :x 819.2 :y -1187.84 :z 2088.96 :w 163840.0)
    )
  (add-connection
    *part-engine*
    obj
    19
    obj
    318
    (new 'static 'vector :x -819.2 :y -1187.84 :z 2088.96 :w 163840.0)
    )
  (add-connection *part-engine* obj 9 obj 768 (new 'static 'vector :w 163840.0))
  0
  (none)
  )

(defmethod go-idle flamer ((obj flamer))
  (if (-> obj formation-entity)
      (go (method-of-object obj wait-for-formation))
      (go (method-of-object obj idle))
      )
  0
  (none)
  )
