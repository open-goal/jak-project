;;-*-Lisp-*-
(in-package goal)

;; name: hover-enemy.gc
;; name in dgo: hover-enemy
;; dgos: FOR, DMI, FRA, STR, NEB, D3A, UNB

;; DECOMP BEGINS

(defmethod general-event-handler ((this hover-enemy) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (local-vars (v1-41 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (case arg2
      (('hit 'hit-knocked 'hit-flinch)
       (logclear! (-> this mask) (process-mask actor-pause))
       (logclear! (-> this focus-status) (focus-status dangerous))
       (logclear! (-> this enemy-flags) (enemy-flag use-notice-distance))
       (logior! (-> this enemy-flags) (enemy-flag alert))
       (logior! (-> this focus-status) (focus-status hit))
       (if (zero? (-> this hit-points))
           (logior! (-> this focus-status) (focus-status dead))
           )
       (logclear! (-> this enemy-flags) (enemy-flag lock-focus))
       (enemy-method-62 this)
       (logior! (-> this enemy-flags) (enemy-flag lock-focus))
       (process-contact-action arg0)
       (send-event arg0 'get-attack-count 1)
       (cond
         ((zero? (-> this hit-points))
          (if (rnd-percent? this 0.4)
              (go (method-of-object this flying-death))
              (go (method-of-object this flying-death-explode))
              )
          )
         (else
           (go (method-of-object this knocked))
           )
         )
       #t
       )
      (('update-formation)
       (let ((s5-1 (the-as object (-> arg3 param 0))))
         (let* ((f0-0 409.6)
                (f0-2 (* f0-0 f0-0))
                )
           (.lvf vf1 (&-> (vector-! (new 'stack-no-clear 'vector) (the-as vector s5-1) (-> this offset)) quad))
           (.add.w.vf vf2 vf0 vf0 :mask #b1)
           (.mul.vf vf1 vf1 vf1)
           (.mul.x.vf acc vf2 vf1 :mask #b1)
           (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
           (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
           (.mov v1-41 vf1)
           (if (< f0-2 v1-41)
               (hover-nav-control-method-21 (-> this hover))
               )
           )
         (let ((v0-7 (the-as object (-> this offset))))
           (set! (-> (the-as vector v0-7) quad) (-> (the-as vector s5-1) quad))
           v0-7
           )
         )
       )
      (('get-hover-nav-sphere)
       (if (not (and (-> this next-state) (let ((v1-49 (-> this next-state name)))
                                            (or (= v1-49 'dormant) (= v1-49 'dormant-aware))
                                            )
                     )
                )
           (-> (the-as collide-shape-prim-group (-> this root root-prim))
               child
               (-> this hover params nav-collide-prim-index)
               prim-core
               )
           )
       )
      (else
        ((method-of-type enemy general-event-handler) this arg0 arg1 arg2 arg3)
        )
      )
    )
  )

(defbehavior hover-enemy-dest-post hover-enemy ()
  (local-vars (at-0 int) (at-1 int))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (hover-nav-control-method-16 (-> self hover) (new 'stack-no-clear 'vector)))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (vector-flatten! gp-0 a1-1 *y-vector*)
      (let ((f28-0 (lerp-scale -10922.667 10922.667 (-> gp-0 z) -1.0 1.0))
            (f30-0 (lerp-scale 10922.667 -10922.667 (-> gp-0 x) -1.0 1.0))
            )
        (set! (-> self rotation-vec x) (deg-seek (-> self rotation-vec x) f28-0 (* 5461.3335 (seconds-per-frame))))
        (set! (-> self rotation-vec z) (deg-seek (-> self rotation-vec z) f30-0 (* 6371.5557 (seconds-per-frame))))
        )
      )
    (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) (-> self focus-pos) (-> self root trans))))
      (vector-normalize! s4-1 1.0)
      (set! (-> self rotation-vec y)
            (deg-seek (-> self rotation-vec y) (vector-y-angle s4-1) (* 14563.556 (seconds-per-frame)))
            )
      )
    (hover-enemy-method-146 self)
    (hover-nav-control-method-12 (-> self hover))
    (enemy-simple-post)
    (let ((a0-14
            (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self hover-info main-joint)))
            )
          (v1-18 (new 'stack-no-clear 'vector))
          )
      (let ((a1-10 (new 'stack-no-clear 'vector)))
        (vector-! v1-18 a0-14 (-> self main-joint-pos))
        (let ((a2-7 v1-18))
          (.lvf vf1 (&-> v1-18 quad))
          (let ((f0-14 (-> self clock frames-per-second)))
            (.mov at-0 f0-14)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> a2-7 quad) vf1)
          )
        (vector-! a1-10 v1-18 (-> self main-joint-vel))
        (let ((a2-9 (-> self main-joint-acc)))
          (.lvf vf1 (&-> a1-10 quad))
          (let ((f0-15 (-> self clock frames-per-second)))
            (.mov at-1 f0-15)
            )
          (.mov vf2 at-1)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> a2-9 quad) vf1)
          )
        )
      (set! (-> self main-joint-pos quad) (-> a0-14 quad))
      (set! (-> self main-joint-vel quad) (-> v1-18 quad))
      )
    0
    (hover-enemy-method-142 self)
    0
    (none)
    )
  )

(defbehavior hover-enemy-hostile-post hover-enemy ()
  (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
    (set! (-> a1-0 from) (process->ppointer self))
    (set! (-> a1-0 num-params) 0)
    (set! (-> a1-0 message) 'get-formation)
    (let* ((t9-0 send-event-function)
           (v1-2 (-> self formation-entity))
           (a0-2 (the-as hover-formation (t9-0
                                           (if v1-2
                                               (-> v1-2 extra process)
                                               )
                                           a1-0
                                           )
                         )
                 )
           (gp-0 (-> self dest-pos))
           )
      (cond
        (a0-2
          (hover-formation-method-15 a0-2 gp-0 (-> self offset))
          )
        (else
          (let* ((s5-0 (handle->process (-> self focus handle)))
                 (a0-7 (if (type? s5-0 process-focusable)
                           s5-0
                           )
                       )
                 )
            (cond
              (a0-7
                (let* ((s5-1 (get-trans (the-as process-focusable a0-7) 3))
                       (a0-9 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) s5-1))
                       )
                  (vector+! gp-0 s5-1 (vector-rotate-y! (new 'stack-no-clear 'vector) (-> self offset) (vector-y-angle a0-9)))
                  )
                )
              (else
                (set! (-> gp-0 quad) (-> self root trans quad))
                )
              )
            )
          )
        )
      (hover-nav-control-method-11 (-> self hover) gp-0)
      )
    )
  (hover-enemy-dest-post)
  (none)
  )

(defmethod hover-enemy-method-142 ((this hover-enemy))
  0
  (none)
  )

(defmethod hover-enemy-method-153 ((this hover-enemy))
  (let* ((v1-0 (-> this formation-entity))
         (a0-1 (if v1-0
                   (-> v1-0 extra process)
                   )
               )
         )
    (if a0-1
        (send-event a0-1 'join)
        )
    )
  0
  (none)
  )

(defmethod hover-enemy-method-154 ((this hover-enemy))
  (let* ((v1-0 (-> this formation-entity))
         (a0-1 (if v1-0
                   (-> v1-0 extra process)
                   )
               )
         )
    (if a0-1
        (send-event a0-1 'leave)
        )
    )
  0
  (none)
  )

(defmethod coin-flip? ((this hover-enemy))
  "@returns The result of a 50/50 RNG roll"
  #f
  )

(defmethod hover-enemy-method-144 ((this hover-enemy))
  (set! (-> this main-joint-pos quad) (-> this root trans quad))
  (set! (-> this main-joint-vel quad) (the-as uint128 0))
  (set! (-> this main-joint-acc quad) (the-as uint128 0))
  (set! (-> this thrust 0) 0.0)
  (set! (-> this thrust 1) 0.0)
  0
  (none)
  )

(defmethod hover-enemy-method-145 ((this hover-enemy) (arg0 int) (arg1 float) (arg2 int) (arg3 int))
  (local-vars (v1-1 int))
  0
  (if (< 0.0 arg1)
      (set! v1-1 arg2)
      (set! v1-1 arg3)
      )
  (let ((a3-5 (-> this skel root-channel arg0)))
    (let ((f0-2 (fabs arg1)))
      (set! (-> a3-5 frame-interp 1) f0-2)
      (set! (-> a3-5 frame-interp 0) f0-2)
      )
    (set! (-> a3-5 frame-group) (the-as art-joint-anim (-> this draw art-group data v1-1)))
    (set! (-> a3-5 param 0) 0.0)
    (set! (-> a3-5 frame-num) (-> this skel root-channel 0 frame-num))
    (joint-control-channel-group! a3-5 (the-as art-joint-anim (-> this draw art-group data v1-1)) num-func-chan)
    )
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod enemy-method-129 ((this hover-enemy))
  (local-vars (s5-0 vector))
  (let ((t9-0 (method-of-type enemy enemy-method-129)))
    (t9-0 this)
    )
  (let ((a0-3 (handle->process (-> this focus handle))))
    (set! s5-0 (when a0-3
                 (set! s5-0 (-> this focus-pos))
                 (set! (-> s5-0 quad) (-> (get-trans (the-as process-focusable a0-3) 3) quad))
                 s5-0
                 )
          )
    )
  (none)
  )

(defmethod common-post ((this hover-enemy))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (hover-enemy-method-148 this)
  (enemy-method-129 this)
  (let ((t9-2 (method-of-type enemy common-post)))
    (t9-2 this)
    )
  (hover-nav-control-method-13 (-> this hover))
  (none)
  )

(defmethod hover-enemy-method-148 ((this hover-enemy))
  (cond
    ((and (-> this draw shadow) (logtest? (-> this draw status) (draw-control-status on-screen)))
     (new 'stack-no-clear 'vector)
     (new 'stack-no-clear 'vector)
     (let ((s4-0 (new 'stack-no-clear 'collide-query))
           (gp-0 (-> this draw shadow-ctrl settings shadow-dir))
           (f30-0 122880.0)
           )
       (set! (-> s4-0 start-pos quad) (-> this root trans quad))
       (vector-normalize-copy! (-> s4-0 move-dist) gp-0 f30-0)
       (let ((v1-10 s4-0))
         (set! (-> v1-10 radius) 2048.0)
         (set! (-> v1-10 collide-with) (collide-spec backgnd))
         (set! (-> v1-10 ignore-process0) this)
         (set! (-> v1-10 ignore-process1) #f)
         (set! (-> v1-10 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
         (set! (-> v1-10 action-mask) (collide-action solid))
         )
       (let ((f0-1 (fill-and-probe-using-line-sphere *collide-cache* s4-0)))
         (cond
           ((>= f0-1 0.0)
            (let ((v1-14 (-> this draw shadow-ctrl)))
              (logclear! (-> v1-14 settings flags) (shadow-flags disable-draw))
              )
            0
            (-> s4-0 best-other-tri intersect)
            (let ((a1-3 (-> this root trans)))
              (-> a1-3 y)
              (let ((f0-2 (* f0-1 f30-0)))
                (shadow-control-method-14
                  (-> this draw shadow-ctrl)
                  a1-3
                  gp-0
                  (- (+ 81920.0 f30-0))
                  (+ -12288.0 f0-2)
                  (+ 12288.0 f0-2)
                  )
                )
              )
            )
           (else
             (let ((v1-25 (-> this draw shadow-ctrl)))
               (logior! (-> v1-25 settings flags) (shadow-flags disable-draw))
               )
             0
             )
           )
         )
       )
     )
    (else
      (let ((v1-28 (-> this draw shadow-ctrl)))
        (logior! (-> v1-28 settings flags) (shadow-flags disable-draw))
        )
      0
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
;; WARN: new jak 2 until loop case, check carefully
(defbehavior hover-enemy-fly-code hover-enemy ()
  (let ((gp-0 (-> self draw art-group data (-> self enemy-info idle-anim))))
    (cond
      ((-> self restart-fly-anims)
       (ja-channel-push! 3 (seconds 0.2))
       (ja-no-eval :group! gp-0 :num! (seek! max (-> self fly-anim-speed)) :frame-num 0.0)
       (let ((a0-4 (-> self skel root-channel 1)))
         (let ((f0-4 0.0))
           (set! (-> a0-4 frame-interp 1) f0-4)
           (set! (-> a0-4 frame-interp 0) f0-4)
           )
         (set! (-> a0-4 frame-group) (the-as art-joint-anim gp-0))
         (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)))
         (set! (-> a0-4 param 1) (-> self fly-anim-speed))
         (set! (-> a0-4 frame-num) 0.0)
         (joint-control-channel-group! a0-4 (the-as art-joint-anim gp-0) num-func-seek!)
         )
       (let ((a0-5 (-> self skel root-channel 2)))
         (let ((f0-9 0.0))
           (set! (-> a0-5 frame-interp 1) f0-9)
           (set! (-> a0-5 frame-interp 0) f0-9)
           )
         (set! (-> a0-5 frame-group) (the-as art-joint-anim gp-0))
         (set! (-> a0-5 param 0) (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)))
         (set! (-> a0-5 param 1) (-> self fly-anim-speed))
         (set! (-> a0-5 frame-num) 0.0)
         (joint-control-channel-group! a0-5 (the-as art-joint-anim gp-0) num-func-seek!)
         )
       (set! (-> self restart-fly-anims) #f)
       )
      (else
        (ja-no-eval :group! gp-0 :num! (loop! (-> self fly-anim-speed)))
        (let ((a0-7 (-> self skel root-channel 1)))
          (let ((f0-15 0.0))
            (set! (-> a0-7 frame-interp 1) f0-15)
            (set! (-> a0-7 frame-interp 0) f0-15)
            )
          (set! (-> a0-7 frame-group) (the-as art-joint-anim gp-0))
          (set! (-> a0-7 param 0) (-> self fly-anim-speed))
          (joint-control-channel-group! a0-7 (the-as art-joint-anim gp-0) num-func-loop!)
          )
        (let ((a0-8 (-> self skel root-channel 2)))
          (let ((f0-17 0.0))
            (set! (-> a0-8 frame-interp 1) f0-17)
            (set! (-> a0-8 frame-interp 0) f0-17)
            )
          (set! (-> a0-8 frame-group) (the-as art-joint-anim gp-0))
          (set! (-> a0-8 param 0) (-> self fly-anim-speed))
          (joint-control-channel-group! a0-8 (the-as art-joint-anim gp-0) num-func-loop!)
          )
        (ja :num! (loop!))
        )
      )
    )
  (until #f
    (let ((s5-0 (hover-nav-control-method-16 (-> self hover) (new 'stack-no-clear 'vector)))
          (gp-1 (-> self hover-info))
          )
      (seek! (-> self local-dir x) (-> s5-0 x) (* 1.3 (seconds-per-frame)))
      (seek! (-> self local-dir z) (-> s5-0 z) (* 1.3 (seconds-per-frame)))
      (hover-enemy-method-145 self 1 (-> self local-dir x) (-> gp-1 fly-left-anim) (-> gp-1 fly-right-anim))
      (hover-enemy-method-145 self 2 (-> self local-dir z) (-> gp-1 fly-forward-anim) (-> gp-1 fly-backward-anim))
      )
    (suspend)
    (ja :num! (loop! (-> self fly-anim-speed)))
    )
  #f
  (none)
  )

(defstate ambush (hover-enemy)
  :virtual #t
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (hover-enemy-method-140 self #f)
    (if (logtest? (-> self path flags) (path-control-flag not-found))
        (go process-drawable-art-error "no path")
        )
    (set! (-> self scale-timer) (the-as uint (current-time)))
    (cond
      ((not (logtest? (-> self fact enemy-options) (enemy-option user0)))
       (logclear! (-> self enemy-flags) (enemy-flag vulnerable))
       (hover-enemy-method-141 self 0.0)
       )
      (else
        (hover-enemy-method-141 self 1.0)
        )
      )
    (let* ((gp-0 *target*)
           (s1-0 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           (gp-1 (new 'stack-no-clear 'vector))
           (s2-0 (new 'stack-no-clear 'vector))
           (s4-0 (-> self root))
           (s5-0 (get-point-at-percent-along-path! (-> self path) (new 'stack-no-clear 'vector) 0.0 'interp))
           )
      (let ((s0-0 (get-point-at-percent-along-path! (-> self path) (new 'stack-no-clear 'vector) 1.0 'interp))
            (s3-1
              (-> (the-as collide-shape-prim-group (-> self root root-prim))
                  child
                  (-> (hover-enemy-method-152 self) nav-collide-prim-index)
                  local-sphere
                  )
              )
            )
        (if s1-0
            (set! (-> self focus-pos quad) (-> (get-trans s1-0 3) quad))
            (set! (-> self focus-pos quad) (-> s0-0 quad))
            )
        (vector-! s2-0 (-> self focus-pos) (-> s4-0 trans))
        (vector-normalize! s2-0 1.0)
        (set-vector! (-> self rotation-vec) (- (vector-x-angle s2-0)) (vector-y-angle s2-0) 0.0 0.0)
        (hover-enemy-method-146 self)
        (set! (-> s4-0 trans quad) (-> s5-0 quad))
        (if (logtest? (-> self fact enemy-options) (enemy-option user0))
            (vector-!
              (-> s4-0 trans)
              (-> s4-0 trans)
              (vector-orient-by-quat! (new 'stack-no-clear 'vector) s3-1 (-> s4-0 quat))
              )
            )
        )
      (displacement-between-points-at-percent-normalized! (-> self path) gp-1 0.0)
      (hover-nav-control-method-10
        (-> self hover)
        s5-0
        gp-1
        (vector-normalize-copy! (new 'stack-no-clear 'vector) gp-1 (* 0.8 (-> self hover params max-speed)))
        )
      )
    (hover-enemy-method-144 self)
    (hover-nav-control-method-18 (-> self hover) (-> self path) -1 -1)
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (local-vars (v1-5 enemy-flag))
    (hover-nav-control-method-20 (-> self hover))
    (hover-enemy-method-140 self #t)
    (let ((v1-4 (-> self enemy-flags)))
      (if (logtest? v1-4 (enemy-flag vulnerable-backup))
          (set! v1-5 (logior v1-4 (enemy-flag vulnerable)))
          (set! v1-5 (logclear v1-4 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-5)
    (hover-enemy-method-153 self)
    )
  :trans (behavior ()
    (when (hover-nav-control-method-23 (-> self hover))
      (hover-enemy-method-153 self)
      (if (not (logtest? (-> self fact enemy-options) (enemy-option user0)))
          (hover-enemy-method-141 self 1.0)
          )
      (go-virtual hostile)
      )
    )
  :code hover-enemy-fly-code
  :post (behavior ()
    (local-vars (v1-19 enemy-flag))
    (when (not (logtest? (-> self fact enemy-options) (enemy-option user0)))
      (let ((f0-1 (the float (- (current-time) (the-as int (-> self scale-timer)))))
            (f1-0 1200.0)
            )
        (when (< f0-1 f1-0)
          (let ((f30-0 (fmin 1.0 (/ (+ 30.0 f0-1) f1-0))))
            (hover-enemy-method-141 self f30-0)
            (when (and (not (logtest? (-> self enemy-flags) (enemy-flag vulnerable))) (>= f30-0 1.0))
              (let ((v1-18 (-> self enemy-flags)))
                (if (logtest? v1-18 (enemy-flag vulnerable-backup))
                    (set! v1-19 (logior v1-18 (enemy-flag vulnerable)))
                    (set! v1-19 (logclear v1-18 (enemy-flag vulnerable)))
                    )
                )
              (set! (-> self enemy-flags) v1-19)
              )
            )
          )
        )
      )
    (hover-nav-control-method-11 (-> self hover) (the-as vector #f))
    (hover-enemy-dest-post)
    )
  )

(defstate notice (hover-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy notice) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (a0-0 *target*)
          (s5-0 (-> self root trans))
          )
      (if a0-0
          (vector-normalize! (vector-! gp-0 (get-trans a0-0 3) s5-0) 1.0)
          (vector-z-quaternion! gp-0 (-> self root quat))
          )
      (hover-nav-control-method-10 (-> self hover) s5-0 gp-0 (the-as vector #t))
      )
    (hover-enemy-method-144 self)
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type enemy notice) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (hover-enemy-method-153 self)
    )
  )

(defstate hostile (hover-enemy)
  :virtual #t
  :code hover-enemy-fly-code
  :post hover-enemy-hostile-post
  )

(defstate knocked (hover-enemy)
  :virtual #t
  :enter (behavior ()
    (let* ((t9-0 find-parent-method)
           (a0-0 hover-enemy)
           (t9-1 (-> (the-as state (t9-0 a0-0 30)) enter))
           )
      (if t9-1
          ((the-as (function enemy none) t9-1) (the-as enemy a0-0))
          )
      )
    (set! (-> self hit-surface?) #f)
    (set! (-> self knocked-start-level) (-> self root trans y))
    )
  :exit (behavior ()
    (let ((t9-1 (-> (the-as state (find-parent-state)) exit)))
      (if t9-1
          (t9-1)
          )
      )
    (set! (-> self hit-surface?) #f)
    )
  :trans (behavior ()
    (let ((gp-0 (-> self root)))
      (when (logtest? (-> gp-0 status) (collide-status on-surface))
        (when (not (-> self hit-surface?))
          (set! (-> self hit-surface?) #t)
          (set! (-> self surface-normal quad) (-> gp-0 poly-normal quad))
          )
        )
      (when (and (-> self hit-surface?) (zero? (-> self hit-points)))
        (let ((s4-0 (new 'stack-no-clear 'quaternion)))
          (let ((s5-0 (new 'stack-no-clear 'vector)))
            (vector-z-quaternion! s5-0 (-> gp-0 quat))
            (forward-up->quaternion s4-0 s5-0 (-> self surface-normal))
            )
          (quaternion-slerp! (-> gp-0 quat) (-> gp-0 quat) s4-0 0.25)
          )
        )
      )
    (if (and (nonzero? (-> self hit-points))
             (zero? (-> self fated-time))
             (time-elapsed? (-> self state-time) (seconds 0.5))
             (< (-> self root trans y) (- (-> self knocked-start-level) (-> self knocked-fall-dist)))
             )
        (go-virtual knocked-recover)
        )
    )
  )

(defstate knocked-recover (hover-enemy)
  :virtual #t
  :event enemy-event-handler
  :code (behavior ()
    (local-vars (v1-38 enemy-flag) (v1-46 enemy-flag))
    (ja-channel-push! 1 (seconds 0.5))
    (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info knocked-land-anim))
                :num! (seek!)
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (set! (-> self restart-fly-anims) #t)
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-37 (-> self enemy-flags)))
      (if (logtest? v1-37 (enemy-flag vulnerable-backup))
          (set! v1-38 (logior v1-37 (enemy-flag vulnerable)))
          (set! v1-38 (logclear v1-37 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-38)
    (if (logtest? (-> self enemy-flags) (enemy-flag attackable-backup))
        (logior! (-> self mask) (process-mask collectable))
        (logclear! (-> self mask) (process-mask collectable))
        )
    (let ((v1-45 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-45)
          (set! v1-46 (logior (enemy-flag trackable) v1-45))
          (set! v1-46 (logclear v1-45 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-46)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self focus-status) (focus-status hit))
    (hover-nav-control-method-21 (-> self hover))
    (go-hostile self)
    )
  :post hover-enemy-hostile-post
  )

(defstate flying-death (hover-enemy)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch 'touched 'attack)
       (if (time-elapsed? (-> self state-time) (seconds 0.5))
           (go-virtual flying-death-explode)
           )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (dying self)
    (stop-looking-at-target! self)
    (logior! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self mask) (process-mask actor-pause))
    (logclear! (-> self focus-status) (focus-status dangerous))
    (logclear! (-> self enemy-flags) (enemy-flag trackable))
    (set! (-> self root penetrate-using) (penetrate lunge vehicle knocked))
    (let ((gp-0 (-> self flying-death-transv)))
      (let ((a1-0 (handle->process (-> self incoming attacker-handle))))
        (if a1-0
            (vector-! gp-0 (-> (the-as process-focusable a1-0) root trans) (-> self root trans))
            (vector-! gp-0 (-> self incoming attacker-pos) (-> self root trans))
            )
        )
      (set! (-> gp-0 y) 0.0)
      (vector-normalize! gp-0 1.0)
      (vector-rotate90-around-y! gp-0 gp-0)
      (if (rnd-percent? self 0.5)
          (vector-negate! gp-0 gp-0)
          )
      (let ((f30-0 (rnd-float-range self 0.0 1.0)))
        (vector-float*! gp-0 gp-0 (lerp 98304.0 172032.0 f30-0))
        (set! (-> gp-0 y) (lerp 8192.0 98304.0 f30-0))
        )
      (let ((v1-29 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat))))
        (cond
          ((< 0.0 (vector-dot gp-0 v1-29))
           (set! (-> self flying-death-anim) (-> self hover-info fly-left-anim))
           (set! (-> self flying-death-engine) (-> self hover-info engine-left))
           (set! (-> self flying-death-thrust-rotate) (-> self hover-info thrust-rotate-left))
           (set! (-> self flying-death-spin-dest) -524288.0)
           )
          (else
            (set! (-> self flying-death-anim) (-> self hover-info fly-right-anim))
            (set! (-> self flying-death-engine) (-> self hover-info engine-right))
            (set! (-> self flying-death-thrust-rotate) (-> self hover-info thrust-rotate-right))
            (set! (-> self flying-death-spin-dest) 524288.0)
            )
          )
        )
      )
    (set! (-> self flying-death-spin-axis quad) (-> *y-vector* quad))
    (vector-rotate-x!
      (-> self flying-death-spin-axis)
      (-> self flying-death-spin-axis)
      (* 182.04445 (rand-vu-float-range -120.0 120.0))
      )
    (set-gravity-length (-> self root dynam) 163840.0)
    (set! (-> self hover speed) 0.2)
    (set! (-> self flying-death-spin) 0.0)
    (enemy-method-103 self)
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (if (or (logtest? (-> self root status)
                      (collide-status touch-surface touch-wall touch-ceiling touch-actor impact-surface touch-background)
                      )
            (time-elapsed? (-> self state-time) (seconds 4))
            )
        (go-virtual flying-death-explode)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self flying-death-anim)) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (seek! (-> self flying-death-spin) (-> self flying-death-spin-dest) (* 196608.0 (seconds-per-frame)))
    (let ((gp-0 (-> self root)))
      (let ((a2-2
              (quaternion-vector-angle!
                (new 'stack-no-clear 'quaternion)
                (-> self flying-death-spin-axis)
                (* (-> self flying-death-spin) (seconds-per-frame))
                )
              )
            )
        (quaternion*! (-> gp-0 quat) (-> gp-0 quat) a2-2)
        )
      (vector-v++!
        (-> self flying-death-transv)
        (compute-acc-due-to-gravity gp-0 (new 'stack-no-clear 'vector) 0.8)
        )
      (let ((v1-6 (hover-enemy-method-152 self)))
        (seek!
          (-> self hover speed)
          (* 2.0 (-> v1-6 max-speed))
          (* 0.8 (seconds-per-frame) (-> v1-6 max-acceleration))
          )
        )
      (vector-normalize-copy! (-> gp-0 transv) (-> self flying-death-transv) (-> self hover speed))
      (let ((a2-8 (new 'stack-no-clear 'collide-query)))
        (set! (-> a2-8 collide-with) (-> gp-0 root-prim prim-core collide-with))
        (set! (-> a2-8 ignore-process0) (-> gp-0 process))
        (set! (-> a2-8 ignore-process1) #f)
        (set! (-> a2-8 ignore-pat) (-> gp-0 pat-ignore-mask))
        (set! (-> a2-8 action-mask) (collide-action solid))
        (fill-cache-integrate-and-collide gp-0 (-> gp-0 transv) a2-8 (meters 0))
        )
      )
    (enemy-simple-post)
    (hover-enemy-method-143 self (-> self flying-death-engine) (-> self flying-death-thrust-rotate))
    )
  )

(defstate flying-death-explode (hover-enemy)
  :virtual #t
  :enter (behavior ()
    (dying self)
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defmethod go-stare ((this hover-enemy))
  (go-hostile this)
  )

(defmethod go-stare2 ((this hover-enemy))
  (go-hostile this)
  )

;; WARN: Return type mismatch quaternion vs none.
(defmethod hover-enemy-method-146 ((this hover-enemy))
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (matrix-rotate-zxy! gp-0 (-> this rotation-vec))
    (matrix->quaternion (-> this root quat) gp-0)
    )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod hover-enemy-method-147 ((this hover-enemy))
  (let ((s5-0 (-> this root quat))
        (gp-0 (-> this rotation-vec))
        )
    (set! (-> gp-0 z) (quaternion-z-angle s5-0))
    (set! (-> gp-0 y) (quaternion-y-angle s5-0))
    (set! (-> gp-0 x) (quaternion-x-angle s5-0))
    )
  (none)
  )

(defmethod hover-enemy-method-140 ((this hover-enemy) (arg0 symbol))
  (let ((v1-0 0)
        (a0-2 (-> this root root-prim))
        )
    (if arg0
        (set! v1-0 1)
        )
    (set! (-> (the-as collide-shape-prim-group a0-2) child 0 prim-core collide-with) (the-as collide-spec v1-0))
    (set! (-> (the-as collide-shape-prim-group a0-2) child 1 prim-core collide-with) (the-as collide-spec v1-0))
    (set! (-> (the-as collide-shape-prim-group a0-2) child 2 prim-core collide-with) (the-as collide-spec v1-0))
    )
  0
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod hover-enemy-method-141 ((this hover-enemy) (arg0 float))
  (let ((f0-1 (* (-> this scale) arg0)))
    (set-vector! (-> this root scale) (* 1.2 f0-1) (* 0.9 f0-1) f0-1 1.0)
    )
  (none)
  )

(defmethod dying ((this hover-enemy))
  "Cleans-up the enemy and any associated resources. Potentially spawns skull gems"
  (when (not (logtest? (enemy-flag called-dying) (-> this enemy-flags)))
    (process-entity-status! this (entity-perm-status subtask-complete) #t)
    (send-event (ppointer->process (-> this parent)) 'hover-die)
    (hover-enemy-method-154 this)
    ((method-of-type enemy dying) this)
    )
  (none)
  )

(defmethod deactivate ((this hover-enemy))
  (hover-nav-control-method-9 (-> this hover))
  ((method-of-type enemy deactivate) this)
  (none)
  )

;; WARN: Return type mismatch enemy vs hover-enemy.
(defmethod relocate ((this hover-enemy) (arg0 int))
  (if (nonzero? (-> this hover))
      (&+! (-> this hover) arg0)
      )
  (the-as hover-enemy ((method-of-type enemy relocate) this arg0))
  )

(defmethod hover-enemy-method-155 ((this hover-enemy))
  (set! (-> this hover-info) (hover-enemy-method-151 this))
  (set! (-> this fly-anim-speed) (rnd-float-range this 0.8 1.2))
  (vector-reset! (-> this rotation-vec))
  (vector-reset! (-> this dest-pos))
  (vector-reset! (-> this local-dir))
  (set! (-> this scale) 1.0)
  (hover-enemy-method-141 this 1.0)
  (set! (-> this formation-entity) (entity-actor-lookup (-> this entity) 'alt-actor 0))
  (logior! (-> this skel status) (joint-control-status sync-math))
  (let ((t0-0 (hover-enemy-method-152 this)))
    (set! (-> this hover) (new 'process 'hover-nav-control this (-> this root) t0-0))
    )
  (let ((s5-0 (-> this offset))
        (t9-6 (method-of-type res-lump get-property-struct))
        (a0-8 (-> this entity))
        (a1-4 'trans-offset)
        (a2-3 'interp)
        (a3-1 -1000000000.0)
        (t0-1 (new 'stack-no-clear 'vector))
        )
    (set! (-> t0-1 x) 0.0)
    (set! (-> t0-1 y) 20480.0)
    (set! (-> t0-1 z) 61440.0)
    (set! (-> t0-1 w) 1.0)
    (set! (-> s5-0 quad)
          (-> (the-as vector (t9-6 a0-8 a1-4 a2-3 a3-1 t0-1 (the-as (pointer res-tag) #f) *res-static-buf*)) quad)
          )
    )
  (set! (-> this restart-fly-anims) #t)
  (set! (-> this knocked-fall-dist) 8192.0)
  0
  (none)
  )

(deftype wasp (hover-enemy)
  ((gun-jmod               joint-mod)
   (entity-group           actor-group)
   (smoke-part             sparticle-launch-control)
   (engine-part            sparticle-launch-control)
   (old-gravity            float   :offset 804)
   (knocked-anim           int32)
   (knocked-recover-anim   int32)
   (last-fire-time         time-frame)
   (bridge-index           int32)
   (gun-x-angle            float)
   (gun-x-angle-final      float)
   (path-u                 float)
   (path-du                float)
   (path-du-final          float)
   (path-dest              float)
   (plat-pos               vector  :inline)
   (sound-id               sound-id)
   (attack-wait-min        float)
   (attack-wait-max        float)
   (attack-miss-dist-min   float)
   (attack-miss-dist-max   float)
   (attack-miss-dist-curr  float)
   )
  (:state-methods
    shoot-bridge-wait
    shoot-bridge-intro
    shoot-bridge-hold
    shoot-bridge-hostile
    shoot-bridge-attack
    shoot-bridge-outro
    attack
    die-now
    die-explode
    )
  (:methods
    (spawn-wasp-shot (_type_ projectile-init-by-other-params int float float) none)
    )
  )
