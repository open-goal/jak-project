;;-*-Lisp-*-
(in-package goal)

;; name: hover-nav-edit.gc
;; name in dgo: hover-nav-edit
;; dgos: FOR, DMI, FRA, STR, NEB, D3A, UNB

;; DECOMP BEGINS

;; this file is debug only
(declare-file (debug))

(defun probe-for-clear-collision? ((arg0 vector) (arg1 vector))
  (let ((s5-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> s5-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> s5-0 move-dist) arg1 arg0)
    (let ((v1-2 s5-0))
      (set! (-> v1-2 radius) 4096.0)
      (set! (-> v1-2 collide-with) (collide-spec backgnd))
      (set! (-> v1-2 ignore-process0) #f)
      (set! (-> v1-2 ignore-process1) #f)
      (set! (-> v1-2 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-2 action-mask) (collide-action solid))
      )
    (when (< (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (set! (-> s4-0 quad) (-> arg0 quad))
        (let* ((f0-2 (vector-vector-distance s4-0 arg1))
               (s3-1 (+ (the int (* 0.000008138021 f0-2)) 1))
               (s2-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 move-dist) 110592.0))
               )
          (dotimes (s1-0 s3-1)
            (set! (-> s5-0 start-pos quad) (-> s4-0 quad))
            (vector-! (-> s5-0 move-dist) arg1 s4-0)
            (if (< 122880.0 (vector-length (-> s5-0 move-dist)))
                (vector-normalize! (-> s5-0 move-dist) 122880.0)
                )
            (let ((v1-15 s5-0))
              (set! (-> v1-15 radius) 12288.0)
              (set! (-> v1-15 collide-with) (collide-spec backgnd))
              (set! (-> v1-15 ignore-process0) #f)
              (set! (-> v1-15 ignore-process1) #f)
              (set! (-> v1-15 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-15 action-mask) (collide-action solid))
              )
            (if (>= (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
                (return #f)
                )
            (vector+! s4-0 s4-0 s2-0)
            )
          )
        )
      #t
      )
    )
  )

(defun hover-nav-graph-process-points ()
  (local-vars (v1-10 symbol))
  (let ((v1-0 (get-nav-graph-editor)))
    (when v1-0
      (let* ((gp-0 (-> v1-0 nav-graph))
             (s5-0 (-> gp-0 node-array length))
             )
        (dotimes (s4-0 s5-0)
          (let ((s3-0 (+ (the-as uint (-> gp-0 node-array data 0 position)) (* 80 s4-0))))
            (when (< s4-0 (+ s5-0 -1))
              (let ((s2-0 (+ s4-0 1)))
                (while (< s2-0 s5-0)
                  (let ((s1-0 (+ (the-as uint (-> gp-0 node-array data 0 position)) (* 80 s2-0))))
                    (dotimes (v1-8 (-> gp-0 edge-array length))
                      (let* ((a1-1 (-> gp-0 edge-array data v1-8))
                             (a0-8 (-> a1-1 runtime-node-id-1))
                             (a1-2 (-> a1-1 runtime-node-id-2))
                             )
                        (when (or (and (= s4-0 a0-8) (= s2-0 a1-2)) (and (= s4-0 a1-2) (= s2-0 a0-8)))
                          (set! v1-10 #t)
                          (goto cfg-19)
                          )
                        )
                      )
                    (set! v1-10 #f)
                    (label cfg-19)
                    (when (not v1-10)
                      (when (and (< (vector-vector-distance (the-as vector s3-0) (the-as vector s1-0)) 122880.0)
                                 (probe-for-clear-collision? (the-as vector s3-0) (the-as vector s1-0))
                                 (probe-for-clear-collision? (the-as vector s1-0) (the-as vector s3-0))
                                 )
                        (let ((v1-17 (alloc-new-edge! gp-0)))
                          (when (!= v1-17 -1)
                            (let ((v1-20 (-> gp-0 edge-array data v1-17)))
                              (set! (-> v1-20 runtime-node-id-1) s4-0)
                              (set! (-> v1-20 runtime-node-id-2) s2-0)
                              (set! (-> v1-20 directionality) (nav-directionality bi_directional))
                              (set! (-> v1-20 speed_limit) 122880.0)
                              (set! (-> v1-20 density) 1.0)
                              (set! (-> v1-20 traffic_edge_flag) 0)
                              (set! (-> v1-20 nav_clock_mask) (nav-clock-mask))
                              (set! (-> v1-20 nav_clock_type) (nav-clock-type no-clock))
                              (set! (-> v1-20 width) 0.0)
                              (set! (-> v1-20 minimap_edge_flag) (nav-minimap-edge-flag))
                              )
                            0
                            )
                          )
                        )
                      )
                    )
                  (+! s2-0 1)
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defun hover-nav-graph-output ()
  (local-vars
    (sv-16 int)
    (sv-32 (function _varargs_ object))
    (sv-48 symbol)
    (sv-64 string)
    (sv-80 int)
    (sv-96 (function _varargs_ object))
    (sv-112 symbol)
    (sv-128 string)
    )
  (let ((v1-0 (get-nav-graph-editor)))
    (when v1-0
      (let* ((gp-0 (-> v1-0 nav-graph))
             (s5-0 (-> gp-0 node-array length))
             (s4-0 0)
             )
        (dotimes (s3-0 s5-0)
          (when (nonzero? (-> gp-0 node-array data s3-0 nav_node_id))
            (let ((s2-0 (the-as object (+ (the-as uint (-> gp-0 node-array data 0 position)) (* 80 s3-0)))))
              (format
                #t
                "(~d (~m ~m ~m) ("
                s4-0
                (-> (the-as vector s2-0) x)
                (-> (the-as vector s2-0) y)
                (-> (the-as vector s2-0) z)
                )
              (dotimes (s1-0 (-> gp-0 edge-array length))
                (let* ((v1-11 (-> gp-0 edge-array data s1-0))
                       (s0-0 (-> v1-11 runtime-node-id-1))
                       )
                  (set! sv-16 (-> v1-11 runtime-node-id-2))
                  (when (= s3-0 s0-0)
                    (let ((a1-2 (+ (the-as uint (-> gp-0 node-array data 0 position)) (* 80 sv-16))))
                      (set! sv-32 format)
                      (set! sv-48 #t)
                      (set! sv-64 "(~d ~m) ")
                      (set! sv-80 sv-16)
                      (let ((a3-1 (vector-vector-distance (the-as vector s2-0) (the-as vector a1-2))))
                        (sv-32 sv-48 sv-64 sv-80 a3-1)
                        )
                      )
                    )
                  (when (= s3-0 sv-16)
                    (let ((a1-4 (+ (the-as uint (-> gp-0 node-array data 0 position)) (* 80 s0-0))))
                      (set! sv-96 format)
                      (set! sv-112 #t)
                      (set! sv-128 "(~d ~m) ")
                      (let ((a3-2 (vector-vector-distance (the-as vector s2-0) (the-as vector a1-4))))
                        (sv-96 sv-112 sv-128 s0-0 a3-2)
                        )
                      )
                    )
                  )
                )
              )
            (format #t "))~%")
            (+! s4-0 1)
            )
          )
        )
      #f
      )
    )
  )

(define *axes-table* (new 'static 'boxed-array :type vector
                       (new 'static 'vector :x 1.0 :w 1.0)
                       (new 'static 'vector :y 1.0 :w 1.0)
                       (new 'static 'vector :z 1.0 :w 1.0)
                       )
        )

(deftype hover-nav-bsp-point (list-node)
  ((index int32          :offset-assert   8)
   (pos   vector :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  (:methods
    (new (symbol type) _type_ 0)
    )
  )


;; WARN: Return type mismatch structure vs hover-nav-bsp-point.
(defmethod new hover-nav-bsp-point ((allocation symbol) (type-to-make type))
  (let ((t9-0 (method-of-type structure new))
        (v1-1 type-to-make)
        )
    (-> type-to-make size)
    (let ((v0-0 (t9-0 allocation v1-1)))
      (set! (-> (the-as hover-nav-bsp-point v0-0) next) #f)
      (set! (-> (the-as hover-nav-bsp-point v0-0) prev) #f)
      (the-as hover-nav-bsp-point v0-0)
      )
    )
  )

(deftype hover-nav-bsp-node (structure)
  ((split-plane vector              :inline :offset-assert   0)
   (point-list  hover-nav-bsp-point         :offset-assert  16)
   (left        hover-nav-bsp-node          :offset-assert  20)
   (right       hover-nav-bsp-node          :offset-assert  24)
   )
  :method-count-assert 11
  :size-assert         #x1c
  :flag-assert         #xb0000001c
  (:methods
    (new (symbol type) _type_ 0)
    (hover-nav-bsp-node-method-9 (_type_) none 9)
    (hover-nav-bsp-node-method-10 (_type_ int) none 10)
    )
  )


;; WARN: Return type mismatch structure vs hover-nav-bsp-node.
(defmethod new hover-nav-bsp-node ((allocation symbol) (type-to-make type))
  (let ((t9-0 (method-of-type structure new))
        (v1-1 type-to-make)
        )
    (-> type-to-make size)
    (let ((v0-0 (t9-0 allocation v1-1)))
      (set! (-> (the-as hover-nav-bsp-node v0-0) point-list) #f)
      (set! (-> (the-as hover-nav-bsp-node v0-0) left) #f)
      (set! (-> (the-as hover-nav-bsp-node v0-0) right) #f)
      (the-as hover-nav-bsp-node v0-0)
      )
    )
  )

(deftype hover-nav-bsp (structure)
  ((root hover-nav-bsp-node  :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(defmethod hover-nav-bsp-node-method-9 hover-nav-bsp-node ((obj hover-nav-bsp-node))
  (let ((v1-0 (-> obj split-plane)))
    (format #t "((~,,1f ~,,1f ~,,1f ~m)~% " (-> v1-0 x) (-> v1-0 y) (-> v1-0 z) (-> v1-0 w))
    )
  (let ((v1-2 (the-as list-node (-> obj point-list))))
    (while v1-2
      (let ((s5-0 (-> v1-2 next)))
        (format
          #t
          "(~d (~m ~m ~m)) "
          (-> (the-as hover-nav-bsp-point v1-2) index)
          (-> (the-as hover-nav-bsp-point v1-2) pos x)
          (-> (the-as hover-nav-bsp-point v1-2) pos y)
          (-> (the-as hover-nav-bsp-point v1-2) pos z)
          )
        (set! v1-2 s5-0)
        )
      )
    )
  (if (-> obj left)
      (hover-nav-bsp-node-method-9 (-> obj left))
      )
  (if (-> obj right)
      (hover-nav-bsp-node-method-9 (-> obj right))
      )
  (format #t ")~%")
  0
  (none)
  )

(defmethod hover-nav-bsp-node-method-10 hover-nav-bsp-node ((obj hover-nav-bsp-node) (arg0 int))
  (when (-> obj point-list)
    (format 0 "build-bsp: ")
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s3-0 0)
          )
      (let ((v1-2 (the-as list-node (-> obj point-list))))
        (while v1-2
          (set! v1-2 (-> v1-2 next))
          (+! s3-0 1)
          )
        )
      (format 0 "count ~d ~%" s3-0)
      (when (< 1 s3-0)
        (vector-reset! s4-0)
        (let ((f0-1 (/ 1.0 (the float s3-0)))
              (a2-1 (the-as list-node (-> obj point-list)))
              )
          (while a2-1
            (let ((v1-9 (-> a2-1 next)))
              (vector+float*! s4-0 s4-0 (the-as vector (+ (the-as uint a2-1) 16)) f0-1)
              (set! a2-1 v1-9)
              )
            )
          )
        (set! (-> obj split-plane quad) (-> *axes-table* arg0 quad))
        (set! (-> obj split-plane w) (- (vector-dot s4-0 (-> obj split-plane))))
        (let ((s3-1 (the-as list-node (-> obj point-list))))
          (while s3-1
            (let ((s4-1 (-> s3-1 next)))
              (let ((f0-7 (- (vector-dot (the-as vector (+ (the-as uint s3-1) 16)) (-> obj split-plane)))))
                (cond
                  ((= f0-7 (-> obj split-plane w))
                   )
                  ((< f0-7 (-> obj split-plane w))
                   (if (not (-> obj left))
                       (set! (-> obj left) (new 'global 'hover-nav-bsp-node))
                       )
                   (let ((v1-21 s3-1))
                     (let ((a0-12 (&-> obj point-list)))
                       (if (= (-> a0-12 0) v1-21)
                           (set! (-> a0-12 0) (the-as hover-nav-bsp-point (-> v1-21 next)))
                           )
                       )
                     (if (-> v1-21 prev)
                         (set! (-> v1-21 prev next) (-> v1-21 next))
                         )
                     (if (-> v1-21 next)
                         (set! (-> v1-21 next prev) (-> v1-21 prev))
                         )
                     (set! (-> v1-21 prev) #f)
                     (set! (-> v1-21 next) #f)
                     )
                   (let ((a0-19 (-> obj left point-list))
                         (v1-25 (&-> (-> obj left) point-list))
                         )
                     (when (zero? s3-1)
                       (break!)
                       0
                       )
                     (when (or (= s3-1 a0-19) (= s3-1 v1-25))
                       (break!)
                       0
                       )
                     (when (not (or (not a0-19) (!= (-> a0-19 prev) s3-1)))
                       (break!)
                       0
                       )
                     (when a0-19
                       (set! (-> s3-1 next) a0-19)
                       (set! (-> s3-1 prev) (-> a0-19 prev))
                       (if (-> s3-1 prev)
                           (set! (-> s3-1 prev next) s3-1)
                           )
                       (if (-> s3-1 next)
                           (set! (-> s3-1 next prev) s3-1)
                           )
                       )
                     (if (or (not a0-19) (= a0-19 (-> v1-25 0)))
                         (set! (-> v1-25 0) (the-as hover-nav-bsp-point s3-1))
                         )
                     )
                   )
                  (else
                    (if (not (-> obj right))
                        (set! (-> obj right) (new 'global 'hover-nav-bsp-node))
                        )
                    (let ((v1-30 s3-1))
                      (let ((a0-22 (&-> obj point-list)))
                        (if (= (-> a0-22 0) v1-30)
                            (set! (-> a0-22 0) (the-as hover-nav-bsp-point (-> v1-30 next)))
                            )
                        )
                      (if (-> v1-30 prev)
                          (set! (-> v1-30 prev next) (-> v1-30 next))
                          )
                      (if (-> v1-30 next)
                          (set! (-> v1-30 next prev) (-> v1-30 prev))
                          )
                      (set! (-> v1-30 prev) #f)
                      (set! (-> v1-30 next) #f)
                      )
                    (let ((v1-32 s3-1)
                          (a1-40 (-> obj right point-list))
                          (a0-31 (&-> (-> obj right) point-list))
                          )
                      (when (zero? v1-32)
                        (break!)
                        0
                        )
                      (when (or (= v1-32 a1-40) (= v1-32 a0-31))
                        (break!)
                        0
                        )
                      (when (not (or (not a1-40) (!= (-> a1-40 prev) v1-32)))
                        (break!)
                        0
                        )
                      (when a1-40
                        (set! (-> v1-32 next) a1-40)
                        (set! (-> v1-32 prev) (-> a1-40 prev))
                        (if (-> v1-32 prev)
                            (set! (-> v1-32 prev next) v1-32)
                            )
                        (if (-> v1-32 next)
                            (set! (-> v1-32 next prev) v1-32)
                            )
                        )
                      (if (or (not a1-40) (= a1-40 (-> a0-31 0)))
                          (set! (-> a0-31 0) (the-as hover-nav-bsp-point v1-32))
                          )
                      )
                    )
                  )
                )
              (set! s3-1 s4-1)
              )
            )
          )
        (if (-> obj left)
            (hover-nav-bsp-node-method-10 (-> obj left) (mod (+ arg0 1) 3))
            )
        (if (-> obj right)
            (hover-nav-bsp-node-method-10 (-> obj right) (mod (+ arg0 1) 3))
            )
        )
      )
    )
  0
  (none)
  )

(define *hover-bsp* (the-as hover-nav-bsp #f))

(defun hover-nav-graph-output-bsp ()
  (let ((v1-0 (get-nav-graph-editor)))
    (when v1-0
      (let ((s5-0 (-> v1-0 nav-graph))
            (gp-0 (new 'global 'hover-nav-bsp))
            )
        (let ((s4-0 (-> s5-0 node-array length))
              (s3-0 0)
              )
          (set! (-> gp-0 root) (new 'global 'hover-nav-bsp-node))
          (dotimes (s2-0 s4-0)
            (when (nonzero? (-> s5-0 node-array data s2-0 nav_node_id))
              (let ((v1-9 (new 'global 'hover-nav-bsp-point)))
                (set! (-> v1-9 index) s3-0)
                (set! (-> v1-9 pos quad)
                      (-> (the-as (pointer uint128) (+ (the-as uint (-> s5-0 node-array data 0 position)) (* 80 s2-0))))
                      )
                (let ((a1-7 (-> gp-0 root point-list))
                      (a0-8 (&-> (-> gp-0 root) point-list))
                      )
                  (when (zero? v1-9)
                    (break!)
                    0
                    )
                  (when (or (= v1-9 a1-7) (= v1-9 a0-8))
                    (break!)
                    0
                    )
                  (when (not (or (not a1-7) (!= (-> a1-7 prev) v1-9)))
                    (break!)
                    0
                    )
                  (when a1-7
                    (set! (-> v1-9 next) a1-7)
                    (set! (-> v1-9 prev) (-> a1-7 prev))
                    (if (-> v1-9 prev)
                        (set! (-> v1-9 prev next) v1-9)
                        )
                    (if (-> v1-9 next)
                        (set! (-> v1-9 next prev) v1-9)
                        )
                    )
                  (if (or (not a1-7) (= a1-7 (-> a0-8 0)))
                      (set! (-> a0-8 0) v1-9)
                      )
                  )
                )
              (+! s3-0 1)
              )
            )
          )
        (hover-nav-bsp-node-method-10 (-> gp-0 root) 0)
        (set! *hover-bsp* gp-0)
        gp-0
        )
      )
    )
  )

(defun hover-nav-network-build-bsp ((arg0 (array hover-nav-bsp-point)))
  (let ((gp-0 (new 'global 'hover-nav-bsp)))
    (let ((s4-0 (-> arg0 length))
          (s3-0 0)
          )
      (set! (-> gp-0 root) (new 'global 'hover-nav-bsp-node))
      (dotimes (s2-0 s4-0)
        (let ((v1-3 (new 'global 'hover-nav-bsp-point)))
          (set! (-> v1-3 index) (the-as int (-> arg0 s2-0 next)))
          (set! (-> v1-3 pos quad) (-> arg0 s2-0 pos quad))
          (let ((a1-8 (-> gp-0 root point-list))
                (a0-11 (&-> (-> gp-0 root) point-list))
                )
            (when (zero? v1-3)
              (break!)
              0
              )
            (when (or (= v1-3 a1-8) (= v1-3 a0-11))
              (break!)
              0
              )
            (when (not (or (not a1-8) (!= (-> a1-8 prev) v1-3)))
              (break!)
              0
              )
            (when a1-8
              (set! (-> v1-3 next) a1-8)
              (set! (-> v1-3 prev) (-> a1-8 prev))
              (if (-> v1-3 prev)
                  (set! (-> v1-3 prev next) v1-3)
                  )
              (if (-> v1-3 next)
                  (set! (-> v1-3 next prev) v1-3)
                  )
              )
            (if (or (not a1-8) (= a1-8 (-> a0-11 0)))
                (set! (-> a0-11 0) v1-3)
                )
            )
          )
        (+! s3-0 1)
        )
      )
    (hover-nav-bsp-node-method-10 (-> gp-0 root) 0)
    (set! *hover-bsp* gp-0)
    gp-0
    )
  )

;; WARN: Return type mismatch object vs none.
(defun hover-nav-bsp-output ((arg0 hover-nav-bsp))
  (format #t "(")
  (hover-nav-bsp-node-method-9 (-> arg0 root))
  (format #t ")~%")
  (none)
  )
