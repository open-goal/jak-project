;;-*-Lisp-*-
(in-package goal)

;; name: hover-nav-control.gc
;; name in dgo: hover-nav-control
;; dgos: FOR, DMI, FRA, STR, NEB, D3A, UNB

;; DECOMP BEGINS

(define *debug-hover* #f)

(deftype nav-network-control (process)
  ((nav-network nav-network  :offset-assert 128)
   )
  :heap-base #x10
  :method-count-assert 15
  :size-assert         #x84
  :flag-assert         #xf00100084
  (:methods
    (idle () _type_ :state 14)
    )
  )


(defstate idle (nav-network-control)
  :virtual #t
  :code (the-as (function none :behavior nav-network-control) sleep-code)
  :post (behavior ()
    (nav-network-method-29 (-> self nav-network))
    (nav-network-method-27 (-> self nav-network))
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior nav-network-control-init-by-other nav-network-control ((arg0 nav-network) (arg1 level))
  (set! (-> self nav-network) arg0)
  (set! (-> self level) arg1)
  (logior! (-> self mask) (process-mask no-kill))
  (go-virtual idle)
  (none)
  )

;; ERROR: function has no type analysis. Cannot decompile.

;; ERROR: function has no type analysis. Cannot decompile.

(defmethod new nav-network ((allocation symbol) (type-to-make type))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 dummy index) 0)
    (set! (-> gp-0 dummy count) 0)
    (vector-reset! (-> gp-0 dummy pos))
    (set! (-> gp-0 network) (the-as (array nav-network-info) (-> gp-0 dummy)))
    (dotimes (v1-4 5)
      (set! (-> gp-0 list-table v1-4) #f)
      )
    (nav-network-method-12 gp-0)
    (set! (-> gp-0 control-handle) (the-as handle #f))
    gp-0
    )
  )

(defmethod nav-network-method-9 nav-network ((obj nav-network))
  (set! (-> obj segment-pool) (the-as (pointer hover-nav-path-segment) (malloc 'loading-level #x6000)))
  (set! (-> obj free-segment-list) #f)
  (dotimes (v1-0 256)
    (let ((a0-3 (&+ (-> obj segment-pool) (* 96 v1-0))))
      (set! (-> a0-3 0) #f)
      (set! (-> a0-3 1) #f)
      (let ((a2-0 (-> obj free-segment-list))
            (a1-3 (&-> obj free-segment-list))
            )
        (when (zero? a0-3)
          (break!)
          0
          )
        (when (or (= a0-3 a2-0) (= a0-3 a1-3))
          (break!)
          0
          )
        (when (not (or (not a2-0) (!= (-> a2-0 prev) a0-3)))
          (break!)
          0
          )
        (when a2-0
          (set! (-> a0-3 0) a2-0)
          (set! (-> a0-3 1) (the-as hover-nav-path-segment (-> a2-0 prev)))
          (if (-> a0-3 1)
              (set! (-> a0-3 1 next) (the-as list-node a0-3))
              )
          (if (-> a0-3 0)
              (set! (-> a0-3 0 prev) (the-as list-node a0-3))
              )
          )
        (if (or (not a2-0) (= a2-0 (-> a1-3 0)))
            (set! (-> a1-3 0) (the-as hover-nav-path-segment a0-3))
            )
        )
      )
    )
  (set! (-> obj sphere-pool) (the-as (pointer hover-nav-sphere) (malloc 'loading-level 768)))
  (set! (-> obj free-sphere-list) #f)
  (dotimes (v1-3 16)
    (let ((a0-6 (&+ (-> obj sphere-pool) (* 48 v1-3))))
      (set! (-> a0-6 0) #f)
      (set! (-> a0-6 1) #f)
      (let ((a2-4 (-> obj free-sphere-list))
            (a1-7 (&-> obj free-sphere-list))
            )
        (when (zero? a0-6)
          (break!)
          0
          )
        (when (or (= a0-6 a2-4) (= a0-6 a1-7))
          (break!)
          0
          )
        (when (not (or (not a2-4) (!= (-> a2-4 prev) a0-6)))
          (break!)
          0
          )
        (when a2-4
          (set! (-> a0-6 0) a2-4)
          (set! (-> a0-6 1) (the-as hover-nav-sphere (-> a2-4 prev)))
          (if (-> a0-6 1)
              (set! (-> a0-6 1 next) (the-as list-node a0-6))
              )
          (if (-> a0-6 0)
              (set! (-> a0-6 0 prev) (the-as list-node a0-6))
              )
          )
        (if (or (not a2-4) (= a2-4 (-> a1-7 0)))
            (set! (-> a1-7 0) (the-as hover-nav-sphere a0-6))
            )
        )
      )
    )
  0
  (none)
  )

(defmethod nav-network-method-10 nav-network ((obj nav-network) (arg0 level) (arg1 (array nav-network-info)))
  (set! (-> obj network) arg1)
  (while (-> obj sphere-list)
    (let ((v1-0 (-> obj sphere-list)))
      (let ((a0-1 v1-0))
        (let ((a1-1 (&-> obj sphere-list)))
          (if (= (-> a1-1 0) a0-1)
              (set! (-> a1-1 0) (the-as hover-nav-sphere (-> a0-1 next)))
              )
          )
        (if (-> a0-1 prev)
            (set! (-> a0-1 prev next) (-> a0-1 next))
            )
        (if (-> a0-1 next)
            (set! (-> a0-1 next prev) (-> a0-1 prev))
            )
        (set! (-> a0-1 prev) #f)
        (set! (-> a0-1 next) #f)
        )
      (let ((a1-8 (-> obj free-sphere-list))
            (a0-3 (&-> obj free-sphere-list))
            )
        (when (zero? v1-0)
          (break!)
          0
          )
        (when (or (= v1-0 a1-8) (= v1-0 a0-3))
          (break!)
          0
          )
        (when (not (or (not a1-8) (!= (-> a1-8 prev) v1-0)))
          (break!)
          0
          )
        (when a1-8
          (set! (-> v1-0 next) a1-8)
          (set! (-> v1-0 prev) (-> a1-8 prev))
          (if (-> v1-0 prev)
              (set! (-> v1-0 prev next) v1-0)
              )
          (if (-> v1-0 next)
              (set! (-> v1-0 next prev) v1-0)
              )
          )
        (if (or (not a1-8) (= a1-8 (-> a0-3 0)))
            (set! (-> a0-3 0) v1-0)
            )
        )
      )
    )
  (if (not (handle->process (-> obj control-handle)))
      (set! (-> obj control-handle)
            (process->handle (the-as process (ppointer->process (process-spawn nav-network-control obj arg0))))
            )
      )
  0
  (none)
  )

(defmethod nav-network-method-12 nav-network ((obj nav-network))
  (set! (-> obj open-list) #f)
  (set! (-> obj closed-list) #f)
  (let ((v1-0 (-> obj network)))
    (when v1-0
      (dotimes (a0-2 (-> v1-0 length))
        (let ((a1-3 (-> v1-0 a0-2 path-node)))
          (set! (-> a1-3 status) (net-path-node-status))
          (set! (-> a1-3 parent) #f)
          (set! (-> a1-3 next) #f)
          (set! (-> a1-3 prev) #f)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod nav-network-method-28 nav-network ((obj nav-network))
  (dotimes (s5-0 2)
    (format #t "list ~d: ~%" s5-0)
    (let ((a0-2 (-> obj list-table s5-0)))
      (while a0-2
        (let ((s4-0 (-> a0-2 next)))
          (inspect a0-2)
          (set! a0-2 s4-0)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod nav-network-method-29 nav-network ((obj nav-network))
  (when *display-nav-network*
    (let ((gp-0 (-> obj network)))
      (when gp-0
        (dotimes (s5-0 (-> gp-0 length))
          (let ((s4-0 (-> gp-0 s5-0)))
            (add-debug-x #t (bucket-id debug2) (-> s4-0 pos) *color-white*)
            (format (clear *temp-string*) "~d" s5-0)
            (let ((a2-2 *temp-string*))
              (add-debug-text-3d #t (bucket-id debug2) a2-2 (-> s4-0 pos) (font-color white) (the-as vector2h #f))
              )
            (dotimes (s3-1 (-> s4-0 count))
              (let ((a2-3 (new 'stack-no-clear 'vector)))
                (set! (-> a2-3 quad) (-> s4-0 pos quad))
                (let ((a3-2 (new 'stack-no-clear 'vector)))
                  (set! (-> a3-2 quad) (-> gp-0 (-> s4-0 adjacency s3-1 index) pos quad))
                  (add-debug-line
                    #t
                    (bucket-id debug2)
                    a2-3
                    a3-2
                    (new 'static 'rgba :r #x7f :g #xff :b #x7f :a #x10)
                    #f
                    (the-as rgba -1)
                    )
                  )
                )
              )
            )
          )
        #f
        )
      )
    )
  )

(defmethod nav-network-method-15 nav-network ((obj nav-network) (arg0 nav-network-path-node))
  (local-vars (a2-4 list-node))
  (when (nonzero? (-> arg0 status))
    (break!)
    0
    )
  (let ((f0-1 (+ (-> arg0 cost-to-start) (-> arg0 cost-to-end))))
    (when (not (and (not (-> arg0 next)) (not (-> arg0 prev))))
      (break!)
      0
      )
    (let ((v1-8 (the-as list-node (-> obj open-list))))
      (while v1-8
        (let ((a2-1 (-> v1-8 next)))
          (if (= v1-8 arg0)
              (return #t)
              )
          (set! v1-8 a2-1)
          )
        )
      )
    (when #f
      (break!)
      0
      )
    (logior! (-> arg0 status) (net-path-node-status open))
    (let ((v1-17 (the-as list-node (-> obj open-list))))
      (while v1-17
        (let ((a2-3 (-> v1-17 next)))
          (when (< f0-1 (+ (-> (the-as nav-network-path-node v1-17) cost-to-start)
                           (-> (the-as nav-network-path-node v1-17) cost-to-end)
                           )
                   )
            (set! a2-4 v1-17)
            (goto cfg-23)
            )
          (set! v1-17 a2-3)
          )
        )
      )
    )
  (set! a2-4 (the-as list-node #f))
  (label cfg-23)
  (cond
    (a2-4
      (let ((v1-20 arg0)
            (a0-1 (-> obj list-table))
            )
        (when (zero? v1-20)
          (break!)
          0
          )
        (when (or (= v1-20 a2-4) (= v1-20 a0-1))
          (break!)
          0
          )
        (when (not (or (not a2-4) (!= (-> (the-as nav-network-path-node a2-4) prev) v1-20)))
          (break!)
          0
          )
        (when a2-4
          (set! (-> v1-20 next) a2-4)
          (set! (-> v1-20 prev) (-> (the-as nav-network-path-node a2-4) prev))
          (if (-> v1-20 prev)
              (set! (-> v1-20 prev next) v1-20)
              )
          (if (-> v1-20 next)
              (set! (-> v1-20 next prev) v1-20)
              )
          )
        (if (or (not a2-4) (= a2-4 (-> a0-1 0)))
            (set! (-> a0-1 0) v1-20)
            )
        )
      )
    (else
      (let ((a2-8 (the-as list-node #f)))
        (let ((v1-21 (the-as list-node (-> obj open-list))))
          (while v1-21
            (let ((a3-22 (-> v1-21 next)))
              (set! a2-8 v1-21)
              (set! v1-21 a3-22)
              )
            )
          )
        (let ((v1-23 arg0)
              (a0-2 (-> obj list-table))
              )
          (when (or (= v1-23 a2-8) (= v1-23 a0-2))
            (break!)
            0
            )
          (when (not (or (not a2-8) (!= (-> (the-as nav-network-path-node a2-8) next) v1-23)))
            (break!)
            0
            )
          (cond
            (a2-8
              (set! (-> v1-23 next) (-> (the-as nav-network-path-node a2-8) next))
              (set! (-> v1-23 prev) a2-8)
              (if (-> v1-23 prev)
                  (set! (-> v1-23 prev next) v1-23)
                  )
              (if (-> v1-23 next)
                  (set! (-> v1-23 next prev) v1-23)
                  )
              )
            (else
              (set! (-> v1-23 next) (-> a0-2 0))
              (set! (-> v1-23 prev) #f)
              (if (-> v1-23 next)
                  (set! (-> v1-23 next prev) v1-23)
                  )
              (set! (-> a0-2 0) v1-23)
              )
            )
          )
        )
      )
    )
  arg0
  )

;; WARN: Return type mismatch nav-network-path-node vs none.
(defmethod nav-network-method-13 nav-network ((obj nav-network) (arg0 int) (arg1 nav-network-path-node))
  (when (nonzero? (-> arg1 status))
    (break!)
    0
    )
  (let ((v1-3 arg1)
        (a3-2 (-> obj list-table arg0))
        (a0-2 (the-as object (&+ (-> obj list-table) (* arg0 4))))
        )
    (when (zero? v1-3)
      (break!)
      0
      )
    (when (or (= v1-3 a3-2) (= v1-3 (the-as (pointer list-node) a0-2)))
      (break!)
      0
      )
    (when (not (or (not a3-2) (!= (-> a3-2 prev) v1-3)))
      (break!)
      0
      )
    (when a3-2
      (set! (-> v1-3 next) a3-2)
      (set! (-> v1-3 prev) (-> a3-2 prev))
      (if (-> v1-3 prev)
          (set! (-> v1-3 prev next) v1-3)
          )
      (if (-> v1-3 next)
          (set! (-> v1-3 next prev) v1-3)
          )
      )
    (if (or (not a3-2) (= a3-2 (-> (the-as list-node a0-2) next)))
        (set! (-> (the-as list-node a0-2) next) v1-3)
        )
    )
  (none)
  )

(defmethod nav-network-method-14 nav-network ((obj nav-network) (arg0 int) (arg1 nav-network-path-node))
  (let ((v1-0 arg1))
    (let ((a3-1 (the-as list-node (&+ (-> obj list-table) (* arg0 4)))))
      (if (= (-> a3-1 next) v1-0)
          (set! (-> a3-1 next) (-> v1-0 next))
          )
      )
    (if (-> v1-0 prev)
        (set! (-> v1-0 prev next) (-> v1-0 next))
        )
    (if (-> v1-0 next)
        (set! (-> v1-0 next prev) (-> v1-0 prev))
        )
    (set! (-> v1-0 prev) #f)
    (set! (-> v1-0 next) #f)
    )
  (let ((v1-4 (-> obj list-table arg0)))
    (while v1-4
      (let ((a0-2 (-> v1-4 next)))
        (if (= v1-4 arg1)
            (return #t)
            )
        (set! v1-4 a0-2)
        )
      )
    )
  (when #f
    (break!)
    0
    )
  (when (not (and (not (-> arg1 next)) (not (-> arg1 prev))))
    (break!)
    0
    )
  (set! (-> arg1 status) (net-path-node-status))
  0
  )

;; WARN: Return type mismatch object vs none.
(defmethod nav-network-method-16 nav-network ((obj nav-network) (arg0 nav-network-path-node))
  (nav-network-method-14 obj 0 arg0)
  (none)
  )

(defmethod nav-network-method-17 nav-network ((obj nav-network))
  (let ((gp-0 (-> obj open-list)))
    (if gp-0
        (nav-network-method-16 obj gp-0)
        (set! gp-0 (the-as nav-network-path-node #f))
        )
    gp-0
    )
  )

;; WARN: Return type mismatch net-path-node-status vs none.
(defmethod nav-network-method-18 nav-network ((obj nav-network) (arg0 nav-network-path-node))
  (nav-network-method-13 obj 1 arg0)
  (logior! (-> arg0 status) (net-path-node-status closed))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod nav-network-method-19 nav-network ((obj nav-network) (arg0 nav-network-path-node))
  (nav-network-method-14 obj 1 arg0)
  (none)
  )

(defmethod nav-network-method-20 nav-network ((obj nav-network) (arg0 nav-network-path-node) (arg1 vector))
  (let* ((s3-0 (-> obj network))
         (s2-0 (-> s3-0 (-> arg0 row-index)))
         )
    (dotimes (s1-0 (-> s2-0 count))
      (let* ((v1-8 (-> s3-0 (-> s2-0 adjacency s1-0 index)))
             (s0-0 (-> v1-8 path-node))
             (f0-1 (+ (-> arg0 cost-to-start) (-> s2-0 adjacency s1-0 dist)))
             )
        (when (or (not (or (logtest? (-> s0-0 status) (net-path-node-status open))
                           (logtest? (-> s0-0 status) (net-path-node-status closed))
                           )
                       )
                  (< f0-1 (-> s0-0 cost-to-start))
                  )
          (set! (-> s0-0 parent) arg0)
          (set! (-> s0-0 cost-to-start) f0-1)
          (set! (-> s0-0 cost-to-end) (vector-vector-distance (-> v1-8 pos) arg1))
          (cond
            ((logtest? (-> s0-0 status) (net-path-node-status open))
             (nav-network-method-16 obj s0-0)
             (nav-network-method-15 obj s0-0)
             )
            ((logtest? (-> s0-0 status) (net-path-node-status closed))
             (nav-network-method-19 obj s0-0)
             (nav-network-method-15 obj s0-0)
             )
            (else
              (nav-network-method-15 obj s0-0)
              )
            )
          )
        )
      )
    )
  (nav-network-method-18 obj arg0)
  0
  (none)
  )

(defmethod nav-network-method-22 nav-network ((obj nav-network) (arg0 hover-nav-path-info) (arg1 vector) (arg2 vector) (arg3 int) (arg4 int))
  (-> obj network)
  (let ((gp-0 (-> obj free-segment-list)))
    (cond
      ((and gp-0 (nonzero? gp-0))
       (let ((v1-2 gp-0))
         (let ((a0-1 (&-> obj free-segment-list)))
           (if (= (-> a0-1 0) v1-2)
               (set! (-> a0-1 0) (the-as hover-nav-path-segment (-> v1-2 next)))
               )
           )
         (if (-> v1-2 prev)
             (set! (-> v1-2 prev next) (-> v1-2 next))
             )
         (if (-> v1-2 next)
             (set! (-> v1-2 next prev) (-> v1-2 prev))
             )
         (set! (-> v1-2 prev) #f)
         (set! (-> v1-2 next) #f)
         )
       (set! (-> gp-0 curve-matrix quad 0) (-> arg1 quad))
       (set! (-> gp-0 curve-matrix vector 1 quad) (-> arg2 quad))
       (set! (-> gp-0 pos-index 0) (the-as float arg3))
       (set! (-> gp-0 pos-index 1) (the-as float arg4))
       (set! (-> gp-0 dist)
             (vector-vector-distance (the-as vector (-> gp-0 curve-matrix)) (-> gp-0 curve-matrix vector 1))
             )
       (if (not (-> arg0 segment-list))
           (set! (-> arg0 tail-segment) gp-0)
           )
       (let ((v1-9 gp-0)
             (a1-7 (-> arg0 segment-list))
             (a0-13 (&-> arg0 segment-list))
             )
         (when (zero? v1-9)
           (break!)
           0
           )
         (when (or (= v1-9 a1-7) (= v1-9 a0-13))
           (break!)
           0
           )
         (when (not (or (not a1-7) (!= (-> a1-7 prev) v1-9)))
           (break!)
           0
           )
         (when a1-7
           (set! (-> v1-9 next) a1-7)
           (set! (-> v1-9 prev) (-> a1-7 prev))
           (if (-> v1-9 prev)
               (set! (-> v1-9 prev next) v1-9)
               )
           (if (-> v1-9 next)
               (set! (-> v1-9 next prev) v1-9)
               )
           )
         (if (or (not a1-7) (= a1-7 (-> a0-13 0)))
             (set! (-> a0-13 0) v1-9)
             )
         )
       gp-0
       )
      (else
        (format #t "nav-network out of path segments~%")
        (the-as hover-nav-path-segment #f)
        )
      )
    )
  )

;; WARN: Return type mismatch hover-nav-path-segment vs none.
(defmethod nav-network-method-21 nav-network ((obj nav-network) (arg0 object) (arg1 int) (arg2 int))
  (let ((t0-0 (-> obj network)))
    (nav-network-method-22 obj (the-as hover-nav-path-info arg0) (-> t0-0 arg1 pos) (-> t0-0 arg2 pos) arg1 arg2)
    )
  (none)
  )

(defmethod nav-network-method-23 nav-network ((obj nav-network) (arg0 hover-nav-path-info))
  (while (-> arg0 segment-list)
    (let ((v1-0 (-> arg0 segment-list)))
      (let ((a2-0 v1-0))
        (let ((a3-0 (&-> arg0 segment-list)))
          (if (= (-> a3-0 0) a2-0)
              (set! (-> a3-0 0) (the-as hover-nav-path-segment (-> a2-0 next)))
              )
          )
        (if (-> a2-0 prev)
            (set! (-> a2-0 prev next) (-> a2-0 next))
            )
        (if (-> a2-0 next)
            (set! (-> a2-0 next prev) (-> a2-0 prev))
            )
        (set! (-> a2-0 prev) #f)
        (set! (-> a2-0 next) #f)
        )
      (let ((a3-7 (-> obj free-segment-list))
            (a2-2 (&-> obj free-segment-list))
            )
        (when (zero? v1-0)
          (break!)
          0
          )
        (when (or (= v1-0 a3-7) (= v1-0 a2-2))
          (break!)
          0
          )
        (when (not (or (not a3-7) (!= (-> a3-7 prev) v1-0)))
          (break!)
          0
          )
        (when a3-7
          (set! (-> v1-0 next) a3-7)
          (set! (-> v1-0 prev) (-> a3-7 prev))
          (if (-> v1-0 prev)
              (set! (-> v1-0 prev next) v1-0)
              )
          (if (-> v1-0 next)
              (set! (-> v1-0 next prev) v1-0)
              )
          )
        (if (or (not a3-7) (= a3-7 (-> a2-2 0)))
            (set! (-> a2-2 0) v1-0)
            )
        )
      )
    )
  (set! (-> arg0 tail-segment) #f)
  (set! (-> arg0 curr-segment) #f)
  0
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod nav-network-method-24 nav-network ((obj nav-network) (arg0 hover-nav-path-info) (arg1 int) (arg2 int) (arg3 int))
  (local-vars (s3-1 nav-network-path-node))
  (nav-network-method-12 obj)
  (let ((s4-0 (-> obj network)))
    (let ((s2-0 (-> s4-0 arg1 path-node)))
      (set! (-> s2-0 row-index) arg1)
      (set! (-> s2-0 status) (net-path-node-status))
      (set! (-> s2-0 parent) #f)
      (set! (-> s2-0 cost-to-start) 0.0)
      (set! (-> s2-0 cost-to-end) (vector-vector-distance (-> s4-0 arg1 pos) (-> s4-0 arg2 pos)))
      (nav-network-method-15 obj s2-0)
      )
    (until #f
      (let ((a1-3 (nav-network-method-17 obj)))
        (when (not a1-3)
          (set! s3-1 (the-as nav-network-path-node #f))
          (goto cfg-9)
          )
        (when (= (-> a1-3 row-index) arg2)
          (set! s3-1 a1-3)
          (goto cfg-9)
          )
        (nav-network-method-20 obj a1-3 (-> s4-0 arg2 pos))
        )
      )
    #f
    (set! s3-1 (nav-network-method-17 obj))
    (label cfg-9)
    (while (and s3-1 (-> s3-1 parent))
      (if *debug-hover*
          (add-debug-sphere #t (bucket-id debug-no-zbuf1) (-> s4-0 (-> s3-1 row-index) pos) (meters 0.5) *color-blue*)
          )
      (nav-network-method-21 obj arg0 (-> s3-1 parent row-index) (-> s3-1 row-index))
      (set! s3-1 (-> s3-1 parent))
      )
    )
  #t
  )

(defmethod nav-network-method-25 nav-network ((obj nav-network) (arg0 process) (arg1 collide-prim-core))
  (local-vars (a3-2 hover-nav-sphere))
  (let ((a1-4 (process->handle arg0)))
    (let ((v1-2 (-> obj sphere-list)))
      (while v1-2
        (let ((a3-1 (-> v1-2 next)))
          (when (= (-> v1-2 handle) a1-4)
            (set! a3-2 v1-2)
            (goto cfg-12)
            )
          (set! v1-2 (the-as hover-nav-sphere a3-1))
          )
        )
      )
    (set! a3-2 (the-as hover-nav-sphere #f))
    (label cfg-12)
    (when (not a3-2)
      (let ((v1-6 (-> obj free-sphere-list)))
        (when v1-6
          (let ((a3-3 v1-6))
            (let ((t0-3 (&-> obj free-sphere-list)))
              (if (= (-> t0-3 0) a3-3)
                  (set! (-> t0-3 0) (the-as hover-nav-sphere (-> a3-3 next)))
                  )
              )
            (if (-> a3-3 prev)
                (set! (-> a3-3 prev next) (-> a3-3 next))
                )
            (if (-> a3-3 next)
                (set! (-> a3-3 next prev) (-> a3-3 prev))
                )
            (set! (-> a3-3 prev) #f)
            (set! (-> a3-3 next) #f)
            )
          (set! (-> v1-6 handle) (the-as handle a1-4))
          (let ((a1-5 v1-6)
                (a3-5 (-> obj sphere-list))
                (a0-1 (&-> obj sphere-list))
                )
            (when (zero? a1-5)
              (break!)
              0
              )
            (when (or (= a1-5 a3-5) (= a1-5 a0-1))
              (break!)
              0
              )
            (when (not (or (not a3-5) (!= (-> a3-5 prev) a1-5)))
              (break!)
              0
              )
            (when a3-5
              (set! (-> a1-5 next) a3-5)
              (set! (-> a1-5 prev) (-> a3-5 prev))
              (if (-> a1-5 prev)
                  (set! (-> a1-5 prev next) a1-5)
                  )
              (if (-> a1-5 next)
                  (set! (-> a1-5 next prev) a1-5)
                  )
              )
            (if (or (not a3-5) (= a3-5 (-> a0-1 0)))
                (set! (-> a0-1 0) a1-5)
                )
            )
          (set! a3-2 v1-6)
          )
        )
      )
    )
  (when a3-2
    (set! (-> a3-2 timer) (seconds 0.5))
    (when arg1
      (set! (-> a3-2 sphere quad) (-> arg1 world-sphere quad))
      (set! (-> a3-2 sphere r) (fmax 4096.0 (-> a3-2 sphere r)))
      )
    )
  0
  (none)
  )

(defmethod nav-network-method-26 nav-network ((obj nav-network) (arg0 vector) (arg1 process) (arg2 vector) (arg3 vector) (arg4 float))
  (local-vars (sv-48 vector) (sv-64 sphere))
  (vector-reset! arg0)
  (let ((s1-0 (process->handle arg1))
        (s2-0 0)
        )
    (let ((v1-3 (the-as list-node (-> obj sphere-list))))
      (while v1-3
        (let ((s0-0 (-> v1-3 next)))
          (when (!= (-> (the-as hover-nav-sphere v1-3) handle) s1-0)
            (set! sv-64 (-> (the-as hover-nav-sphere v1-3) sphere))
            (set! sv-48 (new 'stack-no-clear 'vector))
            (vector-segment-distance-point! sv-64 arg2 arg3 sv-48)
            (when (>= (+ arg4 (-> sv-64 r)) (vector-vector-distance sv-64 sv-48))
              (let* ((v1-8 (new 'stack-no-clear 'vector))
                     (a0-6 arg2)
                     (v1-9 (vector-! v1-8 (the-as vector sv-64) a0-6))
                     )
                (vector+! arg0 arg0 v1-9)
                )
              (+! s2-0 1)
              )
            )
          (set! v1-3 s0-0)
          )
        )
      )
    (vector-float*! arg0 arg0 (/ 1.0 (the float s2-0)))
    )
  )

(defmethod nav-network-method-27 nav-network ((obj nav-network))
  (with-pp
    (let ((v1-0 (the-as list-node (-> obj sphere-list))))
      (while v1-0
        (let ((a0-2 (-> v1-0 next)))
          (set! (-> (the-as hover-nav-sphere v1-0) timer)
                (- (-> (the-as hover-nav-sphere v1-0) timer) (- (current-time) (-> pp clock old-frame-counter)))
                )
          (when (<= (-> (the-as hover-nav-sphere v1-0) timer) 0)
            (let ((a1-4 v1-0))
              (let ((a2-3 (&-> obj sphere-list)))
                (if (= (-> a2-3 0) a1-4)
                    (set! (-> a2-3 0) (the-as hover-nav-sphere (-> a1-4 next)))
                    )
                )
              (if (-> a1-4 prev)
                  (set! (-> a1-4 prev next) (-> a1-4 next))
                  )
              (if (-> a1-4 next)
                  (set! (-> a1-4 next prev) (-> a1-4 prev))
                  )
              (set! (-> a1-4 prev) #f)
              (set! (-> a1-4 next) #f)
              )
            (let ((a2-10 (-> obj free-sphere-list))
                  (a1-6 (&-> obj free-sphere-list))
                  )
              (when (zero? v1-0)
                (break!)
                0
                )
              (when (or (= v1-0 a2-10) (= v1-0 a1-6))
                (break!)
                0
                )
              (when (not (or (not a2-10) (!= (-> a2-10 prev) v1-0)))
                (break!)
                0
                )
              (when a2-10
                (set! (-> v1-0 next) a2-10)
                (set! (-> v1-0 prev) (-> a2-10 prev))
                (if (-> v1-0 prev)
                    (set! (-> v1-0 prev next) v1-0)
                    )
                (if (-> v1-0 next)
                    (set! (-> v1-0 next prev) v1-0)
                    )
                )
              (if (or (not a2-10) (= a2-10 (-> a1-6 0)))
                  (set! (-> a1-6 0) (the-as hover-nav-sphere v1-0))
                  )
              )
            )
          (set! v1-0 a0-2)
          )
        )
      )
    (let ((v1-2 (the-as list-node (-> obj sphere-list))))
      (while v1-2
        (let ((s5-0 (-> v1-2 next)))
          (let* ((s3-0 (handle->process (-> (the-as hover-nav-sphere v1-2) handle)))
                 (s4-0 (if (type? s3-0 hover-enemy)
                           s3-0
                           )
                       )
                 )
            (when s4-0
              (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-9 from) (process->ppointer pp))
                (set! (-> a1-9 num-params) 0)
                (set! (-> a1-9 message) 'get-hover-nav-sphere)
                (let ((a2-14 (send-event-function s4-0 a1-9)))
                  (if a2-14
                      (nav-network-method-25 obj s4-0 (the-as collide-prim-core a2-14))
                      )
                  )
                )
              )
            )
          (set! v1-2 s5-0)
          )
        )
      )
    0
    (none)
    )
  )

(defmethod nav-network-method-31 nav-network ((obj nav-network) (arg0 bounding-box))
  (set-to-point! arg0 (-> obj network 0 pos))
  (let* ((s4-0 (-> obj network length))
         (s3-0 0)
         (v1-7 (-> obj network s3-0))
         )
    (while (< s3-0 s4-0)
      (add-point! arg0 (-> v1-7 pos))
      (+! s3-0 1)
      (set! v1-7 (-> obj network s3-0))
      )
    )
  0
  (none)
  )

(defmethod nav-network-method-32 nav-network ((obj nav-network) (arg0 string))
  (let ((gp-0 (new 'stack-no-clear 'bounding-box))
        (s5-0 (entity-by-name arg0))
        )
    (when s5-0
      (nav-network-method-31 obj gp-0)
      (vector-! (-> gp-0 min) (-> gp-0 min) (-> s5-0 extra trans))
      (vector-! (-> gp-0 max) (-> gp-0 max) (-> s5-0 extra trans))
      (format #t "~S ~m   " (res-lump-struct s5-0 'name structure) (-> s5-0 extra vis-dist))
      (format
        #t
        " ~m ~m ~m    ~m ~m ~m~%"
        (-> gp-0 min x)
        (-> gp-0 min y)
        (-> gp-0 min z)
        (-> gp-0 max x)
        (-> gp-0 max y)
        (-> gp-0 max z)
        )
      )
    )
  0
  (none)
  )

(define *nav-network* (the-as nav-network 0))

(defmethod hover-nav-control-method-26 hover-nav-control ((obj hover-nav-control) (arg0 vector) (arg1 vector) (arg2 float))
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0)))
      (set! (-> gp-0 start-pos quad) (-> arg0 quad))
      (set! (-> gp-0 move-dist quad) (-> v1-1 quad))
      (vector-normalize! (-> gp-0 move-dist) (fmin (vector-length v1-1) (fmax 16384.0 (* 2.0 arg2))))
      )
    (let ((v1-5 gp-0))
      (set! (-> v1-5 radius) 4096.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (fill-using-line-sphere *collide-cache* gp-0)
    (< (probe-using-line-sphere *collide-cache* gp-0) 0.0)
    )
  )

(defmethod hover-nav-control-method-27 hover-nav-control ((obj hover-nav-control) (arg0 vector) (arg1 vector))
  (let ((s2-0 (-> obj nav network))
        (gp-0 (the-as int #f))
        )
    (let ((f30-0 0.0))
      (dotimes (s1-0 (-> s2-0 length))
        (let* ((a0-1 (-> s2-0 s1-0 pos))
               (v1-5 (vector-! (new 'stack-no-clear 'vector) a0-1 arg0))
               (f28-0 (vector-length v1-5))
               )
          (if (< (vector-dot (vector-float*! (new 'stack-no-clear 'vector) v1-5 (/ 1.0 f28-0)) arg1) 0.0)
              (set! f28-0 (* 1.25 f28-0))
              )
          (when (and (< f28-0 204800.0) (hover-nav-control-method-26 obj arg0 (-> s2-0 s1-0 pos) 0.0))
            (when (or (not gp-0) (< f28-0 f30-0))
              (set! gp-0 s1-0)
              (set! f30-0 f28-0)
              )
            )
          )
        )
      )
    gp-0
    )
  )

(defmethod hover-nav-control-method-22 hover-nav-control ((obj hover-nav-control))
  (-> obj path-info curr-segment)
  )

(defmethod hover-nav-control-method-23 hover-nav-control ((obj hover-nav-control))
  (and (-> obj path-info curr-segment) (>= (-> obj path-info curr-u) 1.0))
  )

(defmethod hover-nav-control-method-21 hover-nav-control ((obj hover-nav-control))
  (nav-network-method-23 (-> obj nav) (-> obj path-info))
  (set! (-> obj curr-dest-pt) -1)
  0
  (none)
  )

(defmethod hover-nav-control-method-28 hover-nav-control ((obj hover-nav-control) (arg0 vector) (arg1 vector))
  (local-vars (v0-15 symbol) (sv-32 int) (sv-48 (function hover-nav-control vector vector int)))
  (let ((s4-0 (-> obj nav network))
        (s5-0 (-> obj path-info))
        (s1-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) arg0 arg1) 1.0))
        )
    (set! sv-32 (hover-nav-control-method-27 obj arg1 s1-0))
    (set! v0-15
          (cond
            (sv-32
              (when (or (!= sv-32 (-> obj curr-dest-pt)) (not (-> obj path-info segment-list)))
                (let ((s0-0 obj))
                  (set! sv-48 (method-of-object s0-0 hover-nav-control-method-27))
                  (let* ((a2-2 (vector-negate! s1-0 s1-0))
                         (s2-1 (sv-48 s0-0 arg0 a2-2))
                         )
                    (when s2-1
                      (cond
                        ((= s2-1 sv-32)
                         (if *debug-hover*
                             (add-debug-sphere #t (bucket-id debug-no-zbuf1) (-> s4-0 sv-32 pos) (meters 1) *color-dark-blue*)
                             )
                         (nav-network-method-22 (-> obj nav) s5-0 (-> s4-0 sv-32 pos) arg1 -1 -1)
                         (nav-network-method-22
                           (-> obj nav)
                           s5-0
                           (the-as vector (hover-nav-control-method-17 obj))
                           (-> s4-0 s2-1 pos)
                           -1
                           -1
                           )
                         )
                        (else
                          (when *debug-hover*
                            (add-debug-sphere #t (bucket-id debug-no-zbuf1) (-> s4-0 s2-1 pos) (meters 1) *color-green*)
                            (add-debug-sphere #t (bucket-id debug-no-zbuf1) (-> s4-0 sv-32 pos) (meters 1) *color-cyan*)
                            )
                          (let* ((a0-14 (-> obj nav))
                                 (t9-10 (method-of-object a0-14 nav-network-method-22))
                                 (a1-11 s5-0)
                                 (a2-8 (-> s4-0 sv-32 pos))
                                 (a3-5 arg1)
                                 (t0-5 -1)
                                 )
                            (t9-10 a0-14 a1-11 a2-8 a3-5 t0-5 -1)
                            (nav-network-method-24 (-> obj nav) s5-0 s2-1 sv-32 t0-5)
                            )
                          (nav-network-method-22
                            (-> obj nav)
                            s5-0
                            (the-as vector (hover-nav-control-method-17 obj))
                            (-> s4-0 s2-1 pos)
                            -1
                            -1
                            )
                          )
                        )
                      (hover-nav-control-method-29 obj (-> obj root transv))
                      (set! (-> s5-0 curr-segment) (-> s5-0 segment-list))
                      (set! (-> s5-0 curr-u) (/ 16384.0 (-> s5-0 curr-segment dist)))
                      (set! (-> obj curr-dest-pt) sv-32)
                      )
                    )
                  )
                )
              v0-15
              )
            (else
              (if *debug-hover*
                  (add-debug-sphere #t (bucket-id debug-no-zbuf1) arg1 (meters 1) *color-red*)
                  )
              )
            )
          )
    )
  0
  (none)
  )

(defmethod hover-nav-control-method-29 hover-nav-control ((obj hover-nav-control) (arg0 vector))
  (let ((a0-1 (the-as list-node #f))
        (s4-0 (the-as list-node (-> obj path-info segment-list)))
        )
    (while s4-0
      (cond
        (a0-1
          (set! (-> (the-as hover-nav-path-segment s4-0) curve-matrix vector 2 quad)
                (-> (the-as vector (-> (the-as hover-nav-path-segment a0-1) curve-matrix trans)) quad)
                )
          )
        (arg0
          (set! (-> (the-as hover-nav-path-segment s4-0) curve-matrix vector 2 quad) (-> arg0 quad))
          )
        (else
          (vector-normalize!
            (vector-!
              (-> (the-as hover-nav-path-segment s4-0) curve-matrix vector 2)
              (-> (the-as hover-nav-path-segment s4-0) curve-matrix vector 1)
              (the-as vector (-> (the-as hover-nav-path-segment s4-0) curve-matrix))
              )
            (hover-nav-control-method-30 obj)
            )
          )
        )
      (let ((a0-9 (-> s4-0 next)))
        (cond
          (a0-9
            (vector-!
              (-> (the-as hover-nav-path-segment s4-0) curve-matrix trans)
              (-> (the-as hover-nav-path-segment a0-9) curve-matrix vector 1)
              (the-as vector (+ (the-as uint s4-0) 16))
              )
            (vector-float*!
              (-> (the-as hover-nav-path-segment s4-0) curve-matrix trans)
              (-> (the-as hover-nav-path-segment s4-0) curve-matrix trans)
              0.5
              )
            )
          (else
            (set-vector! (-> (the-as hover-nav-path-segment s4-0) curve-matrix trans) 0.0 0.0 0.0 0.0)
            )
          )
        )
      (set! a0-1 s4-0)
      (set! s4-0 (-> s4-0 next))
      )
    )
  0
  (none)
  )

(defmethod hover-nav-control-method-30 hover-nav-control ((obj hover-nav-control))
  (* (-> obj max-speed-multiplier) (-> obj params max-speed))
  )

(defmethod hover-nav-control-method-31 hover-nav-control ((obj hover-nav-control))
  (* (-> obj max-acceleration-multiplier) (-> obj params max-acceleration))
  )

(defmethod hover-nav-control-method-14 hover-nav-control ((obj hover-nav-control) (arg0 float) (arg1 float))
  (set! (-> obj max-speed-multiplier) arg0)
  (set! (-> obj max-acceleration-multiplier) arg1)
  0
  (none)
  )

(defmethod hover-nav-control-method-18 hover-nav-control ((obj hover-nav-control) (arg0 path-control) (arg1 int) (arg2 int))
  (hover-nav-control-method-21 obj)
  (set! arg2 (cond
               ((= arg2 -1)
                (+ (-> arg0 curve num-cverts) -2)
                )
               (else
                 (empty)
                 arg2
                 )
               )
        )
  (while (>= arg2 (if (= arg1 -1)
                      0
                      arg1
                      )
             )
    (let ((s2-0 (get-point-in-path! arg0 (new 'stack-no-clear 'vector) (the float arg2) 'interp))
          (a3-3 (get-point-in-path! arg0 (new 'stack-no-clear 'vector) (the float (+ arg2 1)) 'interp))
          )
      (hover-nav-path-segment-method-9
        (nav-network-method-22 (-> obj nav) (-> obj path-info) s2-0 a3-3 -1 -1)
        (hover-nav-control-method-30 obj)
        )
      )
    (+! arg2 -1)
    )
  (hover-nav-control-method-29 obj (the-as vector #f))
  (set! (-> obj path-info curr-segment) (-> obj path-info segment-list))
  (logior! (-> obj flags) 1)
  0
  (none)
  )

(defmethod hover-nav-control-method-19 hover-nav-control ((obj hover-nav-control) (arg0 (inline-array vector)) (arg1 int))
  (hover-nav-control-method-21 obj)
  (let ((s4-1 (+ arg1 -2)))
    (while (>= s4-1 0)
      (hover-nav-path-segment-method-9
        (nav-network-method-22 (-> obj nav) (-> obj path-info) (-> arg0 s4-1) (-> arg0 (+ s4-1 1)) -1 -1)
        (hover-nav-control-method-30 obj)
        )
      (+! s4-1 -1)
      )
    )
  (hover-nav-control-method-29 obj (the-as vector #f))
  (set! (-> obj path-info curr-segment) (-> obj path-info segment-list))
  (logior! (-> obj flags) 1)
  0
  (none)
  )

(defmethod hover-nav-control-method-20 hover-nav-control ((obj hover-nav-control))
  (hover-nav-control-method-21 obj)
  (set! (-> obj flags) (logand -2 (-> obj flags)))
  0
  (none)
  )

(defmethod hover-nav-control-method-17 hover-nav-control ((obj hover-nav-control))
  (-> (the-as collide-shape-prim-group (-> obj root root-prim))
      child
      (-> obj params nav-collide-prim-index)
      prim-core
      )
  )

;; WARN: Return type mismatch vector vs none.
(defmethod hover-nav-control-method-15 hover-nav-control ((obj hover-nav-control) (arg0 vector))
  (local-vars (sv-32 vector) (sv-36 collide-shape-moving))
  (set! sv-32 (new 'stack-no-clear 'vector))
  (set! sv-36 (-> obj root))
  (vector-inv-orient-by-quat! sv-32 (-> sv-36 transv) (-> sv-36 quat))
  (vector-float*! arg0 sv-32 (/ 1.0 (hover-nav-control-method-30 obj)))
  (none)
  )

(defmethod hover-nav-control-method-16 hover-nav-control ((obj hover-nav-control) (arg0 vector))
  (local-vars (sv-32 vector))
  (set! sv-32 (new 'stack-no-clear 'vector))
  (vector-inv-orient-by-quat! sv-32 (-> obj transvv) (-> obj root quat))
  (vector-float*! arg0 sv-32 (/ 1.0 (hover-nav-control-method-31 obj)))
  )

(defmethod hover-nav-control-method-10 hover-nav-control ((obj hover-nav-control) (arg0 vector) (arg1 vector) (arg2 vector))
  (set! (-> obj dest-pos quad) (-> arg0 quad))
  (cond
    ;; condition has been changed from `arg2` because some places call this method with #t as arg2
    ((and (!= arg2 #t) arg2) ;arg2
      (set! (-> obj dest-vel quad) (-> arg2 quad))
      (set! (-> obj root transv quad) (-> arg2 quad))
      )
    (else
      (set! (-> obj dest-vel quad) (the-as uint128 0))
      (set! (-> obj root transv quad) (the-as uint128 0))
      )
    )
  (vector-normalize-copy! (-> obj dest-move-dir) arg1 1.0)
  0
  (none)
  )

(defmethod hover-nav-control-method-24 hover-nav-control ((obj hover-nav-control))
  (when (not (logtest? (-> obj flags) 1))
    (let ((s5-0 (new 'stack-no-clear 'collide-query)))
      (-> obj params)
      (let ((v1-5 (hover-nav-control-method-17 obj))
            (s4-0 (-> obj root transv))
            )
        (when (< 0.0 (vector-length s4-0))
          (set! (-> s5-0 start-pos quad) (-> v1-5 world-sphere quad))
          (set! (-> s5-0 move-dist quad) (-> s4-0 quad))
          (let ((f0-1 (vector-length (-> s5-0 move-dist))))
            (if (< 40960.0 f0-1)
                (vector-float*! (-> s5-0 move-dist) (-> s5-0 move-dist) (/ 40960.0 f0-1))
                )
            )
          (let ((a0-14 s5-0))
            (set! (-> a0-14 radius) (-> v1-5 world-sphere w))
            (set! (-> a0-14 collide-with) (-> obj root root-prim prim-core collide-with))
            (set! (-> a0-14 ignore-process0) (-> obj root process))
            (set! (-> a0-14 ignore-process1) #f)
            (set! (-> a0-14 ignore-pat) (-> obj root pat-ignore-mask))
            (set! (-> a0-14 action-mask) (collide-action solid))
            )
          (let ((f0-4 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
            (cond
              ((>= f0-4 0.0)
               (set! (-> obj los-obstruction-distance) (* f0-4 (vector-length s4-0)))
               (logior! (-> obj flags) 2)
               )
              (else
                (set! (-> obj los-last-clear-time) (current-time))
                (set! (-> obj flags) (logand -3 (-> obj flags)))
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod hover-nav-control-method-11 hover-nav-control ((obj hover-nav-control) (arg0 vector))
  (local-vars (sv-288 vector) (sv-304 vector) (sv-320 vector) (sv-336 vector) (sv-352 int))
  (with-pp
    (when *debug-hover*
      (if arg0
          (add-debug-sphere #t (bucket-id debug2) arg0 (meters 0.9) *color-yellow*)
          )
      (if (!= (-> obj curr-dest-pt) -1)
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf1)
            (-> obj nav network (-> obj curr-dest-pt) pos)
            (meters 0.4)
            *color-blue*
            )
          )
      )
    (when (not (logtest? (-> obj flags) 1))
      (cond
        ((and arg0 (and (< (vector-vector-distance arg0 (-> obj root trans)) 40960.0)
                        (>= (-> obj los-last-clear-time) (+ (current-time) (seconds -0.2)))
                        )
              )
         (if (not (and (-> obj path-info curr-segment) (< (-> obj path-info curr-u) 1.0)))
             (hover-nav-control-method-21 obj)
             )
         )
        ((or (>= (- (current-time) (-> obj los-last-clear-time)) (seconds 1)) (not (-> obj path-info curr-segment)))
         (hover-nav-control-method-21 obj)
         (when arg0
           (let ((s4-0 (new 'stack-no-clear 'vector)))
             (set! (-> s4-0 quad) (-> obj root transv quad))
             (if (>= (- (current-time) (-> obj los-last-clear-time)) (seconds 1))
                 (vector-normalize! s4-0 (fmin (vector-length s4-0) (-> obj los-obstruction-distance)))
                 )
             (hover-nav-control-method-28
               obj
               (vector+! (new 'stack-no-clear 'vector) (the-as vector (hover-nav-control-method-17 obj)) s4-0)
               arg0
               )
             )
           )
         )
        )
      )
    (let ((s4-1 (new 'stack-no-clear 'vector)))
      (let* ((s3-1 (-> obj path-info))
             (s2-1 (-> s3-1 curr-segment))
             )
        (cond
          (s2-1
            (when *debug-hover*
              (let ((s1-2 (the-as list-node (-> s3-1 segment-list))))
                (while s1-2
                  (add-debug-x
                    #t
                    (bucket-id debug-no-zbuf1)
                    (the-as vector (+ (the-as uint s1-2) 16))
                    (new 'static 'rgba :r #xff :g #xff :b #xff :a #x40)
                    )
                  (let ((s0-0 (matrix*! (new 'stack-no-clear 'matrix) *hermite-matrix* (the-as matrix (+ (the-as uint s1-2) 16)))))
                    (set! sv-288 (new 'stack-no-clear 'vector))
                    (set! sv-304 (new 'stack-no-clear 'vector))
                    (set! sv-320 (new 'stack-no-clear 'vector))
                    (set! sv-336 (new 'stack-no-clear 'vector))
                    (let ((f30-0 0.0)
                          (f28-0 0.1)
                          )
                      (set! sv-352 0)
                      (while (< sv-352 10)
                        (set-vector! sv-288 (* f30-0 f30-0 f30-0) (* f30-0 f30-0) f30-0 1.0)
                        (set-vector! sv-304 (* f28-0 f28-0 f28-0) (* f28-0 f28-0) f28-0 1.0)
                        (vector-matrix*! sv-320 sv-288 s0-0)
                        (vector-matrix*! sv-336 sv-304 s0-0)
                        (add-debug-line
                          #t
                          (bucket-id debug-no-zbuf1)
                          sv-320
                          sv-336
                          (new 'static 'rgba :r #xff :g #xff :b #xff :a #x40)
                          #f
                          (the-as rgba -1)
                          )
                        (set! f30-0 (+ 0.1 f30-0))
                        (set! f28-0 (+ 0.1 f28-0))
                        (set! sv-352 (+ sv-352 1))
                        )
                      )
                    )
                  (set! s1-2 (-> s1-2 next))
                  )
                )
              )
            (if arg0
                (set! (-> s3-1 tail-segment curve-matrix vector 1 quad) (-> arg0 quad))
                )
            (let ((f30-1 (-> s3-1 curr-u))
                  (a2-11 (matrix*! (new 'stack-no-clear 'matrix) *hermite-matrix* (-> s2-1 curve-matrix)))
                  (a1-12 (new 'stack-no-clear 'vector))
                  )
              (set-vector! a1-12 (* f30-1 f30-1 f30-1) (* f30-1 f30-1) f30-1 1.0)
              (vector-matrix*! s4-1 a1-12 a2-11)
              )
            (if *debug-hover*
                (add-debug-sphere #t (bucket-id debug-no-zbuf1) s4-1 (meters 0.8) *color-magenta*)
                )
            (let ((f0-19 (+ 2048.0 (vector-length (-> obj root transv)))))
              (if (logtest? (-> obj flags) 2)
                  (set! f0-19 (fmin f0-19 (fmax 8192.0 (-> obj los-obstruction-distance))))
                  )
              (hover-nav-path-segment-method-9 s2-1 f0-19)
              )
            (seek! (-> s3-1 curr-u) 1.0 (* (-> s2-1 du) (-> pp clock seconds-per-frame)))
            (when (and (>= (-> s3-1 curr-u) 1.0) (-> s2-1 next))
              (set! (-> s3-1 curr-segment) (the-as hover-nav-path-segment (-> s2-1 next)))
              (set! (-> s3-1 curr-u) 0.0)
              (hover-nav-path-segment-method-9 (-> s3-1 curr-segment) (hover-nav-control-method-30 obj))
              )
            )
          (arg0
            (set! (-> s4-1 quad) (-> arg0 quad))
            )
          (else
            (set! (-> s4-1 quad) (-> (hover-nav-control-method-17 obj) world-sphere quad))
            )
          )
        )
      (let ((v1-94 (vector-! (new 'stack-no-clear 'vector) s4-1 (-> obj dest-pos))))
        (set! (-> obj dest-pos quad) (-> s4-1 quad))
        (vector-float*! (-> obj dest-vel) v1-94 (-> pp clock frames-per-second))
        )
      )
    (if (< 0.0 (vector-length (-> obj dest-vel)))
        (vector-normalize-copy! (-> obj dest-move-dir) (-> obj dest-vel) 1.0)
        )
    0
    (none)
    )
  )

(defmethod hover-nav-control-method-25 hover-nav-control ((obj hover-nav-control))
  (with-pp
    (let ((s5-0 (new 'stack-no-clear 'hover-nav-path-segment))
          (f28-0 (hover-nav-control-method-31 obj))
          (f30-0 (hover-nav-control-method-30 obj))
          (s3-0 (-> obj root transv))
          )
      (-> obj transvv)
      (let ((s4-0 (-> obj dest-offset)))
        (vector-normalize-copy! (-> s5-0 curve-matrix vector 2) s3-0 1.0)
        (vector-normalize-copy! (-> s5-0 curve-matrix trans) s4-0 1.0)
        (set! (-> s5-0 pos-index 0) (vector-dot s3-0 (-> s5-0 curve-matrix trans)))
        (set! (-> s5-0 pos-index 1) (/ (* 0.5 (-> s5-0 pos-index 0) (-> s5-0 pos-index 0)) (* 0.2 f28-0)))
        (set! (-> s5-0 dist) (vector-dot (-> obj dest-vel) (-> s5-0 curve-matrix trans)))
        (vector-normalize-copy! (-> s5-0 curve-matrix vector 1) s4-0 (-> obj target-speed))
        (vector-! (the-as vector (-> s5-0 curve-matrix)) (-> s5-0 curve-matrix vector 1) s3-0)
        (let ((f0-9 (vector-length (the-as vector (-> s5-0 curve-matrix)))))
          (if (< f28-0 f0-9)
              (vector-float*! (the-as vector (-> s5-0 curve-matrix)) (the-as vector (-> s5-0 curve-matrix)) (/ f28-0 f0-9))
              )
          )
        (vector+float*!
          (the-as vector (&-> s5-0 next))
          (-> obj root transv)
          (the-as vector (-> s5-0 curve-matrix))
          (-> pp clock seconds-per-frame)
          )
        (let ((f0-12 (vector-length (the-as vector (&-> s5-0 next))))
              (f1-6 (if (logtest? (-> obj flags) 2)
                        (fmax 8192.0 (* 0.8 (-> obj los-obstruction-distance)))
                        f30-0
                        )
                    )
              )
          (if (< f1-6 f0-12)
              (vector-float*! (the-as vector (&-> s5-0 next)) (the-as vector (&-> s5-0 next)) (/ f1-6 f0-12))
              )
          )
        (set! (-> obj root transv quad) (-> (the-as vector (&-> s5-0 next)) quad))
        (set! (-> obj transvv quad) (-> s5-0 curve-matrix quad 0))
        (when *debug-hover*
          (format *stdcon* " speed act: ~m target: ~m~%" (-> s5-0 pos-index 0) (-> obj target-speed))
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (-> obj root trans)
            (-> obj root transv)
            (meters 0.00024414062)
            *color-yellow*
            )
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (-> obj root trans)
            (-> s5-0 curve-matrix vector 1)
            (meters 0.00024414062)
            *color-cyan*
            )
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (-> obj root trans)
            (-> obj transvv)
            (meters 0.00024414062)
            *color-blue*
            )
          (add-debug-x
            #t
            (bucket-id debug-no-zbuf1)
            (vector+! (new 'stack-no-clear 'vector) (-> obj root trans) s4-0)
            *color-green*
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod hover-nav-control-method-12 hover-nav-control ((obj hover-nav-control))
  (local-vars (at-0 int))
  (with-pp
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (hover-nav-control-method-25 obj)
      (hover-nav-control-method-24 obj)
      (let ((v1-5 (-> obj root transv))
            (a0-4 (-> obj root transv))
            (a1-0 (new 'stack-no-clear 'vector))
            )
        (.lvf vf1 (&-> (-> obj nav-collide-impulse) quad))
        (let ((f0-0 (-> pp clock seconds-per-frame)))
          (.mov at-0 f0-0)
          )
        (.mov vf2 at-0)
        (.mov.vf vf1 vf0 :mask #b1000)
        (.mul.x.vf vf1 vf1 vf2 :mask #b111)
        (.svf (&-> a1-0 quad) vf1)
        (vector+! v1-5 a0-4 a1-0)
        )
      (let ((v1-7 (-> obj root))
            (a2-2 (new 'stack-no-clear 'collide-query))
            )
        (set! (-> a2-2 collide-with) (-> v1-7 root-prim prim-core collide-with))
        (set! (-> a2-2 ignore-process0) (-> v1-7 process))
        (set! (-> a2-2 ignore-process1) #f)
        (set! (-> a2-2 ignore-pat) (-> v1-7 pat-ignore-mask))
        (set! (-> a2-2 action-mask) (collide-action solid))
        (fill-cache-integrate-and-collide v1-7 (-> v1-7 transv) a2-2 (meters 0))
        )
      (vector-float*!
        (-> obj root transv)
        (-> obj root transv)
        (- 1.0 (* (-> obj params friction) (-> pp clock seconds-per-frame)))
        )
      0
      (none)
      )
    )
  )

;; ERROR: Stack slot load at 128 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 144 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 160 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 128 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 144 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 160 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 128 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 144 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 160 mismatch: defined as size 4, got size 16
(defmethod hover-nav-control-method-13 hover-nav-control ((obj hover-nav-control))
  (local-vars (sv-112 float) (sv-128 float) (sv-144 float) (sv-160 float))
  (with-pp
    (let* ((s5-0 (-> obj root))
           (s3-0 (hover-nav-control-method-17 obj))
           (v1-2 (vector-! (new 'stack-no-clear 'vector) (the-as vector s3-0) (-> s5-0 trans)))
           (s4-1 (vector-! (new 'stack-no-clear 'vector) (-> obj dest-pos) v1-2))
           )
      (when (not (logtest? (-> obj flags) 1))
        (let* ((s2-0 (-> obj root transv))
               (f30-0 (vector-length s2-0))
               (s1-0 lerp-scale)
               (s0-0 0.0)
               )
          (set! sv-112 (hover-nav-control-method-30 obj))
          (set! sv-128 (* 2.0 f30-0))
          (set! sv-144 (the-as float 0.0))
          (let* ((t0-0 (hover-nav-control-method-30 obj))
                 (f0-4 (s1-0 s0-0 sv-112 sv-128 sv-144 t0-0))
                 (t0-2 (vector+float*! (new 'stack-no-clear 'vector) (the-as vector s3-0) s2-0 (/ f0-4 f30-0)))
                 (s2-1 (nav-network-method-26
                         (-> obj nav)
                         (new 'stack-no-clear 'vector)
                         (-> obj root process)
                         (the-as vector s3-0)
                         t0-2
                         (-> s3-0 world-sphere w)
                         )
                       )
                 )
            (let ((f0-7 (vector-length s2-1))
                  (s1-1 seek)
                  (s0-1 (-> obj nav-collide-impulse-len))
                  )
              (set! sv-160 f0-7)
              (let ((a2-2 (* (hover-nav-control-method-31 obj) (-> pp clock seconds-per-frame))))
                (set! (-> obj nav-collide-impulse-len) (s1-1 s0-1 sv-160 a2-2))
                )
              )
            (vector-normalize-copy! (-> obj nav-collide-impulse) s2-1 (- (-> obj nav-collide-impulse-len)))
            )
          )
        (if *debug-hover*
            (add-debug-vector
              #t
              (bucket-id debug-no-zbuf1)
              (the-as vector s3-0)
              (-> obj nav-collide-impulse)
              (meters 0.00024414062)
              *color-red*
              )
            )
        )
      (let ((f30-1 (hover-nav-control-method-31 obj))
            (f28-0 (hover-nav-control-method-30 obj))
            )
        (vector-z-quaternion! (-> obj move-dir) (-> s5-0 quat))
        (set! (-> obj speed) (vector-length (-> s5-0 transv)))
        (vector-! (-> obj dest-offset) s4-1 (-> s5-0 trans))
        (let ((s4-2 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> obj dest-offset) 1.0))
              (v0-13 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 transv) 1.0))
              )
          (set! (-> obj speed-dest) (vector-dot (-> s5-0 transv) s4-2))
          (set! (-> obj local-dist) (vector-dot v0-13 (-> obj dest-offset)))
          )
        (let* ((f0-20 (fmax 0.0 (+ -2048.0 (vector-length (-> obj dest-offset)))))
               (f1-5 (sqrtf (* 1.6 f0-20 f30-1)))
               (f0-23 0.0)
               )
          (seek! (-> obj target-speed) (fmax (fmin f1-5 f28-0) f0-23) (* 0.9 (-> pp clock seconds-per-frame) f30-1))
          )
        )
      )
    (when *debug-hover*
      (add-debug-x #t (bucket-id debug-no-zbuf1) (-> obj dest-pos) *color-white*)
      (add-debug-vector
        #t
        (bucket-id debug-no-zbuf1)
        (-> obj dest-pos)
        (-> obj dest-vel)
        (meters 0.00024414062)
        *color-white*
        )
      )
    0
    (none)
    )
  )

(defun hover-bounce-reaction ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (vector-reflect! s4-0 arg3 (-> arg0 surface-normal))
    (vector-float*! arg2 s4-0 0.4)
    )
  (-> arg0 status)
  )

(defmethod hover-nav-control-method-9 hover-nav-control ((obj hover-nav-control))
  (hover-nav-control-method-21 obj)
  0
  (none)
  )

(defmethod relocate hover-nav-control ((obj hover-nav-control) (arg0 int))
  (if (nonzero? (-> obj root))
      (&+! (-> obj root) arg0)
      )
  obj
  )

(defmethod new hover-nav-control ((allocation symbol) (type-to-make type) (arg0 process) (arg1 collide-shape-moving) (arg2 hover-nav-params))
  (let ((s5-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> s5-0 root) arg1)
    (set! (-> s5-0 root reaction) hover-bounce-reaction)
    (set! (-> s5-0 nav) *nav-network*)
    (set! (-> s5-0 path-info segment-list) #f)
    (set! (-> s5-0 path-info tail-segment) #f)
    (set! (-> s5-0 path-info curr-segment) #f)
    (set! (-> s5-0 path-info curr-u) 0.0)
    (set! (-> s5-0 flags) (the-as uint 0))
    (set! (-> s5-0 params) arg2)
    (set! *hover-nav-time-offset* (+ *hover-nav-time-offset* 1))
    (vector-reset! (-> s5-0 dest-pos))
    (set! (-> s5-0 dest-vel quad) (the-as uint128 0))
    (set! (-> s5-0 dest-move-dir quad) (the-as uint128 0))
    (set! (-> s5-0 dest-offset quad) (the-as uint128 0))
    (set! (-> s5-0 nav-collide-impulse quad) (the-as uint128 0))
    (vector-z-quaternion! (-> s5-0 move-dir) (-> s5-0 root quat))
    (set! (-> s5-0 nav-collide-impulse-len) 0.0)
    (set! (-> s5-0 speed) 0.0)
    (set! (-> s5-0 target-speed) 0.0)
    (set! (-> s5-0 target-acceleration) 0.0)
    (set! (-> s5-0 speed-dest) 0.0)
    (set! (-> s5-0 curr-dest-pt) -1)
    (set! (-> s5-0 los-obstruction-distance) 0.0)
    (set! (-> s5-0 los-last-clear-time) (current-time))
    (hover-nav-control-method-14 s5-0 1.0 1.0)
    (nav-network-method-25 (-> s5-0 nav) arg0 (the-as collide-prim-core #f))
    s5-0
    )
  )
