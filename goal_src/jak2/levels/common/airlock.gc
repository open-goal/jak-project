;;-*-Lisp-*-
(in-package goal)

;; name: airlock.gc
;; name in dgo: airlock
;; dgos: GAME, COMMON

;; og:update-with-merge

;; DECOMP BEGINS

(deftype com-airlock (process-drawable)
  ((child-override        basic          :offset         24)
   (root-override         collide-shape  :offset        128)
   (level-name            pair           :offset-assert 200)
   (open-test             pair           :offset-assert 204)
   (were-behind?          symbol         :offset-assert 208)
   (inner?                symbol         :offset-assert 212)
   (sound-behind?         symbol         :offset-assert 216)
   (visible-move?         symbol         :offset-assert 220)
   (saw-pilot?            handle         :offset-assert 224)
   (last-distance         meters         :offset-assert 232)
   (y-height              vector         :offset-assert 236)
   (pre-open-speed        float          :offset-assert 240)
   (latch-closed-time     time-frame     :offset-assert 248)
   (latch-open-time       time-frame     :offset-assert 256)
   (gear                  joint-mod      :offset-assert 264)
   (gear-rot              degrees        :offset-assert 268)
   (gear-rotv             degrees        :offset-assert 272)
   (open-frame            float          :offset-assert 276)
   (pre-open-frame        float          :offset-assert 280)
   (lock-frame            float          :offset-assert 284)
   (open-distance         meters         :offset-assert 288)
   (active-distance       meters         :offset-assert 292)
   (sound-id              sound-id       :offset-assert 296)
   (gear-sound-id         sound-id       :offset-assert 300)
   (sound-gear            sound-spec     :offset-assert 304)
   (sound-pre-open        sound-spec     :offset-assert 308)
   (sound-pre-open-stop   sound-spec     :offset-assert 312)
   (sound-lock-loop       sound-spec     :offset-assert 316)
   (sound-lock-stop       sound-spec     :offset-assert 320)
   (sound-open            sound-spec     :offset-assert 324)
   (sound-open-loop       sound-spec     :offset-assert 328)
   (sound-open-stop       sound-spec     :offset-assert 332)
   (sound-close           sound-spec     :offset-assert 336)
   (sound-close-loop      sound-spec     :offset-assert 340)
   (sound-close-stop      sound-spec     :offset-assert 344)
   (sound-post-close      sound-spec     :offset-assert 348)
   (sound-post-close-stop sound-spec     :offset-assert 352)
   (spool-sound-time      time-frame     :offset-assert 360)
   (door-radius           meters         :offset-assert 368)
   )
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  (:methods
    (open (symbol) _type_ :state 20)
    (close (symbol) _type_ :state 21)
    (init-airlock! (_type_) _type_ 22)
    (want-cross-airlock? (_type_) symbol :behavior com-airlock 23)
    (destination-loaded? (_type_ symbol) symbol 24)
    (check-crossing-distance (_type_ vector symbol) float :behavior com-airlock 25)
    (rotate-gear! (_type_ float) degrees :behavior com-airlock 26)
    (play-city-voice-sound (_type_ symbol) none :behavior com-airlock 27)
    )
  )


(defmethod deactivate com-airlock ((obj com-airlock))
  (process-entity-status! obj (entity-perm-status subtask-complete) #f)
  (if (nonzero? (-> obj sound-id))
      (sound-stop (-> obj sound-id))
      )
  (if (nonzero? (-> obj gear-sound-id))
      (sound-stop (-> obj gear-sound-id))
      )
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs com-airlock.
(defmethod relocate com-airlock ((obj com-airlock) (arg0 int))
  (if (nonzero? (-> obj gear))
      (&+! (-> obj gear) arg0)
      )
  (the-as com-airlock ((method-of-type process-drawable relocate) obj arg0))
  )

(defmethod init-airlock! com-airlock ((obj com-airlock))
  (process-entity-status! obj (entity-perm-status subtask-complete) #f)
  (process-drawable-from-entity! obj (-> obj entity))
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj were-behind?) #f)
  (set! (-> obj inner?)
        (logtest? (the-as int (res-lump-value (-> obj entity) 'options uint128 :time -1000000000.0)) 1)
        )
  (set! (-> obj sound-behind?) #f)
  (set! (-> obj saw-pilot?) (the-as handle #f))
  (set! (-> obj open-frame) 0.0)
  (set! (-> obj pre-open-frame) 0.0)
  (set! (-> obj lock-frame) 0.0)
  (set! (-> obj pre-open-speed) 2.0)
  (set! (-> obj open-distance) (res-lump-float (-> obj entity) 'distance :default 143360.0))
  (set! (-> obj active-distance)
        (res-lump-float (-> obj entity) 'idle-distance :default (+ 143360.0 (-> obj open-distance)))
        )
  (set! (-> obj y-height) (res-lump-data (-> obj entity) 'height vector))
  (set! (-> obj level-name) (res-lump-struct (-> obj entity) 'on-notice pair))
  (set! (-> obj open-test)
        (the-as pair ((method-of-type res-lump get-property-struct)
                      (-> obj entity)
                      'open-test
                      'interp
                      -1000000000.0
                      (the-as structure '(not (or (scene-player?) (focus-test? *target* grabbed))))
                      (the-as (pointer res-tag) #f)
                      *res-static-buf*
                      )
                )
        )
  (set! (-> obj sound-gear) #f)
  (set! (-> obj sound-pre-open) #f)
  (set! (-> obj sound-pre-open-stop) #f)
  (set! (-> obj sound-lock-loop) #f)
  (set! (-> obj sound-lock-stop) #f)
  (set! (-> obj sound-post-close) #f)
  (set! (-> obj sound-post-close-stop) #f)
  (set! (-> obj sound-open) #f)
  (set! (-> obj sound-close) #f)
  (set! (-> obj sound-open-loop) #f)
  (set! (-> obj sound-close-loop) #f)
  (set! (-> obj sound-open-stop) #f)
  (set! (-> obj sound-close-stop) #f)
  (set! (-> obj door-radius) 20480.0)
  obj
  )

(defmethod check-crossing-distance com-airlock ((obj com-airlock) (arg0 vector) (arg1 symbol))
  (let ((s5-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override quat)))
        (s4-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj root-override trans)))
        )
    (set! (-> s4-1 y) 0.0)
    (let ((f30-0 (vector-dot s4-1 s5-0)))
      (cond
        ((not arg1)
         )
        ((or (< (vector-vector-xz-distance (-> obj root-override trans) arg0) 40960.0)
             (< 0.7 (fabs (vector-dot s5-0 (vector-normalize! s4-1 1.0))))
             )
         (when (and (< f30-0 0.0) (< 0.0 (-> obj last-distance)))
           (let ((s5-1 (res-lump-struct (-> obj entity) 'on-cross structure)))
             (if s5-1
                 (script-eval (the-as pair s5-1))
                 )
             )
           )
         (set! (-> obj last-distance) f30-0)
         )
        ((< 0.0 (-> obj last-distance))
         (set! f30-0 (fmax 4096.0 f30-0))
         )
        ((< (-> obj last-distance) 0.0)
         (set! f30-0 (fmin -4096.0 f30-0))
         )
        )
      f30-0
      )
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defmethod want-cross-airlock? com-airlock ((obj com-airlock))
  (local-vars (a0-12 entity-actor))
  (let* ((tgt (target-pos 0))
         (f30-0 (check-crossing-distance obj tgt #t))
         (s5-0 (>= (-> obj latch-open-time) (current-time)))
         )
    (the-as
      symbol
      (and (or s5-0 (< (vector-vector-xz-distance (-> obj root-override trans) tgt) (-> obj active-distance)))
           (or s5-0 (not (-> obj y-height)) (and (>= (-> tgt y) (- (-> obj root-override trans y) (-> obj y-height y)))
                                                 (< (-> tgt y) (+ (-> obj root-override trans y) (-> obj y-height x)))
                                                 )
               )
           (begin
             (if (and (not (-> obj were-behind?)) (and (< f30-0 0.0) (-> obj inner?)))
                 (set! (-> obj were-behind?) #t)
                 )
             (and (< (-> obj latch-closed-time) (current-time))
                  (or (not (and *target* (focus-test? *target* pilot teleporting))) (< f30-0 -409.6))
                  (or (and (< f30-0 (-> obj open-distance))
                           (or (not (-> obj were-behind?)) (< f30-0 20480.0))
                           (and (or (< 409.6 f30-0)
                                    (begin
                                      (let ((a0-11 (-> obj entity)))
                                        (set! a0-12 (entity-actor-lookup a0-11 'next-actor 0))
                                        )
                                      (not a0-12)
                                      )
                                    (logtest? (-> a0-12 extra perm status) (entity-perm-status subtask-complete))
                                    )
                                (and (script-eval (-> obj open-test)) (-> *setting-control* user-current airlock))
                                )
                           )
                      s5-0
                      (let ((f0-8 (check-crossing-distance obj (camera-pos) #f)))
                        (and (or (not *target*) (not (logtest? (-> *target* focus-status) (focus-status in-head))))
                             (or (< (* f30-0 f0-8) 0.0)
                                 (and (< (fabs f0-8) 4096.0)
                                      (< (vector-vector-xz-distance (camera-pos) (-> obj root-override trans)) (-> obj door-radius))
                                      )
                                 )
                             )
                        )
                      )
                  )
             )
           )
      )
    )
  )

(defmethod destination-loaded? com-airlock ((obj com-airlock) (display? symbol))
  (let ((level-list (the-as pair (script-eval (-> obj level-name))))
        (borrow-lev-name #f)
        )
    (cond
      ((not (the-as object level-list))
       (if display?
           'unknown
           #f
           )
       )
      (display?
        (let* ((level-list-iter level-list)
               (lev-name (car (the-as object level-list-iter)))
               )
          (while (not (null? (the-as object level-list-iter)))
            (let ((v1-4 (level-status *level* (the-as symbol lev-name))))
              (if (not (or (= v1-4 'loaded) (= v1-4 'active)))
                  (return #f)
                  )
              )
            (if (= lev-name 'ctywide)
                (set! borrow-lev-name (-> ctywide borrow-level 1))
                )
            (set! level-list-iter (cdr (the-as object level-list-iter)))
            (set! lev-name (car level-list-iter))
            )
          )
        (when borrow-lev-name
          (let ((v1-17 (level-status *level* borrow-lev-name)))
            (if (not (or (= v1-17 'loaded) (= v1-17 'active)))
                (return #f)
                )
            )
          )
        (if (!= display? 'display)
            (return #t)
            )
        (let ((a1-7 (car (the-as object level-list))))
          (while (not (null? (the-as object level-list)))
            (let ((v1-26 (level-get *level* (the-as symbol a1-7))))
              (if (not (and v1-26 (= (-> v1-26 status) 'active) (-> v1-26 display?)))
                  (return #f)
                  )
              )
            (set! level-list (cdr (the-as object level-list)))
            (set! a1-7 (car level-list))
            )
          )
        #t
        )
      (else
        (let* ((v1-33 (the-as object level-list))
               (a0-11 (car v1-33))
               )
          (while (not (null? v1-33))
            (dotimes (a1-10 6)
              (if (= a0-11 (-> *load-state* want a1-10 name))
                  (goto cfg-50)
                  )
              )
            #t
            (return #f)
            (label cfg-50)
            (set! v1-33 (cdr v1-33))
            (set! a0-11 (car (the-as pair v1-33)))
            )
          )
        #t
        )
      )
    )
  )

(defmethod rotate-gear! com-airlock ((obj com-airlock) (arg0 float))
  (when (nonzero? (-> obj gear))
    (if (and (zero? (-> obj gear-sound-id))
             (-> obj sound-gear)
             (and (-> obj next-state) (= (-> obj next-state name) 'open))
             (>= (check-crossing-distance obj (target-pos 0) #f) 0.0)
             )
        (set! (-> obj gear-sound-id) (sound-play-by-spec (-> obj sound-gear) (new-sound-id) (the-as vector #t)))
        )
    (seek! (-> obj gear-rotv) arg0 (* 131072.0 (-> self clock seconds-per-frame)))
    (+! (-> obj gear-rot) (* (-> obj gear-rotv) (-> self clock seconds-per-frame)))
    (twist-set! (-> obj gear) (the-as float #f) (the-as float #f) (-> obj gear-rot))
    )
  (-> obj gear-rotv)
  )

(defmethod play-city-voice-sound com-airlock ((obj com-airlock) (arg0 symbol))
  (let ((gp-0 (the-as (array string) #f)))
    (case arg0
      (('enter)
       (set! gp-0 (new 'static 'boxed-array :type string "cityv005" "cityv006" "cityv007" "cityv008" "cityv009"))
       )
      (('exit)
       (set! gp-0 (new 'static 'boxed-array :type string "cityv001" "cityv002" "cityv003" "cityv004"))
       )
      )
    (cond
      ((and gp-0 (>= (- (current-time) (-> obj spool-sound-time)) (seconds 2)))
       (set! (-> obj spool-sound-time) (current-time))
       (add-process
         *gui-control*
         obj
         (gui-channel alert)
         (gui-action play)
         (-> (the-as (array string) (+ (* (rand-vu-int-range 0 (+ (-> gp-0 length) -1)) 4) (the-as int gp-0))) 0)
         -99.0
         0
         )
       )
      (else
        0
        )
      )
    )
  (none)
  )

(defskelgroup skel-com-airlock-outer com-airlock-outer com-airlock-outer-lod0-jg com-airlock-outer-idle-ja
              ((com-airlock-outer-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

(defskelgroup skel-com-airlock-inner com-airlock-inner com-airlock-inner-lod0-jg com-airlock-inner-idle-ja
              ((com-airlock-inner-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 5 0 14)
              )

(defstate close (com-airlock)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('close)
         (set! (-> self latch-closed-time) (+ (current-time) (if (>= arg1 1)
                                                                 (the-as int (-> event param 0))
                                                                 3000
                                                                 )
                                              )
               )
         (if (and (>= arg1 2) (and (= (-> event param 1) #t) (not (want-cross-airlock? self))))
             (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
             )
         (and (-> self next-state) (= (-> self next-state name) 'open))
         )
        (('open)
         (set! (-> self latch-open-time) (+ (current-time) (if (>= arg1 1)
                                                               (the-as int (-> event param 0))
                                                               3000
                                                               )
                                            )
               )
         (if (and (>= arg1 2) (and (= (-> event param 1) #t) (want-cross-airlock? self) (destination-loaded? self #f)))
             (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
                 :num! (identity
                   (the float (+ (-> (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) frames num-frames) -1))
                   )
                 )
             )
         (and (-> self next-state) (= (-> self next-state name) 'close))
         )
        (('front)
         (let ((f30-0 (check-crossing-distance self (target-pos 0) #f))
               (f0-3 (check-crossing-distance self (camera-pos) #f))
               )
           (and (< 2048.0 f30-0) (>= (* f30-0 f0-3) 0.0))
           )
         )
        (('back)
         (let ((f30-1 (check-crossing-distance self (target-pos 0) #f))
               (f0-5 (check-crossing-distance self (camera-pos) #f))
               )
           (and (< f30-1 -2048.0) (>= (* f30-1 f0-5) 0.0))
           )
         )
        (('sound)
         (if (>= (check-crossing-distance self (target-pos 0) #f) 0.0)
             (the-as object (play-city-voice-sound self (the-as symbol (-> event param 0))))
             )
         )
        (('distance)
         (* (the int (check-crossing-distance self (target-pos 0) #f)) 8)
         )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self visible-move?) #f)
    (none)
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (let ((v1-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-2 command) (sound-command set-param))
        (set! (-> v1-2 id) (-> self sound-id))
        (set! (-> v1-2 params volume) -4)
        (set! (-> v1-2 auto-time) 24)
        (set! (-> v1-2 auto-from) 2)
        (set! (-> v1-2 params mask) (the-as uint 17))
        (-> v1-2 id)
        )
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    (when (nonzero? (-> self gear-sound-id))
      (let ((v1-6 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-6 command) (sound-command set-param))
        (set! (-> v1-6 id) (-> self gear-sound-id))
        (set! (-> v1-6 params volume) -4)
        (set! (-> v1-6 auto-time) 24)
        (set! (-> v1-6 auto-from) 2)
        (set! (-> v1-6 params mask) (the-as uint 17))
        (-> v1-6 id)
        )
      (set! (-> self gear-sound-id) (new 'static 'sound-id))
      0
      )
    (none)
    )
  :trans (behavior ()
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (set! (-> self visible-move?) #t)
        )
    (when (and (want-cross-airlock? self) (begin
                                            (let ((gp-0 (res-lump-struct (-> self entity) 'on-activate structure)))
                                              (if gp-0
                                                  (script-eval (the-as pair gp-0))
                                                  )
                                              )
                                            (destination-loaded? self #f)
                                            )
               )
      (when (nonzero? (-> self sound-id))
        (let ((v1-17 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-17 command) (sound-command set-param))
          (set! (-> v1-17 id) (-> self sound-id))
          (set! (-> v1-17 params volume) -4)
          (set! (-> v1-17 auto-time) 24)
          (set! (-> v1-17 auto-from) 2)
          (set! (-> v1-17 params mask) (the-as uint 17))
          (-> v1-17 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (go-virtual open #f)
      )
    (none)
    )
  :code (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status subtask-complete) #f)
    (when (not arg0)
      (if (and (-> self sound-close)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (sound-play-by-spec (-> self sound-close) (new-sound-id) (the-as vector #t))
          )
      (if (and (-> self sound-close-loop)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (set! (-> self sound-id) (sound-play-by-spec (-> self sound-close-loop) (new-sound-id) (the-as vector #t)))
          )
      (while (< (-> self open-frame) (ja-aframe-num 0))
        (rotate-gear! self 65536.0)
        (when (and (-> self were-behind?)
                   (< 0.4 (vector-dot
                            (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override quat))
                            (-> (math-camera-matrix) vector 2)
                            )
                      )
                   (< 0.0 (check-crossing-distance self (target-pos 0) #f))
                   )
          (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
          (goto cfg-42)
          )
        (suspend)
        (ja :num! (seek! 0.0 2.0))
        (transform-post)
        )
      (label cfg-42)
      (if (< 0.0 (check-crossing-distance self (target-pos 0) #f))
          ((lambda :behavior com-airlock
             ()
             (let ((gp-0 (res-lump-struct (-> self entity) 'on-exit structure)))
               (if (and gp-0 (not *scene-player*))
                   (script-eval (the-as pair gp-0))
                   )
               )
             (the-as pair (when (-> self were-behind?)
                            (let ((gp-1 (res-lump-struct (-> self entity) 'on-inside structure)))
                              (set! (-> self were-behind?) #f)
                              (if (and gp-1 (not *scene-player*))
                                  (script-eval (the-as pair gp-1))
                                  )
                              )
                            )
                     )
             )
           )
          )
      (when (nonzero? (-> self sound-id))
        (let ((v1-46 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-46 command) (sound-command set-param))
          (set! (-> v1-46 id) (-> self sound-id))
          (set! (-> v1-46 params volume) -4)
          (set! (-> v1-46 auto-time) 24)
          (set! (-> v1-46 auto-from) 2)
          (set! (-> v1-46 params mask) (the-as uint 17))
          (-> v1-46 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (if (and (-> self sound-close-stop) (not arg0) (-> self visible-move?))
          (sound-play-by-spec (-> self sound-close-stop) (new-sound-id) (the-as vector #t))
          )
      (while (not (ja-min? 0))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-post-close)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-post-close) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        ;; pc port note: added speed modifier
        (ja :num! (seek! 0.0 (get-airlock-close-speed *pc-settings*)))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-71 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-71 command) (sound-command set-param))
          (set! (-> v1-71 id) (-> self sound-id))
          (set! (-> v1-71 params volume) -4)
          (set! (-> v1-71 auto-time) 24)
          (set! (-> v1-71 auto-from) 2)
          (set! (-> v1-71 params mask) (the-as uint 17))
          (-> v1-71 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-post-close-stop)
            (sound-play-by-spec (-> self sound-post-close-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (when (< 0.0 (check-crossing-distance self (target-pos 0) #f))
        (let ((gp-3 (res-lump-struct (-> self entity) 'on-deactivate structure)))
          (if (and gp-3 (not *scene-player*))
              (script-eval (the-as pair gp-3))
              )
          )
        )
      (while (!= (-> self gear-rotv) 0.0)
        (rotate-gear! self 0.0)
        (suspend)
        (transform-post)
        )
      (when (nonzero? (-> self gear-sound-id))
        (let ((v1-91 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-91 command) (sound-command set-param))
          (set! (-> v1-91 id) (-> self gear-sound-id))
          (set! (-> v1-91 params volume) -4)
          (set! (-> v1-91 auto-time) 24)
          (set! (-> v1-91 auto-from) 2)
          (set! (-> v1-91 params mask) (the-as uint 17))
          (-> v1-91 id)
          )
        (set! (-> self gear-sound-id) (new 'static 'sound-id))
        0
        )
      )
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) :num! min)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    (none)
    )
  )

(defstate open (com-airlock)
  :virtual #t
  :event (-> (method-of-type com-airlock close) event)
  :enter (behavior ((arg0 symbol))
    (set! (-> self visible-move?) #f)
    (none)
    )
  :exit (-> (method-of-type com-airlock close) exit)
  :trans (behavior ()
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (set! (-> self visible-move?) #t)
        )
    (if (not (want-cross-airlock? self))
        (go-virtual close #f)
        )
    (when (logtest? (-> self mask) (process-mask sleep-code))
      (let ((v1-14 (destination-loaded? self 'display)))
        (when (or (not v1-14) (= v1-14 'unknown))
          (if (and (not v1-14) (< (-> self open-frame) (ja-aframe-num 0)))
              (ja :num-func num-func-identity :frame-num (ja-aframe (-> self open-frame) 0))
              )
          (go-virtual close #f)
          )
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (when (< (check-crossing-distance self (target-pos 0) #f) 0.0)
        (if (< (ja-aframe-num 0) (-> self pre-open-frame))
            (ja :num-func num-func-identity :frame-num (ja-aframe (-> self pre-open-frame) 0))
            )
        )
      (while (< (ja-aframe-num 0) (-> self lock-frame))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-pre-open)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-pre-open) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        ;; pc port note: added speed modifier
        (ja :num! (seek! (ja-aframe (-> self lock-frame) 0) (* (get-airlock-speed *pc-settings*) (-> self pre-open-speed))))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-26 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-26 command) (sound-command set-param))
          (set! (-> v1-26 id) (-> self sound-id))
          (set! (-> v1-26 params volume) -4)
          (set! (-> v1-26 auto-time) 24)
          (set! (-> v1-26 auto-from) 2)
          (set! (-> v1-26 params mask) (the-as uint 17))
          (-> v1-26 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-pre-open-stop)
            (sound-play-by-spec (-> self sound-pre-open-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (while (< (ja-aframe-num 0) (-> self open-frame))
        (if (and (zero? (-> self sound-id))
                 (-> self sound-lock-loop)
                 (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                      (not arg0)
                      (-> self visible-move?)
                      )
                 )
            (set! (-> self sound-id) (sound-play-by-spec (-> self sound-lock-loop) (new-sound-id) (the-as vector #t)))
            )
        (rotate-gear! self 65536.0)
        (suspend)
        ;; pc port note: added speed modifier
        (ja :num! (seek! (ja-aframe (-> self open-frame) 0) (* (get-airlock-speed *pc-settings*) 2.0)))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-49 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-49 command) (sound-command set-param))
          (set! (-> v1-49 id) (-> self sound-id))
          (set! (-> v1-49 params volume) -4)
          (set! (-> v1-49 auto-time) 24)
          (set! (-> v1-49 auto-from) 2)
          (set! (-> v1-49 params mask) (the-as uint 17))
          (-> v1-49 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        (if (-> self sound-lock-stop)
            (sound-play-by-spec (-> self sound-lock-stop) (new-sound-id) (the-as vector #t))
            )
        )
      (while (not (destination-loaded? self #t))
        (rotate-gear! self 65536.0)
        (suspend)
        (transform-post)
        )
      (process-entity-status! self (entity-perm-status subtask-complete) #t)
      (let ((s5-10 (res-lump-struct (-> self entity) 'on-enter structure)))
        (if s5-10
            (script-eval (the-as pair s5-10))
            )
        )
      (if (and (-> self sound-open)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (sound-play-by-spec (-> self sound-open) (new-sound-id) (the-as vector #t))
          )
      (if (and (-> self sound-open-loop)
               (and (or (-> self sound-behind?) (>= (check-crossing-distance self (target-pos 0) #f) 0.0))
                    (not arg0)
                    (-> self visible-move?)
                    )
               )
          (set! (-> self sound-id) (sound-play-by-spec (-> self sound-open-loop) (new-sound-id) (the-as vector #t)))
          )
      (set! (-> *ACTOR-bank* birth-max) 1000)
      (while (not (ja-max? 0))
        (rotate-gear! self 65536.0)
        (suspend)
        ;; pc port note: added speed modifier
        (ja :num! (seek! max (get-airlock-speed *pc-settings*)))
        (transform-post)
        )
      (when (nonzero? (-> self sound-id))
        (let ((v1-94 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-94 command) (sound-command set-param))
          (set! (-> v1-94 id) (-> self sound-id))
          (set! (-> v1-94 params volume) -4)
          (set! (-> v1-94 auto-time) 24)
          (set! (-> v1-94 auto-from) 2)
          (set! (-> v1-94 params mask) (the-as uint 17))
          (-> v1-94 id)
          )
        (set! (-> self sound-id) (new 'static 'sound-id))
        0
        )
      (when (nonzero? (-> self gear-sound-id))
        (let ((v1-99 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
          (set! (-> v1-99 command) (sound-command set-param))
          (set! (-> v1-99 id) (-> self gear-sound-id))
          (set! (-> v1-99 params volume) -4)
          (set! (-> v1-99 auto-time) 24)
          (set! (-> v1-99 auto-from) 2)
          (set! (-> v1-99 params mask) (the-as uint 17))
          (-> v1-99 id)
          )
        (set! (-> self gear-sound-id) (new 'static 'sound-id))
        0
        )
      (if (and (-> self sound-open-stop) (not arg0) (-> self visible-move?))
          (sound-play-by-spec (-> self sound-open-stop) (new-sound-id) (the-as vector #t))
          )
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (ja :group! (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
        :num! (identity
          (the float (+ (-> (get-art-by-name (-> self draw art-group) "idle" art-joint-anim) frames num-frames) -1))
          )
        )
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    (none)
    )
  )

(deftype com-airlock-outer (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! com-airlock-outer ((obj com-airlock-outer) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 7)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (init-airlock! obj)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-com-airlock-outer" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj pre-open-frame) 35.0)
  (set! (-> obj lock-frame) 45.0)
  (set! (-> obj open-frame) 45.0)
  (set! (-> obj sound-pre-open) (static-sound-spec "airlock-slider"))
  (set! (-> obj sound-pre-open-stop) (static-sound-spec "airlock-slide-e"))
  (set! (-> obj sound-open) (static-sound-spec "airlock-seal"))
  (set! (-> obj sound-open-loop) (static-sound-spec "airlock-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "airlock-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "airlock-open"))
  (set! (-> obj sound-close-stop) (static-sound-spec "airlock-hit"))
  (set! (-> obj sound-post-close) (static-sound-spec "airlock-slider"))
  (set! (-> obj sound-post-close-stop) (static-sound-spec "airlock-slide-e"))
  (go (method-of-object obj close) #t)
  (none)
  )

(deftype com-airlock-inner (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! com-airlock-inner ((obj com-airlock-inner) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 20480.0 0.0 57344.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 8)
      (set-vector! (-> v1-10 local-sphere) 0.0 20480.0 0.0 32768.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-com-airlock-inner" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj lock-frame) 37.0)
  (set! (-> obj pre-open-frame) 65.0)
  (set! (-> obj open-frame) 75.0)
  (set! (-> obj gear) (new 'process 'joint-mod (joint-mod-mode rotate) obj 12))
  (set! (-> obj inner?)
        (logtest? (the-as int (res-lump-value (-> obj entity) 'options uint128 :default (the-as uint128 1) :time -1000000000.0))
                  1
                  )
        )
  (set! (-> obj pre-open-speed) 0.9)
  (set! (-> obj sound-gear) (static-sound-spec "airlock-gear"))
  (set! (-> obj sound-pre-open) (static-sound-spec "airlock-slider"))
  (set! (-> obj sound-pre-open-stop) (static-sound-spec "airlock-slide-e"))
  (set! (-> obj sound-lock-loop) (static-sound-spec "airlock-turn"))
  (set! (-> obj sound-lock-stop) (static-sound-spec "airlock-unlock"))
  (set! (-> obj sound-open) (static-sound-spec "airlock-seal"))
  (set! (-> obj sound-open-loop) (static-sound-spec "airlock-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "airlock-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "airlock-open"))
  (set! (-> obj sound-close-stop) (static-sound-spec "airlock-hit"))
  (go (method-of-object obj close) #t)
  (none)
  )

(defskelgroup skel-fort-entry-gate fort-entry-gate fort-entry-gate-lod0-jg fort-entry-gate-idle-ja
              ((fort-entry-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 10)
              )

(deftype fort-entry-gate (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! fort-entry-gate ((obj fort-entry-gate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 12288.0 0.0 40960.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 8192.0 16384.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) -8192.0 16384.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fort-entry-gate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "door-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "door-stop-open"))
  (set! (-> obj sound-close-loop) (static-sound-spec "door-close"))
  (set! (-> obj sound-close-stop) (static-sound-spec "door-stop-close"))
  (go (method-of-object obj close) #t)
  (none)
  )

(defskelgroup skel-hip-door-a hip-door-a hip-door-a-lod0-jg hip-door-a-idle-ja
              ((hip-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

(deftype hip-door-a (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! hip-door-a ((obj hip-door-a) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-hip-door-a" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> obj sound-close-stop) (static-sound-spec "wood-close-hit"))
  (set! (-> obj door-radius) 8192.0)
  (go (method-of-object obj close) #t)
  (none)
  )

(defskelgroup skel-tomb-mar-door tomb-mar-door tomb-mar-door-lod0-jg tomb-mar-door-idle-ja
              ((tomb-mar-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 18)
              :origin-joint-index 3
              )

(deftype tomb-mar-door (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-mar-door ((obj tomb-mar-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 24576.0 0.0 73728.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-mar-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "wing-door-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "wing-open-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "wing-door-close"))
  (set! (-> obj sound-close-stop) (static-sound-spec "wing-close-hit"))
  (go (method-of-object obj close) #t)
  (none)
  )

(deftype cas-front-door (com-airlock-outer)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


(defskelgroup skel-pal-throne-door pal-throne-door pal-throne-door-lod0-jg pal-throne-door-idle-ja
              ((pal-throne-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 6 0 24)
              :origin-joint-index 3
              )

(deftype pal-throne-door (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! pal-throne-door ((obj pal-throne-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 24576.0 0.0 73728.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 5)
      (set-vector! (-> v1-8 local-sphere) 0.0 -24576.0 0.0 65536.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 -24576.0 0.0 65536.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-pal-throne-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "wood-door-slide"))
  (set! (-> obj sound-open-stop) (static-sound-spec "wood-door-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "wood-door-slide"))
  (set! (-> obj sound-close-stop) (static-sound-spec "wood-door-hit"))
  (set! (-> obj sound-behind?) #t)
  (go (method-of-object obj close) #t)
  (none)
  )

(defskelgroup skel-vin-door-ctyinda vin-door-ctyinda 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 3 0 6)
              )

(deftype vin-door-ctyinda (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! vin-door-ctyinda ((obj vin-door-ctyinda) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 12288.0 0.0 24576.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 8192.0 16384.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) -8192.0 16384.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vin-door-ctyinda" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> obj sound-close-stop) (static-sound-spec "wood-close-hit"))
  (set! (-> obj door-radius) 8192.0)
  (go (method-of-object obj close) #t)
  (none)
  )

(defskelgroup skel-under-door hip-door-a hip-door-a-lod0-jg hip-door-a-idle-ja
              ((hip-door-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 5)
              )

(deftype under-door (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! under-door ((obj under-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-under-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> obj sound-close-stop) (static-sound-spec "wood-close-hit"))
  (set! (-> obj door-radius) 8192.0)
  (go (method-of-object obj close) #t)
  (none)
  )

(defskelgroup skel-oracle-door oracle-door 0 2 ((1 (meters 999999))) :bounds (static-spherem 0 4 0 10))

(deftype oracle-door (com-airlock)
  ()
  :heap-base #x100
  :method-count-assert 28
  :size-assert         #x174
  :flag-assert         #x1c01000174
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! oracle-door ((obj oracle-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 1024) ;; added
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 0.0 8192.0 0.0 16384.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-oracle-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (init-airlock! obj)
  (set! (-> obj sound-open-loop) (static-sound-spec "wood-door-open"))
  (set! (-> obj sound-open-stop) (static-sound-spec "wood-open-hit"))
  (set! (-> obj sound-close-loop) (static-sound-spec "wood-door-close"))
  (set! (-> obj sound-close-stop) (static-sound-spec "wood-close-hit"))
  (go (method-of-object obj close) #t)
  (none)
  )
