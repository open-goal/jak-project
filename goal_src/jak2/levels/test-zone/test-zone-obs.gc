;;-*-Lisp-*-
(in-package goal)
(deftype test-actor (process-drawable)
  ((root       collide-shape-moving :override)
   (birth-time time-frame)
   (base       vector :inline)
   (old-base   vector :inline)
   (bob-offset int64)
   (bob-amount float))
  (:methods
   (init-collision! (_type_) object))
  (:state-methods
   idle))

(def-actor test-actor
  :bounds (0 0 0 5))

(defmethod init-collision! ((this test-actor))
  (let ((cshape (new 'process 'collide-shape-moving this (collide-list-enum hit-by-player))))
    (set! (-> cshape dynam) (copy *standard-dynamics* 'process))
    (set! (-> cshape reaction) cshape-reaction-default)
    (set! (-> cshape no-reaction) (the (function collide-shape-moving collide-query vector vector object) nothing))
    (let ((mesh (new 'process 'collide-shape-prim-mesh cshape (the uint 0) (the uint 0))))
      (set! (-> mesh prim-core collide-as) (collide-spec pusher))
      (set! (-> mesh collide-with) (collide-spec jak player-list))
      (set! (-> mesh prim-core action) (collide-action solid rideable))
      (set! (-> mesh transform-index) 0)
      (set! (-> cshape total-prims) (the uint 1))
      (set! (-> cshape root-prim) mesh)
      (set-vector! (-> mesh local-sphere) 0.0 (meters 0) 0.0 (meters 5)))
    (pusher-init cshape)
    (set! (-> cshape nav-radius) (* 0.75 (-> cshape root-prim local-sphere w)))
    (let ((prim (-> cshape root-prim)))
      (set! (-> cshape backup-collide-as) (-> prim prim-core collide-as))
      (set! (-> cshape backup-collide-with) (-> prim prim-core collide-with))
      )
    (set! (-> this root) cshape)))

(defmethod init-from-entity! ((this test-actor) (e entity-actor))
  (logior! (-> this mask) (process-mask enemy))
  (init-collision! this)
  (process-drawable-from-entity! this e)
  (set! (-> this bob-amount) 1024.0)
  (set! (-> this bob-offset)
        (+ (the int (-> this root trans x)) (the int (-> this root trans y)) (the int (-> this root trans z))))
  (set-time! (-> this birth-time))
  (vector-copy! (-> this base) (-> this root trans))
  (vector-copy! (-> this old-base) (-> this root trans))
  (initialize-skeleton this *test-actor-sg* '())
  (logclear! (-> this mask) (process-mask actor-pause))
  (transform-post)
  (go-virtual idle :proc this)
  (none))

(defbehavior test-actor-init-by-other test-actor ((pos vector))
  (logior! (-> self mask) (process-mask enemy))
  (init-collision! self)
  (initialize-skeleton self *test-actor-sg* '())
  (vector-copy! (-> self root trans) pos)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self bob-amount) 1024.0)
  (set! (-> self bob-offset)
        (+ (the int (-> self root trans x)) (the int (-> self root trans y)) (the int (-> self root trans z))))
  (set-time! (-> self birth-time))
  (vector-copy! (-> self base) (-> self root trans))
  (vector-copy! (-> self old-base) (-> self root trans))
  (logclear! (-> self mask) (process-mask actor-pause))
  (transform-post)
  (go-virtual idle))

(defstate idle (test-actor)
  :virtual #t
  :event
    (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
      (case message
        (('attack 'touch)
         ; (if (= (-> proc type) target)
         ;   (send-event proc 'attack #f (static-attack-info ((shove-up (meters 2.5)) (shove-back (meters 7.5)))))
         ;   )
         #t)))
  :code
    (behavior ()
      (loop
        (quaternion-rotate-y! (-> self root quat) (-> self root quat) (* (degrees 45) (seconds-per-frame)))
        (let ((bob (-> self bob-amount)))
          (when (< 0.0 bob)
            (set! (-> self root trans y)
                  (+ (-> self base y)
                     (* bob
                        (sin (* 109.22667 (the float (mod (+ (- (current-time) (-> self birth-time)) (-> self bob-offset)) (seconds 2))))))))
            (update-transforms (-> self root))))
        ; (debug-draw-tris (-> (res-lump-struct (-> self draw art-group data 0 extra) 'collide-mesh-group (array collide-mesh)) 0) self 2)
        ; (dotimes (i (-> self node-list length))
        ;   (let* ((joint (-> self node-list data i)) (jpos (vector<-cspace! (new-stack-vector0) joint)))
        ;     (add-debug-sphere #t (bucket-id debug) jpos (meters 0.1) (static-rgba 0 #xff 0 #x40))
        ;     (add-debug-text-sphere (!= (-> joint joint) #f) (bucket-id debug) jpos (meters 0.1) (-> joint joint name) (static-rgba 0 #xff 0 #x40))
        ;     )
        ;   )
        (suspend)))
  :post transform-post)
