;;-*-Lisp-*-
(in-package goal)

;; name: castle-obs.gc
;; name in dgo: castle-obs
;; dgos: CAS

;; DECOMP BEGINS

(define *cas-conveyor-room-id* 0)

(deftype cas-conveyor (conveyor)
  ((actor-group         (pointer actor-group))
   (actor-group-count   int32)
   (texture-anim-index  uint32)
   (my-id               int32)
   (sound-id            sound-id)
   (target-speed        float)
   )
  )


(defmethod init! ((this cas-conveyor))
  "Initializes defaults for things like the `speed` and `belt-radius`"
  (let ((t9-0 (method-of-type conveyor init!)))
    (t9-0 this)
    )
  (set! (-> this speed) (res-lump-float (-> this entity) 'speed :default 30720.0))
  (set! (-> this belt-radius) (res-lump-float (-> this entity) 'center-radius :default 15974.4))
  (set! (-> this texture-anim-index) (res-lump-value (-> this entity) 'index uint :time -1000000000.0))
  (set! (-> this my-id)
        (res-lump-value (-> this entity) 'extra-id int :default (the-as uint128 -1) :time -1000000000.0)
        )
  (set! (-> this pull-y-threshold) 409.6)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-conveyor) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (reset-root! this)
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (< (-> this path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (init! this)
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this target-speed) (-> this speed))
  (conveyor-method-21 this)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-16 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-16 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-16))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (go (method-of-object this idle))
  (none)
  )

(defmethod deactivate ((this cas-conveyor))
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

;; WARN: Return type mismatch sound-id vs none.
(defbehavior sound-update cas-conveyor ()
  (when (and *target*
             (and (>= 327680.0 (vector-vector-distance (-> self collide-bounds) (-> *target* control trans)))
                  (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                  )
             )
    (let ((f0-2 (* 0.000032552085 (+ -30720.0 (fabs (-> self speed))))))
      (sound-play-by-name
        (static-sound-name "castle-conveyor")
        (-> self sound-id)
        1024
        (the int (* 1524.0 f0-2))
        0
        (sound-group sfx)
        (-> self collide-bounds)
        )
      )
    )
  (none)
  )

(defstate idle (cas-conveyor)
  :virtual #t
  :trans sound-update
  :code sleep-code
  :post (behavior ()
    (when (or (= (-> self my-id) -1) (= (-> self my-id) (/ *cas-conveyor-room-id* 8)))
      (cond
        ((zero? (-> self actor-group-count))
         (set! (-> self speed) (seek-with-smooth (-> self speed) (-> self target-speed) 61440.0 0.1 409.6))
         )
        (else
          (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-1 from) (process->ppointer self))
            (set! (-> a1-1 num-params) 1)
            (set! (-> a1-1 message) 'get-speed)
            (set! (-> a1-1 param 0) (the-as uint #f))
            (let ((t9-1 send-event-function)
                  (v1-13 (-> self actor-group 0 data 0 actor))
                  )
              (set! (-> self speed) (the-as float (t9-1
                                                    (if v1-13
                                                        (-> v1-13 extra process)
                                                        )
                                                    a1-1
                                                    )
                                            )
                    )
              )
            )
          )
        )
      (set-conveyor-speed! (the-as int (-> self texture-anim-index)) (-> self speed))
      )
    (let ((t9-3 (-> (method-of-type conveyor idle) post)))
      (if t9-3
          ((the-as (function none) t9-3))
          )
      )
    )
  )

(deftype cas-conveyor-switch (process-focusable)
  ((actor-group         (pointer actor-group))
   (actor-group-count   int32)
   (incoming-attack-id  uint32)
   (quat0               quaternion  :inline)
   (quat180             quaternion  :inline)
   (red-pos             vector      :inline)
   (blue-pos            vector      :inline)
   (track-flag          symbol)
   (lightning-timer     time-frame)
   (speed               float)
   (target-speed        float)
   )
  (:state-methods
    idle
    )
  )


(set! (-> *lightning-spec-id-table* 27) (new 'static 'lightning-spec
                                          :name "lightning-cas-switch"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                                          :reduction 0.42
                                          :num-points 6
                                          :box-size 8192.0
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 1638.4
                                          :duration 30.0
                                          :sound #f
                                          )
      )

(defskelgroup skel-cas-conveyor-switch cas-conveyor-switch cas-conveyor-switch-lod0-jg cas-conveyor-switch-idle-ja
              ((cas-conveyor-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0.7 0 3.5)
              :origin-joint-index 3
              )

(defstate idle (cas-conveyor-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((v1-1 (the-as object (-> block param 1))))
         (when (!= (-> (the-as attack-info v1-1) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-1) id))
           (when (and (-> self track-flag) (= (-> self speed) (-> self target-speed)))
             (set! (-> self target-speed) (- (-> self target-speed)))
             (sound-play "cas-shot-switch")
             )
           )
         )
       )
      (('track)
       (-> self track-flag)
       )
      (('get-speed)
       (-> self speed)
       )
      )
    )
  :trans (behavior ()
    (let ((f30-0 (-> self speed)))
      (set! (-> self speed) (seek-with-smooth (-> self speed) (-> self target-speed) 61440.0 0.1 409.6))
      (cond
        ((< f30-0 0.0)
         (quaternion-smooth-seek! (-> self root quat) (-> self root quat) (-> self quat180) 0.1)
         (launch-particles (-> *part-id-table* 5119) (-> self blue-pos))
         )
        (else
          (quaternion-smooth-seek! (-> self root quat) (-> self root quat) (-> self quat0) 0.1)
          (launch-particles (-> *part-id-table* 5120) (-> self red-pos))
          )
        )
      )
    (cond
      ((or (zero? (-> self actor-group-count))
           (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
           )
       (set! (-> self track-flag) #t)
       )
      (else
        (let ((gp-0 0))
          (dotimes (s5-0 (length (-> self actor-group 0)))
            (let ((v1-16 (-> self actor-group 0 data s5-0))
                  (a1-5 (new 'stack-no-clear 'event-message-block))
                  )
              (set! (-> a1-5 from) (process->ppointer self))
              (set! (-> a1-5 num-params) 0)
              (set! (-> a1-5 message) 'stopped?)
              (let ((t9-5 send-event-function)
                    (v1-17 (-> v1-16 actor))
                    )
                (if (not (t9-5
                           (if v1-17
                               (-> v1-17 extra process)
                               )
                           a1-5
                           )
                         )
                    (+! gp-0 1)
                    )
                )
              )
            )
          (cond
            ((zero? gp-0)
             (set-castle-electricity-scale! 0.0)
             (process-entity-status! self (entity-perm-status subtask-complete) #t)
             )
            (else
              (set-castle-electricity-scale! 1.0)
              )
            )
          (set! (-> self track-flag) (zero? gp-0))
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (local-vars (sv-608 symbol) (sv-624 symbol) (sv-640 (function vector cspace vector)) (sv-656 vector))
    (when (and (logtest? (actor-option user17) (-> self fact options))
               (not (-> self track-flag))
               (< (-> self lightning-timer) (current-time))
               )
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 quad) (-> *y-vector* quad))
        (let ((gp-0 (new 'stack-no-clear 'collide-query)))
          (vector-rotate-x! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 5.0)))
          (vector-rotate-y! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 360.0)))
          (set! (-> gp-0 start-pos quad) (-> self root trans quad))
          (vector-normalize-copy! (-> gp-0 move-dist) s5-0 40960.0)
          (let ((v1-11 gp-0))
            (set! (-> v1-11 radius) 409.6)
            (set! (-> v1-11 collide-with) (collide-spec backgnd enemy obstacle))
            (set! (-> v1-11 ignore-process0) self)
            (set! (-> v1-11 ignore-process1) #f)
            (set! (-> v1-11 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
            (set! (-> v1-11 action-mask) (collide-action solid))
            )
          (let ((f0-5 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
            (when (< 0.0 f0-5)
              (let ((s5-2 (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 start-pos) (-> gp-0 move-dist) f0-5))
                    (gp-1 45)
                    (s4-2 (get-process *default-dead-pool* lightning-tracker #x4000))
                    )
                (when s4-2
                  (let ((t9-7 (method-of-type lightning-tracker activate)))
                    (t9-7
                      (the-as lightning-tracker s4-2)
                      *entity-pool*
                      (symbol->string (-> lightning-tracker symbol))
                      (the-as pointer #x70004000)
                      )
                    )
                  (let ((s3-2 run-function-in-process)
                        (s2-2 s4-2)
                        (s1-0 lightning-tracker-init)
                        (s0-0 (-> *lightning-spec-id-table* 27))
                        )
                    (set! sv-608 (the-as symbol #f))
                    (set! sv-624 (the-as symbol #f))
                    (set! sv-640 vector<-cspace!)
                    (set! sv-656 (new 'stack-no-clear 'vector))
                    (let* ((a1-8 (-> self node-list data (+ (rand-vu-int-count 3) 4)))
                           (t2-0 (sv-640 sv-656 a1-8))
                           )
                      ((the-as (function object object object object object object object object none) s3-2)
                       s2-2
                       s1-0
                       s0-0
                       gp-1
                       sv-608
                       sv-624
                       t2-0
                       s5-2
                       )
                      )
                    )
                  (-> s4-2 ppointer)
                  )
                )
              (set! (-> self lightning-timer) (+ (current-time) (the int (* 300.0 (rand-vu-float-range 0.04 0.1)))))
              )
            )
          )
        )
      )
    (transform-post)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-conveyor-switch) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 1228.8 0.0 14336.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-cas-conveyor-switch" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (logior! (-> this mask) (process-mask enemy))
  (set! (-> this fact)
        (new 'process 'fact-info this (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f))
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (!= (-> this path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (get-point-in-path! (-> this path) (-> this red-pos) 0.0 'exact)
  (get-point-in-path! (-> this path) (-> this blue-pos) 1.0 'exact)
  (set! (-> this lightning-timer) 0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-27 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-27 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-27))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this quat0 quad) (-> this root quat quad))
  (quaternion-rotate-y! (-> this quat180) (-> this quat0) 32768.0)
  (set! (-> this speed) (res-lump-float (-> this entity) 'speed :default 30720.0))
  (set! (-> this target-speed) (-> this speed))
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-electric-fence (process-focusable)
  ((next-spawn-time  time-frame)
   (stop             symbol)
   )
  (:state-methods
    idle
    die
    )
  )


(defskelgroup skel-cas-electric-fence cas-electric-fence cas-electric-fence-lod0-jg cas-electric-fence-idle-ja
              ((cas-electric-fence-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 2)
              )

(defskelgroup skel-cas-electric-fence-explode cas-electric-fence cas-electric-fence-explode-lod0-jg cas-electric-fence-explode-idle-ja
              ((cas-electric-fence-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.2)
              )

(define *cas-electric-fence-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      )
    :collide-spec #x1
    :art-level #f
    )
  )

(defstate die (cas-electric-fence)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cas-electric-fence-explode" (the-as (pointer uint32) #f))
        5
        gp-0
        *cas-electric-fence-exploder-params*
        :to self
        )
      )
    (sound-play "lightning-node")
    (suspend)
    (logior! (-> self entity extra perm status) (entity-perm-status dead))
    (let ((gp-2 (current-time)))
      (until (time-elapsed? gp-2 (seconds 4))
        (suspend)
        )
      )
    (cleanup-for-death self)
    )
  )

(defstate idle (cas-electric-fence)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       #f
       )
      (('attack)
       #f
       )
      (('track)
       #t
       )
      (('stop)
       (let ((v0-0 #t))
         (set! (-> self stop) v0-0)
         v0-0
         )
       )
      (('stopped?)
       (-> self stop)
       )
      )
    )
  :code sleep-code
  :post (behavior ()
    (when (not (-> self stop))
      (when (< (-> self next-spawn-time) (current-time))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (set! (-> s5-0 quad) (-> *y-vector* quad))
          (let ((gp-0 (new 'stack-no-clear 'collide-query)))
            (vector-rotate-x! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 140.0)))
            (vector-rotate-y! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 360.0)))
            (set! (-> gp-0 start-pos quad) (-> self root trans quad))
            (+! (-> gp-0 start-pos y) 15400.96)
            (vector-normalize-copy! (-> gp-0 move-dist) s5-0 40960.0)
            (let ((v1-9 gp-0))
              (set! (-> v1-9 radius) 409.6)
              (set! (-> v1-9 collide-with) (collide-spec backgnd enemy obstacle))
              (set! (-> v1-9 ignore-process0) self)
              (set! (-> v1-9 ignore-process1) #f)
              (set! (-> v1-9 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-9 action-mask) (collide-action solid))
              )
            (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
              (when (< 0.0 f0-7)
                (let ((s5-2 (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 start-pos) (-> gp-0 move-dist) f0-7)))
                  (let ((s4-2 120))
                    (process-spawn
                      lightning-tracker
                      :init lightning-tracker-init
                      (new 'static 'lightning-spec
                        :name #f
                        :flags (lightning-spec-flags lsf0)
                        :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                        :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                        :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                        :fade-start-factor 0.2
                        :texture (new 'static 'texture-id :index #x83 :page #xc)
                        :reduction 0.42
                        :num-points 16
                        :box-size 16384.0
                        :merge-factor 0.5
                        :merge-count 2
                        :radius 2048.0
                        :duration 30.0
                        :sound (static-sound-spec "shock" :fo-min 10 :fo-max 40)
                        )
                      s4-2
                      #f
                      #f
                      (-> gp-0 start-pos)
                      s5-2
                      :to *entity-pool*
                      )
                    (let ((v1-22 (get-field-spec-by-id (-> *part-id-table* 166) (sp-field-id spt-timer))))
                      (if v1-22
                          (set! (-> v1-22 initial-valuef) (the-as float s4-2))
                          )
                      )
                    )
                  (launch-particles (-> *part-id-table* 166) s5-2)
                  )
                (set! (-> self next-spawn-time) (+ (current-time) (the int (* 300.0 (rand-vu-float-range 0.07 0.4)))))
                )
              )
            )
          )
        )
      (let ((gp-2 *target*))
        (when (and gp-2 (not (logtest? (-> gp-2 focus-status) (focus-status disable dead ignore inactive))))
          (let ((s4-3 (get-trans gp-2 0)))
            (when (< (vector-vector-distance s4-3 (-> self root trans)) 24576.0)
              (send-event
                gp-2
                'attack
                #f
                (static-attack-info
                  ((id (new-attack-id))
                   (vector (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s4-3 (-> self root trans)) 1.0))
                   (shove-back (meters 6))
                   (shove-up (meters 3))
                   (control (if (focus-test? gp-2 board)
                                1.0
                                0.0
                                )
                            )
                   )
                  )
                )
              (let ((s5-4 (new 'stack-no-clear 'vector)))
                (set! (-> s5-4 quad) (-> self root trans quad))
                (+! (-> s5-4 y) 15400.96)
                (process-spawn
                  lightning-tracker
                  :init lightning-tracker-init
                  (-> *lightning-spec-id-table* 1)
                  225
                  #f
                  #f
                  s5-4
                  6
                  :to gp-2
                  )
                )
              )
            )
          )
        )
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-electric-fence) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid deadly))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 6144.0 0.0 8192.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-electric-fence" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this next-spawn-time) 0)
  (set! (-> this stop) #f)
  (ja-channel-set! 1)
  (let ((a0-14 (-> this skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-button (basebutton)
  ()
  (:methods
    (cas-button-method-39 (_type_) none)
    )
  )


(defskelgroup skel-cas-button cas-button cas-button-lod0-jg cas-button-idle-ja
              ((cas-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2.25)
              )

(defmethod basebutton-method-34 ((this cas-button))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 9216.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod prepare-trigger-event! ((this cas-button))
  "Sets `event-going-down` to `'trigger`"
  (set! (-> this event-down) 'shutdown)
  0
  (none)
  )

(defstate up-idle (cas-button)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((v1-1 (the-as attack-info (-> block param 1))))
         (case (-> v1-1 mode)
           (('flop)
            (when (or (not (or (= (-> v1-1 mode) 'spin) (= (-> v1-1 mode) 'punch)))
                      (logtest? (-> self button-status) (button-status button-status-3))
                      )
              (send-event! self (-> self event-going-down))
              (sound-play "big-red-button")
              (go-virtual going-down)
              )
            )
           )
         )
       )
      )
    )
  )

(defmethod basebutton-method-33 ((this cas-button))
  "TODO - joint stuff"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> this button-status) (button-status pressed))
     (let ((s5-1 (-> this skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> this draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> this draw art-group data 2)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> this skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> this draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (set! (-> this anim-speed) 2.0)
  (transform-post)
  (none)
  )

(deftype cas-elevator (elevator)
  ((sound-id  sound-id)
   )
  (:methods
    (cas-elevator-method-49 (_type_) none)
    )
  )


(defskelgroup skel-cas-elevator cas-elevator cas-elevator-lod0-jg cas-elevator-up-down-ja
              ((cas-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 9)
              )

(defmethod get-art-group ((this cas-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-cas-elevator" (the-as (pointer uint32) #f))
  )

;; WARN: Return type mismatch float vs none.
(defmethod cas-elevator-method-49 ((this cas-elevator))
  (let* ((f0-1 (fmax 0.0 (- (-> this root trans y) (-> this bottom-top 0))))
         (f0-3 (* 0.001171875 (- f0-1 (* (the float (the int (/ f0-1 30720.0))) 30720.0))))
         (v1-6 (-> this skel root-channel 0))
         )
    (set! (-> v1-6 num-func) num-func-identity)
    (set! (-> v1-6 frame-num) f0-3)
    )
  (none)
  )

(defmethod move-between-points ((this cas-elevator) (arg0 vector) (arg1 float) (arg2 float))
  "Move between two points on the elevator's path
@param vec TODO not sure
@param point-a The first point fetched from the elevator's path
@param point-b The second point fetched from the path
@see [[path-control]] and [[elevator]]"
  (let ((s5-0 (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) arg1 'interp))
        (a0-3 (get-point-in-path! (-> this path) (new 'stack-no-clear 'vector) arg2 'interp))
        (v1-3 (-> this root trans))
        )
    (when (and (< (-> a0-3 y) (-> s5-0 y)) (< (-> arg0 y) (+ -8192.0 (-> v1-3 y))))
      (let ((a0-8 (vector-! (new 'stack-no-clear 'vector) arg0 v1-3)))
        (< (sqrtf (+ (* (-> a0-8 x) (-> a0-8 x)) (* (-> a0-8 z) (-> a0-8 z)))) 36864.0)
        )
      )
    )
  )

(defmethod commited-to-ride? ((this cas-elevator))
  "@returns if the target is considered within the elevator area enough to begin descending/ascending"
  (let* ((s5-0 *target*)
         (a0-2 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (when a0-2
      (let* ((a0-3 (get-trans a0-2 0))
             (v1-2 (vector-! (new 'stack-no-clear 'vector) a0-3 (-> this root trans)))
             )
        (< (sqrtf (+ (* (-> v1-2 x) (-> v1-2 x)) (* (-> v1-2 z) (-> v1-2 z)))) 28672.0)
        )
      )
    )
  )

(defstate waiting (cas-elevator)
  :virtual #t
  :post (behavior ()
    (if (-> self bouncing)
        (cas-elevator-method-49 self)
        )
    (let ((t9-1 (-> (method-of-type elevator waiting) post)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    )
  )

(defstate running (cas-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator running) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (sound-play "cas-elevate" :id (-> self sound-id) :position (-> self root trans))
    )
  :post (behavior ()
    (cas-elevator-method-49 self)
    (let ((t9-1 (-> (method-of-type elevator running) post)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    (when *sound-player-enable*
      (let ((gp-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-0 command) (sound-command set-param))
        (set! (-> gp-0 id) (-> self sound-id))
        (let ((a1-0 (-> self root trans)))
          (let ((s5-0 self))
            (when (= a1-0 #t)
              (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root)))
                  (set! a1-0 (-> s5-0 root trans))
                  (set! a1-0 (the-as vector #f))
                  )
              )
            )
          (sound-trans-convert (the-as vector3w (-> gp-0 params trans)) a1-0)
          )
        (set! (-> gp-0 params mask) (the-as uint 32))
        (-> gp-0 id)
        )
      )
    )
  )

(defstate arrived (cas-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator arrived) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (sound-stop (-> self sound-id))
    (sound-play "cas-elevate-end")
    )
  :post (behavior ()
    (if (-> self bouncing)
        (cas-elevator-method-49 self)
        )
    (let ((t9-1 (-> (method-of-type elevator arrived) post)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    )
  )

(defmethod deactivate ((this cas-elevator))
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

(defmethod init-plat! ((this cas-elevator))
  "Does any necessary initial platform setup.
For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (set! (-> this sound-id) (new-sound-id))
  (cas-elevator-method-49 this)
  (none)
  )

(defmethod init-plat-collision! ((this cas-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 36864.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(deftype cas-rot-bridge (process-drawable)
  ((index       uint32)
   (anim-index  uint32)
   (test-index  uint32)
   (pos         float)
   (pos-old     float)
   (sound-id    sound-id)
   (sound-flag  symbol)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-cas-rot-bridge cas-rot-bridge cas-rot-bridge-lod0-jg cas-rot-bridge-idle-ja
              ((cas-rot-bridge-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 -8 14)
              :origin-joint-index 3
              )

(defstate idle (cas-rot-bridge)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (local-vars (v0-0 number))
    (case message
      (('move)
       (set! (-> self anim-index) (/ (the-as int (-> block param 0)) 8))
       (set! v0-0 (logclear (-> self mask) (process-mask sleep-code)))
       (set! (-> self mask) (the-as process-mask v0-0))
       v0-0
       )
      (('get-pos)
       (set! (-> self test-index) (/ (the-as int (-> block param 0)) 8))
       (let ((f0-0 (ja-aframe-num 0)))
         (cond
           ((zero? (-> self test-index))
            (if (< f0-0 10.0)
                (set! f0-0 10.0)
                )
            (if (< 40.0 f0-0)
                (set! f0-0 40.0)
                )
            (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
            )
           ((= (-> self test-index) 1)
            (if (< f0-0 50.0)
                (set! f0-0 50.0)
                )
            (if (< 80.0 f0-0)
                (set! f0-0 80.0)
                )
            (set! (-> self pos) (* 0.033333335 (+ -50.0 f0-0)))
            )
           ((= (-> self test-index) 2)
            (if (< f0-0 90.0)
                (set! f0-0 90.0)
                )
            (if (< 120.0 f0-0)
                (set! f0-0 120.0)
                )
            (set! (-> self pos) (* 0.033333335 (+ -90.0 f0-0)))
            )
           ((= (-> self test-index) 3)
            (if (< f0-0 10.0)
                (set! f0-0 10.0)
                )
            (if (< 40.0 f0-0)
                (set! f0-0 40.0)
                )
            (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
            )
           )
         )
       (-> self pos)
       )
      (('reset)
       (when (nonzero? (-> self anim-index))
         (ja-no-eval :group! cas-rot-bridge-section-one-ja :num! min)
         (set! (-> self anim-index) (the-as uint 0))
         (set! v0-0 (logclear (-> self mask) (process-mask sleep-code)))
         (set! (-> self mask) (the-as process-mask v0-0))
         v0-0
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      (let ((f0-0 (ja-aframe-num 0)))
        (cond
          ((zero? (-> self anim-index))
           (when (or (= f0-0 10.0) (= f0-0 40.0) (= f0-0 50.0))
             (cond
               ((= f0-0 10.0)
                (ja-no-eval :group! cas-rot-bridge-section-one-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
               (else
                 (ja-no-eval :group! cas-rot-bridge-section-one-reverse-ja :num! (seek! 0.0) :frame-num max)
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! 0.0))
                   )
                 )
               )
             )
           )
          ((= (-> self anim-index) 1)
           (when (or (= f0-0 40.0) (= f0-0 50.0) (= f0-0 80.0) (= f0-0 90.0))
             (cond
               ((or (= f0-0 40.0) (= f0-0 50.0))
                (ja-no-eval :group! cas-rot-bridge-section-two-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
               (else
                 (ja-no-eval :group! cas-rot-bridge-section-two-reverse-ja :num! (seek! 0.0) :frame-num max)
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! 0.0))
                   )
                 )
               )
             )
           )
          ((= (-> self anim-index) 2)
           (when (or (= f0-0 80.0) (= f0-0 90.0) (= f0-0 120.0))
             (cond
               ((or (= f0-0 80.0) (= f0-0 90.0))
                (ja-no-eval :group! cas-rot-bridge-section-three-ja :num! (seek!) :frame-num 0.0)
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
               (else
                 (ja-no-eval :group! cas-rot-bridge-section-three-reverse-ja :num! (seek! 0.0) :frame-num max)
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! 0.0))
                   )
                 )
               )
             )
           )
          ((= (-> self anim-index) 3)
           (cond
             ((= f0-0 10.0)
              (ja-no-eval :group! cas-rot-bridge-single-section-ja :num! (seek!) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              )
             (else
               (ja-no-eval :group! cas-rot-bridge-single-section-reverse-ja :num! (seek! 0.0) :frame-num max)
               (until (ja-done? 0)
                 (suspend)
                 (ja :num! (seek! 0.0))
                 )
               )
             )
           )
          )
        )
      )
    #f
    )
  :post (behavior ()
    (let ((f0-0 (ja-aframe-num 0)))
      (cond
        ((zero? (-> self anim-index))
         (if (< f0-0 10.0)
             (set! f0-0 10.0)
             )
         (if (< 40.0 f0-0)
             (set! f0-0 40.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
         )
        ((= (-> self anim-index) 1)
         (if (< f0-0 50.0)
             (set! f0-0 50.0)
             )
         (if (< 80.0 f0-0)
             (set! f0-0 80.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -50.0 f0-0)))
         )
        ((= (-> self anim-index) 2)
         (if (< f0-0 90.0)
             (set! f0-0 90.0)
             )
         (if (< 120.0 f0-0)
             (set! f0-0 120.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -90.0 f0-0)))
         )
        ((= (-> self anim-index) 3)
         (if (< f0-0 10.0)
             (set! f0-0 10.0)
             )
         (if (< 40.0 f0-0)
             (set! f0-0 40.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
         )
        )
      )
    (let* ((f0-9 (-> self pos))
           (f1-13 (- f0-9 (-> self pos-old)))
           )
      (set! (-> self pos-old) f0-9)
      (when (!= f1-13 0.0)
        (cond
          ((< 0.0 f1-13)
           (cond
             ((< f0-9 1.0)
              (sound-play
                "track-plat-loop"
                :id (-> self sound-id)
                :position (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node cas-rot-bridge-lod0-jg b))
                )
              (set! (-> self sound-flag) #t)
              )
             ((-> self sound-flag)
              (sound-play
                "track-plat-stop"
                :position (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node cas-rot-bridge-lod0-jg b))
                )
              (sound-stop (-> self sound-id))
              (set! (-> self sound-flag) #f)
              )
             )
           )
          (else
            (cond
              ((< 0.0 f0-9)
               (sound-play
                 "track-plat-loop"
                 :id (-> self sound-id)
                 :position (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node cas-rot-bridge-lod0-jg b))
                 )
               (set! (-> self sound-flag) #t)
               )
              ((-> self sound-flag)
               (sound-play
                 "track-plat-stop"
                 :position (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node cas-rot-bridge-lod0-jg b))
                 )
               (sound-stop (-> self sound-id))
               (set! (-> self sound-flag) #f)
               )
              )
            )
          )
        )
      )
    (transform-post)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-rot-bridge) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 5) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 6))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 5)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 57344.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 18432.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 5120.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set! (-> v1-13 transform-index) 5)
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 18432.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 6)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 5120.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 7)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 18432.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-20 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-20 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-20 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-rot-bridge" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (quaternion-rotate-y! (-> this root quat) (-> this root quat) 16384.0)
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! (-> this index) (res-lump-value (-> this entity) 'index uint :time -1000000000.0))
  (let ((v1-30 (-> this index)))
    (cond
      ((zero? v1-30)
       (+! (-> this root trans x) 5734.4)
       (let ((s5-2 (-> this skel root-channel 0)))
         (joint-control-channel-group! s5-2 (the-as art-joint-anim (-> this draw art-group data 6)) num-func-identity)
         (set! (-> s5-2 frame-num) 0.0)
         )
       )
      ((= v1-30 1)
       (let ((s5-3 (-> this skel root-channel 0)))
         (joint-control-channel-group! s5-3 (the-as art-joint-anim (-> this draw art-group data 3)) num-func-identity)
         (set! (-> s5-3 frame-num) 0.0)
         )
       )
      )
    )
  (set! (-> this draw light-index) (the-as uint 1))
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this sound-flag) #f)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-switch (process-drawable)
  ((actor-group         (pointer actor-group))
   (actor-group-count   int32)
   (incoming-attack-id  uint32)
   (anim-index          uint32)
   (direction           uint32)
   (pos-old             float)
   (y-start             float)
   (y-delta             float)
   (sound-id            sound-id)
   (sound-flag          symbol)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-cas-switch cas-switch cas-switch-lod0-jg cas-switch-idle-ja
              ((cas-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2.7 0 3)
              :origin-joint-index 3
              )

(defstate idle (cas-switch)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((gp-0 (the-as attack-info (-> block param 1))))
         (when (or (= (-> gp-0 mode) 'spin) (= (-> gp-0 mode) 'spin-air))
           (let* ((s5-0 (the-as object (-> block param 0)))
                  (s4-0 (-> (the-as touching-shapes-entry s5-0) head))
                  )
             (while s4-0
               (let ((a0-2 (get-touched-prim s4-0 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s5-0))))
                 (when (= (-> a0-2 prim-id) 1)
                   (when (!= (-> gp-0 id) (-> self incoming-attack-id))
                     (set! (-> self incoming-attack-id) (-> gp-0 id))
                     (let ((s3-0 (-> self actor-group 0)))
                       (dotimes (s2-0 (-> s3-0 length))
                         (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
                           (set! (-> a1-6 from) (process->ppointer self))
                           (set! (-> a1-6 num-params) 1)
                           (set! (-> a1-6 message) 'move)
                           (set! (-> a1-6 param 0) (* (-> self anim-index) 8))
                           (let ((t9-1 send-event-function)
                                 (v1-20 (-> s3-0 data s2-0 actor))
                                 )
                             (t9-1
                               (if v1-20
                                   (-> v1-20 extra process)
                                   )
                               a1-6
                               )
                             )
                           )
                         )
                       )
                     )
                   )
                 )
               (set! s4-0 (-> s4-0 next))
               )
             )
           #f
           )
         )
       )
      )
    )
  :trans rider-trans
  :code (behavior ()
    (until #f
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer self))
        (set! (-> a1-0 num-params) 1)
        (set! (-> a1-0 message) 'get-pos)
        (set! (-> a1-0 param 0) (* (-> self anim-index) 8))
        (let* ((t9-0 send-event-function)
               (v1-8 (-> self actor-group 0 data 0 actor))
               (a0-0 (if v1-8
                         (-> v1-8 extra process)
                         )
                     )
               (f30-0 (the-as float (t9-0 a0-0 a1-0)))
               (f28-0 (- f30-0 (-> self pos-old)))
               )
          (set! (-> self pos-old) f30-0)
          (when (!= f28-0 0.0)
            (set! (-> self root trans y) (+ (-> self y-start) (* f30-0 (-> self y-delta))))
            (if (< (* (-> self y-delta) f28-0) 0.0)
                (quaternion-rotate-y! (-> self root quat) (-> self root quat) 1820.4445)
                (quaternion-rotate-y! (-> self root quat) (-> self root quat) -1820.4445)
                )
            (cond
              ((< 0.0 f28-0)
               (cond
                 ((< f30-0 1.0)
                  (sound-play "cas-valve-loop" :id (-> self sound-id) :position (-> self root trans))
                  (set! (-> self sound-flag) #t)
                  )
                 ((-> self sound-flag)
                  (sound-play "cas-valve-stop")
                  (sound-stop (-> self sound-id))
                  (set! (-> self sound-flag) #f)
                  )
                 )
               )
              (else
                (cond
                  ((< 0.0 f30-0)
                   (sound-play "cas-valve-loop" :id (-> self sound-id) :position (-> self root trans))
                   (set! (-> self sound-flag) #t)
                   )
                  ((-> self sound-flag)
                   (sound-play "cas-valve-stop")
                   (sound-stop (-> self sound-id))
                   (set! (-> self sound-flag) #f)
                   )
                  )
                )
              )
            )
          )
        )
      (suspend)
      )
    #f
    )
  :post rider-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-switch) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid no-standon))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 11059.2 0.0 12288.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 11059.2 0.0 12288.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 1))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid rideable))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 11059.2 0.0 12288.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-switch" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logclear! (-> this mask) (process-mask actor-pause))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-22 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-22 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-22))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this anim-index) (res-lump-value (-> this entity) 'index uint :time -1000000000.0))
  (set! (-> this direction) (res-lump-value (-> this entity) 'extra-id uint :time -1000000000.0))
  (let ((s5-2 (-> this root trans))
        (s4-2 (-> this root trans))
        (t9-10 (method-of-type res-lump get-property-struct))
        (a0-27 (-> this entity))
        (a1-19 'trans-offset)
        (a2-9 'interp)
        (a3-7 -1000000000.0)
        (t0-6 (new 'stack-no-clear 'vector))
        )
    (set! (-> t0-6 x) 0.0)
    (set! (-> t0-6 y) 0.0)
    (set! (-> t0-6 z) 0.0)
    (set! (-> t0-6 w) 1.0)
    (vector+!
      s5-2
      s4-2
      (the-as vector (t9-10 a0-27 a1-19 a2-9 a3-7 t0-6 (the-as (pointer res-tag) #f) *res-static-buf*))
      )
    )
  (set! (-> this y-start) (-> this root trans y))
  (if (zero? (-> this direction))
      (set! (-> this y-delta) -12288.0)
      (set! (-> this y-delta) 12288.0)
      )
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this sound-flag) #f)
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-trapdoor (process-drawable)
  ((root  collide-shape :override)
   )
  (:state-methods
    idle
    die
    )
  )


(defskelgroup skel-cas-trapdoor cas-trapdoor cas-trapdoor-lod0-jg cas-trapdoor-idle-ja
              ((cas-trapdoor-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defskelgroup skel-cas-trapdoor-explode cas-trapdoor cas-trapdoor-explode-lod0-jg cas-trapdoor-explode-idle-ja
              ((cas-trapdoor-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *cas-trapdoor-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(defstate idle (cas-trapdoor)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (let ((gp-0 (the-as object (-> block param 1))))
         (when (and (not (task-node-closed? (game-task-node castle-boss-resolution)))
                    (logtest? (-> (the-as attack-info gp-0) penetrate-using) (penetrate flop))
                    )
           (go-virtual die)
           #f
           )
         )
       )
      )
    )
  :code sleep-code
  )

(defstate die (cas-trapdoor)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (sound-play "trapdoor")
    (let ((gp-1 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
      (let* ((s5-1 *target*)
             (a0-3 (if (type? s5-1 process-focusable)
                       s5-1
                       )
                   )
             )
        (when a0-3
          (set! (-> gp-1 fountain-rand-transv-lo quad) (-> (get-trans a0-3 0) quad))
          (+! (-> gp-1 fountain-rand-transv-lo y) -16384.0)
          )
        )
      (set! (-> gp-1 fountain-rand-transv-hi x) 24576.0)
      (set! (-> gp-1 fountain-rand-transv-hi y) 81920.0)
      (set! (-> gp-1 fountain-rand-transv-hi z) 12288.0)
      (set! (-> gp-1 fountain-rand-transv-hi w) 32768.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cas-trapdoor-explode" (the-as (pointer uint32) #f))
        5
        gp-1
        *cas-trapdoor-exploder-params*
        :to self
        )
      )
    )
  :code (behavior ()
    (sound-play "trapdoor")
    (suspend)
    (ja-channel-set! 0)
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 1))
        (suspend)
        )
      )
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post ja-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-trapdoor) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 0)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (if (not (task-node-closed? (game-task-node castle-boss-resolution)))
      (set! (-> this root penetrated-by) (penetrate flop))
      )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-trapdoor" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((a0-14 (-> this skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-chain-plat (process-focusable)
  ()
  (:state-methods
    idle
    drop
    down
    )
  )


(defskelgroup skel-cas-chain-plat cas-chain-plat cas-chain-plat-lod0-jg cas-chain-plat-idle-ja
              ((cas-chain-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 6)
              :origin-joint-index 4
              )

(defstate idle (cas-chain-plat)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (sound-play "cas-shelf-plat")
       (go-virtual drop)
       )
      (('track)
       #t
       )
      )
    )
  :code sleep-code
  :post ja-post
  )

(defstate drop (cas-chain-plat)
  :virtual #t
  :code (behavior ()
    (ja-no-eval :group! cas-chain-plat-drop-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual down)
    )
  :post transform-post
  )

(defstate down (cas-chain-plat)
  :virtual #t
  :code sleep-code
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-chain-plat) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 4)
      (set-vector! (-> v1-2 local-sphere) 0.0 12288.0 0.0 24576.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-chain-plat" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> this mask) (process-mask enemy))
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-rot-blade (process-drawable)
  ((sync       sync-eased  :inline)
   (rot        float)
   (attack-id  uint32)
   (sound-id   sound-id)
   )
  (:state-methods
    idle
    )
  )


(defskelgroup skel-cas-rot-blade cas-rot-blade cas-rot-blade-lod0-jg cas-rot-blade-idle-ja
              ((cas-rot-blade-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              :shadow cas-rot-blade-shadow-mg
              )

(define *cas-rot-blade-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 8192.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

(defun cas-rot-blade-callback ((arg0 cspace) (arg1 transformq))
  (quaternion-rotate-local-y! (-> arg1 quat) (-> arg1 quat) (* 606.8148 (the float (current-time))))
  (cspace<-parented-transformq-joint! arg0 arg1)
  0
  (none)
  )

(defstate idle (cas-rot-blade)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touched)
       (let* ((s4-0 (the-as object (-> block param 0)))
              (s3-0 (-> (the-as touching-shapes-entry s4-0) head))
              )
         (while s3-0
           (let ((a0-3 (get-touched-prim s3-0 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s4-0))))
             (if (= (-> a0-3 prim-id) 1)
                 (send-event proc 'attack (-> block param 0) (static-attack-info ((id (new-attack-id)))))
                 )
             )
           (set! s3-0 (-> s3-0 next))
           )
         )
       #f
       )
      )
    )
  :trans (behavior ()
    (set! (-> self rot) (+ 1820.4445 (get-scaled-val! (-> self sync) 29127.111 0)))
    (quaternion-vector-angle! (-> self root quat) *y-vector* (-> self rot))
    (sound-play
      "cas-arm-blade"
      :id (-> self sound-id)
      :position (vector<-cspace! (new 'stack-no-clear 'vector) (joint-node cas-rot-blade-lod0-jg blade))
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post transform-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-rot-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (set! (-> s4-0 event-self) 'touched)
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 49152.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid deadly))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 14336.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-rot-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this draw light-index) (the-as uint 2))
  (let ((a1-10 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-20 0))
      (if #t
          (set! v1-20 (logior v1-20 1))
          )
      (set! (-> a1-10 sync-type) 'sync-eased)
      (set! (-> a1-10 sync-flags) (the-as sync-flags v1-20))
      )
    (set! (-> a1-10 period) (the-as uint 1800))
    (set! (-> a1-10 entity) arg0)
    (set! (-> a1-10 percent) 0.0)
    (set! (-> a1-10 ease-in) 0.15)
    (set! (-> a1-10 ease-out) 0.15)
    (set! (-> a1-10 pause-in) 0.2)
    (set! (-> a1-10 pause-out) 0.0)
    (initialize! (-> this sync) a1-10)
    )
  (let ((a0-26 (-> this node-list data 4)))
    (set! (-> a0-26 param0) cas-rot-blade-callback)
    (set! (-> a0-26 param1) this)
    )
  (set! (-> this sound-id) (new-sound-id))
  (set! (-> this draw shadow-ctrl) *cas-rot-blade-shadow-control*)
  (go (method-of-object this idle))
  (none)
  )

(defmethod deactivate ((this cas-rot-blade))
  (sound-stop (-> this sound-id))
  (call-parent-method this)
  (none)
  )

(deftype cas-flag-a (process-drawable)
  ()
  (:state-methods
    idle
    )
  )


(defskelgroup skel-cas-flag-a cas-flag-a cas-flag-a-lod0-jg cas-flag-a-idle-ja
              ((cas-flag-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 8.5)
              )

(defstate idle (cas-flag-a)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-flag-a) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-flag-a" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-flag-b (process-drawable)
  ()
  (:state-methods
    idle
    )
  )


(defskelgroup skel-cas-flag-b cas-flag-b cas-flag-b-lod0-jg cas-flag-b-idle-ja
              ((cas-flag-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 8.5)
              )

(defstate idle (cas-flag-b)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post ja-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-flag-b) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-flag-b" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  (none)
  )

(deftype cas-robot-door (process-drawable)
  ((spawner-actor      symbol)
   (door-actor         entity-actor  2)
   (spawn-count        int32)
   (spawn-count-total  int32)
   (spawn-max          int32)
   (spawn-total        int32)
   (notice-dist        float)
   (player-dist        float)
   (anim-index         int32)
   (last-guard         handle)
   (actor-group        (pointer actor-group))
   (actor-group-count  int32)
   )
  (:state-methods
    idle
    spawning
    castle-wait-end
    )
  )


(defskelgroup skel-cas-robot-door cas-robot-door cas-robot-door-lod0-jg cas-robot-door-idle-ja
              ((cas-robot-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defstate idle (cas-robot-door)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('trigger)
       (go-virtual spawning)
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.6))
      (let ((a0-1 *target*))
        (if (and a0-1
                 (not (focus-test? a0-1 disable dead))
                 (< (vector-vector-distance (get-trans a0-1 0) (-> self root trans)) (-> self notice-dist))
                 )
            (go-virtual spawning)
            )
        )
      (set-time! (-> self state-time))
      )
    )
  :code sleep-code
  )

(defstate spawning (cas-robot-door)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('roboguard-die)
       (let ((v0-0 (+ (-> self spawn-count) -1)))
         (set! (-> self spawn-count) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self spawn-count) 0)
    (set! (-> self spawn-count-total) 0)
    (set! (-> self player-dist) (-> self notice-dist))
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.6))
      (let ((a0-1 *target*))
        (if (and a0-1 (not (logtest? (-> a0-1 focus-status) (focus-status disable dead))))
            (set! (-> self player-dist) (vector-vector-distance (get-trans a0-1 0) (-> self root trans)))
            )
        )
      (set-time! (-> self state-time))
      )
    )
  :code (behavior ()
    (sound-play "robo-hatch-open")
    (ja-no-eval :group! cas-robot-door-idle-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-1 (current-time)))
      (until (time-elapsed? gp-1 (seconds 0.5))
        (suspend)
        )
      )
    (while (or (= (-> self spawn-total) -1) (< (-> self spawn-count-total) (-> self spawn-total)))
      (when (and (< (-> self player-dist) (+ 81920.0 (-> self notice-dist)))
                 (and (< (-> self spawn-count) (-> self spawn-max))
                      (or (not (handle->process (-> self last-guard)))
                          (not (and (-> (handle->process (-> self last-guard)) next-state)
                                    (= (-> (handle->process (-> self last-guard)) next-state name) ''ambush)
                                    )
                               )
                          )
                      )
                 )
        (let ((gp-2 (new 'stack-no-clear 'enemy-init-by-other-params)))
          (set! (-> gp-2 trans quad) (-> self root trans quad))
          (quaternion-copy! (-> gp-2 quat) *unity-quaternion*)
          (set! (-> gp-2 entity) (the-as entity (-> self spawner-actor)))
          (set! (-> gp-2 directed?) #f)
          (set! (-> gp-2 no-initial-move-to-ground?) #f)
          (let* ((s5-1 (get-process *default-dead-pool* roboguard-level #x4000))
                 (v1-52 (when s5-1
                          (let ((t9-8 (method-of-type process activate)))
                            (t9-8 s5-1 self (symbol->string (-> roboguard-level symbol)) (the-as pointer #x70004000))
                            )
                          (run-now-in-process s5-1 enemy-init-by-other self gp-2)
                          (-> s5-1 ppointer)
                          )
                        )
                 )
            (when v1-52
              (set! (-> self last-guard) (ppointer->handle v1-52))
              (+! (-> self spawn-count) 1)
              (+! (-> self spawn-count-total) 1)
              )
            )
          )
        )
      (let ((gp-3 (current-time)))
        (until (time-elapsed? gp-3 (the int (* 300.0 (rand-vu-float-range 0.5 1.0))))
          (suspend)
          )
        )
      )
    (while (> (-> self spawn-count) 0)
      (let ((gp-4 (current-time)))
        (until (time-elapsed? gp-4 (seconds 0.43))
          (suspend)
          )
        )
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (cond
      ((= (-> self anim-index) -1)
       (cond
         ((= (-> self actor-group-count) 1)
          (go-virtual castle-wait-end)
          )
         ((= (-> self actor-group-count) 2)
          (until (process-grab? *target* #f)
            (suspend)
            )
          (let ((a3-4 (res-lump-struct (-> self entity) 'camera-name structure)))
            (if a3-4
                (set-setting! 'entity-name a3-4 0.0 0)
                )
            )
          (let ((gp-5 (current-time)))
            (until (time-elapsed? gp-5 (seconds 2))
              (suspend)
              )
            )
          (dotimes (gp-6 (-> self actor-group 1 length))
            (let ((a1-17 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-17 from) (process->ppointer self))
              (set! (-> a1-17 num-params) 0)
              (set! (-> a1-17 message) 'stop)
              (let ((t9-16 send-event-function)
                    (v1-102 (-> self actor-group 1 data gp-6 actor))
                    )
                (t9-16
                  (if v1-102
                      (-> v1-102 extra process)
                      )
                  a1-17
                  )
                )
              )
            )
          )
         )
       )
      (else
        (until (process-grab? *target* #f)
          (suspend)
          )
        (let ((a3-6 (res-lump-struct (-> self entity) 'camera-name structure)))
          (if a3-6
              (set-setting! 'entity-name a3-6 0.0 0)
              )
          )
        (let ((gp-7 (current-time)))
          (until (time-elapsed? gp-7 (seconds 1))
            (suspend)
            )
          )
        (let ((gp-8 (-> self actor-group 0)))
          (dotimes (s5-3 (-> gp-8 length))
            (let ((a1-21 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-21 from) (process->ppointer self))
              (set! (-> a1-21 num-params) 1)
              (set! (-> a1-21 message) 'move)
              (set! (-> a1-21 param 0) (the-as uint (* (-> self anim-index) 8)))
              (let ((t9-20 send-event-function)
                    (v1-128 (-> gp-8 data s5-3 actor))
                    )
                (t9-20
                  (if v1-128
                      (-> v1-128 extra process)
                      )
                  a1-21
                  )
                )
              )
            )
          )
        )
      )
    (sound-play "robo-hatch-cls")
    (ja-no-eval :group! cas-robot-door-idle-ja :num! (seek! 0.0) :frame-num max)
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek! 0.0))
      )
    (let ((gp-10 (current-time)))
      (until (time-elapsed? gp-10 (seconds 1))
        (suspend)
        )
      )
    (remove-setting! 'entity-name)
    (until (process-release? *target*)
      (suspend)
      )
    (sleep-code)
    )
  :post (behavior ()
    '()
    )
  )

(defstate castle-wait-end (cas-robot-door)
  :virtual #t
  :code (behavior ()
    (local-vars (v1-28 symbol))
    (sound-play "robo-hatch-cls")
    (ja-no-eval :group! cas-robot-door-idle-ja :num! (seek! 0.0) :frame-num max)
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek! 0.0))
      )
    (while (begin
             (dotimes (v1-27 (-> self actor-group 0 length))
               (when (not (logtest? (-> self actor-group 0 data v1-27 actor extra perm status) (entity-perm-status subtask-complete))
                          )
                 (set! v1-28 #f)
                 (goto cfg-14)
                 )
               )
             (set! v1-28 #t)
             (goto cfg-14)
             (label cfg-14)
             (not v1-28)
             )
      (let ((gp-1 (current-time)))
        (until (time-elapsed? gp-1 (seconds 0.51))
          (suspend)
          )
        )
      )
    (until (process-grab? *target* #f)
      (suspend)
      )
    (let ((a3-2 (res-lump-struct (-> self entity) 'camera-name structure)))
      (if a3-2
          (set-setting! 'entity-name a3-2 0.0 0)
          )
      )
    (let ((gp-2 (current-time)))
      (until (time-elapsed? gp-2 (seconds 1))
        (suspend)
        )
      )
    (task-node-close! (game-task-node castle-break-in-resolution))
    (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-7 from) (process->ppointer self))
      (set! (-> a1-7 num-params) 2)
      (set! (-> a1-7 message) 'open)
      (set! (-> a1-7 param 0) (the-as uint 6000))
      (set! (-> a1-7 param 1) (the-as uint #f))
      (let ((t9-10 send-event-function)
            (v1-47 (-> self door-actor 0))
            )
        (t9-10
          (if v1-47
              (-> v1-47 extra process)
              )
          a1-7
          )
        )
      )
    (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-8 from) (process->ppointer self))
      (set! (-> a1-8 num-params) 2)
      (set! (-> a1-8 message) 'open)
      (set! (-> a1-8 param 0) (the-as uint 6000))
      (set! (-> a1-8 param 1) (the-as uint #f))
      (let ((t9-11 send-event-function)
            (v1-54 (-> self door-actor 1))
            )
        (t9-11
          (if v1-54
              (-> v1-54 extra process)
              )
          a1-8
          )
        )
      )
    (let ((gp-3 (current-time)))
      (until (time-elapsed? gp-3 (seconds 2.5))
        (suspend)
        )
      )
    (remove-setting! 'entity-name)
    (until (process-release? *target*)
      (suspend)
      )
    (sleep-code)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cas-robot-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  ;; og:preserve-this added
  (stack-size-set! (-> this main-thread) 512)
  (local-vars (sv-16 res-tag) (sv-32 res-tag))
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-robot-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this spawner-actor) (the-as symbol (entity-actor-lookup arg0 'alt-actor 0)))
  (set! (-> this door-actor 0) (entity-actor-lookup arg0 'alt-actor 1))
  (set! (-> this door-actor 1) (entity-actor-lookup arg0 'alt-actor 2))
  (set! (-> this spawn-max) 5)
  (set! (-> this spawn-total) -1)
  (set! (-> this last-guard) (the-as handle #f))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-13 (res-lump-data arg0 'extra-id (pointer int32) :tag-ptr (& sv-16))))
    (when v1-13
      (set! (-> this spawn-max) (-> v1-13 0))
      (if (< (the-as uint 1) (-> sv-16 elt-count))
          (set! (-> this spawn-total) (-> v1-13 1))
          )
      )
    )
  (set! (-> this notice-dist) (res-lump-float arg0 'notice-dist :default 122880.0))
  (set! (-> this anim-index)
        (res-lump-value (-> this entity) 'index int :default (the-as uint128 -1) :time -1000000000.0)
        )
  (set! sv-32 (new 'static 'res-tag))
  (let ((v1-17 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-32))))
    (cond
      ((and v1-17 (nonzero? (-> sv-32 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-17))
       (set! (-> this actor-group-count) (the-as int (-> sv-32 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (let ((a0-27 (-> this skel root-channel 0)))
    (set! (-> a0-27 frame-group) (the-as art-joint-anim (-> this draw art-group data 2)))
    (set! (-> a0-27 frame-num) 0.0)
    (joint-control-channel-group! a0-27 (the-as art-joint-anim (-> this draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype lightning-ball (process-drawable)
  ((root   collide-shape :override)
   (timer  time-frame)
   )
  (:state-methods
    idle
    )
  )


(set! (-> *lightning-spec-id-table* 28) (new 'static 'lightning-spec
                                          :name "lightning-ball-shock"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 60.0
                                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 16384.0
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 8192.0
                                          :duration 30.0
                                          :sound (static-sound-spec "shock" :volume 50.0 :fo-min 10 :fo-max 30)
                                          )
      )

(defstate idle (lightning-ball)
  :virtual #t
  :code sleep-code
  :post (behavior ()
    (when (time-elapsed? (-> self timer) (seconds 0.08))
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (let ((f30-1 (* 182.04445 (rand-vu-float-range -20.0 20.0)))
              (f28-1 (* 182.04445 (rand-vu-float-range -180.0 180.0)))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s5-0 quad) (-> *x-vector* quad))
          (vector-rotate-around-z! s5-0 s5-0 f30-1)
          (vector-rotate-around-y! s5-0 s5-0 f28-1)
          (vector+float*! (-> gp-0 start-pos) (-> self root trans) s5-0 56320.0)
          (vector-float*! (-> gp-0 move-dist) s5-0 81920.0)
          )
        (let ((v1-11 gp-0))
          (set! (-> v1-11 radius) 409.6)
          (set! (-> v1-11 collide-with) (collide-spec backgnd obstacle hit-by-others-list))
          (set! (-> v1-11 ignore-process0) self)
          (set! (-> v1-11 ignore-process1) #f)
          (set! (-> v1-11 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-11 action-mask) (collide-action solid))
          )
        (let ((f30-2 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
          (if (< 0.0 f30-2)
              (process-spawn
                lightning-tracker
                :init lightning-tracker-init
                (-> *lightning-spec-id-table* 28)
                (the int (* 300.0 (rand-vu-float-range 0.1 0.3)))
                #f
                #f
                (-> gp-0 start-pos)
                (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 start-pos) (-> gp-0 move-dist) f30-2)
                :to self
                )
              )
          )
        )
      (set-time! (-> self timer))
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this lightning-ball) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 56320.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (set-time! (-> this timer))
  (update-transforms (-> this root))
  (go (method-of-object this idle))
  (none)
  )
