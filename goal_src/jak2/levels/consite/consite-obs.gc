;;-*-Lisp-*-
(in-package goal)

;; name: consite-obs.gc
;; name in dgo: consite-obs
;; dgos: COA

(declare-type consite-bomb-elevator process-drawable)

;; DECOMP BEGINS

(defskelgroup skel-consite-break-piece-break-d consite-break-scaffold consite-break-scaffold-break-d-lod0-jg consite-break-scaffold-break-d-idle-ja
              ((consite-break-scaffold-break-d-lod0-mg (meters 999999)))
              :bounds (static-spherem 25 17 -25 45)
              )

(deftype consite-break-scaffold (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defstate idle (consite-break-scaffold)
  :virtual #t
  :code (the-as (function none :behavior consite-break-scaffold) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! consite-break-scaffold ((obj consite-break-scaffold) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-consite-break-piece-break-d" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (ja-post)
  (cond
    ((task-node-closed? (game-task-node consite-find-baron-resolution))
     (cleanup-for-death obj)
     (logclear! (-> obj mask) (process-mask actor-pause))
     (go empty-state)
     )
    (else
      (go (method-of-object obj idle))
      )
    )
  (none)
  )

(deftype consite-bomb-elevator-hinges (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-consite-bomb-elevator-hinges consite-bomb-elevator consite-bomb-elevator-hinges-lod0-jg consite-bomb-elevator-hinges-idle-ja
              ((consite-bomb-elevator-hinges-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -25 0 45)
              :origin-joint-index 3
              )

(defstate idle (consite-bomb-elevator-hinges)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior consite-bomb-elevator-hinges) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! consite-bomb-elevator-hinges ((obj consite-bomb-elevator-hinges) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-consite-bomb-elevator-hinges" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior consite-bomb-elevator-hinges-init-by-other consite-bomb-elevator-hinges ((arg0 consite-bomb-elevator) (arg1 entity-actor))
  (set! (-> self root) (new 'process 'trsqv))
  (process-drawable-from-entity! self arg1)
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-consite-bomb-elevator-hinges" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (go-virtual idle)
  (none)
  )

(deftype consite-bomb-elevator (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-consite-bomb-elevator consite-bomb-elevator consite-bomb-elevator-lod0-jg consite-bomb-elevator-idle-ja
              ((consite-bomb-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -25 0 45)
              :origin-joint-index 3
              )

(defstate idle (consite-bomb-elevator)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior consite-bomb-elevator) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! consite-bomb-elevator ((obj consite-bomb-elevator) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 1) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 2))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 -102400.0 0.0 184320.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 61440.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-consite-bomb-elevator" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (process-spawn consite-bomb-elevator-hinges obj arg0 :to obj)
  (go (method-of-object obj idle))
  (none)
  )

(deftype consite-silo-doors (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-consite-silo-doors consite-silo-doors consite-silo-doors-lod0-jg consite-silo-doors-idle-ja
              ((consite-silo-doors-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 10 0 40)
              :origin-joint-index 3
              )

(defstate idle (consite-silo-doors)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior consite-silo-doors) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! consite-silo-doors ((obj consite-silo-doors) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 40960.0 0.0 163840.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 4)
      (set-vector! (-> v1-8 local-sphere) -40960.0 0.0 0.0 61440.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 5)
      (set-vector! (-> v1-10 local-sphere) 40960.0 0.0 0.0 61440.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-consite-silo-doors" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(defun consite-activate ()
  (update-mood-weather! *mood-control* 1.0 1.0 30.0 30.0)
  0
  (none)
  )

(deftype baron-npc (process-taskable)
  ()
  :heap-base #xa0
  :method-count-assert 38
  :size-assert         #x120
  :flag-assert         #x2600a00120
  )


(defmethod get-art-elem baron-npc ((obj baron-npc))
  "Checks various things such the current actor, task status, etc to determine the right art-group data to use
@returns the appropriate [[art-element]] for the given NPC"
  (case (-> obj task actor)
    (((game-task-actor baron-consite))
     (-> obj draw art-group data 4)
     )
    (else
      (-> obj draw art-group data 3)
      )
    )
  )

(defmethod init-art! baron-npc ((obj baron-npc))
  "@see [[initialize-skeleton]]"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-baron-highres" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj draw light-index) (the-as uint 10))
  (set! (-> obj draw shadow) #f)
  0
  (none)
  )
