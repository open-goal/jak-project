;;-*-Lisp-*-
(in-package goal)

;; name: widow.gc
;; name in dgo: widow
;; dgos: TOA

;; DECOMP BEGINS

;; WARN: Return type mismatch joint-control-channel vs none.
(defbehavior widow-common widow ()
  (update! (-> self theta) 0.0)
  (widow-rand-vector-method-10 (-> self rand-vec))
  (widow-oscillator-method-10 (-> self noise-osc) (-> self rand-vec value))
  (widow-oscillator-method-10 (-> self osc) (the-as vector #f))
  (widow-float-seeker-method-11 (-> self left-cover-angle) 0.0)
  (widow-float-seeker-method-11 (-> self right-cover-angle) 0.0)
  (quaternion-axis-angle!
    (-> self left-cover-jm quat)
    1.0
    0.0
    0.0
    (* -16384.0 (-> self left-cover-angle value))
    )
  (quaternion-axis-angle!
    (-> self right-cover-jm quat)
    1.0
    0.0
    0.0
    (* -16384.0 (-> self right-cover-angle value))
    )
  (update! (-> self drill-speed) 0.0)
  (+! (-> self drill-angle) (* 3495.2534 (-> self drill-speed value)))
  (quaternion-axis-angle! (-> self left-drill-jm quat) 0.0 1.0 0.0 (-> self drill-angle))
  (quaternion-axis-angle! (-> self right-drill-jm quat) 0.0 1.0 0.0 (-> self drill-angle))
  (let ((f30-0 (-> self drill-speed value)))
    (let ((v1-23 (ja-group)))
      (if (and (and v1-23 (= v1-23 (-> self draw art-group data 7))) (< 20.0 (ja-aframe-num 0)))
          (set! f30-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 20.0 78.0))
          )
      )
    (let ((v1-32 (ja-group)))
      (if (and (and v1-32 (= v1-32 (-> self draw art-group data 18))) (< (ja-aframe-num 0) 522.0))
          (set! f30-0 (lerp-scale 1.0 0.0 (ja-aframe-num 0) 505.0 552.0))
          )
      )
    (cond
      ((< 0.001 f30-0)
       (sound-play-by-name
         (static-sound-name "widow-drill")
         (-> self drill-sound)
         (the int (* 1024.0 f30-0))
         (the int (* 1524.0 (* 0.5 (+ -1.0 f30-0))))
         0
         (sound-group sfx)
         (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 11))
         )
       (set! (-> self drill-sound-playing) #t)
       )
      ((-> self drill-sound-playing)
       (sound-stop (-> self drill-sound))
       (set! (-> self drill-sound-playing) #f)
       )
      )
    )
  (let ((f30-1 (-> self drill-speed value)))
    (let ((v1-53 (ja-group)))
      (if (and (and v1-53 (= v1-53 (-> self draw art-group data 7))) (< 77.0 (ja-aframe-num 0)))
          (set! f30-1 1.0)
          )
      )
    (cond
      ((< 0.001 f30-1)
       (sound-play
         "widow-dril-swtn"
         :id (-> self drill-sweeten-sound)
         :position (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 11))
         )
       (set! (-> self drill-sweeten-sound-playing) #t)
       )
      ((-> self drill-sweeten-sound-playing)
       (sound-stop (-> self drill-sweeten-sound))
       (set! (-> self drill-sweeten-sound-playing) #f)
       )
      )
    )
  (cond
    ((-> self flying)
     (sound-play-by-name
       (static-sound-name "widow-hover")
       (-> self hover-sound)
       (the int (* 1024.0 (lerp-scale 0.5 1.0 (-> self osc value y) -20480.0 -4096.0)))
       0
       0
       (sound-group sfx)
       (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 3))
       )
     (set! (-> self hover-sound-playing) #t)
     )
    ((-> self hover-sound-playing)
     (sound-stop (-> self hover-sound))
     (set! (-> self hover-sound-playing) #f)
     )
    )
  (let ((v1-81 (ja-group)))
    (when (or (and v1-81 (or (= v1-81 (-> self draw art-group data 8))
                             (= v1-81 (-> self draw art-group data 19))
                             (= v1-81 (-> self draw art-group data 22))
                             )
                   )
              (let ((v1-87 (ja-group)))
                (and (and v1-87 (= v1-87 (-> self draw art-group data 7))) (< 77.0 (ja-aframe-num 0)))
                )
              )
      (let ((gp-5 (new 'stack-no-clear 'vector)))
        (when (nonzero? (-> self drill-spark-part))
          (vector<-cspace! gp-5 (-> self node-list data 11))
          (vector+float*! gp-5 gp-5 (-> self node-list data 11 bone transform vector 1) 10854.4)
          (spawn (-> self drill-spark-part) gp-5)
          )
        (when (nonzero? (-> self drill-spark-part-alt))
          (vector<-cspace! gp-5 (-> self node-list data 44))
          (vector+float*! gp-5 gp-5 (-> self node-list data 44 bone transform vector 1) 10854.4)
          (spawn (-> self drill-spark-part-alt) gp-5)
          )
        )
      )
    )
  (when (and (nonzero? (-> self extract-stone-time))
             (< (- (current-time) (-> self extract-stone-time)) (seconds 2))
             (nonzero? (-> self extract-stone-part))
             )
    (let ((gp-6 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-6 (-> self node-list data 44))
      (spawn (-> self extract-stone-part) gp-6)
      )
    )
  (when (and (nonzero? (-> self insert-stone-time))
             (< (- (current-time) (-> self insert-stone-time)) (seconds 2))
             (nonzero? (-> self insert-stone-part))
             )
    (let ((s5-5 (handle->process (-> self pod))))
      (when s5-5
        (let ((gp-7 (vector<-cspace! (new 'stack-no-clear 'vector) (-> (the-as process-focusable s5-5) node-list data 4))))
          (let ((s4-5 (new 'stack-no-clear 'vector)))
            (vector-matrix*!
              s4-5
              (new 'static 'vector :y 4096.0)
              (-> (the-as process-focusable s5-5) node-list data 4 bone transform)
              )
            (vector+! gp-7 gp-7 s4-5)
            )
          (spawn (-> self insert-stone-part) gp-7)
          )
        )
      )
    )
  (let ((v1-135 (ja-group)))
    (when (and (and v1-135 (or (= v1-135 (-> self draw art-group data 8))
                               (= v1-135 (-> self draw art-group data 19))
                               (= v1-135 (-> self draw art-group data 22))
                               )
                    )
               (zero? (-> self skel float-channels))
               )
      (let* ((v1-141 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-142 (the-as number (logior #x3f800000 v1-141)))
             (f0-28 (+ -1.0 (the-as float v1-142)))
             )
        (cond
          ((< f0-28 0.1)
           (let ((v1-148 (ja-channel-float! (the-as art-joint-anim (-> self draw art-group data 12)) 0.0 0.0 0.0)))
             (when v1-148
               (set! (-> self skel interp-select 0) 1016)
               (set! (-> self skel interp-select 1) 0)
               (set! (-> v1-148 param 0) 1.0)
               (set! (-> v1-148 param 1) 0.25)
               (set! (-> v1-148 param 2) 0.1)
               (set! (-> v1-148 num-func) num-func-interp1-play!)
               )
             )
           )
          ((< f0-28 0.2)
           (let ((v1-153 (ja-channel-float! (the-as art-joint-anim (-> self draw art-group data 13)) 0.0 0.0 0.0)))
             (when v1-153
               (set! (-> self skel interp-select 0) 1016)
               (set! (-> self skel interp-select 1) 0)
               (set! (-> v1-153 param 0) 1.0)
               (set! (-> v1-153 param 1) 0.25)
               (set! (-> v1-153 param 2) 0.1)
               (set! (-> v1-153 num-func) num-func-interp1-play!)
               )
             )
           )
          ((< f0-28 0.3)
           (let ((v1-158 (ja-channel-float! (the-as art-joint-anim (-> self draw art-group data 14)) 0.0 0.0 0.0)))
             (when v1-158
               (set! (-> self skel interp-select 0) 1016)
               (set! (-> self skel interp-select 1) 0)
               (set! (-> v1-158 param 0) 1.0)
               (set! (-> v1-158 param 1) 0.25)
               (set! (-> v1-158 param 2) 0.1)
               (set! (-> v1-158 num-func) num-func-interp1-play!)
               )
             )
           )
          ((< f0-28 0.4)
           (let ((v1-163 (ja-channel-float! (the-as art-joint-anim (-> self draw art-group data 9)) 0.0 0.0 0.0)))
             (when v1-163
               (set! (-> self skel interp-select 0) (shl 2032 32))
               (set! (-> self skel interp-select 1) 0)
               (set! (-> v1-163 param 0) 1.0)
               (set! (-> v1-163 param 1) 0.25)
               (set! (-> v1-163 param 2) 0.1)
               (set! (-> v1-163 num-func) num-func-interp1-play!)
               )
             )
           )
          ((< f0-28 0.5)
           (let ((v1-168 (ja-channel-float! (the-as art-joint-anim (-> self draw art-group data 10)) 0.0 0.0 0.0)))
             (when v1-168
               (set! (-> self skel interp-select 0) (shl 2032 32))
               (set! (-> self skel interp-select 1) 0)
               (set! (-> v1-168 param 0) 1.0)
               (set! (-> v1-168 param 1) 0.25)
               (set! (-> v1-168 param 2) 0.1)
               (set! (-> v1-168 num-func) num-func-interp1-play!)
               )
             )
           )
          ((< f0-28 0.6)
           (let ((v1-172 (ja-channel-float! (the-as art-joint-anim (-> self draw art-group data 11)) 0.0 0.0 0.0)))
             (when v1-172
               (set! (-> self skel interp-select 0) (shl 2032 32))
               (set! (-> self skel interp-select 1) 0)
               (set! (-> v1-172 param 0) 1.0)
               (set! (-> v1-172 param 1) 0.25)
               (set! (-> v1-172 param 2) 0.1)
               (set! (-> v1-172 num-func) num-func-interp1-play!)
               )
             )
           )
          )
        )
      )
    )
  (none)
  )

(defbehavior widow-calc-position widow ((arg0 vector) (arg1 float) (arg2 float) (arg3 float))
  (set! (-> arg0 quad) (-> self circle-center quad))
  (let ((s3-0 (+ 32768.0 arg3)))
    (+! (-> arg0 x) (* arg1 (sin s3-0)))
    (+! (-> arg0 y) arg2)
    (+! (-> arg0 z) (* arg1 (cos s3-0)))
    )
  arg0
  )

(defbehavior widow-calc-target-position widow ((arg0 vector))
  (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self circle-center) (target-pos 0))))
    (set! (-> arg0 x) 184320.0)
    (set! (-> arg0 y) 10240.0)
    (set! (-> s5-1 y) 0.0)
    (vector-normalize! s5-1 1.0)
    (if (and *target* (< (cos 18204.445) (-> s5-1 z)))
        (set! (-> arg0 z) (* 11.780972 (fmax -16438.613 (fmin 16438.613 (asin (-> s5-1 x))))))
        (set! (-> arg0 z) 0.0)
        )
    )
  arg0
  )

(defbehavior widow-calc-root-from-osc widow ((arg0 float))
  (let* ((v1-1 (vector+! (new 'stack-no-clear 'vector) (-> self osc value) (-> self noise-osc value)))
         (f30-0 (* 0.08488264 (-> v1-1 z)))
         )
    (widow-calc-position (-> self root trans) (-> v1-1 x) (-> v1-1 y) f30-0)
    (let* ((f0-4 (+ 32768.0 f30-0))
           (f30-1 (* 0.5 f0-4))
           )
      (quaternion-set! (-> self root quat) 0.0 (sin f30-1) 0.0 (cos f30-1))
      )
    )
  (set! (-> self tilt target) arg0)
  (update! (-> self tilt) 0.0)
  (let ((v1-7 (-> self tilt value)))
    (when (!= v1-7 0.0)
      (let ((s0-0 (* 0.5 v1-7))
            (gp-1 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-set! gp-1 (sin s0-0) 0.0 0.0 (cos s0-0))
        (quaternion-normalize! (quaternion*! (-> self root quat) (-> self root quat) gp-1))
        )
      )
    )
  )

(defbehavior widow-next-pod widow ()
  (+! (-> self which-pod) 1)
  (when (>= (-> self which-pod) 12)
    (set! (-> self which-pod) 0)
    0
    )
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defbehavior widow-pod-position widow ((arg0 vector) (arg1 symbol) (arg2 float))
  (let ((s4-0 71))
    (when arg1
      (set! (-> arg0 x) (- (-> arg0 x)))
      (set! s4-0 75)
      )
    (vector<-cspace! arg0 (-> self node-list data s4-0))
    (vector-normalize-copy! (the-as vector arg2) (-> self node-list data s4-0 bone transform vector 1) 1638.4)
    )
  (none)
  )

(defbehavior spydroid-setup widow ()
  (set! (-> self state-time) (+ (current-time) (seconds -0.247)))
  (set! (-> self next-launch) -1)
  (set! (-> self next-jumper) -1)
  (none)
  )

(defbehavior widow-bomb-setup widow ()
  (set! (-> self state-time) (+ (current-time) (seconds -0.247)))
  (set! (-> self next-launch) -1)
  (none)
  )

(defbehavior spydroid-launch widow ()
  (when (>= (-> self next-jumper) 0)
    (if (send-event (handle->process (-> self bomb (-> self next-jumper))) 'jump 2 (-> self launch-dest))
        (set! (-> self next-jumper) -1)
        )
    )
  (cond
    ((>= (-> self bomb-hits) 4)
     0
     )
    ((>= (-> self next-launch) 0)
     (when (and (>= (- (current-time) (-> self state-time)) (seconds 0.25))
                (let ((v1-24 (ja-group)))
                  (not (and v1-24 (= v1-24 (-> self draw art-group data 18))))
                  )
                (let ((v1-29 (ja-group)))
                  (or (not (and v1-29 (or (= v1-29 (-> self draw art-group data 19)) (= v1-29 (-> self draw art-group data 22)))))
                      (< 12.0 (ja-frame-num 0))
                      )
                  )
                )
       (let* ((a1-3 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 3)))
              (gp-1 (< (the int (vector-dot
                                  (vector-! (new 'stack-no-clear 'vector) (-> self launch-dest) a1-3)
                                  (the-as vector (-> self node-list data 3 bone transform))
                                  )
                            )
                       0
                       )
                    )
              )
         (cond
           (gp-1
             (set! (-> self left-cover-angle target) 0.0)
             (set! (-> self right-cover-angle target) 1.0)
             )
           (else
             (set! (-> self left-cover-angle target) 1.0)
             (set! (-> self right-cover-angle target) 0.0)
             )
           )
         (when (or (and (not gp-1) (< 0.95 (-> self left-cover-angle value)))
                   (and gp-1 (< 0.95 (-> self right-cover-angle value)))
                   )
           (let ((s5-0 (new 'stack-no-clear 'matrix3)))
             (let ((s4-0 (new 'stack-no-clear 'vector)))
               (let ((a2-1 (new 'stack-no-clear 'vector)))
                 (widow-pod-position s4-0 gp-1 (the-as float a2-1))
                 )
               (set! (-> s5-0 vector 0 quad) (-> s4-0 quad))
               )
             (quaternion-copy! (the-as quaternion (-> s5-0 vector 1)) (-> self root quat))
             (set! (-> s5-0 vector 2 x) (the-as float (-> self entity)))
             (set! (-> s5-0 vector 2 y) (the-as float #t))
             (set! (-> s5-0 vector 2 z) (the-as float #t))
             (let ((s4-1 (get-process *default-dead-pool* spydroid #x4000)))
               (set! (-> self bomb (-> self next-launch))
                     (ppointer->handle (when s4-1
                                         (let ((t9-6 (method-of-type process activate)))
                                           (t9-6 s4-1 self (symbol->string (-> spydroid symbol)) (the-as pointer #x70004000))
                                           )
                                         (run-now-in-process s4-1 enemy-init-by-other self s5-0)
                                         (-> s4-1 ppointer)
                                         )
                                       )
                     )
               )
             )
           (when (handle->process (-> self bomb (-> self next-launch)))
             (if gp-1
                 (process-spawn
                   part-tracker
                   :init part-tracker-init
                   (-> *part-group-id-table* 721)
                   300
                   #f
                   #f
                   #f
                   (-> self node-list data 75 bone transform)
                   :to *entity-pool*
                   )
                 (process-spawn
                   part-tracker
                   :init part-tracker-init
                   (-> *part-group-id-table* 721)
                   300
                   #f
                   #f
                   #f
                   (-> self node-list data 71 bone transform)
                   :to *entity-pool*
                   )
                 )
             (set! (-> self state-time) (current-time))
             (let* ((s5-3 (-> self state-time))
                    (f30-1 75.0)
                    (v1-89 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-90 (the-as number (logior #x3f800000 v1-89)))
                    )
               (set! (-> self state-time) (+ s5-3 (the int (* f30-1 (+ -1.0 (the-as float v1-90))))))
               )
             (widow-next-pod)
             (if gp-1
                 (ja :group! (-> self draw art-group data 22) :num! min)
                 (ja :group! (-> self draw art-group data 19) :num! min)
                 )
             (set! (-> self next-jumper) (-> self next-launch))
             (set! (-> self next-launch) -1)
             )
           )
         )
       )
     1
     )
    (else
      (let ((gp-0 0))
        (let ((s5-4 (new 'stack-no-clear 'array 'int32 8)))
          (dotimes (v1-106 7)
            (when (not (handle->process (-> self bomb v1-106)))
              (set! (-> s5-4 gp-0) v1-106)
              (+! gp-0 1)
              )
            )
          (cond
            ((> gp-0 0)
             (let* ((v1-110 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-111 (the-as number (logior #x3f800000 v1-110)))
                    )
               (set! (-> self next-launch)
                     (-> s5-4 (the int (* (+ -1.0 (the-as float v1-111)) (+ -0.0001 (the float gp-0)))))
                     )
               )
             (let* ((f30-2 184320.0)
                    (f28-0 8192.0)
                    (v1-121 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-122 (the-as number (logior #x3f800000 v1-121)))
                    (f30-3 (+ f30-2 (* f28-0 (+ -1.0 (the-as float v1-122)))))
                    (f28-1 (+ -13289.244 (* 4429.748 (the float (-> self next-launch)))))
                    (f26-0 -728.1778)
                    (f24-0 1456.3556)
                    (v1-130 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-131 (the-as number (logior #x3f800000 v1-130)))
                    (f28-2 (+ f26-0 (* f24-0 (+ -1.0 (the-as float v1-131))) f28-1))
                    (f30-4 (- f30-3))
                    )
               (set-vector! (-> self launch-dest) (* (sin f28-2) f30-4) 0.0 (* (cos f28-2) f30-4) 1.0)
               )
             (vector+! (-> self launch-dest) (-> self launch-dest) (-> self circle-center))
             )
            (else
              (set! gp-0 0)
              )
            )
          )
        gp-0
        )
      )
    )
  )

(defbehavior widow-bomb-launch widow ((arg0 symbol) (arg1 symbol) (arg2 symbol))
  (cond
    ((>= (-> self bomb-hits) 4)
     0
     )
    ((>= (-> self next-launch) 0)
     (when (and (>= (- (current-time) (-> self state-time)) (seconds 0.25))
                (let ((v1-8 (ja-group)))
                  (not (and v1-8 (= v1-8 (-> self draw art-group data 18))))
                  )
                (let ((v1-13 (ja-group)))
                  (or (not (and v1-13 (or (= v1-13 (-> self draw art-group data 19))
                                          (= v1-13 (-> self draw art-group data 22))
                                          (= v1-13 (-> self draw art-group data 32))
                                          (= v1-13 (-> self draw art-group data 33))
                                          )
                                )
                           )
                      (< 12.0 (ja-frame-num 0))
                      )
                  )
                )
       (let* ((a1-5 (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 3)))
              (s4-1 (< (the int (vector-dot
                                  (vector-! (new 'stack-no-clear 'vector) (-> self launch-dest) a1-5)
                                  (the-as vector (-> self node-list data 3 bone transform))
                                  )
                            )
                       0
                       )
                    )
              )
         (cond
           (s4-1
             (set! (-> self left-cover-angle target) 0.0)
             (set! (-> self right-cover-angle target) 1.0)
             )
           (else
             (set! (-> self left-cover-angle target) 1.0)
             (set! (-> self right-cover-angle target) 0.0)
             )
           )
         (when (or (and (not s4-1) (< 0.95 (-> self left-cover-angle value)))
                   (and s4-1 (< 0.95 (-> self right-cover-angle value)))
                   )
           (let ((s3-0 (new 'stack-no-clear 'vector))
                 (s2-0 (new 'stack-no-clear 'array 'float 1))
                 )
             (widow-pod-position s3-0 s4-1 (the-as float s2-0))
             (set! (-> self bomb (-> self next-launch))
                   (ppointer->handle (process-spawn widow-bomb s3-0 (-> self launch-dest) #x43e10000 #x46c00000 s2-0 :to self))
                   )
             )
           (when (handle->process (-> self bomb (-> self next-launch)))
             (if s4-1
                 (process-spawn
                   part-tracker
                   :init part-tracker-init
                   (-> *part-group-id-table* 721)
                   300
                   #f
                   #f
                   #f
                   (-> self node-list data 75 bone transform)
                   :to *entity-pool*
                   )
                 (process-spawn
                   part-tracker
                   :init part-tracker-init
                   (-> *part-group-id-table* 721)
                   300
                   #f
                   #f
                   #f
                   (-> self node-list data 71 bone transform)
                   :to *entity-pool*
                   )
                 )
             (set! (-> self state-time) (current-time))
             (let* ((s3-3 (-> self state-time))
                    (f30-1 75.0)
                    (v1-68 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-69 (the-as number (logior #x3f800000 v1-68)))
                    )
               (set! (-> self state-time) (+ s3-3 (the int (* f30-1 (+ -1.0 (the-as float v1-69))))))
               )
             (widow-next-pod)
             (ja-channel-push! 1 (seconds 0.03))
             (cond
               (arg0
                 (if s4-1
                     (ja :group! (-> self draw art-group data 35) :num! min)
                     (ja :group! (-> self draw art-group data 34) :num! min)
                     )
                 )
               (arg1
                 (if s4-1
                     (ja :group! (-> self draw art-group data 33) :num! min)
                     (ja :group! (-> self draw art-group data 32) :num! min)
                     )
                 )
               (s4-1
                 (ja :group! (-> self draw art-group data 22) :num! min)
                 )
               (else
                 (ja :group! (-> self draw art-group data 19) :num! min)
                 )
               )
             (set! (-> self launched-a-bomb) #t)
             (set! (-> self next-launch) -1)
             )
           )
         )
       )
     1
     )
    (else
      (let ((gp-1 0))
        (let ((s5-1 (if arg2
                        8
                        7
                        )
                    )
              (f30-2 (if arg2
                         14563.556
                         13289.244
                         )
                     )
              (s3-4 (new 'stack-no-clear 'array 'int32 8))
              )
          (dotimes (v1-106 s5-1)
            (when (not (handle->process (-> self bomb v1-106)))
              (set! (-> s3-4 gp-1) v1-106)
              (+! gp-1 1)
              )
            )
          (cond
            ((> gp-1 0)
             (let* ((v1-110 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-111 (the-as number (logior #x3f800000 v1-110)))
                    )
               (set! (-> self next-launch)
                     (-> s3-4 (the int (* (+ -1.0 (the-as float v1-111)) (+ -0.0001 (the float gp-1)))))
                     )
               )
             (let* ((f28-0 184320.0)
                    (f26-0 8192.0)
                    (v1-121 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                    (v1-122 (the-as number (logior #x3f800000 v1-121)))
                    (f28-1 (+ f28-0 (* f26-0 (+ -1.0 (the-as float v1-122)))))
                    (f30-3
                      (+ (- f30-2) (* (the float (-> self next-launch)) (the float (/ (the int (* 2.0 f30-2)) (+ s5-1 -1)))))
                      )
                    (f30-4 (cond
                             ((not arg2)
                              (let* ((f26-1 -910.2222)
                                     (f24-0 1820.4445)
                                     (v1-131 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                                     (v1-132 (the-as number (logior #x3f800000 v1-131)))
                                     )
                                (+ f26-1 (* f24-0 (+ -1.0 (the-as float v1-132))) f30-3)
                                )
                              )
                             ((< (-> self osc value z) (* 11.780972 f30-3))
                              (+ -728.1778 f30-3)
                              )
                             (else
                               (+ 728.1778 f30-3)
                               )
                             )
                           )
                    (f28-2 (- f28-1))
                    )
               (set-vector! (-> self launch-dest) (* (sin f30-4) f28-2) 0.0 (* (cos f30-4) f28-2) 1.0)
               )
             (vector+! (-> self launch-dest) (-> self launch-dest) (-> self circle-center))
             )
            (else
              (set! gp-1 0)
              )
            )
          )
        gp-1
        )
      )
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior widow-give-ammo widow ()
  (dotimes (gp-0 2)
    (cond
      ((handle->process (-> self ammos gp-0))
       (set! (-> self ammo-timers gp-0) (current-time))
       )
      ((>= (- (current-time) (-> self ammo-timers gp-0)) (seconds 20))
       (let ((s4-0 (new 'static 'fact-info))
             (s5-0 (new 'stack-no-clear 'vector))
             )
         (set! (-> s5-0 quad) (-> self circle-center quad))
         (let ((s3-0 (new 'stack-no-clear 'vector)))
           (set-vector! s3-0 0.0 57001.605 -16384.0 1.0)
           (if (zero? gp-0)
               (set! (-> s5-0 x) (+ 192512.0 (-> s5-0 x)))
               (set! (-> s5-0 x) (+ -192512.0 (-> s5-0 x)))
               )
           (set! (-> s4-0 options) (actor-option))
           (set! (-> s4-0 pickup-type) (pickup-type ammo-red))
           (set! (-> s4-0 pickup-spawn-amount) 20.0)
           (set! (-> s4-0 fade-time) 0)
           (set! (-> self ammos gp-0) (ppointer->handle (process-spawn
                                                          ammo-collectable
                                                          :init initialize-ammo-by-other
                                                          s5-0
                                                          s3-0
                                                          s4-0
                                                          :from *pickup-dead-pool*
                                                          :to self
                                                          )
                                                        )
                 )
           )
         )
       (let ((v1-32 (handle->process (-> self ammos gp-0))))
         (when v1-32
           (logclear! (-> (the-as collectable v1-32) flags) (collectable-flag fadeout))
           (set! (-> self ammo-timers gp-0) (current-time))
           )
         )
       )
      )
    )
  (none)
  )

(defbehavior widow-bomb-slots-full widow ()
  (let ((v0-0 0))
    (let ((v1-0 (new 'stack-no-clear 'array 'int32 8)))
      (dotimes (a0-0 8)
        (when (handle->process (-> self bomb a0-0))
          (set! (-> v1-0 v0-0) a0-0)
          (+! v0-0 1)
          )
        )
      )
    v0-0
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior widow-debug widow ()
  (when (and (cpad-hold? 0 r1) (cpad-hold? 0 r2) (cpad-hold? 0 l1) (cpad-hold? 0 l2))
    (dotimes (gp-0 8)
      (let ((a0-5 (handle->process (-> self bomb gp-0))))
        (if a0-5
            (deactivate a0-5)
            )
        )
      )
    )
  (none)
  )

(if (not *debug-segment*)
    (set! widow-debug (the-as (function none :behavior widow) nothing))
    )

;; WARN: Return type mismatch float vs none.
(defbehavior widow-cleanup-launch-anim widow ((arg0 symbol))
  (let ((v1-2 (ja-group)))
    (cond
      ((and v1-2 (or (= v1-2 (-> self draw art-group data 18))
                     (= v1-2 (-> self draw art-group data 28))
                     (= v1-2 (-> self draw art-group data 29))
                     (= v1-2 (-> self draw art-group data 30))
                     (= v1-2 (-> self draw art-group data 31))
                     )
            )
       (ja :num! (seek!))
       (when (ja-done? 0)
         (let* ((v1-14 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                (v1-15 (the-as number (logior #x3f800000 v1-14)))
                )
           (if (or (< (+ -1.0 (the-as float v1-15)) 0.5) (not arg0))
               (ja :group! (-> self draw art-group data 20) :num! min)
               (ja :group! (-> self draw art-group data 21) :num! min)
               )
           )
         )
       )
      ((let ((v1-30 (ja-group)))
         (and v1-30 (or (= v1-30 (-> self draw art-group data 20)) (= v1-30 (-> self draw art-group data 21))))
         )
       (ja :num! (seek!))
       (if (ja-done? 0)
           (ja :group! (-> self draw art-group data 7) :num! (identity 26.0))
           )
       )
      ((let ((v1-48 (ja-group)))
         (not (and v1-48 (= v1-48 (-> self draw art-group data 8))))
         )
       (ja :num! (seek!))
       (when (ja-done? 0)
         (ja :group! (-> self draw art-group data 8) :num! min)
         (set! (-> self drill-speed target) 1.0)
         (jump-to-target! (-> self drill-speed) 0.0)
         )
       )
      (else
        (let ((f30-0 (ja-frame-num 0)))
          (ja :num! (loop!))
          (cond
            ((and arg0 (< (ja-frame-num 0) f30-0) (let* ((v1-73 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                                                         (v1-74 (the-as number (logior #x3f800000 v1-73)))
                                                         )
                                                    (< (+ -1.0 (the-as float v1-74)) 0.125)
                                                    )
                  )
             (set! (-> self drill-speed target) 0.0)
             (ja :group! (-> self draw art-group data 18) :num! min)
             )
            (else
              (set! (-> self drill-speed target) 1.0)
              )
            )
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defbehavior widow-last-bomb-anim widow ()
  (let ((v1-2 (ja-group)))
    (cond
      ((and v1-2 (or (= v1-2 (-> self draw art-group data 18))
                     (= v1-2 (-> self draw art-group data 28))
                     (= v1-2 (-> self draw art-group data 29))
                     (= v1-2 (-> self draw art-group data 30))
                     (= v1-2 (-> self draw art-group data 31))
                     (= v1-2 (-> self draw art-group data 32))
                     (= v1-2 (-> self draw art-group data 33))
                     )
            )
       (ja :num! (seek!))
       (when (ja-done? 0)
         (let* ((f30-0 2.999)
                (v1-15 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                (v1-16 (the-as number (logior #x3f800000 v1-15)))
                (v1-18 (the int (* f30-0 (+ -1.0 (the-as float v1-16)))))
                )
           (if (>= v1-18 (-> self previous-anim))
               (+! v1-18 1)
               )
           (set! (-> self previous-anim) v1-18)
           (cond
             ((zero? v1-18)
              (ja :group! (-> self draw art-group data 28) :num! min)
              )
             ((= v1-18 1)
              (ja :group! (-> self draw art-group data 29) :num! min)
              )
             ((= v1-18 2)
              (ja :group! (-> self draw art-group data 30) :num! min)
              )
             (else
               (ja :group! (-> self draw art-group data 31) :num! min)
               )
             )
           )
         )
       )
      (else
        (ja :num! (seek!))
        (when (ja-done? 0)
          (ja :group! (-> self draw art-group data 18) :num! min)
          (set! (-> self drill-speed target) 0.0)
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch number vs none.
(defbehavior widow-flying-anim widow ()
  (let ((v1-2 (ja-group)))
    (cond
      ((and v1-2 (= v1-2 (-> self draw art-group data 5)))
       (ja :num! (loop!))
       )
      (else
        (ja :num! (seek!))
        (when (ja-done? 0)
          (ja :group! (-> self draw art-group data 5) :num! min)
          (set! (-> self drill-speed target) 0.0)
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior widow-kaboom-check widow ((arg0 symbol))
  (if (and arg0
           (>= (-> self bomb-hits) 4)
           (or (not *target*) (not (logtest? (-> *target* focus-status) (focus-status dead))))
           )
      (go-virtual kaboom)
      )
  (if (>= (-> self bomb-hits) 3)
      (script-eval '(want-anim "tomb-boss-res"))
      )
  (none)
  )

(defstate beaten (widow)
  :virtual #t
  :enter (behavior ()
    (ja-channel-set! 0)
    (ja-post)
    (when (-> self hover-sound-playing)
      (sound-stop (-> self hover-sound))
      (set! (-> self hover-sound-playing) #f)
      )
    (send-event (handle->process (-> self hud)) 'hide-and-die)
    (none)
    )
  :exit (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! (-> self draw art-group data 8) :num! min)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  )

(defstate kaboom (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set-setting! 'music #f 0.0 0)
    (dotimes (gp-0 8)
      (let ((a0-2 (handle->process (-> self bomb gp-0))))
        (if a0-2
            (send-event a0-2 'fizzle)
            )
        )
      )
    (set! (-> self bomb-hits) 0)
    (set! (-> self flying) #t)
    (setup-masks (-> self draw) 64 0)
    (send-event (handle->process (-> self pod)) 'finale)
    (send-event (ppointer->process (-> self baron)) 'finale)
    (set! (-> self osc target y) 40960.0)
    (set! (-> self osc target z) 0.0)
    (ja-channel-push! 1 (seconds 0.03))
    (ja :group! (-> self draw art-group data 38) :num! min)
    (setup-masks (-> self draw) 2 128)
    (process-grab? *target* #f)
    (none)
    )
  :exit (behavior ()
    (process-release? *target*)
    (let ((v1-2 (-> self entity extra perm)))
      (logior! (-> v1-2 status) (entity-perm-status bit-5))
      (let ((v0-1 0))
        (dotimes (a0-3 8)
          (if (not (handle->process (-> self catwalk a0-3)))
              (set! v0-1 (logior v0-1 (ash 1 a0-3)))
              )
          )
        (set! (-> v1-2 user-object 1) v0-1)
        )
      )
    (none)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (when (ja-done? 0)
      (process-spawn scene-player :init scene-player-init "tomb-boss-res" #t #f)
      (remove-setting! 'music)
      (deactivate (-> self baron 0))
      (let ((a0-8 (handle->process (-> self pod))))
        (if a0-8
            (deactivate a0-8)
            )
        )
      (go-virtual beaten)
      )
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-low-stage-3 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self osc target y) -122880.0)
    (set! (-> self attack-from-high-deg) (not (-> self attack-from-high-deg)))
    (set! (-> self flying) #t)
    (set! (-> self old-bomb-hits) (-> self bomb-hits))
    (none)
    )
  :trans (behavior ()
    (widow-kaboom-check #t)
    (if (< (-> self osc value y) (+ 8192.0 (-> self osc target y)))
        (go-virtual hover-rise-stage-3)
        )
    (widow-flying-anim)
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-shooting-stage-3 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-shoot-gun-talker)
    (ja-channel-push! 1 (seconds 0.02))
    (ja :group! (-> self draw art-group data 15) :num! min)
    (set! (-> self which-gun) 0)
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (let ((v1-2 (ja-group)))
      (if (not (and v1-2 (or (= v1-2 (-> self draw art-group data 38))
                             (= v1-2 (-> self draw art-group data 37))
                             (= v1-2 (-> self draw art-group data 36))
                             )
                    )
               )
          (ja :group! (-> self draw art-group data 17) :num! min)
          )
      )
    (none)
    )
  :trans (behavior ()
    (widow-kaboom-check #t)
    (if (< (-> self old-bomb-hits) (-> self bomb-hits))
        (go-virtual hover-low-stage-3)
        )
    (let ((a0-3 (widow-calc-target-position (new 'stack-no-clear 'vector)))
          (v1-5 #t)
          )
      (set! (-> self osc target y) (+ -6144.0 (-> a0-3 y)))
      (cond
        ((not (-> self attack-from-high-deg))
         (set! (-> self osc target z) (fmin 193019.44 (+ 21446.604 (-> a0-3 z))))
         (when (< (+ 2457.6 (-> self osc value z)) (-> self osc target z))
           (set! (-> self osc target z) (+ 2457.6 (-> self osc value z)))
           (set! v1-5 #f)
           )
         )
        (else
          (set! (-> self osc target z)
                (fmax (fmax -193019.44 (+ -21446.604 (-> a0-3 z))) (+ -2457.6 (-> self osc value z)))
                )
          (when (< (-> self osc target z) (+ -2457.6 (-> self osc value z)))
            (set! (-> self osc target z) (+ -2457.6 (-> self osc value z)))
            (set! v1-5 #f)
            )
          )
        )
      (set! v1-5 (and (< (fabs (- (-> self osc value z) (-> self osc target z))) 1024.0)
                      (and (>= (- (current-time) (-> self state-time)) (seconds 0.007)) v1-5)
                      )
            )
      (if v1-5
          (go-virtual hover-low-stage-3)
          )
      )
    (ja :num! (seek!))
    (let ((v1-22 (ja-group)))
      (when (and (and v1-22 (= v1-22 (-> self draw art-group data 16)))
                 (>= (ja-frame-num 0) (the float (-> self which-gun)))
                 )
        (let ((v1-28 (-> self which-gun)))
          (cond
            ((zero? v1-28)
             (widow-method-46 self (the-as vector #t) 84)
             (set! (-> self which-gun) 2)
             )
            ((= v1-28 2)
             (widow-method-46 self (the-as vector #t) 87)
             (set! (-> self which-gun) 4)
             )
            ((= v1-28 4)
             (widow-method-46 self (the-as vector #t) 82)
             (set! (-> self which-gun) 6)
             )
            ((= v1-28 6)
             (widow-method-46 self (the-as vector #t) 89)
             (set! (-> self which-gun) 100)
             )
            )
          )
        )
      )
    (when (ja-done? 0)
      (ja :group! (-> self draw art-group data 16) :num! min)
      (set! (-> self which-gun) 0)
      0
      )
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-launch-bombs-stage-3 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-launch-bombs-talker)
    (set! (-> self osc target x) 135168.0)
    (set! (-> self flying) #t)
    (widow-bomb-setup)
    (set! (-> self launched-a-bomb) #f)
    (set! (-> self osc damping) 0.8)
    (none)
    )
  :exit (behavior ()
    (set! (-> self left-cover-angle target) 0.0)
    (set! (-> self right-cover-angle target) 0.0)
    (set! (-> self osc damping) 0.98)
    (none)
    )
  :trans (behavior ()
    (widow-kaboom-check #t)
    (if (< (-> self old-bomb-hits) (-> self bomb-hits))
        (go-virtual hover-low-stage-3)
        )
    (widow-flying-anim)
    (cond
      ((or (< (widow-bomb-slots-full) 2) (not (-> self launched-a-bomb)))
       (widow-bomb-launch (-> self flying) #f #t)
       )
      ((>= (- (current-time) (-> self state-time)) (seconds 2.25))
       (go-virtual hover-shooting-stage-3)
       )
      (else
        (set! (-> self left-cover-angle target) 0.0)
        (set! (-> self right-cover-angle target) 0.0)
        )
      )
    (let ((v1-15 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (set! (-> self osc target y) (-> v1-15 y))
      (if (-> self attack-from-high-deg)
          (set! (-> self osc target z) (fmin 193019.44 (+ 42893.207 (-> v1-15 z))))
          (set! (-> self osc target z) (fmax -193019.44 (+ -42893.207 (-> v1-15 z))))
          )
      )
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-big-blast-stage-3 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self state-time) 0)
    (let* ((f0-1 (* 0.08488264 (-> self osc value z)))
           (v1-2 (max 0 (min 8 (+ (the int (* 0.00024968927 (+ 14017.422 f0-1))) 1))))
           )
      (cond
        ((handle->process (-> self catwalk v1-2))
         (set! (-> self osc target z) (* 11.780972 (+ -12014.934 (* 4004.9778 (the float (+ v1-2 -1))))))
         (set! (-> self osc target y) (+ -4096.0 (-> self osc target y)))
         (set! (-> self targetted-catwalk) v1-2)
         (widow-stone-charge-up-talker)
         (set! (-> self stop-catwalk-sound) #t)
         (set! (-> self catwalk-sound)
               (add-process *gui-control* self (gui-channel jak) (gui-action queue) "cwlkfall" -99.0 0)
               )
         )
        (else
          (set! (-> self stop-catwalk-sound) #f)
          (go-virtual hover-launch-bombs-stage-3)
          )
        )
      )
    (none)
    )
  :exit (behavior ()
    (dotimes (v1-0 5)
      (case (-> self lightning v1-0 state mode)
        (((lightning-mode lm0) (lightning-mode lm3))
         )
        (else
          (let ((a0-7 (-> self lightning v1-0))
                (a1-2 3)
                )
            (let ((a2-1 (!= a1-2 (-> a0-7 state mode))))
              (case a1-2
                ((3)
                 (if a2-1
                     (set! (-> a0-7 state counter) 0.0)
                     )
                 )
                ((1)
                 (set! (-> a0-7 state start-color) (-> a0-7 spec start-color))
                 (set! (-> a0-7 state end-color) (-> a0-7 spec end-color))
                 )
                )
              )
            (set! (-> a0-7 state mode) (the-as lightning-mode a1-2))
            )
          )
        )
      )
    (when (-> self shake-sound-playing)
      (sound-stop (-> self shake-sound))
      (set! (-> self shake-sound-playing) #f)
      )
    (if (-> self stop-catwalk-sound)
        (set-action!
          *gui-control*
          (gui-action stop)
          (-> self catwalk-sound)
          (gui-channel none)
          (gui-action none)
          (the-as string #f)
          (the-as (function gui-connection symbol) #f)
          (the-as process #f)
          )
        )
    (none)
    )
  :trans (behavior ()
    (local-vars (v1-39 symbol) (sv-256 baron-pod) (sv-272 symbol) (sv-288 int) (sv-304 vector) (sv-320 vector))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (widow-kaboom-check #t)
      (if (< (-> self old-bomb-hits) (-> self bomb-hits))
          (go-virtual hover-low-stage-3)
          )
      (cond
        ((or (< 4096.0 (fabs (- (-> self osc value z) (-> self osc target z))))
             (< 4096.0 (fabs (- (-> self osc value y) (-> self osc target y))))
             )
         )
        ((zero? (-> self state-time))
         (set! (-> self state-time) (current-time))
         (sound-play "widow-charge")
         )
        ((>= (- (current-time) (-> self state-time)) (seconds 3))
         (widow-after-stone-shot-talker)
         (set! (-> self stop-catwalk-sound) #f)
         (set-action!
           *gui-control*
           (gui-action play)
           (-> self catwalk-sound)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         (set-falloff! *gui-control* (-> self catwalk-sound) #t -1 200 2)
         (activate! *camera-smush-control* 1228.8 75 270 1.0 0.5 (-> self clock))
         (send-event (handle->process (-> self catwalk (-> self targetted-catwalk))) 'green-hit)
         (go-virtual hover-launch-bombs-stage-3)
         )
        )
      (when (and (nonzero? (-> self state-time)) (nonzero? (-> self green-charge-part)))
        ;; manually rewritten stack var handle->process
        (if (-> self pod)
          (set! sv-256 (the-as baron-pod (handle->process (-> self pod))))
          )
        (when sv-256
          (let ((gp-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> sv-256 node-list data 4))))
            (cond
              ((>= (- (current-time) (-> self state-time)) (seconds 2))
               (when (-> self shake-sound-playing)
                 (sound-stop (-> self shake-sound))
                 (set! (-> self shake-sound-playing) #f)
                 )
               )
              (else
                (spawn (-> self green-charge-part) gp-1)
                (sound-play "widow-shake" :id (-> self shake-sound) :position gp-1)
                (set! (-> self shake-sound-playing) #t)
                )
              )
            (let ((s5-1 (new 'stack-no-clear 'vector))
                  (s4-0 (new 'stack-no-clear 'vector))
                  (s3-0 (new 'stack-no-clear 'vector))
                  (s2-0 (new 'stack-no-clear 'vector))
                  (s1-0 (new 'stack-no-clear 'vector))
                  (s0-0 (new 'stack-no-clear 'matrix))
                  )
              (vector-normalize-copy! s2-0 (-> sv-256 node-list data 4 bone transform vector 1) 1.0)
              (vector-float*! s5-1 s2-0 61440.0)
              (vector+! s5-1 s5-1 gp-1)
              (vector-! s1-0 s5-1 gp-1)
              (vector-normalize! s1-0 1.0)
              (matrix-axis-angle! s0-0 s1-0 13107.2)
              (vector-reset! (-> s0-0 trans))
              (set-vector! s4-0 (-> s1-0 z) 0.0 (- (-> s1-0 x)) 1.0)
              (vector-normalize! s4-0 409.6)
              (when (>= (- (current-time) (-> self state-time)) (seconds 2))
                (set! sv-272 (the-as symbol #f))
                (set! sv-288 0)
                (while (< sv-288 5)
                  (case (-> self lightning sv-288 state mode)
                    (((lightning-mode lm0) (lightning-mode lm3))
                     (let ((v1-78 (-> self lightning sv-288))
                           (a0-35 1)
                           )
                       (let ((a1-19 (!= a0-35 (-> v1-78 state mode))))
                         (case a0-35
                           ((3)
                            (if a1-19
                                (set! (-> v1-78 state counter) 0.0)
                                )
                            )
                           ((1)
                            (set! (-> v1-78 state start-color) (-> v1-78 spec start-color))
                            (set! (-> v1-78 state end-color) (-> v1-78 spec end-color))
                            )
                           )
                         )
                       (set! (-> v1-78 state mode) (the-as lightning-mode a0-35))
                       )
                     (set! sv-272 #t)
                     sv-272
                     )
                    )
                  (vector-matrix*! s4-0 s4-0 s0-0)
                  (vector+! s1-0 s4-0 gp-1)
                  (let ((a0-38 (-> self lightning sv-288))
                        (v1-85 s1-0)
                        )
                    (set! (-> a0-38 state meet data 0 quad) (-> v1-85 quad))
                    )
                  (set! sv-320 s3-0)
                  (set! sv-304 s2-0)
                  (let ((f0-9 (rand-vu-float-range -8192.0 8192.0)))
                    (.lvf vf1 (&-> sv-304 quad))
                    (let ((v1-88 f0-9))
                      (.mov vf2 v1-88)
                      )
                    )
                  (.add.x.vf vf1 vf0 vf0 :mask #b1000)
                  (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                  (.svf (&-> sv-320 quad) vf1)
                  (vector+! s3-0 s3-0 s5-1)
                  (let ((a0-43 (-> self lightning sv-288))
                        (v1-94 s3-0)
                        )
                    (set! (-> a0-43 state meet data (+ (-> a0-43 state points-to-draw) -1) quad) (-> v1-94 quad))
                    )
                  (set! sv-288 (+ sv-288 1))
                  )
                (if sv-272
                    (sound-play "widow-lightning" :position gp-1)
                    )
                )
              )
            )
          )
        )
      (widow-flying-anim)
      (widow-common)
      (widow-calc-root-from-osc 1820.4445)
      (widow-debug)
      (none)
      )
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-rise-stage-3 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self osc target x) 135168.0)
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (set! (-> self osc damping) 0.9)
    (set! (-> self old-bomb-hits) (-> self bomb-hits))
    (none)
    )
  :trans (behavior ()
    (widow-general-flying-talker)
    (widow-kaboom-check #t)
    (let ((gp-0 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (set! (-> self osc target y) (-> gp-0 y))
      (when (< (+ -10240.0 (-> self osc target y)) (-> self osc value y))
        (if (>= (- (current-time) (-> self state-time)) (seconds 0.007))
            (go-virtual hover-big-blast-stage-3)
            )
        )
      (if (-> self attack-from-high-deg)
          (set! (-> self osc target z) (fmin 193019.44 (+ 42893.207 (-> gp-0 z))))
          (set! (-> self osc target z) (fmax -193019.44 (+ -42893.207 (-> gp-0 z))))
          )
      )
    (widow-flying-anim)
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-seek-under-stage-3 (widow)
  :event widow-handler
  :enter (behavior ()
    (set! (-> self osc target x) 135168.0)
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (widow-kaboom-check #f)
    (let ((v1-0 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (if (-> self attack-from-high-deg)
          (set! (-> self osc target z) (fmin 193019.44 (+ 42893.207 (-> v1-0 z))))
          (set! (-> self osc target z) (fmax -193019.44 (+ -42893.207 (-> v1-0 z))))
          )
      )
    (if (and (< (fabs (- (-> self osc value z) (-> self osc target z))) 8192.0)
             (>= (- (current-time) (-> self state-time)) (seconds 0.007))
             )
        (go-virtual hover-rise-stage-3)
        )
    (ja :num! (loop!))
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-jump-down-stage-3 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-leave-perch-talker)
    (set! (-> self state-time) (current-time))
    (ja-channel-push! 1 (seconds 1.5))
    (ja :group! (-> self draw art-group data 5) :num! min)
    (let ((gp-1 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (set! (-> self theta max-vel) 91.022224)
      (set! (-> self theta accel) 0.01)
      (set! (-> self theta target) (* 0.08488264 (-> gp-1 z)))
      (widow-calc-position gp-1 151552.0 -81920.0 (-> self theta target))
      (setup-from-to-duration-and-height! (-> self traj) (-> self root trans) gp-1 450.0 49152.0)
      )
    (set! (-> self flying) #t)
    (none)
    )
  :exit (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (set-vector! a1-0 151552.0 -81920.0 (* 11.780972 (-> self theta target)) 1.0)
      (widow-oscillator-method-9 (-> self osc) a1-0 81.92 1638.4 0.98)
      )
    (widow-oscillator-method-9 (-> self noise-osc) (the-as vector #f) 4.096 204.8 0.9)
    (init (-> self rand-vec) 75 150 204.8 819.2)
    (none)
    )
  :trans (behavior ()
    (widow-kaboom-check #f)
    (ja :num! (loop!))
    (compute-trans-at-time
      (-> self traj)
      (the float (min 450 (- (current-time) (-> self state-time))))
      (-> self root trans)
      )
    (if (>= (- (current-time) (-> self state-time)) (seconds 1.5))
        (go hover-seek-under-stage-3)
        )
    (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 (+ 32768.0 (-> self theta value)))
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate big-reaction-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (talker-spawn-func (-> *talker-speech* 302) *entity-pool* (target-pos 0) (the-as region #f))
    (dotimes (gp-1 8)
      (let ((a0-3 (handle->process (-> self bomb gp-1))))
        (if a0-3
            (send-event a0-3 'fizzle)
            )
        )
      )
    (set! (-> self bomb-hits) 0)
    (set! (-> self drill-speed target) 0.0)
    (set! (-> self flying) #f)
    (ja-channel-push! 1 (seconds 0.02))
    (ja :group! (-> self draw art-group data 4) :num! min)
    (set! (-> self extract-stone-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (send-event (handle->process (-> self pod)) 'grab-done)
    (send-event (ppointer->process (-> self baron)) 'grab-done)
    (send-event (handle->process (-> self heart)) 'grab-done)
    (let ((v1-18 (handle->process (-> self hud))))
      (when v1-18
        (set! (-> (the-as hud-widow v1-18) values 0 target) 3)
        (set! (-> (the-as hud-widow v1-18) values 1 target) 100)
        )
      )
    (none)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (let ((f30-0 (ja-aframe-num 0)))
      (send-event (handle->process (-> self pod)) 'frame f30-0)
      (send-event (ppointer->process (-> self baron)) 'frame f30-0)
      (send-event (handle->process (-> self heart)) 'frame f30-0)
      (if (and (zero? (-> self insert-stone-time)) (>= f30-0 827.0))
          (set! (-> self insert-stone-time) (current-time))
          )
      )
    (if (ja-done? 0)
        (go-virtual hover-jump-down-stage-3)
        )
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate watch-bombs-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self flying) #f)
    (none)
    )
  :trans (behavior ()
    (widow-want-stone-talker)
    (let ((gp-0 (widow-bomb-slots-full)))
      (cond
        ((>= (-> self bomb-hits) 4)
         (go-virtual big-reaction-stage-2)
         )
        ((and (zero? gp-0) (let ((v1-8 (ja-group)))
                             (and v1-8 (= v1-8 (-> self draw art-group data 8)))
                             )
              )
         (go-virtual launch-droids-stage-2)
         )
        )
      (if (and (>= (-> self bomb-hits) 3) (nonzero? gp-0))
          (widow-last-bomb-anim)
          (widow-cleanup-launch-anim (< 3 gp-0))
          )
      )
    (widow-give-ammo)
    (widow-common)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate launch-bombs-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-launch-bombs-talker)
    (widow-bomb-setup)
    (set! (-> self flying) #f)
    (none)
    )
  :exit (behavior ()
    (set! (-> self left-cover-angle target) 0.0)
    (set! (-> self right-cover-angle target) 0.0)
    (none)
    )
  :trans (behavior ()
    (if (>= (-> self bomb-hits) 3)
        (widow-last-bomb-anim)
        (widow-cleanup-launch-anim #f)
        )
    (if (zero? (widow-bomb-launch (-> self flying) (>= (-> self bomb-hits) 3) #f))
        (go-virtual watch-bombs-stage-2)
        )
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate back-to-perch-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (ja-channel-push! 1 (seconds 1))
    (ja :group! (-> self draw art-group data 6) :num! min)
    (let ((a2-1 (new 'stack-no-clear 'vector))
          (f0-1 49152.0)
          )
      (set! (-> a2-1 quad) (-> self circle-center quad))
      (set! (-> a2-1 z) (+ -40960.0 (-> a2-1 z)))
      (let ((f0-3 (- (+ f0-1 (-> a2-1 y)) (-> self root trans y))))
        (setup-from-to-duration-and-height! (-> self traj) (-> self root trans) a2-1 300.0 f0-3)
        )
      )
    (set! (-> self theta max-vel) 273.06668)
    (set! (-> self theta accel) 0.05)
    (set! (-> self theta target) 0.0)
    (set! (-> self theta vel) (* 0.08488264 (-> self osc vel z)))
    (set! (-> self theta value) (* 0.08488264 (-> self osc value z)))
    (set! (-> self flying) #t)
    (none)
    )
  :trans (behavior ()
    (compute-trans-at-time
      (-> self traj)
      (the float (min 300 (- (current-time) (-> self state-time))))
      (-> self root trans)
      )
    (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 (+ 32768.0 (-> self theta value)))
    (let ((v1-9 (ja-group)))
      (cond
        ((and v1-9 (= v1-9 (-> self draw art-group data 6)))
         (ja :num! (seek!))
         (when (and (ja-done? 0) (>= (- (current-time) (-> self state-time)) (seconds 1)))
           (ja-channel-push! 1 (seconds 0.02))
           (ja :group! (-> self draw art-group data 7) :num! min)
           (set! (-> self flying) #f)
           (when (nonzero? (-> self land-part))
             (let ((gp-1 (new 'stack-no-clear 'vector)))
               (vector<-cspace! gp-1 (-> self node-list data 28))
               (spawn (-> self land-part) gp-1)
               (vector<-cspace! gp-1 (-> self node-list data 36))
               (spawn (-> self land-part) gp-1)
               (vector<-cspace! gp-1 (-> self node-list data 61))
               (spawn (-> self land-part) gp-1)
               (vector<-cspace! gp-1 (-> self node-list data 69))
               (spawn (-> self land-part) gp-1)
               )
             )
           )
         )
        ((let ((v1-47 (ja-group)))
           (and v1-47 (= v1-47 (-> self draw art-group data 7)))
           )
         (ja :num! (seek!))
         (when (ja-done? 0)
           (set! (-> self drill-speed target) 1.0)
           (jump-to-target! (-> self drill-speed) 0.0)
           (go-virtual launch-bombs-stage-2)
           )
         )
        )
      )
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-low-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self osc target y) -122880.0)
    (let* ((v1-2 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
           (v1-3 (the-as number (logior #x3f800000 v1-2)))
           )
      (if (< (+ -1.0 (the-as float v1-3)) 0.5)
          (set! (-> self attack-from-high-deg) (not (-> self attack-from-high-deg)))
          )
      )
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (widow-general-flying-talker)
    (if (>= (-> self bomb-hits) 4)
        (go-virtual back-to-perch-stage-2)
        )
    (when (< (-> self osc value y) (+ 8192.0 (-> self osc target y)))
      (cond
        ((zero? (widow-bomb-slots-full))
         (go-virtual back-to-perch-stage-2)
         )
        ((>= (- (current-time) (-> self state-time)) (seconds 0.007))
         (go-virtual hover-seek-under-stage-2)
         )
        )
      )
    (let ((v1-20 (ja-group)))
      (cond
        ((and v1-20 (= v1-20 (-> self draw art-group data 17)))
         (ja :num! (seek!))
         (if (ja-done? 0)
             (ja :group! (-> self draw art-group data 5) :num! min)
             )
         )
        (else
          (ja :num! (loop!))
          )
        )
      )
    (widow-give-ammo)
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-shooting-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-shoot-gun-talker)
    (ja-channel-push! 1 (seconds 0.02))
    (ja :group! (-> self draw art-group data 15) :num! min)
    (set! (-> self which-gun) 0)
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (+! (-> self current-shoot-stage) 1)
    (none)
    )
  :exit (behavior ()
    (ja :group! (-> self draw art-group data 17) :num! min)
    (if (and (< 1 (-> self gun-hits)) (< (-> self current-shoot-stage) 10))
        (talker-spawn-func (-> *talker-speech* 301) *entity-pool* (target-pos 0) (the-as region #f))
        )
    (none)
    )
  :trans (behavior ()
    (if (>= (-> self bomb-hits) 4)
        (go-virtual back-to-perch-stage-2)
        )
    (let ((a0-1 (widow-calc-target-position (new 'stack-no-clear 'vector)))
          (v1-5 #t)
          )
      (set! (-> self osc target y) (-> a0-1 y))
      (cond
        ((not (-> self attack-from-high-deg))
         (set! (-> self osc target z) (fmin 193019.44 (+ 21446.604 (-> a0-1 z))))
         (when (< (+ 2457.6 (-> self osc value z)) (-> self osc target z))
           (set! (-> self osc target z) (+ 2457.6 (-> self osc value z)))
           (set! v1-5 #f)
           )
         )
        (else
          (set! (-> self osc target z)
                (fmax (fmax -193019.44 (+ -21446.604 (-> a0-1 z))) (+ -2457.6 (-> self osc value z)))
                )
          (when (< (-> self osc target z) (+ -2457.6 (-> self osc value z)))
            (set! (-> self osc target z) (+ -2457.6 (-> self osc value z)))
            (set! v1-5 #f)
            )
          )
        )
      (set! v1-5 (and (< (fabs (- (-> self osc value z) (-> self osc target z))) 1024.0)
                      (and (>= (- (current-time) (-> self state-time)) (seconds 0.007)) v1-5)
                      )
            )
      (if v1-5
          (go-virtual hover-low-stage-2)
          )
      )
    (ja :num! (seek!))
    (let ((v1-22 (ja-group)))
      (when (and (and v1-22 (= v1-22 (-> self draw art-group data 16)))
                 (>= (ja-frame-num 0) (the float (-> self which-gun)))
                 )
        (let ((v1-28 (-> self which-gun)))
          (cond
            ((zero? v1-28)
             (widow-method-46 self (the-as vector #t) 84)
             (set! (-> self which-gun) 2)
             )
            ((= v1-28 2)
             (widow-method-46 self (the-as vector #t) 87)
             (set! (-> self which-gun) 4)
             )
            ((= v1-28 4)
             (widow-method-46 self (the-as vector #t) 82)
             (set! (-> self which-gun) 6)
             )
            ((= v1-28 6)
             (widow-method-46 self (the-as vector #t) 89)
             (set! (-> self which-gun) 100)
             )
            )
          )
        )
      )
    (when (ja-done? 0)
      (ja :group! (-> self draw art-group data 16) :num! min)
      (set! (-> self which-gun) 0)
      0
      )
    (widow-give-ammo)
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-rise-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self osc target x) 135168.0)
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (if (>= (-> self bomb-hits) 4)
        (go-virtual back-to-perch-stage-2)
        )
    (let ((gp-0 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (set! (-> self osc target y) (-> gp-0 y))
      (when (and (< (+ -10240.0 (-> self osc target y)) (-> self osc value y))
                 (>= (- (current-time) (-> self state-time)) (seconds 0.007))
                 )
        (let* ((v1-13 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-14 (the-as number (logior #x3f800000 v1-13)))
               )
          (if (< (+ -1.0 (the-as float v1-14)) 0.1)
              (go-virtual hover-low-stage-2)
              (go-virtual hover-shooting-stage-2)
              )
          )
        )
      (if (-> self attack-from-high-deg)
          (set! (-> self osc target z) (fmin 193019.44 (+ 42893.207 (-> gp-0 z))))
          (set! (-> self osc target z) (fmax -193019.44 (+ -42893.207 (-> gp-0 z))))
          )
      )
    (widow-flying-anim)
    (widow-give-ammo)
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-seek-under-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self osc target x) 135168.0)
    (set! (-> self flying) #t)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (if (>= (-> self bomb-hits) 4)
        (go-virtual back-to-perch-stage-2)
        )
    (widow-general-flying-talker)
    (let ((v1-5 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (if (-> self attack-from-high-deg)
          (set! (-> self osc target z) (fmin 193019.44 (+ 42893.207 (-> v1-5 z))))
          (set! (-> self osc target z) (fmax -193019.44 (+ -42893.207 (-> v1-5 z))))
          )
      )
    (if (and (< (fabs (- (-> self osc value z) (-> self osc target z))) 8192.0)
             (>= (- (current-time) (-> self state-time)) (seconds 0.007))
             )
        (go-virtual hover-rise-stage-2)
        )
    (widow-flying-anim)
    (widow-give-ammo)
    (widow-common)
    (widow-calc-root-from-osc 0.0)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hover-jump-down-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-leave-perch-talker)
    (set! (-> self state-time) (current-time))
    (set! (-> self drill-speed target) 0.0)
    (ja-channel-push! 1 (seconds 1.5))
    (ja :group! (-> self draw art-group data 5) :num! min)
    (let ((gp-1 (widow-calc-target-position (new 'stack-no-clear 'vector))))
      (set! (-> self theta target) (* 0.08488264 (-> gp-1 z)))
      (widow-calc-position gp-1 151552.0 -81920.0 (-> self theta target))
      (setup-from-to-duration-and-height! (-> self traj) (-> self root trans) gp-1 450.0 49152.0)
      )
    (set! (-> self flying) #t)
    (none)
    )
  :exit (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (set-vector! a1-0 151552.0 -81920.0 (* 11.780972 (-> self theta target)) 1.0)
      (widow-oscillator-method-9 (-> self osc) a1-0 81.92 1638.4 0.98)
      )
    (widow-oscillator-method-9 (-> self noise-osc) (the-as vector #f) 4.096 204.8 0.9)
    (init (-> self rand-vec) 75 150 204.8 819.2)
    (none)
    )
  :trans (behavior ()
    (widow-flying-anim)
    (compute-trans-at-time
      (-> self traj)
      (the float (min 450 (- (current-time) (-> self state-time))))
      (-> self root trans)
      )
    (if (>= (- (current-time) (-> self state-time)) (seconds 1.5))
        (go-virtual hover-seek-under-stage-2)
        )
    (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 (+ 32768.0 (-> self theta value)))
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate launch-droids-stage-2 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-launch-droids-talker)
    (spydroid-setup)
    (set! (-> self flying) #f)
    (none)
    )
  :exit (behavior ()
    (set! (-> self left-cover-angle target) 0.0)
    (set! (-> self right-cover-angle target) 0.0)
    (none)
    )
  :trans (behavior ()
    (widow-cleanup-launch-anim #f)
    (if (>= (-> self bomb-hits) 4)
        (go-virtual launch-bombs-stage-2)
        )
    (if (zero? (spydroid-launch))
        (go-virtual hover-jump-down-stage-2)
        )
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate big-reaction-stage-1 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (dotimes (gp-0 8)
      (let ((a0-1 (handle->process (-> self bomb gp-0))))
        (if a0-1
            (send-event a0-1 'fizzle)
            )
        )
      )
    (set! (-> self bomb-hits) 0)
    (set! (-> self drill-speed target) 0.0)
    (set! (-> self flying) #f)
    (ja-channel-push! 1 (seconds 0.02))
    (ja :group! (-> self draw art-group data 25) :num! min)
    (none)
    )
  :exit (behavior ()
    (let ((v1-1 (handle->process (-> self hud))))
      (when v1-1
        (set! (-> (the-as hud-widow v1-1) values 0 target) 2)
        (set! (-> (the-as hud-widow v1-1) values 1 target) 100)
        )
      )
    (none)
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (if (and (and v1-2 (= v1-2 (-> self draw art-group data 8))) (zero? (widow-bomb-slots-full)))
          (go-virtual launch-droids-stage-2)
          )
      )
    (ja :num! (seek!))
    (when (ja-done? 0)
      (ja :group! (-> self draw art-group data 8) :num! min)
      (set! (-> self drill-speed target) 1.0)
      )
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate watch-bombs-stage-1 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self flying) #f)
    (none)
    )
  :trans (behavior ()
    (widow-want-stone-talker)
    (let ((gp-0 (widow-bomb-slots-full)))
      (cond
        ((>= (-> self bomb-hits) 4)
         (go-virtual big-reaction-stage-1)
         )
        ((and (zero? gp-0) (let ((v1-8 (ja-group)))
                             (and v1-8 (= v1-8 (-> self draw art-group data 8)))
                             )
              )
         (go-virtual launch-droids-stage-1)
         )
        )
      (widow-cleanup-launch-anim (< 3 gp-0))
      )
    (widow-give-ammo)
    (widow-common)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate launch-bombs-stage-1 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (if (and (< (-> self kicked-bombs) 2) (>= (-> self launch-stages-completed) 1))
        (talker-spawn-func (-> *talker-speech* 303) *entity-pool* (target-pos 0) (the-as region #f))
        (widow-launch-bombs-talker)
        )
    (widow-bomb-setup)
    (set! (-> self flying) #f)
    (none)
    )
  :exit (behavior ()
    (set! (-> self left-cover-angle target) 0.0)
    (set! (-> self right-cover-angle target) 0.0)
    (+! (-> self launch-stages-completed) 1)
    (none)
    )
  :trans (behavior ()
    (widow-cleanup-launch-anim #f)
    (if (zero? (widow-bomb-launch (-> self flying) #f #f))
        (go-virtual watch-bombs-stage-1)
        )
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate watch-droids-stage-1 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (set! (-> self flying) #f)
    (none)
    )
  :trans (behavior ()
    (widow-want-stone-talker)
    (if (>= (-> self bomb-hits) 4)
        (go-virtual big-reaction-stage-1)
        )
    (let ((gp-0 (widow-bomb-slots-full)))
      (if (and (zero? gp-0) (let ((v1-8 (ja-group)))
                              (and v1-8 (= v1-8 (-> self draw art-group data 8)))
                              )
               )
          (go-virtual launch-bombs-stage-1)
          )
      (widow-cleanup-launch-anim (< 3 gp-0))
      )
    (widow-give-ammo)
    (widow-common)
    (widow-debug)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate launch-droids-stage-1 (widow)
  :virtual #t
  :event widow-handler
  :enter (behavior ()
    (widow-launch-droids-talker)
    (let ((gp-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> gp-0 from) (process->ppointer self))
      (set! (-> gp-0 num-params) 0)
      (set! (-> gp-0 message) 'start)
      (let ((s5-0 send-event-function)
            (v1-2 (entity-by-name "cave-in-master-1"))
            )
        (s5-0
          (if v1-2
              (-> v1-2 extra process)
              )
          gp-0
          )
        )
      )
    (spydroid-setup)
    (set! (-> self drill-speed target) 1.0)
    (set! (-> self flying) #f)
    (none)
    )
  :exit (behavior ()
    (set! (-> self left-cover-angle target) 0.0)
    (set! (-> self right-cover-angle target) 0.0)
    (none)
    )
  :trans (behavior ()
    (widow-cleanup-launch-anim #f)
    (if (zero? (spydroid-launch))
        (go-virtual watch-droids-stage-1)
        )
    (widow-give-ammo)
    (widow-common)
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  :post (the-as (function none :behavior widow) transform-post)
  )

(defstate hidden (widow)
  :virtual #t
  :enter (behavior ()
    (ja-channel-set! 0)
    (ja-post)
    (set! (-> self movie-handle) (the-as handle #f))
    (none)
    )
  :exit (behavior ()
    (ja-channel-push! 1 0)
    (ja :group! (-> self draw art-group data 8) :num! min)
    (set! (-> self hud) (ppointer->handle (process-spawn hud-widow :init hud-init-by-other :to self)))
    (let ((v1-13 (handle->process (-> self hud))))
      (if v1-13
          (set! (-> (the-as hud-widow v1-13) values 0 target) 1)
          )
      )
    (none)
    )
  :trans (behavior ()
    (cond
      ((and (= (-> self movie-handle) #f) (not (task-node-closed? (game-task-node tomb-boss-introduction))))
       (when (and *target*
                  (task-node-closed? (game-task-node tomb-boss-door))
                  (not *scene-player*)
                  (not *progress-process*)
                  )
         (let ((f0-0 (vector-vector-xz-distance (-> self circle-center) (-> *target* control trans))))
           (cond
             ((< f0-0 376832.0)
              (set! (-> self movie-handle)
                    (ppointer->handle (process-spawn scene-player :init scene-player-init "tomb-boss-intro" #t #f))
                    )
              )
             ((< f0-0 409600.0)
              (script-eval '(want-anim "tomb-boss-intro"))
              )
             )
           )
         )
       )
      ((or (not (handle->process (-> self movie-handle)))
           (task-node-closed? (game-task-node tomb-boss-introduction))
           )
       (set! (-> self heart) (ppointer->handle (process-spawn heart-mar (-> self root trans) :to self)))
       (set-setting! 'music 'danger7 0.0 0)
       (go-virtual launch-droids-stage-1)
       )
      )
    (none)
    )
  :code (the-as (function none :behavior widow) sleep-code)
  )
