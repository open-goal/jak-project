;;-*-Lisp-*-
(in-package goal)

;; name: widow-extras.gc
;; name in dgo: widow-extras
;; dgos: TOA

;; DECOMP BEGINS

(deftype tomb-boss-catwalk (process-drawable)
  ((root       collide-shape-moving  :override)
   (which-look int32                 :offset-assert 200)
   )
  :heap-base #x50
  :method-count-assert 23
  :size-assert         #xcc
  :flag-assert         #x17005000cc
  (:methods
    (shatter () _type_ :state 20)
    (idle () _type_ :state 21)
    (tomb-boss-catwalk-method-22 (_type_ vector int) none 22)
    )
  )


(defskelgroup skel-tomb-boss-catwalk-main tomb-boss-catwalk tomb-boss-catwalk-main-lod0-jg tomb-boss-catwalk-main-idle-ja
              ((tomb-boss-catwalk-main-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

(defskelgroup skel-tomb-boss-catwalk-a tomb-boss-catwalk tomb-boss-catwalk-a-lod0-jg tomb-boss-catwalk-a-idle-ja
              ((tomb-boss-catwalk-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 18)
              :origin-joint-index 30
              )

(defskelgroup skel-tomb-boss-catwalk-b tomb-boss-catwalk tomb-boss-catwalk-b-lod0-jg tomb-boss-catwalk-b-idle-ja
              ((tomb-boss-catwalk-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 14)
              :origin-joint-index 30
              )

(defskelgroup skel-tomb-boss-catwalk-c tomb-boss-catwalk tomb-boss-catwalk-c-lod0-jg tomb-boss-catwalk-c-idle-ja
              ((tomb-boss-catwalk-c-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 14)
              :origin-joint-index 30
              )

(defskelgroup skel-tomb-boss-catwalk-d tomb-boss-catwalk tomb-boss-catwalk-d-lod0-jg tomb-boss-catwalk-d-idle-ja
              ((tomb-boss-catwalk-d-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 14)
              :origin-joint-index 30
              )

(defskelgroup skel-tomb-boss-catwalk-e tomb-boss-catwalk tomb-boss-catwalk-e-lod0-jg tomb-boss-catwalk-e-idle-ja
              ((tomb-boss-catwalk-e-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 14)
              :origin-joint-index 18
              )

(defskelgroup skel-tomb-boss-catwalk-f tomb-boss-catwalk tomb-boss-catwalk-f-lod0-jg tomb-boss-catwalk-f-idle-ja
              ((tomb-boss-catwalk-f-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 14)
              :origin-joint-index 30
              )

(defskelgroup skel-tomb-boss-catwalk-g tomb-boss-catwalk tomb-boss-catwalk-g-lod0-jg tomb-boss-catwalk-g-idle-ja
              ((tomb-boss-catwalk-g-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -2 0 14)
              :origin-joint-index 30
              )

(defstate shatter (tomb-boss-catwalk)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self draw status) (draw-control-status no-draw-bounds))
    (set! (-> self draw bounds w) 245760.0)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (case (-> self which-look)
        ((1)
         (ja :group! (-> self draw art-group data 3) :num! min)
         (set-vector! gp-0 188416.0 32768.0 -81920.0 1.0)
         )
        ((2)
         (ja :group! (-> self draw art-group data 8) :num! min)
         (set-vector! gp-0 139264.0 32768.0 -147456.0 1.0)
         )
        ((3)
         (ja :group! (-> self draw art-group data 13) :num! min)
         (set-vector! gp-0 81920.0 32768.0 -188416.0 1.0)
         )
        ((4)
         (ja :group! (-> self draw art-group data 18) :num! min)
         (set-vector! gp-0 0.0 32768.0 -200704.0 1.0)
         )
        ((5)
         (ja :group! (-> self draw art-group data 23) :num! min)
         (set-vector! gp-0 -81920.0 32768.0 -188416.0 1.0)
         )
        ((6)
         (ja :group! (-> self draw art-group data 28) :num! min)
         (set-vector! gp-0 -139264.0 32768.0 -147456.0 1.0)
         )
        ((7)
         (ja :group! (-> self draw art-group data 33) :num! min)
         (set-vector! gp-0 -188416.0 32768.0 -81920.0 1.0)
         )
        )
      (vector+! gp-0 gp-0 (-> self root trans))
      (let ((s5-7 (get-process *default-dead-pool* part-tracker #x4000)))
        (when s5-7
          (let ((t9-8 (method-of-type part-tracker activate)))
            (t9-8
              (the-as part-tracker s5-7)
              *entity-pool*
              (symbol->string (-> part-tracker symbol))
              (the-as pointer #x70004000)
              )
            )
          (let ((t9-9 run-function-in-process)
                (a0-54 s5-7)
                (a1-11 part-tracker-init)
                (a2-11 (-> *part-group-id-table* 717))
                (a3-1 0)
                (t0-0 #f)
                (t1-0 #f)
                (t2-0 #f)
                (t3-0 *launch-matrix*)
                )
            (set! (-> t3-0 trans quad) (-> gp-0 quad))
            ((the-as (function object object object object object object object object none) t9-9)
             a0-54
             a1-11
             a2-11
             a3-1
             t0-0
             t1-0
             t2-0
             t3-0
             )
            )
          (-> s5-7 ppointer)
          )
        )
      )
    (none)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (if (ja-done? 0)
        (deactivate self)
        )
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-catwalk) sleep-code)
  :post (the-as (function none :behavior tomb-boss-catwalk) ja-post)
  )

(defstate idle (tomb-boss-catwalk)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('catwalk-hit)
                      (when (zero? (-> self which-look))
                        (case (-> event param 0)
                          ((1)
                           (the-as object (setup-masks (-> self draw) 0 1))
                           )
                          ((2)
                           (the-as object (setup-masks (-> self draw) 0 2))
                           )
                          ((3)
                           (the-as object (setup-masks (-> self draw) 0 4))
                           )
                          ((4)
                           (the-as object (setup-masks (-> self draw) 0 8))
                           )
                          ((5)
                           (the-as object (setup-masks (-> self draw) 0 16))
                           )
                          ((6)
                           (the-as object (setup-masks (-> self draw) 0 32))
                           )
                          ((7)
                           (the-as object (setup-masks (-> self draw) 0 64))
                           )
                          )
                        )
                      )
                     (('green-hit)
                      (when (nonzero? (-> self which-look))
                        (send-event (ppointer->process (-> self parent)) 'catwalk-hit (-> self which-look))
                        (go-virtual shatter)
                        )
                      )
                     )
            )
    )
  :code (the-as (function none :behavior tomb-boss-catwalk) sleep-code)
  )

(defmethod tomb-boss-catwalk-method-22 tomb-boss-catwalk ((obj tomb-boss-catwalk) (arg0 vector) (arg1 int))
  (case arg1
    ((1)
     (let ((s3-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-3 (new 'process 'collide-shape-prim-mesh s3-0 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-3 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-3 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-3 prim-core action) (collide-action solid))
         (set! (-> v1-3 transform-index) 30)
         (set-vector! (-> v1-3 local-sphere) 0.0 -12288.0 0.0 57344.0)
         (set! (-> s3-0 total-prims) (the-as uint 1))
         (set! (-> s3-0 root-prim) v1-3)
         )
       (set! (-> s3-0 nav-radius) 8192.0)
       (let ((v1-5 (-> s3-0 root-prim)))
         (set! (-> s3-0 backup-collide-as) (-> v1-5 prim-core collide-as))
         (set! (-> s3-0 backup-collide-with) (-> v1-5 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-0))
       )
     )
    ((2)
     (let ((s3-1 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-9 (new 'process 'collide-shape-prim-mesh s3-1 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-9 prim-core action) (collide-action solid))
         (set! (-> v1-9 transform-index) 30)
         (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 65536.0)
         (set! (-> s3-1 total-prims) (the-as uint 1))
         (set! (-> s3-1 root-prim) v1-9)
         )
       (set! (-> s3-1 nav-radius) 8192.0)
       (let ((v1-11 (-> s3-1 root-prim)))
         (set! (-> s3-1 backup-collide-as) (-> v1-11 prim-core collide-as))
         (set! (-> s3-1 backup-collide-with) (-> v1-11 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-1))
       )
     )
    ((3)
     (let ((s3-2 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-15 (new 'process 'collide-shape-prim-mesh s3-2 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-15 prim-core action) (collide-action solid))
         (set! (-> v1-15 transform-index) 30)
         (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 65536.0)
         (set! (-> s3-2 total-prims) (the-as uint 1))
         (set! (-> s3-2 root-prim) v1-15)
         )
       (set! (-> s3-2 nav-radius) 8192.0)
       (let ((v1-17 (-> s3-2 root-prim)))
         (set! (-> s3-2 backup-collide-as) (-> v1-17 prim-core collide-as))
         (set! (-> s3-2 backup-collide-with) (-> v1-17 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-2))
       )
     )
    ((4)
     (let ((s3-3 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-21 (new 'process 'collide-shape-prim-mesh s3-3 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-21 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-21 prim-core action) (collide-action solid))
         (set! (-> v1-21 transform-index) 30)
         (set-vector! (-> v1-21 local-sphere) 0.0 0.0 0.0 65536.0)
         (set! (-> s3-3 total-prims) (the-as uint 1))
         (set! (-> s3-3 root-prim) v1-21)
         )
       (set! (-> s3-3 nav-radius) 8192.0)
       (let ((v1-23 (-> s3-3 root-prim)))
         (set! (-> s3-3 backup-collide-as) (-> v1-23 prim-core collide-as))
         (set! (-> s3-3 backup-collide-with) (-> v1-23 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-3))
       )
     )
    ((5)
     (let ((s3-4 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-27 (new 'process 'collide-shape-prim-mesh s3-4 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-27 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-27 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-27 prim-core action) (collide-action solid))
         (set! (-> v1-27 transform-index) 18)
         (set-vector! (-> v1-27 local-sphere) 0.0 0.0 0.0 65536.0)
         (set! (-> s3-4 total-prims) (the-as uint 1))
         (set! (-> s3-4 root-prim) v1-27)
         )
       (set! (-> s3-4 nav-radius) 8192.0)
       (let ((v1-29 (-> s3-4 root-prim)))
         (set! (-> s3-4 backup-collide-as) (-> v1-29 prim-core collide-as))
         (set! (-> s3-4 backup-collide-with) (-> v1-29 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-4))
       )
     )
    ((6)
     (let ((s3-5 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-33 (new 'process 'collide-shape-prim-mesh s3-5 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-33 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-33 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-33 prim-core action) (collide-action solid))
         (set! (-> v1-33 transform-index) 30)
         (set-vector! (-> v1-33 local-sphere) 0.0 0.0 0.0 65536.0)
         (set! (-> s3-5 total-prims) (the-as uint 1))
         (set! (-> s3-5 root-prim) v1-33)
         )
       (set! (-> s3-5 nav-radius) 8192.0)
       (let ((v1-35 (-> s3-5 root-prim)))
         (set! (-> s3-5 backup-collide-as) (-> v1-35 prim-core collide-as))
         (set! (-> s3-5 backup-collide-with) (-> v1-35 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-5))
       )
     )
    ((7)
     (let ((s3-6 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
       (let ((v1-39 (new 'process 'collide-shape-prim-mesh s3-6 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-39 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-39 prim-core collide-with) (collide-spec jak bot player-list))
         (set! (-> v1-39 prim-core action) (collide-action solid))
         (set! (-> v1-39 transform-index) 30)
         (set-vector! (-> v1-39 local-sphere) 0.0 0.0 0.0 65536.0)
         (set! (-> s3-6 total-prims) (the-as uint 1))
         (set! (-> s3-6 root-prim) v1-39)
         )
       (set! (-> s3-6 nav-radius) 8192.0)
       (let ((v1-41 (-> s3-6 root-prim)))
         (set! (-> s3-6 backup-collide-as) (-> v1-41 prim-core collide-as))
         (set! (-> s3-6 backup-collide-with) (-> v1-41 prim-core collide-with))
         )
       (set! (-> obj root) (the-as collide-shape-moving s3-6))
       )
     )
    (else
      (let ((s3-7 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
        (let ((s2-0 (new 'process 'collide-shape-prim-group s3-7 (the-as uint 8) 0)))
          (set! (-> s3-7 total-prims) (the-as uint 9))
          (set! (-> s2-0 prim-core collide-as) (collide-spec obstacle))
          (set! (-> s2-0 prim-core collide-with) (collide-spec jak player-list))
          (set! (-> s2-0 prim-core action) (collide-action solid))
          (set! (-> s2-0 transform-index) 3)
          (set-vector! (-> s2-0 local-sphere) 0.0 0.0 0.0 327680.0)
          (set! (-> s3-7 root-prim) s2-0)
          )
        (let ((v1-52 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 7) (the-as uint 0))))
          (set! (-> v1-52 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-52 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-52 prim-core action) (collide-action solid))
          (set! (-> v1-52 transform-index) 11)
          (set-vector! (-> v1-52 local-sphere) 0.0 114688.0 0.0 65536.0)
          )
        (let ((v1-54 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 6) (the-as uint 0))))
          (set! (-> v1-54 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-54 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-54 prim-core action) (collide-action solid))
          (set! (-> v1-54 transform-index) 10)
          (set-vector! (-> v1-54 local-sphere) 0.0 114688.0 0.0 65536.0)
          )
        (let ((v1-56 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 5) (the-as uint 0))))
          (set! (-> v1-56 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-56 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-56 prim-core action) (collide-action solid))
          (set! (-> v1-56 transform-index) 9)
          (set-vector! (-> v1-56 local-sphere) 0.0 114688.0 0.0 57344.0)
          )
        (let ((v1-58 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 4) (the-as uint 0))))
          (set! (-> v1-58 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-58 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-58 prim-core action) (collide-action solid))
          (set! (-> v1-58 transform-index) 8)
          (set-vector! (-> v1-58 local-sphere) 0.0 114688.0 0.0 61440.0)
          )
        (let ((v1-60 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 3) (the-as uint 0))))
          (set! (-> v1-60 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-60 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-60 prim-core action) (collide-action solid))
          (set! (-> v1-60 transform-index) 7)
          (set-vector! (-> v1-60 local-sphere) 0.0 114688.0 0.0 61440.0)
          )
        (let ((v1-62 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 2) (the-as uint 0))))
          (set! (-> v1-62 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-62 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-62 prim-core action) (collide-action solid))
          (set! (-> v1-62 transform-index) 6)
          (set-vector! (-> v1-62 local-sphere) -8192.0 114688.0 0.0 57344.0)
          )
        (let ((v1-64 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 1) (the-as uint 0))))
          (set! (-> v1-64 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-64 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-64 prim-core action) (collide-action solid))
          (set! (-> v1-64 transform-index) 5)
          (set-vector! (-> v1-64 local-sphere) -4096.0 114688.0 0.0 57344.0)
          )
        (let ((v1-66 (new 'process 'collide-shape-prim-mesh s3-7 (the-as uint 0) (the-as uint 0))))
          (set! (-> v1-66 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-66 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-66 prim-core action) (collide-action solid))
          (set! (-> v1-66 transform-index) 4)
          (set-vector! (-> v1-66 local-sphere) 0.0 114688.0 0.0 65536.0)
          )
        (set! (-> s3-7 nav-radius) 8192.0)
        (let ((v1-68 (-> s3-7 root-prim)))
          (set! (-> s3-7 backup-collide-as) (-> v1-68 prim-core collide-as))
          (set! (-> s3-7 backup-collide-with) (-> v1-68 prim-core collide-with))
          )
        (set! (-> obj root) (the-as collide-shape-moving s3-7))
        )
      )
    )
  (set! (-> obj root trans quad) (-> arg0 quad))
  (case arg1
    ((1)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-a" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    ((2)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-b" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    ((3)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-c" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    ((4)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-d" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    ((5)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-e" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    ((6)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-f" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    ((7)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-tomb-boss-catwalk-g" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw-bounds))
     )
    (else
      (initialize-skeleton
        obj
        (the-as
          skeleton-group
          (art-group-get-by-name *level* "skel-tomb-boss-catwalk-main" (the-as (pointer uint32) #f))
          )
        (the-as pair 0)
        )
      )
    )
  (set! (-> obj root pause-adjust-distance) 245760.0)
  (set! (-> obj which-look) arg1)
  (quaternion-set! (-> obj root quat) 0.0 1.0 0.0 0.0)
  (transform-post)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-boss-catwalk ((obj tomb-boss-catwalk) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((a2-1 (res-lump-value arg0 'mode uint128 :time -1000000000.0)))
    (tomb-boss-catwalk-method-22 obj (-> arg0 extra trans) (the-as int a2-1))
    )
  (cleanup-for-death obj)
  (deactivate obj)
  (go (method-of-object obj idle))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior tomb-boss-catwalk-init-by-other tomb-boss-catwalk ((arg0 vector) (arg1 int))
  (tomb-boss-catwalk-method-22 self arg0 arg1)
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (set! (-> self draw light-index) (the-as uint 2))
  (go-virtual idle)
  (none)
  )

(deftype tomb-boss-catwalk-main (tomb-boss-catwalk)
  ()
  :heap-base #x50
  :method-count-assert 23
  :size-assert         #xcc
  :flag-assert         #x17005000cc
  )


(deftype widow-bomb (process-focusable)
  ((traj                  trajectory               :inline :offset-assert 208)
   (explode-part          sparticle-launch-control         :offset-assert 248)
   (trail-part            sparticle-launch-control         :offset-assert 252)
   (warning-glow-part     sparticle-launch-control         :offset-assert 256)
   (warning-spark-part    sparticle-launch-control         :offset-assert 260)
   (impact                impact-control           :inline :offset-assert 272)
   (which-trajectory      int32                            :offset-assert 352)
   (next-countdown-tick   time-frame                       :offset-assert 360)
   (skid-part             sparticle-launch-control         :offset-assert 368)
   (x-rotate              float                            :offset-assert 372)
   (y-rotate              float                            :offset-assert 376)
   (spin-jm               joint-mod                        :offset-assert 380)
   (firework-sound-played symbol                           :offset-assert 384)
   (steam-sound           sound-id                         :offset-assert 388)
   (launch                vector                   :inline :offset-assert 400)
   (launch-pos            vector                   :inline :offset-assert 416)
   (fizzle-timer          time-frame                       :offset-assert 432)
   )
  :heap-base #x140
  :method-count-assert 35
  :size-assert         #x1b8
  :flag-assert         #x23014001b8
  (:methods
    (freefall () _type_ :state 27)
    (back-atcha () _type_ :state 28)
    (explode () _type_ :state 29)
    (smoke () _type_ :state 30)
    (idle () _type_ :state 31)
    (widow-bomb-method-32 (_type_) none 32)
    (widow-bomb-method-33 (_type_) none 33)
    (widow-bomb-method-34 (_type_) none 34)
    )
  )


(defskelgroup skel-widow-bomb widow-bomb widow-bomb-lod0-jg widow-bomb-idle-ja
              ((widow-bomb-lod0-mg (meters 20)) (widow-bomb-lod1-mg (meters 40)) (widow-bomb-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; ERROR: Stack slot load at 48 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 64 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 48 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 64 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 48 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 64 mismatch: defined as size 4, got size 16
(defmethod widow-bomb-method-34 widow-bomb ((obj widow-bomb))
  (local-vars (sv-48 float) (sv-64 float))
  (let ((s5-0 (new 'stack-no-clear 'quaternion))
        (gp-0 (new 'stack-no-clear 'quaternion))
        )
    (let ((s3-0 quaternion-set!)
          (s2-0 s5-0)
          (s1-0 (sin (* 0.5 (-> obj x-rotate))))
          (s0-0 0.0)
          )
      (set! sv-48 (the-as float 0.0))
      (let ((t0-0 (cos (* 0.5 (-> obj x-rotate)))))
        (s3-0 s2-0 s1-0 s0-0 sv-48 t0-0)
        )
      )
    (let ((s3-1 quaternion-set!)
          (s2-1 gp-0)
          (s1-1 0.0)
          (s0-1 (sin (* 0.5 (-> obj y-rotate))))
          )
      (set! sv-64 (the-as float 0.0))
      (let ((t0-1 (cos (* 0.5 (-> obj y-rotate)))))
        (s3-1 s2-1 s1-1 s0-1 sv-64 t0-1)
        )
      )
    (quaternion-normalize! (quaternion*! (-> obj spin-jm quat) gp-0 s5-0))
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior widow-bomb-handler widow-bomb ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v1-13 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (case arg2
      (('attack)
       (cond
         ((= (-> arg0 type) target)
          (let ((gp-0 (new 'stack-no-clear 'vector))
                (f30-0 32768.0)
                )
            (let* ((s4-0 (ppointer->process (-> self parent)))
                   (v1-5 (if (type? s4-0 widow)
                             (the-as widow s4-0)
                             )
                         )
                   )
              (vector-! gp-0 (-> self root trans) (-> (the-as widow arg0) root trans))
              (set! (-> gp-0 y) 0.0)
              (cond
                (v1-5
                  (if (-> v1-5 flying)
                      (set! f30-0 16384.0)
                      )
                  (let ((s4-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> v1-5 node-list data 3)))
                        (s5-1 (new 'stack-no-clear 'vector))
                        )
                    (let ((f28-0 20480.0))
                      (vector-! s4-1 s4-1 (-> self root trans))
                      (let ((t9-2 vector-normalize!)
                            (a0-14 gp-0)
                            (v1-9 s4-1)
                            )
                        (t9-2 a0-14 (sqrtf (+ (* (-> v1-9 x) (-> v1-9 x)) (* (-> v1-9 z) (-> v1-9 z)))))
                        )
                      (set! (-> gp-0 y) (-> s4-1 y))
                      (vector-! s5-1 s4-1 gp-0)
                      (let* ((f0-6 f28-0)
                             (f0-8 (* f0-6 f0-6))
                             )
                        (.lvf vf1 (&-> s5-1 quad))
                        (.add.w.vf vf2 vf0 vf0 :mask #b1)
                        (.mul.vf vf1 vf1 vf1)
                        (.mul.x.vf acc vf2 vf1 :mask #b1)
                        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                        (.mov v1-13 vf1)
                        (if (< f0-8 v1-13)
                            (vector-normalize! s5-1 f28-0)
                            )
                        )
                      )
                    (vector+! gp-0 gp-0 s5-1)
                    )
                  )
                (else
                  (vector-normalize! gp-0 200704.0)
                  )
                )
              )
            (vector+! gp-0 gp-0 (-> self root trans))
            (setup-from-to-duration-and-height! (-> self traj) (-> self root trans) gp-0 225.0 f30-0)
            )
          (send-event (ppointer->process (-> self parent)) 'bomb-kicked)
          (go-virtual back-atcha)
          )
         (else
           (go-virtual explode)
           )
         )
       )
      (('fizzle)
       (let* ((gp-1 (current-time))
              (f30-1 600.0)
              (v1-34 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
              (v1-35 (the-as number (logior #x3f800000 v1-34)))
              )
         (set! (-> self fizzle-timer) (- gp-1 (the-as time-frame (the int (* f30-1 (+ -1.0 (the-as float v1-35)))))))
         )
       )
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior widow-bomb-back-handler widow-bomb ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact-control)
     (let* ((s4-0 (ppointer->process (-> self parent)))
            (s5-0 (if (type? s4-0 widow)
                      (the-as widow s4-0)
                      )
                  )
            )
       (when s5-0
         (let ((a1-3 (vector<-cspace! (new 'stack-no-clear 'vector) (-> s5-0 node-list data 3))))
           (when (and (< (vector-vector-distance (-> self root trans) a1-3) 49152.0) (not (-> s5-0 flying)))
             (send-event s5-0 'bomb-hit (-> self root trans) 1)
             (go-virtual explode)
             )
           )
         )
       )
     (let ((s5-1 arg0))
       (when (if (type? s5-1 widow)
                 s5-1
                 )
         (send-event arg0 'bomb-hit (-> self root trans) 1)
         (go-virtual explode)
         )
       )
     )
    (('fizzle)
     (let* ((gp-1 (current-time))
            (f30-0 600.0)
            (v1-34 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
            (v1-35 (the-as number (logior #x3f800000 v1-34)))
            )
       (set! (-> self fizzle-timer) (- gp-1 (the-as time-frame (the int (* f30-0 (+ -1.0 (the-as float v1-35)))))))
       )
     )
    )
  (none)
  )

(defstate freefall (widow-bomb)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior widow-bomb) widow-bomb-back-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (if (and (nonzero? (-> self fizzle-timer)) (>= (- (current-time) (-> self fizzle-timer)) (seconds 3)))
        (go-virtual explode)
        )
    (+! (-> self x-rotate) 1092.2667)
    (+! (-> self y-rotate) 728.1778)
    (widow-bomb-method-34 self)
    (spawn-with-cspace (-> self part) (-> self node-list data 3))
    (cond
      ((>= (- (current-time) (-> self state-time)) (seconds 4))
       (go-virtual explode)
       )
      (else
        (vector-v++!
          (-> self root transv)
          (compute-acc-due-to-gravity (the-as collide-shape-moving (-> self root)) (new-stack-vector0) 1.0)
          )
        (let ((a2-1 (new 'stack-no-clear 'collide-query)))
          (set! (-> a2-1 collide-with) (collide-spec backgnd enemy obstacle hit-by-others-list pusher))
          (set! (-> a2-1 ignore-process0) self)
          (set! (-> a2-1 ignore-process1) #f)
          (set! (-> a2-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> a2-1 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self root) (-> self root transv) a2-1 (meters 0))
          )
        )
      )
    (ja :num! (loop!))
    (none)
    )
  :code (the-as (function none :behavior widow-bomb) sleep-code)
  :post (the-as (function none :behavior widow-bomb) transform-post)
  )

(defstate back-atcha (widow-bomb)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior widow-bomb) widow-bomb-back-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (initialize
      (-> self impact)
      self
      3
      4096.0
      (collide-spec backgnd enemy obstacle hit-by-others-list player-list)
      )
    (let ((v1-5 (-> self root root-prim)))
      (logior! (-> v1-5 prim-core collide-with) (collide-spec enemy))
      (logclear! (-> v1-5 prim-core collide-with) (collide-spec jak))
      )
    (none)
    )
  :trans (behavior ()
    (if (and (nonzero? (-> self fizzle-timer)) (>= (- (current-time) (-> self fizzle-timer)) (seconds 3)))
        (go-virtual explode)
        )
    (+! (-> self x-rotate) 4369.067)
    (+! (-> self y-rotate) 3458.8445)
    (widow-bomb-method-34 self)
    (cond
      ((>= (- (current-time) (-> self state-time)) (the int (-> self traj time)))
       (compute-transv-at-time (-> self traj) (-> self traj time) (-> self root transv))
       (vector-float*! (-> self root transv) (-> self root transv) 300.0)
       (go-virtual freefall)
       )
      (else
        (compute-trans-at-time
          (-> self traj)
          (the float (- (current-time) (-> self state-time)))
          (-> self root trans)
          )
        (update-from-cspace (-> self impact))
        (when (>= (- (current-time) (-> self state-time)) 1)
          (let* ((a1-4 (new 'stack-no-clear 'collide-query))
                 (f0-10 (impact-control-method-11
                          (-> self impact)
                          a1-4
                          self
                          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noproj #x1 :noendlessfall #x1)
                          )
                        )
                 )
            (when (< 0.0 f0-10)
              (set! (-> self root trans quad) (-> self impact trans 1 quad))
              (compute-transv-at-time
                (-> self traj)
                (the float (- (current-time) (-> self state-time)))
                (-> self root transv)
                )
              (vector-float*! (-> self root transv) (-> self root transv) 300.0)
              (go-virtual freefall)
              )
            )
          )
        (spawn-with-cspace (-> self part) (-> self node-list data 3))
        )
      )
    (ja :num! (loop!))
    (none)
    )
  :code (the-as (function none :behavior widow-bomb) sleep-code)
  :post (the-as (function none :behavior widow-bomb) transform-post)
  )

(defstate explode (widow-bomb)
  :virtual #t
  :enter (behavior ()
    (let* ((a0-1 (target-pos 0))
           (f0-0 (vector-vector-distance-squared a0-1 (-> self root trans)))
           (f1-0 16384.0)
           )
      (when (< f0-0 (* f1-0 f1-0))
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer self))
          (set! (-> a1-1 num-params) 2)
          (set! (-> a1-1 message) 'attack)
          (set! (-> a1-1 param 0) (the-as uint #f))
          (let ((v1-7 (new 'static 'attack-info :mask (attack-info-mask mode shove-back shove-up id))))
            (let* ((a0-3 *game-info*)
                   (a2-1 (+ (-> a0-3 attack-id) 1))
                   )
              (set! (-> a0-3 attack-id) a2-1)
              (set! (-> v1-7 id) a2-1)
              )
            (set! (-> v1-7 mode) 'explode)
            (set! (-> v1-7 shove-up) 16384.0)
            (set! (-> v1-7 shove-back) 8192.0)
            (set! (-> a1-1 param 1) (the-as uint v1-7))
            )
          (send-event-function *target* a1-1)
          )
        )
      )
    (activate! *camera-smush-control* 819.2 37 210 1.0 0.995 (-> self clock))
    (ja-channel-set! 0)
    (let ((v1-12 (-> self root root-prim)))
      (set! (-> v1-12 prim-core collide-as) (collide-spec))
      (set! (-> v1-12 prim-core collide-with) (collide-spec))
      )
    0
    (sound-play "w-bomb-explode")
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (cond
      ((< (- (current-time) (-> self state-time)) (seconds 2))
       (let ((a1-0 (new 'stack-no-clear 'vector)))
         (set! (-> a1-0 quad) (-> self root trans quad))
         (+! (-> a1-0 y) 2048.0)
         (spawn (-> self explode-part) a1-0)
         )
       )
      ((not (-> self child))
       (deactivate self)
       )
      )
    (none)
    )
  :code (the-as (function none :behavior widow-bomb) sleep-code)
  :post (the-as (function none :behavior widow-bomb) ja-post)
  )

(defmethod widow-bomb-method-32 widow-bomb ((obj widow-bomb))
  (spawn-with-cspace (-> obj part) (-> obj node-list data 3))
  (sound-play "w-bomb-steam" :id (-> obj steam-sound) :position (-> obj root trans))
  (let ((s5-0 (the-as int (- (current-time) (-> obj state-time)))))
    (if (nonzero? (-> obj fizzle-timer))
        (set! s5-0
              (max (the-as time-frame s5-0) (- (seconds 12) (- (seconds 3) (- (current-time) (-> obj fizzle-timer)))))
              )
        )
    (if (< 3600 s5-0)
        (go (method-of-object obj explode))
        )
    (when (< 3000 s5-0)
      (spawn-with-cspace (-> obj warning-spark-part) (-> obj node-list data 3))
      (when (not (-> obj firework-sound-played))
        (set! (-> obj firework-sound-played) #t)
        (sound-play "w-bomb-firewrks")
        )
      )
    (let* ((v1-27 (* s5-0 s5-0))
           (a0-10 3600)
           (v1-28 (- (* a0-10 a0-10) v1-27))
           )
      (when (< v1-28 (-> obj next-countdown-tick))
        (let ((a0-14 540))
          (set! (-> obj next-countdown-tick) (the-as time-frame (- v1-28 (mod v1-28 (* a0-14 a0-14)))))
          )
        (let ((s5-2 (new 'stack-no-clear 'vector)))
          (vector<-cspace! s5-2 (-> obj node-list data 7))
          (spawn (-> obj warning-glow-part) s5-2)
          (vector<-cspace! s5-2 (-> obj node-list data 6))
          (spawn (-> obj warning-glow-part) s5-2)
          (vector<-cspace! s5-2 (-> obj node-list data 5))
          (spawn (-> obj warning-glow-part) s5-2)
          (vector<-cspace! s5-2 (-> obj node-list data 4))
          (spawn (-> obj warning-glow-part) s5-2)
          )
        (sound-play "w-bomb-timer")
        )
      )
    )
  0
  (none)
  )

(defstate smoke (widow-bomb)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior widow-bomb) widow-bomb-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let* ((v1-2 3600)
           (v1-3 (* v1-2 v1-2))
           (a0-0 540)
           )
      (set! (-> self next-countdown-tick) (the-as time-frame (- v1-3 (mod v1-3 (* a0-0 a0-0)))))
      )
    (set! (-> self steam-sound) (new-sound-id))
    (none)
    )
  :exit (behavior ()
    (sound-stop (-> self steam-sound))
    (none)
    )
  :trans (behavior ()
    (widow-bomb-method-32 self)
    (ja :num! (loop!))
    (none)
    )
  :code (the-as (function none :behavior widow-bomb) sleep-code)
  :post (the-as (function none :behavior widow-bomb) ja-post)
  )

(defmethod widow-bomb-method-33 widow-bomb ((obj widow-bomb))
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (set-vector! (-> gp-0 vector 1) 0.0 1.0 0.0 1.0)
    (vector-! (-> gp-0 vector 2) (the-as vector (-> obj impact trans)) (-> obj impact trans 1))
    (vector-cross! (the-as vector (-> gp-0 vector)) (-> gp-0 vector 1) (-> gp-0 vector 2))
    (vector-normalize! (the-as vector (-> gp-0 vector)) 1.0)
    (vector-cross! (-> gp-0 vector 2) (the-as vector (-> gp-0 vector)) (-> gp-0 vector 1))
    (vector<-cspace! (-> gp-0 trans) (-> obj node-list data 3))
    (set! (-> gp-0 vector 0 w) 0.0)
    (set! (-> gp-0 vector 1 w) 0.0)
    (set! (-> gp-0 vector 2 w) 0.0)
    (set! (-> gp-0 trans w) 1.0)
    (spawn-with-matrix (-> obj skid-part) gp-0)
    )
  (none)
  )

(defstate idle (widow-bomb)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as
        object
        (cond
          ((or (= v1-0 'touch) (= v1-0 'bonk))
           (when (< (-> self which-trajectory) 2)
             (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
               (set! (-> a1-1 from) (process->ppointer self))
               (set! (-> a1-1 num-params) 2)
               (set! (-> a1-1 message) 'attack)
               (set! (-> a1-1 param 0) (the-as uint #f))
               (let ((v1-5 (new 'static 'attack-info :mask (attack-info-mask shove-back shove-up id))))
                 (let* ((a0-2 *game-info*)
                        (a2-2 (+ (-> a0-2 attack-id) 1))
                        )
                   (set! (-> a0-2 attack-id) a2-2)
                   (set! (-> v1-5 id) a2-2)
                   )
                 (set! (-> v1-5 shove-up) 4096.0)
                 (set! (-> v1-5 shove-back) 12288.0)
                 (set! (-> a1-1 param 1) (the-as uint v1-5))
                 )
               (send-event-function *target* a1-1)
               )
             )
           )
          ((= v1-0 'impact-control)
           (if (and (!= proc self) (!= proc (-> self parent)))
               (send-event proc 'bomb-hit (-> self root trans) 1)
               )
           )
          ((= v1-0 'fizzle)
           (let* ((gp-0 (current-time))
                  (f30-0 600.0)
                  (v1-17 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                  (v1-18 (the-as number (logior #x3f800000 v1-17)))
                  (v0-0 (the-as object (- gp-0 (the-as time-frame (the int (* f30-0 (+ -1.0 (the-as float v1-18))))))))
                  )
             (set! (-> self fizzle-timer) (the-as time-frame v0-0))
             v0-0
             )
           )
          (else
            (the-as object (widow-bomb-handler proc arg1 event-type event))
            )
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (initialize (-> self impact) self 3 4096.0 (collide-spec backgnd obstacle hit-by-others-list player-list))
    (none)
    )
  :exit (behavior ()
    (when (nonzero? (-> self fizzle-timer))
      (let* ((gp-0 (current-time))
             (f30-0 600.0)
             (v1-4 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-5 (the-as number (logior #x3f800000 v1-4)))
             )
        (set! (-> self fizzle-timer) (- gp-0 (the-as time-frame (the int (* f30-0 (+ -1.0 (the-as float v1-5)))))))
        )
      )
    (none)
    )
  :trans (behavior ()
    (let ((v1-0 (-> self which-trajectory)))
      (cond
        ((zero? v1-0)
         (+! (-> self x-rotate) 4369.067)
         (+! (-> self y-rotate) 3458.8445)
         )
        ((= v1-0 1)
         (+! (-> self x-rotate) 7281.778)
         (set! (-> self y-rotate) 0.0)
         )
        (else
          (seek! (-> self x-rotate) 65353.957 7281.778)
          )
        )
      )
    (if (< 65536.0 (-> self x-rotate))
        (+! (-> self x-rotate) -65536.0)
        )
    (if (< 65536.0 (-> self y-rotate))
        (+! (-> self y-rotate) -65536.0)
        )
    (widow-bomb-method-34 self)
    (when (< (-> self root scale x) 1.0)
      (let ((f0-17 (fmin 1.0 (+ 0.025 (-> self root scale x)))))
        (set-vector! (-> self root scale) f0-17 f0-17 f0-17 1.0)
        )
      )
    (cond
      ((>= (- (current-time) (-> self state-time)) (the int (-> self traj time)))
       (let ((v1-29 (-> self which-trajectory)))
         (cond
           ((zero? v1-29)
            (set! (-> self which-trajectory) 1)
            (compute-trans-at-time
              (-> self traj)
              (fmin (-> self traj time) (the float (- (current-time) (-> self state-time))))
              (-> self root trans)
              )
            (set! (-> self state-time) (current-time))
            (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (the-as vector (-> self traj)))))
              (set! (-> gp-1 y) 0.0)
              (vector-normalize! gp-1 12288.0)
              (vector+! gp-1 gp-1 (-> self root trans))
              (setup-from-to-duration-and-height! (-> self traj) (-> self root trans) gp-1 75.0 4096.0)
              )
            (widow-bomb-method-33 self)
            (sound-play "w-bomb-part1")
            )
           ((= v1-29 1)
            (set! (-> self which-trajectory) 2)
            (compute-trans-at-time
              (-> self traj)
              (fmin (-> self traj time) (the float (- (current-time) (-> self state-time))))
              (-> self root trans)
              )
            (set! (-> self state-time) (current-time))
            (let ((gp-4 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (the-as vector (-> self traj)))))
              (set! (-> gp-4 y) 0.0)
              (vector-normalize! gp-4 4096.0)
              (vector+! gp-4 gp-4 (-> self root trans))
              (setup-from-to-duration-and-height! (-> self traj) (-> self root trans) gp-4 37.5 1024.0)
              )
            (widow-bomb-method-33 self)
            (sound-play "w-bomb-part2")
            )
           ((= v1-29 2)
            (compute-trans-at-time
              (-> self traj)
              (fmin (-> self traj time) (the float (- (current-time) (-> self state-time))))
              (-> self root trans)
              )
            (set! (-> self which-trajectory) 3)
            (let* ((gp-6 (-> self state-time))
                   (f30-0 300.0)
                   (v1-77 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
                   (v1-78 (the-as number (logior #x3f800000 v1-77)))
                   )
              (set! (-> self state-time) (+ gp-6 (the int (* f30-0 (+ -1.0 (the-as float v1-78))))))
              )
            (widow-bomb-method-33 self)
            )
           (else
             (go-virtual smoke)
             )
           )
         )
       )
      ((< (-> self which-trajectory) 3)
       (compute-trans-at-time
         (-> self traj)
         (fmin (-> self traj time) (the float (- (current-time) (-> self state-time))))
         (-> self root trans)
         )
       (when (and (zero? (-> self which-trajectory))
                  (< (- (current-time) (-> self state-time)) (the int (* 0.75 (-> self traj time))))
                  )
         (vector+float*! (-> self launch-pos) (-> self launch-pos) (-> self launch) (-> self clock time-adjust-ratio))
         (vector-lerp!
           (-> self root trans)
           (-> self launch-pos)
           (-> self root trans)
           (parameter-ease-sin-clamp
             (* 1.3333334 (/ (the float (- (current-time) (-> self state-time))) (-> self traj time)))
             )
           )
         )
       (spawn-with-cspace (-> self trail-part) (-> self node-list data 3))
       (when (zero? (-> self which-trajectory))
         (update-from-cspace (-> self impact))
         (when (>= (- (current-time) (-> self state-time)) (seconds 0.05))
           (let ((f0-42 (impact-control-method-11
                          (-> self impact)
                          (new 'stack-no-clear 'collide-query)
                          self
                          (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1)
                          )
                        )
                 )
             (if (< 0.0 f0-42)
                 (go-virtual explode)
                 )
             )
           )
         )
       )
      )
    (ja :num! (loop!))
    (none)
    )
  :code (the-as (function none :behavior widow-bomb) sleep-code)
  :post (behavior ()
    (transform-post)
    (do-push-aways (-> self root))
    (none)
    )
  )

(defmethod deactivate widow-bomb ((obj widow-bomb))
  (if (nonzero? (-> obj explode-part))
      (kill-and-free-particles (-> obj explode-part))
      )
  (if (nonzero? (-> obj trail-part))
      (kill-and-free-particles (-> obj trail-part))
      )
  (if (nonzero? (-> obj warning-glow-part))
      (kill-and-free-particles (-> obj warning-glow-part))
      )
  (if (nonzero? (-> obj warning-spark-part))
      (kill-and-free-particles (-> obj warning-spark-part))
      )
  (if (nonzero? (-> obj skid-part))
      (kill-and-free-particles (-> obj warning-spark-part))
      )
  ((the-as (function process-drawable none) (find-parent-method widow-bomb 10)) obj)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs widow-bomb.
(defmethod relocate widow-bomb ((obj widow-bomb) (arg0 int))
  (if (nonzero? (-> obj explode-part))
      (&+! (-> obj explode-part) arg0)
      )
  (if (nonzero? (-> obj trail-part))
      (&+! (-> obj trail-part) arg0)
      )
  (if (nonzero? (-> obj warning-glow-part))
      (&+! (-> obj warning-glow-part) arg0)
      )
  (if (nonzero? (-> obj warning-spark-part))
      (&+! (-> obj warning-spark-part) arg0)
      )
  (if (nonzero? (-> obj skid-part))
      (&+! (-> obj skid-part) arg0)
      )
  (if (nonzero? (-> obj spin-jm))
      (&+! (-> obj spin-jm) arg0)
      )
  (the-as
    widow-bomb
    ((the-as (function process-drawable int process-drawable) (find-parent-method widow-bomb 7)) obj arg0)
    )
  )

(defbehavior widow-bomb-reaction widow ((arg0 control-info) (arg1 collide-query) (arg2 vector) (arg3 vector))
  (cshape-reaction-update-state arg0 arg1 arg3)
  (vector--float*!
    arg2
    arg3
    (-> arg0 surface-normal)
    (* (vector-dot arg3 (-> arg0 surface-normal)) (rand-vu-float-range 1.2 1.4))
    )
  (send-event (-> arg0 process) 'impact-control)
  (-> arg0 status)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior widow-bomb-init-by-other widow-bomb ((arg0 vector) (arg1 vector) (arg2 float) (arg3 float) (arg4 vector))
  (let ((s1-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s1-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s1-0 reaction) widow-bomb-reaction)
    (set! (-> s1-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s1-0 (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-6 prim-core collide-with) (collide-spec backgnd jak bot hit-by-others-list player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s1-0 total-prims) (the-as uint 1))
      (set! (-> s1-0 root-prim) v1-6)
      )
    (set! (-> s1-0 nav-radius) (* 0.75 (-> s1-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s1-0 root-prim)))
      (set! (-> s1-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s1-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> s1-0 event-self) 'impact-control)
    (set! (-> self root) s1-0)
    )
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-widow-bomb" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 712) self))
  (set! (-> self explode-part) (create-launch-control (-> *part-group-id-table* 711) self))
  (set! (-> self trail-part) (create-launch-control (-> *part-group-id-table* 722) self))
  (set! (-> self warning-glow-part) (create-launch-control (-> *part-group-id-table* 724) self))
  (set! (-> self warning-spark-part) (create-launch-control (-> *part-group-id-table* 723) self))
  (set! (-> self skid-part) (create-launch-control (-> *part-group-id-table* 725) self))
  (set-vector! (-> self root scale) 0.5 0.5 0.5 1.0)
  (if (< (-> arg0 y) (-> arg1 y))
      (set! arg3 (+ arg3 (- (-> arg1 y) (-> arg0 y))))
      )
  (let ((a3-3 (* 0.0000061035157 (vector-vector-xz-distance arg0 arg1) arg2)))
    (setup-from-to-duration-and-height! (-> self traj) arg0 arg1 a3-3 arg3)
    )
  (let ((v1-42 (new 'stack-no-clear 'vector)))
    (vector-! v1-42 arg1 arg0)
    (set! (-> v1-42 y) 0.0)
    (let ((f30-1 (atan (-> v1-42 x) (-> v1-42 z))))
      (quaternion-set! (-> self root quat) 0.0 (sin (* 0.5 f30-1)) 0.0 (cos (* 0.5 f30-1)))
      )
    )
  (set! (-> self which-trajectory) 0)
  (set! (-> self x-rotate) 0.0)
  (set! (-> self y-rotate) 0.0)
  (logclear! (-> self mask) (process-mask actor-pause))
  (set! (-> self spin-jm) (new 'process 'joint-mod (joint-mod-mode joint-set*) self 3))
  (set! (-> self firework-sound-played) #f)
  (set! (-> self steam-sound) (new 'static 'sound-id))
  (set! (-> self launch-pos quad) (-> self root trans quad))
  (set! (-> self launch quad) (-> arg4 quad))
  (set! (-> self fizzle-timer) 0)
  (go-virtual idle)
  (none)
  )

(deftype heart-mar (process-drawable)
  ((root collide-shape-moving  :override)
   )
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-heart-mar heart-mar heart-mar-lod0-jg heart-mar-idle-ja
              ((heart-mar-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              :origin-joint-index 3
              )

(defstate idle (heart-mar)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('frame)
                      (let ((v1-3 (ja-group)))
                        (when (not (and v1-3 (= v1-3 (-> self draw art-group data 3))))
                          (ja :group! (-> self draw art-group data 3) :num! min)
                          (set! (-> self draw bounds w) 81920.0)
                          (setup-masks (-> self draw) 2 0)
                          )
                        )
                      (if (and (< (ja-aframe-num 0) 775.0) (>= (the-as float (-> event param 0)) 775.0))
                          (setup-masks (-> self draw) 0 4)
                          )
                      (if (>= (the-as float (-> event param 0)) 834.0)
                          (deactivate self)
                          )
                      (set-tombboss-gem-light! (lerp-scale 1.0 0.0 (ja-aframe-num 0) 760.0 800.0))
                      (ja :num-func num-func-identity :frame-num (ja-aframe (the-as float (-> event param 0)) 0))
                      (let ((v0-9 (logclear (-> self mask) (process-mask sleep-code))))
                        (set! (-> self mask) v0-9)
                        v0-9
                        )
                      )
                     (('grab-done)
                      (the-as process-mask (deactivate self))
                      )
                     )
            )
    )
  :code (behavior ()
    (until #f
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      (ja-post)
      )
    #f
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior heart-mar-init-by-other heart-mar ((arg0 vector))
  (set! (-> self root) (the-as collide-shape-moving (new 'process 'trsqv)))
  (set! (-> self root trans quad) (-> arg0 quad))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-heart-mar" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (setup-masks (-> self draw) 0 2)
  (quaternion-set! (-> self root quat) 0.0 1.0 0.0 0.0)
  (set! (-> self root pause-adjust-distance) 245760.0)
  (ja-post)
  (add-connection *part-engine* self 3 self 3253 (new 'static 'vector :w 819200.0))
  (set! (-> self draw light-index) (the-as uint 17))
  (set-tombboss-gem-light! 1.0)
  (go-virtual idle)
  (none)
  )

(deftype tomb-boss-pillar (process-drawable)
  ((root            collide-shape-moving      :override)
   (explode-part    sparticle-launch-control  :offset-assert 200)
   (segs-shot       int32                     :offset-assert 204)
   (last-pillar-hit time-frame                :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 23
  :size-assert         #xd8
  :flag-assert         #x17006000d8
  (:methods
    (idle () _type_ :state 20)
    (break-it () _type_ :state 21)
    (broken () _type_ :state 22)
    )
  )


(defskelgroup skel-tomb-boss-pillar tomb-boss-pillar tomb-boss-pillar-lod0-jg tomb-boss-pillar-idle-ja
              ((tomb-boss-pillar-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 9)
              )

(defbehavior damage-pillar tomb-boss-pillar ()
  (case (-> self segs-shot)
    ((1)
     (setup-masks (-> self draw) 0 2)
     )
    ((2)
     (setup-masks (-> self draw) 0 6)
     )
    ((3)
     (setup-masks (-> self draw) 0 14)
     )
    ((4)
     (setup-masks (-> self draw) 0 30)
     )
    ((5)
     (setup-masks (-> self draw) 0 62)
     )
    ((6)
     (setup-masks (-> self draw) 0 126)
     )
    ((7)
     (setup-masks (-> self draw) 0 254)
     )
    ((8)
     (setup-masks (-> self draw) 0 510)
     )
    ((9)
     (setup-masks (-> self draw) 0 1022)
     )
    ((10)
     (setup-masks (-> self draw) 0 2046)
     )
    ((11)
     (setup-masks (-> self draw) 0 4094)
     )
    ((12)
     (setup-masks (-> self draw) 0 8190)
     )
    ((13)
     (setup-masks (-> self draw) 0 #x3ffe)
     )
    ((14)
     (setup-masks (-> self draw) 0 #x7ffe)
     )
    ((15)
     (setup-masks (-> self draw) 0 #xfffe)
     )
    ((16)
     (setup-masks (-> self draw) 0 #x1fffe)
     )
    )
  (none)
  )

(defbehavior tomb-boss-pillar-shrink-collision tomb-boss-pillar ()
  (let ((v1-1 (the-as collide-shape-prim-group (-> self root root-prim))))
    (let ((a0-1 (-> v1-1 child 0)))
      (set! (-> a0-1 prim-core collide-as) (collide-spec))
      (set! (-> a0-1 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-3 (-> v1-1 child 1)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-3 prim-core collide-with) (collide-spec jak bot player-list))
      )
    )
  (none)
  )

(defstate broken (tomb-boss-pillar)
  :virtual #t
  :enter (behavior ()
    (set! (-> self draw bounds w) 36864.0)
    (ja :group! (-> self draw art-group data 4)
        :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
        )
    (tomb-boss-pillar-shrink-collision)
    (ja-post)
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-pillar) sleep-code)
  )

(defstate break-it (tomb-boss-pillar)
  :virtual #t
  :enter (behavior ()
    (set! (-> self draw bounds w) 245760.0)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (if (< (- (current-time) (-> self state-time)) (seconds 1))
        (spawn-with-cspace (-> self explode-part) (-> self node-list data 6))
        )
    (let ((v1-9 (ja-group)))
      (cond
        ((and v1-9 (= v1-9 (-> self draw art-group data 4)))
         (ja :num! (seek!))
         (if (ja-done? 0)
             (go-virtual broken)
             )
         )
        (else
          (ja :group! (-> self draw art-group data 4) :num! min)
          (activate! *camera-smush-control* 819.2 37 210 1.0 0.995 (-> self clock))
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-pillar) sleep-code)
  :post (the-as (function none :behavior tomb-boss-pillar) ja-post)
  )

(defstate idle (tomb-boss-pillar)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (let ((gp-0 proc))
         (when (if (type? gp-0 widow-shot)
                   gp-0
                   )
           (+! (-> self segs-shot) 1)
           (damage-pillar)
           (cond
             ((>= (-> self segs-shot) 16)
              (go-virtual break-it)
              )
             ((>= (- (current-time) (-> self last-pillar-hit)) (seconds 2))
              (process-spawn
                part-tracker
                :init part-tracker-init
                (-> *part-group-id-table* 718)
                0
                #f
                #f
                self
                0
                :to *entity-pool*
                )
              (set! (-> self last-pillar-hit) (current-time))
              (sound-play "pillar-hit" :position (-> self root trans))
              )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (let ((v1-2 (-> self entity extra perm)))
      (logior! (-> v1-2 status) (entity-perm-status bit-5))
      (set! (-> v1-2 user-object 1) (-> self segs-shot))
      )
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-pillar) sleep-code)
  )

(defmethod deactivate tomb-boss-pillar ((obj tomb-boss-pillar))
  (if (nonzero? (-> obj explode-part))
      (kill-and-free-particles (-> obj explode-part))
      )
  ((the-as (function process-drawable none) (find-parent-method tomb-boss-pillar 10)) obj)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs tomb-boss-pillar.
(defmethod relocate tomb-boss-pillar ((obj tomb-boss-pillar) (arg0 int))
  (if (nonzero? (-> obj explode-part))
      (&+! (-> obj explode-part) arg0)
      )
  (the-as
    tomb-boss-pillar
    ((the-as (function process-drawable int process-drawable) (find-parent-method tomb-boss-pillar 7)) obj arg0)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-boss-pillar ((obj tomb-boss-pillar) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (set! (-> s4-0 nav-radius) 8192.0)
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-boss-pillar" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (transform-post)
  (set! (-> obj explode-part) (create-launch-control (-> *part-group-id-table* 719) obj))
  (set! (-> obj last-pillar-hit) 0)
  (let ((v1-23 (-> obj entity extra perm)))
    (logior! (-> v1-23 status) (entity-perm-status bit-5))
    (set! (-> obj segs-shot) (the-as int (-> v1-23 user-object 1)))
    )
  (damage-pillar)
  (if (>= (-> obj segs-shot) 16)
      (go (method-of-object obj broken))
      (go (method-of-object obj idle))
      )
  (none)
  )

(deftype tomb-boss-firepot (process-drawable)
  ((root collide-shape-moving  :override)
   )
  :heap-base #x50
  :method-count-assert 23
  :size-assert         #xc8
  :flag-assert         #x17005000c8
  (:methods
    (idle () _type_ :state 20)
    (break-it () _type_ :state 21)
    (broken () _type_ :state 22)
    )
  )


(defskelgroup skel-tomb-boss-firepot tomb-boss-firepot tomb-boss-firepot-lod0-jg tomb-boss-firepot-idle-ja
              ((tomb-boss-firepot-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 9)
              )

(defbehavior tomb-boss-firepot-shrink-collision tomb-boss-firepot ()
  (let ((v1-1 (the-as collide-shape-prim-group (-> self root root-prim))))
    (let ((a0-1 (-> v1-1 child 0)))
      (set! (-> a0-1 prim-core collide-as) (collide-spec))
      (set! (-> a0-1 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-3 (-> v1-1 child 1)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-3 prim-core collide-with) (collide-spec jak bot player-list))
      )
    )
  (none)
  )

(defstate broken (tomb-boss-firepot)
  :virtual #t
  :enter (behavior ()
    (set! (-> self draw bounds w) 36864.0)
    (ja :group! (-> self draw art-group data 4)
        :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
        )
    (tomb-boss-firepot-shrink-collision)
    (ja-post)
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-firepot) sleep-code)
  )

(defstate break-it (tomb-boss-firepot)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (tomb-boss-firepot-shrink-collision)
    (set! (-> self draw bounds w) 245760.0)
    (ja :group! (-> self draw art-group data 4) :num! min)
    (let ((gp-1 (get-process *default-dead-pool* part-tracker #x4000)))
      (when gp-1
        (let ((t9-4 (method-of-type part-tracker activate)))
          (t9-4
            (the-as part-tracker gp-1)
            *entity-pool*
            (symbol->string (-> part-tracker symbol))
            (the-as pointer #x70004000)
            )
          )
        (let ((t9-5 run-function-in-process)
              (a0-4 gp-1)
              (a1-4 part-tracker-init)
              (a2-6 (-> *part-group-id-table* 720))
              (a3-1 0)
              (t0-0 #f)
              (t1-0 #f)
              (t2-0 #f)
              (t3-0 *launch-matrix*)
              )
          (set! (-> t3-0 trans quad) (-> self root trans quad))
          ((the-as (function object object object object object object object object none) t9-5)
           a0-4
           a1-4
           a2-6
           a3-1
           t0-0
           t1-0
           t2-0
           t3-0
           )
          )
        (-> gp-1 ppointer)
        )
      )
    (none)
    )
  :trans (behavior ()
    (ja :num! (seek!))
    (if (ja-done? 0)
        (go-virtual broken)
        )
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-firepot) sleep-code)
  :post (the-as (function none :behavior tomb-boss-firepot) ja-post)
  )

(defstate idle (tomb-boss-firepot)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (let ((gp-0 proc))
         (when (if (type? gp-0 widow-shot)
                   (the-as widow-shot gp-0)
                   )
           (let ((v1-2 (the-as object (-> event param 1)))
                 (gp-1 (new 'stack-no-clear 'vector))
                 )
             (cond
               ((logtest? (attack-info-mask attacker-velocity) (-> (the-as attack-info v1-2) mask))
                (set! (-> gp-1 quad) (-> (the-as attack-info v1-2) attacker-velocity quad))
                )
               (else
                 (let* ((a3-1 (the-as object (-> event param 0)))
                        (a1-4 (-> (the-as touching-shapes-entry a3-1) head))
                        )
                   (get-intersect-point gp-1 a1-4 (-> self root) (the-as touching-shapes-entry a3-1))
                   )
                 (vector-! gp-1 (-> self root trans) gp-1)
                 )
               )
             (let ((s5-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> self root quat))))
               (vector-flatten! gp-1 gp-1 (-> s5-1 vector 1))
               (when (!= (vector-normalize-ret-len! gp-1 1.0) 0.0)
                 (set! (-> s5-1 vector 2 quad) (-> gp-1 quad))
                 (vector-cross! (the-as vector (-> s5-1 vector)) (-> s5-1 vector 1) (-> s5-1 vector 2))
                 (matrix->quaternion (-> self root quat) s5-1)
                 )
               )
             )
           (go-virtual break-it)
           )
         )
       )
      )
    )
  :enter (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root root-prim)) child 1)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (none)
    )
  :code (the-as (function none :behavior tomb-boss-firepot) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-boss-firepot ((obj tomb-boss-firepot) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 5)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 5)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 5)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 16384.0)
      )
    (set! (-> s4-0 nav-radius) 8192.0)
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> obj root) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-boss-firepot" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj root pause-adjust-distance) 245760.0)
  (transform-post)
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object obj broken))
      (go (method-of-object obj idle))
      )
  (none)
  )

(defmethod draw hud-widow ((obj hud-widow))
  (set-hud-piece-position! (-> obj sprites 1) (the int (+ 462.0 (* 130.0 (-> obj offset)))) 350)
  (set-as-offset-from! (the-as hud-sprite (-> obj sprites)) (the-as vector4w (-> obj sprites 1)) -32 0)
  (set-as-offset-from! (-> obj sprites 5) (the-as vector4w (-> obj sprites 1)) -62 14)
  (set-as-offset-from! (-> obj sprites 6) (the-as vector4w (-> obj sprites 1)) -32 14)
  (let ((s5-0 (-> obj values 0 current))
        (f30-0 (* 0.01 (the float (-> obj values 1 current))))
        )
    (set-as-offset-from! (-> obj sprites 4) (the-as vector4w (-> obj sprites 1)) -92 15)
    (cond
      ((= s5-0 1)
       (set! (-> obj sprites 4 color x) 0)
       (set! (-> obj sprites 4 color y) 255)
       (set! f30-0 (+ 2.0 f30-0))
       )
      ((= s5-0 2)
       (set! (-> obj sprites 4 color y) 255)
       (set! (-> obj sprites 4 color x) 255)
       (set! f30-0 (+ 1.0 f30-0))
       )
      ((= s5-0 3)
       (set! (-> obj sprites 4 color x) 255)
       (set! (-> obj sprites 4 color y) 0)
       0
       )
      (else
        (set! f30-0 0.0)
        )
      )
    (set! (-> obj sprites 4 scale-x) (* -7.25 f30-0))
    )
  (let ((f30-1 (* 0.01 (the float (-> obj values 2 current)))))
    (set-as-offset-from! (-> obj sprites 3) (the-as vector4w (-> obj sprites 1)) -84 4)
    (cond
      ((< f30-1 0.5)
       (set! (-> obj sprites 3 color x) 255)
       (set! (-> obj sprites 3 color y) (the int (lerp 0.0 255.0 (* 2.0 f30-1))))
       )
      (else
        (set! (-> obj sprites 3 color x) (the int (lerp 255.0 0.0 (* 2.0 (+ -0.5 f30-1)))))
        (set! (-> obj sprites 3 color y) 255)
        )
      )
    (set! (-> obj sprites 3 scale-x) (* -18.25 f30-1))
    )
  ((method-of-type hud draw) obj)
  0
  (none)
  )

(defmethod init-callback hud-widow ((obj hud-widow))
  (set! (-> obj gui-id)
        (add-process *gui-control* obj (gui-channel hud-middle-right) (gui-action hidden) (-> obj name) 81920.0 0)
        )
  (set! (-> obj values 0 target) 1)
  (set! (-> obj values 1 target) 100)
  (logior! (-> obj flags) (hud-flags show))
  (set! (-> obj sprites 0 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3b :page #x67a)))
  (set! (-> obj sprites 0 flags) (the-as uint 4))
  (set! (-> obj sprites 1 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3c :page #x67a)))
  (set! (-> obj sprites 1 flags) (the-as uint 4))
  (set! (-> obj sprites 5 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3d :page #x67a)))
  (set! (-> obj sprites 5 scale-x) 0.5)
  (set! (-> obj sprites 5 flags) (the-as uint 4))
  (set! (-> obj sprites 6 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x3d :page #x67a)))
  (set! (-> obj sprites 6 scale-x) 0.5)
  (set! (-> obj sprites 6 flags) (the-as uint 4))
  (set! (-> obj sprites 4 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x41 :page #x67a)))
  (set! (-> obj sprites 4 scale-y) 3.25)
  (set! (-> obj sprites 4 color z) 0)
  (set! (-> obj sprites 4 flags) (the-as uint 4))
  (set! (-> obj sprites 3 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x41 :page #x67a)))
  (set! (-> obj sprites 3 scale-y) 1.5)
  (set! (-> obj sprites 3 color z) 0)
  (set! (-> obj sprites 3 flags) (the-as uint 4))
  0
  (none)
  )
