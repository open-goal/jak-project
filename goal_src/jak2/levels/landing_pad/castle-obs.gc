;;-*-Lisp-*-
(in-package goal)

;; name: castle-obs.gc
;; name in dgo: castle-obs
;; dgos: CAS

;; og:update-with-merge:substr

;; DECOMP BEGINS

(define *cas-conveyor-room-id* 0)

(deftype cas-conveyor (conveyor)
  ((actor-group        (pointer actor-group)  :offset-assert 256)
   (actor-group-count  int32                  :offset-assert 260)
   (texture-anim-index uint32                 :offset-assert 264)
   (my-id              int32                  :offset-assert 268)
   (sound-id           uint32                 :offset-assert 272)
   (target-speed       float                  :offset-assert 276)
   )
  :heap-base #xa0
  :method-count-assert 28
  :size-assert         #x118
  :flag-assert         #x1c00a00118
  )


(defmethod init! cas-conveyor ((obj cas-conveyor))
  "Initializes defaults for things like the `speed` and `belt-radius`"
  (let ((t9-0 (method-of-type conveyor init!)))
    (t9-0 obj)
    )
  (set! (-> obj speed) (res-lump-float (-> obj entity) 'speed :default 30720.0))
  (set! (-> obj belt-radius) (res-lump-float (-> obj entity) 'center-radius :default 15974.4))
  (set! (-> obj texture-anim-index) (res-lump-value (-> obj entity) 'index uint :time -1000000000.0))
  (set! (-> obj my-id)
        (res-lump-value (-> obj entity) 'extra-id int :default (the-as uint128 -1) :time -1000000000.0)
        )
  (set! (-> obj pull-y-threshold) 409.6)
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-conveyor ((obj cas-conveyor) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (reset-root! obj)
  (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 (the-as entity #f) #f))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (< (-> obj path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (init! obj)
  (set! (-> obj sound-id) (the-as uint (new-sound-id)))
  (set! (-> obj target-speed) (-> obj speed))
  (conveyor-method-21 obj)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-16 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-16 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-16))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (go (method-of-object obj idle))
  (none)
  )

(defmethod deactivate cas-conveyor ((obj cas-conveyor))
  (sound-stop (the-as sound-id (-> obj sound-id)))
  ((the-as (function conveyor none) (find-parent-method cas-conveyor 10)) obj)
  (none)
  )

;; WARN: Return type mismatch sound-id vs none.
(defbehavior sound-update cas-conveyor ()
  (when (and *target*
             (and (>= 327680.0 (vector-vector-distance (-> self collide-bounds) (-> *target* control trans)))
                  (zero? (logand (focus-status teleporting) (-> *target* focus-status)))
                  )
             )
    (let ((f0-2 (* 0.000032552085 (+ -30720.0 (fabs (-> self speed))))))
      (sound-play-by-name
        (static-sound-name "castle-conveyor")
        (the-as sound-id (-> self sound-id))
        1024
        (the int (* 1524.0 f0-2))
        0
        (sound-group sfx)
        (-> self collide-bounds)
        )
      )
    )
  (none)
  )

(defstate idle (cas-conveyor)
  :virtual #t
  :trans sound-update
  :code (the-as (function none :behavior cas-conveyor) sleep-code)
  :post (behavior ()
    (when (or (= (-> self my-id) -1) (= (-> self my-id) (/ *cas-conveyor-room-id* 8)))
      (cond
        ((zero? (-> self actor-group-count))
         (set! (-> self speed) (seek-with-smooth (-> self speed) (-> self target-speed) 61440.0 0.1 409.6))
         )
        (else
          (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-1 from) (process->ppointer self))
            (set! (-> a1-1 num-params) 1)
            (set! (-> a1-1 message) 'get-speed)
            (set! (-> a1-1 param 0) (the-as uint #f))
            (let ((t9-1 send-event-function)
                  (v1-13 (-> self actor-group 0 data 0 actor))
                  )
              (set! (-> self speed) (the-as float (t9-1
                                                    (if v1-13
                                                        (-> v1-13 extra process)
                                                        )
                                                    a1-1
                                                    )
                                            )
                    )
              )
            )
          )
        )
      (set-conveyor-speed! (the-as int (-> self texture-anim-index)) (-> self speed))
      )
    (let ((t9-3 (-> (method-of-type conveyor idle) post)))
      (if t9-3
          ((the-as (function none) t9-3))
          )
      )
    (none)
    )
  )

(deftype cas-conveyor-switch (process-focusable)
  ((actor-group        (pointer actor-group)         :offset-assert 204)
   (actor-group-count  int32                         :offset-assert 208)
   (incoming-attack-id uint32                        :offset-assert 212)
   (quat0              quaternion            :inline :offset-assert 224)
   (quat180            quaternion            :inline :offset-assert 240)
   (red-pos            vector                :inline :offset-assert 256)
   (blue-pos           vector                :inline :offset-assert 272)
   (track-flag         symbol                        :offset-assert 288)
   (lightning-timer    time-frame                    :offset-assert 296)
   (speed              float                         :offset-assert 304)
   (target-speed       float                         :offset-assert 308)
   )
  :heap-base #xc0
  :method-count-assert 28
  :size-assert         #x138
  :flag-assert         #x1c00c00138
  (:methods
    (idle () _type_ :state 27)
    )
  )


(set! (-> *lightning-spec-id-table* 27) (new 'static 'lightning-spec
                                          :name "lightning-cas-switch"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                                          :reduction 0.42
                                          :num-points 6
                                          :box-size 8192.0
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 1638.4
                                          :duration 30.0
                                          :sound #f
                                          )
      )

(defskelgroup skel-cas-conveyor-switch cas-conveyor-switch cas-conveyor-switch-lod0-jg cas-conveyor-switch-idle-ja
              ((cas-conveyor-switch-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0.7 0 3.5)
              :origin-joint-index 3
              )

(defstate idle (cas-conveyor-switch)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (let ((v1-1 (the-as object (-> event param 1))))
         (when (!= (-> (the-as attack-info v1-1) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-1) id))
           (when (and (-> self track-flag) (= (-> self speed) (-> self target-speed)))
             (set! (-> self target-speed) (- (-> self target-speed)))
             (sound-play "cas-shot-switch")
             )
           )
         )
       )
      (('track)
       (-> self track-flag)
       )
      (('get-speed)
       (-> self speed)
       )
      )
    )
  :trans (behavior ()
    (let ((f30-0 (-> self speed)))
      (set! (-> self speed) (seek-with-smooth (-> self speed) (-> self target-speed) 61440.0 0.1 409.6))
      (cond
        ((< f30-0 0.0)
         (quaternion-smooth-seek! (-> self root-override quat) (-> self root-override quat) (-> self quat180) 0.1)
         (let ((t9-2 sp-launch-particles-var)
               (a0-2 *sp-particle-system-2d*)
               (a1-2 (-> *part-id-table* 5119))
               (a2-2 *launch-matrix*)
               )
           (set! (-> a2-2 trans quad) (-> self blue-pos quad))
           (t9-2 a0-2 a1-2 a2-2 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
           )
         )
        (else
          (quaternion-smooth-seek! (-> self root-override quat) (-> self root-override quat) (-> self quat0) 0.1)
          (let ((t9-4 sp-launch-particles-var)
                (a0-4 *sp-particle-system-2d*)
                (a1-4 (-> *part-id-table* 5120))
                (a2-4 *launch-matrix*)
                )
            (set! (-> a2-4 trans quad) (-> self red-pos quad))
            (t9-4 a0-4 a1-4 a2-4 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
            )
          )
        )
      )
    (cond
      ((or (zero? (-> self actor-group-count))
           (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status subtask-complete)))
           )
       (set! (-> self track-flag) #t)
       )
      (else
        (let ((gp-0 0))
          (dotimes (s5-0 (length (-> self actor-group 0)))
            (let ((v1-16 (-> self actor-group 0 data s5-0))
                  (a1-5 (new 'stack-no-clear 'event-message-block))
                  )
              (set! (-> a1-5 from) (process->ppointer self))
              (set! (-> a1-5 num-params) 0)
              (set! (-> a1-5 message) 'stopped?)
              (let ((t9-5 send-event-function)
                    (v1-17 (-> v1-16 actor))
                    )
                (if (not (t9-5
                           (if v1-17
                               (-> v1-17 extra process)
                               )
                           a1-5
                           )
                         )
                    (+! gp-0 1)
                    )
                )
              )
            )
          (cond
            ((zero? gp-0)
             (set-castle-electricity-scale! 0.0)
             (process-entity-status! self (entity-perm-status subtask-complete) #t)
             )
            (else
              (set-castle-electricity-scale! 1.0)
              )
            )
          (set! (-> self track-flag) (zero? gp-0))
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior cas-conveyor-switch) sleep-code)
  :post (behavior ()
    (local-vars (sv-608 symbol) (sv-624 symbol) (sv-640 (function vector cspace vector)) (sv-656 vector))
    (when (and (logtest? (actor-option user17) (-> self fact options))
               (not (-> self track-flag))
               (< (-> self lightning-timer) (-> self clock frame-counter))
               )
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 quad) (-> *y-vector* quad))
        (let ((gp-0 (new 'stack-no-clear 'collide-query)))
          (vector-rotate-x! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 5.0)))
          (vector-rotate-y! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 360.0)))
          (set! (-> gp-0 start-pos quad) (-> self root-override trans quad))
          (vector-normalize-copy! (-> gp-0 move-dist) s5-0 40960.0)
          (let ((v1-11 gp-0))
            (set! (-> v1-11 radius) 409.6)
            (set! (-> v1-11 collide-with) (collide-spec backgnd enemy obstacle))
            (set! (-> v1-11 ignore-process0) self)
            (set! (-> v1-11 ignore-process1) #f)
            (set! (-> v1-11 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
            (set! (-> v1-11 action-mask) (collide-action solid))
            )
          (let ((f0-5 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
            (when (< 0.0 f0-5)
              (let ((s5-2 (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 start-pos) (-> gp-0 move-dist) f0-5))
                    (gp-1 45)
                    (s4-2 (get-process *default-dead-pool* lightning-tracker #x4000))
                    )
                (when s4-2
                  (let ((t9-7 (method-of-type lightning-tracker activate)))
                    (t9-7
                      (the-as lightning-tracker s4-2)
                      *entity-pool*
                      (symbol->string (-> lightning-tracker symbol))
                      (the-as pointer #x70004000)
                      )
                    )
                  (let ((s3-2 run-function-in-process)
                        (s2-2 s4-2)
                        (s1-0 lightning-tracker-init)
                        (s0-0 (-> *lightning-spec-id-table* 27))
                        )
                    (set! sv-608 (the-as symbol #f))
                    (set! sv-624 (the-as symbol #f))
                    (set! sv-640 vector<-cspace!)
                    (set! sv-656 (new 'stack-no-clear 'vector))
                    (let* ((a1-8 (-> self node-list data (+ (rand-vu-int-count 3) 4)))
                           (t2-0 (sv-640 sv-656 a1-8))
                           )
                      ((the-as (function object object object object object object object object none) s3-2)
                       s2-2
                       s1-0
                       s0-0
                       gp-1
                       sv-608
                       sv-624
                       t2-0
                       s5-2
                       )
                      )
                    )
                  (-> s4-2 ppointer)
                  )
                )
              (set! (-> self lightning-timer)
                    (+ (-> self clock frame-counter) (the int (* 300.0 (rand-vu-float-range 0.04 0.1))))
                    )
              )
            )
          )
        )
      )
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-conveyor-switch ((obj cas-conveyor-switch) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 1228.8 0.0 14336.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-cas-conveyor-switch" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> obj mask) (logior (process-mask enemy) (-> obj mask)))
  (set! (-> obj fact)
        (new 'process 'fact-info obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 (the-as entity #f) #f))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (if (!= (-> obj path curve num-cverts) 2)
      (go process-drawable-art-error "bad path")
      )
  (get-point-in-path! (-> obj path) (-> obj red-pos) 0.0 'exact)
  (get-point-in-path! (-> obj path) (-> obj blue-pos) 1.0 'exact)
  (set! (-> obj lightning-timer) 0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-27 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-27 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-27))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> obj quat0 quad) (-> obj root-override quat quad))
  (quaternion-rotate-y! (-> obj quat180) (-> obj quat0) 32768.0)
  (set! (-> obj speed) (res-lump-float (-> obj entity) 'speed :default 30720.0))
  (set! (-> obj target-speed) (-> obj speed))
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-electric-fence (process-focusable)
  ((next-spawn-time time-frame  :offset-assert 208)
   (stop            symbol      :offset-assert 216)
   )
  :heap-base #x60
  :method-count-assert 29
  :size-assert         #xdc
  :flag-assert         #x1d006000dc
  (:methods
    (idle () _type_ :state 27)
    (die () _type_ :state 28)
    )
  )


(defskelgroup skel-cas-electric-fence cas-electric-fence cas-electric-fence-lod0-jg cas-electric-fence-idle-ja
              ((cas-electric-fence-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 2)
              )

(defskelgroup skel-cas-electric-fence-explode cas-electric-fence cas-electric-fence-explode-lod0-jg cas-electric-fence-explode-idle-ja
              ((cas-electric-fence-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4.2)
              )

(define *cas-electric-fence-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      )
    :collide-spec #x1
    :art-level #f
    )
  )

(defstate die (cas-electric-fence)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root-override root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cas-electric-fence-explode" (the-as (pointer uint32) #f))
        5
        gp-0
        *cas-electric-fence-exploder-params*
        :to self
        )
      )
    (sound-play "lightning-node")
    (suspend)
    (logior! (-> self entity extra perm status) (entity-perm-status dead))
    (let ((gp-2 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-2) (seconds 4))
        (suspend)
        )
      )
    (cleanup-for-death self)
    (none)
    )
  )

(defstate idle (cas-electric-fence)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('touched)
                      #f
                      )
                     (('attack)
                      #f
                      )
                     (('track)
                      #t
                      )
                     (('stop)
                      (let ((v0-0 #t))
                        (set! (-> self stop) v0-0)
                        v0-0
                        )
                      )
                     (('stopped?)
                      (-> self stop)
                      )
                     )
            )
    )
  :code (the-as (function none :behavior cas-electric-fence) sleep-code)
  :post (behavior ()
    (when (not (-> self stop))
      (when (< (-> self next-spawn-time) (-> self clock frame-counter))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (set! (-> s5-0 quad) (-> *y-vector* quad))
          (let ((gp-0 (new 'stack-no-clear 'collide-query)))
            (vector-rotate-x! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 140.0)))
            (vector-rotate-y! s5-0 s5-0 (* 182.04445 (rand-vu-float-range 0.0 360.0)))
            (set! (-> gp-0 start-pos quad) (-> self root-override trans quad))
            (set! (-> gp-0 start-pos y) (+ 15400.96 (-> gp-0 start-pos y)))
            (vector-normalize-copy! (-> gp-0 move-dist) s5-0 40960.0)
            (let ((v1-9 gp-0))
              (set! (-> v1-9 radius) 409.6)
              (set! (-> v1-9 collide-with) (collide-spec backgnd enemy obstacle))
              (set! (-> v1-9 ignore-process0) self)
              (set! (-> v1-9 ignore-process1) #f)
              (set! (-> v1-9 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-9 action-mask) (collide-action solid))
              )
            (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
              (when (< 0.0 f0-7)
                (let ((s5-2 (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 start-pos) (-> gp-0 move-dist) f0-7)))
                  (let ((s4-2 120))
                    (process-spawn
                      lightning-tracker
                      :init lightning-tracker-init
                      (new 'static 'lightning-spec
                        :name #f
                        :flags (lightning-spec-flags lsf0)
                        :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                        :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                        :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                        :fade-start-factor 0.2
                        :texture (new 'static 'texture-id :index #x83 :page #xc)
                        :reduction 0.42
                        :num-points 16
                        :box-size 16384.0
                        :merge-factor 0.5
                        :merge-count 2
                        :radius 2048.0
                        :duration 30.0
                        :sound (static-sound-spec "shock" :fo-min 10 :fo-max 40)
                        )
                      s4-2
                      #f
                      #f
                      (-> gp-0 start-pos)
                      s5-2
                      :to *entity-pool*
                      )
                    (let ((v1-22 (get-field-spec-by-id (-> *part-id-table* 166) (sp-field-id spt-timer))))
                      (if v1-22
                          (set! (-> v1-22 initial-valuef) (the-as float s4-2))
                          )
                      )
                    )
                  (let ((t9-10 sp-launch-particles-var)
                        (a0-21 *sp-particle-system-2d*)
                        (a1-10 (-> *part-id-table* 166))
                        (a2-8 *launch-matrix*)
                        )
                    (set! (-> a2-8 trans quad) (-> s5-2 quad))
                    (t9-10 a0-21 a1-10 a2-8 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
                    )
                  )
                (set! (-> self next-spawn-time)
                      (+ (-> self clock frame-counter) (the int (* 300.0 (rand-vu-float-range 0.07 0.4))))
                      )
                )
              )
            )
          )
        )
      (let ((gp-2 *target*))
        (when (and gp-2 (zero? (logand (-> gp-2 focus-status) (focus-status disable dead ignore inactive))))
          (let ((s4-3 (get-trans gp-2 0)))
            (when (< (vector-vector-distance s4-3 (-> self root-override trans)) 24576.0)
              (let ((s5-3 (new 'stack-no-clear 'event-message-block)))
                (set! (-> s5-3 from) (process->ppointer self))
                (set! (-> s5-3 num-params) 2)
                (set! (-> s5-3 message) 'attack)
                (set! (-> s5-3 param 0) (the-as uint #f))
                (let ((s3-3 (new 'static 'attack-info :mask (attack-info-mask vector shove-back shove-up control id))))
                  (let* ((v1-38 *game-info*)
                         (a0-29 (+ (-> v1-38 attack-id) 1))
                         )
                    (set! (-> v1-38 attack-id) a0-29)
                    (set! (-> s3-3 id) a0-29)
                    )
                  (set! (-> s3-3 vector quad)
                        (-> (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s4-3 (-> self root-override trans)) 1.0) quad)
                        )
                  (set! (-> s3-3 shove-back) 24576.0)
                  (set! (-> s3-3 shove-up) 12288.0)
                  (set! (-> s3-3 control) (if (logtest? (focus-status board) (-> gp-2 focus-status))
                                              1.0
                                              0.0
                                              )
                        )
                  (set! (-> s5-3 param 1) (the-as uint s3-3))
                  )
                (send-event-function gp-2 s5-3)
                )
              (let ((s5-4 (new 'stack-no-clear 'vector)))
                (set! (-> s5-4 quad) (-> self root-override trans quad))
                (set! (-> s5-4 y) (+ 15400.96 (-> s5-4 y)))
                (process-spawn
                  lightning-tracker
                  :init lightning-tracker-init
                  (-> *lightning-spec-id-table* 1)
                  225
                  #f
                  #f
                  s5-4
                  6
                  :to gp-2
                  )
                )
              )
            )
          )
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-electric-fence ((obj cas-electric-fence) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid deadly))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 6144.0 0.0 8192.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> s4-0 event-self) 'touched)
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-electric-fence" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj next-spawn-time) 0)
  (set! (-> obj stop) #f)
  (ja-channel-set! 1)
  (let ((a0-14 (-> obj skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-button (basebutton)
  ()
  :heap-base #xa0
  :method-count-assert 40
  :size-assert         #x120
  :flag-assert         #x2800a00120
  (:methods
    (cas-button-method-39 (_type_) none 39)
    )
  )


(defskelgroup skel-cas-button cas-button cas-button-lod0-jg cas-button-idle-ja
              ((cas-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2.25)
              )

(defmethod basebutton-method-34 cas-button ((obj cas-button))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 9216.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod prepare-trigger-event! cas-button ((obj cas-button))
  "Sets `event-going-down` to `'trigger`"
  (set! (-> obj event-down) 'shutdown)
  0
  (none)
  )

(defstate up-idle (cas-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (let ((v1-1 (the-as attack-info (-> event param 1))))
         (case (-> v1-1 mode)
           (('flop)
            (when (or (not (or (= (-> v1-1 mode) 'spin) (= (-> v1-1 mode) 'punch)))
                      (logtest? (-> self button-status) (button-status button-status-3))
                      )
              (send-event! self (-> self event-going-down))
              (sound-play "big-red-button")
              (go-virtual going-down)
              )
            )
           )
         )
       )
      )
    )
  )

(defmethod basebutton-method-33 cas-button ((obj cas-button))
  "TODO - joint stuff"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> obj button-status) (button-status pressed))
     (let ((s5-1 (-> obj skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> obj draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 2)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> obj skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> obj draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (set! (-> obj anim-speed) 2.0)
  (transform-post)
  (none)
  )

(deftype cas-elevator (elevator)
  ((sound-id uint32  :offset-assert 368)
   )
  :heap-base #x100
  :method-count-assert 50
  :size-assert         #x174
  :flag-assert         #x3201000174
  (:methods
    (cas-elevator-method-49 (_type_) none 49)
    )
  )


(defskelgroup skel-cas-elevator cas-elevator cas-elevator-lod0-jg cas-elevator-up-down-ja
              ((cas-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 9)
              )

(defmethod get-art-group cas-elevator ((obj cas-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-cas-elevator" (the-as (pointer uint32) #f))
  )

;; WARN: Return type mismatch float vs none.
(defmethod cas-elevator-method-49 cas-elevator ((obj cas-elevator))
  (let* ((f0-1 (fmax 0.0 (- (-> obj root-override trans y) (-> obj bottom-top 0))))
         (f0-3 (* 0.001171875 (- f0-1 (* (the float (the int (/ f0-1 30720.0))) 30720.0))))
         (v1-6 (-> obj skel root-channel 0))
         )
    (set! (-> v1-6 num-func) num-func-identity)
    (set! (-> v1-6 frame-num) f0-3)
    )
  (none)
  )

(defmethod move-between-points cas-elevator ((obj cas-elevator) (arg0 vector) (arg1 float) (arg2 float))
  "Move between two points on the elevator's path
@param vec TODO not sure
@param point-a The first point fetched from the elevator's path
@param point-b The second point fetched from the path
@see [[path-control]] and [[elevator]]"
  (let ((s5-0 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) arg1 'interp))
        (a0-3 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) arg2 'interp))
        (v1-3 (-> obj root-override trans))
        )
    (when (and (< (-> a0-3 y) (-> s5-0 y)) (< (-> arg0 y) (+ -8192.0 (-> v1-3 y))))
      (let ((a0-8 (vector-! (new 'stack-no-clear 'vector) arg0 v1-3)))
        (< (sqrtf (+ (* (-> a0-8 x) (-> a0-8 x)) (* (-> a0-8 z) (-> a0-8 z)))) 36864.0)
        )
      )
    )
  )

(defmethod commited-to-ride? cas-elevator ((obj cas-elevator))
  "@returns if the target is considered within the elevator area enough to begin descending/ascending"
  (let* ((s5-0 *target*)
         (a0-2 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (when a0-2
      (let* ((a0-3 (get-trans a0-2 0))
             (v1-2 (vector-! (new 'stack-no-clear 'vector) a0-3 (-> obj root-override trans)))
             )
        (< (sqrtf (+ (* (-> v1-2 x) (-> v1-2 x)) (* (-> v1-2 z) (-> v1-2 z)))) 28672.0)
        )
      )
    )
  )

(defstate waiting (cas-elevator)
  :virtual #t
  :post (behavior ()
    (if (-> self bouncing)
        (cas-elevator-method-49 self)
        )
    (let ((t9-1 (-> (method-of-type elevator waiting) post)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    (none)
    )
  )

(defstate running (cas-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator running) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (sound-play "cas-elevate" :id (the-as sound-id (-> self sound-id)) :position (-> self root-override trans))
    (none)
    )
  :post (behavior ()
    (cas-elevator-method-49 self)
    (let ((t9-1 (-> (method-of-type elevator running) post)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    (when *sound-player-enable*
      (let ((gp-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> gp-0 command) (sound-command set-param))
        (set! (-> gp-0 id) (the-as sound-id (-> self sound-id)))
        (let ((a1-0 (-> self root-override trans)))
          (let ((s5-0 self))
            (when (= a1-0 #t)
              (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root-override)))
                  (set! a1-0 (-> s5-0 root-override trans))
                  (set! a1-0 (the-as vector #f))
                  )
              )
            )
          (sound-trans-convert (the-as vector3w (-> gp-0 params trans)) a1-0)
          )
        (set! (-> gp-0 params mask) (the-as uint 32))
        (-> gp-0 id)
        )
      )
    (none)
    )
  )

(defstate arrived (cas-elevator)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type elevator arrived) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (sound-stop (the-as sound-id (-> self sound-id)))
    (sound-play "cas-elevate-end")
    (none)
    )
  :post (behavior ()
    (if (-> self bouncing)
        (cas-elevator-method-49 self)
        )
    (let ((t9-1 (-> (method-of-type elevator arrived) post)))
      (if t9-1
          ((the-as (function none) t9-1))
          )
      )
    (none)
    )
  )

(defmethod deactivate cas-elevator ((obj cas-elevator))
  (sound-stop (the-as sound-id (-> obj sound-id)))
  ((the-as (function elevator none) (find-parent-method cas-elevator 10)) obj)
  (none)
  )

(defmethod init-plat! cas-elevator ((obj cas-elevator))
  "Does any necessary initial platform setup.
For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (set! (-> obj sound-id) (the-as uint (new-sound-id)))
  (cas-elevator-method-49 obj)
  (none)
  )

(defmethod init-plat-collision! cas-elevator ((obj cas-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle camera-blocker pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 36864.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(deftype cas-rot-bridge (process-drawable)
  ((index      uint32  :offset-assert 200)
   (anim-index uint32  :offset-assert 204)
   (test-index uint32  :offset-assert 208)
   (pos        float   :offset-assert 212)
   (pos-old    float   :offset-assert 216)
   (sound-id   uint32  :offset-assert 220)
   (sound-flag symbol  :offset-assert 224)
   )
  :heap-base #x70
  :method-count-assert 21
  :size-assert         #xe4
  :flag-assert         #x15007000e4
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-cas-rot-bridge cas-rot-bridge cas-rot-bridge-lod0-jg cas-rot-bridge-idle-ja
              ((cas-rot-bridge-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 -8 14)
              :origin-joint-index 3
              )

(defstate idle (cas-rot-bridge)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 number))
    (the-as object (case event-type
                     (('move)
                      (set! (-> self anim-index) (/ (the-as int (-> event param 0)) 8))
                      (set! v0-0 (logclear (-> self mask) (process-mask sleep-code)))
                      (set! (-> self mask) (the-as process-mask v0-0))
                      v0-0
                      )
                     (('get-pos)
                      (set! (-> self test-index) (/ (the-as int (-> event param 0)) 8))
                      (let ((f0-0 (ja-aframe-num 0)))
                        (cond
                          ((zero? (-> self test-index))
                           (if (< f0-0 10.0)
                               (set! f0-0 10.0)
                               )
                           (if (< 40.0 f0-0)
                               (set! f0-0 40.0)
                               )
                           (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
                           )
                          ((= (-> self test-index) 1)
                           (if (< f0-0 50.0)
                               (set! f0-0 50.0)
                               )
                           (if (< 80.0 f0-0)
                               (set! f0-0 80.0)
                               )
                           (set! (-> self pos) (* 0.033333335 (+ -50.0 f0-0)))
                           )
                          ((= (-> self test-index) 2)
                           (if (< f0-0 90.0)
                               (set! f0-0 90.0)
                               )
                           (if (< 120.0 f0-0)
                               (set! f0-0 120.0)
                               )
                           (set! (-> self pos) (* 0.033333335 (+ -90.0 f0-0)))
                           )
                          ((= (-> self test-index) 3)
                           (if (< f0-0 10.0)
                               (set! f0-0 10.0)
                               )
                           (if (< 40.0 f0-0)
                               (set! f0-0 40.0)
                               )
                           (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
                           )
                          )
                        )
                      (-> self pos)
                      )
                     (('reset)
                      (when (nonzero? (-> self anim-index))
                        (ja-no-eval :group! (-> self draw art-group data 3) :num! min)
                        (set! (-> self anim-index) (the-as uint 0))
                        (set! v0-0 (logclear (-> self mask) (process-mask sleep-code)))
                        (set! (-> self mask) (the-as process-mask v0-0))
                        v0-0
                        )
                      )
                     )
            )
    )
  :code (behavior ()
    (until #f
      (logior! (-> self mask) (process-mask sleep-code))
      (suspend)
      (let ((f0-0 (ja-aframe-num 0)))
        (cond
          ((zero? (-> self anim-index))
           (when (or (= f0-0 10.0) (= f0-0 40.0) (= f0-0 50.0))
             (cond
               ((= f0-0 10.0)
                (ja-no-eval :group! (-> self draw art-group data 3)
                            :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                            :frame-num 0.0
                            )
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
               (else
                 (ja-no-eval :group! (-> self draw art-group data 7)
                             :num! (seek! 0.0)
                             :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 7)) frames num-frames) -1))
                             )
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! 0.0))
                   )
                 )
               )
             )
           )
          ((= (-> self anim-index) 1)
           (when (or (= f0-0 40.0) (= f0-0 50.0) (= f0-0 80.0) (= f0-0 90.0))
             (cond
               ((or (= f0-0 40.0) (= f0-0 50.0))
                (ja-no-eval :group! (-> self draw art-group data 4)
                            :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
                            :frame-num 0.0
                            )
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
               (else
                 (ja-no-eval :group! (-> self draw art-group data 8)
                             :num! (seek! 0.0)
                             :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 8)) frames num-frames) -1))
                             )
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! 0.0))
                   )
                 )
               )
             )
           )
          ((= (-> self anim-index) 2)
           (when (or (= f0-0 80.0) (= f0-0 90.0) (= f0-0 120.0))
             (cond
               ((or (= f0-0 80.0) (= f0-0 90.0))
                (ja-no-eval :group! (-> self draw art-group data 5)
                            :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames) -1)))
                            :frame-num 0.0
                            )
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
               (else
                 (ja-no-eval :group! (-> self draw art-group data 9)
                             :num! (seek! 0.0)
                             :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 9)) frames num-frames) -1))
                             )
                 (until (ja-done? 0)
                   (suspend)
                   (ja :num! (seek! 0.0))
                   )
                 )
               )
             )
           )
          ((= (-> self anim-index) 3)
           (cond
             ((= f0-0 10.0)
              (ja-no-eval :group! (-> self draw art-group data 6)
                          :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 6)) frames num-frames) -1)))
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              )
             (else
               (ja-no-eval :group! (-> self draw art-group data 10)
                           :num! (seek! 0.0)
                           :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 10)) frames num-frames) -1))
                           )
               (until (ja-done? 0)
                 (suspend)
                 (ja :num! (seek! 0.0))
                 )
               )
             )
           )
          )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (let ((f0-0 (ja-aframe-num 0)))
      (cond
        ((zero? (-> self anim-index))
         (if (< f0-0 10.0)
             (set! f0-0 10.0)
             )
         (if (< 40.0 f0-0)
             (set! f0-0 40.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
         )
        ((= (-> self anim-index) 1)
         (if (< f0-0 50.0)
             (set! f0-0 50.0)
             )
         (if (< 80.0 f0-0)
             (set! f0-0 80.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -50.0 f0-0)))
         )
        ((= (-> self anim-index) 2)
         (if (< f0-0 90.0)
             (set! f0-0 90.0)
             )
         (if (< 120.0 f0-0)
             (set! f0-0 120.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -90.0 f0-0)))
         )
        ((= (-> self anim-index) 3)
         (if (< f0-0 10.0)
             (set! f0-0 10.0)
             )
         (if (< 40.0 f0-0)
             (set! f0-0 40.0)
             )
         (set! (-> self pos) (* 0.033333335 (+ -10.0 f0-0)))
         )
        )
      )
    (let* ((f0-9 (-> self pos))
           (f1-13 (- f0-9 (-> self pos-old)))
           )
      (set! (-> self pos-old) f0-9)
      (when (!= f1-13 0.0)
        (cond
          ((< 0.0 f1-13)
           (cond
             ((< f0-9 1.0)
              (sound-play
                "track-plat-loop"
                :id (the-as sound-id (-> self sound-id))
                :position (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 5))
                )
              (set! (-> self sound-flag) #t)
              )
             ((-> self sound-flag)
              (sound-play
                "track-plat-stop"
                :position (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 5))
                )
              (sound-stop (the-as sound-id (-> self sound-id)))
              (set! (-> self sound-flag) #f)
              )
             )
           )
          (else
            (cond
              ((< 0.0 f0-9)
               (sound-play
                 "track-plat-loop"
                 :id (the-as sound-id (-> self sound-id))
                 :position (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 5))
                 )
               (set! (-> self sound-flag) #t)
               )
              ((-> self sound-flag)
               (sound-play
                 "track-plat-stop"
                 :position (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 5))
                 )
               (sound-stop (the-as sound-id (-> self sound-id)))
               (set! (-> self sound-flag) #f)
               )
              )
            )
          )
        )
      )
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-rot-bridge ((obj cas-rot-bridge) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 5) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 6))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 5)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 57344.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 18432.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 5120.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set! (-> v1-13 transform-index) 5)
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 18432.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid))
      (set! (-> v1-15 transform-index) 6)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 0.0 5120.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid))
      (set! (-> v1-17 transform-index) 7)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 18432.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-20 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-20 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-20 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-rot-bridge" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (quaternion-rotate-y! (-> obj root quat) (-> obj root quat) 16384.0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! (-> obj index) (res-lump-value (-> obj entity) 'index uint :time -1000000000.0))
  (let ((v1-30 (-> obj index)))
    (cond
      ((zero? v1-30)
       (set! (-> obj root trans x) (+ 5734.4 (-> obj root trans x)))
       (let ((s5-2 (-> obj skel root-channel 0)))
         (joint-control-channel-group! s5-2 (the-as art-joint-anim (-> obj draw art-group data 6)) num-func-identity)
         (set! (-> s5-2 frame-num) 0.0)
         )
       )
      ((= v1-30 1)
       (let ((s5-3 (-> obj skel root-channel 0)))
         (joint-control-channel-group! s5-3 (the-as art-joint-anim (-> obj draw art-group data 3)) num-func-identity)
         (set! (-> s5-3 frame-num) 0.0)
         )
       )
      )
    )
  (set! (-> obj draw light-index) (the-as uint 1))
  (set! (-> obj sound-id) (the-as uint (new-sound-id)))
  (set! (-> obj sound-flag) #f)
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-switch (process-drawable)
  ((actor-group        (pointer actor-group)  :offset-assert 200)
   (actor-group-count  int32                  :offset-assert 204)
   (incoming-attack-id uint32                 :offset-assert 208)
   (anim-index         uint32                 :offset-assert 212)
   (direction          uint32                 :offset-assert 216)
   (pos-old            float                  :offset-assert 220)
   (y-start            float                  :offset-assert 224)
   (y-delta            float                  :offset-assert 228)
   (sound-id           uint32                 :offset-assert 232)
   (sound-flag         symbol                 :offset-assert 236)
   )
  :heap-base #x70
  :method-count-assert 21
  :size-assert         #xf0
  :flag-assert         #x15007000f0
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-cas-switch cas-switch 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 2.7 0 3)
              :origin-joint-index 3
              )

(defstate idle (cas-switch)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('attack)
         (let ((gp-0 (the-as attack-info (-> event param 1))))
           (when (or (= (-> gp-0 mode) 'spin) (= (-> gp-0 mode) 'spin-air))
             (let* ((s5-0 (the-as object (-> event param 0)))
                    (s4-0 (-> (the-as touching-shapes-entry s5-0) head))
                    )
               (while s4-0
                 (let ((a0-2 (get-touched-prim s4-0 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s5-0))))
                   (when (= (-> a0-2 prim-id) 1)
                     (when (!= (-> gp-0 id) (-> self incoming-attack-id))
                       (set! (-> self incoming-attack-id) (-> gp-0 id))
                       (let ((s3-0 (-> self actor-group 0)))
                         (dotimes (s2-0 (-> s3-0 length))
                           (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
                             (set! (-> a1-6 from) (process->ppointer self))
                             (set! (-> a1-6 num-params) 1)
                             (set! (-> a1-6 message) 'move)
                             (set! (-> a1-6 param 0) (* (-> self anim-index) 8))
                             (let ((t9-1 send-event-function)
                                   (v1-20 (-> s3-0 data s2-0 actor))
                                   )
                               (t9-1
                                 (if v1-20
                                     (-> v1-20 extra process)
                                     )
                                 a1-6
                                 )
                               )
                             )
                           )
                         )
                       )
                     )
                   )
                 (set! s4-0 (-> s4-0 next))
                 )
               )
             #f
             )
           )
         )
        )
      )
    )
  :trans (the-as (function none :behavior cas-switch) rider-trans)
  :code (behavior ()
    (until #f
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer self))
        (set! (-> a1-0 num-params) 1)
        (set! (-> a1-0 message) 'get-pos)
        (set! (-> a1-0 param 0) (* (-> self anim-index) 8))
        (let* ((t9-0 send-event-function)
               (v1-8 (-> self actor-group 0 data 0 actor))
               (a0-0 (if v1-8
                         (-> v1-8 extra process)
                         )
                     )
               (f30-0 (the-as float (t9-0 a0-0 a1-0)))
               (f28-0 (- f30-0 (-> self pos-old)))
               )
          (set! (-> self pos-old) f30-0)
          (when (!= f28-0 0.0)
            (set! (-> self root trans y) (+ (-> self y-start) (* f30-0 (-> self y-delta))))
            (if (< (* (-> self y-delta) f28-0) 0.0)
                (quaternion-rotate-y! (-> self root quat) (-> self root quat) 1820.4445)
                (quaternion-rotate-y! (-> self root quat) (-> self root quat) -1820.4445)
                )
            (cond
              ((< 0.0 f28-0)
               (cond
                 ((< f30-0 1.0)
                  (sound-play "cas-valve-loop" :id (the-as sound-id (-> self sound-id)) :position (-> self root trans))
                  (set! (-> self sound-flag) #t)
                  )
                 ((-> self sound-flag)
                  (sound-play "cas-valve-stop")
                  (sound-stop (the-as sound-id (-> self sound-id)))
                  (set! (-> self sound-flag) #f)
                  )
                 )
               )
              (else
                (cond
                  ((< 0.0 f30-0)
                   (sound-play "cas-valve-loop" :id (the-as sound-id (-> self sound-id)) :position (-> self root trans))
                   (set! (-> self sound-flag) #t)
                   )
                  ((-> self sound-flag)
                   (sound-play "cas-valve-stop")
                   (sound-stop (the-as sound-id (-> self sound-id)))
                   (set! (-> self sound-flag) #f)
                   )
                  )
                )
              )
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior cas-switch) rider-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-switch ((obj cas-switch) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid no-standon))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 11059.2 0.0 12288.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 11059.2 0.0 12288.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 1))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid rideable))
      (set! (-> v1-11 transform-index) 3)
      (set-vector! (-> v1-11 local-sphere) 0.0 11059.2 0.0 12288.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-switch" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logclear! (-> obj mask) (process-mask actor-pause))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-22 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-22 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-22))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> obj anim-index) (res-lump-value (-> obj entity) 'index uint :time -1000000000.0))
  (set! (-> obj direction) (res-lump-value (-> obj entity) 'extra-id uint :time -1000000000.0))
  (let ((s5-2 (-> obj root trans))
        (s4-2 (-> obj root trans))
        (t9-10 (method-of-type res-lump get-property-struct))
        (a0-27 (-> obj entity))
        (a1-19 'trans-offset)
        (a2-9 'interp)
        (a3-7 -1000000000.0)
        (t0-6 (new 'stack-no-clear 'vector))
        )
    (set! (-> t0-6 x) 0.0)
    (set! (-> t0-6 y) 0.0)
    (set! (-> t0-6 z) 0.0)
    (set! (-> t0-6 w) 1.0)
    (vector+!
      s5-2
      s4-2
      (the-as vector (t9-10 a0-27 a1-19 a2-9 a3-7 t0-6 (the-as (pointer res-tag) #f) *res-static-buf*))
      )
    )
  (set! (-> obj y-start) (-> obj root trans y))
  (if (zero? (-> obj direction))
      (set! (-> obj y-delta) -12288.0)
      (set! (-> obj y-delta) 12288.0)
      )
  (set! (-> obj sound-id) (the-as uint (new-sound-id)))
  (set! (-> obj sound-flag) #f)
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-trapdoor (process-drawable)
  ((root-override collide-shape  :offset 128)
   )
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (idle () _type_ :state 20)
    (die () _type_ :state 21)
    )
  )


(defskelgroup skel-cas-trapdoor cas-trapdoor cas-trapdoor-lod0-jg cas-trapdoor-idle-ja
              ((cas-trapdoor-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defskelgroup skel-cas-trapdoor-explode cas-trapdoor cas-trapdoor-explode-lod0-jg cas-trapdoor-explode-idle-ja
              ((cas-trapdoor-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *cas-trapdoor-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 20 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(defstate idle (cas-trapdoor)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('attack)
                      (let ((gp-0 (the-as object (-> event param 1))))
                        (when (and (not (task-node-closed? (game-task-node castle-boss-resolution)))
                                   (logtest? (-> (the-as attack-info gp-0) penetrate-using) (penetrate flop))
                                   )
                          (go-virtual die)
                          #f
                          )
                        )
                      )
                     )
            )
    )
  :code (the-as (function none :behavior cas-trapdoor) sleep-code)
  )

(defstate die (cas-trapdoor)
  :virtual #t
  :enter (behavior ()
    (let ((v1-1 (-> self root-override root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (sound-play "trapdoor")
    (let ((gp-1 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
      (let* ((s5-1 *target*)
             (a0-3 (if (type? s5-1 process-focusable)
                       s5-1
                       )
                   )
             )
        (when a0-3
          (set! (-> gp-1 fountain-rand-transv-lo quad) (-> (get-trans a0-3 0) quad))
          (set! (-> gp-1 fountain-rand-transv-lo y) (+ -16384.0 (-> gp-1 fountain-rand-transv-lo y)))
          )
        )
      (set! (-> gp-1 fountain-rand-transv-hi x) 24576.0)
      (set! (-> gp-1 fountain-rand-transv-hi y) 81920.0)
      (set! (-> gp-1 fountain-rand-transv-hi z) 12288.0)
      (set! (-> gp-1 fountain-rand-transv-hi w) 32768.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cas-trapdoor-explode" (the-as (pointer uint32) #f))
        5
        gp-1
        *cas-trapdoor-exploder-params*
        :to self
        )
      )
    (none)
    )
  :code (behavior ()
    (sound-play "trapdoor")
    (suspend)
    (ja-channel-set! 0)
    (let ((gp-1 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-1) (seconds 1))
        (suspend)
        )
      )
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  :post (the-as (function none :behavior cas-trapdoor) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-trapdoor ((obj cas-trapdoor) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 0)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (if (not (task-node-closed? (game-task-node castle-boss-resolution)))
      (set! (-> obj root-override penetrated-by) (penetrate flop))
      )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-trapdoor" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((a0-14 (-> obj skel root-channel 0)))
    (set! (-> a0-14 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-14 frame-num) 0.0)
    (joint-control-channel-group! a0-14 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-chain-plat (process-focusable)
  ()
  :heap-base #x50
  :method-count-assert 30
  :size-assert         #xcc
  :flag-assert         #x1e005000cc
  (:methods
    (idle () _type_ :state 27)
    (drop () _type_ :state 28)
    (down () _type_ :state 29)
    )
  )


(defskelgroup skel-cas-chain-plat cas-chain-plat cas-chain-plat-lod0-jg cas-chain-plat-idle-ja
              ((cas-chain-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 3 0 6)
              :origin-joint-index 4
              )

(defstate idle (cas-chain-plat)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (sound-play "cas-shelf-plat")
       (go-virtual drop)
       )
      (('track)
       #t
       )
      )
    )
  :code (the-as (function none :behavior cas-chain-plat) sleep-code)
  :post (the-as (function none :behavior cas-chain-plat) ja-post)
  )

(defstate drop (cas-chain-plat)
  :virtual #t
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual down)
    (none)
    )
  :post (the-as (function none :behavior cas-chain-plat) transform-post)
  )

(defstate down (cas-chain-plat)
  :virtual #t
  :code (the-as (function none :behavior cas-chain-plat) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-chain-plat ((obj cas-chain-plat) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 4)
      (set-vector! (-> v1-2 local-sphere) 0.0 12288.0 0.0 24576.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root-override) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-chain-plat" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj mask) (logior (process-mask enemy) (-> obj mask)))
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-rot-blade (process-drawable)
  ((sync      sync-eased :inline :offset-assert 200)
   (rot       float              :offset-assert 244)
   (attack-id uint32             :offset-assert 248)
   (sound-id  uint32             :offset-assert 252)
   )
  :heap-base #x80
  :method-count-assert 21
  :size-assert         #x100
  :flag-assert         #x1500800100
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-cas-rot-blade cas-rot-blade cas-rot-blade-lod0-jg cas-rot-blade-idle-ja
              ((cas-rot-blade-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              :shadow cas-rot-blade-shadow-mg
              )

(define *cas-rot-blade-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 8192.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

(defun cas-rot-blade-callback ((arg0 cspace) (arg1 transformq))
  (with-pp
    (quaternion-rotate-local-y!
      (-> arg1 quat)
      (-> arg1 quat)
      (* 606.8148 (the float (-> pp clock frame-counter)))
      )
    (cspace<-parented-transformq-joint! arg0 arg1)
    0
    (none)
    )
  )

(defstate idle (cas-rot-blade)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('touched)
         (let* ((s4-0 (the-as object (-> event param 0)))
                (s3-0 (-> (the-as touching-shapes-entry s4-0) head))
                )
           (while s3-0
             (let ((a0-3 (get-touched-prim s3-0 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s4-0))))
               (when (= (-> a0-3 prim-id) 1)
                 (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                   (set! (-> a1-2 from) (process->ppointer self))
                   (set! (-> a1-2 num-params) 2)
                   (set! (-> a1-2 message) 'attack)
                   (set! (-> a1-2 param 0) (-> event param 0))
                   (let ((a0-6 (new 'static 'attack-info :mask (attack-info-mask id))))
                     (let* ((v1-10 *game-info*)
                            (a2-3 (+ (-> v1-10 attack-id) 1))
                            )
                       (set! (-> v1-10 attack-id) a2-3)
                       (set! (-> a0-6 id) a2-3)
                       )
                     (set! (-> a1-2 param 1) (the-as uint a0-6))
                     )
                   (send-event-function proc a1-2)
                   )
                 )
               )
             (set! s3-0 (-> s3-0 next))
             )
           )
         #f
         )
        )
      )
    )
  :trans (behavior ()
    (set! (-> self rot) (+ 1820.4445 (get-scaled-val! (-> self sync) 29127.111 0)))
    (quaternion-vector-angle! (-> self root quat) *y-vector* (-> self rot))
    (sound-play
      "cas-arm-blade"
      :id (the-as sound-id (-> self sound-id))
      :position (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data 4))
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior cas-rot-blade) transform-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-rot-blade ((obj cas-rot-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 61440.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (set! (-> s4-0 event-self) 'touched)
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 3)
      (set-vector! (-> v1-9 local-sphere) 0.0 0.0 0.0 49152.0)
      )
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid deadly))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 0.0 0.0 0.0 14336.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-14 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-14 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-14 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-rot-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj draw light-index) (the-as uint 2))
  (let ((a1-10 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-20 0))
      (if #t
          (set! v1-20 (logior v1-20 1))
          )
      (set! (-> a1-10 sync-type) 'sync-eased)
      (set! (-> a1-10 sync-flags) (the-as sync-flags v1-20))
      )
    (set! (-> a1-10 period) (the-as uint 1800))
    (set! (-> a1-10 entity) arg0)
    (set! (-> a1-10 percent) 0.0)
    (set! (-> a1-10 ease-in) 0.15)
    (set! (-> a1-10 ease-out) 0.15)
    (set! (-> a1-10 pause-in) 0.2)
    (set! (-> a1-10 pause-out) 0.0)
    (initialize! (-> obj sync) a1-10)
    )
  (let ((a0-26 (-> obj node-list data 4)))
    (set! (-> a0-26 param0) cas-rot-blade-callback)
    (set! (-> a0-26 param1) obj)
    )
  (set! (-> obj sound-id) (the-as uint (new-sound-id)))
  (set! (-> obj draw shadow-ctrl) *cas-rot-blade-shadow-control*)
  (go (method-of-object obj idle))
  (none)
  )

(defmethod deactivate cas-rot-blade ((obj cas-rot-blade))
  (sound-stop (the-as sound-id (-> obj sound-id)))
  ((the-as (function process-drawable none) (find-parent-method cas-rot-blade 10)) obj)
  (none)
  )

(deftype cas-flag-a (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-cas-flag-a cas-flag-a cas-flag-a-lod0-jg cas-flag-a-idle-ja
              ((cas-flag-a-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 8.5)
              )

(defstate idle (cas-flag-a)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior cas-flag-a) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-flag-a ((obj cas-flag-a) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-flag-a" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-flag-b (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-cas-flag-b cas-flag-b cas-flag-b-lod0-jg cas-flag-b-idle-ja
              ((cas-flag-b-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -8 0 8.5)
              )

(defstate idle (cas-flag-b)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior cas-flag-b) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-flag-b ((obj cas-flag-b) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-flag-b" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype cas-robot-door (process-drawable)
  ((spawner-actor     symbol                  :offset-assert 200)
   (door-actor        entity-actor          2 :offset-assert 204)
   (spawn-count       int32                   :offset-assert 212)
   (spawn-count-total int32                   :offset-assert 216)
   (spawn-max         int32                   :offset-assert 220)
   (spawn-total       int32                   :offset-assert 224)
   (notice-dist       float                   :offset-assert 228)
   (player-dist       float                   :offset-assert 232)
   (anim-index        int32                   :offset-assert 236)
   (last-guard        handle                  :offset-assert 240)
   (actor-group       (pointer actor-group)   :offset-assert 248)
   (actor-group-count int32                   :offset-assert 252)
   )
  :heap-base #x80
  :method-count-assert 23
  :size-assert         #x100
  :flag-assert         #x1700800100
  (:methods
    (idle () _type_ :state 20)
    (spawning () _type_ :state 21)
    (castle-wait-end () _type_ :state 22)
    )
  )


(defskelgroup skel-cas-robot-door cas-robot-door cas-robot-door-lod0-jg cas-robot-door-idle-ja
              ((cas-robot-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defstate idle (cas-robot-door)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (go-virtual spawning)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.6))
      (let ((a0-1 *target*))
        (if (and a0-1
                 (not (logtest? (-> a0-1 focus-status) (focus-status disable dead)))
                 (< (vector-vector-distance (get-trans a0-1 0) (-> self root trans)) (-> self notice-dist))
                 )
            (go-virtual spawning)
            )
        )
      (set! (-> self state-time) (-> self clock frame-counter))
      )
    (none)
    )
  :code (the-as (function none :behavior cas-robot-door) sleep-code)
  )

(defstate spawning (cas-robot-door)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('roboguard-die)
                      (let ((v0-0 (+ (-> self spawn-count) -1)))
                        (set! (-> self spawn-count) v0-0)
                        v0-0
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (set! (-> self spawn-count) 0)
    (set! (-> self spawn-count-total) 0)
    (set! (-> self player-dist) (-> self notice-dist))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.6))
      (let ((a0-1 *target*))
        (if (and a0-1 (zero? (logand (-> a0-1 focus-status) (focus-status disable dead))))
            (set! (-> self player-dist) (vector-vector-distance (get-trans a0-1 0) (-> self root trans)))
            )
        )
      (set! (-> self state-time) (-> self clock frame-counter))
      )
    (none)
    )
  :code (behavior ()
    (sound-play "robo-hatch-open")
    (ja-no-eval :group! (-> self draw art-group data 2)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-1 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-1) (seconds 0.5))
        (suspend)
        )
      )
    (while (or (= (-> self spawn-total) -1) (< (-> self spawn-count-total) (-> self spawn-total)))
      (when (and (< (-> self player-dist) (+ 81920.0 (-> self notice-dist)))
                 (and (< (-> self spawn-count) (-> self spawn-max))
                      (or (not (handle->process (-> self last-guard)))
                          (not (and (-> (handle->process (-> self last-guard)) next-state)
                                    (= (-> (handle->process (-> self last-guard)) next-state name) ''ambush)
                                    )
                               )
                          )
                      )
                 )
        (let ((gp-2 (new 'stack-no-clear 'enemy-init-by-other-params)))
          (set! (-> gp-2 trans quad) (-> self root trans quad))
          (quaternion-copy! (-> gp-2 quat) *unity-quaternion*)
          (set! (-> gp-2 entity) (the-as entity (-> self spawner-actor)))
          (set! (-> gp-2 directed?) #f)
          (set! (-> gp-2 no-initial-move-to-ground?) #f)
          (let* ((s5-1 (get-process *default-dead-pool* roboguard-level #x4000))
                 (v1-52 (when s5-1
                          (let ((t9-8 (method-of-type process activate)))
                            (t9-8 s5-1 self (symbol->string (-> roboguard-level symbol)) (the-as pointer #x70004000))
                            )
                          (run-now-in-process s5-1 enemy-init-by-other self gp-2)
                          (-> s5-1 ppointer)
                          )
                        )
                 )
            (when v1-52
              (set! (-> self last-guard) (ppointer->handle v1-52))
              (+! (-> self spawn-count) 1)
              (+! (-> self spawn-count-total) 1)
              )
            )
          )
        )
      (let ((gp-3 (-> self clock frame-counter)))
        (until (>= (- (-> self clock frame-counter) gp-3) (the int (* 300.0 (rand-vu-float-range 0.5 1.0))))
          (suspend)
          )
        )
      )
    (while (> (-> self spawn-count) 0)
      (let ((gp-4 (-> self clock frame-counter)))
        (until (>= (- (-> self clock frame-counter) gp-4) (seconds 0.43))
          (suspend)
          )
        )
      )
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (cond
      ((= (-> self anim-index) -1)
       (cond
         ((= (-> self actor-group-count) 1)
          (go-virtual castle-wait-end)
          )
         ((= (-> self actor-group-count) 2)
          (until (process-grab? *target* #f)
            (suspend)
            )
          (let ((a3-4 (res-lump-struct (-> self entity) 'camera-name structure)))
            (if a3-4
                (set-setting! 'entity-name a3-4 0 0)
                )
            )
          (let ((gp-5 (-> self clock frame-counter)))
            (until (>= (- (-> self clock frame-counter) gp-5) (seconds 2))
              (suspend)
              )
            )
          (dotimes (gp-6 (-> self actor-group 1 length))
            (let ((a1-17 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-17 from) (process->ppointer self))
              (set! (-> a1-17 num-params) 0)
              (set! (-> a1-17 message) 'stop)
              (let ((t9-16 send-event-function)
                    (v1-102 (-> self actor-group 1 data gp-6 actor))
                    )
                (t9-16
                  (if v1-102
                      (-> v1-102 extra process)
                      )
                  a1-17
                  )
                )
              )
            )
          )
         )
       )
      (else
        (until (process-grab? *target* #f)
          (suspend)
          )
        (let ((a3-6 (res-lump-struct (-> self entity) 'camera-name structure)))
          (if a3-6
              (set-setting! 'entity-name a3-6 0 0)
              )
          )
        (let ((gp-7 (-> self clock frame-counter)))
          (until (>= (- (-> self clock frame-counter) gp-7) (seconds 1))
            (suspend)
            )
          )
        (let ((gp-8 (-> self actor-group 0)))
          (dotimes (s5-3 (-> gp-8 length))
            (let ((a1-21 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-21 from) (process->ppointer self))
              (set! (-> a1-21 num-params) 1)
              (set! (-> a1-21 message) 'move)
              (set! (-> a1-21 param 0) (the-as uint (* (-> self anim-index) 8)))
              (let ((t9-20 send-event-function)
                    (v1-128 (-> gp-8 data s5-3 actor))
                    )
                (t9-20
                  (if v1-128
                      (-> v1-128 extra process)
                      )
                  a1-21
                  )
                )
              )
            )
          )
        )
      )
    (sound-play "robo-hatch-cls")
    (ja-no-eval :group! (-> self draw art-group data 2)
                :num! (seek! 0.0)
                :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1))
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek! 0.0))
      )
    (let ((gp-10 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-10) (seconds 1))
        (suspend)
        )
      )
    (remove-setting! 'entity-name)
    (until (process-release? *target*)
      (suspend)
      )
    (sleep-code)
    (none)
    )
  :post (behavior ()
    '()
    (none)
    )
  )

(defstate castle-wait-end (cas-robot-door)
  :virtual #t
  :code (behavior ()
    (local-vars (v1-28 symbol))
    (sound-play "robo-hatch-cls")
    (ja-no-eval :group! (-> self draw art-group data 2)
                :num! (seek! 0.0)
                :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1))
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek! 0.0))
      )
    (while (begin
             (dotimes (v1-27 (-> self actor-group 0 length))
               (when (not (logtest? (-> self actor-group 0 data v1-27 actor extra perm status) (entity-perm-status subtask-complete))
                          )
                 (set! v1-28 #f)
                 (goto cfg-14)
                 )
               )
             (set! v1-28 #t)
             (goto cfg-14)
             (label cfg-14)
             (not v1-28)
             )
      (let ((gp-1 (-> self clock frame-counter)))
        (until (>= (- (-> self clock frame-counter) gp-1) (seconds 0.51))
          (suspend)
          )
        )
      )
    (until (process-grab? *target* #f)
      (suspend)
      )
    (let ((a3-2 (res-lump-struct (-> self entity) 'camera-name structure)))
      (if a3-2
          (set-setting! 'entity-name a3-2 0 0)
          )
      )
    (let ((gp-2 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-2) (seconds 1))
        (suspend)
        )
      )
    (task-node-close! (game-task-node castle-break-in-resolution))
    (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-7 from) (process->ppointer self))
      (set! (-> a1-7 num-params) 2)
      (set! (-> a1-7 message) 'open)
      (set! (-> a1-7 param 0) (the-as uint 6000))
      (set! (-> a1-7 param 1) (the-as uint #f))
      (let ((t9-10 send-event-function)
            (v1-47 (-> self door-actor 0))
            )
        (t9-10
          (if v1-47
              (-> v1-47 extra process)
              )
          a1-7
          )
        )
      )
    (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-8 from) (process->ppointer self))
      (set! (-> a1-8 num-params) 2)
      (set! (-> a1-8 message) 'open)
      (set! (-> a1-8 param 0) (the-as uint 6000))
      (set! (-> a1-8 param 1) (the-as uint #f))
      (let ((t9-11 send-event-function)
            (v1-54 (-> self door-actor 1))
            )
        (t9-11
          (if v1-54
              (-> v1-54 extra process)
              )
          a1-8
          )
        )
      )
    (let ((gp-3 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-3) (seconds 2.5))
        (suspend)
        )
      )
    (remove-setting! 'entity-name)
    (until (process-release? *target*)
      (suspend)
      )
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cas-robot-door ((obj cas-robot-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (stack-size-set! (-> obj main-thread) 512)
  (local-vars (sv-16 res-tag) (sv-32 res-tag))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak hit-by-others-list player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-2)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-cas-robot-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj spawner-actor) (the-as symbol (entity-actor-lookup arg0 'alt-actor 0)))
  (set! (-> obj door-actor 0) (entity-actor-lookup arg0 'alt-actor 1))
  (set! (-> obj door-actor 1) (entity-actor-lookup arg0 'alt-actor 2))
  (set! (-> obj spawn-max) 5)
  (set! (-> obj spawn-total) -1)
  (set! (-> obj last-guard) (the-as handle #f))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-13 (res-lump-data arg0 'extra-id (pointer int32) :tag-ptr (& sv-16))))
    (when v1-13
      (set! (-> obj spawn-max) (-> v1-13 0))
      (if (< (the-as uint 1) (-> sv-16 elt-count))
          (set! (-> obj spawn-total) (-> v1-13 1))
          )
      )
    )
  (set! (-> obj notice-dist) (res-lump-float arg0 'notice-dist :default 122880.0))
  (set! (-> obj anim-index)
        (res-lump-value (-> obj entity) 'index int :default (the-as uint128 -1) :time -1000000000.0)
        )
  (set! sv-32 (new 'static 'res-tag))
  (let ((v1-17 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-32))))
    (cond
      ((and v1-17 (nonzero? (-> sv-32 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-17))
       (set! (-> obj actor-group-count) (the-as int (-> sv-32 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (let ((a0-27 (-> obj skel root-channel 0)))
    (set! (-> a0-27 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-27 frame-num) 0.0)
    (joint-control-channel-group! a0-27 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype lightning-ball (process-drawable)
  ((root-override collide-shape  :offset        128)
   (timer         time-frame     :offset-assert 200)
   )
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xd0
  :flag-assert         #x15005000d0
  (:methods
    (idle () _type_ :state 20)
    )
  )


(set! (-> *lightning-spec-id-table* 28) (new 'static 'lightning-spec
                                          :name "lightning-ball-shock"
                                          :flags (lightning-spec-flags lsf0)
                                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                                          :fade-start-factor 0.2
                                          :fade-time 60.0
                                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                                          :reduction 0.42
                                          :num-points 16
                                          :box-size 16384.0
                                          :merge-factor 0.5
                                          :merge-count 2
                                          :radius 8192.0
                                          :duration 30.0
                                          :sound (static-sound-spec "shock" :volume 50.0 :fo-min 10 :fo-max 30)
                                          )
      )

(defstate idle (lightning-ball)
  :virtual #t
  :code (the-as (function none :behavior lightning-ball) sleep-code)
  :post (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self timer)) (seconds 0.08))
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (let ((f30-1 (* 182.04445 (rand-vu-float-range -20.0 20.0)))
              (f28-1 (* 182.04445 (rand-vu-float-range -180.0 180.0)))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s5-0 quad) (-> *x-vector* quad))
          (vector-rotate-around-z! s5-0 s5-0 f30-1)
          (vector-rotate-around-y! s5-0 s5-0 f28-1)
          (vector+float*! (-> gp-0 start-pos) (-> self root-override trans) s5-0 56320.0)
          (vector-float*! (-> gp-0 move-dist) s5-0 81920.0)
          )
        (let ((v1-11 gp-0))
          (set! (-> v1-11 radius) 409.6)
          (set! (-> v1-11 collide-with) (collide-spec backgnd obstacle hit-by-others-list))
          (set! (-> v1-11 ignore-process0) self)
          (set! (-> v1-11 ignore-process1) #f)
          (set! (-> v1-11 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-11 action-mask) (collide-action solid))
          )
        (let ((f30-2 (fill-and-probe-using-line-sphere *collide-cache* gp-0)))
          (if (< 0.0 f30-2)
              (process-spawn
                lightning-tracker
                :init lightning-tracker-init
                (-> *lightning-spec-id-table* 28)
                (the int (* 300.0 (rand-vu-float-range 0.1 0.3)))
                #f
                #f
                (-> gp-0 start-pos)
                (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 start-pos) (-> gp-0 move-dist) f30-2)
                :to self
                )
              )
          )
        )
      (set! (-> self timer) (-> self clock frame-counter))
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! lightning-ball ((obj lightning-ball) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (with-pp
    (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
      (let ((v1-2 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
        (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-2 prim-core action) (collide-action solid))
        (set-vector! (-> v1-2 local-sphere) 0.0 0.0 0.0 56320.0)
        (set! (-> s4-0 total-prims) (the-as uint 1))
        (set! (-> s4-0 root-prim) v1-2)
        )
      (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
      (let ((v1-5 (-> s4-0 root-prim)))
        (set! (-> s4-0 backup-collide-as) (-> v1-5 prim-core collide-as))
        (set! (-> s4-0 backup-collide-with) (-> v1-5 prim-core collide-with))
        )
      (set! (-> obj root-override) s4-0)
      )
    (process-drawable-from-entity! obj arg0)
    (set! (-> obj timer) (-> pp clock frame-counter))
    (update-transforms (-> obj root-override))
    (go (method-of-object obj idle))
    (none)
    )
  )
