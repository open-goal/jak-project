;;-*-Lisp-*-
(in-package goal)

;; name: sewer-obs.gc
;; name in dgo: sewer-obs
;; dgos: SEB, SWB

;; DECOMP BEGINS

(deftype sew-blade (process-drawable)
  ((y-min        float    :offset-assert 200)
   (y-max        float    :offset-assert 204)
   (snd-water    uint128  :offset-assert 208)
   (snd-no-water uint128  :offset-assert 224)
   (last-sound   int32    :offset-assert 240)
   (attack-id    uint32   :offset-assert 244)
   )
  :heap-base #x80
  :method-count-assert 21
  :size-assert         #xf8
  :flag-assert         #x15008000f8
  (:methods
    (sew-blade-method-20 (_type_) none 20)
    )
  )


(defmethod sew-blade-method-20 sew-blade ((obj sew-blade))
  (when (nonzero? (-> obj sound))
    (let ((f30-0 (+ (-> obj root trans y) (-> obj y-max)))
          (f28-0 (+ (-> obj root trans y) (-> obj y-min)))
          (f0-2 (get-base-height *ocean-map-sewer*))
          )
      (cond
        ((< f30-0 f0-2)
         (stop! (-> obj sound))
         )
        ((< f0-2 f28-0)
         (when (!= (-> obj last-sound) 1)
           (change-sound! (-> obj sound) (the-as sound-name (-> obj snd-no-water)))
           (set! (-> obj last-sound) 1)
           )
         (update! (-> obj sound))
         )
        (else
          (when (!= (-> obj last-sound) 2)
            (change-sound! (-> obj sound) (the-as sound-name (-> obj snd-water)))
            (set! (-> obj last-sound) 2)
            )
          (update! (-> obj sound))
          )
        )
      )
    )
  0
  (none)
  )

(deftype sew-single-blade (sew-blade)
  ((quat quaternion :inline :offset-assert 256)
   )
  :heap-base #x90
  :method-count-assert 22
  :size-assert         #x110
  :flag-assert         #x1600900110
  (:methods
    (idle () _type_ :state 21)
    )
  )


(defskelgroup skel-sew-single-blade sew-single-blade sew-single-blade-lod0-jg sew-single-blade-idle-ja
              ((sew-single-blade-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 4 5.5)
              )

(defstate idle (sew-single-blade)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (let* ((s4-0 proc)
              (gp-0 (if (type? s4-0 process-focusable)
                        (the-as process-focusable s4-0)
                        )
                    )
              )
         (when gp-0
           (let ((s4-2 (vector-! (new 'stack-no-clear 'vector) (-> gp-0 root-override trans) (-> self root trans)))
                 (v1-5 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                 )
             (if (< (vector-dot v1-5 s4-2) 0.0)
                 (vector-float*! v1-5 v1-5 -1.0)
                 )
             (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
               (set! (-> a1-6 from) (process->ppointer self))
               (set! (-> a1-6 num-params) 2)
               (set! (-> a1-6 message) 'attack-or-shove)
               (set! (-> a1-6 param 0) (-> event param 0))
               (let ((a0-14 (new 'static 'attack-info :mask (attack-info-mask vector shove-back shove-up id))))
                 (set! (-> a0-14 id) (-> self attack-id))
                 (set! (-> a0-14 vector quad) (-> v1-5 quad))
                 (set! (-> a0-14 shove-back) 20480.0)
                 (set! (-> a0-14 shove-up) 12288.0)
                 (set! (-> a1-6 param 1) (the-as uint a0-14))
                 )
               (send-event-function gp-0 a1-6)
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)) 0.02)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.02))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (sew-blade-method-20 self)
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! sew-single-blade ((obj sew-single-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid deadly))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 16384.0 22528.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-single-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (quaternion-copy! (-> obj quat) (-> obj root quat))
  (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj root trans)))
  (set-falloff-far! (-> obj sound) 286720.0)
  (set! (-> obj y-min) -16384.0)
  (set! (-> obj y-max) 16384.0)
  (set! (-> obj snd-water)
        (the-as uint128 (make-u128 (the-as uint #x772d6564616c) (the-as uint #x622d656c676e6973)))
        )
  (set! (-> obj snd-no-water) (the-as uint128 (make-u128 #x6564616c (the-as uint #x622d656c676e6973))))
  (let* ((v1-35 *game-info*)
         (a0-19 (+ (-> v1-35 attack-id) 1))
         )
    (set! (-> v1-35 attack-id) a0-19)
    (set! (-> obj attack-id) a0-19)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype sew-tri-blade (sew-blade)
  ((anim-time    float  :offset-assert 248)
   (anim-offset  float  :offset-assert 252)
   (switch-state int32  :offset-assert 256)
   )
  :heap-base #x90
  :method-count-assert 22
  :size-assert         #x104
  :flag-assert         #x1600900104
  (:methods
    (idle () _type_ :state 21)
    )
  )


(defskelgroup skel-sew-tri-blade sew-tri-blade sew-tri-blade-lod0-jg sew-tri-blade-idle-ja
              ((sew-tri-blade-lod0-mg (meters 20)) (sew-tri-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 2.5 0 9)
              )

(defun sew-tri-blade-joint-callback ((arg0 draw-control) (arg1 cspace-array) (arg2 joint-control))
  (with-pp
    (let ((gp-0 (the-as sew-tri-blade (-> arg0 process)))
          (s5-0 (new-stack-matrix0))
          (f30-0 (* 182.04445 (* 0.0033333334 (the float (-> pp clock frame-counter)))))
          )
      (let ((s3-0 (-> arg1 data 4 bone transform)))
        (matrix-rotate-y! s5-0 (* 240.0 f30-0))
        (matrix*! s3-0 s5-0 s3-0)
        )
      (let ((s3-1 (-> arg1 data 5 bone transform)))
        (matrix-rotate-y! s5-0 (* -240.0 f30-0))
        (matrix*! s3-1 s5-0 s3-1)
        (set! (-> gp-0 y-max) (+ (- 25395.2 (-> gp-0 root trans y)) (-> s3-1 trans y)))
        )
      (let ((s4-1 (-> arg1 data 6 bone transform)))
        (matrix-rotate-y! s5-0 (* 240.0 f30-0))
        (matrix*! s4-1 s5-0 s4-1)
        (set! (-> gp-0 y-max) (fmax (-> gp-0 y-max) (+ (- 19251.2 (-> gp-0 root trans y)) (-> s4-1 trans y))))
        )
      )
    0
    (none)
    )
  )

(defstate idle (sew-tri-blade)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (let* ((s5-0 proc)
              (a0-2 (if (type? s5-0 process-focusable)
                        s5-0
                        )
                    )
              )
         (when a0-2
           (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-6 from) (process->ppointer self))
             (set! (-> a1-6 num-params) 2)
             (set! (-> a1-6 message) 'attack-or-shove)
             (set! (-> a1-6 param 0) (-> event param 0))
             (let ((v1-5 (new 'static 'attack-info :mask (attack-info-mask shove-back shove-up id))))
               (set! (-> v1-5 id) (-> self attack-id))
               (set! (-> v1-5 shove-back) 20480.0)
               (set! (-> v1-5 shove-up) 8192.0)
               (set! (-> a1-6 param 1) (the-as uint v1-5))
               )
             (send-event-function a0-2 a1-6)
             )
           )
         )
       )
      (('on)
       (when (!= (-> self anim-offset) 0.0)
         (let ((f30-0 (+ (-> self root trans y) (-> self y-max))))
           (if (< (get-base-height *ocean-map-sewer*) f30-0)
               (sound-play "tri-blade-up")
               )
           )
         )
       (let ((v0-1 (the-as object 1)))
         (set! (-> self switch-state) (the-as int v0-1))
         v0-1
         )
       )
      (('off)
       (when (= (-> self anim-offset) 0.0)
         (let ((f30-1 (+ (-> self root trans y) (-> self y-max))))
           (if (< (get-base-height *ocean-map-sewer*) f30-1)
               (sound-play "tri-blade-up")
               )
           )
         )
       (set! (-> self switch-state) 0)
       0
       )
      )
    )
  :code (behavior ()
    (until #f
      (cond
        ((zero? (-> self switch-state))
         (cond
           ((>= 3.0 (-> self anim-time))
            (+! (-> self anim-time) (* 6.0 (-> self clock seconds-per-frame)))
            (set! (-> self anim-time) (fmin 3.0 (-> self anim-time)))
            )
           (else
             (+! (-> self anim-time) (* 6.0 (-> self clock seconds-per-frame)))
             (if (< 6.0 (-> self anim-time))
                 (set! (-> self anim-time) 0.0)
                 )
             )
           )
         )
        (else
          (+! (-> self anim-time) (* 6.0 (-> self clock seconds-per-frame)))
          (set! (-> self anim-time) (fmin 6.0 (-> self anim-time)))
          )
        )
      (let ((f30-0 (+ (-> self anim-time) (-> self anim-offset))))
        (if (< 6.0 f30-0)
            (set! f30-0 (+ -6.0 f30-0))
            )
        (ja :group! (-> self draw art-group data 3) :num! (identity f30-0))
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (sew-blade-method-20 self)
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! sew-tri-blade ((obj sew-tri-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (with-pp
    (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
    (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
      (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
      (set! (-> s4-0 reaction) cshape-reaction-default)
      (set! (-> s4-0 no-reaction)
            (the-as (function collide-shape-moving collide-query vector vector object) nothing)
            )
      (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 3) 0)))
        (set! (-> s4-0 total-prims) (the-as uint 4))
        (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
        (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> s3-0 prim-core action) (collide-action solid deadly))
        (set-vector! (-> s3-0 local-sphere) 0.0 10240.0 0.0 36864.0)
        (set! (-> s4-0 root-prim) s3-0)
        )
      (pusher-init s4-0)
      (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
        (set! (-> v1-16 prim-core collide-as) (collide-spec camera-blocker pusher))
        (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-16 prim-core action) (collide-action solid deadly))
        (set! (-> v1-16 transform-index) 4)
        (set-vector! (-> v1-16 local-sphere) 0.0 8192.0 0.0 18841.6)
        )
      (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
        (set! (-> v1-18 prim-core collide-as) (collide-spec camera-blocker pusher))
        (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-18 prim-core action) (collide-action solid deadly))
        (set! (-> v1-18 transform-index) 5)
        (set-vector! (-> v1-18 local-sphere) 0.0 8192.0 0.0 12288.0)
        )
      (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-20 prim-core collide-as) (collide-spec camera-blocker pusher))
        (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-20 prim-core action) (collide-action solid deadly))
        (set! (-> v1-20 transform-index) 6)
        (set-vector! (-> v1-20 local-sphere) 0.0 4915.2 0.0 7372.8)
        )
      (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
      (let ((v1-23 (-> s4-0 root-prim)))
        (set! (-> s4-0 backup-collide-as) (-> v1-23 prim-core collide-as))
        (set! (-> s4-0 backup-collide-with) (-> v1-23 prim-core collide-with))
        )
      (set! (-> obj root) s4-0)
      )
    (process-drawable-from-entity! obj arg0)
    (logclear! (-> obj mask) (process-mask actor-pause))
    (initialize-skeleton
      obj
      (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-tri-blade" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (set! (-> obj state-time) (-> pp clock frame-counter))
    (set! (-> obj anim-time) 0.0)
    (set! (-> obj anim-offset) 0.0)
    (set! (-> obj skel postbind-function) sew-tri-blade-joint-callback)
    (let* ((v1-33 *game-info*)
           (a0-33 (+ (-> v1-33 attack-id) 1))
           )
      (set! (-> v1-33 attack-id) a0-33)
      (set! (-> obj attack-id) a0-33)
      )
    (if (>= (res-lump-value arg0 'extra-id int :default (the-as uint128 -1) :time -1000000000.0) 0)
        (set! (-> obj anim-offset) 3.0)
        )
    (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj root trans)))
    (set-falloff-far! (-> obj sound) 286720.0)
    (set! (-> obj y-min) 0.0)
    (set! (-> obj y-max) 48332.8)
    (set! (-> obj snd-water) (the-as uint128 (make-u128 #x772d65 (the-as uint #x64616c622d697274))))
    (set! (-> obj snd-no-water) (the-as uint128 (make-u128 101 (the-as uint #x64616c622d697274))))
    (transform-post)
    (go (method-of-object obj idle))
    (none)
    )
  )

(deftype sew-arm-blade (sew-blade)
  ()
  :heap-base #x80
  :method-count-assert 22
  :size-assert         #xf8
  :flag-assert         #x16008000f8
  (:methods
    (idle () _type_ :state 21)
    )
  )


(defskelgroup skel-sew-arm-blade sew-arm-blade sew-arm-blade-lod0-jg sew-arm-blade-idle-ja
              ((sew-arm-blade-lod0-mg (meters 20)) (sew-arm-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 -6 0 7)
              )

(defstate idle (sew-arm-blade)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (let* ((s5-0 proc)
              (a0-2 (if (type? s5-0 process-focusable)
                        s5-0
                        )
                    )
              )
         (when a0-2
           (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-4 from) (process->ppointer self))
             (set! (-> a1-4 num-params) 2)
             (set! (-> a1-4 message) 'attack-or-shove)
             (set! (-> a1-4 param 0) (-> event param 0))
             (let ((v1-6 (new 'static 'attack-info :mask (attack-info-mask shove-back shove-up id))))
               (set! (-> v1-6 id) (-> self attack-id))
               (set! (-> v1-6 shove-back) 20480.0)
               (set! (-> v1-6 shove-up) 8192.0)
               (set! (-> a1-4 param 1) (the-as uint v1-6))
               )
             (send-event-function a0-2 a1-4)
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)) 0.02)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.02))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (sew-blade-method-20 self)
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! sew-arm-blade ((obj sew-arm-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid deadly))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 -24576.0 0.0 28672.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-arm-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj root trans)))
  (set-falloff-far! (-> obj sound) 286720.0)
  (set! (-> obj y-min) -43008.0)
  (set! (-> obj y-max) -4096.0)
  (set! (-> obj snd-water) (the-as uint128 (make-u128 #x772d65 (the-as uint #x64616c622d6d7261))))
  (set! (-> obj snd-no-water) (the-as uint128 (make-u128 101 (the-as uint #x64616c622d6d7261))))
  (let* ((v1-34 *game-info*)
         (a0-18 (+ (-> v1-34 attack-id) 1))
         )
    (set! (-> v1-34 attack-id) a0-18)
    (set! (-> obj attack-id) a0-18)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype sew-multi-blade (sew-blade)
  ()
  :heap-base #x80
  :method-count-assert 22
  :size-assert         #xf8
  :flag-assert         #x16008000f8
  (:methods
    (idle () _type_ :state 21)
    )
  )


(defskelgroup skel-sew-multi-blade sew-multi-blade sew-multi-blade-lod0-jg sew-multi-blade-idle-ja
              ((sew-multi-blade-lod0-mg (meters 20)) (sew-multi-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 18 0 0 22)
              )

(defstate idle (sew-multi-blade)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touch 'attack)
       (let* ((s4-0 proc)
              (gp-0 (if (type? s4-0 process-focusable)
                        (the-as process-focusable s4-0)
                        )
                    )
              )
         (when gp-0
           (let ((s4-2 (vector-! (new 'stack-no-clear 'vector) (-> gp-0 root-override trans) (-> self root trans)))
                 (v1-5 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                 )
             (if (< (vector-dot v1-5 s4-2) 0.0)
                 (vector-float*! v1-5 v1-5 -1.0)
                 )
             (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
               (set! (-> a1-6 from) (process->ppointer self))
               (set! (-> a1-6 num-params) 2)
               (set! (-> a1-6 message) 'attack-or-shove)
               (set! (-> a1-6 param 0) (-> event param 0))
               (let ((a0-14 (new 'static 'attack-info :mask (attack-info-mask vector shove-back shove-up id))))
                 (set! (-> a0-14 id) (-> self attack-id))
                 (set! (-> a0-14 vector quad) (-> v1-5 quad))
                 (set! (-> a0-14 shove-back) 28672.0)
                 (set! (-> a0-14 shove-up) 16384.0)
                 (set! (-> a1-6 param 1) (the-as uint a0-14))
                 )
               (send-event-function gp-0 a1-6)
               )
             )
           )
         )
       )
      )
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (sew-blade-method-20 self)
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! sew-multi-blade ((obj sew-multi-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 73728.0 0.0 0.0 90112.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-multi-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj root trans)))
  (set-falloff-far! (-> obj sound) 368640.0)
  (set! (-> obj y-min) -16384.0)
  (set! (-> obj y-max) 16384.0)
  (set! (-> obj snd-water)
        (the-as uint128 (make-u128 (the-as uint #x772d656461) (the-as uint #x6c622d69746c756d)))
        )
  (set! (-> obj snd-no-water) (the-as uint128 (make-u128 #x656461 (the-as uint #x6c622d69746c756d))))
  (let* ((v1-34 *game-info*)
         (a0-18 (+ (-> v1-34 attack-id) 1))
         )
    (set! (-> v1-34 attack-id) a0-18)
    (set! (-> obj attack-id) a0-18)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype sew-twist-blade (sew-blade)
  ((root-overide       collide-shape-moving  :offset        128)
   (no-collision-timer uint64                :offset-assert 248)
   )
  :heap-base #x80
  :method-count-assert 22
  :size-assert         #x100
  :flag-assert         #x1600800100
  (:methods
    (idle () _type_ :state 21)
    )
  )


(defskelgroup skel-sew-twist-blade sew-twist-blade sew-twist-blade-lod0-jg sew-twist-blade-idle-ja
              ((sew-twist-blade-lod0-mg (meters 20)) (sew-twist-blade-lod1-mg (meters 999999)))
              :bounds (static-spherem 10 0 0 12)
              )

(defstate idle (sew-twist-blade)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('touch 'attack)
         (let* ((s4-0 proc)
                (gp-0 (if (type? s4-0 process-focusable)
                          (the-as process-focusable s4-0)
                          )
                      )
                )
           (when gp-0
             (let ((s4-2 (vector-! (new 'stack-no-clear 'vector) (-> gp-0 root-override trans) (-> self root-overide trans)))
                   (v1-5 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-overide quat)))
                   )
               (if (< (vector-dot v1-5 s4-2) 0.0)
                   (vector-float*! v1-5 v1-5 -1.0)
                   )
               (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
                 (set! (-> a1-6 from) (process->ppointer self))
                 (set! (-> a1-6 num-params) 2)
                 (set! (-> a1-6 message) 'attack-or-shove)
                 (set! (-> a1-6 param 0) (-> event param 0))
                 (let ((a0-14 (new 'static 'attack-info :mask (attack-info-mask vector shove-back shove-up id))))
                   (set! (-> a0-14 id) (-> self attack-id))
                   (set! (-> a0-14 vector quad) (-> v1-5 quad))
                   (set! (-> a0-14 shove-back) 16384.0)
                   (set! (-> a0-14 shove-up) 8192.0)
                   (set! (-> a1-6 param 1) (the-as uint a0-14))
                   )
                 (send-event-function gp-0 a1-6)
                 )
               )
             (set! (-> self no-collision-timer) (the-as uint (-> self clock frame-counter)))
             (let ((v1-13 (-> self root-overide root-prim)))
               (set! (-> v1-13 prim-core collide-as) (collide-spec))
               (set! (-> v1-13 prim-core collide-with) (collide-spec))
               )
             0
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (when (and (nonzero? (-> self no-collision-timer))
               (>= (- (-> self clock frame-counter) (the-as int (-> self no-collision-timer)))
                   (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout))
                   )
               )
      (let ((v1-7 (-> self root-overide root-prim)))
        (set! (-> v1-7 prim-core collide-as) (-> self root-overide backup-collide-as))
        (set! (-> v1-7 prim-core collide-with) (-> self root-overide backup-collide-with))
        )
      (set! (-> self no-collision-timer) (the-as uint 0))
      0
      )
    (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> a1-0 options) (overlaps-others-options oo0))
      (set! (-> a1-0 collide-with-filter) (the-as collide-spec -1))
      (set! (-> a1-0 tlist) *touching-list*)
      (find-overlapping-shapes (-> self root-overide) a1-0)
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)) 0.02)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.02))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (sew-blade-method-20 self)
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! sew-twist-blade ((obj sew-twist-blade) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj mask) (logior (process-mask ambient) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid deadly))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 40960.0 0.0 0.0 49152.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> obj root-overide) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-twist-blade" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (transform-post)
  (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj root-overide trans)))
  (set-falloff-far! (-> obj sound) 245760.0)
  (set! (-> obj y-min) -4096.0)
  (set! (-> obj y-max) 4096.0)
  (set! (-> obj snd-water)
        (the-as uint128 (make-u128 (the-as uint #x772d656461) (the-as uint #x6c622d7473697774)))
        )
  (set! (-> obj snd-no-water) (the-as uint128 (make-u128 #x656461 (the-as uint #x6c622d7473697774))))
  (let* ((v1-34 *game-info*)
         (a0-18 (+ (-> v1-34 attack-id) 1))
         )
    (set! (-> v1-34 attack-id) a0-18)
    (set! (-> obj attack-id) a0-18)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype sew-light-switch (process-drawable)
  ((light-state       symbol                 :offset-assert 200)
   (actor-group       (pointer actor-group)  :offset-assert 204)
   (actor-group-count int32                  :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 24
  :size-assert         #xd4
  :flag-assert         #x18006000d4
  (:methods
    (idle () _type_ :state 20)
    (pressed () _type_ :state 21)
    (sew-light-switch-method-22 (_type_) none 22)
    (sew-light-switch-method-23 (_type_ symbol) none 23)
    )
  )


(deftype sew-light-control (process)
  ((search-switches basic         :offset-assert 128)
   (search-turrets  basic         :offset-assert 132)
   (switch-ent      entity-actor  :offset-assert 136)
   (turret-ent      entity-actor  :offset-assert 140)
   )
  :heap-base #x10
  :method-count-assert 17
  :size-assert         #x90
  :flag-assert         #x1100100090
  (:methods
    (idle () _type_ :state 14)
    (sew-light-control-method-15 (_type_ symbol symbol) float 15)
    (sew-light-control-method-16 (_type_ object vector float) symbol 16)
    )
  )


(defskelgroup skel-sew-light-switch sew-light-switch 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 0 0 1.5)
              )

(defstate idle (sew-light-switch)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (sew-light-switch-method-23 self 'cue-chase)
       (go-virtual pressed)
       )
      (('touch 'attack)
       (let* ((gp-0 (-> event param 0))
              (s5-0 proc)
              (v1-6 (if (type? s5-0 target)
                        s5-0
                        )
                    )
              )
         (when (and gp-0 v1-6)
           (sew-light-switch-method-23 self 'cue-chase)
           (go-virtual pressed)
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self light-state) #f)
    (none)
    )
  :code (behavior ()
    (ja-channel-set! 1)
    (ja :group! (-> self draw art-group data 2) :num! min)
    (transform-post)
    (sleep-code)
    (none)
    )
  :post (behavior ()
    (let ((t9-0 sp-launch-particles-var)
          (a0-0 *sp-particle-system-2d*)
          (a1-0 (-> *part-id-table* 1442))
          (a2-0 *launch-matrix*)
          )
      (set! (-> a2-0 trans quad) (-> self root trans quad))
      (t9-0 a0-0 a1-0 a2-0 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
      )
    (ja-post)
    (none)
    )
  )

(defstate pressed (sew-light-switch)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('untrigger)
       (go-virtual idle)
       )
      )
    )
  :enter (behavior ()
    (set! (-> self light-state) #t)
    (sound-play "sew-light-switc")
    (none)
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 2)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch collide-shape-moving vs none.
(defmethod sew-light-switch-method-22 sew-light-switch ((obj sew-light-switch))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod sew-light-switch-method-23 sew-light-switch ((obj sew-light-switch) (arg0 symbol))
  (with-pp
    (dotimes (s4-0 (-> obj actor-group-count))
      (let ((s3-0 (-> obj actor-group s4-0)))
        (dotimes (s2-0 (-> s3-0 length))
          (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-1 from) (process->ppointer pp))
            (set! (-> a1-1 num-params) 0)
            (set! (-> a1-1 message) arg0)
            (let ((t9-0 send-event-function)
                  (v1-5 (-> s3-0 data s2-0 actor))
                  )
              (t9-0
                (if v1-5
                    (-> v1-5 extra process)
                    )
                a1-1
                )
              )
            )
          )
        )
      )
    (if (-> *game-info* controller 0)
        (send-event (-> *game-info* controller 0 process 0) arg0)
        )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! sew-light-switch ((obj sew-light-switch) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (sew-light-switch-method-22 obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-sew-light-switch" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (process-entity-status! obj (entity-perm-status no-kill) #t)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-6 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-6 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-6))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> obj light-state) #f)
  (go (method-of-object obj idle))
  (none)
  )

(defmethod sew-light-control-method-16 sew-light-control ((a0-0 sew-light-control) (a1-0 object) (a2-0 vector) (a3-0 float))
  (format 0 "SEWER - FIX ME!~%")
  #f
  )

(defstate idle (sew-light-control)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 entity))
    (the-as object (case event-type
                     (('use-switch)
                      (set! v0-0 (entity-by-name (the-as string (-> event param 0))))
                      (set! (-> self switch-ent) (the-as entity-actor v0-0))
                      v0-0
                      )
                     (('use-turret)
                      (set! v0-0 (entity-by-name (the-as string (-> event param 0))))
                      (set! (-> self turret-ent) (the-as entity-actor v0-0))
                      v0-0
                      )
                     )
            )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (let* ((gp-0 *target*)
           (a0-1 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           )
      (when a0-1
        (get-trans a0-1 0)
        (let ((gp-1 #f)
              (a2-0 (the-as object #f))
              )
          (let* ((a0-2 (-> self switch-ent))
                 (v1-2 (if a0-2
                           (-> a0-2 extra process)
                           )
                       )
                 )
            (if v1-2
                (set! gp-1 (-> (the-as sew-light-switch v1-2) light-state))
                )
            )
          (let* ((v1-4 (-> self turret-ent))
                 (a0-5 (if v1-4
                           (-> v1-4 extra process)
                           )
                       )
                 )
            (when a0-5
              (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-2 from) (process->ppointer self))
                (set! (-> a1-2 num-params) 0)
                (set! (-> a1-2 message) 'flash-state)
                (set! a2-0 (send-event-function a0-5 a1-2))
                )
              )
            )
          (sew-light-control-method-15 self gp-1 (the-as symbol a2-0))
          )
        )
      )
    (none)
    )
  )

(defmethod sew-light-control-method-15 sew-light-control ((obj sew-light-control) (arg0 symbol) (arg1 symbol))
  (set-sewer-lights-flag! arg0)
  (if arg1
      (set-sewer-turret-flash!)
      )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior sew-light-control-init-by-other sew-light-control ((arg0 entity-actor) (arg1 entity-actor))
  (process-entity-set! self arg0)
  (set! (-> *game-info* controller 0) (process->handle self))
  (set! (-> self switch-ent) arg0)
  (set! (-> self turret-ent) arg1)
  (sew-light-control-method-15 self #f #f)
  (go-virtual idle)
  (none)
  )

(defun sewer-startup ()
  (cond
    ((task-node-closed? (game-task-node sewer-board-introduction))
     (set! (-> sewer bigmap-id) (the-as uint 15))
     (set! (-> sewerb bigmap-id) (the-as uint 15))
     )
    (else
      (set! (-> sewer bigmap-id) (the-as uint 14))
      (set! (-> sewerb bigmap-id) (the-as uint 14))
      )
    )
  (process-spawn
    sew-light-control
    (entity-by-name "sew-light-switch-13")
    (entity-by-name "sew-gunturret-13")
    :to *entity-pool*
    )
  0
  (none)
  )
