;;-*-Lisp-*-
(in-package goal)

;; name: rhino.gc
;; name in dgo: rhino
;; dgos: MTN

(declare-type rhino-wall process-focusable)

;; DECOMP BEGINS

(defpartgroup group-rhino-slide-poof-pmt
  :id 350
  :duration (seconds 0.035)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 1488))
  )

(defpart 1488
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 6.0 6.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 70.0 32.0)
    (:b 40.0 20.0)
    (:a 16.0 16.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.0033333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.07111111 -0.07111111)
    (:accel-y (meters -0.00006666667))
    (:friction 0.94)
    (:timer (seconds 1.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:conerot-x (degrees 60) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-rhino-slide-poof-grs
  :id 351
  :duration (seconds 0.035)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 1489) (sp-item 1490))
  )

(defpart 1489
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 6.0 6.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 96.0 32.0)
    (:g 128.0 32.0)
    (:b 0.0 64.0)
    (:a 16.0 16.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.0033333334))
    (:rotvel-z (degrees -0.2) (degrees 0.4))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.07111111 -0.07111111)
    (:accel-y (meters -0.00006666667))
    (:friction 0.94)
    (:timer (seconds 1.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:conerot-x (degrees 60) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 1490
  :init-specs ((:texture (new 'static 'texture-id :index #x2f :page #xc))
    (:num 0.0 8.0)
    (:x (meters -0.4) (meters 0.8))
    (:y (meters -0.1) (meters 0.4))
    (:z (meters -0.4) (meters 0.8))
    (:scale-x (meters 0.15) (meters 0.35))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.15))
    (:r 128.0 2.0 64.0)
    (:g 255.0 0 1.0)
    (:a 128.0 64.0)
    (:vel-y (meters 0.015) (meters 0.01))
    (:rotvel-z (degrees -2.4) (degrees 4.8))
    (:fade-a -0.42666668)
    (:accel-y (meters -0.001) (meters 0.0005))
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:conerot-x (degrees 30) (degrees 50.000004))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 0.5))
    )
  )

(defskelgroup skel-rhino rhino rhino-lod0-jg -1
              ((rhino-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 1 7)
              :shadow rhino-shadow-mg
              :origin-joint-index 16
              )

(deftype rhino (nav-enemy)
  ((wall                  rhino-wall            :offset-assert 604)
   (path-intro            path-control          :offset-assert 608)
   (charge-aware          uint64                :offset-assert 616)
   (anim-skid-left        int32                 :offset-assert 624)
   (anim-skid-right       int32                 :offset-assert 628)
   (anim-victory-hit      int32                 :offset-assert 632)
   (circle-backward?      symbol                :offset-assert 636)
   (skid-speed            float                 :offset        672)
   (angle                 float                 :offset-assert 676)
   (angle-speed           float                 :offset-assert 680)
   (dest                  vector        :inline :offset-assert 688)
   (charge-straight       symbol                :offset-assert 704)
   (in-stop-run           symbol                :offset-assert 708)
   (smush-target          smush-control         :offset-assert 712)
   (num-hit-flinch        int32                 :offset-assert 716)
   (frame-die-smush       float                 :offset-assert 720)
   (quat                  quaternion    :inline :offset-assert 736)
   (can-hit?              symbol                :offset-assert 752)
   (interest              int32                 :offset-assert 756)
   (victory-count         uint32                :offset-assert 760)
   (stomach-touched-once? symbol                :offset-assert 764)
   )
  :heap-base #x280
  :method-count-assert 183
  :size-assert         #x300
  :flag-assert         #xb702800300
  (:methods
    (attack () _type_ :state 178)
    (stop-run () _type_ :state 179)
    (run-away () _type_ :state 180)
    (charge () _type_ :state 181)
    (rhino-method-182 (_type_ process event-message-block) symbol 182)
    )
  )

;; ERROR: failed type prop at 48: Could not figure out load: (set! a2 (l.wu (+ gp 636)))

(define *rhino-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #f
    :use-victory #t
    :use-jump-blocked #f
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #t
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'array idle-control-frame 8
      (new 'static 'idle-control-frame :command (ic-cmd push) :param0 #x1e)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x3 :param0 #x1 :param1 #x4)
      (new 'static 'idle-control-frame :command (ic-cmd push) :param0 #x1e)
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x4 :param0 #x1 :param1 #x4)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      )
    :idle-anim 3
    :notice-anim 7
    :hostile-anim 10
    :hit-anim 23
    :knocked-anim -1
    :knocked-land-anim -1
    :die-anim 14
    :die-falling-anim 14
    :victory-anim 11
    :jump-wind-up-anim -1
    :jump-in-air-anim -1
    :jump-land-anim -1
    :neck-joint 5
    :look-at-joint 6
    :bullseye-joint 4
    :sound-hit (static-sound-name "rhino-hit")
    :sound-die (static-sound-name "rhino-die")
    :notice-distance (meters 40)
    :notice-distance-delta (meters 10)
    :proximity-notice-distance (meters 2)
    :default-hit-points 35
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
    :penetrate-flinch (penetrate
      touch
      generic-attack
      lunge
      flop
      punch
      spin
      roll
      uppercut
      bonk
      tube
      vehicle
      flut-attack
      board
      mech
      mech-punch
      mech-bonk
      dark-skin
      dark-punch
      dark-bomb
      dark-giant
      shield
      jak-yellow-shot
      jak-red-shot
      jak-blue-shot
      enemy-yellow-shot
      eco-yellow
      eco-red
      eco-blue
      eco-green
      knocked
      penetrate-33
      penetrate-34
      penetrate-35
      penetrate-36
      penetrate-37
      penetrate-38
      penetrate-39
      penetrate-40
      penetrate-41
      penetrate-42
      penetrate-43
      penetrate-44
      penetrate-45
      penetrate-46
      penetrate-47
      penetrate-48
      penetrate-49
      penetrate-50
      penetrate-51
      penetrate-52
      penetrate-53
      penetrate-54
      penetrate-55
      penetrate-56
      penetrate-57
      penetrate-58
      penetrate-59
      penetrate-60
      penetrate-61
      penetrate-62
      penetrate-63
      )
    :movement-gravity (meters -100)
    :friction 0.8
    :attack-shove-back (meters 4)
    :attack-shove-up (meters 4)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :jump-height-min (meters 3)
    :jump-height-factor 0.5
    :knocked-seek-ry-clamp 2730.6667
    :knocked-soft-vxz-lo 72089.6
    :knocked-soft-vxz-hi 108134.4
    :knocked-soft-vy-lo 81920.0
    :knocked-soft-vy-hi 122880.0
    :knocked-medium-vxz-lo 147456.0
    :knocked-medium-vxz-hi 196608.0
    :knocked-medium-vy-lo 135168.0
    :knocked-medium-vy-hi 151552.0
    :knocked-hard-vxz-lo 78643.2
    :knocked-hard-vxz-hi 117964.8
    :knocked-hard-vy-lo 183500.8
    :knocked-hard-vy-hi 209715.2
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 40960.0
    :knocked-yellow-vxz-hi 49152.0
    :knocked-yellow-vy-lo 57344.0
    :knocked-yellow-vy-hi 81920.0
    :knocked-red-vxz-lo 24576.0
    :knocked-red-vxz-hi 196608.0
    :knocked-red-vy-lo 94208.0
    :knocked-red-vy-hi 151552.0
    :knocked-blue-vxz-lo 40960.0
    :knocked-blue-vxz-hi 49152.0
    :knocked-blue-vy-lo 24576.0
    :knocked-blue-vy-hi 81920.0
    :shadow-size (meters 2)
    :shadow-max-y (meters 1)
    :shadow-min-y (meters -1)
    :shadow-locus-dist (meters 150)
    :gem-joint 6
    :gem-seg #x2
    :gem-no-seg #x4
    :gem-offset (new 'static 'sphere :y 2170.88 :z 1761.28 :r 163840.0)
    :callback-info #f
    :use-momentum #t
    :use-frustration #t
    :use-stop-chase #f
    :use-circling #f
    :use-pacing #f
    :walk-anim 6
    :turn-anim -1
    :run-anim 10
    :taunt-anim -1
    :run-travel-speed (meters 14)
    :run-acceleration (meters 40)
    :run-turning-acceleration (meters 26)
    :walk-travel-speed (meters 1)
    :walk-acceleration (meters 1)
    :walk-turning-acceleration (meters 3)
    :maximum-rotation-rate (degrees 180.0)
    :notice-nav-radius (meters 4)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

(set! (-> *rhino-nav-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

(defmethod rhino-method-182 rhino ((obj rhino) (arg0 process) (arg1 event-message-block))
  (let* ((gp-0 (-> arg1 param 0))
         (s5-0 arg0)
         (s2-0 (if (type? s5-0 process-drawable)
                   s5-0
                   )
               )
         )
    (cond
      ((and (-> obj can-hit?) gp-0 ((method-of-type touching-shapes-entry prims-touching?)
                                    (the-as touching-shapes-entry gp-0)
                                    (-> obj root-override2)
                                    (the-as uint 1)
                                    )
            )
       (let ((s4-0 (new 'stack-no-clear 'vector))
             (gp-1 (new 'stack-no-clear 'vector))
             (s5-1 (new 'stack-no-clear 'vector))
             )
         (vector-z-quaternion! s4-0 (-> obj root-override2 quat))
         (vector-x-quaternion! gp-1 (-> obj root-override2 quat))
         (vector-! s5-1 (-> (the-as process-drawable s2-0) root trans) (-> obj root-override2 trans))
         (if (and (< 0.0 (vector-dot s5-1 s4-0)) (< (fabs (vector-dot s5-1 gp-1)) 10240.0))
             #t
             #f
             )
         )
       )
      (else
        #f
        )
      )
    )
  )

(defmethod enemy-method-58 rhino ((obj rhino) (arg0 process) (arg1 event-message-block))
  (let ((t9-0 (method-of-type nav-enemy enemy-method-58)))
    (t9-0 obj arg0 arg1)
    )
  (if (rhino-method-182 obj arg0 arg1)
      'hit
      'hit-flinch
      )
  )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 10]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 25]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 30]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 45]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 151]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 216]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 272]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 318]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 323]
(defmethod general-event-handler rhino ((obj rhino) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (local-vars
    (sv-96 int)
    (sv-112 symbol)
    (sv-128 symbol)
    (sv-144 symbol)
    (sv-160 vector)
    (sv-176 matrix)
    (sv-192 int)
    (sv-208 symbol)
    (sv-224 symbol)
    (sv-240 symbol)
    (sv-256 vector)
    (sv-272 matrix)
    )
  (let ((v1-0 arg2))
    (the-as
      object
      (cond
        ((= v1-0 'charge)
         (if (-> obj wall)
             (go (method-of-object obj charge))
             )
         )
        ((= v1-0 'hit)
         (cond
           ((zero? (-> obj hit-points))
            (set! (-> *rhino-nav-enemy-info* die-anim) 15)
            (set! (-> obj frame-die-smush) 11.0)
            (kill-prefer-falling obj)
            )
           (else
             ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
             )
           )
         )
        ((= v1-0 'hit-flinch)
         (cond
           ((zero? (-> obj hit-points))
            (set! (-> *rhino-nav-enemy-info* die-anim) 14)
            (set! (-> obj frame-die-smush) 16.0)
            (kill-prefer-falling obj)
            )
           (else
             (let* ((s5-0 arg0)
                    (s2-0 (if (type? s5-0 process-drawable)
                              s5-0
                              )
                          )
                    (s3-0 (new 'stack-no-clear 'vector))
                    (s4-0 (new 'stack-no-clear 'vector))
                    (s5-1 (new 'stack-no-clear 'vector))
                    )
               (vector-z-quaternion! s3-0 (-> obj root-override2 quat))
               (vector-x-quaternion! s4-0 (-> obj root-override2 quat))
               (vector-! s5-1 (-> (the-as process-focusable s2-0) root-override trans) (-> obj root-override2 trans))
               (set! (-> s5-1 y) 0.0)
               (vector-normalize! s5-1 1.0)
               (let* ((f30-0 (vector-dot s3-0 s5-1))
                      (f28-0 (vector-dot s4-0 s5-1))
                      (a0-16 (cond
                               ((>= f30-0 (cos 8192.0))
                                (-> obj draw art-group data 16)
                                )
                               ((>= (cos 24576.0) f30-0)
                                (-> obj draw art-group data 19)
                                )
                               ((>= f28-0 (cos 8192.0))
                                (-> obj draw art-group data 17)
                                )
                               ((>= (cos 24576.0) f28-0)
                                (-> obj draw art-group data 18)
                                )
                               (else
                                 (-> obj draw art-group data 16)
                                 )
                               )
                             )
                      (v0-9 (ja-channel-float! (the-as art-joint-anim a0-16) 0.0 0.0 0.0))
                      )
                 (when v0-9
                   (set! (-> obj skel interp-select 0) (the-as int (the-as uint #x1c9002228)))
                   (set! (-> obj skel interp-select 1) 0)
                   (set! (-> v0-9 param 0) 1.0)
                   (set! (-> v0-9 param 1) 1.0)
                   (set! (-> v0-9 param 2) 3.0)
                   (set! (-> v0-9 num-func) num-func-interp1-play!)
                   )
                 )
               )
             (+! (-> obj num-hit-flinch) 1)
             'back
             )
           )
         )
        ((= v1-0 'event-slide-poof)
         (let ((s5-2 (-> arg3 param 1)))
           (cond
             ((= (-> obj root-override2 ground-pat material) (pat-material grass))
              (let ((s4-1 (get-process *default-dead-pool* part-tracker #x4000)))
                (when s4-1
                  (let ((t9-14 (method-of-type part-tracker activate)))
                    (t9-14 (the-as part-tracker s4-1) obj (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                    )
                  (let ((s3-1 run-function-in-process)
                        (s2-1 s4-1)
                        (s1-0 part-tracker-init)
                        (s0-0 (-> *part-group-id-table* 351))
                        )
                    (set! sv-96 0)
                    (set! sv-112 (the-as symbol #f))
                    (set! sv-128 (the-as symbol #f))
                    (set! sv-144 (the-as symbol #f))
                    (set! sv-176 *launch-matrix*)
                    (set! sv-160 (-> sv-176 trans))
                    (let ((v1-52 (-> (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data s5-2)) quad)))
                      (set! (-> sv-160 quad) v1-52)
                      )
                    ((the-as (function object object object object object object object object none) s3-1)
                     s2-1
                     s1-0
                     s0-0
                     sv-96
                     sv-112
                     sv-128
                     sv-144
                     sv-176
                     )
                    )
                  (-> s4-1 ppointer)
                  )
                )
              )
             (else
               (let ((s4-2 (get-process *default-dead-pool* part-tracker #x4000)))
                 (when s4-2
                   (let ((t9-18 (method-of-type part-tracker activate)))
                     (t9-18 (the-as part-tracker s4-2) obj (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                     )
                   (let ((s3-2 run-function-in-process)
                         (s2-2 s4-2)
                         (s1-1 part-tracker-init)
                         (s0-1 (-> *part-group-id-table* 350))
                         )
                     (set! sv-192 0)
                     (set! sv-208 (the-as symbol #f))
                     (set! sv-224 (the-as symbol #f))
                     (set! sv-240 (the-as symbol #f))
                     (set! sv-272 *launch-matrix*)
                     (set! sv-256 (-> sv-272 trans))
                     (let ((v1-64 (-> (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data s5-2)) quad)))
                       (set! (-> sv-256 quad) v1-64)
                       )
                     ((the-as (function object object object object object object object object none) s3-2)
                      s2-2
                      s1-1
                      s0-1
                      sv-192
                      sv-208
                      sv-224
                      sv-240
                      sv-272
                      )
                     )
                   (-> s4-2 ppointer)
                   )
                 )
               )
             )
           )
         )
        ((= v1-0 'interesting)
         (+! (-> obj interest) 1)
         (let ((v1-67 (process->ppointer obj)))
           (set-setting! 'handle-of-interest v1-67 0.0 (-> v1-67 0 pid))
           )
         )
        ((= v1-0 'uninteresting)
         (+! (-> obj interest) -1)
         (when (<= (-> obj interest) 0)
           (set! (-> obj interest) 0)
           (remove-setting! 'handle-of-interest)
           )
         )
        ((= v1-0 'death-end)
         (let ((v1-74 (-> obj root-override2 root-prim)))
           (set! (-> v1-74 prim-core collide-as) (collide-spec))
           (set! (-> v1-74 prim-core collide-with) (collide-spec))
           )
         0
         ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
         )
        (else
          ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defstate idle (rhino)
  :virtual #t
  :enter (behavior ()
    (remove-setting! 'sound-mode)
    (remove-setting! 'sound-excitement)
    (set! (-> self interest) 0)
    (let ((t9-2 (-> (method-of-type nav-enemy idle) enter)))
      (if t9-2
          (t9-2)
          )
      )
    (logclear! (-> self enemy-flags) (enemy-flag enable-on-active))
    (none)
    )
  :exit (behavior ()
    (local-vars (v0-1 enemy-flag))
    (let ((t9-0 (-> (method-of-type nav-enemy idle) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 (-> self enemy-flags)))
      (if (logtest? v1-4 (enemy-flag checking-water))
          (set! v0-1 (logior v1-4 (enemy-flag enable-on-active)))
          (set! v0-1 (logclear v1-4 (enemy-flag enable-on-active)))
          )
      )
    (set! (-> self enemy-flags) v0-1)
    (none)
    )
  :trans (behavior ()
    (cond
      ((-> self wall)
       (debug-draw (-> self path-intro))
       (when (and (>= (the-as int (-> self focus aware)) (the-as int (-> self charge-aware)))
                  *target*
                  (and (>= 122880.0 (vector-vector-distance (-> self root-override2 trans) (-> *target* control trans)))
                       (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                       )
                  )
         (process-entity-status! self (entity-perm-status subtask-complete) #t)
         (go-virtual charge)
         )
       )
      (else
        (if (and (>= (- (current-time) (-> self state-time)) (-> self state-timeout))
                 (> (the-as int (-> self focus aware)) 0)
                 )
            (go-virtual active)
            )
        )
      )
    (none)
    )
  )

(defstate die (rhino)
  :virtual #t
  :enter (behavior ()
    (remove-setting! 'sound-mode)
    (dispose! self)
    (set! (-> self hit-points) 0)
    0
    (none)
    )
  :code (behavior ()
    (set! (-> self smush-target) (the-as smush-control #t))
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2))
          (gp-0 #t)
          )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override die-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override die-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (when (and gp-0 (>= (ja-frame-num 0) (-> self frame-die-smush)))
          (activate! *camera-smush-control* 819.2 37 600 1.0 0.1 (-> self clock))
          (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.5))
          (set! gp-0 #f)
          )
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  )

(defstate hit (rhino)
  :virtual #t
  :code (behavior ()
    (local-vars (v1-67 enemy-flag) (v1-75 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override hit-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override hit-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      (let ((gp-0 #t))
        (ja-no-eval :group! rhino-victory-hit2-ja
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-victory-hit2-ja) frames num-frames) -1)) f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (when (and gp-0 (>= (ja-frame-num 0) 5.0))
            (activate! *camera-smush-control* 819.2 37 600 1.0 0.1 (-> self clock))
            (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.5))
            (set! gp-0 #f)
            )
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    (ja-channel-push! 1 (seconds 0.075))
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-66 (-> self enemy-flags)))
      (if (logtest? v1-66 (enemy-flag checking-water))
          (set! v1-67 (logior v1-66 (enemy-flag enable-on-active)))
          (set! v1-67 (logclear v1-66 (enemy-flag enable-on-active)))
          )
      )
    (set! (-> self enemy-flags) v1-67)
    (if (logtest? (-> self enemy-flags) (enemy-flag look-at-move-dest))
        (set! (-> self mask) (logior (process-mask collectable) (-> self mask)))
        (logclear! (-> self mask) (process-mask collectable))
        )
    (let ((v1-74 (-> self enemy-flags)))
      (if (logtest? (enemy-flag no-initial-move-to-ground) v1-74)
          (set! v1-75 (logior (enemy-flag check-water-backup) v1-74))
          (set! v1-75 (logclear v1-74 (enemy-flag check-water-backup)))
          )
      )
    (set! (-> self enemy-flags) v1-75)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (logclear! (-> self focus-status) (focus-status hit))
    (go-hostile self)
    (none)
    )
  )

(defmethod damage-amount-from-attack rhino ((obj rhino) (arg0 process) (arg1 event-message-block))
  "@returns the amount of damage taken from an attack.  This can come straight off the [[attack-info]] or via [[penetrate-using->damage]]"
  (-> arg1 param 1)
  (let ((f30-0 (the float (penetrate-using->damage (the-as penetrate (-> obj incoming penetrate-using))))))
    (cond
      ((rhino-method-182 obj arg0 arg1)
       (set! (-> obj stomach-touched-once?) #t)
       (the int (* 4.0 f30-0))
       )
      ((logtest? #xc0000 (-> obj incoming penetrate-using))
       (if (and (logtest? #x40000 (-> obj incoming penetrate-using))
                (logtest? #x80000 (-> obj incoming penetrate-using))
                )
           #x420c0000
           (the int (* 1.8 f30-0))
           )
       )
      ((logtest? #x20000 (-> obj incoming penetrate-using))
       (the int (* 2.0 f30-0))
       )
      (else
        (the int (* 0.5 f30-0))
        )
      )
    )
  )

;; WARN: Return type mismatch symbol vs object.
(defmethod enemy-method-75 rhino ((obj rhino) (arg0 process) (arg1 event-message-block))
  (let* ((touch-entry (the-as touching-shapes-entry (-> arg1 param 0)))
         (s3-0 arg0)
         (v1-0 (if (type? s3-0 process-focusable)
                   s3-0
                   )
               )
         )
    (the-as
      object
      (when (and (the-as uint touch-entry) v1-0)
        (cond
          ((and (focus-test? obj dangerous) ((method-of-type touching-shapes-entry prims-touching-action?)
                                             touch-entry
                                             (-> obj root-override2)
                                             (collide-action deadly)
                                             (collide-action)
                                             )
                )
           (let ((a3-2 (if ((method-of-type touching-shapes-entry prims-touching-action?)
                            touch-entry
                            (-> obj root-override2)
                            (collide-action persistent-attack)
                            (collide-action)
                            )
                           (-> obj persistent-attack-id)
                           (-> obj attack-id)
                           )
                       )
                 )
             (enemy-method-104 obj arg0 touch-entry a3-2)
             )
           )
          (((method-of-type touching-shapes-entry prims-touching-action?)
            touch-entry
            (-> obj root-override2)
            (collide-action no-standon)
            (collide-action)
            )
           (send-shoves (-> obj root-override2) arg0 touch-entry 0.7 6144.0 16384.0)
           )
          )
        )
      )
    )
  )

(defmethod enemy-method-104 rhino ((obj rhino) (arg0 process) (arg1 touching-shapes-entry) (arg2 uint))
  (if (and (-> obj next-state) (= (-> obj next-state name) 'victory))
      'attack-or-shove
      'attack
      )
  (let* ((s2-0 (if (-> obj smush-target)
                   'smush
                   (-> obj enemy-info-override attack-mode)
                   )
               )
         (s1-0 arg0)
         (a0-3 (if (type? s1-0 process-focusable)
                   s1-0
                   )
               )
         (s1-1 (new 'stack-no-clear 'vector))
         )
    (vector-! s1-1 (get-trans (the-as process-focusable a0-3) 0) (-> obj root-override2 trans))
    (set! (-> s1-1 y) 0.0)
    (vector-normalize! s1-1 1.0)
    (vector+float*! s1-1 s1-1 (-> obj root-override2 transv) 0.5)
    (set! (-> s1-1 y) 20480.0)
    (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-6 from) (process->ppointer self))
      (set! (-> a1-6 num-params) 2)
      (set! (-> a1-6 message) 'attack)
      (set! (-> a1-6 param 0) (the-as uint arg1))
      (let ((v1-16 (new 'static 'attack-info :mask (attack-info-mask vector mode angle id))))
        (set! (-> v1-16 id) arg2)
        (set! (-> v1-16 angle) 'front)
        (set! (-> v1-16 vector quad) (-> s1-1 quad))
        (set! (-> v1-16 mode) s2-0)
        (set! (-> a1-6 param 1) (the-as uint v1-16))
        )
      (when (send-event-function arg0 a1-6)
        (enemy-method-105 obj arg0)
        #t
        )
      )
    )
  )

(defstate active (rhino)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  )

(defstate notice (rhino)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy notice) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  )

(defstate victory (rhino)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy victory) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core collide-as)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core collide-with)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core action)
          (collide-action deadly)
          )
    (set! (-> self can-hit?) #t)
    (let ((v1-13 (-> self nav state)))
      (set! (-> v1-13 speed) 0.0)
      )
    0
    (+! (-> self victory-count) 1)
    (if (and (= (-> self victory-count) 3) (not (-> self stomach-touched-once?)))
        (talker-spawn-func (-> *talker-speech* 59) *entity-pool* (target-pos 0) (the-as region #f))
        )
    (none)
    )
  :exit (behavior ()
    (set! (-> self can-hit?) #f)
    (set! (-> self smush-target) #f)
    (let ((t9-0 (-> (method-of-type nav-enemy victory) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core collide-as)
          (collide-spec)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core collide-with)
          (collide-spec)
          )
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (ja-no-eval :group! rhino-victory-begin-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-victory-begin-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core collide-as)
          (collide-spec enemy)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core collide-with)
          (collide-spec jak bot player-list)
          )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core action)
          (collide-action solid no-standon)
          )
    (until #f
      (ja-no-eval :group! rhino-victory-loop-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-victory-loop-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (let ((gp-0 (handle->process (-> self focus handle))))
        (cond
          (gp-0
            (if (or (< 10240.0
                       (vector-vector-xz-distance (get-trans (the-as process-focusable gp-0) 0) (-> self root-override2 trans))
                       )
                    (and gp-0
                         (not (logtest? (-> (the-as process-focusable gp-0) focus-status) (focus-status disable dead ignore grabbed)))
                         )
                    )
                (goto cfg-25)
                )
            )
          (else
            (goto cfg-25)
            )
          )
        )
      )
    #f
    (label cfg-25)
    (set! (-> self can-hit?) #f)
    (set! (-> self smush-target) (the-as smush-control #t))
    (let* ((v1-68 *game-info*)
           (a0-24 (+ (-> v1-68 attack-id) 1))
           )
      (set! (-> v1-68 attack-id) a0-24)
      (set! (-> self attack-id) a0-24)
      )
    (set! (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 1 prim-core action)
          (collide-action deadly)
          )
    (logior! (-> self focus-status) (focus-status dangerous))
    (let* ((v1-72 *game-info*)
           (a0-29 (+ (-> v1-72 attack-id) 1))
           )
      (set! (-> v1-72 attack-id) a0-29)
      (set! (-> self attack-id) a0-29)
      )
    (let ((gp-1 #t))
      (ja-no-eval :group! rhino-victory-end-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-victory-end-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (when (and gp-1 (>= (ja-frame-num 0) 12.0))
          (activate! *camera-smush-control* 819.2 37 600 1.0 0.1 (-> self clock))
          (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.5))
          (set! gp-1 #f)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (let ((a0-37 (handle->process (-> self focus handle))))
      (cond
        (a0-37
          (cond
            ((< 22528.0
                (vector-vector-xz-distance (get-trans (the-as process-focusable a0-37) 0) (-> self root-override2 trans))
                )
             (ja-channel-push! 1 (seconds 0.075))
             (react-to-focus self)
             )
            (else
              (go-virtual run-away)
              )
            )
          )
        (else
          (ja-channel-push! 1 (seconds 0.075))
          (react-to-focus self)
          )
        )
      )
    (none)
    )
  )

(defstate run-away (rhino)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior rhino) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (nav-enemy-method-166 self)
    (let ((v1-4 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-4 enemy-flags)))
          (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-4 enemy-flags))))
          )
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-4 enemy-flags))))
      (set! (-> v1-4 nav callback-info) (-> v1-4 enemy-info-override callback-info))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-7 enemy-flags))))
      )
    0
    (set! (-> self root-override2 penetrate-using) (penetrate generic-attack lunge))
    (enemy-method-49 self)
    (let ((s5-0 (-> self path curve num-cverts)))
      (if (<= s5-0 0)
          (go process-drawable-art-error "no path")
          )
      0
      (let ((f30-0 0.0)
            (s4-0 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (dotimes (s3-0 s5-0)
          (get-point-in-path! (-> self path) s4-0 (the float s3-0) 'interp)
          (let ((f0-2 (vector-vector-xz-distance s4-0 (-> self root-override2 trans))))
            (when (< f30-0 f0-2)
              (set! f30-0 f0-2)
              (set! (-> gp-0 quad) (-> s4-0 quad))
              )
            )
          )
        (let ((v1-25 (-> self nav state)))
          (logclear! (-> v1-25 flags) (nav-state-flag directional-mode))
          (logior! (-> v1-25 flags) (nav-state-flag target-poly-dirty))
          (set! (-> v1-25 target-post quad) (-> gp-0 quad))
          )
        )
      )
    0
    (none)
    )
  :trans (behavior ()
    (if (>= (- (current-time) (-> self state-time)) (seconds 1.5))
        (go-virtual active)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.05))
    (until #f
      (ja-no-eval :group! rhino-charge-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-charge-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (nav-enemy-travel-post)
    (none)
    )
  )

(defstate hostile (rhino)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'sound-mode #f 0.0 1)
    (set-setting! 'sound-excitement 'abs 0.0 0)
    (let ((t9-2 (-> (method-of-type nav-enemy hostile) enter)))
      (if t9-2
          (t9-2)
          )
      )
    (set! (-> self charge-straight) #f)
    (nav-enemy-method-166 self)
    (set! (-> self state-time) (current-time))
    (logclear! (-> self enemy-flags) (enemy-flag look-at-focus))
    (none)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy hostile) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((s3-0 (handle->process (-> self focus handle))))
      (when s3-0
        (let ((s2-0 (get-trans (the-as process-focusable s3-0) 0))
              (s5-0 (new 'stack-no-clear 'vector))
              (s1-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              (gp-0 (new 'stack-no-clear 'vector))
              )
          0.0
          0.0
          (vector-z-quaternion! s5-0 (-> self root-override2 quat))
          (vector-! s1-0 s2-0 (-> self root-override2 trans))
          (let ((f28-0 (vector-dot s1-0 s5-0)))
            (vector-normalize! s1-0 1.0)
            (let ((f30-0 (vector-dot s1-0 s5-0)))
              (vector-! gp-0 s2-0 (-> self root-override2 trans))
              (vector-normalize! gp-0 (+ 16384.0 (vector-length gp-0)))
              (vector+! s4-0 (-> self root-override2 trans) gp-0)
              (when (>= (- (current-time) (-> self state-time)) (-> self reaction-time))
                (if (and (< (vector-vector-xz-distance (get-trans (the-as process-focusable s3-0) 0) (-> self root-override2 trans))
                            40960.0
                            )
                         (< 0.9 f30-0)
                         )
                    (set! (-> self charge-straight) #t)
                    )
                )
              (cond
                ((-> self charge-straight)
                 (cond
                   ((>= (- (current-time) (-> self state-time)) (-> self reaction-time))
                    (if (< (vector-vector-xz-distance (get-trans (the-as process-focusable s3-0) 0) (-> self root-override2 trans))
                           20480.0
                           )
                        (go-virtual attack)
                        )
                    (when (and (< f30-0 0.7) (>= 9.0 (ja-frame-num 0)))
                      (set! (-> self charge-straight) #f)
                      (go-virtual stop-run)
                      )
                    )
                   (else
                     (set! (-> self dest quad) (-> s4-0 quad))
                     )
                   )
                 )
                ((and (< f28-0 8192.0)
                      (and (>= (- (current-time) (-> self state-time)) (seconds 2)) (>= 9.0 (ja-frame-num 0)))
                      )
                 (go-virtual stop-run)
                 )
                (else
                  (set! (-> self dest quad) (-> s4-0 quad))
                  )
                )
              )
            )
          (vector-float*! gp-0 s5-0 40960.0)
          (let* ((s5-1 (-> self nav))
                 (v1-67 s5-1)
                 (a0-31 (-> self root-override2 trans))
                 (a1-12 (new 'stack-no-clear 'nav-find-poly-parms))
                 )
            (vector-! (-> a1-12 point) a0-31 (-> v1-67 state mesh bounds))
            (set! (-> a1-12 y-threshold) (-> v1-67 nearest-y-threshold))
            (set! (-> a1-12 ignore) (the-as uint 2))
            (let ((s3-1 (find-poly-containing-point-local (-> v1-67 state mesh) a1-12))
                  (s4-2 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
                  )
              (when s3-1
                (clamp-vector-to-mesh-no-gaps s5-1 (-> self root-override2 trans) s3-1 gp-0 s4-2)
                (when (-> s4-2 found-boundary)
                  (if (and (< (vector-length gp-0) 32768.0) (and (-> self charge-straight) (>= 9.0 (ja-frame-num 0))))
                      (go-virtual stop-run)
                      )
                  )
                )
              )
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data (-> self enemy-info-override hostile-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    (none)
    )
  )

(defstate attack (rhino)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior rhino) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (logior! (-> self focus-status) (focus-status dangerous))
    (let* ((v1-4 *game-info*)
           (a0-2 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) a0-2)
      (set! (-> self attack-id) a0-2)
      )
    (set! (-> self root-override2 penetrate-using) (penetrate generic-attack lunge))
    (enemy-method-49 self)
    (nav-enemy-method-166 self)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (new 'stack-no-clear 'vector)
      (vector-z-quaternion! gp-0 (-> self root-override2 quat))
      (vector-float*! gp-0 gp-0 40960.0)
      (vector+! (-> self dest) (-> self root-override2 trans) gp-0)
      )
    (let ((a0-10 (-> self nav state))
          (v1-17 (-> self dest))
          )
      (logclear! (-> a0-10 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-10 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-10 target-post quad) (-> v1-17 quad))
      )
    0
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :trans (behavior ()
    (enemy-method-49 self)
    (none)
    )
  :code (behavior ()
    (let ((gp-0 #f))
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! rhino-attack-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-attack-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (if (logtest? (-> self enemy-flags) (enemy-flag look-at-focus))
            (set! gp-0 #t)
            )
        (suspend)
        (ja :num! (seek!))
        )
      (if gp-0
          (go-virtual victory)
          (go-hostile self)
          )
      )
    (none)
    )
  :post (the-as (function none :behavior rhino) nav-enemy-travel-post)
  )

(defmethod nav-enemy-method-142 rhino ((obj rhino) (arg0 nav-control))
  (if (-> obj in-stop-run)
      (quaternion*!
        (-> obj root-override2 quat)
        (-> obj quat)
        (quaternion-axis-angle! (new 'stack-no-clear 'quaternion) 0.0 1.0 0.0 (* 182.04445 (* 180.0 (-> obj angle))))
        )
      ((method-of-type nav-enemy nav-enemy-method-142) obj arg0)
      )
  0
  (none)
  )

(defstate stop-run (rhino)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior rhino) enemy-event-handler)
  :enter (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (new 'stack-no-clear 'vector)
      (vector-z-quaternion! gp-0 (-> self root-override2 quat))
      (vector-float*! gp-0 gp-0 40960.0)
      (vector+! (-> self dest) (-> self root-override2 trans) gp-0)
      (let* ((s5-0 (-> self nav))
             (v1-6 s5-0)
             (a0-5 (-> self root-override2 trans))
             (a1-3 (new 'stack-no-clear 'nav-find-poly-parms))
             )
        (vector-! (-> a1-3 point) a0-5 (-> v1-6 state mesh bounds))
        (set! (-> a1-3 y-threshold) (-> v1-6 nearest-y-threshold))
        (set! (-> a1-3 ignore) (the-as uint 2))
        (let ((s3-0 (find-poly-containing-point-local (-> v1-6 state mesh) a1-3))
              (s4-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
              )
          (when s3-0
            (clamp-vector-to-mesh-no-gaps s5-0 (-> self root-override2 trans) s3-0 gp-0 s4-0)
            (if (-> s4-0 found-boundary)
                (vector+! (-> self dest) (-> self root-override2 trans) gp-0)
                )
            )
          )
        )
      )
    (let ((a0-12 (-> self nav state))
          (v1-18 (-> self dest))
          )
      (logclear! (-> a0-12 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-12 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-12 target-post quad) (-> v1-18 quad))
      )
    0
    (set! (-> self skid-speed) 57344.0)
    (set! (-> self in-stop-run) #t)
    (quaternion-copy! (-> self quat) (-> self root-override2 quat))
    (set! (-> self angle) 0.0)
    (set! (-> self angle-speed) 0.0)
    (set! (-> self num-hit-flinch) 0)
    0
    (none)
    )
  :exit (behavior ()
    (let ((v1-1 (-> self nav state)))
      (set! (-> v1-1 speed) 0.0)
      )
    0
    (let ((v1-3 (-> self nav)))
      (set! (-> v1-3 target-speed) (-> self enemy-info-override walk-travel-speed))
      )
    0
    (set! (-> self in-stop-run) #f)
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! rhino-skid-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-skid-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (set! (-> self skid-speed) (fmax 0.0 (- (-> self skid-speed) (* 32768.0 (-> self clock seconds-per-frame)))))
      (suspend)
      (ja :num! (seek!))
      )
    (let ((a0-5 (handle->process (-> self focus handle)))
          (v1-30 0)
          )
      (when a0-5
        (let ((s5-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              (gp-0 (new 'stack-no-clear 'vector))
              )
          0.0
          (vector-! s5-0 (get-trans (the-as process-focusable a0-5) 0) (-> self root-override2 trans))
          (vector-normalize! s5-0 1.0)
          (vector-x-quaternion! gp-0 (-> self root-override2 quat))
          (vector-z-quaternion! s4-0 (-> self root-override2 quat))
          (set! (-> self angle-speed) (* 0.5 (- 1.0 (vector-dot s5-0 s4-0))))
          (set! v1-30 (cond
                        ((< (vector-dot s5-0 gp-0) 0.0)
                         (set! v1-30 (-> self anim-skid-right))
                         (set! (-> self angle-speed) (- (-> self angle-speed)))
                         v1-30
                         )
                        (else
                          (-> self anim-skid-left)
                          )
                        )
                )
          )
        )
      (ja-no-eval :group! (-> self draw art-group data v1-30)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data v1-30)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      )
    (until (ja-done? 0)
      (set! (-> self skid-speed) (fmax 0.0 (- (-> self skid-speed) (* 32768.0 (-> self clock seconds-per-frame)))))
      (let ((v1-45 (-> self nav)))
        (set! (-> v1-45 target-speed) (-> self skid-speed))
        )
      0
      (if (and (>= (ja-frame-num 0) 0.0) (>= 15.0 (ja-frame-num 0)))
          (+! (-> self angle) (* (-> self angle-speed) (-> self clock seconds-per-frame)))
          )
      (let ((a0-20 (-> self nav state))
            (v1-54 (-> self dest))
            )
        (logclear! (-> a0-20 flags) (nav-state-flag directional-mode))
        (logior! (-> a0-20 flags) (nav-state-flag target-poly-dirty))
        (set! (-> a0-20 target-post quad) (-> v1-54 quad))
        )
      0
      (suspend)
      (ja :num! (seek!))
      )
    (if (zero? (-> self num-hit-flinch))
        (go-virtual victory)
        (go-virtual hostile)
        )
    (none)
    )
  :post (the-as (function none :behavior rhino) nav-enemy-travel-post)
  )

(defstate charge (rhino)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior rhino) enemy-event-handler)
  :enter (behavior ()
    (set-setting! 'sound-mode #f 0.0 1)
    (set-setting! 'sound-excitement 'abs 0.0 0)
    (set! (-> self state-time) (current-time))
    (nav-enemy-method-166 self)
    (let ((v1-8 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-8 enemy-flags)))
          (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-8 enemy-flags))))
          )
      (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-8 enemy-flags))))
      (set! (-> v1-8 nav callback-info) (-> v1-8 enemy-info-override callback-info))
      )
    0
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-11 enemy-flags))))
      )
    0
    (let* ((gp-0 (get-point-in-path! (-> self path-intro) (new 'stack-no-clear 'vector) 0.0 'exact))
           (v1-15 (get-point-in-path! (-> self path-intro) (new 'stack-no-clear 'vector) 1.0 'exact))
           (s5-1 (vector-! (new 'stack-no-clear 'vector) v1-15 gp-0))
           )
      (set! (-> s5-1 y) 0.0)
      (vector-xz-normalize! s5-1 163840.0)
      (vector+! (-> self dest) gp-0 s5-1)
      )
    (none)
    )
  :exit (behavior ()
    (set! (-> self wall) #f)
    (none)
    )
  :code (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'trigger)
      (let ((t9-0 send-event-function)
            (v1-2 (-> self wall))
            )
        (t9-0
          (if v1-2
              (-> v1-2 child 3)
              )
          a1-0
          )
        )
      )
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! rhino-attack-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-attack-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! rhino-charge-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-charge-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-no-eval :group! rhino-charge-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim rhino-charge-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual victory)
    (none)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    (none)
    )
  )

(defstate stare (rhino)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy stare) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (none)
    )
  )

(defstate circling (rhino)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy circling) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-5 (-> self nav state)))
      (set! (-> v1-5 speed) 0.0)
      )
    0
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (and v1-2 (= v1-2 (-> self draw art-group data (-> self enemy-info-override walk-anim))))
        (ja-no-eval :num! (seek!))
        (while (not (ja-done? 0))
          (suspend)
          (ja-eval)
          )
        )
      )
    (until #f
      (let ((v1-15 self))
        (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-15 enemy-flags)))
            (set! (-> v1-15 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-15 enemy-flags))))
            )
        (set! (-> v1-15 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-15 enemy-flags))))
        (set! (-> v1-15 nav callback-info) (-> v1-15 enemy-info-override callback-info))
        )
      0
      (let ((v1-18 self))
        (set! (-> v1-18 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-18 enemy-flags))))
        )
      0
      (let ((v1-20 (-> self nav)))
        (set! (-> v1-20 target-speed) 4096.0)
        )
      0
      (let ((v1-22 (-> self nav)))
        (set! (-> v1-22 acceleration) (-> self enemy-info-override run-acceleration))
        )
      0
      (let ((v1-24 (-> self nav)))
        (set! (-> v1-24 turning-acceleration) (-> self enemy-info-override run-turning-acceleration))
        )
      0
      (let ((gp-0 (-> self draw art-group data (-> self enemy-info-override walk-anim))))
        (let ((v1-32 (ja-group)))
          (if (not (and v1-32 (= v1-32 gp-0)))
              (ja-channel-push! 1 (seconds 0.1))
              )
          )
        (let ((s5-0 (get-rand-int self 8))
              (f30-0 (get-rand-float-range self 0.9 1.1))
              )
          (while (nonzero? s5-0)
            (+! s5-0 -1)
            (ja-no-eval :group! gp-0
                        :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)) f30-0)
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          )
        )
      (when (< 20480.0 (vector-vector-xz-distance (-> self focus-pos) (-> self root-override2 trans)))
        (let ((v1-59 self))
          (set! (-> v1-59 enemy-flags) (the-as enemy-flag (logclear (-> v1-59 enemy-flags) (enemy-flag enemy-flag36))))
          (set! (-> v1-59 nav callback-info) *nav-enemy-null-callback-info*)
          )
        0
        (let ((v1-62 self))
          (set! (-> v1-62 enemy-flags) (the-as enemy-flag (logclear (-> v1-62 enemy-flags) (enemy-flag enemy-flag37))))
          )
        0
        (vector-reset! (-> self root-override2 transv))
        (let ((v1-68 (ja-group)))
          (if (not (and v1-68 (= v1-68 (-> self draw art-group data (-> self enemy-info-override victory-anim)))))
              (ja-channel-push! 1 (seconds 0.1))
              )
          )
        (let ((f30-2 (get-rand-float-range self 0.9 1.1)))
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override victory-anim))
                      :num! (seek!
                        (the float
                             (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override victory-anim)))
                                    frames
                                    num-frames
                                    )
                                -1
                                )
                             )
                        f30-2
                        )
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek! max f30-2))
            )
          )
        )
      )
    #f
    (none)
    )
  )

(defmethod init-enemy-collision! rhino ((obj rhino))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 6) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 7))
      (set! (-> s4-0 prim-core collide-as) (collide-spec enemy))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak bot crate obstacle hit-by-others-list player-list)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid semi-solid deadly no-standon))
      (set! (-> s4-0 transform-index) 4)
      (set-vector! (-> s4-0 local-sphere) 0.0 -2048.0 0.0 27648.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-13 prim-core collide-with) (collide-spec backgnd jak bot crate hit-by-others-list player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-13 transform-index) 4)
      (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 8192.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 1))))
      (set! (-> v1-15 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-15 transform-index) 4)
      (set-vector! (-> v1-15 local-sphere) 0.0 0.0 2048.0 10240.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-17 prim-core collide-with) (collide-spec backgnd jak bot crate hit-by-others-list player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid no-standon))
      (set! (-> v1-17 transform-index) 16)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 6144.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 2))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-19 prim-core action) (collide-action semi-solid deadly))
      (set! (-> v1-19 transform-index) 6)
      (set-vector! (-> v1-19 local-sphere) 0.0 -2048.0 0.0 7372.8)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-21 prim-core action) (collide-action deadly persistent-attack))
      (set! (-> v1-21 transform-index) 4)
      (set-vector! (-> v1-21 local-sphere) 0.0 0.0 -3072.0 4915.2)
      )
    (let ((v1-23 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-23 prim-core collide-as) (collide-spec enemy))
      (set! (-> v1-23 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-23 prim-core action) (collide-action deadly persistent-attack))
      (set! (-> v1-23 transform-index) 21)
      (set-vector! (-> v1-23 local-sphere) 0.0 2252.8 0.0 3276.8)
      )
    (set! (-> s5-0 nav-radius) 3686.4)
    (let ((v1-25 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-25 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-25 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 3))
    (set! (-> obj root-override2) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch process-focusable vs rhino.
(defmethod relocate rhino ((obj rhino) (arg0 int))
  (if (nonzero? (-> obj path-intro))
      (&+! (-> obj path-intro) arg0)
      )
  (the-as
    rhino
    ((the-as (function process-focusable int process-focusable) (find-parent-method rhino 7)) obj arg0)
    )
  )

(defmethod init-enemy! rhino ((obj rhino))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (stack-size-set! (-> obj main-thread) 256)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-rhino" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj skel generate-frame-function) create-interpolated2-joint-animation-frame)
  (init-enemy-behaviour-and-stats! obj *rhino-nav-enemy-info*)
  (let ((v1-8 (-> obj neck)))
    (set! (-> v1-8 up) (the-as uint 1))
    (set! (-> v1-8 nose) (the-as uint 2))
    (set! (-> v1-8 ear) (the-as uint 0))
    (set-vector! (-> v1-8 twist-max) 10922.667 12743.111 0.0 1.0)
    (set! (-> v1-8 ignore-angle) 18204.445)
    )
  (set! (-> obj wall) #f)
  (set! (-> obj wall) (the-as rhino-wall (entity-actor-lookup (-> obj entity) 'alt-actor 0)))
  (when (-> obj wall)
    (set! (-> obj path-intro) (new 'process 'path-control obj 'intro 0.0 (-> obj entity) #f))
    (if (-> obj path-intro)
        (logior! (-> obj path-intro flags) (path-control-flag display draw-line draw-point draw-text))
        )
    (when (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (format #t "~S : sub task done~%" (-> obj name))
      (get-point-in-path! (-> obj path-intro) (-> obj root-override2 trans) 1.0 'exact)
      (set! (-> obj wall) #f)
      )
    )
  (set! (-> obj charge-aware) (the-as uint 1))
  (if (>= (res-lump-value (-> obj entity) 'extra-id int :default (the-as uint128 -1) :time -1000000000.0) 0)
      (set! (-> obj charge-aware) (the-as uint 2))
      )
  (set! (-> obj charge-straight) #f)
  (set! (-> obj in-stop-run) #f)
  (set! (-> obj smush-target) #f)
  (set! (-> obj num-hit-flinch) 0)
  (set! (-> obj can-hit?) #f)
  (set! (-> obj anim-skid-left) 21)
  (set! (-> obj anim-skid-right) 22)
  (set! (-> obj anim-victory-hit) 23)
  (set! (-> obj interest) 0)
  (set! (-> obj victory-count) (the-as uint 0))
  (set! (-> obj stomach-touched-once?) #f)
  (add-connection
    *part-engine*
    obj
    6
    obj
    318
    (new 'static 'vector :x 1433.6 :y -1105.92 :z 1925.12 :w 163840.0)
    )
  (add-connection
    *part-engine*
    obj
    6
    obj
    318
    (new 'static 'vector :x -1433.6 :y -1105.92 :z 1925.12 :w 163840.0)
    )
  (let ((v1-38 (-> obj nav)))
    (set! (-> v1-38 speed-scale) 1.0)
    )
  0
  (set-gravity-length (-> obj root-override2 dynam) 573440.0)
  (logior! (-> obj nav flags) (nav-control-flag momentum-ignore-heading))
  (logior! (-> obj focus-status) (focus-status dangerous))
  (logior! (-> obj enemy-flags) (enemy-flag check-water))
  0
  (none)
  )
