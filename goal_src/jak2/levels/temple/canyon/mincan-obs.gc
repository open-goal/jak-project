;;-*-Lisp-*-
(in-package goal)

;; name: mincan-obs.gc
;; name in dgo: mincan-obs
;; dgos: MCN

(declare-type mincan-lighthouse process-drawable)

;; DECOMP BEGINS

(deftype water-anim-mincan (water-anim)
  ()
  :heap-base #x80
  :method-count-assert 29
  :size-assert         #x100
  :flag-assert         #x1d00800100
  )


(define ripple-for-water-anim-mincan (new 'static 'ripple-wave-set
                                       :count 3
                                       :converted #f
                                       :normal-scale 1.0
                                       :wave (new 'static 'inline-array ripple-wave 4
                                         (new 'static 'ripple-wave :scale 5.0 :xdiv -1 :speed 2.75)
                                         (new 'static 'ripple-wave :scale 5.0 :xdiv -2 :zdiv 1 :speed 1.53)
                                         (new 'static 'ripple-wave :scale 5.0 :xdiv 1 :zdiv 1 :speed 2.61)
                                         (new 'static 'ripple-wave)
                                         )
                                       )
        )

(defmethod art-init! water-anim-mincan ((obj water-anim-mincan))
  "Initialize a [[water-anim]]'s [[skeleton-group]], joints and ambience."
  (let ((t9-0 (method-of-type water-anim art-init!)))
    (t9-0 obj)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> obj draw ripple) v1-2)
    (set-vector! (-> obj draw color-mult) 0.01 0.45 0.5 0.75)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-water-anim-mincan)
    )
  0
  (none)
  )

(deftype mincan-lighthouse-lens (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (idle () _type_ :state 20)
    (erect () _type_ :state 21)
    )
  )


(defskelgroup skel-mincan-lighthouse-lens mincan-lighthouse 5 7
              ((6 (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              :origin-joint-index 9
              )

(defstate idle (mincan-lighthouse-lens)
  :virtual #t
  :trans (behavior ()
    (if (task-node-closed? (game-task-node canyon-insert-items-resolution))
        (go-virtual erect)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 7)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 7)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-lighthouse-lens) ja-post)
  )

(defstate erect (mincan-lighthouse-lens)
  :virtual #t
  :code (behavior ()
    (ja-channel-push! 1 0)
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 8)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 8)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-lighthouse-lens) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mincan-lighthouse-lens ((obj mincan-lighthouse-lens) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-mincan-lighthouse-lens" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior mincan-lighthouse-lens-init-by-other mincan-lighthouse-lens ((arg0 mincan-lighthouse) (arg1 entity-actor))
  (set! (-> self root) (new 'process 'trsqv))
  (process-drawable-from-entity! self arg1)
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-mincan-lighthouse-lens" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (go-virtual idle)
  (none)
  )

(deftype mincan-lighthouse (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (idle () _type_ :state 20)
    (erect () _type_ :state 21)
    )
  )


(defskelgroup skel-mincan-lighthouse mincan-lighthouse 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 -20 0 62.5)
              :origin-joint-index 6
              )

(defstate idle (mincan-lighthouse)
  :virtual #t
  :trans (behavior ()
    (if (task-node-closed? (game-task-node canyon-insert-items-resolution))
        (go-virtual erect)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 2)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-lighthouse) ja-post)
  )

(defstate erect (mincan-lighthouse)
  :virtual #t
  :code (behavior ()
    (ja-channel-push! 1 0)
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 3)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-lighthouse) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mincan-lighthouse ((obj mincan-lighthouse) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mincan-lighthouse" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (process-spawn mincan-lighthouse-lens obj arg0 :to obj)
  (go (method-of-object obj idle))
  (none)
  )

(deftype mincan-lens (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (closed () _type_ :state 20)
    (open () _type_ :state 21)
    )
  )


(defskelgroup skel-mincan-lens mincan-lens 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 5 0 15)
              :origin-joint-index 3
              )

(defstate closed (mincan-lens)
  :virtual #t
  :trans (behavior ()
    (if (task-node-closed? (game-task-node canyon-insert-items-resolution))
        (go-virtual open)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 0)
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 3)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-lens) transform-post)
  )

(defstate open (mincan-lens)
  :virtual #t
  :code (behavior ()
    (ja-channel-push! 1 0)
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 2)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-lens) transform-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mincan-lens ((obj mincan-lens) (arg0 entity-actor))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 7) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 8))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 81920.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-8 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 6) (the-as uint 0))))
      (set! (-> v1-8 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-8 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-8 prim-core action) (collide-action solid))
      (set! (-> v1-8 transform-index) 3)
      (set-vector! (-> v1-8 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 32768.0 8192.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 5) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 32768.0 0.0 28672.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 4)
      (set-vector! (-> v1-14 local-sphere) 0.0 12288.0 -36864.0 28672.0)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) 7)
      (set-vector! (-> v1-16 local-sphere) 0.0 12288.0 -36864.0 28672.0)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 10)
      (set-vector! (-> v1-18 local-sphere) 0.0 12288.0 -36864.0 28672.0)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) 13)
      (set-vector! (-> v1-20 local-sphere) 0.0 12288.0 -36864.0 28672.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-23 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-23 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-23 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mincan-lens" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj closed))
  (none)
  )

(deftype mincan-cogs (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-mincan-cogs mincan-cogs 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 0 0 70)
              :origin-joint-index 3
              )

(defstate idle (mincan-cogs)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mincan-cogs) ja-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mincan-cogs ((obj mincan-cogs) (arg0 entity-actor))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mincan-cogs" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object obj idle))
  (none)
  )
