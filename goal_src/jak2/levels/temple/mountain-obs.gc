;;-*-Lisp-*-
(in-package goal)

;; name: mountain-obs.gc
;; name in dgo: mountain-obs
;; dgos: MTN

;; DECOMP BEGINS

(define *dice-back-way-num* 0)

(define *dice-back-way* (new 'static 'boxed-array :type vector
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          (new 'static 'vector)
                          )
        )

(defskelgroup skel-mtn-dice-button mtn-dice-button mtn-dice-button-lod0-jg mtn-dice-button-idle-ja
              ((mtn-dice-button-lod0-mg (meters 20)) (mtn-dice-button-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1)
              )

(deftype mtn-dice-button (basebutton)
  ()
  :heap-base #xa0
  :method-count-assert 39
  :size-assert         #x120
  :flag-assert         #x2700a00120
  )


(defmethod basebutton-method-33 mtn-dice-button ((obj mtn-dice-button))
  "TODO - joint stuff"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-dice-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> obj button-status) (button-status pressed))
     (let ((s5-1 (-> obj skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> obj draw art-group data 3))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 3)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> obj skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> obj draw art-group data 3))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (transform-post)
  (none)
  )

(defmethod basebutton-method-34 mtn-dice-button ((obj mtn-dice-button))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod prepare-trigger-event! mtn-dice-button ((obj mtn-dice-button))
  "Sets `event-going-down` to `'trigger`"
  (logior! (-> obj button-status) (button-status button-status-4))
  (logior! (-> obj button-status) (button-status pressed))
  (set! (-> obj event-going-down) 'trigger)
  0
  (none)
  )

(defstate down-idle (mtn-dice-button)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton down-idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type basebutton down-idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (if (and (not (task-node-closed? (game-task-node mountain-shard-dice))) (< 1 *dice-back-way-num*))
        (go-virtual going-up)
        )
    (none)
    )
  )

(defstate going-down (mtn-dice-button)
  :virtual #t
  :enter (behavior ()
    (sound-play "dice-button")
    (press! self #t)
    (none)
    )
  )

(define *dice-position-array* (new 'static 'boxed-array :type vector
                                (new 'static 'vector :z 8192.0 :w 1.0)
                                (new 'static 'vector :z -8192.0 :w 1.0)
                                (new 'static 'vector :x 8192.0 :w 1.0)
                                (new 'static 'vector :x -8192.0 :w 1.0)
                                (new 'static 'vector :y -8192.0 :w 1.0)
                                (new 'static 'vector :y 8192.0 :w 1.0)
                                )
        )

(define *dice-angle-array* (new 'static 'boxed-array :type vector
                             (new 'static 'vector :y 16384.0)
                             (new 'static 'vector :y -16384.0)
                             (new 'static 'vector :z 32768.0)
                             (new 'static 'vector)
                             (new 'static 'vector :z 16384.0)
                             (new 'static 'vector :z -16384.0)
                             )
        )

(define *dice-offset-x* -663)

(define *dice-offset-z* -30)

(define *dice-world-array* (new 'static 'boxed-array :type uint16
                             #xffff
                             #xffc7
                             #x8007
                             #x7
                             #x3
                             #x3
                             #x7
                             #x8007
                             #xc007
                             #xe003
                             #xe003
                             #xe003
                             #xe003
                             #xe003
                             #xc003
                             #x8003
                             #x7
                             #xf
                             #xf
                             #xf00f
                             #xfc1f
                             #xfe3f
                             #xff3f
                             #xff3f
                             )
        )

(define *dice-good-way-array* (new 'static 'boxed-array :type uint16
                                #x0
                                #x100
                                #x100
                                #x1e0
                                #xe0
                                #xf0
                                #x30
                                #x38
                                #x18
                                #x18
                                #x78
                                #x70
                                #x70
                                #x40
                                #xc0
                                #x80
                                #x80
                                #x80
                                #x3c0
                                #x780
                                #x3e0
                                #x100
                                #x0
                                #x0
                                )
        )

(define *dice-blocked-array* (new 'static 'boxed-array :type uint16 :length 0 :allocated-length 26))

(define *dice-last-safe-position* (new 'static 'vector :x -2603417.5 :y 384983.03 :z -107683.84 :w 1.0))

(defpart 1491
  :init-specs ((:texture (new 'static 'texture-id :index #xbc :page #xc))
    (:num 1.0)
    (:scale-x (meters 1))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 128.0 64.0)
    (:b 128.0 64.0)
    (:a 128.0)
    (:vel-x (meters -0.006666667) (meters 0.006666667))
    (:vel-z (meters -0.006666667) (meters 0.006666667))
    (:rotvel-z (degrees 0.3))
    (:fade-g -0.4)
    (:fade-b -0.4)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    )
  )

(defun dice-wrong-way? ()
  (dotimes (v1-0 24)
    (if (nonzero? (logclear (-> *dice-blocked-array* v1-0) (-> *dice-good-way-array* v1-0)))
        (return #t)
        )
    )
  #f
  )

(deftype mtn-dice (process-drawable)
  ((root-override      collide-shape-moving           :offset        128)
   (incoming-attack-id uint32                         :offset-assert 200)
   (watervol           entity-actor                   :offset-assert 204)
   (face-matrix        matrix               6 :inline :offset-assert 208)
   (face-matrix-back   matrix               6 :inline :offset-assert 592)
   (face-status        int32                6         :offset-assert 976)
   (time-anim          float                          :offset-assert 1000)
   (speed-anim         float                          :offset-assert 1004)
   (rot-axis           vector               :inline   :offset-assert 1008)
   (rot-org            vector               :inline   :offset-assert 1024)
   (first              uint32                         :offset-assert 1040)
   (active             uint32                         :offset-assert 1044)
   (free-face          uint32                         :offset-assert 1048)
   (color              vector               :inline   :offset-assert 1056)
   (punch-anim         symbol                         :offset-assert 1072)
   (first-touch-time   time-frame                     :offset-assert 1080)
   (curtime            time-frame                     :offset-assert 1088)
   (hint-count         float                          :offset-assert 1096)
   )
  :heap-base #x3d0
  :method-count-assert 28
  :size-assert         #x44c
  :flag-assert         #x1c03d0044c
  (:methods
    (idle () _type_ :state 20)
    (idle-done () _type_ :state 21)
    (animate () _type_ :state 22)
    (fall () _type_ :state 23)
    (restart () _type_ :state 24)
    (mtn-dice-method-25 (_type_ int) none 25)
    (mtn-dice-method-26 (_type_ process-focusable touching-shapes-entry) touching-prims-entry 26)
    (mtn-dice-method-27 (_type_ collide-shape process-focusable touching-shapes-entry) none 27)
    )
  )


(defskelgroup skel-mtn-dice mtn-dice mtn-dice-lod0-jg mtn-dice-idle-ja
              ((mtn-dice-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100)
              )

(defmethod mtn-dice-method-25 mtn-dice ((obj mtn-dice) (arg0 int))
  (let ((s4-0 (-> obj face-matrix arg0)))
    (dotimes (s3-0 6)
      (let* ((v1-4 (-> obj face-matrix s3-0))
             (f0-2 (fabs (vector-dot (the-as vector s4-0) (the-as vector v1-4))))
             )
        (when (and (!= s3-0 arg0) (zero? (-> obj face-status s3-0)) (< f0-2 0.001))
          (set! (-> obj face-status s3-0) 1)
          (mtn-dice-method-25 obj s3-0)
          )
        )
      )
    )
  0
  (none)
  )

(defstate restart (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self time-anim) 0.0)
    (set! (-> self speed-anim) 0.0)
    (dotimes (v1-0 6)
      (let* ((a0-2 (-> self face-matrix-back v1-0))
             (t0-0 (-> self face-matrix v1-0))
             (a1-2 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-2 quad 0) a1-2)
        (set! (-> a0-2 quad 1) a2-0)
        (set! (-> a0-2 quad 2) a3-0)
        (set! (-> a0-2 trans quad) t0-1)
        )
      )
    (sound-play "dice-sink")
    (set! (-> self state-time) (current-time))
    (none)
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (cond
      ((>= (- (current-time) (-> self state-time)) (seconds 0.5))
       (+! (-> self speed-anim) (* -0.5 (-> self clock seconds-per-frame) (-> self time-anim)))
       (+! (-> self speed-anim) (* -6.0 (-> self clock seconds-per-frame) (-> self speed-anim)))
       (+! (-> self time-anim) (-> self speed-anim))
       )
      (else
        (set! (-> self draw color-mult quad) (-> self color quad))
        (set! (-> self speed-anim) (- (-> self speed-anim) (* 2.0 (-> self clock seconds-per-frame))))
        (+! (-> self time-anim) (-> self speed-anim))
        (set! (-> self active) (the-as uint 3))
        )
      )
    (when (and (>= (- (current-time) (-> self state-time)) (seconds 0.5)) (!= (-> self active) 2))
      (set! (-> self active) (the-as uint 2))
      (dotimes (gp-0 6)
        (matrix-rotate-xyz! (-> self face-matrix gp-0) (-> *dice-angle-array* gp-0))
        (set! (-> self face-matrix gp-0 trans quad) (-> *dice-position-array* gp-0 quad))
        (vector+! (-> self face-matrix gp-0 trans) (-> self face-matrix gp-0 trans) (-> self root-override trans))
        (set! (-> self face-matrix gp-0 trans y) (+ 8192.0 (-> self face-matrix gp-0 trans y)))
        (let* ((v1-40 (-> self face-matrix-back gp-0))
               (a3-0 (-> self face-matrix gp-0))
               (a0-18 (-> a3-0 quad 0))
               (a1-5 (-> a3-0 quad 1))
               (a2-0 (-> a3-0 quad 2))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> v1-40 quad 0) a0-18)
          (set! (-> v1-40 quad 1) a1-5)
          (set! (-> v1-40 quad 2) a2-0)
          (set! (-> v1-40 trans quad) a3-1)
          )
        (set! (-> self face-status gp-0) 0)
        (let ((v1-44 (-> self root-override root-prim)))
          (logclear! (-> (the-as collide-shape-prim-group v1-44) child gp-0 prim-core action) (collide-action rideable))
          )
        )
      (set-vector! (-> self color) 0.5 0.5 0.5 1.0)
      (set! (-> self free-face) (the-as uint 6))
      )
    (dotimes (v1-51 6)
      (set! (-> self face-matrix v1-51 trans y)
            (+ (-> self face-matrix-back v1-51 trans y) (* 4096.0 (-> self time-anim)))
            )
      )
    (when (>= (- (current-time) (-> self state-time)) (seconds 2))
      (set! (-> self active) (-> self first))
      (go-virtual idle)
      )
    (none)
    )
  :code (the-as (function none :behavior mtn-dice) sleep-code)
  :post (the-as (function none :behavior mtn-dice) transform-post)
  )

(defmethod mtn-dice-method-26 mtn-dice ((obj mtn-dice) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (sv-96 vector) (sv-112 vector) (sv-128 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s3-0 (-> arg0 root-override))
           (s4-0 (if (type? s3-0 collide-shape)
                     s3-0
                     )
                 )
           )
      (when s4-0
        (let ((s3-1 (new 'stack-no-clear 'vector))
              (f30-0 -0.71)
              (s2-0 (the-as touching-prims-entry #f))
              )
          (let ((s0-0 vector-z-quaternion!))
            (set! sv-96 s3-1)
            (let ((a1-3 (get-quat arg0 2)))
              (s0-0 sv-96 a1-3)
              )
            )
          (let ((s1-1 (-> arg1 head)))
            (while s1-1
              (let ((v1-4 (get-touched-prim s1-1 (-> obj root-override) arg1)))
                (-> v1-4 cshape)
                (set! sv-128 (new 'stack-no-clear 'vector))
                (set! (-> sv-128 quad) (the-as uint128 0))
                (set! sv-112 (new 'stack-no-clear 'vector))
                (let ((s0-1 (new 'stack-no-clear 'vector)))
                  (new 'stack-no-clear 'vector)
                  (when (>= (-> obj face-status (-> v1-4 prim-id)) 0)
                    (set! (-> sv-128 quad) (-> obj face-matrix (-> v1-4 prim-id) quad 0))
                    (set! (-> sv-128 w) (- (vector-dot (-> obj face-matrix (-> v1-4 prim-id) trans) sv-128)))
                    (set! (-> sv-112 quad) (-> obj face-matrix (-> v1-4 prim-id) trans quad))
                    (let ((f0-4 (vector4-dot sv-128 (-> s4-0 trans)))
                          (f28-0 (vector-dot sv-128 s3-1))
                          )
                      (when (< f0-4 0.0)
                        (let ((a2-2 s0-1))
                          (let ((a0-28 sv-112))
                            (let ((a1-18 sv-128))
                              (let ((a3-1 -8192.0))
                                (.mov vf7 a3-1)
                                )
                              (.lvf vf5 (&-> a1-18 quad))
                              )
                            (.lvf vf4 (&-> a0-28 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a2-2 quad) vf6)
                          )
                        (let* ((a0-30 (the int (* 0.00024414062 (-> s0-1 x))))
                               (a1-20 (the int (* 0.00024414062 (-> s0-1 z))))
                               (a0-32 (/ (- *dice-offset-x* a0-30) -4))
                               )
                          (if (not (logtest? (-> *dice-blocked-array* (/ (- *dice-offset-z* a1-20) -4)) (ash 1 (- 15 a0-32))))
                              (set! f28-0 -2.0)
                              )
                          )
                        (let ((a0-40 sv-112))
                          (let ((v1-8 (-> obj face-matrix (-> v1-4 prim-id) trans)))
                            (let ((a1-26 sv-128))
                              (let ((a2-10 16384.0))
                                (.mov vf7 a2-10)
                                )
                              (.lvf vf5 (&-> a1-26 quad))
                              )
                            (.lvf vf4 (&-> v1-8 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a0-40 quad) vf6)
                          )
                        (vector-negate-in-place! sv-128)
                        (set! f28-0 (- f28-0))
                        (if (!= (-> obj free-face) 5)
                            (set! f28-0 1.0)
                            )
                        )
                      (let ((v1-13 s0-1))
                        (let ((a0-44 -8192.0))
                          (.mov vf7 a0-44)
                          )
                        (.lvf vf5 (&-> sv-128 quad))
                        (.lvf vf4 (&-> sv-112 quad))
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> v1-13 quad) vf6)
                        )
                      (let* ((v1-15 (the int (* 0.00024414062 (-> s0-1 x))))
                             (a0-48 (the int (* 0.00024414062 (-> s0-1 z))))
                             (v1-17 (/ (- *dice-offset-x* v1-15) -4))
                             (a1-31 (/ (- *dice-offset-z* a0-48) -4))
                             )
                        (when (and (< f28-0 f30-0) (not (logtest? (-> *dice-world-array* a1-31) (ash 1 (- 15 v1-17)))))
                          (set! f30-0 f28-0)
                          (set! s2-0 s1-1)
                          )
                        )
                      )
                    )
                  )
                )
              (set! s1-1 (-> s1-1 next))
              )
            )
          s2-0
          )
        )
      )
    )
  )

(defmethod mtn-dice-method-27 mtn-dice ((obj mtn-dice) (arg0 collide-shape) (arg1 process-focusable) (arg2 touching-shapes-entry))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s3-0 (-> arg1 root-override))
           (s0-0 (if (type? s3-0 collide-shape)
                     s3-0
                     )
                 )
           )
      (when s0-0
        (let ((s5-1 ((method-of-type touching-prims-entry get-touched-prim)
                     (the-as touching-prims-entry arg0)
                     (-> obj root-override)
                     arg2
                     )
                    )
              )
          (-> s5-1 cshape)
          (let ((s1-0 (new-stack-vector0))
                (s2-0 (new-stack-vector0))
                (s3-1 (new 'stack-no-clear 'vector))
                (s4-1 (new 'stack-no-clear 'vector))
                )
            (let ((v1-6 (-> obj face-matrix (-> s5-1 prim-id))))
              (set! (-> s1-0 quad) (-> v1-6 vector 0 quad))
              (set! (-> s1-0 w) (- (vector-dot (-> v1-6 trans) s1-0)))
              (set! (-> s4-1 quad) (-> v1-6 trans quad))
              (when (< (vector4-dot s1-0 (-> s0-0 trans)) 0.0)
                (let ((a0-10 s4-1))
                  (let ((v1-7 (-> v1-6 trans)))
                    (let ((a1-9 s1-0))
                      (let ((a2-3 16384.0))
                        (.mov vf7 a2-3)
                        )
                      (.lvf vf5 (&-> a1-9 quad))
                      )
                    (.lvf vf4 (&-> v1-7 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a0-10 quad) vf6)
                  )
                (vector-negate-in-place! s1-0)
                )
              )
            (set! (-> s4-1 y) (+ -8192.0 (-> s4-1 y)))
            (set! (-> s2-0 y) 1.0)
            (vector-cross! s3-1 s2-0 s1-0)
            (vector-normalize! s3-1 1.0)
            (set! (-> obj rot-axis quad) (-> s3-1 quad))
            (set! (-> obj rot-org quad) (-> s4-1 quad))
            )
          (set! (-> obj face-status (-> s5-1 prim-id)) 1)
          (mtn-dice-method-25 obj (the-as int (-> s5-1 prim-id)))
          )
        )
      )
    0
    (none)
    )
  )

(deftype mtn-dice-info (structure)
  ((mat float 12 :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )


(define *mtn-dice-done-info*
  (new 'static 'boxed-array :type mtn-dice-info
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2584575.8 376831.97 172032.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 -0.9999 -0.9999 0.0 0.0 -2617343.2 376831.5 204800.06)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2600959.5 376831.66 204800.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2600959.8 376831.75 172032.06)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2584575.8 376832.0 155648.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2600959.5 376831.72 188416.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2600959.8 376831.97 -73728.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2568191.5 376832.0 -73727.945)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 -1.0 -1.0 0.0 0.0 -2584575.8 376832.0 -73727.96)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2551807.2 376832.0 -73727.9)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2600959.8 376832.0 -90112.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2551807.2 376832.25 -57343.875)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2551807.8 376832.0 -24576.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2519039.2 376832.0 -8191.963)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 -1.0 -1.0 0.0 0.0 -2535423.5 376832.0 -24575.994)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2519039.2 376831.97 8192.031)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2551807.8 376832.0 -40960.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 -0.9999 -0.9999 0.0 0.0 -2535423.5 376831.97 -8191.9688)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2519039.8 376832.0 40960.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 0.9999 0.9999 0.0 0.0 -2551807.5 376832.0 40960.047)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2568191.2 376831.75 57344.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.0 0.0 0.9999 1.0 0.0 0.0 -2535423.5 376832.0 40960.004)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2519039.8 376832.0 24576.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 1.0 -2551807.5 376831.97 57344.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.0 0.0 1.0 0.9999 0.0 0.0 -2568191.8 376831.97 90112.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.9999 0.0 0.0 0.0 0.0 -0.9999 -2584575.8 376831.72 122880.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 -0.9999 0.0 0.0 0.0 0.0 0.9999 -2584575.5 376831.72 139264.03)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 0.9999 0.0 0.9999 0.0 0.0 0.0 0.0 -0.9999 -2584575.8 376831.75 106496.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 -1.0 0.0 0.0 0.0 0.0 1.0 -2568191.8 376832.0 73728.0)
      )
    (new 'static 'mtn-dice-info
      :mat (new 'static 'array float 12 0.0 1.0 0.0 0.9999 0.0 0.0 0.0 0.0 -1.0 -2568191.8 376831.94 106496.0)
      )
    )
  )

(defstate idle (mtn-dice)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (sv-192 vector))
    (cond
      ((= event-type 'print-info)
       (dotimes (gp-1 6)
         (let ((s5-1 (-> self face-matrix gp-1)))
           (format #t "(static-mtn-dice-info (")
           (format #t "~F ~F ~F " (-> s5-1 vector 0 x) (-> s5-1 vector 0 y) (-> s5-1 vector 0 z))
           (format #t "~F ~F ~F " (-> s5-1 vector 1 x) (-> s5-1 vector 1 y) (-> s5-1 vector 1 z))
           (format #t "~F ~F ~F " (-> s5-1 vector 2 x) (-> s5-1 vector 2 y) (-> s5-1 vector 2 z))
           (format #t "~F ~F ~F " (-> s5-1 trans x) (-> s5-1 trans y) (-> s5-1 trans z))
           )
         (format #t "))~%")
         )
       #f
       )
      ((= event-type 'trigger)
       (mem-set32! (the-as pointer *dice-blocked-array*) 13 0)
       (set! (-> *dice-blocked-array* 1) (the-as uint 256))
       (set! *dice-back-way-num* 0)
       (set-vector! *dice-last-safe-position* -2603417.5 384983.03 -107683.84 1.0)
       (if (and (= (-> self free-face) 5) (= (-> self active) 1))
           (set! (-> self active) (-> self first))
           )
       (if (or (< (-> self free-face) (the-as uint 5)) (= (-> self active) 3))
           (go-virtual restart)
           )
       )
      ((= event-type 'hint)
       (when (>= (-> self hint-count) 0.0)
         (+! (-> self hint-count) (-> self clock seconds-per-frame))
         (if (< 6.0 (-> self hint-count))
             (talker-spawn-func (-> *talker-speech* 61) *entity-pool* (target-pos 0) (the-as region #f))
             )
         )
       )
      ((= event-type 'touch)
       (let* ((s3-0 proc)
              (s2-0 proc)
              (s4-1 (if (type? s2-0 process-focusable)
                        (the-as process-focusable s2-0)
                        )
                    )
              (s2-1 (-> (the-as process-focusable s3-0) root-override))
              (s3-1 (if (type? s2-1 collide-shape)
                        s2-1
                        )
                    )
              )
         (when s3-1
           (let* ((s2-2 (the-as object (-> event param 0)))
                  (s1-0 (-> (the-as touching-shapes-entry s2-2) head))
                  )
             (while s1-0
               (let ((s0-0 (get-touched-tri s1-0 (-> self root-override) (the-as touching-shapes-entry s2-2)))
                     (a1-13 (get-touched-prim s1-0 (-> self root-override) (the-as touching-shapes-entry s2-2)))
                     (v1-30 (new 'stack-no-clear 'matrix))
                     )
                 (let* ((a3-6 (-> self node-list data (+ (-> a1-13 prim-id) 4) bone transform))
                        (a0-26 (-> a3-6 quad 0))
                        (a1-17 (-> a3-6 quad 1))
                        (a2-9 (-> a3-6 quad 2))
                        (a3-7 (-> a3-6 trans quad))
                        )
                   (set! (-> v1-30 quad 0) a0-26)
                   (set! (-> v1-30 quad 1) a1-17)
                   (set! (-> v1-30 quad 2) a2-9)
                   (set! (-> v1-30 trans quad) a3-7)
                   )
                 (when s0-0
                   (when (and (< 0.9 (-> s0-0 normal y)) (< (-> v1-30 vector 0 y) -0.9))
                     (when (< (vector-dot
                                (vector-! (new 'stack-no-clear 'vector) (-> s3-1 trans) (the-as vector (-> s0-0 vertex)))
                                (-> s0-0 normal)
                                )
                              409.6
                              )
                       (when s4-1
                         (let ((s0-1 (new 'stack-no-clear 'vector)))
                           (set! sv-192 *dice-last-safe-position*)
                           (let* ((v1-42 (get-trans s4-1 0))
                                  (s0-2 (vector-! s0-1 sv-192 v1-42))
                                  )
                             (vector-float*! s0-2 s0-2 0.5)
                             (let ((a1-21 (new 'stack-no-clear 'event-message-block)))
                               (set! (-> a1-21 from) (process->ppointer self))
                               (set! (-> a1-21 num-params) 2)
                               (set! (-> a1-21 message) 'shove)
                               (set! (-> a1-21 param 0) (-> event param 0))
                               (let ((v1-49 (new 'static 'attack-info :mask (attack-info-mask vector id))))
                                 (let* ((a0-36 *game-info*)
                                        (a2-11 (+ (-> a0-36 attack-id) 1))
                                        )
                                   (set! (-> a0-36 attack-id) a2-11)
                                   (set! (-> v1-49 id) a2-11)
                                   )
                                 (set! (-> v1-49 vector quad) (-> s0-2 quad))
                                 (set! (-> a1-21 param 1) (the-as uint v1-49))
                                 )
                               (send-event-function proc a1-21)
                               )
                             )
                           )
                         )
                       )
                     )
                   )
                 )
               (set! s1-0 (-> s1-0 next))
               )
             )
           #f
           )
         )
       )
      ((= event-type 'attack)
       (when (= (-> self active) 1)
         (let ((v1-56 (the-as object (-> event param 1))))
           (when (!= (-> (the-as attack-info v1-56) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-56) id))
             (let ((s3-2 proc)
                   (s4-2 (if (type? proc process-focusable)
                             (the-as process-focusable proc)
                             )
                         )
                   )
               (let ((s5-3 (-> (the-as process-focusable s3-2) root-override)))
                 (if (type? s5-3 collide-shape)
                     (empty)
                     )
                 )
               (let* ((gp-3 (-> event param 0))
                      (a1-26 (mtn-dice-method-26 self s4-2 (the-as touching-shapes-entry gp-3)))
                      )
                 (cond
                   (a1-26
                     (mtn-dice-method-27 self (the-as collide-shape a1-26) s4-2 (the-as touching-shapes-entry gp-3))
                     (set! (-> self punch-anim) #t)
                     (sound-play "dice-hit")
                     (set! (-> self hint-count) -1.0)
                     (go-virtual animate)
                     'push
                     )
                   (else
                     (set! (-> self incoming-attack-id) (the-as uint 0))
                     #f
                     )
                   )
                 )
               )
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self curtime) 0)
    (set! (-> self first-touch-time) 0)
    0
    (none)
    )
  :trans (behavior ()
    (if (nonzero? (-> self curtime))
        (set! (-> self first-touch-time) (current-time))
        )
    (set! (-> self curtime) (current-time))
    (when (and (zero? (-> self active)) (dice-wrong-way?))
      )
    (none)
    )
  :code (the-as (function none :behavior mtn-dice) sleep-code)
  :post (behavior ()
    (rider-trans)
    (if (= (-> self active) 1)
        (set! (-> self color x) (fmin 1.0 (+ (-> self color x) (* 2.0 (-> self clock seconds-per-frame)))))
        (set! (-> self color x) (fmax 0.5 (- (-> self color x) (* 2.0 (-> self clock seconds-per-frame)))))
        )
    (set! (-> self color y) (-> self color x))
    (set! (-> self color z) (-> self color x))
    (set! (-> self draw color-mult quad) (-> self color quad))
    (when (zero? (-> self active))
      (let* ((v1-15 (the int (* 0.00024414062 (-> self root-override trans x))))
             (a0-5 (the int (* 0.00024414062 (-> self root-override trans z))))
             (s5-0 (/ (- *dice-offset-x* v1-15) -4))
             (gp-0 (/ (- *dice-offset-z* a0-5) -4))
             )
        (when (or (logtest? (-> *dice-blocked-array* (+ gp-0 1)) (ash 1 (- 15 s5-0)))
                  (logtest? (-> *dice-blocked-array* (+ gp-0 -1)) (ash 1 (- 15 s5-0)))
                  (logtest? (-> *dice-blocked-array* gp-0) (ash 1 (- 15 (+ s5-0 1))))
                  (logtest? (-> *dice-blocked-array* gp-0) (ash 1 (- 15 (+ s5-0 -1))))
                  )
          (when (> *dice-back-way-num* 0)
            (set! (-> *dice-last-safe-position* quad) (-> *dice-back-way* (+ *dice-back-way-num* -1) quad))
            (set! (-> *dice-last-safe-position* y) (+ 8192.0 (-> *dice-last-safe-position* y)))
            )
          (when (not (dice-wrong-way?))
            (set! (-> *dice-back-way* *dice-back-way-num* quad) (-> self root-override trans quad))
            (set! *dice-back-way-num* (+ *dice-back-way-num* 1))
            )
          (set! (-> *dice-blocked-array* gp-0)
                (the-as uint (logior (ash 1 (- 15 s5-0)) (-> *dice-blocked-array* gp-0)))
                )
          (set! (-> self active) (the-as uint 1))
          )
        )
      )
    (when (= (-> self first) 1)
      )
    (rider-post)
    (none)
    )
  )

(defstate idle-done (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self curtime) 0)
    (set! (-> self first-touch-time) 0)
    0
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (the-as (function none :behavior mtn-dice) sleep-code)
  :post (behavior ()
    (rider-trans)
    (rider-post)
    (none)
    )
  )

(defstate animate (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (dotimes (v1-0 6)
      (let* ((a0-2 (-> self face-matrix-back v1-0))
             (t0-0 (-> self face-matrix v1-0))
             (a1-2 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-2 quad 0) a1-2)
        (set! (-> a0-2 quad 1) a2-0)
        (set! (-> a0-2 quad 2) a3-0)
        (set! (-> a0-2 trans quad) t0-1)
        )
      )
    (set! (-> self state-time) (current-time))
    (set! (-> self time-anim) 1.0)
    (set! (-> self speed-anim) -0.5)
    (none)
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (cond
      ((-> self punch-anim)
       (+! (-> self speed-anim) (* -4.0 (-> self clock seconds-per-frame) (-> self time-anim)))
       (+! (-> self speed-anim) (* -16.0 (-> self clock seconds-per-frame) (-> self speed-anim)))
       )
      (else
        (+! (-> self speed-anim) (* -3.0 (-> self clock seconds-per-frame) (-> self time-anim)))
        (+! (-> self speed-anim) (* -20.0 (-> self clock seconds-per-frame) (-> self speed-anim)))
        )
      )
    (+! (-> self time-anim) (-> self speed-anim))
    (when (< (-> self time-anim) 0.0)
      (set! (-> self time-anim) 0.0)
      (set! (-> self speed-anim) (- (-> self speed-anim)))
      )
    (if (>= (- (current-time) (-> self state-time)) (seconds 0.7))
        (set! (-> self time-anim) 0.0)
        )
    (let ((s4-0 (new 'stack-no-clear 'matrix))
          (s5-0 (new 'stack-no-clear 'matrix))
          (gp-0 (new 'stack-no-clear 'matrix))
          )
      (let ((f0-16 (- 1.0 (-> self time-anim)))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (matrix-axis-angle! s4-0 (-> self rot-axis) (* 16384.0 f0-16))
        (vector-negate! s3-0 (-> self rot-org))
        (matrix-translate! s5-0 s3-0)
        )
      (matrix<-trans s4-0 (-> self rot-org))
      (matrix*! gp-0 s5-0 s4-0)
      (dotimes (s5-1 6)
        (if (= (-> self face-status s5-1) 1)
            (matrix*! (-> self face-matrix s5-1) (-> self face-matrix-back s5-1) gp-0)
            )
        )
      )
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.7))
      (dotimes (v1-34 6)
        (when (= (-> self face-status v1-34) 1)
          (set! (-> self face-status v1-34) 0)
          0
          )
        )
      (go-virtual idle)
      )
    (none)
    )
  :code (the-as (function none :behavior mtn-dice) sleep-code)
  :post (behavior ()
    (transform-post)
    (none)
    )
  )

(defstate fall (mtn-dice)
  :virtual #t
  :enter (behavior ()
    (set! (-> self time-anim) 0.0)
    (set! (-> self speed-anim) 0.0)
    (set! (-> self state-time) (current-time))
    (sound-play "dice-sink")
    (none)
    )
  :trans (behavior ()
    (set! (-> self draw color-mult quad) (-> self color quad))
    (set! (-> self speed-anim) (- (-> self speed-anim) (* 0.05 (-> self clock seconds-per-frame))))
    (+! (-> self time-anim) (-> self speed-anim))
    (set! (-> self active) (the-as uint 3))
    (dotimes (v1-5 6)
      (+! (-> self face-matrix v1-5 trans y) (* 4096.0 (-> self time-anim)))
      )
    (when (>= (- (current-time) (-> self state-time)) (seconds 1))
      (dotimes (v1-11 6)
        (when (= (-> self face-status v1-11) 1)
          (set! (-> self face-status v1-11) 0)
          0
          )
        )
      (go-virtual idle)
      )
    (none)
    )
  :code (the-as (function none :behavior mtn-dice) sleep-code)
  :post (the-as (function none :behavior mtn-dice) transform-post)
  )

(defun dice-joint-callback ((arg0 draw-control) (arg1 cspace-array) (arg2 joint-control))
  (local-vars
    (sv-544 int)
    (sv-560 vector)
    (sv-576 vector)
    (sv-592 vector)
    (sv-608 vector)
    (sv-624 vector)
    (sv-640 vector)
    (sv-656 matrix)
    (sv-672 matrix)
    (sv-688 vector)
    (sv-704 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (the-as mtn-dice (-> arg0 process))))
      (new 'stack-no-clear 'vector)
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set-vector! s4-0 4095996000.0 4095996000.0 4095996000.0 1.0)
        (set-vector! s5-0 -4095996000.0 -4095996000.0 -4095996000.0 1.0)
        (dotimes (s2-0 6)
          (let ((s1-0 (-> arg1 data (+ s2-0 4) bone transform)))
            (new-stack-matrix0)
            (let* ((v1-9 s1-0)
                   (a3-0 (-> gp-0 face-matrix s2-0))
                   (a0-11 (-> a3-0 quad 0))
                   (a1-1 (-> a3-0 quad 1))
                   (a2-1 (-> a3-0 quad 2))
                   (a3-1 (-> a3-0 trans quad))
                   )
              (set! (-> v1-9 quad 0) a0-11)
              (set! (-> v1-9 quad 1) a1-1)
              (set! (-> v1-9 quad 2) a2-1)
              (set! (-> v1-9 trans quad) a3-1)
              )
            (let ((v1-12 (the int (+ 2.0 (* 0.00024414062 (-> s1-0 trans x)))))
                  (a0-14 (the int (+ 2.0 (* 0.00024414062 (-> s1-0 trans z)))))
                  )
              (set! sv-544 (/ (- *dice-offset-x* v1-12) -4))
              (let ((s0-0 (/ (- *dice-offset-z* a0-14) -4)))
                (when (and (= (-> gp-0 face-status s2-0) -1) (= (-> gp-0 active) 1))
                  (when (and (= (-> gp-0 active) 1) (not (logtest? (-> *dice-blocked-array* s0-0) (ash 1 (- 15 sv-544)))))
                    (when (> *dice-back-way-num* 0)
                      (set! (-> *dice-last-safe-position* quad) (-> *dice-back-way* (+ *dice-back-way-num* -1) quad))
                      (set! (-> *dice-last-safe-position* y) (+ 8192.0 (-> *dice-last-safe-position* y)))
                      )
                    (when (not (dice-wrong-way?))
                      (set! (-> *dice-back-way* *dice-back-way-num* quad) (-> s1-0 trans quad))
                      (set! *dice-back-way-num* (+ *dice-back-way-num* 1))
                      )
                    (set! (-> *dice-blocked-array* s0-0)
                          (the-as uint (logior (ash 1 (- 15 sv-544)) (-> *dice-blocked-array* s0-0)))
                          )
                    )
                  )
                )
              )
            (cond
              ((>= (-> gp-0 face-status s2-0) 0)
               (when (and (< 0.8 (-> s1-0 vector 0 y)) (zero? (-> gp-0 face-status s2-0)))
                 (+! (-> gp-0 free-face) -1)
                 (set! (-> gp-0 face-status s2-0) -1)
                 )
               (let* ((v1-59 (-> gp-0 face-matrix s2-0))
                      (a3-3 s1-0)
                      (a0-45 (-> a3-3 quad 0))
                      (a1-11 (-> a3-3 quad 1))
                      (a2-5 (-> a3-3 quad 2))
                      (a3-4 (-> a3-3 trans quad))
                      )
                 (set! (-> v1-59 quad 0) a0-45)
                 (set! (-> v1-59 quad 1) a1-11)
                 (set! (-> v1-59 quad 2) a2-5)
                 (set! (-> v1-59 trans quad) a3-4)
                 )
               )
              (else
                (when (!= (-> gp-0 free-face) 5)
                  (let ((a0-47 (-> gp-0 root-override root-prim)))
                    (logior! (-> (the-as collide-shape-prim-group a0-47) child s2-0 prim-core action) (collide-action rideable))
                    )
                  )
                )
              )
            (when (-> gp-0 watervol)
              (let* ((v1-70 (-> gp-0 watervol))
                     (s0-1 (if v1-70
                               (the-as water-anim (-> v1-70 extra process))
                               )
                           )
                     )
                (when s0-1
                  (set! sv-560 (new 'stack-no-clear 'vector))
                  (set! sv-576 (new 'stack-no-clear 'vector))
                  (set! sv-608 (new 'stack-no-clear 'vector))
                  (set! sv-592 (new 'stack-no-clear 'vector))
                  (set! sv-672 (new 'stack-no-clear 'matrix))
                  (set! sv-640 (new 'stack-no-clear 'vector))
                  (let ((a1-15 sv-560))
                    (let ((v1-79 (-> s1-0 trans)))
                      (let ((a0-50 (-> s1-0 vector)))
                        (let ((a2-7 8192.0))
                          (.mov vf7 a2-7)
                          )
                        (.lvf vf5 (&-> a0-50 0 quad))
                        )
                      (.lvf vf4 (&-> v1-79 quad))
                      )
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a1-15 quad) vf6)
                    )
                  (set! (-> sv-640 quad) (-> sv-560 quad))
                  (set! (-> sv-576 quad) (-> sv-560 quad))
                  (set! (-> sv-576 x) (+ 8192.0 (-> sv-576 x)))
                  (set! (-> sv-608 quad) (-> sv-560 quad))
                  (set! (-> sv-608 z) (+ 8192.0 (-> sv-608 z)))
                  (set! (-> sv-560 y) (get-ripple-height s0-1 sv-560))
                  (set! (-> sv-576 y) (get-ripple-height s0-1 sv-576))
                  (set! (-> sv-608 y) (get-ripple-height s0-1 sv-608))
                  (vector-! sv-576 sv-576 sv-560)
                  (vector-! sv-608 sv-608 sv-560)
                  (set! (-> sv-576 y) (* 0.5 (-> sv-576 y)))
                  (set! (-> sv-608 y) (* 0.5 (-> sv-608 y)))
                  (set! (-> sv-576 w) 0.0)
                  (set! (-> sv-592 w) 0.0)
                  (set! (-> sv-608 w) 0.0)
                  (vector-normalize! sv-576 1.0)
                  (vector-normalize! sv-608 1.0)
                  (vector-cross! sv-592 sv-608 sv-576)
                  (vector-normalize! sv-592 1.0)
                  (vector-cross! sv-608 sv-576 sv-592)
                  (vector-normalize! sv-608 1.0)
                  (matrix-identity! sv-672)
                  (set! (-> sv-672 vector 0 quad) (-> sv-576 quad))
                  (set! (-> sv-672 vector 1 quad) (-> sv-592 quad))
                  (set! (-> sv-672 vector 2 quad) (-> sv-608 quad))
                  (set! sv-624 (new 'stack-no-clear 'vector))
                  (set! sv-656 (new 'stack-no-clear 'matrix))
                  (set! sv-688 (new 'stack-no-clear 'vector))
                  (vector-negate! sv-624 sv-640)
                  (matrix-translate! sv-656 sv-624)
                  (matrix<-trans sv-672 sv-640)
                  (matrix*! (the-as matrix sv-688) sv-656 sv-672)
                  (matrix*! s1-0 s1-0 (the-as matrix sv-688))
                  (+! (-> s1-0 trans y) (* 0.5 (- (-> sv-560 y) (-> s0-1 water-height))))
                  (set! (-> s1-0 trans y) (+ 8192.0 (-> s1-0 trans y)))
                  (set! (-> s4-0 x) (fmin (-> s4-0 x) (-> s1-0 trans x)))
                  (set! (-> s4-0 y) (fmin (-> s4-0 y) (-> s1-0 trans y)))
                  (set! (-> s4-0 z) (fmin (-> s4-0 z) (-> s1-0 trans z)))
                  (set! (-> s5-0 x) (fmax (-> s5-0 x) (-> s1-0 trans x)))
                  (set! (-> s5-0 y) (fmax (-> s5-0 y) (-> s1-0 trans y)))
                  (set! (-> s5-0 z) (fmax (-> s5-0 z) (-> s1-0 trans z)))
                  )
                )
              )
            (let ((s0-2 (new 'stack-no-clear 'vector)))
              (set! (-> s0-2 quad) (-> s1-0 vector 0 quad))
              (set! sv-704 (new 'stack-no-clear 'vector))
              (let ((v1-125 (-> s1-0 trans quad)))
                (set! (-> sv-704 quad) v1-125)
                )
              (let ((a1-36 sv-704))
                (let ((v1-126 sv-704))
                  (let ((a0-81 s0-2))
                    (let ((a2-11 8192.0))
                      (.mov vf7 a2-11)
                      )
                    (.lvf vf5 (&-> a0-81 quad))
                    )
                  (.lvf vf4 (&-> v1-126 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-36 quad) vf6)
                )
              (let ((f30-0 0.0)
                    (s1-1 (new 'stack-no-clear 'vector))
                    (v0-14 (camera-pos))
                    )
                (cond
                  ((< f30-0 (vector-dot s0-2 (vector-! s1-1 sv-704 v0-14)))
                   (let ((v1-129 s2-0))
                     (cond
                       ((zero? v1-129)
                        (setup-masks (-> gp-0 draw) 2 0)
                        )
                       ((= v1-129 1)
                        (setup-masks (-> gp-0 draw) 4 0)
                        )
                       ((= v1-129 2)
                        (setup-masks (-> gp-0 draw) 8 0)
                        )
                       ((= v1-129 3)
                        (setup-masks (-> gp-0 draw) 16 0)
                        )
                       ((= v1-129 4)
                        (setup-masks (-> gp-0 draw) 32 0)
                        )
                       ((= v1-129 5)
                        (setup-masks (-> gp-0 draw) 64 0)
                        )
                       )
                     )
                   )
                  (else
                    (let ((v1-143 s2-0))
                      (cond
                        ((zero? v1-143)
                         (setup-masks (-> gp-0 draw) 0 2)
                         )
                        ((= v1-143 1)
                         (setup-masks (-> gp-0 draw) 0 4)
                         )
                        ((= v1-143 2)
                         (setup-masks (-> gp-0 draw) 0 8)
                         )
                        ((= v1-143 3)
                         (setup-masks (-> gp-0 draw) 0 16)
                         )
                        ((= v1-143 4)
                         (setup-masks (-> gp-0 draw) 0 32)
                         )
                        ((= v1-143 5)
                         (setup-masks (-> gp-0 draw) 0 64)
                         )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (let ((s2-1 (new 'stack-no-clear 'vector))
              (s3-1 (new 'stack-no-clear 'vector))
              )
          (vector-average! s2-1 s4-0 s5-0)
          (vector-! s2-1 s2-1 (-> gp-0 root-override trans))
          (vector-! s3-1 s5-0 s4-0)
          (set! (-> gp-0 draw bounds quad) (-> s2-1 quad))
          (set! (-> gp-0 draw bounds w) (+ 16384.0 (* 0.5 (vector-length s3-1))))
          )
        )
      (set! (-> (the-as collide-shape (-> gp-0 root-override)) root-prim local-sphere quad)
            (-> gp-0 draw bounds quad)
            )
      (vector-rotate90-around-y! (-> gp-0 draw bounds) (-> gp-0 draw bounds))
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-dice ((obj mtn-dice) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 6) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 7))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 5)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 2))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 6)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 3))))
      (set! (-> v1-16 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-16 prim-core action) (collide-action solid))
      (set! (-> v1-16 transform-index) 7)
      (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 4))))
      (set! (-> v1-18 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-18 prim-core action) (collide-action solid))
      (set! (-> v1-18 transform-index) 8)
      (set-vector! (-> v1-18 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 5))))
      (set! (-> v1-20 prim-core collide-as) (collide-spec pusher))
      (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-20 prim-core action) (collide-action solid))
      (set! (-> v1-20 transform-index) 9)
      (set-vector! (-> v1-20 local-sphere) 0.0 0.0 0.0 11878.4)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-23 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-23 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-23 prim-core collide-with))
      )
    (set! (-> obj root-override) (the-as collide-shape-moving s4-0))
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-dice" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj skel postbind-function) dice-joint-callback)
  (set! (-> obj first) (the-as uint 0))
  (let ((v1-30 (res-lump-value arg0 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
    (if (= (the-as uint v1-30) 2)
        (set! (-> obj first) (the-as uint 1))
        )
    )
  (let* ((a0-48 (the int (* 0.00024414062 (-> obj root-override trans x))))
         (v1-37 (the int (* 0.00024414062 (-> obj root-override trans y))))
         (a1-21 (the int (* 0.00024414062 (-> obj root-override trans z))))
         (a0-49 (- a0-48 *dice-offset-x*))
         (a2-13 (- a1-21 *dice-offset-z*))
         (a1-22 (+ a0-49 1))
         (a0-50 (+ a2-13 1))
         (a1-23 (logand -4 a1-22))
         (v1-38 (logand -2 v1-37))
         (a0-51 (logand -4 a0-50))
         (a1-24 (+ a1-23 *dice-offset-x*))
         (a0-52 (+ a0-51 *dice-offset-z*))
         )
    (set! (-> obj root-override trans x) (* 4096.0 (the float a1-24)))
    (set! (-> obj root-override trans y) (* 4096.0 (the float v1-38)))
    (set! (-> obj root-override trans z) (* 4096.0 (the float a0-52)))
    )
  (dotimes (s4-2 6)
    (matrix-rotate-xyz! (-> obj face-matrix s4-2) (-> *dice-angle-array* s4-2))
    (set! (-> obj face-matrix s4-2 trans quad) (-> *dice-position-array* s4-2 quad))
    (vector+! (-> obj face-matrix s4-2 trans) (-> obj face-matrix s4-2 trans) (-> obj root-override trans))
    (set! (-> obj face-matrix s4-2 trans y) (+ 8192.0 (-> obj face-matrix s4-2 trans y)))
    )
  (mem-set32! (the-as pointer *dice-blocked-array*) 13 0)
  (set! (-> *dice-blocked-array* 1) (the-as uint 256))
  (set! *dice-back-way-num* 0)
  (set-vector! *dice-last-safe-position* -2603417.5 384983.03 -107683.84 1.0)
  (set-vector! (-> obj color) 0.5 0.5 0.5 1.0)
  (set! (-> obj free-face) (the-as uint 6))
  (set! (-> obj watervol) (entity-actor-lookup (-> obj entity) 'alt-actor 0))
  (set! (-> obj hint-count) 0.0)
  (set! (-> obj active) (-> obj first))
  (setup-masks (-> obj draw) 0 -1)
  (setup-masks (-> obj draw) 1 0)
  (cond
    ((task-node-closed? (game-task-node mountain-shard-dice))
     (let ((v1-71 (res-lump-value arg0 'extra-id uint128 :default (the-as uint128 -1) :time -1000000000.0)))
       (dotimes (a0-76 6)
         (let ((a1-42 (-> *mtn-dice-done-info* (+ a0-76 (* 6 (the-as int (+ v1-71 -1)))))))
           (set! (-> obj face-matrix a0-76 vector 0 x) (-> a1-42 mat 0))
           (set! (-> obj face-matrix a0-76 vector 0 y) (-> a1-42 mat 1))
           (set! (-> obj face-matrix a0-76 vector 0 z) (-> a1-42 mat 2))
           (set! (-> obj face-matrix a0-76 vector 0 w) 0.0)
           (set! (-> obj face-matrix a0-76 vector 1 x) (-> a1-42 mat 3))
           (set! (-> obj face-matrix a0-76 vector 1 y) (-> a1-42 mat 4))
           (set! (-> obj face-matrix a0-76 vector 1 z) (-> a1-42 mat 5))
           (set! (-> obj face-matrix a0-76 vector 1 w) 0.0)
           (set! (-> obj face-matrix a0-76 vector 2 x) (-> a1-42 mat 6))
           (set! (-> obj face-matrix a0-76 vector 2 y) (-> a1-42 mat 7))
           (set! (-> obj face-matrix a0-76 vector 2 z) (-> a1-42 mat 8))
           (set! (-> obj face-matrix a0-76 vector 2 w) 0.0)
           (set! (-> obj face-matrix a0-76 trans x) (-> a1-42 mat 9))
           (set! (-> obj face-matrix a0-76 trans y) (-> a1-42 mat 10))
           (set! (-> obj face-matrix a0-76 trans z) (-> a1-42 mat 11))
           )
         (set! (-> obj face-matrix a0-76 trans w) 1.0)
         )
       )
     (go (method-of-object obj idle-done))
     )
    (else
      (go (method-of-object obj idle))
      )
    )
  (none)
  )

(deftype mtn-plat-elevator (elevator)
  ()
  :heap-base #xf0
  :method-count-assert 49
  :size-assert         #x170
  :flag-assert         #x3100f00170
  )


(defskelgroup skel-mtn-plat-elevator mtn-plat-elevator mtn-plat-elevator-lod0-jg mtn-plat-elevator-idle-ja
              ((mtn-plat-elevator-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7)
              )

(defmethod get-art-group mtn-plat-elevator ((obj mtn-plat-elevator))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-mtn-plat-elevator" (the-as (pointer uint32) #f))
  )

(defmethod set-ambient-sound! mtn-plat-elevator ((obj mtn-plat-elevator))
  "Sets the elevator's [[ambient-sound]] up"
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "mtn-elevator-lp" :fo-max 70) (-> obj root-override trans))
        )
  0
  (none)
  )

(defmethod move-between-points mtn-plat-elevator ((obj mtn-plat-elevator) (arg0 vector) (arg1 float) (arg2 float))
  "Move between two points on the elevator's path
@param vec TODO not sure
@param point-a The first point fetched from the elevator's path
@param point-b The second point fetched from the path
@see [[path-control]] and [[elevator]]"
  (let ((s4-0 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) arg1 'interp))
        (a0-3 (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) arg2 'interp))
        )
    (and (< (-> a0-3 y) (-> s4-0 y))
         (< (-> arg0 y) (+ -4096.0 (-> obj root-override trans y)))
         (< (vector-vector-xz-distance a0-3 arg0) 24576.0)
         )
    )
  )

(defmethod init-plat-collision! mtn-plat-elevator ((obj mtn-plat-elevator))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 28672.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(deftype mtn-plat-updown (base-plat)
  ((sync     sync-eased :inline :offset-assert 272)
   (path-pos float              :offset-assert 316)
   )
  :heap-base #xc0
  :method-count-assert 36
  :size-assert         #x140
  :flag-assert         #x2400c00140
  (:methods
    (idle () _type_ :state 34)
    (active () _type_ :state 35)
    )
  )


(defskelgroup skel-mtn-plat-updown mtn-plat-updown mtn-plat-updown-lod0-jg mtn-plat-updown-idle-ja
              ((mtn-plat-updown-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defstate idle (mtn-plat-updown)
  :virtual #t
  :code (the-as (function none :behavior mtn-plat-updown) sleep-code)
  :post (the-as (function none :behavior mtn-plat-updown) ja-post)
  )

(defstate active (mtn-plat-updown)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mtn-plat-updown) plat-event)
  :trans (behavior ()
    (set! (-> self path-pos) (get-norm! (-> self sync) 0))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (plat-trans)
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mtn-plat-updown) plat-post)
  )

(defmethod init-plat-collision! mtn-plat-updown ((obj mtn-plat-updown))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 16384.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-plat-updown ((obj mtn-plat-updown) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-updown" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((a0-5 (-> obj skel root-channel 0)))
    (set! (-> a0-5 frame-group) (if (> (-> obj skel active-channels) 0)
                                    (-> obj skel root-channel 0 frame-group)
                                    )
          )
    (set! (-> a0-5 param 0) 1.0)
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group!
      a0-5
      (if (> (-> obj skel active-channels) 0)
          (-> obj skel root-channel 0 frame-group)
          )
      num-func-loop!
      )
    )
  (ja-post)
  (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 arg0 #f))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> obj fact)
        (new 'process 'fact-info obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-7 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if (not (logtest? (-> obj fact options) (actor-option loop)))
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-7 sync-type) 'sync-eased)
      (set! (-> a1-7 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-7 period) (the-as uint 1800))
    (set! (-> a1-7 entity) arg0)
    (set! (-> a1-7 percent) 0.0)
    (set! (-> a1-7 ease-in) 0.15)
    (set! (-> a1-7 ease-out) 0.15)
    (set! (-> a1-7 pause-in) 0.2)
    (set! (-> a1-7 pause-out) 0.0)
    (initialize! (-> obj sync) a1-7)
    )
  (cond
    ((logtest? (-> obj path flags) (path-control-flag not-found))
     (go (method-of-object obj idle))
     )
    ((> (-> obj sync period) 0)
     (go (method-of-object obj active))
     )
    (else
      (go (method-of-object obj idle))
      )
    )
  (none)
  )

(deftype mtn-plat-eject (process-drawable)
  ((dest-pos vector :inline :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 23
  :size-assert         #xe0
  :flag-assert         #x17006000e0
  (:methods
    (wait () _type_ :state 20)
    (eject () _type_ :state 21)
    (mtn-plat-eject-method-22 (_type_) none 22)
    )
  )


(defskelgroup skel-mtn-plat-eject mtn-plat-eject mtn-plat-eject-lod0-jg mtn-plat-eject-idle-ja
              ((mtn-plat-eject-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 4 7.1)
              )

(defstate wait (mtn-plat-eject)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('eject)
       (go-virtual eject)
       )
      )
    )
  :code (the-as (function none :behavior mtn-plat-eject) sleep-code)
  )

(defstate eject (mtn-plat-eject)
  :virtual #t
  :enter (behavior ()
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (loop!) :frame-num 0.0)
    (none)
    )
  :code (the-as (function none :behavior mtn-plat-eject) sleep-code)
  :post (behavior ()
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self dest-pos) (-> self root trans))))
      (vector-normalize! gp-1 (* 0.25 (vector-length gp-1)))
      (vector+! (-> self root trans) (-> self root trans) gp-1)
      )
    (transform-post)
    (none)
    )
  )

(defmethod mtn-plat-eject-method-22 mtn-plat-eject ((obj mtn-plat-eject))
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((v1-2 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-2 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-2 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-2 prim-core action) (collide-action solid))
      (set! (-> v1-2 transform-index) 3)
      (set-vector! (-> v1-2 local-sphere) 0.0 0.0 16384.0 29081.6)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-5 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-5 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-5 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-plat-eject ((obj mtn-plat-eject) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (mtn-plat-eject-method-22 obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-eject" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj dest-pos quad) (-> obj root trans quad))
  (let ((s5-2 (new 'stack-no-clear 'vector)))
    (set! (-> s5-2 x) 0.0)
    (set! (-> s5-2 y) 0.0)
    (set! (-> s5-2 z) -40960.0)
    (set! (-> s5-2 w) 1.0)
    (vector-orient-by-quat! s5-2 s5-2 (-> obj root quat))
    (vector+! (-> obj root trans) (-> obj root trans) s5-2)
    )
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object obj eject))
      (go (method-of-object obj wait))
      )
  (none)
  )

(deftype mtn-plat-long (base-plat)
  ((sync sync-linear :inline :offset-assert 272)
   )
  :heap-base #xa0
  :method-count-assert 35
  :size-assert         #x120
  :flag-assert         #x2300a00120
  (:methods
    (idle () _type_ :state 34)
    )
  )


(defskelgroup skel-mtn-plat-long mtn-plat-long mtn-plat-long-lod0-jg mtn-plat-long-idle-ja
              ((mtn-plat-long-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15.5)
              )

(defstate idle (mtn-plat-long)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior mtn-plat-long) plat-event)
  :trans (the-as (function none :behavior mtn-plat-long) plat-trans)
  :code (behavior ()
    (until #f
      (let ((f0-1 (* (get-current-phase-no-mod (-> self sync)) (the float (+ (-> (ja-group) frames num-frames) -1))))
            (a0-1 (-> self skel root-channel 0))
            )
        (let ((v1-14 (ja-group)))
          (set! (-> a0-1 frame-group) v1-14)
          )
        (set! (-> a0-1 param 0) 1.0)
        (set! (-> a0-1 frame-num) f0-1)
        (joint-control-channel-group! a0-1 (ja-group) num-func-loop!)
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mtn-plat-long) plat-post)
  )

(defmethod init-plat-collision! mtn-plat-long ((obj mtn-plat-long))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 63488.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-plat-long ((obj mtn-plat-long) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-long" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! obj)
  (update-transforms (-> obj root-override))
  (base-plat-method-32 obj)
  (set! (-> obj fact)
        (new 'process 'fact-info obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (let ((a1-5 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-13 0))
      (if (not (logtest? (-> obj fact options) (actor-option loop)))
          (set! v1-13 (logior v1-13 1))
          )
      (set! (-> a1-5 sync-type) 'sync-linear)
      (set! (-> a1-5 sync-flags) (the-as sync-flags v1-13))
      )
    (set! (-> a1-5 entity) arg0)
    (set! (-> a1-5 period) (the-as uint 1200))
    (set! (-> a1-5 percent) 0.0)
    (initialize! (-> obj sync) a1-5)
    )
  (go (method-of-object obj idle))
  (none)
  )

(deftype mtn-gate (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (idle () _type_ :state 20)
    (open () _type_ :state 21)
    )
  )


(defskelgroup skel-mtn-gate mtn-gate mtn-gate-lod0-jg mtn-gate-idle-ja
              ((mtn-gate-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 4 0 18)
              )

(defstate idle (mtn-gate)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code (the-as (function none :behavior mtn-gate) sleep-code)
  )

(defstate open (mtn-gate)
  :virtual #t
  :code (behavior ()
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set-setting! 'entity-name "camera-259" 0.0 0)
    (let ((gp-0 (current-time)))
      (until (>= (- (current-time) gp-0) (seconds 1))
        (suspend)
        )
      )
    (ja-no-eval :group! (ja-group)
                :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((gp-1 (current-time)))
      (until (>= (- (current-time) gp-1) (seconds 1))
        (suspend)
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  :post (the-as (function none :behavior mtn-gate) transform-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-gate ((obj mtn-gate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set-vector! (-> s3-0 local-sphere) 0.0 24576.0 -2457.6 49152.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 4)
      (set-vector! (-> v1-7 local-sphere) -16384.0 16384.0 0.0 32768.0)
      )
    (let ((v1-9 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-9 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-9 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-9 prim-core action) (collide-action solid))
      (set! (-> v1-9 transform-index) 5)
      (set-vector! (-> v1-9 local-sphere) 16384.0 16384.0 0.0 32768.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-gate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-push! 1 0)
  (let ((s5-2 (-> obj skel root-channel 0)))
    (joint-control-channel-group-eval!
      s5-2
      (the-as art-joint-anim (-> obj draw art-group data 3))
      num-func-identity
      )
    (set! (-> s5-2 frame-num) 0.0)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype mtn-aval-rocks (process-drawable)
  ((art-name  symbol        :offset-assert 200)
   (anim      spool-anim    :offset-assert 204)
   (rock-data vector-array  :offset-assert 208)
   (loop-id   sound-id      :offset-assert 212)
   (volume    float         :offset-assert 216)
   )
  :heap-base #x60
  :method-count-assert 22
  :size-assert         #xdc
  :flag-assert         #x16006000dc
  (:methods
    (fall () _type_ :state 20)
    (idle () _type_ :state 21)
    )
  )


;; WARN: Return type mismatch process-drawable vs mtn-aval-rocks.
(defmethod relocate mtn-aval-rocks ((obj mtn-aval-rocks) (arg0 int))
  (if (nonzero? (-> obj rock-data))
      (&+! (-> obj rock-data) arg0)
      )
  (the-as mtn-aval-rocks ((method-of-type process-drawable relocate) obj arg0))
  )

(deftype mtn-aval-rocks-shadow (process-drawable)
  ((parent-ptr   (pointer mtn-aval-rocks)  :offset         16)
   (parent-joint int32                     :offset-assert 200)
   (update-time  time-frame                :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 21
  :size-assert         #xd8
  :flag-assert         #x15006000d8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-mtn-aval-rocks-1 mtn-aval-rocks mtn-aval-rocks-1-lod0-jg mtn-aval-rocks-1-idle-ja
              ((mtn-aval-rocks-1-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 -100 140)
              )

(defskelgroup skel-mtn-aval-rocks-shadow mtn-aval-rocks mtn-aval-rocks-shadow-lod0-jg mtn-aval-rocks-shadow-idle-ja
              ((mtn-aval-rocks-shadow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1.5 0 2)
              :shadow mtn-aval-rocks-shadow-shadow-mg
              )

(define *mtn-aval-rocks-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 245760.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0)
                                           :fade-dist 409600.0
                                           )
                               )
  )

(defstate idle (mtn-aval-rocks-shadow)
  :virtual #t
  :code (the-as (function none :behavior mtn-aval-rocks-shadow) sleep-code)
  :post (behavior ()
    (let ((s5-0 (-> (the-as process-drawable (-> self parent-ptr 0)) node-list data (-> self parent-joint)))
          (gp-0 (-> self draw shadow-ctrl))
          )
      (vector<-cspace! (-> self root trans) s5-0)
      (let ((f0-1 (* 0.5 (-> s5-0 bone scale y))))
        (set-vector! (-> self root scale) f0-1 f0-1 f0-1 1.0)
        )
      (cond
        ((< (vector-vector-distance (math-camera-pos) (-> self root trans)) (-> gp-0 settings fade-dist))
         (let ((s5-2 (new 'stack-no-clear 'collide-query)))
           (set! (-> s5-2 start-pos quad) (-> self root trans quad))
           (set! (-> s5-2 start-pos z) (+ -8192.0 (-> s5-2 start-pos z)))
           (set-vector! (-> s5-2 move-dist) 0.0 -81920.0 0.0 1.0)
           (let ((v1-13 s5-2))
             (set! (-> v1-13 radius) 819.2)
             (set! (-> v1-13 collide-with) (collide-spec backgnd))
             (set! (-> v1-13 ignore-process0) self)
             (set! (-> v1-13 ignore-process1) #f)
             (set! (-> v1-13 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
             (set! (-> v1-13 action-mask) (collide-action solid))
             )
           (cond
             ((>= (fill-and-probe-using-line-sphere *collide-cache* s5-2) 0.0)
              (let ((v1-16 gp-0))
                (logclear! (-> v1-16 settings flags) (shadow-flags disable-draw))
                )
              0
              (set! (-> gp-0 settings bot-plane w)
                    (- (- (+ (- 4096.0 (-> s5-2 best-other-tri intersect y)) (-> self root trans y))))
                    )
              0
              )
             (else
               (let ((v1-21 gp-0))
                 (logior! (-> v1-21 settings flags) (shadow-flags disable-draw))
                 )
               0
               )
             )
           )
         )
        (else
          (let ((v1-23 gp-0))
            (logior! (-> v1-23 settings flags) (shadow-flags disable-draw))
            )
          0
          )
        )
      )
    (ja-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior mtn-aval-rocks-shadow-init-by-other mtn-aval-rocks-shadow ((arg0 int))
  (stack-size-set! (-> self main-thread) 128)
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self parent-joint) arg0)
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> self parent-ptr 0 root trans quad))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton
    self
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-mtn-aval-rocks-shadow" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (set! (-> self draw shadow-ctrl) (copy *mtn-aval-rocks-shadow-control* 'process))
  (go-virtual idle)
  (none)
  )

(defpartgroup group-aval-rock-hit
  :id 352
  :duration (seconds 0.017)
  :linger-duration (seconds 1.5)
  :bounds (static-bspherem 0 0 0 2)
  :parts ((sp-item 112) (sp-item 113) (sp-item 104))
  )

(defstate idle (mtn-aval-rocks)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('draw)
       (if (-> event param 0)
           (go-virtual fall)
           )
       )
      )
    )
  :trans (behavior ()
    (cond
      ((not *target*)
       )
      ((string= (-> *game-info* current-continue name) "mountain-aval")
       (go-virtual fall)
       )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-set! 0)
    (transform-post)
    (logior! (-> self mask) (process-mask sleep-code))
    (suspend)
    0
    (none)
    )
  )

(defstate fall (mtn-aval-rocks)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (a2-3 int))
    (case event-type
      (('touch 'attack)
       (let ((s3-0 (-> event param 0))
             (s4-0 0)
             )
         (when s3-0
           (let ((a0-6 ((method-of-type touching-shapes-entry prims-touching?)
                        (the-as touching-shapes-entry s3-0)
                        (the-as collide-shape (-> self root))
                        (the-as uint -1)
                        )
                       )
                 )
             (when a0-6
               (let ((a0-7 (get-touched-prim a0-6 (the-as collide-shape (-> self root)) (the-as touching-shapes-entry s3-0))))
                 (if a0-7
                     (set! s4-0 (the-as int (-> a0-7 prim-id)))
                     )
                 )
               )
             )
           )
         (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
           (set! (-> a1-4 from) (process->ppointer self))
           (set! (-> a1-4 num-params) 2)
           (set! (-> a1-4 message) 'attack)
           (set! (-> a1-4 param 0) (-> event param 0))
           (let ((v1-11 (new 'static 'attack-info :mask (attack-info-mask shove-up id damage))))
             (set! a2-3 (cond
                          ((nonzero? s4-0)
                           (+ s4-0 10)
                           )
                          (else
                            (let ((a0-9 *game-info*))
                              (set! a2-3 (the-as int (+ (-> a0-9 attack-id) 1)))
                              (set! (-> a0-9 attack-id) (the-as uint a2-3))
                              )
                            a2-3
                            )
                          )
                   )
             (set! (-> v1-11 id) (the-as uint a2-3))
             (set! (-> v1-11 shove-up) 12288.0)
             (set! (-> v1-11 damage) 1.0)
             (set! (-> a1-4 param 1) (the-as uint v1-11))
             )
           (send-event-function proc a1-4)
           )
         )
       )
      (('draw)
       (if (not (-> event param 0))
           (go-virtual idle)
           )
       )
      )
    )
  :exit (behavior ()
    (when (= (-> *setting-control* user-current spooling) (process->ppointer self))
      (ja-abort-spooled-anim (-> self anim) (the-as art-joint-anim #f) -1)
      (ja-channel-set! 0)
      )
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (remove-process *gui-control* self (gui-channel art-load-next))
    (let ((v1-10 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-10 command) (sound-command set-param))
      (set! (-> v1-10 id) (-> self loop-id))
      (set! (-> v1-10 params volume) -4)
      (set! (-> v1-10 auto-time) 240)
      (set! (-> v1-10 auto-from) 2)
      (set! (-> v1-10 params mask) (the-as uint 17))
      (-> v1-10 id)
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 2)
          (s5-0 (+ (-> self node-list length) -1))
          )
      (while (>= s5-0 gp-0)
        (process-spawn mtn-aval-rocks-shadow gp-0 :to self)
        (+! gp-0 1)
        )
      )
    (let ((gp-1
            (add-process *gui-control* self (gui-channel art-load-next) (gui-action queue) (-> self anim name) -1.0 0)
            )
          )
      (while (!= (get-status *gui-control* gp-1) (gui-status ready))
        (suspend)
        )
      )
    (until #f
      (let ((v1-16
              (lookup-gui-connection
                *gui-control*
                self
                (gui-channel art-load-next)
                (the-as string #f)
                (new 'static 'sound-id)
                )
              )
            )
        (if v1-16
            (set! (-> v1-16 channel) (gui-channel art-load))
            )
        )
      (add-process *gui-control* self (gui-channel art-load-next) (gui-action queue) (-> self anim name) -1.0 0)
      (ja-play-spooled-anim
        (-> self anim)
        (get-art-by-name (-> self draw art-group) "idle" art-joint-anim)
        (the-as art-joint-anim #f)
        (the-as (function process-drawable symbol) false-func)
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (local-vars (sv-16 vector-array) (sv-20 vector) (sv-48 float) (sv-52 symbol))
    (transform-post)
    (if (= (-> *setting-control* user-current music) 'mountain)
        (seek! (-> self volume) 0.6 (* 0.2 (-> self clock seconds-per-frame)))
        (seek! (-> self volume) 1.0 (* 0.5 (-> self clock seconds-per-frame)))
        )
    (sound-play-by-name
      (static-sound-name "mtn-aval-loop")
      (-> self loop-id)
      (the int (* 1024.0 (-> self volume)))
      0
      0
      (sound-group sfx)
      (-> self draw origin)
      )
    (set! sv-16 (-> self rock-data))
    (set! sv-20 (target-pos 0))
    (dotimes (gp-0 (-> self node-list length))
      (let* ((a1-3 (-> self node-list data gp-0))
             (s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) a1-3))
             )
        (set! (-> s5-0 y) (+ -4096.0 (-> s5-0 y)))
        (set! sv-48 (* (- (-> s5-0 y) (-> sv-16 data gp-0 x)) (-> self clock frames-per-second)))
        (set! sv-52 (the-as symbol #f))
        (when (and (< (-> sv-16 data gp-0 y) -24576.0) (< (* 0.45 (-> sv-16 data gp-0 y)) sv-48))
          (set! sv-52 #t)
          (let ((f30-0 (vector-vector-distance sv-20 s5-0)))
            (when (< f30-0 204800.0)
              (let ((s4-0 (get-process *default-dead-pool* part-tracker #x4000)))
                (when s4-0
                  (let ((t9-8 (method-of-type part-tracker activate)))
                    (t9-8
                      (the-as part-tracker s4-0)
                      *entity-pool*
                      (symbol->string (-> part-tracker symbol))
                      (the-as pointer #x70004000)
                      )
                    )
                  (let ((t9-9 run-function-in-process)
                        (a0-16 s4-0)
                        (a1-7 part-tracker-init)
                        (a2-7 (-> *part-group-id-table* 352))
                        (a3-2 0)
                        (t0-1 #f)
                        (t1-1 #f)
                        (t2-1 #f)
                        (t3-0 *launch-matrix*)
                        )
                    (set! (-> t3-0 trans quad) (-> s5-0 quad))
                    ((the-as (function object object object object object object object object none) t9-9)
                     a0-16
                     a1-7
                     a2-7
                     a3-2
                     t0-1
                     t1-1
                     t2-1
                     t3-0
                     )
                    )
                  (-> s4-0 ppointer)
                  )
                )
              (when (= (-> sv-16 data gp-0 w) 0.0)
                (sound-play-by-name
                  (static-sound-name "mtn-boulder")
                  (new-sound-id)
                  (the int
                       (* 1024.0 (* (lerp-scale 0.3 1.0 (fabs (- (-> sv-16 data gp-0 y) sv-48)) 0.0 40960.0) (-> self volume)))
                       )
                  0
                  0
                  (sound-group sfx)
                  s5-0
                  )
                (set! (-> sv-16 data gp-0 w) 20.0)
                )
              )
            (when (< f30-0 122880.0)
              (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 (the int (* 255.0 (- 1.0 (* 0.000008138021 f30-0)))) (seconds 0.2))
              (activate!
                *camera-smush-control*
                (lerp-scale 1638.4 0.0 f30-0 0.0 122880.0)
                15
                75
                1.0
                0.9
                (-> *display* camera-clock)
                )
              )
            )
          )
        (set! (-> sv-16 data gp-0 y) sv-48)
        (set! (-> sv-16 data gp-0 x) (-> s5-0 y))
        )
      (seek! (-> sv-16 data gp-0 w) 0.0 1.0)
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-aval-rocks ((obj mtn-aval-rocks) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 collide-shape-prim-sphere) (sv-48 collide-shape-prim-sphere) (sv-64 vector))
  (stack-size-set! (-> obj main-thread) 512)
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (set! (-> s4-0 penetrated-by) (penetrate))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 49) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 50))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 transform-index) 0)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 -409600.0 573440.0)
      (set! (-> s4-0 root-prim) s3-0)
      (pusher-init s4-0)
      (let* ((s2-0 1)
             (s1-0
               '((3 9011)
                 (4 9011)
                 (5 9011)
                 (6 9011)
                 (13 9011)
                 (14 9011)
                 (15 9011)
                 (16 9011)
                 (22 9011)
                 (23 9011)
                 (42 9011)
                 (26 9011)
                 (27 9011)
                 (35 9011)
                 (36 9011)
                 (37 9011)
                 (45 9011)
                 (46 9011)
                 (47 9011)
                 (48 9011)
                 (7 6144)
                 (8 6144)
                 (9 6144)
                 (10 6144)
                 (17 6144)
                 (18 6144)
                 (49 6144)
                 (19 6144)
                 (20 6144)
                 (21 6144)
                 (11 6144)
                 (12 6144)
                 (24 3686)
                 (25 3686)
                 (32 3686)
                 (33 3686)
                 (34 3686)
                 (43 3686)
                 (44 3686)
                 (50 3686)
                 (38 3686)
                 (38 3686)
                 (40 3686)
                 (39 3686)
                 (41 3686)
                 (28 3686)
                 (29 3686)
                 (30 3686)
                 (31 3686)
                 )
               )
             (s0-0 (car s1-0))
             )
        (while (not (null? s1-0))
          (set! sv-16 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0)))
          (set! sv-48 sv-16)
          (set! (-> sv-48 prim-core collide-as) (-> s3-0 prim-core collide-as))
          (set! (-> sv-48 prim-core collide-with) (-> s3-0 prim-core collide-with))
          (set! (-> sv-48 prim-core action) (-> s3-0 prim-core action))
          (set! (-> sv-48 transform-index) (command-get-int (car s0-0) 0))
          (set! (-> sv-48 prim-id) (the-as uint s2-0))
          (+! s2-0 1)
          (set! sv-64 (-> sv-16 local-sphere))
          (set! (-> sv-64 x) 0.0)
          (set! (-> sv-64 y) 0.0)
          (set! (-> sv-64 z) 0.0)
          (set! (-> sv-64 w) (command-get-float (car (cdr s0-0)) 0.0))
          (set! s1-0 (cdr s1-0))
          (set! s0-0 (car s1-0))
          )
        )
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-27 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause))
  (quaternion-rotate-y! (-> obj root quat) (-> obj root quat) 32768.0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-aval-rocks-1" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> obj skel status) (joint-control-status sync-math))
  (set! (-> obj art-name) (the-as symbol "mtn-aval-rocks-1"))
  (set! (-> obj anim)
        (new 'static 'spool-anim :name "mtn-aval-rocks-1" :anim-name "1-fall" :parts 8 :command-list '())
        )
  (set! (-> obj loop-id) (new-sound-id))
  (set! (-> obj rock-data) (new 'process 'vector-array (-> obj node-list length)))
  (dotimes (v1-42 (-> obj node-list length))
    (let* ((a0-21 *game-info*)
           (a1-13 (the-as number (+ (-> a0-21 attack-id) 1)))
           )
      (set! (-> a0-21 attack-id) (the-as uint a1-13))
      (set! (-> obj rock-data data v1-42 z) (the-as float a1-13))
      )
    (set! (-> obj rock-data data v1-42 w) 0.0)
    )
  (let ((a2-7 (matrix<-transformq! (-> obj node-list data 0 bone transform) (the-as transformq (-> obj root trans))))
        (a1-17 (new 'stack-no-clear 'vector))
        )
    (set! (-> a1-17 quad) (-> obj draw bounds quad))
    (set! (-> a1-17 w) 1.0)
    (vector-matrix*! (-> obj draw origin) a1-17 a2-7)
    )
  (set! (-> obj draw origin w) (-> obj draw bounds w))
  (go (method-of-object obj idle))
  (none)
  )

(deftype mtn-plat-return (base-plat)
  ((ride-timer time-frame  :offset-assert 272)
   (flags      uint16      :offset-assert 280)
   (path-pos   float       :offset-assert 284)
   (dest-pos   float       :offset-assert 288)
   (path-speed float       :offset-assert 292)
   )
  :heap-base #xb0
  :method-count-assert 38
  :size-assert         #x128
  :flag-assert         #x2600b00128
  (:methods
    (waiting () _type_ :state 34)
    (running () _type_ :state 35)
    (waiting-for-no-player () _type_ :state 36)
    (mtn-plat-return-method-37 (_type_) none 37)
    )
  )


(defskelgroup skel-mtn-plat-return mtn-plat-return 0 4
              ((1 (meters 999999)))
              :bounds (static-spherem 0 0 0 4.8)
              )

(defstate waiting (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) 1))))
         (set! (-> self flags) (the-as uint v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self ride-timer) (current-time))
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (none)
    )
  :trans (behavior ()
    (set! (-> self flags) (logand -2 (-> self flags)))
    (plat-trans)
    (if (not (logtest? (-> self flags) 1))
        (set! (-> self ride-timer) (current-time))
        )
    (let ((v1-10 (and (>= (- (current-time) (-> self ride-timer)) (seconds 0.5))
                      (logtest? (-> self flags) 1)
                      (if (logtest? (-> self flags) 2)
                          (and *target* (process-grab? *target* #f))
                          #t
                          )
                      )
                 )
          )
      (when v1-10
        (if (= (-> self path-pos) 0.0)
            (set! (-> self dest-pos) 1.0)
            (set! (-> self dest-pos) 0.0)
            )
        (go-virtual running)
        )
      )
    (none)
    )
  :code (the-as (function none :behavior mtn-plat-return) sleep-code)
  :post (the-as (function none :behavior mtn-plat-return) plat-post)
  )

(defstate running (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('ridden)
       (let ((v0-0 (the-as object (logior (-> self flags) 1))))
         (set! (-> self flags) (the-as uint v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc arg1 event-type event)
        )
      )
    )
  :trans (behavior ()
    (if (= (-> self path-pos) (-> self dest-pos))
        (go-virtual waiting-for-no-player)
        )
    (plat-trans)
    (none)
    )
  :code (the-as (function none :behavior mtn-plat-return) sleep-code)
  :post (behavior ()
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (-> self clock seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    (none)
    )
  )

(defstate waiting-for-no-player (mtn-plat-return)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('ridden)
       (let ((v0-0 (the-as object (current-time))))
         (set! (-> self ride-timer) (the-as time-frame v0-0))
         v0-0
         )
       )
      (else
        (plat-event proc arg1 event-type event)
        )
      )
    )
  :trans (behavior ()
    (plat-trans)
    (when (>= (- (current-time) (-> self ride-timer)) (seconds 1))
      (cond
        ((= (-> self path-pos) 1.0)
         (set! (-> self dest-pos) 0.0)
         (go-virtual running)
         )
        (else
          (go-virtual waiting)
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior mtn-plat-return) sleep-code)
  :post (the-as (function none :behavior mtn-plat-return) plat-post)
  )

;; WARN: Return type mismatch object vs none.
(defmethod mtn-plat-return-method-37 mtn-plat-return ((obj mtn-plat-return))
  (go (method-of-object obj waiting))
  (none)
  )

(defmethod init-plat-collision! mtn-plat-return ((obj mtn-plat-return))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 0)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 19660.8)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-11 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-11 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-11 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  0
  (none)
  )

(defmethod init-from-entity! mtn-plat-return ((obj mtn-plat-return) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-plat-collision! obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-plat-return" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (stop-bouncing! obj)
  (set! (-> obj flags) (the-as uint 0))
  (set! (-> obj path-pos) 0.0)
  (set! (-> obj path) (new 'process 'curve-control obj 'path -1000000000.0))
  (if (logtest? (-> obj path flags) (path-control-flag not-found))
      (go process-drawable-art-error "error in path")
      )
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((f30-0 (total-distance (-> obj path))))
    (set! (-> obj path-speed) (/ (res-lump-float arg0 'speed :default 40960.0) f30-0))
    (set! (-> obj root-override pause-adjust-distance) (+ 204800.0 f30-0))
    )
  (set! (-> obj sound)
        (new 'process 'ambient-sound (static-sound-spec "mtn-plat-lp" :fo-max 70) (-> obj root-override trans))
        )
  (init-plat! obj)
  (mtn-plat-return-method-37 obj)
  (none)
  )

(deftype mtn-plat-gap (mtn-plat-return)
  ()
  :heap-base #xb0
  :method-count-assert 38
  :size-assert         #x128
  :flag-assert         #x2600b00128
  )


(defstate running (mtn-plat-gap)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (plat-event proc arg1 event-type event)
    )
  :trans (behavior ()
    (plat-trans)
    (none)
    )
  :code (the-as (function none :behavior mtn-plat-gap) sleep-code)
  :post (behavior ()
    (seek! (-> self path-pos) (-> self dest-pos) (* (-> self path-speed) (-> self clock seconds-per-frame)))
    (get-point-at-percent-along-path!
      (-> self path)
      (-> self basetrans)
      (ease-value-in-out (-> self path-pos) 0.1)
      'interp
      )
    (plat-post)
    (none)
    )
  )

(defstate waiting (mtn-plat-gap)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (set! (-> self dest-pos) 0.0)
       (go-virtual running)
       )
      (else
        (plat-event proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self path-pos) 1.0)
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (none)
    )
  :trans (behavior ()
    (plat-trans)
    (none)
    )
  :code (the-as (function none :behavior mtn-plat-gap) sleep-code)
  :post (the-as (function none :behavior mtn-plat-gap) plat-post)
  )

(deftype mtn-button (process-drawable)
  ((on-activate symbol  :offset-assert 200)
   )
  :heap-base #x50
  :method-count-assert 24
  :size-assert         #xcc
  :flag-assert         #x18005000cc
  (:methods
    (idle () _type_ :state 20)
    (open () _type_ :state 21)
    (waiting () _type_ :state 22)
    (pressed (symbol) _type_ :state 23)
    )
  )


(defskelgroup skel-mtn-button mtn-button mtn-button-lod0-jg mtn-button-open-ja
              ((mtn-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(defstate idle (mtn-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code (the-as (function none :behavior mtn-button) sleep-code)
  )

(defstate open (mtn-button)
  :virtual #t
  :trans (the-as (function none :behavior mtn-button) rider-trans)
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 2)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual waiting)
    (none)
    )
  :post (the-as (function none :behavior mtn-button) rider-post)
  )

(defstate waiting (mtn-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('bonk)
       (go-virtual pressed #f)
       )
      )
    )
  :enter (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (transform-post)
    (none)
    )
  :code (the-as (function none :behavior mtn-button) sleep-code)
  )

(defstate pressed (mtn-button)
  :virtual #t
  :code (behavior ((arg0 symbol))
    (when (not arg0)
      (let ((gp-0 (-> self on-activate)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root trans))
            )
        )
      (ja-no-eval :group! (-> self draw art-group data 3)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (transform-post)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (ja :group! (-> self draw art-group data 3)
        :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
        )
    (transform-post)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-button ((obj mtn-button) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid rideable))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 12288.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 4)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 10240.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj on-activate) (res-lump-struct (-> obj entity) 'on-activate symbol))
  (let ((a0-22 (-> obj skel root-channel 0)))
    (set! (-> a0-22 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-22 param 0) 1.0)
    (set! (-> a0-22 frame-num) 0.0)
    (joint-control-channel-group! a0-22 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-loop!)
    )
  (transform-post)
  (if (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
      (go (method-of-object obj pressed) #t)
      (go (method-of-object obj idle))
      )
  (none)
  )

(deftype mtn-gear-device (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xc8
  :flag-assert         #x16005000c8
  (:methods
    (idle () _type_ :state 20)
    (idle-collapsed () _type_ :state 21)
    )
  )


(defskelgroup skel-mtn-gear-device mtn-gear-device mtn-gear-device-lod0-jg mtn-gear-device-idle-ja
              ((mtn-gear-device-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 9 0 16)
              :origin-joint-index 3
              )

(defskelgroup skel-mtn-gear-device-collapse mtn-gear-device mtn-gear-device-collapse-lod0-jg mtn-gear-device-collapse-idle-ja
              ((mtn-gear-device-collapse-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 9 0 40)
              :origin-joint-index 33
              )

(defstate idle (mtn-gear-device)
  :virtual #t
  :code (behavior ()
    (add-process *gui-control* self (gui-channel art-load) (gui-action queue) "mountain-gear-res" -99.0 0)
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (update! (-> self sound))
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior mtn-gear-device) ja-post)
  )

(defstate idle-collapsed (mtn-gear-device)
  :virtual #t
  :code (the-as (function none :behavior mtn-gear-device) transform-and-sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! mtn-gear-device ((obj mtn-gear-device) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (cond
    ((task-complete? *game-info* (game-task mountain-gear))
     (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
       (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 9) 0)))
         (set! (-> s4-0 total-prims) (the-as uint 10))
         (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle))
         (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> s3-0 prim-core action) (collide-action solid))
         (set! (-> s3-0 transform-index) 0)
         (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 73728.0)
         (set! (-> s4-0 root-prim) s3-0)
         )
       (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
         (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-10 prim-core action) (collide-action solid))
         (set! (-> v1-10 transform-index) 7)
         (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
         (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-12 prim-core action) (collide-action solid))
         (set! (-> v1-12 transform-index) 8)
         (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
         (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-14 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-14 prim-core action) (collide-action solid))
         (set! (-> v1-14 transform-index) 9)
         (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 2048.0)
         )
       (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
         (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-16 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-16 prim-core action) (collide-action solid))
         (set! (-> v1-16 transform-index) 12)
         (set-vector! (-> v1-16 local-sphere) 2048.0 0.0 0.0 10240.0)
         )
       (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
         (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-18 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-18 prim-core action) (collide-action solid))
         (set! (-> v1-18 transform-index) 23)
         (set-vector! (-> v1-18 local-sphere) 0.0 0.0 -8192.0 45056.0)
         )
       (let ((v1-20 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 5) (the-as uint 0))))
         (set! (-> v1-20 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-20 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-20 prim-core action) (collide-action solid))
         (set! (-> v1-20 transform-index) 24)
         (set-vector! (-> v1-20 local-sphere) 0.0 -4096.0 0.0 16384.0)
         )
       (let ((v1-22 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 6) (the-as uint 0))))
         (set! (-> v1-22 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-22 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-22 prim-core action) (collide-action solid))
         (set! (-> v1-22 transform-index) 25)
         (set-vector! (-> v1-22 local-sphere) 0.0 -4096.0 0.0 16384.0)
         )
       (let ((v1-24 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 7) (the-as uint 0))))
         (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-24 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-24 prim-core action) (collide-action solid))
         (set! (-> v1-24 transform-index) 34)
         (set-vector! (-> v1-24 local-sphere) 0.0 0.0 0.0 13312.0)
         )
       (let ((v1-26 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 8) (the-as uint 0))))
         (set! (-> v1-26 prim-core collide-as) (collide-spec obstacle))
         (set! (-> v1-26 prim-core collide-with) (collide-spec jak player-list))
         (set! (-> v1-26 prim-core action) (collide-action solid))
         (set! (-> v1-26 transform-index) 38)
         (set-vector! (-> v1-26 local-sphere) 0.0 0.0 0.0 22528.0)
         )
       (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
       (let ((v1-29 (-> s4-0 root-prim)))
         (set! (-> s4-0 backup-collide-as) (-> v1-29 prim-core collide-as))
         (set! (-> s4-0 backup-collide-with) (-> v1-29 prim-core collide-with))
         )
       (set! (-> obj root) s4-0)
       )
     (process-drawable-from-entity! obj arg0)
     (initialize-skeleton
       obj
       (the-as
         skeleton-group
         (art-group-get-by-name *level* "skel-mtn-gear-device-collapse" (the-as (pointer uint32) #f))
         )
       (the-as pair 0)
       )
     (go (method-of-object obj idle-collapsed))
     )
    (else
      (let ((s4-2 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
        (let ((v1-38 (new 'process 'collide-shape-prim-sphere s4-2 (the-as uint 0))))
          (set! (-> v1-38 prim-core collide-as) (collide-spec obstacle))
          (set! (-> v1-38 prim-core collide-with) (collide-spec jak bot player-list))
          (set! (-> v1-38 prim-core action) (collide-action solid))
          (set! (-> v1-38 transform-index) 0)
          (set-vector! (-> v1-38 local-sphere) 0.0 36864.0 0.0 65536.0)
          (set! (-> s4-2 total-prims) (the-as uint 1))
          (set! (-> s4-2 root-prim) v1-38)
          )
        (set! (-> s4-2 nav-radius) (* 0.75 (-> s4-2 root-prim local-sphere w)))
        (let ((v1-41 (-> s4-2 root-prim)))
          (set! (-> s4-2 backup-collide-as) (-> v1-41 prim-core collide-as))
          (set! (-> s4-2 backup-collide-with) (-> v1-41 prim-core collide-with))
          )
        (set! (-> obj root) s4-2)
        )
      (process-drawable-from-entity! obj arg0)
      (initialize-skeleton
        obj
        (the-as skeleton-group (art-group-get-by-name *level* "skel-mtn-gear-device" (the-as (pointer uint32) #f)))
        (the-as pair 0)
        )
      (set! (-> obj root pause-adjust-distance) 450560.0)
      (add-connection *part-engine* obj 24 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 25 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 21 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 22 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 14 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 13 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 15 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 16 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 17 obj 1492 (new 'static 'vector :w 163840.0))
      (add-connection *part-engine* obj 18 obj 1492 (new 'static 'vector :w 163840.0))
      (set! (-> obj sound)
            (new 'process 'ambient-sound (static-sound-spec "mtn-gear-device" :fo-max 90) (-> obj root trans))
            )
      (go (method-of-object obj idle))
      )
    )
  (none)
  )

(deftype water-anim-mountain (water-anim)
  ()
  :heap-base #x80
  :method-count-assert 29
  :size-assert         #x100
  :flag-assert         #x1d00800100
  )


(define ripple-for-water-anim-mountain (new 'static 'ripple-wave-set
                                         :count 3
                                         :converted #f
                                         :normal-scale 1.0
                                         :wave (new 'static 'inline-array ripple-wave 4
                                           (new 'static 'ripple-wave :scale 40.0 :xdiv 1 :speed 1.5)
                                           (new 'static 'ripple-wave :scale 40.0 :xdiv -1 :zdiv 1 :speed 1.5)
                                           (new 'static 'ripple-wave :scale 20.0 :xdiv 5 :zdiv 3 :speed 0.75)
                                           (new 'static 'ripple-wave)
                                           )
                                         )
        )

(defmethod init-water! water-anim-mountain ((obj water-anim-mountain))
  "Initialize a [[water-anim]]'s default settings, this may include applying a [[riple-control]]"
  (let ((t9-0 (method-of-type water-anim init-water!)))
    (t9-0 obj)
    )
  (let ((v1-2 (new 'process 'ripple-control)))
    (set! (-> obj draw ripple) v1-2)
    (set-vector! (-> obj draw color-mult) 0.01 0.45 0.5 0.75)
    (set! (-> v1-2 global-scale) 3072.0)
    (set! (-> v1-2 close-fade-dist) 163840.0)
    (set! (-> v1-2 far-fade-dist) 245760.0)
    (set! (-> v1-2 waveform) ripple-for-water-anim-mountain)
    )
  0
  (none)
  )

(deftype trans-plat (mtn-plat-return)
  ()
  :heap-base #xb0
  :method-count-assert 39
  :size-assert         #x128
  :flag-assert         #x2700b00128
  (:methods
    (rising () _type_ :state 38)
    )
  )


(defstate rising (trans-plat)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior trans-plat) plat-event)
  :code (behavior ()
    (get-point-at-percent-along-path! (-> self path) (-> self basetrans) (-> self path-pos) 'interp)
    (let ((f30-0 (-> self basetrans y))
          (f28-0 24576.0)
          )
      (while (< 0.0 f28-0)
        (set! (-> self basetrans y) (- f30-0 f28-0))
        (plat-trans)
        (set! f28-0 (seek-ease
                      f28-0
                      0.0
                      (* 40960.0 (-> self clock seconds-per-frame))
                      2048.0
                      (* 4096.0 (-> self clock seconds-per-frame))
                      )
              )
        (suspend)
        )
      )
    (go-virtual waiting)
    (none)
    )
  :post (the-as (function none :behavior trans-plat) plat-post)
  )

(defstate waiting (trans-plat)
  :virtual #t
  :enter (behavior ()
    (when (not (or (not (task-node-closed? (game-task-node forest-scouts-introduction)))
                   (task-node-closed? (game-task-node forest-scouts-pegasus))
                   (!= (-> self path-pos) 0.0)
                   )
               )
      (let ((gp-0 (new 'stack-no-clear 'task-arrow-params)))
        (set! (-> gp-0 pos quad) (-> self root-override trans quad))
        (quaternion-identity! (-> gp-0 quat))
        (set! (-> gp-0 flags) (task-arrow-flags))
        (set! (-> gp-0 map-icon) (the-as uint 15))
        (task-arrow-spawn gp-0 (the-as task-arrow self))
        )
      )
    (let ((t9-5 (-> (the-as state (find-parent-method trans-plat 34)) enter)))
      (if t9-5
          ((the-as (function none) t9-5))
          )
      )
    (none)
    )
  :exit (behavior ()
    (while (-> self child)
      (deactivate (-> self child 0))
      )
    (let ((t9-2 (-> (the-as state (find-parent-method trans-plat 34)) exit)))
      (if t9-2
          (t9-2)
          )
      )
    (none)
    )
  :trans (behavior ()
    (cond
      ((task-node-closed? (game-task-node forest-scouts-introduction))
       (logclear! (-> self draw status) (draw-control-status no-draw))
       (let ((v1-3 (-> self root-override root-prim)))
         (set! (-> v1-3 prim-core collide-as) (-> self root-override backup-collide-as))
         (set! (-> v1-3 prim-core collide-with) (-> self root-override backup-collide-with))
         )
       )
      (else
        (logior! (-> self draw status) (draw-control-status no-draw))
        (let ((v1-8 (-> self root-override root-prim)))
          (set! (-> v1-8 prim-core collide-as) (collide-spec))
          (set! (-> v1-8 prim-core collide-with) (collide-spec))
          )
        0
        )
      )
    (let ((t9-2 (-> (the-as state (find-parent-method trans-plat 34)) trans)))
      (if t9-2
          (t9-2)
          )
      )
    (none)
    )
  )

(defstate running (trans-plat)
  :virtual #t
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type mtn-plat-return running) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (if (logtest? (-> self flags) 1)
        (process-release? *target*)
        )
    (none)
    )
  )

(defstate waiting-for-no-player (trans-plat)
  :virtual #t
  :trans (behavior ()
    (plat-trans)
    (if (>= (- (current-time) (-> self ride-timer)) (seconds 1))
        (go-virtual waiting)
        )
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod mtn-plat-return-method-37 trans-plat ((obj trans-plat))
  (go (method-of-object obj rising))
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod init-plat! trans-plat ((obj trans-plat))
  "Does any necessary initial platform setup.
For example for an elevator pre-compute the distance between the first and last points (both ways) and clear the sound."
  (logior! (-> obj flags) 2)
  (let* ((s5-0 *target*)
         (a0-2 (if (type? s5-0 process-focusable)
                   s5-0
                   )
               )
         )
    (when a0-2
      (let ((s4-0 (get-trans a0-2 0))
            (s3-0 (-> obj path))
            (f28-0 0.0)
            (f30-0 -1.0)
            (s5-1 (-> obj path curve num-cverts))
            )
        (dotimes (s2-0 s5-1)
          (let ((f0-2
                  (vector-vector-distance s4-0 (get-point-in-path! s3-0 (new 'stack-no-clear 'vector) (the float s2-0) 'interp))
                  )
                )
            (when (or (= f30-0 -1.0) (< f0-2 f28-0))
              (set! f28-0 f0-2)
              (set! f30-0 (the float s2-0))
              )
            )
          )
        (if (!= f30-0 -1.0)
            (set! (-> obj path-pos) (/ f30-0 (+ -1.0 (the float s5-1))))
            )
        )
      )
    )
  (none)
  )
