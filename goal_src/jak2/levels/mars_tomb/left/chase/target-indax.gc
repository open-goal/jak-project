;;-*-Lisp-*-
(in-package goal)

;; name: target-indax.gc
;; name in dgo: target-indax
;; dgos: TOE

(define-extern *indax-walk-mods* surface)
(define-extern *indax-jump-mods* surface)
(define-extern *indax-double-jump-mods* surface)
(define-extern *indax-bounce-mods* surface)
(define-extern target-indax-handler (function process int symbol event-message-block object :behavior target))
(define-extern target-indax-dangerous-event-handler (function process int symbol event-message-block object :behavior target))
(define-extern target-indax-jump-event-handler (function process int symbol event-message-block object :behavior target))
(define-extern target-indax-init (function none :behavior target))
(define-extern target-indax-exit (function none :behavior target))
(define-extern target-indax-real-post (function none :behavior target))
(define-extern target-indax-post (function none :behavior target))
(define-extern target-indax-stance (state target))
(define-extern target-indax-walk (state target))
(define-extern target-indax-falling (state symbol target))
(define-extern target-indax-jump (state float float surface target))
(define-extern target-indax-double-jump (state float float target))
(define-extern target-indax-hit-ground (state symbol target))
(define-extern target-indax-trip (state target))
(define-extern target-indax-attack (state target))
(define-extern target-indax-attack-air (state symbol target))
(define-extern target-indax-running-attack (state target))
(define-extern target-indax-hit-setup-anim (function attack-info none :behavior target))
(define-extern target-indax-hit (state symbol attack-info target))
(define-extern target-indax-death (state symbol target))

;; DECOMP BEGINS

(deftype indax-info (basic)
  ((indax-start-time time-frame  :offset-assert   8)
   (indax-time       time-frame  :offset-assert  16)
   (art-group-backup art-group   :offset-assert  24)
   )
  :method-count-assert 9
  :size-assert         #x1c
  :flag-assert         #x90000001c
  )


(let ((v1-2 (copy *walk-mods* 'loading-level)))
  (set! (-> v1-2 flags) (surface-flag gun-off gun-fast-exit))
  (set! (-> v1-2 target-speed) 32768.0)
  (set! (-> v1-2 transv-max) 32768.0)
  (set! *indax-walk-mods* v1-2)
  )

(let ((v1-4 (copy *jump-mods* 'loading-level)))
  (set! (-> v1-4 target-speed) 32768.0)
  (set! (-> v1-4 transv-max) 32768.0)
  (set! *indax-jump-mods* v1-4)
  )

(let ((v1-6 (copy *double-jump-mods* 'loading-level)))
  (set! (-> v1-6 target-speed) 32768.0)
  (set! (-> v1-6 transv-max) 32768.0)
  (set! *indax-double-jump-mods* v1-6)
  )

(let ((v1-8 (copy *jump-mods* 'loading-level)))
  (set! (-> v1-8 target-speed) 49152.0)
  (set! (-> v1-8 transv-max) 49152.0)
  (set! (-> v1-8 seek0) 0.7)
  (set! (-> v1-8 seek90) 0.7)
  (set! (-> v1-8 seek180) 0.7)
  (set! *indax-bounce-mods* v1-8)
  )

(defbehavior target-indax-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (a0-10 symbol))
  (cond
    ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
     'indax
     )
    (else
      (case arg2
        (('end-mode)
         (go target-stance)
         )
        (('change-mode)
         (let ((v1-5 (-> arg3 param 0)))
           (cond
             ((= v1-5 'grab)
              (when (not (focus-test? self dead))
                (if (not (-> arg3 param 1))
                    #t
                    (go target-grab 'stance)
                    )
                )
              )
             ((= v1-5 'normal)
              (go target-stance)
              )
             ((begin (set! a0-10 'falling) (= v1-5 a0-10))
              (go target-indax-falling a0-10)
              )
             )
           )
         )
        (('trip)
         (if (not (or (focus-test? self dead hit grabbed)
                      (and (-> self next-state) (= (-> self next-state name) 'target-indax-trip))
                      )
                  )
             (go target-indax-trip)
             )
         )
        (('swim 'slide 'edge-grab)
         #f
         )
        (('clone-anim)
         (go target-clone-anim (process->handle (the-as process (-> arg3 param 0))))
         )
        (('attack 'attack-or-shove 'attack-invinc)
         (target-attacked
           arg2
           (the-as attack-info (-> arg3 param 1))
           arg0
           (the-as touching-shapes-entry (-> arg3 param 0))
           target-indax-hit
           )
         )
        (('shove)
         (when (not (and (-> self next-state) (let ((v1-25 (-> self next-state name)))
                                                (or (= v1-25 'target-indax-hit) (= v1-25 'target-hit))
                                                )
                         )
                    )
           (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 160)
           (when (not (logtest? (-> self attack-info-rec mask) (attack-info-mask attacker)))
             (set! (-> self attack-info-rec attacker) (process->handle arg0))
             (logior! (-> self attack-info-rec mask) (attack-info-mask attacker))
             )
           (go target-indax-hit 'shove (-> self attack-info-rec))
           )
         )
        (else
          (target-standard-event-handler arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defbehavior target-indax-dangerous-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (cond
       ((< 0.0 (-> self fact-override shield-level))
        (let ((s4-1 (-> self control penetrate-using)))
          (set! (-> self control penetrate-using) (penetrate touch shield))
          (let ((v0-0 (the-as object (target-send-attack
                                       arg0
                                       'shield
                                       (the-as touching-shapes-entry (-> arg3 param 0))
                                       (the-as int (-> self fact-override shield-attack-id))
                                       0
                                       (-> self control penetrate-using)
                                       )
                              )
                      )
                )
            (set! (-> self control penetrate-using) s4-1)
            v0-0
            )
          )
        )
       (((method-of-type touching-shapes-entry prims-touching?)
         (the-as touching-shapes-entry (-> arg3 param 0))
         (-> self control)
         (the-as uint 1920)
         )
        (target-send-attack
          arg0
          (-> self control danger-mode)
          (the-as touching-shapes-entry (-> arg3 param 0))
          (the-as int (-> self control target-attack-id))
          (the-as int (-> self control attack-count))
          (-> self control penetrate-using)
          )
        )
       (else
         (target-indax-handler arg0 arg1 arg2 arg3)
         )
       )
     )
    (('attack 'attack-or-shove 'attack-invinc)
     (target-attacked
       arg2
       (the-as attack-info (-> arg3 param 1))
       arg0
       (the-as touching-shapes-entry (-> arg3 param 0))
       target-indax-hit
       )
     )
    (else
      (target-indax-handler arg0 arg1 arg2 arg3)
      )
    )
  )

(defbehavior target-indax-jump-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((s2-0 (new 'stack-no-clear 'vector)))
    (cond
      ((and (= arg2 'touched)
            ((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry (-> arg3 param 0))
             (-> self control)
             (the-as uint 6)
             )
            (< (* 16384.0 (-> self clock time-adjust-ratio))
               (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control transv) (-> self control last-transv))
                 )
               )
            (begin
              (vector-normalize!
                (vector-!
                  s2-0
                  (the-as vector (-> self control collision-spheres 0 prim-core))
                  (-> self control actor-contact-pt)
                  )
                1.0
                )
              (< 0.01 (-> s2-0 y))
              )
            )
       (if (< 0.75 (-> s2-0 y))
           (send-event
             arg0
             'bonk
             (-> arg3 param 0)
             (fmax
               (-> self control ground-impact-vel)
               (- (vector-dot (-> self control transv) (-> self control dynam gravity-normal)))
               )
             )
           )
       (target-indax-handler arg0 arg1 arg2 arg3)
       )
      ((= arg2 'jump)
       (sound-play "jump-long")
       (go
         target-indax-jump
         (the-as float (-> arg3 param 0))
         (the-as float (-> arg3 param 1))
         (the-as surface (-> arg3 param 2))
         )
       )
      (else
        (target-indax-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-indax-init target ()
  (set! (-> self control current-surface flags)
        (logior (surface-flag gun-fast-exit) (-> self control current-surface flags))
        )
  (target-gun-end-mode #t)
  (target-exit)
  (logior! (-> self game features) (game-feature sidekick))
  (target-sidekick-setup #t)
  (if (zero? (-> self indax))
      (set! (-> self indax) (new 'process 'indax-info))
      )
  (set! (-> self control reaction) target-collision-reaction)
  (set! (-> self control transv quad) (the-as uint128 0))
  (set! (-> self control ctrl-xz-vel) 0.0)
  (set! (-> self focus-status) (logior (focus-status indax) (-> self focus-status)))
  (set! (-> self control bend-target) 0.0)
  (target-collide-set! 'indax 0.0)
  (set! (-> self fact-override health) (-> self fact-override health-max))
  (set! (-> self indax indax-start-time) (-> self clock frame-counter))
  (set! (-> self indax art-group-backup) (-> self draw art-group))
  (set! (-> self draw art-group) (-> self sidekick 0 draw art-group))
  (logior! (-> self draw status) (draw-control-status no-draw-bounds2))
  (send-event (ppointer->process (-> self sidekick)) 'matrix 'indax)
  (remove-exit)
  (go target-indax-stance)
  (none)
  )

(defbehavior target-indax-exit target ()
  (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                         (or (= v1-3 'target-indax-stance)
                                             (= v1-3 'target-indax-walk)
                                             (= v1-3 'target-indax-jump)
                                             (= v1-3 'target-indax-double-jump)
                                             (= v1-3 'target-indax-falling)
                                             (= v1-3 'target-indax-hit-ground)
                                             (= v1-3 'target-indax-attack)
                                             (= v1-3 'target-indax-attack-air)
                                             (= v1-3 'target-indax-running-attack)
                                             (= v1-3 'target-indax-trip)
                                             (= v1-3 'target-indax-hit)
                                             (= v1-3 'target-indax-death)
                                             )
                                         )
                  )
             )
    (logclear! (-> self focus-status) (focus-status indax))
    (logclear! (-> self control root-prim prim-core action) (collide-action stuck-wall-escape))
    (set! (-> self control mod-surface) *walk-mods*)
    (logclear! (-> self state-flags) (state-flags sf6))
    (target-collide-set! 'normal 0.0)
    (set! (-> self draw art-group) (-> self indax art-group-backup))
    (logclear! (-> self draw status) (draw-control-status no-draw-bounds2))
    (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
    (if (not (focus-test? self dead))
        (set! (-> self fact-override health) (-> self fact-override health-max))
        )
    (target-exit)
    )
  (none)
  )

(defbehavior target-indax-real-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (if (< (-> self control force-turn-to-strength) 0.0)
            (set! (-> self control force-turn-to-strength) (- 1.0 (-> self control cpad stick0-speed)))
            )
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (let ((f28-0 (debounce-speed
                         (-> self control pad-magnitude)
                         (-> self control last-pad-magnitude)
                         (-> self control pad-xz-dir)
                         (-> self control last-pad-xz-dir)
                         )
                       )
                )
            (when (!= (-> self control force-turn-to-strength) 0.0)
              (let ((f0-12 (fmin 1.0 (-> self control force-turn-to-strength))))
                (set! (-> self control force-turn-to-strength) f0-12)
                (let ((a1-3 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (if (= f28-0 0.0)
                                  *zero-vector*
                                  s5-0
                                  )
                              f28-0
                              )
                            )
                      (a2-2 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (-> self control force-turn-to-direction)
                              (-> self control force-turn-to-speed)
                              )
                            )
                      )
                  (vector-lerp! s5-0 a1-3 a2-2 f0-12)
                  )
                )
              (set! f28-0 (vector-length s5-0))
              (vector-normalize! s5-0 1.0)
              )
            (turn-to-vector s5-0 f28-0)
            )
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-38 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-38)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (let ((a2-3 (new 'stack-no-clear 'collide-query)))
          (let ((v1-51 (-> self control)))
            (set! (-> a2-3 collide-with) (-> v1-51 root-prim prim-core collide-with))
            (set! (-> a2-3 ignore-process0) self)
            (set! (-> a2-3 ignore-process1) #f)
            (set! (-> a2-3 ignore-pat) (-> v1-51 pat-ignore-mask))
            )
          (set! (-> a2-3 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-3 (meters 1))
          )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-68 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-68))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-68 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (logclear! (-> self draw status) (draw-control-status no-draw-temp uninited))
  (evaluate-joint-control self)
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-indax-post target ()
  (target-indax-real-post)
  (none)
  )

(defstate target-indax-start (target)
  :event target-standard-event-handler
  :code (behavior ()
    (target-indax-init)
    (go target-indax-stance)
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-stance (target)
  :event target-indax-handler
  :enter (behavior ()
    ((-> target-stance enter))
    (set! (-> self control mod-surface) *indax-walk-mods*)
    (none)
    )
  :exit (behavior ()
    ((-> target-stance exit))
    (target-indax-exit)
    (none)
    )
  :trans (behavior ()
    ((-> self state-hook))
    (when (move-legs?)
      (set! (-> self control bend-target) 0.0)
      (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
      (remove-exit)
      (go target-indax-walk)
      )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (can-hands? #t)
             )
        (go target-indax-running-attack)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons circle)
                       )
             (can-feet? #t)
             )
        (go target-indax-attack)
        )
    (fall-test target-indax-falling -4096000.0)
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 421)))
         (ja-no-eval :group! (-> self draw art-group data 422)
                     :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 422)) frames num-frames) -1)))
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (ja-channel-push! 1 (seconds 0.05))
         )
        ((let ((v1-32 (ja-group)))
           (and v1-32 (= v1-32 (-> self draw art-group data 437)))
           )
         (ja-no-eval :group! (-> self draw art-group data 442)
                     :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 442)) frames num-frames) -1)))
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (ja-channel-push! 1 (seconds 0.05))
         )
        ((let ((v1-62 (ja-group)))
           (and (and v1-62 (= v1-62 (-> self draw art-group data 417)))
                (< (-> self skel root-channel 2 frame-interp (-> self skel active-frame-interp)) 0.5)
                )
           )
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! (-> self draw art-group data 429)
                     :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 429)) frames num-frames) -1)))
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.05))
          )
        )
      )
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 415)
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 415)) frames num-frames) -1))
                    1.5
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 1.5))
        )
      )
    #f
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-walk (target)
  :event target-indax-handler
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (set! (-> self control mod-surface) *indax-walk-mods*)
    (none)
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-state-hook-exit)
    (target-indax-exit)
    (none)
    )
  :trans (behavior ()
    ((-> self state-hook))
    (when (not (move-legs?))
      (target-effect-exit)
      (remove-exit)
      (go target-indax-stance)
      )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (can-hands? #t)
             )
        (go target-indax-running-attack)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons circle)
                       )
             (can-feet? #t)
             )
        (go target-indax-attack)
        )
    (fall-test target-indax-falling -4096000.0)
    (none)
    )
  :code (behavior ()
    (let ((f26-0 0.0)
          (f30-0 0.0)
          (f28-0 0.0)
          (gp-0 (-> self clock frame-counter))
          )
      (let ((v1-3 (ja-group)))
        (cond
          ((and v1-3 (or (= v1-3 (-> self draw art-group data 416)) (= v1-3 (-> self draw art-group data 417))))
           (set! f26-0 (ja-frame-num 0))
           )
          ((let ((v1-9 (ja-group)))
             (and (or (and v1-9 (= v1-9 (-> self draw art-group data 419)))
                      (let ((v1-15 (ja-group)))
                        (and (and v1-15 (= v1-15 (-> self draw art-group data 418))) (< 15.0 (ja-aframe-num 0)))
                        )
                      )
                  (< 12288.0 (-> self control ctrl-xz-vel))
                  )
             )
           (ja-channel-push! 1 (seconds 0.01))
           (ja-no-eval :group! (-> self draw art-group data 427)
                       :num! (seek!
                         (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 427)) frames num-frames) -1))
                         2.0
                         )
                       :frame-num 0.0
                       )
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek! max 2.0))
             )
           (ja-channel-push! 3 (seconds 0.05))
           )
          (else
            (ja-channel-push! 3 (seconds 0.05))
            )
          )
        )
      (ja-no-eval :group! (-> self draw art-group data 417) :num! (identity f26-0) :dist 13107.2)
      (ja-no-eval :chan 1 :group! (-> self draw art-group data 423) :num! (identity f26-0) :dist 12697.6)
      (let ((a0-25 (-> self skel root-channel 2)))
        (let ((f0-12 (- 1.0 f30-0)))
          (set! (-> a0-25 frame-interp 1) f0-12)
          (set! (-> a0-25 frame-interp 0) f0-12)
          )
        (set! (-> a0-25 dist) 5939.2)
        (set! (-> a0-25 frame-group) (the-as art-joint-anim (-> self draw art-group data 416)))
        (set! (-> a0-25 param 0) 1.0)
        (set! (-> a0-25 frame-num) f26-0)
        (joint-control-channel-group! a0-25 (the-as art-joint-anim (-> self draw art-group data 416)) num-func-loop!)
        )
      (until #f
        (suspend)
        (let ((f26-1 (lerp-scale 0.0 1.0 (-> self control ctrl-xz-vel) 16384.0 32768.0)))
          (cond
            ((>= (- (-> self clock frame-counter) gp-0) (seconds 5))
             (set! gp-0 (-> self clock frame-counter))
             )
            ((>= (- (-> self clock frame-counter) gp-0) (seconds 2.5))
             )
            ((>= (- (-> self clock frame-counter) gp-0) (seconds 1))
             (set! f28-0 (seek f28-0 1.0 (* 2.0 (-> self clock seconds-per-frame))))
             )
            (else
              (set! f28-0 (seek f28-0 0.0 (* 2.0 (-> self clock seconds-per-frame))))
              )
            )
          (set! f30-0 (seek f30-0 f26-1 (* 4.0 (-> self clock seconds-per-frame))))
          )
        (let ((v1-94 (-> self skel root-channel 1)))
          (set! (-> v1-94 frame-interp 1) f28-0)
          (set! (-> v1-94 frame-interp 0) f28-0)
          )
        (let ((v1-98 (-> self skel root-channel 2))
              (f0-23 (- 1.0 f30-0))
              )
          (set! (-> v1-98 frame-interp 1) f0-23)
          (set! (-> v1-98 frame-interp 0) f0-23)
          )
        (let ((v1-101 (-> self skel effect))
              (a0-33 (cond
                       ((< 0.5 f30-0)
                        (if (< 0.5 f28-0)
                            1
                            0
                            )
                        )
                       (else
                         2
                         )
                       )
                     )
              )
          (set! (-> v1-101 channel-offset) a0-33)
          )
        0
        (let* ((f0-27 (* (current-cycle-distance (-> self skel)) (-> self control scale x)))
               (f0-29 (/ (* 60.0 (-> self control ctrl-xz-vel)) (* 60.0 f0-27)))
               )
          (ja :num! (loop! f0-29))
          )
        (ja :chan 1 :num! (chan 0))
        (ja :chan 2 :num! (chan 0))
        )
      )
    #f
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-falling (target)
  :event target-indax-jump-event-handler
  :enter (behavior ((arg0 symbol))
    ((-> target-falling enter) arg0)
    (set! (-> self control mod-surface) *indax-jump-mods*)
    (none)
    )
  :exit target-indax-exit
  :trans (behavior ()
    (set! (-> self control unknown-float36)
          (fmax
            (-> self control unknown-float36)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
            )
          )
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-indax-hit-ground #f)
        )
    (if (and (cpad-pressed? (-> self control cpad number) circle) (can-feet? #f))
        (go target-indax-attack-air #f)
        )
    (let ((f0-3 (fmax 0.0 (fmin 1.0 (* 0.000048828126 (+ -10240.0 (-> self control ctrl-xz-vel)))))))
      (if (< (-> self control unknown-float35) f0-3)
          (seek! (-> self control unknown-float35) f0-3 (* 4.0 (-> self clock seconds-per-frame)))
          )
      )
    (none)
    )
  :code (behavior ((arg0 symbol))
    (let ((a1-0 75))
      (let ((v1-2 (ja-group)))
        (cond
          ((and v1-2 (or (= v1-2 (-> self draw art-group data 418)) (= v1-2 (-> self draw art-group data 419))))
           )
          (else
            (let ((v1-8 (ja-group)))
              (cond
                ((and v1-8 (= v1-8 (-> self draw art-group data 428)))
                 (set! a1-0 15)
                 (set! (-> self control unknown-float35) 0.0)
                 )
                (else
                  (set! (-> self control unknown-float35) 0.0)
                  )
                )
              )
            )
          )
        )
      (ja-channel-push! 1 (the-as time-frame a1-0))
      )
    (ja-no-eval :group! (-> self draw art-group data 419) :num! (loop!) :frame-num 0.0)
    (until #f
      (seek! (-> self control unknown-float35) 0.0 (* 10.0 (-> self clock seconds-per-frame)))
      (suspend)
      (ja-blend-eval)
      (ja :num! (loop!))
      )
    #f
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-jump (target)
  :event target-indax-jump-event-handler
  :enter (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (let ((t9-0 (-> target-jump enter)))
      (set! arg2 (cond
                   (arg2
                     (empty)
                     arg2
                     )
                   (else
                     *indax-jump-mods*
                     )
                   )
            )
      (t9-0 arg0 arg1 arg2)
      )
    (set! (-> self control unknown-float35) 0.0)
    (none)
    )
  :exit (behavior ()
    (target-exit)
    (target-indax-exit)
    (none)
    )
  :trans (behavior ()
    ((-> target-indax-falling trans))
    (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (if (and (cpad-pressed? (-> self control cpad number) x)
             (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 12288.0)
             (and (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                  (not (logtest? (water-flags touch-water) (-> self water flags)))
                  (not (logtest? (state-flags prevent-jump prevent-double-jump) (-> self state-flags)))
                  )
             )
        (go
          target-indax-double-jump
          (-> *TARGET-bank* indax-double-jump-height-min)
          (-> *TARGET-bank* indax-double-jump-height-max)
          )
        )
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (ja-channel-push! 2 (seconds 0.02))
    (ja :group! (-> self draw art-group data 418) :num! min)
    (ja :chan 1 :group! (-> self draw art-group data 424) :num! (chan 0))
    (suspend)
    (until (ja-done? 0)
      (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            (f0-4 (- 10.0 (ja-aframe-num 0)))
            (gp-1 (-> self skel root-channel 0))
            )
        (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
        (let ((v1-26 (and (< 0.0 f30-0) (< 0.0 f0-4))))
          (set! (-> gp-1 param 1)
                (if v1-26
                    (fmin (fmin 3.0 f0-4) (/ (* 10.0 f0-4) (the float (time-to-apex f30-0 -245760.0))))
                    1.0
                    )
                )
          )
        (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      (let ((a0-8 (-> self skel root-channel 1)))
        (let ((f0-10 (-> self control unknown-float35)))
          (set! (-> a0-8 frame-interp 1) f0-10)
          (set! (-> a0-8 frame-interp 0) f0-10)
          )
        (set! (-> a0-8 param 0) 0.0)
        (joint-control-channel-group-eval! a0-8 (the-as art-joint-anim #f) num-func-chan)
        )
      (suspend)
      )
    (go target-indax-falling #f)
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-double-jump (target)
  :event target-indax-jump-event-handler
  :enter (behavior ((arg0 float) (arg1 float))
    (set! (-> self state-time) (-> self clock frame-counter))
    (init-var-jump arg0 arg1 #t #t (-> self control transv) 2.0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (if (!= (-> self control mod-surface) *slide-jump-mods*)
        (set! (-> self control mod-surface) *indax-double-jump-mods*)
        )
    (let ((v1-10 (ja-group)))
      (cond
        ((and v1-10 (or (= v1-10 (-> self draw art-group data 418)) (= v1-10 (-> self draw art-group data 419))))
         )
        (else
          (set! (-> self control unknown-float35) 0.0)
          )
        )
      )
    (none)
    )
  :exit (-> target-indax-jump exit)
  :trans (behavior ()
    ((-> target-indax-falling trans))
    (mod-var-jump #t #t (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float))
    (sound-play "jump-double")
    (let ((v1-3 (ja-group)))
      (cond
        ((and (and v1-3 (= v1-3 (-> self draw art-group data 418))) (< 0.6 (-> self control unknown-float35)))
         (ja-channel-push! 2 (seconds 0.04))
         (ja-no-eval :group! (-> self draw art-group data 418)
                     :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 418)) frames num-frames) -1)))
                     :frame-num (ja-aframe 1.0 0)
                     )
         (ja :chan 1 :group! (-> self draw art-group data 424) :num! (chan 0))
         )
        (else
          (ja-channel-push! 2 (seconds 0.05))
          (ja-no-eval :group! (-> self draw art-group data 418)
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 418)) frames num-frames) -1)))
                      :frame-num (ja-aframe 5.0 0)
                      )
          (ja :chan 1 :group! (-> self draw art-group data 424) :num! (chan 0))
          )
        )
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      (let ((a0-16 (-> self skel root-channel 1)))
        (let ((f0-14 (-> self control unknown-float35)))
          (set! (-> a0-16 frame-interp 1) f0-14)
          (set! (-> a0-16 frame-interp 0) f0-14)
          )
        (set! (-> a0-16 param 0) 0.0)
        (joint-control-channel-group-eval! a0-16 (the-as art-joint-anim #f) num-func-chan)
        )
      )
    (go target-indax-falling #f)
    (none)
    )
  :post target-post
  )

(defstate target-indax-hit-ground (target)
  :event target-indax-handler
  :enter (behavior ((arg0 symbol))
    ((-> target-hit-ground enter) arg0)
    (set! (-> self control mod-surface) *indax-walk-mods*)
    (none)
    )
  :exit target-indax-exit
  :trans (behavior ()
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
    (if (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
        (go target-indax-walk)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (can-hands? #t)
             )
        (go target-indax-running-attack)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons circle)
                       )
             (can-feet? #t)
             )
        (go target-indax-attack)
        )
    (fall-test target-falling -4096000.0)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! (-> self draw art-group data 420)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 420)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go target-indax-stance)
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-trip (target)
  :event target-indax-jump-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (sound-play "jump" :vol 70)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (none)
    )
  :exit (behavior ()
    (target-exit)
    (target-indax-exit)
    (none)
    )
  :code (behavior ()
    (set! (-> self control mod-surface) *indax-bounce-mods*)
    (ja-channel-push! 1 (seconds 0.02))
    (ja-no-eval :group! (-> self draw art-group data 443)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 443)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-y-vel adjust-xz-vel) 1.0 1.0 2.0)
      (suspend)
      (ja :num! (seek!))
      )
    (while (not (logtest? (-> self control status) (collide-status on-surface)))
      (suspend)
      )
    (ja-no-eval :group! (-> self draw art-group data 444)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 444)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    (none)
    )
  :post target-no-stick-post
  )

(defstate target-indax-attack (target)
  :event target-indax-dangerous-event-handler
  :enter (-> target-attack enter)
  :exit (behavior ()
    ((-> target-attack exit))
    (target-indax-exit)
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self draw art-group data 421)))
      (quaternion-rotate-y! (-> self control quat-for-control) (-> self control quat-for-control) -1365.3334)
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! gp-0
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1))
                    (-> self control current-surface align-speed)
                    )
                  :frame-num 0.0
                  )
      )
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                           (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                           )
                                   (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                   )
                           (pad-buttons x)
                           )
                 (can-jump? #f)
                 )
        (set-quaternion! (-> self control) (-> self control dir-targ))
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
      (suspend)
      (ja :num! (seek! max (-> self control current-surface align-speed)))
      )
    (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
    (if (< 11.4 (ja-aframe-num 0))
        (ja :num-func num-func-identity :frame-num max)
        )
    (go target-indax-stance)
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-attack-air (target)
  :event target-indax-dangerous-event-handler
  :enter (-> target-attack-air enter)
  :exit (behavior ()
    ((-> target-attack-air exit))
    (target-indax-exit)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (let ((gp-0 (-> self draw art-group data 428)))
      (ja-channel-push! 1 (seconds 0.05))
      (ja-no-eval :group! gp-0
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1))
                    (-> self control current-surface align-speed)
                    )
                  :frame-num 0.0
                  )
      )
    (until (ja-done? 0)
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                           (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                           )
                                   (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                   )
                           (pad-buttons x)
                           )
                 (can-jump? #f)
                 )
        (set-quaternion! (-> self control) (-> self control dir-targ))
        (go
          target-indax-jump
          (-> *TARGET-bank* indax-jump-height-min)
          (-> *TARGET-bank* indax-jump-height-max)
          (the-as surface #f)
          )
        )
      (suspend)
      (ja :num! (seek! max (-> self control current-surface align-speed)))
      )
    (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
    (go target-indax-falling #f)
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-running-attack (target)
  :event target-indax-dangerous-event-handler
  :enter (-> target-running-attack enter)
  :exit (behavior ()
    ((-> target-running-attack enter))
    (target-indax-exit)
    (none)
    )
  :code (behavior ()
    (if (logtest? (water-flags touch-water) (-> self water flags))
        (sound-play "swim-stroke")
        )
    (set! (-> self control dynam gravity-max) 368640.0)
    (set! (-> self control dynam gravity-length) 368640.0)
    (let ((gp-1 (-> self draw art-group data 437)))
      (ja-channel-push! 1 (seconds 0.02))
      (ja-no-eval :group! gp-1 :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-1) frames num-frames) -1))))
      )
    (target-start-attack)
    (target-danger-set! 'punch #f)
    (let ((f26-0 (the-as number 0.0))
          (f30-0 1.0)
          (gp-2 0)
          (f28-0 1.0)
          )
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (when (not (ja-min? 0))
          (cond
            ((and (>= (ja-aframe-num 0) 20.0)
                  (and (and (not (logtest? (-> self control status) (collide-status on-surface)))
                            (>= (- (-> self clock frame-counter) (-> self control last-time-on-surface))
                                (the-as time-frame (-> *TARGET-bank* ground-timeout))
                                )
                            (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                            (>= (target-height-above-ground) (-> *TARGET-bank* fall-height))
                            )
                       (>= (- (-> self clock frame-counter) (-> self control sliding-start-time)) (seconds 0.04))
                       )
                  )
             (go target-indax-falling #f)
             )
            ((< (the-as float f26-0) 0.0)
             (set! f26-0 (seek (the-as float f26-0) -0.04096 (* 491520.0 (-> self clock seconds-per-frame))))
             (set-forward-vel (the-as float f26-0))
             )
            ((and (nonzero? (-> self control unknown-time-frame18))
                  (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame18)) (seconds 0.04))
                  )
             (set-forward-vel 0.0)
             )
            ((and (not (cpad-hold? (-> self control cpad number) square))
                  (>= (- (-> self clock frame-counter) (-> self control unknown-combo-tracker00 move-start-time))
                      (seconds 0.05)
                      )
                  )
             (if (= (-> self control ground-pat material) (pat-material ice))
                 (set-forward-vel (fmax 32768.0 (* 0.8 (-> self control ctrl-xz-vel))))
                 (set-forward-vel (* 0.8 (-> self control ctrl-xz-vel)))
                 )
             )
            ((ja-done? 0)
             (set-forward-vel (the-as float f26-0))
             )
            (else
              (set! f26-0
                    (* (target-align-vel-z-adjust (-> self align delta trans z)) (-> self clock frames-per-second) f30-0)
                    )
              (set-forward-vel (the-as float f26-0))
              )
            )
          )
        (let ((s5-1 (new-stack-vector0)))
          (vector-matrix*! s5-1 (-> self control transv) (-> self control w-R-c))
          (set! (-> s5-1 y) 0.0)
          (vector-matrix*! (-> self control align-xz-vel) s5-1 (-> self control c-R-w))
          )
        (when (!= (the-as float (-> self control unknown-word04)) 0.0)
          (activate! *camera-smush-control* 819.2 15 75 1.0 0.9 (-> *display* camera-clock))
          (set! f26-0 (-> self control unknown-word04))
          (set! (-> self control unknown-word04) (the-as uint 0.0))
          )
        (suspend)
        (ja :num! (seek! max (* (-> self control current-surface align-speed) f28-0)))
        (if (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.1))
            (set! (-> *run-attack-mods* turnvv) 0.0)
            )
        (if (< 2 gp-2)
            (set! f30-0 (* f30-0 (fmin 1.0 (-> self control zx-vel-frac))))
            )
        (+! gp-2 1)
        )
      )
    (if (and (not (logtest? (-> self control status) (collide-status on-surface)))
             (>= (- (-> self clock frame-counter) (-> self control last-time-on-surface))
                 (the-as time-frame (-> *TARGET-bank* ground-timeout))
                 )
             (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
             (>= (target-height-above-ground) (-> *TARGET-bank* fall-height))
             )
        (go target-indax-falling #f)
        )
    (go target-indax-stance)
    (none)
    )
  :post target-post
  )

;; WARN: Return type mismatch float vs none.
(defbehavior target-indax-hit-setup-anim target ((arg0 attack-info))
  (case (-> arg0 angle)
    (('back)
     (let ((v1-3 (ja-group)))
       (when (not (and v1-3 (= v1-3 (-> self draw art-group data 431))))
         (ja-channel-push! 1 (seconds 0.075))
         (ja :group! (-> self draw art-group data 431) :num! min)
         )
       )
     )
    (else
      (let ((v1-12 (ja-group)))
        (when (not (and v1-12 (= v1-12 (-> self draw art-group data 430))))
          (ja-channel-push! 1 (seconds 0.075))
          (ja :group! (-> self draw art-group data 430) :num! min)
          )
        )
      )
    )
  (none)
  )

(defstate target-indax-hit (target)
  :event target-indax-handler
  :exit (behavior ()
    ((-> target-hit exit))
    (target-indax-exit)
    (none)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (pickup-collectable! (-> self fact-override) (pickup-type health) 100.0 (the-as handle #f))
        (go target-indax-stance)
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flags jump-out))
    (set! (-> self state-time) (-> self clock frame-counter))
    (set! (-> self neck flex-blend) 0.0)
    (let ((gp-0 (-> self attack-info)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((v1-5 gp-0))
          (set! (-> v1-5 attacker) (the-as handle #f))
          (set! (-> v1-5 mode) 'generic)
          (set! (-> v1-5 shove-back) 6144.0)
          (set! (-> v1-5 shove-up) 4915.2)
          (set! (-> v1-5 angle) #f)
          (set! (-> v1-5 trans quad) (-> self control trans quad))
          (set! (-> v1-5 control) 0.0)
          (set! (-> v1-5 invinc-time) (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)))
          (set! (-> v1-5 damage) (-> *FACT-bank* health-default-inc))
          )
        (case arg0
          (('shove)
           (let ((v1-8 gp-0))
             (set! (-> v1-8 shove-back) (-> *TARGET-bank* smack-surface-dist))
             (set! (-> v1-8 shove-up) (-> *TARGET-bank* smack-surface-height))
             (set! (-> v1-8 angle) 'shove)
             )
           )
          )
        (combine! gp-0 arg1 self)
        (when (not (logtest? (-> gp-0 mask) (attack-info-mask vector)))
          (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-for-control))
          (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
          (set! (-> gp-0 vector y) (-> gp-0 shove-up))
          )
        (set! (-> s5-0 quad) (-> gp-0 vector quad))
        (let ((f0-12 (vector-dot
                       (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                       )
                     )
              )
          (if (not (-> self attack-info angle))
              (set! (-> self attack-info angle) (if (>= 0.0 f0-12)
                                                    'front
                                                    'back
                                                    )
                    )
              )
          )
        (cond
          ((= arg0 'attack)
           (logior! (-> self focus-status) (focus-status hit))
           (set! (-> self game hit-time) (-> self clock frame-counter))
           (case (-> gp-0 mode)
             (('endlessfall)
              (cond
                ((= (-> self game mode) 'debug)
                 (let ((s4-1 (new-stack-vector0)))
                   (set! (-> s4-1 quad) (-> self control last-trans-on-ground quad))
                   (ja-channel-set! 0)
                   (let ((s3-1 (-> self clock frame-counter)))
                     (until (>= (- (-> self clock frame-counter) s3-1) (seconds 1))
                       (suspend)
                       )
                     )
                   (move-to-point! (-> self control) s4-1)
                   )
                 (set! (-> self control camera-pos quad) (-> self control trans quad))
                 (send-event *camera* 'teleport)
                 (go target-indax-stance)
                 )
                (else
                  (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
                  (go target-indax-death (-> gp-0 mode))
                  )
                )
              )
             (('instant-death 'smush 'tomb-spider 'bot)
              (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
              (if (= (-> self game mode) 'play)
                  (go target-indax-death (-> gp-0 mode))
                  )
              )
             (else
               (pickup-collectable! (-> self fact-override) (pickup-type health) (- (-> gp-0 damage)) (the-as handle #f))
               )
             )
           (target-hit-effect gp-0)
           )
          (else
            (case (-> gp-0 mode)
              (('burn 'burnup)
               (sound-play "get-burned")
               )
              )
            )
          )
        (set! (-> self control mod-surface) *smack-mods*)
        (target-indax-hit-setup-anim gp-0)
        (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-falling-anim-trans 1.0)
        )
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-override health)))
          (go target-indax-death (-> gp-0 mode))
          )
      )
    (go target-indax-hit-ground #f)
    (none)
    )
  :post target-indax-post
  )

(defstate target-indax-death (target)
  :event (-> target-death event)
  :exit (behavior ()
    ((-> target-death exit))
    (target-indax-exit)
    (none)
    )
  :trans (-> target-indax-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self 0)
    (set-setting! 'process-mask 'set 0 (process-mask enemy platform projectile death))
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (cond
      ((or (= arg0 'none) (= arg0 'instant-death) (= arg0 'bot))
       )
      ((= arg0 'endlessfall)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds175" -99.0 0)
             )
       (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
       (set! (-> self control pat-ignore-mask)
             (logior (new 'static 'pat-surface :noendlessfall #x1) (-> self control pat-ignore-mask))
             )
       (logclear! (-> self water flags) (water-flags swim-ground))
       (set! (-> self post-hook) target-no-move-post)
       (let ((f30-0 (if (rand-vu-percent? 0.2)
                        0.0
                        55.0
                        )
                    )
             )
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! (-> self draw art-group data 434)
                     :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 434)) frames num-frames) -1)))
                     :frame-num (ja-aframe f30-0 0)
                     )
         )
       (until (ja-done? 0)
         (let ((a1-8 (new 'stack-no-clear 'event-message-block)))
           (let ((v1-50 (process->ppointer self)))
             (set! (-> a1-8 from) v1-50)
             )
           (set! (-> a1-8 num-params) 2)
           (set! (-> a1-8 message) 'joystick)
           (set! (-> a1-8 param 0) (the-as uint 0))
           (set! (-> a1-8 param 1) (the-as uint -1082130432))
           (send-event-function *camera* a1-8)
           )
         (vector-reset! (-> self control transv))
         (suspend)
         (ja :num! (seek!))
         )
       (remove-setting! 'mode-name)
       )
      ((= arg0 'smush)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
             )
       (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
       (set! (-> self control mod-surface) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (ja-no-eval :group! (-> self draw art-group data 433)
                   :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 433)) frames num-frames) -1)))
                   :frame-num 0.0
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       )
      ((= arg0 'tomb-spider)
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
             )
       (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
       (set! (-> self control mod-surface) *neutral-mods*)
       (ja-channel-push! 1 (seconds 0.1))
       (cond
         ((rand-vu-percent? 0.5)
          (ja-no-eval :group! (-> self draw art-group data 436)
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 436)) frames num-frames) -1)))
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
         (else
           (ja-no-eval :group! (-> self draw art-group data 435)
                       :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 435)) frames num-frames) -1)))
                       :frame-num 0.0
                       )
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek!))
             )
           )
         )
       )
      (else
        (set! (-> self control unknown-sound-id00)
              (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "ds173" -99.0 0)
              )
        (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
        (set! (-> self control mod-surface) *neutral-mods*)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! (-> self draw art-group data 435)
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 435)) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (initialize! (-> self game) 'life (the-as game-save #f) (the-as string #f))
    (set! (-> self state-time) (-> self clock frame-counter))
    (sleep-code)
    (none)
    )
  :post target-no-stick-post
  )
