;;-*-Lisp-*-
(in-package goal)

;; name: tomb-water.gc
;; name in dgo: tomb-water
;; dgos: TOA

;; +++tomb-water:simon-block-flags
(defenum simon-block-flags
  :type uint16
  :bitfield #t
  (sbf0)
  (sbf1)
  (sbf2)
  (sbf3)
  (sbf4)
  (sbf5)
  (sbf6)
  (sbf7)
  (sbf8)
  (sbf9)
  (sbf10)
  (sbf11)
  (sbf12)
  (sbf13)
  (sbf14)
  (sbf15)
  )
;; ---tomb-water:simon-block-flags

(declare-type tomb-simon-block base-plat)
(define-extern tomb-simon-block-init-by-other (function vector int int int int none :behavior tomb-simon-block))

;; DECOMP BEGINS

(deftype tomb-door (process-drawable)
  ((notify-actor entity  :offset-assert 200)
   (round        uint32  :offset-assert 204)
   )
  :heap-base #x50
  :method-count-assert 22
  :size-assert         #xd0
  :flag-assert         #x16005000d0
  (:methods
    (idle () _type_ :state 20)
    (open (time-frame) _type_ :state 21)
    )
  )


(defskelgroup skel-tomb-door tomb-door tomb-door-lod0-jg tomb-door-idle-ja
              ((tomb-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 4 4 0 7)
              )

(defstate idle (tomb-door)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('simon-done)
       (sound-play "simon-correct")
       )
      (('trigger)
       (go-virtual open (seconds 0.5))
       )
      )
    )
  :trans (behavior ()
    (when (logtest? (actor-option user17) (-> self fact options))
      (let* ((gp-0 *target*)
             (a0-3 (if (type? gp-0 process-focusable)
                       gp-0
                       )
                   )
             (s4-0 (-> self root trans))
             )
        (when a0-3
          (let* ((s3-0 (get-trans a0-3 0))
                 (s5-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s3-0 s4-0) 1.0))
                 (gp-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                 )
            (if (and (< (vector-vector-xz-distance s4-0 s3-0) 61440.0) (< (vector-dot s5-0 gp-1) 0.0))
                (go-virtual open 0)
                )
            )
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior tomb-door) sleep-code)
  )

(defstate open (tomb-door)
  :virtual #t
  :enter (behavior ((arg0 time-frame))
    (let ((gp-0 (-> self notify-actor)))
      (when gp-0
        (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-0 from) (process->ppointer self))
          (set! (-> a1-0 num-params) 0)
          (set! (-> a1-0 message) 'untrigger)
          (let ((t9-0 send-event-function)
                (v1-2 gp-0)
                )
            (t9-0
              (if v1-2
                  (-> v1-2 extra process)
                  )
              a1-0
              )
            )
          )
        (when (< (-> *event-queue* length) (-> *event-queue* allocated-length))
          (let ((v0-3 (-> *event-queue* data (-> *event-queue* length))))
            (+! (-> *event-queue* length) 1)
            (set! (-> v0-3 form-handle) (process->handle self))
            (set! (-> v0-3 to-handle) (process->handle (if gp-0
                                                           (-> gp-0 extra process)
                                                           )
                                                       )
                  )
            (set! (-> v0-3 num-params) 1)
            (set! (-> v0-3 message) 'set-round)
            (set! (-> v0-3 param 0) (-> self round))
            )
          )
        )
      )
    (none)
    )
  :code (behavior ((arg0 time-frame))
    (let ((s5-0 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) s5-0) arg0)
        (suspend)
        )
      )
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (-> self root quat)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-door ((obj tomb-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 16384.0 16384.0 0.0 36864.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 8192.0 16384.0 4096.0 22528.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set! (-> v1-13 transform-index) 5)
      (set-vector! (-> v1-13 local-sphere) -8192.0 16384.0 4096.0 22528.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj fact)
        (new 'process 'fact-info obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (set! (-> obj notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! (-> obj round) (res-lump-value (-> obj entity) 'extra-id uint :time -1000000000.0))
  (ja-channel-push! 1 0)
  (let ((a0-27 (-> obj skel root-channel 0)))
    (set! (-> a0-27 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-27 frame-num) 0.0)
    (joint-control-channel-group! a0-27 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype tomb-beetle-door (process-drawable)
  ((offset            vector                3 :inline :offset-assert 208)
   (offset-index      int32                           :offset-assert 256)
   (key-index         int32                           :offset-assert 260)
   (beetle            handle                3         :offset-assert 264)
   (actor-group       (pointer actor-group)           :offset-assert 288)
   (actor-group-count int32                           :offset-assert 292)
   )
  :heap-base #xb0
  :method-count-assert 22
  :size-assert         #x128
  :flag-assert         #x1600b00128
  (:methods
    (idle () _type_ :state 20)
    (open () _type_ :state 21)
    )
  )


(defskelgroup skel-tomb-beetle-door tomb-beetle-door tomb-beetle-door-lod0-jg tomb-beetle-door-idle-ja
              ((tomb-beetle-door-lod0-mg (meters 999999)))
              :bounds (static-spherem 4 4 0 7)
              )

(defstate idle (tomb-beetle-door)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('add-beetle)
       (set! (-> self beetle (-> self offset-index)) (process->handle proc))
       (+! (-> self offset-index) 1)
       (-> self offset (+ (-> self offset-index) -1))
       )
      (('key)
       (+! (-> self key-index) 1)
       (if (= (-> self key-index) 3)
           (go-virtual open)
           )
       )
      (('trigger)
       (go-virtual open)
       )
      )
    )
  :code (the-as (function none :behavior tomb-beetle-door) sleep-code)
  :post (behavior ()
    0
    (none)
    )
  )

(defstate open (tomb-beetle-door)
  :virtual #t
  :enter (behavior ()
    (let ((gp-0 (-> self actor-group 0)))
      (dotimes (s5-0 (-> gp-0 length))
        (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-0 from) (process->ppointer self))
          (set! (-> a1-0 num-params) 0)
          (set! (-> a1-0 message) 'die)
          (let ((t9-0 send-event-function)
                (v1-5 (-> gp-0 data s5-0 actor))
                )
            (t9-0
              (if v1-5
                  (-> v1-5 extra process)
                  )
              a1-0
              )
            )
          )
        )
      )
    (let ((gp-1 (-> self actor-group 1)))
      (dotimes (s5-1 (-> gp-1 length))
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer self))
          (set! (-> a1-1 num-params) 0)
          (set! (-> a1-1 message) 'door-open)
          (let ((t9-1 send-event-function)
                (v1-16 (-> gp-1 data s5-1 actor))
                )
            (t9-1
              (if v1-16
                  (-> v1-16 extra process)
                  )
              a1-1
              )
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    (none)
    )
  :post (the-as (function none :behavior tomb-beetle-door) ja-post)
  )

(define tomb-beetle-door-offsets (new 'static 'inline-array vector 3
                                   (new 'static 'vector :x 8192.0 :y 20480.0 :z 819.2 :w 1.0)
                                   (new 'static 'vector :x 16384.0 :y 20480.0 :z 819.2 :w 1.0)
                                   (new 'static 'vector :x 24576.0 :y 20480.0 :z 819.2 :w 1.0)
                                   )
        )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-beetle-door ((obj tomb-beetle-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 16384.0 16384.0 4096.0 49152.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-11 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-11 prim-core action) (collide-action solid))
      (set! (-> v1-11 transform-index) 4)
      (set-vector! (-> v1-11 local-sphere) 8192.0 16384.0 4096.0 22528.0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set! (-> v1-13 transform-index) 5)
      (set-vector! (-> v1-13 local-sphere) -8192.0 16384.0 4096.0 22528.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-beetle-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (countdown (s5-2 3)
    (vector-orient-by-quat! (-> obj offset s5-2) (-> tomb-beetle-door-offsets s5-2) (-> obj root quat))
    (set! (-> obj offset s5-2 w) (quaternion-y-angle (-> obj root quat)))
    (set! (-> obj beetle s5-2) (the-as handle #f))
    )
  (set! (-> obj offset-index) 0)
  (set! (-> obj key-index) 0)
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-33 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-33 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-33))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (ja-channel-push! 1 0)
  (let ((a0-30 (-> obj skel root-channel 0)))
    (set! (-> a0-30 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-30 frame-num) 0.0)
    (joint-control-channel-group! a0-30 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(defskelgroup skel-tomb-button tomb-button tomb-button-lod0-jg tomb-button-idle-ja
              ((tomb-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 2.5)
              )

(deftype tomb-button (basebutton)
  ()
  :heap-base #xa0
  :method-count-assert 39
  :size-assert         #x120
  :flag-assert         #x2700a00120
  )


(defmethod basebutton-method-33 tomb-button ((obj tomb-button))
  "TODO - joint stuff"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-button" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ja-channel-set! 1)
  (cond
    ((logtest? (-> obj button-status) (button-status pressed))
     (let ((s5-1 (-> obj skel root-channel 0)))
       (joint-control-channel-group-eval!
         s5-1
         (the-as art-joint-anim (-> obj draw art-group data 2))
         num-func-identity
         )
       (set! (-> s5-1 frame-num)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 2)) frames num-frames) -1))
             )
       )
     )
    (else
      (let ((s5-2 (-> obj skel root-channel 0)))
        (joint-control-channel-group-eval!
          s5-2
          (the-as art-joint-anim (-> obj draw art-group data 2))
          num-func-identity
          )
        (set! (-> s5-2 frame-num) 0.0)
        )
      )
    )
  (transform-post)
  (none)
  )

;; WARN: Return type mismatch collide-shape vs none.
(defmethod basebutton-method-34 tomb-button ((obj tomb-button))
  "TODO - collision stuff"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 9011.2)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod prepare-trigger-event! tomb-button ((obj tomb-button))
  "Sets `event-going-down` to `'trigger`"
  (logior! (-> obj button-status) (button-status button-status-4))
  (set! (-> obj event-going-down) 'cue-chase)
  (set! (-> obj root-override trans y) (+ 204.8 (-> obj root-override trans y)))
  (none)
  )

(deftype tomb-beetle-button (tomb-button)
  ((round        uint32      :offset-assert 288)
   (speech-mask  uint32      :offset-assert 292)
   (speech-timer time-frame  :offset-assert 296)
   )
  :heap-base #xb0
  :method-count-assert 40
  :size-assert         #x130
  :flag-assert         #x2800b00130
  (:methods
    (tomb-beetle-button-method-39 (_type_) none 39)
    )
  )


(defmethod tomb-beetle-button-method-39 tomb-beetle-button ((obj tomb-beetle-button))
  (with-pp
    (when (>= (- (-> pp clock frame-counter) (-> obj speech-timer)) (seconds 6))
      (let ((s5-0 (rand-vu-int-count-excluding 4 (the-as int (-> obj speech-mask)))))
        (let* ((v1-4 s5-0)
               (t0-0 (cond
                       ((zero? v1-4)
                        "ora011"
                        )
                       ((= v1-4 1)
                        "ora012"
                        )
                       ((= v1-4 2)
                        "ora013"
                        )
                       ((= v1-4 3)
                        "ora014"
                        )
                       )
                     )
               )
          (add-process *gui-control* obj (gui-channel alert) (gui-action play) t0-0 -99.0 0)
          )
        (set! (-> obj speech-mask) (the-as uint (ash 1 s5-0)))
        )
      (set! (-> obj speech-timer) (-> pp clock frame-counter))
      )
    0
    (none)
    )
  )

(defstate going-down (tomb-beetle-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('get-round)
       (-> self round)
       )
      (else
        ((-> (method-of-type basebutton going-down) event) proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type tomb-button going-down) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (process-grab? *target* #f)
    (none)
    )
  )

(defstate down-idle (tomb-beetle-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (cond
                       ((= v1-0 'set-round)
                        (let ((v0-0 (the-as object (-> event param 0))))
                          (set! (-> self round) (the-as uint v0-0))
                          v0-0
                          )
                        )
                       ((= v1-0 'door-open)
                        (remove-setting! 'gun)
                        (the-as object (remove-setting! 'entity-name))
                        )
                       (else
                         ((-> (method-of-type basebutton down-idle) event) proc arg1 event-type event)
                         )
                       )
              )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type tomb-button down-idle) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 4))
      (if (and *target* (logtest? (-> *target* focus-status) (focus-status grabbed)))
          (process-release? *target*)
          )
      (if (and *target*
               (logtest? (state-flags prevent-gun) (-> *target* state-flags))
               (cpad-pressed? (-> *target* control cpad number) up right down left r1)
               )
          (tomb-beetle-button-method-39 self)
          )
      )
    (none)
    )
  )

(defstate going-up (tomb-beetle-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('set-round)
       (let ((v0-0 (the-as object (-> event param 0))))
         (set! (-> self round) (the-as uint v0-0))
         v0-0
         )
       )
      (else
        ((-> (method-of-type basebutton going-up) event) proc arg1 event-type event)
        )
      )
    )
  )

(defstate up-idle (tomb-beetle-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('get-round)
       (-> self round)
       )
      (('set-round)
       (let ((v0-0 (the-as object (-> event param 0))))
         (set! (-> self round) (the-as uint v0-0))
         v0-0
         )
       )
      (else
        ((-> (method-of-type basebutton up-idle) event) proc arg1 event-type event)
        )
      )
    )
  :trans (behavior ()
    (let ((t9-1 (-> (the-as (state basebutton) (find-parent-method tomb-beetle-button 30)) trans)))
      (if t9-1
          (t9-1)
          )
      )
    (let ((v1-2 *target*))
      (cond
        ((and v1-2 (< (vector-vector-xz-distance (-> v1-2 control trans) (-> self root-override trans)) 40960.0))
         (when (zero? (-> self entity extra perm user-uint8 1))
           (tomb-beetle-button-method-39 self)
           (let ((v1-15 (-> self entity extra perm)))
             (logior! (-> v1-15 status) (entity-perm-status bit-5))
             (set! (-> v1-15 user-int8 1) 1)
             )
           )
         (set-setting! 'gun #f 0 0)
         (set-setting! 'entity-name "camera-194" 0 0)
         (if (and *target*
                  (logtest? (state-flags prevent-gun) (-> *target* state-flags))
                  (cpad-pressed? (-> *target* control cpad number) up right down left r1)
                  )
             (tomb-beetle-button-method-39 self)
             )
         )
        (else
          (remove-setting! 'gun)
          (remove-setting! 'entity-name)
          )
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod send-event! tomb-beetle-button ((obj tomb-beetle-button) (arg0 symbol))
  "Prepares an [[event-message-block]] using the provided type to send an event to:
- the `notify-actor`
- every [[entity-actor]] in the `actor-group` array
@see [[entity-actor]]"
  (when arg0
    (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-1 from) (process->ppointer self))
      (set! (-> a1-1 num-params) 0)
      (set! (-> a1-1 message) arg0)
      (let ((t9-0 send-event-function)
            (v1-1 (-> obj notify-actor))
            )
        (t9-0
          (if v1-1
              (-> v1-1 extra process)
              )
          a1-1
          )
        )
      )
    (let ((s4-0 (-> obj actor-group (-> obj round))))
      (dotimes (s3-0 (-> s4-0 length))
        (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-2 from) (process->ppointer self))
          (set! (-> a1-2 num-params) 1)
          (set! (-> a1-2 message) arg0)
          (set! (-> a1-2 param 0) (-> obj round))
          (let ((t9-1 send-event-function)
                (v1-11 (-> s4-0 data s3-0 actor))
                )
            (t9-1
              (if v1-11
                  (-> v1-11 extra process)
                  )
              a1-2
              )
            )
          )
        )
      )
    )
  (none)
  )

(defmethod prepare-trigger-event! tomb-beetle-button ((obj tomb-beetle-button))
  "Sets `event-going-down` to `'trigger`"
  (let ((t9-0 (method-of-type tomb-button prepare-trigger-event!)))
    (t9-0 obj)
    )
  (set! (-> obj round) (-> obj entity extra perm user-uint8 0))
  (set! (-> obj speech-mask) (the-as uint 0))
  (set! (-> obj speech-timer) 0)
  0
  (none)
  )

(defskelgroup skel-tomb-move-swing-pole tomb-move-swing-pole tomb-move-swing-pole-lod0-jg tomb-move-swing-pole-idle-ja
              ((tomb-move-swing-pole-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.5)
              )

(deftype tomb-simon-block (base-plat)
  ((sound-show  uint128                   :offset-assert 272)
   (color       vector            :inline :offset-assert 288)
   (my-idx      int32                     :offset-assert 304)
   (next-idx    int32                     :offset-assert 308)
   (flags       simon-block-flags         :offset-assert 312)
   (blink-timer time-frame        2       :offset-assert 320)
   (ride-timer  time-frame                :offset-assert 336)
   (order       int32                     :offset-assert 344)
   (base-height float                     :offset-assert 348)
   (move-rate   float                     :offset-assert 352)
   )
  :heap-base #xf0
  :method-count-assert 42
  :size-assert         #x164
  :flag-assert         #x2a00f00164
  (:methods
    (idle () _type_ :state 34)
    (ready () _type_ :state 35)
    (ridden () _type_ :state 36)
    (temporary () _type_ :state 37)
    (dangerous () _type_ :state 38)
    (wobble-die () _type_ :state 39)
    (die () _type_ :state 40)
    (set-blink-timers! (_type_) none 41)
    )
  )


(deftype tomb-plat-simon (process-drawable)
  ((plat           (array handle)    :offset-assert 200)
   (plat-seq       (pointer uint32)  :offset-assert 204)
   (plat-count     int32             :offset-assert 208)
   (plat-seq-count int32             :offset-assert 212)
   (plat-idx       int32             :offset-assert 216)
   (button-handle  handle            :offset-assert 224)
   (notify-actor   entity            :offset-assert 232)
   (flags          uint16            :offset-assert 236)
   )
  :heap-base #x70
  :method-count-assert 25
  :size-assert         #xee
  :flag-assert         #x19007000ee
  (:methods
    (dormant () _type_ :state 20)
    (appear () _type_ :state 21)
    (show-sequence () _type_ :state 22)
    (idle () _type_ :state 23)
    (tomb-plat-simon-method-24 (_type_ int) none 24)
    )
  )


(define *tomb-simon-sound-tbl* (new 'static 'array sound-name 4
                                 (static-sound-name "simon-red")
                                 (static-sound-name "simon-green")
                                 (static-sound-name "simon-blue")
                                 (static-sound-name "simon-yellow")
                                 )
        )

(define *tomb-simon-color-tbl* (new 'static 'inline-array vector 4
                                 (new 'static 'vector :x 0.8 :y 0.28 :z 0.28 :w 1.0)
                                 (new 'static 'vector :x 0.39 :y 0.61 :z 0.28 :w 1.0)
                                 (new 'static 'vector :x 0.28 :y 0.5 :z 0.61 :w 1.0)
                                 (new 'static 'vector :x 0.8 :y 0.64 :z 0.28 :w 1.0)
                                 )
        )

(defskelgroup skel-tomb-simon-block tomb-plat-simon tomb-plat-simon-lod0-jg tomb-plat-simon-idle-ja
              ((tomb-plat-simon-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 135]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 199]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 280]
(defbehavior tomb-plat-simon-handler tomb-plat-simon ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (the-as object (case arg2
                   (('ready-index)
                    (tomb-plat-simon-method-24 self (the-as int (-> arg3 param 0)))
                    )
                   (('plat-ridden)
                    (logior! (-> self flags) 1)
                    (when (= (-> arg3 param 0) (-> self plat-seq (+ (-> self plat-seq-count) -1)))
                      (when (-> self notify-actor)
                        (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                          (set! (-> a1-2 from) (process->ppointer self))
                          (set! (-> a1-2 num-params) 0)
                          (set! (-> a1-2 message) 'simon-done)
                          (let ((t9-1 send-event-function)
                                (v1-11 (-> self notify-actor))
                                )
                            (t9-1
                              (if v1-11
                                  (-> v1-11 extra process)
                                  )
                              a1-2
                              )
                            )
                          )
                        (when (< (-> *event-queue* length) (-> *event-queue* allocated-length))
                          (let ((v1-20 (-> *event-queue* data (-> *event-queue* length))))
                            (+! (-> *event-queue* length) 1)
                            (set! (-> v1-20 form-handle) (process->handle self))
                            (let ((a0-23 (-> self notify-actor)))
                              (set! (-> v1-20 to-handle) (process->handle (if a0-23
                                                                              (-> a0-23 extra process)
                                                                              )
                                                                          )
                                    )
                              )
                            (set! (-> v1-20 num-params) 0)
                            (set! (-> v1-20 message) 'trigger)
                            )
                          )
                        )
                      (sound-play "tomb-simon-fall")
                      (dotimes (s5-1 (-> self plat-count))
                        (if (!= s5-1 (-> arg3 param 0))
                            (send-event (handle->process (-> self plat s5-1)) 'die-unmaskable)
                            )
                        )
                      #f
                      )
                    )
                   (('finished)
                    (if (-> self button-handle)
                        (send-event (handle->process (-> self button-handle)) 'trigger)
                        )
                    (dotimes (gp-1 (-> self plat-count))
                      (send-event (handle->process (-> self plat gp-1)) 'die-unmaskable)
                      )
                    (go-virtual dormant)
                    )
                   (('die-but)
                    (if (-> self button-handle)
                        (send-event (handle->process (-> self button-handle)) 'untrigger)
                        )
                    (sound-play "tomb-simon-fall")
                    (dotimes (s5-3 (-> self plat-count))
                      (if (!= s5-3 (-> arg3 param 0))
                          (send-event (handle->process (-> self plat s5-3)) 'die)
                          )
                      )
                    (go-virtual dormant)
                    )
                   )
          )
  )

(defstate dormant (tomb-plat-simon)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger 'cue-chase)
       (set! (-> self button-handle) (process->handle proc))
       (go-virtual appear)
       )
      )
    )
  :code (the-as (function none :behavior tomb-plat-simon) sleep-code)
  )

(defstate appear (tomb-plat-simon)
  :virtual #t
  :event tomb-plat-simon-handler
  :enter (behavior ()
    (local-vars
      (sv-96 target)
      (sv-128 vector)
      (sv-136 int)
      (sv-144 int)
      (sv-160 int)
      (sv-176 (function vector vector float))
      )
    (set! (-> self state-time) (-> self clock frame-counter))
    (set! (-> self plat-idx) 0)
    (dotimes (gp-0 (-> self plat-count))
      (if (nonzero? (-> self plat gp-0))
          (send-event (handle->process (-> self plat gp-0)) 'die-unmaskable)
          )
      )
    (let ((gp-1 *target*))
      (set! sv-96 (if (type? gp-1 process-focusable)
                      gp-1
                      )
            )
      )
    (dotimes (gp-2 (-> self plat-count))
      (set! sv-128 (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (the float gp-2) 'exact))
      (set! sv-136 -1)
      (dotimes (v1-20 (+ (-> self plat-seq-count) -1))
        (if (= gp-2 (-> self plat-seq v1-20))
            (set! sv-136 (the-as int (-> self plat-seq (+ v1-20 1))))
            )
        )
      (let ((v1-26 (the int (* 0.000061035156 (+ 40960000.0 (-> sv-128 x)))))
            (a0-21 (the int (* 0.000061035156 (+ 40960000.0 (-> sv-128 z)))))
            )
        (set! sv-144 (logand (logior (logand v1-26 1) (* a0-21 2)) 3))
        )
      (let* ((s5-0 (get-process *default-dead-pool* tomb-simon-block #x4000))
             (s4-0 (when s5-0
                     (let ((t9-4 (method-of-type tomb-simon-block activate)))
                       (t9-4
                         (the-as tomb-simon-block s5-0)
                         self
                         (symbol->string (-> tomb-simon-block symbol))
                         (the-as pointer #x70004000)
                         )
                       )
                     (let ((s4-1 run-function-in-process)
                           (s3-0 s5-0)
                           (s2-0 tomb-simon-block-init-by-other)
                           (s1-0 sv-128)
                           (s0-0 gp-2)
                           )
                       (set! sv-160 sv-136)
                       (let ((f30-0 0.00012207031))
                         (set! sv-176 vector-vector-xz-distance)
                         (let* ((a0-26 (get-trans sv-96 0))
                                (a1-9 sv-128)
                                (t1-0 (the int (* f30-0 (sv-176 a0-26 a1-9))))
                                (t2-0 sv-144)
                                )
                           ((the-as (function object object object object object object object none) s4-1)
                            s3-0
                            s2-0
                            s1-0
                            s0-0
                            sv-160
                            t1-0
                            t2-0
                            )
                           )
                         )
                       )
                     (-> s5-0 ppointer)
                     )
                   )
             )
        (send-event (ppointer->process s4-0) 'reparent)
        (set! (-> self plat gp-2) (ppointer->handle s4-0))
        )
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-0) (seconds 2))
        (suspend)
        )
      )
    (go-virtual show-sequence)
    (none)
    )
  )

(defstate show-sequence (tomb-plat-simon)
  :virtual #t
  :event tomb-plat-simon-handler
  :enter (behavior ()
    (set! (-> self state-time) (+ (-> self clock frame-counter) (seconds -1)))
    (set! (-> self plat-idx) 0)
    0
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 2))
      (set! (-> self state-time) (-> self clock frame-counter))
      (if (< (-> self plat-idx) (-> self plat-seq-count))
          (send-event (handle->process (-> self plat (-> self plat-seq (-> self plat-idx)))) 'blink)
          )
      (if (zero? (-> self plat-idx))
          (tomb-plat-simon-method-24 self (the-as int (-> self plat-seq 0)))
          )
      (+! (-> self plat-idx) 1)
      (if (= (-> self plat-idx) (+ (-> self plat-seq-count) 1))
          (go-virtual idle)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior tomb-plat-simon) sleep-code)
  )

(defstate idle (tomb-plat-simon)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger 'cue-chase)
       (dotimes (gp-0 (-> self plat-count))
         (send-event (handle->process (-> self plat gp-0)) 'reset)
         )
       (go-virtual show-sequence)
       )
      (else
        (tomb-plat-simon-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (if (-> self button-handle)
        (send-event (handle->process (-> self button-handle)) 'untrigger)
        )
    (none)
    )
  :code (the-as (function none :behavior tomb-plat-simon) sleep-code)
  :post (behavior ()
    (debug-draw (-> self path))
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod tomb-plat-simon-method-24 tomb-plat-simon ((obj tomb-plat-simon) (arg0 int))
  (let ((a0-3 (handle->process (-> obj plat arg0))))
    (send-event a0-3 'ready)
    )
  (none)
  )

;; WARN: Return type mismatch process-drawable vs tomb-plat-simon.
(defmethod relocate tomb-plat-simon ((obj tomb-plat-simon) (arg0 int))
  (if (nonzero? (-> obj plat))
      (&+! (-> obj plat) arg0)
      )
  (the-as tomb-plat-simon ((method-of-type process-drawable relocate) obj arg0))
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-plat-simon ((obj tomb-plat-simon) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag))
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (change-parent obj *pusher-pool*)
  (set! (-> obj notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-2 (res-lump-data (-> obj entity) 'plat-seq pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-2 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj plat-seq-count) (the-as int (-> sv-16 elt-count)))
       (set! (-> obj plat-seq) (the-as (pointer uint32) v1-2))
       )
      (else
        (set! (-> obj plat-seq-count) 0)
        (set! (-> obj plat-seq) (the-as (pointer uint32) #f))
        )
      )
    )
  (let ((s4-0 arg0))
    (let ((v1-4 (entity-actor-lookup arg0 'path-actor 0)))
      (if v1-4
          (set! s4-0 v1-4)
          )
      )
    (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 s4-0 #f))
    )
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (set! (-> obj plat-count) (-> obj path curve num-cverts))
  (set! (-> obj plat) (new 'process 'boxed-array handle (-> obj plat-count)))
  (set! (-> obj flags) (the-as uint 0))
  (set! (-> obj button-handle) (the-as handle #f))
  (go (method-of-object obj dormant))
  (none)
  )

(defbehavior simon-block-handler tomb-simon-block ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (plat-event arg0 arg1 arg2 arg3)
  )

(defbehavior tomb-simon-block-post tomb-simon-block ()
  (when (!= (-> self basetrans y) (-> self base-height))
    (seek! (-> self basetrans y) (-> self base-height) (* (-> self move-rate) (-> self clock seconds-per-frame)))
    (when (and (< (- (-> self base-height) (-> self basetrans y)) 21504.0)
               (zero? (logand (-> self flags) (simon-block-flags sbf5)))
               )
      (sound-play "simon-up")
      (logior! (-> self flags) (simon-block-flags sbf5))
      )
    (if (< (- (-> self base-height) (-> self basetrans y)) 81920.0)
        (seek! (-> self move-rate) 0.0 (* 81920.0 (-> self clock seconds-per-frame)))
        )
    (when (< (+ -409.6 (-> self base-height)) (-> self basetrans y))
      (sound-play "simon-hit")
      (set! (-> self basetrans y) (-> self base-height))
      )
    )
  (plat-post)
  (none)
  )

(defbehavior tomb-simon-block-trans tomb-simon-block ()
  (when (logtest? (-> self flags) (simon-block-flags sbf0))
    (when (>= (-> self clock frame-counter) (-> self blink-timer 1))
      (cond
        ((logtest? (-> self flags) (simon-block-flags sbf1))
         (set! (-> self draw color-mult quad) (-> self color quad))
         )
        (else
          (sound-play-by-name (the-as sound-name (-> self sound-show)) (new-sound-id) 1024 0 0 (sound-group sfx) #t)
          (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
          )
        )
      (logxor! (-> self flags) (simon-block-flags sbf1))
      (set! (-> self blink-timer 1) (+ (-> self clock frame-counter) (seconds 0.2)))
      )
    (when (>= (- (-> self clock frame-counter) (-> self blink-timer 0)) (seconds 1.2))
      (logclear! (-> self flags) (simon-block-flags sbf0))
      (set! (-> self draw color-mult quad) (-> self color quad))
      )
    )
  (plat-trans)
  (none)
  )

(defstate idle (tomb-simon-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('reparent)
         (change-parent self proc)
         )
        (('blink)
         (the-as object (set-blink-timers! self))
         )
        (('edge-grabbed)
         (go-virtual dangerous)
         )
        (('ridden 'bonk)
         (let* ((gp-0 *target*)
                (a0-12 (if (type? gp-0 process-focusable)
                           gp-0
                           )
                       )
                )
           (when a0-12
             (let ((v1-6 (get-trans a0-12 0))
                   (a0-14 (-> self root-override trans))
                   )
               (if (and (>= 8192.0 (fabs (- (-> v1-6 x) (-> a0-14 x)))) (>= 8192.0 (fabs (- (-> v1-6 z) (-> a0-14 z)))))
                   (go-virtual dangerous)
                   )
               )
             )
           )
         )
        (('die 'die-unmaskable)
         (go-virtual die)
         )
        (('ready)
         (go-virtual ready)
         )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (logclear! (-> self flags) (simon-block-flags sbf0 sbf1 sbf2 sbf5))
    (set! (-> self move-rate) 122880.0)
    (none)
    )
  :trans tomb-simon-block-trans
  :code (the-as (function none :behavior tomb-simon-block) sleep-code)
  :post (behavior ()
    (if (>= (- (-> self clock frame-counter) (-> self state-time))
            (the int (* 300.0 (+ (* 0.1 (the float (-> self order))) (* 0.015 (the float (-> self my-idx))))))
            )
        (tomb-simon-block-post)
        (plat-post)
        )
    (none)
    )
  )

(defstate dangerous (tomb-simon-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('die-unmaskable)
       (go-virtual die)
       )
      (('reset)
       (go-virtual idle)
       )
      (('touch 'ridden 'bonk 'edge-grabbed)
       (set! (-> self ride-timer) (-> self clock frame-counter))
       (when (logtest? (-> self flags) (simon-block-flags sbf4))
         (let* ((gp-0 *target*)
                (a0-10 (if (type? gp-0 process-focusable)
                           gp-0
                           )
                       )
                (v1-10 (new 'stack-no-clear 'vector))
                )
           (set! (-> v1-10 x) 0.0)
           (set! (-> v1-10 y) 0.0)
           (set! (-> v1-10 z) 1.0)
           (set! (-> v1-10 w) 0.0)
           (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-6 from) (process->ppointer self))
             (set! (-> a1-6 num-params) 2)
             (set! (-> a1-6 message) 'attack)
             (set! (-> a1-6 param 0) (the-as uint #f))
             (let ((a2-4 (new 'static 'attack-info :mask (attack-info-mask vector shove-back shove-up control id))))
               (let* ((a3-2 *game-info*)
                      (t0-1 (+ (-> a3-2 attack-id) 1))
                      )
                 (set! (-> a3-2 attack-id) t0-1)
                 (set! (-> a2-4 id) t0-1)
                 )
               (set! (-> a2-4 vector quad) (-> v1-10 quad))
               (set! (-> a2-4 shove-back) 0.0)
               (set! (-> a2-4 shove-up) 12288.0)
               (set! (-> a2-4 control) (if (logtest? (focus-status board) (-> a0-10 focus-status))
                                           1.0
                                           0.0
                                           )
                     )
               (set! (-> a1-6 param 1) (the-as uint a2-4))
               )
             (send-event-function a0-10 a1-6)
             )
           )
         (let ((v0-0 (the-as object (logclear (-> self flags) (simon-block-flags sbf4)))))
           (set! (-> self flags) (the-as simon-block-flags v0-0))
           v0-0
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (logior! (-> self flags) (simon-block-flags sbf4))
    (set! (-> self ride-timer) (-> self clock frame-counter))
    (send-event (ppointer->process (-> self parent)) 'die-but (-> self my-idx))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self ride-timer)) (seconds 1))
      (sound-play "tomb-simon-last")
      (go-virtual die)
      )
    (plat-trans)
    (none)
    )
  :code (the-as (function none :behavior tomb-simon-block) sleep-code)
  :post tomb-simon-block-post
  )

(defstate ready (tomb-simon-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (the-as object (start-bouncing! self))
                      )
                     (('reset)
                      (go-virtual idle)
                      )
                     (('blink)
                      (the-as object (set-blink-timers! self))
                      )
                     (('die 'die-unmaskable)
                      (go-virtual die)
                      )
                     (('ridden)
                      (send-event (ppointer->process (-> self parent)) 'plat-ridden (-> self my-idx))
                      (if (!= (-> self next-idx) -1)
                          (send-event (ppointer->process (-> self parent)) 'ready-index (-> self next-idx))
                          )
                      (go-virtual ridden)
                      )
                     )
            )
    )
  :trans tomb-simon-block-trans
  :code (the-as (function none :behavior tomb-simon-block) sleep-code)
  :post tomb-simon-block-post
  )

(defstate ridden (tomb-simon-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (the-as object (start-bouncing! self))
                      )
                     (('reset)
                      (go-virtual idle)
                      )
                     (('die-unmaskable)
                      (go-virtual die)
                      )
                     (('die)
                      (go-virtual temporary)
                      )
                     (('ridden)
                      (let ((v0-0 (the-as object (-> self clock frame-counter))))
                        (set! (-> self ride-timer) (the-as time-frame v0-0))
                        v0-0
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self ride-timer) (-> self clock frame-counter))
    (none)
    )
  :trans (behavior ()
    (let* ((gp-0 *target*)
           (a0-1 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           )
      (when a0-1
        (let ((v1-2 (get-trans a0-1 0))
              (a0-3 (-> self root-override trans))
              )
          (when (and (or (< 16384.0 (fabs (- (-> a0-3 x) (-> v1-2 x)))) (< 16384.0 (fabs (- (-> a0-3 z) (-> v1-2 z)))))
                     (>= (- (-> self clock frame-counter) (-> self ride-timer)) (seconds 0.25))
                     )
            (when (= (-> self next-idx) -1)
              (when (< (-> *event-queue* length) (-> *event-queue* allocated-length))
                (let ((v1-17 (-> *event-queue* data (-> *event-queue* length))))
                  (+! (-> *event-queue* length) 1)
                  (set! (-> v1-17 form-handle) (process->handle self))
                  (set! (-> v1-17 to-handle) (process->handle (the-as process (ppointer->process (-> self parent)))))
                  (set! (-> v1-17 num-params) 0)
                  (set! (-> v1-17 message) 'finished)
                  )
                )
              (sound-play "tomb-simon-last")
              )
            (go-virtual temporary)
            )
          )
        )
      )
    (tomb-simon-block-trans)
    (none)
    )
  :code (the-as (function none :behavior tomb-simon-block) sleep-code)
  :post tomb-simon-block-post
  )

(defstate temporary (tomb-simon-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('bonk)
                      (the-as object (start-bouncing! self))
                      )
                     (('reset)
                      (go-virtual idle)
                      )
                     (('die-unmaskable)
                      (go-virtual die)
                      )
                     (('ridden)
                      (when (not (logtest? (-> self flags) (simon-block-flags sbf2)))
                        (logior! (-> self flags) (simon-block-flags sbf2))
                        (let ((v0-0 (the-as object (-> self clock frame-counter))))
                          (set! (-> self ride-timer) (the-as time-frame v0-0))
                          v0-0
                          )
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (logclear! (-> self flags) (simon-block-flags sbf0 sbf1 sbf2))
    (set! (-> self draw color-mult quad) (-> self color quad))
    (none)
    )
  :trans (behavior ()
    (if (and (logtest? (-> self flags) (simon-block-flags sbf2))
             (>= (- (-> self clock frame-counter) (-> self ride-timer)) (seconds 0.5))
             )
        (go-virtual wobble-die)
        )
    (plat-trans)
    (none)
    )
  :code (the-as (function none :behavior tomb-simon-block) sleep-code)
  :post tomb-simon-block-post
  )

(defstate wobble-die (tomb-simon-block)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('reset)
       (go-virtual idle)
       )
      (('die-unmaskable)
       (go-virtual die)
       )
      )
    )
  :trans (the-as (function none :behavior tomb-simon-block) plat-trans)
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (sound-play "tomb-simon-last")
    (go-virtual die)
    (none)
    )
  :post tomb-simon-block-post
  )

(defstate die (tomb-simon-block)
  :virtual #t
  :code (behavior ()
    (set! (-> self move-rate) (* 4096.0 (rand-vu-float-range 0.5 1.5)))
    (let ((gp-0 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-0) (seconds 0.25))
        (suspend)
        )
      )
    (logclear! (-> self root-override root-prim prim-core action) (collide-action rideable))
    (let ((gp-1 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-1) (seconds 1))
        (suspend)
        )
      )
    (cleanup-for-death self)
    (none)
    )
  :post (behavior ()
    (set! (-> self root-override transv y)
          (- (-> self root-override transv y) (* (-> self move-rate) (-> self clock seconds-per-frame)))
          )
    (+! (-> self root-override trans y) (-> self root-override transv y))
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod set-blink-timers! tomb-simon-block ((obj tomb-simon-block))
  (with-pp
    (logior! (-> obj flags) (simon-block-flags sbf0 sbf1))
    (set! (-> obj blink-timer 0) (-> pp clock frame-counter))
    (set! (-> obj blink-timer 1) (-> pp clock frame-counter))
    (none)
    )
  )

(defmethod get-art-group tomb-simon-block ((obj tomb-simon-block))
  "@returns The associated [[art-group]]"
  (art-group-get-by-name *level* "skel-tomb-simon-block" (the-as (pointer uint32) #f))
  )

;; WARN: Return type mismatch collide-shape vs none.
(defmethod init-plat-collision! tomb-simon-block ((obj tomb-simon-block))
  "TODO - collision stuff for setting up the platform"
  (let ((s5-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
    (let ((s4-0 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 -4096.0 0.0 16384.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-12 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-12 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-12 prim-core collide-with))
      )
    (set! (-> obj root-override) s5-0)
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior tomb-simon-block-init-by-other tomb-simon-block ((arg0 vector) (arg1 int) (arg2 int) (arg3 int) (arg4 int))
  (init-plat-collision! self)
  (set! (-> self mask) (logior (process-mask platform) (-> self mask)))
  (set! (-> self root-override trans quad) (-> arg0 quad))
  (set! (-> self base-height) (-> self root-override trans y))
  (set! (-> self root-override trans y) (+ -122880.0 (-> self root-override trans y)))
  (quaternion-copy! (-> self root-override quat) *unity-quaternion*)
  (vector-identity! (-> self root-override scale))
  (initialize-skeleton self (the-as skeleton-group (get-art-group self)) (the-as pair 0))
  (logclear! (-> self mask) (process-mask actor-pause))
  (update-transforms (-> self root-override))
  (stop-bouncing! self)
  (set! (-> self my-idx) arg1)
  (set! (-> self next-idx) arg2)
  (set! (-> self flags) (simon-block-flags))
  (set! (-> self order) arg3)
  (set! (-> self color quad) (-> *tomb-simon-color-tbl* arg4 quad))
  (set! (-> self sound-show) (-> *tomb-simon-sound-tbl* arg4))
  (set! (-> self draw color-mult quad) (-> self color quad))
  (set! (-> self event-hook) (-> (method-of-type tomb-simon-block idle) event))
  (go-virtual idle)
  (none)
  )

(deftype tomb-simon-button (process-drawable)
  ((notify-actor entity           :offset-assert 200)
   (on-notice    (function none)  :offset-assert 204)
   (on-activate  (function none)  :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 25
  :size-assert         #xd4
  :flag-assert         #x19006000d4
  (:methods
    (idle () _type_ :state 20)
    (open (symbol) _type_ :state 21)
    (waiting () _type_ :state 22)
    (pressed (symbol) _type_ :state 23)
    (unpress () _type_ :state 24)
    )
  )


(defskelgroup skel-tomb-simon-button tomb-simon-button tomb-simon-button-lod0-jg tomb-simon-button-open-ja
              ((tomb-simon-button-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5.5)
              )

(defstate idle (tomb-simon-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger)
       (go-virtual open #f)
       )
      )
    )
  :trans (behavior ()
    (let ((gp-0 (-> self on-notice)))
      (when gp-0
        (if (eval!
              (new 'stack 'script-context (the-as basic (process->ppointer self)) self (the-as vector #f))
              (the-as pair gp-0)
              )
            (go-virtual open #f)
            )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior tomb-simon-button) sleep-code)
  )

(defstate open (tomb-simon-button)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (let ((v1-2 (-> self entity extra perm)))
      (set! (-> v1-2 user-int8 0) 1)
      )
    (none)
    )
  :trans (the-as (function none :behavior tomb-simon-button) rider-trans)
  :code (behavior ((arg0 symbol))
    (cond
      (arg0
        (ja :group! (-> self draw art-group data 3)
            :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
            )
        )
      (else
        (sound-play "simon-btn-open")
        (ja-no-eval :group! (-> self draw art-group data 3)
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        )
      )
    (go-virtual waiting)
    (none)
    )
  :post (the-as (function none :behavior tomb-simon-button) rider-post)
  )

(defstate waiting (tomb-simon-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('bonk 'touch)
       (when ((method-of-type touching-shapes-entry prims-touching?)
              (the-as touching-shapes-entry (-> event param 0))
              (the-as collide-shape (-> self root))
              (the-as uint 1)
              )
         (let ((v1-3 (-> self notify-actor)))
           (if v1-3
               (send-event
                 (if v1-3
                     (-> v1-3 extra process)
                     )
                 'trigger
                 )
               )
           )
         (go-virtual pressed #f)
         )
       )
      (('trigger)
       (go-virtual pressed #f)
       )
      )
    )
  :enter (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 4)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (transform-post)
    (none)
    )
  :code (the-as (function none :behavior tomb-simon-button) sleep-code)
  )

(defstate pressed (tomb-simon-button)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('untrigger)
       (go-virtual unpress)
       )
      )
    )
  :code (behavior ((arg0 symbol))
    (let ((v1-2 (-> self entity extra perm)))
      (set! (-> v1-2 user-int8 0) 2)
      )
    (cond
      (arg0
        (ja :group! (-> self draw art-group data 4)
            :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
            )
        (transform-post)
        )
      (else
        (sound-play "simon-btn-press")
        (ja-no-eval :group! (-> self draw art-group data 4)
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (transform-post)
          (suspend)
          (ja :num! (seek!))
          )
        (let ((gp-2 (-> self on-activate)))
          (if gp-2
              (eval!
                (new 'stack 'script-context (the-as basic (process->ppointer self)) self (the-as vector #f))
                (the-as pair gp-2)
                )
              )
          )
        )
      )
    (sleep-code)
    (none)
    )
  )

(defstate unpress (tomb-simon-button)
  :virtual #t
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 5)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (let ((v1-26 (-> self entity extra perm)))
      (set! (-> v1-26 user-int8 0) 1)
      )
    (go-virtual waiting)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-simon-button ((obj tomb-simon-button) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (with-pp
    (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
      (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 5) 0)))
        (set! (-> s4-0 total-prims) (the-as uint 6))
        (set! (-> s3-0 prim-core collide-as) (collide-spec pusher))
        (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> s3-0 prim-core action) (collide-action solid rideable pull-rider-can-collide))
        (set-vector! (-> s3-0 local-sphere) 0.0 0.0 0.0 122880.0)
        (set! (-> s4-0 root-prim) s3-0)
        )
      (pusher-init s4-0)
      (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 1))))
        (set! (-> v1-10 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-10 prim-core action) (collide-action solid rideable))
        (set! (-> v1-10 transform-index) 3)
        (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 12288.0)
        )
      (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
        (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-12 prim-core action) (collide-action solid))
        (set! (-> v1-12 transform-index) 4)
        (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 11059.2)
        )
      (let ((v1-14 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
        (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-14 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-14 prim-core action) (collide-action solid))
        (set! (-> v1-14 transform-index) 5)
        (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 11059.2)
        )
      (let ((v1-16 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 3) (the-as uint 0))))
        (set! (-> v1-16 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-16 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-16 prim-core action) (collide-action solid))
        (set! (-> v1-16 transform-index) 6)
        (set-vector! (-> v1-16 local-sphere) 0.0 0.0 0.0 11059.2)
        )
      (let ((v1-18 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 4) (the-as uint 0))))
        (set! (-> v1-18 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-18 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-18 prim-core action) (collide-action solid))
        (set! (-> v1-18 transform-index) 7)
        (set-vector! (-> v1-18 local-sphere) 0.0 0.0 0.0 11059.2)
        )
      (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
      (let ((v1-21 (-> s4-0 root-prim)))
        (set! (-> s4-0 backup-collide-as) (-> v1-21 prim-core collide-as))
        (set! (-> s4-0 backup-collide-with) (-> v1-21 prim-core collide-with))
        )
      (set! (-> obj root) s4-0)
      )
    (process-drawable-from-entity! obj arg0)
    (initialize-skeleton
      obj
      (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-simon-button" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (set! (-> obj notify-actor) (entity-actor-lookup arg0 'alt-actor 0))
    (set! (-> obj on-notice) (res-lump-struct (-> obj entity) 'on-notice (function none)))
    (set! (-> obj on-activate) (res-lump-struct (-> obj entity) 'on-activate (function none)))
    (let ((a0-42 (-> obj skel root-channel 0)))
      (set! (-> a0-42 frame-group) (the-as art-joint-anim (-> obj draw art-group data 3)))
      (set! (-> a0-42 param 0) 1.0)
      (set! (-> a0-42 frame-num) 0.0)
      (joint-control-channel-group! a0-42 (the-as art-joint-anim (-> obj draw art-group data 3)) num-func-loop!)
      )
    (transform-post)
    (let ((s5-1 (-> obj on-notice)))
      (when s5-1
        (if (eval!
              (new 'stack 'script-context (the-as basic (process->ppointer pp)) pp (the-as vector #f))
              (the-as pair s5-1)
              )
            (go (method-of-object obj open) #t)
            )
        )
      )
    (let ((v1-49 (-> obj entity extra perm user-uint8 0)))
      (cond
        ((zero? v1-49)
         (go (method-of-object obj idle))
         )
        ((= v1-49 1)
         (go (method-of-object obj open) #t)
         )
        ((= v1-49 2)
         (go (method-of-object obj pressed) #t)
         )
        )
      )
    (none)
    )
  )

(deftype tomb-vibe (process-drawable)
  ((spawn-pos         vector                :inline :offset-assert 208)
   (pat-tbl           (array handle)                :offset-assert 224)
   (pat-count         int32                         :offset-assert 228)
   (pat-index         int32                         :offset-assert 232)
   (pat-entry-index   int32                         :offset-assert 236)
   (pat-timer         time-frame                    :offset-assert 240)
   (pat-duration      time-frame                    :offset-assert 248)
   (actor-group       (pointer actor-group)         :offset-assert 256)
   (actor-group-count int32                         :offset-assert 260)
   (flags             uint16                        :offset-assert 264)
   (on-activate       basic                         :offset-assert 268)
   )
  :heap-base #x90
  :method-count-assert 24
  :size-assert         #x110
  :flag-assert         #x1800900110
  (:methods
    (get-pattern () _type_ :state 20)
    (idle () _type_ :state 21)
    (vibrate () _type_ :state 22)
    (die (symbol) _type_ :state 23)
    )
  )


(defskelgroup skel-tomb-vibe tomb-vibe tomb-vibe-lod0-jg tomb-vibe-idle-ja
              ((tomb-vibe-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defstate get-pattern (tomb-vibe)
  :virtual #t
  :code (behavior ()
    (until #f
      (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-0 from) (process->ppointer self))
        (set! (-> a1-0 num-params) 0)
        (set! (-> a1-0 message) 'ready?)
        (let ((t9-0 send-event-function)
              (v1-5 (-> self actor-group 0 data 0 actor))
              )
          (when (t9-0
                  (if v1-5
                      (-> v1-5 extra process)
                      )
                  a1-0
                  )
            (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-1 from) (process->ppointer self))
              (set! (-> a1-1 num-params) 0)
              (set! (-> a1-1 message) 'get-pattern)
              (let ((t9-1 send-event-function)
                    (v1-14 (-> self actor-group 0 data 0 actor))
                    )
                (set! (-> self pat-index) (the-as int (t9-1
                                                        (if v1-14
                                                            (-> v1-14 extra process)
                                                            )
                                                        a1-1
                                                        )
                                                  )
                      )
                )
              )
            (go-virtual idle)
            )
          )
        )
      (let ((gp-0 (-> self clock frame-counter)))
        (until (>= (- (-> self clock frame-counter) gp-0) (seconds 0.45))
          (suspend)
          )
        )
      )
    #f
    (none)
    )
  )

(defstate idle (tomb-vibe)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 (new 'static 'array int32 4 -1 0 0 0))
          (gp-0 (new 'static 'array handle 2
                  (new 'static 'handle :process #xffffffff :pid #xffffffff :u64 #xffffffffffffffff)
                  (new 'static 'handle)
                  )
                )
          )
      (case event-type
        (('attack)
         (case (-> (the-as attack-info (-> event param 1)) mode)
           (('flop 'spin 'punch)
            (cond
              ((and (= (-> v1-0 0) (-> (the-as (pointer int32) (+ (the-as uint (-> self pat-tbl)) (* (-> self pat-index) 4)))))
                    (!= (-> gp-0 0) (process->handle self))
                    )
               (send-event (handle->process (-> gp-0 0)) 'interrupt)
               (send-event (handle->process (-> gp-0 0)) 'die)
               (logior! (-> self flags) 1)
               (go-virtual vibrate)
               )
              (else
                (set! (-> v1-0 0) (-> (the-as (pointer int32) (+ (the-as uint (-> self pat-tbl)) (* (-> self pat-index) 4)))))
                (set! (-> gp-0 0) (process->handle self))
                (go-virtual vibrate)
                )
              )
            )
           )
         )
        (('set-pattern)
         (set! (-> v1-0 0) -1)
         (set! (-> gp-0 0) (the-as handle #f))
         (let ((v0-0 (the-as object (-> event param 0))))
           (set! (-> self pat-index) (the-as int v0-0))
           v0-0
           )
         )
        (('get-pattern)
         (-> self pat-index)
         )
        (('ready?)
         (!= (-> self pat-index) -1)
         )
        (('die)
         (go-virtual die #f)
         )
        )
      )
    )
  :trans (behavior ()
    0
    (none)
    )
  :code (the-as (function none :behavior tomb-vibe) sleep-code)
  :post (behavior ()
    (let* ((s5-0 *target*)
           (gp-0 (if (type? s5-0 process-focusable)
                     s5-0
                     )
                 )
           )
      (when gp-0
        (when (and (not (logtest? (-> self flags) 2))
                   (< (vector-vector-distance (-> self root trans) (get-trans gp-0 0)) 102400.0)
                   )
          (set-setting! 'sound-mode #f 0 2)
          (logior! (-> self flags) 2)
          )
        (when (and (logtest? (-> self flags) 2)
                   (< 184320.0 (vector-vector-distance (-> self root trans) (get-trans gp-0 0)))
                   )
          (remove-setting! 'sound-mode)
          (set! (-> self flags) (logand -3 (-> self flags)))
          )
        )
      )
    (none)
    )
  )

(defstate vibrate (tomb-vibe)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as
      object
      (case event-type
        (('interrupt)
         (the-as object (kill-persister *setting-control* (the-as engine-pers (process->ppointer self)) 'sound-tune))
         )
        (('die)
         (go-virtual die #f)
         )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (set! (-> self pat-entry-index) 0)
    (set-vector! (-> self draw color-mult) 0.9 0.9 0.9 1.0)
    (let ((gp-0 (-> self actor-group 0)))
      (dotimes (s5-0 (-> gp-0 length))
        (let ((v1-8 (-> gp-0 data s5-0 actor)))
          (when (!= (if v1-8
                        (-> v1-8 extra process)
                        )
                    self
                    )
            (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-0 from) (process->ppointer self))
              (set! (-> a1-0 num-params) 0)
              (set! (-> a1-0 message) 'interrupt)
              (let ((t9-0 send-event-function)
                    (v1-16 (-> gp-0 data s5-0 actor))
                    )
                (t9-0
                  (if v1-16
                      (-> v1-16 extra process)
                      )
                  a1-0
                  )
                )
              )
            )
          )
        )
      )
    (none)
    )
  :exit (behavior ()
    (process-release? *target*)
    (kill-persister *setting-control* (the-as engine-pers (process->ppointer self)) 'sound-tune)
    (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
    (none)
    )
  :trans (behavior ()
    0
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-0) (seconds 0.2))
        (suspend)
        )
      )
    (persist-with-delay
      *setting-control*
      (the-as symbol (process->ppointer self))
      (seconds 1)
      'sound-tune
      #f
      0.0
      (+ (-> (the-as (pointer int32) (+ (the-as uint (-> self pat-tbl)) (* (-> self pat-index) 4)))) 18)
      )
    (let ((gp-1 (-> self clock frame-counter)))
      (until (>= (- (-> self clock frame-counter) gp-1) (seconds 0.2))
        (suspend)
        )
      )
    (process-grab? *target* #f)
    (let ((gp-2 (-> self clock frame-counter))
          (s5-0 540)
          (f30-0 1.0)
          )
      (ja-no-eval :group! (-> self draw art-group data 4) :num! (loop! f30-0) :frame-num 0.0)
      (until (>= (- (-> self clock frame-counter) gp-2) s5-0)
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    (process-release? *target*)
    (if (logtest? (-> self flags) 1)
        (go-virtual die #f)
        (go-virtual idle)
        )
    (none)
    )
  :post (the-as (function none :behavior tomb-vibe) transform-post)
  )

(defstate die (tomb-vibe)
  :virtual #t
  :enter (behavior ((arg0 symbol))
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (cond
      (arg0
        (ja :group! (-> self draw art-group data 5)
            :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames) -1)))
            )
        (transform-post)
        )
      (else
        (let ((gp-1 (get-process *default-dead-pool* part-tracker #x4000)))
          (when gp-1
            (let ((t9-3 (method-of-type part-tracker activate)))
              (t9-3 (the-as part-tracker gp-1) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
              )
            (let ((t9-4 run-function-in-process)
                  (a0-4 gp-1)
                  (a1-3 part-tracker-init)
                  (a2-5 (-> *part-group-id-table* 686))
                  (a3-1 450)
                  (t0-0 #f)
                  (t1-0 #f)
                  (t2-0 #f)
                  (t3-0 *launch-matrix*)
                  )
              (set! (-> t3-0 trans quad) (-> self spawn-pos quad))
              ((the-as (function object object object object object object object object none) t9-4)
               a0-4
               a1-3
               a2-5
               a3-1
               t0-0
               t1-0
               t2-0
               t3-0
               )
              )
            (-> gp-1 ppointer)
            )
          )
        (ja-no-eval :group! (-> self draw art-group data 5)
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (transform-post)
          (suspend)
          (ja :num! (seek!))
          )
        (let ((v1-45 (-> self actor-group 0)))
          (dotimes (a0-8 (-> v1-45 length))
            (if (not (logtest? (-> v1-45 data a0-8 actor extra perm status) (entity-perm-status subtask-complete)))
                (goto cfg-13)
                )
            )
          )
        (task-node-close! (game-task-node tomb-water-vibe))
        )
      )
    (label cfg-13)
    (sleep-code)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-vibe ((obj tomb-vibe) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (sv-16 res-tag) (sv-32 res-tag))
  (with-pp
    (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum hit-by-player))))
      (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
        (set! (-> s4-0 total-prims) (the-as uint 3))
        (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
        (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> s3-0 prim-core action) (collide-action solid))
        (set! (-> s3-0 transform-index) 3)
        (set-vector! (-> s3-0 local-sphere) 0.0 4096.0 0.0 9011.2)
        (set! (-> s4-0 root-prim) s3-0)
        )
      (pusher-init s4-0)
      (let ((v1-11 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-11 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-11 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-11 prim-core action) (collide-action solid))
        (set! (-> v1-11 transform-index) 4)
        (set-vector! (-> v1-11 local-sphere) 0.0 4096.0 0.0 8192.0)
        )
      (let ((v1-13 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
        (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
        (set! (-> v1-13 prim-core collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-13 prim-core action) (collide-action solid))
        (set! (-> v1-13 transform-index) 3)
        (set-vector! (-> v1-13 local-sphere) 0.0 0.0 0.0 8192.0)
        )
      (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
      (let ((v1-16 (-> s4-0 root-prim)))
        (set! (-> s4-0 backup-collide-as) (-> v1-16 prim-core collide-as))
        (set! (-> s4-0 backup-collide-with) (-> v1-16 prim-core collide-with))
        )
      (set! (-> obj root) s4-0)
      )
    (process-drawable-from-entity! obj arg0)
    (initialize-skeleton
      obj
      (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-vibe" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (set! (-> obj entity) arg0)
    (set! (-> obj spawn-pos quad) (-> obj root trans quad))
    (set! (-> obj spawn-pos y) (+ 81.92 (-> obj spawn-pos y)))
    (set! (-> obj fact)
          (new 'process 'fact-info obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
          )
    (set! sv-16 (new 'static 'res-tag))
    (let ((v1-26 (res-lump-data (-> obj entity) 'vibe-pattern pointer :tag-ptr (& sv-16))))
      (cond
        ((and v1-26 (nonzero? (-> sv-16 elt-count)))
         (set! (-> obj pat-tbl) (the-as (array handle) v1-26))
         (set! (-> obj pat-count) (the-as int (-> sv-16 elt-count)))
         )
        (else
          (set! (-> obj pat-tbl) #f)
          (set! (-> obj pat-count) 0)
          0
          )
        )
      )
    (set! sv-32 (new 'static 'res-tag))
    (let ((v1-33 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-32))))
      (cond
        ((and v1-33 (nonzero? (-> sv-32 elt-count)))
         (set! (-> obj actor-group) (the-as (pointer actor-group) v1-33))
         (set! (-> obj actor-group-count) (the-as int (-> sv-32 elt-count)))
         )
        (else
          (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
          (set! (-> obj actor-group-count) 0)
          0
          )
        )
      )
    (when (logtest? (actor-option user17) (-> obj fact options))
      (let ((s5-1 (-> obj entity extra perm)))
        (when (not (logtest? (-> s5-1 status) (entity-perm-status bit-5)))
          (set! (-> s5-1 user-object 0) (rand-vu-int-range 0 (+ (-> obj pat-count) -1)))
          (logior! (-> s5-1 status) (entity-perm-status bit-5))
          )
        (when (< (-> *event-queue* length) (-> *event-queue* allocated-length))
          (let ((v1-56 (-> *event-queue* data (-> *event-queue* length))))
            (+! (-> *event-queue* length) 1)
            (set! (-> v1-56 form-handle) (process->handle pp))
            (set! (-> v1-56 to-handle) (process->handle obj))
            (set! (-> v1-56 num-params) 1)
            (set! (-> v1-56 message) 'set-pattern)
            (set! (-> v1-56 param 0) (the-as uint (-> s5-1 user-object 0)))
            )
          )
        )
      )
    (set! (-> obj pat-index) -1)
    (ja-channel-push! 1 0)
    (let ((a0-53 (-> obj skel root-channel 0)))
      (set! (-> a0-53 frame-group) (the-as art-joint-anim (-> obj draw art-group data 3)))
      (set! (-> a0-53 frame-num) 0.0)
      (joint-control-channel-group! a0-53 (the-as art-joint-anim (-> obj draw art-group data 3)) num-func-identity)
      )
    (transform-post)
    (set! (-> obj flags) (the-as uint 0))
    (set! (-> obj event-hook) (-> (method-of-type tomb-vibe idle) event))
    (cond
      ((logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete))
       (go (method-of-object obj die) #t)
       )
      ((logtest? (actor-option user17) (-> obj fact options))
       (go (method-of-object obj idle))
       )
      (else
        (go (method-of-object obj get-pattern))
        )
      )
    (none)
    )
  )

(deftype tomb-water-trap (process-drawable)
  ((bbox              bounding-box   :inline :offset-assert 208)
   (run-bbox          bounding-box   :inline :offset-assert 240)
   (sync              sync-linear    :inline :offset-assert 272)
   (on-duration       time-frame             :offset-assert 288)
   (harmless-time     time-frame             :offset-assert 296)
   (l-spec            lightning-spec         :offset-assert 304)
   (l-count           uint32                 :offset-assert 308)
   (l-index           (array uint32)         :offset-assert 312)
   (attack-id         uint32                 :offset-assert 316)
   (volume            float                  :offset-assert 320)
   (can-exit-running? symbol                 :offset-assert 324)
   )
  :heap-base #xd0
  :method-count-assert 25
  :size-assert         #x148
  :flag-assert         #x1900d00148
  (:methods
    (idle () _type_ :state 20)
    (running () _type_ :state 21)
    (tomb-water-trap-method-22 (_type_) none 22)
    (tomb-water-trap-method-23 (_type_ vector vector) none 23)
    (tomb-water-trap-method-24 (_type_ vector vector int) none 24)
    )
  )


(defstate idle (tomb-water-trap)
  :virtual #t
  :trans (behavior ()
    (let* ((gp-0 *target*)
           (a0-1 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           )
      (if (and a0-1 (box-vector-inside? (-> self run-bbox) (get-trans a0-1 0)))
          (go-virtual running)
          )
      )
    (cond
      ((< 0.0 (-> self volume))
       (seek! (-> self volume) 0.0 (* 2.0 (-> self clock seconds-per-frame)))
       (update-vol! (-> self sound) (-> self volume))
       (update! (-> self sound))
       )
      (else
        (logior! (-> self mask) (process-mask actor-pause))
        )
      )
    (none)
    )
  :code (the-as (function none :behavior tomb-water-trap) sleep-code)
  )

(defstate running (tomb-water-trap)
  :virtual #t
  :enter (behavior ()
    (set! (-> self can-exit-running?) #f)
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((v1-3 (-> self path curve num-cverts)))
      (dotimes (a0-1 (the-as int (-> self l-count)))
        (set! (-> self l-index a0-1)
              (the-as uint (the int (* (/ (the float a0-1) (the float (-> self l-count))) (the float v1-3))))
              )
        )
      )
    (none)
    )
  :exit (behavior ()
    (set-tombc-electricity-scale! 0.0)
    (none)
    )
  :trans (behavior ()
    (when (-> self can-exit-running?)
      (let ((a0-0 *target*))
        (if (not (and a0-0 (box-vector-inside? (-> self run-bbox) (get-trans a0-0 0))))
            (go-virtual idle)
            )
        )
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (set! (-> self can-exit-running?) #f)
      (let ((gp-0 0)
            (s5-0 (-> self clock frame-counter))
            )
        (until (>= (- (-> self clock frame-counter) s5-0) (-> self on-duration))
          (when (< (-> self harmless-time) (-> self clock frame-counter))
            (tomb-water-trap-method-22 self)
            (dotimes (s4-0 (+ (-> self path curve num-cverts) -1))
              (let ((s3-0 (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (the float s4-0) 'interp))
                    (a2-2 (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (the float (+ s4-0 1)) 'interp))
                    )
                (tomb-water-trap-method-23 self s3-0 a2-2)
                )
              )
            )
          (seek! (-> self volume) 1.0 (* 2.0 (-> self clock seconds-per-frame)))
          (cond
            ((logtest? gp-0 8)
             (set! gp-0 0)
             (set-tombc-electricity-scale! 1.0)
             (dotimes (s4-1 (the-as int (-> self l-count)))
               (let* ((v1-19 (-> self path curve num-cverts))
                      (s1-0 (+ v1-19 -1))
                      (s0-0 (mod (the-as int (-> self l-index s4-1)) v1-19))
                      (s3-2 (max 0 (min (+ s0-0 (* (rand-vu-int-range -3 3) 2)) s1-0)))
                      (s2-1 (max 0 (min (+ (* (rand-vu-int-range -3 3) 2) 1 s0-0) s1-0)))
                      )
                 (if (!= (logand s3-2 1) (logand s2-1 1))
                     (tomb-water-trap-method-24
                       self
                       (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (the float s3-2) 'interp)
                       (get-point-in-path! (-> self path) (new 'stack-no-clear 'vector) (the float s2-1) 'interp)
                       (the int (* 9.0 (rand-vu-float-range 8.0 12.0)))
                       )
                     )
                 )
               )
             )
            (else
              (+! gp-0 1)
              )
            )
          (suspend)
          )
        )
      (set! (-> self can-exit-running?) #t)
      (let ((gp-1 90))
        (let ((s5-1 (-> self clock frame-counter)))
          (until (>= (- (-> self clock frame-counter) s5-1) gp-1)
            (suspend)
            )
          )
        (let ((s5-2 #f)
              (s4-2 (-> self clock frame-counter))
              )
          (until (>= (- (-> self clock frame-counter) s4-2)
                     (the-as time-frame (- (- (-> self sync period) (the-as uint (-> self on-duration))) (the-as uint gp-1)))
                     )
            (when (and (not s5-2) (>= (- (-> self clock frame-counter) s4-2) (seconds 0.3)))
              (set! s5-2 #t)
              (set-tombc-electricity-scale! 0.0)
              )
            (seek! (-> self volume) 0.0 (* 2.0 (-> self clock seconds-per-frame)))
            (suspend)
            )
          )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (update-vol! (-> self sound) (-> self volume))
    (update! (-> self sound))
    (none)
    )
  )

(defmethod tomb-water-trap-method-22 tomb-water-trap ((obj tomb-water-trap))
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> gp-0 collide-with) (collide-spec jak bot player-list))
    (set! (-> gp-0 ignore-process0) obj)
    (set! (-> gp-0 ignore-process1) #f)
    (set! (-> gp-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
    (set! (-> gp-0 action-mask) (collide-action solid))
    (mem-copy! (the-as pointer (-> gp-0 bbox)) (the-as pointer (-> obj bbox)) 32)
    (fill-using-bounding-box *collide-cache* gp-0)
    )
  (none)
  )

;; WARN: Return type mismatch time-frame vs none.
(defmethod tomb-water-trap-method-23 tomb-water-trap ((obj tomb-water-trap) (arg0 vector) (arg1 vector))
  (with-pp
    (let ((s4-0 (new 'stack-no-clear 'collide-query))
          (s3-1 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
          )
      (set! (-> s4-0 start-pos quad) (-> arg0 quad))
      (set! (-> s4-0 move-dist quad) (-> s3-1 quad))
      (let ((v1-3 s4-0))
        (set! (-> v1-3 radius) 2048.0)
        (set! (-> v1-3 collide-with) (collide-spec jak bot player-list))
        (set! (-> v1-3 ignore-process0) obj)
        (set! (-> v1-3 ignore-process1) #f)
        (set! (-> v1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-3 action-mask) (collide-action solid semi-solid))
        )
      (let ((f30-0 (probe-using-line-sphere *collide-cache* s4-0)))
        (when (>= f30-0 0.0)
          (let* ((s2-0 (-> s4-0 best-other-tri collide-ptr))
                 (s4-1 (if (type? s2-0 collide-shape-prim-sphere)
                           (the-as collide-shape-prim-sphere s2-0)
                           )
                       )
                 )
            (when s4-1
              (let ((s2-2 (vector+float*! (new 'stack-no-clear 'vector) arg0 s3-1 f30-0)))
                (tomb-water-trap-method-24 obj arg0 s2-2 (the int (* 3.0 (rand-vu-float-range 5.0 11.0))))
                )
              (let ((v1-10 (vector-reset! (new 'stack-no-clear 'vector)))
                    (a1-5 (new 'stack-no-clear 'event-message-block))
                    )
                (set! (-> a1-5 from) (process->ppointer pp))
                (set! (-> a1-5 num-params) 2)
                (set! (-> a1-5 message) 'attack)
                (set! (-> a1-5 param 0) (the-as uint #f))
                (let ((a0-17 (new 'static 'attack-info :mask (attack-info-mask vector invinc-time mode shove-up id))))
                  (set! (-> a0-17 id) (-> obj attack-id))
                  (set! (-> a0-17 invinc-time) (seconds 3))
                  (set! (-> a0-17 mode) 'shock)
                  (set! (-> a0-17 vector quad) (-> v1-10 quad))
                  (set! (-> a0-17 shove-up) 12288.0)
                  (set! (-> a1-5 param 1) (the-as uint a0-17))
                  )
                (if (send-event-function (-> s4-1 cshape process) a1-5)
                    (set! (-> obj harmless-time) (+ (-> pp clock frame-counter) (seconds 3)))
                    )
                )
              )
            )
          )
        )
      )
    (none)
    )
  )

(defmethod tomb-water-trap-method-24 tomb-water-trap ((obj tomb-water-trap) (arg0 vector) (arg1 vector) (arg2 int))
  (let ((v1-1 (process-spawn
                lightning-tracker
                :init lightning-tracker-init
                (-> obj l-spec)
                (+ arg2 120)
                #f
                #f
                arg0
                arg1
                :to *entity-pool*
                )
              )
        )
    (if v1-1
        (-> v1-1 0 self)
        )
    )
  (let* ((s3-1 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) arg1 arg0) 1.0))
         (s2-1 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) arg0 arg1) 1.0))
         (s3-2 (forward-up-nopitch->quaternion (new 'stack-no-clear 'quaternion) s3-1 *up-vector*))
         (s1-0 (forward-up-nopitch->quaternion (new 'stack-no-clear 'quaternion) s2-1 *up-vector*))
         (s2-2 (quaternion->matrix (new 'stack-no-clear 'matrix) s3-2))
         (s3-3 (quaternion->matrix (new 'stack-no-clear 'matrix) s1-0))
         )
    (set! (-> s2-2 trans quad) (-> arg0 quad))
    (set! (-> s3-3 trans quad) (-> arg1 quad))
    (spawn-with-matrix (-> obj part) s2-2)
    (spawn-with-matrix (-> obj part) s3-3)
    )
  (none)
  )

;; WARN: Return type mismatch process-drawable vs tomb-water-trap.
(defmethod relocate tomb-water-trap ((obj tomb-water-trap) (arg0 int))
  (if (nonzero? (-> obj l-index))
      (&+! (-> obj l-index) arg0)
      )
  (the-as tomb-water-trap ((method-of-type process-drawable relocate) obj arg0))
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-water-trap ((obj tomb-water-trap) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (let ((a1-3 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-1 0))
      (if #t
          (set! v1-1 (logior v1-1 1))
          )
      (set! (-> a1-3 sync-type) 'sync-linear)
      (set! (-> a1-3 sync-flags) (the-as sync-flags v1-1))
      )
    (set! (-> a1-3 entity) arg0)
    (set! (-> a1-3 period) (the-as uint 2400))
    (set! (-> a1-3 percent) 0.75)
    (initialize! (-> obj sync) a1-3)
    )
  (set! (-> obj on-duration) (the-as time-frame (the int (-> obj sync offset))))
  (set! (-> obj harmless-time) 0)
  (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 arg0 #f))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (let ((s5-1 (new 'stack-no-clear 'sphere)))
    (get-point-in-path! (-> obj path) s5-1 0.0 'interp)
    (set! (-> s5-1 r) 4096.0)
    (set-from-sphere! (-> obj bbox) s5-1)
    (countdown (s4-0 (+ (-> obj path curve num-cverts) -1))
      (add-point!
        (-> obj bbox)
        (get-point-in-path! (-> obj path) (new 'stack-no-clear 'vector) (the float s4-0) 'interp)
        )
      )
    (get-bounding-sphere (-> obj bbox) s5-1)
    (set! (-> s5-1 r) (+ 81920.0 (-> s5-1 r)))
    (set-from-sphere! (-> obj run-bbox) s5-1)
    )
  (let* ((v1-29 *game-info*)
         (a0-17 (+ (-> v1-29 attack-id) 1))
         )
    (set! (-> v1-29 attack-id) a0-17)
    (set! (-> obj attack-id) a0-17)
    )
  (set! (-> obj l-spec) (new 'static 'lightning-spec
                          :name #f
                          :flags (lightning-spec-flags lsf2)
                          :start-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                          :end-color (new 'static 'rgba :a #x80)
                          :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                          :fade-start-factor 0.2
                          :fade-time 120.0
                          :texture (new 'static 'texture-id :index #x83 :page #xc)
                          :reduction 0.42
                          :num-points 12
                          :box-size 14336.0
                          :merge-factor 0.5
                          :merge-count 4
                          :radius 3276.8
                          :duration -1.0
                          :sound #f
                          )
        )
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 696) obj))
  (let ((a3-3 (new 'stack-no-clear 'vector)))
    (set! (-> a3-3 x) (* 0.5 (+ (-> obj bbox min x) (-> obj bbox max x))))
    (set! (-> a3-3 y) (* 0.5 (+ (-> obj bbox min y) (-> obj bbox max y))))
    (set! (-> a3-3 z) (* 0.5 (+ (-> obj bbox min z) (-> obj bbox max z))))
    (set! (-> obj sound) (new 'process 'ambient-sound (static-sound-spec "water-trap-zap" :fo-max 55) a3-3))
    )
  (set! (-> obj volume) 0.0)
  (let ((a0-20 (-> obj entity)))
    (set! (-> obj l-count) (the-as uint ((method-of-object a0-20 get-property-value)
                                         a0-20
                                         'bolt-count
                                         'interp
                                         -1000000000.0
                                         (the-as uint128 8)
                                         (the-as (pointer res-tag) #f)
                                         *res-static-buf*
                                         )
                                   )
          )
    )
  (set! (-> obj l-index) (new 'process 'boxed-array uint32 (the-as int (-> obj l-count))))
  (go (method-of-object obj idle))
  (none)
  )

(deftype tomb-smash-door (process-drawable)
  ((timeout time-frame  :offset-assert 200)
   (button  handle      :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 23
  :size-assert         #xd8
  :flag-assert         #x17006000d8
  (:methods
    (idle () _type_ :state 20)
    (open () _type_ :state 21)
    (close () _type_ :state 22)
    )
  )


(defskelgroup skel-tomb-smash-door tomb-smash-door 0 2
              ((1 (meters 999999)))
              :bounds (static-spherem 0 8 0 12)
              )

(defstate idle (tomb-smash-door)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('trigger 'cue-chase)
       (set! (-> self button) (process->handle proc))
       (go-virtual open)
       )
      )
    )
  :code (the-as (function none :behavior tomb-smash-door) sleep-code)
  )

(defstate open (tomb-smash-door)
  :virtual #t
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self timeout))
      (let* ((s5-0 *target*)
             (gp-0 (if (type? s5-0 process-focusable)
                       s5-0
                       )
                   )
             )
        (cond
          (gp-0
            (let* ((s5-1 (camera-pos))
                   (s4-0 (get-trans gp-0 0))
                   (gp-1 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                   (s5-2 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s5-1 (-> self root trans)) 1.0))
                   )
              (if (or (>= (vector-dot (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s4-0 (-> self root trans)) 1.0) gp-1)
                          0.0
                          )
                      (< (vector-dot s5-2 gp-1) 0.0)
                      )
                  (go-virtual close)
                  )
              )
            )
          (else
            (go-virtual close)
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 3)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (sleep-code)
    (none)
    )
  )

(defstate close (tomb-smash-door)
  :virtual #t
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 4)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 4)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (transform-post)
      (suspend)
      (ja :num! (seek!))
      )
    (send-event (handle->process (-> self button)) 'untrigger)
    (go-virtual idle)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! tomb-smash-door ((obj tomb-smash-door) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 2) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 3))
      (set! (-> s3-0 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid))
      (set-vector! (-> s3-0 local-sphere) 0.0 32768.0 0.0 49152.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set! (-> v1-10 transform-index) 4)
      (set-vector! (-> v1-10 local-sphere) 12288.0 32768.0 0.0 40960.0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec camera-blocker pusher))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 5)
      (set-vector! (-> v1-12 local-sphere) -12288.0 32768.0 0.0 40960.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-15 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-15 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-15 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-tomb-smash-door" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (let ((f30-0 300.0)
        (a0-22 (-> obj entity))
        )
    (set! (-> obj timeout)
          (the-as time-frame (the int (* f30-0 ((method-of-object a0-22 get-property-value-float)
                                                a0-22
                                                'timeout
                                                'interp
                                                -1000000000.0
                                                14.0
                                                (the-as (pointer res-tag) #f)
                                                *res-static-buf*
                                                )
                                         )
                                  )
                  )
          )
    )
  (ja-channel-push! 1 0)
  (let ((a0-24 (-> obj skel root-channel 0)))
    (set! (-> a0-24 frame-group) (the-as art-joint-anim (-> obj draw art-group data 2)))
    (set! (-> a0-24 frame-num) 0.0)
    (joint-control-channel-group! a0-24 (the-as art-joint-anim (-> obj draw art-group data 2)) num-func-identity)
    )
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )
