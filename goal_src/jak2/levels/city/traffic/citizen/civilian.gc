;;-*-Lisp-*-
(in-package goal)

;; name: civilian.gc
;; name in dgo: civilian
;; dgos: CWI

;; DECOMP BEGINS

(deftype civilian-anim-info (structure)
  ((anim-index        int32  2)
   (anim-index-front  int32  :overlay-at (-> anim-index 0))
   (anim-index-back   int32  :overlay-at (-> anim-index 1))
   )
  :pack-me
  )


(deftype civilian-global-info (basic)
  ((prev-yellow-hit                 int8)
   (prev-blue-hit                   int8)
   (knocked                         int32               2)
   (anim-knocked-front              int32               :overlay-at (-> knocked 0))
   (anim-knocked-back               int32               :overlay-at (-> knocked 1))
   (knocked-land                    int32               2)
   (anim-knocked-front-land         int32               :overlay-at (-> knocked-land 0))
   (anim-knocked-back-land          int32               :overlay-at (-> knocked-land 1))
   (yellow-hit-anim                 civilian-anim-info  1 :inline)
   (blue-hit-anim                   civilian-anim-info  3 :inline)
   (anim-cover-head-start           int32)
   (anim-cover-head-loop            int32)
   (anim-cover-head-end             int32)
   (car-stance-anim                 int32)
   (bike-stance-anim                int32)
   (get-in-car-anim                 int32)
   (get-on-bike-anim                int32)
   (seat-flag                       uint8)
   (speech-ambient                  int8)
   (speech-alert                    int8)
   (speech-cower                    int8)
   (speech-touched-by-player        int8)
   (speech-shot-by-player           int8)
   (speech-avoiding-player-vehicle  int8)
   (speech-hit-by-player-vehicle    int8)
   (speech-player-stealing-vehicle  int8)
   )
  )


(deftype civilian (citizen)
  ((info               civilian-global-info)
   (anim-panic-run     int32)
   (anim-on-ground     int32)
   (anim-dive          int32)
   (anim-get-up-front  int32)
   (anim-get-up-back   int32)
   (last-second-pos    vector  :inline)
   (last-distance      float)
   (next-time          time-frame)
   (dive-target-point  vector  :inline)
   (dive-reaction      float)
   (allow-dive         symbol)
   (dive-finished?     symbol)
   (hit-face           uint32)
   (seat               int32)
   )
  (:state-methods
    avoid-danger
    clear-path
    on-ground
    dive
    get-up-front
    get-up-back
    cower-ground
    wait-for-ride
    move-to-vehicle
    board-vehicle
    ride
    exit-vehicle
    wait-at-dest
    )
  (:methods
    (civilian-method-214 (_type_ nav-branch int vector float) float)
    (civilian-method-215 (_type_ vector) none)
    (go-dive (_type_) none)
    (civilian-method-217 (_type_ vector) symbol)
    )
  )


(defmethod get-run-anim ((this civilian))
  (if (and (-> this next-state) (= (-> this next-state name) 'flee))
      (-> this anim-panic-run)
      (-> this anim-run)
      )
  )

(defmethod enemy-method-81 ((this civilian))
  #f
  )

;; WARN: Return type mismatch object vs none.
(defmethod cleanup-for-death ((this civilian))
  (cond
    ((zero? (-> this hit-points))
     (logclear! (-> this flags) (citizen-flag persistent))
     (send-event (ppointer->process (-> this parent)) 'child-killed)
     (let ((a1-1 (new 'stack-no-clear 'traffic-danger-info)))
       (set! (-> a1-1 sphere quad) (-> this root trans quad))
       (set! (-> a1-1 sphere r) 40960.0)
       (set! (-> a1-1 velocity quad) (-> this root transv quad))
       (set! (-> a1-1 notify-radius) 122880.0)
       (set! (-> a1-1 danger-level) 1.0)
       (set! (-> a1-1 decay-rate) 0.0)
       (set! (-> a1-1 flags) (traffic-danger-flags tdf0))
       (set! (-> a1-1 danger-type) (traffic-danger-type tdt7))
       (set! (-> a1-1 handle) (process->handle this))
       (set! (-> a1-1 handle) (the-as handle #f))
       (add-danger (-> this controller traffic) a1-1)
       )
     (go-inactive this)
     )
    (else
      (set! (-> this hit-points) (-> this enemy-info default-hit-points))
      (set! (-> this hit-points) (rand-vu-int-range 1 4))
      (set! (-> this fated-time) 0)
      (logior! (-> this enemy-flags) (enemy-flag vulnerable vulnerable-backup))
      (logior! (-> this focus-status) (focus-status dangerous))
      (logior! (-> this enemy-flags) (enemy-flag dangerous-backup))
      (logior! (-> this enemy-flags) (enemy-flag trackable trackable-backup))
      (logclear! (-> this focus-status) (focus-status dead))
      (logior! (-> this mask) (process-mask collectable))
      (logior! (-> this enemy-flags) (enemy-flag attackable-backup))
      (if (zero? (-> this hit-face))
          (go (method-of-object this get-up-front))
          (go (method-of-object this get-up-back))
          )
      )
    )
  (none)
  )

(defmethod damage-amount-from-attack ((this civilian) (arg0 process) (arg1 event-message-block))
  "@returns the amount of damage taken from an attack.  This can come straight off the [[attack-info]] or via [[penetrate-using->damage]]"
  (cond
    ;; og:preserve-this constant
    ((= (scf-get-territory) GAME_TERRITORY_SCEI)
     (let ((a1-1 (-> arg1 param 1))
           (a0-1 arg0)
           )
       (cond
         (a0-1
           (let ((v1-0 (find-offending-process-focusable a0-1 (the-as attack-info a1-1))))
             (cond
               (v1-0
                 (cond
                   ((= (-> v1-0 type) target)
                    0
                    )
                   ((or (logtest? (process-mask enemy) (-> v1-0 mask)) (logtest? (process-mask guard) (-> v1-0 mask)))
                    ((method-of-type nav-enemy damage-amount-from-attack) this arg0 arg1)
                    )
                   (else
                     0
                     )
                   )
                 )
               (else
                 0
                 )
               )
             )
           )
         (else
           0
           )
         )
       )
     )
    (else
      ((method-of-type nav-enemy damage-amount-from-attack) this arg0 arg1)
      )
    )
  )

(defmethod enemy-method-108 ((this civilian) (arg0 process-drawable) (arg1 event-message-block))
  0
  )

;; WARN: Return type mismatch none vs object.
(defmethod go-hostile ((this civilian))
  (cleanup-for-death this)
  )

;; WARN: Return type mismatch none vs object.
(defmethod kill-prefer-falling ((this civilian))
  "If available in `enemy-info`, [[go]] to the [[die-falling]] state, if not, [[die]]"
  (cleanup-for-death this)
  )

(defmethod set-behavior! ((this civilian) (arg0 traffic-object-spawn-params))
  (let ((v1-0 (-> arg0 behavior)))
    (cond
      ((zero? v1-0)
       (go (method-of-object this idle))
       )
      ((= v1-0 2)
       (go (method-of-object this active))
       )
      ((= v1-0 3)
       (go (method-of-object this hostile))
       )
      ((= v1-0 7)
       (logior! (-> this flags) (citizen-flag persistent))
       (go (method-of-object this wait-for-ride))
       )
      (else
        (go-inactive this)
        )
      )
    )
  0
  (none)
  )

(defmethod citizen-init! ((this civilian))
  "Initialize [[citizen]] defaults."
  (let ((t9-0 (method-of-type citizen citizen-init!)))
    (t9-0 this)
    )
  (set! (-> this mask) (the-as process-mask (logior (process-mask civilian) (-> this mask))))
  (set! (-> this hit-points) (rand-vu-int-range 1 4))
  (set! (-> this hit-points) 4)
  (set! (-> this fact pickup-type) (pickup-type none))
  (set! (-> this fact pickup-amount) 0.0)
  (set! (-> this fact pickup-spawn-amount) 0.0)
  0
  (none)
  )

;; WARN: Return type mismatch nav-segment vs none.
(defmethod civilian-method-215 ((this civilian) (arg0 vector))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> this root trans quad))
    (set! (-> v1-0 w) 81920.0)
    (let ((s5-0 (find-segment this v1-0 arg0)))
      (if s5-0
          (citizen-method-186 this s5-0)
          )
      )
    )
  (none)
  )

(defmethod general-event-handler ((this civilian) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
   @TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (case arg2
    (('track)
     #f
     )
    (('combo)
     #f
     )
    (('touched)
     ((method-of-type citizen general-event-handler) this arg0 arg1 arg2 arg3)
     )
    (('panic)
     (let ((a0-6 (-> arg3 param 0)))
       (set! (-> this danger-pos quad) (-> (the-as sphere (+ a0-6 0)) quad))
       )
     (if (and (-> this next-state) (let ((v1-6 (-> this next-state name)))
                                     (or (= v1-6 'active) (= v1-6 'wait) (= v1-6 'avoid-danger))
                                     )
              )
         (go (method-of-object this flee))
         )
     )
    (('event-death)
     (if (zero? (-> this hit-points))
         (do-effect (-> this skel effect) 'death-default 0.0 -1)
         )
     )
    (('avoid)
     (set-time! (-> this last-danger-time))
     (let ((a0-15 (-> arg3 param 0)))
       (set! (-> this danger-pos quad) (-> (the-as vector (+ a0-15 0)) quad))
       )
     (if (and (-> this next-state) (let ((v1-18 (-> this next-state name)))
                                     (or (= v1-18 'active) (= v1-18 'wait))
                                     )
              )
         (go (method-of-object this avoid-danger))
         )
     )
    (('clear-path)
     (set-time! (-> this last-danger-time))
     (let ((v1-23 (the-as traffic-danger-info (-> arg3 param 0))))
       (set! (-> this cp-valid?) #t)
       (set! (-> this cp-sphere quad) (-> v1-23 sphere quad))
       (set! (-> this cp-vec quad) (-> v1-23 velocity quad))
       (case (-> v1-23 danger-type)
         (((traffic-danger-type tdt0))
          (set! (-> this allow-dive) #f)
          (set! (-> this cp-factor) 20.0)
          )
         (((traffic-danger-type tdt1))
          (set! (-> this allow-dive) #f)
          (set! (-> this cp-factor) 20.0)
          )
         (((traffic-danger-type tdt2))
          (set! (-> this allow-dive) #t)
          (set! (-> this cp-factor) 50.0)
          )
         (((traffic-danger-type tdt3))
          (set! (-> this allow-dive) #t)
          (set! (-> this cp-factor) 50.0)
          )
         (((traffic-danger-type tdt4))
          (set! (-> this allow-dive) #f)
          (set! (-> this cp-factor) 2.0)
          )
         (((traffic-danger-type tdt5))
          (set! (-> this allow-dive) #t)
          (set! (-> this cp-factor) 50.0)
          )
         (((traffic-danger-type tdt6))
          (set! (-> this allow-dive) #t)
          (set! (-> this cp-factor) 50.0)
          )
         )
       )
     (let ((s5-1 (-> this cp-plane)))
       (set! (-> s5-1 quad) (-> this cp-vec quad))
       (set! (-> s5-1 y) 0.0)
       (vector-rotate90-around-y! s5-1 s5-1)
       (vector-normalize! s5-1 1.0)
       (set! (-> s5-1 w) (- (vector-dot (the-as vector s5-1) (the-as vector (-> this cp-sphere)))))
       )
     (set! (-> this cp-exit-time) (+ (current-time) (seconds 4)))
     (if (and (-> this next-state) (let ((v1-54 (-> this next-state name)))
                                     (or (= v1-54 'active) (= v1-54 'wait) (= v1-54 'avoid-danger))
                                     )
              )
         (go (method-of-object this clear-path))
         )
     )
    (('hit 'hit-flinch 'hit-knocked)
     (speech-control-method-13 *speech-control* (the-as handle this))
     (if (logtest? (-> this flags) (citizen-flag female))
         (speech-control-method-12 *speech-control* this (speech-type speech-type-27))
         (speech-control-method-12 *speech-control* this (speech-type speech-type-19))
         )
     ((method-of-type citizen general-event-handler) this arg0 arg1 arg2 arg3)
     )
    (('end-task)
     (let ((v0-0 (the-as object (logclear (-> this flags) (citizen-flag persistent)))))
       (set! (-> this flags) (the-as citizen-flag v0-0))
       v0-0
       )
     )
    (else
      ((method-of-type citizen general-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod civilian-method-214 ((this civilian) (arg0 nav-branch) (arg1 int) (arg2 vector) (arg3 float))
  (when (nonzero? arg1)
    (-> arg0 src-node)
    (let* ((s3-0 (-> arg0 dest-node))
           (t9-0 vector-vector-xz-distance)
           (a0-1 arg2)
           (a2-1 s3-0)
           (a1-1 (new 'stack-no-clear 'vector))
           )
      (set! (-> a1-1 quad) (-> a2-1 position quad))
      (set! (-> a1-1 w) 1.0)
      (let ((s1-0 (t9-0 a0-1 a1-1))
            (s2-0 (-> s3-0 branch-count))
            (f30-0 0.0)
            )
        (dotimes (s0-0 s2-0)
          (+! f30-0 (civilian-method-214 this (-> s3-0 branch-array s0-0) (+ arg1 -1) arg2 s1-0))
          )
        ;; og:preserve-this changed to fix a divide by zero crash
        (set! arg3 (+ s1-0 (the float (/-signed-0-guard (the int f30-0) s2-0))))
        )
      )
    )
  arg3
  )

(defstate wait (civilian)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type citizen wait) enter)))
      (if t9-0
          (t9-0)
          )
      )
    )
  )

(defbehavior civilian-flee-post civilian ()
  (let* ((gp-0 (-> self controller))
         (s4-0 (-> gp-0 branch dest-node))
         (s5-0 (the-as nav-branch #f))
         (s3-1 (vector-!
                 (new 'stack-no-clear 'vector)
                 (-> self controller turn-exit-point)
                 (-> self controller path-prev-point)
                 )
               )
         )
    0.0
    (let ((s2-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (-> self controller turn-exit-point))))
      (set! (-> s2-1 y) 0.0)
      (set! (-> s3-1 y) 0.0)
      (vector-xz-normalize! s3-1 1.0)
      (let ((f0-4 (vector-dot s2-1 s3-1)))
        (when (< -16384.0 f0-4)
          (cond
            ((zero? (-> s4-0 branch-count))
             )
            (else
              (let ((s3-2 (-> s4-0 branch-count))
                    (f30-0 0.0)
                    )
                (dotimes (s2-2 s3-2)
                  (let* ((s1-0 (-> s4-0 branch-array s2-2))
                         (f0-5 (civilian-method-214 self s1-0 4 (-> self danger-pos) 0.0))
                         )
                    (when (< f30-0 f0-5)
                      (set! f30-0 f0-5)
                      (set! s5-0 s1-0)
                      )
                    )
                  )
                )
              )
            )
          (when s5-0
            (vehicle-controller-method-11 gp-0)
            (let ((s4-1 (new 'stack-no-clear 'vector)))
              (set! (-> s4-1 quad) (-> gp-0 turn-exit-point quad))
              (vehicle-controller-method-10 gp-0 (the-as traffic-tracker s5-0))
              (set! (-> gp-0 path-prev-point quad) (-> s4-1 quad))
              )
            (set! (-> gp-0 branch) s5-0)
            (let ((a1-3 (-> s5-0 dest-node))
                  (v1-23 (-> gp-0 turn-exit-point))
                  )
              (set! (-> v1-23 quad) (-> a1-3 position quad))
              (set! (-> v1-23 w) 1.0)
              )
            )
          )
        )
      )
    )
  (when (< (-> self cp-next-time) (current-time))
    (set! (-> self cp-next-time) (+ (current-time) (rnd-int-range self 600 1200)))
    (citizen-method-190 self (-> self cp-force))
    )
  (add-offset-to-target! (-> self nav state) (-> self cp-force))
  (if *citizen-debug*
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (-> self root trans)
        (vector+! (new 'stack-no-clear 'vector) (-> self root trans) (-> self cp-force))
        *color-red*
        #f
        (the-as rgba -1)
        )
      )
  (let ((a0-18 (-> self nav state))
        (v1-42 (-> self controller turn-exit-point))
        )
    (logclear! (-> a0-18 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-18 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-18 target-post quad) (-> v1-42 quad))
    )
  0
  (set! (-> (new 'stack-no-clear 'vector) quad) (-> self nav state target-post quad))
  (nav-enemy-method-176 self)
  (none)
  )

(defstate flee (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-166 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self speed-run)))
      )
    0
    (let ((a1-5 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (the-as vector (-> self danger-pos)))))
      (civilian-method-215 self a1-5)
      )
    (if (zero? (-> self controller branch))
        (citizen-method-195 self (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
        )
    (if (zero? (-> self controller branch))
        (go-dive self)
        )
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.0 0.0 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    )
  :trans (behavior ()
    (when (and (logtest? (-> self draw status) (draw-control-status on-screen))
               (< (vector-vector-distance (-> self root trans) (camera-pos)) 204800.0)
               )
      (if (logtest? (-> self flags) (citizen-flag female))
          (speech-control-method-12 *speech-control* self (speech-type speech-type-24))
          (speech-control-method-12 *speech-control* self (speech-type speech-type-16))
          )
      )
    (if (and (time-elapsed? (-> self state-time) (seconds 0.1))
             (not (logtest? (-> self nav state flags) (nav-state-flag in-mesh)))
             (< (-> self root trans y) 4096.0)
             )
        (go-virtual in-ditch)
        )
    (citizen-method-192 self)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self anim-panic-run))) 30)
    )
  :post (behavior ()
    (civilian-flee-post)
    )
  )

(defbehavior civilian-avoid-danger-post civilian ()
  (local-vars (sv-352 nav-poly))
  (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (the-as vector (-> self danger-pos)))))
    (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self controller turn-exit-point) (-> self root trans))))
      (vector-!
        (new 'stack-no-clear 'vector)
        (-> self controller turn-exit-point)
        (the-as vector (-> self danger-pos))
        )
      (let ((s1-1 (vector-!
                    (new 'stack-no-clear 'vector)
                    (-> self controller turn-exit-point)
                    (-> self controller path-prev-point)
                    )
                  )
            )
        (set! (-> s5-1 y) 0.0)
        (set! (-> s1-1 y) 0.0)
        (vector-xz-normalize! s1-1 1.0)
        (vector-rotate90-around-y! s1-1 s1-1)
        (let ((s3-0 (new 'stack-no-clear 'vector))
              (s2-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              (s0-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
              )
          (let ((v1-6 (-> self nav))
                (a0-8 (-> self danger-pos))
                (a1-5 (new 'stack-no-clear 'nav-find-poly-parms))
                )
            (vector-! (-> a1-5 point) (the-as vector a0-8) (-> v1-6 state mesh bounds))
            (set! (-> a1-5 y-threshold) (-> v1-6 nearest-y-threshold))
            (set! (-> a1-5 ignore) (the-as uint 2))
            (set! sv-352 (find-poly-containing-point-local (-> v1-6 state mesh) a1-5))
            )
          (when sv-352
            (vector-normalize-copy! s3-0 s1-1 40960.0)
            (clamp-vector-to-mesh-no-gaps (-> self nav) (-> self danger-pos) sv-352 s3-0 s0-0)
            (vector-normalize-copy! s2-0 s1-1 -40960.0)
            (let ((a0-14 (-> self nav))
                  (t9-7 (method-of-type nav-control clamp-vector-to-mesh-no-gaps))
                  (a1-9 (-> self danger-pos))
                  (a3-3 s2-0)
                  )
              (t9-7 a0-14 a1-9 sv-352 a3-3 s0-0)
              )
            (let* ((v1-12 s3-0)
                   (f0-7 (sqrtf (+ (* (-> v1-12 x) (-> v1-12 x)) (* (-> v1-12 z) (-> v1-12 z)))))
                   (v1-14 s2-0)
                   (f1-7 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
                   )
              (cond
                ((< 0.0 (vector-dot s1-1 gp-1))
                 (if (< 8192.0 f0-7)
                     (set! (-> s4-0 quad) (-> s3-0 quad))
                     (set! (-> s4-0 quad) (-> s2-0 quad))
                     )
                 )
                ((< 8192.0 f1-7)
                 (set! (-> s4-0 quad) (-> s2-0 quad))
                 )
                (else
                  (set! (-> s4-0 quad) (-> s3-0 quad))
                  )
                )
              )
            (let* ((v1-24 gp-1)
                   (f0-13 (sqrtf (+ (* (-> v1-24 x) (-> v1-24 x)) (* (-> v1-24 z) (-> v1-24 z)))))
                   )
              (let ((f1-12 0.8)
                    (v1-27 s5-1)
                    )
                (* f1-12 (sqrtf (+ (* (-> v1-27 x) (-> v1-27 x)) (* (-> v1-27 z) (-> v1-27 z)))))
                )
              (let ((f0-15 (/ (- (-> self danger-pos r) f0-13) (-> self danger-pos r))))
                (if (< f0-15 0.0)
                    (set! f0-15 0.0)
                    )
                (if (< 0.8 f0-15)
                    (set! f0-15 0.8)
                    )
                (set! (-> gp-1 quad) (-> s4-0 quad))
                (vector-xz-normalize! gp-1 (* 16384.0 f0-15))
                )
              )
            (vector-xz-normalize! s5-1 16384.0)
            )
          )
        )
      (vector+! gp-1 gp-1 s5-1)
      )
    (vector-xz-normalize! gp-1 4096.0)
    (let ((a0-27 (-> self nav state))
          (v1-41 (vector+! (new 'stack-no-clear 'vector) gp-1 (-> self root trans)))
          )
      (logclear! (-> a0-27 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-27 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-27 target-post quad) (-> v1-41 quad))
      )
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defbehavior civilian-avoid-danger-post2 civilian ()
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (calc-danger-vec self (-> self danger-pos) gp-0)
    (add-offset-to-target! (-> self nav state) gp-0)
    (if *citizen-debug*
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> self root trans)
          (vector+! (new 'stack-no-clear 'vector) (-> self root trans) gp-0)
          *color-blue*
          #f
          (the-as rgba -1)
          )
        )
    )
  (let ((gp-1 (new 'stack-no-clear 'vector)))
    (citizen-method-188 self gp-1)
    (add-offset-to-target! (-> self nav state) gp-1)
    (if *citizen-debug*
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> self root trans)
          (vector+! (new 'stack-no-clear 'vector) (-> self root trans) gp-1)
          *color-green*
          #f
          (the-as rgba -1)
          )
        )
    )
  (let ((a0-6 (-> self nav state))
        (v1-23 (-> self controller turn-exit-point))
        )
    (logclear! (-> a0-6 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-6 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-6 target-post quad) (-> v1-23 quad))
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defstate avoid-danger (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self speed-walk)))
      )
    0
    (set! (-> self next-time) (+ (current-time) (rnd-int-range self 300 600)))
    (set! (-> self last-second-pos quad) (-> self root trans quad))
    (set! (-> self last-distance)
          (vector-vector-xz-distance (-> self controller turn-exit-point) (-> self root trans))
          )
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.0 0.0 1.0 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    )
  :trans (behavior ()
    (if (< (+ (-> self last-danger-time) (seconds 1)) (current-time))
        (go-virtual active)
        )
    (when (citizen-method-187 self)
      (cond
        ((< (* 2.0 (-> self danger-pos r))
            (vector-vector-xz-distance (-> self danger-pos) (-> self controller turn-exit-point))
            )
         (go-virtual active)
         )
        (else
          (vehicle-controller-method-14 (-> self controller) (the-as vehicle self))
          (set! (-> self last-distance)
                (vector-vector-xz-distance (-> self controller turn-exit-point) (-> self root trans))
                )
          )
        )
      )
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info walk-anim))) 60)
    )
  :post (behavior ()
    (civilian-avoid-danger-post2)
    )
  )

(defbehavior civilian-clear-path-post civilian ()
  (local-vars (sv-304 nav-poly))
  (let ((s5-1 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (the-as vector (-> self cp-sphere))))
        (s1-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> gp-0 quad) (-> self cp-vec quad))
    (set! (-> gp-0 y) 0.0)
    (vector-xz-normalize! gp-0 1.0)
    (vector-rotate90-around-y! gp-0 gp-0)
    (set! (-> s5-1 y) 0.0)
    (vector-*! s1-0 s5-1 gp-0 (vector-dot s5-1 gp-0))
    (vector+! s1-0 s1-0 (the-as vector (-> self cp-sphere)))
    (vector-xz-normalize! s5-1 1.0)
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s2-0 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (s0-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
          )
      (set! sv-304 (-> self nav state current-poly))
      (let ((f30-0 (+ 4096.0 (-> self cp-sphere r))))
        (when sv-304
          (vector-normalize-copy! s3-0 gp-0 f30-0)
          (vector-normalize-copy! s2-0 gp-0 (- f30-0))
          (clamp-vector-to-mesh-no-gaps (-> self nav) s1-0 sv-304 s3-0 s0-0)
          (let ((a0-12 (-> self nav))
                (t9-8 (method-of-type nav-control clamp-vector-to-mesh-no-gaps))
                (a3-3 s2-0)
                )
            (t9-8 a0-12 s1-0 sv-304 a3-3 s0-0)
            )
          (let* ((v1-14 s3-0)
                 (f0-9 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
                 (v1-16 s2-0)
                 (f1-8 (sqrtf (+ (* (-> v1-16 x) (-> v1-16 x)) (* (-> v1-16 z) (-> v1-16 z)))))
                 )
            (cond
              ((< 0.0 (vector-dot gp-0 s5-1))
               (if (< 4096.0 f0-9)
                   (set! (-> s4-0 quad) (-> s3-0 quad))
                   (set! (-> s4-0 quad) (-> s2-0 quad))
                   )
               )
              ((< 4096.0 f1-8)
               (set! (-> s4-0 quad) (-> s2-0 quad))
               )
              (else
                (set! (-> s4-0 quad) (-> s3-0 quad))
                )
              )
            )
          (set! (-> gp-0 quad) (-> s4-0 quad))
          )
        )
      )
    (if *citizen-debug*
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> self root trans)
          (vector+! (new 'stack-no-clear 'vector) (-> self root trans) gp-0)
          *color-blue*
          #f
          (the-as rgba -1)
          )
        )
    (let ((a0-21 (-> self nav state))
          (v1-34 (vector+! (new 'stack-no-clear 'vector) gp-0 (-> self root trans)))
          )
      (logclear! (-> a0-21 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-21 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-21 target-post quad) (-> v1-34 quad))
      )
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defbehavior civilian-clear-path-post2 civilian ()
  (citizen-method-192 self)
  (when (< (-> self cp-next-time) (current-time))
    (citizen-method-190 self (-> self cp-force))
    (set! (-> self cp-next-time) (+ (current-time) (rnd-int-range self 1200 2400)))
    )
  (let ((gp-1 (new 'stack-no-clear 'vector)))
    (citizen-method-188 self gp-1)
    (add-offset-to-target! (-> self nav state) gp-1)
    )
  (if *citizen-debug*
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (-> self root trans)
        (vector+! (new 'stack-no-clear 'vector) (-> self root trans) (-> self cp-force))
        *color-blue*
        #f
        (the-as rgba -1)
        )
      )
  (add-offset-to-target! (-> self nav state) (-> self cp-force))
  (let ((a0-9 (-> self nav state))
        (v1-25 (-> self controller turn-exit-point))
        )
    (logclear! (-> a0-9 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-9 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-9 target-post quad) (-> v1-25 quad))
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defstate clear-path (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self speed-walk)))
      )
    0
    (set! (-> self cp-next-time) (+ (current-time) (rnd-int-range self 1200 2400)))
    (set! (-> self cp-force quad) (the-as uint128 0))
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.0 1.0 0.0 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    )
  :trans (behavior ()
    (when (citizen-method-187 self)
      (vehicle-controller-method-14 (-> self controller) (the-as vehicle self))
      (set! (-> self last-distance)
            (vector-vector-xz-distance (-> self controller turn-exit-point) (-> self root trans))
            )
      )
    (let ((v1-8 (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (the-as vector (-> self cp-sphere)))))
      (cond
        ((< (* 0.5 (vector-length (-> self cp-vec))) (vector-length v1-8))
         (let ((a0-10 (-> self nav)))
           (set! (-> a0-10 target-speed) (* (-> self speed-scale) (-> self speed-walk)))
           )
         0
         (let ((a0-12 (-> self nav)))
           (set! (-> a0-12 acceleration) (-> self enemy-info walk-acceleration))
           )
         0
         (let ((a0-14 (-> self nav)))
           (set! (-> a0-14 turning-acceleration) (-> self enemy-info walk-turning-acceleration))
           )
         0
         )
        (else
          (let ((a0-16 (-> self nav)))
            (set! (-> a0-16 target-speed) (* (-> self speed-scale) (-> self speed-run)))
            )
          0
          (let ((a0-18 (-> self nav)))
            (set! (-> a0-18 acceleration) (-> self enemy-info run-acceleration))
            )
          0
          (let ((a0-20 (-> self nav)))
            (set! (-> a0-20 turning-acceleration) (-> self enemy-info run-turning-acceleration))
            )
          0
          )
        )
      (if (and (-> self allow-dive)
               (< (vector-length v1-8) (* (-> self dive-reaction) (vector-length (-> self cp-vec))))
               (< (fabs (vector4-dot (-> self root trans) (the-as vector (-> self cp-plane)))) (/ (-> self cp-sphere r) 2))
               )
          (go-dive self)
          )
      )
    (if (< (-> self cp-exit-time) (current-time))
        (go-virtual active)
        )
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info walk-anim))) 30)
    )
  :post (behavior ()
    (civilian-clear-path-post2)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-dive ((this civilian))
  (if (< (-> this nav state speed) 8192.0)
      (go (method-of-object this on-ground))
      (go (method-of-object this dive))
      )
  (none)
  )

(defstate on-ground (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-8 (-> self root root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self root nav-flags) (nav-flags has-root-sphere has-extra-sphere))
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.5 0.5 1.0 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (let ((v1-5 (-> self root root-prim)))
      (set! (-> v1-5 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-5 prim-core collide-with) (-> self root backup-collide-with))
      )
    (logior! (-> self root nav-flags) (nav-flags has-root-sphere))
    )
  :trans (behavior ()
    (if (< (+ (-> self last-danger-time) (seconds 1)) (current-time))
        (go-virtual get-up-front)
        )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-on-ground))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (nav-enemy-simple-post)
    )
  )

(defstate dive (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (let ((v1-8 (-> self root root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self root nav-flags) (nav-flags has-root-sphere has-extra-sphere))
    (let ((v1-12 (-> self nav)))
      (set! (-> v1-12 sphere-mask) (the-as uint 0))
      )
    0
    (let ((v1-14 (-> self nav)))
      (set! (-> v1-14 target-speed) 32768.0)
      )
    0
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 acceleration) 32768.0)
      )
    0
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (let ((a1-4 (-> self nav state)))
        (set! (-> gp-0 quad) (-> a1-4 heading quad))
        )
      (vector-normalize! gp-0 614400.0)
      (vector+! (-> self dive-target-point) (-> self root trans) gp-0)
      (set! (-> self dive-target-point quad) (-> gp-0 quad))
      )
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.5 0.5 1.0 1.0)
        )
    (set! (-> self dive-finished?) #f)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (let ((v1-5 (-> self root root-prim)))
      (set! (-> v1-5 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-5 prim-core collide-with) (-> self root backup-collide-with))
      )
    (logior! (-> self root nav-flags) (nav-flags has-root-sphere))
    ;; og:preserve-this fix potential use-after-free bug
    (if (-> self nav)
      (let ((v1-9 (-> self nav)))
        (set! (-> v1-9 sphere-mask) (the-as uint #x800fe))
        ))
    0
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-dive))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (add-offset-to-target! (-> self nav state) (-> self dive-target-point))
      (if (>= (ja-frame-num 0) 6.0)
          (vector-v*float++! (-> self dive-target-point) (-> self dive-target-point) -20.0)
          )
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (set! (-> self dive-finished?) #t)
    (set! (-> self root transv quad) (the-as uint128 0))
    (go-virtual cower-ground)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 *null-vector*)
          )
      (logior! (-> a0-0 flags) (nav-state-flag directional-mode))
      (set! (-> a0-0 travel quad) (-> v1-1 quad))
      )
    0
    (if (-> self dive-finished?)
        (common-post self)
        (nav-enemy-method-176 self)
        )
    )
  )

(defstate cower-ground (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-8 (-> self root root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self root nav-flags) (nav-flags has-root-sphere has-extra-sphere))
    (let ((v1-12 (-> self nav)))
      (set! (-> v1-12 sphere-mask) (the-as uint 0))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.2 0.2 0.2 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (let ((v1-5 (-> self root root-prim)))
      (set! (-> v1-5 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-5 prim-core collide-with) (-> self root backup-collide-with))
      )
    (logior! (-> self root nav-flags) (nav-flags has-root-sphere))
    ;; og:preserve-this fix potential use-after-free bug
    (if (-> self nav)
      (let ((v1-9 (-> self nav)))
        (set! (-> v1-9 sphere-mask) (the-as uint #x800fe))
        ))
    0
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-start))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-loop))
                  :num! (seek! max (-> self speed-scale))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self speed-scale)))
        )
      (if (< (+ (-> self last-danger-time) (seconds 1)) (current-time))
          (goto cfg-9)
          )
      )
    #f
    (label cfg-9)
    (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-end))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (go-virtual get-up-front)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 *null-vector*)
          )
      (logior! (-> a0-0 flags) (nav-state-flag directional-mode))
      (set! (-> a0-0 travel quad) (-> v1-1 quad))
      )
    0
    (common-post self)
    )
  )

(defstate get-up-front (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-front))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (go-virtual flee)
    )
  :post (behavior ()
    (enemy-method-49 self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (common-post self)
    )
  )

(defstate get-up-back (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-back))
                :num! (seek! max (-> self speed-scale))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (go-virtual flee)
    )
  :post (behavior ()
    (enemy-method-49 self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (common-post self)
    )
  )

(defbehavior civilian-falling-post civilian ()
  (logior! (-> self enemy-flags) (enemy-flag recover-applied-velocity))
  (let ((gp-0 (-> self root)))
    (cond
      ((focus-test? self under-water)
       (enemy-method-47 self (-> gp-0 transv))
       )
      (else
        (let ((a1-1 (new-stack-vector0)))
          (vector-v++! (-> gp-0 transv) (compute-acc-due-to-gravity gp-0 a1-1 (-> self enemy-info slip-factor)))
          )
        )
      )
    (let ((a2-1 (new 'stack-no-clear 'collide-query)))
      (set! (-> a2-1 collide-with) (-> gp-0 root-prim prim-core collide-with))
      (set! (-> a2-1 ignore-process0) self)
      (set! (-> a2-1 ignore-process1) (-> self vehicle process 0))
      (set! (-> a2-1 ignore-pat) (logior (new 'static 'pat-surface :noendlessfall #x1) (-> gp-0 pat-ignore-mask)))
      (set! (-> a2-1 action-mask) (collide-action solid))
      (fill-cache-integrate-and-collide gp-0 (-> gp-0 transv) a2-1 (meters 0))
      )
    )
  (enemy-method-111 self)
  (common-post self)
  (none)
  )

(defstate knocked (civilian)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type citizen knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self hit-face)
          (the-as
            uint
            (if (< (vector-dot (-> self root transv) (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
                   0.0
                   )
                1
                0
                )
            )
          )
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self root backup-collide-with))
      )
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) exit)))
      (if t9-0
          (t9-0)
          )
      )
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type citizen knocked) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (enemy-method-49 self)
    )
  )

(defstate wait-for-ride (civilian)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('board-vehicle)
       (let ((a0-1 (the-as vehicle (-> block param 0))))
         (when a0-1
           (let ((v0-0 (the-as object (process->handle a0-1))))
             (set! (-> self vehicle) (the-as handle v0-0))
             v0-0
             )
           )
         )
       )
      (else
        (enemy-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set-time! (-> self state-time))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((a0-5 (-> self nav state))
          (v1-10 *null-vector*)
          )
      (logior! (-> a0-5 flags) (nav-state-flag directional-mode))
      (set! (-> a0-5 travel quad) (-> v1-10 quad))
      )
    0
    (set! (-> self vehicle) (the-as handle #f))
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    )
  :trans (behavior ()
    (if (and (not (logtest? (-> self nav state flags) (nav-state-flag in-mesh))) (< (-> self root trans y) 4096.0))
        (go-virtual in-ditch)
        )
    (when (-> self vehicle)
      (case (-> (the-as vehicle (handle->process (-> self vehicle))) info object-type)
        ((14 15 16 11 12 13)
         (go-virtual move-to-vehicle)
         )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                  :num! (seek! max 0.1)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.1))
        )
      )
    #f
    )
  :post (behavior ()
    (nav-enemy-simple-post)
    )
  )

(defmethod civilian-method-217 ((this civilian) (arg0 vector))
  (let ((s3-0 (handle->process (-> this vehicle)))
        (s4-0 (new 'stack 'collide-query))
        )
    (compute-seat-position (the-as vehicle s3-0) arg0 (-> this seat))
    (vector-! arg0 arg0 (-> (the-as vehicle s3-0) root trans))
    (vector-normalize! arg0 (+ 14336.0 (vector-length arg0)))
    (vector+! arg0 arg0 (-> (the-as vehicle s3-0) root trans))
    (when (enemy-above-ground? this s4-0 arg0 (collide-spec backgnd) 8192.0 81920.0 1024.0)
      (set! (-> arg0 y) (-> s4-0 best-other-tri intersect y))
      (let ((v1-14 (-> this nav))
            (a1-10 (new 'stack-no-clear 'nav-find-poly-parms))
            )
        (vector-! (-> a1-10 point) arg0 (-> v1-14 state mesh bounds))
        (set! (-> a1-10 y-threshold) (-> v1-14 nearest-y-threshold))
        (set! (-> a1-10 ignore) (the-as uint 2))
        (if (find-poly-containing-point-local (-> v1-14 state mesh) a1-10)
            (return #t)
            )
        )
      )
    )
  #f
  )

(defun do-spline2 ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 vector) (arg5 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((f1-1 (* arg5 arg5))
           (f0-2 (* arg5 f1-1))
           )
      (let ((f2-3 (- (+ 1.0 (* -3.0 arg5) (* 3.0 f1-1)) f0-2))
            (f3-7 (+ (* 3.0 f0-2) (* -6.0 f1-1) (* 3.0 arg5)))
            (f1-3 (+ (* -3.0 f0-2) (* 3.0 f1-1)))
            )
        (vector-float*! arg0 arg1 f2-3)
        (let ((t2-0 arg0))
          (let ((v1-10 arg0))
            (let ((t1-3 (vector+! (new 'stack-no-clear 'vector) arg1 arg2)))
              (let ((a1-1 f3-7))
                (.mov vf7 a1-1)
                )
              (.lvf vf5 (&-> t1-3 quad))
              )
            (.lvf vf4 (&-> v1-10 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> t2-0 quad) vf6)
          )
        (let ((a2-1 arg0))
          (let ((v1-11 arg0))
            (let ((a1-3 (vector+! (new 'stack-no-clear 'vector) arg3 arg4)))
              (let ((t0-1 f1-3))
                (.mov vf7 t0-1)
                )
              (.lvf vf5 (&-> a1-3 quad))
              )
            (.lvf vf4 (&-> v1-11 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a2-1 quad) vf6)
          )
        )
      (let ((v0-0 arg0))
        (let ((v1-12 arg0))
          (let ((a0-1 arg3))
            (let ((a1-4 f0-2))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-1 quad))
            )
          (.lvf vf4 (&-> v1-12 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v0-0 quad) vf6)
        v0-0
        )
      )
    )
  )

(defstate move-to-vehicle (civilian)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (enemy-event-handler proc argc message block)
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set-time! (-> self state-time))
    (let ((v1-4 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-4 enemy-flags)))
          (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-4 enemy-flags))))
          )
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-4 enemy-flags))))
      (set! (-> v1-4 nav callback-info) (-> v1-4 enemy-info callback-info))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-7 enemy-flags))))
      )
    0
    (nav-enemy-method-166 self)
    (let ((v1-12 (-> self nav state)))
      (set! (-> v1-12 speed) 0.0)
      )
    0
    (let ((v1-14 (-> self nav)))
      (set! (-> v1-14 sphere-mask) (the-as uint #x800f8))
      )
    0
    )
  :exit (behavior ()
    ;; og:preserve-this fix potential use-after-free bug
    (if (-> self nav)
      (let ((v1-0 (-> self nav)))
        (set! (-> v1-0 sphere-mask) (the-as uint #x800fe))
        ))
    0
    (logclear! (-> self flags) (citizen-flag persistent))
    )
  :trans (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (new 'stack-no-clear 'vector)
      (let ((s0-0 (handle->process (-> self vehicle))))
        (cond
          (s0-0
            (set! (-> self seat)
                  (get-best-seat-for-vehicle (the-as vehicle s0-0) (-> self root trans) (the-as int (-> self info seat-flag)) 1)
                  )
            (cond
              ((!= (-> self seat) -1)
               (compute-seat-position (the-as vehicle s0-0) gp-0 (-> self seat))
               (let ((s2-0 (new 'stack-no-clear 'vector))
                     (s4-0 (new 'stack-no-clear 'vector))
                     (s1-0 (new 'stack-no-clear 'vector))
                     (s5-0 (new 'stack-no-clear 'vector))
                     )
                 (let ((s3-0 (new 'stack-no-clear 'vector)))
                   (new 'stack-no-clear 'vector)
                   (set! (-> s2-0 quad) (-> self root trans quad))
                   (set! (-> s1-0 quad) (-> gp-0 quad))
                   (vector-! s5-0 gp-0 (-> (the-as vehicle s0-0) root trans))
                   (vector-z-quaternion! s4-0 (-> self root quat))
                   (let ((f30-1 (* 0.5 (vector-vector-xz-distance s2-0 s1-0))))
                     (vector-normalize! s4-0 (* 2.0 f30-1))
                     (vector-normalize! s5-0 (* 4.0 f30-1))
                     )
                   (do-spline2 s3-0 s2-0 s4-0 s1-0 s5-0 0.8)
                   (let ((v1-21 (-> self nav state)))
                     (logclear! (-> v1-21 flags) (nav-state-flag directional-mode))
                     (logior! (-> v1-21 flags) (nav-state-flag target-poly-dirty))
                     (set! (-> v1-21 target-post quad) (-> s3-0 quad))
                     )
                   )
                 0
                 (if (and (< (vector-dot (vector-normalize! s4-0 1.0) (vector-normalize! s5-0 1.0)) -0.5)
                          (< (vector-vector-xz-distance gp-0 (-> self root trans)) 18432.0)
                          (< (fabs (- (-> gp-0 y) (-> self root trans y))) 20480.0)
                          )
                     (go-virtual board-vehicle)
                     )
                 )
               )
              (else
                (go-virtual wait-for-ride)
                )
              )
            )
          (else
            (go-virtual wait-for-ride)
            )
          )
        )
      (if (< 73728.0 (vector-vector-xz-distance gp-0 (-> self root trans)))
          (go-virtual wait-for-ride)
          )
      )
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info walk-anim))) 60)
    )
  :post (behavior ()
    (nav-enemy-method-176 self)
    )
  )

(defstate board-vehicle (civilian)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('vehicle-crash)
       #f
       )
      (('end-task)
       (kill-prefer-falling self)
       )
      (else
        (enemy-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set-time! (-> self state-time))
    (let ((v1-5 (-> self root root-prim)))
      (set! (-> v1-5 prim-core collide-as) (collide-spec))
      (set! (-> v1-5 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-7 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-10 self))
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logclear (-> v1-10 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (logclear! (-> self focus-status) (focus-status pilot))
    )
  :trans (behavior ()
    (let ((v1-1 (handle->process (-> self vehicle))))
      (if (or (not v1-1) (logtest? (-> (the-as vehicle v1-1) flags) (rigid-body-object-flag dead)))
          (throw-off-vehicle self)
          )
      )
    )
  :code (behavior ()
    (local-vars (sv-128 float) (sv-144 float))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim)) :num! min)
    (let ((f30-0 0.0))
      (while (< f30-0 1.0)
        (ja :num-func num-func-identity
            :frame-num (lerp-scale 0.0 1.0 (+ (* -2.0 f30-0 f30-0 f30-0) (* 3.0 f30-0 f30-0)) 0.0 1.0)
            )
        (suspend)
        (+! f30-0 (* 3.0 (seconds-per-frame)))
        )
      )
    (let ((gp-2 (new 'stack-no-clear 'vector)))
      (set! (-> gp-2 quad) (-> self root trans quad))
      (let ((s5-0 (quaternion-copy! (new 'stack-no-clear 'quaternion) (-> self root quat))))
        (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                    :num! (seek! (ja-aframe 5.0 0) 0.86956525)
                    :frame-num (ja-aframe 1.0 0)
                    )
        (until (ja-done? 0)
          (let ((s2-0 (handle->process (-> self vehicle)))
                (s1-0 (new 'stack-no-clear 'vector))
                (s4-1 (new 'stack-no-clear 'vector))
                (s3-0 (new 'stack-no-clear 'quaternion))
                )
            (if (not s2-0)
                (go-virtual wait-for-ride)
                )
            (quaternion-copy! s3-0 (-> (the-as vehicle s2-0) root quat))
            (compute-seat-position (the-as vehicle s2-0) s1-0 (-> self seat))
            (vector-! s4-1 s1-0 gp-2)
            (let ((s2-1 lerp-scale)
                  (s1-1 0.0)
                  (s0-0 1.0)
                  )
              (set! sv-128 (ja-aframe-num 0))
              (set! sv-144 (ja-aframe 1.0 0))
              (let* ((t0-1 (ja-aframe 5.0 0))
                     (f30-1 (s2-1 s1-1 s0-0 sv-128 sv-144 t0-1))
                     )
                (quaternion-rotate-local-y! s3-0 s3-0 (* f30-1 (if (zero? (-> self seat))
                                                                   -16384.0
                                                                   16384.0
                                                                   )
                                                         )
                                            )
                (quaternion-slerp! (-> self root quat) s5-0 s3-0 f30-1)
                (vector+float*! (-> self root trans) gp-2 s4-1 f30-1)
                )
              )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 5.0 0) 0.86956525))
          )
        )
      )
    (quaternion-copy! (new 'stack-no-clear 'quaternion) (-> self root quat))
    (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                :num! (seek! (ja-aframe 12.0 0) 0.4)
                :frame-num (ja-aframe 5.0 0)
                )
    (until (ja-done? 0)
      (let ((s5-1 (handle->process (-> self vehicle)))
            (gp-4 (new 'stack-no-clear 'quaternion))
            )
        (if (not s5-1)
            (go-virtual wait-for-ride)
            )
        (quaternion-copy! gp-4 (-> (the-as vehicle s5-1) root quat))
        (compute-seat-position (the-as vehicle s5-1) (-> self root trans) (-> self seat))
        (let ((f0-22 (lerp-scale 0.0 1.0 (ja-aframe-num 0) (ja-aframe 7.0 0) (ja-aframe 10.0 0))))
          (quaternion-rotate-local-y! (-> self root quat) gp-4 (* (- 1.0 f0-22) (if (zero? (-> self seat))
                                                                                    -16384.0
                                                                                    16384.0
                                                                                    )
                                                                  )
                                      )
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 12.0 0) 0.4))
      )
    (put-rider-in-seat (the-as vehicle (handle->process (-> self vehicle))) (-> self seat) self)
    (go-virtual ride)
    )
  :post (behavior ()
    (common-post self)
    )
  )

(defstate ride (civilian)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('exit-vehicle)
       (let ((a0-1 (the-as object (-> block param 0))))
         (set! (-> self event-param-point quad) (-> (the-as vector a0-1) quad))
         )
       (if (time-elapsed? (-> self state-time) (seconds 1))
           (go-virtual exit-vehicle)
           )
       )
      (('end-task)
       (kill-prefer-falling self)
       )
      (else
        (enemy-event-handler proc argc message block)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set-time! (-> self state-time))
    (let ((v1-5 (-> self root root-prim)))
      (set! (-> v1-5 prim-core collide-as) (collide-spec))
      (set! (-> v1-5 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-7 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-10 self))
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logclear (-> v1-10 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (logior! (-> self focus-status) (focus-status pilot-riding pilot))
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    )
  :trans (behavior ()
    (let ((v1-1 (handle->process (-> self vehicle))))
      (if (or (not v1-1) (logtest? (-> (the-as vehicle v1-1) flags) (rigid-body-object-flag dead)))
          (throw-off-vehicle self)
          )
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  :post (behavior ()
    (common-post self)
    )
  )

(defstate exit-vehicle (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (change-to (find-nearest-nav-mesh (-> self root trans) (the-as float #x7f800000)) self)
    (if (not (-> self nav))
        (go-inactive self)
        )
    (let ((v1-8 (-> self nav state)))
      (set! (-> v1-8 current-poly) (the-as nav-poly #f))
      )
    0
    (citizen-method-195
      self
      (vector-negate-in-place! (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root quat)))
      )
    (let ((a0-7 (-> self nav state))
          (v1-14 (-> self controller turn-exit-point))
          )
      (logclear! (-> a0-7 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-7 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-7 target-post quad) (-> v1-14 quad))
      )
    0
    (citizen-nav-init! self)
    (set! (-> self gnd-height) (-> self root gspot-pos y))
    (logior! (-> self flags) (citizen-flag persistent))
    (logior! (-> self focus-status) (focus-status pilot-riding pilot))
    (set-time! (-> self state-time))
    (let ((v1-28 (-> self root root-prim)))
      (set! (-> v1-28 prim-core collide-as) (collide-spec))
      (set! (-> v1-28 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-30 self))
      (set! (-> v1-30 enemy-flags) (the-as enemy-flag (logclear (-> v1-30 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-30 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-33 self))
      (set! (-> v1-33 enemy-flags) (the-as enemy-flag (logclear (-> v1-33 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    )
  :trans (behavior ()
    (let ((v1-1 (handle->process (-> self vehicle))))
      (if (or (not v1-1) (logtest? (-> (the-as vehicle v1-1) flags) (rigid-body-object-flag dead)))
          (throw-off-vehicle self)
          )
      )
    )
  :code (behavior ()
    (local-vars (sv-128 float) (sv-144 float))
    (ja-channel-push! 1 (seconds 0.1))
    (remove-rider (the-as vehicle (handle->process (-> self vehicle))) self)
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                :num! (seek! (ja-aframe 5.0 0) 0.5)
                :frame-num (ja-aframe 12.0 0)
                )
    (until (ja-done? 0)
      (let ((s5-0 (handle->process (-> self vehicle)))
            (gp-1 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-copy! gp-1 (-> (the-as vehicle s5-0) root quat))
        (compute-seat-position (the-as vehicle s5-0) (-> self root trans) (-> self seat))
        (let ((f0-3 (lerp-scale 0.0 1.0 (ja-aframe-num 0) (ja-aframe 10.0 0) (ja-aframe 7.0 0))))
          (quaternion-rotate-local-y! (-> self root quat) gp-1 (* f0-3 (if (zero? (-> self seat))
                                                                           -16384.0
                                                                           16384.0
                                                                           )
                                                                  )
                                      )
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 5.0 0) 0.5))
      )
    (let ((gp-3 (new 'stack-no-clear 'vector))
          (s5-2 (new 'stack-no-clear 'quaternion))
          )
      (while (not (civilian-method-217 self gp-3))
        (let ((s4-1 (handle->process (-> self vehicle)))
              (s3-1 (new 'stack-no-clear 'quaternion))
              )
          (quaternion-copy! s3-1 (-> (the-as vehicle s4-1) root quat))
          (compute-seat-position (the-as vehicle s4-1) (-> self root trans) (-> self seat))
          (quaternion-rotate-local-y! (-> self root quat) s3-1 (if (zero? (-> self seat))
                                                                   -16384.0
                                                                   16384.0
                                                                   )
                                      )
          )
        (suspend)
        )
      (let ((v1-43 (handle->process (-> self vehicle))))
        (quaternion-copy! s5-2 (-> (the-as vehicle v1-43) root quat))
        )
      (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                  :num! (seek! (ja-aframe 1.0 0) 0.5)
                  :frame-num (ja-aframe 5.0 0)
                  )
      (until (ja-done? 0)
        (let ((a0-46 (handle->process (-> self vehicle)))
              (s2-1 (new 'stack-no-clear 'vector))
              (s4-3 (new 'stack-no-clear 'vector))
              (s3-2 (new 'stack-no-clear 'quaternion))
              )
          (compute-seat-position (the-as vehicle a0-46) s2-1 (-> self seat))
          (vector-! s4-3 s2-1 gp-3)
          (let ((s2-2 lerp-scale)
                (s1-1 0.0)
                (s0-0 1.0)
                )
            (set! sv-128 (ja-aframe-num 0))
            (set! sv-144 (ja-aframe 5.0 0))
            (let* ((t0-1 (ja-aframe 1.0 0))
                   (f0-12 (s2-2 s1-1 s0-0 sv-128 sv-144 t0-1))
                   (f30-0 (- 1.0 f0-12))
                   )
              (quaternion-rotate-local-y! s3-2 s5-2 (if (zero? (-> self seat))
                                                        -16384.0
                                                        16384.0
                                                        )
                                          )
              (quaternion-copy! (-> self root quat) s3-2)
              (vector+float*! (-> self root trans) gp-3 s4-3 f30-0)
              )
            )
          )
        (suspend)
        (ja :num! (seek! (ja-aframe 1.0 0) 0.5))
        )
      )
    (let ((v1-74 (-> self root root-prim)))
      (set! (-> v1-74 prim-core collide-as) (-> self root backup-collide-as))
      (set! (-> v1-74 prim-core collide-with) (-> self root backup-collide-with))
      )
    (go-virtual active)
    )
  :post (behavior ()
    (common-post self)
    )
  )

(defstate wait-at-dest (civilian)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (set-time! (-> self state-time))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                  :num! (seek! max 0.1)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.1))
        )
      )
    #f
    )
  :post (behavior ()
    (nav-enemy-simple-post)
    )
  )
