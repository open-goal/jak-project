;;-*-Lisp-*-
(in-package goal)

;; name: vehicle.gc
;; name in dgo: vehicle
;; dgos: CWI

;; TODO - for vehicle
(define-extern *race-rigid-body-queue* rigid-body-queue)
(define-extern *traffic-rigid-body-queue* rigid-body-queue)

;; DECOMP BEGINS

(defun string-word-wrap ((arg0 string) (arg1 int))
  (let ((v1-0 (-> arg0 data)))
    (label cfg-1)
    (let ((a2-0 0)
          (a0-1 0)
          )
      (b! #t cfg-6 :delay (nop!))
      (label cfg-2)
      (b! (zero? (-> v1-0 a2-0)) cfg-11 :delay (nop!))
      (if (= (-> v1-0 a2-0) 32)
          (set! a0-1 a2-0)
          )
      (+! a2-0 1)
      (label cfg-6)
      (b! (< a2-0 arg1) cfg-2)
      (if (zero? a0-1)
          (set! a0-1 a2-0)
          )
      (set! (-> v1-0 a0-1) (the-as uint 10))
      (&+! v1-0 (+ a0-1 1))
      )
    )
  (goto cfg-1)
  (label cfg-11)
  0
  (none)
  )

(deftype debug-vehicle-work (basic)
  ((impact-time  time-frame                :offset-assert   8)
   (impact       rigid-body-impact :inline :offset-assert  16)
   (prim-sphere1 sphere            :inline :offset-assert  80)
   (prim-sphere2 sphere            :inline :offset-assert  96)
   )
  :method-count-assert 9
  :size-assert         #x70
  :flag-assert         #x900000070
  )


(define *debug-vehicle-work* (new 'static 'debug-vehicle-work))

(defskelgroup skel-vehicle-explosion vehicle-explosion vehicle-explosion-lod0-jg vehicle-explosion-idle-ja
              ((vehicle-explosion-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              )

(define *vehicle-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

(define *vehicle-shadow-control-disabled*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03 disable-draw)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

(defmethod rigid-body-object-method-45 vehicle ((obj vehicle) (arg0 rigid-body-impact))
  (local-vars (v1-63 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (set! (-> obj impact-pos quad) (-> arg0 point quad))
    (let* ((f0-0 1.0)
           (f1-0 (-> arg0 impulse))
           (f2-0 61440.0)
           (f30-0 (fmin f0-0 (* f1-0 (/ 1.0 f2-0) (-> obj info info inv-mass))))
           (f28-0 (* (-> obj info info mass) (-> obj info toughness-factor)))
           )
      (set! (-> obj crash-impulse) (-> arg0 impulse))
      (cond
        ((< (* 286720.0 f28-0) (-> arg0 impulse))
         (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 1))
             )
         (apply-damage obj 1.0 arg0)
         (vehicle-method-76 obj 2 (the-as uint 300))
         )
        ((< (* 131072.0 f28-0) (-> arg0 impulse))
         (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
             )
         (apply-damage obj 0.25 arg0)
         (vehicle-method-76 obj 1 (the-as uint 75))
         )
        ((< (* 102400.0 f28-0) (-> arg0 impulse))
         (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.25))
             )
         (apply-damage obj 0.125 arg0)
         (vehicle-method-76 obj 1 (the-as uint 75))
         )
        (else
          (let* ((f0-9 0.0)
                 (f1-7 (-> arg0 impulse))
                 (f2-5 (* 16384000.0 f28-0))
                 (f0-10 (fmax f0-9 (* f1-7 (/ 1.0 f2-5))))
                 )
            (apply-damage obj f0-10 arg0)
            )
          (when (< (* 32768.0 f28-0) (-> arg0 impulse))
            (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
                (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
                )
            )
          (if (< 0.1 f30-0)
              (sound-play-by-name
                (-> obj info glance-sound)
                (new-sound-id)
                (the int (* 1024.0 f30-0))
                0
                0
                (sound-group sfx)
                #t
                )
              )
          )
        )
      (when (< (* 102400.0 f28-0) (-> arg0 impulse))
        (sound-play-by-name
          (-> obj info impact-sound)
          (new-sound-id)
          (the int (* 1024.0 f30-0))
          0
          0
          (sound-group sfx)
          #t
          )
        (logclear! (-> obj flags) (rigid-body-object-flag turbo-boost))
        )
      )
    (let ((a0-17 (new 'stack-no-clear 'vector)))
      (vector+float*!
        a0-17
        (-> arg0 velocity)
        (-> arg0 normal)
        (- (vector-dot (-> arg0 velocity) (-> arg0 normal)))
        )
      (.lvf vf1 (&-> a0-17 quad))
      )
    (.add.w.vf vf2 vf0 vf0 :mask #b1)
    (.mul.vf vf1 vf1 vf1)
    (.mul.x.vf acc vf2 vf1 :mask #b1)
    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
    (.mov v1-63 vf1)
    (let ((f0-25 v1-63)
          (f1-11 12288.0)
          )
      (when (< (* f1-11 f1-11) f0-25)
        (set! (-> obj scrape-sound-envelope) 1.0)
        (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
            (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.05))
            )
        )
      )
    (if (>= 0.0 (-> obj hit-points))
        (vehicle-method-76 obj 2 (the-as uint 300))
        )
    0
    (none)
    )
  )

(defmethod vehicle-method-104 vehicle ((obj vehicle))
  (with-pp
    (when (= (-> obj controller traffic sync-mask-8) (ash 1 (logand (-> obj traffic-priority-id) 7)))
      (let ((a1-0 (-> obj root trans)))
        (set! (-> obj flight-level) (get-height-at-point *traffic-height-map* a1-0))
        )
      )
    (set! (-> obj target-acceleration y)
          (- (* 8.0 (- (-> obj flight-level) (-> obj root trans y))) (-> obj root transv y))
          )
    (vector-v++! (-> obj root transv) (-> obj target-acceleration))
    (vector-v++! (-> obj root trans) (-> obj root transv))
    (let* ((v1-14 (-> obj root transv))
           (f30-0 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
           (s5-0 (new 'stack-no-clear 'vehicle-control-point))
           )
      (when (< 40.96 f30-0)
        (vector-float*! (-> s5-0 normal) (-> obj root transv) (/ 1.0 f30-0))
        (quaternion-set!
          (the-as quaternion (-> s5-0 local-pos))
          0.0
          (-> s5-0 normal x)
          0.0
          (+ 1.0 (-> s5-0 normal z))
          )
        (quaternion-normalize! (the-as quaternion (-> s5-0 local-pos)))
        (quaternion-rotate-local-z!
          (the-as quaternion (-> s5-0 local-pos))
          (the-as quaternion (-> s5-0 local-pos))
          (* -0.08886719 (-> obj controls steering) (fmin 81920.0 f30-0))
          )
        (quaternion-smooth-seek!
          (-> obj root quat)
          (-> obj root quat)
          (the-as quaternion (-> s5-0 local-pos))
          (* 0.00014686584 (-> pp clock seconds-per-frame) f30-0)
          )
        )
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-93 vehicle ((obj vehicle))
  (with-pp
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (set! (-> s5-0 vector 2 quad) (-> obj rbody state matrix quad 0))
      (set! (-> s5-0 trans quad) (-> obj rbody state matrix vector 2 quad))
      (let ((f28-0 (* (-> obj rbody state ang-velocity y) (vector-length (-> obj rbody state lin-velocity))))
            (f30-0 (-> pp clock seconds-per-frame))
            )
        (when (zero? (-> obj flight-level-index))
          (if (logtest? (-> obj flags) (rigid-body-object-flag riding))
              (vehicle-method-80 obj)
              )
          )
        (vector-! (-> s5-0 vector 1) (-> obj target-acceleration) (-> obj lin-acceleration))
        (let ((f0-3 (* 0.00006 (vector-dot (-> s5-0 trans) (-> s5-0 vector 1)) f30-0)))
          (set! (-> s5-0 vector 0 y) (fmax 0.0 (fmin 1.0 (* 20.0 f0-3))))
          (set! (-> s5-0 vector 0 z) (fmax 0.0 (fmin 1.0 (* -40.0 f0-3))))
          (if (= obj *debug-actor*)
              (format *stdcon* "delta-throttle ~f~%" f0-3)
              )
          )
        (when (logtest? (-> obj flags) (rigid-body-object-flag player-edge-grabbing))
          (set! (-> s5-0 vector 0 y) 0.0)
          (set! (-> s5-0 vector 0 z) 1.0)
          (logclear! (-> obj flags) (rigid-body-object-flag reverse-gear))
          )
        (let ((f0-7 (* 6.0 f30-0))
              (f4-0 (* 0.00018024445
                       (- (vector-dot (-> s5-0 vector 2) (-> obj target-acceleration)) f28-0)
                       (if (< (-> obj controls throttle) 0.0)
                           -1.0
                           1.0
                           )
                       f30-0
                       )
                    )
              )
          (set! (-> s5-0 vector 0 x)
                (fmax -1.0 (fmin 1.0 (+ (-> obj controls steering) (fmax (fmin f4-0 f0-7) (- f0-7)))))
                )
          )
        )
      (set! (-> s5-0 vector 0 w) 0.0)
      (vehicle-method-95 obj (the-as vector (-> s5-0 vector)))
      (when (= obj *debug-actor*)
        (let ((v1-43 (-> s5-0 vector)))
          (format *stdcon* "steer ~f, throttle ~f, brake ~f~%" (-> v1-43 0 x) (-> v1-43 0 y) (-> v1-43 0 z))
          )
        (let ((v1-45 (-> obj controls)))
          (format *stdcon* "steer ~f, throttle ~f, brake ~f~%" (-> v1-45 steering) (-> v1-45 throttle) (-> v1-45 brake))
          )
        )
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-95 vehicle ((obj vehicle) (arg0 vector))
  (with-pp
    (seek! (-> obj controls steering) (-> arg0 x) (* 8.0 (-> pp clock seconds-per-frame)))
    (seek! (-> obj controls lean-z) (-> arg0 w) (* 8.0 (-> pp clock seconds-per-frame)))
    (logclear! (-> obj flags) (rigid-body-object-flag slide))
    (let ((f0-10 (-> arg0 y))
          (f30-0 (-> arg0 z))
          )
      (set! f30-0
            (cond
              ((< 0.0 f0-10)
               (logclear! (-> obj flags) (rigid-body-object-flag reverse-gear))
               (when (< 0.0 f30-0)
                 (set! f30-0 0.25)
                 (logior! (-> obj flags) (rigid-body-object-flag slide))
                 )
               f30-0
               )
              ((< 0.0 f30-0)
               (cond
                 ((logtest? (rigid-body-object-flag reverse-gear) (-> obj flags))
                  (let ((f0-11 -0.5)
                        (f1-5 0.0)
                        (f2-0 -40960.0)
                        )
                    (set! f0-10
                          (fmax
                            f0-11
                            (fmin
                              f1-5
                              (* (/ 1.0 f2-0)
                                 f30-0
                                 (- 8192.0 (vector-dot (-> obj rbody state lin-velocity) (-> obj rbody state matrix vector 2)))
                                 )
                              )
                            )
                          )
                    )
                  0.0
                  )
                 (else
                   (let* ((v1-25 (-> obj rbody state lin-velocity))
                          (f1-10 (+ (* (-> v1-25 x) (-> v1-25 x)) (* (-> v1-25 z) (-> v1-25 z))))
                          (f2-8 8192.0)
                          )
                     (if (< f1-10 (* f2-8 f2-8))
                         (logior! (-> obj flags) (rigid-body-object-flag reverse-gear))
                         )
                     )
                   f30-0
                   )
                 )
               )
              (else
                (logclear! (-> obj flags) (rigid-body-object-flag reverse-gear))
                f30-0
                )
              )
            )
      (seek! (-> obj controls throttle) f0-10 (* 4.0 (-> pp clock seconds-per-frame)))
      (+! (-> obj controls brake)
          (* (- f30-0 (-> obj controls brake)) (fmin 1.0 (* 8.0 (-> pp clock seconds-per-frame))))
          )
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-94 vehicle ((obj vehicle))
  (cond
    ((or (logtest? (rigid-body-object-flag player-grabbed) (-> obj flags))
         (and *target* (focus-test? *target* dead grabbed))
         )
     (let ((v1-7 (new 'stack-no-clear 'vector)))
       (set! (-> v1-7 x) 0.0)
       (set! (-> v1-7 w) 0.0)
       (set! (-> v1-7 y) 0.0)
       (set! (-> v1-7 z) (if (logtest? (-> obj flags) (rigid-body-object-flag in-air))
                             0.0
                             1.0
                             )
             )
       (logclear! (-> obj flags) (rigid-body-object-flag reverse-gear))
       (vehicle-method-95 obj (the-as vector (&-> v1-7 x)))
       )
     )
    ((and (zero? (-> obj crash-level))
          (not (logtest? (rigid-body-object-flag ai-driving measure-control-parameters) (-> obj flags)))
          )
     (when (and (cpad-pressed? 0 r2) (not *pause-lock*))
       (if (zero? (-> obj flight-level-index))
           (vehicle-method-80 obj)
           (vehicle-method-81 obj)
           )
       )
     (let ((s5-0 (new 'stack-no-clear 'vector)))
       (set! (-> s5-0 x) (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0))
       (set! (-> s5-0 w) (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 48.0 110.0 -1.0))
       (set! (-> s5-0 y) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 6)))))
       (set! (-> s5-0 z) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 7)))))
       (vehicle-method-95 obj (the-as vector (&-> s5-0 x)))
       )
     (if (or (cpad-hold? 0 l1) (and (logtest? (-> obj info flags) 512) (cpad-hold? 0 r1)))
         (start-jump obj)
         )
     (if (cpad-pressed? 0 circle)
         (vehicle-method-66 obj)
         )
     )
    )
  0
  (none)
  )

(defmethod vehicle-method-96 vehicle ((obj vehicle))
  (with-pp
    (when (and *target* (logtest? (rigid-body-object-flag ignition) (-> obj flags)))
      (when (and (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
                 (zero? (-> obj root num-riders))
                 (or (not *target*) (or (< 32768.0 (vector-vector-distance (-> obj root trans) (-> *target* control trans)))
                                        (focus-test? *target* teleporting)
                                        )
                     )
                 )
        (set! (-> obj controls throttle) 0.0)
        (set! (-> obj controls steering) 0.0)
        (set! (-> obj controls lean-z) 0.0)
        (mem-copy! (the-as pointer (-> obj prev-controls)) (the-as pointer (-> obj controls)) 16)
        )
      )
    (cond
      ((zero? (-> obj crash-level))
       (seek! (-> obj force-scale) 1.0 (-> pp clock seconds-per-frame))
       )
      ((< (-> obj crash-level) 3)
       (when (>= (- (current-time) (-> obj crash-time)) (the-as time-frame (-> obj crash-duration)))
         (if (or (>= (-> obj rbody state matrix vector 1 y) (cos 18204.445))
                 (>= (- (current-time) (-> obj crash-time)) (seconds 3))
                 )
             (vehicle-method-77 obj)
             )
         )
       )
      )
    (set! (-> obj force-level) (-> obj crash-level))
    (cond
      ((>= (-> obj hit-points) 0.9)
       (set! (-> obj power-fluctuation-factor) 0.01)
       )
      ((>= (-> obj hit-points) 0.75)
       (set! (-> obj power-fluctuation-factor) 0.02)
       )
      ((>= (-> obj hit-points) 0.5)
       (set! (-> obj power-fluctuation-factor) 0.04)
       )
      ((>= (-> obj hit-points) 0.3)
       (set! (-> obj power-fluctuation-factor) 0.08)
       )
      ((>= (-> obj hit-points) 0.15)
       (set! (-> obj power-fluctuation-factor) 0.16)
       )
      ((>= (-> obj hit-points) 0.05)
       (set! (-> obj power-fluctuation-factor) 0.32)
       )
      (else
        (set! (-> obj power-fluctuation-factor) 0.7)
        )
      )
    (let ((f1-6 0.0))
      (when (logtest? (rigid-body-object-flag ignition) (-> obj flags))
        (let ((f0-23 (- 1.0 (* (rand-vu) (-> obj power-fluctuation-factor)))))
          (set! f1-6 (* f0-23 f0-23))
          )
        (if (not (logtest? (-> obj flags) (rigid-body-object-flag riding)))
            (set! f1-6 (* 0.5 f1-6))
            )
        )
      (+! (-> obj power-level)
          (* (- f1-6 (-> obj power-level))
             (fmin 1.0 (* (+ 1.0 (* 50.0 (-> obj power-fluctuation-factor))) (-> pp clock seconds-per-frame)))
             )
          )
      )
    (when (logtest? (rigid-body-object-flag turbo-boost) (-> obj flags))
      (if (or (>= (- (current-time) (-> obj turbo-boost-time)) (the-as time-frame (-> obj turbo-boost-duration)))
              (and (>= (- (current-time) (-> obj turbo-boost-time)) (seconds 0.1)) (>= (-> obj controls brake) 0.75))
              )
          (logclear! (-> obj flags) (rigid-body-object-flag turbo-boost))
          )
      )
    (cond
      ((logtest? (rigid-body-object-flag ignition) (-> obj flags))
       (-> obj controls throttle)
       (let* ((f1-13
                (fmax
                  0.0
                  (fmin 1.0 (/ (* (vector-length (-> obj rbody state lin-velocity)) (-> obj info engine-intake-factor))
                               (-> obj info max-xz-speed)
                               )
                        )
                  )
                )
              (f1-16 (fmin (-> obj controls throttle) (* 0.83333 (+ 0.5 f1-13))))
              )
         0
         (if (logtest? (rigid-body-object-flag turbo-boost) (-> obj flags))
             (set! f1-16 (+ 1.0 (* (-> obj turbo-boost-factor) (-> obj info turbo-boost-factor))))
             )
         (if (< (-> obj engine-thrust) f1-16)
             (+! (-> obj engine-thrust)
                 (* (- f1-16 (-> obj engine-thrust))
                    (fmin 1.0 (* (-> obj info engine-response-rate) (-> pp clock seconds-per-frame)))
                    )
                 )
             (seek! (-> obj engine-thrust) f1-16 (-> pp clock seconds-per-frame))
             )
         )
       )
      (else
        (set! (-> obj engine-thrust) 0.0)
        )
      )
    (set! (-> obj engine-power-factor) (fabs (-> obj engine-thrust)))
    (if (and (logtest? (rigid-body-object-flag jump) (-> obj flags)) (< 0.0 (-> obj jump-time)))
        (set! (-> obj jump-thrust) 1.0)
        (set! (-> obj jump-thrust) 0.0)
        )
    (cond
      ((logtest? (rigid-body-object-flag jump) (-> obj flags))
       (seek! (-> obj jump-time) 0.0 (-> pp clock seconds-per-frame))
       )
      ((not (logtest? (-> obj flags) (rigid-body-object-flag in-air)))
       (if (< 0.0 (-> obj jump-time))
           (logclear! (-> obj flags) (rigid-body-object-flag jump-sound))
           )
       (seek! (-> obj jump-time) 0.1 (* 0.5 (-> pp clock seconds-per-frame)))
       )
      )
    (when (and (logtest? (rigid-body-object-flag jump) (-> obj flags))
               (not (logtest? (-> obj flags) (rigid-body-object-flag in-air)))
               (logtest? (-> obj vehicle-jkhn1b23jn1) 1024)
               )
      (logior! (-> obj flags) (rigid-body-object-flag hard-turn))
      (set! (-> obj turn-time) (current-time))
      )
    (if (or (not (logtest? (rigid-body-object-flag jump) (-> obj flags)))
            (>= (- (current-time) (-> obj turn-time)) (seconds 1))
            )
        (logclear! (-> obj flags) (rigid-body-object-flag hard-turn))
        )
    (if (logtest? (-> obj flags) (rigid-body-object-flag on-ground on-flight-level))
        (set! (-> obj air-time) (current-time))
        )
    (when (logtest? (rigid-body-object-flag flight-level-transition) (-> obj flags))
      (if (or (and (> (-> obj flight-level-index) 0)
                   (< (fabs (- (-> obj flight-level) (-> obj rbody state position y))) 8192.0)
                   (< (fabs (-> obj rbody state lin-velocity y)) 8192.0)
                   )
              (and (zero? (-> obj flight-level-index)) (logtest? (-> obj flags) (rigid-body-object-flag on-ground)))
              )
          (vehicle-method-79 obj)
          )
      (when (and (> (-> obj flight-level-index) 0) (>= (- (current-time) (-> obj transition-time)) (seconds 2)))
        (vehicle-method-79 obj)
        (vehicle-method-83 obj)
        )
      )
    (when (and (logtest? (rigid-body-object-flag flight-level-transition-ending) (-> obj flags))
               (>= (- (current-time) (-> obj transition-end-time)) (seconds 1))
               )
      (logclear! (-> obj flags) (rigid-body-object-flag flight-level-transition-ending))
      (vehicle-method-92 obj)
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-97 vehicle ((obj vehicle))
  (local-vars (v1-88 float) (v1-98 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (when (logtest? (rigid-body-object-flag camera) (-> obj flags))
        (let ((f0-0 -4096000.0))
          (dotimes (v1-4 (-> *level* length))
            (let ((a0-5 (-> *level* level v1-4)))
              (when (= (-> a0-5 status) 'active)
                (let ((a0-7 (-> a0-5 bsp city-level-info)))
                  (when (nonzero? a0-7)
                    (let ((f1-0 (the-as float (-> a0-7 camera-ceiling))))
                      (if (= (the-as meters f1-0) 0.0)
                          (set! f1-0 40960000.0)
                          )
                      (set! f0-0 (fmax f0-0 f1-0))
                      )
                    )
                  )
                )
              )
            )
          (set-setting! 'string-camera-ceiling 'abs f0-0 0)
          )
        (cond
          ((logtest? (-> obj flags) (rigid-body-object-flag in-air))
           (when (or (< 55296.0 (-> obj rbody state lin-velocity y)) (>= (- (current-time) (-> obj air-time)) (seconds 0.75)))
             (set-setting! 'extra-follow-height 'abs (meters -4) 0)
             (send-event *camera* 'set-max-angle-offset (-> obj info camera-air-max-angle-offset))
             )
           )
          (else
            (remove-setting! 'extra-follow-height)
            (send-event *camera* 'set-max-angle-offset (-> obj info camera-normal-max-angle-offset))
            )
          )
        (let ((f0-5 (vector-dot (-> obj rbody state lin-velocity) (-> obj rbody state matrix vector 2))))
          (cond
            ((= (-> obj crash-level) 2)
             (vehicle-method-90 obj)
             )
            ((< f0-5 (-> obj info camera-max-lookaround-speed))
             (vehicle-method-90 obj)
             )
            ((< (+ 4096.0 (-> obj info camera-max-lookaround-speed)) f0-5)
             (vehicle-method-89 obj)
             )
            )
          )
        (when (not (logtest? (rigid-body-object-flag flight-level-transition) (-> obj flags)))
          (let* ((f0-6 1.0)
                 (v1-57 (-> obj rbody state lin-velocity))
                 (f0-7
                   (fmin
                     f0-6
                     (/ (sqrtf (+ (* (-> v1-57 x) (-> v1-57 x)) (* (-> v1-57 z) (-> v1-57 z)))) (-> obj info max-xz-speed))
                     )
                   )
                 )
            (seek! (-> obj cam-speed-interp) f0-7 (* 0.1 (-> pp clock seconds-per-frame)))
            )
          (let ((f30-0 (-> obj cam-speed-interp)))
            (if #f
                (set! f30-0
                      (fmax 0.0 (fmin 1.0 (analog-input (the-as int (-> *cpad-list* cpads 1 righty)) 128.0 48.0 110.0 -1.0)))
                      )
                )
            (let ((f0-15 (lerp-scale (-> obj info camera-min-fov) (-> obj info camera-max-fov) f30-0 0.0 1.0)))
              (set-setting! 'fov 'abs f0-15 0)
              )
            (let ((f30-2 (lerp-scale 1.0 0.6 f30-0 0.0 1.0)))
              (set-setting! 'string-min-length 'abs (* f30-2 (-> obj info camera-string-min-length)) 0)
              (set-setting! 'string-max-length 'abs (* f30-2 (-> obj info camera-string-max-length)) 0)
              )
            )
          )
        (when *target*
          (let ((v1-83 (-> *target* draw shadow-ctrl settings shadow-dir quad)))
            (set! (-> obj draw shadow-ctrl settings shadow-dir quad) v1-83)
            )
          (cond
            ((logtest? (rigid-body-object-flag camera-rapid-track-mode) (-> obj flags))
             (.lvf vf1 (&-> (-> obj root transv) quad))
             (.add.w.vf vf2 vf0 vf0 :mask #b1)
             (.mul.vf vf1 vf1 vf1)
             (.mul.x.vf acc vf2 vf1 :mask #b1)
             (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
             (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
             (.mov v1-88 vf1)
             (let ((f0-20 v1-88)
                   (f1-13 122880.0)
                   )
               (if (< f0-20 (* f1-13 f1-13))
                   (vehicle-method-92 obj)
                   )
               )
             )
            (else
              (let* ((f0-21 143360.0)
                     (f0-23 (* f0-21 f0-21))
                     )
                (.lvf vf1 (&-> (-> obj root transv) quad))
                (.add.w.vf vf2 vf0 vf0 :mask #b1)
                (.mul.vf vf1 vf1 vf1)
                (.mul.x.vf acc vf2 vf1 :mask #b1)
                (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                (.mov v1-98 vf1)
                (if (< f0-23 v1-98)
                    (vehicle-method-91 obj)
                    )
                )
              )
            )
          (let ((v1-102 (math-camera-matrix))
                (a0-39 (new 'stack-no-clear 'vehicle-control-point))
                )
            (set! (-> a0-39 normal quad) (-> *target* alt-cam-pos quad))
            (vector-! (-> a0-39 local-pos) (-> a0-39 normal) (-> v1-102 trans))
            (let ((f0-26 (/ (vector-dot (-> a0-39 local-pos) (-> v1-102 vector 1))
                            (vector-dot (-> a0-39 local-pos) (-> v1-102 vector 2))
                            )
                         )
                  )
              (cond
                ((and (< f0-26 0.15) (< -0.5 f0-26))
                 (set-setting! 'vertical-follow-matches-camera #f 0.0 0)
                 )
                (else
                  (if (< (fabs (-> obj root transv y)) 8192.0)
                      (remove-setting! 'vertical-follow-matches-camera)
                      )
                  )
                )
              )
            )
          )
        0
        )
      0
      (none)
      )
    )
  )

(defmethod vehicle-method-120 vehicle ((obj vehicle))
  (with-pp
    (let ((s5-0 (-> obj draw shadow-ctrl)))
      (when (!= *vehicle-shadow-control-disabled* s5-0)
        (let ((f30-0 (vector-vector-xz-distance (camera-pos) (-> obj root trans))))
          (cond
            ((< 245760.0 f30-0)
             (logior! (-> s5-0 settings flags) (shadow-flags disable-draw))
             0
             (set! (-> obj draw bounds w) (-> obj bound-radius))
             )
            (else
              (let ((s4-1 (-> obj root)))
                (when (or (logtest? (-> s5-0 settings flags) (shadow-flags disable-draw))
                          (= (-> obj controller traffic sync-mask-8) (ash 1 (logand (-> obj traffic-priority-id) 7)))
                          )
                  (let ((s3-0 (new 'stack-no-clear 'collide-query)))
                    (logclear! (-> s4-1 status) (collide-status on-ground))
                    (cond
                      ((above-ground? s4-1 s3-0 (-> s4-1 trans) (collide-spec backgnd) 0.0 102400.0 1024.0)
                       (set! (-> s4-1 gspot-pos quad) (-> s4-1 trans quad))
                       (set! (-> s4-1 gspot-pos y) (-> s3-0 best-other-tri intersect y))
                       (set! (-> s4-1 gspot-normal quad) (-> s3-0 best-other-tri normal quad))
                       (set! (-> s4-1 ground-pat) (-> s3-0 best-other-tri pat))
                       (when (logtest? (-> s5-0 settings flags) (shadow-flags disable-draw))
                         (set! (-> s5-0 settings top-plane w) (- (-> s5-0 settings center y) (-> obj root gspot-pos y)))
                         (set! (-> s5-0 settings bot-plane w) (- (-> s5-0 settings center y) (-> obj root gspot-pos y)))
                         )
                       (let ((v1-29 s5-0))
                         (logclear! (-> v1-29 settings flags) (shadow-flags disable-draw))
                         )
                       0
                       )
                      (else
                        (let ((v1-31 s5-0))
                          (logior! (-> v1-31 settings flags) (shadow-flags disable-draw))
                          )
                        0
                        )
                      )
                    )
                  )
                )
              (set! (-> obj draw bounds w) (lerp-scale
                                             (- (-> s5-0 settings center y) (-> obj root gspot-pos y))
                                             (-> obj bound-radius)
                                             f30-0
                                             81920.0
                                             122880.0
                                             )
                    )
              (if (< (-> obj draw bounds w) (-> obj bound-radius))
                  (set! (-> obj draw bounds w) (-> obj bound-radius))
                  )
              (let* ((f0-13 (lerp-scale 0.0 1.0 f30-0 245760.0 40960.0))
                     (f30-1 (* 4096.0 (+ 5.0 (* 5.0 (- 1.0 (-> obj root gspot-normal y))))))
                     (f28-0 (- (-> s5-0 settings center y) (-> obj root gspot-pos y)))
                     (f0-16 (fmax 0.01 (+ (* -2.0 f0-13 f0-13 f0-13) (* 3.0 f0-13 f0-13))))
                     )
                (set! (-> s5-0 settings shadow-dir w) (+ 20480.0 (* 409600.0 f0-16) f28-0))
                (let ((f26-0 (+ 0.5 f0-16)))
                  (seek!
                    (-> s5-0 settings top-plane w)
                    (+ f28-0 (* f26-0 (- f30-1)))
                    (* 81920.0 (-> pp clock seconds-per-frame))
                    )
                  (seek! (-> s5-0 settings bot-plane w) (+ f28-0 (* f26-0 f30-1)) (* 81920.0 (-> pp clock seconds-per-frame)))
                  )
                )
              )
            )
          )
        )
      )
    (set! (-> obj vehicle-jkhn1b23jn1) (the-as int (-> obj flags)))
    (ja-post)
    0
    (none)
    )
  )

(defmethod rigid-body-object-method-51 vehicle ((obj vehicle))
  (with-pp
    (let ((s5-0 (new 'stack-no-clear 'collide-query)))
      (let ((f30-0 -4096000.0))
        (set! (-> s5-0 start-pos quad) (-> obj rbody state position quad))
        (vector-float*! (-> s5-0 move-dist) (-> obj rbody state lin-velocity) (-> pp clock seconds-per-frame))
        (let ((v1-4 s5-0))
          (set! (-> v1-4 radius) (+ 4096.0 (-> obj root root-prim local-sphere w)))
          (set! (-> v1-4 collide-with) (collide-spec
                                         backgnd
                                         crate
                                         civilian
                                         enemy
                                         obstacle
                                         vehicle-sphere
                                         hit-by-player-list
                                         hit-by-others-list
                                         collectable
                                         blocking-plane
                                         pusher
                                         vehicle-mesh-probeable
                                         )
                )
          (set! (-> v1-4 ignore-process0) obj)
          (set! (-> v1-4 ignore-process1) #f)
          (set! (-> v1-4 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1))
          (set! (-> v1-4 action-mask) (collide-action solid))
          )
        (if (focus-test? obj dead)
            (set! (-> s5-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
            )
        (if (logtest? (-> obj flags) (rigid-body-object-flag player-touching))
            (logclear! (-> s5-0 collide-with) (collide-spec jak player-list))
            )
        (let ((s4-0 (new 'stack-no-clear 'water-info)))
          (water-info-init! (-> obj root) s4-0 (collide-action solid semi-solid))
          (if (and (logtest? (-> s4-0 flags) (water-flags active)) (logtest? (water-flags over-water) (-> s4-0 flags)))
              (set! f30-0 (-> s4-0 base-height))
              )
          )
        (set! (-> obj water-height) f30-0)
        (when (< (- (+ (-> s5-0 start-pos y) (fmin 0.0 (-> s5-0 move-dist y))) (-> s5-0 radius)) f30-0)
          (let ((v1-23
                  (new 'static 'water-control :flags (water-flags active swim-ground can-ground over-water) :joint-index 3)
                  )
                )
            (logior! (-> s5-0 collide-with) (collide-spec water))
            (set! (-> v1-23 height) f30-0)
            (set! (-> v1-23 collide-height) f30-0)
            (set! (-> obj water) v1-23)
            )
          )
        )
      (fill-using-line-sphere *collide-cache* s5-0)
      )
    (set! (-> obj water) (the-as water-control 0))
    0
    (rigid-body-control-method-10 (-> obj rbody) obj (-> obj rbody state time-remaining) (-> obj max-time-step))
    0
    (none)
    )
  )

(defmethod rigid-body-object-method-52 vehicle ((obj vehicle))
  (with-pp
    (let ((v1-0 (new 'stack-no-clear 'vehicle-control-point)))
      (set! (-> v1-0 local-pos quad) (-> obj root transv quad))
      (vector-! (-> v1-0 normal) (-> obj rbody state lin-velocity) (-> v1-0 local-pos))
      (vector-float*! (-> obj lin-acceleration) (-> v1-0 normal) (-> pp clock frames-per-second))
      )
    (set! (-> obj root transv quad) (-> obj rbody state lin-velocity quad))
    (quaternion-copy! (-> obj root quat) (-> obj rbody state rotation))
    (let ((v1-6 (-> obj rbody))
          (a1-7 (-> obj root trans))
          )
      (rigid-body-method-23 (-> v1-6 state) a1-7)
      )
    (let* ((v1-11 (-> obj node-list data 0 bone transform))
           (a3-0 (-> obj rbody state matrix))
           (a0-13 (-> a3-0 quad 0))
           (a1-8 (-> a3-0 quad 1))
           (a2-1 (-> a3-0 quad 2))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-11 quad 0) a0-13)
      (set! (-> v1-11 quad 1) a1-8)
      (set! (-> v1-11 quad 2) a2-1)
      (set! (-> v1-11 trans quad) a3-1)
      )
    (set! (-> obj node-list data 0 bone transform trans quad) (-> obj root trans quad))
    (vehicle-method-119 obj)
    (let ((f0-1 (-> obj player-dist2))
          (f1-0 245760.0)
          )
      (if (< f0-1 (* f1-0 f1-0))
          (do-engine-sounds obj)
          )
      )
    (when (logtest? (-> obj draw status) (draw-control-status on-screen))
      (if #t
          (draw-thrusters obj)
          )
      (let ((f0-2 (-> obj camera-dist2))
            (f1-3 245760.0)
            )
        (if (< f0-2 (* f1-3 f1-3))
            (update-joint-mods obj)
            )
        )
      )
    (vehicle-method-120 obj)
    (let ((s5-0 (-> obj root)))
      (update-transforms s5-0)
      (when (and (logtest? (-> obj flags) (rigid-body-object-flag player-touching))
                 (not (logtest? (-> obj flags) (rigid-body-object-flag player-driving)))
                 )
        (pull-riders! s5-0)
        (cond
          ((logtest? (do-push-aways s5-0) (collide-spec jak))
           (+! (-> obj overlap-player-counter) 1)
           (when (< (the-as uint 60) (-> obj overlap-player-counter))
             (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
               (set! (-> a1-9 from) (process->ppointer pp))
               (set! (-> a1-9 num-params) 2)
               (set! (-> a1-9 message) 'attack-invinc)
               (set! (-> a1-9 param 0) (the-as uint #f))
               (let ((v1-56 (new 'static 'attack-info :mask (attack-info-mask mode id damage))))
                 (let* ((a0-29 *game-info*)
                        (a2-3 (+ (-> a0-29 attack-id) 1))
                        )
                   (set! (-> a0-29 attack-id) a2-3)
                   (set! (-> v1-56 id) a2-3)
                   )
                 (set! (-> v1-56 mode) 'smush)
                 (set! (-> v1-56 damage) 1000.0)
                 (set! (-> a1-9 param 1) (the-as uint v1-56))
                 )
               (send-event-function *target* a1-9)
               )
             (set! (-> obj overlap-player-counter) (the-as uint 0))
             0
             )
           )
          (else
            (set! (-> obj overlap-player-counter) (the-as uint 0))
            0
            )
          )
        )
      )
    (if (and (logtest? (-> obj flags) (rigid-body-object-flag dead))
             (not (logtest? (-> obj focus-status) (focus-status dead)))
             )
        (go (method-of-object obj crash))
        )
    (if (logtest? (rigid-body-object-flag nav-spheres) (-> obj flags))
        (vehicle-method-143 obj)
        )
    (seek! (-> obj scrape-sound-envelope) 0.0 (* 2.0 (-> pp clock seconds-per-frame)))
    (mem-copy! (the-as pointer (-> obj prev-controls)) (the-as pointer (-> obj controls)) 16)
    (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force jump))
    0
    (none)
    )
  )

(defmethod vehicle-method-121 vehicle ((obj vehicle))
  (if (>= (- (current-time) (-> obj player-touch-time)) (seconds 0.1))
      (logclear! (-> obj flags) (rigid-body-object-flag player-touching player-edge-grabbing player-standing-on))
      )
  (when (logtest? (-> obj flags) (rigid-body-object-flag player-touching))
    (detect-riders! (-> obj root))
    0
    )
  (if (logtest? (-> obj flags) (rigid-body-object-flag player-touching player-driving))
      (logior! (-> obj skel status) (joint-control-status sync-math))
      (logclear! (-> obj skel status) (joint-control-status sync-math))
      )
  (vehicle-method-96 obj)
  (let ((a1-0 (-> obj rbody state position)))
    (set! (-> obj flight-level) (get-height-at-point *traffic-height-map* a1-0))
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-37 vehicle ((obj vehicle))
  (local-vars (a0-14 int) (a0-16 int) (a0-19 int) (a0-21 int))
  (let* ((v1-1 (-> *perf-stats* data 37))
         (a0-1 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-1) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-1)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (set! (-> obj camera-dist2) (vector-vector-distance-squared (-> obj root trans) (camera-pos)))
  (set! (-> obj player-dist2) (vector-vector-distance-squared (-> obj root trans) (target-pos 0)))
  (cond
    ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
     (if (not (vehicle-method-105 obj))
         (rigid-body-object-method-39 obj)
         )
     )
    (else
      (if (vehicle-method-105 obj)
          (rigid-body-object-method-38 obj)
          )
      )
    )
  (cond
    ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
     (vehicle-method-121 obj)
     (vehicle-method-106 obj)
     )
    (else
      (let* ((v1-26 (-> *perf-stats* data 20))
             (a0-11 (-> v1-26 ctrl))
             )
        (+! (-> v1-26 count) 1)
        (b! (zero? a0-11) cfg-12 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-11)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-12)
      0
      (vehicle-method-120 obj)
      (let ((v1-31 (-> *perf-stats* data 20)))
        (b! (zero? (-> v1-31 ctrl)) cfg-14 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-14 pcr0)
        (+! (-> v1-31 accum0) a0-14)
        (.mfpc a0-16 pcr1)
        (+! (-> v1-31 accum1) a0-16)
        )
      (label cfg-14)
      0
      )
    )
  (let ((v1-34 (-> *perf-stats* data 37)))
    (b! (zero? (-> v1-34 ctrl)) cfg-17 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-19 pcr0)
    (+! (-> v1-34 accum0) a0-19)
    (.mfpc a0-21 pcr1)
    (+! (-> v1-34 accum1) a0-21)
    )
  (label cfg-17)
  0
  0
  (none)
  )

(defmethod vehicle-method-123 vehicle ((obj vehicle))
  (local-vars (v1-4 symbol) (a0-21 int) (a0-23 int))
  (set! (-> obj camera-dist2) (vector-vector-distance-squared (-> obj root trans) (camera-pos)))
  (set! (-> obj player-dist2) (vector-vector-distance-squared (-> obj root trans) (target-pos 0)))
  (b!
    (not (logtest? (rigid-body-object-flag traffic-managed) (-> obj flags)))
    cfg-3
    :likely-delay (set! v1-4 #f)
    )
  (set! v1-4 (not (logtest? (-> obj flags) (rigid-body-object-flag persistent))))
  (label cfg-3)
  (b! (not v1-4) cfg-20 :delay (empty-form))
  (let ((f0-3 (fmin (-> obj player-dist2) (-> obj camera-dist2))))
    (let ((f1-1 819200.0))
      (b! (>= (* f1-1 f1-1) f0-3) cfg-8)
      )
    (let ((f1-4 819200.0))
      (if (< (* f1-4 f1-4) f0-3)
          (vehicle-method-113 obj)
          )
      )
    (b! #t cfg-19 :delay (nop!))
    (label cfg-8)
    (let ((f1-7 81920.0))
      (b! (>= (* f1-7 f1-7) f0-3) cfg-18)
      )
    (b! (not (logtest? (-> obj draw status) (draw-control-status on-screen))) cfg-11 :delay (nop!))
    (set! (-> obj state-time) (current-time))
    (b! #t cfg-17 :delay (nop!))
    (label cfg-11)
    (if (or (>= (- (current-time) (-> obj state-time)) (seconds 10)) (let ((f1-10 409600.0))
                                                                       (< (* f1-10 f1-10) f0-3)
                                                                       )
            )
        (vehicle-method-113 obj)
        )
    )
  (label cfg-17)
  (b! #t cfg-19 :delay (nop!))
  (label cfg-18)
  (set! (-> obj state-time) (current-time))
  (label cfg-19)
  0
  (label cfg-20)
  (check-player-get-on obj)
  (b! (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))) cfg-24 :delay (nop!))
  (if (not (vehicle-method-105 obj))
      (rigid-body-object-method-39 obj)
      )
  (b! #t cfg-26 :delay (nop!))
  (label cfg-24)
  (if (vehicle-method-105 obj)
      (rigid-body-object-method-38 obj)
      )
  (label cfg-26)
  (b! (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))) cfg-31 :delay (nop!))
  (vector-reset! (-> obj target-acceleration))
  (when (logtest? (-> obj flags) (rigid-body-object-flag disturbed))
    (if (logtest? (-> obj flags) (rigid-body-object-flag in-air))
        (set! (-> obj disturbed-time) (current-time))
        )
    )
  (vehicle-method-121 obj)
  (vehicle-method-106 obj)
  (b! #t cfg-36 :delay (nop!))
  (label cfg-31)
  (let* ((v1-65 (-> *perf-stats* data 20))
         (a0-18 (-> v1-65 ctrl))
         )
    (+! (-> v1-65 count) 1)
    (b! (zero? a0-18) cfg-33 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-18)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-33)
  0
  (vehicle-method-120 obj)
  (let ((v1-70 (-> *perf-stats* data 20)))
    (b! (zero? (-> v1-70 ctrl)) cfg-35 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-21 pcr0)
    (+! (-> v1-70 accum0) a0-21)
    (.mfpc a0-23 pcr1)
    (+! (-> v1-70 accum1) a0-23)
    )
  (label cfg-35)
  0
  (label cfg-36)
  0
  (none)
  )

(defmethod vehicle-method-122 vehicle ((obj vehicle))
  (local-vars (a0-23 int) (a0-25 int) (a0-35 int) (a0-37 int) (a0-40 int) (a0-42 int))
  (with-pp
    (let* ((v1-1 (-> *perf-stats* data 37))
           (a0-1 (-> v1-1 ctrl))
           )
      (+! (-> v1-1 count) 1)
      (b! (zero? a0-1) cfg-2 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mtpc pcr0 0)
      (.mtpc pcr1 0)
      (.sync.l)
      (.sync.p)
      (.mtc0 Perf a0-1)
      )
    (.sync.l)
    (.sync.p)
    (label cfg-2)
    0
    (set! (-> obj camera-dist2) (vector-vector-distance-squared (-> obj root trans) (camera-pos)))
    (set! (-> obj player-dist2) (vector-vector-distance-squared (-> obj root trans) (target-pos 0)))
    (vehicle-controller-method-18
      (-> obj controller)
      (-> obj target-acceleration)
      (-> obj root transv)
      obj
      (/ 1.0 (-> pp clock seconds-per-frame))
      )
    (cond
      ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
       (if (not (vehicle-method-105 obj))
           (rigid-body-object-method-39 obj)
           )
       )
      (else
        (if (vehicle-method-105 obj)
            (rigid-body-object-method-38 obj)
            )
        )
      )
    (cond
      ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
       (vehicle-method-93 obj)
       (vehicle-method-106 obj)
       (vehicle-method-121 obj)
       )
      (else
        (let ((f1-3 (* 0.000024414063
                       (vector-dot (the-as vector (-> obj node-list data 0 bone transform)) (-> obj target-acceleration))
                       )
                    )
              )
          (+! (-> obj controls steering) (* 0.1 (- f1-3 (-> obj controls steering))))
          )
        (set! (-> obj controls steering) (fmax -1.0 (fmin 1.0 (-> obj controls steering))))
        (let* ((v1-42 (-> *perf-stats* data 19))
               (a0-14 (-> v1-42 ctrl))
               )
          (+! (-> v1-42 count) 1)
          (b! (zero? a0-14) cfg-12 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mtpc pcr0 0)
          (.mtpc pcr1 0)
          (.sync.l)
          (.sync.p)
          (.mtc0 Perf a0-14)
          )
        (.sync.l)
        (.sync.p)
        (label cfg-12)
        0
        (vehicle-method-104 obj)
        (let ((f0-9 (-> obj player-dist2))
              (f1-8 245760.0)
              )
          (when (< f0-9 (* f1-8 f1-8))
            (let ((f0-10 (vector-length (-> obj root transv))))
              (seek! (-> obj engine-power-factor) (* 0.000016276043 f0-10) (* 6.0 (-> pp clock seconds-per-frame)))
              )
            (do-engine-sounds obj)
            )
          )
        (when (logtest? (-> obj draw status) (draw-control-status on-screen))
          (when #t
            (set! (-> obj node-list data 0 bone transform trans quad) (-> obj root trans quad))
            (draw-thrusters obj)
            )
          )
        (let ((v1-70 (-> *perf-stats* data 19)))
          (b! (zero? (-> v1-70 ctrl)) cfg-19 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mfpc a0-23 pcr0)
          (+! (-> v1-70 accum0) a0-23)
          (.mfpc a0-25 pcr1)
          (+! (-> v1-70 accum1) a0-25)
          )
        (label cfg-19)
        0
        (let* ((v1-73 (-> *perf-stats* data 20))
               (a0-27 (-> v1-73 ctrl))
               )
          (+! (-> v1-73 count) 1)
          (b! (zero? a0-27) cfg-21 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mtpc pcr0 0)
          (.mtpc pcr1 0)
          (.sync.l)
          (.sync.p)
          (.mtc0 Perf a0-27)
          )
        (.sync.l)
        (.sync.p)
        (label cfg-21)
        0
        (vehicle-method-120 obj)
        (update-transforms (-> obj root))
        (set! (-> obj node-list data 0 bone transform trans quad) (-> obj root trans quad))
        (vehicle-method-119 obj)
        (let ((v1-85 (-> *perf-stats* data 20)))
          (b! (zero? (-> v1-85 ctrl)) cfg-23 :delay (nop!))
          (.mtc0 Perf 0)
          (.sync.l)
          (.sync.p)
          (.mfpc a0-35 pcr0)
          (+! (-> v1-85 accum0) a0-35)
          (.mfpc a0-37 pcr1)
          (+! (-> v1-85 accum1) a0-37)
          )
        (label cfg-23)
        0
        )
      )
    (let ((v1-88 (-> *perf-stats* data 37)))
      (b! (zero? (-> v1-88 ctrl)) cfg-26 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mfpc a0-40 pcr0)
      (+! (-> v1-88 accum0) a0-40)
      (.mfpc a0-42 pcr1)
      (+! (-> v1-88 accum1) a0-42)
      )
    (label cfg-26)
    0
    0
    (none)
    )
  )

(defmethod vehicle-method-124 vehicle ((obj vehicle))
  (#when PC_PORT
    ;; vehicle hp display cheat
    (when (pc-cheats? (-> *pc-settings* cheats) vehicle-health-bars)
        (when (and *target* (focus-test? *target* pilot) (nonzero? (-> *target* pilot)))
          (when (= (handle->process (-> *target* pilot vehicle)) obj)
            (let ((x 0) (y 0)
                  (w 0) (h 0)
                  (screen-pos (new 'static 'vector4w)))

            ;; convert 3D -> 2D screen now (store result in screen-pos)
            (when (transform-point-qword! screen-pos (-> *target* root trans))

              ;; set params
              (set! w (the int (* 52.0 (-> *video-params* relative-x-scale))))
              (set! h (the int 10.0))
              (set! x (- (+ (/ (-> screen-pos x) 16) -1792) (/ w 2)))
              (set! y (+ (+ (/ (-> screen-pos y) 16) -1855) 20))
              
              (draw-health-bar x y w h (-> obj hit-points) (bucket-id debug-no-zbuf1))
              )))
          )
        )
    )
  (vehicle-method-94 obj)
  (vehicle-method-121 obj)
  (vehicle-method-97 obj)
  0
  (none)
  )

(defmethod alloc-and-init-rigid-body-control vehicle ((obj vehicle) (arg0 rigid-body-vehicle-constants))
  (if (logtest? (-> arg0 flags) 8)
      (iterate-prims
        (-> obj root)
        (lambda ((arg0 collide-shape-prim))
          (case (-> arg0 prim-core prim-type)
            (((prim-type sphere))
             (set! (-> arg0 prim-core collide-with)
                   (collide-spec
                     backgnd
                     crate
                     civilian
                     enemy
                     obstacle
                     vehicle-sphere
                     hit-by-player-list
                     hit-by-others-list
                     collectable
                     pusher
                     )
                   )
             (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere))
             )
            (((prim-type mesh))
             (set! (-> arg0 prim-core collide-with) (collide-spec jak player-list))
             (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-mesh))
             )
            (((prim-type group))
             (set! (-> arg0 prim-core collide-with)
                   (collide-spec
                     backgnd
                     jak
                     crate
                     civilian
                     enemy
                     obstacle
                     vehicle-sphere
                     hit-by-player-list
                     hit-by-others-list
                     player-list
                     collectable
                     pusher
                     )
                   )
             (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
             )
            )
          (none)
          )
        )
      (iterate-prims
        (-> obj root)
        (lambda ((arg0 collide-shape-prim))
          (set! (-> arg0 prim-core collide-with) (collide-spec
                                                   backgnd
                                                   jak
                                                   crate
                                                   civilian
                                                   enemy
                                                   obstacle
                                                   vehicle-sphere
                                                   hit-by-player-list
                                                   hit-by-others-list
                                                   player-list
                                                   collectable
                                                   pusher
                                                   )
                )
          (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
          (none)
          )
        )
      )
  (set! (-> obj bound-radius) (-> obj draw bounds w))
  (if (-> obj draw shadow)
      (set! (-> obj draw shadow-ctrl)
            (new 'process 'shadow-control -2048.0 -61440.0 69632.0 (shadow-flags shdf03) 245760.0)
            )
      (set! (-> obj draw shadow-ctrl) *vehicle-shadow-control-disabled*)
      )
  (logior! (-> obj root root-prim prim-core action) (collide-action pull-rider-can-collide))
  (set! (-> obj root pat-ignore-mask) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
  (set! (-> obj root event-self) 'touched)
  (let ((t9-3 (method-of-type rigid-body-object alloc-and-init-rigid-body-control)))
    (t9-3 obj arg0)
    )
  (logior! (-> obj rbody state flags) (rigid-body-flag enable-collision))
  (set! (-> obj root max-iteration-count) (the-as uint 8))
  (set! (-> obj max-time-step) 0.033333335)
  (logior! (-> obj mask) (process-mask vehicle))
  (logclear! (-> obj mask) (process-mask actor-pause movie))
  (logclear! (-> obj skel status) (joint-control-status sync-math))
  (process-entity-status! obj (entity-perm-status no-kill) #t)
  (set! (-> obj nav) #f)
  (let ((v1-32 (-> obj root root-prim)))
    (set! (-> obj root backup-collide-as) (-> v1-32 prim-core collide-as))
    (set! (-> obj root backup-collide-with) (-> v1-32 prim-core collide-with))
    )
  (rigid-body-object-method-40 obj)
  (vehicle-controller-method-9 (-> obj controller))
  (vehicle-method-82 obj)
  (set! (-> obj power-level) 0.5)
  (set! (-> obj lights-factor) 0.0)
  (set! (-> obj jump-thrust) 1.0)
  (set! (-> obj turbo-boost-factor) 1.0)
  (dotimes (v1-43 4)
    (set! (-> obj rider-array v1-43) (the-as handle #f))
    )
  (set! (-> obj engine-sound-id) (new 'static 'sound-id))
  (set! (-> obj thrust-sound-id) (new 'static 'sound-id))
  (set! (-> obj roll-sound-id) (new 'static 'sound-id))
  (set! (-> obj scrape-sound-id) (new 'static 'sound-id))
  (set! (-> obj extra-sound-id) (new 'static 'sound-id))
  (set! (-> obj damage-zap-sound-id) (new-sound-id))
  (set! (-> obj damage-pop-sound-id) (new-sound-id))
  (set! (-> obj controller target-speed-offset) (* (rand-vu) (-> arg0 target-speed-offset)))
  (set! (-> obj draw lod-set lod 0 dist) 122880.0)
  (set! (-> obj draw lod-set lod 1 dist) 204800.0)
  (set! (-> obj draw lod-set lod 2 dist) 819200.0)
  (if (zero? (-> obj draw light-index))
      (set! (-> obj draw light-index) (the-as uint 10))
      )
  (rigid-body-queue-method-11
    (if (logtest? (-> obj info flags) 1024)
        *race-rigid-body-queue*
        *traffic-rigid-body-queue*
        )
    obj
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-47 vehicle ((obj vehicle) (arg0 process-drawable) (arg1 attack-info) (arg2 touching-shapes-entry) (arg3 penetrate))
  (local-vars (f0-2 float) (sv-96 vector))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (rigid-body-object-method-49 obj (the-as rigid-body-impact s5-0) arg2)
      (cond
        ((logtest? (attack-info-mask attacker-velocity) (-> arg1 mask))
         (set! (-> s5-0 vector 2 quad) (-> arg1 attacker-velocity quad))
         )
        (else
          (let ((s0-0 arg0))
            (cond
              ((if (type? s0-0 process-focusable)
                   (the-as process-focusable s0-0)
                   )
               (set! sv-96 (-> s5-0 vector 2))
               (let ((s0-1 (-> s5-0 vector))
                     (v1-7 (get-trans (the-as process-focusable arg0) 3))
                     )
                 (.lvf vf4 (&-> s0-1 0 quad))
                 (.lvf vf5 (&-> v1-7 quad))
                 )
               (.mov.vf vf6 vf0 :mask #b1000)
               (.sub.vf vf6 vf4 vf5 :mask #b111)
               (.svf (&-> sv-96 quad) vf6)
               )
              (else
                (vector-! (-> s5-0 vector 2) (the-as vector (-> s5-0 vector)) (-> arg0 root trans))
                )
              )
            )
          )
        )
      0.0
      0.0
      (let ((f1-0 (cond
                    ((= (-> arg1 mode) 'mine)
                     (set! f0-2 20480.0)
                     0.2
                     )
                    ((or (logtest? (penetrate dark-giant) arg3)
                         (and (logtest? (-> arg1 mask) (attack-info-mask mode)) (= (-> arg1 mode) 'eco-dark))
                         )
                     (set! (-> s5-0 vector 2 y) (* 0.1 (-> s5-0 vector 2 y)))
                     (set! f0-2 (* 409600.0 (-> obj info info mass)))
                     (/ 0.4 (-> obj info damage-factor))
                     )
                    ((or (logtest? (penetrate dark-punch dark-bomb) arg3)
                         (and (logtest? (penetrate dark-skin) arg3) (logtest? arg3 (penetrate punch spin)))
                         )
                     (set! f0-2 (* 204800.0 (-> obj info info mass)))
                     (/ 0.2 (-> obj info damage-factor))
                     )
                    ((logtest? (penetrate enemy-yellow-shot) arg3)
                     (set! f0-2 49152.0)
                     0.025
                     )
                    ((logtest? (penetrate jak-yellow-shot) arg3)
                     (set! f0-2 98304.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-blue-shot) arg3)
                     (set! f0-2 196608.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-red-shot) arg3)
                     (set! f0-2 196608.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-dark-shot enemy-dark-shot) arg3)
                     (set! f0-2 393216.0)
                     0.5
                     )
                    ((or (logtest? (penetrate explode) arg3)
                         (and (logtest? (-> arg1 mask) (attack-info-mask mode)) (case (-> arg1 mode)
                                                                                  (('explode 'grenade 'melt 'ice)
                                                                                   #t
                                                                                   )
                                                                                  )
                              )
                         )
                     (set! f0-2 122880.0)
                     1.0
                     )
                    ((logtest? arg3 (penetrate punch))
                     (set! f0-2 40960.0)
                     0.1
                     )
                    ((logtest? arg3 (penetrate flop spin))
                     (set! f0-2 20480.0)
                     0.05
                     )
                    (else
                      (set! f0-2 8192.0)
                      0.01
                      )
                    )
                  )
            )
        (set! (-> s5-0 trans x) f0-2)
        (apply-damage obj (* 0.667 f1-0) (the-as rigid-body-impact s5-0))
        )
      (rigid-body-object-method-42 obj)
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (set! (-> s3-1 quad) (-> s5-0 vector 2 quad))
        (vector-normalize! s3-1 1.0)
        (vector-float*! s3-1 s3-1 (-> s5-0 trans x))
        (let ((v1-90 (-> obj rbody))
              (a1-11 (-> s5-0 vector))
              (a2-3 s3-1)
              )
          (rigid-body-method-18 (-> v1-90 state) (the-as vector a1-11) a2-3)
          )
        (let ((v1-93 (-> obj rbody))
              (f0-10 1.0)
              )
          (rigid-body-method-12 (-> v1-93 state) f0-10)
          )
        (rigid-body-method-13 (-> obj rbody state))
        (when #f
          (set! (-> *debug-vehicle-work* impact-time) (current-time))
          (mem-copy! (the-as pointer (-> *debug-vehicle-work* impact)) (the-as pointer s5-0) 64)
          (let ((v1-103 (-> arg2 head)))
            (set! (-> *debug-vehicle-work* prim-sphere1 quad) (-> v1-103 prim1 cprim prim-core world-sphere quad))
            (set! (-> *debug-vehicle-work* prim-sphere2 quad) (-> v1-103 prim2 cprim prim-core world-sphere quad))
            )
          (add-debug-x #t (bucket-id debug-no-zbuf1) (the-as vector (-> s5-0 vector)) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (the-as vector (-> s5-0 vector))
            s3-1
            (meters 0.00024414062)
            *color-blue*
            )
          )
        )
      (rigid-body-object-method-45 obj (the-as rigid-body-impact s5-0))
      )
    (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
        (go (method-of-object obj waiting))
        )
    #t
    )
  )

(defmethod rigid-body-object-method-48 vehicle ((obj vehicle) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (v1-2 symbol) (v1-30 symbol) (a0-19 object))
  (with-pp
    (b!
      (not (logtest? (process-mask target crate enemy guard civilian) (-> arg0 mask)))
      cfg-5
      :likely-delay (set! v1-2 #t)
      )
    (b! (not (logtest? (-> arg0 mask) (process-mask target))) cfg-5 :likely-delay (set! v1-2 #f))
    (set! v1-2 (focus-test? arg0 dangerous pilot))
    (label cfg-5)
    (b! v1-2 cfg-32 :delay (nop!))
    (let ((s5-0 (new 'stack-no-clear 'rigid-body-impact)))
      (let ((s2-0 (new 'stack-no-clear 'vector)))
        (let ((f30-0 (get-inv-mass arg0)))
          (rigid-body-object-method-49 obj s5-0 arg1)
          (cond
            ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
             (let ((v1-14 (-> obj rbody))
                   (a1-3 (-> s5-0 point))
                   (a2-2 (-> s5-0 velocity))
                   )
               (rigid-body-method-22 (-> v1-14 state) a1-3 a2-2)
               )
             )
            (else
              (set! (-> s5-0 velocity quad) (-> obj root transv quad))
              )
            )
          (let ((v1-18 (-> arg0 root)))
            (set! (-> s2-0 quad) (-> v1-18 transv quad))
            (vector-! (-> s5-0 velocity) (-> v1-18 transv) (-> s5-0 velocity))
            )
          (let ((f0-1 (vector-dot (-> s5-0 velocity) (-> s5-0 normal))))
            (b! (>= f0-1 0.0) cfg-32 :delay #f)
            (set! (-> s5-0 impulse) (/ f0-1 (+ f30-0 (-> obj info info inv-mass))))
            )
          (vector+float*! s2-0 s2-0 (-> s5-0 normal) (* -3.1 f30-0 (-> s5-0 impulse)))
          (set! (-> s2-0 y) (fmax (* 49152.0 f30-0) (-> s2-0 y)))
          )
        (b! (logtest? (rigid-body-object-flag in-pursuit) (-> obj flags)) cfg-13 :likely-delay (set! v1-30 #t))
        (set! v1-30 (!= arg0 *target*))
        (label cfg-13)
        (b! (not v1-30) cfg-25 :delay (empty-form))
        (when (>= (- (current-time) (-> obj sent-attack-time)) (seconds 0.5))
          (set! (-> obj sent-attack-time) (current-time))
          (let* ((v1-39 *game-info*)
                 (a0-18 (+ (-> v1-39 attack-id) 1))
                 )
            (set! (-> v1-39 attack-id) a0-18)
            (set! (-> obj outgoing-attack-id) a0-18)
            )
          )
        (let ((f30-1 (+ 0.5 (* 0.000024414063 (- (-> s5-0 impulse)))))
              (s1-0 (new 'stack-no-clear 'event-message-block))
              )
          (let ((v1-42 pp))
            (b! (not v1-42) cfg-18 :delay (set! a0-19 #f))
            (set! a0-19 (-> v1-42 ppointer))
            )
          (label cfg-18)
          (set! (-> s1-0 from) (the-as (pointer process) a0-19))
          (set! (-> s1-0 num-params) 2)
          (set! (-> s1-0 message) 'attack)
          (set! (-> s1-0 param 0) (the-as uint arg1))
          (let ((s0-0 (new 'static 'attack-info :mask (attack-info-mask vector attacker mode id penetrate-using damage))))
            (set! (-> s0-0 id) (-> obj outgoing-attack-id))
            (set! (-> s0-0 attacker) (process->handle (vehicle-method-70 obj)))
            (set! (-> s0-0 mode) 'vehicle)
            (set! (-> s0-0 vector quad) (-> s2-0 quad))
            (set! (-> s0-0 penetrate-using) (penetrate vehicle))
            (set! (-> s0-0 damage) f30-1)
            (set! (-> s1-0 param 1) (the-as uint s0-0))
            )
          (b! (not (send-event-function arg0 s1-0)) cfg-25 :delay (empty-form))
          )
        )
      (label cfg-25)
      (rigid-body-object-method-42 obj)
      (let ((a2-4 (new 'stack-no-clear 'vector)))
        (vector-float*! a2-4 (-> s5-0 normal) (-> s5-0 impulse))
        (let ((v1-60 (-> obj rbody))
              (a1-9 (-> s5-0 point))
              )
          (rigid-body-method-18 (-> v1-60 state) a1-9 a2-4)
          )
        )
      (let ((v1-63 (-> obj rbody))
            (f0-11 1.0)
            )
        (rigid-body-method-12 (-> v1-63 state) f0-11)
        )
      (rigid-body-method-13 (-> obj rbody state))
      (when #f
        (set! (-> *debug-vehicle-work* impact-time) (current-time))
        (mem-copy! (the-as pointer (-> *debug-vehicle-work* impact)) (the-as pointer s5-0) 64)
        (let ((v1-73 (-> arg1 head)))
          (set! (-> *debug-vehicle-work* prim-sphere1 quad) (-> v1-73 prim1 cprim prim-core world-sphere quad))
          (set! (-> *debug-vehicle-work* prim-sphere2 quad) (-> v1-73 prim2 cprim prim-core world-sphere quad))
          )
        (add-debug-x #t (bucket-id debug-no-zbuf1) (-> s5-0 point) *color-blue*)
        (add-debug-vector
          #t
          (bucket-id debug-no-zbuf1)
          (-> s5-0 point)
          (-> s5-0 normal)
          (- (-> s5-0 impulse))
          *color-blue*
          )
        )
      (rigid-body-object-method-45 obj s5-0)
      )
    (b! (not (and (-> obj next-state) (= (-> obj next-state name) 'idle))) cfg-32 :delay (empty-form))
    (go (method-of-object obj waiting))
    (label cfg-32)
    #t
    )
  )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 71]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 182]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 215]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 222]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 257]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 273]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 323]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 290]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 307]
(defmethod rigid-body-object-method-46 vehicle ((obj vehicle) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (when (and (= arg2 'touched) arg0 (logtest? (process-mask bit18) (-> arg0 mask)))
    (dotimes (s1-0 4)
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer arg0))
        (set! (-> a1-2 num-params) arg1)
        (set! (-> a1-2 message) arg2)
        (set! (-> a1-2 param 0) (-> arg3 param 0))
        (set! (-> a1-2 param 1) (-> arg3 param 1))
        (set! (-> a1-2 param 2) (-> arg3 param 2))
        (set! (-> a1-2 param 3) (-> arg3 param 3))
        (set! (-> a1-2 param 4) (-> arg3 param 4))
        (set! (-> a1-2 param 5) (-> arg3 param 5))
        (send-event-function (handle->process (-> obj rider-array s1-0)) a1-2)
        )
      )
    )
  (let ((v1-19 arg2))
    (the-as
      object
      (cond
        ((= v1-19 'traffic-off)
         (when (not (logtest? (-> obj flags) (rigid-body-object-flag persistent)))
           (cond
             ((logtest? (-> obj flags) (rigid-body-object-flag dead))
              (go (method-of-object obj die))
              )
             (else
               (if (logtest? (rigid-body-object-flag ai-driving) (-> obj flags))
                   (vehicle-method-113 obj)
                   )
               )
             )
           )
         )
        ((= v1-19 'traffic-off-force)
         (vehicle-method-113 obj)
         )
        ((= v1-19 'traffic-activate)
         (set! (-> obj controller traffic) (the-as traffic-engine (-> arg3 param 1)))
         (logior! (-> obj flags) (rigid-body-object-flag traffic-managed))
         (let ((s5-1 (the-as traffic-object-spawn-params (-> arg3 param 0))))
           (set! (-> obj root trans quad) (-> s5-1 position quad))
           (quaternion-copy! (-> obj root quat) (-> s5-1 rotation))
           (set! (-> obj root transv quad) (-> s5-1 velocity quad))
           (vehicle-method-130 obj s5-1)
           )
         )
        ((= v1-19 'attack)
         (let ((s3-1 (the-as attack-info (-> arg3 param 1)))
               (s2-1 (get-penetrate-using-from-attack-event arg0 arg3))
               )
           (when (and (!= (-> s3-1 id) (-> obj incoming-attack-id))
                      (not (logtest? (-> obj flags) (rigid-body-object-flag dead)))
                      (or (not (logtest? (-> obj flags) (rigid-body-object-flag player-driving)))
                          (not (logtest? (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot) s2-1))
                          )
                      )
             (set! (-> obj incoming-attack-id) (-> s3-1 id))
             (when (and (logtest? (-> obj info flags) 4) (logtest? (rigid-body-object-flag ai-driving) (-> obj flags)))
               (let ((a1-8 (find-offending-process-focusable arg0 s3-1)))
                 (if (and a1-8 (logtest? (-> a1-8 mask) (process-mask target)))
                     (vehicle-method-134 obj a1-8)
                     )
                 )
               )
             (rigid-body-object-method-47 obj arg0 s3-1 (the-as touching-shapes-entry (-> arg3 param 0)) s2-1)
             )
           )
         )
        ((= v1-19 'turbo-ring)
         (set! (-> obj turbo-boost-factor) (the-as float (-> arg3 param 0)))
         (set! (-> obj turbo-boost-time) (current-time))
         (set! (-> obj turbo-boost-duration) (the-as uint 75))
         (logior! (-> obj flags) (rigid-body-object-flag turbo-boost))
         (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             (sound-play "boost-ring")
             )
         )
        ((= v1-19 'get-offending-focusable)
         (if (logtest? (-> obj flags) (rigid-body-object-flag player-driving))
             *target*
             )
         )
        ((= v1-19 'pilot-on)
         (let* ((s3-2 (-> arg3 param 0))
                (s2-2 arg0)
                (s5-3 (if (type? s2-2 process-focusable)
                          s2-2
                          )
                      )
                )
           (when s5-3
             (format #t "vehicle::event-handler: pilot-on (pid ~d) from pid ~d~%" (-> obj pid) (-> arg0 pid))
             (logior! (-> obj flags) (rigid-body-object-flag riding))
             (put-rider-in-seat obj (the-as int s3-2) (the-as process-focusable s5-3))
             (if (logtest? (-> s5-3 mask) (process-mask target))
                 (logior! (-> obj flags) (rigid-body-object-flag player-driving))
                 )
             #t
             )
           )
         )
        ((= v1-19 'player-get-off)
         (if (and (logtest? (-> obj flags) (rigid-body-object-flag player-driving)) (!= (-> obj crash-level) 3))
             (go (method-of-object obj waiting))
             )
         )
        ((= v1-19 'rider-off)
         (send-event (ppointer->process (-> obj child)) 'rider-off)
         )
        ((= v1-19 'rider-on)
         (send-event (ppointer->process (-> obj child)) 'rider-on)
         )
        ((= v1-19 'nav-mesh-kill)
         (vehicle-method-142 obj)
         )
        (else
          ((method-of-type rigid-body-object rigid-body-object-method-46) obj arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defmethod vehicle-method-135 vehicle ((obj vehicle) (arg0 traffic-object-spawn-params))
  0
  (none)
  )

(defbehavior vehicle-init-by-other vehicle ((arg0 traffic-object-spawn-params))
  (stack-size-set! (-> self main-thread) 16)
  (logior! (-> self mask) (process-mask vehicle))
  (allocate-and-init-cshape self)
  (set! (-> self root trans quad) (-> arg0 position quad))
  (quaternion-copy! (-> self root quat) (-> arg0 rotation))
  (if (not (logtest? (-> arg0 flags) (traffic-spawn-flags trsflags-00)))
      (lwide-entity-hack)
      )
  (init-skel-and-rigid-body self)
  (set! (-> self traffic-priority-id) (the-as int (-> arg0 id)))
  (vehicle-method-136 self arg0)
  (none)
  )
