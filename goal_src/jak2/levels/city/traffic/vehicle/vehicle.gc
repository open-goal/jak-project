;;-*-Lisp-*-
(in-package goal)

;; name: vehicle.gc
;; name in dgo: vehicle
;; dgos: CWI

;; TODO - for vehicle
(define-extern *race-rigid-body-queue* rigid-body-queue)
(define-extern *traffic-rigid-body-queue* rigid-body-queue)

;; DECOMP BEGINS

(defun string-word-wrap ((arg0 string) (arg1 int))
  (let ((v1-0 (-> arg0 data)))
    (label cfg-1)
    (let ((a2-0 0)
          (a0-1 0)
          )
      (b! #t cfg-6 :delay (nop!))
      (label cfg-2)
      (b! (zero? (-> v1-0 a2-0)) cfg-11 :delay (nop!))
      (if (= (-> v1-0 a2-0) 32)
          (set! a0-1 a2-0)
          )
      (+! a2-0 1)
      (label cfg-6)
      (b! (< a2-0 arg1) cfg-2)
      (if (zero? a0-1)
          (set! a0-1 a2-0)
          )
      (set! (-> v1-0 a0-1) (the-as uint 10))
      (&+! v1-0 (+ a0-1 1))
      )
    )
  (goto cfg-1)
  (label cfg-11)
  0
  (none)
  )

(deftype debug-vehicle-work (basic)
  ((impact-time  time-frame                :offset-assert   8)
   (impact       rigid-body-impact :inline :offset-assert  16)
   (prim-sphere1 sphere            :inline :offset-assert  80)
   (prim-sphere2 sphere            :inline :offset-assert  96)
   )
  :method-count-assert 9
  :size-assert         #x70
  :flag-assert         #x900000070
  )


(define *debug-vehicle-work* (new 'static 'debug-vehicle-work))

(defskelgroup skel-vehicle-explosion vehicle-explosion vehicle-explosion-lod0-jg vehicle-explosion-idle-ja
              ((vehicle-explosion-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              )

(define *vehicle-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

(define *vehicle-shadow-control-disabled*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade shdf03 disable-draw)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 163840.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 40960.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w 2048.0)
                                           )
                               )
  )

(defmethod rigid-body-object-method-45 vehicle ((this vehicle) (arg0 rigid-body-impact))
  (local-vars (v1-63 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (set! (-> this impact-pos quad) (-> arg0 point quad))
    (let* ((f0-0 1.0)
           (f1-0 (-> arg0 impulse))
           (f2-0 61440.0)
           (f30-0 (fmin f0-0 (* f1-0 (/ 1.0 f2-0) (-> this info info inv-mass))))
           (f28-0 (* (-> this info info mass) (-> this info toughness-factor)))
           )
      (set! (-> this crash-impulse) (-> arg0 impulse))
      (cond
        ((< (* 286720.0 f28-0) (-> arg0 impulse))
         (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 1))
             )
         (apply-damage this 1.0 arg0)
         (vehicle-method-76 this 2 (the-as uint 300))
         )
        ((< (* 131072.0 f28-0) (-> arg0 impulse))
         (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.5))
             )
         (apply-damage this 0.25 arg0)
         (vehicle-method-76 this 1 (the-as uint 75))
         )
        ((< (* 102400.0 f28-0) (-> arg0 impulse))
         (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
             (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.25))
             )
         (apply-damage this 0.125 arg0)
         (vehicle-method-76 this 1 (the-as uint 75))
         )
        (else
          (let* ((f0-9 0.0)
                 (f1-7 (-> arg0 impulse))
                 (f2-5 (* 16384000.0 f28-0))
                 (f0-10 (fmax f0-9 (* f1-7 (/ 1.0 f2-5))))
                 )
            (apply-damage this f0-10 arg0)
            )
          (when (< (* 32768.0 f28-0) (-> arg0 impulse))
            (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
                (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
                )
            )
          (if (< 0.1 f30-0)
              (sound-play-by-name
                (-> this info glance-sound)
                (new-sound-id)
                (the int (* 1024.0 f30-0))
                0
                0
                (sound-group sfx)
                #t
                )
              )
          )
        )
      (when (< (* 102400.0 f28-0) (-> arg0 impulse))
        (sound-play-by-name
          (-> this info impact-sound)
          (new-sound-id)
          (the int (* 1024.0 f30-0))
          0
          0
          (sound-group sfx)
          #t
          )
        (logclear! (-> this flags) (rigid-body-object-flag turbo-boost))
        )
      )
    (let ((a0-17 (new 'stack-no-clear 'vector)))
      (vector+float*!
        a0-17
        (-> arg0 velocity)
        (-> arg0 normal)
        (- (vector-dot (-> arg0 velocity) (-> arg0 normal)))
        )
      (.lvf vf1 (&-> a0-17 quad))
      )
    (.add.w.vf vf2 vf0 vf0 :mask #b1)
    (.mul.vf vf1 vf1 vf1)
    (.mul.x.vf acc vf2 vf1 :mask #b1)
    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
    (.mov v1-63 vf1)
    (let ((f0-25 v1-63)
          (f1-11 12288.0)
          )
      (when (< (* f1-11 f1-11) f0-25)
        (set! (-> this scrape-sound-envelope) 1.0)
        (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
            (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.05))
            )
        )
      )
    (if (>= 0.0 (-> this hit-points))
        (vehicle-method-76 this 2 (the-as uint 300))
        )
    0
    (none)
    )
  )

(defmethod vehicle-method-104 vehicle ((this vehicle))
  (when (= (-> this controller traffic sync-mask-8) (ash 1 (logand (-> this traffic-priority-id) 7)))
    (let ((a1-0 (-> this root trans)))
      (set! (-> this flight-level) (get-height-at-point *traffic-height-map* a1-0))
      )
    )
  (set! (-> this target-acceleration y)
        (- (* 8.0 (- (-> this flight-level) (-> this root trans y))) (-> this root transv y))
        )
  (vector-v++! (-> this root transv) (-> this target-acceleration))
  (vector-v++! (-> this root trans) (-> this root transv))
  (let* ((v1-14 (-> this root transv))
         (f30-0 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
         (s5-0 (new 'stack-no-clear 'vehicle-control-point))
         )
    (when (< 40.96 f30-0)
      (vector-float*! (-> s5-0 normal) (-> this root transv) (/ 1.0 f30-0))
      (quaternion-set!
        (the-as quaternion (-> s5-0 local-pos))
        0.0
        (-> s5-0 normal x)
        0.0
        (+ 1.0 (-> s5-0 normal z))
        )
      (quaternion-normalize! (the-as quaternion (-> s5-0 local-pos)))
      (quaternion-rotate-local-z!
        (the-as quaternion (-> s5-0 local-pos))
        (the-as quaternion (-> s5-0 local-pos))
        (* -0.08886719 (-> this controls steering) (fmin 81920.0 f30-0))
        )
      (quaternion-smooth-seek!
        (-> this root quat)
        (-> this root quat)
        (the-as quaternion (-> s5-0 local-pos))
        (* 0.00014686584 (seconds-per-frame) f30-0)
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-93 vehicle ((this vehicle))
  (let ((s5-0 (new 'stack-no-clear 'matrix)))
    (set! (-> s5-0 vector 2 quad) (-> this rbody state matrix quad 0))
    (set! (-> s5-0 trans quad) (-> this rbody state matrix vector 2 quad))
    (let ((f28-0 (* (-> this rbody state ang-velocity y) (vector-length (-> this rbody state lin-velocity))))
          (f30-0 (seconds-per-frame))
          )
      (when (zero? (-> this flight-level-index))
        (if (logtest? (-> this flags) (rigid-body-object-flag riding))
            (vehicle-method-80 this)
            )
        )
      (vector-! (-> s5-0 vector 1) (-> this target-acceleration) (-> this lin-acceleration))
      (let ((f0-3 (* 0.00006 (vector-dot (-> s5-0 trans) (-> s5-0 vector 1)) f30-0)))
        (set! (-> s5-0 vector 0 y) (fmax 0.0 (fmin 1.0 (* 20.0 f0-3))))
        (set! (-> s5-0 vector 0 z) (fmax 0.0 (fmin 1.0 (* -40.0 f0-3))))
        (if (= this *debug-actor*)
            (format *stdcon* "delta-throttle ~f~%" f0-3)
            )
        )
      (when (logtest? (-> this flags) (rigid-body-object-flag player-edge-grabbing))
        (set! (-> s5-0 vector 0 y) 0.0)
        (set! (-> s5-0 vector 0 z) 1.0)
        (logclear! (-> this flags) (rigid-body-object-flag reverse-gear))
        )
      (let ((f0-7 (* 6.0 f30-0))
            (f4-0 (* 0.00018024445
                     (- (vector-dot (-> s5-0 vector 2) (-> this target-acceleration)) f28-0)
                     (if (< (-> this controls throttle) 0.0)
                         -1.0
                         1.0
                         )
                     f30-0
                     )
                  )
            )
        (set! (-> s5-0 vector 0 x)
              (fmax -1.0 (fmin 1.0 (+ (-> this controls steering) (fmax (fmin f4-0 f0-7) (- f0-7)))))
              )
        )
      )
    (set! (-> s5-0 vector 0 w) 0.0)
    (vehicle-method-95 this (the-as vector (-> s5-0 vector)))
    (when (= this *debug-actor*)
      (let ((v1-43 (-> s5-0 vector)))
        (format *stdcon* "steer ~f, throttle ~f, brake ~f~%" (-> v1-43 0 x) (-> v1-43 0 y) (-> v1-43 0 z))
        )
      (let ((v1-45 (-> this controls)))
        (format *stdcon* "steer ~f, throttle ~f, brake ~f~%" (-> v1-45 steering) (-> v1-45 throttle) (-> v1-45 brake))
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-95 vehicle ((this vehicle) (arg0 vector))
  (seek! (-> this controls steering) (-> arg0 x) (* 8.0 (seconds-per-frame)))
  (seek! (-> this controls lean-z) (-> arg0 w) (* 8.0 (seconds-per-frame)))
  (logclear! (-> this flags) (rigid-body-object-flag slide))
  (let ((f0-10 (-> arg0 y))
        (f30-0 (-> arg0 z))
        )
    (set! f30-0
          (cond
            ((< 0.0 f0-10)
             (logclear! (-> this flags) (rigid-body-object-flag reverse-gear))
             (when (< 0.0 f30-0)
               (set! f30-0 0.25)
               (logior! (-> this flags) (rigid-body-object-flag slide))
               )
             f30-0
             )
            ((< 0.0 f30-0)
             (cond
               ((logtest? (rigid-body-object-flag reverse-gear) (-> this flags))
                (let ((f0-11 -0.5)
                      (f1-5 0.0)
                      (f2-0 -40960.0)
                      )
                  (set! f0-10
                        (fmax
                          f0-11
                          (fmin
                            f1-5
                            (* (/ 1.0 f2-0)
                               f30-0
                               (- 8192.0 (vector-dot (-> this rbody state lin-velocity) (-> this rbody state matrix vector 2)))
                               )
                            )
                          )
                        )
                  )
                0.0
                )
               (else
                 (let* ((v1-25 (-> this rbody state lin-velocity))
                        (f1-10 (+ (* (-> v1-25 x) (-> v1-25 x)) (* (-> v1-25 z) (-> v1-25 z))))
                        (f2-8 8192.0)
                        )
                   (if (< f1-10 (* f2-8 f2-8))
                       (logior! (-> this flags) (rigid-body-object-flag reverse-gear))
                       )
                   )
                 f30-0
                 )
               )
             )
            (else
              (logclear! (-> this flags) (rigid-body-object-flag reverse-gear))
              f30-0
              )
            )
          )
    (seek! (-> this controls throttle) f0-10 (* 4.0 (seconds-per-frame)))
    (+! (-> this controls brake) (* (- f30-0 (-> this controls brake)) (fmin 1.0 (* 8.0 (seconds-per-frame)))))
    )
  0
  (none)
  )

(defmethod vehicle-method-94 vehicle ((this vehicle))
  (cond
    ((or (logtest? (rigid-body-object-flag player-grabbed) (-> this flags))
         (and *target* (focus-test? *target* dead grabbed))
         )
     (let ((v1-7 (new 'stack-no-clear 'vector)))
       (set! (-> v1-7 x) 0.0)
       (set! (-> v1-7 w) 0.0)
       (set! (-> v1-7 y) 0.0)
       (set! (-> v1-7 z) (if (logtest? (-> this flags) (rigid-body-object-flag in-air))
                             0.0
                             1.0
                             )
             )
       (logclear! (-> this flags) (rigid-body-object-flag reverse-gear))
       (vehicle-method-95 this (the-as vector (&-> v1-7 x)))
       )
     )
    ((and (zero? (-> this crash-level))
          (not (logtest? (rigid-body-object-flag ai-driving measure-control-parameters) (-> this flags)))
          )
     (when (and (cpad-pressed? 0 r2) (not *pause-lock*))
       (if (zero? (-> this flight-level-index))
           (vehicle-method-80 this)
           (vehicle-method-81 this)
           )
       )
     (let ((s5-0 (new 'stack-no-clear 'vector)))
       (set! (-> s5-0 x) (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0))
       (set! (-> s5-0 w) (analog-input (the-as int (-> *cpad-list* cpads 0 lefty)) 128.0 48.0 110.0 -1.0))
       (set! (-> s5-0 y) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 6)))))
       (set! (-> s5-0 z) (fmin 1.0 (* 0.023529412 (the float (-> *cpad-list* cpads 0 abutton 7)))))
       (vehicle-method-95 this (the-as vector (&-> s5-0 x)))
       )
     (if (or (cpad-hold? 0 l1) (and (logtest? (-> this info flags) 512) (cpad-hold? 0 r1)))
         (start-jump this)
         )
     (if (cpad-pressed? 0 circle)
         (vehicle-method-66 this)
         )
     )
    )
  0
  (none)
  )

(defmethod vehicle-method-96 vehicle ((this vehicle))
  (when (and *target* (logtest? (rigid-body-object-flag ignition) (-> this flags)))
    (when (and (logtest? (-> this flags) (rigid-body-object-flag player-driving))
               (zero? (-> this root num-riders))
               (or (not *target*) (or (< 32768.0 (vector-vector-distance (-> this root trans) (-> *target* control trans)))
                                      (focus-test? *target* teleporting)
                                      )
                   )
               )
      (set! (-> this controls throttle) 0.0)
      (set! (-> this controls steering) 0.0)
      (set! (-> this controls lean-z) 0.0)
      (mem-copy! (the-as pointer (-> this prev-controls)) (the-as pointer (-> this controls)) 16)
      )
    )
  (cond
    ((zero? (-> this crash-level))
     (seek! (-> this force-scale) 1.0 (seconds-per-frame))
     )
    ((< (-> this crash-level) 3)
     (when (time-elapsed? (-> this crash-time) (the-as time-frame (-> this crash-duration)))
       (if (or (>= (-> this rbody state matrix vector 1 y) (cos 18204.445))
               (time-elapsed? (-> this crash-time) (seconds 3))
               )
           (vehicle-method-77 this)
           )
       )
     )
    )
  (set! (-> this force-level) (-> this crash-level))
  (cond
    ((>= (-> this hit-points) 0.9)
     (set! (-> this power-fluctuation-factor) 0.01)
     )
    ((>= (-> this hit-points) 0.75)
     (set! (-> this power-fluctuation-factor) 0.02)
     )
    ((>= (-> this hit-points) 0.5)
     (set! (-> this power-fluctuation-factor) 0.04)
     )
    ((>= (-> this hit-points) 0.3)
     (set! (-> this power-fluctuation-factor) 0.08)
     )
    ((>= (-> this hit-points) 0.15)
     (set! (-> this power-fluctuation-factor) 0.16)
     )
    ((>= (-> this hit-points) 0.05)
     (set! (-> this power-fluctuation-factor) 0.32)
     )
    (else
      (set! (-> this power-fluctuation-factor) 0.7)
      )
    )
  (let ((f1-6 0.0))
    (when (logtest? (rigid-body-object-flag ignition) (-> this flags))
      (let ((f0-23 (- 1.0 (* (rand-vu) (-> this power-fluctuation-factor)))))
        (set! f1-6 (* f0-23 f0-23))
        )
      (if (not (logtest? (-> this flags) (rigid-body-object-flag riding)))
          (set! f1-6 (* 0.5 f1-6))
          )
      )
    (+! (-> this power-level)
        (* (- f1-6 (-> this power-level))
           (fmin 1.0 (* (+ 1.0 (* 50.0 (-> this power-fluctuation-factor))) (seconds-per-frame)))
           )
        )
    )
  (when (logtest? (rigid-body-object-flag turbo-boost) (-> this flags))
    (if (or (time-elapsed? (-> this turbo-boost-time) (the-as time-frame (-> this turbo-boost-duration)))
            (and (time-elapsed? (-> this turbo-boost-time) (seconds 0.1)) (>= (-> this controls brake) 0.75))
            )
        (logclear! (-> this flags) (rigid-body-object-flag turbo-boost))
        )
    )
  (cond
    ((logtest? (rigid-body-object-flag ignition) (-> this flags))
     (-> this controls throttle)
     (let* ((f1-13
              (fmax
                0.0
                (fmin 1.0 (/ (* (vector-length (-> this rbody state lin-velocity)) (-> this info engine-intake-factor))
                             (-> this info max-xz-speed)
                             )
                      )
                )
              )
            (f1-16 (fmin (-> this controls throttle) (* 0.83333 (+ 0.5 f1-13))))
            )
       0
       (if (logtest? (rigid-body-object-flag turbo-boost) (-> this flags))
           (set! f1-16 (+ 1.0 (* (-> this turbo-boost-factor) (-> this info turbo-boost-factor))))
           )
       (if (< (-> this engine-thrust) f1-16)
           (+! (-> this engine-thrust)
               (* (- f1-16 (-> this engine-thrust)) (fmin 1.0 (* (-> this info engine-response-rate) (seconds-per-frame))))
               )
           (seek! (-> this engine-thrust) f1-16 (seconds-per-frame))
           )
       )
     )
    (else
      (set! (-> this engine-thrust) 0.0)
      )
    )
  (set! (-> this engine-power-factor) (fabs (-> this engine-thrust)))
  (if (and (logtest? (rigid-body-object-flag jump) (-> this flags)) (< 0.0 (-> this jump-time)))
      (set! (-> this jump-thrust) 1.0)
      (set! (-> this jump-thrust) 0.0)
      )
  (cond
    ((logtest? (rigid-body-object-flag jump) (-> this flags))
     (seek! (-> this jump-time) 0.0 (seconds-per-frame))
     )
    ((not (logtest? (-> this flags) (rigid-body-object-flag in-air)))
     (if (< 0.0 (-> this jump-time))
         (logclear! (-> this flags) (rigid-body-object-flag jump-sound))
         )
     (seek! (-> this jump-time) 0.1 (* 0.5 (seconds-per-frame)))
     )
    )
  (when (and (logtest? (rigid-body-object-flag jump) (-> this flags))
             (not (logtest? (-> this flags) (rigid-body-object-flag in-air)))
             (logtest? (-> this vehicle-jkhn1b23jn1) 1024)
             )
    (logior! (-> this flags) (rigid-body-object-flag hard-turn))
    (set-time! (-> this turn-time))
    )
  (if (or (not (logtest? (rigid-body-object-flag jump) (-> this flags)))
          (time-elapsed? (-> this turn-time) (seconds 1))
          )
      (logclear! (-> this flags) (rigid-body-object-flag hard-turn))
      )
  (if (logtest? (-> this flags) (rigid-body-object-flag on-ground on-flight-level))
      (set-time! (-> this air-time))
      )
  (when (logtest? (rigid-body-object-flag flight-level-transition) (-> this flags))
    (if (or (and (> (-> this flight-level-index) 0)
                 (< (fabs (- (-> this flight-level) (-> this rbody state position y))) 8192.0)
                 (< (fabs (-> this rbody state lin-velocity y)) 8192.0)
                 )
            (and (zero? (-> this flight-level-index)) (logtest? (-> this flags) (rigid-body-object-flag on-ground)))
            )
        (vehicle-method-79 this)
        )
    (when (and (> (-> this flight-level-index) 0) (time-elapsed? (-> this transition-time) (seconds 2)))
      (vehicle-method-79 this)
      (vehicle-method-83 this)
      )
    )
  (when (and (logtest? (rigid-body-object-flag flight-level-transition-ending) (-> this flags))
             (time-elapsed? (-> this transition-end-time) (seconds 1))
             )
    (logclear! (-> this flags) (rigid-body-object-flag flight-level-transition-ending))
    (vehicle-method-92 this)
    )
  0
  (none)
  )

(defmethod vehicle-method-97 vehicle ((this vehicle))
  (local-vars (v1-88 float) (v1-98 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (when (logtest? (rigid-body-object-flag camera) (-> this flags))
      (let ((f0-0 -4096000.0))
        (dotimes (v1-4 (-> *level* length))
          (let ((a0-5 (-> *level* level v1-4)))
            (when (= (-> a0-5 status) 'active)
              (let ((a0-7 (-> a0-5 bsp city-level-info)))
                (when (nonzero? a0-7)
                  (let ((f1-0 (the-as float (-> a0-7 camera-ceiling))))
                    (if (= (the-as meters f1-0) 0.0)
                        (set! f1-0 40960000.0)
                        )
                    (set! f0-0 (fmax f0-0 f1-0))
                    )
                  )
                )
              )
            )
          )
        (set-setting! 'string-camera-ceiling 'abs f0-0 0)
        )
      (cond
        ((logtest? (-> this flags) (rigid-body-object-flag in-air))
         (when (or (< 55296.0 (-> this rbody state lin-velocity y)) (time-elapsed? (-> this air-time) (seconds 0.75)))
           (set-setting! 'extra-follow-height 'abs (meters -4) 0)
           (send-event *camera* 'set-max-angle-offset (-> this info camera-air-max-angle-offset))
           )
         )
        (else
          (remove-setting! 'extra-follow-height)
          (send-event *camera* 'set-max-angle-offset (-> this info camera-normal-max-angle-offset))
          )
        )
      (let ((f0-5 (vector-dot (-> this rbody state lin-velocity) (-> this rbody state matrix vector 2))))
        (cond
          ((= (-> this crash-level) 2)
           (vehicle-method-90 this)
           )
          ((< f0-5 (-> this info camera-max-lookaround-speed))
           (vehicle-method-90 this)
           )
          ((< (+ 4096.0 (-> this info camera-max-lookaround-speed)) f0-5)
           (vehicle-method-89 this)
           )
          )
        )
      (when (not (logtest? (rigid-body-object-flag flight-level-transition) (-> this flags)))
        (let* ((f0-6 1.0)
               (v1-57 (-> this rbody state lin-velocity))
               (f0-7
                 (fmin
                   f0-6
                   (/ (sqrtf (+ (* (-> v1-57 x) (-> v1-57 x)) (* (-> v1-57 z) (-> v1-57 z)))) (-> this info max-xz-speed))
                   )
                 )
               )
          (seek! (-> this cam-speed-interp) f0-7 (* 0.1 (seconds-per-frame)))
          )
        (let ((f30-0 (-> this cam-speed-interp)))
          (if #f
              (set! f30-0
                    (fmax 0.0 (fmin 1.0 (analog-input (the-as int (-> *cpad-list* cpads 1 righty)) 128.0 48.0 110.0 -1.0)))
                    )
              )
          (let ((f0-15 (lerp-scale (-> this info camera-min-fov) (-> this info camera-max-fov) f30-0 0.0 1.0)))
            (set-setting! 'fov 'abs f0-15 0)
            )
          (let ((f30-2 (lerp-scale 1.0 0.6 f30-0 0.0 1.0)))
            (set-setting! 'string-min-length 'abs (* f30-2 (-> this info camera-string-min-length)) 0)
            (set-setting! 'string-max-length 'abs (* f30-2 (-> this info camera-string-max-length)) 0)
            )
          )
        )
      (when *target*
        (let ((v1-83 (-> *target* draw shadow-ctrl settings shadow-dir quad)))
          (set! (-> this draw shadow-ctrl settings shadow-dir quad) v1-83)
          )
        (cond
          ((logtest? (rigid-body-object-flag camera-rapid-track-mode) (-> this flags))
           (.lvf vf1 (&-> (-> this root transv) quad))
           (.add.w.vf vf2 vf0 vf0 :mask #b1)
           (.mul.vf vf1 vf1 vf1)
           (.mul.x.vf acc vf2 vf1 :mask #b1)
           (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
           (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
           (.mov v1-88 vf1)
           (let ((f0-20 v1-88)
                 (f1-13 122880.0)
                 )
             (if (< f0-20 (* f1-13 f1-13))
                 (vehicle-method-92 this)
                 )
             )
           )
          (else
            (let* ((f0-21 143360.0)
                   (f0-23 (* f0-21 f0-21))
                   )
              (.lvf vf1 (&-> (-> this root transv) quad))
              (.add.w.vf vf2 vf0 vf0 :mask #b1)
              (.mul.vf vf1 vf1 vf1)
              (.mul.x.vf acc vf2 vf1 :mask #b1)
              (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
              (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
              (.mov v1-98 vf1)
              (if (< f0-23 v1-98)
                  (vehicle-method-91 this)
                  )
              )
            )
          )
        (let ((v1-102 (math-camera-matrix))
              (a0-39 (new 'stack-no-clear 'vehicle-control-point))
              )
          (set! (-> a0-39 normal quad) (-> *target* alt-cam-pos quad))
          (vector-! (-> a0-39 local-pos) (-> a0-39 normal) (-> v1-102 trans))
          (let ((f0-26 (/ (vector-dot (-> a0-39 local-pos) (-> v1-102 vector 1))
                          (vector-dot (-> a0-39 local-pos) (-> v1-102 vector 2))
                          )
                       )
                )
            (cond
              ((and (< f0-26 0.15) (< -0.5 f0-26))
               (set-setting! 'vertical-follow-matches-camera #f 0.0 0)
               )
              (else
                (if (< (fabs (-> this root transv y)) 8192.0)
                    (remove-setting! 'vertical-follow-matches-camera)
                    )
                )
              )
            )
          )
        )
      0
      )
    0
    (none)
    )
  )

(defmethod vehicle-method-120 vehicle ((this vehicle))
  (let ((s5-0 (-> this draw shadow-ctrl)))
    (when (!= *vehicle-shadow-control-disabled* s5-0)
      (let ((f30-0 (vector-vector-xz-distance (camera-pos) (-> this root trans))))
        (cond
          ((< 245760.0 f30-0)
           (logior! (-> s5-0 settings flags) (shadow-flags disable-draw))
           0
           (set! (-> this draw bounds w) (-> this bound-radius))
           )
          (else
            (let ((s4-1 (-> this root)))
              (when (or (logtest? (-> s5-0 settings flags) (shadow-flags disable-draw))
                        (= (-> this controller traffic sync-mask-8) (ash 1 (logand (-> this traffic-priority-id) 7)))
                        )
                (let ((s3-0 (new 'stack-no-clear 'collide-query)))
                  (logclear! (-> s4-1 status) (collide-status on-ground))
                  (cond
                    ((above-ground? s4-1 s3-0 (-> s4-1 trans) (collide-spec backgnd) 0.0 102400.0 1024.0)
                     (set! (-> s4-1 gspot-pos quad) (-> s4-1 trans quad))
                     (set! (-> s4-1 gspot-pos y) (-> s3-0 best-other-tri intersect y))
                     (set! (-> s4-1 gspot-normal quad) (-> s3-0 best-other-tri normal quad))
                     (set! (-> s4-1 ground-pat) (-> s3-0 best-other-tri pat))
                     (when (logtest? (-> s5-0 settings flags) (shadow-flags disable-draw))
                       (set! (-> s5-0 settings top-plane w) (- (-> s5-0 settings center y) (-> this root gspot-pos y)))
                       (set! (-> s5-0 settings bot-plane w) (- (-> s5-0 settings center y) (-> this root gspot-pos y)))
                       )
                     (let ((v1-29 s5-0))
                       (logclear! (-> v1-29 settings flags) (shadow-flags disable-draw))
                       )
                     0
                     )
                    (else
                      (let ((v1-31 s5-0))
                        (logior! (-> v1-31 settings flags) (shadow-flags disable-draw))
                        )
                      0
                      )
                    )
                  )
                )
              )
            (set! (-> this draw bounds w) (lerp-scale
                                            (- (-> s5-0 settings center y) (-> this root gspot-pos y))
                                            (-> this bound-radius)
                                            f30-0
                                            81920.0
                                            122880.0
                                            )
                  )
            (if (< (-> this draw bounds w) (-> this bound-radius))
                (set! (-> this draw bounds w) (-> this bound-radius))
                )
            (let* ((f0-13 (lerp-scale 0.0 1.0 f30-0 245760.0 40960.0))
                   (f30-1 (* 4096.0 (+ 5.0 (* 5.0 (- 1.0 (-> this root gspot-normal y))))))
                   (f28-0 (- (-> s5-0 settings center y) (-> this root gspot-pos y)))
                   (f0-16 (fmax 0.01 (+ (* -2.0 f0-13 f0-13 f0-13) (* 3.0 f0-13 f0-13))))
                   )
              (set! (-> s5-0 settings shadow-dir w) (+ 20480.0 (* 409600.0 f0-16) f28-0))
              (let ((f26-0 (+ 0.5 f0-16)))
                (seek! (-> s5-0 settings top-plane w) (+ f28-0 (* f26-0 (- f30-1))) (* 81920.0 (seconds-per-frame)))
                (seek! (-> s5-0 settings bot-plane w) (+ f28-0 (* f26-0 f30-1)) (* 81920.0 (seconds-per-frame)))
                )
              )
            )
          )
        )
      )
    )
  (set! (-> this vehicle-jkhn1b23jn1) (the-as int (-> this flags)))
  (ja-post)
  0
  (none)
  )

(defmethod rigid-body-object-method-51 vehicle ((this vehicle))
  (let ((s5-0 (new 'stack-no-clear 'collide-query)))
    (let ((f30-0 -4096000.0))
      (set! (-> s5-0 start-pos quad) (-> this rbody state position quad))
      (vector-float*! (-> s5-0 move-dist) (-> this rbody state lin-velocity) (seconds-per-frame))
      (let ((v1-4 s5-0))
        (set! (-> v1-4 radius) (+ 4096.0 (-> this root root-prim local-sphere w)))
        (set! (-> v1-4 collide-with)
              (collide-spec
                backgnd
                crate
                civilian
                enemy
                obstacle
                vehicle-sphere
                hit-by-player-list
                hit-by-others-list
                collectable
                blocking-plane
                pusher
                vehicle-mesh-probeable
                )
              )
        (set! (-> v1-4 ignore-process0) this)
        (set! (-> v1-4 ignore-process1) #f)
        (set! (-> v1-4 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1))
        (set! (-> v1-4 action-mask) (collide-action solid))
        )
      (if (focus-test? this dead)
          (set! (-> s5-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
          )
      (if (logtest? (-> this flags) (rigid-body-object-flag player-touching))
          (logclear! (-> s5-0 collide-with) (collide-spec jak player-list))
          )
      (let ((s4-0 (new 'stack-no-clear 'water-info)))
        (water-info-init! (-> this root) s4-0 (collide-action solid semi-solid))
        (if (and (logtest? (-> s4-0 flags) (water-flags active)) (logtest? (water-flags over-water) (-> s4-0 flags)))
            (set! f30-0 (-> s4-0 base-height))
            )
        )
      (set! (-> this water-height) f30-0)
      (when (< (- (+ (-> s5-0 start-pos y) (fmin 0.0 (-> s5-0 move-dist y))) (-> s5-0 radius)) f30-0)
        (let ((v1-23
                (new 'static 'water-control :flags (water-flags active swim-ground can-ground over-water) :joint-index 3)
                )
              )
          (logior! (-> s5-0 collide-with) (collide-spec water))
          (set! (-> v1-23 height) f30-0)
          (set! (-> v1-23 collide-height) f30-0)
          (set! (-> this water) v1-23)
          )
        )
      )
    (fill-using-line-sphere *collide-cache* s5-0)
    )
  (set! (-> this water) (the-as water-control 0))
  0
  (rigid-body-control-method-10
    (-> this rbody)
    this
    (-> this rbody state time-remaining)
    (-> this max-time-step)
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-52 vehicle ((this vehicle))
  (with-pp
    (let ((v1-0 (new 'stack-no-clear 'vehicle-control-point)))
      (set! (-> v1-0 local-pos quad) (-> this root transv quad))
      (vector-! (-> v1-0 normal) (-> this rbody state lin-velocity) (-> v1-0 local-pos))
      (vector-float*! (-> this lin-acceleration) (-> v1-0 normal) (-> pp clock frames-per-second))
      )
    (set! (-> this root transv quad) (-> this rbody state lin-velocity quad))
    (quaternion-copy! (-> this root quat) (-> this rbody state rotation))
    (let ((v1-6 (-> this rbody))
          (a1-7 (-> this root trans))
          )
      (rigid-body-method-23 (-> v1-6 state) a1-7)
      )
    (let* ((v1-11 (-> this node-list data 0 bone transform))
           (a3-0 (-> this rbody state matrix))
           (a0-13 (-> a3-0 quad 0))
           (a1-8 (-> a3-0 quad 1))
           (a2-1 (-> a3-0 quad 2))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-11 quad 0) a0-13)
      (set! (-> v1-11 quad 1) a1-8)
      (set! (-> v1-11 quad 2) a2-1)
      (set! (-> v1-11 trans quad) a3-1)
      )
    (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
    (vehicle-method-119 this)
    (let ((f0-1 (-> this player-dist2))
          (f1-0 245760.0)
          )
      (if (< f0-1 (* f1-0 f1-0))
          (do-engine-sounds this)
          )
      )
    (when (logtest? (-> this draw status) (draw-control-status on-screen))
      (if #t
          (draw-thrusters this)
          )
      (let ((f0-2 (-> this camera-dist2))
            (f1-3 245760.0)
            )
        (if (< f0-2 (* f1-3 f1-3))
            (update-joint-mods this)
            )
        )
      )
    (vehicle-method-120 this)
    (let ((s5-0 (-> this root)))
      (update-transforms s5-0)
      (when (and (logtest? (-> this flags) (rigid-body-object-flag player-touching))
                 (not (logtest? (-> this flags) (rigid-body-object-flag player-driving)))
                 )
        (pull-riders! s5-0)
        (cond
          ((logtest? (do-push-aways s5-0) (collide-spec jak))
           (+! (-> this overlap-player-counter) 1)
           (when (< (the-as uint 60) (-> this overlap-player-counter))
             (send-event
               *target*
               'attack-invinc
               #f
               (static-attack-info ((id (new-attack-id)) (mode 'smush) (damage 1000.0)))
               )
             (set! (-> this overlap-player-counter) (the-as uint 0))
             0
             )
           )
          (else
            (set! (-> this overlap-player-counter) (the-as uint 0))
            0
            )
          )
        )
      )
    (if (and (logtest? (-> this flags) (rigid-body-object-flag dead))
             (not (logtest? (-> this focus-status) (focus-status dead)))
             )
        (go (method-of-object this crash))
        )
    (if (logtest? (rigid-body-object-flag nav-spheres) (-> this flags))
        (vehicle-method-143 this)
        )
    (seek! (-> this scrape-sound-envelope) 0.0 (* 2.0 (seconds-per-frame)))
    (mem-copy! (the-as pointer (-> this prev-controls)) (the-as pointer (-> this controls)) 16)
    (logclear! (-> this flags) (rigid-body-object-flag player-impulse-force player-contact-force jump))
    0
    (none)
    )
  )

(defmethod vehicle-method-121 vehicle ((this vehicle))
  (if (time-elapsed? (-> this player-touch-time) (seconds 0.1))
      (logclear! (-> this flags) (rigid-body-object-flag player-touching player-edge-grabbing player-standing-on))
      )
  (when (logtest? (-> this flags) (rigid-body-object-flag player-touching))
    (detect-riders! (-> this root))
    0
    )
  (if (logtest? (-> this flags) (rigid-body-object-flag player-touching player-driving))
      (logior! (-> this skel status) (joint-control-status sync-math))
      (logclear! (-> this skel status) (joint-control-status sync-math))
      )
  (vehicle-method-96 this)
  (let ((a1-0 (-> this rbody state position)))
    (set! (-> this flight-level) (get-height-at-point *traffic-height-map* a1-0))
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-37 vehicle ((this vehicle))
  (local-vars (a0-14 int) (a0-16 int) (a0-19 int) (a0-21 int))
  (let* ((v1-1 (-> *perf-stats* data 37))
         (a0-1 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-1) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-1)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (set! (-> this camera-dist2) (vector-vector-distance-squared (-> this root trans) (camera-pos)))
  (set! (-> this player-dist2) (vector-vector-distance-squared (-> this root trans) (target-pos 0)))
  (cond
    ((logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
     (if (not (vehicle-method-105 this))
         (rigid-body-object-method-39 this)
         )
     )
    (else
      (if (vehicle-method-105 this)
          (rigid-body-object-method-38 this)
          )
      )
    )
  (cond
    ((logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
     (vehicle-method-121 this)
     (vehicle-method-106 this)
     )
    (else
      (let* ((v1-26 (-> *perf-stats* data 20))
             (a0-11 (-> v1-26 ctrl))
             )
        (+! (-> v1-26 count) 1)
        (b! (zero? a0-11) cfg-12 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-11)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-12)
      0
      (vehicle-method-120 this)
      (let ((v1-31 (-> *perf-stats* data 20)))
        (b! (zero? (-> v1-31 ctrl)) cfg-14 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-14 pcr0)
        (+! (-> v1-31 accum0) a0-14)
        (.mfpc a0-16 pcr1)
        (+! (-> v1-31 accum1) a0-16)
        )
      (label cfg-14)
      0
      )
    )
  (let ((v1-34 (-> *perf-stats* data 37)))
    (b! (zero? (-> v1-34 ctrl)) cfg-17 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-19 pcr0)
    (+! (-> v1-34 accum0) a0-19)
    (.mfpc a0-21 pcr1)
    (+! (-> v1-34 accum1) a0-21)
    )
  (label cfg-17)
  0
  0
  (none)
  )

(defmethod vehicle-method-123 vehicle ((this vehicle))
  (local-vars (v1-4 symbol) (a0-21 int) (a0-23 int))
  (set! (-> this camera-dist2) (vector-vector-distance-squared (-> this root trans) (camera-pos)))
  (set! (-> this player-dist2) (vector-vector-distance-squared (-> this root trans) (target-pos 0)))
  (b!
    (not (logtest? (rigid-body-object-flag traffic-managed) (-> this flags)))
    cfg-3
    :likely-delay (set! v1-4 #f)
    )
  (set! v1-4 (not (logtest? (-> this flags) (rigid-body-object-flag persistent))))
  (label cfg-3)
  (b! (not v1-4) cfg-20 :delay (empty-form))
  (let ((f0-3 (fmin (-> this player-dist2) (-> this camera-dist2))))
    (let ((f1-1 819200.0))
      (b! (>= (* f1-1 f1-1) f0-3) cfg-8)
      )
    (let ((f1-4 819200.0))
      (if (< (* f1-4 f1-4) f0-3)
          (vehicle-method-113 this)
          )
      )
    (b! #t cfg-19 :delay (nop!))
    (label cfg-8)
    (let ((f1-7 81920.0))
      (b! (>= (* f1-7 f1-7) f0-3) cfg-18)
      )
    (b! (not (logtest? (-> this draw status) (draw-control-status on-screen))) cfg-11 :delay (nop!))
    (set-time! (-> this state-time))
    (b! #t cfg-17 :delay (nop!))
    (label cfg-11)
    (if (or (time-elapsed? (-> this state-time) (seconds 10)) (let ((f1-10 409600.0))
                                                                (< (* f1-10 f1-10) f0-3)
                                                                )
            )
        (vehicle-method-113 this)
        )
    )
  (label cfg-17)
  (b! #t cfg-19 :delay (nop!))
  (label cfg-18)
  (set-time! (-> this state-time))
  (label cfg-19)
  0
  (label cfg-20)
  (check-player-get-on this)
  (b! (not (logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))) cfg-24 :delay (nop!))
  (if (not (vehicle-method-105 this))
      (rigid-body-object-method-39 this)
      )
  (b! #t cfg-26 :delay (nop!))
  (label cfg-24)
  (if (vehicle-method-105 this)
      (rigid-body-object-method-38 this)
      )
  (label cfg-26)
  (b! (not (logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))) cfg-31 :delay (nop!))
  (vector-reset! (-> this target-acceleration))
  (when (logtest? (-> this flags) (rigid-body-object-flag disturbed))
    (if (logtest? (-> this flags) (rigid-body-object-flag in-air))
        (set-time! (-> this disturbed-time))
        )
    )
  (vehicle-method-121 this)
  (vehicle-method-106 this)
  (b! #t cfg-36 :delay (nop!))
  (label cfg-31)
  (let* ((v1-65 (-> *perf-stats* data 20))
         (a0-18 (-> v1-65 ctrl))
         )
    (+! (-> v1-65 count) 1)
    (b! (zero? a0-18) cfg-33 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-18)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-33)
  0
  (vehicle-method-120 this)
  (let ((v1-70 (-> *perf-stats* data 20)))
    (b! (zero? (-> v1-70 ctrl)) cfg-35 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-21 pcr0)
    (+! (-> v1-70 accum0) a0-21)
    (.mfpc a0-23 pcr1)
    (+! (-> v1-70 accum1) a0-23)
    )
  (label cfg-35)
  0
  (label cfg-36)
  0
  (none)
  )

(defmethod vehicle-method-122 vehicle ((this vehicle))
  (local-vars (a0-23 int) (a0-25 int) (a0-35 int) (a0-37 int) (a0-40 int) (a0-42 int))
  (let* ((v1-1 (-> *perf-stats* data 37))
         (a0-1 (-> v1-1 ctrl))
         )
    (+! (-> v1-1 count) 1)
    (b! (zero? a0-1) cfg-2 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mtpc pcr0 0)
    (.mtpc pcr1 0)
    (.sync.l)
    (.sync.p)
    (.mtc0 Perf a0-1)
    )
  (.sync.l)
  (.sync.p)
  (label cfg-2)
  0
  (set! (-> this camera-dist2) (vector-vector-distance-squared (-> this root trans) (camera-pos)))
  (set! (-> this player-dist2) (vector-vector-distance-squared (-> this root trans) (target-pos 0)))
  (vehicle-controller-method-18
    (-> this controller)
    (-> this target-acceleration)
    (-> this root transv)
    this
    (/ 1.0 (seconds-per-frame))
    )
  (cond
    ((logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
     (if (not (vehicle-method-105 this))
         (rigid-body-object-method-39 this)
         )
     )
    (else
      (if (vehicle-method-105 this)
          (rigid-body-object-method-38 this)
          )
      )
    )
  (cond
    ((logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
     (vehicle-method-93 this)
     (vehicle-method-106 this)
     (vehicle-method-121 this)
     )
    (else
      (let ((f1-3 (* 0.000024414063
                     (vector-dot (the-as vector (-> this node-list data 0 bone transform)) (-> this target-acceleration))
                     )
                  )
            )
        (+! (-> this controls steering) (* 0.1 (- f1-3 (-> this controls steering))))
        )
      (set! (-> this controls steering) (fmax -1.0 (fmin 1.0 (-> this controls steering))))
      (let* ((v1-42 (-> *perf-stats* data 19))
             (a0-14 (-> v1-42 ctrl))
             )
        (+! (-> v1-42 count) 1)
        (b! (zero? a0-14) cfg-12 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-14)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-12)
      0
      (vehicle-method-104 this)
      (let ((f0-9 (-> this player-dist2))
            (f1-8 245760.0)
            )
        (when (< f0-9 (* f1-8 f1-8))
          (let ((f0-10 (vector-length (-> this root transv))))
            (seek! (-> this engine-power-factor) (* 0.000016276043 f0-10) (* 6.0 (seconds-per-frame)))
            )
          (do-engine-sounds this)
          )
        )
      (when (logtest? (-> this draw status) (draw-control-status on-screen))
        (when #t
          (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
          (draw-thrusters this)
          )
        )
      (let ((v1-70 (-> *perf-stats* data 19)))
        (b! (zero? (-> v1-70 ctrl)) cfg-19 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-23 pcr0)
        (+! (-> v1-70 accum0) a0-23)
        (.mfpc a0-25 pcr1)
        (+! (-> v1-70 accum1) a0-25)
        )
      (label cfg-19)
      0
      (let* ((v1-73 (-> *perf-stats* data 20))
             (a0-27 (-> v1-73 ctrl))
             )
        (+! (-> v1-73 count) 1)
        (b! (zero? a0-27) cfg-21 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mtpc pcr0 0)
        (.mtpc pcr1 0)
        (.sync.l)
        (.sync.p)
        (.mtc0 Perf a0-27)
        )
      (.sync.l)
      (.sync.p)
      (label cfg-21)
      0
      (vehicle-method-120 this)
      (update-transforms (-> this root))
      (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
      (vehicle-method-119 this)
      (let ((v1-85 (-> *perf-stats* data 20)))
        (b! (zero? (-> v1-85 ctrl)) cfg-23 :delay (nop!))
        (.mtc0 Perf 0)
        (.sync.l)
        (.sync.p)
        (.mfpc a0-35 pcr0)
        (+! (-> v1-85 accum0) a0-35)
        (.mfpc a0-37 pcr1)
        (+! (-> v1-85 accum1) a0-37)
        )
      (label cfg-23)
      0
      )
    )
  (let ((v1-88 (-> *perf-stats* data 37)))
    (b! (zero? (-> v1-88 ctrl)) cfg-26 :delay (nop!))
    (.mtc0 Perf 0)
    (.sync.l)
    (.sync.p)
    (.mfpc a0-40 pcr0)
    (+! (-> v1-88 accum0) a0-40)
    (.mfpc a0-42 pcr1)
    (+! (-> v1-88 accum1) a0-42)
    )
  (label cfg-26)
  0
  0
  (none)
  )

(defmethod vehicle-method-124 vehicle ((this vehicle))
  ;; og:preserve-this vehicle hp display cheat
  (#when PC_PORT
    (when (pc-cheats? (-> *pc-settings* cheats) vehicle-health-bars)
        (when (and *target* (focus-test? *target* pilot) (nonzero? (-> *target* pilot)))
          (when (= (handle->process (-> *target* pilot vehicle)) this)
            (let ((x 0) (y 0)
                  (w 0) (h 0)
                  (screen-pos (new 'static 'vector4w)))

            ;; convert 3D -> 2D screen now (store result in screen-pos)
            (when (transform-point-qword! screen-pos (-> *target* root trans))

              ;; set params
              (set! w (the int (* 52.0 (-> *video-params* relative-x-scale))))
              (set! h (the int 10.0))
              (set! x (- (+ (/ (-> screen-pos x) 16) -1792) (/ w 2)))
              (set! y (+ (+ (/ (-> screen-pos y) 16) -1855) 20))
              
              (draw-health-bar x y w h (-> this hit-points) (bucket-id debug-no-zbuf1))
              )))
          )
        )
    )
  (vehicle-method-94 this)
  (vehicle-method-121 this)
  (vehicle-method-97 this)
  0
  (none)
  )

(defmethod alloc-and-init-rigid-body-control vehicle ((this vehicle) (arg0 rigid-body-vehicle-constants))
  (if (logtest? (-> arg0 flags) 8)
      (iterate-prims
        (-> this root)
        (lambda ((arg0 collide-shape-prim))
          (case (-> arg0 prim-core prim-type)
            (((prim-type sphere))
             (set! (-> arg0 prim-core collide-with)
                   (collide-spec
                     backgnd
                     crate
                     civilian
                     enemy
                     obstacle
                     vehicle-sphere
                     hit-by-player-list
                     hit-by-others-list
                     collectable
                     pusher
                     )
                   )
             (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere))
             )
            (((prim-type mesh))
             (set! (-> arg0 prim-core collide-with) (collide-spec jak player-list))
             (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-mesh))
             )
            (((prim-type group))
             (set! (-> arg0 prim-core collide-with)
                   (collide-spec
                     backgnd
                     jak
                     crate
                     civilian
                     enemy
                     obstacle
                     vehicle-sphere
                     hit-by-player-list
                     hit-by-others-list
                     player-list
                     collectable
                     pusher
                     )
                   )
             (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
             )
            )
          (none)
          )
        )
      (iterate-prims
        (-> this root)
        (lambda ((arg0 collide-shape-prim))
          (set! (-> arg0 prim-core collide-with) (collide-spec
                                                   backgnd
                                                   jak
                                                   crate
                                                   civilian
                                                   enemy
                                                   obstacle
                                                   vehicle-sphere
                                                   hit-by-player-list
                                                   hit-by-others-list
                                                   player-list
                                                   collectable
                                                   pusher
                                                   )
                )
          (set! (-> arg0 prim-core collide-as) (collide-spec vehicle-sphere vehicle-mesh))
          (none)
          )
        )
      )
  (set! (-> this bound-radius) (-> this draw bounds w))
  (if (-> this draw shadow)
      (set! (-> this draw shadow-ctrl)
            (new 'process 'shadow-control -2048.0 -61440.0 69632.0 (shadow-flags shdf03) 245760.0)
            )
      (set! (-> this draw shadow-ctrl) *vehicle-shadow-control-disabled*)
      )
  (logior! (-> this root root-prim prim-core action) (collide-action pull-rider-can-collide))
  (set! (-> this root pat-ignore-mask) (new 'static 'pat-surface :noentity #x1 :nopilot #x1 :probe #x1))
  (set! (-> this root event-self) 'touched)
  (let ((t9-3 (method-of-type rigid-body-object alloc-and-init-rigid-body-control)))
    (t9-3 this arg0)
    )
  (logior! (-> this rbody state flags) (rigid-body-flag enable-collision))
  (set! (-> this root max-iteration-count) (the-as uint 8))
  (set! (-> this max-time-step) 0.033333335)
  (logior! (-> this mask) (process-mask vehicle))
  (logclear! (-> this mask) (process-mask actor-pause movie))
  (logclear! (-> this skel status) (joint-control-status sync-math))
  (process-entity-status! this (entity-perm-status no-kill) #t)
  (set! (-> this nav) #f)
  (let ((v1-32 (-> this root root-prim)))
    (set! (-> this root backup-collide-as) (-> v1-32 prim-core collide-as))
    (set! (-> this root backup-collide-with) (-> v1-32 prim-core collide-with))
    )
  (rigid-body-object-method-40 this)
  (vehicle-controller-method-9 (-> this controller))
  (vehicle-method-82 this)
  (set! (-> this power-level) 0.5)
  (set! (-> this lights-factor) 0.0)
  (set! (-> this jump-thrust) 1.0)
  (set! (-> this turbo-boost-factor) 1.0)
  (dotimes (v1-43 4)
    (set! (-> this rider-array v1-43) (the-as handle #f))
    )
  (set! (-> this engine-sound-id) (new 'static 'sound-id))
  (set! (-> this thrust-sound-id) (new 'static 'sound-id))
  (set! (-> this roll-sound-id) (new 'static 'sound-id))
  (set! (-> this scrape-sound-id) (new 'static 'sound-id))
  (set! (-> this extra-sound-id) (new 'static 'sound-id))
  (set! (-> this damage-zap-sound-id) (new-sound-id))
  (set! (-> this damage-pop-sound-id) (new-sound-id))
  (set! (-> this controller target-speed-offset) (* (rand-vu) (-> arg0 target-speed-offset)))
  (set! (-> this draw lod-set lod 0 dist) 122880.0)
  (set! (-> this draw lod-set lod 1 dist) 204800.0)
  (set! (-> this draw lod-set lod 2 dist) 819200.0)
  (if (zero? (-> this draw light-index))
      (set! (-> this draw light-index) (the-as uint 10))
      )
  (rigid-body-queue-method-11
    (if (logtest? (-> this info flags) 1024)
        *race-rigid-body-queue*
        *traffic-rigid-body-queue*
        )
    this
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-47 vehicle ((this vehicle) (arg0 process-drawable) (arg1 attack-info) (arg2 touching-shapes-entry) (arg3 penetrate))
  (local-vars (f0-2 float) (sv-96 vector))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (rigid-body-object-method-49 this (the-as rigid-body-impact s5-0) arg2)
      (cond
        ((logtest? (attack-mask attacker-velocity) (-> arg1 mask))
         (set! (-> s5-0 vector 2 quad) (-> arg1 attacker-velocity quad))
         )
        (else
          (let ((s0-0 arg0))
            (cond
              ((if (type? s0-0 process-focusable)
                   (the-as process-focusable s0-0)
                   )
               (set! sv-96 (-> s5-0 vector 2))
               (let ((s0-1 (-> s5-0 vector))
                     (v1-7 (get-trans (the-as process-focusable arg0) 3))
                     )
                 (.lvf vf4 (&-> s0-1 0 quad))
                 (.lvf vf5 (&-> v1-7 quad))
                 )
               (.mov.vf vf6 vf0 :mask #b1000)
               (.sub.vf vf6 vf4 vf5 :mask #b111)
               (.svf (&-> sv-96 quad) vf6)
               )
              (else
                (vector-! (-> s5-0 vector 2) (the-as vector (-> s5-0 vector)) (-> arg0 root trans))
                )
              )
            )
          )
        )
      0.0
      0.0
      (let ((f1-0 (cond
                    ((= (-> arg1 mode) 'mine)
                     (set! f0-2 20480.0)
                     0.2
                     )
                    ((or (logtest? (penetrate dark-giant) arg3)
                         (and (logtest? (-> arg1 mask) (attack-mask mode)) (= (-> arg1 mode) 'eco-dark))
                         )
                     (set! (-> s5-0 vector 2 y) (* 0.1 (-> s5-0 vector 2 y)))
                     (set! f0-2 (* 409600.0 (-> this info info mass)))
                     (/ 0.4 (-> this info damage-factor))
                     )
                    ((or (logtest? (penetrate dark-punch dark-bomb) arg3)
                         (and (logtest? (penetrate dark-skin) arg3) (logtest? arg3 (penetrate punch spin)))
                         )
                     (set! f0-2 (* 204800.0 (-> this info info mass)))
                     (/ 0.2 (-> this info damage-factor))
                     )
                    ((logtest? (penetrate enemy-yellow-shot) arg3)
                     (set! f0-2 49152.0)
                     0.025
                     )
                    ((logtest? (penetrate jak-yellow-shot) arg3)
                     (set! f0-2 98304.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-blue-shot) arg3)
                     (set! f0-2 196608.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-red-shot) arg3)
                     (set! f0-2 196608.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-dark-shot enemy-dark-shot) arg3)
                     (set! f0-2 393216.0)
                     0.5
                     )
                    ((or (logtest? (penetrate explode) arg3)
                         (and (logtest? (-> arg1 mask) (attack-mask mode)) (case (-> arg1 mode)
                                                                             (('explode 'grenade 'melt 'ice)
                                                                              #t
                                                                              )
                                                                             )
                              )
                         )
                     (set! f0-2 122880.0)
                     1.0
                     )
                    ((logtest? arg3 (penetrate punch))
                     (set! f0-2 40960.0)
                     0.1
                     )
                    ((logtest? arg3 (penetrate flop spin))
                     (set! f0-2 20480.0)
                     0.05
                     )
                    (else
                      (set! f0-2 8192.0)
                      0.01
                      )
                    )
                  )
            )
        (set! (-> s5-0 trans x) f0-2)
        (apply-damage this (* 0.667 f1-0) (the-as rigid-body-impact s5-0))
        )
      (rigid-body-object-method-42 this)
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (set! (-> s3-1 quad) (-> s5-0 vector 2 quad))
        (vector-normalize! s3-1 1.0)
        (vector-float*! s3-1 s3-1 (-> s5-0 trans x))
        (let ((v1-90 (-> this rbody))
              (a1-11 (-> s5-0 vector))
              (a2-3 s3-1)
              )
          (rigid-body-method-18 (-> v1-90 state) (the-as vector a1-11) a2-3)
          )
        (let ((v1-93 (-> this rbody))
              (f0-10 1.0)
              )
          (rigid-body-method-12 (-> v1-93 state) f0-10)
          )
        (rigid-body-method-13 (-> this rbody state))
        (when #f
          (set-time! (-> *debug-vehicle-work* impact-time))
          (mem-copy! (the-as pointer (-> *debug-vehicle-work* impact)) (the-as pointer s5-0) 64)
          (let ((v1-103 (-> arg2 head)))
            (set! (-> *debug-vehicle-work* prim-sphere1 quad) (-> v1-103 prim1 cprim prim-core world-sphere quad))
            (set! (-> *debug-vehicle-work* prim-sphere2 quad) (-> v1-103 prim2 cprim prim-core world-sphere quad))
            )
          (add-debug-x #t (bucket-id debug-no-zbuf1) (the-as vector (-> s5-0 vector)) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (the-as vector (-> s5-0 vector))
            s3-1
            (meters 0.00024414062)
            *color-blue*
            )
          )
        )
      (rigid-body-object-method-45 this (the-as rigid-body-impact s5-0))
      )
    (if (and (-> this next-state) (= (-> this next-state name) 'idle))
        (go (method-of-object this waiting))
        )
    #t
    )
  )

(defmethod rigid-body-object-method-48 vehicle ((this vehicle) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (v1-2 symbol) (v1-30 symbol) (a0-19 object))
  (with-pp
    (b!
      (not (logtest? (process-mask target crate enemy guard civilian) (-> arg0 mask)))
      cfg-5
      :likely-delay (set! v1-2 #t)
      )
    (b! (not (logtest? (-> arg0 mask) (process-mask target))) cfg-5 :likely-delay (set! v1-2 #f))
    (set! v1-2 (focus-test? arg0 dangerous pilot))
    (label cfg-5)
    (b! v1-2 cfg-32 :delay (nop!))
    (let ((s5-0 (new 'stack-no-clear 'rigid-body-impact)))
      (let ((s2-0 (new 'stack-no-clear 'vector)))
        (let ((f30-0 (get-inv-mass arg0)))
          (rigid-body-object-method-49 this s5-0 arg1)
          (cond
            ((logtest? (-> this rbody state flags) (rigid-body-flag enable-physics))
             (let ((v1-14 (-> this rbody))
                   (a1-3 (-> s5-0 point))
                   (a2-2 (-> s5-0 velocity))
                   )
               (rigid-body-method-22 (-> v1-14 state) a1-3 a2-2)
               )
             )
            (else
              (set! (-> s5-0 velocity quad) (-> this root transv quad))
              )
            )
          (let ((v1-18 (-> arg0 root)))
            (set! (-> s2-0 quad) (-> v1-18 transv quad))
            (vector-! (-> s5-0 velocity) (-> v1-18 transv) (-> s5-0 velocity))
            )
          (let ((f0-1 (vector-dot (-> s5-0 velocity) (-> s5-0 normal))))
            (b! (>= f0-1 0.0) cfg-32 :delay #f)
            (set! (-> s5-0 impulse) (/ f0-1 (+ f30-0 (-> this info info inv-mass))))
            )
          (vector+float*! s2-0 s2-0 (-> s5-0 normal) (* -3.1 f30-0 (-> s5-0 impulse)))
          (set! (-> s2-0 y) (fmax (* 49152.0 f30-0) (-> s2-0 y)))
          )
        (b! (logtest? (rigid-body-object-flag in-pursuit) (-> this flags)) cfg-13 :likely-delay (set! v1-30 #t))
        (set! v1-30 (!= arg0 *target*))
        (label cfg-13)
        (b! (not v1-30) cfg-25 :delay (empty-form))
        (when (time-elapsed? (-> this sent-attack-time) (seconds 0.5))
          (set-time! (-> this sent-attack-time))
          (let* ((v1-39 *game-info*)
                 (a0-18 (+ (-> v1-39 attack-id) 1))
                 )
            (set! (-> v1-39 attack-id) a0-18)
            (set! (-> this outgoing-attack-id) a0-18)
            )
          )
        (let ((f30-1 (+ 0.5 (* 0.000024414063 (- (-> s5-0 impulse)))))
              (s1-0 (new 'stack-no-clear 'event-message-block))
              )
          (let ((v1-42 pp))
            (b! (not v1-42) cfg-18 :delay (set! a0-19 #f))
            (set! a0-19 (-> v1-42 ppointer))
            )
          (label cfg-18)
          (set! (-> s1-0 from) (the-as (pointer process) a0-19))
          (set! (-> s1-0 num-params) 2)
          (set! (-> s1-0 message) 'attack)
          (set! (-> s1-0 param 0) (the-as uint arg1))
          (set! (-> s1-0 param 1)
                (the-as uint (static-attack-info ((id (-> this outgoing-attack-id))
                                                  (attacker (process->handle (vehicle-method-70 this)))
                                                  (mode 'vehicle)
                                                  (vector s2-0)
                                                  (penetrate-using (penetrate vehicle))
                                                  (damage f30-1)
                                                  )
                                                 )
                        )
                )
          (b! (not (send-event-function arg0 s1-0)) cfg-25 :delay (empty-form))
          )
        )
      (label cfg-25)
      (rigid-body-object-method-42 this)
      (let ((a2-4 (new 'stack-no-clear 'vector)))
        (vector-float*! a2-4 (-> s5-0 normal) (-> s5-0 impulse))
        (let ((v1-60 (-> this rbody))
              (a1-9 (-> s5-0 point))
              )
          (rigid-body-method-18 (-> v1-60 state) a1-9 a2-4)
          )
        )
      (let ((v1-63 (-> this rbody))
            (f0-11 1.0)
            )
        (rigid-body-method-12 (-> v1-63 state) f0-11)
        )
      (rigid-body-method-13 (-> this rbody state))
      (when #f
        (set-time! (-> *debug-vehicle-work* impact-time))
        (mem-copy! (the-as pointer (-> *debug-vehicle-work* impact)) (the-as pointer s5-0) 64)
        (let ((v1-73 (-> arg1 head)))
          (set! (-> *debug-vehicle-work* prim-sphere1 quad) (-> v1-73 prim1 cprim prim-core world-sphere quad))
          (set! (-> *debug-vehicle-work* prim-sphere2 quad) (-> v1-73 prim2 cprim prim-core world-sphere quad))
          )
        (add-debug-x #t (bucket-id debug-no-zbuf1) (-> s5-0 point) *color-blue*)
        (add-debug-vector
          #t
          (bucket-id debug-no-zbuf1)
          (-> s5-0 point)
          (-> s5-0 normal)
          (- (-> s5-0 impulse))
          *color-blue*
          )
        )
      (rigid-body-object-method-45 this s5-0)
      )
    (b! (not (and (-> this next-state) (= (-> this next-state name) 'idle))) cfg-32 :delay (empty-form))
    (go (method-of-object this waiting))
    (label cfg-32)
    #t
    )
  )

(defmethod rigid-body-object-method-46 vehicle ((this vehicle) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (when (and (= arg2 'touched) arg0 (logtest? (process-mask bit18) (-> arg0 mask)))
    (dotimes (s1-0 4)
      (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-2 from) (process->ppointer arg0))
        (set! (-> a1-2 num-params) arg1)
        (set! (-> a1-2 message) arg2)
        (set! (-> a1-2 param 0) (-> arg3 param 0))
        (set! (-> a1-2 param 1) (-> arg3 param 1))
        (set! (-> a1-2 param 2) (-> arg3 param 2))
        (set! (-> a1-2 param 3) (-> arg3 param 3))
        (set! (-> a1-2 param 4) (-> arg3 param 4))
        (set! (-> a1-2 param 5) (-> arg3 param 5))
        (send-event-function (handle->process (-> this rider-array s1-0)) a1-2)
        )
      )
    )
  (case arg2
    (('traffic-off)
     (when (not (logtest? (-> this flags) (rigid-body-object-flag persistent)))
       (cond
         ((logtest? (-> this flags) (rigid-body-object-flag dead))
          (go (method-of-object this die))
          )
         (else
           (if (logtest? (rigid-body-object-flag ai-driving) (-> this flags))
               (vehicle-method-113 this)
               )
           )
         )
       )
     )
    (('traffic-off-force)
     (vehicle-method-113 this)
     )
    (('traffic-activate)
     (set! (-> this controller traffic) (the-as traffic-engine (-> arg3 param 1)))
     (logior! (-> this flags) (rigid-body-object-flag traffic-managed))
     (let ((s5-1 (the-as traffic-object-spawn-params (-> arg3 param 0))))
       (set! (-> this root trans quad) (-> s5-1 position quad))
       (quaternion-copy! (-> this root quat) (-> s5-1 rotation))
       (set! (-> this root transv quad) (-> s5-1 velocity quad))
       (vehicle-method-130 this s5-1)
       )
     )
    (('attack)
     (let ((s3-1 (the-as attack-info (-> arg3 param 1)))
           (s2-1 (get-penetrate-using-from-attack-event arg0 arg3))
           )
       (when (and (!= (-> s3-1 id) (-> this incoming-attack-id))
                  (not (logtest? (-> this flags) (rigid-body-object-flag dead)))
                  (or (not (logtest? (-> this flags) (rigid-body-object-flag player-driving)))
                      (not (logtest? (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot) s2-1))
                      )
                  )
         (set! (-> this incoming-attack-id) (-> s3-1 id))
         (when (and (logtest? (-> this info flags) 4) (logtest? (rigid-body-object-flag ai-driving) (-> this flags)))
           (let ((a1-8 (find-offending-process-focusable arg0 s3-1)))
             (if (and a1-8 (logtest? (-> a1-8 mask) (process-mask target)))
                 (vehicle-method-134 this a1-8)
                 )
             )
           )
         (rigid-body-object-method-47 this arg0 s3-1 (the-as touching-shapes-entry (-> arg3 param 0)) s2-1)
         )
       )
     )
    (('turbo-ring)
     (set! (-> this turbo-boost-factor) (the-as float (-> arg3 param 0)))
     (set-time! (-> this turbo-boost-time))
     (set! (-> this turbo-boost-duration) (the-as uint 75))
     (logior! (-> this flags) (rigid-body-object-flag turbo-boost))
     (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
         (sound-play "boost-ring")
         )
     )
    (('get-offending-focusable)
     (if (logtest? (-> this flags) (rigid-body-object-flag player-driving))
         *target*
         )
     )
    (('pilot-on)
     (let* ((s3-2 (-> arg3 param 0))
            (s2-2 arg0)
            (s5-3 (if (type? s2-2 process-focusable)
                      s2-2
                      )
                  )
            )
       (when s5-3
         (format #t "vehicle::event-handler: pilot-on (pid ~d) from pid ~d~%" (-> this pid) (-> arg0 pid))
         (logior! (-> this flags) (rigid-body-object-flag riding))
         (put-rider-in-seat this (the-as int s3-2) (the-as process-focusable s5-3))
         (if (logtest? (-> s5-3 mask) (process-mask target))
             (logior! (-> this flags) (rigid-body-object-flag player-driving))
             )
         #t
         )
       )
     )
    (('player-get-off)
     (if (and (logtest? (-> this flags) (rigid-body-object-flag player-driving)) (!= (-> this crash-level) 3))
         (go (method-of-object this waiting))
         )
     )
    (('rider-off)
     (send-event (ppointer->process (-> this child)) 'rider-off)
     )
    (('rider-on)
     (send-event (ppointer->process (-> this child)) 'rider-on)
     )
    (('nav-mesh-kill)
     (vehicle-method-142 this)
     )
    (else
      ((method-of-type rigid-body-object rigid-body-object-method-46) this arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod vehicle-method-135 vehicle ((this vehicle) (arg0 traffic-object-spawn-params))
  0
  (none)
  )

(defbehavior vehicle-init-by-other vehicle ((arg0 traffic-object-spawn-params))
  (stack-size-set! (-> self main-thread) 16)
  (logior! (-> self mask) (process-mask vehicle))
  (allocate-and-init-cshape self)
  (set! (-> self root trans quad) (-> arg0 position quad))
  (quaternion-copy! (-> self root quat) (-> arg0 rotation))
  (if (not (logtest? (-> arg0 flags) (traffic-spawn-flags trsflags-00)))
      (lwide-entity-hack)
      )
  (init-skel-and-rigid-body self)
  (set! (-> self traffic-priority-id) (the-as int (-> arg0 id)))
  (vehicle-method-136 self arg0)
  (none)
  )
