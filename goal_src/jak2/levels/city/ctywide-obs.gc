;;-*-Lisp-*-
(in-package goal)

;; name: ctywide-obs.gc
;; name in dgo: ctywide-obs
;; dgos: CWI

;; DECOMP BEGINS

(deftype security-wall (process-drawable)
  ((root                collide-shape :override)
   (pass                int32)
   (incoming-attack-id  uint32)
   (next-message-time   int64)
   (message             int32)
   (plane               plane          :inline)
   (color               vector         :inline)
   (target-pos          vector         :inline)
   (flash               float)
   (touch-count         int32)
   (breach              symbol)
   )
  (:state-methods
    idle-open
    idle-close
    )
  (:methods
    (security-wall-method-22 (_type_ path-control float) vector)
    (security-wall-method-23 (_type_) none)
    (security-wall-method-24 (_type_) none)
    )
  )


(defskelgroup skel-security-wall security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

(defmethod security-wall-method-23 ((this security-wall))
  (when (< (-> this next-message-time) (current-time))
    (set! (-> this next-message-time)
          (the-as int (+ (current-time) (the int (* 300.0 (rand-vu-float-range 2.0 5.0)))))
          )
    (let ((v1-6 (rand-vu-int-count 15)))
      (cond
        ((zero? v1-6)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 1)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 2)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 3)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 4)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 5)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 6)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 7)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 8)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 9)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 10)
         (let ((v1-45 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-45)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-45 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-45 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 11)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (let ((v1-57 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-57)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-57 1)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-57 2)
              (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         )
        ((= v1-6 12)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 13)
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 14)
         (case (-> this pass)
           ((29)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         (add-process *gui-control* this (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        )
      )
    (+! (-> this message) 1)
    (when (>= (-> this message) 5)
      (set! (-> this message) 0)
      0
      )
    )
  0
  (none)
  )

(defmethod security-wall-method-24 ((this security-wall))
  (let ((s4-0 *target*))
    (when s4-0
      (let* ((f0-0 (vector-vector-distance-squared (-> this root trans) (-> s4-0 control trans)))
             (f30-0 (+ 40960.0 (-> this root root-prim local-sphere w)))
             (f1-1 f30-0)
             )
        (when (< f0-0 (* f1-1 f1-1))
          (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 1)))
            (set! (-> s5-0 0 quad) (-> s4-0 control trans quad))
            (when (< (vector-vector-distance-squared (-> this root trans) (-> this target-pos)) (* f30-0 f30-0))
              (let ((f0-3 (vector4-dot (-> this target-pos) (the-as vector (-> this plane))))
                    (f1-7 (vector4-dot (-> s5-0 0) (the-as vector (-> this plane))))
                    )
                (if (and (< (fabs f1-7) 16384.0)
                         (< (fabs f0-3) 16384.0)
                         (or (and (< f0-3 0.0) (>= f1-7 0.0)) (and (< f1-7 0.0) (>= f0-3 0.0)))
                         )
                    (set! (-> this breach) #t)
                    )
                )
              )
            (set! (-> this target-pos quad) (-> s5-0 0 quad))
            )
          (when (-> this breach)
            (if (send-event *target* 'attack-invinc #f (static-attack-info ((id (new-attack-id)) (mode 'grenade))))
                (set! (-> this breach) #f)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defstate idle-close (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('on)
         (let ((v1-2 (-> self root root-prim)))
           (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
           (let ((v0-0 (the-as object (-> self root backup-collide-with))))
             (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
             v0-0
             )
           )
         )
        (('off)
         (let ((v1-4 (-> self root root-prim)))
           (set! (-> v1-4 prim-core collide-as) (collide-spec))
           (set! (-> v1-4 prim-core collide-with) (collide-spec))
           )
         0
         )
        (('attack)
         (let ((v1-5 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
             (let* ((s5-0 proc)
                    (s3-0 (if (type? s5-0 process-drawable)
                              (the-as process-drawable s5-0)
                              )
                          )
                    )
               (when s3-0
                 (let ((s5-1 (process-spawn
                               manipy
                               :init manipy-init
                               (-> s3-0 root trans)
                               (-> self entity)
                               (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer uint32) #f))
                               #f
                               0
                               :to self
                               )
                             )
                       )
                   (when s5-1
                     (send-event (ppointer->process s5-1) 'anim-mode 'play1)
                     (send-event (ppointer->process s5-1) 'speed 1.5)
                     (send-event (ppointer->process s5-1) 'art-joint-anim "generic-ripples-idle" 0)
                     (set-vector! (-> (the-as process-drawable (-> s5-1 0)) root scale) 1.0 1.0 1.0 1.0)
                     (quaternion-rotate-local-x! (-> (the-as process-drawable (-> s5-1 0)) root quat) (-> self root quat) -16384.0)
                     (let ((v1-45 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                       (let ((a0-29 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a1-11 *up-vector*))
                           (let ((a2-9 8192.0))
                             (.mov vf7 a2-9)
                             )
                           (.lvf vf5 (&-> a1-11 quad))
                           )
                         (.lvf vf4 (&-> a0-29 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> v1-45 quad) vf6)
                       )
                     (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> s5-1 0)) root trans) (the-as vector (-> self plane)))))
                       (let ((v1-52 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-33 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-12 (-> self plane)))
                             (let ((a2-10 (- f0-6)))
                               (.mov vf7 a2-10)
                               )
                             (.lvf vf5 (&-> a1-12 quad))
                             )
                           (.lvf vf4 (&-> a0-33 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-52 quad) vf6)
                         )
                       (let ((v1-55 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-36 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-13 (-> self plane)))
                             (let ((a2-12 (the-as float (if (< 0.0 f0-6)
                                                            -989855744
                                                            #x45000000
                                                            )
                                                  )
                                          )
                                   )
                               (.mov vf7 a2-12)
                               )
                             (.lvf vf5 (&-> a1-13 quad))
                             )
                           (.lvf vf4 (&-> a0-36 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-55 quad) vf6)
                         )
                       )
                     (send-event (ppointer->process s5-1) 'trans-hook (lambda () #f))
                     )
                   )
                 )
               )
             (when (zero? (-> self touch-count))
               (+! (-> self touch-count) 1)
               (set! (-> self flash) 0.375)
               )
             (+! (-> self touch-count) 1)
             (if (and (logtest? (-> proc mask) (process-mask target))
                      (not (logtest? (process-mask projectile) (-> proc mask)))
                      )
                 (security-wall-method-23 self)
                 )
             )
           )
         )
        (('touched)
         (when (zero? (-> self touch-count))
           (+! (-> self touch-count) 1)
           (set! (-> self flash) 0.375)
           )
         (+! (-> self touch-count) 1)
         (let ((v1-83 (if (type? proc process-focusable)
                          (the-as process-focusable proc)
                          )
                      )
               )
           (when v1-83
             (let* ((gp-1 (-> v1-83 root))
                    (a0-45 (if (type? gp-1 collide-shape)
                               gp-1
                               )
                           )
                    )
               (if (and a0-45 (logtest? (-> a0-45 root-prim prim-core collide-as) (collide-spec jak)))
                   (security-wall-method-23 self)
                   )
               )
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (security-wall-method-24 self)
    )
  ;; og:preserve-this
  :code (behavior ()
    (until #f
      (when (or (and (logtest? (game-feature pass-red) (-> *game-info* features)) (= 29 (-> self pass)))
                (and (logtest? (game-feature pass-green) (-> *game-info* features)) (= 30 (-> self pass)))
                (and (logtest? (game-feature pass-yellow) (-> *game-info* features)) (= 31 (-> self pass)))
                (and (logtest? (game-feature pass-blue) (-> *game-info* features)) (= 32 (-> self pass)))
                )
        (go-virtual idle-open)
        (return #t)
        )
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-13 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-13 (-> self color) f30-0)
        (set-security-color! a0-13)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (set! (-> self flash)
              (seek (-> self flash) 0.0 (-> self clock seconds-per-frame))
              )
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-security-flash! gp-0)
        )
      (suspend)
      )
    #f
    )
  )

(defstate idle-open (security-wall)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('on)
       (let ((v1-2 (-> self root root-prim)))
         (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
         (let ((v0-0 (the-as int (-> self root backup-collide-with))))
           (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
           v0-0
           )
         )
       )
      (('off)
       (let ((v1-4 (-> self root root-prim)))
         (set! (-> v1-4 prim-core collide-as) (collide-spec))
         (set! (-> v1-4 prim-core collide-with) (collide-spec))
         )
       0
       )
      )
    )
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    )
  :trans (behavior ()
    (let* ((f28-0 (vector4-dot (the-as vector (-> self plane)) (target-pos 0)))
           (f30-0 (calc-fade-from-fog (-> self root trans)))
           (f28-1 (lerp-scale 0.0 1.0 (fabs f28-0) 163840.0 327680.0))
           (gp-1 (new 'stack-no-clear 'vector))
           )
      (when (= f28-1 0.0)
        (cleanup-for-death self)
        (deactivate self)
        )
      (let ((f0-3 (* f30-0 f28-1)))
        (vector-float*! gp-1 (-> self color) f0-3)
        )
      (set! (-> gp-1 w) 1.0)
      (set-security-color! gp-1)
      )
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    )
  )

(defmethod security-wall-method-22 ((this security-wall) (arg0 path-control) (arg1 float))
  (let ((s4-0 (new 'static 'vector))
        (s3-0 (new 'static 'vector))
        )
    0.0
    (get-point-in-path! arg0 s4-0 0.0 'exact)
    (get-point-in-path! arg0 s3-0 1.0 'exact)
    (* 0.5 (vector-vector-distance s4-0 s3-0))
    (let ((s2-1 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
      (let ((v1-7 (new 'process 'collide-shape-prim-mesh s2-1 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-7 prim-core collide-as) (collide-spec blocking-plane camera-blocker))
        (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-7 prim-core action) (collide-action solid))
        (set! (-> v1-7 transform-index) 3)
        (set! (-> s2-1 total-prims) (the-as uint 1))
        (set! (-> s2-1 root-prim) v1-7)
        )
      (set! (-> s2-1 nav-radius) (* 0.75 (-> s2-1 root-prim local-sphere w)))
      (let ((v1-10 (-> s2-1 root-prim)))
        (set! (-> s2-1 backup-collide-as) (-> v1-10 prim-core collide-as))
        (set! (-> s2-1 backup-collide-with) (-> v1-10 prim-core collide-with))
        )
      (set! (-> this root) s2-1)
      )
    (let ((s2-2 (new 'stack-no-clear 'matrix))
          (s1-0 (-> this root))
          )
      (vector+! (-> s1-0 trans) s4-0 s3-0)
      (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
      (+! (-> s1-0 trans y) (/ arg1 2))
      (vector-! (the-as vector (-> s2-2 vector)) s3-0 s4-0)
      (let ((f30-1 (vector-normalize-ret-len! (the-as vector (-> s2-2 vector)) 1.0)))
        (set! (-> s1-0 scale x) (/ f30-1 METER_LENGTH))
        (set! (-> s1-0 scale y) (/ arg1 METER_LENGTH))
        (set! (-> s1-0 scale z) 1.0)
        (set! (-> s2-2 vector 1 quad) (-> (new 'static 'vector :y 1.0 :w 1.0) quad))
        (vector-cross! (-> s2-2 vector 2) (the-as vector (-> s2-2 vector)) (-> s2-2 vector 1))
        (vector-normalize! (-> s2-2 vector 2) 1.0)
        (matrix->quaternion (-> s1-0 quat) s2-2)
        (set! (-> this plane quad) (-> s2-2 vector 2 quad))
        (set! (-> this plane w) (- (vector-dot (-> s2-2 vector 2) (-> this root trans))))
        (let ((v0-8 (-> this root root-prim local-sphere)))
          (set! (-> v0-8 x) 0.0)
          (set! (-> v0-8 y) (* 0.00024414062 (/ arg1 2)))
          (set! (-> v0-8 z) 0.0)
          (let ((f0-20 0.5)
                (f1-7 (* f30-1 f30-1))
                (f2-2 arg1)
                )
            (set! (-> v0-8 w) (* f0-20 (sqrtf (+ f1-7 (* f2-2 f2-2)))))
            )
          v0-8
          )
        )
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this security-wall) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (ctywide-entity-hack)
  (set! (-> this breach) #f)
  (set! (-> this pass) (res-lump-value arg0 'pickup-type int :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control this 'path 0.0 (the-as entity #f) #f)))
    (set! (-> this path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (security-wall-method-22 this (-> this path) 122880.0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this root event-self) 'touched)
  (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> this draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> this color) 1.0 1.0 1.0 1.0)
  (cond
    ((= (-> this pass) 29)
     (set-vector! (-> this color) 1.0 0.0 0.0 1.0)
     )
    ((= (-> this pass) 31)
     (set-vector! (-> this color) 1.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) 30)
     (set-vector! (-> this color) 0.0 1.0 0.0 1.0)
     )
    ((= (-> this pass) 32)
     (set-vector! (-> this color) 0.0 0.0 1.0 1.0)
     )
    )
  (set-security-color! (-> this color))
  (set-vector! (-> this draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> this draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (if (or (and (logtest? (game-feature pass-red) (-> *game-info* features)) (= 29 (-> this pass)))
          (and (logtest? (game-feature pass-green) (-> *game-info* features)) (= 30 (-> this pass)))
          (and (logtest? (game-feature pass-yellow) (-> *game-info* features)) (= 31 (-> this pass)))
          (and (logtest? (game-feature pass-blue) (-> *game-info* features)) (= 32 (-> this pass)))
          )
      (go (method-of-object this idle-open))
      (go (method-of-object this idle-close))
      )
  (none)
  )

(deftype fruit-stand (process-focusable)
  ((incoming-attack-id  uint32)
   (hack-counter        uint32)
   (count-sparts        uint32)
   (first-sparts        uint32)
   (num-sparts          uint32)
   (sparts-index        uint32  4)
   (sparts-pos          vector  4 :inline)
   )
  (:state-methods
    idle
    )
  (:methods
    (fruit-stand-method-28 (_type_) none)
    (fruit-stand-method-29 (_type_) none)
    )
  )


(define *fruit-check-ground-counter* 0)

(defun fruit-check-ground-bounce ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo) (arg3 matrix))
  (let ((v1-1 (-> arg1 key proc))
        (f0-0 (-> arg1 user-float))
        )
    (when (and (>= (-> (the-as fruit-stand v1-1) count-sparts) (-> (the-as fruit-stand v1-1) first-sparts))
               (nonzero? (-> (the-as fruit-stand v1-1) hack-counter))
               )
      (set! (-> (the-as fruit-stand v1-1) sparts-index (-> (the-as fruit-stand v1-1) num-sparts))
            (the-as uint arg3)
            )
      (set-vector!
        (-> (the-as fruit-stand v1-1) sparts-pos (-> (the-as fruit-stand v1-1) num-sparts))
        (-> arg2 launchrot x)
        (-> arg2 launchrot y)
        (-> arg2 launchrot z)
        1.0
        )
      (+! (-> (the-as fruit-stand v1-1) num-sparts) 1)
      (+! (-> (the-as fruit-stand v1-1) hack-counter) -1)
      )
    (+! (-> (the-as fruit-stand v1-1) count-sparts) 1)
    (when (and (< (-> arg2 launchrot y) f0-0) (< (-> arg1 vel-sxvel y) 0.0))
      (set! (-> arg2 launchrot y) f0-0)
      (if (and (< (-> arg1 vel-sxvel y) -122.88) (< (rand-vu-int-count 10) 3))
          (set-vector!
            (new 'stack-no-clear 'vector)
            (-> arg2 launchrot x)
            (-> arg2 launchrot y)
            (-> arg2 launchrot z)
            1.0
            )
          )
      (set! (-> arg1 vel-sxvel y) (* (-> arg1 vel-sxvel y) (- (rand-vu-float-range 0.6 0.8))))
      )
    )
  )

(defun fruit-sparticle-next-on-mode-1 ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> arg1 key)))
      (cond
        ((zero? (-> s5-0 state-mode 0))
         (set! (-> arg1 next-time)
               (the-as uint (* (max 1 (the-as int (-> *display* clock (-> arg1 clock-index) sparticle-data x))) 2))
               )
         )
        (else
          (let ((s4-0 (new 'stack-no-clear 'vector)))
            0.0
            0.0
            0.0
            (let* ((f28-0 (/ 1.0 (/ (-> arg1 omega) METER_LENGTH)))
                   (f26-0 (* (rand-vu-float-range -136.53334 136.53334) f28-0))
                   (f30-0 (* (rand-vu-float-range 0.0 136.53334) f28-0))
                   (f0-8 (* (rand-vu-float-range -13.653334 54.613335) f28-0))
                   )
              (vector-float*! s4-0 (the-as vector (-> s5-0 origin)) f26-0)
              (let ((a1-5 s4-0))
                (let ((v1-8 s4-0))
                  (let ((a0-10 (-> s5-0 origin vector 1)))
                    (let ((a2-1 f30-0))
                      (.mov vf7 a2-1)
                      )
                    (.lvf vf5 (&-> a0-10 quad))
                    )
                  (.lvf vf4 (&-> v1-8 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-5 quad) vf6)
                )
              (let ((a1-6 s4-0))
                (let ((v1-9 s4-0))
                  (let ((a0-11 (-> s5-0 origin vector 2)))
                    (let ((a2-2 f0-8))
                      (.mov vf7 a2-2)
                      )
                    (.lvf vf5 (&-> a0-11 quad))
                    )
                  (.lvf vf4 (&-> v1-9 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-6 quad) vf6)
                )
              )
            (set! (-> arg1 vel-sxvel x) (-> s4-0 x))
            (set! (-> arg1 vel-sxvel y) (-> s4-0 y))
            (set! (-> arg1 vel-sxvel z) (-> s4-0 z))
            )
          (-> arg1 vel-sxvel)
          (set! (-> arg1 user-float) (+ (-> s5-0 origin trans y) (-> arg1 omega)))
          )
        )
      )
    0.0
    )
  )

(defpartgroup group-ctywide-fruit
  :id 185
  :flags (use-local-clock unk-6)
  :bounds (static-bspherem 0 0 0 6)
  :rotate ((degrees 30) (degrees 0) (degrees 0))
  :parts ((sp-item 856 :flags (launch-asap bit7))
    (sp-item 857 :flags (launch-asap bit7))
    (sp-item 858 :flags (launch-asap bit7))
    (sp-item 859 :flags (launch-asap bit7))
    (sp-item 860 :flags (launch-asap bit7))
    )
  )

(defpart 856
  :init-specs ((:texture (market-melon ctywide-sprite))
    (:num 8.0)
    (:x (meters 2.2) 2 (meters 0.75))
    (:y (meters 1.1))
    (:z (meters -1.25) 2 (meters 0.75))
    (:scale-x (meters 0.75) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g :copy r)
    (:b :copy b)
    (:a 128.0)
    (:omega (degrees 9))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1638.4)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 861)
    (:rotate-y (degrees 0))
    )
  )

(defpart 861
  :init-specs ((:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.96 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 2) (seconds 3.997))
    (:next-launcher 862)
    )
  )

(defpart 860
  :init-specs ((:texture (market-orange ctywide-sprite))
    (:num 40.0)
    (:x (meters -3.7) 7 (meters 0.25))
    (:y (meters 1.1))
    (:z (meters -1.1) 7 (meters 0.25))
    (:scale-x (meters 0.25) (meters 0.1))
    (:scale-y (meters 0.35) (meters 0.1))
    (:r 0.0 1 160.0)
    (:g 100.0 64.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 4.5))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 819.2)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 863)
    (:rotate-y (degrees 0))
    )
  )

(defpart 859
  :init-specs ((:texture (market-orange ctywide-sprite))
    (:num 24.0)
    (:x (meters -3.6) 7 (meters 0.25))
    (:y (meters 1.25))
    (:z (meters -1.075) 6 (meters 0.25))
    (:scale-x (meters 0.25) (meters 0.1))
    (:scale-y (meters 0.35) (meters 0.1))
    (:r 0.0 1 160.0)
    (:g 100.0 64.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 4.5))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 819.2)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 863)
    (:rotate-y (degrees 0))
    )
  )

(defpart 863
  :init-specs ((:rot-z (degrees 0) (degrees 360))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.97 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 1.5) (seconds 2.997))
    (:next-launcher 864)
    )
  )

(defpart 864
  :init-specs ((:rotvel-z (degrees 0)) (:fade-a -0.42666668))
  )

(defpart 858
  :init-specs ((:texture (market-orange ctywide-sprite))
    (:num 32.0)
    (:x (meters -0.8) 3 (meters 0.5))
    (:y (meters 1))
    (:z (meters -1) 3 (meters 0.5))
    (:scale-x (meters 0.4) (meters 0.15))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 48.0 32.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 6.7500005))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1228.8)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 865)
    (:rotate-y (degrees 0))
    )
  )

(defpart 857
  :init-specs ((:texture (market-orange ctywide-sprite))
    (:num 32.0)
    (:x (meters -0.55) 2 (meters 0.5))
    (:y (meters 1.25))
    (:z (meters -0.8) 2 (meters 0.5))
    (:scale-x (meters 0.4) (meters 0.15))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 48.0 32.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 6.7500005))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1228.8)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 865)
    (:rotate-y (degrees 0))
    )
  )

(defpart 865
  :init-specs ((:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.97 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 2) (seconds 3.997))
    (:next-launcher 862)
    )
  )

(defpart 862
  :init-specs ((:fade-a -0.42666668))
  )

(defskelgroup skel-fruit-stand cty-fruit-stand cty-fruit-stand-lod0-jg cty-fruit-stand-idle-ja
              ((cty-fruit-stand-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; WARN: Return type mismatch int vs object.
(defbehavior fruit-stand-event-handler fruit-stand ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (let ((v1-1 (the-as object (-> arg3 param 1))))
       (when (!= (-> (the-as attack-info v1-1) id) (-> self incoming-attack-id))
         (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-1) id))
         (let ((v0-0 1))
           (set! (-> self part state-mode 0) (the-as uint v0-0))
           v0-0
           )
         )
       )
     )
    )
  )

(defstate idle (fruit-stand)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (fruit-stand-event-handler proc argc message block)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post (behavior ()
    (dotimes (gp-0 (the-as int (-> self num-sparts)))
      (let ((s5-0 (new 'stack-no-clear 'collide-query))
            (s4-0 (-> *sp-particle-system-2d* cpuinfo-table (-> self sparts-index gp-0)))
            )
        (set! (-> s5-0 start-pos quad) (-> self sparts-pos gp-0 quad))
        (+! (-> s5-0 start-pos y) 4096.0)
        (set-vector! (-> s5-0 move-dist) 0.0 -40960.0 0.0 1.0)
        (let ((v1-5 s5-0))
          (set! (-> v1-5 radius) (-> s4-0 omega))
          (set! (-> v1-5 collide-with) (collide-spec backgnd))
          (set! (-> v1-5 ignore-process0) #f)
          (set! (-> v1-5 ignore-process1) #f)
          (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-5 action-mask) (collide-action solid))
          )
        (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
          (if (>= f0-7 0.0)
              (set! (-> s4-0 user-float) (+ (-> s5-0 start-pos y) (* (-> s5-0 move-dist y) f0-7)))
              )
          (when (< f0-7 0.0)
            )
          )
        )
      )
    (+! (-> self first-sparts) (-> self num-sparts))
    (when (>= (-> self first-sparts) (-> self count-sparts))
      (set! (-> self first-sparts) (the-as uint 0))
      0
      )
    (set! (-> self num-sparts) (the-as uint 0))
    (set! (-> self hack-counter) (the-as uint 4))
    (set! (-> self count-sparts) (the-as uint 0))
    (spawn-with-cspace (-> self part) (the-as cspace (-> self node-list data)))
    (ja-post)
    )
  )

(defmethod fruit-stand-method-28 ((this fruit-stand))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod fruit-stand-method-29 ((this fruit-stand))
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 185) this))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this fruit-stand) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (fruit-stand-method-28 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fruit-stand" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (fruit-stand-method-29 this)
  (go (method-of-object this idle))
  (none)
  )

(deftype cty-fruit-stand (fruit-stand)
  ()
  )


(defpartgroup group-cty-guard-turret-hit
  :id 186
  :duration (seconds 3)
  :linger-duration (seconds 1)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 15)
  :parts ((sp-item 866 :period (seconds 5) :length (seconds 0.085) :offset -10)
    (sp-item 867 :fade-after (meters 60) :period (seconds 5) :length (seconds 0.1))
    (sp-item 868 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 5) :length (seconds 0.335))
    (sp-item 869 :fade-after (meters 200) :falloff-to (meters 200) :period (seconds 5) :length (seconds 0.167))
    (sp-item 870 :period (seconds 5) :length (seconds 0.017) :offset -10)
    (sp-item 871 :fade-after (meters 150) :falloff-to (meters 150) :period (seconds 5) :length (seconds 0.167))
    )
  )

(defpart 869
  :init-specs ((:texture (explosion-wave effects))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360) :store)
    (:scale-y (meters 0.8) (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a -0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:func 'sparticle-motion-blur)
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 872)
    (:conerot-x '*sp-temp*)
    )
  )

(defpart 871
  :init-specs ((:texture (explosion-nebula effects))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a 0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 872)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 872
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:next-time (seconds 0.017) (seconds 0.065)) (:next-launcher 873))
  )

(defpart 873
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.44)
    (:fade-g -2.36)
    (:fade-b -2.64)
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 874)
    )
  )

(defpart 874
  :init-specs ((:scalevel-x (meters 0.008333334) (meters 0.008333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.2944444)
    (:fade-g -0.7111111)
    (:fade-b -0.094444446)
    (:fade-a -0.06545454 -0.06545454)
    (:next-time (seconds 0.5) (seconds 0.097))
    (:next-launcher 875)
    )
  )

(defpart 875
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

(defpart 870
  :init-specs ((:texture (glow effects))
    (:num 1.0)
    (:scale-x (meters 5))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 96.0)
    (:scalevel-x (meters 0.5))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -1.28)
    (:fade-b -5.1)
    (:fade-a 0.0)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.167))
    (:next-launcher 876)
    )
  )

(defpart 876
  :init-specs ((:scalevel-x (meters -0.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -2.56)
    (:fade-b 0.0)
    (:fade-a -1.92)
    )
  )

(defpart 868
  :init-specs ((:texture (specs effects))
    (:num 5.0 3.0)
    (:x (meters 0.25))
    (:scale-x (meters 1) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.083333336) (meters 0.083333336))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.18)
    (:fade-b -2.12)
    (:accel-y (meters -0.00016666666) (meters -0.00033333333))
    (:friction 0.87)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 877)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 877
  :init-specs ((:scalevel-x (meters 0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g 0.02)
    (:fade-b 0.23555556)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 878)
    )
  )

(defpart 878
  :init-specs ((:fade-r -0.5543478) (:fade-g -0.5543478) (:fade-a -0.13913043))
  )

(defpart 866
  :init-specs ((:texture (bigpuff effects))
    (:num 3.0 1.0)
    (:x (meters 0) (meters 0.6))
    (:scale-x (meters 2) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 70.0 20.0)
    (:g 70.0 20.0)
    (:b 70.0 20.0)
    (:a 0.0 40.0)
    (:vel-y (meters 0) (meters 0.1))
    (:scalevel-x (meters 0.033333335) (meters 0.016666668))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 3.3)
    (:fade-g 3.12)
    (:fade-b 1.18)
    (:fade-a 1.76)
    (:friction 0.88)
    (:timer (seconds 2.367))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 879)
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 879
  :init-specs ((:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.53333336)
    (:fade-g -1.9666667)
    (:fade-b -2.2)
    (:fade-a -0.41666666)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 880)
    )
  )

(defpart 880
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.38833332)
    (:fade-g -0.21333334)
    (:fade-b -0.028333334)
    (:fade-a -0.38833332)
    )
  )

(defpart 867
  :init-specs ((:texture (flamingstick effects))
    (:num 4.0 2.0)
    (:scale-x (meters 0.1) (meters 0.25))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 128.0 128.0)
    (:g 96.0)
    (:b 64.0)
    (:a 64.0 64.0)
    (:scalevel-x (meters 0.13333334) (meters 0.02))
    (:fade-g 1.6)
    (:fade-b 3.2)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

(deftype cty-guard-turret (process-focusable)
  ((incoming-attack-id  uint32)
   (jm-turret           joint-mod)
   (jm-gunsL            joint-mod)
   (jm-gunsR            joint-mod)
   (angle-turret        degrees)
   (angle-guns          degrees)
   (last-no-zero        int64)
   (next-time-shot      time-frame)
   (num-shots           uint32)
   (focus               focus  :inline)
   (id                  int32)
   (destroyed           symbol)
   (button-down?        symbol)
   (hit-points          int32)
   )
  (:state-methods
    idle
    hostile
    explode
    wait-for-pushing
    pushed
    )
  (:methods
    (cty-guard-turret-method-32 (_type_) none)
    (cty-guard-turret-method-33 (_type_) none)
    (cty-guard-turret-method-34 (_type_) none)
    (cty-guard-turret-method-35 (_type_) quaternion)
    )
  )


(defskelgroup skel-cty-guard-turret cty-guard-turret cty-guard-turret-lod0-jg cty-guard-turret-idle-ja
              ((cty-guard-turret-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7.5)
              )

(defskelgroup skel-cty-guard-turret-explode cty-guard-turret cty-guard-turret-explode-lod0-jg cty-guard-turret-explode-idle-ja
              ((cty-guard-turret-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *cty-guard-turret-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index 7)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index 6)
      )
    :collide-spec #x1
    )
  )

(defbehavior cty-guard-turret-event-handler cty-guard-turret ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (when (and (-> self next-state) (= (-> self next-state name) 'hostile))
       (let ((a0-1 (get-penetrate-using-from-attack-event (the-as process-drawable arg0) arg3))
             (v1-5 (the-as object (-> arg3 param 1)))
             )
         (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
           (cond
             ((logtest? (penetrate
                          flop
                          punch
                          spin
                          uppercut
                          mech-punch
                          mech-bonk
                          dark-punch
                          dark-bomb
                          dark-giant
                          explode
                          jak-red-shot
                          jak-dark-shot
                          enemy-dark-shot
                          )
                        a0-1
                        )
              (+! (-> self hit-points) -10)
              )
             ((logtest? (attack-mask damage) (-> (the-as attack-info v1-5) mask))
              (set! (-> self hit-points) (- (-> self hit-points) (the int (-> (the-as attack-info v1-5) damage))))
              )
             (else
               (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage a0-1)))
               )
             )
           (when (< (-> self hit-points) 0)
             (sound-play "gturret-explode")
             (go-virtual explode)
             )
           )
         )
       )
     )
    (('track)
     (if (and (-> self next-state) (= (-> self next-state name) 'hostile))
         #t
         #f
         )
     )
    )
  )

(defmethod get-trans ((this cty-guard-turret) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (let ((v1-0 (-> this root)))
    (cond
      ((= arg0 3)
       (let ((v0-0 (vector<-cspace! (new 'static 'vector) (-> this node-list data 6))))
         (set! (-> v0-0 w) (-> this root root-prim prim-core world-sphere w))
         v0-0
         )
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

(defmethod get-inv-mass ((this cty-guard-turret))
  0.01
  )

(defstate idle (cty-guard-turret)
  :virtual #t
  :event cty-guard-turret-event-handler
  :enter (behavior ()
    (try-update-focus (-> self focus) *target*)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! cty-guard-turret-idle-ja :num! zero)
    (transform-post)
    (logior! (-> self focus-status) (focus-status ignore))
    )
  :exit (behavior ()
    (logclear! (-> self focus-status) (focus-status ignore))
    )
  :code sleep-code
  :post (behavior ()
    (when (>= (-> self id) 0)
      (let* ((v1-4 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
             (gp-0 (if (-> v1-4 info)
                       (-> v1-4 info manager)
                       (the-as handle #f)
                       )
                   )
             )
        (when (handle->process gp-0)
          (if (or (task-node-open? (game-task-node city-power-post-win))
                  (not (send-event (handle->process gp-0) 'guard-turret-status (-> self id) (-> self root trans)))
                  )
              (set! (-> self destroyed) #t)
              )
          )
        )
      )
    (if (= (level-status *level* 'lwideb) 'active)
        (set! (-> self destroyed) #t)
        )
    (let ((gp-2 (handle->process (-> self focus handle))))
      (when (and gp-2
                 (and *traffic-engine*
                      (let ((f0-0 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-2) 0) (-> self root trans)))
                            (f1-0 409600.0)
                            )
                        (< f0-0 (* f1-0 f1-0))
                        )
                      (not (-> self destroyed))
                      )
                 )
        (cond
          ((and (>= (-> self id) 0) (task-node-open? (game-task-node city-power-resolution)))
           (go-virtual hostile)
           )
          (else
            (if (and (focus-test? (the-as process-focusable gp-2) pilot)
                     (>= (the-as uint (get-alert-level *traffic-engine*)) (the-as uint 1))
                     )
                (go-virtual hostile)
                )
            )
          )
        )
      )
    (transform-post)
    )
  )

(defstate explode (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('button-down)
       (let ((v0-0 #t))
         (set! (-> self button-down?) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cty-guard-turret-explode" (the-as (pointer uint32) #f))
        6
        gp-0
        *cty-guard-turret-exploder-params*
        :to self
        )
      )
    (when (and (>= (-> self id) 0) (let ((v1-12 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                                     (handle->process (if (-> v1-12 info)
                                                          (-> v1-12 info manager)
                                                          (the-as handle #f)
                                                          )
                                                      )
                                     )
               )
      (set! (-> self button-down?) #f)
      (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-6 from) (process->ppointer self))
        (set! (-> a1-6 num-params) 1)
        (set! (-> a1-6 message) 'guard-turret-killed)
        (set! (-> a1-6 param 0) (the-as uint (-> self id)))
        (let ((t9-5 send-event-function)
              (v1-23 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
              )
          (t9-5
            (handle->process (if (-> v1-23 info)
                                 (-> v1-23 info manager)
                                 (the-as handle #f)
                                 )
                             )
            a1-6
            )
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    )
  :code (behavior ()
    (local-vars (v1-6 handle))
    (cond
      ((and (>= (-> self id) 0)
            (begin
              (let ((v1-4 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                (set! v1-6 (if (-> v1-4 info)
                               (-> v1-4 info manager)
                               (the-as handle #f)
                               )
                      )
                )
              (nonzero? (l32-false-check v1-6))
              )
            (let ((a0-4 (-> v1-6 process 0)))
              (if (= (-> v1-6 pid) (-> a0-4 pid))
                  a0-4
                  )
              )
            )
       (suspend-for (seconds 2)
         (let ((a1-1 (new 'stack-no-clear 'vector)))
           (set! (-> a1-1 quad) (-> self root trans quad))
           (+! (-> a1-1 y) 10240.0)
           (spawn (-> self part) a1-1)
           )
         )
       (while (not (-> self button-down?))
         (suspend)
         )
       (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-2 from) (process->ppointer self))
         (set! (-> a1-2 num-params) 1)
         (set! (-> a1-2 message) 'guard-turret-button-pushed)
         (set! (-> a1-2 param 0) (the-as uint (-> self id)))
         (let ((t9-1 send-event-function)
               (v1-25 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
               )
           (t9-1
             (handle->process (if (-> v1-25 info)
                                  (-> v1-25 info manager)
                                  (the-as handle #f)
                                  )
                              )
             a1-2
             )
           )
         )
       (go-virtual pushed)
       )
      (else
        (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 32.0 0.5) :frame-num 20.0)
        (until (ja-done? 0)
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (+! (-> a1-4 y) 10240.0)
            (spawn (-> self part) a1-4)
            )
          (suspend)
          (ja :num! (seek! 32.0 0.5))
          )
        (suspend-for (seconds 3)
          )
        )
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    )
  :post (behavior ()
    (ja-post)
    )
  )

(defstate wait-for-pushing (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('button-down)
       (let ((v0-0 #t))
         (set! (-> self button-down?) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self button-down?) #f)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'spawn-button)
      (set! (-> a1-0 param 0) (the-as uint (-> self id)))
      (set! (-> a1-0 param 1) (the-as uint #f))
      (let ((t9-0 send-event-function)
            (v1-6 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-6 info)
                               (-> v1-6 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 20.0) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0))
      )
    (while (not (-> self button-down?))
      (suspend)
      )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) (process->ppointer self))
      (set! (-> a1-2 num-params) 1)
      (set! (-> a1-2 message) 'guard-turret-button-pushed)
      (set! (-> a1-2 param 0) (the-as uint (-> self id)))
      (let ((t9-3 send-event-function)
            (v1-25 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-3
          (handle->process (if (-> v1-25 info)
                               (-> v1-25 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-2
          )
        )
      )
    (loop
      (suspend)
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    )
  :post (behavior ()
    (ja-post)
    )
  )

(defstate pushed (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('close)
       (let ((v0-0 #t))
         (set! (-> self button-down?) v0-0)
         v0-0
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self button-down?) #f)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'spawn-button)
      (set! (-> a1-0 param 0) (the-as uint (-> self id)))
      (set! (-> a1-0 param 1) (the-as uint #t))
      (let ((t9-0 send-event-function)
            (v1-7 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-7 info)
                               (-> v1-7 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    (set! (-> self button-down?) #f)
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja
                :num! (seek! (ja-aframe 20.0 0))
                :frame-num (ja-aframe 20.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 20.0 0)))
      )
    (while (not (-> self button-down?))
      (suspend)
      )
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja
                :num! (seek! (ja-aframe 32.0 0))
                :frame-num (ja-aframe 20.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 32.0 0)))
      )
    (suspend-for (seconds 5)
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    )
  :post (behavior ()
    (ja-post)
    )
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defmethod cty-guard-turret-method-34 ((this cty-guard-turret))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s2-0 (-> this node-list data 7 bone transform))
          (s5-0 (-> this node-list data 8 bone transform))
          (s4-0 (new 'stack-no-clear 'projectile-init-by-other-params))
          )
      (let ((s1-0 (new 'stack-no-clear 'vector))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (vector<-matrix! s1-0 s2-0)
        (let ((a1-1 s1-0))
          (let ((v1-4 s1-0))
            (let ((a0-2 (-> s2-0 vector 2)))
              (let ((a2-1 10727.424))
                (.mov vf7 a2-1)
                )
              (.lvf vf5 (&-> a0-2 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-1 quad) vf6)
          )
        (vector<-matrix! s3-0 s5-0)
        (let ((a1-3 s3-0))
          (let ((v1-5 s3-0))
            (let ((a0-4 (-> s5-0 vector 2)))
              (let ((a2-3 -10727.424))
                (.mov vf7 a2-3)
                )
              (.lvf vf5 (&-> a0-4 quad))
              )
            (.lvf vf4 (&-> v1-5 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-3 quad) vf6)
          )
        (set! (-> s4-0 ent) (-> this entity))
        (set! (-> s4-0 charge) 1.0)
        (set! (-> s4-0 options) (projectile-options))
        (set! (-> s4-0 notify-handle) (process->handle this))
        (set! (-> s4-0 owner-handle) (the-as handle #f))
        (set! (-> s4-0 ignore-handle) (process->handle this))
        (let* ((v1-14 *game-info*)
               (a0-14 (+ (-> v1-14 attack-id) 1))
               )
          (set! (-> v1-14 attack-id) a0-14)
          (set! (-> s4-0 attack-id) a0-14)
          )
        (set! (-> s4-0 timeout) (seconds 4))
        (set! (-> s4-0 pos quad) (-> s1-0 quad))
        (set! (-> s4-0 vel quad) (-> s2-0 vector 2 quad))
        (vector-normalize! (-> s4-0 vel) 819200.0)
        (spawn-projectile guard-shot s4-0 this *default-dead-pool*)
        (set! (-> s4-0 pos quad) (-> s3-0 quad))
        )
      (vector-negate! (-> s4-0 vel) (-> s5-0 vector 2))
      (vector-normalize! (-> s4-0 vel) 819200.0)
      (spawn-projectile guard-shot s4-0 this *default-dead-pool*)
      )
    (none)
    )
  )

(defmethod cty-guard-turret-method-35 ((this cty-guard-turret))
  (local-vars (sv-192 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (handle->process (-> this focus handle))))
      (when s5-0
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (set! (-> s4-0 quad) (-> (get-trans (the-as process-focusable s5-0) 3) quad))
          (let ((s0-0 (new 'stack-no-clear 'vector)))
            (let ((v1-8 (-> this root trans)))
              (let ((a0-5 *y-vector*))
                (let ((a1-3 10240.0))
                  (.mov vf7 a1-3)
                  )
                (.lvf vf5 (&-> a0-5 quad))
                )
              (.lvf vf4 (&-> v1-8 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> s0-0 quad) vf6)
            (let ((f30-0 (vector-vector-xz-distance s4-0 s0-0)))
              (let ((f0-2 (/ f30-0 (meters 200)))
                    (a0-7 s4-0)
                    )
                (let ((v1-10 s4-0))
                  (let ((a1-6 (-> (the-as process-focusable s5-0) root transv)))
                    (let ((a2-0 f0-2))
                      (.mov vf7 a2-0)
                      )
                    (.lvf vf5 (&-> a1-6 quad))
                    )
                  (.lvf vf4 (&-> v1-10 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a0-7 quad) vf6)
                )
              (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) s4-0 s0-0))
                    (s1-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)))
                    )
                (set! sv-192 (new 'stack-no-clear 'vector))
                (let ((s2-0 (new 'stack-no-clear 'vector)))
                  (-> this node-list data 6 bone transform)
                  (-> this node-list data 7 bone transform)
                  (-> this node-list data 8 bone transform)
                  (vector-rotate90-around-y! sv-192 s3-1)
                  (set! (-> sv-192 y) 0.0)
                  (vector-normalize! sv-192 1.0)
                  (let* ((f26-0 (vector-vector-xz-distance-squared s0-0 s4-0))
                         (f0-4 7389.184)
                         (f28-0 (* f0-4 f0-4))
                         (t9-6 vector-vector-xz-distance-squared)
                         (a0-13 (new 'stack-no-clear 'vector))
                         )
                    (let ((v1-27 7389.184))
                      (.mov vf7 v1-27)
                      )
                    (.lvf vf5 (&-> sv-192 quad))
                    (.lvf vf4 (&-> s0-0 quad))
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a0-13 quad) vf6)
                    (let* ((f2-0 (t9-6 a0-13 s4-0))
                           (f28-1 (acos (fmax -1.0 (fmin 1.0 (/ (- (- f26-0 f28-0) f2-0) (* -2.0 (sqrtf f2-0) (sqrtf f28-0)))))))
                           )
                      (let ((s0-1 (new 'stack-no-clear 'vector))
                            (s4-1 (new 'stack-no-clear 'vector))
                            )
                        (if (< f28-1 11832.889)
                            (set! f28-1 11832.889)
                            )
                        (rot-zxy-from-vector! s0-1 s1-0)
                        (rot-zxy-from-vector! s2-0 s3-1)
                        (set! (-> s4-1 x) (deg- (-> s2-0 x) (-> s0-1 x)))
                        (set! (-> s4-1 y) (deg- (-> s2-0 y) (-> s0-1 y)))
                        (cond
                          ((focus-test? (the-as process-focusable s5-0) pilot)
                           (set! (-> this angle-turret) (deg-seek (-> this angle-turret) (-> s4-1 y) (* 36408.89 (seconds-per-frame))))
                           (set! (-> this angle-guns) (deg-seek (-> this angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                           )
                          (else
                            (set! (-> this angle-turret) (deg-seek (-> this angle-turret) (-> s4-1 y) (* 18204.445 (seconds-per-frame))))
                            (set! (-> this angle-guns) (deg-seek (-> this angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                            )
                          )
                        (quaternion-axis-angle! (-> this jm-turret quat) 0.0 1.0 0.0 (-> this angle-turret))
                        (when (= (+ (fabs (- (-> this angle-turret) (-> s4-1 y))) (fabs (- (-> this angle-guns) (-> s4-1 x)))) 0.0)
                          (set! (-> this next-time-shot) (+ (current-time) (seconds 1)))
                          (set! (-> this num-shots) (the-as uint 0))
                          0
                          )
                        )
                      (let ((s5-1 (new 'stack-no-clear 'quaternion)))
                        (let ((f0-42 (/ 45511.11 (/ f30-0 METER_LENGTH))))
                          (quaternion-axis-angle! s5-1 1.0 0.0 0.0 (fmax (fmin (-> this angle-guns) f0-42) (- f0-42)))
                          )
                        (quaternion*!
                          (-> this jm-gunsL quat)
                          (quaternion-axis-angle! (new 'stack-no-clear 'quaternion) 0.0 1.0 0.0 (+ -16384.0 f28-1))
                          s5-1
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (quaternion-copy! (-> this jm-gunsR quat) (-> this jm-gunsL quat))
        )
      )
    )
  )

(defstate hostile (cty-guard-turret)
  :virtual #t
  :event cty-guard-turret-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (set! (-> self num-shots) (the-as uint 0))
    0
    )
  :trans (behavior ()
    '()
    )
  :code (behavior ()
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 20.0 0.5) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0 0.5))
      )
    (until #f
      (cond
        ((zero? (-> self next-time-shot))
         (cty-guard-turret-method-35 self)
         )
        ((>= (current-time) (-> self next-time-shot))
         (cty-guard-turret-method-34 self)
         (+! (-> self num-shots) 1)
         (cond
           ((= (-> self num-shots) 5)
            (set! (-> self next-time-shot) 0)
            0
            )
           (else
             (set! (-> self next-time-shot) (+ (current-time) (seconds 0.1)))
             )
           )
         )
        )
      (suspend)
      (let ((gp-0 (handle->process (-> self focus handle))))
        (cond
          ((and gp-0
                (let ((f0-5 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-0) 0) (-> self root trans)))
                      (f1-0 491520.0)
                      )
                  (< f0-5 (* f1-0 f1-0))
                  )
                )
           (cond
             ((and (>= (-> self id) 0) (task-node-open? (game-task-node city-power-resolution)))
              )
             (else
               (if (and (not (focus-test? (the-as process-focusable gp-0) pilot))
                        *traffic-engine*
                        (zero? (get-alert-level *traffic-engine*))
                        )
                   (goto cfg-36)
                   )
               )
             )
           )
          (else
            (goto cfg-36)
            )
          )
        )
      )
    #f
    (label cfg-36)
    (ja-no-eval :group! cty-guard-turret-pop-up-down-ja :num! (seek! 32.0 0.5) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 32.0 0.5))
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (transform-post)
    )
  )

(defmethod relocate ((this cty-guard-turret) (offset int))
  (if (nonzero? (-> this jm-turret))
      (&+! (-> this jm-turret) offset)
      )
  (if (nonzero? (-> this jm-gunsL))
      (&+! (-> this jm-gunsL) offset)
      )
  (if (nonzero? (-> this jm-gunsR))
      (&+! (-> this jm-gunsR) offset)
      )
  (call-parent-method this offset)
  )

(defmethod cty-guard-turret-method-32 ((this cty-guard-turret))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 26624.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 4)
      (set-vector! (-> v1-13 local-sphere) -6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 5)
      (set-vector! (-> v1-15 local-sphere) 6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 14336.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 6)
      (set-vector! (-> v1-19 local-sphere) 0.0 -8192.0 0.0 13107.2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod cty-guard-turret-method-33 ((this cty-guard-turret))
  (logior! (-> this mask) (process-mask enemy))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this cty-guard-turret) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (local-vars (v1-23 handle))
  (with-pp
    (cty-guard-turret-method-32 this)
    (set! (-> this entity) arg0)
    (process-drawable-from-entity! this arg0)
    (ctywide-entity-hack)
    (initialize-skeleton
      this
      (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-guard-turret" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (cty-guard-turret-method-33 this)
    (reset-to-collide-spec (-> this focus) (collide-spec jak player-list))
    (set! (-> this jm-turret) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 6))
    (set! (-> this jm-gunsL) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 7))
    (set! (-> this jm-gunsR) (new 'process 'joint-mod (joint-mod-mode joint-set*) this 8))
    (set! (-> this part) (create-launch-control (-> *part-group-id-table* 186) this))
    (set! (-> this id) (res-lump-value arg0 'extra-id int :default (the-as uint128 -1) :time -1000000000.0))
    (set! (-> this destroyed) #f)
    (set! (-> this hit-points) 6)
    (cond
      ((and (>= (-> this id) 0)
            (begin
              (let ((v1-21 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                (set! v1-23 (if (-> v1-21 info)
                                (-> v1-21 info manager)
                                (the-as handle #f)
                                )
                      )
                )
              (nonzero? (l32-false-check v1-23))
              )
            (let ((a0-16 (-> v1-23 process 0)))
              (if (= (-> v1-23 pid) (-> a0-16 pid))
                  a0-16
                  )
              )
            )
       (let ((a1-11 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-11 from) (process->ppointer pp))
         (set! (-> a1-11 num-params) 2)
         (set! (-> a1-11 message) 'guard-turret-status)
         (set! (-> a1-11 param 0) (the-as uint (-> this id)))
         (set! (-> a1-11 param 1) (the-as uint (-> this root trans)))
         (let* ((t9-12 send-event-function)
                (v1-33 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
                (v1-38 (t9-12
                         (handle->process (if (-> v1-33 info)
                                              (-> v1-33 info manager)
                                              (the-as handle #f)
                                              )
                                          )
                         a1-11
                         )
                       )
                )
           (cond
             ((zero? v1-38)
              (go (method-of-object this idle))
              )
             ((= v1-38 1)
              (go (method-of-object this wait-for-pushing))
              )
             ((= v1-38 2)
              (go (method-of-object this pushed))
              )
             (else
               (go (method-of-object this idle))
               )
             )
           )
         )
       )
      (else
        (go (method-of-object this idle))
        )
      )
    (none)
    )
  )

(deftype parking-spot (process-drawable)
  ((vehicle      handle)
   (spawned      symbol)
   (minimap      connection-minimap)
   (test-sphere  sphere  :inline)
   )
  (:state-methods
    idle
    )
  (:methods
    (parking-spot-method-21 (_type_) none)
    (parking-spot-method-22 (_type_) none)
    (parking-spot-method-23 (_type_ uint) none)
    (parking-spot-method-24 (_type_) none)
    )
  )


(defmethod parking-spot-method-24 ((this parking-spot))
  (let ((gp-0 (new 'stack-no-clear 'collide-query-with-2vec)))
    (set! (-> gp-0 vec quad) (-> this root trans quad))
    (set! (-> gp-0 cquery start-pos quad) (-> gp-0 vec quad))
    (vector-reset! (-> gp-0 vec2))
    (set! (-> gp-0 vec2 y) 1.0)
    (set-vector! (-> gp-0 cquery move-dist) 0.0 -40960.0 0.0 1.0)
    (let ((v1-5 (-> gp-0 cquery)))
      (set! (-> v1-5 radius) 1024.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* (-> gp-0 cquery))))
      (when (>= f30-0 0.0)
        (vector+float*! (-> gp-0 vec) (-> gp-0 cquery start-pos) (-> gp-0 cquery move-dist) f30-0)
        (set! (-> gp-0 vec2 quad) (-> gp-0 cquery best-other-tri normal quad))
        (set! (-> this root trans quad) (-> gp-0 vec quad))
        (format #t "parking-spot::find-ground: ground y ~M~%" (-> gp-0 vec y))
        )
      (if (< f30-0 0.0)
          (format #t "parking-spot::find-ground: could not find ground~%")
          )
      )
    (set! (-> this root trans quad) (-> gp-0 vec quad))
    (forward-up-nopitch->quaternion (-> this root quat) (new 'static 'vector :z 1.0 :w 1.0) (-> gp-0 vec2))
    )
  0
  (none)
  )

(defmethod parking-spot-method-21 ((this parking-spot))
  (let ((s5-0 (handle->process (-> this vehicle))))
    (cond
      (s5-0
        (cond
          ((or (focus-test? (the-as vehicle s5-0) dead inactive)
               (not (logtest? (-> (the-as vehicle s5-0) flags) (rigid-body-object-flag waiting-for-player)))
               (let ((f0-0 (-> this test-sphere r)))
                 (< (* f0-0 f0-0) (vector-vector-distance-squared (-> (the-as vehicle s5-0) root trans) (-> this test-sphere)))
                 )
               )
           (logclear! (-> (the-as vehicle s5-0) flags) (rigid-body-object-flag persistent))
           (set! (-> this vehicle) (the-as handle #f))
           )
          (else
            (if (not (-> this minimap))
                (set! (-> this minimap) (add-icon! *minimap* this (the-as uint 17) (the-as int #f) (the-as vector #t) 0))
                )
            )
          )
        )
      (else
        (when (-> this minimap)
          (logior! (-> this minimap flags) (minimap-flag fade-out))
          (set! (-> this minimap) #f)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod parking-spot-method-23 ((this parking-spot) (arg0 uint))
  (let ((v1-0 (new 'stack-no-clear 'inline-array 'collide-query 1)))
    (let* ((a0-1 (new 'stack-no-clear 'inline-array 'vector 1))
           (a1-1 #x813f9)
           (a2-1 (logand -2 a1-1))
           )
      (set! (-> a0-1 0 quad) (-> this test-sphere quad))
      (let ((a1-3 (-> v1-0 0)))
        (set! (-> a1-3 best-dist) (the-as float a0-1))
        (set! (-> a1-3 num-spheres) (the-as uint 1))
        (set! (-> a1-3 collide-with) (the-as collide-spec a2-1))
        (set! (-> a1-3 ignore-process0) #f)
        (set! (-> a1-3 ignore-process1) #f)
        (set! (-> a1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> a1-3 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> a1-3 action-mask) (collide-action solid))
        )
      )
    0
    (when (not (fill-and-probe-using-spheres *collide-cache* (-> v1-0 0)))
      (let ((s4-0 (new 'stack 'traffic-object-spawn-params)))
        (set! (-> s4-0 position quad) (-> this root trans quad))
        (mem-copy! (the-as pointer (-> s4-0 rotation)) (the-as pointer (-> this root quat)) 16)
        (+! (-> s4-0 position y) 14336.0)
        (set! (-> s4-0 behavior) (the-as uint 0))
        (set! (-> s4-0 object-type) (the-as traffic-type arg0))
        (set! (-> s4-0 id) (the-as uint 0))
        (send-event *traffic-manager* 'activate-object s4-0)
        (when (-> s4-0 proc)
          (set! (-> this vehicle) (process->handle (-> s4-0 proc)))
          (set! (-> this spawned) #t)
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this parking-spot) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (set! (-> this minimap) #f)
  (set! (-> this vehicle) (the-as handle #f))
  (set! (-> this spawned) #f)
  (process-drawable-from-entity! this arg0)
  (logclear! (-> this mask) (process-mask actor-pause movie))
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (parking-spot-method-24 this)
  (set! (-> this test-sphere quad) (-> this root trans quad))
  (set! (-> this test-sphere r) 24576.0)
  (set-time! (-> this state-time))
  (let ((a1-5 (get-random-parking-spot-type *traffic-engine*)))
    (if (!= a1-5 (traffic-type traffic-type-21))
        (parking-spot-method-23 this (the-as uint a1-5))
        )
    )
  (go (method-of-object this idle))
  (none)
  )

(defstate idle (parking-spot)
  :virtual #t
  :exit (behavior ()
    (parking-spot-method-21 self)
    (send-event (handle->process (-> self vehicle)) 'traffic-off-force)
    )
  :code sleep-code
  :post (behavior ()
    (when (time-elapsed? (-> self state-time) (seconds 0.25))
      (set-time! (-> self state-time))
      (parking-spot-method-21 self)
      (when (not (-> self spawned))
        (let ((f0-0 (vector-vector-distance-squared (camera-pos) (-> self test-sphere)))
              (f1-0 327680.0)
              )
          (when (< (* f1-0 f1-0) f0-0)
            (let ((f1-3 614400.0))
              (when (or (< (* f1-3 f1-3) f0-0) (not (sphere-in-view-frustum? (-> self test-sphere))))
                (let ((a1-1 (get-random-parking-spot-type *traffic-engine*)))
                  (if (!= a1-1 (traffic-type traffic-type-21))
                      (parking-spot-method-23 self (the-as uint a1-1))
                      )
                  )
                )
              )
            )
          )
        )
      )
    0
    )
  )

(deftype propa (process-focusable)
  ((sound-id            sound-id)
   (sound-index         uint32)
   (handle              handle)
   (y-rot               float)
   (hit-points          int32)
   (incoming-attack-id  uint32)
   )
  (:state-methods
    idle
    broken
    )
  (:methods
    (propa-method-29 (_type_) none)
    (propa-method-30 (_type_) none)
    (propa-method-31 (_type_ vector) none)
    )
  )


(defskelgroup skel-propa propa propa-lod0-jg propa-idle-ja
              ((propa-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(define *propa-sounds* (new 'static 'boxed-array :type string
                         "prop009"
                         "prop010"
                         "prop011"
                         "prop012"
                         "prop013"
                         "prop014"
                         "prop015"
                         "prop016"
                         "prop017"
                         "prop018"
                         "prop019"
                         "prop020"
                         "prop021"
                         "prop022"
                         "prop023"
                         "prop024"
                         "prop025"
                         "prop026"
                         "prop028"
                         "prop027"
                         "prop029"
                         "prop030"
                         "prop031"
                         "prop032"
                         "prop033"
                         "prop034"
                         "prop035"
                         "prop036"
                         "prop037"
                         "prop038"
                         "prop039"
                         "prop040"
                         "prop041"
                         "prop042"
                         "prop043"
                         "prop008"
                         "prop006"
                         "prop005"
                         "prop004"
                         "prop002"
                         "prop003"
                         "bar001"
                         "prop044"
                         "prop045"
                         "prop046"
                         "prop047"
                         "prop048"
                         "prop049"
                         "prop051"
                         "prop052"
                         "prop053"
                         "prop054"
                         "prop055"
                         "prop056"
                         )
        )

(define *propa-sounds-class-3* (new 'static 'boxed-array :type string "cityv177"))

(define *propa-sounds-class-2* (new 'static 'boxed-array :type string "cityv176"))

(define *propa-sounds-class-1* (new 'static 'boxed-array :type string "prop050" "spot004" "cityv175"))

(define *propa-sounds-metalheads* (new 'static 'boxed-array :type string
                                    "prop007"
                                    "prop057"
                                    "cityv096"
                                    "cityv097"
                                    "cityv098"
                                    "cityv099"
                                    "cityv142"
                                    "cityv143"
                                    )
        )

(define *propa-sounds-baron-construction* (new 'static 'boxed-array :type string "prop058"))

;; WARN: Return type mismatch int vs knocked-type.
(defun propa-pu->knocked-type ((arg0 penetrate))
  (the-as knocked-type (cond
                         ((logtest? arg0 (penetrate vehicle))
                          7
                          )
                         ((logtest? (penetrate jak-blue-shot) arg0)
                          6
                          )
                         ((logtest? (penetrate jak-yellow-shot enemy-yellow-shot) arg0)
                          4
                          )
                         ((logtest? (penetrate jak-red-shot) arg0)
                          5
                          )
                         ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg0)
                          2
                          )
                         ((logtest? (penetrate dark-bomb dark-giant) arg0)
                          3
                          )
                         ((logtest? arg0 (penetrate mech-punch))
                          1
                          )
                         (else
                           0
                           )
                         )
          )
  )

(defstate broken (propa)
  :virtual #t
  :code sleep-code
  )

(defstate idle (propa)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (case message
        (('attack)
         (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)
         (let ((v1-2 (the-as object (-> block param 1))))
           (when (!= (-> (the-as attack-info v1-2) id) (-> self incoming-attack-id))
             (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-2) id))
             (let ((gp-1 (get-penetrate-using-from-attack-event (the-as process-drawable proc) block)))
               (if (and (not (logtest? (penetrate dark-skin) gp-1)) (zero? (propa-pu->knocked-type gp-1)))
                   (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage gp-1)))
                   (+! (-> self hit-points) -10)
                   )
               )
             (cond
               ((< (-> self hit-points) 3)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 1 0)
                (let* ((a0-9 (the-as collide-shape-prim-group (-> self root root-prim)))
                       (v1-17 (-> a0-9 child 0))
                       )
                  (let ((a0-11 (-> a0-9 child 1)))
                    (set! (-> a0-11 prim-core collide-as) (-> v1-17 prim-core collide-as))
                    (set! (-> a0-11 prim-core collide-with) (-> v1-17 prim-core collide-with))
                    )
                  (set! (-> v1-17 prim-core collide-as) (collide-spec))
                  (set! (-> v1-17 prim-core collide-with) (collide-spec))
                  )
                0
                (let ((gp-2 (get-process *default-dead-pool* part-tracker #x4000)))
                  (when gp-2
                    (let ((t9-7 (method-of-type part-tracker activate)))
                      (t9-7
                        (the-as part-tracker gp-2)
                        *entity-pool*
                        (symbol->string (-> part-tracker symbol))
                        (the-as pointer #x70004000)
                        )
                      )
                    (let ((t9-8 run-function-in-process)
                          (a0-14 gp-2)
                          (a1-10 part-tracker-init)
                          (a2-7 (-> *part-group-id-table* 161))
                          (a3-2 0)
                          (t0-0 #f)
                          (t1-0 #f)
                          (t2-0 #f)
                          (t3-0 *launch-matrix*)
                          )
                      (let ((v1-25 (-> t3-0 trans))
                            (t4-0 (new 'stack-no-clear 'vector))
                            )
                        (let ((t5-1 (-> self root trans)))
                          (let ((t6-0 *up-vector*))
                            (let ((t7-1 8192.0))
                              (.mov vf7 t7-1)
                              )
                            (.lvf vf5 (&-> t6-0 quad))
                            )
                          (.lvf vf4 (&-> t5-1 quad))
                          )
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> t4-0 quad) vf6)
                        (set! (-> v1-25 quad) (-> t4-0 quad))
                        )
                      ((the-as (function object object object object object object object object none) t9-8)
                       a0-14
                       a1-10
                       a2-7
                       a3-2
                       t0-0
                       t1-0
                       t2-0
                       t3-0
                       )
                      )
                    (-> gp-2 ppointer)
                    )
                  )
                (go-virtual broken)
                )
               ((< (-> self hit-points) 6)
                (setup-masks (-> self draw) 0 -1)
                (setup-masks (-> self draw) 2 0)
                )
               )
             )
           )
         )
        )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (sound-stop (-> self sound-id))
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    )
  :code sleep-code
  :post (behavior ()
    (cond
      ((or (not (-> *setting-control* user-current speech-control))
           (< 245760.0 (vector-vector-distance (camera-pos) (-> self root trans)))
           )
       (when (nonzero? (-> self sound-id))
         (set-action!
           *gui-control*
           (gui-action stop)
           (-> self sound-id)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         (set! (-> self sound-id) (new 'static 'sound-id))
         (+! (-> self sound-index) 1)
         (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
           (set! (-> self sound-index) (the-as uint 0))
           0
           )
         )
       )
      ((< (vector-vector-distance (camera-pos) (-> self root trans)) 225280.0)
       (cond
         ((zero? (-> self sound-id))
          (set! (-> self sound-id) (add-process
                                     *gui-control*
                                     self
                                     (gui-channel alert)
                                     (gui-action play)
                                     (-> *propa-sounds* (-> self sound-index))
                                     -99.0
                                     0
                                     )
                )
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (set! (-> a1-4 w) 40960.0)
            (propa-method-31 self a1-4)
            )
          )
         (else
           (when *sound-player-enable*
             (let ((gp-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
               (set! (-> gp-2 command) (sound-command set-param))
               (set! (-> gp-2 id) (-> self sound-id))
               (set! (-> gp-2 params fo-min) 40)
               (set! (-> gp-2 params fo-max) 55)
               (set! (-> gp-2 params fo-curve) 2)
               (let ((a1-5 (-> self root trans)))
                 (let ((s5-0 self))
                   (when (= a1-5 #t)
                     (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root)))
                         (set! a1-5 (-> s5-0 root trans))
                         (set! a1-5 (the-as vector #f))
                         )
                     )
                   )
                 (sound-trans-convert (the-as vector3w (-> gp-2 params trans)) a1-5)
                 )
               (set! (-> gp-2 params mask) (the-as uint 480))
               (-> gp-2 id)
               )
             )
           (when (= (get-status *gui-control* (-> self sound-id)) (gui-status unknown))
             (set! (-> self sound-id) (new 'static 'sound-id))
             (+! (-> self sound-index) 1)
             (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
               (set! (-> self sound-index) (the-as uint 0))
               0
               )
             )
           )
         )
       )
      )
    (let ((s5-1 (matrix->trans (-> self node-list data 3 bone transform) (new 'stack-no-clear 'vector)))
          (s4-0 (new 'stack-no-clear 'vector))
          (gp-3 (new 'stack-no-clear 'matrix))
          )
      (when (and (nonzero? (-> self handle)) (handle->process (-> self handle)))
        (let* ((s3-0 (handle->process (-> self handle)))
               (a0-25 (if (type? s3-0 process-focusable)
                          (the-as process-focusable s3-0)
                          )
                      )
               )
          (when a0-25
            (vector-! s4-0 (-> a0-25 root trans) (-> self root trans))
            (set! (-> self y-rot) (deg-seek
                                    (-> self y-rot)
                                    (deg- (vector-y-angle s4-0) (quaternion-y-angle (-> self root quat)))
                                    (* 36408.89 (seconds-per-frame))
                                    )
                  )
            )
          )
        )
      (matrix-rotate-y! gp-3 (-> self y-rot))
      (matrix<-trans gp-3 s5-1)
      (spawn-with-matrix (-> self part) gp-3)
      )
    )
  )

(defmethod propa-method-31 ((this propa) (arg0 vector))
  (let ((s5-0 (the-as process-focusable #f)))
    (let ((f30-0 (the-as float #x7f800000))
          (s3-0 (new 'stack-no-clear 'array 'collide-shape 64))
          )
      (countdown (s2-0 (fill-actor-list-for-sphere *actor-hash* (the-as sphere arg0) s3-0 64))
        (let* ((s1-0 (-> s3-0 s2-0))
               (a0-3 (if (type? s1-0 collide-shape)
                         s1-0
                         )
                     )
               )
          (when a0-3
            (let* ((s0-0 (-> a0-3 process))
                   (s1-1 (if (type? s0-0 process-focusable)
                             (the-as process-focusable s0-0)
                             )
                         )
                   )
              (when (and s1-1
                         (!= this s1-1)
                         (not (focus-test? s1-1 inactive))
                         (not (focus-test? s1-1 disable))
                         (not (focus-test? s1-1 dead))
                         (not (logtest? (process-mask guard) (-> s1-1 mask)))
                         (not (logtest? (process-mask crate) (-> s1-1 mask)))
                         (not (logtest? (process-mask vehicle) (-> s1-1 mask)))
                         )
                (let ((f0-0 (vector-vector-xz-distance (-> this root trans) (-> s1-1 root trans))))
                  (when (or (not s5-0) (< f0-0 f30-0))
                    (set! s5-0 s1-1)
                    (set! f30-0 f0-0)
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (and *target* (< (vector-vector-distance (target-pos 0) arg0) (-> arg0 w)))
        (set! s5-0 *target*)
        )
    (if s5-0
        (set! (-> this handle) (process->handle s5-0))
        (set! (-> this handle) (the-as handle #f))
        )
    )
  0
  (none)
  )

(defmethod propa-method-29 ((this propa))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod propa-method-30 ((this propa))
  (logior! (-> this mask) (process-mask crate))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 170) this))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this propa) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (propa-method-29 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-propa" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (propa-method-30 this)
  (set! (-> this sound-index) (the-as uint (rand-vu-int-count (-> *propa-sounds* length))))
  (setup-masks (-> this draw) 0 -1)
  (setup-masks (-> this draw) 4 0)
  (set! (-> this hit-points) 10)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype baron-statue (process-drawable)
  ()
  (:state-methods
    idle
    )
  )


(defskelgroup skel-baron-statue baron-statue baron-statue-lod0-jg baron-statue-idle-ja
              ((baron-statue-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 75 0 83)
              )

(defmethod run-logic? ((this baron-statue))
  "Should this process be run? Checked by execute-process-tree."
  #t
  )

(defstate idle (baron-statue)
  :virtual #t
  :code sleep-code
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this baron-statue) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-baron-statue" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (when (task-node-closed? (game-task-node canyon-insert-items-resolution))
    (cleanup-for-death this)
    (go empty-state)
    )
  (ja-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype burning-bush (process-focusable)
  ((task        game-task-control)
   (part-off    sparticle-launch-control)
   (part-alert  sparticle-launch-control)
   (angle       degrees)
   (time        float)
   )
  (:state-methods
    idle
    talking
    menu
    )
  (:methods
    (burning-bush-method-30 (_type_) none)
    (burning-bush-method-31 (_type_) none)
    (burning-bush-method-32 (_type_) object)
    )
  )


(defskelgroup skel-burning-bush burning-bush burning-bush-lod0-jg burning-bush-idle-ja
              ((burning-bush-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 3.5)
              )

(defstate idle (burning-bush)
  :virtual #t
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    (let ((gp-0 (get-current-task-event (-> self task)))
          (s5-0 #f)
          )
      (let ((s4-0 (new 'stack-no-clear 'matrix)))
        (let* ((a2-0 (-> self node-list data 3 bone transform))
               (v1-3 (-> a2-0 quad 0))
               (a0-1 (-> a2-0 quad 1))
               (a1-0 (-> a2-0 quad 2))
               (a2-1 (-> a2-0 trans quad))
               )
          (set! (-> s4-0 quad 0) v1-3)
          (set! (-> s4-0 quad 1) a0-1)
          (set! (-> s4-0 quad 2) a1-0)
          (set! (-> s4-0 trans quad) a2-1)
          )
        (when (< (vector-dot
                   (-> s4-0 vector 2)
                   (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans s4-0 (new 'stack-no-clear 'vector)))
                   )
                 0.0
                 )
          )
        (cond
          ((and *traffic-manager* (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                                    (set! (-> a1-2 from) (process->ppointer self))
                                    (set! (-> a1-2 num-params) 0)
                                    (set! (-> a1-2 message) 'get-alert-level)
                                    (and (nonzero? (send-event-function *traffic-manager* a1-2))
                                         (zero? (-> *setting-control* user-current exclusive-task))
                                         )
                                    )
                )
           (spawn-with-matrix (-> self part-alert) s4-0)
           (set! s5-0 #t)
           )
          ((= (-> gp-0 action) (game-task-action show))
           (spawn-with-matrix (-> self part) s4-0)
           )
          ((= (-> gp-0 action) (game-task-action play))
           (spawn-with-matrix (-> self part-off) s4-0)
           )
          ((= (-> gp-0 action) (game-task-action menu))
           (spawn-with-matrix (-> self part) s4-0)
           )
          (else
            (spawn-with-matrix (-> self part-off) s4-0)
            )
          )
        )
      (when (and (not s5-0)
                 (or (= (-> gp-0 action) (game-task-action show)) (= (-> gp-0 action) (game-task-action menu)))
                 (and (burning-bush-method-32 self) (can-display-query? self (the-as string #f) -99.0))
                 )
        (let ((s5-1
                (new 'stack 'font-context *font-default-matrix* 32 280 0.0 (font-color default) (font-flags shadow kerning))
                )
              )
          (set! (-> s5-1 flags) (font-flags shadow kerning large))
          (let ((v1-37 s5-1))
            (set! (-> v1-37 width) (the float 340))
            )
          (let ((v1-38 s5-1))
            (set! (-> v1-38 height) (the float 80))
            )
          (let ((v1-39 s5-1))
            (set! (-> v1-39 scale) 0.9)
            )
          (let ((s4-1 print-game-text))
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id press-triangle-to-talk) #f))
            (s4-1 *temp-string* s5-1 #f 44 (bucket-id progress))
            )
          )
        (when (cpad-pressed? 0 triangle)
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
          (if (= (-> gp-0 action) (game-task-action menu))
              (go-virtual menu)
              (go-virtual talking)
              )
          )
        )
      )
    )
  :code sleep-code
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

(defstate talking (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (process-entity-status! self (entity-perm-status no-kill) #t)
    )
  :exit (behavior ()
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'minimap)
    (set! (-> *part-id-table* 832 init-specs 4 initial-valuef) 14336.0)
    (set! (-> *part-id-table* 833 init-specs 4 initial-valuef) 16384.0)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (local-vars (sv-272 vector) (sv-288 quaternion))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (!= (-> self time) -1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (let ((s5-0 gp-0)
                (s4-0 (-> self root trans))
                (s3-0 vector-orient-by-quat!)
                (s2-0 (new 'stack-no-clear 'vector))
                (s1-0 (new 'static 'vector :y 16384.0 :z 40960.0 :w 1.0))
                (s0-0 quaternion-rotate-local-y!)
                )
            (set! sv-272 (new 'stack-no-clear 'vector))
            (set! sv-288 (-> self root quat))
            (let ((a2-0 (* 182.04445 (* 30.0 (sin (* 7281.778 (-> self time)))))))
              (vector+! s5-0 s4-0 (s3-0 s2-0 s1-0 (s0-0 (the-as quaternion sv-272) sv-288 a2-0)))
              )
            )
          (set! (-> *camera* slave 0 trans quad) (-> gp-0 quad))
          (let ((t9-3 forward-down->inv-matrix)
                (a0-5 (-> *camera* slave 0 tracking))
                (a1-2 (new 'stack-no-clear 'vector))
                (v1-17 (new 'stack-no-clear 'vector))
                )
            (let ((a2-3 (-> self root trans)))
              (let ((a3-0 *up-vector*))
                (let ((t0-1 20480.0))
                  (.mov vf7 t0-1)
                  )
                (.lvf vf5 (&-> a3-0 quad))
                )
              (.lvf vf4 (&-> a2-3 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-17 quad) vf6)
            (t9-3 (the-as matrix a0-5) (vector-! a1-2 v1-17 gp-0) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-1 (new 'stack-no-clear 'matrix)))
        (let* ((a2-5 (-> self node-list data 3 bone transform))
               (v1-22 (-> a2-5 quad 0))
               (a0-6 (-> a2-5 quad 1))
               (a1-4 (-> a2-5 quad 2))
               (a2-6 (-> a2-5 trans quad))
               )
          (set! (-> gp-1 quad 0) v1-22)
          (set! (-> gp-1 quad 1) a0-6)
          (set! (-> gp-1 quad 2) a1-4)
          (set! (-> gp-1 trans quad) a2-6)
          )
        (if (< (vector-dot
                 (-> gp-1 vector 2)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-1 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-1)
            )
        (+! (-> self angle) (* 100.0 (rand-vu)))
        (set! (-> *part-id-table* 832 init-specs 4 initial-valuef)
              (+ 14336.0 (* 1228.8 (cos (* 182.04445 (-> self angle)))))
              )
        (set! (-> *part-id-table* 833 init-specs 4 initial-valuef)
              (+ 2048.0 (-> *part-id-table* 832 init-specs 4 initial-valuef))
              )
        (spawn-with-matrix (-> self part) gp-1)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (if *target*
        (set! (-> *target* neck flex-blend) 1.0)
        )
    (add-setting! 'music-volume 'rel (-> *setting-control* user-current music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> *setting-control* user-current sfx-movie-volume) 0)
    (add-setting! 'dialog-volume 'rel (-> *setting-control* user-current dialog-volume-hint) 0)
    (set-time! (-> self state-time))
    (let* ((v1-21 (get-current-task-event (-> self task)))
           (gp-0 (add-process
                   *gui-control*
                   self
                   (gui-channel bbush)
                   (gui-action play)
                   (the-as string (-> v1-21 scene))
                   -99.0
                   0
                   )
                 )
           )
      (while (nonzero? (get-status *gui-control* gp-0))
        (set! (-> self time) (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
        (suspend)
        (when (cpad-pressed? 0 triangle)
          (set-action!
            *gui-control*
            (gui-action stop)
            gp-0
            (gui-channel none)
            (gui-action none)
            (the-as string #f)
            (the-as (function gui-connection symbol) #f)
            (the-as process #f)
            )
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
          (sound-play "inter-burn-bush")
          )
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (task-node-close! (-> self task current-node))
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

(defstate menu (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (set-time! (-> self state-time))
    )
  :exit (behavior ()
    (remove-setting! 'minimap)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    )
  :trans (behavior ()
    (local-vars
      (sv-352 (function _varargs_ object))
      (sv-368 string)
      (sv-384 (function string font-context symbol int bucket-id float))
      (sv-400 (function _varargs_ object))
      (sv-416 string)
      (sv-432 (function string font-context symbol int bucket-id float))
      (sv-448 (function _varargs_ object))
      (sv-464 string)
      (sv-480 (function string font-context symbol int bucket-id float))
      (sv-496 (function _varargs_ object))
      (sv-512 string)
      (sv-528 (function string font-context symbol int bucket-id float))
      (sv-544 (function _varargs_ object))
      (sv-560 string)
      (sv-576 (function string font-context symbol int bucket-id float))
      (sv-592 (function _varargs_ object))
      (sv-608 string)
      (sv-624 (function string font-context symbol int bucket-id float))
      (sv-640 (function _varargs_ object))
      (sv-656 string)
      (sv-672 (function string font-context symbol int bucket-id float))
      (sv-688 (function _varargs_ object))
      (sv-704 string)
      )
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (time-elapsed? (-> self state-time) (seconds 1.5))
        (let ((gp-0 0)
              (s5-0 0)
              )
          (let ((s4-0 310))
            (when (or (task-node-open? (the-as game-task-node s4-0)) (task-node-closed? (the-as game-task-node s4-0)))
              (if (task-node-closed? (the-as game-task-node s4-0))
                  (set! s5-0 0)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-1 312))
            (when (or (task-node-open? (the-as game-task-node s4-1)) (task-node-closed? (the-as game-task-node s4-1)))
              (if (task-node-closed? (the-as game-task-node s4-1))
                  (set! s5-0 1)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-2 314))
            (when (or (task-node-open? (the-as game-task-node s4-2)) (task-node-closed? (the-as game-task-node s4-2)))
              (if (task-node-closed? (the-as game-task-node s4-2))
                  (set! s5-0 2)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-3 316))
            (when (or (task-node-open? (the-as game-task-node s4-3)) (task-node-closed? (the-as game-task-node s4-3)))
              (if (task-node-closed? (the-as game-task-node s4-3))
                  (set! s5-0 3)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-4 318))
            (when (or (task-node-open? (the-as game-task-node s4-4)) (task-node-closed? (the-as game-task-node s4-4)))
              (if (task-node-closed? (the-as game-task-node s4-4))
                  (set! s5-0 4)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-5 320))
            (when (or (task-node-open? (the-as game-task-node s4-5)) (task-node-closed? (the-as game-task-node s4-5)))
              (if (task-node-closed? (the-as game-task-node s4-5))
                  (set! s5-0 5)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-6 322))
            (when (or (task-node-open? (the-as game-task-node s4-6)) (task-node-closed? (the-as game-task-node s4-6)))
              (if (task-node-closed? (the-as game-task-node s4-6))
                  (set! s5-0 6)
                  )
              (+! gp-0 1)
              )
            )
          (when (cpad-pressed? 0 down l-analog-down)
            (+! s5-0 1)
            (cond
              ((< (+ gp-0 -1) s5-0)
               (set! s5-0 (+ gp-0 -1))
               s5-0
               )
              (else
                (the-as int (sound-play "menu-up-down"))
                )
              )
            )
          (when (cpad-pressed? 0 up l-analog-up)
            (+! s5-0 -1)
            (cond
              ((< s5-0 0)
               (set! s5-0 0)
               s5-0
               )
              (else
                (the-as int (sound-play "menu-up-down"))
                )
              )
            )
          (let ((v1-43 s5-0))
            (cond
              ((zero? v1-43)
               (task-node-open! (game-task-node stadium-burning-bush-race-board-resolution))
               )
              ((= v1-43 1)
               (task-node-open! (game-task-node stadium-burning-bush-race-class3-resolution))
               )
              ((= v1-43 2)
               (task-node-open! (game-task-node stadium-burning-bush-race-class2-resolution))
               )
              ((= v1-43 3)
               (task-node-open! (game-task-node stadium-burning-bush-race-class1-resolution))
               )
              ((= v1-43 4)
               (task-node-open! (game-task-node stadium-burning-bush-race-class3-r-resolution))
               )
              ((= v1-43 5)
               (task-node-open! (game-task-node stadium-burning-bush-race-class2-r-resolution))
               )
              ((= v1-43 6)
               (task-node-open! (game-task-node stadium-burning-bush-race-class1-r-resolution))
               )
              )
            )
          (let* ((s4-9 40)
                 (s3-2 36)
                 (s2-0 (- 228 (* gp-0 (/ s4-9 2))))
                 (s1-0 (new
                         'stack
                         'font-context
                         *font-default-matrix*
                         s3-2
                         s2-0
                         0.0
                         (font-color default)
                         (font-flags shadow kerning)
                         )
                       )
                 )
            (set! (-> s1-0 flags) (font-flags shadow kerning middle middle-vert large))
            (let ((v1-48 s1-0))
              (set! (-> v1-48 width) (the float 440))
              )
            (let ((v1-49 s1-0))
              (set! (-> v1-49 height) (the float 50))
              )
            (let ((v1-50 s1-0))
              (set! (-> v1-50 scale) 1.0)
              )
            (let ((v1-51 s1-0)
                  (a1-3 s3-2)
                  (a0-59 40)
                  )
              (set! (-> v1-51 origin x) (the float a1-3))
              (set! (-> v1-51 origin y) (the float a0-59))
              )
            (let ((a0-60 s1-0))
              (set! (-> a0-60 color) (font-color progress-old-yellow))
              )
            (let ((s0-0 print-game-text))
              (set! sv-352 format)
              (set! sv-368 (clear *temp-string*))
              (let ((a1-5 (lookup-text! *common-text* (text-id select-event) #f)))
                (sv-352 sv-368 a1-5)
                )
              (s0-0 *temp-string* s1-0 #f 44 (bucket-id progress))
              )
            (let ((v1-55 s1-0))
              (set! (-> v1-55 height) (the float s4-9))
              )
            (dotimes (s0-1 gp-0)
              (let ((v1-56 s1-0)
                    (a1-7 s3-2)
                    (a0-66 s2-0)
                    )
                (set! (-> v1-56 origin x) (the float a1-7))
                (set! (-> v1-56 origin y) (the float a0-66))
                )
              (let ((v1-57 s1-0))
                (set! (-> v1-57 scale) (if (= s0-1 s5-0)
                                           0.8
                                           0.6
                                           )
                      )
                )
              (let ((a0-68 s1-0))
                (set! (-> a0-68 color) (if (= s0-1 s5-0)
                                           (font-color progress-old-selected)
                                           (font-color default)
                                           )
                      )
                )
              (let ((v1-59 s0-1))
                (cond
                  ((zero? v1-59)
                   (set! sv-384 print-game-text)
                   (set! sv-400 format)
                   (set! sv-416 (clear *temp-string*))
                   (let ((a1-9 (lookup-text! *common-text* (text-id board-name) #f)))
                     (sv-400 sv-416 a1-9)
                     )
                   (let ((a0-73 *temp-string*)
                         (a1-10 s1-0)
                         (a2-6 #f)
                         (a3-4 44)
                         (t0-4 320)
                         )
                     (sv-384 a0-73 a1-10 a2-6 a3-4 (the-as bucket-id t0-4))
                     )
                   )
                  ((= v1-59 1)
                   (set! sv-432 print-game-text)
                   (set! sv-448 format)
                   (set! sv-464 (clear *temp-string*))
                   (let ((a1-12 (lookup-text! *common-text* (text-id race-class3) #f)))
                     (sv-448 sv-464 a1-12)
                     )
                   (let ((a0-79 *temp-string*)
                         (a1-13 s1-0)
                         (a2-8 #f)
                         (a3-5 44)
                         (t0-5 320)
                         )
                     (sv-432 a0-79 a1-13 a2-8 a3-5 (the-as bucket-id t0-5))
                     )
                   )
                  ((= v1-59 2)
                   (set! sv-480 print-game-text)
                   (set! sv-496 format)
                   (set! sv-512 (clear *temp-string*))
                   (let ((a1-15 (lookup-text! *common-text* (text-id race-class2) #f)))
                     (sv-496 sv-512 a1-15)
                     )
                   (let ((a0-85 *temp-string*)
                         (a1-16 s1-0)
                         (a2-10 #f)
                         (a3-6 44)
                         (t0-6 320)
                         )
                     (sv-480 a0-85 a1-16 a2-10 a3-6 (the-as bucket-id t0-6))
                     )
                   )
                  ((= v1-59 3)
                   (set! sv-528 print-game-text)
                   (set! sv-544 format)
                   (set! sv-560 (clear *temp-string*))
                   (let ((a1-18 (lookup-text! *common-text* (text-id race-class1) #f)))
                     (sv-544 sv-560 a1-18)
                     )
                   (let ((a0-91 *temp-string*)
                         (a1-19 s1-0)
                         (a2-12 #f)
                         (a3-7 44)
                         (t0-7 320)
                         )
                     (sv-528 a0-91 a1-19 a2-12 a3-7 (the-as bucket-id t0-7))
                     )
                   )
                  ((= v1-59 4)
                   (set! sv-576 print-game-text)
                   (set! sv-592 format)
                   (set! sv-608 (clear *temp-string*))
                   (let ((a1-21 (lookup-text! *common-text* (text-id reverse-race-class3) #f)))
                     (sv-592 sv-608 a1-21)
                     )
                   (let ((a0-97 *temp-string*)
                         (a1-22 s1-0)
                         (a2-14 #f)
                         (a3-8 44)
                         (t0-8 320)
                         )
                     (sv-576 a0-97 a1-22 a2-14 a3-8 (the-as bucket-id t0-8))
                     )
                   )
                  ((= v1-59 5)
                   (set! sv-624 print-game-text)
                   (set! sv-640 format)
                   (set! sv-656 (clear *temp-string*))
                   (let ((a1-24 (lookup-text! *common-text* (text-id reverse-race-class2) #f)))
                     (sv-640 sv-656 a1-24)
                     )
                   (let ((a0-103 *temp-string*)
                         (a1-25 s1-0)
                         (a2-16 #f)
                         (a3-9 44)
                         (t0-9 320)
                         )
                     (sv-624 a0-103 a1-25 a2-16 a3-9 (the-as bucket-id t0-9))
                     )
                   )
                  ((= v1-59 6)
                   (set! sv-672 print-game-text)
                   (set! sv-688 format)
                   (set! sv-704 (clear *temp-string*))
                   (let ((a1-27 (lookup-text! *common-text* (text-id reverse-race-class1) #f)))
                     (sv-688 sv-704 a1-27)
                     )
                   (let ((a0-108 *temp-string*)
                         (a1-28 s1-0)
                         (a2-18 #f)
                         (a3-10 44)
                         (t0-10 320)
                         )
                     (sv-672 a0-108 a1-28 a2-18 a3-10 (the-as bucket-id t0-10))
                     )
                   )
                  )
                )
              (+! s2-0 s4-9)
              )
            )
          )
        )
      (when (!= (-> self time) -1.0)
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (vector+! gp-1 (-> self root trans) (vector-orient-by-quat!
                                                (new 'stack-no-clear 'vector)
                                                (new 'static 'vector :y 24166.4 :z 32768.0 :w 1.0)
                                                (-> self root quat)
                                                )
                    )
          (set! (-> *camera* slave 0 trans quad) (-> gp-1 quad))
          (let ((t9-66 forward-down->inv-matrix)
                (a0-112 (-> *camera* slave 0 tracking))
                (a1-30 (new 'stack-no-clear 'vector))
                (v1-96 (new 'stack-no-clear 'vector))
                )
            (let ((a2-21 (-> self root trans)))
              (let ((a3-11 *up-vector*))
                (let ((t0-12 24166.4))
                  (.mov vf7 t0-12)
                  )
                (.lvf vf5 (&-> a3-11 quad))
                )
              (.lvf vf4 (&-> a2-21 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-96 quad) vf6)
            (t9-66 (the-as matrix a0-112) (vector-! a1-30 v1-96 gp-1) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-2 (new 'stack-no-clear 'matrix)))
        (let* ((a2-23 (-> self node-list data 3 bone transform))
               (v1-101 (-> a2-23 quad 0))
               (a0-113 (-> a2-23 quad 1))
               (a1-32 (-> a2-23 quad 2))
               (a2-24 (-> a2-23 trans quad))
               )
          (set! (-> gp-2 quad 0) v1-101)
          (set! (-> gp-2 quad 1) a0-113)
          (set! (-> gp-2 quad 2) a1-32)
          (set! (-> gp-2 trans quad) a2-24)
          )
        (if (< (vector-dot
                 (-> gp-2 vector 2)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-2 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-2 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-2)
            )
        (spawn-with-matrix (-> self part-off) gp-2)
        )
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set! (-> self time) 0.0)
    (let ((s5-0 #f))
      (let ((gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) "cityv174" -99.0 0)))
        (while (nonzero? (get-status *gui-control* gp-0))
          (suspend)
          (when (or (cpad-pressed? 0 triangle) (cpad-pressed? 0 confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (set-action!
              *gui-control*
              (gui-action stop)
              gp-0
              (gui-channel none)
              (gui-action none)
              (the-as string #f)
              (the-as (function gui-connection symbol) #f)
              (the-as process #f)
              )
            (sound-play "inter-burn-bush")
            (set! s5-0 #t)
            )
          )
        )
      (when (not s5-0)
        (until #f
          (when (or (cpad-pressed? 0 confirm) (cpad-pressed? 0 triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (sound-play "menu-pick")
            #t
            (goto cfg-17)
            )
          (suspend)
          )
        #f
        )
      )
    (until (process-release? *target*)
      (label cfg-17)
      (suspend)
      )
    (go-virtual idle)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      )
    )
  )

(defmethod burning-bush-method-32 ((this burning-bush))
  (let* ((gp-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> this root trans)))
         (f30-0 (vector-dot (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         (f0-2 (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> this root quat)) gp-1))
         )
    (and *target*
         (not (focus-test? *target* pilot))
         (< (fabs f30-0) 10240.0)
         (< 0.0 f0-2)
         (< (fabs f0-2) 20480.0)
         )
    )
  )

(defmethod burning-bush-method-30 ((this burning-bush))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod burning-bush-method-31 ((this burning-bush))
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 173) this))
  (set! (-> this part-off) (create-launch-control (-> *part-group-id-table* 171) this))
  (set! (-> this part-alert) (create-launch-control (-> *part-group-id-table* 172) this))
  0
  (none)
  )

;; WARN: Return type mismatch process-focusable vs burning-bush.
(defmethod relocate ((this burning-bush) (offset int))
  (if (nonzero? (-> this task))
      (&+! (-> this task) offset)
      )
  (if (nonzero? (-> this part-off))
      (&+! (-> this part-off) offset)
      )
  (if (nonzero? (-> this part-alert))
      (&+! (-> this part-alert) offset)
      )
  (the-as burning-bush ((method-of-type process-focusable relocate) this offset))
  )

(defmethod run-logic? ((this burning-bush))
  "Should this process be run? Checked by execute-process-tree."
  (or (not (logtest? (-> this mask) (process-mask actor-pause)))
      (or (and (nonzero? (-> this draw))
               (logtest? (-> this draw status) (draw-control-status on-screen))
               (>= (+ (-> *ACTOR-bank* pause-dist) (-> this root pause-adjust-distance))
                   (vector-vector-distance (-> this root trans) (math-camera-pos))
                   )
               )
          (and (nonzero? (-> this skel)) (!= (-> this skel root-channel 0) (-> this skel channel)))
          (and (nonzero? (-> this draw)) (logtest? (-> this draw status) (draw-control-status uninited)))
          )
      )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this burning-bush) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (burning-bush-method-30 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-burning-bush" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (burning-bush-method-31 this)
  (let ((f0-0 (res-lump-float (-> this entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-local-y! (-> this root quat) (-> this root quat) f0-0)
        )
    )
  (set! (-> this task)
        (new 'process 'game-task-control (res-lump-value arg0 'task-actor game-task-actor :time -1000000000.0))
        )
  (set! (-> this angle) 0.0)
  (set! (-> this root pause-adjust-distance) 819200.0)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(defskelgroup skel-barons-ship-lores barons-ship-lores barons-ship-lores-lod0-jg barons-ship-lores-idle-ja
              ((barons-ship-lores-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 120)
              )

(deftype barons-ship-lores (process-drawable)
  ((paths             path-control  3)
   (sync              sync-eased    :inline)
   (current-path      int32)
   (forward-backward  symbol)
   )
  (:state-methods
    idle
    )
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this barons-ship-lores) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (when (demo?)
    (process-entity-status! this (entity-perm-status dead) #t)
    (go empty-state)
    )
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-barons-ship-lores" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this root pause-adjust-distance) 32768000.0)
  (set! (-> this paths 0) (new 'process 'curve-control this 'path 0.0))
  (set! (-> this paths 1) (new 'process 'curve-control this 'path 1.0))
  (set! (-> this paths 2) (new 'process 'curve-control this 'path 2.0))
  (set! (-> this current-path) 0)
  (set! (-> this forward-backward) #t)
  (logior! (-> this paths 0 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this paths 1 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this paths 2 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> this mask) (process-mask no-kill))
  (let ((a1-9 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if #t
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-9 sync-type) 'sync-eased)
      (set! (-> a1-9 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-9 period) (the-as uint #x8ca0))
    (set! (-> a1-9 entity) arg0)
    (set! (-> a1-9 percent) 0.0)
    (set! (-> a1-9 ease-in) 0.15)
    (set! (-> a1-9 ease-out) 0.15)
    (set! (-> a1-9 pause-in) 0.05)
    (set! (-> a1-9 pause-out) 0.0)
    (initialize! (-> this sync) a1-9)
    )
  (go (method-of-object this idle))
  (none)
  )

(defmethod relocate ((this barons-ship-lores) (offset int))
  (if (nonzero? (-> this paths 0))
      (&+! (-> this paths 0) offset)
      )
  (if (nonzero? (-> this paths 1))
      (&+! (-> this paths 1) offset)
      )
  (if (nonzero? (-> this paths 2))
      (&+! (-> this paths 2) offset)
      )
  (call-parent-method this offset)
  )

(defstate idle (barons-ship-lores)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja :num-func num-func-identity :frame-num 0.0)
      (let ((v1-7 (< 0.5 (get-current-phase-no-mod (-> self sync)))))
        (if (and (!= v1-7 (-> self forward-backward)) (not (-> self forward-backward)))
            (set! (-> self current-path) (mod (+ (-> self current-path) 1) 3))
            )
        (set! (-> self forward-backward) v1-7)
        )
      (let ((f30-1 (get-norm! (-> self sync) 0)))
        (get-point-at-percent-along-path! (-> self paths (-> self current-path)) (-> self root trans) f30-1 'interp)
        (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 0.0)
        (let ((gp-0 (displacement-between-points-at-percent-normalized!
                      (-> self paths (-> self current-path))
                      (new 'stack-no-clear 'vector)
                      f30-1
                      )
                    )
              (s5-0 (quaternion->matrix (new-stack-matrix0) (-> self root quat)))
              )
          (vector-normalize! gp-0 1.0)
          (let* ((a2-4 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 vector 1) 1.0))
                 (a0-18 (vector-normalize! (vector-flatten! (new 'stack-no-clear 'vector) gp-0 a2-4) 1.0))
                 (f0-2 (vector-y-angle a0-18))
                 )
            f0-2
            (set! f0-2 (cond
                         ((< f30-1 0.15)
                          (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
                          (cond
                            ((-> self forward-backward)
                             (+ 16384.0 (* 109226.664 f30-1) f0-2)
                             )
                            (else
                              (+! f0-2 (* 109226.664 (- 0.15 f30-1)))
                              f0-2
                              )
                            )
                          )
                         (else
                           (when (< 0.9 f30-1)
                             (let ((f1-12 (- 1.0 (* 10.0 (+ -0.9 f30-1)))))
                               (set-vector! (-> self root scale) f1-12 f1-12 f1-12 1.0)
                               )
                             )
                           (if (-> self forward-backward)
                               (set! f0-2 (+ 32768.0 f0-2))
                               )
                           f0-2
                           )
                         )
                  )
            (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 f0-2)
            )
          )
        )
      (suspend)
      )
    #f
    )
  :post ja-post
  )

(defmethod city-race-ring-info-method-9 ((this city-race-ring-info) (arg0 symbol))
  (format arg0 "(static-race-ring-info~%")
  (format arg0 "     :pos (~4,,2M ~4,,2M ~4,,2M)~%" (-> this pos x) (-> this pos y) (-> this pos z))
  (let ((f0-3 (-> this pos w)))
    (format arg0 "     :angle (deg ~f)~%" (* 0.005493164 f0-3))
    )
  (if (!= (-> this boost) 1.0)
      (format arg0 "     :boost ~4,,2f~%" (-> this boost))
      )
  (format arg0 "     :dist (meters ~4,,2M)~%" (-> this dist))
  (format arg0 "     ~%)~%")
  0
  (none)
  )

(defmethod city-ambush-info-method-9 ((this city-ambush-info) (arg0 traffic-object-spawn-params))
  (set! (-> arg0 position quad) (-> this array 0 pos quad))
  (set! (-> arg0 nav-mesh) (find-nearest-nav-mesh (-> arg0 position) (the-as float #x7f800000)))
  (vector-reset! (-> arg0 velocity))
  (dotimes (s4-0 (-> this count))
    (let ((v1-3 (-> this array s4-0)))
      (set! (-> arg0 position quad) (-> v1-3 pos quad))
      (set! (-> arg0 object-type) (the-as traffic-type (-> v1-3 obj-type)))
      )
    (send-event *traffic-manager* 'activate-object arg0)
    0
    )
  0
  (none)
  )

(defskelgroup skel-lurker-pipe-lid lurker-pipe-lid lurker-pipe-lid-lod0-jg lurker-pipe-lid-idle-ja
              ((lurker-pipe-lid-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(deftype lurker-pipe-lid (process-focusable)
  ((angle  degrees)
   (rot    float)
   )
  (:state-methods
    idle
    )
  (:methods
    (lurker-pipe-lid-method-28 (_type_) none)
    (lurker-pipe-lid-method-29 (_type_) none)
    (lurker-pipe-lid-method-30 (_type_) none)
    )
  )


(defstate idle (lurker-pipe-lid)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('spin)
       (set! (-> self angle) 196608.0)
       (set! (-> self rot) -655360.0)
       )
      )
    )
  :enter (behavior ()
    '()
    )
  :exit (behavior ()
    '()
    )
  :trans (behavior ()
    '()
    )
  :code sleep-code
  :post (behavior ()
    (if (< 0.0 (-> self angle))
        (set! (-> self angle)
              (- (-> self angle) (* 6.0 (seconds-per-frame) (fmax 1820.4445 (fmin (-> self angle) (-> self angle)))))
              )
        (set! (-> self angle) 0.0)
        )
    (quaternion-vector-angle! (-> self root quat) *x-vector* (-> self angle))
    (ja-post)
    )
  )

(defmethod lurker-pipe-lid-method-28 ((this lurker-pipe-lid))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod lurker-pipe-lid-method-29 ((this lurker-pipe-lid))
  (logior! (-> this mask) (process-mask crate))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this lurker-pipe-lid) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (lurker-pipe-lid-method-28 this)
  (process-drawable-from-entity! this arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-lurker-pipe-lid" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (lurker-pipe-lid-method-29 this)
  (set! (-> this angle) 0.0)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )

(deftype ctyn-lamp (process-focusable)
  ()
  (:state-methods
    idle
    die
    )
  (:methods
    (ctyn-lamp-method-29 (_type_) none)
    (ctyn-lamp-method-30 (_type_) none)
    )
  )


(defskelgroup skel-ctyn-lamp ctyn-lamp ctyn-lamp-lod0-jg ctyn-lamp-idle-ja
              ((ctyn-lamp-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defskelgroup skel-ctyn-lamp-explode ctyn-lamp ctyn-lamp-explode-lod0-jg ctyn-lamp-explode-idle-ja
              ((ctyn-lamp-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

(define *ctyn-lamp-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(defstate idle (ctyn-lamp)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (-> block param 1)
       (let ((s5-0 (the-as process-drawable proc))
             (gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1)))
             )
         (set! (-> gp-0 fountain-rand-transv-lo quad) (-> s5-0 root trans quad))
         (set! (-> gp-0 fountain-rand-transv-hi x) 16384.0)
         (set! (-> gp-0 fountain-rand-transv-hi y) 40960.0)
         (process-spawn
           joint-exploder
           (art-group-get-by-name *level* "skel-ctyn-lamp-explode" (the-as (pointer uint32) #f))
           5
           gp-0
           *ctyn-lamp-exploder-params*
           :to self
           )
         )
       (go-virtual die)
       )
      )
    )
  :code sleep-code
  )

(defstate die (ctyn-lamp)
  :virtual #t
  :enter #f
  :exit #f
  :trans #f
  :code (behavior ()
    (sound-play "lamp-hit")
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  :post #f
  )

(defmethod ctyn-lamp-method-29 ((this ctyn-lamp))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 0)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod ctyn-lamp-method-30 ((this ctyn-lamp))
  (logior! (-> this mask) (process-mask crate))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this ctyn-lamp) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
   This commonly includes things such as:
   - stack size
   - collision information
   - loading the skeleton group / bones
   - sounds"
  (ctyn-lamp-method-29 this)
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ctyn-lamp" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ctyn-lamp-method-30 this)
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )
