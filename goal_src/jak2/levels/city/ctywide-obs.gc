;;-*-Lisp-*-
(in-package goal)

;; name: ctywide-obs.gc
;; name in dgo: ctywide-obs
;; dgos: CWI

;; DECOMP BEGINS

(deftype security-wall (process-drawable)
  ((root               collide-shape         :override)
   (pass               int32                 :offset-assert 200)
   (incoming-attack-id uint32                :offset-assert 204)
   (next-message-time  int64                 :offset-assert 208)
   (message            int32                 :offset-assert 216)
   (plane              plane         :inline :offset-assert 224)
   (color              vector        :inline :offset-assert 240)
   (target-pos         vector        :inline :offset-assert 256)
   (flash              float                 :offset-assert 272)
   (touch-count        int32                 :offset-assert 276)
   (breach             symbol                :offset-assert 280)
   )
  :heap-base #xa0
  :method-count-assert 25
  :size-assert         #x11c
  :flag-assert         #x1900a0011c
  (:methods
    (idle-open () _type_ :state 20)
    (idle-close () _type_ :state 21)
    (security-wall-method-22 (_type_ path-control float) vector 22)
    (security-wall-method-23 (_type_) none 23)
    (security-wall-method-24 (_type_) none 24)
    )
  )


(defskelgroup skel-security-wall security-wall security-wall-lod0-jg security-wall-idle-ja
              ((security-wall-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 100.1)
              )

(defmethod security-wall-method-23 security-wall ((obj security-wall))
  (when (< (-> obj next-message-time) (current-time))
    (set! (-> obj next-message-time)
          (the-as int (+ (current-time) (the int (* 300.0 (rand-vu-float-range 2.0 5.0)))))
          )
    (let ((v1-6 (rand-vu-int-count 15)))
      (cond
        ((zero? v1-6)
         (case (-> obj pass)
           ((29)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 1)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 2)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 3)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 4)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 5)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 6)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         )
        ((= v1-6 7)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 8)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         )
        ((= v1-6 9)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv012" -99.0 0)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         )
        ((= v1-6 10)
         (let ((v1-45 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-45)
              (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-45 1)
              (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-45 2)
              (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        ((= v1-6 11)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (let ((v1-57 (rand-vu-int-count 3)))
           (cond
             ((zero? v1-57)
              (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv035" -99.0 0)
              )
             ((= v1-57 1)
              (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv038" -99.0 0)
              )
             ((= v1-57 2)
              (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv058" -99.0 0)
              )
             )
           )
         )
        ((= v1-6 12)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv014" -99.0 0)
         (case (-> obj pass)
           ((29)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 13)
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv011" -99.0 0)
         (case (-> obj pass)
           ((29)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         )
        ((= v1-6 14)
         (case (-> obj pass)
           ((29)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv015" -99.0 0)
            )
           ((30)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv016" -99.0 0)
            )
           ((31)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv017" -99.0 0)
            )
           ((32)
            (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv018" -99.0 0)
            )
           )
         (add-process *gui-control* obj (gui-channel alert) (gui-action play) "cityv013" -99.0 0)
         )
        )
      )
    (+! (-> obj message) 1)
    (when (>= (-> obj message) 5)
      (set! (-> obj message) 0)
      0
      )
    )
  0
  (none)
  )

(defmethod security-wall-method-24 security-wall ((obj security-wall))
  (with-pp
    (let ((s4-0 *target*))
      (when s4-0
        (let* ((f0-0 (vector-vector-distance-squared (-> obj root trans) (-> s4-0 control trans)))
               (f30-0 (+ 40960.0 (-> obj root root-prim local-sphere w)))
               (f1-1 f30-0)
               )
          (when (< f0-0 (* f1-1 f1-1))
            (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 1)))
              (set! (-> s5-0 0 quad) (-> s4-0 control trans quad))
              (when (< (vector-vector-distance-squared (-> obj root trans) (-> obj target-pos)) (* f30-0 f30-0))
                (let ((f0-3 (vector4-dot (-> obj target-pos) (the-as vector (-> obj plane))))
                      (f1-7 (vector4-dot (-> s5-0 0) (the-as vector (-> obj plane))))
                      )
                  (if (and (< (fabs f1-7) 16384.0)
                           (< (fabs f0-3) 16384.0)
                           (or (and (< f0-3 0.0) (>= f1-7 0.0)) (and (< f1-7 0.0) (>= f0-3 0.0)))
                           )
                      (set! (-> obj breach) #t)
                      )
                  )
                )
              (set! (-> obj target-pos quad) (-> s5-0 0 quad))
              )
            (when (-> obj breach)
              (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                (set! (-> a1-2 from) (process->ppointer pp))
                (set! (-> a1-2 num-params) 2)
                (set! (-> a1-2 message) 'attack-invinc)
                (set! (-> a1-2 param 0) (the-as uint #f))
                (let ((v1-32 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                  (let* ((a0-11 *game-info*)
                         (a2-1 (+ (-> a0-11 attack-id) 1))
                         )
                    (set! (-> a0-11 attack-id) a2-1)
                    (set! (-> v1-32 id) a2-1)
                    )
                  (set! (-> v1-32 mode) 'grenade)
                  (set! (-> a1-2 param 1) (the-as uint v1-32))
                  )
                (if (send-event-function *target* a1-2)
                    (set! (-> obj breach) #f)
                    )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defstate idle-close (security-wall)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (the-as
        object
        (case event-type
          (('on)
           (let ((v1-2 (-> self root root-prim)))
             (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
             (let ((v0-0 (the-as int (-> self root backup-collide-with))))
               (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
               v0-0
               )
             )
           )
          (('off)
           (let ((v1-4 (-> self root root-prim)))
             (set! (-> v1-4 prim-core collide-as) (collide-spec))
             (set! (-> v1-4 prim-core collide-with) (collide-spec))
             )
           0
           )
          (('attack)
           (let ((v1-5 (the-as object (-> event param 1))))
             (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
               (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
               (let* ((s5-0 proc)
                      (s3-0 (if (type? s5-0 process-drawable)
                                (the-as process-drawable s5-0)
                                )
                            )
                      )
                 (when s3-0
                   (let ((s5-1 (process-spawn
                                 manipy
                                 :init manipy-init
                                 (-> s3-0 root trans)
                                 (-> self entity)
                                 (art-group-get-by-name *level* "skel-generic-ripples" (the-as (pointer uint32) #f))
                                 #f
                                 0
                                 :to self
                                 )
                               )
                         )
                     (when s5-1
                       (send-event (ppointer->process s5-1) 'anim-mode 'play1)
                       (send-event (ppointer->process s5-1) 'speed 1.5)
                       (send-event (ppointer->process s5-1) 'art-joint-anim "generic-ripples-idle" 0)
                       (set-vector! (-> (the-as process-drawable (-> s5-1 0)) root scale) 1.0 1.0 1.0 1.0)
                       (quaternion-rotate-local-x! (-> (the-as process-drawable (-> s5-1 0)) root quat) (-> self root quat) -16384.0)
                       (let ((v1-45 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                         (let ((a0-29 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a1-11 *up-vector*))
                             (let ((a2-9 8192.0))
                               (.mov vf7 a2-9)
                               )
                             (.lvf vf5 (&-> a1-11 quad))
                             )
                           (.lvf vf4 (&-> a0-29 quad))
                           )
                         (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                         (.mul.x.vf acc vf5 vf7 :mask #b111)
                         (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                         (.svf (&-> v1-45 quad) vf6)
                         )
                       (let ((f0-6 (vector4-dot (-> (the-as process-drawable (-> s5-1 0)) root trans) (the-as vector (-> self plane)))))
                         (let ((v1-52 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a0-33 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                             (let ((a1-12 (-> self plane)))
                               (let ((a2-10 (- f0-6)))
                                 (.mov vf7 a2-10)
                                 )
                               (.lvf vf5 (&-> a1-12 quad))
                               )
                             (.lvf vf4 (&-> a0-33 quad))
                             )
                           (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                           (.mul.x.vf acc vf5 vf7 :mask #b111)
                           (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                           (.svf (&-> v1-52 quad) vf6)
                           )
                         (let ((v1-55 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                           (let ((a0-36 (-> (the-as process-drawable (-> s5-1 0)) root trans)))
                             (let ((a1-13 (-> self plane)))
                               (let ((a2-12 (the-as float (if (< 0.0 f0-6)
                                                              -989855744
                                                              #x45000000
                                                              )
                                                    )
                                            )
                                     )
                                 (.mov vf7 a2-12)
                                 )
                               (.lvf vf5 (&-> a1-13 quad))
                               )
                             (.lvf vf4 (&-> a0-36 quad))
                             )
                           (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                           (.mul.x.vf acc vf5 vf7 :mask #b111)
                           (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                           (.svf (&-> v1-55 quad) vf6)
                           )
                         )
                       (send-event (ppointer->process s5-1) 'trans-hook (lambda () #f))
                       )
                     )
                   )
                 )
               (when (zero? (-> self touch-count))
                 (+! (-> self touch-count) 1)
                 (set! (-> self flash) 0.375)
                 )
               (+! (-> self touch-count) 1)
               (if (and (logtest? (-> proc mask) (process-mask target))
                        (not (logtest? (process-mask projectile) (-> proc mask)))
                        )
                   (the-as int (security-wall-method-23 self))
                   )
               )
             )
           )
          (('touched)
           (when (zero? (-> self touch-count))
             (+! (-> self touch-count) 1)
             (set! (-> self flash) 0.375)
             )
           (+! (-> self touch-count) 1)
           (let ((v1-83 (if (type? proc process-focusable)
                            (the-as process-focusable proc)
                            )
                        )
                 )
             (when v1-83
               (let* ((gp-1 (-> v1-83 root))
                      (a0-45 (if (type? gp-1 collide-shape)
                                 gp-1
                                 )
                             )
                      )
                 (if (and a0-45 (logtest? (-> a0-45 root-prim prim-core collide-as) (collide-spec jak)))
                     (the-as int (security-wall-method-23 self))
                     )
                 )
               )
             )
           )
          )
        )
      )
    )
  :trans (behavior ()
    (security-wall-method-24 self)
    (none)
    )
  ;; og:preserve-this
  :code (behavior ()
    (until #f
      (when (or (and (logtest? (game-feature pass-red) (-> *game-info* features)) (= 29 (-> self pass)))
                (and (logtest? (game-feature pass-green) (-> *game-info* features)) (= 30 (-> self pass)))
                (and (logtest? (game-feature pass-yellow) (-> *game-info* features)) (= 31 (-> self pass)))
                (and (logtest? (game-feature pass-blue) (-> *game-info* features)) (= 32 (-> self pass)))
                )
        (go-virtual idle-open)
        (return #t)
        )
      (let ((f30-0 (calc-fade-from-fog (-> self root trans)))
            (a0-13 (new 'stack-no-clear 'vector))
            (gp-0 (new 'stack-no-clear 'vector))
            )
        (vector-float*! a0-13 (-> self color) f30-0)
        (set-security-color! a0-13)
        (vector-float*! gp-0 (-> self color) (* f30-0 (-> self flash)))
        (set! (-> self flash)
              (seek (-> self flash) 0.0 (-> self clock seconds-per-frame))
              )
        (if (nonzero? (-> self touch-count))
            (+! (-> self touch-count) -1)
            )
        (set-security-flash! gp-0)
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate idle-open (security-wall)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('on)
                      (let ((v1-2 (-> self root root-prim)))
                        (set! (-> v1-2 prim-core collide-as) (-> self root backup-collide-as))
                        (let ((v0-0 (the-as int (-> self root backup-collide-with))))
                          (set! (-> v1-2 prim-core collide-with) (the-as collide-spec v0-0))
                          v0-0
                          )
                        )
                      )
                     (('off)
                      (let ((v1-4 (-> self root root-prim)))
                        (set! (-> v1-4 prim-core collide-as) (collide-spec))
                        (set! (-> v1-4 prim-core collide-with) (collide-spec))
                        )
                      0
                      )
                     )
            )
    )
  :enter (behavior ()
    (let ((v1-1 (-> self root root-prim)))
      (set! (-> v1-1 prim-core collide-as) (collide-spec))
      (set! (-> v1-1 prim-core collide-with) (collide-spec))
      )
    0
    (none)
    )
  :trans (behavior ()
    (let* ((f28-0 (vector4-dot (the-as vector (-> self plane)) (target-pos 0)))
           (f30-0 (calc-fade-from-fog (-> self root trans)))
           (f28-1 (lerp-scale 0.0 1.0 (fabs f28-0) 163840.0 327680.0))
           (gp-1 (new 'stack-no-clear 'vector))
           )
      (when (= f28-1 0.0)
        (cleanup-for-death self)
        (deactivate self)
        )
      (let ((f0-3 (* f30-0 f28-1)))
        (vector-float*! gp-1 (-> self color) f0-3)
        )
      (set! (-> gp-1 w) 1.0)
      (set-security-color! gp-1)
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  )

(defmethod security-wall-method-22 security-wall ((obj security-wall) (arg0 path-control) (arg1 float))
  (let ((s4-0 (new 'static 'vector))
        (s3-0 (new 'static 'vector))
        )
    0.0
    (get-point-in-path! arg0 s4-0 0.0 'exact)
    (get-point-in-path! arg0 s3-0 1.0 'exact)
    (* 0.5 (vector-vector-distance s4-0 s3-0))
    (let ((s2-1 (new 'process 'collide-shape obj (collide-list-enum usually-hit-by-player))))
      (let ((v1-7 (new 'process 'collide-shape-prim-mesh s2-1 (the-as uint 0) (the-as uint 0))))
        (set! (-> v1-7 prim-core collide-as) (collide-spec blocking-plane camera-blocker))
        (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list))
        (set! (-> v1-7 prim-core action) (collide-action solid))
        (set! (-> v1-7 transform-index) 3)
        (set! (-> s2-1 total-prims) (the-as uint 1))
        (set! (-> s2-1 root-prim) v1-7)
        )
      (set! (-> s2-1 nav-radius) (* 0.75 (-> s2-1 root-prim local-sphere w)))
      (let ((v1-10 (-> s2-1 root-prim)))
        (set! (-> s2-1 backup-collide-as) (-> v1-10 prim-core collide-as))
        (set! (-> s2-1 backup-collide-with) (-> v1-10 prim-core collide-with))
        )
      (set! (-> obj root) s2-1)
      )
    (let ((s2-2 (new 'stack-no-clear 'matrix))
          (s1-0 (-> obj root))
          )
      (vector+! (-> s1-0 trans) s4-0 s3-0)
      (vector-float*! (-> s1-0 trans) (-> s1-0 trans) 0.5)
      (+! (-> s1-0 trans y) (* 0.5 arg1))
      (vector-! (the-as vector (-> s2-2 vector)) s3-0 s4-0)
      (let ((f30-1 (vector-normalize-ret-len! (the-as vector (-> s2-2 vector)) 1.0)))
        (set! (-> s1-0 scale x) (* 0.00024414062 f30-1))
        (set! (-> s1-0 scale y) (* 0.00024414062 arg1))
        (set! (-> s1-0 scale z) 1.0)
        (set! (-> s2-2 vector 1 quad) (-> (new 'static 'vector :y 1.0 :w 1.0) quad))
        (vector-cross! (-> s2-2 vector 2) (the-as vector (-> s2-2 vector)) (-> s2-2 vector 1))
        (vector-normalize! (-> s2-2 vector 2) 1.0)
        (matrix->quaternion (-> s1-0 quat) s2-2)
        (set! (-> obj plane quad) (-> s2-2 vector 2 quad))
        (set! (-> obj plane w) (- (vector-dot (-> s2-2 vector 2) (-> obj root trans))))
        (let ((v0-8 (-> obj root root-prim local-sphere)))
          (set! (-> v0-8 x) 0.0)
          (set! (-> v0-8 y) (* 0.00024414062 (* 0.5 arg1)))
          (set! (-> v0-8 z) 0.0)
          (let ((f0-20 0.5)
                (f1-7 (* f30-1 f30-1))
                (f2-2 arg1)
                )
            (set! (-> v0-8 w) (* f0-20 (sqrtf (+ f1-7 (* f2-2 f2-2)))))
            )
          v0-8
          )
        )
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! security-wall ((obj security-wall) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (ctywide-entity-hack)
  (set! (-> obj breach) #f)
  (set! (-> obj pass) (res-lump-value arg0 'pickup-type int :time -1000000000.0))
  (let ((v1-3 (new 'process 'path-control obj 'path 0.0 (the-as entity #f) #f)))
    (set! (-> obj path) v1-3)
    (if (or (not v1-3) (!= (-> v1-3 curve num-cverts) 2))
        (go process-drawable-art-error "bad path")
        )
    )
  (security-wall-method-22 obj (-> obj path) 122880.0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-security-wall" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj root event-self) 'touched)
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> obj draw status) (draw-control-status disable-fog))
  (set-security-texture-masks! (the-as vector (-> obj draw mgeo header texture-usage-group data 4)))
  (set-vector! (-> obj color) 1.0 1.0 1.0 1.0)
  (cond
    ((= (-> obj pass) 29)
     (set-vector! (-> obj color) 1.0 0.0 0.0 1.0)
     )
    ((= (-> obj pass) 31)
     (set-vector! (-> obj color) 1.0 1.0 0.0 1.0)
     )
    ((= (-> obj pass) 30)
     (set-vector! (-> obj color) 0.0 1.0 0.0 1.0)
     )
    ((= (-> obj pass) 32)
     (set-vector! (-> obj color) 0.0 0.0 1.0 1.0)
     )
    )
  (set-security-color! (-> obj color))
  (set-vector! (-> obj draw color-mult) 0.0 0.0 0.0 0.0)
  (set-vector! (-> obj draw color-emissive) 1.0 1.0 1.0 1.0)
  (transform-post)
  (if (or (and (logtest? (game-feature pass-red) (-> *game-info* features)) (= 29 (-> obj pass)))
          (and (logtest? (game-feature pass-green) (-> *game-info* features)) (= 30 (-> obj pass)))
          (and (logtest? (game-feature pass-yellow) (-> *game-info* features)) (= 31 (-> obj pass)))
          (and (logtest? (game-feature pass-blue) (-> *game-info* features)) (= 32 (-> obj pass)))
          )
      (go (method-of-object obj idle-open))
      (go (method-of-object obj idle-close))
      )
  (none)
  )

(deftype fruit-stand (process-focusable)
  ((incoming-attack-id uint32           :offset-assert 204)
   (hack-counter       uint32           :offset-assert 208)
   (count-sparts       uint32           :offset-assert 212)
   (first-sparts       uint32           :offset-assert 216)
   (num-sparts         uint32           :offset-assert 220)
   (sparts-index       uint32 4         :offset-assert 224)
   (sparts-pos         vector 4 :inline :offset-assert 240)
   )
  :heap-base #xb0
  :method-count-assert 30
  :size-assert         #x130
  :flag-assert         #x1e00b00130
  (:methods
    (idle () _type_ :state 27)
    (fruit-stand-method-28 (_type_) none 28)
    (fruit-stand-method-29 (_type_) none 29)
    )
  )


(define *fruit-check-ground-counter* 0)

(defun fruit-check-ground-bounce ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo) (arg3 matrix))
  (let ((v1-1 (-> arg1 key proc))
        (f0-0 (-> arg1 user-float))
        )
    (when (and (>= (-> (the-as fruit-stand v1-1) count-sparts) (-> (the-as fruit-stand v1-1) first-sparts))
               (nonzero? (-> (the-as fruit-stand v1-1) hack-counter))
               )
      (set! (-> (the-as fruit-stand v1-1) sparts-index (-> (the-as fruit-stand v1-1) num-sparts))
            (the-as uint arg3)
            )
      (set-vector!
        (-> (the-as fruit-stand v1-1) sparts-pos (-> (the-as fruit-stand v1-1) num-sparts))
        (-> arg2 launchrot x)
        (-> arg2 launchrot y)
        (-> arg2 launchrot z)
        1.0
        )
      (+! (-> (the-as fruit-stand v1-1) num-sparts) 1)
      (+! (-> (the-as fruit-stand v1-1) hack-counter) -1)
      )
    (+! (-> (the-as fruit-stand v1-1) count-sparts) 1)
    (when (and (< (-> arg2 launchrot y) f0-0) (< (-> arg1 vel-sxvel y) 0.0))
      (set! (-> arg2 launchrot y) f0-0)
      (if (and (< (-> arg1 vel-sxvel y) -122.88) (< (rand-vu-int-count 10) 3))
          (set-vector!
            (new 'stack-no-clear 'vector)
            (-> arg2 launchrot x)
            (-> arg2 launchrot y)
            (-> arg2 launchrot z)
            1.0
            )
          )
      (set! (-> arg1 vel-sxvel y) (* (-> arg1 vel-sxvel y) (- (rand-vu-float-range 0.6 0.8))))
      )
    )
  )

(defun fruit-sparticle-next-on-mode-1 ((arg0 sparticle-system) (arg1 sparticle-cpuinfo) (arg2 sparticle-launchinfo))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (-> arg1 key)))
      (cond
        ((zero? (-> s5-0 state-mode 0))
         (set! (-> arg1 next-time)
               (the-as uint (* (max 1 (the-as int (-> *display* clock (-> arg1 clock-index) sparticle-data x))) 2))
               )
         )
        (else
          (let ((s4-0 (new 'stack-no-clear 'vector)))
            0.0
            0.0
            0.0
            (let* ((f28-0 (/ 1.0 (* 0.00024414062 (-> arg1 omega))))
                   (f26-0 (* (rand-vu-float-range -136.53334 136.53334) f28-0))
                   (f30-0 (* (rand-vu-float-range 0.0 136.53334) f28-0))
                   (f0-8 (* (rand-vu-float-range -13.653334 54.613335) f28-0))
                   )
              (vector-float*! s4-0 (the-as vector (-> s5-0 origin)) f26-0)
              (let ((a1-5 s4-0))
                (let ((v1-8 s4-0))
                  (let ((a0-10 (-> s5-0 origin vector 1)))
                    (let ((a2-1 f30-0))
                      (.mov vf7 a2-1)
                      )
                    (.lvf vf5 (&-> a0-10 quad))
                    )
                  (.lvf vf4 (&-> v1-8 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-5 quad) vf6)
                )
              (let ((a1-6 s4-0))
                (let ((v1-9 s4-0))
                  (let ((a0-11 (-> s5-0 origin vector 2)))
                    (let ((a2-2 f0-8))
                      (.mov vf7 a2-2)
                      )
                    (.lvf vf5 (&-> a0-11 quad))
                    )
                  (.lvf vf4 (&-> v1-9 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-6 quad) vf6)
                )
              )
            (set! (-> arg1 vel-sxvel x) (-> s4-0 x))
            (set! (-> arg1 vel-sxvel y) (-> s4-0 y))
            (set! (-> arg1 vel-sxvel z) (-> s4-0 z))
            )
          (-> arg1 vel-sxvel)
          (set! (-> arg1 user-float) (+ (-> s5-0 origin trans y) (-> arg1 omega)))
          )
        )
      )
    0.0
    )
  )

(defpartgroup group-ctywide-fruit
  :id 185
  :flags (use-local-clock unk-6)
  :bounds (static-bspherem 0 0 0 6)
  :rotate ((degrees 30) (degrees 0) (degrees 0))
  :parts ((sp-item 856 :flags (launch-asap bit7))
    (sp-item 857 :flags (launch-asap bit7))
    (sp-item 858 :flags (launch-asap bit7))
    (sp-item 859 :flags (launch-asap bit7))
    (sp-item 860 :flags (launch-asap bit7))
    )
  )

(defpart 856
  :init-specs ((:texture (new 'static 'texture-id :index #x75 :page #x45e))
    (:num 8.0)
    (:x (meters 2.2) 2 (meters 0.75))
    (:y (meters 1.1))
    (:z (meters -1.25) 2 (meters 0.75))
    (:scale-x (meters 0.75) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g :copy r)
    (:b :copy b)
    (:a 128.0)
    (:omega (degrees 9))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1638.4)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 861)
    (:rotate-y (degrees 0))
    )
  )

(defpart 861
  :init-specs ((:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.96 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 2) (seconds 3.997))
    (:next-launcher 862)
    )
  )

(defpart 860
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 40.0)
    (:x (meters -3.7) 7 (meters 0.25))
    (:y (meters 1.1))
    (:z (meters -1.1) 7 (meters 0.25))
    (:scale-x (meters 0.25) (meters 0.1))
    (:scale-y (meters 0.35) (meters 0.1))
    (:r 0.0 1 160.0)
    (:g 100.0 64.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 4.5))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 819.2)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 863)
    (:rotate-y (degrees 0))
    )
  )

(defpart 859
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 24.0)
    (:x (meters -3.6) 7 (meters 0.25))
    (:y (meters 1.25))
    (:z (meters -1.075) 6 (meters 0.25))
    (:scale-x (meters 0.25) (meters 0.1))
    (:scale-y (meters 0.35) (meters 0.1))
    (:r 0.0 1 160.0)
    (:g 100.0 64.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 4.5))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 819.2)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 863)
    (:rotate-y (degrees 0))
    )
  )

(defpart 863
  :init-specs ((:rot-z (degrees 0) (degrees 360))
    (:rotvel-z (degrees -1.2) (degrees 2.4))
    (:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.97 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 1.5) (seconds 2.997))
    (:next-launcher 864)
    )
  )

(defpart 864
  :init-specs ((:rotvel-z (degrees 0)) (:fade-a -0.42666668))
  )

(defpart 858
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 32.0)
    (:x (meters -0.8) 3 (meters 0.5))
    (:y (meters 1))
    (:z (meters -1) 3 (meters 0.5))
    (:scale-x (meters 0.4) (meters 0.15))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 48.0 32.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 6.7500005))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1228.8)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 865)
    (:rotate-y (degrees 0))
    )
  )

(defpart 857
  :init-specs ((:texture (new 'static 'texture-id :index #x76 :page #x45e))
    (:num 32.0)
    (:x (meters -0.55) 2 (meters 0.5))
    (:y (meters 1.25))
    (:z (meters -0.8) 2 (meters 0.5))
    (:scale-x (meters 0.4) (meters 0.15))
    (:scale-y :copy scale-x)
    (:r 128.0 64.0)
    (:g 48.0 32.0)
    (:b 0.0 5.0)
    (:a 128.0)
    (:omega (degrees 6.7500005))
    (:timer (seconds -0.005))
    (:flags (sp-cpuinfo-flag-2 aux-list sp-cpuinfo-flag-12 use-global-acc))
    (:userdata 1228.8)
    (:func 'fruit-sparticle-next-on-mode-1)
    (:next-launcher 865)
    (:rotate-y (degrees 0))
    )
  )

(defpart 865
  :init-specs ((:accel-y (meters -0.0033333334) (meters -0.0016666667))
    (:friction 0.97 0.02)
    (:func 'fruit-check-ground-bounce)
    (:next-time (seconds 2) (seconds 3.997))
    (:next-launcher 862)
    )
  )

(defpart 862
  :init-specs ((:fade-a -0.42666668))
  )

(defskelgroup skel-fruit-stand cty-fruit-stand cty-fruit-stand-lod0-jg cty-fruit-stand-idle-ja
              ((cty-fruit-stand-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

;; WARN: Return type mismatch int vs object.
(defbehavior fruit-stand-event-handler fruit-stand ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (the-as object (case arg2
                   (('attack)
                    (let ((v1-1 (the-as object (-> arg3 param 1))))
                      (when (!= (-> (the-as attack-info v1-1) id) (-> self incoming-attack-id))
                        (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-1) id))
                        (let ((v0-0 1))
                          (set! (-> self part state-mode 0) (the-as uint v0-0))
                          v0-0
                          )
                        )
                      )
                    )
                   )
          )
  )

(defstate idle (fruit-stand)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (fruit-stand-event-handler proc arg1 event-type event)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (ja-group)
                  :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (dotimes (gp-0 (the-as int (-> self num-sparts)))
      (let ((s5-0 (new 'stack-no-clear 'collide-query))
            (s4-0 (-> *sp-particle-system-2d* cpuinfo-table (-> self sparts-index gp-0)))
            )
        (set! (-> s5-0 start-pos quad) (-> self sparts-pos gp-0 quad))
        (+! (-> s5-0 start-pos y) 4096.0)
        (set-vector! (-> s5-0 move-dist) 0.0 -40960.0 0.0 1.0)
        (let ((v1-5 s5-0))
          (set! (-> v1-5 radius) (-> s4-0 omega))
          (set! (-> v1-5 collide-with) (collide-spec backgnd))
          (set! (-> v1-5 ignore-process0) #f)
          (set! (-> v1-5 ignore-process1) #f)
          (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-5 action-mask) (collide-action solid))
          )
        (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
          (if (>= f0-7 0.0)
              (set! (-> s4-0 user-float) (+ (-> s5-0 start-pos y) (* (-> s5-0 move-dist y) f0-7)))
              )
          (when (< f0-7 0.0)
            )
          )
        )
      )
    (+! (-> self first-sparts) (-> self num-sparts))
    (when (>= (-> self first-sparts) (-> self count-sparts))
      (set! (-> self first-sparts) (the-as uint 0))
      0
      )
    (set! (-> self num-sparts) (the-as uint 0))
    (set! (-> self hack-counter) (the-as uint 4))
    (set! (-> self count-sparts) (the-as uint 0))
    (spawn-with-cspace (-> self part) (the-as cspace (-> self node-list data)))
    (ja-post)
    (none)
    )
  )

(defmethod fruit-stand-method-28 fruit-stand ((obj fruit-stand))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 0)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(defmethod fruit-stand-method-29 fruit-stand ((obj fruit-stand))
  (logior! (-> obj mask) (process-mask crate))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 185) obj))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! fruit-stand ((obj fruit-stand) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (fruit-stand-method-28 obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-fruit-stand" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (fruit-stand-method-29 obj)
  (go (method-of-object obj idle))
  (none)
  )

(deftype cty-fruit-stand (fruit-stand)
  ()
  :heap-base #xb0
  :method-count-assert 30
  :size-assert         #x130
  :flag-assert         #x1e00b00130
  )


(defpartgroup group-cty-guard-turret-hit
  :id 186
  :duration (seconds 3)
  :linger-duration (seconds 1)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 15)
  :parts ((sp-item 866 :period (seconds 5) :length (seconds 0.085) :offset -10)
    (sp-item 867 :fade-after (meters 60) :period (seconds 5) :length (seconds 0.1))
    (sp-item 868 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 5) :length (seconds 0.335))
    (sp-item 869 :fade-after (meters 200) :falloff-to (meters 200) :period (seconds 5) :length (seconds 0.167))
    (sp-item 870 :period (seconds 5) :length (seconds 0.017) :offset -10)
    (sp-item 871 :fade-after (meters 150) :falloff-to (meters 150) :period (seconds 5) :length (seconds 0.167))
    )
  )

(defpart 869
  :init-specs ((:texture (new 'static 'texture-id :index #x34 :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360) :store)
    (:scale-y (meters 0.8) (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a -0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:func 'sparticle-motion-blur)
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 872)
    (:conerot-x '*sp-temp*)
    )
  )

(defpart 871
  :init-specs ((:texture (new 'static 'texture-id :index #x33 :page #xc))
    (:num 1.0 1.0)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 0.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.13333334))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.36)
    (:fade-b -4.24)
    (:fade-a 0.22068965)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085) (seconds 0.015))
    (:next-launcher 872)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 872
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:next-time (seconds 0.017) (seconds 0.065)) (:next-launcher 873))
  )

(defpart 873
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.44)
    (:fade-g -2.36)
    (:fade-b -2.64)
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 874)
    )
  )

(defpart 874
  :init-specs ((:scalevel-x (meters 0.008333334) (meters 0.008333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.2944444)
    (:fade-g -0.7111111)
    (:fade-b -0.094444446)
    (:fade-a -0.06545454 -0.06545454)
    (:next-time (seconds 0.5) (seconds 0.097))
    (:next-launcher 875)
    )
  )

(defpart 875
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0))
  )

(defpart 870
  :init-specs ((:texture (new 'static 'texture-id :index #xbb :page #xc))
    (:num 1.0)
    (:scale-x (meters 5))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 96.0)
    (:scalevel-x (meters 0.5))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -1.28)
    (:fade-b -5.1)
    (:fade-a 0.0)
    (:timer (seconds 0.335))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.167))
    (:next-launcher 876)
    )
  )

(defpart 876
  :init-specs ((:scalevel-x (meters -0.2))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -2.56)
    (:fade-b 0.0)
    (:fade-a -1.92)
    )
  )

(defpart 868
  :init-specs ((:texture (new 'static 'texture-id :index #x32 :page #xc))
    (:num 5.0 3.0)
    (:x (meters 0.25))
    (:scale-x (meters 1) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.083333336) (meters 0.083333336))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -0.18)
    (:fade-b -2.12)
    (:accel-y (meters -0.00016666666) (meters -0.00033333333))
    (:friction 0.87)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 877)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 877
  :init-specs ((:scalevel-x (meters 0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g 0.02)
    (:fade-b 0.23555556)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 878)
    )
  )

(defpart 878
  :init-specs ((:fade-r -0.5543478) (:fade-g -0.5543478) (:fade-a -0.13913043))
  )

(defpart 866
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 3.0 1.0)
    (:x (meters 0) (meters 0.6))
    (:scale-x (meters 2) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 70.0 20.0)
    (:g 70.0 20.0)
    (:b 70.0 20.0)
    (:a 0.0 40.0)
    (:vel-y (meters 0) (meters 0.1))
    (:scalevel-x (meters 0.033333335) (meters 0.016666668))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 3.3)
    (:fade-g 3.12)
    (:fade-b 1.18)
    (:fade-a 1.76)
    (:friction 0.88)
    (:timer (seconds 2.367))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 879)
    (:conerot-x (degrees 0) (degrees 360))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 879
  :init-specs ((:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.53333336)
    (:fade-g -1.9666667)
    (:fade-b -2.2)
    (:fade-a -0.41666666)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 880)
    )
  )

(defpart 880
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.38833332)
    (:fade-g -0.21333334)
    (:fade-b -0.028333334)
    (:fade-a -0.38833332)
    )
  )

(defpart 867
  :init-specs ((:texture (new 'static 'texture-id :index #x31 :page #xc))
    (:num 4.0 2.0)
    (:scale-x (meters 0.1) (meters 0.25))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 128.0 128.0)
    (:g 96.0)
    (:b 64.0)
    (:a 64.0 64.0)
    (:scalevel-x (meters 0.13333334) (meters 0.02))
    (:fade-g 1.6)
    (:fade-b 3.2)
    (:fade-a -1.6)
    (:timer (seconds 0.267))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

(deftype cty-guard-turret (process-focusable)
  ((incoming-attack-id uint32             :offset-assert 204)
   (jm-turret          joint-mod          :offset-assert 208)
   (jm-gunsL           joint-mod          :offset-assert 212)
   (jm-gunsR           joint-mod          :offset-assert 216)
   (angle-turret       degrees            :offset-assert 220)
   (angle-guns         degrees            :offset-assert 224)
   (last-no-zero       int64              :offset-assert 232)
   (next-time-shot     time-frame         :offset-assert 240)
   (num-shots          uint32             :offset-assert 248)
   (focus              focus      :inline :offset-assert 256)
   (id                 int32              :offset-assert 268)
   (destroyed          symbol             :offset-assert 272)
   (button-down?       symbol             :offset-assert 276)
   (hit-points         int32              :offset-assert 280)
   )
  :heap-base #xa0
  :method-count-assert 36
  :size-assert         #x11c
  :flag-assert         #x2400a0011c
  (:methods
    (idle () _type_ :state 27)
    (hostile () _type_ :state 28)
    (explode () _type_ :state 29)
    (wait-for-pushing () _type_ :state 30)
    (pushed () _type_ :state 31)
    (cty-guard-turret-method-32 (_type_) none 32)
    (cty-guard-turret-method-33 (_type_) none 33)
    (cty-guard-turret-method-34 (_type_) none 34)
    (cty-guard-turret-method-35 (_type_) quaternion 35)
    )
  )


(defskelgroup skel-cty-guard-turret cty-guard-turret cty-guard-turret-lod0-jg cty-guard-turret-idle-ja
              ((cty-guard-turret-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 7.5)
              )

(defskelgroup skel-cty-guard-turret-explode cty-guard-turret cty-guard-turret-explode-lod0-jg cty-guard-turret-explode-idle-ja
              ((cty-guard-turret-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 15)
              )

(define *cty-guard-turret-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index 8)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index 6)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index 7)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index 6)
      )
    :collide-spec #x1
    )
  )

(defbehavior cty-guard-turret-event-handler cty-guard-turret ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack)
     (when (and (-> self next-state) (= (-> self next-state name) 'hostile))
       (let ((a0-1 (get-penetrate-using-from-attack-event (the-as process-drawable arg0) arg3))
             (v1-5 (the-as object (-> arg3 param 1)))
             )
         (when (!= (-> (the-as attack-info v1-5) id) (-> self incoming-attack-id))
           (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-5) id))
           (cond
             ((logtest? (penetrate
                          flop
                          punch
                          spin
                          uppercut
                          mech-punch
                          mech-bonk
                          dark-punch
                          dark-bomb
                          dark-giant
                          explode
                          jak-red-shot
                          jak-dark-shot
                          enemy-dark-shot
                          )
                        a0-1
                        )
              (+! (-> self hit-points) -10)
              )
             ((logtest? (attack-info-mask damage) (-> (the-as attack-info v1-5) mask))
              (set! (-> self hit-points) (- (-> self hit-points) (the int (-> (the-as attack-info v1-5) damage))))
              )
             (else
               (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage a0-1)))
               )
             )
           (when (< (-> self hit-points) 0)
             (sound-play "gturret-explode")
             (go-virtual explode)
             )
           )
         )
       )
     )
    (('track)
     (if (and (-> self next-state) (= (-> self next-state name) 'hostile))
         #t
         #f
         )
     )
    )
  )

(defmethod get-trans cty-guard-turret ((obj cty-guard-turret) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (let ((v1-0 (-> obj root)))
    (cond
      ((= arg0 3)
       (let ((v0-0 (vector<-cspace! (new 'static 'vector) (-> obj node-list data 6))))
         (set! (-> v0-0 w) (-> obj root root-prim prim-core world-sphere w))
         v0-0
         )
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

(defmethod get-inv-mass cty-guard-turret ((obj cty-guard-turret))
  0.01
  )

(defstate idle (cty-guard-turret)
  :virtual #t
  :event cty-guard-turret-event-handler
  :enter (behavior ()
    (try-update-focus (-> self focus) *target*)
    (ja-channel-push! 1 0)
    (ja-no-eval :group! (-> self draw art-group data 2) :num! zero)
    (transform-post)
    (logior! (-> self focus-status) (focus-status ignore))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self focus-status) (focus-status ignore))
    (none)
    )
  :code (the-as (function none :behavior cty-guard-turret) sleep-code)
  :post (behavior ()
    (when (>= (-> self id) 0)
      (let* ((v1-4 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
             (gp-0 (if (-> v1-4 info)
                       (-> v1-4 info manager)
                       (the-as handle #f)
                       )
                   )
             )
        (when (handle->process gp-0)
          (if (or (task-node-open? (game-task-node city-power-post-win))
                  (not (send-event (handle->process gp-0) 'guard-turret-status (-> self id) (-> self root trans)))
                  )
              (set! (-> self destroyed) #t)
              )
          )
        )
      )
    (if (= (level-status *level* 'lwideb) 'active)
        (set! (-> self destroyed) #t)
        )
    (let ((gp-2 (handle->process (-> self focus handle))))
      (when (and gp-2
                 (and *traffic-engine*
                      (let ((f0-0 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-2) 0) (-> self root trans)))
                            (f1-0 409600.0)
                            )
                        (< f0-0 (* f1-0 f1-0))
                        )
                      (not (-> self destroyed))
                      )
                 )
        (cond
          ((and (>= (-> self id) 0) (task-node-open? (game-task-node city-power-resolution)))
           (go-virtual hostile)
           )
          (else
            (if (and (focus-test? (the-as process-focusable gp-2) pilot)
                     (>= (the-as uint (get-alert-level *traffic-engine*)) (the-as uint 1))
                     )
                (go-virtual hostile)
                )
            )
          )
        )
      )
    (transform-post)
    (none)
    )
  )

(defstate explode (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('button-down)
                      (let ((v0-0 #t))
                        (set! (-> self button-down?) v0-0)
                        v0-0
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (let ((gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-cty-guard-turret-explode" (the-as (pointer uint32) #f))
        6
        gp-0
        *cty-guard-turret-exploder-params*
        :to self
        )
      )
    (when (and (>= (-> self id) 0) (let ((v1-12 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                                     (handle->process (if (-> v1-12 info)
                                                          (-> v1-12 info manager)
                                                          (the-as handle #f)
                                                          )
                                                      )
                                     )
               )
      (set! (-> self button-down?) #f)
      (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-6 from) (process->ppointer self))
        (set! (-> a1-6 num-params) 1)
        (set! (-> a1-6 message) 'guard-turret-killed)
        (set! (-> a1-6 param 0) (the-as uint (-> self id)))
        (let ((t9-5 send-event-function)
              (v1-23 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
              )
          (t9-5
            (handle->process (if (-> v1-23 info)
                                 (-> v1-23 info manager)
                                 (the-as handle #f)
                                 )
                             )
            a1-6
            )
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    (none)
    )
  :code (behavior ()
    (local-vars (v1-6 handle))
    (cond
      ((and (>= (-> self id) 0)
            (begin
              (let ((v1-4 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                (set! v1-6 (if (-> v1-4 info)
                               (-> v1-4 info manager)
                               (the-as handle #f)
                               )
                      )
                )
              (nonzero? (l32-false-check v1-6))
              )
            (let ((a0-4 (-> v1-6 process 0)))
              (if (= (-> v1-6 pid) (-> a0-4 pid))
                  a0-4
                  )
              )
            )
       (let ((gp-0 (current-time)))
         (until (>= (- (current-time) gp-0) (seconds 2))
           (let ((a1-1 (new 'stack-no-clear 'vector)))
             (set! (-> a1-1 quad) (-> self root trans quad))
             (+! (-> a1-1 y) 10240.0)
             (spawn (-> self part) a1-1)
             )
           (suspend)
           )
         )
       (while (not (-> self button-down?))
         (suspend)
         )
       (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-2 from) (process->ppointer self))
         (set! (-> a1-2 num-params) 1)
         (set! (-> a1-2 message) 'guard-turret-button-pushed)
         (set! (-> a1-2 param 0) (the-as uint (-> self id)))
         (let ((t9-1 send-event-function)
               (v1-25 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
               )
           (t9-1
             (handle->process (if (-> v1-25 info)
                                  (-> v1-25 info manager)
                                  (the-as handle #f)
                                  )
                              )
             a1-2
             )
           )
         )
       (go-virtual pushed)
       )
      (else
        (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! 32.0 0.5) :frame-num 20.0)
        (until (ja-done? 0)
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (+! (-> a1-4 y) 10240.0)
            (spawn (-> self part) a1-4)
            )
          (suspend)
          (ja :num! (seek! 32.0 0.5))
          )
        (let ((gp-1 (current-time)))
          (until (>= (- (current-time) gp-1) (seconds 3))
            (suspend)
            )
          )
        )
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    (none)
    )
  :post (behavior ()
    (ja-post)
    (none)
    )
  )

(defstate wait-for-pushing (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('button-down)
                      (let ((v0-0 #t))
                        (set! (-> self button-down?) v0-0)
                        v0-0
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self button-down?) #f)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'spawn-button)
      (set! (-> a1-0 param 0) (the-as uint (-> self id)))
      (set! (-> a1-0 param 1) (the-as uint #f))
      (let ((t9-0 send-event-function)
            (v1-6 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-6 info)
                               (-> v1-6 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    (none)
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! 20.0) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0))
      )
    (while (not (-> self button-down?))
      (suspend)
      )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) (process->ppointer self))
      (set! (-> a1-2 num-params) 1)
      (set! (-> a1-2 message) 'guard-turret-button-pushed)
      (set! (-> a1-2 param 0) (the-as uint (-> self id)))
      (let ((t9-3 send-event-function)
            (v1-25 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-3
          (handle->process (if (-> v1-25 info)
                               (-> v1-25 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-2
          )
        )
      )
    (loop
      (suspend)
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    (none)
    )
  :post (behavior ()
    (ja-post)
    (none)
    )
  )

(defstate pushed (cty-guard-turret)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('close)
                      (let ((v0-0 #t))
                        (set! (-> self button-down?) v0-0)
                        v0-0
                        )
                      )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self button-down?) #f)
    (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-0 from) (process->ppointer self))
      (set! (-> a1-0 num-params) 2)
      (set! (-> a1-0 message) 'spawn-button)
      (set! (-> a1-0 param 0) (the-as uint (-> self id)))
      (set! (-> a1-0 param 1) (the-as uint #t))
      (let ((t9-0 send-event-function)
            (v1-7 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
            )
        (t9-0
          (handle->process (if (-> v1-7 info)
                               (-> v1-7 info manager)
                               (the-as handle #f)
                               )
                           )
          a1-0
          )
        )
      )
    (setup-masks (-> self draw) 0 2)
    (set! (-> self root root-prim specific 0) (+ (-> self root root-prim specific 1) -1))
    (set! (-> self button-down?) #f)
    (none)
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (ja-aframe 20.0 0))
                :frame-num (ja-aframe 20.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 20.0 0)))
      )
    (while (not (-> self button-down?))
      (suspend)
      )
    (ja-no-eval :group! (-> self draw art-group data 3)
                :num! (seek! (ja-aframe 32.0 0))
                :frame-num (ja-aframe 20.0 0)
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 32.0 0)))
      )
    (let ((gp-4 (current-time)))
      (until (>= (- (current-time) gp-4) (seconds 5))
        (suspend)
        )
      )
    (set! (-> self root root-prim specific 0) (-> self root root-prim specific 1))
    (setup-masks (-> self draw) 2 0)
    (go-virtual idle)
    (none)
    )
  :post (behavior ()
    (ja-post)
    (none)
    )
  )

;; WARN: Return type mismatch (pointer process) vs none.
(defmethod cty-guard-turret-method-34 cty-guard-turret ((obj cty-guard-turret))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s2-0 (-> obj node-list data 7 bone transform))
          (s5-0 (-> obj node-list data 8 bone transform))
          (s4-0 (new 'stack-no-clear 'projectile-init-by-other-params))
          )
      (let ((s1-0 (new 'stack-no-clear 'vector))
            (s3-0 (new 'stack-no-clear 'vector))
            )
        (vector<-matrix! s1-0 s2-0)
        (let ((a1-1 s1-0))
          (let ((v1-4 s1-0))
            (let ((a0-2 (-> s2-0 vector 2)))
              (let ((a2-1 10727.424))
                (.mov vf7 a2-1)
                )
              (.lvf vf5 (&-> a0-2 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-1 quad) vf6)
          )
        (vector<-matrix! s3-0 s5-0)
        (let ((a1-3 s3-0))
          (let ((v1-5 s3-0))
            (let ((a0-4 (-> s5-0 vector 2)))
              (let ((a2-3 -10727.424))
                (.mov vf7 a2-3)
                )
              (.lvf vf5 (&-> a0-4 quad))
              )
            (.lvf vf4 (&-> v1-5 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-3 quad) vf6)
          )
        (set! (-> s4-0 ent) (-> obj entity))
        (set! (-> s4-0 charge) 1.0)
        (set! (-> s4-0 options) (projectile-options))
        (set! (-> s4-0 notify-handle) (process->handle obj))
        (set! (-> s4-0 owner-handle) (the-as handle #f))
        (set! (-> s4-0 ignore-handle) (process->handle obj))
        (let* ((v1-14 *game-info*)
               (a0-14 (+ (-> v1-14 attack-id) 1))
               )
          (set! (-> v1-14 attack-id) a0-14)
          (set! (-> s4-0 attack-id) a0-14)
          )
        (set! (-> s4-0 timeout) (seconds 4))
        (set! (-> s4-0 pos quad) (-> s1-0 quad))
        (set! (-> s4-0 vel quad) (-> s2-0 vector 2 quad))
        (vector-normalize! (-> s4-0 vel) 819200.0)
        (spawn-projectile guard-shot s4-0 obj *default-dead-pool*)
        (set! (-> s4-0 pos quad) (-> s3-0 quad))
        )
      (vector-negate! (-> s4-0 vel) (-> s5-0 vector 2))
      (vector-normalize! (-> s4-0 vel) 819200.0)
      (spawn-projectile guard-shot s4-0 obj *default-dead-pool*)
      )
    (none)
    )
  )

(defmethod cty-guard-turret-method-35 cty-guard-turret ((obj cty-guard-turret))
  (local-vars (sv-192 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (handle->process (-> obj focus handle))))
      (when s5-0
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (set! (-> s4-0 quad) (-> (get-trans (the-as process-focusable s5-0) 3) quad))
          (let ((s0-0 (new 'stack-no-clear 'vector)))
            (let ((v1-8 (-> obj root trans)))
              (let ((a0-5 *y-vector*))
                (let ((a1-3 10240.0))
                  (.mov vf7 a1-3)
                  )
                (.lvf vf5 (&-> a0-5 quad))
                )
              (.lvf vf4 (&-> v1-8 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> s0-0 quad) vf6)
            (let ((f30-0 (vector-vector-xz-distance s4-0 s0-0)))
              (let ((f0-2 (* 0.0000012207031 f30-0))
                    (a0-7 s4-0)
                    )
                (let ((v1-10 s4-0))
                  (let ((a1-6 (-> (the-as process-focusable s5-0) root transv)))
                    (let ((a2-0 f0-2))
                      (.mov vf7 a2-0)
                      )
                    (.lvf vf5 (&-> a1-6 quad))
                    )
                  (.lvf vf4 (&-> v1-10 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a0-7 quad) vf6)
                )
              (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) s4-0 s0-0))
                    (s1-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root quat)))
                    )
                (set! sv-192 (new 'stack-no-clear 'vector))
                (let ((s2-0 (new 'stack-no-clear 'vector)))
                  (-> obj node-list data 6 bone transform)
                  (-> obj node-list data 7 bone transform)
                  (-> obj node-list data 8 bone transform)
                  (vector-rotate90-around-y! sv-192 s3-1)
                  (set! (-> sv-192 y) 0.0)
                  (vector-normalize! sv-192 1.0)
                  (let* ((f26-0 (vector-vector-xz-distance-squared s0-0 s4-0))
                         (f0-4 7389.184)
                         (f28-0 (* f0-4 f0-4))
                         (t9-6 vector-vector-xz-distance-squared)
                         (a0-13 (new 'stack-no-clear 'vector))
                         )
                    (let ((v1-27 7389.184))
                      (.mov vf7 v1-27)
                      )
                    (.lvf vf5 (&-> sv-192 quad))
                    (.lvf vf4 (&-> s0-0 quad))
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> a0-13 quad) vf6)
                    (let* ((f2-0 (t9-6 a0-13 s4-0))
                           (f28-1 (acos (fmax -1.0 (fmin 1.0 (/ (- (- f26-0 f28-0) f2-0) (* -2.0 (sqrtf f2-0) (sqrtf f28-0)))))))
                           )
                      (let ((s0-1 (new 'stack-no-clear 'vector))
                            (s4-1 (new 'stack-no-clear 'vector))
                            )
                        (if (< f28-1 11832.889)
                            (set! f28-1 11832.889)
                            )
                        (rot-zxy-from-vector! s0-1 s1-0)
                        (rot-zxy-from-vector! s2-0 s3-1)
                        (set! (-> s4-1 x) (deg- (-> s2-0 x) (-> s0-1 x)))
                        (set! (-> s4-1 y) (deg- (-> s2-0 y) (-> s0-1 y)))
                        (cond
                          ((focus-test? (the-as process-focusable s5-0) pilot)
                           (set! (-> obj angle-turret) (deg-seek (-> obj angle-turret) (-> s4-1 y) (* 36408.89 (seconds-per-frame))))
                           (set! (-> obj angle-guns) (deg-seek (-> obj angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                           )
                          (else
                            (set! (-> obj angle-turret) (deg-seek (-> obj angle-turret) (-> s4-1 y) (* 18204.445 (seconds-per-frame))))
                            (set! (-> obj angle-guns) (deg-seek (-> obj angle-guns) (-> s4-1 x) (* 7281.778 (seconds-per-frame))))
                            )
                          )
                        (quaternion-axis-angle! (-> obj jm-turret quat) 0.0 1.0 0.0 (-> obj angle-turret))
                        (when (= (+ (fabs (- (-> obj angle-turret) (-> s4-1 y))) (fabs (- (-> obj angle-guns) (-> s4-1 x)))) 0.0)
                          (set! (-> obj next-time-shot) (+ (current-time) (seconds 1)))
                          (set! (-> obj num-shots) (the-as uint 0))
                          0
                          )
                        )
                      (let ((s5-1 (new 'stack-no-clear 'quaternion)))
                        (let ((f0-42 (/ 45511.11 (* 0.00024414062 f30-0))))
                          (quaternion-axis-angle! s5-1 1.0 0.0 0.0 (fmax (fmin (-> obj angle-guns) f0-42) (- f0-42)))
                          )
                        (quaternion*!
                          (-> obj jm-gunsL quat)
                          (quaternion-axis-angle! (new 'stack-no-clear 'quaternion) 0.0 1.0 0.0 (+ -16384.0 f28-1))
                          s5-1
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        (quaternion-copy! (-> obj jm-gunsR quat) (-> obj jm-gunsL quat))
        )
      )
    )
  )

(defstate hostile (cty-guard-turret)
  :virtual #t
  :event cty-guard-turret-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self num-shots) (the-as uint 0))
    0
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! 20.0 0.5) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 20.0 0.5))
      )
    (until #f
      (cond
        ((zero? (-> self next-time-shot))
         (cty-guard-turret-method-35 self)
         )
        ((>= (current-time) (-> self next-time-shot))
         (cty-guard-turret-method-34 self)
         (+! (-> self num-shots) 1)
         (cond
           ((= (-> self num-shots) 5)
            (set! (-> self next-time-shot) 0)
            0
            )
           (else
             (set! (-> self next-time-shot) (+ (current-time) (seconds 0.1)))
             )
           )
         )
        )
      (suspend)
      (let ((gp-0 (handle->process (-> self focus handle))))
        (cond
          ((and gp-0
                (let ((f0-5 (vector-vector-xz-distance-squared (get-trans (the-as process-focusable gp-0) 0) (-> self root trans)))
                      (f1-0 491520.0)
                      )
                  (< f0-5 (* f1-0 f1-0))
                  )
                )
           (cond
             ((and (>= (-> self id) 0) (task-node-open? (game-task-node city-power-resolution)))
              )
             (else
               (if (and (not (focus-test? (the-as process-focusable gp-0) pilot))
                        *traffic-engine*
                        (zero? (get-alert-level *traffic-engine*))
                        )
                   (goto cfg-36)
                   )
               )
             )
           )
          (else
            (goto cfg-36)
            )
          )
        )
      )
    #f
    (label cfg-36)
    (ja-no-eval :group! (-> self draw art-group data 3) :num! (seek! 32.0 0.5) :frame-num 20.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! 32.0 0.5))
      )
    (go-virtual idle)
    (none)
    )
  :post (behavior ()
    (transform-post)
    (none)
    )
  )

;; WARN: Return type mismatch process-focusable vs cty-guard-turret.
(defmethod relocate cty-guard-turret ((obj cty-guard-turret) (arg0 int))
  (if (nonzero? (-> obj jm-turret))
      (&+! (-> obj jm-turret) arg0)
      )
  (if (nonzero? (-> obj jm-gunsL))
      (&+! (-> obj jm-gunsL) arg0)
      )
  (if (nonzero? (-> obj jm-gunsR))
      (&+! (-> obj jm-gunsR) arg0)
      )
  (the-as
    cty-guard-turret
    ((the-as (function process-focusable int process-focusable) (find-parent-method cty-guard-turret 7)) obj arg0)
    )
  )

(defmethod cty-guard-turret-method-32 cty-guard-turret ((obj cty-guard-turret))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 26624.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-13 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-13 prim-core action) (collide-action solid rideable))
      (set! (-> v1-13 transform-index) 4)
      (set-vector! (-> v1-13 local-sphere) -6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 5)
      (set-vector! (-> v1-15 local-sphere) 6144.0 0.0 0.0 10649.6)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 0.0 14336.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-19 prim-core action) (collide-action solid))
      (set! (-> v1-19 transform-index) 6)
      (set-vector! (-> v1-19 local-sphere) 0.0 -8192.0 0.0 13107.2)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-22 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-22 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-22 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(defmethod cty-guard-turret-method-33 cty-guard-turret ((obj cty-guard-turret))
  (logior! (-> obj mask) (process-mask enemy))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! cty-guard-turret ((obj cty-guard-turret) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (local-vars (v1-23 handle))
  (with-pp
    (cty-guard-turret-method-32 obj)
    (set! (-> obj entity) arg0)
    (process-drawable-from-entity! obj arg0)
    (ctywide-entity-hack)
    (initialize-skeleton
      obj
      (the-as skeleton-group (art-group-get-by-name *level* "skel-cty-guard-turret" (the-as (pointer uint32) #f)))
      (the-as pair 0)
      )
    (cty-guard-turret-method-33 obj)
    (reset-to-collide-spec (-> obj focus) (collide-spec jak player-list))
    (set! (-> obj jm-turret) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 6))
    (set! (-> obj jm-gunsL) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 7))
    (set! (-> obj jm-gunsR) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 8))
    (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 186) obj))
    (set! (-> obj id) (res-lump-value arg0 'extra-id int :default (the-as uint128 -1) :time -1000000000.0))
    (set! (-> obj destroyed) #f)
    (set! (-> obj hit-points) 6)
    (cond
      ((and (>= (-> obj id) 0)
            (begin
              (let ((v1-21 (-> *game-info* sub-task-list (game-task-node city-power-resolution))))
                (set! v1-23 (if (-> v1-21 info)
                                (-> v1-21 info manager)
                                (the-as handle #f)
                                )
                      )
                )
              (nonzero? (l32-false-check v1-23))
              )
            (let ((a0-16 (-> v1-23 process 0)))
              (if (= (-> v1-23 pid) (-> a0-16 pid))
                  a0-16
                  )
              )
            )
       (let ((a1-11 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-11 from) (process->ppointer pp))
         (set! (-> a1-11 num-params) 2)
         (set! (-> a1-11 message) 'guard-turret-status)
         (set! (-> a1-11 param 0) (the-as uint (-> obj id)))
         (set! (-> a1-11 param 1) (the-as uint (-> obj root trans)))
         (let* ((t9-12 send-event-function)
                (v1-33 (-> *game-info* sub-task-list (game-task-node city-power-resolution)))
                (v1-38 (t9-12
                         (handle->process (if (-> v1-33 info)
                                              (-> v1-33 info manager)
                                              (the-as handle #f)
                                              )
                                          )
                         a1-11
                         )
                       )
                )
           (cond
             ((zero? v1-38)
              (go (method-of-object obj idle))
              )
             ((= v1-38 1)
              (go (method-of-object obj wait-for-pushing))
              )
             ((= v1-38 2)
              (go (method-of-object obj pushed))
              )
             (else
               (go (method-of-object obj idle))
               )
             )
           )
         )
       )
      (else
        (go (method-of-object obj idle))
        )
      )
    (none)
    )
  )

(deftype parking-spot (process-drawable)
  ((vehicle     handle                     :offset-assert 200)
   (spawned     symbol                     :offset-assert 208)
   (minimap     connection-minimap         :offset-assert 212)
   (test-sphere sphere             :inline :offset-assert 224)
   )
  :heap-base #x70
  :method-count-assert 25
  :size-assert         #xf0
  :flag-assert         #x19007000f0
  (:methods
    (idle () _type_ :state 20)
    (parking-spot-method-21 (_type_) none 21)
    (parking-spot-method-22 (_type_) none 22)
    (parking-spot-method-23 (_type_ uint) none 23)
    (parking-spot-method-24 (_type_) none 24)
    )
  )


(defmethod parking-spot-method-24 parking-spot ((obj parking-spot))
  (let ((gp-0 (new 'stack-no-clear 'collide-query-with-2vec)))
    (set! (-> gp-0 vec quad) (-> obj root trans quad))
    (set! (-> gp-0 cquery start-pos quad) (-> gp-0 vec quad))
    (vector-reset! (-> gp-0 vec2))
    (set! (-> gp-0 vec2 y) 1.0)
    (set-vector! (-> gp-0 cquery move-dist) 0.0 -40960.0 0.0 1.0)
    (let ((v1-5 (-> gp-0 cquery)))
      (set! (-> v1-5 radius) 1024.0)
      (set! (-> v1-5 collide-with) (collide-spec backgnd))
      (set! (-> v1-5 ignore-process0) #f)
      (set! (-> v1-5 ignore-process1) #f)
      (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-5 action-mask) (collide-action solid))
      )
    (let ((f30-0 (fill-and-probe-using-line-sphere *collide-cache* (-> gp-0 cquery))))
      (when (>= f30-0 0.0)
        (vector+float*! (-> gp-0 vec) (-> gp-0 cquery start-pos) (-> gp-0 cquery move-dist) f30-0)
        (set! (-> gp-0 vec2 quad) (-> gp-0 cquery best-other-tri normal quad))
        (set! (-> obj root trans quad) (-> gp-0 vec quad))
        (format #t "parking-spot::find-ground: ground y ~M~%" (-> gp-0 vec y))
        )
      (if (< f30-0 0.0)
          (format #t "parking-spot::find-ground: could not find ground~%")
          )
      )
    (set! (-> obj root trans quad) (-> gp-0 vec quad))
    (forward-up-nopitch->quaternion (-> obj root quat) (new 'static 'vector :z 1.0 :w 1.0) (-> gp-0 vec2))
    )
  0
  (none)
  )

(defmethod parking-spot-method-21 parking-spot ((obj parking-spot))
  (let ((s5-0 (handle->process (-> obj vehicle))))
    (cond
      (s5-0
        (cond
          ((or (focus-test? (the-as vehicle s5-0) dead inactive)
               (not (logtest? (-> (the-as vehicle s5-0) flags) (rigid-body-object-flag waiting-for-player)))
               (let ((f0-0 (-> obj test-sphere r)))
                 (< (* f0-0 f0-0) (vector-vector-distance-squared (-> (the-as vehicle s5-0) root trans) (-> obj test-sphere)))
                 )
               )
           (logclear! (-> (the-as vehicle s5-0) flags) (rigid-body-object-flag persistent))
           (set! (-> obj vehicle) (the-as handle #f))
           )
          (else
            (if (not (-> obj minimap))
                (set! (-> obj minimap) (add-icon! *minimap* obj (the-as uint 17) (the-as int #f) (the-as vector #t) 0))
                )
            )
          )
        )
      (else
        (when (-> obj minimap)
          (logior! (-> obj minimap flags) (minimap-flag fade-out))
          (set! (-> obj minimap) #f)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod parking-spot-method-23 parking-spot ((obj parking-spot) (arg0 uint))
  (let ((v1-0 (new 'stack-no-clear 'inline-array 'collide-query 1)))
    (let* ((a0-1 (new 'stack-no-clear 'inline-array 'vector 1))
           (a1-1 #x813f9)
           (a2-1 (logand -2 a1-1))
           )
      (set! (-> a0-1 0 quad) (-> obj test-sphere quad))
      (let ((a1-3 (-> v1-0 0)))
        (set! (-> a1-3 best-dist) (the-as float a0-1))
        (set! (-> a1-3 num-spheres) (the-as uint 1))
        (set! (-> a1-3 collide-with) (the-as collide-spec a2-1))
        (set! (-> a1-3 ignore-process0) #f)
        (set! (-> a1-3 ignore-process1) #f)
        (set! (-> a1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> a1-3 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> a1-3 action-mask) (collide-action solid))
        )
      )
    0
    (when (not (fill-and-probe-using-spheres *collide-cache* (-> v1-0 0)))
      (let ((s4-0 (new 'stack 'traffic-object-spawn-params)))
        (set! (-> s4-0 position quad) (-> obj root trans quad))
        (mem-copy! (the-as pointer (-> s4-0 rotation)) (the-as pointer (-> obj root quat)) 16)
        (+! (-> s4-0 position y) 14336.0)
        (set! (-> s4-0 behavior) (the-as uint 0))
        (set! (-> s4-0 object-type) (the-as traffic-type arg0))
        (set! (-> s4-0 id) (the-as uint 0))
        (send-event *traffic-manager* 'activate-object s4-0)
        (when (-> s4-0 proc)
          (set! (-> obj vehicle) (process->handle (-> s4-0 proc)))
          (set! (-> obj spawned) #t)
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! parking-spot ((obj parking-spot) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (set! (-> obj minimap) #f)
  (set! (-> obj vehicle) (the-as handle #f))
  (set! (-> obj spawned) #f)
  (process-drawable-from-entity! obj arg0)
  (logclear! (-> obj mask) (process-mask actor-pause movie))
  (let ((f0-0 (res-lump-float (-> obj entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-y! (-> obj root quat) (-> obj root quat) f0-0)
        )
    )
  (parking-spot-method-24 obj)
  (set! (-> obj test-sphere quad) (-> obj root trans quad))
  (set! (-> obj test-sphere r) 24576.0)
  (set! (-> obj state-time) (current-time))
  (let ((a1-5 (get-random-parking-spot-type *traffic-engine*)))
    (if (!= a1-5 (traffic-type traffic-type-21))
        (parking-spot-method-23 obj (the-as uint a1-5))
        )
    )
  (go (method-of-object obj idle))
  (none)
  )

(defstate idle (parking-spot)
  :virtual #t
  :exit (behavior ()
    (parking-spot-method-21 self)
    (send-event (handle->process (-> self vehicle)) 'traffic-off-force)
    (none)
    )
  :code (the-as (function none :behavior parking-spot) sleep-code)
  :post (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.25))
      (set! (-> self state-time) (current-time))
      (parking-spot-method-21 self)
      (when (not (-> self spawned))
        (let ((f0-0 (vector-vector-distance-squared (camera-pos) (-> self test-sphere)))
              (f1-0 327680.0)
              )
          (when (< (* f1-0 f1-0) f0-0)
            (let ((f1-3 614400.0))
              (when (or (< (* f1-3 f1-3) f0-0) (not (sphere-in-view-frustum? (-> self test-sphere))))
                (let ((a1-1 (get-random-parking-spot-type *traffic-engine*)))
                  (if (!= a1-1 (traffic-type traffic-type-21))
                      (parking-spot-method-23 self (the-as uint a1-1))
                      )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(deftype propa (process-focusable)
  ((sound-id           sound-id  :offset-assert 204)
   (sound-index        uint32    :offset-assert 208)
   (handle             handle    :offset-assert 216)
   (y-rot              float     :offset-assert 224)
   (hit-points         int32     :offset-assert 228)
   (incoming-attack-id uint32    :offset-assert 232)
   )
  :heap-base #x70
  :method-count-assert 32
  :size-assert         #xec
  :flag-assert         #x20007000ec
  (:methods
    (idle () _type_ :state 27)
    (broken () _type_ :state 28)
    (propa-method-29 (_type_) none 29)
    (propa-method-30 (_type_) none 30)
    (propa-method-31 (_type_ vector) none 31)
    )
  )


(defskelgroup skel-propa propa propa-lod0-jg propa-idle-ja
              ((propa-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(define *propa-sounds* (new 'static 'boxed-array :type string
                         "prop009"
                         "prop010"
                         "prop011"
                         "prop012"
                         "prop013"
                         "prop014"
                         "prop015"
                         "prop016"
                         "prop017"
                         "prop018"
                         "prop019"
                         "prop020"
                         "prop021"
                         "prop022"
                         "prop023"
                         "prop024"
                         "prop025"
                         "prop026"
                         "prop028"
                         "prop027"
                         "prop029"
                         "prop030"
                         "prop031"
                         "prop032"
                         "prop033"
                         "prop034"
                         "prop035"
                         "prop036"
                         "prop037"
                         "prop038"
                         "prop039"
                         "prop040"
                         "prop041"
                         "prop042"
                         "prop043"
                         "prop008"
                         "prop006"
                         "prop005"
                         "prop004"
                         "prop002"
                         "prop003"
                         "bar001"
                         "prop044"
                         "prop045"
                         "prop046"
                         "prop047"
                         "prop048"
                         "prop049"
                         "prop051"
                         "prop052"
                         "prop053"
                         "prop054"
                         "prop055"
                         "prop056"
                         )
        )

(define *propa-sounds-class-3* (new 'static 'boxed-array :type string "cityv177"))

(define *propa-sounds-class-2* (new 'static 'boxed-array :type string "cityv176"))

(define *propa-sounds-class-1* (new 'static 'boxed-array :type string "prop050" "spot004" "cityv175"))

(define *propa-sounds-metalheads* (new 'static 'boxed-array :type string
                                    "prop007"
                                    "prop057"
                                    "cityv096"
                                    "cityv097"
                                    "cityv098"
                                    "cityv099"
                                    "cityv142"
                                    "cityv143"
                                    )
        )

(define *propa-sounds-baron-construction* (new 'static 'boxed-array :type string "prop058"))

;; WARN: Return type mismatch int vs knocked-type.
(defun propa-pu->knocked-type ((arg0 penetrate))
  (the-as knocked-type (cond
                         ((logtest? arg0 (penetrate vehicle))
                          7
                          )
                         ((logtest? (penetrate jak-blue-shot) arg0)
                          6
                          )
                         ((logtest? (penetrate jak-yellow-shot enemy-yellow-shot) arg0)
                          4
                          )
                         ((logtest? (penetrate jak-red-shot) arg0)
                          5
                          )
                         ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg0)
                          2
                          )
                         ((logtest? (penetrate dark-bomb dark-giant) arg0)
                          3
                          )
                         ((logtest? arg0 (penetrate mech-punch))
                          1
                          )
                         (else
                           0
                           )
                         )
          )
  )

(defstate broken (propa)
  :virtual #t
  :code (the-as (function none :behavior propa) sleep-code)
  )

(defstate idle (propa)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (the-as
        object
        (case event-type
          (('attack)
           (get-penetrate-using-from-attack-event (the-as process-drawable proc) event)
           (let ((v1-2 (the-as object (-> event param 1))))
             (when (!= (-> (the-as attack-info v1-2) id) (-> self incoming-attack-id))
               (set! (-> self incoming-attack-id) (-> (the-as attack-info v1-2) id))
               (let ((gp-1 (get-penetrate-using-from-attack-event (the-as process-drawable proc) event)))
                 (if (and (not (logtest? (penetrate dark-skin) gp-1)) (zero? (propa-pu->knocked-type gp-1)))
                     (set! (-> self hit-points) (- (-> self hit-points) (penetrate-using->damage gp-1)))
                     (+! (-> self hit-points) -10)
                     )
                 )
               (cond
                 ((< (-> self hit-points) 3)
                  (setup-masks (-> self draw) 0 -1)
                  (setup-masks (-> self draw) 1 0)
                  (let* ((a0-9 (the-as collide-shape-prim-group (-> self root root-prim)))
                         (v1-17 (-> a0-9 child 0))
                         )
                    (let ((a0-11 (-> a0-9 child 1)))
                      (set! (-> a0-11 prim-core collide-as) (-> v1-17 prim-core collide-as))
                      (set! (-> a0-11 prim-core collide-with) (-> v1-17 prim-core collide-with))
                      )
                    (set! (-> v1-17 prim-core collide-as) (collide-spec))
                    (set! (-> v1-17 prim-core collide-with) (collide-spec))
                    )
                  0
                  (let ((gp-2 (get-process *default-dead-pool* part-tracker #x4000)))
                    (when gp-2
                      (let ((t9-7 (method-of-type part-tracker activate)))
                        (t9-7
                          (the-as part-tracker gp-2)
                          *entity-pool*
                          (symbol->string (-> part-tracker symbol))
                          (the-as pointer #x70004000)
                          )
                        )
                      (let ((t9-8 run-function-in-process)
                            (a0-14 gp-2)
                            (a1-10 part-tracker-init)
                            (a2-7 (-> *part-group-id-table* 161))
                            (a3-2 0)
                            (t0-0 #f)
                            (t1-0 #f)
                            (t2-0 #f)
                            (t3-0 *launch-matrix*)
                            )
                        (let ((v1-25 (-> t3-0 trans))
                              (t4-0 (new 'stack-no-clear 'vector))
                              )
                          (let ((t5-1 (-> self root trans)))
                            (let ((t6-0 *up-vector*))
                              (let ((t7-1 8192.0))
                                (.mov vf7 t7-1)
                                )
                              (.lvf vf5 (&-> t6-0 quad))
                              )
                            (.lvf vf4 (&-> t5-1 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> t4-0 quad) vf6)
                          (set! (-> v1-25 quad) (-> t4-0 quad))
                          )
                        ((the-as (function object object object object object object object object none) t9-8)
                         a0-14
                         a1-10
                         a2-7
                         a3-2
                         t0-0
                         t1-0
                         t2-0
                         t3-0
                         )
                        )
                      (-> gp-2 ppointer)
                      )
                    )
                  (go-virtual broken)
                  )
                 ((< (-> self hit-points) 6)
                  (setup-masks (-> self draw) 0 -1)
                  (the-as object (setup-masks (-> self draw) 2 0))
                  )
                 )
               )
             )
           )
          )
        )
      )
    )
  :exit (behavior ()
    (when (nonzero? (-> self sound-id))
      (sound-stop (-> self sound-id))
      (set! (-> self sound-id) (new 'static 'sound-id))
      0
      )
    (none)
    )
  :code (the-as (function none :behavior propa) sleep-code)
  :post (behavior ()
    (cond
      ((or (not (-> *setting-control* user-current speech-control))
           (< 245760.0 (vector-vector-distance (camera-pos) (-> self root trans)))
           )
       (when (nonzero? (-> self sound-id))
         (set-action!
           *gui-control*
           (gui-action stop)
           (-> self sound-id)
           (gui-channel none)
           (gui-action none)
           (the-as string #f)
           (the-as (function gui-connection symbol) #f)
           (the-as process #f)
           )
         (set! (-> self sound-id) (new 'static 'sound-id))
         (+! (-> self sound-index) 1)
         (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
           (set! (-> self sound-index) (the-as uint 0))
           0
           )
         )
       )
      ((< (vector-vector-distance (camera-pos) (-> self root trans)) 225280.0)
       (cond
         ((zero? (-> self sound-id))
          (set! (-> self sound-id) (add-process
                                     *gui-control*
                                     self
                                     (gui-channel alert)
                                     (gui-action play)
                                     (-> *propa-sounds* (-> self sound-index))
                                     -99.0
                                     0
                                     )
                )
          (let ((a1-4 (new 'stack-no-clear 'vector)))
            (set! (-> a1-4 quad) (-> self root trans quad))
            (set! (-> a1-4 w) 40960.0)
            (propa-method-31 self a1-4)
            )
          )
         (else
           (when *sound-player-enable*
             (let ((gp-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
               (set! (-> gp-2 command) (sound-command set-param))
               (set! (-> gp-2 id) (-> self sound-id))
               (set! (-> gp-2 params fo-min) 40)
               (set! (-> gp-2 params fo-max) 55)
               (set! (-> gp-2 params fo-curve) 2)
               (let ((a1-5 (-> self root trans)))
                 (let ((s5-0 self))
                   (when (= a1-5 #t)
                     (if (and s5-0 (type? s5-0 process-drawable) (nonzero? (-> s5-0 root)))
                         (set! a1-5 (-> s5-0 root trans))
                         (set! a1-5 (the-as vector #f))
                         )
                     )
                   )
                 (sound-trans-convert (the-as vector3w (-> gp-2 params trans)) a1-5)
                 )
               (set! (-> gp-2 params mask) (the-as uint 480))
               (-> gp-2 id)
               )
             )
           (when (= (get-status *gui-control* (-> self sound-id)) (gui-status unknown))
             (set! (-> self sound-id) (new 'static 'sound-id))
             (+! (-> self sound-index) 1)
             (when (>= (-> self sound-index) (the-as uint (-> *propa-sounds* length)))
               (set! (-> self sound-index) (the-as uint 0))
               0
               )
             )
           )
         )
       )
      )
    (let ((s5-1 (matrix->trans (-> self node-list data 3 bone transform) (new 'stack-no-clear 'vector)))
          (s4-0 (new 'stack-no-clear 'vector))
          (gp-3 (new 'stack-no-clear 'matrix))
          )
      (when (and (nonzero? (-> self handle)) (handle->process (-> self handle)))
        (let* ((s3-0 (handle->process (-> self handle)))
               (a0-25 (if (type? s3-0 process-focusable)
                          (the-as process-focusable s3-0)
                          )
                      )
               )
          (when a0-25
            (vector-! s4-0 (-> a0-25 root trans) (-> self root trans))
            (set! (-> self y-rot) (deg-seek
                                    (-> self y-rot)
                                    (deg- (vector-y-angle s4-0) (quaternion-y-angle (-> self root quat)))
                                    (* 36408.89 (seconds-per-frame))
                                    )
                  )
            )
          )
        )
      (matrix-rotate-y! gp-3 (-> self y-rot))
      (matrix<-trans gp-3 s5-1)
      (spawn-with-matrix (-> self part) gp-3)
      )
    (none)
    )
  )

(defmethod propa-method-31 propa ((obj propa) (arg0 vector))
  (let ((s5-0 (the-as process-focusable #f)))
    (let ((f30-0 (the-as float #x7f800000))
          (s3-0 (new 'stack-no-clear 'array 'collide-shape 64))
          )
      (countdown (s2-0 (fill-actor-list-for-sphere *actor-hash* (the-as sphere arg0) s3-0 64))
        (let* ((s1-0 (-> s3-0 s2-0))
               (a0-3 (if (type? s1-0 collide-shape)
                         s1-0
                         )
                     )
               )
          (when a0-3
            (let* ((s0-0 (-> a0-3 process))
                   (s1-1 (if (type? s0-0 process-focusable)
                             (the-as process-focusable s0-0)
                             )
                         )
                   )
              (when (and s1-1
                         (!= obj s1-1)
                         (not (focus-test? s1-1 inactive))
                         (not (focus-test? s1-1 disable))
                         (not (focus-test? s1-1 dead))
                         (not (logtest? (process-mask guard) (-> s1-1 mask)))
                         (not (logtest? (process-mask crate) (-> s1-1 mask)))
                         (not (logtest? (process-mask vehicle) (-> s1-1 mask)))
                         )
                (let ((f0-0 (vector-vector-xz-distance (-> obj root trans) (-> s1-1 root trans))))
                  (when (or (not s5-0) (< f0-0 f30-0))
                    (set! s5-0 s1-1)
                    (set! f30-0 f0-0)
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if (and *target* (< (vector-vector-distance (target-pos 0) arg0) (-> arg0 w)))
        (set! s5-0 *target*)
        )
    (if s5-0
        (set! (-> obj handle) (process->handle s5-0))
        (set! (-> obj handle) (the-as handle #f))
        )
    )
  0
  (none)
  )

(defmethod propa-method-29 propa ((obj propa))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec crate))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> s4-0 prim-core action) (collide-action solid rideable))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-12 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-12 prim-core action) (collide-action solid rideable))
      (set! (-> v1-12 transform-index) 3)
      (set-vector! (-> v1-12 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-14 prim-core action) (collide-action solid rideable))
      (set! (-> v1-14 transform-index) 3)
      (set-vector! (-> v1-14 local-sphere) 0.0 0.0 0.0 20480.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(defmethod propa-method-30 propa ((obj propa))
  (logior! (-> obj mask) (process-mask crate))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 170) obj))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! propa ((obj propa) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (propa-method-29 obj)
  (process-drawable-from-entity! obj arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-propa" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (propa-method-30 obj)
  (set! (-> obj sound-index) (the-as uint (rand-vu-int-count (-> *propa-sounds* length))))
  (setup-masks (-> obj draw) 0 -1)
  (setup-masks (-> obj draw) 4 0)
  (set! (-> obj hit-points) 10)
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype baron-statue (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defskelgroup skel-baron-statue baron-statue baron-statue-lod0-jg baron-statue-idle-ja
              ((baron-statue-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 75 0 83)
              )

(defmethod run-logic? baron-statue ((obj baron-statue))
  #t
  )

(defstate idle (baron-statue)
  :virtual #t
  :code (the-as (function none :behavior baron-statue) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! baron-statue ((obj baron-statue) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-baron-statue" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (when (task-node-closed? (game-task-node canyon-insert-items-resolution))
    (cleanup-for-death obj)
    (go empty-state)
    )
  (ja-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype burning-bush (process-focusable)
  ((task       game-task-control         :offset-assert 204)
   (part-off   sparticle-launch-control  :offset-assert 208)
   (part-alert sparticle-launch-control  :offset-assert 212)
   (angle      degrees                   :offset-assert 216)
   (time       float                     :offset-assert 220)
   )
  :heap-base #x60
  :method-count-assert 33
  :size-assert         #xe0
  :flag-assert         #x21006000e0
  (:methods
    (idle () _type_ :state 27)
    (talking () _type_ :state 28)
    (menu () _type_ :state 29)
    (burning-bush-method-30 (_type_) none 30)
    (burning-bush-method-31 (_type_) none 31)
    (burning-bush-method-32 (_type_) object 32)
    )
  )


(defskelgroup skel-burning-bush burning-bush burning-bush-lod0-jg burning-bush-idle-ja
              ((burning-bush-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 3.5)
              )

(defstate idle (burning-bush)
  :virtual #t
  :exit (behavior ()
    '()
    (none)
    )
  :trans (behavior ()
    (let ((gp-0 (get-current-task-event (-> self task)))
          (s5-0 #f)
          )
      (let ((s4-0 (new 'stack-no-clear 'matrix)))
        (let* ((a2-0 (-> self node-list data 3 bone transform))
               (v1-3 (-> a2-0 quad 0))
               (a0-1 (-> a2-0 quad 1))
               (a1-0 (-> a2-0 quad 2))
               (a2-1 (-> a2-0 trans quad))
               )
          (set! (-> s4-0 quad 0) v1-3)
          (set! (-> s4-0 quad 1) a0-1)
          (set! (-> s4-0 quad 2) a1-0)
          (set! (-> s4-0 trans quad) a2-1)
          )
        (when (< (vector-dot
                   (-> s4-0 vector 2)
                   (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans s4-0 (new 'stack-no-clear 'vector)))
                   )
                 0.0
                 )
          )
        (cond
          ((and *traffic-manager* (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                                    (set! (-> a1-2 from) (process->ppointer self))
                                    (set! (-> a1-2 num-params) 0)
                                    (set! (-> a1-2 message) 'get-alert-level)
                                    (and (nonzero? (send-event-function *traffic-manager* a1-2))
                                         (zero? (-> *setting-control* user-current exclusive-task))
                                         )
                                    )
                )
           (spawn-with-matrix (-> self part-alert) s4-0)
           (set! s5-0 #t)
           )
          ((= (-> gp-0 action) (game-task-action show))
           (spawn-with-matrix (-> self part) s4-0)
           )
          ((= (-> gp-0 action) (game-task-action play))
           (spawn-with-matrix (-> self part-off) s4-0)
           )
          ((= (-> gp-0 action) (game-task-action menu))
           (spawn-with-matrix (-> self part) s4-0)
           )
          (else
            (spawn-with-matrix (-> self part-off) s4-0)
            )
          )
        )
      (when (and (not s5-0)
                 (or (= (-> gp-0 action) (game-task-action show)) (= (-> gp-0 action) (game-task-action menu)))
                 (and (burning-bush-method-32 self) (can-display-query? self (the-as string #f) -99.0))
                 )
        (let ((s5-1
                (new 'stack 'font-context *font-default-matrix* 32 280 0.0 (font-color default) (font-flags shadow kerning))
                )
              )
          (set! (-> s5-1 flags) (font-flags shadow kerning large))
          (let ((v1-37 s5-1))
            (set! (-> v1-37 width) (the float 340))
            )
          (let ((v1-38 s5-1))
            (set! (-> v1-38 height) (the float 80))
            )
          (let ((v1-39 s5-1))
            (set! (-> v1-39 scale) 0.9)
            )
          (let ((s4-1 print-game-text))
            (format (clear *temp-string*) (lookup-text! *common-text* (text-id press-triangle-to-talk) #f))
            (s4-1 *temp-string* s5-1 #f 44 (bucket-id progress))
            )
          )
        (when (cpad-pressed? 0 triangle)
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
          (if (= (-> gp-0 action) (game-task-action menu))
              (go-virtual menu)
              (go-virtual talking)
              )
          )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior burning-bush) sleep-code)
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      (none)
      )
    )
  )

(defstate talking (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (process-entity-status! self (entity-perm-status no-kill) #t)
    (none)
    )
  :exit (behavior ()
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'minimap)
    (set! (-> *part-id-table* 832 init-specs 4 initial-valuef) 14336.0)
    (set! (-> *part-id-table* 833 init-specs 4 initial-valuef) 16384.0)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    (none)
    )
  :trans (behavior ()
    (local-vars (sv-272 vector) (sv-288 quaternion))
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (!= (-> self time) -1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (let ((s5-0 gp-0)
                (s4-0 (-> self root trans))
                (s3-0 vector-orient-by-quat!)
                (s2-0 (new 'stack-no-clear 'vector))
                (s1-0 (new 'static 'vector :y 16384.0 :z 40960.0 :w 1.0))
                (s0-0 quaternion-rotate-local-y!)
                )
            (set! sv-272 (new 'stack-no-clear 'vector))
            (set! sv-288 (-> self root quat))
            (let ((a2-0 (* 182.04445 (* 30.0 (sin (* 7281.778 (-> self time)))))))
              (vector+! s5-0 s4-0 (s3-0 s2-0 s1-0 (s0-0 (the-as quaternion sv-272) sv-288 a2-0)))
              )
            )
          (set! (-> *camera* slave 0 trans quad) (-> gp-0 quad))
          (let ((t9-3 forward-down->inv-matrix)
                (a0-5 (-> *camera* slave 0 tracking))
                (a1-2 (new 'stack-no-clear 'vector))
                (v1-17 (new 'stack-no-clear 'vector))
                )
            (let ((a2-3 (-> self root trans)))
              (let ((a3-0 *up-vector*))
                (let ((t0-1 20480.0))
                  (.mov vf7 t0-1)
                  )
                (.lvf vf5 (&-> a3-0 quad))
                )
              (.lvf vf4 (&-> a2-3 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-17 quad) vf6)
            (t9-3 (the-as matrix a0-5) (vector-! a1-2 v1-17 gp-0) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-1 (new 'stack-no-clear 'matrix)))
        (let* ((a2-5 (-> self node-list data 3 bone transform))
               (v1-22 (-> a2-5 quad 0))
               (a0-6 (-> a2-5 quad 1))
               (a1-4 (-> a2-5 quad 2))
               (a2-6 (-> a2-5 trans quad))
               )
          (set! (-> gp-1 quad 0) v1-22)
          (set! (-> gp-1 quad 1) a0-6)
          (set! (-> gp-1 quad 2) a1-4)
          (set! (-> gp-1 trans quad) a2-6)
          )
        (if (< (vector-dot
                 (-> gp-1 vector 2)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-1 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-1)
            )
        (+! (-> self angle) (* 100.0 (rand-vu)))
        (set! (-> *part-id-table* 832 init-specs 4 initial-valuef)
              (+ 14336.0 (* 1228.8 (cos (* 182.04445 (-> self angle)))))
              )
        (set! (-> *part-id-table* 833 init-specs 4 initial-valuef)
              (+ 2048.0 (-> *part-id-table* 832 init-specs 4 initial-valuef))
              )
        (spawn-with-matrix (-> self part) gp-1)
        )
      (none)
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (suspend)
    (if *target*
        (set! (-> *target* neck flex-blend) 1.0)
        )
    (add-setting! 'music-volume 'rel (-> *setting-control* user-current music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> *setting-control* user-current sfx-movie-volume) 0)
    (add-setting! 'dialog-volume 'rel (-> *setting-control* user-current dialog-volume-hint) 0)
    (set! (-> self state-time) (current-time))
    (let* ((v1-21 (get-current-task-event (-> self task)))
           (gp-0 (add-process
                   *gui-control*
                   self
                   (gui-channel bbush)
                   (gui-action play)
                   (the-as string (-> v1-21 scene))
                   -99.0
                   0
                   )
                 )
           )
      (while (nonzero? (get-status *gui-control* gp-0))
        (set! (-> self time) (* 0.0033333334 (the float (- (current-time) (-> self state-time)))))
        (suspend)
        (when (cpad-pressed? 0 triangle)
          (set-action!
            *gui-control*
            (gui-action stop)
            gp-0
            (gui-channel none)
            (gui-action none)
            (the-as string #f)
            (the-as (function gui-connection symbol) #f)
            (the-as process #f)
            )
          (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
          (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
          (sound-play "inter-burn-bush")
          )
        )
      )
    (until (process-release? *target*)
      (suspend)
      )
    (task-node-close! (-> self task current-node))
    (go-virtual idle)
    (none)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      (none)
      )
    )
  )

(defstate menu (burning-bush)
  :virtual #t
  :enter (behavior ()
    (set-setting! 'minimap 'clear 0.0 (minimap-flag minimap))
    (set! (-> self time) -1.0)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (remove-setting! 'minimap)
    (send-event *camera* 'change-target *target*)
    (remove-setting! 'interp-time)
    (remove-setting! 'mode-name)
    (none)
    )
  :trans (behavior ()
    (local-vars
      (sv-352 (function _varargs_ object))
      (sv-368 string)
      (sv-384 (function string font-context symbol int bucket-id float))
      (sv-400 (function _varargs_ object))
      (sv-416 string)
      (sv-432 (function string font-context symbol int bucket-id float))
      (sv-448 (function _varargs_ object))
      (sv-464 string)
      (sv-480 (function string font-context symbol int bucket-id float))
      (sv-496 (function _varargs_ object))
      (sv-512 string)
      (sv-528 (function string font-context symbol int bucket-id float))
      (sv-544 (function _varargs_ object))
      (sv-560 string)
      (sv-576 (function string font-context symbol int bucket-id float))
      (sv-592 (function _varargs_ object))
      (sv-608 string)
      (sv-624 (function string font-context symbol int bucket-id float))
      (sv-640 (function _varargs_ object))
      (sv-656 string)
      (sv-672 (function string font-context symbol int bucket-id float))
      (sv-688 (function _varargs_ object))
      (sv-704 string)
      )
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (>= (- (current-time) (-> self state-time)) (seconds 1.5))
        (let ((gp-0 0)
              (s5-0 0)
              )
          (let ((s4-0 310))
            (when (or (task-node-open? (the-as game-task-node s4-0)) (task-node-closed? (the-as game-task-node s4-0)))
              (if (task-node-closed? (the-as game-task-node s4-0))
                  (set! s5-0 0)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-1 312))
            (when (or (task-node-open? (the-as game-task-node s4-1)) (task-node-closed? (the-as game-task-node s4-1)))
              (if (task-node-closed? (the-as game-task-node s4-1))
                  (set! s5-0 1)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-2 314))
            (when (or (task-node-open? (the-as game-task-node s4-2)) (task-node-closed? (the-as game-task-node s4-2)))
              (if (task-node-closed? (the-as game-task-node s4-2))
                  (set! s5-0 2)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-3 316))
            (when (or (task-node-open? (the-as game-task-node s4-3)) (task-node-closed? (the-as game-task-node s4-3)))
              (if (task-node-closed? (the-as game-task-node s4-3))
                  (set! s5-0 3)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-4 318))
            (when (or (task-node-open? (the-as game-task-node s4-4)) (task-node-closed? (the-as game-task-node s4-4)))
              (if (task-node-closed? (the-as game-task-node s4-4))
                  (set! s5-0 4)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-5 320))
            (when (or (task-node-open? (the-as game-task-node s4-5)) (task-node-closed? (the-as game-task-node s4-5)))
              (if (task-node-closed? (the-as game-task-node s4-5))
                  (set! s5-0 5)
                  )
              (+! gp-0 1)
              )
            )
          (let ((s4-6 322))
            (when (or (task-node-open? (the-as game-task-node s4-6)) (task-node-closed? (the-as game-task-node s4-6)))
              (if (task-node-closed? (the-as game-task-node s4-6))
                  (set! s5-0 6)
                  )
              (+! gp-0 1)
              )
            )
          (when (cpad-pressed? 0 down l-analog-down)
            (+! s5-0 1)
            (cond
              ((< (+ gp-0 -1) s5-0)
               (set! s5-0 (+ gp-0 -1))
               s5-0
               )
              (else
                (the-as int (sound-play "menu-up-down"))
                )
              )
            )
          (when (cpad-pressed? 0 up l-analog-up)
            (+! s5-0 -1)
            (cond
              ((< s5-0 0)
               (set! s5-0 0)
               s5-0
               )
              (else
                (the-as int (sound-play "menu-up-down"))
                )
              )
            )
          (let ((v1-43 s5-0))
            (cond
              ((zero? v1-43)
               (task-node-open! (game-task-node stadium-burning-bush-race-board-resolution))
               )
              ((= v1-43 1)
               (task-node-open! (game-task-node stadium-burning-bush-race-class3-resolution))
               )
              ((= v1-43 2)
               (task-node-open! (game-task-node stadium-burning-bush-race-class2-resolution))
               )
              ((= v1-43 3)
               (task-node-open! (game-task-node stadium-burning-bush-race-class1-resolution))
               )
              ((= v1-43 4)
               (task-node-open! (game-task-node stadium-burning-bush-race-class3-r-resolution))
               )
              ((= v1-43 5)
               (task-node-open! (game-task-node stadium-burning-bush-race-class2-r-resolution))
               )
              ((= v1-43 6)
               (task-node-open! (game-task-node stadium-burning-bush-race-class1-r-resolution))
               )
              )
            )
          (let* ((s4-9 40)
                 (s3-2 36)
                 (s2-0 (- 228 (* gp-0 (/ s4-9 2))))
                 (s1-0 (new
                         'stack
                         'font-context
                         *font-default-matrix*
                         s3-2
                         s2-0
                         0.0
                         (font-color default)
                         (font-flags shadow kerning)
                         )
                       )
                 )
            (set! (-> s1-0 flags) (font-flags shadow kerning middle left large))
            (let ((v1-48 s1-0))
              (set! (-> v1-48 width) (the float 440))
              )
            (let ((v1-49 s1-0))
              (set! (-> v1-49 height) (the float 50))
              )
            (let ((v1-50 s1-0))
              (set! (-> v1-50 scale) 1.0)
              )
            (let ((v1-51 s1-0)
                  (a1-3 s3-2)
                  (a0-59 40)
                  )
              (set! (-> v1-51 origin x) (the float a1-3))
              (set! (-> v1-51 origin y) (the float a0-59))
              )
            (let ((a0-60 s1-0))
              (set! (-> a0-60 color) (font-color progress-old-yellow))
              )
            (let ((s0-0 print-game-text))
              (set! sv-352 format)
              (set! sv-368 (clear *temp-string*))
              (let ((a1-5 (lookup-text! *common-text* (text-id select-event) #f)))
                (sv-352 sv-368 a1-5)
                )
              (s0-0 *temp-string* s1-0 #f 44 (bucket-id progress))
              )
            (let ((v1-55 s1-0))
              (set! (-> v1-55 height) (the float s4-9))
              )
            (dotimes (s0-1 gp-0)
              (let ((v1-56 s1-0)
                    (a1-7 s3-2)
                    (a0-66 s2-0)
                    )
                (set! (-> v1-56 origin x) (the float a1-7))
                (set! (-> v1-56 origin y) (the float a0-66))
                )
              (let ((v1-57 s1-0))
                (set! (-> v1-57 scale) (if (= s0-1 s5-0)
                                           0.8
                                           0.6
                                           )
                      )
                )
              (let ((a0-68 s1-0))
                (set! (-> a0-68 color) (if (= s0-1 s5-0)
                                           (font-color progress-old-selected)
                                           (font-color default)
                                           )
                      )
                )
              (let ((v1-59 s0-1))
                (cond
                  ((zero? v1-59)
                   (set! sv-384 print-game-text)
                   (set! sv-400 format)
                   (set! sv-416 (clear *temp-string*))
                   (let ((a1-9 (lookup-text! *common-text* (text-id board-name) #f)))
                     (sv-400 sv-416 a1-9)
                     )
                   (let ((a0-73 *temp-string*)
                         (a1-10 s1-0)
                         (a2-6 #f)
                         (a3-4 44)
                         (t0-4 320)
                         )
                     (sv-384 a0-73 a1-10 a2-6 a3-4 (the-as bucket-id t0-4))
                     )
                   )
                  ((= v1-59 1)
                   (set! sv-432 print-game-text)
                   (set! sv-448 format)
                   (set! sv-464 (clear *temp-string*))
                   (let ((a1-12 (lookup-text! *common-text* (text-id race-class3) #f)))
                     (sv-448 sv-464 a1-12)
                     )
                   (let ((a0-79 *temp-string*)
                         (a1-13 s1-0)
                         (a2-8 #f)
                         (a3-5 44)
                         (t0-5 320)
                         )
                     (sv-432 a0-79 a1-13 a2-8 a3-5 (the-as bucket-id t0-5))
                     )
                   )
                  ((= v1-59 2)
                   (set! sv-480 print-game-text)
                   (set! sv-496 format)
                   (set! sv-512 (clear *temp-string*))
                   (let ((a1-15 (lookup-text! *common-text* (text-id race-class2) #f)))
                     (sv-496 sv-512 a1-15)
                     )
                   (let ((a0-85 *temp-string*)
                         (a1-16 s1-0)
                         (a2-10 #f)
                         (a3-6 44)
                         (t0-6 320)
                         )
                     (sv-480 a0-85 a1-16 a2-10 a3-6 (the-as bucket-id t0-6))
                     )
                   )
                  ((= v1-59 3)
                   (set! sv-528 print-game-text)
                   (set! sv-544 format)
                   (set! sv-560 (clear *temp-string*))
                   (let ((a1-18 (lookup-text! *common-text* (text-id race-class1) #f)))
                     (sv-544 sv-560 a1-18)
                     )
                   (let ((a0-91 *temp-string*)
                         (a1-19 s1-0)
                         (a2-12 #f)
                         (a3-7 44)
                         (t0-7 320)
                         )
                     (sv-528 a0-91 a1-19 a2-12 a3-7 (the-as bucket-id t0-7))
                     )
                   )
                  ((= v1-59 4)
                   (set! sv-576 print-game-text)
                   (set! sv-592 format)
                   (set! sv-608 (clear *temp-string*))
                   (let ((a1-21 (lookup-text! *common-text* (text-id reverse-race-class3) #f)))
                     (sv-592 sv-608 a1-21)
                     )
                   (let ((a0-97 *temp-string*)
                         (a1-22 s1-0)
                         (a2-14 #f)
                         (a3-8 44)
                         (t0-8 320)
                         )
                     (sv-576 a0-97 a1-22 a2-14 a3-8 (the-as bucket-id t0-8))
                     )
                   )
                  ((= v1-59 5)
                   (set! sv-624 print-game-text)
                   (set! sv-640 format)
                   (set! sv-656 (clear *temp-string*))
                   (let ((a1-24 (lookup-text! *common-text* (text-id reverse-race-class2) #f)))
                     (sv-640 sv-656 a1-24)
                     )
                   (let ((a0-103 *temp-string*)
                         (a1-25 s1-0)
                         (a2-16 #f)
                         (a3-9 44)
                         (t0-9 320)
                         )
                     (sv-624 a0-103 a1-25 a2-16 a3-9 (the-as bucket-id t0-9))
                     )
                   )
                  ((= v1-59 6)
                   (set! sv-672 print-game-text)
                   (set! sv-688 format)
                   (set! sv-704 (clear *temp-string*))
                   (let ((a1-27 (lookup-text! *common-text* (text-id reverse-race-class1) #f)))
                     (sv-688 sv-704 a1-27)
                     )
                   (let ((a0-108 *temp-string*)
                         (a1-28 s1-0)
                         (a2-18 #f)
                         (a3-10 44)
                         (t0-10 320)
                         )
                     (sv-672 a0-108 a1-28 a2-18 a3-10 (the-as bucket-id t0-10))
                     )
                   )
                  )
                )
              (+! s2-0 s4-9)
              )
            )
          )
        )
      (when (!= (-> self time) -1.0)
        (let ((gp-1 (new 'stack-no-clear 'vector)))
          (new 'stack-no-clear 'vector)
          (vector+! gp-1 (-> self root trans) (vector-orient-by-quat!
                                                (new 'stack-no-clear 'vector)
                                                (new 'static 'vector :y 24166.4 :z 32768.0 :w 1.0)
                                                (-> self root quat)
                                                )
                    )
          (set! (-> *camera* slave 0 trans quad) (-> gp-1 quad))
          (let ((t9-66 forward-down->inv-matrix)
                (a0-112 (-> *camera* slave 0 tracking))
                (a1-30 (new 'stack-no-clear 'vector))
                (v1-96 (new 'stack-no-clear 'vector))
                )
            (let ((a2-21 (-> self root trans)))
              (let ((a3-11 *up-vector*))
                (let ((t0-12 24166.4))
                  (.mov vf7 t0-12)
                  )
                (.lvf vf5 (&-> a3-11 quad))
                )
              (.lvf vf4 (&-> a2-21 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> v1-96 quad) vf6)
            (t9-66 (the-as matrix a0-112) (vector-! a1-30 v1-96 gp-1) (-> *camera* local-down))
            )
          )
        )
      (let ((gp-2 (new 'stack-no-clear 'matrix)))
        (let* ((a2-23 (-> self node-list data 3 bone transform))
               (v1-101 (-> a2-23 quad 0))
               (a0-113 (-> a2-23 quad 1))
               (a1-32 (-> a2-23 quad 2))
               (a2-24 (-> a2-23 trans quad))
               )
          (set! (-> gp-2 quad 0) v1-101)
          (set! (-> gp-2 quad 1) a0-113)
          (set! (-> gp-2 quad 2) a1-32)
          (set! (-> gp-2 trans quad) a2-24)
          )
        (if (< (vector-dot
                 (-> gp-2 vector 2)
                 (vector-! (new 'stack-no-clear 'vector) (camera-pos) (matrix->trans gp-2 (new 'stack-no-clear 'vector)))
                 )
               0.0
               )
            (matrix*! gp-2 (matrix-rotate-y! (new 'stack-no-clear 'matrix) 32768.0) gp-2)
            )
        (spawn-with-matrix (-> self part-off) gp-2)
        )
      (none)
      )
    )
  :code (behavior ()
    (set-setting! 'mode-name 'cam-really-fixed 0.0 0)
    (suspend)
    (until (process-grab? *target* #f)
      (suspend)
      )
    (set! (-> self time) 0.0)
    (let ((s5-0 #f))
      (let ((gp-0 (add-process *gui-control* self (gui-channel bbush) (gui-action play) "cityv174" -99.0 0)))
        (while (nonzero? (get-status *gui-control* gp-0))
          (suspend)
          (when (or (cpad-pressed? 0 triangle) (cpad-pressed? 0 confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (set-action!
              *gui-control*
              (gui-action stop)
              gp-0
              (gui-channel none)
              (gui-action none)
              (the-as string #f)
              (the-as (function gui-connection symbol) #f)
              (the-as process #f)
              )
            (sound-play "inter-burn-bush")
            (set! s5-0 #t)
            )
          )
        )
      (when (not s5-0)
        (until #f
          (when (or (cpad-pressed? 0 confirm) (cpad-pressed? 0 triangle))
            (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle circle x confirm))
            (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle circle x confirm))
            (sound-play "menu-pick")
            #t
            (goto cfg-17)
            )
          (suspend)
          )
        #f
        )
      )
    (until (process-release? *target*)
      (label cfg-17)
      (suspend)
      )
    (go-virtual idle)
    (none)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when *target*
        (let* ((a0-0 (-> *target* neck))
               (t9-0 (method-of-object a0-0 look-at!))
               (a1-0 (new 'stack-no-clear 'vector))
               )
          (let ((v1-4 (-> self root trans)))
            (let ((a2-0 *up-vector*))
              (let ((a3-1 20480.0))
                (.mov vf7 a3-1)
                )
              (.lvf vf5 (&-> a2-0 quad))
              )
            (.lvf vf4 (&-> v1-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-0 quad) vf6)
          (t9-0 a0-0 a1-0 #f self)
          )
        )
      (none)
      )
    )
  )

(defmethod burning-bush-method-32 burning-bush ((obj burning-bush))
  (let* ((gp-1 (vector-! (new 'stack-no-clear 'vector) (target-pos 0) (-> obj root trans)))
         (f30-0 (vector-dot (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> obj root quat)) gp-1))
         (f0-2 (vector-dot (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root quat)) gp-1))
         )
    (and *target*
         (not (focus-test? *target* pilot))
         (< (fabs f30-0) 10240.0)
         (< 0.0 f0-2)
         (< (fabs f0-2) 20480.0)
         )
    )
  )

(defmethod burning-bush-method-30 burning-bush ((obj burning-bush))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(defmethod burning-bush-method-31 burning-bush ((obj burning-bush))
  (set! (-> obj part) (create-launch-control (-> *part-group-id-table* 173) obj))
  (set! (-> obj part-off) (create-launch-control (-> *part-group-id-table* 171) obj))
  (set! (-> obj part-alert) (create-launch-control (-> *part-group-id-table* 172) obj))
  0
  (none)
  )

;; WARN: Return type mismatch process-focusable vs burning-bush.
(defmethod relocate burning-bush ((obj burning-bush) (arg0 int))
  (if (nonzero? (-> obj task))
      (&+! (-> obj task) arg0)
      )
  (if (nonzero? (-> obj part-off))
      (&+! (-> obj part-off) arg0)
      )
  (if (nonzero? (-> obj part-alert))
      (&+! (-> obj part-alert) arg0)
      )
  (the-as burning-bush ((method-of-type process-focusable relocate) obj arg0))
  )

(defmethod run-logic? burning-bush ((obj burning-bush))
  (or (not (logtest? (-> obj mask) (process-mask actor-pause)))
      (or (and (nonzero? (-> obj draw))
               (logtest? (-> obj draw status) (draw-control-status on-screen))
               (>= (+ (-> *ACTOR-bank* pause-dist) (-> obj root pause-adjust-distance))
                   (vector-vector-distance (-> obj root trans) (math-camera-pos))
                   )
               )
          (and (nonzero? (-> obj skel)) (!= (-> obj skel root-channel 0) (-> obj skel channel)))
          (and (nonzero? (-> obj draw)) (logtest? (-> obj draw status) (draw-control-status uninited)))
          )
      )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! burning-bush ((obj burning-bush) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (burning-bush-method-30 obj)
  (process-drawable-from-entity! obj arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-burning-bush" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (burning-bush-method-31 obj)
  (let ((f0-0 (res-lump-float (-> obj entity) 'rotoffset)))
    (if (!= f0-0 0.0)
        (quaternion-rotate-local-y! (-> obj root quat) (-> obj root quat) f0-0)
        )
    )
  (set! (-> obj task)
        (new 'process 'game-task-control (res-lump-value arg0 'task-actor game-task-actor :time -1000000000.0))
        )
  (set! (-> obj angle) 0.0)
  (set! (-> obj root pause-adjust-distance) 819200.0)
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(defskelgroup skel-barons-ship-lores barons-ship-lores barons-ship-lores-lod0-jg barons-ship-lores-idle-ja
              ((barons-ship-lores-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 120)
              )

(deftype barons-ship-lores (process-drawable)
  ((paths            path-control 3       :offset-assert 200)
   (sync             sync-eased   :inline :offset-assert 216)
   (current-path     int32                :offset-assert 260)
   (forward-backward symbol               :offset-assert 264)
   )
  :heap-base #x90
  :method-count-assert 21
  :size-assert         #x10c
  :flag-assert         #x150090010c
  (:methods
    (idle () _type_ :state 20)
    )
  )


;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! barons-ship-lores ((obj barons-ship-lores) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (when (demo?)
    (process-entity-status! obj (entity-perm-status dead) #t)
    (go empty-state)
    )
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-barons-ship-lores" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj root pause-adjust-distance) 32768000.0)
  (set! (-> obj paths 0) (new 'process 'curve-control obj 'path 0.0))
  (set! (-> obj paths 1) (new 'process 'curve-control obj 'path 1.0))
  (set! (-> obj paths 2) (new 'process 'curve-control obj 'path 2.0))
  (set! (-> obj current-path) 0)
  (set! (-> obj forward-backward) #t)
  (logior! (-> obj paths 0 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> obj paths 1 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> obj paths 2 flags) (path-control-flag display draw-line draw-point draw-text))
  (logior! (-> obj mask) (process-mask no-kill))
  (let ((a1-9 (new 'stack-no-clear 'sync-info-params)))
    (let ((v1-24 0))
      (if #t
          (set! v1-24 (logior v1-24 1))
          )
      (set! (-> a1-9 sync-type) 'sync-eased)
      (set! (-> a1-9 sync-flags) (the-as sync-flags v1-24))
      )
    (set! (-> a1-9 period) (the-as uint #x8ca0))
    (set! (-> a1-9 entity) arg0)
    (set! (-> a1-9 percent) 0.0)
    (set! (-> a1-9 ease-in) 0.15)
    (set! (-> a1-9 ease-out) 0.15)
    (set! (-> a1-9 pause-in) 0.05)
    (set! (-> a1-9 pause-out) 0.0)
    (initialize! (-> obj sync) a1-9)
    )
  (go (method-of-object obj idle))
  (none)
  )

;; WARN: Return type mismatch process-drawable vs barons-ship-lores.
(defmethod relocate barons-ship-lores ((obj barons-ship-lores) (arg0 int))
  (if (nonzero? (-> obj paths 0))
      (&+! (-> obj paths 0) arg0)
      )
  (if (nonzero? (-> obj paths 1))
      (&+! (-> obj paths 1) arg0)
      )
  (if (nonzero? (-> obj paths 2))
      (&+! (-> obj paths 2) arg0)
      )
  (the-as
    barons-ship-lores
    ((the-as (function process-drawable int process-drawable) (find-parent-method barons-ship-lores 7)) obj arg0)
    )
  )

(defstate idle (barons-ship-lores)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja :num-func num-func-identity :frame-num 0.0)
      (let ((v1-7 (< 0.5 (get-current-phase-no-mod (-> self sync)))))
        (if (and (!= v1-7 (-> self forward-backward)) (not (-> self forward-backward)))
            (set! (-> self current-path) (mod (+ (-> self current-path) 1) 3))
            )
        (set! (-> self forward-backward) v1-7)
        )
      (let ((f30-1 (get-norm! (-> self sync) 0)))
        (get-point-at-percent-along-path! (-> self paths (-> self current-path)) (-> self root trans) f30-1 'interp)
        (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 0.0)
        (let ((gp-0 (displacement-between-points-at-percent-normalized!
                      (-> self paths (-> self current-path))
                      (new 'stack-no-clear 'vector)
                      f30-1
                      )
                    )
              (s5-0 (quaternion->matrix (new-stack-matrix0) (-> self root quat)))
              )
          (vector-normalize! gp-0 1.0)
          (let* ((a2-4 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> s5-0 vector 1) 1.0))
                 (a0-18 (vector-normalize! (vector-flatten! (new 'stack-no-clear 'vector) gp-0 a2-4) 1.0))
                 (f0-2 (vector-y-angle a0-18))
                 )
            f0-2
            (set! f0-2 (cond
                         ((< f30-1 0.15)
                          (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
                          (cond
                            ((-> self forward-backward)
                             (+ 16384.0 (* 109226.664 f30-1) f0-2)
                             )
                            (else
                              (+! f0-2 (* 109226.664 (- 0.15 f30-1)))
                              f0-2
                              )
                            )
                          )
                         (else
                           (when (< 0.9 f30-1)
                             (let ((f1-12 (- 1.0 (* 10.0 (+ -0.9 f30-1)))))
                               (set-vector! (-> self root scale) f1-12 f1-12 f1-12 1.0)
                               )
                             )
                           (if (-> self forward-backward)
                               (set! f0-2 (+ 32768.0 f0-2))
                               )
                           f0-2
                           )
                         )
                  )
            (quaternion-axis-angle! (-> self root quat) 0.0 1.0 0.0 f0-2)
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior barons-ship-lores) ja-post)
  )

(defmethod city-race-ring-info-method-9 city-race-ring-info ((obj city-race-ring-info) (arg0 symbol))
  (format arg0 "(static-race-ring-info~%")
  (format arg0 "     :pos (~4,,2M ~4,,2M ~4,,2M)~%" (-> obj pos x) (-> obj pos y) (-> obj pos z))
  (let ((f0-3 (-> obj pos w)))
    (format arg0 "     :angle (deg ~f)~%" (* 0.005493164 f0-3))
    )
  (if (!= (-> obj boost) 1.0)
      (format arg0 "     :boost ~4,,2f~%" (-> obj boost))
      )
  (format arg0 "     :dist (meters ~4,,2M)~%" (-> obj dist))
  (format arg0 "     ~%)~%")
  0
  (none)
  )

(defmethod city-ambush-info-method-9 city-ambush-info ((obj city-ambush-info) (arg0 traffic-object-spawn-params))
  (set! (-> arg0 position quad) (-> obj array 0 pos quad))
  (set! (-> arg0 nav-mesh) (find-nearest-nav-mesh (-> arg0 position) (the-as float #x7f800000)))
  (vector-reset! (-> arg0 velocity))
  (dotimes (s4-0 (-> obj count))
    (let ((v1-3 (-> obj array s4-0)))
      (set! (-> arg0 position quad) (-> v1-3 pos quad))
      (set! (-> arg0 object-type) (the-as traffic-type (-> v1-3 obj-type)))
      )
    (send-event *traffic-manager* 'activate-object arg0)
    0
    )
  0
  (none)
  )

(defskelgroup skel-lurker-pipe-lid lurker-pipe-lid lurker-pipe-lid-lod0-jg lurker-pipe-lid-idle-ja
              ((lurker-pipe-lid-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3)
              )

(deftype lurker-pipe-lid (process-focusable)
  ((angle degrees  :offset-assert 204)
   (rot   float    :offset-assert 208)
   )
  :heap-base #x60
  :method-count-assert 31
  :size-assert         #xd4
  :flag-assert         #x1f006000d4
  (:methods
    (idle () _type_ :state 27)
    (lurker-pipe-lid-method-28 (_type_) none 28)
    (lurker-pipe-lid-method-29 (_type_) none 29)
    (lurker-pipe-lid-method-30 (_type_) none 30)
    )
  )


(defstate idle (lurker-pipe-lid)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('spin)
                      (set! (-> self angle) 196608.0)
                      (set! (-> self rot) -655360.0)
                      )
                     )
            )
    )
  :enter (behavior ()
    '()
    (none)
    )
  :exit (behavior ()
    '()
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (the-as (function none :behavior lurker-pipe-lid) sleep-code)
  :post (behavior ()
    (if (< 0.0 (-> self angle))
        (set! (-> self angle)
              (- (-> self angle) (* 6.0 (seconds-per-frame) (fmax 1820.4445 (fmin (-> self angle) (-> self angle)))))
              )
        (set! (-> self angle) 0.0)
        )
    (quaternion-vector-angle! (-> self root quat) *x-vector* (-> self angle))
    (ja-post)
    (none)
    )
  )

(defmethod lurker-pipe-lid-method-28 lurker-pipe-lid ((obj lurker-pipe-lid))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-6 prim-core collide-as) (collide-spec crate))
      (set! (-> v1-6 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-6 prim-core action) (collide-action solid rideable))
      (set! (-> v1-6 transform-index) 3)
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-6)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-9 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-9 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-9 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(defmethod lurker-pipe-lid-method-29 lurker-pipe-lid ((obj lurker-pipe-lid))
  (logior! (-> obj mask) (process-mask crate))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! lurker-pipe-lid ((obj lurker-pipe-lid) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (lurker-pipe-lid-method-28 obj)
  (process-drawable-from-entity! obj arg0)
  (ctywide-entity-hack)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-lurker-pipe-lid" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (lurker-pipe-lid-method-29 obj)
  (set! (-> obj angle) 0.0)
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )

(deftype ctyn-lamp (process-focusable)
  ()
  :heap-base #x50
  :method-count-assert 31
  :size-assert         #xcc
  :flag-assert         #x1f005000cc
  (:methods
    (idle () _type_ :state 27)
    (die () _type_ :state 28)
    (ctyn-lamp-method-29 (_type_) none 29)
    (ctyn-lamp-method-30 (_type_) none 30)
    )
  )


(defskelgroup skel-ctyn-lamp ctyn-lamp ctyn-lamp-lod0-jg ctyn-lamp-idle-ja
              ((ctyn-lamp-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              )

(defskelgroup skel-ctyn-lamp-explode ctyn-lamp ctyn-lamp-explode-lod0-jg ctyn-lamp-explode-idle-ja
              ((ctyn-lamp-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 80)
              )

(define *ctyn-lamp-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(defstate idle (ctyn-lamp)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack)
       (-> event param 1)
       (let ((s5-0 (the-as process-drawable proc))
             (gp-0 (new 'stack 'joint-exploder-tuning (the-as uint 1)))
             )
         (set! (-> gp-0 fountain-rand-transv-lo quad) (-> s5-0 root trans quad))
         (set! (-> gp-0 fountain-rand-transv-hi x) 16384.0)
         (set! (-> gp-0 fountain-rand-transv-hi y) 40960.0)
         (process-spawn
           joint-exploder
           (art-group-get-by-name *level* "skel-ctyn-lamp-explode" (the-as (pointer uint32) #f))
           5
           gp-0
           *ctyn-lamp-exploder-params*
           :to self
           )
         )
       (go-virtual die)
       )
      )
    )
  :code (the-as (function none :behavior ctyn-lamp) sleep-code)
  )

(defstate die (ctyn-lamp)
  :virtual #t
  :enter (the-as (function none :behavior ctyn-lamp) #f)
  :exit (the-as (function none :behavior ctyn-lamp) #f)
  :trans (the-as (function none :behavior ctyn-lamp) #f)
  :code (behavior ()
    (sound-play "lamp-hit")
    (let ((v1-3 (-> self root root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  :post (the-as (function none :behavior ctyn-lamp) #f)
  )

(defmethod ctyn-lamp-method-29 ctyn-lamp ((obj ctyn-lamp))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((v1-7 (new 'process 'collide-shape-prim-mesh s5-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-7 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-7 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-7 prim-core action) (collide-action solid))
      (set! (-> v1-7 transform-index) 0)
      (set-vector! (-> v1-7 local-sphere) 0.0 0.0 0.0 20480.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-7)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-10 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-10 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-10 prim-core collide-with))
      )
    (set! (-> obj root) s5-0)
    )
  0
  (none)
  )

(defmethod ctyn-lamp-method-30 ctyn-lamp ((obj ctyn-lamp))
  (logior! (-> obj mask) (process-mask crate))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ctyn-lamp ((obj ctyn-lamp) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (ctyn-lamp-method-29 obj)
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-ctyn-lamp" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (ctyn-lamp-method-30 obj)
  (transform-post)
  (go (method-of-object obj idle))
  (none)
  )
