;;-*-Lisp-*-
(in-package goal)

;; name: trail.gc
;; name in dgo: trail
;; dgos: CWI

;; DECOMP BEGINS

;; WARN: Return type mismatch symbol vs none.
(defmethod debug-draw trail-conn ((obj trail-conn) (arg0 trail-graph) (arg1 int))
  (let ((a2-3 (-> arg0 node (-> obj head-id)))
        (v1-2 (-> arg0 node (-> obj tail-id)))
        (s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set-vector! s4-0 (* 4096.0 (the float (-> a2-3 x))) 53248.0 (* 4096.0 (the float (-> a2-3 z))) 1.0)
    (set-vector! s3-0 (* 4096.0 (the float (-> v1-2 x))) 53248.0 (* 4096.0 (the float (-> v1-2 z))) 1.0)
    (vector-lerp! s5-0 s4-0 s3-0 0.5)
    (let* ((s2-0 (math-camera-pos))
           (f0-12 (vector-vector-distance-squared s4-0 s2-0))
           (f1-8 819200.0)
           )
      (when (or (< f0-12 (* f1-8 f1-8))
                (let ((f0-13 (vector-vector-distance-squared s3-0 s2-0))
                      (f1-11 819200.0)
                      )
                  (< f0-13 (* f1-11 f1-11))
                  )
                (let ((f0-14 (vector-vector-distance-squared s5-0 s2-0))
                      (f1-14 819200.0)
                      )
                  (< f0-14 (* f1-14 f1-14))
                  )
                )
        (add-debug-line #t (bucket-id debug2) s4-0 s3-0 *color-orange* #f (the-as rgba -1))
        (let ((s4-1 add-debug-text-3d)
              (s3-1 #t)
              (s2-1 324)
              )
          (format (clear *temp-string*) "~D" arg1)
          (s4-1 s3-1 (the-as bucket-id s2-1) *temp-string* s5-0 (font-color yellow) (the-as vector2h #f))
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod debug-draw trail-node ((obj trail-node) (arg0 int))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'sphere))
        )
    (set-vector! s5-0 (* 4096.0 (the float (-> obj x))) 53248.0 (* 4096.0 (the float (-> obj z))) 1.0)
    (set! (-> s4-0 quad) (-> s5-0 quad))
    (set! (-> s4-0 r) 4096.0)
    (let ((f0-7 (vector-vector-distance-squared s5-0 (math-camera-pos)))
          (f1-4 819200.0)
          )
      (when (and (< f0-7 (* f1-4 f1-4)) (sphere-in-view-frustum? s4-0))
        (add-debug-x #t (bucket-id debug2) s5-0 *color-red*)
        (let ((s4-1 add-debug-text-3d)
              (s3-1 #t)
              (s2-1 324)
              )
          (format (clear *temp-string*) "~D" arg0)
          (s4-1 s3-1 (the-as bucket-id s2-1) *temp-string* s5-0 (font-color cyan) (the-as vector2h #f))
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod debug-draw-cell trail-graph ((obj trail-graph) (arg0 int))
  (local-vars (sv-80 int) (sv-96 (function _varargs_ object)))
  (let* ((s5-0 (-> obj conn-hash))
         (s4-0 (-> s5-0 cell arg0))
         (s3-0 (new 'stack-no-clear 'inline-array 'vector 2))
         )
    (set-vector!
      (-> s3-0 0)
      (+ (* (-> s5-0 cell-width) (the float (logand arg0 15))) (-> s5-0 origin x))
      53248.0
      (+ (* (-> s5-0 cell-width) (the float (/ arg0 16))) (-> s5-0 origin z))
      1.0
      )
    (set! (-> s3-0 1 quad) (-> s3-0 0 quad))
    (+! (-> s3-0 1 x) (-> s5-0 cell-width))
    (set! (-> s3-0 2 quad) (-> s3-0 1 quad))
    (+! (-> s3-0 2 z) (-> s5-0 cell-width))
    (set! (-> s3-0 3 quad) (-> s3-0 2 quad))
    (set! (-> s3-0 3 x) (- (-> s3-0 3 x) (-> s5-0 cell-width)))
    (add-debug-line #t (bucket-id debug-no-zbuf1) (-> s3-0 0) (-> s3-0 1) *color-white* #f (the-as rgba -1))
    (add-debug-line #t (bucket-id debug-no-zbuf1) (-> s3-0 1) (-> s3-0 2) *color-white* #f (the-as rgba -1))
    (add-debug-line #t (bucket-id debug-no-zbuf1) (-> s3-0 2) (-> s3-0 3) *color-white* #f (the-as rgba -1))
    (add-debug-line #t (bucket-id debug-no-zbuf1) (-> s3-0 3) (-> s3-0 0) *color-white* #f (the-as rgba -1))
    (set-vector!
      (-> s3-0 3)
      (* 0.5 (+ (-> s3-0 0 x) (-> s3-0 2 x)))
      (-> s3-0 0 y)
      (* 0.5 (+ (-> s3-0 0 z) (-> s3-0 2 z)))
      1.0
      )
    (let ((s1-0 add-debug-text-3d)
          (s0-0 #t)
          )
      (set! sv-80 324)
      (set! sv-96 format)
      (let ((a0-20 (clear *temp-string*))
            (a1-5 "cell ~D (~D,~D)")
            (a2-4 arg0)
            (a3-4 (logand arg0 15))
            (t0-4 (/ arg0 16))
            )
        (sv-96 a0-20 a1-5 a2-4 a3-4 t0-4)
        )
      (let ((a2-5 *temp-string*)
            (a3-5 (-> s3-0 3))
            (t0-5 1)
            (t1-4 #f)
            )
        (s1-0 s0-0 (the-as bucket-id sv-80) a2-5 a3-5 (the-as font-color t0-5) (the-as vector2h t1-4))
        )
      )
    (countdown (s2-1 (-> s4-0 conn-count))
      (let ((s1-1 (-> obj conn (-> s5-0 conn-ids (+ s2-1 (-> s4-0 first-conn))))))
        (get-position (-> obj node (-> s1-1 head-id)) (-> s3-0 0))
        (set! (-> s3-0 0 y) 53248.0)
        (set! (-> s3-0 0 x) (+ -2048.0 (-> s3-0 0 x)))
        (set! (-> s3-0 0 z) (+ -2048.0 (-> s3-0 0 z)))
        (get-position (-> obj node (-> s1-1 tail-id)) (-> s3-0 1))
        )
      (set! (-> s3-0 1 y) 53248.0)
      (set! (-> s3-0 1 x) (+ -2048.0 (-> s3-0 1 x)))
      (set! (-> s3-0 1 z) (+ -2048.0 (-> s3-0 1 z)))
      (add-debug-line #t (bucket-id debug2) (-> s3-0 0) (-> s3-0 1) *color-white* #f (the-as rgba -1))
      )
    )
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod debug-draw-path trail-graph ((obj trail-graph) (arg0 int) (arg1 (pointer uint16)) (arg2 vector) (arg3 vector) (arg4 rgba) (arg5 float))
  (local-vars (sv-48 int))
  (let ((s0-0 (new 'stack-no-clear 'inline-array 'vector 2)))
    (set-vector! (-> s0-0 1) (+ (-> arg2 x) arg5) 53248.0 (+ (-> arg2 z) arg5) 1.0)
    (set! sv-48 0)
    (until #f
      (set! (-> s0-0 0 quad) (-> s0-0 1 quad))
      (cond
        ((< sv-48 arg0)
         (let ((a0-7 (-> obj node (-> arg1 sv-48))))
           (set-vector!
             (-> s0-0 1)
             (+ (* 4096.0 (the float (-> a0-7 x))) arg5)
             53248.0
             (+ (* 4096.0 (the float (-> a0-7 z))) arg5)
             1.0
             )
           )
         )
        ((= sv-48 arg0)
         (set-vector! (-> s0-0 1) (+ (-> arg3 x) arg5) 53248.0 (+ (-> arg3 z) arg5) 1.0)
         )
        (else
          (return #f)
          )
        )
      (add-debug-line #t (bucket-id debug2) (-> s0-0 0) (-> s0-0 1) arg4 #f (the-as rgba -1))
      (set! sv-48 (+ sv-48 1))
      )
    )
  #f
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod debug-draw trail-graph ((obj trail-graph))
  (when (= (-> obj mode) 3)
    (let ((s5-0 (new 'stack-no-clear 'inline-array 'vector 2)))
      (set! (-> s5-0 1 quad) (-> obj orig-goal-pos quad))
      (set! (-> s5-0 1 y) 53248.0)
      (let ((v1-4 (-> obj goal-node-id)))
        (until #f
          (set! (-> s5-0 0 quad) (-> s5-0 1 quad))
          (cond
            ((>= v1-4 0)
             (let ((s4-0 (-> obj node v1-4)))
               (set-vector!
                 (-> s5-0 1)
                 (+ 2048.0 (* 4096.0 (the float (-> s4-0 x))))
                 53248.0
                 (+ 2048.0 (* 4096.0 (the float (-> s4-0 z))))
                 1.0
                 )
               (add-debug-line #t (bucket-id debug2) (-> s5-0 0) (-> s5-0 1) *color-green* #f (the-as rgba -1))
               (set! v1-4 (-> s4-0 parent-id))
               )
             )
            (else
              (set! (-> s5-0 1 quad) (-> obj orig-start-pos quad))
              (set! (-> s5-0 1 y) 53248.0)
              (add-debug-line #t (bucket-id debug2) (-> s5-0 0) (-> s5-0 1) *color-green* #f (the-as rgba -1))
              (goto cfg-7)
              )
            )
          )
        )
      )
    #f
    )
  (label cfg-7)
  (case (-> obj mode)
    ((1 2 3)
     (let ((s5-1 (new 'stack-no-clear 'vector)))
       (add-debug-sphere
         #t
         (bucket-id debug-no-zbuf1)
         (-> obj orig-start-pos)
         (meters 1)
         (new 'static 'rgba :r #xff :a #x80)
         )
       (set! (-> s5-1 quad) (-> obj conn-start-pos quad))
       (set! (-> s5-1 y) 53248.0)
       (add-debug-sphere #t (bucket-id debug-no-zbuf1) s5-1 (meters 0.25) (new 'static 'rgba :r #xff :a #x80))
       (add-debug-sphere
         #t
         (bucket-id debug-no-zbuf1)
         (-> obj orig-goal-pos)
         (meters 1)
         (new 'static 'rgba :g #xff :a #x80)
         )
       (set! (-> s5-1 quad) (-> obj conn-goal-pos quad))
       (set! (-> s5-1 y) 53248.0)
       (add-debug-sphere #t (bucket-id debug-no-zbuf1) s5-1 (meters 0.25) (new 'static 'rgba :g #xff :a #x80))
       )
     )
    )
  (dotimes (s5-2 (the-as int (-> obj conn-count)))
    (debug-draw (-> obj conn s5-2) obj s5-2)
    )
  (dotimes (s5-3 (the-as int (-> obj node-count)))
    (debug-draw (-> obj node s5-3) s5-3)
    )
  0
  (none)
  )

(defmethod get-position trail-node ((obj trail-node) (arg0 vector))
  "Unpack the position to a vector"
  (let ((v0-0 arg0))
    (set! (-> v0-0 x) (* 4096.0 (the float (-> obj x))))
    (set! (-> v0-0 y) 0.0)
    (set! (-> v0-0 z) (* 4096.0 (the float (-> obj z))))
    (set! (-> v0-0 w) 1.0)
    v0-0
    )
  )

(defmethod get-node-location-by-id trail-graph ((obj trail-graph) (arg0 uint) (arg1 vector))
  "Get the location of the node with the given ID"
  (get-position (-> obj node (the-as int arg0)) arg1)
  )

(defmethod get-path-to-root trail-graph ((obj trail-graph) (arg0 (pointer uint16)) (arg1 int) (arg2 (pointer int32)) (arg3 (pointer float)))
  "Get the path from goal to root, following parent-id"
  (set! (-> arg3 0) 0.0)
  (set! (-> arg2 0) (-> obj goal-node-id))
  (let ((v0-0 -1))
    (when (= (-> obj mode) 3)
      (let ((v1-3 (-> obj node))
            (a3-2 0)
            )
        (let ((t1-0 (-> obj goal-node-id)))
          (while (>= t1-0 0)
            (+! a3-2 1)
            (set! t1-0 (-> v1-3 t1-0 parent-id))
            )
          )
        (let ((t1-4 (-> obj goal-node-id)))
          (let ((t2-1 (- a3-2 arg1)))
            (cond
              ((> t2-1 0)
               (while (> t2-1 0)
                 (set! t1-4 (-> v1-3 t1-4 parent-id))
                 (+! t2-1 -1)
                 )
               (set! v0-0 arg1)
               )
              (else
                (set! v0-0 a3-2)
                )
              )
            )
          (countdown (a2-3 v0-0)
            (set! (-> arg0 a2-3) (the-as uint t1-4))
            (set! t1-4 (-> v1-3 t1-4 parent-id))
            )
          )
        (when (> a3-2 0)
          (let ((a0-3 (-> v1-3 (-> obj goal-node-id)))
                (v1-4 (-> v1-3 (-> arg0 0)))
                )
            (set! (-> arg3 0)
                  (- (* 512.0 (the float (-> a0-3 cost-from-start))) (* 512.0 (the float (-> v1-4 cost-from-start))))
                  )
            )
          )
        )
      )
    v0-0
    )
  )

(defmethod try-initialize trail-graph ((obj trail-graph))
  "Init and verify that constants are good."
  (let ((a3-0 (shr (+ (-> obj node-count) 127) 7)))
    (when (!= a3-0 6)
      (format 0 "ERROR: <SW> TRAIL_NODE_BIT_ARRAY_QUAD_COUNT is ~d, but should be ~d!  Please change it!~%" 6 a3-0)
      (return #f)
      )
    )
  (let ((a3-1 (shr (+ (-> obj conn-count) 127) 7)))
    (when (!= a3-1 7)
      (format 0 "ERROR: <SW> TRAIL_CONN_BIT_ARRAY_QUAD_COUNT is ~d, but should be ~d!  Please change it!~%" 7 a3-1)
      (return #f)
      )
    )
  (set! (-> obj mode) (the-as uint 0))
  (set! (-> obj goal-conn-id) -1)
  (set! (-> obj goal-node-id) -1)
  (set! (-> obj open-head-id) -1)
  #t
  )

(defmethod reset-search-state trail-graph ((obj trail-graph))
  "Reset the search/goal."
  (when (nonzero? (-> obj mode))
    (set! (-> obj goal-node-id) -1)
    (let ((a1-0 (-> obj goal-conn-id)))
      (when (>= a1-0 0)
        (update-node-flags-for-conn obj a1-0 (trail-node-flag) (trail-node-flag tnf0))
        (set! (-> obj goal-conn-id) -1)
        )
      )
    (set! (-> obj open-head-id) -1)
    (let ((v1-7 (-> obj open-quads)))
      (set! (-> v1-7 0 quad) (the-as uint128 0))
      (set! (-> v1-7 1 quad) (the-as uint128 0))
      (set! (-> v1-7 2 quad) (the-as uint128 0))
      (set! (-> v1-7 3 quad) (the-as uint128 0))
      (set! (-> v1-7 4 quad) (the-as uint128 0))
      (set! (-> v1-7 5 quad) (the-as uint128 0))
      )
    0
    (let ((v1-9 (-> obj closed-quads)))
      (set! (-> v1-9 0 quad) (the-as uint128 0))
      (set! (-> v1-9 1 quad) (the-as uint128 0))
      (set! (-> v1-9 2 quad) (the-as uint128 0))
      (set! (-> v1-9 3 quad) (the-as uint128 0))
      (set! (-> v1-9 4 quad) (the-as uint128 0))
      (set! (-> v1-9 5 quad) (the-as uint128 0))
      )
    0
    (set! (-> obj mode) (the-as uint 0))
    0
    )
  (none)
  )

;; WARN: Return type mismatch trail-node-flag vs none.
(defmethod update-node-flags-for-conn trail-graph ((obj trail-graph) (arg0 int) (arg1 trail-node-flag) (arg2 trail-node-flag))
  "Set arg1, clear arg2"
  (let* ((v1-0 (lognot arg2))
         (a3-2 (-> obj conn arg0))
         (t0-0 (-> a3-2 visgroup-id))
         (a1-2 (-> obj node))
         )
    (cond
      ((> t0-0 0)
       (let* ((a3-4 (-> obj visgroup (+ t0-0 -1)))
              (a0-2 (&-> (-> obj visnode-ids) (-> a3-4 first-conn)))
              )
         (countdown (a3-5 (-> a3-4 conn-count))
           (let ((t0-8 (-> a1-2 (-> a0-2 0))))
             (set! (-> t0-8 flags) (logior (logand (-> t0-8 flags) v1-0) arg1))
             )
           (set! a0-2 (&-> a0-2 1))
           )
         )
       )
      (else
        (let ((a0-5 (-> a1-2 (-> a3-2 head-id)))
              (a1-3 (-> a1-2 (-> a3-2 tail-id)))
              )
          (set! (-> a0-5 flags) (logior (logand (-> a0-5 flags) v1-0) arg1))
          (set! (-> a1-3 flags) (logior (logand (-> a1-3 flags) v1-0) arg1))
          )
        )
      )
    )
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defmethod trail-graph-method-25 trail-graph ((obj trail-graph) (arg0 trail-conn-search) (arg1 int) (arg2 int))
  (let* ((v1-1 (+ (* arg2 16) arg1))
         (a0-1 (/ v1-1 8))
         (a1-2 (ash 1 (logand v1-1 7)))
         (a2-4 (-> arg0 cell-quads 0 byte a0-1))
         )
    (when (not (logtest? a2-4 a1-2))
      (set! (-> arg0 cell-quads 0 byte a0-1) (logior a2-4 a1-2))
      (let* ((v1-3 (-> obj conn-hash cell v1-1))
             (s4-0 (&-> (-> obj conn-hash conn-ids) (-> v1-3 first-conn)))
             )
        (countdown (s3-0 (-> v1-3 conn-count))
          (let* ((s2-0 (-> s4-0 0))
                 (v1-4 (shr s2-0 3))
                 (a1-7 (ash 1 (logand s2-0 7)))
                 (a2-5 (-> arg0 conn-quads 0 byte v1-4))
                 )
            (when (not (logtest? a2-5 a1-7))
              (set! (-> arg0 conn-quads 0 byte v1-4) (logior a2-5 a1-7))
              (let* ((v1-7 (-> obj conn s2-0))
                     (a0-14 (-> v1-7 flags))
                     )
                (when (= (logand (the-as conn-flag (-> obj conn-mask)) a0-14) a0-14)
                  (let ((a3-2 (-> obj node (-> v1-7 head-id)))
                        (v1-10 (-> obj node (-> v1-7 tail-id)))
                        (a1-14 (new 'stack-no-clear 'vector))
                        (a2-7 (new 'stack-no-clear 'vector))
                        (s1-0 (new 'stack-no-clear 'vector))
                        )
                    (set-vector!
                      a1-14
                      (* 4096.0 (the float (-> a3-2 x)))
                      (-> arg0 src-pos y)
                      (* 4096.0 (the float (-> a3-2 z)))
                      1.0
                      )
                    (set-vector!
                      a2-7
                      (* 4096.0 (the float (-> v1-10 x)))
                      (-> arg0 src-pos y)
                      (* 4096.0 (the float (-> v1-10 z)))
                      1.0
                      )
                    (let ((f0-12 (vector-segment-distance-point! (-> arg0 src-pos) a1-14 a2-7 s1-0)))
                      (when (or (< (-> arg0 best-conn-id) 0) (< f0-12 (-> arg0 best-dist)))
                        (set! (-> arg0 best-dist) f0-12)
                        (set! (-> arg0 best-conn-id) (the-as int s2-0))
                        (set! (-> arg0 conn-pos quad) (-> s1-0 quad))
                        )
                      )
                    )
                  )
                )
              )
            )
          (set! s4-0 (&-> s4-0 1))
          )
        )
      )
    )
  (none)
  )

(defmethod do-path trail-graph ((obj trail-graph) (arg0 vector) (arg1 vector))
  (let ((v1-0 (-> obj conn-hash))
        (s5-0 (new 'stack-no-clear 'trail-conn-search))
        )
    (set! (-> s5-0 src-pos) arg0)
    (set! (-> s5-0 conn-pos) arg1)
    (set! (-> s5-0 best-conn-id) -1)
    (let ((a0-2 (-> s5-0 conn-quads)))
      (set! (-> a0-2 0 quad) (the-as uint128 0))
      (set! (-> a0-2 1 quad) (the-as uint128 0))
      (set! (-> a0-2 2 quad) (the-as uint128 0))
      (set! (-> a0-2 3 quad) (the-as uint128 0))
      (set! (-> a0-2 4 quad) (the-as uint128 0))
      (set! (-> a0-2 5 quad) (the-as uint128 0))
      (set! (-> a0-2 6 quad) (the-as uint128 0))
      )
    0
    (let ((a0-4 (-> s5-0 cell-quads)))
      (set! (-> a0-4 0 quad) (the-as uint128 0))
      (set! (-> a0-4 1 quad) (the-as uint128 0))
      )
    0
    (let* ((f0-0 (-> v1-0 cell-width))
           (f1-1 (* 0.5 f0-0))
           )
      (let ((f3-0 (- (-> arg0 x) f1-1))
            (f2-2 (- (-> arg0 z) f1-1))
            )
        (set! (-> s5-0 bounds min x) (max 0 (min 15 (the int (/ (- f3-0 (-> v1-0 origin x)) f0-0)))))
        (set! (-> s5-0 bounds min z) (max 0 (min 15 (the int (/ (- f2-2 (-> v1-0 origin z)) f0-0)))))
        )
      (let ((f2-7 (+ (-> arg0 x) f1-1))
            (f1-2 (+ (-> arg0 z) f1-1))
            )
        (set! (-> s5-0 bounds max x) (max 0 (min 15 (the int (/ (- f2-7 (-> v1-0 origin x)) f0-0)))))
        (set! (-> s5-0 bounds max z) (max 0 (min 15 (the int (/ (- f1-2 (-> v1-0 origin z)) f0-0)))))
        )
      )
    (let ((s3-0 (-> s5-0 bounds min z)))
      (until (< (-> s5-0 bounds max z) s3-0)
        (let ((s2-0 (-> s5-0 bounds min x)))
          (until (< (-> s5-0 bounds max x) s2-0)
            (trail-graph-method-25 obj s5-0 s2-0 s3-0)
            (+! s2-0 1)
            )
          )
        (+! s3-0 1)
        )
      )
    (while (< (-> s5-0 best-conn-id) 0)
      (let ((v1-8 15))
        (set! (-> s5-0 bounds min x) (max 0 (+ (-> s5-0 bounds min x) -1)))
        (set! (-> s5-0 bounds min z) (max 0 (+ (-> s5-0 bounds min z) -1)))
        (set! (-> s5-0 bounds max x) (min (+ (-> s5-0 bounds max x) 1) v1-8))
        (set! (-> s5-0 bounds max z) (min (+ (-> s5-0 bounds max z) 1) v1-8))
        )
      (let ((s3-1 (-> s5-0 bounds min x)))
        (until (< (-> s5-0 bounds max x) s3-1)
          (trail-graph-method-25 obj s5-0 s3-1 (-> s5-0 bounds min z))
          (trail-graph-method-25 obj s5-0 s3-1 (-> s5-0 bounds max z))
          (+! s3-1 1)
          )
        )
      (let ((s3-2 (-> s5-0 bounds min z)))
        (until (< (-> s5-0 bounds max z) s3-2)
          (trail-graph-method-25 obj s5-0 (-> s5-0 bounds min x) s3-2)
          (trail-graph-method-25 obj s5-0 (-> s5-0 bounds max x) s3-2)
          (+! s3-2 1)
          )
        )
      )
    (set! (-> arg1 y) 0.0)
    (-> s5-0 best-conn-id)
    )
  )

(defmethod trail-graph-method-9 trail-graph ((obj trail-graph) (arg0 int))
  (let ((s4-0 (-> obj node arg0)))
    (set! (-> s4-0 cost-from-start) (get-dist-score s4-0 (-> obj orig-start-pos)))
    (set! (-> s4-0 cost-to-goal) (get-dist-score s4-0 (-> obj orig-goal-pos)))
    )
  (trail-graph-method-11 obj arg0 -1)
  0
  (none)
  )

(defmethod trail-graph-method-10 trail-graph ((obj trail-graph) (arg0 int))
  (let* ((s5-0 (-> obj conn arg0))
         (v1-1 (-> s5-0 visgroup-id))
         )
    (cond
      ((> v1-1 0)
       (let* ((v1-4 (-> obj visgroup (+ v1-1 -1)))
              (s5-1 (&-> (-> obj visnode-ids) (-> v1-4 first-conn)))
              (s4-0 (-> v1-4 conn-count))
              )
         (-> obj visnode-ids)
         (while (nonzero? s4-0)
           (+! s4-0 -1)
           (trail-graph-method-9 obj (the-as int (-> s5-1 0)))
           (set! s5-1 (&-> s5-1 1))
           )
         )
       )
      (else
        (trail-graph-method-9 obj (the-as int (-> s5-0 head-id)))
        (trail-graph-method-9 obj (the-as int (-> s5-0 tail-id)))
        )
      )
    )
  (none)
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod trail-graph-method-11 trail-graph ((obj trail-graph) (arg0 int) (arg1 int))
  (let ((v1-0 (/ arg0 8))
        (a3-1 (ash 1 (logand arg0 7)))
        )
    (logior! (-> obj open-quads 0 byte v1-0) a3-1)
    )
  (let* ((v1-2 (-> obj node))
         (v0-0 (-> v1-2 arg0))
         )
    (set! (-> v0-0 parent-id) arg1)
    (let ((a3-6 (+ (-> v0-0 cost-from-start) (-> v0-0 cost-to-goal)))
          (t0-4 (-> obj open-head-id))
          (a2-2 -1)
          )
      (until #f
        (when (< t0-4 0)
          (set! (-> v0-0 next-id) -1)
          (set! (-> v0-0 prev-id) a2-2)
          (if (>= a2-2 0)
              (set! (-> v1-2 a2-2 next-id) arg0)
              (set! (-> obj open-head-id) arg0)
              )
          (return v0-0)
          )
        (let ((t1-4 (-> v1-2 t0-4)))
          (when (>= (+ (-> t1-4 cost-from-start) (-> t1-4 cost-to-goal)) a3-6)
            (set! (-> v0-0 next-id) t0-4)
            (set! (-> v0-0 prev-id) a2-2)
            (set! (-> t1-4 prev-id) arg0)
            (if (>= a2-2 0)
                (set! (-> v1-2 a2-2 next-id) arg0)
                (set! (-> obj open-head-id) arg0)
                )
            (return v0-0)
            )
          (set! a2-2 t0-4)
          (set! t0-4 (-> t1-4 next-id))
          )
        )
      )
    #f
    v0-0
    )
  )

(defmethod trail-graph-method-22 trail-graph ((obj trail-graph) (arg0 int))
  (let ((v1-0 (/ arg0 8))
        (a2-1 (ash 1 (logand arg0 7)))
        )
    (logior! (-> obj open-quads 0 byte v1-0) a2-1)
    )
  (let* ((v1-2 (-> obj node))
         (a2-4 (-> v1-2 arg0))
         (a1-2 (-> a2-4 prev-id))
         (a2-5 (-> a2-4 next-id))
         )
    (cond
      ((>= a1-2 0)
       (set! (-> v1-2 a1-2 next-id) a2-5)
       (if (>= a2-5 0)
           (set! (-> v1-2 a2-5 prev-id) a1-2)
           )
       )
      (else
        (set! (-> obj open-head-id) a2-5)
        (if (>= a2-5 0)
            (set! (-> v1-2 a2-5 prev-id) -1)
            )
        )
      )
    )
  (none)
  )

(defmethod get-next-to-explore trail-graph ((obj trail-graph))
  (let ((v0-0 (-> obj open-head-id)))
    (when (>= v0-0 0)
      (let* ((v1-1 (-> obj node))
             (a2-0 (-> v1-1 v0-0 next-id))
             )
        (set! (-> obj open-head-id) a2-0)
        (if (>= a2-0 0)
            (set! (-> v1-1 a2-0 prev-id) -1)
            )
        )
      (let ((v1-3 (/ v0-0 8))
            (a1-6 (ash 1 (logand v0-0 7)))
            )
        (logior! (-> obj closed-quads 0 byte v1-3) a1-6)
        (logxor! (-> obj open-quads 0 byte v1-3) (the-as uint a1-6))
        )
      )
    v0-0
    )
  )

;; WARN: Return type mismatch int vs uint.
(defmethod get-dist-score trail-node ((obj trail-node) (arg0 vector))
  (let* ((f0-1 (- (-> arg0 x) (* 4096.0 (the float (-> obj x)))))
         (f1-3 (- (-> arg0 z) (* 4096.0 (the float (-> obj z)))))
         (f0-4 (sqrtf (+ (* f0-1 f0-1) (* f1-3 f1-3))))
         )
    (the uint (fmin 65535.0 (* 0.00024414062 (* 8.0 f0-4))))
    )
  )

(defmethod do-some-work trail-graph ((obj trail-graph))
  (let ((s5-0 (get-next-to-explore obj)))
    (if (< s5-0 0)
        (return 2)
        )
    (let ((s4-0 (-> obj node s5-0)))
      (when (logtest? (-> s4-0 flags) (trail-node-flag tnf0))
        (set! (-> obj goal-node-id) s5-0)
        (return 3)
        )
      (let ((s3-0 (&-> (-> obj conn-ids) (-> s4-0 first-conn))))
        (countdown (s2-0 (-> s4-0 conn-count))
          (let* ((a0-7 (-> obj conn (-> s3-0 0)))
                 (v1-12 (-> a0-7 flags))
                 )
            (when (= (logand (the-as conn-flag (-> obj conn-mask)) v1-12) v1-12)
              (let ((s1-0 (-> a0-7 tail-id)))
                (if (= s1-0 s5-0)
                    (set! s1-0 (-> a0-7 head-id))
                    )
                (let ((s0-0 (-> obj node s1-0))
                      (v1-17 (min #xffff (the-as int (+ (-> a0-7 cost) (-> s4-0 cost-from-start)))))
                      (a0-10 (shr s1-0 3))
                      (a1-7 (ash 1 (logand s1-0 7)))
                      )
                  (cond
                    ((logtest? (-> obj open-quads 0 byte a0-10) a1-7)
                     (when (< (the-as uint v1-17) (-> s0-0 cost-from-start))
                       (set! (-> s0-0 cost-from-start) (the-as uint v1-17))
                       (trail-graph-method-22 obj (the-as int s1-0))
                       (trail-graph-method-11 obj (the-as int s1-0) s5-0)
                       )
                     )
                    ((not (logtest? (-> obj closed-quads 0 byte a0-10) a1-7))
                     (set! (-> s0-0 cost-from-start) (the-as uint v1-17))
                     (set! (-> s0-0 cost-to-goal) (get-dist-score s0-0 (-> obj orig-goal-pos)))
                     (trail-graph-method-11 obj (the-as int s1-0) s5-0)
                     )
                    ((< (the-as uint v1-17) (-> s0-0 cost-from-start))
                     (set! (-> s0-0 cost-from-start) (the-as uint v1-17))
                     (trail-graph-method-11 obj (the-as int s1-0) s5-0)
                     )
                    )
                  )
                )
              )
            )
          (set! s3-0 (&-> s3-0 1))
          )
        )
      )
    )
  1
  )

;; ERROR: Unsupported inline assembly instruction kind - [mfc0 v1, Count]
;; ERROR: Unsupported inline assembly instruction kind - [mfc0 v1, Count]
(defmethod run-until-done-or-timeout trail-graph ((obj trail-graph) (arg0 int))
  (local-vars (v1-1 int))
  (let ((v0-0 (the-as int (-> obj mode))))
    0
    (.mfc0 v1-1 Count)
    (while (and (= v0-0 1)
                ;; changed in PC port: they used to abort early if searching takes too long
                ;; it is fast enough on PC that we don't care.
                ;; (< (the-as uint v1-1) (the-as uint arg0)) HACK
                )
      (set! v0-0 (do-some-work obj))
      (.mfc0 v1-1 Count)
      )
    (set! (-> obj mode) (the-as uint v0-0))
    )
  (none)
  )

(deftype trail-vis-work (structure)
  ((best-count    uint32         :offset-assert   0)
   (best-dist     float          :offset-assert   4)
   (start-conn-id uint32         :offset-assert   8)
   (p0            vector :inline :offset-assert  16)
   (p1            vector :inline :offset-assert  32)
   (best-node-id  uint16 64      :offset-assert  48)
   )
  :method-count-assert 9
  :size-assert         #xb0
  :flag-assert         #x9000000b0
  )


(defmethod trail-graph-method-19 trail-graph ((obj trail-graph) (arg0 int) (arg1 int))
  (local-vars (s4-1 symbol))
  (let* ((s4-0 (-> obj node))
         (v1-2 (-> s4-0 arg1))
         (s5-0 (new 'stack-no-clear 'trail-vis-work))
         )
    (set! (-> s5-0 start-conn-id) (the-as uint arg0))
    (set-vector!
      (-> s5-0 p0)
      (* 4096.0 (the float (-> v1-2 x)))
      (-> obj orig-goal-pos y)
      (* 4096.0 (the float (-> v1-2 z)))
      1.0
      )
    (set! (-> s5-0 p1 quad) (-> s5-0 p0 quad))
    (set! (-> s5-0 best-count) (the-as uint 0))
    (set! (-> s5-0 best-dist) -1.0)
    (let ((s2-0 (&-> (-> obj conn-ids) (-> v1-2 first-conn))))
      (countdown (s1-0 (-> v1-2 conn-count))
        (let* ((v1-4 (-> obj conn (-> s2-0 0)))
               (s0-0 (-> v1-4 tail-id))
               )
          (if (= s0-0 arg1)
              (set! s0-0 (-> v1-4 head-id))
              )
          (let ((v1-8 (-> s4-0 s0-0)))
            (set! (-> s5-0 p1 x) (* 4096.0 (the float (-> v1-8 x))))
            (set! (-> s5-0 p1 z) (* 4096.0 (the float (-> v1-8 z))))
            )
          (let ((f0-11 (vector-segment-distance-point! (-> obj orig-goal-pos) (-> s5-0 p0) (-> s5-0 p1) (the-as vector #f)))
                (f1-8 (-> s5-0 best-dist))
                )
            (cond
              ((or (< f1-8 0.0) (< f0-11 f1-8))
               (set! (-> s5-0 best-dist) f0-11)
               (set! (-> s5-0 best-count) (the-as uint 1))
               (set! (-> s5-0 best-node-id 0) s0-0)
               )
              ((= f0-11 f1-8)
               (let ((v1-15 (-> s5-0 best-count)))
                 (when (< v1-15 (the-as uint 64))
                   (set! (-> s5-0 best-node-id v1-15) s0-0)
                   (set! (-> s5-0 best-count) (+ v1-15 1))
                   )
                 )
               )
              )
            )
          )
        (set! s2-0 (&-> s2-0 1))
        )
      )
    (update-node-flags-for-conn obj (the-as int (-> s5-0 start-conn-id)) (trail-node-flag tnf1) (trail-node-flag))
    (countdown (v1-20 (-> s5-0 best-count))
      (let ((a1-14 (-> s4-0 (-> s5-0 best-node-id v1-20))))
        (when (= (logand (-> a1-14 flags) (trail-node-flag tnf0 tnf1)) (trail-node-flag tnf0 tnf1))
          (set! s4-1 #t)
          (goto cfg-22)
          )
        )
      )
    (set! s4-1 #f)
    (label cfg-22)
    (update-node-flags-for-conn obj (the-as int (-> s5-0 start-conn-id)) (trail-node-flag) (trail-node-flag tnf1))
    )
  s4-1
  )

(defmethod do-search! trail-graph ((obj trail-graph) (arg0 vector) (arg1 vector) (arg2 trail-cached-search-info))
  (reset-search-state obj)
  (+! (-> obj search-id) 1)
  (set! (-> obj orig-start-pos quad) (-> arg0 quad))
  (let ((a1-1 -1))
    (when arg2
      (let ((v1-6 (-> arg2 goal-conn-id)))
        (when (and (>= v1-6 0)
                   (= (-> arg2 orig-goal-pos x) (-> arg1 x))
                   (= (-> arg2 orig-goal-pos y) (-> arg1 y))
                   (= (-> arg2 orig-goal-pos z) (-> arg1 z))
                   )
          (set! a1-1 v1-6)
          (set! (-> obj conn-goal-pos quad) (-> arg2 conn-goal-pos quad))
          )
        )
      )
    (set! (-> obj orig-goal-pos quad) (-> arg1 quad))
    (when (< a1-1 0)
      (set! a1-1 (do-path obj (-> obj orig-goal-pos) (-> obj conn-goal-pos)))
      (when arg2
        (set! (-> arg2 goal-conn-id) a1-1)
        (set! (-> arg2 orig-goal-pos quad) (-> obj orig-goal-pos quad))
        (set! (-> arg2 conn-goal-pos quad) (-> obj conn-goal-pos quad))
        )
      )
    (set! (-> obj goal-conn-id) a1-1)
    (update-node-flags-for-conn obj a1-1 (trail-node-flag tnf0) (trail-node-flag))
    )
  (let ((v1-17 -1))
    (let ((a0-16 (-> *game-info* features)))
      (if (not (logtest? (game-feature pass-red) a0-16))
          (set! v1-17 (logand -2 v1-17))
          )
      (if (not (logtest? (game-feature pass-green) a0-16))
          (set! v1-17 (logand -3 v1-17))
          )
      (if (not (logtest? (game-feature pass-yellow) a0-16))
          (set! v1-17 (logand -5 v1-17))
          )
      (if (not (logtest? (game-feature pass-blue) a0-16))
          (set! v1-17 (logand -9 v1-17))
          )
      )
    (set! (-> obj conn-mask) (the-as uint v1-17))
    )
  (let ((s5-1 (do-path obj (-> obj orig-start-pos) (-> obj conn-start-pos))))
    (trail-graph-method-10 obj s5-1)
    (let ((a2-5 (-> obj open-head-id)))
      (if (and (logtest? (-> obj node a2-5 flags) (trail-node-flag tnf0)) (trail-graph-method-19 obj s5-1 a2-5))
          (set! (-> obj mode) (the-as uint 3))
          (set! (-> obj mode) (the-as uint 1))
          )
      )
    )
  (none)
  )

(if (not (try-initialize *trail-graph*))
    (set! *trail-graph* #f)
    )
