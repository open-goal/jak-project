;;-*-Lisp-*-
(in-package goal)

;; name: guard.gc
;; name in dgo: guard
;; dgos: CWI

;; DECOMP BEGINS

(defskelgroup skel-crimson-guard crimson-guard crimson-guard-lod0-jg -1
              ((crimson-guard-lod0-mg (meters 20)) (crimson-guard-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5)
              :shadow crimson-guard-shadow-mg
              :origin-joint-index 3
              )

(deftype guard-anim-info (structure)
  ((anim-index       int32 2 :offset-assert   0)
   (anim-index-front int32   :offset          0)
   (anim-index-back  int32   :offset          4)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(deftype guard-global-info (basic)
  ((prev-yellow-hit         int8                      :offset-assert   4)
   (prev-blue-hit           int8                      :offset-assert   5)
   (knocked                 int32           2         :offset-assert   8)
   (knocked-land            int32           2         :offset-assert  16)
   (anim-knocked-front      int32                     :offset          8)
   (anim-knocked-back       int32                     :offset         12)
   (anim-knocked-front-land int32                     :offset         16)
   (anim-knocked-back-land  int32                     :offset         20)
   (yellow-hit-anim         guard-anim-info 2 :inline :offset-assert  24)
   (yellow-land-anim        guard-anim-info 2 :inline :offset-assert  40)
   (blue-hit-anim           int32                     :offset-assert  56)
   )
  :method-count-assert 9
  :size-assert         #x3c
  :flag-assert         #x90000003c
  )


(deftype guard-shoot-info (structure)
  ((anim-index int32  :offset-assert   0)
   (start      float  :offset-assert   4)
   (end        float  :offset-assert   8)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(define *crimson-guard-global-info*
  (new 'static 'guard-global-info
    :knocked (new 'static 'array int32 2 31 8)
    :knocked-land (new 'static 'array int32 2 32 9)
    :yellow-hit-anim (new 'static 'inline-array guard-anim-info 2
      (new 'static 'guard-anim-info :anim-index (new 'static 'array int32 2 13 15))
      (new 'static 'guard-anim-info :anim-index (new 'static 'array int32 2 15 13))
      )
    :yellow-land-anim (new 'static 'inline-array guard-anim-info 2
      (new 'static 'guard-anim-info :anim-index (new 'static 'array int32 2 14 16))
      (new 'static 'guard-anim-info :anim-index (new 'static 'array int32 2 16 14))
      )
    :blue-hit-anim 10
    )
  )

(define *crimson-guard-nav-enemy-info*
  (new 'static 'nav-enemy-info
    :use-die-falling #f
    :use-victory #f
    :use-jump-blocked #f
    :debug-draw-neck #f
    :jump-debug-draw #f
    :move-to-ground #t
    :hover-if-no-ground #f
    :idle-anim-script (new 'static 'array idle-control-frame 4
      (new 'static 'idle-control-frame :command (ic-cmd play) :anim #x4 :param0 #x1 :param1 #x1)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      (new 'static 'idle-control-frame)
      )
    :idle-anim 4
    :notice-anim 4
    :hostile-anim -1
    :hit-anim 4
    :knocked-anim 8
    :knocked-land-anim 9
    :die-anim 17
    :die-falling-anim 8
    :victory-anim 4
    :jump-wind-up-anim 7
    :jump-in-air-anim 4
    :jump-land-anim 7
    :neck-joint 27
    :look-at-joint 6
    :bullseye-joint 5
    :sound-hit (static-sound-name "guard-hit")
    :sound-die (static-sound-name "guard-die")
    :notice-distance (meters 100)
    :notice-distance-delta (meters 10)
    :proximity-notice-distance (meters 100)
    :default-hit-points 4
    :gnd-collide-with (collide-spec backgnd)
    :overlaps-others-collide-with-filter (collide-spec jak bot player-list)
    :penetrate-knocked (penetrate
      touch
      generic-attack
      lunge
      flop
      punch
      spin
      roll
      uppercut
      bonk
      tube
      vehicle
      flut-attack
      board
      mech
      mech-punch
      mech-bonk
      dark-skin
      dark-punch
      dark-bomb
      dark-giant
      shield
      explode
      jak-yellow-shot
      jak-red-shot
      jak-blue-shot
      jak-dark-shot
      enemy-yellow-shot
      enemy-dark-shot
      eco-yellow
      eco-red
      eco-blue
      eco-green
      knocked
      penetrate-33
      penetrate-34
      penetrate-35
      penetrate-36
      penetrate-37
      penetrate-38
      penetrate-39
      penetrate-40
      penetrate-41
      penetrate-42
      penetrate-43
      penetrate-44
      penetrate-45
      penetrate-46
      penetrate-47
      penetrate-48
      penetrate-49
      penetrate-50
      penetrate-51
      penetrate-52
      penetrate-53
      penetrate-54
      penetrate-55
      penetrate-56
      penetrate-57
      penetrate-58
      penetrate-59
      penetrate-60
      penetrate-61
      penetrate-62
      penetrate-63
      )
    :movement-gravity (meters -100)
    :friction 0.5
    :attack-shove-back (meters 3)
    :attack-shove-up (meters 2)
    :attack-mode 'generic
    :attack-damage 2
    :recover-gnd-collide-with (collide-spec backgnd crate obstacle hit-by-others-list pusher)
    :jump-height-min (meters 0.5)
    :jump-height-factor 0.1
    :knocked-seek-ry-clamp 6371.5557
    :knocked-soft-vxz-lo 32768.0
    :knocked-soft-vxz-hi 53248.0
    :knocked-soft-vy-lo 61440.0
    :knocked-soft-vy-hi 61440.0
    :knocked-medium-vxz-lo 147456.0
    :knocked-medium-vxz-hi 196608.0
    :knocked-medium-vy-lo 135168.0
    :knocked-medium-vy-hi 151552.0
    :knocked-hard-vxz-lo 40960.0
    :knocked-hard-vxz-hi 61440.0
    :knocked-hard-vy-lo 98304.0
    :knocked-hard-vy-hi 106496.0
    :knocked-huge-vxz-lo 164659.2
    :knocked-huge-vxz-hi 249036.8
    :knocked-huge-vy-lo 183500.8
    :knocked-huge-vy-hi 217907.2
    :knocked-yellow-vxz-lo 20480.0
    :knocked-yellow-vxz-hi 24576.0
    :knocked-yellow-vy-lo 28672.0
    :knocked-yellow-vy-hi 40960.0
    :knocked-red-vxz-lo 65536.0
    :knocked-red-vxz-hi 81920.0
    :knocked-red-vy-lo 61440.0
    :knocked-red-vy-hi 61440.0
    :knocked-blue-vxz-lo 32768.0
    :knocked-blue-vxz-hi 65536.0
    :knocked-blue-vy-lo 16384.0
    :knocked-blue-vy-hi 32768.0
    :shadow-size (meters 2)
    :shadow-max-y (meters 1)
    :shadow-min-y (meters -1)
    :shadow-locus-dist (meters 150)
    :gem-joint -1
    :gem-offset (new 'static 'sphere :r 163840.0)
    :callback-info #f
    :use-momentum #f
    :use-frustration #t
    :use-stop-chase #f
    :use-circling #f
    :use-pacing #f
    :walk-anim 5
    :turn-anim 5
    :run-anim 6
    :taunt-anim -1
    :run-travel-speed (meters 12)
    :run-acceleration (meters 2)
    :run-turning-acceleration (meters 30)
    :walk-travel-speed (meters 3)
    :walk-acceleration (meters 1)
    :walk-turning-acceleration (meters 8)
    :maximum-rotation-rate (degrees 720.0)
    :notice-nav-radius (meters 3)
    :frustration-distance (meters 8)
    :frustration-time (seconds 4)
    :blocked-time (seconds 0.3)
    :circle-dist-lo 20480.0
    :circle-dist-hi 61440.0
    :nav-mesh #f
    )
  )

(set! (-> *crimson-guard-nav-enemy-info* fact-defaults) *fact-info-enemy-defaults*)

(deftype crimson-guard (citizen)
  ((info                    guard-global-info                     :offset-assert 964)
   (hit-face                uint32                                :offset-assert 968)
   (anim-get-up-front       int32                                 :offset-assert 972)
   (anim-get-up-back        int32                                 :offset-assert 976)
   (small-hit               int32                                 :offset-assert 980)
   (yellow-anim             uint32                                :offset-assert 984)
   (guard-type              uint8                                 :offset-assert 988)
   (settings                traffic-guard-type-settings           :offset-assert 992)
   (next-time               time-frame                            :offset-assert 1000)
   (last-time-see-target    time-frame                            :offset-assert 1008)
   (joint                   joint-mod                             :offset-assert 1016)
   (joint-enable            symbol                                :offset-assert 1020)
   (already-shot            symbol                                :offset-assert 1024)
   (miss-amount             float                                 :offset-assert 1028)
   (l-control               lightning-control                     :offset-assert 1032)
   (next-shot               int64                                 :offset-assert 1040)
   (anim-shoot              guard-shoot-info            3 :inline :offset-assert 1048)
   (transport               handle                                :offset-assert 1088)
   (transport-side          uint32                                :offset-assert 1096)
   (target-flags            uint8                                 :offset-assert 1100)
   (target-pos              vector                      :inline   :offset-assert 1104)
   (target-pos-predict      vector                      :inline   :offset-assert 1120)
   (target-pos-predict-miss vector                      :inline   :offset-assert 1136)
   (target-vel-vec          vector                      :inline   :offset-assert 1152)
   (target-vel              float                                 :offset-assert 1168)
   (target-self             vector                      :inline   :offset-assert 1184)
   (target-self-xz          vector                      :inline   :offset-assert 1200)
   (target-self-dist        float                                 :offset-assert 1216)
   (target-self-xz-dist     float                                 :offset-assert 1220)
   (target-y-angle          degrees                               :offset-assert 1224)
   (last-visible-target-pos vector                      :inline   :offset-assert 1232)
   (lazer-sound             sound-id                              :offset-assert 1248)
   (move-position           vector                      :inline   :offset-assert 1264)
   (move-index              int32                                 :offset-assert 1280)
   (traffic-target-status   traffic-target-status       :inline   :offset-assert 1296)
   (minimap                 connection-minimap                    :offset-assert 1376)
   (other-side              symbol                                :offset-assert 1380)
   )
  :heap-base #x4f0
  :method-count-assert 227
  :size-assert         #x568
  :flag-assert         #xe304f00568
  (:methods
    (get-up-front () _type_ :state 201)
    (get-up-back () _type_ :state 202)
    (search () _type_ :state 203)
    (attack () _type_ :state 204)
    (arrest () _type_ :state 205)
    (gun-shoot () _type_ :state 206)
    (exit-transport () _type_ :state 207)
    (waiting-ambush () _type_ :state 208)
    (close-attack () _type_ :state 209)
    (knocked-off-vehicle () _type_ :state 210)
    (roll-right () _type_ :state 211)
    (roll-left () _type_ :state 212)
    (close-attack-active () _type_ :state 213)
    (crimson-guard-method-214 (_type_) none 214)
    (crimson-guard-method-215 (_type_) symbol 215)
    (crimson-guard-method-216 (_type_) symbol 216)
    (crimson-guard-method-217 (_type_ vector vector vector) int 217)
    (crimson-guard-method-218 (_type_ vector) none 218)
    (crimson-guard-method-219 (_type_) none 219)
    (crimson-guard-method-220 (_type_) none 220)
    (crimson-guard-method-221 (_type_) none 221)
    (crimson-guard-method-222 (_type_) none 222)
    (crimson-guard-method-223 (_type_ float) none 223)
    (crimson-guard-method-224 (_type_ vector) float 224)
    (crimson-guard-method-225 (_type_ uint symbol) none 225)
    (crimson-guard-method-226 (_type_) none 226)
    )
  )


(defmethod crimson-guard-method-218 crimson-guard ((obj crimson-guard) (arg0 vector))
  (local-vars
    (sv-240 vector)
    (sv-256 (function vector vector vector))
    (sv-272 vector)
    (sv-288 vector)
    (sv-304 vector)
    (sv-320 vector)
    )
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (set! sv-240 arg0)
      (let ((s0-0 (new 'stack-no-clear 'vector)))
        (let ((v1-1 (-> obj root-override2 trans)))
          (let ((a0-1 *y-vector*))
            (let ((a1-2 8192.0))
              (.mov vf7 a1-2)
              )
            (.lvf vf5 (&-> a0-1 quad))
            )
          (.lvf vf4 (&-> v1-1 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s0-0 quad) vf6)
        (set! sv-320 (new 'stack-no-clear 'vector))
        (set! sv-304 (new 'stack-no-clear 'vector))
        (let ((s1-0 (new 'stack-no-clear 'vector))
              (s2-0 (new 'stack-no-clear 'vector))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (-> obj node-list data 4 bone transform)
          (let ((s4-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
                (s3-0 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
                )
            (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat))
            (set! (-> s0-0 quad) (-> obj root-override2 trans quad))
            (cond
              ((logtest? (enemy-flag dislike-combo) (-> obj enemy-flags))
               (let ((a1-6 s0-0))
                 (let ((v1-14 s0-0))
                   (let ((a0-9 s4-0))
                     (let ((a2-1 4096.0))
                       (.mov vf7 a2-1)
                       )
                     (.lvf vf5 (&-> a0-9 quad))
                     )
                   (.lvf vf4 (&-> v1-14 quad))
                   )
                 (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                 (.mul.x.vf acc vf5 vf7 :mask #b111)
                 (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                 (.svf (&-> a1-6 quad) vf6)
                 )
               )
              (else
                (let ((a1-7 s0-0))
                  (let ((v1-15 s0-0))
                    (let ((a0-10 s4-0))
                      (let ((a2-3 2048.0))
                        (.mov vf7 a2-3)
                        )
                      (.lvf vf5 (&-> a0-10 quad))
                      )
                    (.lvf vf4 (&-> v1-15 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a1-7 quad) vf6)
                  )
                )
              )
            (let ((a1-8 s0-0))
              (let ((v1-16 s0-0))
                (let ((a0-11 s3-0))
                  (let ((a2-5 8540.16))
                    (.mov vf7 a2-5)
                    )
                  (.lvf vf5 (&-> a0-11 quad))
                  )
                (.lvf vf4 (&-> v1-16 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-8 quad) vf6)
              )
            (vector-normalize! (vector-! sv-320 sv-240 s0-0) 1.0)
            (set! sv-288 (new 'stack-no-clear 'vector))
            (let ((v1-20 (-> sv-240 quad)))
              (set! (-> sv-288 quad) v1-20)
              )
            (set! sv-256 vector-rotate90-around-y!)
            (set! sv-272 (new 'stack-no-clear 'vector))
            (let* ((a1-13 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) sv-288 s0-0) -2998.272))
                   (v0-5 (sv-256 sv-272 a1-13))
                   )
              (vector+! sv-288 sv-288 v0-5)
              )
            (vector-normalize! (vector-! sv-320 sv-288 s0-0) 1.0)
            (vector-z-quaternion! sv-304 (-> obj root-override2 quat))
            (rot-zxy-from-vector! s2-0 sv-304)
            (rot-zxy-from-vector! s1-0 sv-320)
            (set! (-> s5-0 x) (fmax -14563.556 (fmin 14563.556 (deg- (-> s1-0 x) (-> s2-0 x)))))
            (set! (-> s5-0 y) (fmax -14563.556 (fmin 14563.556 (deg- (-> s1-0 y) (-> s2-0 y)))))
            (set! (-> s5-0 z) 0.0)
            (let ((s2-1 (new 'stack-no-clear 'quaternion)))
              (let ((s1-1 (new 'stack-no-clear 'quaternion)))
                (quaternion-vector-angle! s2-1 s4-0 (-> s5-0 x))
                (quaternion-vector-angle! s1-1 s3-0 (-> s5-0 y))
                (quaternion*! s2-1 s1-1 s2-1)
                )
              (quaternion-pseudo-seek (-> obj joint quat) (-> obj joint quat) s2-1 (-> pp clock seconds-per-frame))
              )
            )
          )
        )
      0
      (none)
      )
    )
  )

(defmethod crimson-guard-method-219 crimson-guard ((obj crimson-guard))
  (with-pp
    (quaternion-pseudo-seek
      (-> obj joint quat)
      (-> obj joint quat)
      *unity-quaternion*
      (-> pp clock seconds-per-frame)
      )
    0
    (none)
    )
  )

(define *guard-min-id-hack* 255)

(defmethod track-target! crimson-guard ((obj crimson-guard))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (let ((t9-0 (method-of-type citizen track-target!)))
    (t9-0 obj)
    )
  (update-transforms (-> obj root-override2))
  (if (< (-> obj traffic-id) *guard-min-id-hack*)
      (set! *guard-min-id-hack* (-> obj traffic-id))
      )
  (if (-> obj joint-enable)
      (crimson-guard-method-218 obj (-> obj target-pos-predict-miss))
      (crimson-guard-method-219 obj)
      )
  (none)
  )

(defmethod kill-prefer-falling crimson-guard ((obj crimson-guard))
  "If available in `enemy-info`, [[go]] to the [[die-falling]] state, if not, [[die]]"
  ((method-of-type nav-enemy kill-prefer-falling) obj)
  )

(defmethod react-to-focus crimson-guard ((obj crimson-guard))
  "@TODO - flesh out docs"
  (if (not (logtest? (-> obj flags) (citizen-flag hostile)))
      (go (method-of-object obj active))
      (go-hostile obj)
      )
  (none)
  )

(defmethod damage-amount-from-attack crimson-guard ((obj crimson-guard) (arg0 process) (arg1 event-message-block))
  "@returns the amount of damage taken from an attack.  This can come straight off the [[attack-info]] or via [[penetrate-using->damage]]"
  (let ((v0-0 ((method-of-type nav-enemy damage-amount-from-attack) obj arg0 arg1)))
    (-> arg1 param 1)
    v0-0
    )
  )

;; WARN: Return type mismatch none vs object.
;; WARN: disable def twice: 122. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod general-event-handler crimson-guard ((obj crimson-guard) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (let ((v1-0 arg2))
    (the-as
      object
      (cond
        ((or (= v1-0 'hit) (= v1-0 'hit-flinch) (= v1-0 'hit-knocked))
         (speech-control-method-13 *speech-control* (the-as handle obj))
         (logior! (-> obj flags) (citizen-flag hostile))
         (let* ((s0-0 (handle->process (-> obj incoming attacker-handle)))
                (s1-0 (if (type? s0-0 process-focusable)
                          s0-0
                          )
                      )
                )
           (when s1-0
             (speech-control-method-12 *speech-control* obj (speech-type speech-type-0 speech-type-1 speech-type-3))
             (trigger-alert obj 1 (the-as target s1-0))
             )
           )
         ((method-of-type nav-enemy general-event-handler) obj arg0 arg1 arg2 arg3)
         )
        ((= v1-0 'event-death)
         (if (zero? (-> obj hit-points))
             (the-as object (do-effect (-> obj skel effect) 'death-default 0.0 -1))
             )
         )
        ((= v1-0 'bouncing-off)
         (when (or (and (-> obj next-state) (= (-> obj next-state name) 'active))
                   (and (-> obj next-state) (= (-> obj next-state name) 'wait))
                   )
           (speech-control-method-12 *speech-control* obj (speech-type speech-type-1 speech-type-2 speech-type-3))
           (go (method-of-object obj close-attack-active))
           )
         )
        ((= v1-0 'combo)
         (and (not (and (-> obj next-state) (= (-> obj next-state name) 'inactive)))
              (and (not (logtest? (enemy-flag multi-focus) (-> obj enemy-flags))) (nonzero? (-> obj hit-points)))
              )
         )
        ((= v1-0 'avoid)
         #f
         )
        ((= v1-0 'panic)
         (set! (-> obj last-danger-time) (current-time))
         (let ((v1-38 (the-as traffic-danger-info (-> arg3 param 0))))
           (case (-> v1-38 danger-type)
             (((traffic-danger-type tdt7))
              (set! (-> obj cp-factor) 20.0)
              (let ((s5-1 (method-of-object obj trigger-alert))
                    (s4-1 1)
                    (s3-1 (handle->process (-> v1-38 handle)))
                    )
                (the-as object (s5-1 obj s4-1 (the-as target (if (type? s3-1 process-focusable)
                                                                 s3-1
                                                                 )
                                                      )
                                     )
                        )
                )
              )
             )
           )
         )
        ((= v1-0 'clear-path)
         (set! (-> obj last-danger-time) (current-time))
         (let ((v1-44 (the-as traffic-danger-info (-> arg3 param 0))))
           (set! (-> obj cp-valid?) #t)
           (set! (-> obj cp-sphere quad) (-> v1-44 sphere quad))
           (set! (-> obj cp-vec quad) (-> v1-44 velocity quad))
           (case (-> v1-44 danger-type)
             (((traffic-danger-type tdt0))
              (trigger-alert obj 1 *target*)
              )
             (((traffic-danger-type tdt1))
              )
             (((traffic-danger-type tdt2))
              )
             (((traffic-danger-type tdt3))
              )
             (((traffic-danger-type tdt4))
              )
             (((traffic-danger-type tdt5))
              )
             (((traffic-danger-type tdt6))
              )
             (((traffic-danger-type tdt7))
              (trigger-alert obj 1 *target*)
              )
             )
           )
         (let ((s5-2 (-> obj cp-plane)))
           (set! (-> s5-2 quad) (-> obj cp-vec quad))
           (set! (-> s5-2 y) 0.0)
           (vector-rotate90-around-y! s5-2 s5-2)
           (vector-normalize! s5-2 1.0)
           (set! (-> s5-2 w) (- (vector-dot (the-as vector s5-2) (the-as vector (-> obj cp-sphere)))))
           )
         (let ((v0-4 (the-as object (+ (current-time) (seconds 1)))))
           (set! (-> obj cp-exit-time) (the-as time-frame v0-4))
           v0-4
           )
         )
        ((= v1-0 'end-pursuit)
         (when *debug-segment*
           (when (focus-test? obj inactive)
             (format 0 "guard::event end-pursuit recieved by inactive process ~d~%" (-> obj pid))
             (break!)
             0
             )
           )
         (when (not (focus-test? obj dead))
           (when (logtest? (-> obj flags) (citizen-flag hostile))
             (logclear! (-> obj flags) (citizen-flag persistent in-pursuit hostile))
             (citizen-method-195 obj (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
             (go (method-of-object obj active))
             )
           )
         )
        ((= v1-0 'alert-begin)
         (when *debug-segment*
           (when (focus-test? obj inactive)
             (format 0 "guard::event alert-begin recieved by inactive process ~d~%" (-> obj pid))
             (break!)
             0
             )
           )
         (when (not (focus-test? obj dead))
           (when (not (logtest? (-> obj flags) (citizen-flag hostile)))
             (let ((a1-27 (the-as object (-> arg3 param 0))))
               (when (and (the-as uint a1-27)
                          (not (logtest? (-> (the-as process-focusable a1-27) focus-status) (focus-status disable dead inactive)))
                          )
                 (set! (-> obj traffic-target-status handle) (process->handle (the-as process-focusable a1-27)))
                 (try-update-focus (-> obj focus) (the-as process-focusable a1-27) obj)
                 (if (and (not (and (-> obj next-state) (= (-> obj next-state name) 'jump)))
                          (not (and (-> obj next-state) (= (-> obj next-state name) 'exit-transport)))
                          )
                     (the-as object (go-hostile obj))
                     )
                 )
               )
             )
           )
         )
        ((= v1-0 'alert-end)
         (when *debug-segment*
           (when (focus-test? obj inactive)
             (format 0 "guard::event alert-end recieved by inactive process ~d~%" (-> obj pid))
             (break!)
             0
             )
           )
         (when (not (focus-test? obj dead))
           (when (logtest? (-> obj flags) (citizen-flag hostile))
             (logclear! (-> obj flags) (citizen-flag persistent in-pursuit hostile))
             (speech-control-method-12 *speech-control* obj (speech-type speech-type-0 speech-type-2))
             (citizen-method-195 obj (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
             (go (method-of-object obj active))
             )
           )
         )
        ((= v1-0 'track)
         (if (and (-> obj next-state) (let ((v1-129 (-> obj next-state name)))
                                        (or (= v1-129 'exit-transport) (= v1-129 'jump))
                                        )
                  )
             #f
             #t
             )
         )
        ((= v1-0 'notify)
         (let ((a0-84 (-> arg3 param 0))
               (v1-130 (the-as object (-> arg3 param 1)))
               )
           (when (= a0-84 'attack)
             (when (logtest? (-> (the-as process-focusable v1-130) mask) (process-mask target))
               (when (focus-test? (the-as process-focusable v1-130) dead)
                 (format #t "guard killed player~%")
                 (the-as object (speech-control-method-12 *speech-control* obj (speech-type speech-type-1 speech-type-3)))
                 )
               )
             )
           )
         )
        (else
          ((method-of-type citizen general-event-handler) obj arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defmethod get-inv-mass crimson-guard ((obj crimson-guard))
  0.6666667
  )

(defstate get-up-front (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (set! (-> self hit-face) (the-as uint -1))
    (let ((v1-6 (-> self root-override2 root-prim)))
      (logclear! (-> (the-as collide-shape-prim-group v1-6) child 0 prim-core action) (collide-action no-standon))
      (logior! (-> (the-as collide-shape-prim-group v1-6) child 1 prim-core action) (collide-action no-standon))
      (set! (-> (the-as collide-shape-prim-group v1-6) child 1 prim-core collide-as) (collide-spec enemy))
      (set! (-> (the-as collide-shape-prim-group v1-6) child 1 prim-core collide-with)
            (collide-spec backgnd jak civilian hit-by-others-list player-list)
            )
      )
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-front))
                :num! (seek!
                  (the float
                       (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-get-up-front))) frames num-frames)
                          -1
                          )
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (set! (-> self hit-face) (the-as uint -1))
    (react-to-focus self)
    (none)
    )
  :post (behavior ()
    (enemy-method-49 self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (track-target! self)
    (none)
    )
  )

(defstate get-up-back (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (set! (-> self hit-face) (the-as uint -1))
    (let ((v1-6 (-> self root-override2 root-prim)))
      (logclear! (-> (the-as collide-shape-prim-group v1-6) child 0 prim-core action) (collide-action no-standon))
      (logior! (-> (the-as collide-shape-prim-group v1-6) child 1 prim-core action) (collide-action no-standon))
      (set! (-> (the-as collide-shape-prim-group v1-6) child 1 prim-core collide-as) (collide-spec enemy))
      (set! (-> (the-as collide-shape-prim-group v1-6) child 1 prim-core collide-with)
            (collide-spec backgnd jak civilian hit-by-others-list player-list)
            )
      )
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-back))
                :num! (seek!
                  (the float
                       (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-get-up-back))) frames num-frames) -1)
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (set! (-> self hit-face) (the-as uint -1))
    (react-to-focus self)
    (none)
    )
  :post (behavior ()
    (enemy-method-49 self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (track-target! self)
    (none)
    )
  )

(defstate knocked (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-5 (the-as collide-shape-prim-group (-> self root-override2 root-prim))))
      (logior! (-> v1-5 child 0 prim-core action) (collide-action no-standon))
      (logclear! (-> v1-5 child 1 prim-core action) (collide-action no-standon))
      (set! (-> v1-5 child 1 prim-core collide-as) (collide-spec))
      (set! (-> v1-5 child 1 prim-core collide-with) (collide-spec))
      )
    0
    (if (zero? (-> self hit-points))
        (set! (-> self root-override2 penetrated-by) (the-as penetrate -1))
        )
    (set! (-> self hit-face)
          (the-as uint (if (< (vector-dot
                                (-> self root-override2 transv)
                                (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat))
                                )
                              0.0
                              )
                           1
                           0
                           )
                  )
          )
    (none)
    )
  :exit (behavior ()
    (let ((v1-1 (-> self root-override2 root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (enemy-method-49 self)
    (none)
    )
  )

(defmethod enemy-method-77 crimson-guard ((obj crimson-guard) (arg0 (pointer float)))
  (cond
    ((logtest? (-> obj flags) (citizen-flag knocked-out-car))
     (ja-channel-push! 1 (seconds 0.1))
     (let ((a0-2 (-> obj skel root-channel 0)))
       (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> obj draw art-group data 42)))
       (set! (-> a0-2 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 42)) frames num-frames) -1))
             )
       (set! (-> a0-2 param 1) (-> arg0 0))
       (set! (-> a0-2 frame-num) 0.0)
       (joint-control-channel-group! a0-2 (the-as art-joint-anim (-> obj draw art-group data 42)) num-func-seek!)
       )
     (logclear! (-> obj flags) (citizen-flag knocked-out-car))
     )
    ((logtest? (-> obj flags) (citizen-flag knocked-out-bike))
     (ja-channel-push! 1 (seconds 0.1))
     (let ((a0-5 (-> obj skel root-channel 0)))
       (set! (-> a0-5 frame-group) (the-as art-joint-anim (-> obj draw art-group data 43)))
       (set! (-> a0-5 param 0)
             (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 43)) frames num-frames) -1))
             )
       (set! (-> a0-5 param 1) (-> arg0 0))
       (set! (-> a0-5 frame-num) 0.0)
       (joint-control-channel-group! a0-5 (the-as art-joint-anim (-> obj draw art-group data 43)) num-func-seek!)
       )
     (logclear! (-> obj flags) (citizen-flag knocked-out-bike))
     )
    ((begin
       (let ((v1-37 (-> obj root-override2 transv)))
         (cond
           ((< (sqrtf (+ (* (-> v1-37 x) (-> v1-37 x)) (* (-> v1-37 z) (-> v1-37 z)))) 32768.0)
            (set! (-> obj small-hit) 1)
            )
           (else
             (set! (-> obj small-hit) 0)
             0
             )
           )
         )
       (<= (-> obj hit-points) 0)
       )
     (ja-channel-push! 1 (seconds 0.01))
     (let ((a1-6 (-> obj draw art-group data (-> obj info knocked (-> obj hit-face))))
           (a0-11 (-> obj skel root-channel 0))
           )
       (set! (-> a0-11 frame-group) (the-as art-joint-anim a1-6))
       (set! (-> a0-11 param 0) (the float (+ (-> (the-as art-joint-anim a1-6) frames num-frames) -1)))
       (set! (-> a0-11 param 1) (-> arg0 0))
       (set! (-> a0-11 frame-num) 0.0)
       (joint-control-channel-group! a0-11 (the-as art-joint-anim a1-6) num-func-seek!)
       )
     )
    (else
      (case (-> obj incoming knocked-type)
        (((knocked-type knocked-type-4) (knocked-type knocked-type-5) (knocked-type knocked-type-7))
         (ja-channel-push! 1 (seconds 0.01))
         (cond
           ((= (-> obj small-hit) 1)
            (set! (-> obj yellow-anim) (the-as uint (get-rand-int obj 2)))
            (let ((a1-12 (-> obj
                             draw
                             art-group
                             data
                             (-> (the-as
                                   guard-global-info
                                   (+ (+ (* (-> obj hit-face) 4) (* (-> obj yellow-anim) 8)) (the-as uint (-> obj info)))
                                   )
                                 yellow-hit-anim
                                 0
                                 anim-index-front
                                 )
                             )
                         )
                  (a0-23 (-> obj skel root-channel 0))
                  )
              (set! (-> a0-23 frame-group) (the-as art-joint-anim a1-12))
              (set! (-> a0-23 param 0) (the float (+ (-> (the-as art-joint-anim a1-12) frames num-frames) -1)))
              (set! (-> a0-23 param 1) (-> arg0 0))
              (set! (-> a0-23 frame-num) 0.0)
              (joint-control-channel-group! a0-23 (the-as art-joint-anim a1-12) num-func-seek!)
              )
            )
           (else
             (let ((a1-13 (-> obj draw art-group data (-> obj info knocked (-> obj hit-face))))
                   (a0-27 (-> obj skel root-channel 0))
                   )
               (set! (-> a0-27 frame-group) (the-as art-joint-anim a1-13))
               (set! (-> a0-27 param 0) (the float (+ (-> (the-as art-joint-anim a1-13) frames num-frames) -1)))
               (set! (-> a0-27 param 1) (-> arg0 0))
               (set! (-> a0-27 frame-num) 0.0)
               (joint-control-channel-group! a0-27 (the-as art-joint-anim a1-13) num-func-seek!)
               )
             )
           )
         )
        (((knocked-type knocked-type-6))
         (ja-channel-push! 1 (seconds 0.01))
         (let ((a0-30 (-> obj skel root-channel 0)))
           (set! (-> a0-30 frame-group) (the-as art-joint-anim (-> obj draw art-group data 10)))
           (set! (-> a0-30 param 0)
                 (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 10)) frames num-frames) -1))
                 )
           (set! (-> a0-30 param 1) (-> arg0 0))
           (set! (-> a0-30 frame-num) 0.0)
           (joint-control-channel-group! a0-30 (the-as art-joint-anim (-> obj draw art-group data 10)) num-func-seek!)
           )
         )
        (((knocked-type knocked-type-2))
         (ja-channel-push! 1 (seconds 0.1))
         (let ((a1-17 (-> obj draw art-group data (-> obj info knocked (-> obj hit-face)))))
           (set! (-> arg0 0) (* 0.5 (-> arg0 0)))
           (let ((a0-36 (-> obj skel root-channel 0)))
             (set! (-> a0-36 frame-group) (the-as art-joint-anim a1-17))
             (set! (-> a0-36 param 0) (the float (+ (-> (the-as art-joint-anim a1-17) frames num-frames) -1)))
             (set! (-> a0-36 param 1) (-> arg0 0))
             (set! (-> a0-36 frame-num) 0.0)
             (joint-control-channel-group! a0-36 (the-as art-joint-anim a1-17) num-func-seek!)
             )
           )
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (let ((a1-19 (-> obj draw art-group data (-> obj info knocked (-> obj hit-face))))
                (a0-41 (-> obj skel root-channel 0))
                )
            (set! (-> a0-41 frame-group) (the-as art-joint-anim a1-19))
            (set! (-> a0-41 param 0) (the float (+ (-> (the-as art-joint-anim a1-19) frames num-frames) -1)))
            (set! (-> a0-41 param 1) (-> arg0 0))
            (set! (-> a0-41 frame-num) 0.0)
            (joint-control-channel-group! a0-41 (the-as art-joint-anim a1-19) num-func-seek!)
            )
          )
        )
      )
    )
  #t
  )

(defmethod enemy-method-78 crimson-guard ((obj crimson-guard) (arg0 (pointer float)))
  (cond
    ((<= (-> obj hit-points) 0)
     (ja-channel-push! 1 (seconds 0.1))
     (let ((a1-2 (-> obj draw art-group data (-> obj info knocked-land (-> obj hit-face))))
           (a0-5 (-> obj skel root-channel 0))
           )
       (set! (-> a0-5 frame-group) (the-as art-joint-anim a1-2))
       (set! (-> a0-5 param 0) (the float (+ (-> (the-as art-joint-anim a1-2) frames num-frames) -1)))
       (set! (-> a0-5 param 1) (-> arg0 0))
       (set! (-> a0-5 frame-num) 0.0)
       (joint-control-channel-group! a0-5 (the-as art-joint-anim a1-2) num-func-seek!)
       )
     (set! (-> obj hit-face) (the-as uint -1))
     #t
     )
    (else
      (case (-> obj incoming knocked-type)
        (((knocked-type knocked-type-4) (knocked-type knocked-type-5) (knocked-type knocked-type-7))
         (ja-channel-push! 1 (seconds 0.1))
         (cond
           ((= (-> obj small-hit) 1)
            (let ((a1-7 (-> obj
                            draw
                            art-group
                            data
                            (-> (the-as
                                  guard-global-info
                                  (+ (+ (* (-> obj hit-face) 4) (* (-> obj yellow-anim) 8)) (the-as uint (-> obj info)))
                                  )
                                yellow-land-anim
                                0
                                anim-index-front
                                )
                            )
                        )
                  (a0-16 (-> obj skel root-channel 0))
                  )
              (set! (-> a0-16 frame-group) (the-as art-joint-anim a1-7))
              (set! (-> a0-16 param 0) (the float (+ (-> (the-as art-joint-anim a1-7) frames num-frames) -1)))
              (set! (-> a0-16 param 1) (-> arg0 0))
              (set! (-> a0-16 frame-num) 0.0)
              (joint-control-channel-group! a0-16 (the-as art-joint-anim a1-7) num-func-seek!)
              )
            (set! (-> obj hit-face) (the-as uint -1))
            #t
            )
           (else
             (let ((a1-8 (-> obj draw art-group data (-> obj info knocked-land (-> obj hit-face))))
                   (a0-20 (-> obj skel root-channel 0))
                   )
               (set! (-> a0-20 frame-group) (the-as art-joint-anim a1-8))
               (set! (-> a0-20 param 0) (the float (+ (-> (the-as art-joint-anim a1-8) frames num-frames) -1)))
               (set! (-> a0-20 param 1) (-> arg0 0))
               (set! (-> a0-20 frame-num) 0.0)
               (joint-control-channel-group! a0-20 (the-as art-joint-anim a1-8) num-func-seek!)
               )
             #t
             )
           )
         )
        (((knocked-type knocked-type-6))
         (ja-channel-push! 1 (seconds 0.01))
         (let ((a0-23 (-> obj skel root-channel 0)))
           (set! (-> a0-23 frame-group) (the-as art-joint-anim (-> obj draw art-group data 11)))
           (set! (-> a0-23 param 0)
                 (the float (+ (-> (the-as art-joint-anim (-> obj draw art-group data 11)) frames num-frames) -1))
                 )
           (set! (-> a0-23 param 1) (-> arg0 0))
           (set! (-> a0-23 frame-num) 0.0)
           (joint-control-channel-group! a0-23 (the-as art-joint-anim (-> obj draw art-group data 11)) num-func-seek!)
           )
         (set! (-> obj hit-face) (the-as uint -1))
         #t
         )
        (else
          (ja-channel-push! 1 (seconds 0.1))
          (let ((a1-12 (-> obj draw art-group data (-> obj info knocked-land (-> obj hit-face)))))
            (set! (-> arg0 0) 1.0)
            (let ((a0-28 (-> obj skel root-channel 0)))
              (set! (-> a0-28 frame-group) (the-as art-joint-anim a1-12))
              (set! (-> a0-28 param 0) (the float (+ (-> (the-as art-joint-anim a1-12) frames num-frames) -1)))
              (set! (-> a0-28 param 1) (-> arg0 0))
              (set! (-> a0-28 frame-num) 0.0)
              (joint-control-channel-group! a0-28 (the-as art-joint-anim a1-12) num-func-seek!)
              )
            )
          #t
          )
        )
      )
    )
  )

(defmethod set-behavior! crimson-guard ((obj crimson-guard) (arg0 traffic-object-spawn-params))
  (let ((a1-1 (-> arg0 guard-type)))
    (if (or (and (!= a1-1 7) (!= a1-1 (-> obj guard-type))) (= (-> arg0 behavior) 11))
        (crimson-guard-method-225 obj a1-1 (= (-> arg0 behavior) 11))
        )
    )
  (case (-> arg0 behavior)
    ((5)
     (logior! (-> obj flags) (citizen-flag persistent hostile))
     (let ((s4-0 (-> obj focus))
           (s3-0 (method-of-type enemy-focus enemy-focus-method-13))
           (s5-1 (handle->process (-> arg0 handle)))
           )
       (s3-0
         s4-0
         (the-as process-focusable (if (type? s5-1 process-focusable)
                                       s5-1
                                       )
                 )
         (enemy-aware enemy-aware-3)
         )
       )
     (go (method-of-object obj arrest))
     )
    ((6)
     (logior! (-> obj flags) (citizen-flag persistent))
     (logior! (-> obj flags) (citizen-flag hostile))
     (set! (-> obj transport) (-> arg0 handle))
     (set! (-> obj transport-side) (-> arg0 user-data))
     (crimson-guard-method-223 obj 0.0)
     (let* ((s4-1 (-> obj controller traffic))
            (s5-2 (get-target s4-1))
            )
       (if (and (>= (the-as uint (get-alert-level s4-1)) (the-as uint 1)) s5-2)
           (try-update-focus (-> obj focus) s5-2 obj)
           )
       )
     (go (method-of-object obj exit-transport))
     )
    ((9)
     (logior! (-> obj flags) (citizen-flag persistent))
     (set! (-> obj focus handle) (-> arg0 handle))
     (set! (-> obj traffic-target-status handle) (-> arg0 handle))
     (go (method-of-object obj waiting-ambush))
     )
    ((3)
     (set! (-> obj focus handle) (-> arg0 handle))
     (set! (-> obj traffic-target-status handle) (-> arg0 handle))
     (go (method-of-object obj hostile))
     )
    ((11)
     (set! (-> obj root-override2 trans quad) (-> arg0 position quad))
     (quaternion-copy! (-> obj root-override2 quat) (-> arg0 rotation))
     (set! (-> obj vehicle) (-> arg0 handle))
     (ja-channel-set! 1)
     (case (-> (the-as vehicle (handle->process (-> obj vehicle))) info-override object-type)
       ((11 12 13 18)
        (logior! (-> obj flags) (citizen-flag knocked-out-bike))
        (let ((v1-64 (-> obj skel root-channel 0)))
          (set! (-> v1-64 frame-group) (the-as art-joint-anim (-> obj draw art-group data 35)))
          )
        )
       ((14 15 16 19)
        (logior! (-> obj flags) (citizen-flag knocked-out-car))
        (let ((v1-70 (-> obj skel root-channel 0)))
          (set! (-> v1-70 frame-group) (the-as art-joint-anim (-> obj draw art-group data 36)))
          )
        )
       )
     (ja-post)
     (go (method-of-object obj knocked-off-vehicle))
     )
    (else
      ((method-of-type citizen set-behavior!) obj arg0)
      )
    )
  0
  (none)
  )

(defstate knocked-off-vehicle (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (suspend)
    (throw-off-vehicle self)
    (none)
    )
  )

(defmethod go-hostile crimson-guard ((obj crimson-guard))
  (cond
    ((handle->process (-> obj focus handle))
     (logior! (-> obj flags) (citizen-flag hostile))
     (let ((v1-6 (-> obj hit-face)))
       (cond
         ((zero? v1-6)
          (go (method-of-object obj get-up-front))
          )
         ((= v1-6 1)
          (go (method-of-object obj get-up-back))
          )
         (else
           (go (method-of-object obj hostile))
           )
         )
       )
     )
    (else
      (go (method-of-object obj active))
      )
    )
  0
  (none)
  )

(defmethod crimson-guard-method-214 crimson-guard ((obj crimson-guard))
  (let* ((s4-0 (-> obj target-pos-predict-miss))
         (s5-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 14)))
         (v1-2 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 15)))
         (v1-3 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s4-0 v1-2) 1.0))
         (s4-1 (new 'stack-no-clear 'projectile-init-by-other-params))
         )
    (set! (-> s4-1 ent) (-> obj entity))
    (set! (-> s4-1 charge) 1.0)
    (set! (-> s4-1 options) (projectile-options))
    (set! (-> s4-1 notify-handle) (process->handle obj))
    (set! (-> s4-1 owner-handle) (the-as handle #f))
    (set! (-> s4-1 ignore-handle) (process->handle obj))
    (let* ((a0-13 *game-info*)
           (a1-12 (+ (-> a0-13 attack-id) 1))
           )
      (set! (-> a0-13 attack-id) a1-12)
      (set! (-> s4-1 attack-id) a1-12)
      )
    (set! (-> s4-1 timeout) (seconds 4))
    (set! (-> s4-1 pos quad) (-> s5-0 quad))
    (set! (-> s4-1 vel quad) (-> v1-3 quad))
    (vector-normalize! (-> s4-1 vel) 819200.0)
    (spawn-projectile guard-shot s4-1 obj *default-dead-pool*)
    )
  0
  (none)
  )

(defstate active (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (when (not (-> self nav))
      (format #t "++++++++++++++ guard::active : nav = #f +++++++++++++++~%")
      (go-virtual inactive)
      )
    (let ((t9-2 (-> (method-of-type citizen active) enter)))
      (if t9-2
          (t9-2)
          )
      )
    (logclear! (-> self flags) (citizen-flag in-pursuit hostile))
    (set! (-> self already-shot) #f)
    (none)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type citizen active) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (if (logtest? (-> self draw status) (draw-control-status on-screen))
        (speech-control-method-12 *speech-control* self (speech-type speech-type-0))
        )
    (when (logtest? (-> self controller traffic alert-state flags) (traffic-alert-flag guard-multi-focus))
      (let ((gp-0 (find-closest-to-with-collide-lists (-> self controller traffic) self (-> self focus collide-with))))
        (when gp-0
          (try-update-focus (-> self focus) gp-0 self)
          (set! (-> self traffic-target-status handle) (process->handle gp-0))
          (go-hostile self)
          )
        )
      )
    (none)
    )
  )

(defstate close-attack-active (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (let ((v1-0 self))
      (set! (-> v1-0 enemy-flags) (the-as enemy-flag (logclear (-> v1-0 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-0 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-3 self))
      (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logclear (-> v1-3 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let* ((v1-5 *game-info*)
           (a0-8 (+ (-> v1-5 attack-id) 1))
           )
      (set! (-> v1-5 attack-id) a0-8)
      (set! (-> self attack-id) a0-8)
      )
    (let ((v1-6 (-> self nav)))
      (set! (-> v1-6 target-speed) 0.0)
      )
    0
    (logior! (-> self focus-status) (focus-status dangerous))
    (none)
    )
  :exit (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 3)))
      (logclear! (-> v1-3 prim-core action) (collide-action deadly))
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-0 #f))
      (ja-no-eval :group! (-> self draw art-group data 18)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 18)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (when (and (< 7.0 (ja-frame-num 0)) (not gp-0))
          (let ((v1-22 (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 3)))
            (logior! (-> v1-22 prim-core action) (collide-action deadly))
            )
          (set! gp-0 #t)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-virtual active)
    (none)
    )
  :post (behavior ()
    (nav-enemy-method-176 self)
    (none)
    )
  )

(defstate inactive (crimson-guard)
  :virtual #t
  :enter (behavior ()
    (when (-> self minimap)
      (logior! (-> self minimap flags) (minimap-flag fade-out))
      (set! (-> self minimap) #f)
      )
    (let ((t9-0 (-> (method-of-type citizen inactive) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (logclear! (-> self flags) (citizen-flag in-pursuit hostile))
    (set! (-> self already-shot) #f)
    (none)
    )
  )

(defmethod crimson-guard-method-217 crimson-guard ((obj crimson-guard) (arg0 vector) (arg1 vector) (arg2 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'collide-query)))
      (let ((f0-0 1228.8)
            (f30-0 6144.0)
            )
        (set! (-> s5-0 start-pos quad) (-> arg0 quad))
        (vector-! (-> s5-0 move-dist) arg1 arg0)
        (let ((v1-4 s5-0))
          (set! (-> v1-4 radius) f0-0)
          (set! (-> v1-4 collide-with) (collide-spec backgnd))
          (set! (-> v1-4 ignore-process0) obj)
          (set! (-> v1-4 ignore-process1) (handle->process (-> obj focus handle)))
          (set! (-> v1-4 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-4 action-mask) (collide-action solid))
          )
        (let ((f0-1 (fill-and-probe-using-line-sphere *collide-cache* s5-0)))
          (cond
            ((>= f0-1 0.0)
             (vector-float*! (-> s5-0 move-dist) (-> s5-0 move-dist) f0-1)
             (cond
               ((< (vector-dot
                     (-> s5-0 best-other-tri normal)
                     (vector-! (new 'stack-no-clear 'vector) arg2 (the-as vector (-> s5-0 best-other-tri)))
                     )
                   0.0
                   )
                (return 1)
                )
               (else
                 )
               )
             )
            (else
              (vector-! (-> s5-0 move-dist) arg1 arg0)
              )
            )
          )
        (set! (-> s5-0 start-pos quad) (-> arg0 quad))
        (let ((a0-19 (-> s5-0 start-pos)))
          (let ((v1-15 (-> s5-0 move-dist)))
            (let ((a1-10 -0.1))
              (.mov vf7 a1-10)
              )
            (.lvf vf5 (&-> v1-15 quad))
            )
          (.lvf vf4 (&-> arg0 quad))
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a0-19 quad) vf6)
          )
        (let ((a1-11 (-> s5-0 move-dist)))
          (let ((v1-16 (-> s5-0 move-dist)))
            (let ((a0-20 (-> s5-0 move-dist)))
              (let ((a2-4 0.1))
                (.mov vf7 a2-4)
                )
              (.lvf vf5 (&-> a0-20 quad))
              )
            (.lvf vf4 (&-> v1-16 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a1-11 quad) vf6)
          )
        (let ((v1-17 s5-0))
          (set! (-> v1-17 radius) f30-0)
          (set! (-> v1-17 collide-with) (collide-spec civilian enemy obstacle hit-by-player-list hit-by-others-list))
          (set! (-> v1-17 ignore-process0) obj)
          (set! (-> v1-17 ignore-process1) (handle->process (-> obj focus handle)))
          (set! (-> v1-17 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-17 action-mask) (collide-action solid))
          )
        )
      (cond
        ((< (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
         0
         )
        (else
          (let ((s4-1 (-> s5-0 best-other-tri collide-ptr)))
            (if (and (if (type? s4-1 collide-shape-prim)
                         s4-1
                         )
                     (< (vector-dot
                          (-> s5-0 best-other-tri normal)
                          (vector-! (new 'stack-no-clear 'vector) arg2 (the-as vector (-> s5-0 best-other-tri)))
                          )
                        0.0
                        )
                     )
                2
                0
                )
            )
          )
        )
      )
    )
  )

(defmethod crimson-guard-method-220 crimson-guard ((obj crimson-guard))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (cond
      ((logtest? (-> obj controller traffic alert-state flags) (traffic-alert-flag guard-multi-focus))
       (set! (-> obj enemy-flags) (logior (enemy-flag trackable) (-> obj enemy-flags)))
       (when (not (logtest? (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
         (let ((a0-4 (find-closest-to-with-collide-lists (-> obj controller traffic) obj (-> obj focus collide-with))))
           (if a0-4
               (set! (-> obj traffic-target-status handle) (process->handle a0-4))
               (set! (-> obj traffic-target-status handle) (the-as handle #f))
               )
           )
         )
       )
      (else
        (when (logtest? (enemy-flag trackable) (-> obj enemy-flags))
          (logclear! (-> obj enemy-flags) (enemy-flag trackable))
          (let* ((s5-0 (handle->process (-> obj traffic-target-status handle)))
                 (v1-21 (if (type? s5-0 process-focusable)
                            s5-0
                            )
                        )
                 )
            (if (and v1-21 (!= (-> v1-21 type) target))
                (set! (-> obj traffic-target-status handle) (the-as handle #f))
                )
            )
          )
        )
      )
    (let ((a1-3 (new 'stack-no-clear 'vector)))
      (set! (-> a1-3 quad) (-> obj root-override2 trans quad))
      (set! (-> a1-3 y) (+ 8192.0 (-> a1-3 y)))
      (let ((s5-1
              (traffic-engine-method-49 (-> obj controller traffic) a1-3 (-> obj traffic-id) (-> obj traffic-target-status))
              )
            )
        (let* ((s4-0 obj)
               (s3-0 (method-of-object s4-0 enemy-method-63))
               (s2-0 (handle->process (-> obj traffic-target-status handle)))
               )
          (s3-0
            s4-0
            (the-as process-focusable (if (type? s2-0 process-focusable)
                                          s2-0
                                          )
                    )
            (the-as enemy-aware #f)
            )
          )
        (let ((s4-1 (handle->process (-> obj focus handle))))
          (cond
            ((and s4-1
                  (not (logtest? (-> (the-as process-focusable s4-1) focus-status) (focus-status disable dead inactive)))
                  )
             (when (logtest? (-> s5-1 flags) (traffic-target-flag updated))
               (logclear! (-> obj flags) (citizen-flag target-in-sight))
               (if (crimson-guard-method-215 obj)
                   (logior! (-> obj flags) (citizen-flag target-in-sight))
                   )
               )
             (set! (-> obj target-flags) (the-as uint (-> s5-1 flags)))
             (set! (-> obj target-pos quad) (-> (get-trans (the-as process-focusable s4-1) 3) quad))
             (set! (-> obj target-vel-vec quad) (-> (the-as process-focusable s4-1) root-override transv quad))
             (set! (-> obj target-vel) (vector-length (-> obj target-vel-vec)))
             (let ((s5-4 (vector-! (new 'stack-no-clear 'vector) (-> obj root-override2 trans) (-> obj target-pos))))
               (let* ((f0-3 (vector-length s5-4))
                      (f0-4 (* 0.0000012207031 f0-3))
                      (a1-9 (-> obj target-pos-predict))
                      )
                 (let ((v1-62 (-> obj target-pos)))
                   (let ((a0-36 (-> obj target-vel-vec)))
                     (let ((a2-3 f0-4))
                       (.mov vf7 a2-3)
                       )
                     (.lvf vf5 (&-> a0-36 quad))
                     )
                   (.lvf vf4 (&-> v1-62 quad))
                   )
                 (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                 (.mul.x.vf acc vf5 vf7 :mask #b111)
                 (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                 (.svf (&-> a1-9 quad) vf6)
                 )
               (set! (-> s5-4 y) 0.0)
               (vector-rotate90-around-y! s5-4 s5-4)
               (if (-> obj other-side)
                   (vector-negate! s5-4 s5-4)
                   )
               (vector-normalize! s5-4 (-> obj miss-amount))
               (vector+! (-> obj target-pos-predict-miss) (-> obj target-pos-predict) s5-4)
               )
             (vector-! (-> obj target-self) (-> obj target-pos) (-> obj root-override2 trans))
             (set! (-> obj target-self-xz quad) (-> obj target-self quad))
             (set! (-> obj target-self-xz y) 0.0)
             (set! (-> obj target-self-dist) (vector-length (-> obj target-self)))
             (set! (-> obj target-self-xz-dist) (vector-length (-> obj target-self-xz)))
             (set! (-> obj target-y-angle)
                   (deg-diff (quaternion-y-angle (-> obj root-override2 quat)) (vector-y-angle (-> obj target-self)))
                   )
             )
            (else
              (set! (-> obj traffic-target-status handle) (the-as handle #f))
              (logclear! (-> obj flags) (citizen-flag persistent in-pursuit hostile))
              (citizen-method-195 obj (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
              (go (method-of-object obj active))
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod crimson-guard-method-221 crimson-guard ((obj crimson-guard))
  (let ((a1-0 (new 'stack-no-clear 'traffic-danger-info)))
    (set! (-> a1-0 sphere quad) (-> obj root-override2 trans quad))
    (set! (-> a1-0 sphere r) 40960.0)
    (set! (-> a1-0 velocity quad) (-> obj root-override2 transv quad))
    (set! (-> a1-0 notify-radius) 122880.0)
    (set! (-> a1-0 danger-level) 1.0)
    (set! (-> a1-0 decay-rate) 0.0)
    (set! (-> a1-0 flags) (traffic-danger-flags tdf0))
    (set! (-> a1-0 danger-type) (traffic-danger-type tdt0))
    (add-danger (-> obj controller traffic) a1-0)
    )
  (none)
  )

(defmethod crimson-guard-method-215 crimson-guard ((obj crimson-guard))
  (let ((s5-0 (get-trans obj 3))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s4-0 quad) (-> obj target-pos quad))
    (let ((s3-1 (vector-! (new 'stack-no-clear 'vector) s4-0 s5-0)))
      (vector-normalize! s3-1 409600.0)
      (zero? (crimson-guard-method-217 obj s5-0 (vector+! (new 'stack-no-clear 'vector) s5-0 s3-1) s4-0))
      )
    )
  )

(defmethod crimson-guard-method-216 crimson-guard ((obj crimson-guard))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 quad) (-> obj target-pos-predict-miss quad))
    (let* ((s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 14)))
           (a0-3 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 15)))
           (s3-1 (vector-! (new 'stack-no-clear 'vector) s5-0 a0-3))
           )
      (vector-normalize! s3-1 409600.0)
      (and (crimson-guard-method-215 obj)
           (zero? (crimson-guard-method-217 obj s4-0 (vector+! (new 'stack-no-clear 'vector) s4-0 s3-1) s5-0))
           )
      )
    )
  )

(defstate search (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info-override callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-166 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self enemy-info-override run-travel-speed)))
      )
    0
    (if (zero? (-> self controller branch))
        (citizen-method-195 self (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat)))
        )
    (none)
    )
  :exit (behavior ()
    '()
    (none)
    )
  :trans (behavior ()
    (-> self target-flags)
    (crimson-guard-method-220 self)
    (cond
      ((logtest? (-> self target-flags) 1)
       (speech-control-method-12 *speech-control* self (speech-type speech-type-0 speech-type-1))
       (go-hostile self)
       )
      (else
        (speech-control-method-12 *speech-control* self (speech-type speech-type-2))
        )
      )
    (none)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info-override walk-anim))) 60)
    (none)
    )
  :post (behavior ()
    (if (and (nonzero? (-> self controller branch))
             (let ((f0-0 (vector-vector-xz-distance-squared (-> self root-override2 trans) (-> self controller turn-exit-point)))
                   (f1-0 16384.0)
                   )
               (< f0-0 (* f1-0 f1-0))
               )
             )
        (vehicle-controller-method-14 (-> self controller) (the-as vehicle self))
        )
    (let ((a0-2 (-> self nav state))
          (v1-9 (-> self controller turn-exit-point))
          )
      (logclear! (-> a0-2 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-2 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-2 target-post quad) (-> v1-9 quad))
      )
    0
    (nav-enemy-method-176 self)
    (none)
    )
  )

(defun do-spline ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 vector) (arg5 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((f1-1 (* arg5 arg5))
           (f0-2 (* arg5 f1-1))
           )
      (let ((f2-3 (- (+ 1.0 (* -3.0 arg5) (* 3.0 f1-1)) f0-2))
            (f3-7 (+ (* 3.0 f0-2) (* -6.0 f1-1) (* 3.0 arg5)))
            (f1-3 (+ (* -3.0 f0-2) (* 3.0 f1-1)))
            )
        (vector-float*! arg0 arg1 f2-3)
        (let ((t2-0 arg0))
          (let ((v1-10 arg0))
            (let ((t1-3 (vector+! (new 'stack-no-clear 'vector) arg1 arg2)))
              (let ((a1-1 f3-7))
                (.mov vf7 a1-1)
                )
              (.lvf vf5 (&-> t1-3 quad))
              )
            (.lvf vf4 (&-> v1-10 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> t2-0 quad) vf6)
          )
        (let ((a2-1 arg0))
          (let ((v1-11 arg0))
            (let ((a1-3 (vector+! (new 'stack-no-clear 'vector) arg3 arg4)))
              (let ((t0-1 f1-3))
                (.mov vf7 t0-1)
                )
              (.lvf vf5 (&-> a1-3 quad))
              )
            (.lvf vf4 (&-> v1-11 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a2-1 quad) vf6)
          )
        )
      (let ((v0-0 arg0))
        (let ((v1-12 arg0))
          (let ((a0-1 arg3))
            (let ((a1-4 f0-2))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-1 quad))
            )
          (.lvf vf4 (&-> v1-12 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v0-0 quad) vf6)
        v0-0
        )
      )
    )
  )

(defstate hostile (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (when *debug-segment*
      (when (not (-> self nav))
        (format 0 "guard::enter hostile with nav=#f ~d~%" (-> self pid))
        (break!)
        0
        )
      )
    (let ((t9-1 (-> (method-of-type nav-enemy hostile) enter)))
      (if t9-1
          (t9-1)
          )
      )
    (set! (-> self state-time) (current-time))
    (let ((v1-11 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-11 enemy-flags)))
          (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-11 enemy-flags))))
          )
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-11 enemy-flags))))
      (set! (-> v1-11 nav callback-info) (-> v1-11 enemy-info-override callback-info))
      )
    0
    (let ((v1-14 self))
      (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-14 enemy-flags))))
      )
    0
    (nav-enemy-method-166 self)
    (when (-> self nav)
      (let ((v1-20 (-> self nav)))
        (set! (-> v1-20 target-speed) (* (-> self speed-scale) (-> self enemy-info-override run-travel-speed)))
        )
      0
      )
    (logior! (-> self flags) (citizen-flag persistent in-pursuit))
    (set! (-> self root-override2 nav-radius) 6144.0)
    (none)
    )
  :exit (behavior ()
    (when (-> self nav)
      )
    (none)
    )
  :trans (behavior ()
    (crimson-guard-method-220 self)
    (when (and (not (logtest? (-> self draw status) (draw-control-status on-screen)))
               (= (-> self controller traffic sync-mask-16) (ash 1 (logand (-> self traffic-id) 15)))
               (not (logtest? (-> self flags) (citizen-flag sticky-weapon)))
               )
      (let ((a1-4 (get-traffic-guard-change-to-type (-> self controller traffic) (the-as int (-> self guard-type)))))
        (if (!= a1-4 (-> self guard-type))
            (crimson-guard-method-225 self a1-4 #f)
            )
        )
      )
    (let* ((s5-0 (-> self traffic-target-status))
           (s4-0 (handle->process (-> s5-0 handle)))
           (gp-0 (if (type? s4-0 process-focusable)
                     (the-as process-focusable s4-0)
                     )
                 )
           )
      (if (or (focus-test? gp-0 inactive) (focus-test? gp-0 disable))
          (set! gp-0 (the-as process-focusable #f))
          )
      (cond
        ((not gp-0)
         (go-virtual active)
         )
        (else
          (if (and (not (logtest? (-> s5-0 flags) (traffic-target-flag visible-recently)))
                   (logtest? (-> s5-0 flags) (traffic-target-flag visible-ever))
                   )
              (speech-control-method-12 *speech-control* self (speech-type speech-type-1))
              )
          (when (and (logtest? (-> self nav state flags) (nav-state-flag at-target))
                     (not (logtest? (-> s5-0 flags) (traffic-target-flag visible-recently)))
                     )
            (logclear! (-> self flags) (citizen-flag persistent))
            (citizen-method-195 self (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat)))
            (go-virtual search)
            )
          (when (or (logtest? (-> s5-0 flags) (traffic-target-flag visible-recently))
                    (not (logtest? (-> gp-0 mask) (process-mask target)))
                    )
            (speech-control-method-15 *speech-control* self)
            (cond
              ((focus-test? gp-0 arrestable)
               (if (and (< (-> self target-self-xz-dist) 28672.0)
                        (< (fabs (-> self target-y-angle)) 7281.778)
                        (>= 8192.0 (fabs (- (-> (get-trans gp-0 1) y) (-> self root-override2 trans y))))
                        )
                   (go-virtual arrest)
                   )
               )
              (else
                (if (and (< (-> self target-self-xz-dist) 16384.0)
                         (and (< (fabs (-> self target-y-angle)) 7281.778)
                              (and gp-0 (not (logtest? (-> gp-0 focus-status) (focus-status disable dead ignore grabbed))))
                              (logtest? (-> self flags) (citizen-flag target-in-sight))
                              )
                         )
                    (go-virtual close-attack)
                    )
                (let ((v1-78 (-> self guard-type)))
                  (cond
                    ((= v1-78 1)
                     (when (and (< (-> self target-self-xz-dist) 163840.0)
                                (or (< 40960.0 (-> self target-self-xz-dist)) (>= 2 (the-as int (-> self focus aware))))
                                )
                       (if (and (>= (- (current-time) (-> self state-time)) (the int (* 300.0 (get-rand-float-range self 1.0 3.0))))
                                (logtest? (-> self flags) (citizen-flag target-in-sight))
                                )
                           (go-virtual gun-shoot)
                           )
                       )
                     )
                    ((zero? v1-78)
                     (if (or (< (-> self target-self-xz-dist) 28672.0) (>= 2 (the-as int (-> self focus aware))))
                         (go-virtual attack)
                         )
                     )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info-override walk-anim))) 60)
    (none)
    )
  :post (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (handle->process (-> self focus handle))
      (let ((v1-5 (new 'stack-no-clear 'vector)))
        (if (< 32768.0 (-> self target-self-xz-dist))
            (set! (-> v1-5 quad) (-> self move-position quad))
            (set! (-> v1-5 quad) (-> self traffic-target-status position quad))
            )
        (cond
          ((< 8192000.0 (-> self target-self-xz-dist))
           (let ((s5-0 (-> self root-override2 trans))
                 (s4-0 (new 'stack-no-clear 'vector))
                 (s3-0 (new 'stack-no-clear 'vector))
                 (s2-0 (new 'stack-no-clear 'vector))
                 (gp-0 (new 'stack-no-clear 'vector))
                 )
             (new 'stack-no-clear 'vector)
             (set! (-> s3-0 quad) (-> v1-5 quad))
             (vector-z-quaternion! s4-0 (-> self root-override2 quat))
             (let ((f30-0 (* 182.04445 (* 60.0 (the float (- (-> self traffic-id) *guard-min-id-hack*))))))
               (set-vector! s2-0 (cos f30-0) 0.0 (sin f30-0) 1.0)
               )
             (let ((a1-6 s3-0))
               (let ((v1-13 s3-0))
                 (let ((a0-15 s2-0))
                   (let ((a2-1 12288.0))
                     (.mov vf7 a2-1)
                     )
                   (.lvf vf5 (&-> a0-15 quad))
                   )
                 (.lvf vf4 (&-> v1-13 quad))
                 )
               (.add.x.vf vf6 vf0 vf0 :mask #b1000)
               (.mul.x.vf acc vf5 vf7 :mask #b111)
               (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
               (.svf (&-> a1-6 quad) vf6)
               )
             (let ((f30-2 (* 0.5 (vector-vector-xz-distance s5-0 s3-0))))
               (vector-normalize! s4-0 (* 0.5 f30-2))
               (vector-normalize! s2-0 (* 2.0 f30-2))
               )
             (do-spline gp-0 s5-0 s4-0 s3-0 s2-0 0.9)
             (let ((v1-19 (-> self nav state)))
               (logclear! (-> v1-19 flags) (nav-state-flag directional-mode))
               (logior! (-> v1-19 flags) (nav-state-flag target-poly-dirty))
               (set! (-> v1-19 target-post quad) (-> gp-0 quad))
               )
             )
           0
           )
          (else
            (let ((a0-26 (-> self nav state)))
              (logclear! (-> a0-26 flags) (nav-state-flag directional-mode))
              (logior! (-> a0-26 flags) (nav-state-flag target-poly-dirty))
              (set! (-> a0-26 target-post quad) (-> v1-5 quad))
              )
            0
            )
          )
        )
      (nav-enemy-method-176 self)
      (none)
      )
    )
  )

(defstate close-attack (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((v1-4 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-4 enemy-flags)))
          (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-4 enemy-flags))))
          )
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-4 enemy-flags))))
      (set! (-> v1-4 nav callback-info) (-> v1-4 enemy-info-override callback-info))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let* ((v1-9 *game-info*)
           (a0-17 (+ (-> v1-9 attack-id) 1))
           )
      (set! (-> v1-9 attack-id) a0-17)
      (set! (-> self attack-id) a0-17)
      )
    (let ((v1-10 (-> self nav)))
      (set! (-> v1-10 target-speed) 0.0)
      )
    0
    (none)
    )
  :exit (behavior ()
    (let ((v1-3 (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 3)))
      (logclear! (-> v1-3 prim-core action) (collide-action deadly))
      )
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :trans (behavior ()
    (crimson-guard-method-220 self)
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-0 #f))
      (ja-no-eval :group! (-> self draw art-group data 18)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 18)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (when (and (< 7.0 (ja-frame-num 0)) (not gp-0))
          (let ((v1-22 (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 3)))
            (logior! (-> v1-22 prim-core action) (collide-action deadly))
            )
          (set! gp-0 #t)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-virtual hostile)
    (none)
    )
  :post (behavior ()
    (nav-enemy-method-176 self)
    (none)
    )
  )

(defstate gun-shoot (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (set! (-> self other-side) (if (< (rand-vu) 0.5)
                                   #t
                                   #f
                                   )
          )
    (nav-enemy-method-166 self)
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logclear (-> v1-9 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-12 (-> self nav state)))
      (set! (-> v1-12 speed) 0.0)
      )
    0
    (let ((a0-9 (-> self nav state))
          (v1-15 *null-vector*)
          )
      (set! (-> a0-9 velocity quad) (-> v1-15 quad))
      )
    0
    (set! (-> self state-time) (current-time))
    (set! (-> self last-time-see-target) (current-time))
    (crimson-guard-method-220 self)
    (set! (-> self miss-amount) (lerp-scale 0.0 16384.0 (-> self target-self-dist) 40960.0 122880.0))
    (set! (-> self miss-amount) 16384.0)
    (let ((v1-27 (handle->process (-> self focus handle))))
      (if (and v1-27 (logtest? (process-mask enemy) (-> v1-27 mask)))
          (set! (-> self miss-amount) 0.0)
          )
      )
    (set! (-> self next-shot) (the-as int (current-time)))
    (set! (-> self joint-enable) #t)
    (none)
    )
  :exit (behavior ()
    (set! (-> self joint-enable) #f)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (none)
    )
  :trans (behavior ()
    (crimson-guard-method-220 self)
    (let ((gp-0 (handle->process (-> self focus handle))))
      (when gp-0
        (when (not (and gp-0
                        (not (logtest? (-> (the-as process-focusable gp-0) focus-status) (focus-status disable dead ignore grabbed)))
                        )
                   )
          (set! (-> self miss-amount) (lerp-scale 0.0 16384.0 (-> self target-self-dist) 40960.0 122880.0))
          (set! (-> self miss-amount) 16384.0)
          )
        (if (and (< (-> self target-self-xz-dist) 16384.0)
                 (and (< (fabs (-> self target-y-angle)) 7281.778)
                      gp-0
                      (not (logtest? (-> (the-as process-focusable gp-0) focus-status) (focus-status disable dead ignore grabbed)))
                      )
                 )
            (go-virtual close-attack)
            )
        (if (and (>= (- (current-time) (-> self state-time)) (seconds 1))
                 (or (not (logtest? (-> self flags) (citizen-flag target-in-sight)))
                     (< 184320.0 (-> self target-self-xz-dist))
                     (< 10922.667 (fabs (-> self target-y-angle)))
                     )
                 )
            (go-hostile self)
            )
        )
      )
    (none)
    )
  :code (behavior ()
    (local-vars (v1-35 object))
    (speech-control-method-12 *speech-control* self (speech-type speech-type-0 speech-type-3))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self anim-shoot 0 anim-index))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-shoot 0 anim-index))) frames num-frames)
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (seek-toward-heading-vec! (-> self root-override2) (-> self target-self-xz) 65536.0 (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (label cfg-3)
    (when (crimson-guard-method-216 self)
      (set! v1-35 #t)
      (goto cfg-10)
      )
    (when (>= (- (current-time) (-> self state-time)) (seconds 1))
      (set! v1-35 #f)
      (goto cfg-10)
      )
    (suspend)
    (b! (not #f) cfg-3 :delay (set! v1-35 #f))
    (label cfg-10)
    (when v1-35
      (set! (-> self state-time) (current-time))
      (let ((gp-0 3))
        (until #f
          (ja-channel-push! 1 (seconds 0.1))
          (ja-no-eval :group! (-> self draw art-group data (-> self anim-shoot 1 anim-index)) :num! min)
          (set! (-> self already-shot) #t)
          (lerp-scale 1.0 0.2 (-> self target-self-dist) 20480.0 122880.0)
          (let ((f0-8 1.0))
            (cond
              ((logtest? (-> self draw status) (draw-control-status on-screen))
               (let ((v1-58 (handle->process (-> self focus handle))))
                 (when v1-58
                   (if (or (< (-> self target-vel) 40.96)
                           (and (focus-test? (the-as process-focusable v1-58) pilot) (< (-> self target-pos y) 49152.0))
                           )
                       (set! (-> self miss-amount) (- (-> self miss-amount) (* 12288.0 f0-8)))
                       (set! (-> self miss-amount) (- (-> self miss-amount) (* 4096.0 f0-8)))
                       )
                   )
                 )
               )
              (else
                (set! (-> self miss-amount) (- (-> self miss-amount) (* 3276.8 f0-8)))
                )
              )
            )
          (if (< (-> self miss-amount) 0.0)
              (set! (-> self miss-amount) 0.0)
              )
          (crimson-guard-method-214 self)
          (until (ja-done? 0)
            (ja :num! (seek!))
            (suspend)
            )
          (+! gp-0 -1)
          (if (< gp-0 0)
              (goto cfg-40)
              )
          )
        )
      #f
      )
    (label cfg-40)
    (let ((f30-1 (get-rand-float-range self 0.9 1.1)))
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! (-> self draw art-group data (-> self anim-shoot 2 anim-index))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-shoot 2 anim-index))) frames num-frames)
                            -1
                            )
                         )
                    f30-1
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (seek-toward-heading-vec! (-> self root-override2) (-> self target-self-xz) 65536.0 (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (crimson-guard-method-226 self)
    (none)
    )
  :post (behavior ()
    (citizen-method-200 self)
    (nav-enemy-method-176 self)
    (none)
    )
  )

(defmethod crimson-guard-method-226 crimson-guard ((obj crimson-guard))
  (let ((s4-0 (vector-x-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
        (s5-0 (-> obj root-override2))
        (s3-0 (lambda ((arg0 crimson-guard) (arg1 collide-shape-moving) (arg2 vector))
                (let ((s4-0 (new 'stack-no-clear 'vector))
                      (s3-0 (new 'stack-no-clear 'vector))
                      )
                  (vector+! s3-0 (-> arg1 trans) arg2)
                  (cloest-point-on-mesh (-> arg0 nav) s4-0 s3-0 (the-as nav-poly #f))
                  (cond
                    ((< 409.6 (vector-vector-distance s3-0 s4-0))
                     #f
                     )
                    ((let ((a1-4 (new 'stack-no-clear 'vector)))
                       (set! (-> a1-4 quad) (-> s4-0 quad))
                       (set! (-> a1-4 w) (-> arg0 root-override2 nav-radius))
                       (add-root-sphere-to-hash! (-> arg0 nav) a1-4 #x8046e)
                       )
                     #f
                     )
                    (else
                      (let ((a1-5 (new 'stack-no-clear 'collide-query)))
                        (set! (-> a1-5 start-pos quad) (-> arg1 trans quad))
                        (vector-! (-> a1-5 move-dist) s4-0 (-> a1-5 start-pos))
                        (let ((v1-10 a1-5))
                          (set! (-> v1-10 radius) 2048.0)
                          (set! (-> v1-10 collide-with) (-> arg1 root-prim prim-core collide-with))
                          (set! (-> v1-10 ignore-process0) arg0)
                          (set! (-> v1-10 ignore-process1) #f)
                          (set! (-> v1-10 ignore-pat) (-> arg1 pat-ignore-mask))
                          (set! (-> v1-10 action-mask) (collide-action solid))
                          )
                        (if (>= (fill-and-probe-using-line-sphere *collide-cache* a1-5) 0.0)
                            #f
                            #t
                            )
                        )
                      )
                    )
                  )
                )
              )
        )
    (cond
      ((s3-0 obj s5-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-0 24576.0))
       (go (method-of-object obj roll-right))
       )
      ((s3-0 obj s5-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-0 -24576.0))
       (go (method-of-object obj roll-left))
       )
      (else
        (go-hostile obj)
        )
      )
    )
  (none)
  )

(defstate roll-right (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :code (behavior ()
    (vector-reset! (-> self root-override2 transv))
    (vector-x-quaternion! (-> self root-override2 transv) (-> self root-override2 quat))
    (set! (-> self root-override2 transv y) 24576.0)
    (vector-xz-normalize! (-> self root-override2 transv) 40960.0)
    (let ((v1-7 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-7 enemy-flags)))
          (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-7 enemy-flags))))
          )
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-7 enemy-flags))))
      (set! (-> v1-7 nav callback-info) (-> v1-7 enemy-info-override callback-info))
      )
    0
    (ja-channel-push! 1 (seconds 0.1))
    (cond
      ((logtest? (enemy-flag dislike-combo) (-> self enemy-flags))
       (ja-no-eval :group! (-> self draw art-group data 40)
                   :num! (seek! (ja-aframe 6.0 0))
                   :frame-num (ja-aframe 0.0 0)
                   )
       (until (ja-done? 0)
         (let ((a0-20 (handle->process (-> self focus handle))))
           (if a0-20
               (seek-toward-heading-vec!
                 (-> self root-override2)
                 (vector-!
                   (new 'stack-no-clear 'vector)
                   (get-trans (the-as process-focusable a0-20) 0)
                   (-> self root-override2 trans)
                   )
                 32768.0
                 (seconds 0.05)
                 )
               )
           )
         (suspend)
         (ja :num! (seek! (ja-aframe 6.0 0)))
         )
       )
      (else
        (ja-no-eval :group! (-> self draw art-group data 41)
                    :num! (seek! (ja-aframe 9.0 0))
                    :frame-num (ja-aframe 0.0 0)
                    )
        (until (ja-done? 0)
          (let ((a0-33 (handle->process (-> self focus handle))))
            (if a0-33
                (seek-toward-heading-vec!
                  (-> self root-override2)
                  (vector-!
                    (new 'stack-no-clear 'vector)
                    (get-trans (the-as process-focusable a0-33) 0)
                    (-> self root-override2 trans)
                    )
                  32768.0
                  (seconds 0.05)
                  )
                )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 9.0 0)))
          )
        )
      )
    (let ((v1-59 self))
      (set! (-> v1-59 enemy-flags) (the-as enemy-flag (logclear (-> v1-59 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-59 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (cond
      ((logtest? (enemy-flag dislike-combo) (-> self enemy-flags))
       (ja-no-eval :group! (-> self draw art-group data 40)
                   :num! (seek! (ja-aframe 11.0 0))
                   :frame-num (ja-aframe 6.0 0)
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 11.0 0)))
         )
       )
      (else
        (ja-no-eval :group! (-> self draw art-group data 41)
                    :num! (seek! (ja-aframe 11.0 0))
                    :frame-num (ja-aframe 9.0 0)
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! (ja-aframe 11.0 0)))
          )
        )
      )
    (go-virtual gun-shoot)
    (none)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (when (logtest? (enemy-flag enemy-flag36) (-> a0-0 enemy-flags))
        (vector-v++!
          (-> self root-override2 transv)
          (compute-acc-due-to-gravity (-> self root-override2) (new 'stack-no-clear 'vector) 0.0)
          )
        (let ((a2-1 (new 'stack-no-clear 'collide-query))
              (a0-5 (-> self root-override2))
              )
          (set! (-> a2-1 collide-with) (-> a0-5 root-prim prim-core collide-with))
          (set! (-> a2-1 ignore-process0) self)
          (set! (-> a2-1 ignore-process1) #f)
          (set! (-> a2-1 ignore-pat) (-> a0-5 pat-ignore-mask))
          (set! (-> a2-1 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide a0-5 (-> self root-override2 transv) a2-1 (meters 0))
          )
        )
      )
    (nav-enemy-simple-post)
    (none)
    )
  )

(defstate roll-left (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :code (behavior ()
    (vector-reset! (-> self root-override2 transv))
    (vector-x-quaternion! (-> self root-override2 transv) (-> self root-override2 quat))
    (set! (-> self root-override2 transv y) 24576.0)
    (vector-xz-normalize! (-> self root-override2 transv) -40960.0)
    (let ((v1-7 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-7 enemy-flags)))
          (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-7 enemy-flags))))
          )
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-7 enemy-flags))))
      (set! (-> v1-7 nav callback-info) (-> v1-7 enemy-info-override callback-info))
      )
    0
    (ja-channel-push! 1 (seconds 0.1))
    (cond
      ((logtest? (enemy-flag dislike-combo) (-> self enemy-flags))
       (ja-no-eval :group! (-> self draw art-group data 41)
                   :num! (seek! (ja-aframe 9.0 0))
                   :frame-num (ja-aframe 0.0 0)
                   )
       (until (ja-done? 0)
         (let ((a0-20 (handle->process (-> self focus handle))))
           (if a0-20
               (seek-toward-heading-vec!
                 (-> self root-override2)
                 (vector-!
                   (new 'stack-no-clear 'vector)
                   (get-trans (the-as process-focusable a0-20) 0)
                   (-> self root-override2 trans)
                   )
                 32768.0
                 (seconds 0.05)
                 )
               )
           )
         (suspend)
         (ja :num! (seek! (ja-aframe 9.0 0)))
         )
       )
      (else
        (ja-no-eval :group! (-> self draw art-group data 40)
                    :num! (seek! (ja-aframe 6.0 0))
                    :frame-num (ja-aframe 0.0 0)
                    )
        (until (ja-done? 0)
          (let ((a0-33 (handle->process (-> self focus handle))))
            (if a0-33
                (seek-toward-heading-vec!
                  (-> self root-override2)
                  (vector-!
                    (new 'stack-no-clear 'vector)
                    (get-trans (the-as process-focusable a0-33) 0)
                    (-> self root-override2 trans)
                    )
                  32768.0
                  (seconds 0.05)
                  )
                )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 6.0 0)))
          )
        )
      )
    (let ((v1-59 self))
      (set! (-> v1-59 enemy-flags) (the-as enemy-flag (logclear (-> v1-59 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-59 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (cond
      ((logtest? (enemy-flag dislike-combo) (-> self enemy-flags))
       (ja-no-eval :group! (-> self draw art-group data 41)
                   :num! (seek! (ja-aframe 11.0 0))
                   :frame-num (ja-aframe 9.0 0)
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 11.0 0)))
         )
       )
      (else
        (ja-no-eval :group! (-> self draw art-group data 40)
                    :num! (seek! (ja-aframe 11.0 0))
                    :frame-num (ja-aframe 6.0 0)
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! (ja-aframe 11.0 0)))
          )
        )
      )
    (go-virtual gun-shoot)
    (none)
    )
  :post (-> (method-of-type crimson-guard roll-right) post)
  )

(defstate arrest (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (nav-enemy-method-167 self)
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (vector-reset! (-> self root-override2 transv))
    (let ((a0-9 (-> self nav state))
          (v1-12 *null-vector*)
          )
      (set! (-> a0-9 velocity quad) (-> v1-12 quad))
      )
    0
    (set! (-> self state-time) (current-time))
    (set! (-> self last-time-see-target) (current-time))
    (set! (-> self miss-amount) 0.0)
    (set! (-> self next-shot) (the-as int (current-time)))
    (set! (-> self joint-enable) #t)
    (crimson-guard-method-221 self)
    (none)
    )
  :exit (behavior ()
    (set! (-> self joint-enable) #f)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (none)
    )
  :trans (behavior ()
    (crimson-guard-method-220 self)
    (send-event (handle->process (-> self focus handle)) 'arrest)
    (none)
    )
  :code (behavior ()
    (speech-control-method-12 *speech-control* self (speech-type speech-type-0 speech-type-2 speech-type-3))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data 19)
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 19)) frames num-frames) -1))
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (seek-toward-heading-vec! (-> self root-override2) (-> self target-self-xz) 65536.0 (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (until #f
      (if (or (not (logtest? (-> self flags) (citizen-flag target-in-sight)))
              (< 49152.0 (-> self target-self-xz-dist))
              (< 10922.667 (fabs (-> self target-y-angle)))
              )
          (goto cfg-17)
          )
      (ja-no-eval :group! (-> self draw art-group data 20)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 20)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (label cfg-17)
    (let ((f30-1 (get-rand-float-range self 0.9 1.1)))
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! (-> self draw art-group data 24)
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 24)) frames num-frames) -1))
                    f30-1
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (seek-toward-heading-vec! (-> self root-override2) (-> self target-self-xz) 65536.0 (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (go-hostile self)
    (none)
    )
  :post (behavior ()
    (citizen-method-200 self)
    (nav-enemy-simple-post)
    (none)
    )
  )

(defstate waiting-ambush (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (nav-enemy-method-167 self)
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (vector-reset! (-> self root-override2 transv))
    (let ((a0-9 (-> self nav state))
          (v1-12 *null-vector*)
          )
      (set! (-> a0-9 velocity quad) (-> v1-12 quad))
      )
    0
    (set! (-> self state-time) (current-time))
    (set! (-> self miss-amount) 0.0)
    (set! (-> self next-shot) (the-as int (current-time)))
    (set! (-> self joint-enable) #t)
    (crimson-guard-method-221 self)
    (none)
    )
  :exit (behavior ()
    (set! (-> self joint-enable) #f)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (none)
    )
  :trans (behavior ()
    (crimson-guard-method-220 self)
    (if (logtest? (-> self flags) (citizen-flag target-in-sight))
        (speech-control-method-12 *speech-control* self (speech-type speech-type-0 speech-type-1))
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data 19)
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 19)) frames num-frames) -1))
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (while (not (logtest? (-> self flags) (citizen-flag target-in-sight)))
      (ja-no-eval :group! (-> self draw art-group data 20)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 20)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (let ((f30-1 (get-rand-float-range self 0.9 1.1)))
      (ja-channel-push! 1 (seconds 0.2))
      (ja-no-eval :group! (-> self draw art-group data 24)
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 24)) frames num-frames) -1))
                    f30-1
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (go-hostile self)
    (none)
    )
  :post (behavior ()
    (seek-toward-heading-vec! (-> self root-override2) (-> self target-self-xz) 65536.0 (seconds 0.02))
    (nav-enemy-simple-post)
    (none)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defun spread-lightning-lazer ((arg0 lightning-control) (arg1 vector) (arg2 vector) (arg3 vector))
  (local-vars (sv-640 int) (sv-656 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg1 quad))
      (let ((s4-0 (new 'stack-no-clear 'vector)))
        (set! (-> s4-0 quad) (-> arg2 quad))
        (let ((s3-0 (new 'stack-no-clear 'vector))
              (s2-0 (new 'stack-no-clear 'quaternion))
              )
          (vector-length arg2)
          (let ((s1-0 (new 'stack-no-clear 'vector)))
            (set! (-> s1-0 quad) (-> arg3 quad))
            (let ((s0-0 (new 'stack-no-clear 'collide-query)))
              (set! sv-640 0)
              (while (< sv-640 6)
                (let ((v1-6 s0-0))
                  (set! (-> v1-6 radius) 2867.2)
                  (set! (-> v1-6 collide-with)
                        (collide-spec jak bot civilian enemy vehicle-sphere hit-by-others-list player-list)
                        )
                  (set! (-> v1-6 ignore-process0) #f)
                  (set! (-> v1-6 ignore-process1) #f)
                  (set! (-> v1-6 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                  (set! (-> v1-6 action-mask) (collide-action solid))
                  )
                (set! (-> s0-0 start-pos quad) (-> s5-0 quad))
                (set! (-> s0-0 move-dist quad) (-> s4-0 quad))
                (set-from-point-offset-pad! (-> s0-0 bbox) (-> s0-0 start-pos) (-> s0-0 move-dist) (-> s0-0 radius))
                (fill-using-bounding-box *collide-cache* s0-0)
                (set! (-> s0-0 radius) 409.6)
                (let ((f0-4 (probe-using-line-sphere *collide-cache* s0-0)))
                  (cond
                    ((>= f0-4 0.0)
                     (let ((a1-4 s3-0))
                       (let ((v1-13 (-> s0-0 start-pos)))
                         (let ((a0-12 (-> s0-0 move-dist)))
                           (let ((a2-2 f0-4))
                             (.mov vf7 a2-2)
                             )
                           (.lvf vf5 (&-> a0-12 quad))
                           )
                         (.lvf vf4 (&-> v1-13 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> a1-4 quad) vf6)
                       )
                     (set! (-> s5-0 quad) (-> s3-0 quad))
                     )
                    (else
                      (vector+! (-> s0-0 start-pos) s5-0 s4-0)
                      (let ((a1-7 (-> s0-0 start-pos)))
                        (let ((v1-16 (-> s0-0 start-pos)))
                          (let ((a0-16 s1-0))
                            (let ((a2-4 -2048.0))
                              (.mov vf7 a2-4)
                              )
                            (.lvf vf5 (&-> a0-16 quad))
                            )
                          (.lvf vf4 (&-> v1-16 quad))
                          )
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> a1-7 quad) vf6)
                        )
                      (vector-negate! (-> s0-0 move-dist) s4-0)
                      (set! f0-4 (probe-using-line-sphere *collide-cache* s0-0))
                      (when (>= f0-4 0.0)
                        (let ((a1-10 s3-0))
                          (let ((v1-19 (-> s0-0 start-pos)))
                            (let ((a0-19 (-> s0-0 move-dist)))
                              (let ((a2-5 f0-4))
                                (.mov vf7 a2-5)
                                )
                              (.lvf vf5 (&-> a0-19 quad))
                              )
                            (.lvf vf4 (&-> v1-19 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a1-10 quad) vf6)
                          )
                        (let ((a1-11 s3-0))
                          (let ((v1-20 s3-0))
                            (let ((a0-20 s1-0))
                              (let ((a2-7 2048.0))
                                (.mov vf7 a2-7)
                                )
                              (.lvf vf5 (&-> a0-20 quad))
                              )
                            (.lvf vf4 (&-> v1-20 quad))
                            )
                          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                          (.mul.x.vf acc vf5 vf7 :mask #b111)
                          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                          (.svf (&-> a1-11 quad) vf6)
                          )
                        (set! (-> s5-0 quad) (-> s3-0 quad))
                        )
                      )
                    )
                  (cond
                    ((>= f0-4 0.0)
                     (+! (-> s3-0 x) (rand-vu-float-range -819.2 819.2))
                     (+! (-> s3-0 y) (rand-vu-float-range -819.2 819.2))
                     (+! (-> s3-0 z) (rand-vu-float-range -819.2 819.2))
                     (set-point! arg0 (-> arg0 state points-to-draw) s3-0)
                     (+! (-> arg0 state points-to-draw) 1)
                     (set! sv-656 (-> s0-0 best-other-tri normal))
                     (quaternion-from-two-vectors! s2-0 s1-0 sv-656)
                     (vector-orient-by-quat! s4-0 s4-0 s2-0)
                     (set! (-> s1-0 quad) (-> sv-656 quad))
                     (vector-flatten! s4-0 s4-0 sv-656)
                     )
                    (else
                      (vector+! s5-0 s5-0 s4-0)
                      (when (< sv-640 6)
                        (set-point! arg0 (-> arg0 state points-to-draw) s5-0)
                        (+! (-> arg0 state points-to-draw) 1)
                        )
                      )
                    )
                  )
                (set! sv-640 (+ sv-640 1))
                )
              )
            )
          )
        )
      )
    (none)
    )
  )

(defmethod crimson-guard-method-222 crimson-guard ((obj crimson-guard))
  (local-vars (sv-800 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((s4-0 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 14)))
           (v0-1 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data 15)))
           (s2-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s4-0 v0-1) 16384.0))
           (s1-0
             (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> obj target-pos-predict-miss) s4-0) 16384.0)
             )
           (s5-0 (new 'stack-no-clear 'vector))
           (s3-0 (new 'stack-no-clear 'collide-query))
           )
      (when (< 1820.4445 (vector-vector-angle-safe s2-0 s1-0))
        (let* ((a1-9 (vector-normalize! (vector-cross! (new 'stack-no-clear 'vector) s2-0 s1-0) 1.0))
               (a2-1 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) a1-9 1820.4445))
               )
          (vector-orient-by-quat! s1-0 s2-0 a2-1)
          )
        )
      (let ((a0-12 s4-0))
        (let ((v1-8 s4-0))
          (let ((a1-12 0.2))
            (.mov vf7 a1-12)
            )
          (.lvf vf5 (&-> s2-0 quad))
          (.lvf vf4 (&-> v1-8 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> a0-12 quad) vf6)
        )
      (vector+! s5-0 s4-0 s1-0)
      (let ((v1-10 s3-0))
        (set! (-> v1-10 radius) 409.6)
        (set! (-> v1-10 collide-with)
              (collide-spec jak bot civilian enemy vehicle-sphere hit-by-others-list player-list)
              )
        (set! (-> v1-10 ignore-process0) #f)
        (set! (-> v1-10 ignore-process1) #f)
        (set! (-> v1-10 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-10 action-mask) (collide-action solid))
        )
      (set! (-> s3-0 start-pos quad) (-> s4-0 quad))
      (set! (-> s3-0 move-dist quad) (-> s1-0 quad))
      (set! (-> obj l-control state points-to-draw) 0)
      (let ((f0-3 (fill-and-probe-using-line-sphere *collide-cache* s3-0))
            (s2-1 (new 'stack-no-clear 'vector))
            )
        (cond
          ((>= f0-3 0.0)
           (vector-float*! s1-0 (-> s3-0 move-dist) f0-3)
           (vector+! s5-0 s4-0 s1-0)
           (point-in-plane-<-point+normal! s2-1 s5-0 (-> s3-0 best-other-tri normal))
           (vector-! s2-1 s2-1 s5-0)
           (let ((s1-1 quaternion-vector-angle!)
                 (s0-0 (new 'stack-no-clear 'quaternion))
                 )
             (set! sv-800 (-> s3-0 best-other-tri normal))
             (let* ((a2-3 (rand-vu-float-range 0.0 65536.0))
                    (a2-4 (s1-1 s0-0 sv-800 a2-3))
                    )
               (vector-orient-by-quat! s2-1 s2-1 a2-4)
               )
             )
           (let ((s1-2 (get-process *default-dead-pool* part-tracker #x4000)))
             (when s1-2
               (let ((t9-14 (method-of-type part-tracker activate)))
                 (t9-14 (the-as part-tracker s1-2) obj (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                 )
               (let ((t9-15 run-function-in-process)
                     (a0-33 s1-2)
                     (a1-24 part-tracker-init)
                     (a2-9 (-> *part-group-id-table* 140))
                     (a3-1 0)
                     (t0-0 #f)
                     (t1-0 #f)
                     (t2-0 #f)
                     (t3-0 *launch-matrix*)
                     )
                 (set! (-> t3-0 trans quad) (-> s4-0 quad))
                 ((the-as (function object object object object object object object object none) t9-15)
                  a0-33
                  a1-24
                  a2-9
                  a3-1
                  t0-0
                  t1-0
                  t2-0
                  t3-0
                  )
                 )
               (-> s1-2 ppointer)
               )
             )
           (let ((s1-3 (get-process *default-dead-pool* part-tracker #x4000)))
             (when s1-3
               (let ((t9-17 (method-of-type part-tracker activate)))
                 (t9-17 (the-as part-tracker s1-3) obj (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                 )
               (let ((t9-18 run-function-in-process)
                     (a0-36 s1-3)
                     (a1-27 part-tracker-init)
                     (a2-14 (-> *part-group-id-table* 140))
                     (a3-3 0)
                     (t0-1 #f)
                     (t1-1 #f)
                     (t2-1 #f)
                     (t3-1 *launch-matrix*)
                     )
                 (set! (-> t3-1 trans quad) (-> s5-0 quad))
                 ((the-as (function object object object object object object object object none) t9-18)
                  a0-36
                  a1-27
                  a2-14
                  a3-3
                  t0-1
                  t1-1
                  t2-1
                  t3-1
                  )
                 )
               (-> s1-3 ppointer)
               )
             )
           (set-point! (-> obj l-control) 0 s4-0)
           (set-point! (-> obj l-control) 1 s5-0)
           (set! (-> obj l-control spec) (-> *lightning-spec-id-table* 13))
           (+! (-> obj l-control state points-to-draw) 2)
           (let* ((s1-4 (-> s3-0 best-other-tri collide-ptr))
                  (v1-43 (if (type? s1-4 collide-shape-prim)
                             s1-4
                             )
                         )
                  (s1-5 #t)
                  )
             (when v1-43
               (set! s1-5 #f)
               (let ((s0-1 (new 'stack-no-clear 'projectile-init-by-other-params)))
                 (set! (-> s0-1 ent) (-> obj entity))
                 (set! (-> s0-1 charge) 1.0)
                 (set! (-> s0-1 options) (projectile-options))
                 (set! (-> s0-1 notify-handle) (process->handle obj))
                 (set! (-> s0-1 owner-handle) (the-as handle #f))
                 (set! (-> s0-1 ignore-handle) (process->handle obj))
                 (set! (-> s0-1 attack-id) (-> obj attack-id))
                 (set! (-> s0-1 timeout) (seconds 4))
                 (set! (-> s0-1 pos quad) (-> s4-0 quad))
                 (vector-! (-> s0-1 vel) s5-0 s4-0)
                 (vector-normalize! (-> s0-1 vel) 131072.0)
                 (spawn-projectile guard-lazer-shot s0-1 obj *default-dead-pool*)
                 )
               )
             )
           (spread-lightning-lazer (-> obj l-control) s5-0 s2-1 (-> s3-0 best-other-tri normal))
           )
          (else
            (let ((s3-1 (get-process *default-dead-pool* part-tracker #x4000)))
              (when s3-1
                (let ((t9-26 (method-of-type part-tracker activate)))
                  (t9-26 (the-as part-tracker s3-1) obj (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                  )
                (let ((t9-27 run-function-in-process)
                      (a0-59 s3-1)
                      (a1-36 part-tracker-init)
                      (a2-23 (-> *part-group-id-table* 140))
                      (a3-7 0)
                      (t0-3 #f)
                      (t1-2 #f)
                      (t2-2 #f)
                      (t3-2 *launch-matrix*)
                      )
                  (set! (-> t3-2 trans quad) (-> s4-0 quad))
                  ((the-as (function object object object object object object object object none) t9-27)
                   a0-59
                   a1-36
                   a2-23
                   a3-7
                   t0-3
                   t1-2
                   t2-2
                   t3-2
                   )
                  )
                (-> s3-1 ppointer)
                )
              )
            (let ((s3-2 (get-process *default-dead-pool* part-tracker #x4000)))
              (when s3-2
                (let ((t9-29 (method-of-type part-tracker activate)))
                  (t9-29 (the-as part-tracker s3-2) obj (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                  )
                (let ((t9-30 run-function-in-process)
                      (a0-62 s3-2)
                      (a1-39 part-tracker-init)
                      (a2-28 (-> *part-group-id-table* 140))
                      (a3-9 0)
                      (t0-4 #f)
                      (t1-3 #f)
                      (t2-3 #f)
                      (t3-3 *launch-matrix*)
                      )
                  (set! (-> t3-3 trans quad) (-> s5-0 quad))
                  ((the-as (function object object object object object object object object none) t9-30)
                   a0-62
                   a1-39
                   a2-28
                   a3-9
                   t0-4
                   t1-3
                   t2-3
                   t3-3
                   )
                  )
                (-> s3-2 ppointer)
                )
              )
            (set! (-> obj l-control state points-to-draw) 9)
            (set! (-> obj l-control spec) (-> *lightning-spec-id-table* 14))
            (let ((v1-77 s4-0))
              (set! (-> obj l-control state meet data 0 quad) (-> v1-77 quad))
              )
            (let ((a0-68 (-> obj l-control))
                  (v1-79 s5-0)
                  )
              (set! (-> a0-68 state meet data (+ (-> a0-68 state points-to-draw) -1) quad) (-> v1-79 quad))
              )
            )
          )
        )
      )
    (none)
    )
  )

(defstate attack (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (set! (-> self joint-enable) #t)
    (logior! (-> self focus-status) (focus-status dangerous))
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-5 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-8 self))
      (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logclear (-> v1-8 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (set! (-> self miss-amount) 0.0)
    (set! (-> self state-time) (current-time))
    (set! (-> self lazer-sound) (new 'static 'sound-id))
    0
    (none)
    )
  :exit (behavior ()
    (if (nonzero? (-> self lazer-sound))
        (sound-stop (-> self lazer-sound))
        )
    (iterate-prims
      (-> self root-override2)
      (lambda ((arg0 collide-shape-prim)) (logclear! (-> arg0 prim-core action) (collide-action deadly)) (none))
      )
    (let ((v1-5 (-> self l-control))
          (a0-2 0)
          )
      (let ((a1-2 (!= a0-2 (-> v1-5 state mode))))
        (case a0-2
          ((3)
           (if a1-2
               (set! (-> v1-5 state counter) 0.0)
               )
           )
          ((1)
           (set! (-> v1-5 state start-color) (-> v1-5 spec start-color))
           (set! (-> v1-5 state end-color) (-> v1-5 spec end-color))
           )
          )
        )
      (set! (-> v1-5 state mode) (the-as lightning-mode a0-2))
      )
    (set! (-> self joint-enable) #f)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :trans (behavior ()
    (crimson-guard-method-220 self)
    (if (and (>= (- (current-time) (-> self state-time)) (seconds 1))
             (or (< 32768.0 (-> self target-self-xz-dist)) (not (logtest? (-> self flags) (citizen-flag target-in-sight))))
             )
        (go-hostile self)
        )
    (let ((v1-14 (handle->process (-> self focus handle))))
      (if (or (focus-test? (the-as process-focusable v1-14) inactive)
              (focus-test? (the-as process-focusable v1-14) disable)
              )
          (set! v1-14 (the-as process #f))
          )
      (if (not v1-14)
          (go-virtual active)
          )
      )
    (none)
    )
  :code (behavior ()
    (local-vars (v1-94 symbol))
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data 19) :num! (seek! (ja-aframe 7.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 7.0 0)))
      )
    (let ((gp-2 #t))
      (until #f
        (while (or (< 7281.778 (fabs (-> self target-y-angle))) (>= (-> self next-shot) (current-time)))
          (when gp-2
            )
          (speech-control-method-12 *speech-control* self (speech-type speech-type-0 speech-type-3))
          (cond
            ((< 7281.778 (fabs (-> self target-y-angle)))
             (ja-channel-push! 1 (seconds 0.1))
             (while (< 7281.778 (fabs (-> self target-y-angle)))
               (let ((f0-6 (the-as float (-> self target-y-angle)))
                     (f30-0 16384.0)
                     )
                 (if (< (the-as degrees f0-6) 0.0)
                     (set! f30-0 (- f30-0))
                     )
                 (if (logtest? (enemy-flag dislike-combo) (-> self enemy-flags))
                     (set! f0-6 (- (the-as degrees f0-6)))
                     )
                 (cond
                   ((< f0-6 0.0)
                    (ja-no-eval :group! (-> self draw art-group data 25)
                                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 25)) frames num-frames) -1)))
                                :frame-num 0.0
                                )
                    (until (ja-done? 0)
                      (quaternion-rotate-local-y!
                        (-> self root-override2 quat)
                        (-> self root-override2 quat)
                        (* f30-0 (-> self clock seconds-per-frame))
                        )
                      (suspend)
                      (ja :num! (seek!))
                      )
                    )
                   (else
                     (ja-no-eval :group! (-> self draw art-group data 25)
                                 :num! (seek! 0.0)
                                 :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 25)) frames num-frames) -1))
                                 )
                     (until (ja-done? 0)
                       (quaternion-rotate-local-y!
                         (-> self root-override2 quat)
                         (-> self root-override2 quat)
                         (* f30-0 (-> self clock seconds-per-frame))
                         )
                       (suspend)
                       (ja :num! (seek! 0.0))
                       )
                     )
                   )
                 )
               )
             )
            (else
              (ja-channel-push! 1 (seconds 0.1))
              (ja-no-eval :group! (-> self draw art-group data 20) :num! (loop!))
              (until v1-94
                (suspend)
                (ja :num! (loop!))
                (set! v1-94
                      (or (< (current-time) (-> self next-shot))
                          (< (-> self target-self-xz-dist) 16384.0)
                          (not (and (handle->process (-> self focus handle))
                                    (not (logtest? (-> (the-as process-focusable (handle->process (-> self focus handle))) focus-status)
                                                   (focus-status disable dead ignore grabbed)
                                                   )
                                         )
                                    )
                               )
                          (>= (fabs (-> self target-y-angle)) 7281.778)
                          )
                      )
                )
              )
            )
          (when (< (-> self target-self-xz-dist) 16384.0)
            (set! (-> self next-shot) 0)
            0
            )
          )
        (cond
          ((and (handle->process (-> self focus handle))
                (not (logtest? (-> (the-as process-focusable (handle->process (-> self focus handle))) focus-status)
                               (focus-status disable dead ignore grabbed)
                               )
                     )
                )
           (cond
             ((< (-> self target-self-xz-dist) 16384.0)
              (go-virtual close-attack)
              )
             (else
               (ja-channel-push! 1 (seconds 0.1))
               (ja-no-eval :group! (-> self draw art-group data 21)
                           :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 21)) frames num-frames) -1)))
                           :frame-num 0.0
                           )
               (until (ja-done? 0)
                 (suspend)
                 (ja :num! (seek!))
                 )
               (crimson-guard-method-221 self)
               (set! (-> self next-shot) (the-as int (+ (current-time) (seconds 0.1))))
               (let ((v1-155 (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 2)))
                 (logior! (-> v1-155 prim-core action) (collide-action deadly))
                 )
               (let* ((v1-156 *game-info*)
                      (a0-52 (+ (-> v1-156 attack-id) 1))
                      )
                 (set! (-> v1-156 attack-id) a0-52)
                 (set! (-> self attack-id) a0-52)
                 )
               (set! (-> self lazer-sound) (sound-play "guard-zap"))
               (let ((v1-158 (-> self l-control))
                     (a0-56 1)
                     )
                 (let ((a1-31 (!= a0-56 (-> v1-158 state mode))))
                   (case a0-56
                     ((3)
                      (if a1-31
                          (set! (-> v1-158 state counter) 0.0)
                          )
                      )
                     ((1)
                      (set! (-> v1-158 state start-color) (-> v1-158 spec start-color))
                      (set! (-> v1-158 state end-color) (-> v1-158 spec end-color))
                      )
                     )
                   )
                 (set! (-> v1-158 state mode) (the-as lightning-mode a0-56))
                 )
               (let ((s5-1 (current-time))
                     (s4-1 150)
                     (f30-1 1.0)
                     )
                 (ja-no-eval :group! (-> self draw art-group data 22) :num! (loop! f30-1) :frame-num 0.0)
                 (until (>= (- (current-time) s5-1) s4-1)
                   (crimson-guard-method-222 self)
                   (suspend)
                   (ja :num! (loop! f30-1))
                   )
                 )
               (let ((v1-181 (-> (the-as collide-shape-prim-group (-> self root-override2 root-prim)) child 2)))
                 (logclear! (-> v1-181 prim-core action) (collide-action deadly))
                 )
               (let ((v1-182 (-> self l-control))
                     (a0-62 3)
                     )
                 (let ((a1-44 (!= a0-62 (-> v1-182 state mode))))
                   (case a0-62
                     ((3)
                      (if a1-44
                          (set! (-> v1-182 state counter) 0.0)
                          )
                      )
                     ((1)
                      (set! (-> v1-182 state start-color) (-> v1-182 spec start-color))
                      (set! (-> v1-182 state end-color) (-> v1-182 spec end-color))
                      )
                     )
                   )
                 (set! (-> v1-182 state mode) (the-as lightning-mode a0-62))
                 )
               (ja-no-eval :group! (-> self draw art-group data 23)
                           :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 23)) frames num-frames) -1)))
                           :frame-num 0.0
                           )
               (until (ja-done? 0)
                 (suspend)
                 (ja :num! (seek!))
                 )
               )
             )
           )
          (else
            (set! (-> self next-shot) (the-as int (+ (current-time) (seconds 1))))
            (suspend)
            0
            )
          )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (citizen-method-200 self)
    (nav-enemy-method-176 self)
    (none)
    )
  )

(defmethod crimson-guard-method-223 crimson-guard ((obj crimson-guard) (arg0 float))
  (let* ((s3-0 (handle->process (-> obj transport)))
         (s4-0 (if (type? s3-0 process-focusable)
                   (the-as process-focusable s3-0)
                   )
               )
         )
    (when s4-0
      (let ((s2-0 (matrix<-transformq! (new 'stack-no-clear 'matrix) (the-as transformq (-> s4-0 root-override trans))))
            (s3-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> s3-1 x) (if (zero? (-> obj transport-side))
                              -8192.0
                              8192.0
                              )
              )
        (set! (-> s3-1 y) 12288.0)
        (set! (-> s3-1 z) (lerp-scale -16384.0 -49152.0 arg0 0.0 1.0))
        (set! (-> s3-1 w) 1.0)
        (quaternion-rotate-local-y! (-> obj root-override2 quat) (-> s4-0 root-override quat) 32768.0)
        (vector-matrix*! (-> obj root-override2 trans) s3-1 s2-0)
        )
      )
    )
  (let ((f0-5 (fmax 0.0 (fmin 1.0 (* 3.3333333 arg0)))))
    (set-vector! (-> obj draw color-mult) f0-5 f0-5 f0-5 1.0)
    )
  0
  (none)
  )

;; ERROR: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defmethod crimson-guard-method-224 crimson-guard ((obj crimson-guard) (arg0 vector))
  (local-vars
    (f0-8 float)
    (sv-768 vector)
    (sv-784 vector)
    (sv-800 nav-control)
    (sv-816 nav-poly)
    (sv-832 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
          (f30-0 0.0)
          )
      (dotimes (s3-0 2)
        (vector-normalize! s4-0 (* 4096.0 (+ 4.0 (* 2.0 (the float s3-0)))))
        (dotimes (s2-0 6)
          (set! sv-768 (new 'stack-no-clear 'vector))
          (let ((s1-0 (new 'stack-no-clear 'vector))
                (s0-0 (new 'stack 'collide-query))
                )
            (vector-rotate-around-y! sv-768 s4-0 (* 182.04445 (the float (+ (* 23 s2-0) -70))))
            (let ((v1-10 s1-0))
              (let ((a0-6 (-> obj root-override2 trans)))
                (let ((a1-5 sv-768))
                  (let ((a2-2 1.0))
                    (.mov vf7 a2-2)
                    )
                  (.lvf vf5 (&-> a1-5 quad))
                  )
                (.lvf vf4 (&-> a0-6 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> v1-10 quad) vf6)
              )
            (if (enemy-above-ground? obj s0-0 s1-0 (collide-spec backgnd) 8192.0 81920.0 1024.0)
                (set! (-> s1-0 y) (-> s0-0 best-other-tri intersect y))
                )
            (let ((v1-14 (-> obj nav))
                  (a0-8 s1-0)
                  (a1-7 (new 'stack-no-clear 'nav-find-poly-parms))
                  )
              (vector-! (-> a1-7 point) a0-8 (-> v1-14 state mesh bounds))
              (set! (-> a1-7 y-threshold) (-> v1-14 nearest-y-threshold))
              (set! (-> a1-7 ignore) (the-as uint 2))
              (set! sv-816 (find-poly-containing-point-local (-> v1-14 state mesh) a1-7))
              )
            (when sv-816
              (let* ((v1-18 s4-0)
                     (f0-7 (-> sv-768 x))
                     (f1-4 (-> sv-768 y))
                     (f2-2 (-> sv-768 z))
                     (f3-2 (-> v1-18 x))
                     (f4-0 (-> v1-18 y))
                     (f5-0 (-> v1-18 z))
                     )
                ; (.mula.s f0-7 f3-2)
                ; (.madda.s f1-4 f4-0)
                ; (.madd.s f0-8 f2-2 f5-0)
                (set! f0-8 (+ (* f0-7 f3-2) (* f1-4 f4-0) (* f2-2 f5-0)))
                )
              (let ((f28-0 f0-8))
                (new 'stack-no-clear 'vector)
                (let ((a1-8 (new 'stack-no-clear 'vector)))
                  (set! (-> a1-8 quad) (-> s1-0 quad))
                  (set! (-> a1-8 w) 8192.0)
                  (when (not (add-root-sphere-to-hash! (-> obj nav) a1-8 32))
                    (when (< f30-0 f28-0)
                      (set! f30-0 f28-0)
                      (set! sv-784 (new 'stack-no-clear 'vector))
                      (let ((a3-3 (new 'stack-no-clear 'vector)))
                        (set! sv-800 (-> obj nav))
                        (set! sv-832 sv-784)
                        (let* ((v1-29 s1-0)
                               (a0-18 (-> sv-800 state mesh))
                               (t9-7 (method-of-object a0-18 project-point-onto-plane-of-poly-local))
                               (a2-7 sv-832)
                               (t0-2 (vector-! (new 'stack-no-clear 'vector) v1-29 (-> sv-800 state mesh bounds)))
                               )
                          (t9-7 a0-18 sv-816 a2-7 a3-3 t0-2)
                          )
                        )
                      (let ((v1-30 sv-832))
                        (let ((a0-21 (-> sv-800 state mesh bounds)))
                          (.mov.vf vf6 vf0 :mask #b1000)
                          (.lvf vf4 (&-> sv-832 quad))
                          (.lvf vf5 (&-> a0-21 quad))
                          )
                        (.add.vf vf6 vf4 vf5 :mask #b111)
                        (.svf (&-> v1-30 quad) vf6)
                        )
                      0
                      (set! (-> s1-0 y) (-> sv-784 y))
                      (if (enemy-above-ground? obj s0-0 s1-0 (collide-spec backgnd) 8192.0 81920.0 1024.0)
                          (set! (-> s1-0 y) (-> s0-0 best-other-tri intersect y))
                          )
                      (set! (-> arg0 quad) (-> s1-0 quad))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      f30-0
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod enemy-method-93 crimson-guard ((obj crimson-guard))
  (let ((s5-0 (-> obj nav state))
        (v1-2 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
        )
    (set! (-> s5-0 heading quad) (-> v1-2 quad))
    )
  0
  (let ((s5-1 (-> obj nav state))
        (v1-7 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
        )
    (logior! (-> s5-1 flags) (nav-state-flag directional-mode))
    (set! (-> s5-1 travel quad) (-> v1-7 quad))
    )
  0
  (let ((s5-2 (-> obj nav state))
        (v1-12 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
        )
    (set! (-> s5-2 velocity quad) (-> v1-12 quad))
    )
  0
  (crimson-guard-method-220 obj)
  (set! (-> obj move-position quad) (-> obj target-pos quad))
  (go (method-of-object obj hostile))
  (none)
  )

(defmethod enemy-method-89 crimson-guard ((obj crimson-guard) (arg0 enemy-jump-info))
  #f
  )

(defmethod enemy-method-87 crimson-guard ((obj crimson-guard) (arg0 enemy-jump-info))
  (let ((a0-1 (-> obj skel root-channel 0)))
    (set! (-> a0-1 param 0) 1.0)
    (joint-control-channel-group! a0-1 (the-as art-joint-anim #f) num-func-loop!)
    )
  (ja-channel-push! 1 (seconds 0.1))
  (let ((s4-0 (-> obj skel root-channel 0)))
    (set! (-> s4-0 frame-group) (the-as art-joint-anim (-> obj draw art-group data 38)))
    (set! (-> s4-0 param 0) (ja-aframe 3.0 0))
    (set! (-> s4-0 param 1) (-> arg0 anim-speed))
    (set! (-> s4-0 frame-num) (ja-aframe 0.0 0))
    (joint-control-channel-group! s4-0 (the-as art-joint-anim (-> obj draw art-group data 38)) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-88 crimson-guard ((obj crimson-guard) (arg0 enemy-jump-info))
  (let ((a0-1 (-> obj skel root-channel 0)))
    (set! (-> a0-1 param 0) 1.0)
    (joint-control-channel-group! a0-1 (the-as art-joint-anim #f) num-func-loop!)
    )
  (ja-channel-push! 1 (seconds 0.01))
  (let ((s4-0 (-> obj skel root-channel 0)))
    (set! (-> s4-0 frame-group) (the-as art-joint-anim (-> obj draw art-group data 38)))
    (set! (-> s4-0 param 0) (ja-aframe 9.0 0))
    (set! (-> s4-0 param 1) (-> arg0 anim-speed))
    (set! (-> s4-0 frame-num) (ja-aframe 4.0 0))
    (joint-control-channel-group! s4-0 (the-as art-joint-anim (-> obj draw art-group data 38)) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-90 crimson-guard ((obj crimson-guard) (arg0 int) (arg1 enemy-jump-info))
  (local-vars (s5-0 symbol))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (not (enemy-method-89 obj arg1))
       )
      ((= v1-0 1)
       (set! s5-0 (ja-done? 0))
       (let ((s4-1 (-> obj skel root-channel 0)))
         (set! (-> s4-1 param 0) (ja-aframe 3.0 0))
         (set! (-> s4-1 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! s4-1 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      ((= v1-0 2)
       (enemy-method-87 obj arg1)
       #f
       )
      ((= v1-0 3)
       (set! s5-0 (ja-done? 0))
       (let ((s4-2 (-> obj skel root-channel 0)))
         (set! (-> s4-2 param 0) (ja-aframe 3.0 0))
         (set! (-> s4-2 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! s4-2 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      ((= v1-0 4)
       (not (enemy-method-88 obj arg1))
       )
      ((= v1-0 5)
       (set! s5-0 (ja-done? 0))
       (let ((s4-3 (-> obj skel root-channel 0)))
         (set! (-> s4-3 param 0) (ja-aframe 9.0 0))
         (set! (-> s4-3 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! s4-3 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      (else
        #t
        )
      )
    )
  )

(defstate exit-transport (crimson-guard)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior crimson-guard) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logior! (-> self nav flags) (nav-control-flag output-sphere-hash))
    (logclear! (-> self flags) (citizen-flag hostile))
    (nav-enemy-method-166 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self enemy-info-override run-travel-speed)))
      )
    0
    (set! (-> self already-shot) #f)
    (none)
    )
  :exit (behavior ()
    (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
    (logclear! (-> self nav flags) (nav-control-flag output-sphere-hash))
    (none)
    )
  :trans (behavior ()
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (when (not (-> self already-shot))
        (crimson-guard-method-223 self 1.0)
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (set! (-> gp-0 quad) (-> self root-override2 trans quad))
          (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat)))
                (s5-0 (new 'stack 'collide-query))
                )
            (let ((a0-3 gp-0))
              (let ((v1-8 gp-0))
                (let ((a1-4 20480.0))
                  (.mov vf7 a1-4)
                  )
                (.lvf vf5 (&-> s4-0 quad))
                (.lvf vf4 (&-> v1-8 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a0-3 quad) vf6)
              )
            (if (enemy-above-ground? self s5-0 gp-0 (collide-spec backgnd) 8192.0 81920.0 1024.0)
                (set! (-> gp-0 y) (-> s5-0 best-other-tri intersect y))
                )
            )
          )
        (when (!= (crimson-guard-method-224 self (-> self event-param-point)) 0.0)
          (let* ((v1-16 (-> self nav))
                 (a1-7 (-> self event-param-point))
                 (f0-3 (-> v1-16 extra-nav-sphere w))
                 )
            (set! (-> v1-16 extra-nav-sphere quad) (-> a1-7 quad))
            (set! (-> v1-16 extra-nav-sphere w) f0-3)
            )
          0
          (let ((v1-19 (-> self nav)))
            (set! (-> v1-19 extra-nav-sphere w) (-> self nav-radius-backup))
            )
          0
          (let ((v1-21 (-> self nav)))
            (logior! (-> v1-21 shape nav-flags) (nav-flags has-extra-sphere))
            )
          0
          (set! (-> self already-shot) #t)
          )
        (crimson-guard-method-223 self 0.0)
        )
      (none)
      )
    )
  :code (behavior ()
    (while (not (-> self already-shot))
      (suspend)
      )
    (set! (-> self state-time) (current-time))
    (ja-channel-set! 1)
    (let ((gp-0 (current-time))
          (s5-0 150)
          (f30-0 2.0)
          )
      (ja-no-eval :group! (-> self draw art-group data 6) :num! (loop! f30-0) :frame-num 0.0)
      (until (>= (- (current-time) gp-0) s5-0)
        (crimson-guard-method-223 self (* 0.006666667 (the float (- (current-time) (-> self state-time)))))
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag vulnerable))))
    (send-event self 'jump 0 (-> self event-param-point))
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (ja-post)
    (none)
    )
  )

(defmethod init-enemy-collision! crimson-guard ((obj crimson-guard))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate
                                    generic-attack
                                    lunge
                                    flop
                                    punch
                                    spin
                                    roll
                                    uppercut
                                    bonk
                                    tube
                                    vehicle
                                    flut-attack
                                    board
                                    mech-punch
                                    dark-punch
                                    dark-giant
                                    )
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 4) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 5))
      (set! (-> s4-0 prim-core collide-as) (collide-spec civilian))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak civilian enemy hit-by-others-list player-list)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid no-standon))
      (set-vector! (-> s4-0 local-sphere) 0.0 8192.0 0.0 24576.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-13 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-13 prim-core collide-as) (collide-spec civilian))
      (set! (-> v1-13 prim-core collide-with) (collide-spec backgnd jak civilian hit-by-others-list player-list))
      (set! (-> v1-13 prim-core action) (collide-action solid))
      (set-vector! (-> v1-13 local-sphere) 0.0 6144.0 0.0 6144.0)
      )
    (let ((v1-15 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec civilian))
      (set! (-> v1-15 prim-core collide-with) (collide-spec backgnd jak civilian hit-by-others-list player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid no-standon))
      (set-vector! (-> v1-15 local-sphere) 0.0 9830.4 0.0 6144.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec civilian))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak civilian enemy hit-by-others-list player-list))
      (set! (-> v1-17 transform-index) 14)
      (set-vector! (-> v1-17 local-sphere) 0.0 0.0 2048.0 4096.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec civilian))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak civilian enemy hit-by-others-list player-list))
      (set! (-> v1-19 transform-index) 14)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 -12288.0 6144.0)
      )
    (set! (-> s5-0 nav-radius) 6144.0)
    (let ((v1-21 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-21 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-21 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 3))
    (set! (-> obj root-override2) s5-0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch process-drawable vs crimson-guard.
(defmethod relocate crimson-guard ((obj crimson-guard) (arg0 int))
  (if (nonzero? (-> obj joint))
      (&+! (-> obj joint) arg0)
      )
  (if (nonzero? (-> obj l-control))
      (&+! (-> obj l-control) arg0)
      )
  (the-as
    crimson-guard
    ((the-as (function process-drawable int process-drawable) (find-parent-method crimson-guard 7)) obj arg0)
    )
  )

(defmethod init-enemy! crimson-guard ((obj crimson-guard))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-crimson-guard" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> obj joint) (new 'process 'joint-mod (joint-mod-mode joint-set*-world) obj 4))
  (set! (-> obj info) *crimson-guard-global-info*)
  (init-enemy-behaviour-and-stats! obj *crimson-guard-nav-enemy-info*)
  (let ((v1-7 (-> obj nav)))
    (set! (-> v1-7 speed-scale) 1.0)
    )
  0
  (set! (-> obj draw lod-set lod 0 dist) 143360.0)
  (set! (-> obj draw lod-set lod 1 dist) 491520.0)
  (set! (-> obj anim-shuffle) 5)
  (set! (-> obj anim-walk) 5)
  (set! (-> obj speed-walk) 12288.0)
  (set! (-> obj dist-walk-anim) 12288.0)
  (set! (-> obj dist-run-anim) 34078.72)
  (set! (-> obj anim-run) 6)
  (set! (-> obj speed-run) 49152.0)
  (set! (-> obj anim-get-up-front) 33)
  (set! (-> obj anim-get-up-back) 34)
  (set! (-> obj l-control) (new 'process 'lightning-control (-> *lightning-spec-id-table* 13) obj 0.0))
  (set! (-> obj l-control state points-to-draw) 0)
  (set! (-> obj water-anim) -1)
  (set! (-> obj minimap) #f)
  0
  (none)
  )

(defmethod crimson-guard-method-225 crimson-guard ((obj crimson-guard) (arg0 uint) (arg1 symbol))
  (set! (-> obj guard-type) arg0)
  (set! (-> obj settings)
        (get-traffic-guard-type-settings (-> obj controller traffic) (the-as int (-> obj guard-type)))
        )
  (setup-masks (-> obj draw) 0 30)
  (cond
    ((zero? (-> obj guard-type))
     (setup-masks (-> obj draw) 16 0)
     (set! (-> obj root-override2 nav-radius) 8192.0)
     )
    (else
      (setup-masks (-> obj draw) 8 0)
      (set! (-> obj root-override2 nav-radius) 6144.0)
      )
    )
  (cond
    ((and (not arg1) (logtest? (-> obj flags) (citizen-flag dark-guard)))
     (setup-masks (-> obj draw) 5 0)
     (set-vector! (-> obj root-override2 scale) 1.1 1.1 1.1 1.0)
     (set-vector! (-> obj joint scale) 1.1 1.0 1.1 1.0)
     (let* ((a0-16 (-> obj neck))
            (t9-5 (method-of-object a0-16 trs-set!))
            (a1-6 #f)
            (a2-5 #f)
            (a3-0 (new 'stack-no-clear 'vector))
            )
       (set! (-> a3-0 x) 0.9090909)
       (set! (-> a3-0 y) 1.0)
       (set! (-> a3-0 z) 0.9090909)
       (set! (-> a3-0 w) 1.0)
       (t9-5 a0-16 (the-as vector a1-6) (the-as quaternion a2-5) a3-0)
       )
     (mode-set! (-> obj neck) (joint-mod-mode rotate2))
     (set! (-> obj joint parented-scale?) #t)
     (set! (-> obj neck parented-scale?) #t)
     )
    (else
      (setup-masks (-> obj draw) 3 0)
      (set-vector! (-> obj root-override2 scale) 1.0 1.0 1.0 1.0)
      (set-vector! (-> obj joint scale) 1.0 1.0 1.0 1.0)
      (let* ((a0-29 (-> obj neck))
             (t9-8 (method-of-object a0-29 trs-set!))
             (a1-9 #f)
             (a2-7 #f)
             (a3-1 (new 'stack-no-clear 'vector))
             )
        (set! (-> a3-1 x) 1.0)
        (set! (-> a3-1 y) 1.0)
        (set! (-> a3-1 z) 1.0)
        (set! (-> a3-1 w) 1.0)
        (t9-8 a0-29 (the-as vector a1-9) (the-as quaternion a2-7) a3-1)
        )
      (mode-set! (-> obj neck) (joint-mod-mode reset))
      )
    )
  0
  (none)
  )

(defmethod citizen-init! crimson-guard ((obj crimson-guard))
  "Initialize [[citizen]] defaults."
  (let ((t9-0 (method-of-type citizen citizen-init!)))
    (t9-0 obj)
    )
  (if (logtest? (-> obj flags) (citizen-flag dark-guard))
      (set! (-> obj hit-points) (the int (* 2.0 (the float (-> obj enemy-info-override default-hit-points)))))
      )
  (set! (-> obj hit-face) (the-as uint -1))
  (crimson-guard-method-225 obj (get-guard-type-for-traffic-obj (-> obj controller traffic) 6) #f)
  (let ((v1-12 (-> obj nav)))
    (set! (-> v1-12 sphere-mask) (the-as uint #x800de))
    )
  0
  (set! (-> obj joint-enable) #f)
  (logclear! (-> obj mask) (process-mask enemy))
  (set! (-> obj mask) (logior (process-mask guard) (-> obj mask)))
  (set! (-> obj fact-info-override pickup-type) (pickup-type ammo-random))
  (set! (-> obj fact-info-override pickup-amount) 10.0)
  (set! (-> obj fact-info-override pickup-spawn-amount) 1.0)
  (set! (-> obj traffic-target-status handle) (the-as handle #f))
  (let ((v1-24 (get-rand-int obj 2)))
    (cond
      ((zero? v1-24)
       (set! (-> obj anim-shoot 0 anim-index) 19)
       (set! (-> obj anim-shoot 0 start) 1.0)
       (set! (-> obj anim-shoot 0 end) 12.0)
       (set! (-> obj anim-shoot 1 anim-index) 26)
       (set! (-> obj anim-shoot 1 start) 12.0)
       (set! (-> obj anim-shoot 1 end) 22.0)
       (set! (-> obj anim-shoot 2 anim-index) 24)
       (set! (-> obj anim-shoot 2 start) 20.0)
       (set! (-> obj anim-shoot 2 end) 30.0)
       )
      ((= v1-24 1)
       (set! (-> obj anim-shoot 0 anim-index) 27)
       (set! (-> obj anim-shoot 0 start) 2.0)
       (set! (-> obj anim-shoot 0 end) 9.0)
       (set! (-> obj anim-shoot 1 anim-index) 29)
       (set! (-> obj anim-shoot 1 start) 18.0)
       (set! (-> obj anim-shoot 1 end) 26.0)
       (set! (-> obj anim-shoot 2 anim-index) 30)
       (set! (-> obj anim-shoot 2 start) 26.0)
       (set! (-> obj anim-shoot 2 end) 35.0)
       )
      )
    )
  (set-vector! (-> obj draw color-mult) 1.0 1.0 1.0 1.0)
  (if (logtest? (-> obj controller traffic alert-state flags) (traffic-alert-flag target-jak))
      (reset-to-collide-spec
        (-> obj focus)
        (collide-spec jak enemy hit-by-others-list player-list bot-targetable jak-vehicle)
        )
      (reset-to-collide-spec (-> obj focus) (collide-spec enemy hit-by-others-list bot-targetable))
      )
  (if (not (-> obj minimap))
      (set! (-> obj minimap) (add-icon! *minimap* obj (the-as uint 32) (the-as int #f) (the-as vector #t) 0))
      )
  (set! (-> obj move-index) -1)
  (ja-channel-set! 0)
  0
  (none)
  )
