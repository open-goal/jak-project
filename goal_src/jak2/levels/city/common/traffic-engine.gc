;;-*-Lisp-*-
(in-package goal)

;; name: traffic-engine.gc
;; name in dgo: traffic-engine
;; dgos: CWI
(declare-type crimson-guard citizen)
;; DECOMP BEGINS

(define *traffic-suppress-activation* #f)

(define *mysql-nav-graph* (the-as mysql-nav-graph #f))

(define *traffic-rigid-body-queue* (new 'static 'rigid-body-queue))

(defun get-level-nav-graph-by-id ((arg0 int))
  "Get the nav-graph with the given ID from any of the currently loaded levels"
  (dotimes (v1-0 (-> *level* length))
    (let ((a1-3 (-> *level* level v1-0)))
      (when (= (-> a1-3 status) 'active)
        (when (and (!= (-> a1-3 bsp city-level-info) 0) (!= (-> a1-3 bsp city-level-info nav-graph) 0))
          (let ((a1-6 (-> a1-3 bsp city-level-info nav-graph)))
            (if (and (!= a1-6 0) (= (-> a1-6 id) arg0))
                (return a1-6)
                )
            )
          )
        )
      )
    )
  (the-as nav-graph #f)
  )

(defun-debug add-debug-line-arrow ()
  "Does nothing!"
  0
  (none)
  )

(defmethod debug-draw vis-cell ((obj vis-cell))
  (dotimes (s5-0 (-> obj segment-count))
    (let ((s4-0 (-> obj segment-array s5-0)))
      (add-debug-line
        #t
        (bucket-id debug2)
        (the-as vector (-> s4-0 vertex))
        (-> s4-0 vertex 1)
        *color-gray*
        #f
        (the-as rgba -1)
        )
      (add-debug-x #t (bucket-id debug2) (-> s4-0 vertex 1) *color-red*)
      )
    )
  0
  (none)
  )

(defmethod reset-segment-counts vis-cell ((obj vis-cell))
  (set! (-> obj incoming-segment-count) 0)
  (set! (-> obj segment-count) 0)
  0
  (none)
  )

(defmethod setup-grid-from-bounding-box grid-info ((obj grid-info) (arg0 (pointer bounding-box)) (arg1 int) (arg2 int))
  "Set up a grid which fills the given bounding box"
  (mem-copy! (the-as pointer (-> obj box)) arg0 32)
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (dotimes (a0-2 3)
      (set! (-> v1-0 data a0-2) (- (-> obj box max data a0-2) (-> obj box min data a0-2)))
      )
    (let ((f0-5 (sqrtf (/ (the float arg1) (* (-> v1-0 x) (-> v1-0 z) (the float arg2))))))
      (let ((a0-6 (min 126 (+ arg1 -1))))
        (set! (-> obj dimension-array 0) (max 1 (min (the int (* f0-5 (-> v1-0 x))) a0-6)))
        (set! (-> obj dimension-array 1) arg2)
        (set! (-> obj dimension-array 2) (max 1 (min (the int (* f0-5 (-> v1-0 z))) a0-6)))
        )
      (let* ((f1-11 (* f0-5 (-> v1-0 z)))
             (f1-13 (- f1-11 (the float (the int f1-11))))
             (f0-6 (* f0-5 (-> v1-0 x)))
             )
        (cond
          ((< f1-13 (- f0-6 (the float (the int f0-6))))
           (if (>= arg1 (* (* (+ (-> obj dimension-array 0) 1) (-> obj dimension-array 1)) (-> obj dimension-array 2)))
               (+! (-> obj dimension-array 0) 1)
               )
           )
          (else
            (if (>= arg1 (* (* (-> obj dimension-array 0) (-> obj dimension-array 1)) (+ (-> obj dimension-array 2) 1)))
                (+! (-> obj dimension-array 2) 1)
                )
            )
          )
        )
      )
    (dotimes (a0-24 3)
      (set! (-> obj axis-scale a0-24) (/ (the float (-> obj dimension-array a0-24)) (-> v1-0 data a0-24)))
      (set! (-> obj cell-size data a0-24) (/ (-> v1-0 data a0-24) (the float (-> obj dimension-array a0-24))))
      )
    )
  0
  (none)
  )

(defmethod lookup-cell-for-point grid-info ((obj grid-info) (arg0 vis-grid-pos) (arg1 vector))
  "Get the grid cell containing the point (or closest, if outside the grid)"
  (set! (-> arg0 x)
        (max
          0
          (min (the int (* (- (-> arg1 x) (-> obj box min x)) (-> obj axis-scale 0))) (+ (-> obj dimension-array 0) -1))
          )
        )
  (set! (-> arg0 y)
        (max
          0
          (min (the int (* (- (-> arg1 y) (-> obj box min y)) (-> obj axis-scale 1))) (+ (-> obj dimension-array 1) -1))
          )
        )
  (set! (-> arg0 z)
        (max
          0
          (min (the int (* (- (-> arg1 z) (-> obj box min z)) (-> obj axis-scale 2))) (+ (-> obj dimension-array 2) -1))
          )
        )
  0
  (none)
  )

(defmethod lookup-box-for-sphere grid-info ((obj grid-info) (arg0 vis-grid-box) (arg1 vector))
  "Get the box of cells containing the given sphere"
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
      (let ((a0-1 (-> s5-0 min)))
        (let ((v1-0 arg1))
          (let ((a1-1 (- (-> arg1 w))))
            (.mov vf6 a1-1)
            )
          (.lvf vf4 (&-> v1-0 quad))
          )
        (.add.x.vf vf5 vf0 vf0 :mask #b1000)
        (.add.x.vf vf5 vf4 vf6 :mask #b111)
        (.svf (&-> a0-1 quad) vf5)
        )
      (let ((a0-2 (-> s5-0 max)))
        (let ((v1-1 arg1))
          (let ((a1-2 (-> arg1 w)))
            (.mov vf6 a1-2)
            )
          (.lvf vf4 (&-> v1-1 quad))
          )
        (.add.x.vf vf5 vf0 vf0 :mask #b1000)
        (.add.x.vf vf5 vf4 vf6 :mask #b111)
        (.svf (&-> a0-2 quad) vf5)
        )
      (lookup-cell-for-point obj (-> arg0 min) (-> s5-0 min))
      (lookup-cell-for-point obj (-> arg0 max) (-> s5-0 max))
      )
    0
    (none)
    )
  )

(defmethod debug-draw-cell grid-info ((obj grid-info) (arg0 vis-grid-pos) (arg1 rgba))
  (let ((v1-0 (new 'stack-no-clear 'bounding-box)))
    (dotimes (a3-0 3)
      (set! (-> v1-0 min data a3-0)
            (+ (-> obj box min data a3-0) (* (the float (-> arg0 data a3-0)) (-> obj cell-size data a3-0)))
            )
      )
    (vector+! (-> v1-0 max) (-> v1-0 min) (-> obj cell-size))
    (add-debug-box #t (bucket-id debug2) (-> v1-0 min) (-> v1-0 max) arg1)
    )
  0
  (none)
  )

(defmethod debug-draw-grid grid-info ((obj grid-info) (arg0 rgba))
  (draw-grid (the-as vector (-> obj box)) (-> obj box max) (-> obj dimension-array) arg0)
  0
  (none)
  )

(defmethod try-creating-new-suppression-box traffic-suppression-params ((obj traffic-suppression-params))
  "Try getting new suppression box, return if it succeeded. ID is stored in the params."
  (cond
    ((= (-> obj id) -1)
     (send-event *traffic-manager* 'new-suppression-box obj)
     (!= (-> obj id) -1)
     )
    (else
      #t
      )
    )
  )

(defmethod create-or-update-suppression-box traffic-suppression-params ((obj traffic-suppression-params))
  "If the params are already associated with a box, update. Otherwise, attempt to create a new one."
  (cond
    ((= (-> obj id) -1)
     (send-event *traffic-manager* 'new-suppression-box obj)
     (!= (-> obj id) -1)
     )
    (else
      (send-event *traffic-manager* 'update-suppression-box obj)
      #t
      )
    )
  )

(defmethod kill-suppression-box traffic-suppression-params ((obj traffic-suppression-params))
  "Kill a suppression box, and inform the traffic manager by setting duration to 0."
  (when (!= (-> obj id) -1)
    (let ((s5-0 (-> obj duration)))
      (set! (-> obj duration) 0)
      (send-event *traffic-manager* 'update-suppression-box obj)
      (set! (-> obj duration) s5-0)
      )
    (set! (-> obj id) -1)
    )
  (none)
  )

(defmethod reset-boxes traffic-suppressor ((obj traffic-suppressor))
  "Clears some flags, mark all boxes as disabled."
  (logclear! (-> obj flags) (traffic-suppression-flags tfs0 needs-update))
  (dotimes (v1-2 16)
    (let ((a1-3 (-> obj array v1-2)))
      (logclear! (-> a1-3 flags) (traffic-suppression-box-flags in-use tfsb1))
      )
    )
  0
  (none)
  )

(defmethod add-new-supression-box traffic-suppressor ((obj traffic-suppressor) (arg0 traffic-suppression-params))
  "Create a suppression box for these params.
The param object is updated with the ID of the box and can be later used with update-box-from-params."
  (set! (-> arg0 id) -1)
  (let ((v1-1 0))
    (b! #t cfg-4 :delay (nop!))
    (label cfg-1)
    (let ((a2-2 (-> obj array v1-1)))
      (b! (logtest? (-> a2-2 flags) (traffic-suppression-box-flags in-use)) cfg-3 :delay (empty-form))
      (set! (-> arg0 id) v1-1)
      (set! (-> a2-2 flags) (traffic-suppression-box-flags in-use))
      )
    (update-box-from-params obj arg0)
    (b! #t cfg-6 :delay (nop!))
    (label cfg-3)
    (+! v1-1 1)
    (label cfg-4)
    (b! (< v1-1 16) cfg-1)
    )
  (label cfg-6)
  0
  (none)
  )

(defmethod remove-box-by-id traffic-suppressor ((obj traffic-suppressor) (arg0 int))
  "Remove a box that was previously added, by its ID."
  (when (!= arg0 -1)
    (logior! (-> obj flags) (traffic-suppression-flags needs-update))
    (let ((v1-6 (-> obj array arg0)))
      (logclear! (-> v1-6 flags) (traffic-suppression-box-flags in-use))
      )
    )
  0
  (none)
  )

(defmethod update-box-from-params traffic-suppressor ((obj traffic-suppressor) (arg0 traffic-suppression-params))
  "Update a box that was previously added"
  (let ((v1-0 (-> arg0 id)))
    (when (!= v1-0 -1)
      (logior! (-> obj flags) (traffic-suppression-flags needs-update))
      (let* ((s5-0 (-> obj array v1-0))
             (s4-1 (logior (-> s5-0 flags) (traffic-suppression-box-flags tfsb1)))
             )
        (mem-copy! (the-as pointer (-> s5-0 bbox)) (the-as pointer (-> arg0 bbox)) 32)
        (set! (-> s5-0 duration) (the-as uint (-> arg0 duration)))
        (set! (-> s5-0 flags) s4-1)
        )
      )
    )
  0
  (none)
  )

(defmethod debug-draw traffic-suppressor ((obj traffic-suppressor))
  (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
    (new 'stack-no-clear 'vector4w)
    (let ((s4-0 *color-red*))
      (dotimes (s3-0 16)
        (let ((v1-3 (-> obj array s3-0)))
          (when (logtest? (-> v1-3 flags) (traffic-suppression-box-flags in-use))
            (set! (-> s5-0 min quad) (-> v1-3 bbox min quad))
            (set! (-> s5-0 max quad) (-> v1-3 bbox max quad))
            (set! (-> s5-0 min w) 1.0)
            (set! (-> s5-0 max w) 1.0)
            (add-debug-box #t (bucket-id debug-no-zbuf1) (-> s5-0 min) (-> s5-0 max) s4-0)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod for-all-active-processes traffic-tracker ((obj traffic-tracker) (arg0 (function process-focusable traffic-object-type-info none)))
  "Call the given function on all active processes."
  (let ((s4-0 (-> obj traffic)))
    (countdown (s3-0 (-> obj active-object-count))
      (let ((a1-1 (-> s4-0 object-type-info-array (-> obj active-object-type-list s3-0)))
            (a0-2 (handle->process (-> obj active-object-list s3-0)))
            )
        (if (not (focus-test? (the-as process-focusable a0-2) inactive))
            (arg0 (the-as process-focusable a0-2) a1-1)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod for-all-active-processes-of-type traffic-tracker ((obj traffic-tracker) (arg0 traffic-type) (arg1 (function process-focusable traffic-object-type-info none)))
  "Call the given function on all active processes matching the given type."
  (let ((s3-0 (-> obj traffic)))
    (countdown (s2-0 (-> obj active-object-count))
      (let ((a0-1 (-> obj active-object-type-list s2-0)))
        (when (= a0-1 arg0)
          (let ((a1-1 (-> s3-0 object-type-info-array a0-1))
                (a0-3 (handle->process (-> obj active-object-list s2-0)))
                )
            (if (not (focus-test? (the-as process-focusable a0-3) inactive))
                (arg1 (the-as process-focusable a0-3) a1-1)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod add-active-process traffic-tracker ((obj traffic-tracker) (arg0 traffic-type) (arg1 handle))
  "Add a process as active."
  (let ((v1-0 (-> obj active-object-count)))
    (when (< v1-0 (the-as uint 126))
      (set! (-> obj active-object-list v1-0) arg1)
      (set! (-> obj active-object-type-list v1-0) arg0)
      (+! (-> obj active-object-count) 1)
      (let ((v1-6 (-> obj traffic object-type-info-array arg0)))
        (+! (-> v1-6 active-count) 1)
        )
      )
    )
  0
  (none)
  )

(defmethod remove-active-process traffic-tracker ((obj traffic-tracker) (arg0 int))
  "Remove a process from the tracking list."
  (let ((v0-0 (-> obj active-object-list arg0)))
    (let ((v1-3 (-> obj active-object-type-list arg0))
          (a2-1 (+ (-> obj active-object-count) -1))
          )
      (when (>= a2-1 0)
        (set! (-> obj active-object-list arg0) (-> obj active-object-list a2-1))
        (set! (-> obj active-object-type-list arg0) (-> obj active-object-type-list a2-1))
        (+! (-> obj active-object-count) -1)
        (let ((v1-6 (-> obj traffic object-type-info-array v1-3)))
          (+! (-> v1-6 active-count) -1)
          )
        )
      )
    v0-0
    )
  )

(defmethod add-reserved-process traffic-tracker ((obj traffic-tracker) (arg0 traffic-type) (arg1 handle))
  "Add a process to the reserve list for a type. This process is allocated, but not yet activated."
  (let* ((v1-2 (-> obj traffic object-type-info-array arg0))
         (a1-2 (-> v1-2 inactive-count))
         )
    (when (< a1-2 20)
      (set! (-> v1-2 array a1-2) arg1)
      (+! (-> v1-2 inactive-count) 1)
      (+! (-> v1-2 reserve-count) 1)
      (+! (-> obj inactive-object-count) 1)
      )
    )
  0
  (none)
  )

(defmethod get-from-inactive-by-type traffic-tracker ((obj traffic-tracker) (arg0 traffic-type))
  "Get any handle from the inactive list of this type, and remove it from the list."
  (let ((v1-2 (-> obj traffic object-type-info-array arg0))
        (a1-2 0)
        (v0-0 (the-as handle #f))
        )
    (let ((a2-1 (+ (-> v1-2 inactive-count) -1)))
      (when (>= a2-1 0)
        (set! v0-0 (-> v1-2 array a1-2))
        (set! (-> v1-2 array a1-2) (-> v1-2 array a2-1))
        (+! (-> v1-2 inactive-count) -1)
        (+! (-> v1-2 reserve-count) -1)
        (+! (-> obj inactive-object-count) -1)
        )
      )
    v0-0
    )
  )

(defmethod get-from-inactive-by-handle traffic-tracker ((obj traffic-tracker) (arg0 traffic-type) (arg1 handle))
  "Remove the given handle from the inactive list of the given type."
  (let ((v1-2 (-> obj traffic object-type-info-array arg0))
        (v0-0 (the-as handle #f))
        )
    (let* ((a3-0 (+ (-> v1-2 inactive-count) -1))
           (a1-3 a3-0)
           )
      (while (and (>= a1-3 0) (!= (-> v1-2 array a1-3) arg1))
        (+! a1-3 -1)
        )
      (when (>= a1-3 0)
        (set! v0-0 (-> v1-2 array a1-3))
        (set! (-> v1-2 array a1-3) (-> v1-2 array a3-0))
        (+! (-> v1-2 inactive-count) -1)
        (+! (-> obj inactive-object-count) -1)
        )
      )
    v0-0
    )
  )

(defmethod deactivate-object traffic-tracker ((obj traffic-tracker) (arg0 int) (arg1 symbol))
  "Send a traffic-off event (or traffic-off-force) to deactivate an object, specified by index in active object array.
Process is recycled and moved to reserved, if it deactivates."
  (with-pp
    (let* ((s3-0 (-> obj active-object-type-list arg0))
           (gp-0 'traffic-off)
           (s2-0 (remove-active-process obj arg0))
           (s1-0 (handle->process s2-0))
           (v1-5 (the-as object #t))
           )
      (when s1-0
        (when (not (focus-test? (the-as process-focusable s1-0) inactive))
          (if arg1
              (set! gp-0 'traffic-off-force)
              )
          (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-2 from) (process->ppointer pp))
            (set! (-> a1-2 num-params) 0)
            (set! (-> a1-2 message) gp-0)
            (set! v1-5 (send-event-function s1-0 a1-2))
            )
          )
        (cond
          (v1-5
            (add-reserved-process obj s3-0 s2-0)
            )
          (else
            (add-active-process obj s3-0 s2-0)
            (when *debug-segment*
              (when arg1
                (format 0 "traffic-engine::deactivate-object: ~s event refused~%" gp-0)
                (format 0 "obj ~s~%" s1-0)
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod set-process-to-killed traffic-tracker ((obj traffic-tracker) (arg0 process))
  "Move from active to killed. Separate from reserve."
  (let ((v1-0 -1))
    (let ((a0-1 (process->ppointer arg0)))
      (b! (not a0-1) cfg-4 :delay (nop!))
      (let ((a1-3 (new 'static 'handle :pid (-> a0-1 0 pid))))
        (b! #t cfg-5 :delay (nop!))
        (label cfg-4)
        (set! a1-3 (new 'static 'handle))
        (label cfg-5)
        (let ((a0-3 (logior a1-3 (new 'static 'handle :process a0-1)))
              (a1-4 (-> obj active-object-count))
              )
          (b! #t cfg-8 :delay (nop!))
          (label cfg-6)
          (+! a1-4 -1)
          (b! (!= (-> obj active-object-list a1-4) a0-3) cfg-8 :delay (empty-form))
          (set! v1-0 (the-as int a1-4))
          (b! #t cfg-10 :delay (nop!))
          (label cfg-8)
          (b! (nonzero? a1-4) cfg-6 :delay (nop!))
          )
        )
      )
    (label cfg-10)
    (when (!= v1-0 -1)
      (let ((s5-0 (-> obj active-object-type-list v1-0)))
        (let ((a2-4 (remove-active-process obj v1-0)))
          (add-reserved-process obj s5-0 a2-4)
          )
        (let ((v1-5 (-> obj traffic object-type-info-array s5-0)))
          (+! (-> v1-5 killed-count) 1)
          (+! (-> v1-5 reserve-count) -1)
          )
        )
      #t
      )
    )
  0
  (none)
  )

(defmethod deactivate-all-of-type traffic-tracker ((obj traffic-tracker) (arg0 traffic-type) (arg1 symbol))
  "Deactivate all processes of given type"
  (countdown (s3-0 (-> obj active-object-count))
    (if (= (-> obj active-object-type-list s3-0) arg0)
        (deactivate-object obj (the-as int s3-0) arg1)
        )
    )
  0
  (none)
  )

(defmethod deactivate-all traffic-tracker ((obj traffic-tracker) (arg0 symbol))
  "Deactivate all processes that are tracked"
  (countdown (s4-0 (-> obj active-object-count))
    (deactivate-object obj (the-as int s4-0) arg0)
    )
  0
  (none)
  )

(defmethod activate-from-params traffic-tracker ((obj traffic-tracker) (arg0 traffic-object-spawn-params))
  "Get a reserved process, and activate with the given params."
  (local-vars (sv-16 handle))
  (let ((gp-0 (-> arg0 object-type)))
    (set! (-> arg0 proc) #f)
    (let ((v1-2 (-> obj traffic object-type-info-array gp-0)))
      (when (and (> (-> v1-2 inactive-count) 0) (> (-> v1-2 reserve-count) 0))
        (set! sv-16 (get-from-inactive-by-type obj gp-0))
        (let ((s3-0 (handle->process sv-16)))
          (when s3-0
            (cond
              ((send-event s3-0 'traffic-activate arg0 (-> obj traffic))
               (set! (-> arg0 proc) s3-0)
               (add-active-process obj gp-0 sv-16)
               0
               )
              (else
                (add-reserved-process obj gp-0 sv-16)
                )
              )
            )
          )
        0
        )
      )
    )
  0
  (none)
  )

(defmethod activate-by-type traffic-tracker ((obj traffic-tracker) (arg0 traffic-type) (arg1 nav-segment) (arg2 float))
  "If possible, activate a process of the given type."
  (let ((v1-2 (-> obj traffic object-type-info-array arg0)))
    (when (and (> (-> v1-2 inactive-count) 0)
               (> (-> v1-2 reserve-count) 0)
               (< (-> v1-2 active-count) (-> v1-2 target-count))
               (logtest? (-> v1-2 flags) (traffic-type-flags trtflags-2))
               (logtest? (-> v1-2 flags) (traffic-type-flags trtflags-3))
               (or (not (logtest? (-> v1-2 flags) (traffic-type-flags trtflags-0)))
                   (not (logtest? (-> obj traffic alert-state flags) (traffic-alert-flag alert-ending)))
                   )
               )
      (let ((s4-0 (new 'stack-no-clear 'mystery-traffic-object-spawn-params)))
        (let ((s2-0 (-> arg1 branch)))
          (set! (-> s4-0 params object-type) arg0)
          (set! (-> s4-0 params guard-type) (-> v1-2 guard-type))
          (set! (-> s4-0 params nav-branch) s2-0)
          (let ((v1-4 s2-0))
            (set! (-> s4-0 vector 2 x) (* 1024.0 (the float (-> v1-4 speed-limit))))
            )
          (vector-! (the-as vector (-> s4-0 vector)) (-> arg1 vertex 1) (the-as vector (-> arg1 vertex)))
          (vector-normalize! (the-as vector (-> s4-0 vector)) 1.0)
          (vector+float*!
            (-> s4-0 params position)
            (the-as vector (-> arg1 vertex))
            (the-as vector (-> s4-0 vector))
            arg2
            )
          (let ((f0-6 (* (+ -0.5 (rand-vu)) (* 256.0 (the float (-> s2-0 width))))))
            (+! (-> s4-0 params position x) (* -1.0 (-> s4-0 vector 0 z) f0-6))
            (+! (-> s4-0 params position z) (* (-> s4-0 vector 0 x) f0-6))
            )
          )
        (set! (-> s4-0 vector 2 y)
              (+ (* 0.5 (-> s4-0 vector 2 x)) (* (-> obj rand) (-> obj traffic inv-density-factor) (-> arg1 spawn-spacing)))
              )
        (vector-float*! (-> s4-0 params velocity) (the-as vector (-> s4-0 vector)) (-> s4-0 vector 2 x))
        (vector-float*! (-> s4-0 vector 1) (the-as vector (-> s4-0 vector)) (-> s4-0 vector 2 y))
        (when (not (sphere-hash-method-32 (-> obj object-hash) (-> s4-0 params position) (-> s4-0 vector 1) 20480.0 -1))
          (set! (-> s4-0 params behavior) (the-as uint 2))
          (set! (-> s4-0 params nav-mesh) #f)
          (-> arg1 nav-mesh-id)
          (if (= (-> arg1 tracker-id) 1)
              (set! (-> s4-0 params nav-mesh) (get-nav-mesh (the-as actor-id (-> arg1 nav-mesh-id))))
              )
          (forward-up-nopitch->quaternion
            (-> s4-0 params rotation)
            (the-as vector (-> s4-0 vector))
            (new 'static 'vector :y 1.0 :w 1.0)
            )
          (set! (-> obj rand) (rand-vu))
          (activate-from-params obj (-> s4-0 params))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod activate-by-handle traffic-tracker ((obj traffic-tracker) (arg0 traffic-object-spawn-params))
  "Activate, using the handle in the params."
  (local-vars (sv-16 handle))
  (let ((gp-0 (-> arg0 object-type)))
    (set! (-> arg0 proc) #f)
    (when (> (-> obj traffic object-type-info-array gp-0 inactive-count) 0)
      (set! sv-16 (get-from-inactive-by-handle obj gp-0 (-> arg0 handle)))
      (let ((s3-0 (handle->process sv-16)))
        (when s3-0
          (cond
            ((send-event s3-0 'traffic-activate arg0 (-> obj traffic))
             (set! (-> arg0 proc) s3-0)
             (add-active-process obj gp-0 sv-16)
             0
             )
            (else
              (add-reserved-process obj gp-0 sv-16)
              )
            )
          )
        )
      0
      )
    )
  0
  (none)
  )

(defmethod reset traffic-level-data ((obj traffic-level-data))
  (set! (-> obj city-info) (the-as city-level-info 0))
  (set! (-> obj active-cell-count) (the-as uint 0))
  (set! (-> obj newly-active-cell-count) (the-as uint 0))
  0
  (none)
  )

(defmethod reset traffic-tracker ((obj traffic-tracker) (arg0 uint) (arg1 traffic-engine))
  (set! (-> obj traffic) arg1)
  (set! (-> obj object-hash) (-> arg1 object-hash))
  (set! (-> obj rand) 0.5)
  (set! (-> obj id) arg0)
  (set! (-> obj active-object-count) (the-as uint 0))
  (set! (-> obj inactive-object-count) 0)
  0
  (none)
  )

(defmethod reset traffic-alert-state ((obj traffic-alert-state))
  (set! (-> obj flags) (traffic-alert-flag))
  (set! (-> obj level) (the-as uint 0))
  (set! (-> obj duration) (the-as uint 9000))
  (set! (-> obj alarm-sound-id) (new-sound-id))
  (set! (-> obj guard-inaccuracy-factor) 1.0)
  (dotimes (v1-2 3)
    (let ((a0-4 (-> obj target-status-array v1-2)))
      (set! (-> a0-4 flags) (traffic-target-flag))
      (set! (-> a0-4 handle) (the-as handle #f))
      )
    )
  (set! (-> obj guard-type-info-array 0 object-type) (traffic-type crimson-guard-1))
  (set! (-> obj guard-type-info-array 1 object-type) (traffic-type crimson-guard-1))
  (set! (-> obj guard-type-info-array 2 object-type) (traffic-type crimson-guard-1))
  (set! (-> obj guard-type-info-array 3 object-type) (traffic-type crimson-guard-2))
  (set! (-> obj guard-type-info-array 4 object-type) (traffic-type guard-bike))
  (set! (-> obj guard-type-info-array 5 object-type) (traffic-type hellcat))
  (dotimes (v1-11 21)
    (set! (-> obj guard-type-mask-from-object-type v1-11) (the-as uint 0))
    )
  (dotimes (v1-14 6)
    (let ((a0-10 (-> obj guard-type-info-array v1-14 object-type)))
      (set! (-> obj guard-type-mask-from-object-type a0-10)
            (the-as uint (logior (ash 1 v1-14) (-> obj guard-type-mask-from-object-type a0-10)))
            )
      )
    )
  0
  (none)
  )

(defmethod reset-and-init-from-manager traffic-engine ((obj traffic-engine) (arg0 process))
  "Reset the traffic engine"
  (set! (-> obj manager) (process->handle arg0))
  (set! (-> obj flags) (the-as uint 0))
  (set! (-> obj danger-sphere-count) 0)
  (set! (-> *game-info* wanted-flash) #f)
  (let ((v1-4 (-> obj inactive-object-array)))
    (dotimes (a0-5 21)
      (let ((a1-3 (-> obj object-type-info-array a0-5)))
        (set! (-> a1-3 flags) (traffic-type-flags trtflags-1 trtflags-2))
        (set! (-> a1-3 inactive-count) 0)
        (set! (-> a1-3 active-count) 0)
        (set! (-> a1-3 target-count) 20)
        (set! (-> a1-3 reserve-count) (the-as uint #x7d00))
        (set! (-> a1-3 killed-count) (the-as uint 0))
        (set! (-> a1-3 array) v1-4)
        (set! (-> a1-3 level) #f)
        )
      (set! v1-4 (&-> v1-4 20))
      )
    )
  (set! (-> obj object-type-info-array 6 guard-type) (the-as uint 0))
  (set! (-> obj object-type-info-array 20 level) 'ctywide)
  (let ((v1-8 11))
    (dotimes (a0-6 10)
      (set! (-> obj object-type-info-array v1-8 tracker-index) (the-as uint 0))
      (+! v1-8 1)
      )
    )
  (let ((v1-11 0))
    (dotimes (a0-7 11)
      (set! (-> obj object-type-info-array v1-11 tracker-index) (the-as uint 1))
      (+! v1-11 1)
      )
    )
  (dotimes (s5-0 2)
    (reset (-> obj tracker-array s5-0) (the-as uint s5-0) obj)
    )
  (reset-boxes (-> obj suppressor))
  (set! (-> obj object-hash object-count) 0)
  (let* ((v1-24 (-> obj object-hash))
         (a0-15
           (/ (+ (* (* (* (-> v1-24 dimension-array 0) (-> v1-24 dimension-array 1)) (-> v1-24 dimension-array 2))
                    (-> v1-24 bucket-size)
                    )
                 15
                 )
              16
              )
           )
         (v1-25 (the-as (pointer uinteger) (-> v1-24 bucket-array)))
         )
    (while (nonzero? a0-15)
      (+! a0-15 -1)
      (set! (-> (the-as (pointer uint128) v1-25) 0) (the-as uint128 0))
      (set! v1-25 (&-> (the-as (pointer grid-hash-word) v1-25) 16))
      )
    )
  0
  (dotimes (s5-1 2)
    (reset (-> obj level-data-array s5-1))
    )
  (dotimes (s5-2 (-> *level* length))
    (let ((a1-12 (-> *level* level s5-2)))
      (if (= (-> a1-12 status) 'active)
          (level-link obj a1-12)
          )
      )
    )
  (reset (-> obj alert-state))
  0
  (none)
  )

(defmethod stop-alarm-sound traffic-engine ((obj traffic-engine))
  (sound-stop (-> obj alert-state alarm-sound-id))
  0
  (none)
  )

(defmethod level-link traffic-engine ((obj traffic-engine) (arg0 level))
  "Call after loading a level to patch the data in the bsp"
  (format #t "traffic-engine: level birth ~S~%" (-> arg0 nickname))
  (cond
    ((or (not *debug-segment*)
         (not (and (get-nav-graph-editor) (= (-> (get-nav-graph-editor) nav-graph nav_graph_id) 1)))
         )
     (when (and (nonzero? (-> arg0 bsp city-level-info)) (nonzero? (-> arg0 bsp city-level-info nav-graph)))
       (let ((s4-0 (-> arg0 bsp city-level-info)))
         (let ((v1-13 (-> arg0 bsp city-level-info nav-graph)))
           (when (not (-> v1-13 patched))
             (dotimes (a0-8 (the-as int (-> s4-0 cell-count)))
               (let ((a1-3 (-> s4-0 cell-array a0-8)))
                 (set! (-> a1-3 segment-array)
                       (the-as (inline-array nav-segment) (-> s4-0 segment-array (the-as int (the-as uint (-> a1-3 segment-array)))))
                       )
                 )
               )
             (dotimes (a0-11 (-> s4-0 segment-count))
               (let ((a1-6 (-> s4-0 segment-array a0-11)))
                 (set! (-> a1-6 branch) (-> v1-13 branch-array (the-as uint (-> a1-6 branch))))
                 )
               )
             (dotimes (a0-14 (-> v1-13 node-count))
               (let ((a1-9 (-> v1-13 node-array a0-14)))
                 (set! (-> a1-9 branch-array)
                       (the-as (inline-array nav-branch) (-> v1-13 branch-array (the-as uint (-> a1-9 branch-array))))
                       )
                 )
               )
             (dotimes (a0-17 (-> v1-13 branch-count))
               (let* ((a1-12 (-> v1-13 branch-array a0-17))
                      (t0-1 (the-as object (-> a1-12 src-node)))
                      (a2-12 (the-as object (-> a1-12 dest-node)))
                      )
                 (set! (-> a1-12 src-node) (-> v1-13 node-array (the-as uint t0-1)))
                 (cond
                   ((< #x186a0 (the-as int a2-12))
                    (let ((a2-13 (- (the-as uint #xffffffff) (the-as uint a2-12))))
                      (set! (-> a1-12 dest-node) (-> v1-13 link-array a2-13 dummy-node))
                      )
                    )
                   (else
                     (set! (-> a1-12 dest-node) (-> v1-13 node-array (the-as uint a2-12)))
                     )
                   )
                 )
               )
             (set! (-> v1-13 patched) #t)
             )
           (dotimes (a0-21 (-> v1-13 branch-count))
             (set! (-> v1-13 branch-array a0-21 user-count) (the-as uint 0))
             0
             )
           )
         (dotimes (v1-16 (the-as int (-> s4-0 cell-count)))
           (let ((a0-23 (-> s4-0 cell-array v1-16)))
             (set! (-> a0-23 flags) (vis-cell-flag))
             (set! (-> a0-23 prev-flags) (vis-cell-flag))
             )
           0
           )
         (let ((s3-0 0))
           (dotimes (s2-0 (-> s4-0 segment-count))
             (let ((s1-0 (-> s4-0 segment-array s2-0)))
               (vector-vector-distance (the-as vector (-> s1-0 vertex)) (-> s1-0 vertex 1))
               (when (< (-> s1-0 spawn-spacing) 0.0)
                 (inspect s1-0)
                 #t
                 (+! s3-0 1)
                 (set! (-> s1-0 spawn-spacing) (fabs (-> s1-0 spawn-spacing)))
                 )
               )
             )
           (format #t "birth-level ~s found ~d bad segs~%" arg0 s3-0)
           )
         )
       )
     )
    (else
      0
      )
    )
  (let ((s4-1 (the-as traffic-level-data #f)))
    (dotimes (v1-31 2)
      (let ((a0-34 (-> obj level-data-array v1-31)))
        (if (zero? (-> a0-34 city-info))
            (set! s4-1 a0-34)
            )
        )
      )
    (if (not s4-1)
        (format 0 "level-data not found~%")
        )
    (when s4-1
      (set! (-> s4-1 city-info) (-> arg0 bsp city-level-info))
      (set! (-> s4-1 active-cell-count) (the-as uint 0))
      0
      )
    )
  (dotimes (gp-1 (-> *level* length))
    (let ((v1-43 (-> *level* level gp-1)))
      (when (= (-> v1-43 status) 'active)
        (when (nonzero? (-> v1-43 bsp city-level-info))
          (let ((s5-1 (-> v1-43 bsp city-level-info nav-graph)))
            (when (and (nonzero? s5-1) (-> s5-1 patched))
              (dotimes (s4-2 (-> s5-1 link-count))
                (let ((s3-1 (-> s5-1 link-array s4-2)))
                  (when (not (-> s3-1 dest-graph))
                    (let ((s2-1 (get-level-nav-graph-by-id (the-as int (-> s3-1 dest-graph-id)))))
                      (when (and s2-1 (-> s2-1 patched))
                        (dotimes (s1-1 (-> s2-1 node-count))
                          (when (= (-> s3-1 dest-node-id) (-> s2-1 node-array s1-1 id))
                            (set! (-> s3-1 dest-graph) s2-1)
                            (set-dst-node (-> s5-1 branch-array (-> s3-1 src-branch-id)) (-> s2-1 node-array s1-1))
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod level-unlink traffic-engine ((obj traffic-engine) (arg0 level))
  "Call after removing a level. Kills processes and unlinks nav"
  (let ((s4-0 (-> arg0 bsp city-level-info nav-graph)))
    (dotimes (v1-2 2)
      (let ((a0-4 (-> obj level-data-array v1-2)))
        (when (= (-> a0-4 city-info) (-> arg0 bsp city-level-info))
          (set! (-> a0-4 city-info) (the-as city-level-info 0))
          0
          )
        )
      )
    (when (nonzero? s4-0)
      (dotimes (s3-0 (-> *level* length))
        (let ((v1-9 (-> *level* level s3-0)))
          (when (= (-> v1-9 status) 'active)
            (when (and (!= arg0 v1-9) (!= (-> v1-9 bsp city-level-info) 0))
              (let ((s2-0 (-> v1-9 bsp city-level-info nav-graph)))
                (when (nonzero? s2-0)
                  (dotimes (s1-0 (-> s2-0 link-count))
                    (let ((s0-0 (-> s2-0 link-array s1-0)))
                      (when (= (-> s0-0 dest-graph) s4-0)
                        (set! (-> s0-0 dest-graph) (get-level-nav-graph-by-id (the-as int (-> s0-0 dest-graph-id))))
                        (when (-> s0-0 dest-graph)
                          (set-dst-node (-> s2-0 branch-array (-> s0-0 src-branch-id)) (-> s0-0 dummy-node))
                          (set! (-> s0-0 dest-graph) #f)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (let ((s4-1 (-> arg0 bsp city-level-info nav-graph)))
    (dotimes (s3-1 (-> s4-1 link-count))
      (let ((s2-1 (-> s4-1 link-array s3-1)))
        (set-dst-node (-> s4-1 branch-array (-> s2-1 src-branch-id)) (-> s2-1 dummy-node))
        (set! (-> s2-1 dest-graph) #f)
        )
      )
    )
  (deactivate-all-from-level obj (-> arg0 name))
  0
  (none)
  )

(defmethod for-all-active-processes traffic-engine ((obj traffic-engine) (arg0 (function process-focusable traffic-object-type-info none)))
  (dotimes (s4-0 2)
    (for-all-active-processes (-> obj tracker-array s4-0) arg0)
    )
  0
  (none)
  )

(defmethod add-object traffic-engine ((obj traffic-engine) (arg0 traffic-type) (arg1 process))
  (add-reserved-process
    (-> obj tracker-array (-> obj object-type-info-array arg0 tracker-index))
    arg0
    (process->handle arg1)
    )
  0
  (none)
  )

(defmethod child-killed traffic-engine ((obj traffic-engine) (arg0 process))
  "handle killing a child process"
  (cond
    ((type? arg0 citizen)
     (set-process-to-killed (-> obj vehicle-tracker-array) arg0)
     )
    ((type? arg0 vehicle)
     (set-process-to-killed (-> obj citizen-tracker-array) arg0)
     )
    (else
      0
      )
    )
  0
  (none)
  )

(defmethod activate-one-citizen traffic-engine ((obj traffic-engine) (arg0 nav-segment) (arg1 float))
  (let ((a1-1 (+ (rand-vu-int-count 10) 11)))
    (activate-by-type (-> obj citizen-tracker-array) (the-as traffic-type a1-1) arg0 arg1)
    )
  0
  (none)
  )

(defmethod activate-one-vehicle traffic-engine ((obj traffic-engine) (arg0 nav-segment) (arg1 float))
  (let ((a1-1 0))
    (dotimes (v1-0 11)
      (if (zero? (-> obj object-type-info-array v1-0 inactive-count))
          (set! a1-1 (logior a1-1 (ash 1 v1-0)))
          )
      )
    (let ((a1-2 (rand-vu-int-count-excluding 11 a1-1)))
      (activate-by-type (-> obj vehicle-tracker-array) (the-as traffic-type a1-2) arg0 arg1)
      )
    )
  0
  (none)
  )

(defmethod handle-new-vis-cell traffic-engine ((obj traffic-engine) (arg0 vis-cell))
  (dotimes (s4-0 (-> arg0 segment-count))
    (let* ((s3-0 (-> arg0 segment-array s4-0))
           (s1-0 (-> s3-0 tracker-id))
           )
      (when (and (logtest? (logxor (-> arg0 flags) (the-as uint (-> arg0 prev-flags))) (ash 1 s1-0))
                 (and (not (logtest? (-> arg0 flags) (vis-cell-flag suppress)))
                      (not (or (can-dest-be-used? obj (-> s3-0 branch)) (let ((a0-7 (-> s3-0 branch)))
                                                                          (>= (-> a0-7 user-count) (-> a0-7 max-user-count))
                                                                          )
                               )
                           )
                      )
                 )
        (let* ((s2-0 (-> obj tracker-array s1-0))
               (f30-0 (* (-> s2-0 rand) (-> obj inv-density-factor) (-> s3-0 spawn-spacing)))
               )
          (cond
            ((= s1-0 1)
             (when (nonzero? (-> s3-0 nav-mesh-id))
               (while (and (< f30-0 (-> s3-0 length)) (> (-> s2-0 inactive-object-count) 0))
                 (activate-one-vehicle obj s3-0 f30-0)
                 (set! f30-0 (+ 24576.0 (* (-> s2-0 rand) (-> obj inv-density-factor) (-> s3-0 spawn-spacing)) f30-0))
                 )
               )
             )
            (else
              (while (and (< f30-0 (-> s3-0 length)) (> (-> s2-0 inactive-object-count) 0))
                (activate-one-citizen obj s3-0 f30-0)
                (set! f30-0 (+ 49152.0 (* (-> s2-0 rand) (-> obj inv-density-factor) (-> s3-0 spawn-spacing)) f30-0))
                )
              )
            )
          (if (>= f30-0 (-> s3-0 length))
              (set! (-> s2-0 rand)
                    (fmax 0.0 (- (-> s2-0 rand) (/ (-> s3-0 length) (* (-> s3-0 spawn-spacing) (-> obj inv-density-factor)))))
                    )
              )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod debug-draw traffic-level-data ((obj traffic-level-data))
  (local-vars (sv-16 nav-node) (sv-20 nav-branch) (sv-80 nav-node) (sv-84 vector) (sv-88 vector) (sv-92 vector))
  (when (and (nonzero? (-> obj city-info)) (nonzero? (-> obj city-info nav-graph)))
    (let ((s5-0 (-> obj city-info nav-graph)))
      (let ((v1-6 (-> s5-0 node-array 0)))
        (countdown (a0-3 (-> s5-0 node-count))
          (logclear! (-> v1-6 flags) (nav-node-flag-byte visited))
          (&+! v1-6 32)
          )
        )
      (dotimes (s4-0 (the-as int (-> obj active-cell-count)))
        (let ((a0-4 (-> obj active-cell-list s4-0)))
          (dotimes (v1-11 (-> a0-4 segment-count))
            (let ((a1-5 (-> a0-4 segment-array v1-11 branch src-node)))
              (logior! (-> a1-5 flags) (nav-node-flag-byte visited))
              )
            )
          (debug-draw a0-4)
          )
        )
      (set! sv-16 (-> s5-0 node-array 0))
      (countdown (gp-1 (-> s5-0 node-count))
        (when (logtest? (-> sv-16 flags) (nav-node-flag-byte visited))
          (debug-draw sv-16)
          (dotimes (s5-1 (-> sv-16 branch-count))
            (set! sv-20 (-> sv-16 branch-array s5-1))
            (set! sv-80 (-> sv-20 dest-node))
            (set! sv-84 (new 'stack-no-clear 'vector))
            (set! sv-88 (new 'stack-no-clear 'vector))
            (set! sv-92 (new 'stack-no-clear 'vector))
            (let ((a1-7 sv-16)
                  (v1-35 sv-88)
                  )
              (set! (-> v1-35 quad) (-> a1-7 position quad))
              (set! (-> v1-35 w) 1.0)
              )
            (let ((a1-10 sv-80)
                  (v1-36 sv-92)
                  )
              (set! (-> v1-36 quad) (-> a1-10 position quad))
              (set! (-> v1-36 w) 1.0)
              )
            (vector-! sv-84 sv-92 sv-88)
            (add-debug-vector #t (bucket-id debug2) sv-88 sv-84 (meters 0.00023193359) *color-light-green*)
            (vector+float*! sv-84 sv-88 sv-84 0.5)
            (let ((s4-1 add-debug-text-3d)
                  (s3-0 #t)
                  (s2-0 324)
                  )
              (format (clear *temp-string*) "~D" (-> sv-20 user-count))
              (s4-1
                s3-0
                (the-as bucket-id s2-0)
                *temp-string*
                sv-84
                (if (< (-> sv-20 user-count) (-> sv-20 max-user-count))
                    (font-color yellow)
                    (font-color red)
                    )
                (the-as vector2h #f)
                )
              )
            )
          )
        (set! sv-16 (&+ sv-16 32))
        )
      )
    )
  0
  (none)
  )

(defmethod debug-unused traffic-engine ((obj traffic-engine))
  (dotimes (v1-0 (-> *level* length))
    (let ((a0-4 (-> *level* level v1-0)))
      (when (= (-> a0-4 status) 'active)
        (when (and (!= (-> a0-4 bsp city-level-info) 0) (!= (-> a0-4 bsp city-level-info nav-graph) 0))
          )
        )
      )
    )
  (when #f
    )
  0
  (none)
  )

(defmethod sphere-in-loaded-city-infos? traffic-engine ((obj traffic-engine) (arg0 vector) (arg1 int))
  (dotimes (s3-0 2)
    (let ((v1-3 (-> obj level-data-array s3-0)))
      (when (nonzero? (-> v1-3 city-info))
        (if (sphere-in-grid? (-> v1-3 city-info) arg0 arg1)
            (return #t)
            )
        )
      )
    )
  #f
  )

(defmethod can-dest-be-used? traffic-engine ((obj traffic-engine) (arg0 nav-branch))
  (let ((v1-0 (-> arg0 src-node)))
    (or (logtest? (-> arg0 flags) (nav-branch-flags nabflags-0))
        (logtest? (-> v1-0 flags) (nav-node-flag-byte blocked))
        (not (-> arg0 dest-node))
        (>= (-> arg0 user-count) (-> arg0 max-user-count))
        )
    )
  )

(defmethod update-sync-from-frame-counter traffic-engine ((obj traffic-engine))
  (+! (-> obj sync-clock) 1)
  (set! (-> obj sync-mask-8) (the-as uint (ash 1 (logand (-> obj sync-clock) 7))))
  (set! (-> obj sync-mask-16) (the-as uint (ash 1 (logand (-> obj sync-clock) 15))))
  (set! (-> obj sync-mask-32) (the-as uint (ash 1 (logand (-> obj sync-clock) 31))))
  (let ((v1-10 (/ (current-time) 300)))
    (set! (-> obj sync-array 0) (the-as uint 255))
    (let ((a1-12 (mod v1-10 20)))
      (set! (-> obj sync-array 1) (the-as uint (cond
                                                 ((>= 6 a1-12)
                                                  1
                                                  )
                                                 ((>= 9 a1-12)
                                                  2
                                                  )
                                                 ((>= 16 a1-12)
                                                  4
                                                  )
                                                 (else
                                                   8
                                                   )
                                                 )
                                          )
            )
      )
    (let ((a1-15 (mod v1-10 30)))
      (set! (-> obj sync-array 2) (the-as uint (cond
                                                 ((>= 6 a1-15)
                                                  1
                                                  )
                                                 ((>= 9 a1-15)
                                                  2
                                                  )
                                                 ((>= 16 a1-15)
                                                  4
                                                  )
                                                 ((>= 19 a1-15)
                                                  8
                                                  )
                                                 ((>= 26 a1-15)
                                                  16
                                                  )
                                                 (else
                                                   32
                                                   )
                                                 )
                                          )
            )
      )
    (let ((v1-11 (mod v1-10 40)))
      (set! (-> obj sync-array 3) (the-as uint (cond
                                                 ((>= 6 v1-11)
                                                  1
                                                  )
                                                 ((>= 9 v1-11)
                                                  2
                                                  )
                                                 ((>= 16 v1-11)
                                                  4
                                                  )
                                                 ((>= 19 v1-11)
                                                  8
                                                  )
                                                 ((>= 26 v1-11)
                                                  16
                                                  )
                                                 ((>= 29 v1-11)
                                                  32
                                                  )
                                                 ((>= 36 v1-11)
                                                  64
                                                  )
                                                 (else
                                                   128
                                                   )
                                                 )
                                          )
            )
      )
    )
  0
  (none)
  )

(defmethod update-danger-from-target traffic-engine ((obj traffic-engine))
  "make people run away from jak when he is dangerous."
  (local-vars (v1-20 float) (v1-32 float))
  (with-pp
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((s5-0 *target*))
        (when s5-0
          (let ((v1-1 (-> obj danger-sphere-array)))
            (set! (-> v1-1 0 handle) (process->handle s5-0))
            (let ((a0-4 (-> s5-0 focus-status))
                  (notify-radius 0.0)
                  (danger-radius 0.0)
                  (decay-rate 1.0)
                  (danger-level 0.0)
                  )
              (cond
                ((logtest? (focus-status mech dark shooting) a0-4)
                 (set! notify-radius 245760.0)
                 (set! danger-radius 163840.0)
                 (set! danger-level 1.0)
                 (set! decay-rate 0.0)
                 )
                ((logtest? (focus-status gun) a0-4)
                 (set! notify-radius 102400.0)
                 (set! danger-radius 61440.0)
                 (set! danger-level 0.5)
                 (set! decay-rate 0.5)
                 )
                ((logtest? (focus-status board pilot) a0-4)
                 (set! notify-radius 40960.0)
                 (set! danger-radius 24576.0)
                 (set! danger-level 0.5)
                 )
                ((logtest? a0-4 (focus-status dangerous))
                 (set! notify-radius 61440.0)
                 (set! danger-radius 40960.0)
                 (set! decay-rate 0.0)
                 (set! danger-level 0.5)
                 )
                (else
                  (set! decay-rate 1.5)
                  )
                )
              (set! (-> v1-1 0 decay-rate) (* 0.1 decay-rate))
              (when (< (-> v1-1 0 danger-level) danger-level)
                (set! (-> v1-1 0 danger-level) danger-level)
                (set! (-> v1-1 0 sphere r) danger-radius)
                (set! (-> v1-1 0 notify-radius) notify-radius)
                )
              )
            (let ((f0-1 (-> v1-1 0 sphere r)))
              (set! (-> v1-1 0 sphere quad) (-> s5-0 control trans quad))
              (set! (-> v1-1 0 sphere r) f0-1)
              )
            (set! (-> v1-1 0 velocity quad) (-> s5-0 control transv quad))
            (let ((f0-3 (- (-> v1-1 0 danger-level) (* (-> v1-1 0 decay-rate) (-> pp clock seconds-per-frame)))))
              (set! (-> v1-1 0 danger-level) (fmax 0.0 f0-3))
              )
            )
          (let ((s3-0 (-> s5-0 focus-status))
                (f30-0 0.0)
                (s4-0 (new 'stack-no-clear 'inline-array 'traffic-suppression-box 2))
                )
            (set! (-> s4-0 0 bbox max quad) (-> s5-0 control transv quad))
            (vector-z-quaternion! (the-as vector (-> s4-0 1)) (get-quat s5-0 3))
            (set! (-> s4-0 1 data 16) (the-as uint 3))
            (cond
              ((logtest? (focus-status shooting) s3-0)
               (vector-float*! (the-as vector (-> s4-0 0)) (the-as vector (-> s4-0 1)) 409600.0)
               (set! f30-0 4096.0)
               (set! (-> s4-0 1 data 16) (the-as uint 0))
               0
               )
              ((and (logtest? (focus-status gun) s3-0)
                    (not (and (logtest? (focus-status pilot) s3-0) (let* ((v1-19 (-> s4-0 0 bbox max))
                                                                          (f0-6 40960.0)
                                                                          (f0-8 (* f0-6 f0-6))
                                                                          )
                                                                     (.lvf vf1 (&-> v1-19 quad))
                                                                     (.add.w.vf vf2 vf0 vf0 :mask #b1)
                                                                     (.mul.vf vf1 vf1 vf1)
                                                                     (.mul.x.vf acc vf2 vf1 :mask #b1)
                                                                     (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                                                                     (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                                                                     (.mov v1-20 vf1)
                                                                     (< f0-8 v1-20)
                                                                     )
                              )
                         )
                    )
               (vector-float*! (the-as vector (-> s4-0 0)) (the-as vector (-> s4-0 1)) 163840.0)
               (set! f30-0 8192.0)
               (set! (-> s4-0 1 data 16) (the-as uint 1))
               )
              ((logtest? (focus-status dangerous board pilot) s3-0)
               (vector-float*! (the-as vector (-> s4-0 0)) (-> s4-0 0 bbox max) 2.0)
               (let* ((v1-31 (-> s4-0 0))
                      (f0-11 20480.0)
                      (f0-13 (* f0-11 f0-11))
                      )
                 (.lvf vf1 (&-> v1-31 bbox min quad))
                 (.add.w.vf vf2 vf0 vf0 :mask #b1)
                 (.mul.vf vf1 vf1 vf1)
                 (.mul.x.vf acc vf2 vf1 :mask #b1)
                 (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                 (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                 (.mov v1-32 vf1)
                 (if (< f0-13 v1-32)
                     (set! f30-0 20480.0)
                     )
                 )
               (set! (-> s4-0 1 data 16) (the-as uint (cond
                                                        ((logtest? (focus-status pilot) s3-0)
                                                         3
                                                         )
                                                        ((logtest? (focus-status board) s3-0)
                                                         2
                                                         )
                                                        ((logtest? s3-0 (focus-status dangerous))
                                                         4
                                                         )
                                                        (else
                                                          5
                                                          )
                                                        )
                                                 )
                     )
               )
              )
            (when (< 0.0 f30-0)
              (let ((s3-1 (new 'stack-no-clear 'array 'collide-shape 40))
                    (s2-1 (new 'stack 'traffic-danger-info))
                    )
                (set! (-> s2-1 sphere quad) (-> s5-0 control trans quad))
                (set! (-> s2-1 danger-type) (the-as traffic-danger-type (-> s4-0 1 data 16)))
                (set! (-> s2-1 sphere r) f30-0)
                (set! (-> s2-1 velocity quad) (-> s4-0 0 bbox min quad))
                (let ((gp-1 (fill-actor-list-for-line-sphere
                              (-> obj object-hash)
                              (-> s2-1 sphere)
                              (-> s2-1 velocity)
                              (-> s2-1 sphere r)
                              s3-1
                              40
                              -1
                              )
                            )
                      )
                  (dotimes (s5-1 gp-1)
                    (let* ((s4-1 (-> s3-1 s5-1))
                           (a0-52 (if (type? s4-1 citizen)
                                      s4-1
                                      )
                                  )
                           )
                      (if a0-52
                          (send-event (the-as process-tree a0-52) 'clear-path s2-1)
                          )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      0
      (none)
      )
    )
  )

(defmethod update-danger traffic-engine ((obj traffic-engine))
  "see what's dangerous and make people avoid it."
  (update-danger-from-target obj)
  (dotimes (s5-0 (-> obj danger-sphere-count))
    (let ((s4-0 (-> obj danger-sphere-array s5-0)))
      (when (< 0.0 (-> s4-0 danger-level))
        (let ((s3-0 (new 'stack-no-clear 'array 'collide-shape 40))
              (a1-0 (new 'stack-no-clear 'sphere))
              )
          (set! (-> a1-0 quad) (-> s4-0 sphere quad))
          (set! (-> a1-0 r) (-> s4-0 notify-radius))
          (let ((s2-0 (fill-actor-list-for-sphere (-> obj object-hash) a1-0 s3-0 40)))
            (dotimes (s1-0 s2-0)
              (let* ((s0-0 (-> s3-0 s1-0))
                     (a0-6 (if (type? s0-0 citizen)
                               s0-0
                               )
                           )
                     )
                (if a0-6
                    (send-event
                      (the-as process-tree a0-6)
                      (if (< 0.5 (-> s4-0 danger-level))
                          'panic
                          'avoid
                          )
                      s4-0
                      )
                    )
                )
              )
            )
          )
        )
      )
    )
  (set! (-> obj danger-sphere-count) 1)
  0
  (none)
  )

(defmethod add-danger traffic-engine ((obj traffic-engine) (arg0 traffic-danger-info))
  "Add a danger sphere and suppression box."
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (new 'stack-no-clear 'traffic-suppression-params)))
      (let ((a0-1 (-> a1-1 bbox)))
        (let ((v1-0 (-> arg0 sphere)))
          (let ((a2-0 (- (-> arg0 notify-radius))))
            (.mov vf6 a2-0)
            )
          (.lvf vf4 (&-> v1-0 quad))
          )
        (.add.x.vf vf5 vf0 vf0 :mask #b1000)
        (.add.x.vf vf5 vf4 vf6 :mask #b111)
        (.svf (&-> a0-1 min quad) vf5)
        )
      (let ((a0-2 (-> a1-1 bbox max)))
        (let ((v1-1 (-> arg0 sphere)))
          (let ((a2-1 (-> arg0 notify-radius)))
            (.mov vf6 a2-1)
            )
          (.lvf vf4 (&-> v1-1 quad))
          )
        (.add.x.vf vf5 vf0 vf0 :mask #b1000)
        (.add.x.vf vf5 vf4 vf6 :mask #b111)
        (.svf (&-> a0-2 quad) vf5)
        )
      (set! (-> a1-1 duration) (seconds 5))
      (new-suppression-box obj a1-1)
      )
    (let ((v1-5 (-> obj danger-sphere-count)))
      (when (< v1-5 4)
        (let ((a0-5 (-> obj danger-sphere-array v1-5)))
          (mem-copy! (the-as pointer a0-5) (the-as pointer arg0) 54)
          )
        (+! (-> obj danger-sphere-count) 1)
        )
      )
    0
    (none)
    )
  )

(defmethod kill-traffic-sphere traffic-engine ((obj traffic-engine) (arg0 sphere))
  "Kill everything in the sphere with a traffic-off-force."
  (let ((gp-0 (new 'stack-no-clear 'array 'collide-shape 64)))
    (countdown (s5-0 (fill-actor-list-for-sphere *actor-hash* arg0 gp-0 64))
      (let* ((s4-0 (-> gp-0 s5-0))
             (v1-3 (if (type? s4-0 collide-shape)
                       s4-0
                       )
                   )
             )
        (if v1-3
            (send-event (-> v1-3 process) 'traffic-off-force)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod update-traffic-amount traffic-engine ((obj traffic-engine))
  "kills inactive traffic and spawns more if needed."
  (local-vars (sv-48 int) (sv-64 nav-segment))
  (set! (-> obj object-hash object-count) 0)
  (let* ((v1-1 (-> obj object-hash))
         (a0-6 (/ (+ (* (* (* (-> v1-1 dimension-array 0) (-> v1-1 dimension-array 1)) (-> v1-1 dimension-array 2))
                        (-> v1-1 bucket-size)
                        )
                     15
                     )
                  16
                  )
               )
         (v1-2 (the-as (pointer uinteger) (-> v1-1 bucket-array)))
         )
    (while (nonzero? a0-6)
      (+! a0-6 -1)
      (set! (-> (the-as (pointer uint128) v1-2) 0) (the-as uint128 0))
      (set! v1-2 (&-> (the-as (pointer grid-hash-word) v1-2) 16))
      )
    )
  0
  (new 'stack-no-clear 'vector)
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let ((a2-0 *target*))
      (when a2-0
        (cond
          ((focus-test? a2-0 pilot)
           (when (nonzero? (-> a2-0 pilot))
             (let ((a2-1 (handle->process (-> a2-0 pilot vehicle))))
               (when a2-1
                 (set! (-> s5-0 quad) (-> (the-as process-focusable a2-1) root-override root-prim prim-core world-sphere quad))
                 (spatial-hash-method-39 (-> obj object-hash) s5-0 (the-as hash-object-info a2-1))
                 )
               )
             )
           )
          (else
            (set! (-> s5-0 quad) (-> a2-0 control trans quad))
            (set! (-> s5-0 w) 20480.0)
            (spatial-hash-method-39 (-> obj object-hash) s5-0 (the-as hash-object-info a2-0))
            )
          )
        )
      )
    (countdown (s4-0 (-> obj citizen-tracker-array active-object-count))
      (let ((s3-0 (handle->process (-> obj citizen-tracker-array active-object-list s4-0))))
        (cond
          (s3-0
            (cond
              ((focus-test? (the-as vehicle s3-0) inactive)
               (deactivate-object (-> obj citizen-tracker-array) (the-as int s4-0) #f)
               )
              ((begin
                 (let ((v1-33 (-> (the-as vehicle s3-0) root-override-2)))
                   (set! (-> s5-0 quad) (-> v1-33 trans quad))
                   (set! (-> s5-0 w) (-> v1-33 root-prim prim-core world-sphere w))
                   )
                 (sphere-in-loaded-city-infos? obj s5-0 0)
                 )
               (set! (-> (the-as vehicle s3-0) traffic-hash-id)
                     (spatial-hash-method-39 (-> obj object-hash) s5-0 (the-as hash-object-info s3-0))
                     )
               )
              (else
                (deactivate-object (-> obj citizen-tracker-array) (the-as int s4-0) #f)
                )
              )
            )
          (else
            (remove-active-process (-> obj citizen-tracker-array) (the-as int s4-0))
            )
          )
        )
      )
    (countdown (s4-1 (-> obj vehicle-tracker-array active-object-count))
      (let ((s3-1 (handle->process (-> obj vehicle-tracker-array active-object-list s4-1))))
        (cond
          (s3-1
            (cond
              ((focus-test? (the-as process-focusable s3-1) inactive)
               (deactivate-object (-> obj vehicle-tracker-array) (the-as int s4-1) #f)
               )
              ((begin
                 (let ((v1-54 (-> (the-as process-focusable s3-1) root-override)))
                   (set! (-> s5-0 quad) (-> v1-54 trans quad))
                   (set! (-> s5-0 w) (-> v1-54 root-prim prim-core world-sphere w))
                   )
                 (sphere-in-loaded-city-infos? obj s5-0 1)
                 )
               (spatial-hash-method-39 (-> obj object-hash) s5-0 (the-as hash-object-info s3-1))
               )
              (else
                (deactivate-object (-> obj vehicle-tracker-array) (the-as int s4-1) #f)
                )
              )
            )
          (else
            (remove-active-process (-> obj vehicle-tracker-array) (the-as int s4-1))
            )
          )
        )
      )
    )
  (dotimes (s5-1 2)
    (let ((s4-2 (-> obj level-data-array s5-1)))
      (when (nonzero? (-> s4-2 city-info))
        (dotimes (s3-2 (the-as int (-> s4-2 newly-active-cell-count)))
          (let ((a1-22 (-> s4-2 newly-active-cell-list s3-2)))
            (handle-new-vis-cell obj a1-22)
            )
          )
        (dotimes (s3-3 2)
          (when (> (-> obj tracker-array s3-3 inactive-object-count) 0)
            (let ((s2-0 (the-as nav-segment #f)))
              (let ((f30-0 10000000000000000000000000000000000000.0))
                (dotimes (s1-0 (the-as int (-> s4-2 active-cell-count)))
                  (let ((s0-0 (-> s4-2 active-cell-list s1-0)))
                    (when (and (logtest? (-> s0-0 flags) (ash 1 s3-3)) (not (logtest? (-> s0-0 flags) (vis-cell-flag suppress))))
                      (set! sv-48 0)
                      (while (< sv-48 (-> s0-0 incoming-segment-count))
                        (set! sv-64 (-> s0-0 segment-array sv-48))
                        (when (= (-> sv-64 tracker-id) s3-3)
                          (when (not (logtest? (-> s4-2 city-info cell-array (-> sv-64 from-cell-id) flags) (ash 1 s3-3)))
                            (let ((f0-3 (rand-vu)))
                              (when (< f0-3 f30-0)
                                (set! f30-0 f0-3)
                                (set! s2-0 sv-64)
                                )
                              )
                            )
                          )
                        (set! sv-48 (+ sv-48 1))
                        )
                      )
                    )
                  )
                )
              (when s2-0
                (let ((a0-51 (-> s2-0 branch)))
                  (when (not (or (>= (-> a0-51 user-count) (-> a0-51 max-user-count)) (can-dest-be-used? obj (-> s2-0 branch))))
                    (cond
                      ((= s3-3 1)
                       (if (nonzero? (-> s2-0 nav-mesh-id))
                           (activate-one-vehicle obj s2-0 0.0)
                           )
                       )
                      (else
                        (activate-one-citizen obj s2-0 0.0)
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod update-traffic traffic-engine ((obj traffic-engine))
  (update-sync-from-frame-counter obj)
  (update-suppressor obj)
  (let ((s5-0 (new 'stack-no-clear 'bounding-box)))
    (set-vector!
      (-> s5-0 min)
      10000000000000000000000000000000000000.0
      10000000000000000000000000000000000000.0
      10000000000000000000000000000000000000.0
      1.0
      )
    (set-vector!
      (-> s5-0 max)
      -10000000000000000000000000000000000000.0
      -10000000000000000000000000000000000000.0
      -10000000000000000000000000000000000000.0
      1.0
      )
    (dotimes (s4-0 2)
      (let ((s3-0 (-> obj level-data-array s4-0)))
        (when (nonzero? (-> s3-0 city-info))
          (per-frame-cell-update s3-0)
          (add-box! s5-0 (-> s3-0 active-cell-box))
          0
          )
        )
      )
    (update-grid-for-objects-in-box (-> obj object-hash) 253 (-> s5-0 min) (-> s5-0 max))
    )
  (update-traffic-amount obj)
  (set! (-> obj alert-state guard-aim-count) 0)
  (update-alert-state obj)
  (update-guards obj)
  (update-danger obj)
  0
  (none)
  )

(defmethod callback-on-nav-segments-in-sphere traffic-engine ((obj traffic-engine)
                                                            (arg0 vector)
                                                            (arg1 int)
                                                            (arg2 traffic-find-segment-struct)
                                                            (arg3 (function traffic-find-segment-struct nav-segment none))
                                                            )
  (dotimes (s1-0 2)
    (let ((v1-3 (-> obj level-data-array s1-0)))
      (if (nonzero? (-> v1-3 city-info))
          (callback-on-nav-segments-in-sphere (-> v1-3 city-info) arg0 arg1 arg2 arg3)
          )
      )
    )
  0
  (none)
  )

(deftype traffic-find-segment-struct (structure)
  ((best-seg    nav-segment         :offset-assert   0)
   (best-rating float               :offset-assert   4)
   (dir         vector      :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(defmethod find-best-segment traffic-engine ((obj traffic-engine) (arg0 vector) (arg1 vector) (arg2 int))
  (let ((gp-0 (new 'stack-no-clear 'traffic-find-segment-struct)))
    (set! (-> gp-0 dir quad) (-> arg1 quad))
    (set! (-> gp-0 best-rating) -10000000000000000000000000000000000000.0)
    (set! (-> gp-0 best-seg) #f)
    (callback-on-nav-segments-in-sphere
      obj
      arg0
      arg2
      gp-0
      (lambda ((arg0 traffic-find-segment-struct) (arg1 nav-segment))
        (let ((v1-0 (new 'stack-no-clear 'vector)))
          (vector-! v1-0 (-> arg1 vertex 1) (the-as vector (-> arg1 vertex)))
          (let ((a2-1 v1-0)
                (a3-1 v1-0)
                (f0-0 (-> arg1 length))
                )
            (vector-float*! a2-1 a3-1 (/ 1.0 f0-0))
            )
          (let ((f0-4 (vector-dot v1-0 (-> arg0 dir))))
            (when (< (-> arg0 best-rating) f0-4)
              (set! (-> arg0 best-rating) f0-4)
              (set! (-> arg0 best-seg) arg1)
              )
            )
          )
        (none)
        )
      )
    (-> gp-0 best-seg)
    )
  )

(defmethod maybe-increase-guard-aim-count traffic-engine ((obj traffic-engine))
  (when (< (-> obj alert-state guard-aim-count) 2)
    (+! (-> obj alert-state guard-aim-count) 1)
    #t
    )
  )

(defmethod increase-alert-level traffic-engine ((obj traffic-engine) (arg0 int) (arg1 target))
  (when (and (logtest? (-> obj alert-state flags) (traffic-alert-flag target-jak))
             (logtest? (-> arg1 mask) (process-mask target))
             )
    (let ((v1-6 (min arg0 (the-as int (-> obj alert-state max-level)))))
      (when #t
        (set! (-> obj alert-state start-time) (current-time))
        (logclear! (-> obj alert-state flags) (traffic-alert-flag alert-ending))
        )
      (set! (-> obj alert-state level) (the-as uint (max (the-as int (-> obj alert-state level)) v1-6)))
      )
    )
  0
  (none)
  )

(defmethod decrease-alert-level traffic-engine ((obj traffic-engine) (arg0 int))
  (if (logtest? (-> obj alert-state flags) (traffic-alert-flag target-jak))
      (set! (-> obj alert-state level) (the-as uint (min (the-as int (-> obj alert-state level)) arg0)))
      )
  0
  (none)
  )

(defmethod set-alert-level traffic-engine ((obj traffic-engine) (arg0 int))
  (set! (-> obj alert-state level) (the-as uint arg0))
  (set! (-> obj alert-state start-time) (current-time))
  (logclear! (-> obj alert-state flags) (traffic-alert-flag alert-ending))
  0
  (none)
  )

(defmethod set-max-alert-level traffic-engine ((obj traffic-engine) (arg0 int))
  (set! (-> obj alert-state max-level) (the-as uint arg0))
  (set! (-> obj alert-state level) (the-as uint (min (the-as int (-> obj alert-state level)) arg0)))
  0
  (none)
  )

;; WARN: Return type mismatch uint vs int.
(defmethod get-alert-level traffic-engine ((obj traffic-engine))
  (the-as int (-> obj alert-state level))
  )

(defmethod get-target traffic-engine ((obj traffic-engine))
  "@returns [[*target*]]"
  *target*
  )

(defun traffic-los-clear? ((arg0 vector) (arg1 vector))
  (let ((v1-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> v1-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> v1-0 move-dist) arg1 arg0)
    (let ((a0-1 v1-0))
      (set! (-> a0-1 radius) 2048.0)
      (set! (-> a0-1 collide-with) (collide-spec backgnd))
      (set! (-> a0-1 ignore-process0) #f)
      (set! (-> a0-1 ignore-process1) #f)
      (set! (-> a0-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> a0-1 action-mask) (collide-action solid))
      )
    (< (fill-and-probe-using-line-sphere *collide-cache* v1-0) 0.0)
    )
  )

(define *guard-target-spots* (new 'static 'boxed-array :type vector
                               (new 'static 'vector :x 20480.0 :w 1.0)
                               (new 'static 'vector :x 14481.408 :z -14481.408 :w 1.0)
                               (new 'static 'vector :z -20480.0 :w 1.0)
                               (new 'static 'vector :x -14481.408 :z -14481.408 :w 1.0)
                               (new 'static 'vector :x -20480.0 :w 1.0)
                               (new 'static 'vector :x -14481.408 :z 14481.408 :w 1.0)
                               (new 'static 'vector :z 20480.0 :w 1.0)
                               (new 'static 'vector :x 14481.408 :z 14481.408 :w 1.0)
                               (new 'static 'vector :x 28672.0 :w 1.0)
                               (new 'static 'vector :x 24831.182 :z -14335.181 :w 1.0)
                               (new 'static 'vector :x 14336.409 :z -24829.543 :w 1.0)
                               (new 'static 'vector :z -28672.0 :w 1.0)
                               (new 'static 'vector :x -14333.952 :z -24831.182 :w 1.0)
                               (new 'static 'vector :x -24829.951 :z -14336.409 :w 1.0)
                               (new 'static 'vector :x -28672.0 :w 1.0)
                               (new 'static 'vector :x -24830.771 :z 14333.952 :w 1.0)
                               (new 'static 'vector :x -14337.229 :z 24829.951 :w 1.0)
                               (new 'static 'vector :z 28672.0 :w 1.0)
                               (new 'static 'vector :x 14335.181 :z 24830.771 :w 1.0)
                               (new 'static 'vector :x 24829.543 :z 14337.229 :w 1.0)
                               )
        )

(define *guard-id-spots* (new 'static 'boxed-array :type int32
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           -1
                           )
        )

(define *guard-status-spots* (new 'static 'boxed-array :type int32 :length 0 :allocated-length 32))

(defun update-guard-status-spots ((arg0 vector))
  (local-vars (v0-1 symbol))
  (let ((s5-0 (find-nearest-nav-mesh arg0 (the-as float #x7f800000)))
        (v1-0 (new 'stack-no-clear 'vector))
        )
    (new 'stack-no-clear 'vector)
    (let ((s4-0 (new 'stack-no-clear 'nav-find-poly-parms)))
      (if (or (not s5-0) (zero? s5-0))
          (return #f)
          )
      (when s5-0
        (vector-! v1-0 arg0 (-> s5-0 bounds))
        (set! (-> s4-0 y-threshold) 40960.0)
        (set! (-> s4-0 ignore) (the-as uint 2))
        (dotimes (s3-0 8)
          (vector+! (-> s4-0 point) arg0 (-> *guard-target-spots* s3-0))
          (vector-! (-> s4-0 point) (-> s4-0 point) (-> s5-0 bounds))
          (cond
            ((find-poly-containing-point-local s5-0 s4-0)
             (vector+! (-> s4-0 point) (-> s4-0 point) (-> s5-0 bounds))
             (set! (-> *guard-status-spots* s3-0) 1)
             )
            (else
              (set! (-> *guard-status-spots* s3-0) 0)
              0
              )
            )
          )
        )
      )
    )
  (return #t)
  v0-1
  )

;; WARN: Return type mismatch object vs none.
(defun generate-target-spots ()
  "Code-gen function to define [[*guard-target-spots*]] using [[*x-vector*]]"
  (format #t "(define *guard-target-spots* (new 'static 'array 'vector 0~%")
  (dotimes (gp-0 8)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (vector-rotate-around-y! s5-0 *x-vector* (* 182.04445 (* 45.0 (the float gp-0))))
      (vector-float*! s5-0 s5-0 20480.0)
      (format
        #t
        "                                  (new 'static 'vector :x (meters ~M) :y (meters ~M) :z (meters ~M) :w 1.0)~%"
        (-> s5-0 x)
        (-> s5-0 y)
        (-> s5-0 z)
        )
      )
    )
  (dotimes (gp-1 12)
    (let ((s5-1 (new 'stack-no-clear 'vector)))
      (vector-rotate-around-y! s5-1 *x-vector* (* 182.04445 (* 30.0 (the float gp-1))))
      (vector-float*! s5-1 s5-1 28672.0)
      (format
        #t
        "                                  (new 'static 'vector :x (meters ~M) :y (meters ~M) :z (meters ~M) :w 1.0)~%"
        (-> s5-1 x)
        (-> s5-1 y)
        (-> s5-1 z)
        )
      )
    )
  (format #t "                                  )~%")
  (format #t "  )~%")
  (none)
  )

(defmethod find-closest-to-with-collide-lists traffic-engine ((obj traffic-engine) (arg0 process-drawable) (arg1 collide-spec))
  "Iterate through collide lists, find the closest thing to the given process."
  (let ((gp-0 (the-as process-focusable #f)))
    (let ((f30-0 (the-as float #x7f800000)))
      (when (logtest? arg1 (collide-spec player-list))
        (let ((v1-4 (-> *collide-player-list* alive-list next0)))
          *collide-player-list*
          (let ((s3-0 (-> v1-4 next0)))
            (while (!= v1-4 (-> *collide-player-list* alive-list-end))
              (let ((v1-5 (the-as collide-shape (-> (the-as connection v1-4) param1))))
                (when (logtest? arg1 (-> v1-5 root-prim prim-core collide-as))
                  (let* ((s1-0 (-> v1-5 process))
                         (s2-0 (if (type? s1-0 process-focusable)
                                   (the-as process-focusable s1-0)
                                   )
                               )
                         )
                    (when (and s2-0 (not (focus-test? s2-0 disable dead inactive)) (!= arg0 s2-0))
                      (let ((f0-0 (vector-vector-xz-distance (-> arg0 root trans) (-> s2-0 root-override trans))))
                        (when (or (not gp-0) (< f0-0 f30-0))
                          (set! gp-0 s2-0)
                          (set! f30-0 f0-0)
                          )
                        )
                      )
                    )
                  )
                )
              (set! v1-4 s3-0)
              *collide-player-list*
              (set! s3-0 (-> s3-0 next0))
              )
            )
          )
        )
      (when (logtest? arg1 (collide-spec hit-by-player-list hit-by-others-list))
        (when (logtest? arg1 (collide-spec hit-by-player-list))
          (let ((v1-22 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((s3-1 (-> v1-22 next0)))
              (while (!= v1-22 (-> *collide-hit-by-player-list* alive-list-end))
                (let ((v1-23 (the-as collide-shape (-> (the-as connection v1-22) param1))))
                  (when (logtest? arg1 (-> v1-23 root-prim prim-core collide-as))
                    (let* ((s1-1 (-> v1-23 process))
                           (s2-1 (if (type? s1-1 process-focusable)
                                     (the-as process-focusable s1-1)
                                     )
                                 )
                           )
                      (when (and s2-1 (not (focus-test? s2-1 disable dead inactive)) (!= arg0 s2-1))
                        (let ((f0-1 (vector-vector-xz-distance (-> arg0 root trans) (-> s2-1 root-override trans))))
                          (when (or (not gp-0) (< f0-1 f30-0))
                            (set! gp-0 s2-1)
                            (set! f30-0 f0-1)
                            )
                          )
                        )
                      )
                    )
                  )
                (set! v1-22 s3-1)
                *collide-hit-by-player-list*
                (set! s3-1 (-> s3-1 next0))
                )
              )
            )
          )
        (when (logtest? arg1 (collide-spec hit-by-others-list))
          (let ((v1-38 (-> *collide-hit-by-others-list* alive-list next0)))
            *collide-hit-by-others-list*
            (let ((s3-2 (-> v1-38 next0)))
              (while (!= v1-38 (-> *collide-hit-by-others-list* alive-list-end))
                (let ((v1-39 (the-as collide-shape (-> (the-as connection v1-38) param1))))
                  (when (logtest? arg1 (-> v1-39 root-prim prim-core collide-as))
                    (let* ((s1-2 (-> v1-39 process))
                           (s2-2 (if (type? s1-2 process-focusable)
                                     (the-as process-focusable s1-2)
                                     )
                                 )
                           )
                      (when (and s2-2 (not (focus-test? s2-2 disable dead inactive)) (!= arg0 s2-2))
                        (let ((f0-2 (vector-vector-xz-distance (-> arg0 root trans) (-> s2-2 root-override trans))))
                          (when (or (not gp-0) (< f0-2 f30-0))
                            (set! gp-0 s2-2)
                            (set! f30-0 f0-2)
                            )
                          )
                        )
                      )
                    )
                  )
                (set! v1-38 s3-2)
                *collide-hit-by-others-list*
                (set! s3-2 (-> s3-2 next0))
                )
              )
            )
          )
        )
      )
    gp-0
    )
  )

(defmethod traffic-engine-method-49 traffic-engine ((obj traffic-engine) (los vector) (arg2 int) (target-status traffic-target-status))
  (local-vars
    (guards (pointer crimson-guard))
    (guard-target-dists (pointer float))
    (guard-idx int)
    (sv-208 int)
    (sv-216 float)
    )
  (logclear! (-> target-status flags) (traffic-target-flag visible-now updated))
  (cond
    ((= (-> obj sync-mask-16) (ash 1 (logand arg2 15)))
     (logior! (-> target-status flags) (traffic-target-flag updated))
     (let ((target-proc (handle->process (-> target-status handle)))
           (target-pos (new 'stack-no-clear 'vector))
           )
       (when target-proc
         (set! (-> target-pos quad) (-> (get-trans (the-as process-focusable target-proc) 3) quad))
         (cond
           ((= (-> (the-as process-focusable target-proc) type) target)
            (let ((s1-1 (-> obj alert-state target-status-array)))
              (logclear! (-> s1-1 0 flags) (traffic-target-flag visible-now updated))
              (logior! (-> s1-1 0 flags) (traffic-target-flag updated))
              (cond
                ((or (logtest? (-> s1-1 0 flags) (traffic-target-flag force-visible)) (traffic-los-clear? los target-pos))
                 (logior! (-> s1-1 0 flags) (traffic-target-flag visible-now visible-recently visible-ever))
                 (set! (-> s1-1 0 last-seen-time) (current-time))
                 (set! (-> s1-1 0 position quad) (-> target-pos quad))
                 (set! (-> s1-1 0 velocity quad) (-> (get-transv (the-as process-focusable target-proc)) quad))
                 )
                (else
                  (if (>= (- (current-time) (-> s1-1 0 last-seen-time)) (seconds 2))
                      (logclear! (-> s1-1 0 flags) (traffic-target-flag visible-recently))
                      )
                  )
                )
              (mem-copy! (the-as pointer target-status) (the-as pointer s1-1) 80)
              )
            0
            )
           (else
             (logior! (-> target-status flags) (traffic-target-flag visible-now visible-recently visible-ever))
             (set! (-> target-status last-seen-time) (current-time))
             (set! (-> target-status position quad) (-> target-pos quad))
             (set! (-> target-status velocity quad) (-> (get-transv (the-as process-focusable target-proc)) quad))
             )
           )
         (set! (-> target-pos quad) (-> target-status position quad))
         (when (not (update-guard-status-spots target-pos))
           )
         (when (update-guard-status-spots target-pos)
           (set! guards (new 'stack-no-clear 'array 'crimson-guard 16))
           (set! guard-target-dists (new 'stack-no-clear 'array 'float 16))
           (set! guard-idx 0)
           (dotimes (guard-count (the-as int (-> obj vehicle-tracker-array active-object-count)))
             (case (-> obj vehicle-tracker-array active-object-type-list guard-count)
               (((traffic-type crimson-guard-1))
                (let ((guard (handle->process (-> obj vehicle-tracker-array active-object-list guard-count))))
                  (when (and guard
                             (not (focus-test? (the-as process-focusable guard) dead inactive))
                             (= (-> (the-as crimson-guard guard) traffic-target-status handle) (-> target-status handle))
                             )
                    (set! (-> guards guard-idx) (the-as crimson-guard guard))
                    (set! (-> guard-target-dists guard-idx)
                          (vector-vector-distance (-> (the-as crimson-guard guard) root-override2 trans) target-pos)
                          )
                    (set! guard-idx (+ guard-idx 1))
                    (set! (-> (the-as crimson-guard guard) move-index) -1)
                    )
                  )
                )
               )
             )
           (let ((a0-35 #t))
             (while a0-35
               (set! a0-35 #f)
               (dotimes (v1-77 (+ guard-idx -1))
                 (when (< (-> guard-target-dists (+ v1-77 1)) (-> guard-target-dists v1-77))
                   (let ((a0-38 (-> guards v1-77))
                         (f0-2 (-> guard-target-dists v1-77))
                         )
                     (set! (-> guards v1-77) (-> guards (+ v1-77 1)))
                     (set! (-> guards (+ v1-77 1)) a0-38)
                     (set! (-> guard-target-dists v1-77) (-> guard-target-dists (+ v1-77 1)))
                     (set! (-> guard-target-dists (+ v1-77 1)) f0-2)
                     )
                   (set! a0-35 #t)
                   )
                 )
               )
             )
           (dotimes (s4-1 guard-idx)
             (let ((crimson-guard (-> (the-as (pointer crimson-guard) guards) s4-1)))
               (when (= (-> crimson-guard move-index) -1)
                 (set! sv-208 -1)
                 (set! sv-216 100000000000000000.0) ;; kinda hacky, was ps2 weird infinity.
                 (dotimes (s2-4 (-> *guard-target-spots* length))
                   (when (= (-> *guard-status-spots* s2-4) 1)
                     (let* ((a0-53 (vector+! (new 'stack-no-clear 'vector) target-pos (-> *guard-target-spots* s2-4)))
                            (f0-4 (vector-vector-distance a0-53 (-> crimson-guard root-override2 trans)))
                            )
                       (when (or (= sv-208 -1) (< f0-4 sv-216))
                         (set! sv-208 s2-4)
                         (set! sv-216 f0-4)
                         )
                       )
                     )
                   )
                 (cond
                   ((!= sv-208 -1)
                    (set! (-> *guard-status-spots* sv-208) 0)
                    (vector+! (-> crimson-guard move-position) target-pos (-> *guard-target-spots* sv-208))
                    )
                   (else
                     (set! (-> crimson-guard move-position quad) (-> target-pos quad))
                     )
                   )
                 )
               )
             )
           )
         )
       )
     )
    (else
      (let ((s5-1 (handle->process (-> target-status handle)))
            (s3-3 (new 'stack-no-clear 'vector))
            )
        (when s5-1
          (set! (-> s3-3 quad) (-> (get-trans (the-as process-focusable s5-1) 3) quad))
          (cond
            ((= (-> s5-1 type) target)
             (mem-copy! (the-as pointer target-status) (the-as pointer (-> obj alert-state target-status-array)) 80)
             )
            (else
              )
            )
          )
        )
      (logclear! (-> target-status flags) (traffic-target-flag updated))
      )
    )
  target-status
  )

(defmethod set-alert-duration traffic-engine ((obj traffic-engine) (arg0 time-frame))
  (set! (-> obj alert-state duration) (the-as uint arg0))
  0
  (none)
  )

(defmethod guard-count traffic-engine ((obj traffic-engine))
  (let ((v0-0 0))
    (dotimes (v1-0 6)
      (+! v0-0 (-> obj alert-state guard-type-info-array v1-0 count))
      )
    v0-0
    )
  )

(defmethod end-pursuit-by-type traffic-engine ((obj traffic-engine) (arg0 traffic-type))
  (for-all-active-processes-of-type
    (-> obj tracker-array (-> obj object-type-info-array arg0 tracker-index))
    arg0
    (the-as
      (function process-focusable traffic-object-type-info none)
      (lambda ((arg0 process-tree)) (send-event arg0 'end-pursuit) (none))
      )
    )
  0
  (none)
  )

(defmethod set-target-level traffic-engine ((obj traffic-engine) (arg0 float))
  (set! (-> obj alert-state guard-target-level) arg0)
  (dotimes (v1-0 21)
    (let ((a2-2 (-> obj object-type-info-array v1-0)))
      (set! (-> a2-2 target-count) (the int (* arg0 (the float (max 0 (+ (-> a2-2 want-count) -1))))))
      )
    )
  0
  (none)
  )

(defmethod set-guard-target-level traffic-engine ((obj traffic-engine) (arg0 float))
  (set! (-> obj alert-state guard-target-level) arg0)
  0
  (none)
  )

(define *alert-level-settings* (new 'static 'inline-array traffic-alert-state-settings 5
                                 (new 'static 'traffic-alert-state-settings
                                   :ped-tazer (new 'static 'traffic-guard-type-settings
                                     :target-count 5
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-rifle (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :ped-grenade (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-roboguard (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :bike-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 1
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x5dc
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :hellcat-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 1
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x5dc
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   )
                                 (new 'static 'traffic-alert-state-settings
                                   :ped-tazer (new 'static 'traffic-guard-type-settings
                                     :target-count 5
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-rifle (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :ped-grenade (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-roboguard (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :bike-turret (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x5dc
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :hellcat-turret (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x5dc
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   )
                                 (new 'static 'traffic-alert-state-settings
                                   :ped-tazer (new 'static 'traffic-guard-type-settings
                                     :target-count 3
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-rifle (new 'static 'traffic-guard-type-settings
                                     :target-count 4
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :ped-grenade (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-roboguard (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :bike-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 2
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x5dc
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :hellcat-turret (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x5dc
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   )
                                 (new 'static 'traffic-alert-state-settings
                                   :ped-tazer (new 'static 'traffic-guard-type-settings
                                     :target-count 2
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-rifle (new 'static 'traffic-guard-type-settings
                                     :target-count #x7
                                     :inaccuracy 0.25
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :ped-grenade (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-roboguard (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :bike-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 3
                                     :inaccuracy 0.25
                                     :acquire-delay #xe1
                                     :shot-delay #x4b
                                     :burst-delay #x4b0
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   :hellcat-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 2
                                     :inaccuracy 0.25
                                     :acquire-delay #xe1
                                     :shot-delay #x4b
                                     :burst-delay #x4b0
                                     :shot-count 2
                                     :rand-shot-count 1
                                     )
                                   )
                                 (new 'static 'traffic-alert-state-settings
                                   :ped-tazer (new 'static 'traffic-guard-type-settings
                                     :target-count 2
                                     :inaccuracy 0.125
                                     :acquire-delay #x96
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :ped-rifle (new 'static 'traffic-guard-type-settings
                                     :target-count #x7
                                     :inaccuracy 0.125
                                     :acquire-delay #x96
                                     :shot-delay #x2d
                                     :burst-delay #x258
                                     :shot-count 2
                                     :rand-shot-count 2
                                     )
                                   :ped-grenade (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.125
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x384
                                     :shot-count 1
                                     )
                                   :ped-roboguard (new 'static 'traffic-guard-type-settings
                                     :inaccuracy 0.5
                                     :acquire-delay #x12c
                                     :shot-delay #x4b
                                     :burst-delay #x258
                                     :shot-count 1
                                     )
                                   :bike-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 3
                                     :inaccuracy 0.125
                                     :acquire-delay #x96
                                     :shot-delay #x4b
                                     :burst-delay #x384
                                     :shot-count 2
                                     :rand-shot-count 2
                                     )
                                   :hellcat-turret (new 'static 'traffic-guard-type-settings
                                     :target-count 2
                                     :inaccuracy 0.125
                                     :acquire-delay #x96
                                     :shot-delay #x4b
                                     :burst-delay #x384
                                     :shot-count 2
                                     :rand-shot-count 2
                                     )
                                   )
                                 )
        )

(defmethod get-traffic-guard-type-settings traffic-engine ((obj traffic-engine) (arg0 int))
  "TODO - guard-type should be an enum"
  (-> obj alert-state settings guard-settings-array arg0)
  )

(defmethod get-guard-type-for-traffic-obj traffic-engine ((obj traffic-engine) (arg0 int))
  "TODO - guard-type should be an enum"
  (-> obj object-type-info-array arg0 guard-type)
  )

(defmethod get-traffic-guard-change-to-type traffic-engine ((obj traffic-engine) (arg0 int))
  "TODO - guard-type should be an enum"
  (-> obj alert-state guard-type-info-array arg0 change-to-type)
  )

(defmethod update-guards traffic-engine ((obj traffic-engine))
  (dotimes (v1-0 6)
    (set! (-> obj alert-state guard-type-info-array v1-0 count) 0)
    )
  (let* ((f0-0 122880.0)
         (f0-2 (* f0-0 f0-0))
         (a0-3 (the-as vehicle #f))
         (v1-5 0)
         )
    (let ((a1-0 0))
      (dotimes (a2-0 (the-as int (-> obj citizen-tracker-array active-object-count)))
        (case (-> obj citizen-tracker-array active-object-type-list a2-0)
          (((traffic-type guard-bike) (traffic-type hellcat))
           (let ((a3-6 (handle->process (-> obj citizen-tracker-array active-object-list a2-0))))
             (when (and a3-6
                        (not (focus-test? (the-as vehicle a3-6) dead inactive))
                        (logtest? (rigid-body-object-flag alert) (-> (the-as vehicle a3-6) flags))
                        )
               (let ((t0-13 (-> (the-as vehicle a3-6) info-override guard-type)))
                 (+! (-> obj alert-state guard-type-info-array t0-13 count) 1)
                 )
               (when (and (logtest? (rigid-body-object-flag in-pursuit) (-> (the-as vehicle a3-6) flags))
                          (logtest? (rigid-body-object-flag target-in-sight) (-> (the-as vehicle a3-6) flags))
                          )
                 (+! a1-0 1)
                 (when (not (logtest? (-> (the-as vehicle a3-6) draw status) (draw-control-status on-screen)))
                   (+! v1-5 1)
                   (let ((f1-0 (-> (the-as vehicle a3-6) target-distance2)))
                     (when (< f0-2 f1-0)
                       (set! f0-2 f1-0)
                       (set! a0-3 (the-as vehicle a3-6))
                       )
                     )
                   )
                 )
               )
             )
           )
          )
        )
      (set! (-> obj alert-state guards-in-sight-of-target) a1-0)
      )
    (when (< 2 v1-5)
      (if (not (logtest? (-> obj alert-state flags) (traffic-alert-flag disable-pursuit-control)))
          (send-event a0-3 'end-pursuit)
          )
      )
    )
  (let ((f30-0 122880.0)
        (s5-0 (the-as crimson-guard #f))
        (s4-0 0)
        )
    (let ((s3-0 0))
      (let ((s2-0 0))
        (dotimes (s1-0 (the-as int (-> obj vehicle-tracker-array active-object-count)))
          (case (-> obj vehicle-tracker-array active-object-type-list s1-0)
            (((traffic-type crimson-guard-1))
             (let ((s0-0 (handle->process (-> obj vehicle-tracker-array active-object-list s1-0))))
               (when (and s0-0 (not (logtest? (-> (the-as crimson-guard s0-0) focus-status) (focus-status dead inactive))))
                 (when (and (logtest? (-> (the-as crimson-guard s0-0) flags) (citizen-flag in-pursuit))
                            (logtest? (-> (the-as crimson-guard s0-0) flags) (citizen-flag target-in-sight))
                            )
                   (+! s3-0 1)
                   (when (not (logtest? (-> (the-as crimson-guard s0-0) draw status) (draw-control-status on-screen)))
                     (+! s4-0 1)
                     (let ((f0-3 (-> (the-as crimson-guard s0-0) target-self-dist)))
                       (when (< f30-0 f0-3)
                         (set! f30-0 f0-3)
                         (set! s5-0 (the-as crimson-guard s0-0))
                         )
                       (if (and (< 327680.0 f0-3)
                                (not (logtest? (-> obj alert-state flags) (traffic-alert-flag disable-pursuit-control)))
                                )
                           (send-event (the-as crimson-guard s0-0) 'end-pursuit)
                           )
                       )
                     )
                   )
                 (let ((v1-42 (-> s0-0 stack 860)))
                   (when (< v1-42 (the-as uint 6))
                     (+! s2-0 1)
                     (+! (-> obj alert-state guard-type-info-array v1-42 count) 1)
                     )
                   )
                 )
               )
             )
            )
          )
        )
      (+! (-> obj alert-state guards-in-sight-of-target) s3-0)
      )
    (when (< 2 s4-0)
      (if (not (logtest? (-> obj alert-state flags) (traffic-alert-flag disable-pursuit-control)))
          (send-event s5-0 'end-pursuit)
          )
      )
    )
  (let ((v1-58 -1)
        (a0-25 -1)
        )
    (let ((a1-6 0)
          (a2-4 9)
          )
      (dotimes (a3-9 6)
        (when (= (-> obj alert-state guard-type-info-array a3-9 object-type) (traffic-type crimson-guard-1))
          (let ((t1-15 (-> obj alert-state guard-type-info-array a3-9)))
            (set! (-> t1-15 change-to-type) (the-as uint a3-9))
            (let ((t0-33 (- (-> t1-15 target-count) (-> t1-15 count))))
              (when (< a1-6 t0-33)
                (set! v1-58 a3-9)
                (set! a1-6 t0-33)
                )
              (when (and (< t0-33 a2-4) (> (-> t1-15 count) 0))
                (set! a0-25 a3-9)
                (set! a2-4 t0-33)
                )
              )
            )
          )
        )
      )
    (when (and (!= v1-58 -1) (!= a0-25 -1))
      (set! (-> obj alert-state guard-type-info-array a0-25 change-to-type) (the-as uint v1-58))
      (set! (-> obj object-type-info-array 6 guard-type) (the-as uint v1-58))
      )
    )
  0
  (none)
  )

(defmethod update-alert-state traffic-engine ((obj traffic-engine))
  (if (and (logtest? (-> obj alert-state flags) (traffic-alert-flag target-jak)) *target*)
      (set! (-> obj alert-state target-status-array 0 handle) (process->handle *target*))
      )
  (when #t
    (mem-copy!
      (the-as pointer (-> obj alert-state settings))
      (the-as pointer (-> *alert-level-settings* (-> obj alert-state level)))
      96
      )
    (dotimes (v1-10 6)
      (let ((a1-3 (-> obj alert-state settings guard-settings-array v1-10))
            (a0-10 (-> obj alert-state guard-type-info-array v1-10))
            )
        (set! (-> a1-3 inaccuracy)
              (fmax 0.0 (fmin 1.0 (* (-> a1-3 inaccuracy) (-> obj alert-state guard-inaccuracy-factor))))
              )
        (when *target*
          (when (focus-test? *target* pilot)
            (set! (-> a1-3 acquire-delay) (the-as uint (the int (* 0.75 (the float (-> a1-3 acquire-delay))))))
            (set! (-> a1-3 shot-delay) (the-as uint (the int (* 0.6 (the float (-> a1-3 shot-delay))))))
            (set! (-> a1-3 burst-delay) (the-as uint (the int (* 0.8 (the float (-> a1-3 burst-delay))))))
            )
          )
        (set! (-> a0-10 target-count)
              (max
                (min
                  (the int (* (the float (-> a1-3 target-count)) (-> obj alert-state guard-target-level)))
                  (-> a0-10 max-target-count)
                  )
                (-> a0-10 min-target-count)
                )
              )
        )
      )
    )
  (dotimes (v1-13 21)
    (let ((a1-8 (-> obj alert-state guard-type-mask-from-object-type v1-13)))
      (when (nonzero? a1-8)
        (let ((a2-18 0)
              (a0-14 0)
              )
          (while (nonzero? a1-8)
            (if (logtest? a1-8 1)
                (+! a0-14 (-> obj alert-state guard-type-info-array a2-18 target-count))
                )
            (+! a2-18 1)
            (set! a1-8 (shr a1-8 1))
            )
          (set! (-> obj object-type-info-array v1-13 target-count) a0-14)
          )
        )
      )
    )
  (let ((s5-0 #f))
    (when *traffic-alert-level-force*
      (set! (-> obj alert-state level) (the-as uint 3))
      (logclear! (-> obj alert-state flags) (traffic-alert-flag alert-ending))
      (set! (-> obj alert-state start-time) (current-time))
      )
    (when (>= (-> obj alert-state level) (the-as uint 1))
      (set! s5-0 #t)
      (cond
        ((logtest? (-> obj alert-state flags) (traffic-alert-flag alert-ending))
         (cond
           ((> (guard-count obj) 0)
            (set! (-> obj alert-state start-time) (current-time))
            )
           (else
             (when (>= (- (current-time) (-> obj alert-state start-time)) (seconds 3))
               (set! s5-0 #f)
               (set! (-> obj alert-state level) (the-as uint 0))
               (logclear! (-> obj alert-state flags) (traffic-alert-flag alert-ending))
               )
             )
           )
         )
        (else
          (let ((v1-39
                  (+ (- (-> obj alert-state start-time) (current-time)) (the-as time-frame (-> obj alert-state duration)))
                  )
                )
            (if (and *target* (-> *target* next-state) (= (-> *target* next-state name) 'target-hide))
                (set! v1-39 (- v1-39 (the-as time-frame (* (- (current-time) (-> *target* state-time)) 2))))
                )
            (if (> v1-39 0)
                0
                (logior! (-> obj alert-state flags) (traffic-alert-flag alert-ending))
                )
            )
          )
        )
      )
    (cond
      (s5-0
        (when (not (logtest? (-> obj alert-state flags) (traffic-alert-flag alarm-on)))
          (logior! (-> obj alert-state flags) (traffic-alert-flag alarm-on))
          (set! (-> *game-info* wanted-flash) (the-as basic #t))
          (if (= (-> *setting-control* user-current music) 'city1)
              (set-setting! 'sound-mode #f 0.0 1)
              )
          )
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (set! (-> s5-1 quad) (-> (target-pos 0) quad))
          (if (or (= (-> *setting-control* user-default music-volume) 0.0)
                  (!= (-> *setting-control* user-current music) 'city1)
                  )
              (sound-play "city-alarm" :id (-> obj alert-state alarm-sound-id) :position s5-1)
              )
          )
        (if #t
            (send-alert-events obj)
            )
        (let ((v1-67 0))
          (dotimes (a0-45 21)
            (let ((a1-19 (-> obj object-type-info-array a0-45)))
              (if #t
                  (+! v1-67 (-> a1-19 killed-count))
                  )
              )
            )
          (if (and (>= v1-67 (the-as int (* (-> obj alert-state level) 8)))
                   (< (-> obj alert-state level) (-> obj alert-state max-level))
                   )
              (set-alert-level obj (the-as int (+ (-> obj alert-state level) 1)))
              )
          )
        )
      (else
        (when (logtest? (-> obj alert-state flags) (traffic-alert-flag alarm-on))
          (logclear! (-> obj alert-state flags) (traffic-alert-flag alarm-on))
          (set! (-> *game-info* wanted-flash) #f)
          (remove-setting! 'sound-mode)
          (sound-stop (-> obj alert-state alarm-sound-id))
          (send-alert-events obj)
          (let ((v1-84 (-> obj alert-state target-status-array)))
            (logclear! (-> v1-84 0 flags) (traffic-target-flag visible-now visible-recently visible-ever))
            )
          (dotimes (v1-85 21)
            (set! (-> obj object-type-info-array v1-85 killed-count) (the-as uint 0))
            0
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod send-alert-events traffic-engine ((obj traffic-engine))
  (set! (-> obj alert-state notify-time) (current-time))
  (cond
    ((> (-> obj alert-state level) 0)
     (if (and (logtest? (-> obj alert-state flags) (traffic-alert-flag target-jak))
              (not (logtest? (-> obj alert-state flags) (traffic-alert-flag alert-ending)))
              *target*
              )
         (for-all-active-processes obj (lambda ((arg0 process-focusable) (arg1 traffic-object-type-info))
                                         (if (logtest? (-> arg1 flags) (traffic-type-flags trtflags-0))
                                             (send-event arg0 'alert-begin *target*)
                                             )
                                         (none)
                                         )
                                   )
         )
     )
    (else
      (for-all-active-processes obj (lambda ((arg0 process-focusable) (arg1 traffic-object-type-info))
                                      (if (logtest? (-> arg1 flags) (traffic-type-flags trtflags-0))
                                          (send-event arg0 'alert-end)
                                          )
                                      (none)
                                      )
                                )
      )
    )
  0
  (none)
  )

(defmethod restore-default-settings traffic-engine ((obj traffic-engine))
  (restore-city-speeches)
  (logclear!
    (-> obj alert-state flags)
    (traffic-alert-flag guard-multi-focus sticky-guard-settings disable-pursuit-control)
    )
  (set! (-> obj inv-density-factor) 5.0)
  (if (demo?)
      (set! (-> obj inv-density-factor) 1.25)
      )
  (let ((v1-6 (-> obj alert-state target-status-array)))
    (logclear! (-> v1-6 0 flags) (traffic-target-flag force-visible))
    )
  (set-target-level obj 1.0)
  (set-alert-duration obj (seconds 30))
  (set-max-alert-level obj 4)
  (let ((v1-13 42))
    (dotimes (a0-7 21)
      (let ((a1-6 (-> obj object-type-info-array a0-7)))
        (set! (-> a1-6 flags) (traffic-type-flags trtflags-1 trtflags-2))
        (set! (-> a1-6 reserve-count) (the-as uint (max 1000 (min #xfde8 (* 1000 (-> a1-6 want-count))))))
        (set! (-> a1-6 killed-count) (the-as uint 0))
        (set! (-> a1-6 parking-spot-prob)
              (the-as
                uint
                (if (and (zero? (-> a1-6 tracker-index)) (not (logtest? (-> a1-6 flags) (traffic-type-flags trtflags-0))))
                    v1-13
                    0
                    )
                )
              )
        )
      )
    )
  (let ((v1-16 (-> obj object-type-info-array 6)))
    (logior! (-> v1-16 flags) (traffic-type-flags trtflags-0))
    )
  (let ((v1-17 (-> obj object-type-info-array 7)))
    (logior! (-> v1-17 flags) (traffic-type-flags trtflags-0))
    )
  (let ((v1-18 (-> obj object-type-info-array 18)))
    (logior! (-> v1-18 flags) (traffic-type-flags trtflags-0))
    )
  (let ((v1-19 (-> obj object-type-info-array 19)))
    (logior! (-> v1-19 flags) (traffic-type-flags trtflags-0))
    )
  (let ((v1-20 (-> obj object-type-info-array 20)))
    (logior! (-> v1-20 flags) (traffic-type-flags trtflags-0))
    )
  (let ((v1-21 (-> obj object-type-info-array 5)))
    (set! (-> v1-21 target-count) 0)
    (logclear! (-> v1-21 flags) (traffic-type-flags trtflags-1 trtflags-2))
    )
  (let ((v1-22 (-> obj object-type-info-array 3)))
    (set! (-> v1-22 target-count) 0)
    (logclear! (-> v1-22 flags) (traffic-type-flags trtflags-2))
    )
  (let ((v1-23 (-> obj object-type-info-array 4)))
    (set! (-> v1-23 target-count) 0)
    (logclear! (-> v1-23 flags) (traffic-type-flags trtflags-2))
    )
  (let ((v1-24 (-> obj object-type-info-array 17)))
    (set! (-> v1-24 target-count) 0)
    (logclear! (-> v1-24 flags) (traffic-type-flags trtflags-1 trtflags-2))
    )
  (dotimes (v1-25 6)
    (let ((a0-28 (-> obj alert-state guard-type-info-array v1-25)))
      (set! (-> a0-28 min-target-count) 0)
      (set! (-> a0-28 max-target-count) 127)
      )
    )
  0
  (none)
  )

(defmethod deactivate-all traffic-engine ((obj traffic-engine))
  (deactivate-all (-> obj citizen-tracker-array) #t)
  (deactivate-all (-> obj vehicle-tracker-array) #t)
  0
  (none)
  )

(defmethod deactivate-by-type traffic-engine ((obj traffic-engine) (arg0 traffic-type))
  (let ((a2-0 (-> obj object-type-info-array arg0)))
    (deactivate-all-of-type (-> obj tracker-array (-> a2-0 tracker-index)) arg0 #t)
    )
  0
  (none)
  )

(defmethod deactivate-all-from-level traffic-engine ((obj traffic-engine) (arg0 symbol))
  (local-vars (v1-6 nav-branch))
  (countdown (s4-0 (-> obj citizen-tracker-array active-object-count))
    (let ((v1-3 (handle->process (-> obj citizen-tracker-array active-object-list s4-0))))
      (when v1-3
        (cond
          ((focus-test? (the-as process-focusable v1-3) inactive)
           (deactivate-object (-> obj citizen-tracker-array) (the-as int s4-0) #f)
           )
          ((begin (set! v1-6 (-> (the-as vehicle v1-3) controller branch)) (and v1-6 (nonzero? v1-6)))
           (let ((v1-7 (-> v1-6 dest-node)))
             (cond
               (v1-7
                 (if (= arg0 (-> v1-7 level))
                     (deactivate-object (-> obj citizen-tracker-array) (the-as int s4-0) #t)
                     )
                 )
               (else
                 0
                 )
               )
             )
           )
          (else
            0
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod set-object-auto-activate traffic-engine ((obj traffic-engine) (arg0 int) (arg1 object))
  (let ((v1-2 (-> obj object-type-info-array arg0)))
    (if arg1
        (logior! (-> v1-2 flags) (traffic-type-flags trtflags-2))
        (logclear! (-> v1-2 flags) (traffic-type-flags trtflags-2))
        )
    )
  0
  (none)
  )

(defmethod set-object-target-level traffic-engine ((obj traffic-engine) (arg0 int) (arg1 float))
  (let ((v1-2 (-> obj object-type-info-array arg0)))
    (set! (-> v1-2 target-count) (the int (* arg1 (the float (max 0 (+ (-> v1-2 want-count) -1))))))
    )
  0
  (none)
  )

(defmethod set-object-target-count traffic-engine ((obj traffic-engine) (arg0 int) (arg1 int))
  (set! (-> obj object-type-info-array arg0 target-count) arg1)
  0
  (none)
  )

(defmethod set-guard-target-count-range traffic-engine ((obj traffic-engine) (arg0 int) (arg1 int) (arg2 int))
  (let ((v1-2 (-> obj alert-state guard-type-info-array arg0)))
    (set! (-> v1-2 min-target-count) (max 0 (min 127 arg1)))
    (set! (-> v1-2 max-target-count) (max 0 (min 127 arg2)))
    )
  0
  (none)
  )

(defmethod set-object-reserve-count traffic-engine ((obj traffic-engine) (arg0 int) (arg1 uint))
  (set! (-> obj object-type-info-array arg0 reserve-count) arg1)
  0
  (none)
  )

;; WARN: Return type mismatch uint vs int.
(defmethod get-object-reserve-count traffic-engine ((obj traffic-engine) (arg0 int))
  (the-as int (-> obj object-type-info-array arg0 reserve-count))
  )

(defmethod get-object-remaining-count traffic-engine ((obj traffic-engine) (arg0 int))
  (let ((a0-1 (-> obj object-type-info-array arg0)))
    (+ (-> a0-1 active-count) (-> a0-1 reserve-count))
    )
  )

(defmethod set-parking-spot-prob traffic-engine ((obj traffic-engine) (arg0 int) (arg1 float))
  (let ((v1-2 (-> obj object-type-info-array arg0)))
    (set! (-> v1-2 parking-spot-prob) (the-as uint (min 255 (the int (* 256.0 arg1)))))
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs traffic-type.
(defmethod get-random-parking-spot-type traffic-engine ((obj traffic-engine))
  (let ((s5-0 11))
    (let ((s4-0 (the int (* 256.0 (rand-vu))))
          (s3-0 0)
          )
      (while (< (the-as uint s5-0) (the-as uint 21))
        (let ((s2-0 (-> obj object-type-info-array s5-0)))
          (when (and (logtest? (-> s2-0 flags) (traffic-type-flags trtflags-3))
                     (= (level-status *level* (-> s2-0 level)) 'active)
                     )
            (+! s3-0 (-> s2-0 parking-spot-prob))
            (b! (>= (the-as uint s3-0) (the-as uint s4-0)) cfg-10)
            )
          )
        (+! s5-0 1)
        )
      )
    (set! s5-0 21)
    (label cfg-10)
    (the-as traffic-type s5-0)
    )
  )

(defmethod activate-object traffic-engine ((obj traffic-engine) (arg0 traffic-object-spawn-params))
  (let ((a2-0 (-> obj object-type-info-array (-> arg0 object-type))))
    (activate-from-params (-> obj tracker-array (-> a2-0 tracker-index)) arg0)
    )
  0
  (none)
  )

(defmethod activate-by-handle traffic-engine ((obj traffic-engine) (arg0 traffic-object-spawn-params))
  (let ((a2-0 (-> obj object-type-info-array (-> arg0 object-type))))
    (activate-by-handle (-> obj tracker-array (-> a2-0 tracker-index)) arg0)
    )
  0
  (none)
  )

(defmethod new-suppression-box traffic-engine ((obj traffic-engine) (arg0 traffic-suppression-params))
  (add-new-supression-box (-> obj suppressor) arg0)
  (none)
  )

(defmethod remove-suppression-box traffic-engine ((obj traffic-engine) (arg0 traffic-suppression-params))
  (remove-box-by-id (-> obj suppressor) (the-as int arg0))
  (none)
  )

(defmethod update-suppression-box traffic-engine ((obj traffic-engine) (arg0 traffic-suppression-params))
  (update-box-from-params (-> obj suppressor) arg0)
  (none)
  )

(defmethod update-suppressor traffic-engine ((obj traffic-engine))
  (let ((v1-3 (- (-> *display* game-clock frame-counter) (-> *display* game-clock old-frame-counter))))
    (dotimes (a1-3 16)
      (let ((a2-2 (-> obj suppressor array a1-3)))
        (when (logtest? (-> a2-2 flags) (traffic-suppression-box-flags in-use))
          (let ((a3-3 (the-as int (-> a2-2 duration))))
            (cond
              ((< (the-as uint a3-3) (the-as uint v1-3))
               (logclear! (-> a2-2 flags) (traffic-suppression-box-flags in-use))
               (logior! (-> obj suppressor flags) (traffic-suppression-flags needs-update))
               )
              (else
                (set! (-> a2-2 duration) (the-as uint (- (the-as time-frame a3-3) v1-3)))
                )
              )
            )
          )
        )
      )
    )
  (when (logtest? (-> obj suppressor flags) (traffic-suppression-flags needs-update))
    (logclear! (-> obj suppressor flags) (traffic-suppression-flags needs-update))
    (recompute-supressions obj)
    )
  0
  (none)
  )

(defmethod recompute-supressions traffic-engine ((obj traffic-engine))
  (dotimes (s5-0 2)
    (let ((v1-3 (-> obj level-data-array s5-0)))
      (if (nonzero? (-> v1-3 city-info))
          (update-suppressions-from-traffic-engine (-> v1-3 city-info) obj)
          )
      )
    )
  0
  (none)
  )

(defmethod new traffic-engine ((allocation symbol) (type-to-make type))
  (let ((s5-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> s5-0 object-hash) ((method-of-type spatial-hash new) allocation spatial-hash #xc1c0 253))
    s5-0
    )
  )

(defmethod get-first-cell-in-box city-level-info ((obj city-level-info) (arg0 vis-grid-box))
  (-> obj
      cell-array
      (+ (-> arg0 min x)
         (* (-> arg0 min z) (-> obj grid-info dimension-array 0))
         (* (* (-> arg0 min y) (-> obj grid-info dimension-array 0)) (-> obj grid-info dimension-array 2))
         )
      )
  )

(defmethod sphere-in-grid? city-level-info ((obj city-level-info) (arg0 vector) (arg1 int))
  (let ((gp-0 #f))
    (let ((s3-0 (new 'stack-no-clear 'vis-grid-box))
          (s2-0 (new 'stack-no-clear 'vis-grid-box))
          )
      (lookup-box-for-sphere (-> obj grid-info) s2-0 arg0)
      (set! (-> s3-0 min y) (-> s2-0 min y))
      (let ((v1-6 (+ (- 1 (-> s2-0 min y)) (-> s2-0 max y))))
        (b! #t cfg-13 :delay (nop!))
        (label cfg-1)
        (+! v1-6 -1)
        (set! (-> s3-0 min z) (-> s2-0 min z))
        (let ((a0-7 (+ (- 1 (-> s2-0 min z)) (-> s2-0 max z))))
          (b! #t cfg-11 :delay (nop!))
          (label cfg-2)
          (+! a0-7 -1)
          (set! (-> s3-0 min x) (-> s2-0 min x))
          (let ((a1-7 (+ (- 1 (-> s2-0 min x)) (-> s2-0 max x))))
            (b! #t cfg-9 :delay (nop!))
            (label cfg-3)
            (+! a1-7 -1)
            (let ((a3-0 obj)
                  (t1-0 s3-0)
                  )
              (b!
                (not (logtest? (-> a3-0
                                   cell-array
                                   (+ (-> t1-0 min x)
                                      (* (-> t1-0 min z) (-> a3-0 grid-info dimension-array 0))
                                      (* (* (-> t1-0 min y) (-> a3-0 grid-info dimension-array 0)) (-> a3-0 grid-info dimension-array 2))
                                      )
                                   flags
                                   )
                               (ash 1 arg1)
                               )
                     )
                cfg-8
                :delay (empty-form)
                )
              )
            (set! gp-0 #t)
            (b! #t cfg-15 :delay (nop!))
            (label cfg-8)
            (+! (-> s3-0 min x) 1)
            (label cfg-9)
            (b! (nonzero? a1-7) cfg-3 :delay (nop!))
            )
          (+! (-> s3-0 min z) 1)
          (label cfg-11)
          (b! (nonzero? a0-7) cfg-2 :delay (nop!))
          )
        (+! (-> s3-0 min y) 1)
        (label cfg-13)
        (b! (nonzero? v1-6) cfg-1 :delay (nop!))
        )
      )
    (label cfg-15)
    gp-0
    )
  )

(defmethod callback-on-nav-segments-in-sphere city-level-info ((obj city-level-info)
                                                             (arg0 vector)
                                                             (arg1 int)
                                                             (arg2 traffic-find-segment-struct)
                                                             (arg3 (function traffic-find-segment-struct nav-segment none))
                                                             )
  (local-vars
    (sv-16 city-level-info)
    (sv-20 vector)
    (sv-24 int)
    (sv-28 traffic-find-segment-struct)
    (sv-32 (function traffic-find-segment-struct nav-segment none))
    (sv-80 vis-grid-box)
    (sv-84 vis-grid-box)
    )
  (set! sv-16 obj)
  (set! sv-20 arg0)
  (set! sv-24 arg1)
  (set! sv-28 arg2)
  (set! sv-32 arg3)
  (set! sv-80 (new 'stack-no-clear 'vis-grid-box))
  (set! sv-84 (new 'stack-no-clear 'vis-grid-box))
  (lookup-box-for-sphere (-> sv-16 grid-info) sv-80 sv-20)
  (set! (-> sv-84 min y) (-> sv-80 min y))
  (countdown (gp-0 (+ (- 1 (-> sv-80 min y)) (-> sv-80 max y)))
    (set! (-> sv-84 min z) (-> sv-80 min z))
    (countdown (s5-0 (+ (- 1 (-> sv-80 min z)) (-> sv-80 max z)))
      (set! (-> sv-84 min x) (-> sv-80 min x))
      (countdown (s4-0 (+ (- 1 (-> sv-80 min x)) (-> sv-80 max x)))
        (let* ((a0-17 sv-16)
               (a2-2 sv-84)
               (v1-18
                 (-> a0-17
                     cell-array
                     (+ (-> a2-2 min x)
                        (* (-> a2-2 min z) (-> a0-17 grid-info dimension-array 0))
                        (* (* (-> a2-2 min y) (-> a0-17 grid-info dimension-array 0)) (-> a0-17 grid-info dimension-array 2))
                        )
                     )
                 )
               (s3-0 (-> v1-18 segment-array 0))
               )
          (countdown (s2-0 (-> v1-18 segment-count))
            (if (and (= (-> s3-0 tracker-id) sv-24)
                     (line-sphere-intersection? sv-20 (the-as vector (-> s3-0 vertex)) (-> s3-0 vertex 1))
                     )
                (sv-32 sv-28 s3-0)
                )
            (&+! s3-0 48)
            )
          )
        (+! (-> sv-84 min x) 1)
        )
      (+! (-> sv-84 min z) 1)
      )
    (+! (-> sv-84 min y) 1)
    )
  0
  (none)
  )

(defmethod update-suppressions-from-traffic-engine city-level-info ((obj city-level-info) (arg0 traffic-engine))
  (let ((v1-0 (-> obj cell-count)))
    (dotimes (a0-1 (the-as int v1-0))
      (let ((a1-2 (-> obj cell-array a0-1)))
        (logclear! (-> a1-2 flags) (vis-cell-flag suppress))
        )
      )
    )
  (let ((s4-0 (new 'stack-no-clear 'inline-array 'vis-grid-pos 2)))
    (dotimes (s3-0 16)
      (let ((s2-0 (-> arg0 suppressor array s3-0)))
        (when (logtest? (-> s2-0 flags) (traffic-suppression-box-flags in-use))
          (lookup-cell-for-point (-> obj grid-info) (-> s4-0 1) (the-as vector (-> s2-0 bbox)))
          (lookup-cell-for-point (-> obj grid-info) (-> s4-0 2) (-> s2-0 bbox max))
          (set! (-> s4-0 0 y) (-> s4-0 1 y))
          (countdown (v1-15 (+ (- 1 (-> s4-0 1 y)) (-> s4-0 2 y)))
            (set! (-> s4-0 0 z) (-> s4-0 1 z))
            (countdown (a0-9 (+ (- 1 (-> s4-0 1 z)) (-> s4-0 2 z)))
              (set! (-> s4-0 0 x) (-> s4-0 1 x))
              (countdown (a1-10 (+ (- 1 (-> s4-0 1 x)) (-> s4-0 2 x)))
                (let* ((a3-1 obj)
                       (t1-0 (-> s4-0 0))
                       (a2-8 (-> a3-1
                                 cell-array
                                 (+ (-> t1-0 x)
                                    (* (-> t1-0 z) (-> a3-1 grid-info dimension-array 0))
                                    (* (* (-> t1-0 y) (-> a3-1 grid-info dimension-array 0)) (-> a3-1 grid-info dimension-array 2))
                                    )
                                 )
                             )
                       )
                  (logior! (-> a2-8 flags) (vis-cell-flag suppress))
                  )
                (+! (-> s4-0 0 x) 1)
                )
              (+! (-> s4-0 0 z) 1)
              )
            (+! (-> s4-0 0 y) 1)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod add-active-cell traffic-level-data ((obj traffic-level-data) (arg0 vis-cell))
  (let ((v1-0 (-> obj active-cell-count)))
    (when (< v1-0 (the-as uint 255))
      (set! (-> obj active-cell-list v1-0) arg0)
      (+! (-> obj active-cell-count) 1)
      )
    )
  0
  (none)
  )

(defmethod remove-active-cell traffic-level-data ((obj traffic-level-data) (arg0 int))
  (let ((v1-1 (+ (-> obj active-cell-count) -1)))
    (when (>= v1-1 0)
      (set! (-> obj active-cell-list arg0) (-> obj active-cell-list v1-1))
      (+! (-> obj active-cell-count) -1)
      )
    )
  0
  (none)
  )

(defmethod add-newly-active-cell traffic-level-data ((obj traffic-level-data) (arg0 vis-cell))
  (let ((v1-0 (-> obj newly-active-cell-count)))
    (when (< v1-0 (the-as uint 255))
      (set! (-> obj newly-active-cell-list v1-0) arg0)
      (+! (-> obj newly-active-cell-count) 1)
      )
    )
  0
  (none)
  )

(defmethod per-frame-cell-update traffic-level-data ((obj traffic-level-data))
  (set! (-> obj newly-active-cell-count) (the-as uint 0))
  (dotimes (v1-0 (the-as int (-> obj active-cell-count)))
    (let ((a0-3 (-> obj active-cell-list v1-0)))
      (set! (-> a0-3 prev-flags) (-> a0-3 flags))
      )
    )
  (let ((s5-0 (math-camera-pos))
        (f30-0 (meters 20))
        (f28-0 (meters 200))
        (f26-0 (meters 120))
        )
    (dotimes (s4-0 (the-as int (-> obj city-info cell-count)))
      (let ((s3-0 (-> obj city-info cell-array s4-0)))
        (let ((f24-0 (vector-vector-distance-squared (-> s3-0 sphere) s5-0))
              (f0-1 (+ (-> s3-0 sphere r) f28-0))
              )
          (cond
            ((or (< (* f0-1 f0-1) f24-0) (let ((f0-5 (+ (-> s3-0 sphere r) f30-0)))
                                           (and (< (* f0-5 f0-5) f24-0) (not (sphere-in-view-frustum? (-> s3-0 sphere))))
                                           )
                 )
             (logclear! (-> s3-0 flags) (vis-cell-flag active-vehicle active-pedestrian))
             )
            ((let ((f0-9 (+ (-> s3-0 sphere r) f26-0)))
               (< (* f0-9 f0-9) f24-0)
               )
             (let ((v1-17 (logior (-> s3-0 flags) (vis-cell-flag active-vehicle))))
               (set! (-> s3-0 flags) (logclear v1-17 (vis-cell-flag active-pedestrian)))
               )
             )
            (else
              (logior! (-> s3-0 flags) (vis-cell-flag active-vehicle active-pedestrian))
              )
            )
          )
        (if (< (the-as uint (logand (-> s3-0 prev-flags) (vis-cell-flag active-vehicle active-pedestrian)))
               (the-as uint (logand (-> s3-0 flags) (vis-cell-flag active-vehicle active-pedestrian)))
               )
            (add-newly-active-cell obj s3-0)
            )
        )
      )
    )
  (countdown (s5-1 (-> obj active-cell-count))
    (let ((v1-32 (-> obj active-cell-list s5-1)))
      (when (not (logtest? (-> v1-32 flags) (vis-cell-flag active-vehicle active-pedestrian)))
        (logclear! (-> v1-32 prev-flags) (vis-cell-flag active-vehicle active-pedestrian))
        (remove-active-cell obj (the-as int s5-1))
        )
      )
    )
  (dotimes (s5-2 (the-as int (-> obj newly-active-cell-count)))
    (let ((a1-5 (-> obj newly-active-cell-list s5-2)))
      (add-active-cell obj a1-5)
      )
    )
  (let ((v1-43 (-> obj active-cell-box)))
    (set-vector!
      (-> v1-43 min)
      10000000000000000000000000000000000000.0
      10000000000000000000000000000000000000.0
      10000000000000000000000000000000000000.0
      1.0
      )
    (set-vector!
      (-> v1-43 max)
      -10000000000000000000000000000000000000.0
      -10000000000000000000000000000000000000.0
      -10000000000000000000000000000000000000.0
      1.0
      )
    (countdown (a0-23 (-> obj active-cell-count))
      (let ((a1-16 (-> obj active-cell-list a0-23)))
        (set! (-> v1-43 min x) (fmin (-> v1-43 min x) (- (-> a1-16 sphere x) (-> a1-16 sphere r))))
        (set! (-> v1-43 min y) (fmin (-> v1-43 min y) (- (-> a1-16 sphere y) (-> a1-16 sphere r))))
        (set! (-> v1-43 min z) (fmin (-> v1-43 min z) (- (-> a1-16 sphere z) (-> a1-16 sphere r))))
        (set! (-> v1-43 max x) (fmax (-> v1-43 max x) (+ (-> a1-16 sphere x) (-> a1-16 sphere r))))
        (set! (-> v1-43 max y) (fmax (-> v1-43 max y) (+ (-> a1-16 sphere y) (-> a1-16 sphere r))))
        (set! (-> v1-43 max z) (fmax (-> v1-43 max z) (+ (-> a1-16 sphere z) (-> a1-16 sphere r))))
        )
      )
    )
  0
  (none)
  )

(defmethod lookup-cell-by-position city-level-info ((obj city-level-info) (arg0 vector))
  (let ((s5-0 (new 'stack-no-clear 'vis-grid-pos)))
    (lookup-cell-for-point (-> obj grid-info) s5-0 arg0)
    (-> obj
        cell-array
        (+ (-> s5-0 x)
           (* (-> s5-0 z) (-> obj grid-info dimension-array 0))
           (* (* (-> s5-0 y) (-> obj grid-info dimension-array 0)) (-> obj grid-info dimension-array 2))
           )
        )
    )
  )

(defmethod init-vis-ray city-level-info ((obj city-level-info) (arg0 vis-ray) (arg1 vector) (arg2 vector))
  (set! (-> arg0 pos quad) (-> arg1 quad))
  (set! (-> arg0 dest-pos quad) (-> arg2 quad))
  (let ((v1-2 (new 'stack-no-clear 'vector)))
    (vector-! v1-2 arg2 arg1)
    (set! (-> arg0 len) (vector-length v1-2))
    (let ((a0-9 (-> arg0 dir))
          (f0-1 (-> arg0 len))
          )
      (vector-float*! a0-9 v1-2 (/ 1.0 f0-1))
      )
    )
  (lookup-cell-for-point (-> obj grid-info) (-> arg0 grid-pos) arg1)
  (set! (-> arg0 cell) (lookup-cell-by-position obj arg1))
  0
  (none)
  )

(defmethod city-level-info-method-11 city-level-info ((obj city-level-info) (arg0 vis-ray))
  (local-vars (a3-3 int))
  (let ((f0-0 (-> arg0 len))
        (s4-0 -1)
        )
    (dotimes (v1-0 2)
      (let ((a0-1 (* v1-0 2))
            (a1-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-1 quad) (the-as uint128 0))
        (set! (-> a1-1 data a0-1) -1.0)
        (let ((f1-1 (-> obj grid-info box min data a0-1))
              (a2-6 1)
              )
          (let ((a3-2 (-> arg0 dir data a0-1)))
            (shift-arith-right-32 a3-3 a3-2 31)
            )
          (set! (-> a1-1 w)
                (+ f1-1
                   (* (the float (+ (- a2-6 (logand a3-3 1)) (-> (the-as (pointer int8) (+ a0-1 (the-as int arg0))) 64)))
                      (-> obj grid-info cell-size data a0-1)
                      )
                   )
                )
          )
        (when (!= (-> arg0 dir data a0-1) 0.0)
          (let ((f1-6 (/ (- (-> a1-1 w) (-> arg0 pos data a0-1)) (-> arg0 dir data a0-1))))
            (when (< f1-6 f0-0)
              (set! f0-0 f1-6)
              (set! s4-0 a0-1)
              (set! (-> arg0 plane quad) (-> a1-1 quad))
              )
            )
          )
        )
      )
    (cond
      ((= s4-0 -1)
       (set! (-> arg0 pos quad) (-> arg0 dest-pos quad))
       (set! (-> arg0 len) 0.0)
       )
      (else
        (vector+float*! (-> arg0 pos) (-> arg0 pos) (-> arg0 dir) f0-0)
        (set! (-> arg0 len) (vector-vector-distance (-> arg0 pos) (-> arg0 dest-pos)))
        (+! (-> arg0 grid-pos data s4-0) (if (>= (-> arg0 dir data s4-0) 0.0)
                                             1
                                             -1
                                             )
            )
        (let ((a1-4 (-> arg0 grid-pos)))
          (set! (-> arg0 cell)
                (-> obj
                    cell-array
                    (+ (-> a1-4 x)
                       (* (-> a1-4 z) (-> obj grid-info dimension-array 0))
                       (* (* (-> a1-4 y) (-> obj grid-info dimension-array 0)) (-> obj grid-info dimension-array 2))
                       )
                    )
                )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod city-level-info-method-12 city-level-info ((obj city-level-info) (arg0 vector) (arg1 nav-branch) (arg2 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s2-0 (-> arg1 dest-node))
          (s3-0 #t)
          (s5-0 (new 'stack-no-clear 'inline-array 'vector 7))
          )
      (let ((a1-1 s2-0)
            (v1-0 (-> s5-0 2))
            )
        (set! (-> v1-0 quad) (-> a1-1 position quad))
        (set! (-> v1-0 w) 1.0)
        )
      (let ((v1-1 s2-0)
            (s1-0 (-> s5-0 3))
            )
        (let ((f0-2 (the float (-> v1-1 angle)))
              (s0-0 (new 'stack-no-clear 'vector))
              )
          (sincos! s0-0 f0-2)
          (set! (-> s1-0 x) (-> s0-0 y))
          (set! (-> s1-0 y) 0.0)
          (set! (-> s1-0 z) (- (-> s0-0 x)))
          )
        (set! (-> s1-0 w) 1.0)
        )
      (vector-! (-> s5-0 5) (-> s5-0 2) arg0)
      (set! (-> s5-0 4 quad) (-> s5-0 3 quad))
      (set! (-> s5-0 4 x) (-> s5-0 3 z))
      (set! (-> s5-0 4 z) (- (-> s5-0 3 x)))
      (when (< 0.0 (vector-dot (-> s5-0 5) (-> s5-0 4)))
        (set! s3-0 #f)
        (vector-float*! (-> s5-0 4) (-> s5-0 4) -1.0)
        )
      (let ((a1-8 (-> s5-0 6)))
        (let ((v1-12 (-> s5-0 2)))
          (let ((a0-9 (-> s5-0 4)))
            (let* ((a2-1 s2-0)
                   (a2-4 (* 1024.0 (the float (-> a2-1 radius))))
                   )
              (.mov vf7 a2-4)
              )
            (.lvf vf5 (&-> a0-9 quad))
            )
          (.lvf vf4 (&-> v1-12 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> a1-8 quad) vf6)
        )
      (set! (-> s5-0 6 w) (* 1024.0 (the float (-> s2-0 radius))))
      (vector-! (-> s5-0 0) (-> s5-0 6) arg0)
      (set! (-> s5-0 0 y) 0.0)
      (let* ((v1-17 (-> s5-0 0))
             (f30-0 (sqrtf (+ (* (-> v1-17 x) (-> v1-17 x)) (* (-> v1-17 z) (-> v1-17 z)))))
             (f28-0 (-> s5-0 6 w))
             )
        (vector-xz-normalize! (-> s5-0 0) 1.0)
        (set! (-> s5-0 1 x) (-> s5-0 0 z))
        (set! (-> s5-0 1 y) 0.0)
        (set! (-> s5-0 1 z) (- (-> s5-0 0 x)))
        (if s3-0
            (vector-float*! (-> s5-0 1) (-> s5-0 1) -1.0)
            )
        (let* ((f0-29 f30-0)
               (f0-31 (* f0-29 f0-29))
               (f1-9 f28-0)
               (f1-12 (sqrtf (fabs (- f0-31 (* f1-9 f1-9)))))
               (f0-35 (/ (* f28-0 f1-12) f30-0))
               )
          (let ((f1-15 (/ (* f1-12 f1-12) f30-0)))
            (set! (-> arg2 quad) (-> arg0 quad))
            (let ((a1-13 arg2))
              (let ((v1-26 arg2))
                (let ((a0-14 (-> s5-0 0)))
                  (let ((a2-5 f1-15))
                    (.mov vf7 a2-5)
                    )
                  (.lvf vf5 (&-> a0-14 quad))
                  )
                (.lvf vf4 (&-> v1-26 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-13 quad) vf6)
              )
            )
          (let ((a1-14 arg2))
            (let ((v1-27 arg2))
              (let ((a0-15 (-> s5-0 1)))
                (let ((a2-6 f0-35))
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-15 quad))
                )
              (.lvf vf4 (&-> v1-27 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-14 quad) vf6)
            )
          )
        )
      (set! (-> arg2 y) (-> s5-0 2 y))
      )
    arg2
    )
  )

(defmethod city-level-info-method-18 city-level-info ((obj city-level-info))
  (local-vars (sv-48 int))
  (let ((gp-0 (new 'stack-no-clear 'bounding-box))
        (s5-0 (-> obj nav-graph))
        )
    (set! sv-48 (-> s5-0 node-count))
    (dotimes (s4-0 sv-48)
      (let ((s3-0 (-> s5-0 node-array s4-0)))
        (set-id-and-link-branches-back s3-0 (the-as uint s4-0))
        (let ((a1-1 s3-0)
              (v1-4 (-> gp-0 min))
              )
          (set! (-> v1-4 quad) (-> a1-1 position quad))
          (set! (-> v1-4 w) 1.0)
          )
        (dotimes (s2-0 (-> s3-0 branch-count))
          (let ((s1-0 (-> s3-0 branch-array s2-0)))
            (let ((a1-4 (-> s1-0 dest-node))
                  (v1-6 (-> gp-0 max))
                  )
              (set! (-> v1-6 quad) (-> a1-4 position quad))
              (set! (-> v1-6 w) 1.0)
              )
            (set! (-> s1-0 max-user-count)
                  (the-as uint (max 1 (the int (/ (vector-vector-distance (-> gp-0 min) (-> gp-0 max))
                                                  (if (logtest? (-> s3-0 flags) (nav-node-flag-byte pedestrian))
                                                      24576.0
                                                      49152.0
                                                      )
                                                  )
                                           )
                                    )
                          )
                  )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs symbol.
(defmethod city-level-info-method-9 city-level-info ((obj city-level-info))
  (local-vars
    (sv-96 (inline-array nav-node))
    (sv-100 int)
    (sv-104 vis-ray)
    (sv-112 int)
    (sv-160 nav-node)
    (sv-164 vector)
    (sv-168 vector)
    (sv-172 vis-cell)
    (sv-176 int)
    (sv-184 nav-branch)
    (sv-240 nav-node)
    (sv-244 vector)
    (sv-248 vector)
    (sv-252 vector)
    (sv-256 nav-segment)
    (sv-260 vis-cell)
    (sv-264 int)
    )
  (set! (-> obj cell-count)
        (the-as uint (* (* (-> obj grid-info dimension-array 0) (-> obj grid-info dimension-array 1))
                        (-> obj grid-info dimension-array 2)
                        )
                )
        )
  (let ((s5-0 (-> obj cell-count)))
    (dotimes (s4-0 (the-as int s5-0))
      (reset-segment-counts (-> obj cell-array s4-0))
      )
    (when (< 0.01 (-> obj grid-info axis-scale 0))
      (format 0 "segments not generates~%")
      (return (the-as symbol #t))
      )
    (set! sv-96 (-> obj nav-graph node-array))
    (set! sv-100 (-> obj nav-graph node-count))
    (set! sv-104 (new 'stack-no-clear 'vis-ray))
    (set! sv-112 0)
    (dotimes (s4-1 sv-100)
      (let ((s3-0 (-> sv-96 s4-1)))
        (dotimes (s2-0 (-> s3-0 branch-count))
          (let* ((a2-0 (-> s3-0 branch-array s2-0))
                 (f0-1 0.0)
                 (v1-19 a2-0)
                 )
            (when (< f0-1 (* 0.0078125 (the float (-> v1-19 density))))
              (set! sv-160 (-> a2-0 dest-node))
              (set! sv-164 (new 'stack-no-clear 'vector))
              (set! sv-168 (new 'stack-no-clear 'vector))
              (set! sv-172 (the-as vis-cell #f))
              (set! sv-176 0)
              (let ((a1-1 s3-0)
                    (v1-26 sv-168)
                    )
                (set! (-> v1-26 quad) (-> a1-1 position quad))
                (set! (-> v1-26 w) 1.0)
                )
              (cond
                ((logtest? (-> s3-0 flags) (nav-node-flag-byte pedestrian))
                 (let ((a1-4 (-> a2-0 dest-node))
                       (v1-29 sv-164)
                       )
                   (set! (-> v1-29 quad) (-> a1-4 position quad))
                   (set! (-> v1-29 w) 1.0)
                   )
                 )
                (else
                  (city-level-info-method-12 obj sv-168 a2-0 sv-164)
                  )
                )
              (init-vis-ray obj sv-104 sv-168 sv-164)
              (while (< 0.0 (-> sv-104 len))
                (set! sv-172 (-> sv-104 cell))
                (city-level-info-method-11 obj sv-104)
                (+! (-> sv-172 segment-count) 1)
                (set! sv-112 (+ sv-112 1))
                (if (> sv-176 0)
                    (+! (-> sv-172 incoming-segment-count) 1)
                    )
                (set! sv-176 (+ sv-176 1))
                )
              )
            )
          )
        )
      )
    (format 0 "~d segments were generated~%" sv-112)
    (set! (-> obj segment-array) (the-as (inline-array nav-segment) (malloc 'debug (* 48 sv-112))))
    (let ((v1-59 0))
      (dotimes (a0-20 (the-as int s5-0))
        (let ((a1-14 (-> obj cell-array a0-20)))
          (set! (-> a1-14 id) (the-as uint a0-20))
          (set! (-> a1-14 segment-array) (the-as (inline-array nav-segment) #f))
          (when (> (-> a1-14 segment-count) 0)
            (set! (-> a1-14 segment-array) (the-as (inline-array nav-segment) (-> obj segment-array v1-59)))
            (dotimes (a2-8 (-> a1-14 segment-count))
              (let ((a3-5 (-> a1-14 segment-array a2-8)))
                (set! (-> a3-5 id) (the-as uint v1-59))
                (set! (-> a3-5 cell-id) (the-as uint #xffff))
                )
              (+! v1-59 1)
              )
            )
          (set! (-> a1-14 flags) (the-as vis-cell-flag (-> a1-14 segment-count)))
          (set! (-> a1-14 segment-count) 0)
          (set! (-> a1-14 incoming-segment-count) 0)
          )
        0
        )
      (set! (-> obj segment-count) v1-59)
      )
    )
  (dotimes (s5-1 sv-100)
    (let ((s4-2 (-> sv-96 s5-1)))
      (dotimes (s3-1 (-> s4-2 branch-count))
        (set! sv-184 (-> s4-2 branch-array s3-1))
        (let ((f0-5 0.0)
              (v1-63 sv-184)
              )
          (when (< f0-5 (* 0.0078125 (the float (-> v1-63 density))))
            (set! sv-240 (-> sv-184 dest-node))
            (set! sv-244 (new 'stack-no-clear 'vector))
            (set! sv-248 (new 'stack-no-clear 'vector))
            (set! sv-252 (new 'stack-no-clear 'vector))
            (set! sv-256 (the-as nav-segment #f))
            (set! sv-260 (the-as vis-cell #f))
            (set! sv-264 0)
            (let ((a1-16 s4-2)
                  (v1-72 sv-244)
                  )
              (set! (-> v1-72 quad) (-> a1-16 position quad))
              (set! (-> v1-72 w) 1.0)
              )
            (cond
              ((logtest? (-> s4-2 flags) (nav-node-flag-byte pedestrian))
               (let ((a1-19 (-> sv-184 dest-node))
                     (v1-76 sv-252)
                     )
                 (set! (-> v1-76 quad) (-> a1-19 position quad))
                 (set! (-> v1-76 w) 1.0)
                 )
               )
              (else
                (city-level-info-method-12 obj sv-244 sv-184 sv-252)
                )
              )
            (init-vis-ray obj sv-104 sv-244 sv-252)
            (while (< 0.0 (-> sv-104 len))
              (set! (-> sv-248 quad) (-> sv-104 pos quad))
              (set! sv-260 (-> sv-104 cell))
              (city-level-info-method-11 obj sv-104)
              (let ((a2-14 (-> sv-260 incoming-segment-count)))
                (if (zero? sv-264)
                    (set! a2-14
                          (+ (- -1 (-> sv-260 segment-count)) (-> sv-260 incoming-segment-count) (-> sv-260 alloc-segment-count))
                          )
                    )
                (when (or (< a2-14 0) (>= a2-14 (-> sv-260 alloc-segment-count)))
                  (format
                    0
                    "******************************************************** bad i-seg ~d ************************************************~%"
                    a2-14
                    )
                  (return (the-as symbol #f))
                  )
                (let ((s2-1 (-> sv-260 segment-array a2-14)))
                  (set! (-> s2-1 vertex 0 quad) (-> sv-248 quad))
                  (set! (-> s2-1 vertex 1 quad) (-> sv-104 pos quad))
                  (set! (-> s2-1 length) (vector-vector-distance (the-as vector (-> s2-1 vertex)) (-> s2-1 vertex 1)))
                  (let* ((f0-9 (if (logtest? (-> s4-2 flags) (nav-node-flag-byte pedestrian))
                                   24576.0
                                   49152.0
                                   )
                               )
                         (f1-8 -1.0)
                         (f2-4 0.0001)
                         (v1-107 sv-184)
                         (f2-5 (fmax f2-4 (* 0.0078125 (the float (-> v1-107 density)))))
                         )
                    (set! (-> s2-1 spawn-spacing) (* f0-9 (+ f1-8 (/ 1.0 f2-5))))
                    )
                  (set! (-> s2-1 cell-id) (-> sv-260 id))
                  (set! (-> s2-1 branch) sv-184)
                  (set! (-> s2-1 from-cell-id) (the-as uint #xffff))
                  (set! (-> s2-1 nav-mesh-id) (-> s4-2 nav-mesh-id))
                  (set! (-> s2-1 tracker-id) 0)
                  (if (logtest? (-> s4-2 flags) (nav-node-flag-byte pedestrian))
                      (set! (-> s2-1 tracker-id) 1)
                      )
                  (if sv-256
                      (set! (-> s2-1 from-cell-id) (-> (the-as nav-segment sv-256) cell-id))
                      )
                  (set! sv-256 s2-1)
                  )
                )
              0
              (+! (-> sv-260 segment-count) 1)
              (if (> sv-264 0)
                  (+! (-> sv-260 incoming-segment-count) 1)
                  )
              (set! sv-264 (+ sv-264 1))
              )
            )
          )
        )
      )
    )
  (the-as symbol 0)
  )

(defmethod debug-check-proc-in-tracker traffic-engine ((obj traffic-engine) (arg0 process) (arg1 int))
  (let ((v1-3 (-> obj tracker-array arg1))
        (a0-3 (process->handle arg0))
        (a3-4 0)
        )
    (b! #t cfg-8 :delay (nop!))
    (label cfg-6)
    (b! (= (-> v1-3 active-object-list a3-4) a0-3) cfg-10 :delay (nop!))
    (+! a3-4 1)
    (label cfg-8)
    (b! (< a3-4 (the-as int (-> v1-3 active-object-count))) cfg-6)
    )
  (format #t "proc pid ~d (~a) not found in tracker ~d~%" (-> arg0 pid) arg0 arg1)
  (label cfg-10)
  0
  0
  (none)
  )
