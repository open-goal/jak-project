;;-*-Lisp-*-
(in-package goal)

;; name: vehicle-states.gc
;; name in dgo: vehicle-states
;; dgos: CWI

;; DECOMP BEGINS

;; WARN: Return type mismatch object vs none.
(defbehavior vehicle-event-handler vehicle ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (rigid-body-object-method-46 self (the-as process-drawable arg0) arg1 arg2 arg3)
  (none)
  )

(defstate idle (vehicle)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior vehicle) vehicle-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (rigid-body-object-method-39 self)
    (go-virtual waiting)
    (none)
    )
  :code (the-as (function none :behavior vehicle) sleep-code)
  :post (behavior ()
    (ja-post)
    (none)
    )
  )

(defstate inactive (vehicle)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('nav-mesh-kill 'traffic-activate 'traffic-off-force 'traffic-off 'rider-on 'rider-off)
       (rigid-body-object-method-46 self (the-as process-drawable proc) arg1 event-type event)
       )
      )
    )
  :enter (behavior ()
    (logior! (-> self focus-status) (focus-status disable inactive))
    (rigid-body-object-method-39 self)
    (rigid-body-object-method-41 self)
    (vehicle-method-88 self)
    (logior! (-> self draw status) (draw-control-status no-draw))
    (none)
    )
  :exit (behavior ()
    (rigid-body-object-method-40 self)
    (logclear! (-> self focus-status) (focus-status disable inactive))
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (none)
    )
  :code (the-as (function none :behavior vehicle) sleep-code)
  )

(defstate active (vehicle)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior vehicle) vehicle-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (vehicle-method-139 self)
    (set! (-> self flags) (logior (rigid-body-object-flag riding ai-driving) (-> self flags)))
    (vehicle-method-142 self)
    (set! (-> self flight-level-index) 1)
    (none)
    )
  :exit (behavior ()
    '()
    (none)
    )
  :trans (the-as (function none :behavior vehicle) #f)
  :code (the-as (function none :behavior vehicle) sleep-code)
  :post (behavior ()
    (check-player-get-on self)
    (vehicle-method-122 self)
    (none)
    )
  )

(defstate waiting (vehicle)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior vehicle) vehicle-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (vehicle-method-140 self)
    (set! (-> self flags) (the-as
                            rigid-body-object-flag
                            (logior (rigid-body-object-flag waiting-for-player nav-spheres) (-> self flags))
                            )
          )
    (logclear! (-> self flags) (rigid-body-object-flag riding player-driving))
    (set! (-> self controls throttle) 0.0)
    (set! (-> self controls brake) 0.0)
    (set! (-> self controls steering) 0.0)
    (vehicle-method-83 self)
    (update-transforms (-> self root-override-2))
    (vehicle-method-143 self)
    (let ((v1-15 (find-prim-by-id-logtest (-> self root-override-2) (the-as uint 32))))
      (when v1-15
        (set! (-> v1-15 prim-core collide-with) (collide-spec))
        (set! (-> v1-15 prim-core collide-as) (collide-spec))
        0
        )
      )
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (rigid-body-object-flag waiting-for-player))
    (let ((v1-3 (find-prim-by-id-logtest (-> self root-override-2) (the-as uint 32))))
      (when v1-3
        (set! (-> v1-3 prim-core collide-with) (collide-spec
                                                 backgnd
                                                 crate
                                                 civilian
                                                 enemy
                                                 obstacle
                                                 vehicle-sphere
                                                 hit-by-player-list
                                                 hit-by-others-list
                                                 collectable
                                                 pusher
                                                 )
              )
        (set! (-> v1-3 prim-core collide-as) (collide-spec vehicle-sphere))
        )
      )
    (none)
    )
  :trans (the-as (function none :behavior vehicle) #f)
  :code (the-as (function none :behavior vehicle) sleep-code)
  :post (behavior ()
    (vehicle-method-123 self)
    (none)
    )
  )

(defstate player-control (vehicle)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior vehicle) vehicle-event-handler)
  :enter (behavior ()
    (set-setting! 'sound-flava #f 31.0 5)
    (set! (-> self state-time) (current-time))
    (iterate-prims
      (-> self root-override-2)
      (lambda ((arg0 collide-shape-prim))
        (when (!= (-> arg0 prim-core prim-type) (prim-type mesh))
          (logior! (-> arg0 prim-core collide-as) (collide-spec jak))
          (logior! (-> arg0 prim-core collide-with) (collide-spec blocking-plane))
          )
        (none)
        )
      )
    (vehicle-method-139 self)
    (set! (-> self flags)
          (the-as
            rigid-body-object-flag
            (logior (rigid-body-object-flag riding player-driving nav-spheres) (-> self flags))
            )
          )
    (set! (-> self max-time-step) 0.02)
    (rigid-body-object-method-38 self)
    (vehicle-method-102 self)
    (vehicle-method-87 self)
    (set! (-> self root-override-2 penetrated-by)
          (logior (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot)
                  (-> self root-override-2 penetrated-by)
                  )
          )
    (set! (-> self damage-factor) (* 0.7518797 (-> self damage-factor)))
    0
    (none)
    )
  :exit (behavior ()
    (logclear!
      (-> self root-override-2 penetrated-by)
      (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot)
      )
    (when (not (logtest? (rigid-body-object-flag measure-control-parameters) (-> self flags)))
      (iterate-prims
        (-> self root-override-2)
        (lambda ((arg0 collide-shape-prim))
          (when (!= (-> arg0 prim-core prim-type) (prim-type mesh))
            (logclear! (-> arg0 prim-core collide-as) (collide-spec jak))
            (logclear! (-> arg0 prim-core collide-with) (collide-spec blocking-plane))
            )
          (none)
          )
        )
      (if (and (not (logtest? (-> self info-override flags) 256)) (= (send-event *target* 'query 'mode) 'pilot))
          (send-event *target* 'end-mode)
          )
      (set! (-> self controls throttle) 0.0)
      (set! (-> self controls steering) 0.0)
      (set! (-> self controls brake) 0.0)
      (set! (-> self controls lean-z) 0.0)
      (vehicle-method-83 self)
      (set! (-> self max-time-step) 0.033333335)
      (vehicle-method-88 self)
      )
    (set! (-> self damage-factor) (* 1.33 (-> self damage-factor)))
    (rigid-body-object-method-42 self)
    (logclear! (-> self flags) (rigid-body-object-flag player-driving))
    (remove-setting! 'sound-flava)
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.1))
      (if (not *target*)
          (go-virtual waiting)
          )
      (when (and (cpad-pressed? 0 triangle)
                 (not (logtest? (-> self info-override flags) 256))
                 (-> *setting-control* user-current pilot-exit)
                 (not (focus-test? *target* dead hit grabbed))
                 (!= (-> self crash-level) 3)
                 )
        (if (send-event *target* 'end-mode)
            (go-virtual waiting)
            )
        )
      )
    (none)
    )
  :code (the-as (function none :behavior vehicle) sleep-code)
  :post (behavior ()
    (local-vars (a0-3 int) (a0-5 int))
    (let* ((v1-1 (-> *perf-stats* data 18))
           (a0-0 (-> v1-1 ctrl))
           )
      (+! (-> v1-1 count) 1)
      (b! (zero? a0-0) cfg-2 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mtpc pcr0 0)
      (.mtpc pcr1 0)
      (.sync.l)
      (.sync.p)
      (.mtc0 Perf a0-0)
      )
    (.sync.l)
    (.sync.p)
    (label cfg-2)
    0
    (vehicle-method-124 self)
    (let ((v1-6 (-> *perf-stats* data 18)))
      (b! (zero? (-> v1-6 ctrl)) cfg-4 :delay (nop!))
      (.mtc0 Perf 0)
      (.sync.l)
      (.sync.p)
      (.mfpc a0-3 pcr0)
      (+! (-> v1-6 accum0) a0-3)
      (.mfpc a0-5 pcr1)
      (+! (-> v1-6 accum1) a0-5)
      )
    (label cfg-4)
    0
    (none)
    )
  )

(defstate crash (vehicle)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior vehicle) vehicle-event-handler)
  :enter (behavior ()
    (logclear! (-> self flags) (rigid-body-object-flag player-driving))
    (set! (-> self state-time) (current-time))
    (vehicle-method-129 self)
    (set! (-> self crash-level) 3)
    (vehicle-method-88 self)
    (dotimes (gp-0 (-> self info-override seat-count))
      (send-event (handle->process (-> self rider-array gp-0)) 'vehicle-crash)
      )
    (none)
    )
  :trans (behavior ()
    (set! (-> self hit-points) (- (-> self hit-points) (* 0.5 (-> self clock seconds-per-frame))))
    (if (and (>= (- (current-time) (-> self state-time)) 1) (< (-> self hit-points) -0.25))
        (go-virtual explode)
        )
    (none)
    )
  :code (the-as (function none :behavior vehicle) sleep-code)
  :post (behavior ()
    (vehicle-method-121 self)
    (none)
    )
  )

(defbehavior vehicle-explode-post vehicle ()
  (local-vars (v1-48 float) (v1-53 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (set! (-> self camera-dist2) (vector-vector-distance-squared (-> self root-override-2 trans) (camera-pos)))
    (set! (-> self player-dist2) (vector-vector-distance-squared (-> self root-override-2 trans) (target-pos 0)))
    (cond
      ((logtest? (-> self draw status) (draw-control-status on-screen))
       (set! (-> self state-time) (current-time))
       )
      (else
        (if (or (>= (- (current-time) (-> self state-time)) (seconds 5)) (let ((f0-2 409600.0))
                                                                           (< (* f0-2 f0-2) (-> self camera-dist2))
                                                                           )
                )
            (go-virtual die)
            )
        )
      )
    (let ((f0-5 819200.0))
      (if (< (* f0-5 f0-5) (-> self camera-dist2))
          (go-virtual die)
          )
      )
    (cond
      ((logtest? (-> self rbody state flags) (rigid-body-flag enable-physics))
       (let ((gp-2 (new 'stack-no-clear 'rigid-body-info)))
         (mem-copy! (&-> gp-2 mass) (the-as pointer (-> self info-override info)) 188)
         (set! (-> self rbody state info) (the-as rigid-body-info (&-> gp-2 mass)))
         (set! (-> gp-2 bounce-mult-factor) 0.0)
         (set! (-> gp-2 bounce-factor) 0.4)
         (set! (-> gp-2 linear-damping) 0.99)
         (set! (-> gp-2 angular-damping) 0.97)
         (set! (-> gp-2 friction-factor) 0.05)
         )
       (vehicle-method-121 self)
       (set! (-> self rbody state info) (-> self info-override info))
       (when (logtest? (-> self flags) (rigid-body-object-flag disturbed))
         (let* ((f0-14 (* 0.0033333334 (the float (- (current-time) (-> self disturbed-time)))))
                (f0-17 (* f0-14 f0-14 (-> self camera-dist2)))
                (f1-5 0.000016276043)
                (f0-18 (* f0-17 (* f1-5 f1-5)))
                )
           (.lvf vf1 (&-> (-> self rbody state ang-velocity) quad))
           (.add.w.vf vf2 vf0 vf0 :mask #b1)
           (.mul.vf vf1 vf1 vf1)
           (.mul.x.vf acc vf2 vf1 :mask #b1)
           (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
           (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
           (.mov v1-48 vf1)
           (if (and (< v1-48 f0-18) (begin
                                      (.lvf vf1 (&-> (-> self rbody state lin-velocity) quad))
                                      (.add.w.vf vf2 vf0 vf0 :mask #b1)
                                      (.mul.vf vf1 vf1 vf1)
                                      (.mul.x.vf acc vf2 vf1 :mask #b1)
                                      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                                      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                                      (.mov v1-53 vf1)
                                      (let ((f1-9 v1-53)
                                            (f2-0 614.4)
                                            )
                                        (< f1-9 (* f0-18 (* f2-0 f2-0)))
                                        )
                                      )
                    )
               (logclear! (-> self flags) (rigid-body-object-flag disturbed))
               )
           )
         )
       (when (not (vehicle-method-105 self))
         (rigid-body-object-method-39 self)
         (let ((gp-3 (-> self rbody)))
           (logclear! (-> gp-3 state flags) (rigid-body-flag enable-physics))
           (clear-momentum! (-> gp-3 state))
           (let ((v1-69 (-> gp-3 state)))
             (set! (-> v1-69 force quad) (the-as uint128 0))
             (set! (-> v1-69 torque quad) (the-as uint128 0))
             )
           )
         0
         (set! (-> self flags)
               (the-as rigid-body-object-flag (logior (rigid-body-object-flag nav-spheres) (-> self flags)))
               )
         (vehicle-method-143 self)
         )
       )
      (else
        (vehicle-method-120 self)
        )
      )
    0
    (none)
    )
  )

(defstate explode (vehicle)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior vehicle) vehicle-event-handler)
  :enter (behavior ()
    (rlet ((vf0 :class vf))
      (init-vf0-vector)
      (let ((a0-0 (-> self draw color-mult)))
        (vector-float*! (the-as vector a0-0) (the-as vector a0-0) 0.25)
        )
      (let ((gp-0 (-> self child)))
        (while gp-0
          (send-event (ppointer->process gp-0) 'traffic-off)
          (set! gp-0 (-> gp-0 0 brother))
          )
        )
      (dotimes (gp-1 (-> self info-override seat-count))
        (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-2 from) (process->ppointer self))
          (set! (-> a1-2 num-params) 2)
          (set! (-> a1-2 message) 'attack-invinc)
          (set! (-> a1-2 param 0) (the-as uint #f))
          (let ((v1-14 (new 'static 'attack-info :mask (attack-info-mask mode id))))
            (let* ((a0-4 *game-info*)
                   (a2-1 (+ (-> a0-4 attack-id) 1))
                   )
              (set! (-> a0-4 attack-id) a2-1)
              (set! (-> v1-14 id) a2-1)
              )
            (set! (-> v1-14 mode) 'big-explosion)
            (set! (-> a1-2 param 1) (the-as uint v1-14))
            )
          (send-event-function (handle->process (-> self rider-array gp-1)) a1-2)
          )
        (put-rider-in-seat self gp-1 (the-as process-focusable #f))
        )
      (logior! (-> self focus-status) (focus-status dead))
      (set! (-> self crash-level) 3)
      (set! (-> self force-level) 3)
      (logclear! (-> self flags) (rigid-body-object-flag persistent player-driving))
      (sound-play-by-spec (static-sound-spec "vehicle-explode") (new-sound-id) (the-as vector #t))
      (sound-play-by-spec (static-sound-spec "vehicle-explo-b") (new-sound-id) (the-as vector #t))
      (rigid-body-object-method-42 self)
      (let ((s4-0 (new 'stack-no-clear 'vector))
            (s5-2 (new 'stack-no-clear 'vector))
            (gp-4 (-> self rbody))
            )
        (vector-reset! s4-0)
        (set! (-> s4-0 y) 163840.0)
        (dotimes (s3-0 3)
          (set! (-> s5-2 data s3-0) (* 4096.0 (+ -1.0 (* 2.0 (rand-vu)))))
          )
        (vector+! s5-2 s5-2 (-> gp-4 state position))
        (rigid-body-method-18 (-> gp-4 state) s5-2 s4-0)
        (let ((v1-48 gp-4)
              (f0-6 1.0)
              )
          (rigid-body-method-12 (-> v1-48 state) f0-6)
          )
        (rigid-body-method-13 (-> gp-4 state))
        )
      (vehicle-method-110 self)
      (vehicle-method-103 self)
      (let ((gp-5 (new 'stack-no-clear 'explosion-init-params)))
        (set! (-> gp-5 spawn-point quad) (-> self root-override-2 trans quad))
        (quaternion-copy! (-> gp-5 spawn-quat) (-> self root-override-2 quat))
        (set! (-> gp-5 radius) (+ 12288.0 (-> self root-override-2 root-prim local-sphere w)))
        (set! (-> gp-5 group) (-> *part-group-id-table* (-> self info-override explosion-part)))
        (set! (-> gp-5 collide-with)
              (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
              )
        (set! (-> gp-5 penetrate-using) (penetrate explode))
        (explosion-spawn (the-as process-drawable (ppointer->process (-> self parent))) explosion gp-5)
        )
      (let ((gp-6 (-> self info-override explosion)))
        (when gp-6
          (set! (-> gp-6 skel)
                (the-as skeleton-group (art-group-get-by-name *level* (-> gp-6 skel-name) (the-as (pointer uint32) #f)))
                )
          (let ((s5-3 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
            (set! (-> s5-3 duration) (seconds 4))
            (set! (-> s5-3 gravity) -327680.0)
            (set! (-> s5-3 rot-speed) 10.2)
            (set-vector! (-> s5-3 fountain-rand-transv-lo) -81920.0 61440.0 -81920.0 1.0)
            (set-vector! (-> s5-3 fountain-rand-transv-hi) 81920.0 131072.0 81920.0 1.0)
            (let ((v1-83 (process-spawn joint-exploder (-> gp-6 skel) (-> gp-6 anim) s5-3 gp-6 :to self)))
              (when v1-83
                (let ((v1-88 (-> (the-as joint-exploder (-> v1-83 0)) draw)))
                  (if v1-88
                      (.svf (&-> (-> v1-88 color-mult) quad) vf0)
                      )
                  )
                )
              )
            )
          )
        )
      (set! (-> self state-time) (current-time))
      (none)
      )
    )
  :code (the-as (function none :behavior vehicle) sleep-code)
  :post (behavior ()
    (vehicle-explode-post)
    (none)
    )
  )

(defstate die (vehicle)
  :virtual #t
  :code (behavior ()
    (cond
      ((logtest? (rigid-body-object-flag traffic-managed) (-> self flags))
       (send-event (ppointer->process (-> self parent)) 'child-killed)
       (vehicle-method-113 self)
       )
      (else
        (cleanup-for-death self)
        )
      )
    (none)
    )
  )

(defstate measure-control-parameters (vehicle)
  :virtual #t
  :enter (behavior ()
    '()
    (none)
    )
  :exit (behavior ()
    (set! (-> self flags)
          (the-as rigid-body-object-flag (logclear (-> self flags) (rigid-body-object-flag measure-control-parameters)))
          )
    (none)
    )
  :trans (behavior ()
    (if (cpad-pressed? 1 square)
        (vehicle-method-138 self)
        )
    (none)
    )
  :code (behavior ()
    (vehicle-method-138 self)
    (none)
    )
  :post (behavior ()
    (vehicle-method-121 self)
    (none)
    )
  )
