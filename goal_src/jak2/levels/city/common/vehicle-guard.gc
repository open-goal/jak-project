;;-*-Lisp-*-
(in-package goal)

;; name: vehicle-guard.gc
;; name in dgo: vehicle-guard
;; dgos: CWI

(deftype turret-unknown-stack-structure (structure)
  "TODO - sigh...another one that i cant seem to find a fit"
  ((vec-1 vector :inline :offset-assert 0)
   (vec-2 vector :inline :offset-assert 16)
   (vec-3 vector :inline :offset-assert 32)
   (vec-4 vector :inline :offset-assert 48)
   (vec-5 vector :inline :offset-assert 64)
   (vec-6 vector :inline :offset-assert 80)
   (vec-7 vector :inline :offset-assert 96)
   (mat-1 matrix :inline :offset-assert 112)
   (vec-8 vector :inline :offset-assert 176)
   (vec-9 vector :inline :offset-assert 192)
   (vec-10 vector :inline :offset-assert 208)
   (vec-11 vector :inline :offset-assert 224)
   (vec-12 vector :inline :offset-assert 240))
  )

(deftype turret-unknown-stack-structure2 (structure)
  "TODO - another one! this one has an entity, but also a matrix!?"
  ((proj-params projectile-init-by-other-params :inline :offset-assert 0)
   (mat-1 matrix :inline :offset-assert 96)
   (vec-1 vector :inline :offset-assert 160)
   (vec-2 vector :inline :offset-assert 176)
   )
)

;; +++turret-flag
(defenum turret-flag
    :bitfield #t
    :type uint8
    (firing 0)
    (aiming 1)
    (should-shoot 2)
    (targetting-laser 3)
    (display-marks 4)
    (no-rot-y-clamp 5)
    )
;; ---turret-flag

;; DECOMP BEGINS

(deftype turret-barrel-info (structure)
  ((local-pos vector :inline :offset-assert   0)
   (local-dir vector :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(deftype turret-control-info (structure)
  ((joint-index  int8                         :offset-assert   0)
   (barrel-count int8                         :offset-assert   1)
   (shot-speed   float                        :offset-assert   4)
   (attack-range float                        :offset-assert   8)
   (rot-min      float              2         :offset-assert  12)
   (rot-max      float              2         :offset-assert  20)
   (rot-x-min    float                        :offset         12)
   (rot-x-max    float                        :offset         20)
   (rot-y-min    float                        :offset         16)
   (rot-y-max    float                        :offset         24)
   (local-pos    vector             :inline   :offset-assert  32)
   (local-dir    vector             :inline   :offset-assert  48)
   (barrel-array turret-barrel-info 4 :inline :offset-assert  64)
   )
  :method-count-assert 9
  :size-assert         #xc0
  :flag-assert         #x9000000c0
  )


(deftype turret-control (structure)
  ((info                 turret-control-info           :offset-assert   0)
   (guard-settings       traffic-guard-type-settings   :offset-assert   4)
   (flags                turret-flag                   :offset-assert   8)
   (shot-count           int8                          :offset-assert   9)
   (burst-count          int16                         :offset-assert  10)
   (target-dist          float                         :offset-assert  12)
   (inaccuracy           float                         :offset-assert  16)
   (aim-offset-angle     degrees                       :offset-assert  20)
   (aim-rot              float                       2 :offset-assert  24)
   (aim-rot-vel          float                       2 :offset-assert  32)
   (aim-rot-offset       float                       2 :offset-assert  40)
   (aim-rot-x            float                         :offset         24)
   (aim-rot-y            float                         :offset         28)
   (aim-rot-vel-x        float                         :offset         32)
   (aim-rot-vel-y        float                         :offset         36)
   (target-in-sight-time time-frame                    :offset-assert  48)
   (aim-acquire-time     time-frame                    :offset-assert  56)
   (shoot-time           time-frame                    :offset-assert  64)
   (owner-handle         handle                        :offset-assert  72)
   )
  :pack-me
  :method-count-assert 18
  :size-assert         #x50
  :flag-assert         #x1200000050
  (:methods
    (turret-control-method-9 (_type_ vehicle vector vector) none 9)
    (turret-control-method-10 (_type_ vehicle) none 10)
    (turret-control-method-11 (_type_ object object vector) none 11)
    (update-joint-mod (_type_ joint-mod-rotate-local) none 12)
    (turret-control-method-13 (_type_) none 13)
    (turret-control-method-14 (_type_) none 14)
    (set-info (_type_ turret-control-info) none 15)
    (turret-control-method-16 (_type_ float float) none 16)
    (turret-control-method-17 (_type_ vehicle) none 17)
    )
  )


(defmethod set-info turret-control ((obj turret-control) (arg0 turret-control-info))
  (set! (-> obj info) arg0)
  (set! (-> obj owner-handle) (the-as handle #f))
  0
  (none)
  )

(defmethod update-joint-mod turret-control ((obj turret-control) (arg0 joint-mod-rotate-local))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 x) (- (-> obj aim-rot-x)))
    (set! (-> v1-0 y) (-> obj aim-rot-y))
    (set! (-> v1-0 z) 0.0)
    (quaternion-zxy! (-> arg0 rotation) v1-0)
    )
  0
  (none)
  )

(defmethod turret-control-method-13 turret-control ((obj turret-control))
  (let ((f30-0
          (/ (* 298261630.0 (-> obj inaccuracy) (-> obj guard-settings inaccuracy)) (fmax 40960.0 (-> obj target-dist)))
          )
        )
    (set! (-> obj aim-rot-offset 0) (* f30-0 (cos (-> obj aim-offset-angle))))
    (set! (-> obj aim-rot-offset 1) (* f30-0 (sin (-> obj aim-offset-angle))))
    )
  (+! (-> obj aim-offset-angle) (* 32768.0 (rand-vu)))
  0
  (none)
  )

(defmethod turret-control-method-14 turret-control ((obj turret-control))
  (logclear! (-> obj flags) (turret-flag firing aiming))
  (set! (-> obj burst-count) 0)
  (set! (-> obj aim-offset-angle) (* 65536.0 (rand-vu)))
  0
  (none)
  )

(defun vehicle-los-clear? ((arg0 vector) (arg1 vector))
  (let ((v1-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> v1-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> v1-0 move-dist) arg1 arg0)
    (let ((a0-1 v1-0))
      (set! (-> a0-1 radius) 2048.0)
      (set! (-> a0-1 collide-with) (collide-spec backgnd))
      (set! (-> a0-1 ignore-process0) #f)
      (set! (-> a0-1 ignore-process1) #f)
      (set! (-> a0-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> a0-1 action-mask) (collide-action solid))
      )
    (< (fill-and-probe-using-line-sphere *collide-cache* v1-0) 0.0)
    )
  )

(defun vehicle-draw-beam ((arg0 sparticle-launcher) (arg1 vector) (arg2 vector) (arg3 object) (arg4 symbol))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-2 (vector+! (new 'stack-no-clear 'vector) arg1 arg2)))
      (when (or (not arg4) (line-in-view-frustum? arg1 a1-2))
        (let ((s5-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'quaternion))
              )
          (if (get-field-spec-by-id arg0 (sp-field-id spt-scale-y))
              (set! (-> *beam-info* y-scale) (vector-length arg2))
              )
          (let ((a0-4 s5-0))
            (let ((v1-10 arg2))
              (let ((a1-5 0.5))
                (.mov vf7 a1-5)
                )
              (.lvf vf5 (&-> v1-10 quad))
              )
            (.lvf vf4 (&-> arg1 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-4 quad) vf6)
            )
          (forward-up->quaternion s4-0 arg2 (new 'static 'vector :y 1.0 :w 1.0))
          (dotimes (s3-1 3)
            (quaternion-rotate-local-z! s4-0 s4-0 10922.667)
            (quaternion-copy! *particle-quat* s4-0)
            (let ((t9-5 sp-launch-particles-var)
                  (a0-8 *sp-particle-system-3d*)
                  (a1-9 arg0)
                  (a2-3 *launch-matrix*)
                  )
              (set! (-> a2-3 trans quad) (-> s5-0 quad))
              (t9-5 a0-8 a1-9 a2-3 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defun vehicle-draw-laser-spot ((arg0 vector) (arg1 vector) (arg2 symbol))
  (vector+float*! (new 'stack-no-clear 'vector) arg0 arg1 -1638.4)
  (cond
    (arg2
      (let ((t9-0 sp-launch-particles-var)
            (a0-2 *sp-particle-system-2d*)
            (a1-1 (-> *part-id-table* 771))
            (a2-1 *launch-matrix*)
            )
        (set! (-> a2-1 trans quad) (-> arg0 quad))
        (t9-0 a0-2 a1-1 a2-1 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
        )
      (let ((t9-1 sp-launch-particles-var)
            (a0-3 *sp-particle-system-2d*)
            (a1-2 (-> *part-id-table* 770))
            (a2-2 *launch-matrix*)
            )
        (set! (-> a2-2 trans quad) (-> arg0 quad))
        (t9-1 a0-3 a1-2 a2-2 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
        )
      )
    (else
      (let ((t9-2 sp-launch-particles-var)
            (a0-4 *sp-particle-system-2d*)
            (a1-3 (-> *part-id-table* 772))
            (a2-3 *launch-matrix*)
            )
        (set! (-> a2-3 trans quad) (-> arg0 quad))
        (t9-2 a0-4 a1-3 a2-3 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
        )
      )
    )
  0
  (none)
  )

(defun vehicle-draw-laser ((arg0 vector) (arg1 vector))
  (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (camera-pos) arg0) 1.0)
  (set! (-> (new 'stack-no-clear 'vector) quad) (-> arg0 quad))
  (let ((s5-1 (-> *part-id-table* 769)))
    (get-field-spec-by-id s5-1 (sp-field-id spt-timer))
    (let* ((s4-3 (vector-! (new 'stack-no-clear 'vector) arg1 arg0))
           (f30-0 (vector-vector-distance (camera-pos) arg0))
           (s3-2 (get-field-spec-by-id s5-1 (sp-field-id spt-scale-x)))
           (f0-4 (cond
                   ((< f30-0 122.88)
                    0.0
                    )
                   ((< 65536.0 f30-0)
                    1.0
                    )
                   (else
                     (* 0.000015287453 (+ -122.88 f30-0))
                     )
                   )
                 )
           (f30-1 (-> s3-2 initial-valuef))
           (f28-0 (-> s3-2 random-rangef))
           )
      (set! (-> s3-2 initial-valuef) (* f30-1 f0-4))
      (set! (-> s3-2 random-rangef) (* f28-0 f0-4))
      (vehicle-draw-beam s5-1 arg0 s4-3 #f #t)
      (set! (-> s3-2 initial-valuef) f30-1)
      (set! (-> s3-2 random-rangef) f28-0)
      )
    )
  0
  (none)
  )

(defmethod turret-control-method-9 turret-control ((obj turret-control) (arg0 vehicle) (arg1 vector) (arg2 vector))
  (with-pp
    (let ((gp-0 (new 'stack-no-clear 'turret-unknown-stack-structure)))
      (set! (-> gp-0 vec-12 x) (-> pp clock seconds-per-frame))
      (let* ((v1-1 (-> gp-0 mat-1))
             (a3-1 (-> arg0 node-list data (-> obj info joint-index) bone transform))
             (a0-4 (-> a3-1 quad 0))
             (a1-4 (-> a3-1 quad 1))
             (a2-1 (-> a3-1 quad 2))
             (a3-2 (-> a3-1 trans quad))
             )
        (set! (-> v1-1 quad 0) a0-4)
        (set! (-> v1-1 quad 1) a1-4)
        (set! (-> v1-1 quad 2) a2-1)
        (set! (-> v1-1 trans quad) a3-2)
        )
      (set! (-> obj target-dist) (vector-vector-distance (-> gp-0 mat-1 trans) arg1))
      (let ((f0-3 (/ (-> obj target-dist) (-> obj info shot-speed))))
        (vector+float*! (-> gp-0 vec-1) arg1 arg2 f0-3)
        )
      (when (not (logtest? (-> obj flags) (turret-flag aiming)))
        (logior! (-> obj flags) (turret-flag aiming))
        (turret-control-method-13 obj)
        )
      (vector-matrix*! (-> gp-0 vec-6) (-> obj info local-pos) (-> gp-0 mat-1))
      (vector-! (-> gp-0 vec-5) (-> gp-0 vec-1) (-> gp-0 vec-6))
      (let* ((v1-14 (-> gp-0 mat-1))
             (a3-3 (-> arg0 node-list data 0 bone transform))
             (a0-11 (-> a3-3 quad 0))
             (a1-9 (-> a3-3 quad 1))
             (a2-3 (-> a3-3 quad 2))
             (a3-4 (-> a3-3 trans quad))
             )
        (set! (-> v1-14 quad 0) a0-11)
        (set! (-> v1-14 quad 1) a1-9)
        (set! (-> v1-14 quad 2) a2-3)
        (set! (-> v1-14 trans quad) a3-4)
        )
      (matrix-transpose! (the-as matrix (-> gp-0 vec-8)) (-> gp-0 mat-1))
      (vector-rotate*! (-> gp-0 vec-3) (-> gp-0 vec-5) (the-as matrix (-> gp-0 vec-8)))
      (set! (-> gp-0 vec-4 y) (atan (-> gp-0 vec-3 x) (-> gp-0 vec-3 z)))
      (let* ((v1-15 (-> gp-0 vec-3))
             (f0-11 (sqrtf (+ (* (-> v1-15 x) (-> v1-15 x)) (* (-> v1-15 z) (-> v1-15 z)))))
             )
        (set! (-> gp-0 vec-4 x) (atan (-> gp-0 vec-3 y) f0-11))
        )
      (+! (-> gp-0 vec-4 x) (-> obj aim-rot-offset 0))
      (+! (-> gp-0 vec-4 y) (-> obj aim-rot-offset 1))
      (dotimes (s3-1 2)
        (+! (-> obj aim-rot-vel s3-1)
            (* 5.0
               (- (* 8.0 (if (or (zero? s3-1) (not (logtest? (-> obj flags) (turret-flag no-rot-y-clamp))))
                             (- (-> gp-0 vec-4 data s3-1) (-> obj aim-rot s3-1))
                             (deg- (-> gp-0 vec-4 data s3-1) (-> obj aim-rot s3-1))
                             )
                     )
                  (-> obj aim-rot-vel s3-1)
                  )
               (-> gp-0 vec-12 x)
               )
            )
        (set! (-> obj aim-rot-vel s3-1) (* (-> obj aim-rot-vel s3-1) (fmax 0.0 (- 1.0 (* 0.1 (-> gp-0 vec-12 x))))))
        (+! (-> obj aim-rot s3-1) (* (-> obj aim-rot-vel s3-1) (-> gp-0 vec-12 x)))
        (when (or (zero? s3-1) (not (logtest? (-> obj flags) (turret-flag no-rot-y-clamp))))
          (let ((f0-31 (-> obj info rot-min s3-1)))
            (when (< (-> obj aim-rot s3-1) f0-31)
              (set! (-> obj aim-rot s3-1) f0-31)
              (set! (-> obj aim-rot-vel s3-1) 0.0)
              )
            )
          (let ((f0-33 (-> obj info rot-max s3-1)))
            (when (< f0-33 (-> obj aim-rot s3-1))
              (set! (-> obj aim-rot s3-1) f0-33)
              (set! (-> obj aim-rot-vel s3-1) 0.0)
              )
            )
          )
        )
      (logclear! (-> obj flags) (turret-flag should-shoot))
      (when (and (< (fabs (deg- (-> obj aim-rot-x) (-> gp-0 vec-4 x))) 2912.7112)
                 (< (fabs (deg- (-> obj aim-rot-y) (-> gp-0 vec-4 y))) 2912.7112)
                 (< (-> obj target-dist) (-> obj info attack-range))
                 )
        (logior! (-> obj flags) (turret-flag should-shoot))
        (when (logtest? (-> obj flags) (turret-flag targetting-laser))
          (let* ((v1-88 (-> gp-0 mat-1))
                 (a3-5 (-> arg0 node-list data (-> obj info joint-index) bone transform))
                 (a0-29 (-> a3-5 quad 0))
                 (a1-20 (-> a3-5 quad 1))
                 (a2-5 (-> a3-5 quad 2))
                 (a3-6 (-> a3-5 trans quad))
                 )
            (set! (-> v1-88 quad 0) a0-29)
            (set! (-> v1-88 quad 1) a1-20)
            (set! (-> v1-88 quad 2) a2-5)
            (set! (-> v1-88 trans quad) a3-6)
            )
          (set! (-> gp-0 vec-7 quad) (-> gp-0 mat-1 vector 2 quad))
          (let ((s3-2 (new 'stack-no-clear 'collide-query)))
            (set! (-> s3-2 start-pos quad) (-> gp-0 vec-6 quad))
            (vector-float*! (-> s3-2 move-dist) (-> gp-0 vec-7) (-> obj info attack-range))
            (let ((v1-93 s3-2))
              (set! (-> v1-93 radius) 409.6)
              (set! (-> v1-93 collide-with)
                    (collide-spec backgnd jak bot crate enemy obstacle hit-by-others-list player-list)
                    )
              (set! (-> v1-93 ignore-process0) arg0)
              (set! (-> v1-93 ignore-process1) #f)
              (set! (-> v1-93 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-93 action-mask) (collide-action solid))
              )
            (let ((f30-1 (fill-and-probe-using-line-sphere *collide-cache* s3-2))
                  (s5-1 #f)
                  )
              (cond
                ((< f30-1 0.0)
                 (vector+! (-> gp-0 vec-2) (-> s3-2 start-pos) (-> s3-2 move-dist))
                 )
                (else
                  (let* ((s4-1 (-> s3-2 best-other-tri collide-ptr))
                         (a0-43 (if (type? s4-1 collide-shape-prim)
                                    s4-1
                                    )
                                )
                         )
                    (if (and a0-43 (logtest? (-> (the-as collide-shape-prim a0-43) prim-core collide-as) (collide-spec jak)))
                        (set! s5-1 #t)
                        )
                    )
                  (vector+float*! (-> gp-0 vec-2) (-> s3-2 start-pos) (-> s3-2 move-dist) f30-1)
                  (vehicle-draw-laser-spot (-> gp-0 vec-2) (-> gp-0 vec-7) s5-1)
                  )
                )
              (when (not s5-1)
                )
              )
            )
          (let ((t9-13 vehicle-draw-laser)
                (a0-48 (-> gp-0 vec-6))
                (a1-27 (-> gp-0 vec-2))
                )
            (-> gp-0 vec-7)
            (t9-13 a0-48 a1-27)
            )
          )
        )
      )
    0
    (none)
    )
  )

(defmethod turret-control-method-10 turret-control ((obj turret-control) (arg0 vehicle))
  (cond
    ((logtest? (-> obj flags) (turret-flag should-shoot))
     (cond
       ((logtest? (-> obj flags) (turret-flag firing))
        (cond
          ((> (-> obj shot-count) 0)
           (if (>= (- (current-time) (-> obj shoot-time)) (the-as time-frame (-> obj guard-settings shot-delay)))
               (turret-control-method-17 obj arg0)
               )
           )
          (else
            (logclear! (-> obj flags) (turret-flag firing))
            (+! (-> obj burst-count) 1)
            (turret-control-method-13 obj)
            )
          )
        )
       (else
         (when (and (>= (- (current-time) (-> obj shoot-time)) (the-as time-frame (-> obj guard-settings burst-delay)))
                    (>= (- (current-time) (-> obj aim-acquire-time)) (the-as time-frame (-> obj guard-settings acquire-delay)))
                    )
           (set! (-> obj shot-count)
                 (+ (-> obj guard-settings shot-count) (rand-vu-int-count (+ (-> obj guard-settings rand-shot-count) 1)))
                 )
           (logior! (-> obj flags) (turret-flag firing))
           )
         )
       )
     )
    (else
      (set! (-> obj aim-acquire-time) (current-time))
      (turret-control-method-14 obj)
      )
    )
  0
  (none)
  )

(defmethod turret-control-method-11 turret-control ((obj turret-control) (arg0 object) (arg1 object) (arg2 vector))
  (when (nonzero? (-> obj info))
    (set! (-> obj inaccuracy) (* 0.000012207031 (+ 20480.0 (vector-length arg2))))
    (turret-control-method-9 obj (the-as vehicle arg0) (the-as vector arg1) arg2)
    (turret-control-method-10 obj (the-as vehicle arg0))
    )
  0
  (none)
  )

(defmethod turret-control-method-17 turret-control ((obj turret-control) (arg0 vehicle))
  (let ((s4-0 (new 'stack-no-clear 'turret-unknown-stack-structure2)))
    (set! (-> s4-0 proj-params ent) (-> arg0 entity))
    (set! (-> s4-0 proj-params charge) 1.0)
    (set! (-> s4-0 proj-params options) (projectile-options))
    (set! (-> s4-0 proj-params notify-handle) (process->handle arg0))
    (set! (-> s4-0 proj-params owner-handle) (process->handle (handle->process (-> obj owner-handle))))
    (set! (-> s4-0 proj-params ignore-handle) (process->handle arg0))
    (let* ((v1-14 *game-info*)
           (a0-16 (+ (-> v1-14 attack-id) 1))
           )
      (set! (-> v1-14 attack-id) a0-16)
      (set! (-> s4-0 proj-params attack-id) a0-16)
      )
    (set! (-> s4-0 proj-params timeout) (seconds 4))
    (let* ((v1-16 (-> s4-0 mat-1))
           (a3-0 (-> arg0 node-list data (-> obj info joint-index) bone transform))
           (a0-20 (-> a3-0 quad 0))
           (a1-6 (-> a3-0 quad 1))
           (a2-0 (-> a3-0 quad 2))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-16 quad 0) a0-20)
      (set! (-> v1-16 quad 1) a1-6)
      (set! (-> v1-16 quad 2) a2-0)
      (set! (-> v1-16 trans quad) a3-1)
      )
    (dotimes (s3-0 (-> obj info barrel-count))
      (vector-matrix*! (-> s4-0 vec-1) (the-as vector (-> obj info barrel-array s3-0)) (-> s4-0 mat-1))
      (set! (-> s4-0 vec-2 quad) (-> s4-0 mat-1 vector 2 quad))
      (set! (-> s4-0 proj-params pos quad) (-> s4-0 vec-1 quad))
      (vector-float*! (-> s4-0 proj-params vel) (-> s4-0 vec-2) (-> obj info shot-speed))
      (spawn-projectile guard-shot (-> s4-0 proj-params) arg0 *default-dead-pool*)
      )
    )
  (set! (-> obj shoot-time) (current-time))
  (+! (-> obj shot-count) -1)
  0
  (none)
  )

(defmethod turret-control-method-16 turret-control ((obj turret-control) (arg0 float) (arg1 float))
  (with-pp
    (let ((f0-0 (-> pp clock seconds-per-frame)))
      (set! (-> obj aim-rot-vel-x) arg1)
      (set! (-> obj aim-rot-vel-y) arg0)
      (dotimes (v1-1 2)
        (+! (-> obj aim-rot v1-1) (* f0-0 (-> obj aim-rot-vel v1-1)))
        (let ((f1-4 (-> obj info rot-min v1-1)))
          (when (< (-> obj aim-rot v1-1) f1-4)
            (set! (-> obj aim-rot v1-1) f1-4)
            (set! (-> obj aim-rot-vel v1-1) 0.0)
            )
          )
        (let ((f1-6 (-> obj info rot-max v1-1)))
          (when (< f1-6 (-> obj aim-rot v1-1))
            (set! (-> obj aim-rot v1-1) f1-6)
            (set! (-> obj aim-rot-vel v1-1) 0.0)
            )
          )
        )
      )
    0
    (none)
    )
  )

(deftype vehicle-guard-target-data (structure)
  ((tpos          vector :inline :offset-assert   0)
   (spos          vector :inline :offset-assert  16)
   (tvel          vector :inline :offset-assert  32)
   (svel          vector :inline :offset-assert  48)
   (tdir          vector :inline :offset-assert  64)
   (sdir          vector :inline :offset-assert  80)
   (to-target     vector :inline :offset-assert  96)
   (to-target-dir vector :inline :offset-assert 112)
   (temp          vector :inline :offset-assert 128)
   (target        target         :offset-assert 144)
   (dist          float          :offset-assert 148)
   (inv-dist      float          :offset-assert 152)
   (attack-range  float          :offset-assert 156)
   )
  :method-count-assert 9
  :size-assert         #xa0
  :flag-assert         #x9000000a0
  )


(deftype vehicle-guard (vehicle)
  ((ai-hook                      (function vehicle-guard none)         :offset-assert 880)
   (turret                       turret-control                :inline :offset-assert 888)
   (target-flags                 turret-flag                           :offset-assert 968)
   (target-in-sight-time         time-frame                            :offset-assert 976)
   (minimap                      connection-minimap                    :offset-assert 984)
   (vehicle-guard-pad-k1jn23k1   uint32                                :offset-assert 988)
   (traffic-target-status        traffic-target-status                 :offset-assert 992)
   (pursuit-target               handle                                :offset-assert 1000)
   (vehicle-guard-pad-1kjh2nb3k1 uint32                        16      :offset-assert 1008)
   (lod2                         symbol                                :offset-assert 1072)
   )
  :heap-base #x3c0
  :method-count-assert 159
  :size-assert         #x434
  :flag-assert         #x9f03c00434
  (:methods
    (hostile () _type_ :state 144)
    (stop-and-shoot () _type_ :state 145)
    (slow-pursuit () _type_ :state 146)
    (vehicle-guard-method-147 () none 147)
    (vehicle-guard-method-148 () none 148)
    (waiting-ambush () _type_ :state 149)
    (vehicle-guard-method-150 (_type_) none 150)
    (vehicle-guard-method-151 (_type_ vehicle-guard-target-data) none 151)
    (vehicle-guard-method-152 (_type_ vehicle-guard-target-data) none 152)
    (vehicle-guard-method-153 (_type_ target) none 153)
    (vehicle-guard-method-154 (_type_) none 154)
    (vehicle-guard-method-155 (_type_ vector vector) none 155)
    (vehicle-guard-method-156 (_type_) none 156)
    (vehicle-guard-method-157 (_type_ vehicle-guard-target-data) symbol 157)
    (vehicle-guard-method-158 (_type_) none 158)
    )
  )


(defmethod vehicle-guard-method-153 vehicle-guard ((obj vehicle-guard) (arg0 target))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (set! (-> s5-0 quad) (-> (get-trans arg0 3) quad))
    (turret-control-method-11 (-> obj turret) obj s5-0 (-> arg0 control transv))
    )
  0
  (none)
  )

(defmethod vehicle-guard-method-151 vehicle-guard ((obj vehicle-guard) (arg0 vehicle-guard-target-data))
  (let ((s5-0 (handle->process (-> obj pursuit-target))))
    (set! (-> arg0 target) (the-as target s5-0))
    (when s5-0
      (set! (-> arg0 tpos quad) (-> (the-as process-drawable s5-0) root trans quad))
      (set! (-> arg0 spos quad) (-> obj root-override-2 trans quad))
      (set! (-> arg0 tvel quad) (-> (the-as process-drawable s5-0) root transv quad))
      (set! (-> arg0 svel quad) (-> obj root-override-2 transv quad))
      (vector-normalize-copy! (-> arg0 tdir) (-> arg0 tvel) 1.0)
      (vector-normalize-copy! (-> arg0 sdir) (-> arg0 svel) 1.0)
      (set! (-> arg0 tpos y) (+ 4096.0 (-> arg0 tpos y)))
      (vector-! (-> arg0 to-target) (-> arg0 tpos) (-> arg0 spos))
      (let* ((f0-2 (vector-length (-> arg0 to-target)))
             (f1-2 (/ 1.0 f0-2))
             )
        (set! (-> arg0 dist) f0-2)
        (set! (-> arg0 inv-dist) f1-2)
        (vector-float*! (-> arg0 to-target-dir) (-> arg0 to-target) f1-2)
        )
      (let ((f0-3 204800.0))
        (if (focus-test? (the-as process-focusable s5-0) pilot)
            (set! f0-3 (+ 102400.0 f0-3))
            )
        (set! (-> arg0 attack-range) f0-3)
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-guard-method-152 vehicle-guard ((obj vehicle-guard) (arg0 vehicle-guard-target-data))
  (let ((s4-0 (handle->process (-> obj pursuit-target))))
    (cond
      ((logtest? (rigid-body-object-flag target-in-sight) (-> obj flags))
       (logclear! (-> obj controller flags) (vehicle-controller-flag direct-mode))
       (when (>= (- (vector-dot (-> arg0 to-target-dir) (-> arg0 tdir))) (cos 21845.334))
         (logior! (-> obj controller flags) (vehicle-controller-flag direct-mode))
         (vector-! (-> arg0 temp) (-> arg0 svel) (-> arg0 tvel))
         (let* ((f2-0 (vector-dot (-> arg0 temp) (-> arg0 to-target-dir)))
                (f0-5 (fmax 0.0 (fmin 1.0 (/ (-> arg0 dist) (fmax 4096.0 f2-0)))))
                )
           (vector+float*! (-> arg0 tpos) (-> arg0 tpos) (-> arg0 tvel) f0-5)
           (cond
             ((or (< f0-5 0.05) (vehicle-los-clear? (-> arg0 tpos) (-> arg0 spos)))
              (vector-! (-> arg0 to-target) (-> arg0 tpos) (-> arg0 spos))
              (vector-normalize-copy! (-> arg0 to-target-dir) (-> arg0 to-target) 1.0)
              (vector-float*! (-> arg0 tvel) (-> arg0 tvel) -1.0)
              )
             (else
               (set! (-> arg0 tpos quad) (-> (the-as process-drawable s4-0) root trans quad))
               )
             )
           )
         )
       (vehicle-controller-method-19 (-> obj controller) (-> arg0 spos) #x43cccccd (-> arg0 tpos) (-> arg0 tvel))
       (vector-! (-> arg0 to-target) (-> obj controller target-point) (-> arg0 spos))
       (vector-normalize-copy! (-> arg0 to-target-dir) (-> arg0 to-target) 1.0)
       (cond
         ((< -12288.0 (- (-> arg0 tpos y) (-> arg0 spos y)))
          (logior! (-> obj controller flags) (vehicle-controller-flag ignore-others no-slowing-for-turns))
          (let* ((f0-9 (* 2.0 (-> obj info-override max-xz-speed)))
                 (f1-8 (fmax 0.0 (vector-dot (-> arg0 sdir) (-> arg0 to-target-dir))))
                 (f0-10 (* f0-9 (* f1-8 f1-8)))
                 )
            (+! (-> obj controller target-speed) f0-10)
            )
          )
         (else
           (logclear! (-> obj controller flags) (vehicle-controller-flag ignore-others no-slowing-for-turns))
           (let ((f0-13 (* (-> obj info-override max-xz-speed) (fmax 0.0 (vector-dot (-> arg0 sdir) (-> arg0 to-target-dir)))))
                 )
             (+! (-> obj controller target-speed) f0-13)
             )
           )
         )
       )
      (else
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-guard-method-150 vehicle-guard ((obj vehicle-guard))
  (cond
    ((handle->process (-> obj pursuit-target))
     (let ((v1-3 (new 'stack-no-clear 'vehicle-control-point)))
       (set! (-> v1-3 local-pos quad) (-> obj root-override-2 trans quad))
       (let ((v1-4 (traffic-engine-method-49
                     (-> obj controller traffic)
                     (-> v1-3 local-pos)
                     (-> obj traffic-priority-id)
                     (the-as traffic-target-status (&-> obj traffic-target-status))
                     )
                   )
             )
         (when (logtest? (-> v1-4 flags) (traffic-target-flag updated))
           (set! (-> obj flags)
                 (the-as rigid-body-object-flag (logclear (-> obj flags) (rigid-body-object-flag target-in-sight)))
                 )
           (when (logtest? (-> v1-4 flags) (traffic-target-flag visible-now))
             (set! (-> obj flags)
                   (the-as rigid-body-object-flag (logior (rigid-body-object-flag target-in-sight) (-> obj flags)))
                   )
             (set! (-> obj target-in-sight-time) (current-time))
             )
           )
         (set! (-> obj target-flags) (the-as turret-flag (-> v1-4 flags)))
         )
       )
     (when (not (logtest? (rigid-body-object-flag in-pursuit) (-> obj flags)))
       (if (logtest? (rigid-body-object-flag target-in-sight) (-> obj flags))
           (vehicle-method-108 obj)
           )
       )
     )
    (else
      (vehicle-method-109 obj)
      )
    )
  (let ((v1-22 (if (logtest? (rigid-body-object-flag in-pursuit) (-> obj flags))
                   (-> obj draw lod-set lod 1 geo)
                   (-> obj lod2)
                   )
               )
        )
    (when (!= v1-22 (-> obj draw lod-set lod 2 geo))
      (set! (-> obj draw lod-set lod 2 geo) (the-as merc-ctrl v1-22))
      (set! (-> obj draw cur-lod) -1)
      (lod-set! (-> obj draw) (-> obj draw desired-lod))
      )
    )
  0
  (none)
  )

(defmethod vehicle-guard-method-155 vehicle-guard ((obj vehicle-guard) (arg0 vector) (arg1 vector))
  (cond
    (#f
      (let ((s5-0 (new 'stack-no-clear 'traj3d-params)))
        (let ((f0-2 (+ 0.5 (* 0.5 (rand-vu)))))
          (set! (-> s5-0 src quad) (-> obj root-override-2 trans quad))
          (vector+float*! (-> s5-0 dest) arg0 arg1 f0-2)
          )
        (set! (-> s5-0 initial-tilt) 8192.0)
        (set! (-> s5-0 gravity) 184320.0)
        (when (traj3d-calc-initial-velocity-using-tilt s5-0)
          (let ((a1-1 (new 'stack-no-clear 'projectile-init-by-other-params)))
            (set! (-> a1-1 ent) (-> obj entity))
            (set! (-> a1-1 charge) 1.0)
            (set! (-> a1-1 options) (projectile-options))
            (set! (-> a1-1 pos quad) (-> s5-0 src quad))
            (set! (-> a1-1 vel quad) (-> s5-0 initial-velocity quad))
            (set! (-> a1-1 notify-handle) (the-as handle #f))
            (set! (-> a1-1 owner-handle) (the-as handle #f))
            (set! (-> a1-1 ignore-handle) (process->handle obj))
            (let* ((v1-15 *game-info*)
                   (a0-14 (+ (-> v1-15 attack-id) 1))
                   )
              (set! (-> v1-15 attack-id) a0-14)
              (set! (-> a1-1 attack-id) a0-14)
              )
            (set! (-> a1-1 timeout) (seconds 4))
            (spawn-projectile vehicle-grenade a1-1 obj *default-dead-pool*)
            )
          (let ((a1-2 (new 'stack-no-clear 'traffic-danger-info)))
            (set! (-> a1-2 sphere quad) (-> obj root-override-2 trans quad))
            (set! (-> a1-2 sphere r) 40960.0)
            (set! (-> a1-2 velocity quad) (-> s5-0 initial-velocity quad))
            (set! (-> a1-2 notify-radius) 122880.0)
            (set! (-> a1-2 danger-level) 1.0)
            (set! (-> a1-2 decay-rate) 0.0)
            (set! (-> a1-2 flags) (traffic-danger-flags tdf0))
            (set! (-> a1-2 danger-type) (traffic-danger-type tdt6))
            (set! (-> a1-2 handle) (the-as handle #f))
            (add-danger (-> obj controller traffic) a1-2)
            )
          )
        )
      )
    (else
      (let ((s5-1 (new 'stack-no-clear 'turret-unknown-stack-structure2)))
        (set! (-> s5-1 mat-1 quad 0) (-> obj root-override-2 trans quad))
        (vector-! (-> s5-1 mat-1 vector 1) arg0 (the-as vector (-> s5-1 mat-1)))
        (vector-normalize! (-> s5-1 mat-1 vector 1) 1.0)
        (set! (-> s5-1 proj-params ent) (-> obj entity))
        (set! (-> s5-1 proj-params charge) 1.0)
        (set! (-> s5-1 proj-params options) (projectile-options))
        (set! (-> s5-1 proj-params notify-handle) (process->handle obj))
        (set! (-> s5-1 proj-params owner-handle) (the-as handle #f))
        (set! (-> s5-1 proj-params ignore-handle) (process->handle obj))
        (let* ((v1-38 *game-info*)
               (a0-36 (+ (-> v1-38 attack-id) 1))
               )
          (set! (-> v1-38 attack-id) a0-36)
          (set! (-> s5-1 proj-params attack-id) a0-36)
          )
        (set! (-> s5-1 proj-params timeout) (seconds 4))
        (vector+float*! (-> s5-1 proj-params pos) (the-as vector (-> s5-1 mat-1)) (-> s5-1 mat-1 vector 1) 16384.0)
        (vector-float*! (-> s5-1 proj-params vel) (-> s5-1 mat-1 vector 1) 819200.0)
        (spawn-projectile guard-shot (-> s5-1 proj-params) obj *default-dead-pool*)
        )
      )
    )
  0
  (none)
  )

(defmethod vehicle-method-134 vehicle-guard ((obj vehicle-guard) (arg0 process))
  "Stubbed"
  (set! (-> obj pursuit-target) (process->handle arg0))
  (set! (-> obj flags) (logior (rigid-body-object-flag alert) (-> obj flags)))
  (vehicle-method-111 obj 2 (the-as target arg0))
  0
  (none)
  )

;; WARN: disable def twice: 112. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod rigid-body-object-method-46 vehicle-guard ((obj vehicle-guard) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact-impulse)
     (let ((s5-1 (the-as matrix (-> arg3 param 0))))
       (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-driving)))
         (let ((a1-2 (find-offending-process-focusable arg0 (the-as attack-info #f))))
           (when a1-2
             (cond
               ((logtest? (rigid-body-object-flag in-pursuit) (-> obj flags))
                (if (= (handle->process (-> obj pursuit-target)) a1-2)
                    (set! (-> obj flags)
                          (the-as rigid-body-object-flag (logior (rigid-body-object-flag rammed-target) (-> obj flags)))
                          )
                    )
                )
               (else
                 (if (and (< (* 49152.0 (-> obj info-override info mass)) (-> s5-1 trans x))
                          (logtest? (-> a1-2 mask) (process-mask target))
                          )
                     (vehicle-method-134 obj a1-2)
                     )
                 )
               )
             )
           )
         )
       (rigid-body-object-method-42 obj)
       (rigid-body-object-method-45 obj (the-as rigid-body-impact s5-1))
       )
     (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
         (go (method-of-object obj waiting))
         )
     )
    (('track)
     (not (logtest? (-> obj flags) (rigid-body-object-flag player-driving)))
     )
    (('alert-begin)
     (when (and (not (focus-test? obj dead))
                (not (logtest? (rigid-body-object-flag alert) (-> obj flags)))
                (logtest? (rigid-body-object-flag ai-driving) (-> obj flags))
                (>= (the-as uint (get-alert-level (-> obj controller traffic))) (the-as uint 2))
                )
       (set! (-> obj flags) (logior (rigid-body-object-flag alert) (-> obj flags)))
       (let ((v0-4 (the-as object (process->handle (the-as process (-> arg3 param 0))))))
         (set! (-> obj pursuit-target) (the-as handle v0-4))
         v0-4
         )
       )
     )
    (('alert-end)
     (when (not (focus-test? obj dead))
       (when (logtest? (rigid-body-object-flag alert) (-> obj flags))
         (set! (-> obj flags)
               (the-as rigid-body-object-flag (logclear (-> obj flags) (rigid-body-object-flag persistent alert in-pursuit)))
               )
         (speech-control-method-12 *speech-control* obj (speech-type speech-type-0 speech-type-2))
         (vehicle-method-109 obj)
         (go (method-of-object obj active))
         )
       )
     )
    (('end-pursuit)
     (when (logtest? (rigid-body-object-flag alert) (-> obj flags))
       (set! (-> obj flags)
             (the-as rigid-body-object-flag (logclear (-> obj flags) (rigid-body-object-flag persistent alert in-pursuit)))
             )
       (vehicle-method-109 obj)
       (go (method-of-object obj active))
       )
     )
    (else
      ((method-of-type vehicle rigid-body-object-method-46) obj arg0 arg1 arg2 arg3)
      )
    )
  )

(defmethod vehicle-method-137 vehicle-guard ((obj vehicle-guard) (arg0 traffic-object-spawn-params))
  (vehicle-rider-spawn obj crimson-guard-rider arg0)
  0
  (none)
  )

(defun vehicle-guard-choose-branch ((arg0 vehicle-controller) (arg1 vehicle))
  (let ((gp-0 (the-as nav-branch #f)))
    (cond
      ((logtest? (rigid-body-object-flag alert) (-> arg1 flags))
       (let ((s5-0 (-> arg0 branch dest-node))
             (s4-0 (new 'stack-no-clear 'inline-array 'vector 5))
             )
         (set! (-> s4-0 4 x) -10000000000000000000000000000000000000.0)
         (set! (-> s4-0 3 quad) (-> arg1 root-override-2 trans quad))
         (vector-! (-> s4-0 0) (-> s4-0 3) (the-as vector (&-> arg1 stack 896)))
         (vector-normalize! (-> s4-0 0) 1.0)
         (dotimes (s3-0 (-> s5-0 branch-count))
           (let ((s2-0 (-> s5-0 branch-array s3-0)))
             (when (!= (-> s2-0 dest-node id) #xffff)
               (let ((a1-3 (-> s2-0 dest-node))
                     (v1-11 (-> s4-0 2))
                     )
                 (set! (-> v1-11 quad) (-> a1-3 position quad))
                 (set! (-> v1-11 w) 1.0)
                 )
               (vector-! (-> s4-0 1) (-> s4-0 2) (-> s4-0 3))
               (vector-normalize! (-> s4-0 1) 1.0)
               (let ((f0-3 (vector-dot (-> s4-0 0) (-> s4-0 1))))
                 (when (< (-> s4-0 4 x) f0-3)
                   (set! (-> s4-0 4 x) f0-3)
                   (set! gp-0 s2-0)
                   )
                 )
               )
             )
           )
         )
       )
      (else
        (set! gp-0 (vehicle-controller-method-15 arg0))
        )
      )
    gp-0
    )
  )

(defmethod alloc-and-init-rigid-body-control vehicle-guard ((obj vehicle-guard) (arg0 rigid-body-vehicle-constants))
  (let ((t9-0 (method-of-type vehicle alloc-and-init-rigid-body-control)))
    (t9-0 obj arg0)
    )
  (set! (-> obj mask) (logior (process-mask enemy guard) (-> obj mask)))
  (set! (-> obj pursuit-target) (the-as handle #f))
  (set! (-> obj minimap) #f)
  (set! (-> obj lod2) (the-as symbol (-> obj draw lod-set lod 2 geo)))
  (set! (-> obj controller choose-branch-callback) vehicle-guard-choose-branch)
  0
  (none)
  )

;; WARN: Return type mismatch traffic-guard-type-settings vs none.
(defmethod vehicle-method-82 vehicle-guard ((obj vehicle-guard))
  (let ((t9-0 (method-of-type vehicle vehicle-method-82)))
    (t9-0 obj)
    )
  (set! (-> obj turret guard-settings)
        (get-traffic-guard-type-settings (-> obj controller traffic) (the-as int (-> obj info-override guard-type)))
        )
  (none)
  )

(defmethod vehicle-method-128 vehicle-guard ((obj vehicle-guard))
  (if (not (-> obj minimap))
      (set! (-> obj minimap) (add-icon! *minimap* obj (the-as uint 14) (the-as int #f) (the-as vector #t) 0))
      )
  ((method-of-type vehicle vehicle-method-128) obj)
  (none)
  )

(defmethod vehicle-method-127 vehicle-guard ((obj vehicle-guard))
  (when (-> obj minimap)
    (logior! (-> obj minimap flags) (minimap-flag fade-out))
    (set! (-> obj minimap) #f)
    )
  ((method-of-type vehicle vehicle-method-127) obj)
  (none)
  )

(defmethod vehicle-method-129 vehicle-guard ((obj vehicle-guard))
  (when (-> obj minimap)
    (logior! (-> obj minimap flags) (minimap-flag fade-out))
    (set! (-> obj minimap) #f)
    )
  ((method-of-type vehicle vehicle-method-129) obj)
  (none)
  )

(defmethod vehicle-method-130 vehicle-guard ((obj vehicle-guard) (arg0 traffic-object-spawn-params))
  (case (-> arg0 behavior)
    ((9)
     (vehicle-method-128 obj)
     (set! (-> obj flags) (logior (rigid-body-object-flag persistent alert) (-> obj flags)))
     (set! (-> obj pursuit-target) (-> arg0 handle))
     (go (method-of-object obj waiting-ambush))
     )
    (else
      ((method-of-type vehicle vehicle-method-130) obj arg0)
      )
    )
  (none)
  )

(defmethod vehicle-guard-method-157 vehicle-guard ((obj vehicle-guard) (arg0 vehicle-guard-target-data))
  (local-vars (v1-11 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (and (logtest? (rigid-body-object-flag target-in-sight) (-> obj flags))
         (or (and (not (logtest? (focus-status pilot) (-> arg0 target focus-status))) (< (-> arg0 dist) 184320.0))
             (and (< (-> arg0 tpos y) (+ -16384.0 (-> obj root-override-2 trans y)))
                  (begin
                    (.lvf vf1 (&-> (-> arg0 tvel) quad))
                    (.add.w.vf vf2 vf0 vf0 :mask #b1)
                    (.mul.vf vf1 vf1 vf1)
                    (.mul.x.vf acc vf2 vf1 :mask #b1)
                    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
                    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
                    (.mov v1-11 vf1)
                    (let ((f0-2 v1-11)
                          (f1-3 61440.0)
                          )
                      (< f0-2 (* f1-3 f1-3))
                      )
                    )
                  (< (-> arg0 dist) 122880.0)
                  )
             )
         )
    )
  )

(defmethod vehicle-guard-method-156 vehicle-guard ((obj vehicle-guard))
  (with-pp
    (let ((f30-0 (-> pp clock seconds-per-frame)))
      (seek! (-> obj controls throttle) 0.0 (* 4.0 f30-0))
      (+! (-> obj controls brake) (* (- 1.0 (-> obj controls brake)) (fmin 1.0 (* 8.0 f30-0))))
      (let ((s4-0 (-> obj rbody state matrix))
            (s3-0 (-> obj rbody state matrix vector 2))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (vector-reset! s5-0)
        (let ((v1-9 (handle->process (-> obj pursuit-target)))
              (f28-0 0.0)
              )
          (when (and v1-9 (logtest? (rigid-body-object-flag target-in-sight) (-> obj flags)))
            (vector-! s5-0 (-> (the-as process-drawable v1-9) root trans) (-> obj root-override-2 trans))
            (set! (-> s5-0 y) 0.0)
            (vector-normalize! s5-0 1.0)
            (if (< (vector-dot s3-0 s5-0) (cos 2730.6667))
                (set! f28-0 (vector-dot (the-as vector s4-0) s5-0))
                )
            )
          (+! (-> obj controls steering) (* (- f28-0 (-> obj controls steering)) (fmin 1.0 (* 8.0 f30-0))))
          )
        )
      )
    (when (zero? (-> obj flight-level-index))
      (if (logtest? (-> obj flags) (rigid-body-object-flag riding))
          (vehicle-method-80 obj)
          )
      )
    0
    (none)
    )
  )

(defmethod vehicle-guard-method-154 vehicle-guard ((obj vehicle-guard))
  (with-pp
    (if (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
        (rigid-body-object-method-38 obj)
        )
    (set! (-> obj camera-dist2) (vector-vector-distance-squared (-> obj root-override-2 trans) (camera-pos)))
    (set! (-> obj player-dist2) (vector-vector-distance-squared (-> obj root-override-2 trans) (target-pos 0)))
    (vehicle-controller-method-18
      (-> obj controller)
      (-> obj target-acceleration)
      (-> obj root-override-2 transv)
      obj
      (/ 1.0 (-> pp clock seconds-per-frame))
      )
    ((-> obj ai-hook) obj)
    (vehicle-method-121 obj)
    (vehicle-method-106 obj)
    (when (not (logtest? (rigid-body-object-flag in-pursuit) (-> obj flags)))
      (if (not (logtest? (-> obj target-flags) (turret-flag aiming)))
          (speech-control-method-12 *speech-control* obj (speech-type speech-type-1))
          )
      (go (method-of-object obj active))
      )
    0
    (none)
    )
  )

(defmethod vehicle-guard-method-158 vehicle-guard ((obj vehicle-guard))
  (vehicle-guard-method-150 obj)
  (let ((s5-0 (new 'stack-no-clear 'vehicle-guard-target-data)))
    (vehicle-guard-method-151 obj s5-0)
    (let ((a1-1 (-> s5-0 target)))
      (when a1-1
        (cond
          ((logtest? (rigid-body-object-flag target-in-sight) (-> obj flags))
           (vehicle-guard-method-153 obj a1-1)
           (speech-control-method-15 *speech-control* obj)
           )
          (else
            (if (and (>= (- (current-time) (-> obj target-in-sight-time)) (seconds 4)) (< 368640.0 (-> s5-0 dist)))
                (vehicle-method-109 obj)
                )
            )
          )
        )
      )
    )
  (if (not (logtest? (rigid-body-object-flag in-pursuit) (-> obj flags)))
      (go (method-of-object obj active))
      )
  (rigid-body-object-method-42 obj)
  (vehicle-method-122 obj)
  0
  (none)
  )

(defmethod vehicle-method-94 vehicle-guard ((obj vehicle-guard))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 (new 'stack-no-clear 'camera-free-floating-move-info)))
      (let* ((a0-1 (-> v1-0 tm))
             (t0-0 (-> obj rbody state matrix))
             (a1-1 (-> t0-0 quad 0))
             (a2-0 (-> t0-0 quad 1))
             (a3-0 (-> t0-0 quad 2))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-1 quad 0) a1-1)
        (set! (-> a0-1 quad 1) a2-0)
        (set! (-> a0-1 quad 2) a3-0)
        (set! (-> a0-1 trans quad) t0-1)
        )
      (let ((a0-2 (-> v1-0 rv)))
        (let ((a1-3 (-> obj rbody state position)))
          (let ((a2-1 (-> v1-0 tm vector 2)))
            (let ((a3-2 163840.0))
              (.mov vf7 a3-2)
              )
            (.lvf vf5 (&-> a2-1 quad))
            )
          (.lvf vf4 (&-> a1-3 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> a0-2 quad) vf6)
        )
      (vector-reset! (-> v1-0 up))
      (set! (-> obj turret inaccuracy) 0.0)
      (turret-control-method-9 (-> obj turret) obj (-> v1-0 rv) (-> v1-0 up))
      )
    (when (cpad-hold? 0 r1)
      (when (>= (- (current-time) (-> obj turret shoot-time)) (seconds 0.35))
        (set! (-> obj turret owner-handle) (process->handle *target*))
        (turret-control-method-17 (-> obj turret) obj)
        (set! (-> obj turret owner-handle) (the-as handle #f))
        )
      )
    ((method-of-type vehicle vehicle-method-94) obj)
    0
    (none)
    )
  )

(defstate active (vehicle-guard)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-guard)
    vehicle-event-handler
    )
  :enter (behavior ()
    (let ((v1-0 (-> self controller branch)))
      (when (or (not v1-0) (zero? v1-0))
        (cond
          ((logtest? (-> self draw status) (draw-control-status on-screen))
           (set! (-> self hit-points) 0.0)
           (vehicle-method-76 self 2 (the-as uint 3000))
           (go-virtual crash)
           )
          (else
            (vehicle-method-113 self)
            )
          )
        )
      )
    (let ((t9-3 (-> (method-of-type vehicle active) enter)))
      (if t9-3
          (t9-3)
          )
      )
    (none)
    )
  :trans (the-as (function none :behavior vehicle-guard) #f)
  :code (the-as (function none :behavior vehicle-guard) sleep-code)
  :post (behavior ()
    (cond
      ((logtest? (rigid-body-object-flag alert) (-> self flags))
       (vehicle-guard-method-150 self)
       (when (logtest? (rigid-body-object-flag in-pursuit) (-> self flags))
         (logior! (-> self flags) (rigid-body-object-flag persistent))
         (go-virtual hostile)
         )
       (speech-control-method-12 *speech-control* self (speech-type speech-type-2))
       (if (or (>= (- (current-time) (-> self state-time)) (seconds 8)) (let ((f0-0 409600.0))
                                                                          (< (* f0-0 f0-0) (-> self player-dist2))
                                                                          )
               )
           (logclear! (-> self flags) (rigid-body-object-flag persistent alert))
           )
       )
      (else
        (speech-control-method-12 *speech-control* self (speech-type speech-type-0))
        )
      )
    (check-player-get-on self)
    (vehicle-method-122 self)
    (none)
    )
  )

(defstate hostile (vehicle-guard)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-guard)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self ai-hook) (method-of-object self vehicle-method-93))
    (none)
    )
  :trans (the-as (function none :behavior vehicle-guard) #f)
  :code (the-as (function none :behavior vehicle-guard) sleep-code)
  :post (behavior ()
    (vehicle-guard-method-150 self)
    (when (logtest? (rigid-body-object-flag in-pursuit) (-> self flags))
      (if (or (>= (- (current-time) (-> self target-in-sight-time)) (seconds 8))
              (and (>= (-> self controller traffic alert-state guards-in-sight-of-target) 2)
                   (>= (- (current-time) (-> self target-in-sight-time)) (seconds 0.5))
                   )
              )
          (vehicle-method-109 self)
          )
      )
    (let ((gp-0 (new 'stack-no-clear 'vehicle-guard-target-data)))
      (vehicle-guard-method-151 self gp-0)
      (let ((a1-1 (-> gp-0 target)))
        (cond
          (a1-1
            (cond
              ((logtest? (rigid-body-object-flag target-in-sight) (-> self flags))
               (vehicle-guard-method-153 self a1-1)
               (if (vehicle-guard-method-157 self gp-0)
                   (go-virtual stop-and-shoot)
                   )
               (speech-control-method-15 *speech-control* self)
               )
              (else
                )
              )
            (vehicle-guard-method-152 self gp-0)
            )
          (else
            (vehicle-method-109 self)
            )
          )
        )
      )
    (if (logtest? (rigid-body-object-flag rammed-target) (-> self flags))
        (go-virtual slow-pursuit)
        )
    (vehicle-guard-method-154 self)
    (none)
    )
  )

(defstate stop-and-shoot (vehicle-guard)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-guard)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self ai-hook) (method-of-object self vehicle-guard-method-156))
    (none)
    )
  :trans (the-as (function none :behavior vehicle-guard) #f)
  :code (the-as (function none :behavior vehicle-guard) sleep-code)
  :post (behavior ()
    (vehicle-guard-method-150 self)
    (let ((s5-0 (new 'stack-no-clear 'vehicle-guard-target-data)))
      (vehicle-guard-method-151 self s5-0)
      (let ((gp-0 (-> s5-0 target)))
        (when gp-0
          (if (not (vehicle-guard-method-157 self s5-0))
              (go-virtual hostile)
              )
          (vehicle-guard-method-153 self gp-0)
          )
        )
      )
    (vehicle-guard-method-154 self)
    (none)
    )
  )

(defstate slow-pursuit (vehicle-guard)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-guard)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self ai-hook) (method-of-object self vehicle-guard-method-156))
    (none)
    )
  :trans (the-as (function none :behavior vehicle-guard) #f)
  :code (the-as (function none :behavior vehicle-guard) sleep-code)
  :post (behavior ()
    (vehicle-guard-method-150 self)
    (let ((s5-0 (new 'stack-no-clear 'vehicle-guard-target-data)))
      (vehicle-guard-method-151 self s5-0)
      (let ((gp-0 (-> s5-0 target)))
        (when gp-0
          (when (or (< (-> s5-0 attack-range) (-> s5-0 dist))
                    (not (logtest? (rigid-body-object-flag target-in-sight) (-> self flags)))
                    (>= (- (current-time) (-> self state-time)) (seconds 2))
                    )
            (set! (-> self flags)
                  (the-as rigid-body-object-flag (logclear (-> self flags) (rigid-body-object-flag rammed-target)))
                  )
            (go-virtual hostile)
            )
          (vehicle-guard-method-153 self gp-0)
          )
        )
      )
    (vehicle-guard-method-154 self)
    (none)
    )
  )

(defstate waiting-ambush (vehicle-guard)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior vehicle-guard)
    vehicle-event-handler
    )
  :enter (behavior ()
    (set! (-> self flags) (logior (rigid-body-object-flag riding ignition ai-driving) (-> self flags)))
    (set! (-> self ai-hook) (method-of-object self vehicle-guard-method-156))
    (none)
    )
  :trans (the-as (function none :behavior vehicle-guard) #f)
  :code (the-as (function none :behavior vehicle-guard) sleep-code)
  :post (behavior ()
    (vehicle-guard-method-150 self)
    (let ((gp-0 (new 'stack-no-clear 'vehicle-guard-target-data)))
      (vehicle-guard-method-151 self gp-0)
      (let ((s5-0 (-> gp-0 target)))
        (when s5-0
          (when (logtest? (rigid-body-object-flag target-in-sight) (-> self flags))
            (vehicle-guard-method-153 self s5-0)
            (vehicle-method-111 self 2 s5-0)
            (if (< (-> gp-0 dist) 122880.0)
                (go-virtual hostile)
                )
            )
          )
        )
      )
    (set! (-> self flags)
          (the-as rigid-body-object-flag (logior (rigid-body-object-flag in-pursuit) (-> self flags)))
          )
    (vehicle-guard-method-154 self)
    (none)
    )
  )
