;;-*-Lisp-*-
(in-package goal)

;; name: civilian.gc
;; name in dgo: civilian
;; dgos: CWI

;; DECOMP BEGINS

(deftype civilian-anim-info (structure)
  ((anim-index       int32 2 :offset-assert   0)
   (anim-index-front int32   :offset          0)
   (anim-index-back  int32   :offset          4)
   )
  :pack-me
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(deftype civilian-global-info (basic)
  ((prev-yellow-hit                int8                         :offset-assert   4)
   (prev-blue-hit                  int8                         :offset-assert   5)
   (knocked                        int32              2         :offset-assert   8)
   (anim-knocked-front             int32                        :offset          8)
   (anim-knocked-back              int32                        :offset         12)
   (knocked-land                   int32              2         :offset-assert  16)
   (anim-knocked-front-land        int32                        :offset         16)
   (anim-knocked-back-land         int32                        :offset         20)
   (yellow-hit-anim                civilian-anim-info 1 :inline :offset-assert  24)
   (blue-hit-anim                  civilian-anim-info 3 :inline :offset-assert  32)
   (anim-cover-head-start          int32                        :offset-assert  56)
   (anim-cover-head-loop           int32                        :offset-assert  60)
   (anim-cover-head-end            int32                        :offset-assert  64)
   (car-stance-anim                int32                        :offset-assert  68)
   (bike-stance-anim               int32                        :offset-assert  72)
   (get-in-car-anim                int32                        :offset-assert  76)
   (get-on-bike-anim               int32                        :offset-assert  80)
   (seat-flag                      uint8                        :offset-assert  84)
   (speech-ambient                 int8                         :offset-assert  85)
   (speech-alert                   int8                         :offset-assert  86)
   (speech-cower                   int8                         :offset-assert  87)
   (speech-touched-by-player       int8                         :offset-assert  88)
   (speech-shot-by-player          int8                         :offset-assert  89)
   (speech-avoiding-player-vehicle int8                         :offset-assert  90)
   (speech-hit-by-player-vehicle   int8                         :offset-assert  91)
   (speech-player-stealing-vehicle int8                         :offset-assert  92)
   )
  :method-count-assert 9
  :size-assert         #x5d
  :flag-assert         #x90000005d
  )


(deftype civilian (citizen)
  ((info              civilian-global-info         :offset-assert 964)
   (anim-panic-run    int32                        :offset-assert 968)
   (anim-on-ground    int32                        :offset-assert 972)
   (anim-dive         int32                        :offset-assert 976)
   (anim-get-up-front int32                        :offset-assert 980)
   (anim-get-up-back  int32                        :offset-assert 984)
   (last-second-pos   vector               :inline :offset-assert 992)
   (last-distance     float                        :offset-assert 1008)
   (next-time         time-frame                   :offset-assert 1016)
   (dive-target-point vector               :inline :offset-assert 1024)
   (dive-reaction     float                        :offset-assert 1040)
   (allow-dive        symbol                       :offset-assert 1044)
   (dive-finished?    symbol                       :offset-assert 1048)
   (hit-face          uint32                       :offset-assert 1052)
   (seat              int32                        :offset-assert 1056)
   )
  :heap-base #x3b0
  :method-count-assert 218
  :size-assert         #x424
  :flag-assert         #xda03b00424
  (:methods
    (avoid-danger () _type_ :state 201)
    (clear-path () _type_ :state 202)
    (on-ground () _type_ :state 203)
    (dive () _type_ :state 204)
    (get-up-front () _type_ :state 205)
    (get-up-back () _type_ :state 206)
    (cower-ground () _type_ :state 207)
    (wait-for-ride () _type_ :state 208)
    (move-to-vehicle () _type_ :state 209)
    (board-vehicle () _type_ :state 210)
    (ride () _type_ :state 211)
    (exit-vehicle (object object int symbol event-message-block) _type_ :state 212)
    (wait-at-dest () _type_ :state 213)
    (civilian-method-214 (_type_ nav-branch int vector float) float 214)
    (civilian-method-215 (_type_ vector) none 215)
    (go-dive (_type_) none 216)
    (civilian-method-217 (_type_ vector) symbol 217)
    )
  )


(defmethod get-run-anim civilian ((obj civilian))
  (if (and (-> obj next-state) (= (-> obj next-state name) 'flee))
      (-> obj anim-panic-run)
      (-> obj anim-run)
      )
  )

(defmethod enemy-method-81 civilian ((obj civilian))
  #f
  )

(defmethod cleanup-for-death civilian ((obj civilian))
  (cond
    ((zero? (-> obj hit-points))
     (logclear! (-> obj flags) (citizen-flag persistent))
     (send-event (ppointer->process (-> obj parent)) 'child-killed)
     (let ((a1-1 (new 'stack-no-clear 'traffic-danger-info)))
       (set! (-> a1-1 sphere quad) (-> obj root-override2 trans quad))
       (set! (-> a1-1 sphere r) 40960.0)
       (set! (-> a1-1 velocity quad) (-> obj root-override2 transv quad))
       (set! (-> a1-1 notify-radius) 122880.0)
       (set! (-> a1-1 danger-level) 1.0)
       (set! (-> a1-1 decay-rate) 0.0)
       (set! (-> a1-1 flags) (traffic-danger-flags tdf0))
       (set! (-> a1-1 danger-type) (traffic-danger-type tdt7))
       (set! (-> a1-1 handle) (process->handle obj))
       (set! (-> a1-1 handle) (the-as handle #f))
       (add-danger (-> obj controller traffic) a1-1)
       )
     (go-inactive obj)
     )
    (else
      (set! (-> obj hit-points) (-> obj enemy-info-override default-hit-points))
      (set! (-> obj hit-points) (rand-vu-int-range 1 4))
      (set! (-> obj fated-time) 0)
      (logior! (-> obj enemy-flags) (enemy-flag enable-on-active checking-water))
      (logior! (-> obj focus-status) (focus-status dangerous))
      (logior! (-> obj enemy-flags) (enemy-flag check-water))
      (set! (-> obj enemy-flags)
            (logior (enemy-flag check-water-backup no-initial-move-to-ground) (-> obj enemy-flags))
            )
      (logclear! (-> obj focus-status) (focus-status dead))
      (set! (-> obj mask) (logior (process-mask collectable) (-> obj mask)))
      (logior! (-> obj enemy-flags) (enemy-flag look-at-move-dest))
      (if (zero? (-> obj hit-face))
          (go (method-of-object obj get-up-front))
          (go (method-of-object obj get-up-back))
          )
      )
    )
  (none)
  )

(defmethod damage-amount-from-attack civilian ((obj civilian) (arg0 process) (arg1 event-message-block))
  "@returns the amount of damage taken from an attack.  This can come straight off the [[attack-info]] or via [[penetrate-using->damage]]"
  (cond
    ((= (scf-get-territory) 2)
     (let ((a1-1 (-> arg1 param 1))
           (a0-1 arg0)
           )
       (cond
         (a0-1
           (let ((v1-0 (find-offending-process-focusable a0-1 (the-as attack-info a1-1))))
             (cond
               (v1-0
                 (cond
                   ((= (-> v1-0 type) target)
                    0
                    )
                   ((or (logtest? (process-mask enemy) (-> v1-0 mask)) (logtest? (process-mask guard) (-> v1-0 mask)))
                    ((method-of-type nav-enemy damage-amount-from-attack) obj arg0 arg1)
                    )
                   (else
                     0
                     )
                   )
                 )
               (else
                 0
                 )
               )
             )
           )
         (else
           0
           )
         )
       )
     )
    (else
      ((method-of-type nav-enemy damage-amount-from-attack) obj arg0 arg1)
      )
    )
  )

(defmethod enemy-method-108 civilian ((obj civilian) (arg0 enemy) (arg1 event-message-block))
  0
  )

(defmethod go-hostile civilian ((obj civilian))
  (cleanup-for-death obj)
  (none)
  )

;; WARN: Return type mismatch none vs object.
(defmethod kill-prefer-falling civilian ((obj civilian))
  "If available in `enemy-info`, [[go]] to the [[die-falling]] state, if not, [[die]]"
  (the-as object (cleanup-for-death obj))
  )

(defmethod set-behavior! civilian ((obj civilian) (arg0 traffic-object-spawn-params))
  (let ((v1-0 (-> arg0 behavior)))
    (cond
      ((zero? v1-0)
       (go (method-of-object obj idle))
       )
      ((= v1-0 2)
       (go (method-of-object obj active))
       )
      ((= v1-0 3)
       (go (method-of-object obj hostile))
       )
      ((= v1-0 7)
       (logior! (-> obj flags) (citizen-flag persistent))
       (go (method-of-object obj wait-for-ride))
       )
      (else
        (go-inactive obj)
        )
      )
    )
  0
  (none)
  )

(defmethod citizen-init! civilian ((obj civilian))
  "Initialize [[citizen]] defaults."
  (let ((t9-0 (method-of-type citizen citizen-init!)))
    (t9-0 obj)
    )
  (set! (-> obj mask) (the-as process-mask (logior (process-mask civilian) (-> obj mask))))
  (set! (-> obj hit-points) (rand-vu-int-range 1 4))
  (set! (-> obj hit-points) 4)
  (set! (-> obj fact-info-override pickup-type) (pickup-type none))
  (set! (-> obj fact-info-override pickup-amount) 0.0)
  (set! (-> obj fact-info-override pickup-spawn-amount) 0.0)
  0
  (none)
  )

;; WARN: Return type mismatch nav-segment vs none.
(defmethod civilian-method-215 civilian ((obj civilian) (arg0 vector))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> obj root-override2 trans quad))
    (set! (-> v1-0 w) 81920.0)
    (let ((s5-0 (find-segment obj v1-0 arg0)))
      (if s5-0
          (citizen-method-186 obj s5-0)
          )
      )
    )
  (none)
  )

;; WARN: Return type mismatch none vs object.
(defmethod general-event-handler civilian ((obj civilian) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (let ((v1-0 arg2))
    (the-as
      object
      (cond
        ((= v1-0 'track)
         #f
         )
        ((= v1-0 'combo)
         #f
         )
        ((= v1-0 'touched)
         ((method-of-type citizen general-event-handler) obj arg0 arg1 arg2 arg3)
         )
        ((= v1-0 'panic)
         (let ((a0-6 (-> arg3 param 0)))
           (set! (-> obj danger-pos quad) (-> (the-as sphere (+ a0-6 0)) quad))
           )
         (if (and (-> obj next-state) (let ((v1-6 (-> obj next-state name)))
                                        (or (= v1-6 'active) (= v1-6 'wait) (= v1-6 'avoid-danger))
                                        )
                  )
             (go (method-of-object obj flee))
             )
         )
        ((= v1-0 'event-death)
         (if (zero? (-> obj hit-points))
             (the-as object (do-effect (-> obj skel effect) 'death-default 0.0 -1))
             )
         )
        ((= v1-0 'avoid)
         (set! (-> obj last-danger-time) (current-time))
         (let ((a0-15 (-> arg3 param 0)))
           (set! (-> obj danger-pos quad) (-> (the-as vector (+ a0-15 0)) quad))
           )
         (if (and (-> obj next-state) (let ((v1-18 (-> obj next-state name)))
                                        (or (= v1-18 'active) (= v1-18 'wait))
                                        )
                  )
             (go (method-of-object obj avoid-danger))
             )
         )
        ((= v1-0 'clear-path)
         (set! (-> obj last-danger-time) (current-time))
         (let ((v1-23 (the-as traffic-danger-info (-> arg3 param 0))))
           (set! (-> obj cp-valid?) #t)
           (set! (-> obj cp-sphere quad) (-> v1-23 sphere quad))
           (set! (-> obj cp-vec quad) (-> v1-23 velocity quad))
           (case (-> v1-23 danger-type)
             (((traffic-danger-type tdt0))
              (set! (-> obj allow-dive) #f)
              (set! (-> obj cp-factor) 20.0)
              )
             (((traffic-danger-type tdt1))
              (set! (-> obj allow-dive) #f)
              (set! (-> obj cp-factor) 20.0)
              )
             (((traffic-danger-type tdt2))
              (set! (-> obj allow-dive) #t)
              (set! (-> obj cp-factor) 50.0)
              )
             (((traffic-danger-type tdt3))
              (set! (-> obj allow-dive) #t)
              (set! (-> obj cp-factor) 50.0)
              )
             (((traffic-danger-type tdt4))
              (set! (-> obj allow-dive) #f)
              (set! (-> obj cp-factor) 2.0)
              )
             (((traffic-danger-type tdt5))
              (set! (-> obj allow-dive) #t)
              (set! (-> obj cp-factor) 50.0)
              )
             (((traffic-danger-type tdt6))
              (set! (-> obj allow-dive) #t)
              (set! (-> obj cp-factor) 50.0)
              )
             )
           )
         (let ((s5-1 (-> obj cp-plane)))
           (set! (-> s5-1 quad) (-> obj cp-vec quad))
           (set! (-> s5-1 y) 0.0)
           (vector-rotate90-around-y! s5-1 s5-1)
           (vector-normalize! s5-1 1.0)
           (set! (-> s5-1 w) (- (vector-dot (the-as vector s5-1) (the-as vector (-> obj cp-sphere)))))
           )
         (set! (-> obj cp-exit-time) (+ (current-time) (seconds 4)))
         (if (and (-> obj next-state) (let ((v1-54 (-> obj next-state name)))
                                        (or (= v1-54 'active) (= v1-54 'wait) (= v1-54 'avoid-danger))
                                        )
                  )
             (go (method-of-object obj clear-path))
             )
         )
        ((or (= v1-0 'hit) (= v1-0 'hit-flinch) (= v1-0 'hit-knocked))
         (speech-control-method-13 *speech-control* (the-as handle obj))
         (if (logtest? (-> obj flags) (citizen-flag female))
             (speech-control-method-12
               *speech-control*
               obj
               (speech-type speech-type-0 speech-type-1 speech-type-3 speech-type-4)
               )
             (speech-control-method-12 *speech-control* obj (speech-type speech-type-0 speech-type-1 speech-type-4))
             )
         ((method-of-type citizen general-event-handler) obj arg0 arg1 arg2 arg3)
         )
        ((= v1-0 'end-task)
         (let ((v0-0 (the-as object (logclear (-> obj flags) (citizen-flag persistent)))))
           (set! (-> obj flags) (the-as citizen-flag v0-0))
           v0-0
           )
         )
        (else
          ((method-of-type citizen general-event-handler) obj arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

(defmethod civilian-method-214 civilian ((obj civilian) (arg0 nav-branch) (arg1 int) (arg2 vector) (arg3 float))
  (when (nonzero? arg1)
    (-> arg0 src-node)
    (let* ((s3-0 (-> arg0 dest-node))
           (t9-0 vector-vector-xz-distance)
           (a0-1 arg2)
           (a2-1 s3-0)
           (a1-1 (new 'stack-no-clear 'vector))
           )
      (set! (-> a1-1 quad) (-> a2-1 position quad))
      (set! (-> a1-1 w) 1.0)
      (let ((s1-0 (t9-0 a0-1 a1-1))
            (s2-0 (-> s3-0 branch-count))
            (f30-0 0.0)
            )
        (dotimes (s0-0 s2-0)
          (+! f30-0 (civilian-method-214 obj (-> s3-0 branch-array s0-0) (+ arg1 -1) arg2 s1-0))
          )
        ;; changed to fix a divide by zero crash
        (set! arg3 (+ s1-0 (the float (/-0-guard (the int f30-0) s2-0))))
        )
      )
    )
  arg3
  )

(defstate wait (civilian)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type citizen wait) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  )

(defbehavior civilian-flee-post civilian ()
  (let* ((gp-0 (-> self controller))
         (s4-0 (-> gp-0 branch dest-node))
         (s5-0 (the-as nav-branch #f))
         (s3-1 (vector-!
                 (new 'stack-no-clear 'vector)
                 (-> self controller turn-exit-point)
                 (-> self controller path-prev-point)
                 )
               )
         )
    0.0
    (let ((s2-1
            (vector-! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (-> self controller turn-exit-point))
            )
          )
      (set! (-> s2-1 y) 0.0)
      (set! (-> s3-1 y) 0.0)
      (vector-xz-normalize! s3-1 1.0)
      (let ((f0-4 (vector-dot s2-1 s3-1)))
        (when (< -16384.0 f0-4)
          (cond
            ((zero? (-> s4-0 branch-count))
             )
            (else
              (let ((s3-2 (-> s4-0 branch-count))
                    (f30-0 0.0)
                    )
                (dotimes (s2-2 s3-2)
                  (let* ((s1-0 (-> s4-0 branch-array s2-2))
                         (f0-5 (civilian-method-214 self s1-0 4 (-> self danger-pos) 0.0))
                         )
                    (when (< f30-0 f0-5)
                      (set! f30-0 f0-5)
                      (set! s5-0 s1-0)
                      )
                    )
                  )
                )
              )
            )
          (when s5-0
            (vehicle-controller-method-11 gp-0)
            (let ((s4-1 (new 'stack-no-clear 'vector)))
              (set! (-> s4-1 quad) (-> gp-0 turn-exit-point quad))
              (vehicle-controller-method-10 gp-0 (the-as traffic-tracker s5-0))
              (set! (-> gp-0 path-prev-point quad) (-> s4-1 quad))
              )
            (set! (-> gp-0 branch) s5-0)
            (let ((a1-3 (-> s5-0 dest-node))
                  (v1-23 (-> gp-0 turn-exit-point))
                  )
              (set! (-> v1-23 quad) (-> a1-3 position quad))
              (set! (-> v1-23 w) 1.0)
              )
            )
          )
        )
      )
    )
  (when (< (-> self cp-next-time) (current-time))
    (set! (-> self cp-next-time) (+ (current-time) (get-rand-int-range self 600 1200)))
    (citizen-method-190 self (-> self cp-force))
    )
  (add-offset-to-target! (-> self nav state) (-> self cp-force))
  (if *citizen-debug*
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (-> self root-override2 trans)
        (vector+! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (-> self cp-force))
        *color-red*
        #f
        (the-as rgba -1)
        )
      )
  (let ((a0-18 (-> self nav state))
        (v1-42 (-> self controller turn-exit-point))
        )
    (logclear! (-> a0-18 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-18 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-18 target-post quad) (-> v1-42 quad))
    )
  0
  (set! (-> (new 'stack-no-clear 'vector) quad) (-> self nav state target-post quad))
  (nav-enemy-method-176 self)
  (none)
  )

(defstate flee (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info-override callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-166 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self speed-run)))
      )
    0
    (let ((a1-5
            (vector-! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (the-as vector (-> self danger-pos)))
            )
          )
      (civilian-method-215 self a1-5)
      )
    (if (zero? (-> self controller branch))
        (citizen-method-195 self (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat)))
        )
    (if (zero? (-> self controller branch))
        (go-dive self)
        )
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.0 0.0 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (none)
    )
  :trans (behavior ()
    (when (and (logtest? (-> self draw status) (draw-control-status on-screen))
               (< (vector-vector-distance (-> self root-override2 trans) (camera-pos)) 204800.0)
               )
      (if (logtest? (-> self flags) (citizen-flag female))
          (speech-control-method-12 *speech-control* self (speech-type speech-type-3 speech-type-4))
          (speech-control-method-12 *speech-control* self (speech-type speech-type-4))
          )
      )
    (if (and (>= (- (current-time) (-> self state-time)) (seconds 0.1))
             (not (logtest? (-> self nav state flags) (nav-state-flag in-mesh)))
             (< (-> self root-override2 trans y) 4096.0)
             )
        (go-virtual in-ditch)
        )
    (citizen-method-192 self)
    (none)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self anim-panic-run))) 30)
    (none)
    )
  :post (behavior ()
    (civilian-flee-post)
    (none)
    )
  )

(defbehavior civilian-avoid-danger-post civilian ()
  (local-vars (sv-352 nav-poly))
  (let ((gp-1
          (vector-! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (the-as vector (-> self danger-pos)))
          )
        )
    (let ((s5-1
            (vector-! (new 'stack-no-clear 'vector) (-> self controller turn-exit-point) (-> self root-override2 trans))
            )
          )
      (vector-!
        (new 'stack-no-clear 'vector)
        (-> self controller turn-exit-point)
        (the-as vector (-> self danger-pos))
        )
      (let ((s1-1 (vector-!
                    (new 'stack-no-clear 'vector)
                    (-> self controller turn-exit-point)
                    (-> self controller path-prev-point)
                    )
                  )
            )
        (set! (-> s5-1 y) 0.0)
        (set! (-> s1-1 y) 0.0)
        (vector-xz-normalize! s1-1 1.0)
        (vector-rotate90-around-y! s1-1 s1-1)
        (let ((s3-0 (new 'stack-no-clear 'vector))
              (s2-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              (s0-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
              )
          (let ((v1-6 (-> self nav))
                (a0-8 (-> self danger-pos))
                (a1-5 (new 'stack-no-clear 'nav-find-poly-parms))
                )
            (vector-! (-> a1-5 point) (the-as vector a0-8) (-> v1-6 state mesh bounds))
            (set! (-> a1-5 y-threshold) (-> v1-6 nearest-y-threshold))
            (set! (-> a1-5 ignore) (the-as uint 2))
            (set! sv-352 (find-poly-containing-point-local (-> v1-6 state mesh) a1-5))
            )
          (when sv-352
            (vector-normalize-copy! s3-0 s1-1 40960.0)
            (clamp-vector-to-mesh-no-gaps (-> self nav) (-> self danger-pos) sv-352 s3-0 s0-0)
            (vector-normalize-copy! s2-0 s1-1 -40960.0)
            (let ((a0-14 (-> self nav))
                  (t9-7 (method-of-type nav-control clamp-vector-to-mesh-no-gaps))
                  (a1-9 (-> self danger-pos))
                  (a3-3 s2-0)
                  )
              (t9-7 a0-14 a1-9 sv-352 a3-3 s0-0)
              )
            (let* ((v1-12 s3-0)
                   (f0-7 (sqrtf (+ (* (-> v1-12 x) (-> v1-12 x)) (* (-> v1-12 z) (-> v1-12 z)))))
                   (v1-14 s2-0)
                   (f1-7 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
                   )
              (cond
                ((< 0.0 (vector-dot s1-1 gp-1))
                 (if (< 8192.0 f0-7)
                     (set! (-> s4-0 quad) (-> s3-0 quad))
                     (set! (-> s4-0 quad) (-> s2-0 quad))
                     )
                 )
                ((< 8192.0 f1-7)
                 (set! (-> s4-0 quad) (-> s2-0 quad))
                 )
                (else
                  (set! (-> s4-0 quad) (-> s3-0 quad))
                  )
                )
              )
            (let* ((v1-24 gp-1)
                   (f0-13 (sqrtf (+ (* (-> v1-24 x) (-> v1-24 x)) (* (-> v1-24 z) (-> v1-24 z)))))
                   )
              (let ((f1-12 0.8)
                    (v1-27 s5-1)
                    )
                (* f1-12 (sqrtf (+ (* (-> v1-27 x) (-> v1-27 x)) (* (-> v1-27 z) (-> v1-27 z)))))
                )
              (let ((f0-15 (/ (- (-> self danger-pos r) f0-13) (-> self danger-pos r))))
                (if (< f0-15 0.0)
                    (set! f0-15 0.0)
                    )
                (if (< 0.8 f0-15)
                    (set! f0-15 0.8)
                    )
                (set! (-> gp-1 quad) (-> s4-0 quad))
                (vector-xz-normalize! gp-1 (* 16384.0 f0-15))
                )
              )
            (vector-xz-normalize! s5-1 16384.0)
            )
          )
        )
      (vector+! gp-1 gp-1 s5-1)
      )
    (vector-xz-normalize! gp-1 4096.0)
    (let ((a0-27 (-> self nav state))
          (v1-41 (vector+! (new 'stack-no-clear 'vector) gp-1 (-> self root-override2 trans)))
          )
      (logclear! (-> a0-27 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-27 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-27 target-post quad) (-> v1-41 quad))
      )
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defbehavior civilian-avoid-danger-post2 civilian ()
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (calc-danger-vec self (-> self danger-pos) gp-0)
    (add-offset-to-target! (-> self nav state) gp-0)
    (if *citizen-debug*
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> self root-override2 trans)
          (vector+! (new 'stack-no-clear 'vector) (-> self root-override2 trans) gp-0)
          *color-blue*
          #f
          (the-as rgba -1)
          )
        )
    )
  (let ((gp-1 (new 'stack-no-clear 'vector)))
    (citizen-method-188 self gp-1)
    (add-offset-to-target! (-> self nav state) gp-1)
    (if *citizen-debug*
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> self root-override2 trans)
          (vector+! (new 'stack-no-clear 'vector) (-> self root-override2 trans) gp-1)
          *color-green*
          #f
          (the-as rgba -1)
          )
        )
    )
  (let ((a0-6 (-> self nav state))
        (v1-23 (-> self controller turn-exit-point))
        )
    (logclear! (-> a0-6 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-6 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-6 target-post quad) (-> v1-23 quad))
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defstate avoid-danger (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info-override callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self speed-walk)))
      )
    0
    (set! (-> self next-time) (+ (current-time) (get-rand-int-range self 300 600)))
    (set! (-> self last-second-pos quad) (-> self root-override2 trans quad))
    (set! (-> self last-distance)
          (vector-vector-xz-distance (-> self controller turn-exit-point) (-> self root-override2 trans))
          )
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.0 0.0 1.0 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (none)
    )
  :trans (behavior ()
    (if (< (+ (-> self last-danger-time) (seconds 1)) (current-time))
        (go-virtual active)
        )
    (when (citizen-method-187 self)
      (cond
        ((< (* 2.0 (-> self danger-pos r))
            (vector-vector-xz-distance (-> self danger-pos) (-> self controller turn-exit-point))
            )
         (go-virtual active)
         )
        (else
          (vehicle-controller-method-14 (-> self controller) (the-as vehicle self))
          (set! (-> self last-distance)
                (vector-vector-xz-distance (-> self controller turn-exit-point) (-> self root-override2 trans))
                )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info-override walk-anim))) 60)
    (none)
    )
  :post (behavior ()
    (civilian-avoid-danger-post2)
    (none)
    )
  )

(defbehavior civilian-clear-path-post civilian ()
  (local-vars (sv-304 nav-poly))
  (let ((s5-1
          (vector-! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (the-as vector (-> self cp-sphere)))
          )
        (s1-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> gp-0 quad) (-> self cp-vec quad))
    (set! (-> gp-0 y) 0.0)
    (vector-xz-normalize! gp-0 1.0)
    (vector-rotate90-around-y! gp-0 gp-0)
    (set! (-> s5-1 y) 0.0)
    (vector-*! s1-0 s5-1 gp-0 (vector-dot s5-1 gp-0))
    (vector+! s1-0 s1-0 (the-as vector (-> self cp-sphere)))
    (vector-xz-normalize! s5-1 1.0)
    (let ((s3-0 (new 'stack-no-clear 'vector))
          (s2-0 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          (s0-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
          )
      (set! sv-304 (-> self nav state current-poly))
      (let ((f30-0 (+ 4096.0 (-> self cp-sphere r))))
        (when sv-304
          (vector-normalize-copy! s3-0 gp-0 f30-0)
          (vector-normalize-copy! s2-0 gp-0 (- f30-0))
          (clamp-vector-to-mesh-no-gaps (-> self nav) s1-0 sv-304 s3-0 s0-0)
          (let ((a0-12 (-> self nav))
                (t9-8 (method-of-type nav-control clamp-vector-to-mesh-no-gaps))
                (a3-3 s2-0)
                )
            (t9-8 a0-12 s1-0 sv-304 a3-3 s0-0)
            )
          (let* ((v1-14 s3-0)
                 (f0-9 (sqrtf (+ (* (-> v1-14 x) (-> v1-14 x)) (* (-> v1-14 z) (-> v1-14 z)))))
                 (v1-16 s2-0)
                 (f1-8 (sqrtf (+ (* (-> v1-16 x) (-> v1-16 x)) (* (-> v1-16 z) (-> v1-16 z)))))
                 )
            (cond
              ((< 0.0 (vector-dot gp-0 s5-1))
               (if (< 4096.0 f0-9)
                   (set! (-> s4-0 quad) (-> s3-0 quad))
                   (set! (-> s4-0 quad) (-> s2-0 quad))
                   )
               )
              ((< 4096.0 f1-8)
               (set! (-> s4-0 quad) (-> s2-0 quad))
               )
              (else
                (set! (-> s4-0 quad) (-> s3-0 quad))
                )
              )
            )
          (set! (-> gp-0 quad) (-> s4-0 quad))
          )
        )
      )
    (if *citizen-debug*
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (-> self root-override2 trans)
          (vector+! (new 'stack-no-clear 'vector) (-> self root-override2 trans) gp-0)
          *color-blue*
          #f
          (the-as rgba -1)
          )
        )
    (let ((a0-21 (-> self nav state))
          (v1-34 (vector+! (new 'stack-no-clear 'vector) gp-0 (-> self root-override2 trans)))
          )
      (logclear! (-> a0-21 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-21 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-21 target-post quad) (-> v1-34 quad))
      )
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defbehavior civilian-clear-path-post2 civilian ()
  (citizen-method-192 self)
  (when (< (-> self cp-next-time) (current-time))
    (citizen-method-190 self (-> self cp-force))
    (set! (-> self cp-next-time) (+ (current-time) (get-rand-int-range self 1200 2400)))
    )
  (let ((gp-1 (new 'stack-no-clear 'vector)))
    (citizen-method-188 self gp-1)
    (add-offset-to-target! (-> self nav state) gp-1)
    )
  (if *citizen-debug*
      (add-debug-line
        #t
        (bucket-id debug-no-zbuf1)
        (-> self root-override2 trans)
        (vector+! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (-> self cp-force))
        *color-blue*
        #f
        (the-as rgba -1)
        )
      )
  (add-offset-to-target! (-> self nav state) (-> self cp-force))
  (let ((a0-9 (-> self nav state))
        (v1-25 (-> self controller turn-exit-point))
        )
    (logclear! (-> a0-9 flags) (nav-state-flag directional-mode))
    (logior! (-> a0-9 flags) (nav-state-flag target-poly-dirty))
    (set! (-> a0-9 target-post quad) (-> v1-25 quad))
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defstate clear-path (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info-override callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 target-speed) (* (-> self speed-scale) (-> self speed-walk)))
      )
    0
    (set! (-> self cp-next-time) (+ (current-time) (get-rand-int-range self 1200 2400)))
    (set! (-> self cp-force quad) (the-as uint128 0))
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.0 1.0 0.0 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (none)
    )
  :trans (behavior ()
    (when (citizen-method-187 self)
      (vehicle-controller-method-14 (-> self controller) (the-as vehicle self))
      (set! (-> self last-distance)
            (vector-vector-xz-distance (-> self controller turn-exit-point) (-> self root-override2 trans))
            )
      )
    (let ((v1-8
            (vector-! (new 'stack-no-clear 'vector) (-> self root-override2 trans) (the-as vector (-> self cp-sphere)))
            )
          )
      (cond
        ((< (* 0.5 (vector-length (-> self cp-vec))) (vector-length v1-8))
         (let ((a0-10 (-> self nav)))
           (set! (-> a0-10 target-speed) (* (-> self speed-scale) (-> self speed-walk)))
           )
         0
         (let ((a0-12 (-> self nav)))
           (set! (-> a0-12 acceleration) (-> self enemy-info-override walk-acceleration))
           )
         0
         (let ((a0-14 (-> self nav)))
           (set! (-> a0-14 turning-acceleration) (-> self enemy-info-override walk-turning-acceleration))
           )
         0
         )
        (else
          (let ((a0-16 (-> self nav)))
            (set! (-> a0-16 target-speed) (* (-> self speed-scale) (-> self speed-run)))
            )
          0
          (let ((a0-18 (-> self nav)))
            (set! (-> a0-18 acceleration) (-> self enemy-info-override run-acceleration))
            )
          0
          (let ((a0-20 (-> self nav)))
            (set! (-> a0-20 turning-acceleration) (-> self enemy-info-override run-turning-acceleration))
            )
          0
          )
        )
      (if (and (-> self allow-dive)
               (< (vector-length v1-8) (* (-> self dive-reaction) (vector-length (-> self cp-vec))))
               (< (fabs (vector4-dot (-> self root-override2 trans) (the-as vector (-> self cp-plane))))
                  (* 0.5 (-> self cp-sphere r))
                  )
               )
          (go-dive self)
          )
      )
    (if (< (-> self cp-exit-time) (current-time))
        (go-virtual active)
        )
    (none)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info-override walk-anim))) 30)
    (none)
    )
  :post (behavior ()
    (civilian-clear-path-post2)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-dive civilian ((obj civilian))
  (if (< (-> obj nav state speed) 8192.0)
      (go (method-of-object obj on-ground))
      (go (method-of-object obj dive))
      )
  (none)
  )

(defstate on-ground (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-8 (-> self root-override2 root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self root-override2 nav-flags) (nav-flags has-root-sphere has-extra-sphere))
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.5 0.5 1.0 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (let ((v1-5 (-> self root-override2 root-prim)))
      (set! (-> v1-5 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-5 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (logior! (-> self root-override2 nav-flags) (nav-flags has-root-sphere))
    (none)
    )
  :trans (behavior ()
    (if (< (+ (-> self last-danger-time) (seconds 1)) (current-time))
        (go-virtual get-up-front)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-on-ground))
                :num! (seek!
                  (the float
                       (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-on-ground))) frames num-frames) -1)
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (nav-enemy-simple-post)
    (none)
    )
  )

(defstate dive (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-2 enemy-flags)))
          (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-2 enemy-flags))))
          )
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-2 enemy-flags))))
      (set! (-> v1-2 nav callback-info) (-> v1-2 enemy-info-override callback-info))
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (let ((v1-8 (-> self root-override2 root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self root-override2 nav-flags) (nav-flags has-root-sphere has-extra-sphere))
    (let ((v1-12 (-> self nav)))
      (set! (-> v1-12 sphere-mask) (the-as uint 0))
      )
    0
    (let ((v1-14 (-> self nav)))
      (set! (-> v1-14 target-speed) 32768.0)
      )
    0
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 acceleration) 32768.0)
      )
    0
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (let ((a1-4 (-> self nav state)))
        (set! (-> gp-0 quad) (-> a1-4 heading quad))
        )
      (vector-normalize! gp-0 614400.0)
      (vector+! (-> self dive-target-point) (-> self root-override2 trans) gp-0)
      (set! (-> self dive-target-point quad) (-> gp-0 quad))
      )
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.5 0.5 1.0 1.0)
        )
    (set! (-> self dive-finished?) #f)
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (let ((v1-5 (-> self root-override2 root-prim)))
      (set! (-> v1-5 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-5 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (logior! (-> self root-override2 nav-flags) (nav-flags has-root-sphere))
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 sphere-mask) (the-as uint #x800fe))
      )
    0
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-dive))
                :num! (seek!
                  (the float
                       (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-dive))) frames num-frames) -1)
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (add-offset-to-target! (-> self nav state) (-> self dive-target-point))
      (if (>= (ja-frame-num 0) 6.0)
          (vector-v*float++! (-> self dive-target-point) (-> self dive-target-point) -20.0)
          )
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (set! (-> self dive-finished?) #t)
    (set! (-> self root-override2 transv quad) (the-as uint128 0))
    (go-virtual cower-ground)
    (none)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 *null-vector*)
          )
      (logior! (-> a0-0 flags) (nav-state-flag directional-mode))
      (set! (-> a0-0 travel quad) (-> v1-1 quad))
      )
    0
    (if (-> self dive-finished?)
        (track-target! self)
        (nav-enemy-method-176 self)
        )
    (none)
    )
  )

(defstate cower-ground (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-8 (-> self root-override2 root-prim)))
      (set! (-> v1-8 prim-core collide-as) (collide-spec))
      (set! (-> v1-8 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self root-override2 nav-flags) (nav-flags has-root-sphere has-extra-sphere))
    (let ((v1-12 (-> self nav)))
      (set! (-> v1-12 sphere-mask) (the-as uint 0))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 0.2 0.2 0.2 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (let ((v1-5 (-> self root-override2 root-prim)))
      (set! (-> v1-5 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-5 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (logior! (-> self root-override2 nav-flags) (nav-flags has-root-sphere))
    (let ((v1-9 (-> self nav)))
      (set! (-> v1-9 sphere-mask) (the-as uint #x800fe))
      )
    0
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-start))
                :num! (seek!
                  (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self info anim-cover-head-start)))
                                    frames
                                    num-frames
                                    )
                                -1
                                )
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-loop))
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self info anim-cover-head-loop)))
                                      frames
                                      num-frames
                                      )
                                  -1
                                  )
                         )
                    (-> self speed-scale)
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max (-> self speed-scale)))
        )
      (if (< (+ (-> self last-danger-time) (seconds 1)) (current-time))
          (goto cfg-9)
          )
      )
    #f
    (label cfg-9)
    (ja-no-eval :group! (-> self draw art-group data (-> self info anim-cover-head-end))
                :num! (seek!
                  (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self info anim-cover-head-end)))
                                    frames
                                    num-frames
                                    )
                                -1
                                )
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (go-virtual get-up-front)
    (none)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 *null-vector*)
          )
      (logior! (-> a0-0 flags) (nav-state-flag directional-mode))
      (set! (-> a0-0 travel quad) (-> v1-1 quad))
      )
    0
    (track-target! self)
    (none)
    )
  )

(defstate get-up-front (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-front))
                :num! (seek!
                  (the float
                       (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-get-up-front))) frames num-frames)
                          -1
                          )
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (go-virtual flee)
    (none)
    )
  :post (behavior ()
    (enemy-method-49 self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (track-target! self)
    (none)
    )
  )

(defstate get-up-back (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-2 self))
      (set! (-> v1-2 enemy-flags) (the-as enemy-flag (logclear (-> v1-2 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-2 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logclear (-> v1-5 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 0.5 0.5 1.0)
        )
    (none)
    )
  :exit (behavior ()
    (if *citizen-debug*
        (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
        )
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja-no-eval :group! (-> self draw art-group data (-> self anim-get-up-back))
                :num! (seek!
                  (the float
                       (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self anim-get-up-back))) frames num-frames) -1)
                       )
                  (-> self speed-scale)
                  )
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max (-> self speed-scale)))
      )
    (go-virtual flee)
    (none)
    )
  :post (behavior ()
    (enemy-method-49 self)
    (let ((a0-1 (-> self nav state))
          (v1-3 *null-vector*)
          )
      (logior! (-> a0-1 flags) (nav-state-flag directional-mode))
      (set! (-> a0-1 travel quad) (-> v1-3 quad))
      )
    0
    (track-target! self)
    (none)
    )
  )

(defbehavior civilian-falling-post civilian ()
  (set! (-> self enemy-flags) (logior (enemy-flag directed) (-> self enemy-flags)))
  (let ((gp-0 (-> self root-override2)))
    (cond
      ((focus-test? self under-water)
       (enemy-method-47 self (-> gp-0 transv))
       )
      (else
        (let ((a1-1 (new-stack-vector0)))
          (vector-v++!
            (-> gp-0 transv)
            (compute-acc-due-to-gravity gp-0 a1-1 (-> self enemy-info-override slip-factor))
            )
          )
        )
      )
    (let ((a2-1 (new 'stack-no-clear 'collide-query)))
      (set! (-> a2-1 collide-with) (-> gp-0 root-prim prim-core collide-with))
      (set! (-> a2-1 ignore-process0) self)
      (set! (-> a2-1 ignore-process1) (-> self vehicle process 0))
      (set! (-> a2-1 ignore-pat) (logior (new 'static 'pat-surface :noendlessfall #x1) (-> gp-0 pat-ignore-mask)))
      (set! (-> a2-1 action-mask) (collide-action solid))
      (fill-cache-integrate-and-collide gp-0 (-> gp-0 transv) a2-1 (meters 0))
      )
    )
  (enemy-method-111 self)
  (track-target! self)
  (none)
  )

(defstate knocked (civilian)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type citizen knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self hit-face)
          (the-as uint (if (< (vector-dot
                                (-> self root-override2 transv)
                                (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat))
                                )
                              0.0
                              )
                           1
                           0
                           )
                  )
          )
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (let ((v1-1 (-> self root-override2 root-prim)))
      (set! (-> v1-1 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-1 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (let ((t9-0 (-> (method-of-type nav-enemy knocked) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (none)
    )
  :trans (behavior ()
    (let ((t9-0 (-> (method-of-type citizen knocked) trans)))
      (if t9-0
          (t9-0)
          )
      )
    (enemy-method-49 self)
    (none)
    )
  )

(defstate wait-for-ride (civilian)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('board-vehicle)
       (let ((a0-1 (the-as vehicle (-> event param 0))))
         (when a0-1
           (let ((v0-0 (the-as object (process->handle a0-1))))
             (set! (-> self vehicle) (the-as handle v0-0))
             v0-0
             )
           )
         )
       )
      (else
        (enemy-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set! (-> self state-time) (current-time))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((a0-5 (-> self nav state))
          (v1-10 *null-vector*)
          )
      (logior! (-> a0-5 flags) (nav-state-flag directional-mode))
      (set! (-> a0-5 travel quad) (-> v1-10 quad))
      )
    0
    (set! (-> self vehicle) (the-as handle #f))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (none)
    )
  :trans (behavior ()
    (if (and (not (logtest? (-> self nav state flags) (nav-state-flag in-mesh)))
             (< (-> self root-override2 trans y) 4096.0)
             )
        (go-virtual in-ditch)
        )
    (when (-> self vehicle)
      (case (-> (the-as vehicle (handle->process (-> self vehicle))) info-override object-type)
        ((14 15 16 11 12 13)
         (go-virtual move-to-vehicle)
         )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override idle-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override idle-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    0.1
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.1))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (nav-enemy-simple-post)
    (none)
    )
  )

(defmethod civilian-method-217 civilian ((obj civilian) (arg0 vector))
  (let ((s3-0 (handle->process (-> obj vehicle)))
        (s4-0 (new 'stack 'collide-query))
        )
    (compute-seat-position (the-as vehicle s3-0) arg0 (-> obj seat))
    (vector-! arg0 arg0 (-> (the-as vehicle s3-0) root-override-2 trans))
    (vector-normalize! arg0 (+ 14336.0 (vector-length arg0)))
    (vector+! arg0 arg0 (-> (the-as vehicle s3-0) root-override-2 trans))
    (when (enemy-above-ground? obj s4-0 arg0 (collide-spec backgnd) 8192.0 81920.0 1024.0)
      (set! (-> arg0 y) (-> s4-0 best-other-tri intersect y))
      (let ((v1-14 (-> obj nav))
            (a1-10 (new 'stack-no-clear 'nav-find-poly-parms))
            )
        (vector-! (-> a1-10 point) arg0 (-> v1-14 state mesh bounds))
        (set! (-> a1-10 y-threshold) (-> v1-14 nearest-y-threshold))
        (set! (-> a1-10 ignore) (the-as uint 2))
        (if (find-poly-containing-point-local (-> v1-14 state mesh) a1-10)
            (return #t)
            )
        )
      )
    )
  #f
  )

(defun do-spline2 ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 vector) (arg5 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let* ((f1-1 (* arg5 arg5))
           (f0-2 (* arg5 f1-1))
           )
      (let ((f2-3 (- (+ 1.0 (* -3.0 arg5) (* 3.0 f1-1)) f0-2))
            (f3-7 (+ (* 3.0 f0-2) (* -6.0 f1-1) (* 3.0 arg5)))
            (f1-3 (+ (* -3.0 f0-2) (* 3.0 f1-1)))
            )
        (vector-float*! arg0 arg1 f2-3)
        (let ((t2-0 arg0))
          (let ((v1-10 arg0))
            (let ((t1-3 (vector+! (new 'stack-no-clear 'vector) arg1 arg2)))
              (let ((a1-1 f3-7))
                (.mov vf7 a1-1)
                )
              (.lvf vf5 (&-> t1-3 quad))
              )
            (.lvf vf4 (&-> v1-10 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> t2-0 quad) vf6)
          )
        (let ((a2-1 arg0))
          (let ((v1-11 arg0))
            (let ((a1-3 (vector+! (new 'stack-no-clear 'vector) arg3 arg4)))
              (let ((t0-1 f1-3))
                (.mov vf7 t0-1)
                )
              (.lvf vf5 (&-> a1-3 quad))
              )
            (.lvf vf4 (&-> v1-11 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf5 vf7 :mask #b111)
          (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
          (.svf (&-> a2-1 quad) vf6)
          )
        )
      (let ((v0-0 arg0))
        (let ((v1-12 arg0))
          (let ((a0-1 arg3))
            (let ((a1-4 f0-2))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-1 quad))
            )
          (.lvf vf4 (&-> v1-12 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> v0-0 quad) vf6)
        v0-0
        )
      )
    )
  )

(defstate move-to-vehicle (civilian)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (enemy-event-handler proc arg1 event-type event)
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set! (-> self state-time) (current-time))
    (let ((v1-4 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-4 enemy-flags)))
          (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-4 enemy-flags))))
          )
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-4 enemy-flags))))
      (set! (-> v1-4 nav callback-info) (-> v1-4 enemy-info-override callback-info))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-7 enemy-flags))))
      )
    0
    (nav-enemy-method-166 self)
    (let ((v1-12 (-> self nav state)))
      (set! (-> v1-12 speed) 0.0)
      )
    0
    (let ((v1-14 (-> self nav)))
      (set! (-> v1-14 sphere-mask) (the-as uint #x800f8))
      )
    0
    (none)
    )
  :exit (behavior ()
    (let ((v1-0 (-> self nav)))
      (set! (-> v1-0 sphere-mask) (the-as uint #x800fe))
      )
    0
    (logclear! (-> self flags) (citizen-flag persistent))
    (none)
    )
  :trans (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (new 'stack-no-clear 'vector)
      (let ((s0-0 (handle->process (-> self vehicle))))
        (cond
          (s0-0
            (set! (-> self seat) (get-best-seat-for-vehicle
                                   (the-as vehicle s0-0)
                                   (-> self root-override2 trans)
                                   (the-as int (-> self info seat-flag))
                                   1
                                   )
                  )
            (cond
              ((!= (-> self seat) -1)
               (compute-seat-position (the-as vehicle s0-0) gp-0 (-> self seat))
               (let ((s2-0 (new 'stack-no-clear 'vector))
                     (s4-0 (new 'stack-no-clear 'vector))
                     (s1-0 (new 'stack-no-clear 'vector))
                     (s5-0 (new 'stack-no-clear 'vector))
                     )
                 (let ((s3-0 (new 'stack-no-clear 'vector)))
                   (new 'stack-no-clear 'vector)
                   (set! (-> s2-0 quad) (-> self root-override2 trans quad))
                   (set! (-> s1-0 quad) (-> gp-0 quad))
                   (vector-! s5-0 gp-0 (-> (the-as vehicle s0-0) root-override-2 trans))
                   (vector-z-quaternion! s4-0 (-> self root-override2 quat))
                   (let ((f30-1 (* 0.5 (vector-vector-xz-distance s2-0 s1-0))))
                     (vector-normalize! s4-0 (* 2.0 f30-1))
                     (vector-normalize! s5-0 (* 4.0 f30-1))
                     )
                   (do-spline2 s3-0 s2-0 s4-0 s1-0 s5-0 0.8)
                   (let ((v1-21 (-> self nav state)))
                     (logclear! (-> v1-21 flags) (nav-state-flag directional-mode))
                     (logior! (-> v1-21 flags) (nav-state-flag target-poly-dirty))
                     (set! (-> v1-21 target-post quad) (-> s3-0 quad))
                     )
                   )
                 0
                 (if (and (< (vector-dot (vector-normalize! s4-0 1.0) (vector-normalize! s5-0 1.0)) -0.5)
                          (< (vector-vector-xz-distance gp-0 (-> self root-override2 trans)) 18432.0)
                          (< (fabs (- (-> gp-0 y) (-> self root-override2 trans y))) 20480.0)
                          )
                     (go-virtual board-vehicle)
                     )
                 )
               )
              (else
                (go-virtual wait-for-ride)
                )
              )
            )
          (else
            (go-virtual wait-for-ride)
            )
          )
        )
      (if (< 73728.0 (vector-vector-xz-distance gp-0 (-> self root-override2 trans)))
          (go-virtual wait-for-ride)
          )
      )
    (none)
    )
  :code (behavior ()
    (citizen-travel-anim (the-as int (-> self draw art-group data (-> self enemy-info-override walk-anim))) 60)
    (none)
    )
  :post (behavior ()
    (nav-enemy-method-176 self)
    (none)
    )
  )

(defstate board-vehicle (civilian)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('vehicle-crash)
       #f
       )
      (('end-task)
       (kill-prefer-falling self)
       )
      (else
        (enemy-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set! (-> self state-time) (current-time))
    (let ((v1-5 (-> self root-override2 root-prim)))
      (set! (-> v1-5 prim-core collide-as) (collide-spec))
      (set! (-> v1-5 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-7 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-10 self))
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logclear (-> v1-10 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (logclear! (-> self focus-status) (focus-status pilot))
    (none)
    )
  :trans (behavior ()
    (let ((v1-1 (handle->process (-> self vehicle))))
      (if (or (not v1-1) (logtest? (-> (the-as vehicle v1-1) flags) (rigid-body-object-flag dead)))
          (throw-off-vehicle self)
          )
      )
    (none)
    )
  :code (behavior ()
    (local-vars (sv-128 float) (sv-144 float))
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim)) :num! min)
    (let ((f30-0 0.0))
      (while (< f30-0 1.0)
        (ja :num-func num-func-identity
            :frame-num (lerp-scale 0.0 1.0 (+ (* -2.0 f30-0 f30-0 f30-0) (* 3.0 f30-0 f30-0)) 0.0 1.0)
            )
        (suspend)
        (+! f30-0 (* 3.0 (-> self clock seconds-per-frame)))
        )
      )
    (let ((gp-2 (new 'stack-no-clear 'vector)))
      (set! (-> gp-2 quad) (-> self root-override2 trans quad))
      (let ((s5-0 (quaternion-copy! (new 'stack-no-clear 'quaternion) (-> self root-override2 quat))))
        (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                    :num! (seek! (ja-aframe 5.0 0) 0.86956525)
                    :frame-num (ja-aframe 1.0 0)
                    )
        (until (ja-done? 0)
          (let ((s2-0 (handle->process (-> self vehicle)))
                (s1-0 (new 'stack-no-clear 'vector))
                (s4-1 (new 'stack-no-clear 'vector))
                (s3-0 (new 'stack-no-clear 'quaternion))
                )
            (if (not s2-0)
                (go-virtual wait-for-ride)
                )
            (quaternion-copy! s3-0 (-> (the-as vehicle s2-0) root-override-2 quat))
            (compute-seat-position (the-as vehicle s2-0) s1-0 (-> self seat))
            (vector-! s4-1 s1-0 gp-2)
            (let ((s2-1 lerp-scale)
                  (s1-1 0.0)
                  (s0-0 1.0)
                  )
              (set! sv-128 (ja-aframe-num 0))
              (set! sv-144 (ja-aframe 1.0 0))
              (let* ((t0-1 (ja-aframe 5.0 0))
                     (f30-1 (s2-1 s1-1 s0-0 sv-128 sv-144 t0-1))
                     )
                (quaternion-rotate-local-y! s3-0 s3-0 (* f30-1 (if (zero? (-> self seat))
                                                                   -16384.0
                                                                   16384.0
                                                                   )
                                                         )
                                            )
                (quaternion-slerp! (-> self root-override2 quat) s5-0 s3-0 f30-1)
                (vector+float*! (-> self root-override2 trans) gp-2 s4-1 f30-1)
                )
              )
            )
          (suspend)
          (ja :num! (seek! (ja-aframe 5.0 0) 0.86956525))
          )
        )
      )
    (quaternion-copy! (new 'stack-no-clear 'quaternion) (-> self root-override2 quat))
    (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                :num! (seek! (ja-aframe 12.0 0) 0.4)
                :frame-num (ja-aframe 5.0 0)
                )
    (until (ja-done? 0)
      (let ((s5-1 (handle->process (-> self vehicle)))
            (gp-4 (new 'stack-no-clear 'quaternion))
            )
        (if (not s5-1)
            (go-virtual wait-for-ride)
            )
        (quaternion-copy! gp-4 (-> (the-as vehicle s5-1) root-override-2 quat))
        (compute-seat-position (the-as vehicle s5-1) (-> self root-override2 trans) (-> self seat))
        (let ((f0-22 (lerp-scale 0.0 1.0 (ja-aframe-num 0) (ja-aframe 7.0 0) (ja-aframe 10.0 0))))
          (quaternion-rotate-local-y! (-> self root-override2 quat) gp-4 (* (- 1.0 f0-22) (if (zero? (-> self seat))
                                                                                              -16384.0
                                                                                              16384.0
                                                                                              )
                                                                            )
                                      )
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 12.0 0) 0.4))
      )
    (put-rider-in-seat (the-as vehicle (handle->process (-> self vehicle))) (-> self seat) self)
    (go-virtual ride)
    (none)
    )
  :post (behavior ()
    (track-target! self)
    (none)
    )
  )

(defstate ride (civilian)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type)
          (t0-0 'exit-vehicle)
          )
      (cond
        ((= v1-0 t0-0)
         (let ((a0-1 (the-as object (-> event param 0))))
           (set! (-> self event-param-point quad) (-> (the-as vector a0-1) quad))
           )
         (let ((v1-3 (current-time))
               (a0-3 (-> self state-time))
               )
           (if (>= (- v1-3 a0-3) (seconds 1))
               (go-virtual
                 exit-vehicle
                 a0-3
                 arg1
                 (the-as int event-type)
                 (the-as symbol event)
                 (the-as event-message-block t0-0)
                 )
               )
           )
         )
        ((= v1-0 'end-task)
         (kill-prefer-falling self)
         )
        (else
          (enemy-event-handler proc arg1 event-type event)
          )
        )
      )
    )
  :enter (behavior ()
    (logior! (-> self flags) (citizen-flag persistent))
    (set! (-> self state-time) (current-time))
    (let ((v1-5 (-> self root-override2 root-prim)))
      (set! (-> v1-5 prim-core collide-as) (collide-spec))
      (set! (-> v1-5 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-7 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-10 self))
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logclear (-> v1-10 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (set! (-> self focus-status) (logior (focus-status pilot-riding pilot) (-> self focus-status)))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (none)
    )
  :trans (behavior ()
    (let ((v1-1 (handle->process (-> self vehicle))))
      (if (or (not v1-1) (logtest? (-> (the-as vehicle v1-1) flags) (rigid-body-object-flag dead)))
          (throw-off-vehicle self)
          )
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (track-target! self)
    (none)
    )
  )

(defstate exit-vehicle (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ((arg0 object) (arg1 object) (arg2 int) (arg3 symbol) (arg4 event-message-block))
    (change-to (find-nearest-nav-mesh (-> self root-override2 trans) (the-as float #x7f800000)) self)
    (if (not (-> self nav))
        (go-inactive self)
        )
    (let ((v1-8 (-> self nav state)))
      (set! (-> v1-8 current-poly) (the-as nav-poly #f))
      )
    0
    (citizen-method-195
      self
      (vector-negate-in-place! (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self root-override2 quat)))
      )
    (let ((a0-8 (-> self nav state))
          (v1-14 (-> self controller turn-exit-point))
          )
      (logclear! (-> a0-8 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-8 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-8 target-post quad) (-> v1-14 quad))
      )
    0
    (citizen-nav-init! self)
    (set! (-> self gnd-height) (-> self root-override2 gspot-pos y))
    (logior! (-> self flags) (citizen-flag persistent))
    (set! (-> self focus-status) (logior (focus-status pilot-riding pilot) (-> self focus-status)))
    (set! (-> self state-time) (current-time))
    (let ((v1-28 (-> self root-override2 root-prim)))
      (set! (-> v1-28 prim-core collide-as) (collide-spec))
      (set! (-> v1-28 prim-core collide-with) (collide-spec))
      )
    0
    (let ((v1-30 self))
      (set! (-> v1-30 enemy-flags) (the-as enemy-flag (logclear (-> v1-30 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-30 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-33 self))
      (set! (-> v1-33 enemy-flags) (the-as enemy-flag (logclear (-> v1-33 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    (none)
    )
  :trans (behavior ()
    (let ((v1-1 (handle->process (-> self vehicle))))
      (if (or (not v1-1) (logtest? (-> (the-as vehicle v1-1) flags) (rigid-body-object-flag dead)))
          (throw-off-vehicle self)
          )
      )
    (none)
    )
  :code (behavior ((arg0 object) (arg1 object) (arg2 int) (arg3 symbol) (arg4 event-message-block))
    (local-vars (sv-128 float) (sv-144 float))
    (ja-channel-push! 1 (seconds 0.1))
    (remove-rider (the-as vehicle (handle->process (-> self vehicle))) self)
    (logclear! (-> self focus-status) (focus-status pilot-riding pilot))
    (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                :num! (seek! (ja-aframe 5.0 0) 0.5)
                :frame-num (ja-aframe 12.0 0)
                )
    (until (ja-done? 0)
      (let ((s5-0 (handle->process (-> self vehicle)))
            (gp-1 (new 'stack-no-clear 'quaternion))
            )
        (quaternion-copy! gp-1 (-> (the-as vehicle s5-0) root-override-2 quat))
        (compute-seat-position (the-as vehicle s5-0) (-> self root-override2 trans) (-> self seat))
        (let ((f0-3 (lerp-scale 0.0 1.0 (ja-aframe-num 0) (ja-aframe 10.0 0) (ja-aframe 7.0 0))))
          (quaternion-rotate-local-y! (-> self root-override2 quat) gp-1 (* f0-3 (if (zero? (-> self seat))
                                                                                     -16384.0
                                                                                     16384.0
                                                                                     )
                                                                            )
                                      )
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 5.0 0) 0.5))
      )
    (let ((gp-3 (new 'stack-no-clear 'vector))
          (s5-2 (new 'stack-no-clear 'quaternion))
          )
      (while (not (civilian-method-217 self gp-3))
        (let ((s4-1 (handle->process (-> self vehicle)))
              (s3-1 (new 'stack-no-clear 'quaternion))
              )
          (quaternion-copy! s3-1 (-> (the-as vehicle s4-1) root-override-2 quat))
          (compute-seat-position (the-as vehicle s4-1) (-> self root-override2 trans) (-> self seat))
          (quaternion-rotate-local-y! (-> self root-override2 quat) s3-1 (if (zero? (-> self seat))
                                                                             -16384.0
                                                                             16384.0
                                                                             )
                                      )
          )
        (suspend)
        )
      (let ((v1-43 (handle->process (-> self vehicle))))
        (quaternion-copy! s5-2 (-> (the-as vehicle v1-43) root-override-2 quat))
        )
      (ja-no-eval :group! (-> self draw art-group data (-> self info get-in-car-anim))
                  :num! (seek! (ja-aframe 1.0 0) 0.5)
                  :frame-num (ja-aframe 5.0 0)
                  )
      (until (ja-done? 0)
        (let ((a0-47 (handle->process (-> self vehicle)))
              (s2-1 (new 'stack-no-clear 'vector))
              (s4-3 (new 'stack-no-clear 'vector))
              (s3-2 (new 'stack-no-clear 'quaternion))
              )
          (compute-seat-position (the-as vehicle a0-47) s2-1 (-> self seat))
          (vector-! s4-3 s2-1 gp-3)
          (let ((s2-2 lerp-scale)
                (s1-1 0.0)
                (s0-0 1.0)
                )
            (set! sv-128 (ja-aframe-num 0))
            (set! sv-144 (ja-aframe 5.0 0))
            (let* ((t0-2 (ja-aframe 1.0 0))
                   (f0-12 (s2-2 s1-1 s0-0 sv-128 sv-144 t0-2))
                   (f30-0 (- 1.0 f0-12))
                   )
              (quaternion-rotate-local-y! s3-2 s5-2 (if (zero? (-> self seat))
                                                        -16384.0
                                                        16384.0
                                                        )
                                          )
              (quaternion-copy! (-> self root-override2 quat) s3-2)
              (vector+float*! (-> self root-override2 trans) gp-3 s4-3 f30-0)
              )
            )
          )
        (suspend)
        (ja :num! (seek! (ja-aframe 1.0 0) 0.5))
        )
      )
    (let ((v1-74 (-> self root-override2 root-prim)))
      (set! (-> v1-74 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-74 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (go-virtual active)
    (none)
    )
  :post (behavior ()
    (track-target! self)
    (none)
    )
  )

(defstate wait-at-dest (civilian)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior civilian) enemy-event-handler)
  :enter (behavior ()
    (logclear! (-> self flags) (citizen-flag persistent))
    (set! (-> self state-time) (current-time))
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override idle-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override idle-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    0.1
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.1))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (nav-enemy-simple-post)
    (none)
    )
  )
