;;-*-Lisp-*-
(in-package goal)

;; name: wren.gc
;; name in dgo: wren
;; dgos: FOR

;; DECOMP BEGINS

(deftype wren (process-drawable)
  ((move-dest      vector        :inline :offset-assert 208)
   (fly-curve      curve-control 2       :offset-assert 224)
   (fly-index      uint32                :offset-assert 232)
   (fly-speed      float                 :offset-assert 236)
   (fly-y-rate     float                 :offset-assert 240)
   (fly-interp     float                 :offset-assert 244)
   (path-u         float                 :offset-assert 248)
   (path-du        float                 :offset-assert 252)
   (path-du-mod    float                 :offset-assert 256)
   (bob-level      float                 :offset-assert 260)
   (bob-level-seek float                 :offset-assert 264)
   (bank-angle     float                 :offset-assert 268)
   (peck-timer     uint64                :offset-assert 272)
   (flags          uint16                :offset-assert 280)
   )
  :heap-base #xa0
  :method-count-assert 28
  :size-assert         #x11a
  :flag-assert         #x1c00a0011a
  (:methods
    (hunt () _type_ :state 20)
    (peck () _type_ :state 21)
    (fly () _type_ :state 22)
    (land () _type_ :state 23)
    (on-branch () _type_ :state 24)
    (die () _type_ :state 25)
    (spooked? (_type_) symbol 26)
    (debug-draw-path (_type_) symbol 27)
    )
  )


(defskelgroup skel-wren wren wren-lod0-jg wren-idle-ja
              ((wren-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 4)
              )

(defmethod debug-draw-path wren ((obj wren))
  "Draws the associated [[curve-control]]s associated with this wren"
  (dotimes (s5-0 2)
    (if (-> obj fly-curve s5-0)
        (debug-draw (-> obj fly-curve s5-0))
        )
    )
  #f
  )

(defbehavior fly-post wren ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (seek! (-> self bob-level) (-> self bob-level-seek) (* 12288.0 (-> self clock seconds-per-frame)))
    (let ((gp-0 (-> self fly-curve (-> self fly-index))))
      (get-point-at-percent-along-path! gp-0 (-> self root trans) (-> self path-u) 'interp)
      (seek! (-> self path-u) 1.0 (* (-> self path-du) (-> self path-du-mod) (-> self clock seconds-per-frame)))
      (seek! (-> self path-du) 0.2 (* 0.1 (-> self clock seconds-per-frame)))
      (let* ((f30-0 (-> self path-u))
             (f0-16 (fmin 1.0 (+ 0.125 f30-0)))
             (s4-0 (displacement-between-points-at-percent-normalized! gp-0 (new 'stack-no-clear 'vector) f0-16))
             (s3-0 (displacement-between-points-at-percent-normalized! gp-0 (new 'stack-no-clear 'vector) f30-0))
             (gp-1 (-> self root quat))
             )
        (forward-up->quaternion gp-1 s4-0 *up-vector*)
        (set! (-> self fly-y-rate) (tan (vector-x-angle s4-0)))
        (let ((s5-1 (new 'stack-no-clear 'vector)))
          (let ((v1-16 s3-0)
                (a0-9 s4-0)
                )
            (.lvf vf1 (&-> v1-16 quad))
            (.lvf vf2 (&-> a0-9 quad))
            )
          (.add.x.vf vf1 vf0 vf0 :mask #b10)
          (.add.x.vf vf2 vf0 vf0 :mask #b10)
          (.outer.product.a.vf acc vf1 vf2)
          (.outer.product.b.vf vf3 vf2 vf1 acc)
          (.svf (&-> s5-1 quad) vf3)
          (let* ((f0-19 (acos (vector-dot s3-0 s4-0)))
                 (f1-8 (if (< 0.0 (vector-dot s5-1 *up-vector*))
                           (- f0-19)
                           f0-19
                           )
                       )
                 )
            (if (and (-> self next-state) (= (-> self next-state name) 'fly))
                (seek! (-> self bank-angle) f1-8 (* f0-19 (-> self clock seconds-per-frame)))
                (seek! (-> self bank-angle) 0.0 (* 8192.0 (-> self clock seconds-per-frame)))
                )
            )
          )
        (quaternion-rotate-local-z! gp-1 gp-1 (-> self bank-angle))
        )
      )
    0
    (debug-draw-path self)
    (+! (-> self root trans y) (-> self bob-level))
    (ja-post)
    (none)
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defmethod spooked? wren ((obj wren))
  "@returns a [[symbol]] indicating if Jak is considered close enough to the wren to spook it.
If so, it transitions from [[wren::peck]] to [[wren::hunt]]"
  (let* ((gp-0 *target*)
         (a0-2 (if (type? gp-0 process-focusable)
                   gp-0
                   )
               )
         )
    (the-as symbol (and a0-2 (< (vector-vector-xz-distance (-> obj root trans) (get-trans a0-2 0)) 102400.0)))
    )
  )

(defstate hunt (wren)
  :virtual #t
  :trans (behavior ()
    (when (< (vector-vector-xz-distance (-> self root trans) (-> self move-dest)) 2048.0)
      (cond
        ((logtest? (-> self flags) 4)
         (set! (-> self flags) (logand -5 (-> self flags)))
         (set! (-> self fly-index) (the-as uint 0))
         (go-virtual fly)
         )
        (else
          (go-virtual peck)
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (ja-no-eval :group! wren-hop-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim wren-hop-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans))))
        (vector-normalize! gp-1 12288.0)
        (let ((v1-1 (new 'stack-no-clear 'vector)))
          (.lvf vf1 (&-> gp-1 quad))
          (let ((f0-0 (-> self clock seconds-per-frame)))
            (.mov at-0 f0-0)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-1 quad) vf1)
          (vector+! (-> self root trans) (-> self root trans) v1-1)
          )
        )
      (ja-post)
      (none)
      )
    )
  )

(defstate peck (wren)
  :virtual #t
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self peck-timer) (the-as uint (the int (* 300.0 (rand-vu-float-range 1.4 4.3)))))
    (set! (-> self flags) (logand -7 (-> self flags)))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (the-as time-frame (-> self peck-timer)))
      (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans))))
        (if (< (fabs (deg-diff (quaternion-y-angle (-> self root quat)) (vector-y-angle gp-1))) 728.1778)
            (go-virtual hunt)
            )
        )
      )
    (when (logtest? (-> self flags) 2)
      (set! (-> self flags) (logand -3 (-> self flags)))
      (when (spooked? self)
        (get-point-in-path! (-> self fly-curve 0) (-> self move-dest) 0.0 'interp)
        (set-yaw-angle-clear-roll-pitch!
          (-> self root)
          (vector-y-angle (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans)))
          )
        (logior! (-> self flags) 4)
        (go-virtual hunt)
        )
      )
    (none)
    )
  :code (behavior ()
    (local-vars (v1-34 symbol))
    (until #f
      (set! (-> self flags) (logand -2 (-> self flags)))
      (let ((f0-0 (rand-vu-float-range 0.0 (get-num-segments (-> self path)))))
        (get-point-in-path! (-> self path) (-> self move-dest) f0-0 'interp)
        )
      (logior! (-> self flags) 2)
      (ja-no-eval :group! wren-peck-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim wren-peck-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      #t
      (let ((v1-33 (the-as symbol (logand (-> self flags) 2))))
        (set! v1-33 v1-33)
        (cmove-#f-zero v1-34 v1-33 v1-33)
        )
      (let ((gp-1 (current-time))
            (s5-1 (the int (* 300.0 (rand-vu-float-range 0.1 0.6))))
            (f30-1 1.0)
            )
        (ja-no-eval :group! wren-idle-ja :num! (loop! f30-1) :frame-num 0.0)
        (until (>= (- (current-time) gp-1) s5-1)
          (suspend)
          (ja :num! (loop! f30-1))
          )
        )
      (logior! (-> self flags) 1)
      (let ((gp-2 (current-time))
            (s5-2 (the int (* 300.0 (rand-vu-float-range 0.2 1.5))))
            (f30-3 1.0)
            )
        (ja-no-eval :group! wren-idle-ja :num! (loop! f30-3) :frame-num 0.0)
        (until (>= (- (current-time) gp-2) s5-2)
          (suspend)
          (ja :num! (loop! f30-3))
          )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (if (logtest? (-> self flags) 1)
        (seek-to-point-toward-point! (-> self root) (-> self move-dest) 262144.0 (seconds 0.02))
        )
    (ja-post)
    (none)
    )
  )

(defstate fly (wren)
  :virtual #t
  :enter (behavior ()
    (set! (-> self path-u) 0.0)
    (set! (-> self path-du) 0.0)
    (set! (-> self path-du-mod) 1.0)
    (set! (-> self fly-speed) 0.0)
    (set! (-> self fly-interp) 0.0)
    (set! (-> self bob-level) 0.0)
    (set! (-> self bob-level-seek) 0.0)
    (none)
    )
  :trans (behavior ()
    (when (< 0.99 (-> self path-u))
      (if (-> self fly-curve (logand (+ (-> self fly-index) 1) 1))
          (go-virtual land)
          (go-virtual die)
          )
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (current-time))
          (s5-0 240)
          (f30-0 2.0)
          )
      (ja-no-eval :group! wren-takeoff-ja :num! (loop! f30-0) :frame-num 0.0)
      (until (>= (- (current-time) gp-0) s5-0)
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    (ja-channel-push! 2 (seconds 0.3))
    (ja-no-eval :group! wren-glide-ja
                :num! (seek! (the float (+ (-> (the-as art-joint-anim wren-glide-ja) frames num-frames) -1)))
                :frame-num 0.0
                )
    (let ((a0-4 (-> self skel root-channel 1)))
      (let ((f0-5 0.0))
        (set! (-> a0-4 frame-interp 1) f0-5)
        (set! (-> a0-4 frame-interp 0) f0-5)
        )
      (set! (-> a0-4 frame-group) (the-as art-joint-anim wren-fly-ja))
      (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim wren-fly-ja) frames num-frames) -1)))
      (set! (-> a0-4 param 1) 1.0)
      (set! (-> a0-4 frame-num) 0.0)
      (joint-control-channel-group! a0-4 (the-as art-joint-anim wren-fly-ja) num-func-seek!)
      )
    (until #f
      (let ((f0-11 (fmax -0.2 (fmin 0.5 (-> self fly-y-rate)))))
        (seek! (-> self fly-interp) (lerp-scale 0.0 1.0 f0-11 -0.2 0.5) (-> self clock seconds-per-frame))
        )
      (let ((f30-1 (-> self fly-interp)))
        (seek! (-> self path-du-mod) (+ 0.9 (* 0.2 f30-1)) (* 0.5 (-> self clock seconds-per-frame)))
        (set! (-> self bob-level-seek) (+ -12288.0 (* 24576.0 f30-1)))
        (let ((v1-59 (-> self skel root-channel 0)))
          (let ((f0-23 (- 1.0 f30-1)))
            (set! (-> v1-59 frame-interp 1) f0-23)
            (set! (-> v1-59 frame-interp 0) f0-23)
            )
          (set! (-> v1-59 frame-group) (the-as art-joint-anim wren-glide-ja))
          )
        (let ((v1-62 (-> self skel root-channel 1)))
          (set! (-> v1-62 frame-interp 1) f30-1)
          (set! (-> v1-62 frame-interp 0) f30-1)
          (set! (-> v1-62 frame-group) (the-as art-joint-anim wren-fly-ja))
          )
        (let ((f30-2 (lerp 0.6 2.4 f30-1)))
          (ja :num! (loop! f30-2))
          (ja :chan 1 :num! (loop! f30-2))
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post fly-post
  )

(defstate land (wren)
  :virtual #t
  :code (behavior ()
    (set! (-> self bob-level-seek) 0.0)
    (ja-channel-push! 1 (seconds 0.3))
    (while (!= (-> self path-u) 1.0)
      (ja-no-eval :group! wren-land-ja
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim wren-land-ja) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go-virtual on-branch)
    (none)
    )
  :post (behavior ()
    (seek! (-> self path-du-mod) 0.0 (* 0.5 (-> self clock seconds-per-frame)))
    (fly-post)
    (none)
    )
  )

(defstate on-branch (wren)
  :virtual #t
  :enter (behavior ()
    (let ((v1-6 (displacement-between-points-at-percent-normalized!
                  (-> self fly-curve (logand (+ (-> self fly-index) 1) 1))
                  (new 'stack-no-clear 'vector)
                  0.1
                  )
                )
          )
      (vector+! (-> self move-dest) (-> self root trans) v1-6)
      )
    (none)
    )
  :trans (behavior ()
    (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) (-> self move-dest) (-> self root trans))))
      (when (< (fabs (deg-diff (quaternion-y-angle (-> self root quat)) (vector-y-angle gp-1))) 728.1778)
        (when (>= (- (current-time) (-> self state-time)) (the-as time-frame (-> self peck-timer)))
          (set! (-> self fly-index) (logand (+ (-> self fly-index) 1) 1))
          (go-virtual fly)
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (set! (-> self flags) (logand -2 (-> self flags)))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((gp-0 (current-time))
          (s5-0 (the int (* 300.0 (rand-vu-float-range 4.2 16.8))))
          (f30-1 1.0)
          )
      (ja-no-eval :group! wren-idle-ja :num! (loop! f30-1) :frame-num 0.0)
      (until (>= (- (current-time) gp-0) s5-0)
        (suspend)
        (ja :num! (loop! f30-1))
        )
      )
    (logior! (-> self flags) 1)
    (let ((gp-1 (current-time))
          (s5-1 600)
          (f30-2 1.0)
          )
      (ja-no-eval :group! wren-idle-ja :num! (loop! f30-2) :frame-num 0.0)
      (until (>= (- (current-time) gp-1) s5-1)
        (suspend)
        (ja :num! (loop! f30-2))
        )
      )
    (none)
    )
  :post (behavior ()
    (if (logtest? (-> self flags) 1)
        (seek-to-point-toward-point! (-> self root) (-> self move-dest) 262144.0 (seconds 0.02))
        )
    (debug-draw-path self)
    (ja-post)
    (none)
    )
  )

(defstate die (wren)
  :virtual #t
  :code (behavior ()
    (cleanup-for-death self)
    (suspend)
    0
    (none)
    )
  )

;; WARN: Return type mismatch process-drawable vs wren.
(defmethod relocate wren ((obj wren) (arg0 int))
  (dotimes (v1-0 2)
    (when (-> obj fly-curve v1-0)
      (if (nonzero? (-> obj fly-curve v1-0))
          (&+! (-> obj fly-curve v1-0) arg0)
          )
      )
    )
  (the-as wren ((the-as (function process-drawable int process-drawable) (find-parent-method wren 7)) obj arg0))
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! wren ((obj wren) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> obj root) (new 'process 'trsqv))
  (process-drawable-from-entity! obj arg0)
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-wren" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logclear! (-> obj mask) (process-mask actor-pause))
  (let ((f0-0 (rand-vu-float-range 1.5 3.5)))
    (set-vector! (-> obj root scale) f0-0 f0-0 f0-0 1.0)
    )
  (set! (-> obj fly-index) (the-as uint 0))
  (set! (-> obj path-u) 0.0)
  (set! (-> obj flags) (the-as uint 0))
  (set! (-> obj bob-level) 0.0)
  (set! (-> obj bank-angle) 0.0)
  (set! (-> obj path) (new 'process 'path-control obj 'idle 0.0 arg0 #f))
  (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
  (cond
    ((logtest? (-> obj path flags) (path-control-flag not-found))
     (dotimes (s5-1 2)
       (set! (-> obj fly-curve s5-1) (new 'process 'curve-control obj 'path (the float s5-1)))
       (logior! (-> obj fly-curve s5-1 flags) (path-control-flag display draw-line draw-point draw-text))
       )
     (setup-masks (-> obj draw) 0 -1)
     (setup-masks (-> obj draw) 8 0)
     (go (method-of-object obj fly))
     )
    (else
      (set! (-> obj fly-curve 0) (new 'process 'curve-control obj 'takeoff -1000000000.0))
      (logior! (-> obj fly-curve 0 flags) (path-control-flag display draw-line draw-point draw-text))
      (set! (-> obj fly-curve 1) #f)
      (setup-masks (-> obj draw) 0 -1)
      (setup-masks (-> obj draw) 2 0)
      (go (method-of-object obj peck))
      )
    )
  (none)
  )
