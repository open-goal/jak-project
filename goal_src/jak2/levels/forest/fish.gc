;;-*-Lisp-*-
(in-package goal)

;; name: fish.gc
;; name in dgo: fish
;; dgos: FOR

;; +++fish-type
(defenum fish-type
  :type int32
  :bitfield #f
  (red 0)
  (blue 1)
  (green 2)
  (yellow 3))
;; ---fish-type


;; DECOMP BEGINS

(defskelgroup skel-minnow minnow minnow-lod0-jg minnow-idle-ja
              ((minnow-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1)
              )

(deftype minnow (process-drawable)
  ()
  :heap-base #x50
  :method-count-assert 21
  :size-assert         #xc8
  :flag-assert         #x15005000c8
  (:methods
    (idle () _type_ :state 20)
    )
  )


;; WARN: Return type mismatch object vs none.
(defbehavior minnow-init-by-other minnow ((arg0 object) (arg1 fish-type))
  "TODO - fish type"
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (the-as uint128 0))
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-minnow" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (setup-masks (-> self draw) 0 -1)
  (cond
    ((= arg1 (fish-type red))
     (setup-masks (-> self draw) 4 0)
     )
    ((= arg1 (fish-type blue))
     (setup-masks (-> self draw) 1 0)
     )
    ((= arg1 (fish-type green))
     (setup-masks (-> self draw) 2 0)
     )
    (else
      (setup-masks (-> self draw) 8 0)
      )
    )
  (go-virtual idle)
  (none)
  )

(defstate idle (minnow)
  :virtual #t
  :code (behavior ()
    (until #f
      (ja-no-eval :group! (-> self draw art-group data 2)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 2)) frames num-frames) -1)) 5.0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 5.0))
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior minnow) ja-post)
  )

(deftype fish (structure)
  ((pos       vector :inline :offset-assert   0)
   (vel       vector :inline :offset-assert  16)
   (border-f  vector :inline :offset-assert  32)
   (avoid-d   vector :inline :offset-assert  48)
   (wander    float          :offset-assert  64)
   (max-speed float          :offset-assert  68)
   (speed     float          :offset-assert  72)
   (handle    handle         :offset-assert  80)
   )
  :method-count-assert 9
  :size-assert         #x58
  :flag-assert         #x900000058
  )


(deftype fish-manager (process-drawable)
  ((fishes fish 12 :inline :offset-assert 208)
   )
  :heap-base #x4d0
  :method-count-assert 21
  :size-assert         #x550
  :flag-assert         #x1504d00550
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defstate idle (fish-manager)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (format #t "training-manager received event ~s~%" event-type)
    (format #t "event-from ~s~%" proc)
    )
  :code (the-as (function none :behavior fish-manager) sleep-code)
  :post (behavior ()
    (local-vars
      (sv-448 (function vector vector float vector))
      (sv-464 vector)
      (sv-480 vector)
      (sv-496 vector)
      (sv-512 vector)
      (sv-528 vector)
      (sv-544 vector)
      (sv-560 vector)
      (sv-576 vector)
      (sv-592 vector)
      (sv-608 vector)
      (sv-624 int)
      (sv-640 int)
      (sv-656 fish)
      (sv-672 vector)
      (sv-688 vector)
      (sv-704 vector)
      (sv-720 nav-poly)
      )
    (rlet ((acc :class vf)
           (vf0 :class vf)
           (vf4 :class vf)
           (vf5 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (-> self nav))
            (s5-0 (new 'stack 'clamp-travel-vector-to-mesh-return-info))
            )
        (dotimes (s4-0 12)
          (let* ((s1-0 (-> self fishes s4-0))
                 (s2-0 (-> s1-0 pos))
                 (s3-0 (-> s1-0 vel))
                 )
            (new 'stack-no-clear 'vector)
            (new 'stack-no-clear 'vector)
            (set! sv-544 (new 'stack-no-clear 'vector))
            (new 'stack-no-clear 'vector)
            (let ((s0-0 (new-stack-vector0)))
              (set! (-> sv-544 quad) (-> s3-0 quad))
              (set! sv-448 vector-rotate-around-y!)
              (set! sv-464 sv-544)
              (set! sv-480 sv-544)
              (let ((a2-0 (rand-vu-float-range 0.0 65536.0)))
                (sv-448 sv-464 sv-480 a2-0)
                )
              (vector-float*! sv-544 sv-544 0.5)
              (cond
                ((and *target* (< (-> (target-pos 0) y) 0.0))
                 (set! sv-512 (new 'stack-no-clear 'vector))
                 (set! sv-496 s2-0)
                 (let ((v0-4 (target-pos 0)))
                   (.lvf vf4 (&-> sv-496 quad))
                   (.lvf vf5 (&-> v0-4 quad))
                   )
                 (.mov.vf vf6 vf0 :mask #b1000)
                 (.sub.vf vf6 vf4 vf5 :mask #b111)
                 (.svf (&-> sv-512 quad) vf6)
                 (let* ((v1-21 sv-512)
                        (f0-5 (+ (* (-> v1-21 x) (-> v1-21 x)) (* (-> v1-21 z) (-> v1-21 z))))
                        (f1-4 16384.0)
                        )
                   (cond
                     ((< f0-5 (* f1-4 f1-4))
                      (set! (-> s1-0 max-speed) 40960.0)
                      (vector-normalize! sv-512 (* 4096.0 (/ 4096.0 f0-5)))
                      (let ((a0-9 (-> s1-0 avoid-d)))
                        (let ((v1-28 (-> s1-0 avoid-d)))
                          (let ((a1-6 100000.0))
                            (.mov vf7 a1-6)
                            )
                          (.lvf vf5 (&-> sv-512 quad))
                          (.lvf vf4 (&-> v1-28 quad))
                          )
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> a0-9 quad) vf6)
                        )
                      #t
                      )
                     ((let ((f1-9 81920.0))
                        (< f0-5 (* f1-9 f1-9))
                        )
                      (set! (-> s1-0 max-speed) 16384.0)
                      )
                     (else
                       (set! (-> s1-0 max-speed) 4096.0)
                       )
                     )
                   )
                 )
                (else
                  (set! (-> s1-0 max-speed) 4096.0)
                  )
                )
              (set! sv-528 (new 'stack-no-clear 'vector))
              (let ((v1-39 s2-0))
                (let ((a0-10 sv-544))
                  (let ((a1-9 -0.1))
                    (.mov vf7 a1-9)
                    )
                  (.lvf vf5 (&-> a0-10 quad))
                  )
                (.lvf vf4 (&-> v1-39 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> sv-528 quad) vf6)
              (let ((v1-41 gp-0)
                    (a0-11 sv-528)
                    (a1-10 (new 'stack-no-clear 'nav-find-poly-parms))
                    )
                (vector-! (-> a1-10 point) a0-11 (-> v1-41 state mesh bounds))
                (set! (-> a1-10 y-threshold) (-> v1-41 nearest-y-threshold))
                (set! (-> a1-10 ignore) (the-as uint 2))
                (set! sv-720 (find-poly-containing-point-local (-> v1-41 state mesh) a1-10))
                )
              (new 'stack-no-clear 'vector)
              (when sv-720
                (let ((a0-14 gp-0)
                      (t9-7 (method-of-type nav-control clamp-vector-to-mesh-no-gaps))
                      (a2-3 sv-720)
                      (t0-0 s5-0)
                      )
                  (t9-7 a0-14 sv-528 a2-3 sv-544 t0-0)
                  )
                (cond
                  ((-> s5-0 found-boundary)
                   (let ((a1-12 (-> s1-0 border-f)))
                     (let ((v1-48 (-> s1-0 border-f)))
                       (let ((a0-15 (-> s5-0 boundary-normal)))
                         (let ((a2-5 -10000.0))
                           (.mov vf7 a2-5)
                           )
                         (.lvf vf5 (&-> a0-15 quad))
                         )
                       (.lvf vf4 (&-> v1-48 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> a1-12 quad) vf6)
                     )
                   )
                  (else
                    (set! sv-608 (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 1.0))
                    (let ((a1-14 sv-608))
                      (let ((v1-49 s2-0))
                        (let ((a0-17 sv-608))
                          (let ((a2-8 4096.0))
                            (.mov vf7 a2-8)
                            )
                          (.lvf vf5 (&-> a0-17 quad))
                          )
                        (.lvf vf4 (&-> v1-49 quad))
                        )
                      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                      (.mul.x.vf acc vf5 vf7 :mask #b111)
                      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                      (.svf (&-> a1-14 quad) vf6)
                      )
                    (set! sv-592 sv-608)
                    (set! sv-560 sv-608)
                    (set! sv-576 (new 'stack-no-clear 'vector))
                    (set! (-> sv-576 x) (cos (-> s1-0 wander)))
                    (set! (-> sv-576 y) 0.0)
                    (set! (-> sv-576 z) (sin (-> s1-0 wander)))
                    (set! (-> sv-576 w) 1.0)
                    (let ((v1-59 3276.8))
                      (.mov vf7 v1-59)
                      )
                    (.lvf vf5 (&-> sv-576 quad))
                    (.lvf vf4 (&-> sv-560 quad))
                    (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                    (.mul.x.vf acc vf5 vf7 :mask #b111)
                    (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                    (.svf (&-> sv-592 quad) vf6)
                    (vector-! sv-608 sv-608 s2-0)
                    (let ((a0-21 s0-0))
                      (let ((v1-64 s0-0))
                        (let ((a1-18 10.0))
                          (.mov vf7 a1-18)
                          )
                        (.lvf vf5 (&-> sv-608 quad))
                        (.lvf vf4 (&-> v1-64 quad))
                        )
                      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                      (.mul.x.vf acc vf5 vf7 :mask #b111)
                      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                      (.svf (&-> a0-21 quad) vf6)
                      )
                    (+! (-> s1-0 wander) (rand-vu-float-range -1820.4445 1820.4445))
                    )
                  )
                )
              (set! sv-624 0)
              (set! sv-688 (new 'stack-no-clear 'vector))
              (set! (-> sv-688 quad) (the-as uint128 0))
              (set! sv-704 (new 'stack-no-clear 'vector))
              (set! (-> sv-704 quad) (the-as uint128 0))
              (set! sv-640 0)
              (while (< sv-640 12)
                (when (!= sv-640 s4-0)
                  (set! sv-656 (-> self fishes sv-640))
                  (set! sv-672 (new 'stack-no-clear 'vector))
                  (let ((v1-78 s2-0)
                        (a0-25 (-> sv-656 pos))
                        )
                    (.lvf vf4 (&-> v1-78 quad))
                    (.lvf vf5 (&-> a0-25 quad))
                    )
                  (.mov.vf vf6 vf0 :mask #b1000)
                  (.sub.vf vf6 vf4 vf5 :mask #b111)
                  (.svf (&-> sv-672 quad) vf6)
                  (let* ((v1-80 sv-672)
                         (f0-29 (+ (* (-> v1-80 x) (-> v1-80 x)) (* (-> v1-80 z) (-> v1-80 z))))
                         (f1-15 4096.0)
                         )
                    (when (< f0-29 (* f1-15 f1-15))
                      (vector-normalize! sv-672 (* 4096.0 (/ 4096.0 f0-29)))
                      (let ((a0-27 s0-0))
                        (let ((v1-87 s0-0))
                          (let ((a1-24 100.0))
                            (.mov vf7 a1-24)
                            )
                          (.lvf vf5 (&-> sv-672 quad))
                          (.lvf vf4 (&-> v1-87 quad))
                          )
                        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                        (.mul.x.vf acc vf5 vf7 :mask #b111)
                        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                        (.svf (&-> a0-27 quad) vf6)
                        )
                      (vector+! sv-688 sv-688 (-> sv-656 pos))
                      (vector+! sv-704 sv-704 (-> sv-656 vel))
                      (set! sv-624 (+ sv-624 1))
                      sv-624
                      )
                    )
                  )
                (set! sv-640 (+ sv-640 1))
                )
              (when (nonzero? sv-624)
                (vector-float*! sv-688 sv-688 (/ 1.0 (the float sv-624)))
                (vector-! sv-688 sv-688 s2-0)
                (let ((t9-13 vector-normalize!)
                      (a0-35 sv-688)
                      (f0-35 4096.0)
                      (f1-21 4096.0)
                      (v1-104 sv-688)
                      )
                  (t9-13 a0-35 (* f0-35 (/ f1-21 (+ (* (-> v1-104 x) (-> v1-104 x)) (* (-> v1-104 z) (-> v1-104 z))))))
                  )
                (let ((a0-36 s0-0))
                  (let ((v1-106 s0-0))
                    (let ((a1-36 100.0))
                      (.mov vf7 a1-36)
                      )
                    (.lvf vf5 (&-> sv-688 quad))
                    (.lvf vf4 (&-> v1-106 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a0-36 quad) vf6)
                  )
                (vector-float*! sv-704 sv-704 (/ 1.0 (the float sv-624)))
                (vector-! sv-704 sv-704 s3-0)
                (let ((a0-39 s0-0))
                  (let ((v1-110 s0-0))
                    (let ((a1-43 5.0))
                      (.mov vf7 a1-43)
                      )
                    (.lvf vf5 (&-> sv-704 quad))
                    (.lvf vf4 (&-> v1-110 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a0-39 quad) vf6)
                  )
                )
              (vector-float*! (-> s1-0 avoid-d) (-> s1-0 avoid-d) 0.95)
              (vector-float*! (-> s1-0 border-f) (-> s1-0 border-f) 0.99)
              (vector+! s0-0 s0-0 (-> s1-0 border-f))
              (vector+! s0-0 s0-0 (-> s1-0 avoid-d))
              (set! (-> s0-0 y) 0.0)
              (let ((a0-44 s3-0))
                (let ((v1-117 s3-0))
                  (let ((a1-52 (-> self clock seconds-per-frame)))
                    (.mov vf7 a1-52)
                    )
                  (.lvf vf5 (&-> s0-0 quad))
                  (.lvf vf4 (&-> v1-117 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a0-44 quad) vf6)
                )
              )
            (vector-float*! s3-0 s3-0 0.8)
            (let ((a1-54 s2-0))
              (let ((v1-120 s2-0))
                (let ((a0-46 s3-0))
                  (let ((a2-10 (-> self clock seconds-per-frame)))
                    (.mov vf7 a2-10)
                    )
                  (.lvf vf5 (&-> a0-46 quad))
                  )
                (.lvf vf4 (&-> v1-120 quad))
                )
              (.add.x.vf vf6 vf0 vf0 :mask #b1000)
              (.mul.x.vf acc vf5 vf7 :mask #b111)
              (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
              (.svf (&-> a1-54 quad) vf6)
              )
            (cloest-point-on-mesh (-> self nav) s2-0 s2-0 sv-720)
            (set! (-> s2-0 y) -1638.4)
            (let ((v1-124 (handle->process (-> s1-0 handle))))
              (when v1-124
                (set! (-> (the-as process-drawable v1-124) root trans quad) (-> s2-0 quad))
                (forward-up->quaternion
                  (-> (the-as process-drawable v1-124) root quat)
                  (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 1.0)
                  *up-vector*
                  )
                )
              )
            )
          )
        )
      (none)
      )
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! fish-manager ((obj fish-manager) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-6 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 0))))
      (set-vector! (-> v1-6 local-sphere) 0.0 0.0 0.0 9216.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-6)
      )
    (set! (-> s4-0 nav-radius) 4096.0)
    (let ((v1-8 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-8 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-8 prim-core collide-with))
      )
    (set! (-> obj root) s4-0)
    )
  (process-drawable-from-entity! obj arg0)
  (get-nav-control obj (the-as nav-mesh #f))
  (let ((s5-1 (rand-vu-int-count 4)))
    (dotimes (s4-1 12)
      (let ((s3-0 (-> obj fishes s4-1)))
        (let ((f30-1 (* 182.04445 (the float (rand-vu-int-count 360)))))
          (set! (-> s3-0 pos quad) (-> obj root trans quad))
          (+! (-> s3-0 pos x) (rand-vu-float-range 409.6 4096.0))
          (+! (-> s3-0 pos z) (rand-vu-float-range 409.6 4096.0))
          (set! (-> s3-0 wander) (rand-vu-float-range 0.0 65536.0))
          (set-vector! (-> s3-0 vel) (cos f30-1) 0.0 (sin f30-1) 1.0)
          )
        (set! (-> s3-0 border-f quad) (the-as uint128 0))
        (set! (-> s3-0 avoid-d quad) (the-as uint128 0))
        (set! (-> s3-0 max-speed) 16384.0)
        (set! (-> s3-0 handle) (ppointer->handle (process-spawn minnow obj s5-1 :to obj)))
        )
      )
    )
  (go (method-of-object obj idle))
  (none)
  )
