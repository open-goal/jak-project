;;-*-Lisp-*-
(in-package goal)

;; name: target-handler.gc
;; name in dgo: target-handler
;; dgos: ENGINE, GAME

(define-extern type-from-race-vehicle-type (function uint type))
(define-extern type-from-vehicle-type (function vehicle-type type))
(define-extern vehicle-spawn (function process type traffic-object-spawn-params process-drawable))

;; DECOMP BEGINS

(defbehavior target-shoved target ((arg0 meters) (arg1 meters) (arg2 process) (arg3 (state object object target)))
  (let ((s5-0 (new 'static 'attack-info)))
    (set! (-> s5-0 attacker) (process->handle arg2))
    (set! (-> s5-0 shove-back) arg0)
    (set! (-> s5-0 shove-up) arg1)
    (set! (-> s5-0 angle)
          (if (not (logtest? (logior (-> self control status) (-> self control old-status)) (collide-status on-surface)))
              'air
              'shove
              )
          )
    (set! (-> s5-0 mask) (attack-info-mask attacker shove-back shove-up angle))
    (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
    (go arg3 'shove s5-0)
    )
  )

(defun attack-mode-is-invinc ((arg0 symbol))
  (case arg0
    (('dark-eco-pool
       'endlessfall
       'melt
       'lava
       'bot
       'instant-death
       'grenade
       'drill-mech-master
       'centipede
       'drown-death
       'crush
       'death
       )
     #t
     )
    )
  )

(defbehavior target-attacked target ((arg0 symbol)
                           (arg1 attack-info)
                           (arg2 process)
                           (arg3 touching-shapes-entry)
                           (arg4 (state symbol attack-info target))
                           )
  (let ((s4-0 (if (logtest? (-> arg1 mask) (attack-info-mask mode))
                  (-> arg1 mode)
                  )
              )
        (s2-0 arg0)
        )
    (when (or (and (not (focus-test? self hit)) (not (logtest? (state-flags disable-attacks) (-> self state-flags))))
              (= s4-0 'endlessfall)
              )
      (case s4-0
        (('endlessfall)
         (if (not (-> *setting-control* user-current endlessfall))
             (return #f)
             )
         )
        )
      (cond
        ((or (logtest? (state-flags sf2 tinvul1 tinvul2) (-> self state-flags))
             (logtest? (-> self game secrets) (game-secrets invulnerable))
             (and (logtest? (-> self state-flags) (state-flags sf4)) (not (attack-mode-is-invinc s4-0)))
             (< 0.0 (-> (the-as fact-info-target (-> self fact-override)) shield-level))
             (and (= s4-0 'darkeco)
                  (and (and (= (-> (the-as fact-info-target (-> self fact-override)) eco-type) 2)
                            (>= (-> (the-as fact-info-target (-> self fact-override)) eco-level) 1.0)
                            )
                       (or (logtest? (-> self state-flags) (state-flags sf15)) (focus-test? self dangerous))
                       )
                  )
             )
         (case arg0
           (('attack-or-shove)
            )
           (('attack-invinc)
            (set! arg0 'attack)
            )
           (else
             (return #f)
             )
           )
         )
        (else
          (case arg0
            (('attack-or-shove 'attack-invinc)
             (set! arg0 'attack)
             )
            )
          )
        )
      (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer arg1) 160)
      (compute-intersect-info (-> self attack-info-rec) arg1 self arg2 arg3)
      (when (not (focus-test? self mech))
        (if (and (not (target-log-attack (-> self attack-info-rec) (if (logtest? (attack-info-mask test) (-> arg1 mask))
                                                                       'test
                                                                       'log
                                                                       )
                                         )
                      )
                 (!= s2-0 'attack-invinc)
                 )
            (return #f)
            )
        )
      (if (logtest? (attack-info-mask test) (-> arg1 mask))
          (return #t)
          )
      (set! (-> self control attacked-by-id) (the-as int (-> self attack-info-rec id)))
      (cond
        ((and (logtest? (-> self attack-info-rec mask) (attack-info-mask mode))
              (= (-> self attack-info-rec mode) 'damage)
              (not (and (= (-> self game mode) 'play)
                        (>= 0.0 (- (-> (the-as fact-info-target (-> self fact-override)) health) (-> self attack-info-rec damage)))
                        )
                   )
              )
         (pickup-collectable!
           (-> self fact-override)
           (pickup-type health)
           (if (logtest? (attack-info-mask damage) (-> self attack-info-rec mask))
               (- (-> self attack-info-rec damage))
               (- (-> *FACT-bank* health-single-inc))
               )
           (the-as handle #f)
           )
         (let ((gp-1 (get-process *default-dead-pool* part-tracker #x4000)))
           (when gp-1
             (let ((t9-6 (method-of-type part-tracker activate)))
               (t9-6 (the-as part-tracker gp-1) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
               )
             (let ((t9-7 run-function-in-process)
                   (a0-27 gp-1)
                   (a1-10 part-tracker-init)
                   (a2-9 (-> *part-group-id-table* 9))
                   (a3-4 0)
                   (t0-2 #f)
                   (t1-0 #f)
                   (t2-0 #f)
                   (t3-0 *launch-matrix*)
                   )
               (set! (-> t3-0 trans quad)
                     (-> (the-as vector (if (logtest? (-> self attack-info-rec mask) (attack-info-mask intersection))
                                            (-> self attack-info-rec intersection)
                                            (the-as vector (-> self control root-prim prim-core))
                                            )
                                 )
                         quad
                         )
                     )
               ((the-as (function object object object object object object object object none) t9-7)
                a0-27
                a1-10
                a2-9
                a3-4
                t0-2
                t1-0
                t2-0
                t3-0
                )
               )
             (-> gp-1 ppointer)
             )
           )
         (target-timed-invulnerable
           (the-as time-frame (if (logtest? (-> self attack-info-rec mask) (attack-info-mask invinc-time))
                                  (the-as int (-> self attack-info-rec invinc-time))
                                  (the-as int (-> *TARGET-bank* hit-invulnerable-timeout))
                                  )
                   )
           self
           1
           )
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (sound-play "oof")
         #t
         )
        (else
          (logior! (-> self focus-status) (focus-status ignore hit))
          (when (and (= (-> self game mode) 'play)
                     (and (or (and (>= 0.0 (- (-> (the-as fact-info-target (-> self fact-override)) health) (-> self attack-info-rec damage)))
                                   (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
                                   )
                              (attack-mode-is-invinc s4-0)
                              )
                          (= arg0 'attack)
                          )
                     )
            (logior! (-> self focus-status) (focus-status dead))
            (set! (-> self state-flags) (logior (state-flags disable-attacks) (-> self state-flags)))
            )
          (go arg4 arg0 (-> self attack-info-rec))
          )
        )
      )
    )
  )

;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 711]
(defbehavior target-send-attack target ((arg0 process) (arg1 symbol) (arg2 touching-shapes-entry) (arg3 int) (arg4 int) (arg5 penetrate))
  (local-vars
    (sv-96 symbol)
    (sv-100 touching-prims-entry)
    (sv-128 touching-prims-entry)
    (sv-176 touching-prims-entry)
    (sv-224 penetrate)
    (sv-240 int)
    (sv-256 symbol)
    (sv-272 symbol)
    (sv-288 symbol)
    (sv-304 vector)
    (sv-320 matrix)
    (sv-336 int)
    (sv-352 symbol)
    (sv-368 symbol)
    (sv-384 symbol)
    (sv-400 vector)
    (sv-416 matrix)
    (sv-432 int)
    (sv-448 symbol)
    (sv-464 symbol)
    (sv-480 symbol)
    (sv-496 vector)
    (sv-512 matrix)
    (sv-528 int)
    (sv-544 symbol)
    (sv-560 symbol)
    (sv-576 symbol)
    (sv-592 vector)
    (sv-608 matrix)
    (sv-624 int)
    (sv-640 symbol)
    (sv-656 symbol)
    (sv-672 symbol)
    (sv-688 vector)
    (sv-704 matrix)
    )
  (set! sv-224 arg5)
  (let* ((s3-0 arg0)
         (s4-0 (if (type? s3-0 process-focusable)
                   s3-0
                   )
               )
         (s3-1 (and s4-0 (focus-test? (the-as process-focusable s4-0) dead hit)))
         )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) (process->ppointer self))
      (set! (-> a1-2 num-params) 2)
      (set! (-> a1-2 message) 'attack)
      (set! (-> a1-2 param 0) (the-as uint arg2))
      (let ((v1-5 (new 'static 'attack-info :mask (attack-info-mask mode id count penetrate-using))))
        (set! (-> v1-5 id) (the-as uint arg3))
        (set! (-> v1-5 mode) arg1)
        (set! (-> v1-5 count) (the-as uint arg4))
        (set! (-> v1-5 penetrate-using) sv-224)
        (set! (-> a1-2 param 1) (the-as uint v1-5))
        )
      (set! sv-96 (the-as symbol (send-event-function arg0 a1-2)))
      )
    (when sv-96
      (set! (-> self control send-attack-dest) (process->handle arg0))
      (set! (-> self control send-attack-time) (current-time))
      (send-event self 'hit arg1 arg0 arg2)
      (set! arg0
            (the process (and (and (focus-test? self dark) (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 2)) arg0))
            )
      (when (the-as object arg0)
        (when (and s4-0 (not s3-1) (-> self control danger-mode) (not (logtest? (-> s4-0 mask) (process-mask dark-effect))))
          (logior! (-> s4-0 mask) (process-mask dark-effect))
          (process-spawn-function
            process
            (lambda :behavior target
              ((arg0 handle))
              (local-vars (sv-112 vector) (sv-128 matrix))
              (stack-size-set! (-> self main-thread) 512) ;; added
              (let ((gp-0 (-> self parent)))
                (let ((s4-0 0)
                      (s3-0 (current-time))
                      )
                  (set! (-> self clock) (-> gp-0 0 clock))
                  (while (let ((v1-48 gp-0))
                           (and (or (focus-test?
                                      (the-as process-focusable (if v1-48
                                                                    (the-as process-focusable (-> v1-48 0 self))
                                                                    )
                                              )
                                      dead
                                      hit
                                      )
                                    (let ((v1-53 gp-0))
                                      (and (-> (the-as process-focusable (if v1-53
                                                                             (the-as process-focusable (-> v1-53 0 self))
                                                                             )
                                                       )
                                               next-state
                                               )
                                           (let ((v1-56 gp-0))
                                             (= (-> (the-as process-focusable (if v1-56
                                                                                  (the-as process-focusable (-> v1-56 0 self))
                                                                                  )
                                                            )
                                                    next-state
                                                    name
                                                    )
                                                'knocked
                                                )
                                             )
                                           )
                                      )
                                    )
                                (< (- (current-time) s3-0) (seconds 15))
                                (not (logtest? (-> (the-as process-focusable (-> gp-0 0)) draw status) (draw-control-status no-draw no-draw-temp))
                                     )
                                )
                           )
                    (let ((s2-0 sp-launch-particles-var)
                          (s1-0 *sp-particle-system-2d*)
                          (s0-0 (-> *part-id-table* 178))
                          )
                      (set! sv-128 *launch-matrix*)
                      (set! sv-112 (-> sv-128 trans))
                      (let ((v1-9 (-> (process-drawable-random-point!
                                        (the-as process-drawable (ppointer->process gp-0))
                                        (new 'stack-no-clear 'vector)
                                        )
                                      quad
                                      )
                                  )
                            )
                        (set! (-> sv-112 quad) v1-9)
                        )
                      (let ((a3-0 #f)
                            (t0-0 #f)
                            (t1-0 1.0)
                            )
                        (s2-0 s1-0 s0-0 sv-128 (the-as sparticle-launch-state a3-0) (the-as sparticle-launch-control t0-0) t1-0)
                        )
                      )
                    (send-event (ppointer->process gp-0) 'color-effect 'dark 60)
                    (when (>= (- (current-time) (the-as time-frame s4-0)) (seconds 0.05))
                      (set! s4-0 (the-as int (current-time)))
                      (cond
                        ((and (< (- (current-time) s3-0) (seconds 0.5)) (handle->process arg0))
                         (process-drawable2-shock-effect
                           (the-as process-drawable (handle->process arg0))
                           (the-as process-drawable (ppointer->process gp-0))
                           (-> *lightning-spec-id-table* 9)
                           lightning-probe-callback
                           (-> *part-id-table* 179)
                           )
                         )
                        (else
                          (send-event (handle->process arg0) 'color-effect 'shock 60)
                          (process-drawable-shock-effect
                            (the-as process-drawable (ppointer->process gp-0))
                            (-> *lightning-spec-id-table* 9)
                            lightning-probe-callback
                            (-> *part-id-table* 179)
                            0
                            0
                            40960.0
                            )
                          )
                        )
                      )
                    (suspend)
                    )
                  )
                (logclear! (-> gp-0 0 mask) (process-mask dark-effect))
                (send-event (ppointer->process gp-0) 'color-effect #f 0)
                )
              (none)
              )
            (process->handle self)
            :to s4-0
            )
          )
        )
      (let ((v1-37 arg1))
        (cond
          ((or (= v1-37 'spin) (= v1-37 'spin-air) (= v1-37 'board-spin))
           (set! sv-100 (prims-touching? arg2 (-> self control) (the-as uint 256)))
           (cond
             (sv-100
               (let ((s4-1 (get-process *default-dead-pool* part-tracker #x4000)))
                 (when s4-1
                   (let ((t9-8 (method-of-type part-tracker activate)))
                     (t9-8 (the-as part-tracker s4-1) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                     )
                   (let ((s3-4 run-function-in-process)
                         (s2-1 s4-1)
                         (s1-1 part-tracker-init)
                         (s0-1 (-> *part-group-id-table* 10))
                         )
                     (set! sv-240 0)
                     (set! sv-256 (the-as symbol #f))
                     (set! sv-272 (the-as symbol #f))
                     (set! sv-288 (the-as symbol #f))
                     (set! sv-320 *launch-matrix*)
                     (set! sv-304 (-> sv-320 trans))
                     (let ((v1-50 (-> (get-intersect-point (new 'stack-no-clear 'vector) sv-100 (-> self control) arg2) quad)))
                       (set! (-> sv-304 quad) v1-50)
                       )
                     ((the-as (function object object object object object object object object none) s3-4)
                      s2-1
                      s1-1
                      s0-1
                      sv-240
                      sv-256
                      sv-272
                      sv-288
                      sv-320
                      )
                     )
                   (-> s4-1 ppointer)
                   )
                 )
               )
             (else
               (do-effect (-> self skel effect) 'group-spin-hit -1.0 38)
               )
             )
           (play-effect-sound (-> self skel effect) arg1 -1.0 38 (the-as basic #f) (cond
                                                                                     ((= arg1 'board-spin)
                                                                                      (static-sound-name "board-impact")
                                                                                      )
                                                                                     ((using-gun? self)
                                                                                      (static-sound-name "gun-spin-hit")
                                                                                      )
                                                                                     (else
                                                                                       (static-sound-name "spin-hit")
                                                                                       )
                                                                                     )
                              )
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.2))
           )
          ((or (= v1-37 'punch) (= v1-37 'mech-punch))
           (when arg2
             (set! sv-128 (prims-touching? arg2 (-> self control) (the-as uint 256)))
             (cond
               (sv-128
                 (let ((s4-3 (get-process *default-dead-pool* part-tracker #x4000)))
                   (when s4-3
                     (let ((t9-17 (method-of-type part-tracker activate)))
                       (t9-17 (the-as part-tracker s4-3) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                       )
                     (let ((s3-6 run-function-in-process)
                           (s2-3 s4-3)
                           (s1-3 part-tracker-init)
                           (s0-3 (-> *part-group-id-table* 11))
                           )
                       (set! sv-336 0)
                       (set! sv-352 (the-as symbol #f))
                       (set! sv-368 (the-as symbol #f))
                       (set! sv-384 (the-as symbol #f))
                       (set! sv-416 *launch-matrix*)
                       (set! sv-400 (-> sv-416 trans))
                       (let ((v1-77 (-> (get-intersect-point (new 'stack-no-clear 'vector) sv-128 (-> self control) arg2) quad)))
                         (set! (-> sv-400 quad) v1-77)
                         )
                       ((the-as (function object object object object object object object object none) s3-6)
                        s2-3
                        s1-3
                        s0-3
                        sv-336
                        sv-352
                        sv-368
                        sv-384
                        sv-416
                        )
                       )
                     (-> s4-3 ppointer)
                     )
                   )
                 )
               ((let ((v0-20 (prims-touching? arg2 (-> self control) (the-as uint 128))))
                  (set! sv-128 v0-20)
                  v0-20
                  )
                (let ((s4-4 (get-process *default-dead-pool* part-tracker #x4000)))
                  (when s4-4
                    (let ((t9-22 (method-of-type part-tracker activate)))
                      (t9-22 (the-as part-tracker s4-4) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                      )
                    (let ((s3-7 run-function-in-process)
                          (s2-4 s4-4)
                          (s1-4 part-tracker-init)
                          (s0-4 (-> *part-group-id-table* 11))
                          )
                      (set! sv-432 0)
                      (set! sv-448 (the-as symbol #f))
                      (set! sv-464 (the-as symbol #f))
                      (set! sv-480 (the-as symbol #f))
                      (set! sv-512 *launch-matrix*)
                      (set! sv-496 (-> sv-512 trans))
                      (let ((v1-91 (-> (get-intersect-point (new 'stack-no-clear 'vector) sv-128 (-> self control) arg2) quad)))
                        (set! (-> sv-496 quad) v1-91)
                        )
                      ((the-as (function object object object object object object object object none) s3-7)
                       s2-4
                       s1-4
                       s0-4
                       sv-432
                       sv-448
                       sv-464
                       sv-480
                       sv-512
                       )
                      )
                    (-> s4-4 ppointer)
                    )
                  )
                )
               )
             )
           (case arg1
             (('mech-punch)
              (play-effect-sound (-> self skel effect) arg1 -1.0 22 (the-as basic #f) (static-sound-name "mech-punch-hit"))
              )
             (else
               (let ((t1-6 (if (using-gun? self)
                               (static-sound-name "gun-punch-hit")
                               (static-sound-name "punch-hit")
                               )
                           )
                     )
                 (play-effect-sound (-> self skel effect) arg1 -1.0 22 (the-as basic #f) t1-6)
                 )
               )
             )
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
           )
          ((= v1-37 'flip)
           (play-effect-sound (-> self skel effect) arg1 -1.0 38 (the-as basic #f) (static-sound-name "punch-hit"))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 127 (seconds 0.1))
           )
          ((= v1-37 'uppercut)
           (set! sv-176 (prims-touching? arg2 (-> self control) (the-as uint 256)))
           (cond
             (sv-176
               (let ((s4-5 (get-process *default-dead-pool* part-tracker #x4000)))
                 (when s4-5
                   (let ((t9-33 (method-of-type part-tracker activate)))
                     (t9-33 (the-as part-tracker s4-5) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                     )
                   (let ((s3-8 run-function-in-process)
                         (s2-5 s4-5)
                         (s1-5 part-tracker-init)
                         (s0-5 (-> *part-group-id-table* 11))
                         )
                     (set! sv-528 0)
                     (set! sv-544 (the-as symbol #f))
                     (set! sv-560 (the-as symbol #f))
                     (set! sv-576 (the-as symbol #f))
                     (set! sv-608 *launch-matrix*)
                     (set! sv-592 (-> sv-608 trans))
                     (let ((v1-123 (-> (get-intersect-point (new 'stack-no-clear 'vector) sv-176 (-> self control) arg2) quad)))
                       (set! (-> sv-592 quad) v1-123)
                       )
                     ((the-as (function object object object object object object object object none) s3-8)
                      s2-5
                      s1-5
                      s0-5
                      sv-528
                      sv-544
                      sv-560
                      sv-576
                      sv-608
                      )
                     )
                   (-> s4-5 ppointer)
                   )
                 )
               )
             ((let ((v0-34 (prims-touching? arg2 (-> self control) (the-as uint 128))))
                (set! sv-176 v0-34)
                v0-34
                )
              (let ((s4-6 (get-process *default-dead-pool* part-tracker #x4000)))
                (when s4-6
                  (let ((t9-38 (method-of-type part-tracker activate)))
                    (t9-38 (the-as part-tracker s4-6) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                    )
                  (let ((s3-9 run-function-in-process)
                        (s2-6 s4-6)
                        (s1-6 part-tracker-init)
                        (s0-6 (-> *part-group-id-table* 11))
                        )
                    (set! sv-624 0)
                    (set! sv-640 (the-as symbol #f))
                    (set! sv-656 (the-as symbol #f))
                    (set! sv-672 (the-as symbol #f))
                    (set! sv-704 *launch-matrix*)
                    (set! sv-688 (-> sv-704 trans))
                    (let ((v1-137 (-> (get-intersect-point (new 'stack-no-clear 'vector) sv-176 (-> self control) arg2) quad)))
                      (set! (-> sv-688 quad) v1-137)
                      )
                    ((the-as (function object object object object object object object object none) s3-9)
                     s2-6
                     s1-6
                     s0-6
                     sv-624
                     sv-640
                     sv-656
                     sv-672
                     sv-704
                     )
                    )
                  (-> s4-6 ppointer)
                  )
                )
              )
             )
           (do-effect (-> self skel effect) 'group-uppercut-hit -1.0 22)
           (play-effect-sound (-> self skel effect) arg1 -1.0 22 (the-as basic #f) (static-sound-name "uppercut-hit"))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
           )
          ((or (= v1-37 'flop) (= v1-37 'flop-down))
           (do-effect (-> self skel effect) 'group-flop-hit -1.0 22)
           (do-effect (-> self skel effect) 'group-flop-hit -1.0 18)
           (play-effect-sound (-> self skel effect) arg1 -1.0 22 (the-as basic #f) (static-sound-name "flop-hit"))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 178 (seconds 0.1))
           )
          ((= v1-37 'flut-attack)
           (play-effect-sound (-> self skel effect) arg1 -1.0 22 (the-as basic #f) (static-sound-name "punch-hit"))
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.2))
           )
          ((= v1-37 'darkjak)
           (set! (-> self darkjak attack-time) (current-time))
           (let* ((v1-160 *game-info*)
                  (a0-102 (+ (-> v1-160 attack-id) 1))
                  )
             (set! (-> v1-160 attack-id) a0-102)
             (set! (-> self darkjak attack-id) a0-102)
             a0-102
             )
           )
          )
        )
      )
    )
  sv-96
  )

;; WARN: Return type mismatch none vs object.
(defbehavior target-generic-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (the-as
    object
    (case arg2
      (('get-pickup)
       (when (not (focus-test? self dead))
         (let ((s4-0 (-> arg3 param 0))
               (f28-0 (the-as float (-> arg3 param 1)))
               )
           (if (!= (pickup-collectable! (-> self fact-override) (the-as pickup-type s4-0) 0.0 (the-as handle #f))
                   (pickup-collectable! (-> self fact-override) (the-as pickup-type s4-0) f28-0 (process->handle arg0))
                   )
               #t
               'full
               )
           )
         )
       )
      (('test-pickup)
       (let ((a1-6 (-> arg3 param 0)))
         (pickup-collectable! (-> self fact-override) (the-as pickup-type a1-6) 0.0 (the-as handle #f))
         )
       )
      (('reset-pickup)
       (the-as object (reset! (-> self fact-override) (the-as symbol (-> arg3 param 0))))
       )
      (('reset-collide)
       (cond
         ((-> self control collide-mode)
          (target-collide-set! (-> self control collide-mode) (-> self control collide-mode-transition))
          )
         ((-> self control danger-mode)
          (the-as object (target-danger-set! (-> self control danger-mode) #f))
          )
         )
       )
      (('level-deactivate)
       (when (and (focus-test? self pilot)
                  (or (= (-> arg3 param 0) 'ctywide) (and (= (-> arg3 param 0) 'lracelit) (-> self pilot as-daxter?)))
                  )
         (ja-channel-set! 0)
         (target-gun-end-mode #t)
         (set! (-> self skel top-anim interp) 0.0)
         (let ((v1-30 (get-channel (-> self skel top-anim) 0)))
           (if v1-30
               (set! (-> v1-30 frame-interp 1) 0.0)
               )
           )
         (update (-> self skel top-anim))
         (when (not (focus-test? self grabbed))
           (set! (-> self event-hook) #f)
           (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
           )
         )
       )
      (('level-enter)
       (let ((s5-1 (level-get *level* (the-as symbol (-> arg3 param 0)))))
         (when s5-1
           (let ((s4-1 (-> s5-1 info)))
             (let ((v1-40 (-> s4-1 buzzer)))
               (if (nonzero? v1-40)
                   (set! (-> self fact-override buzzer) 0.0)
                   (set! (-> self fact-override buzzer) (pickup-collectable!
                                                          (-> self fact-override)
                                                          (pickup-type buzzer)
                                                          (the float (logior -65536 v1-40))
                                                          (the-as handle #f)
                                                          )
                         )
                   )
               )
             (if (zero? (-> self game task-enter-times (-> s4-1 task-level)))
                 (set! (-> self game task-enter-times (-> s4-1 task-level)) (-> *display* game-clock frame-counter))
                 )
             )
           (let ((s4-2 (-> *game-info* sub-task-list)))
             (dotimes (s3-0 (-> s4-2 length))
               (when (nonzero? s3-0)
                 (let ((s2-0 (-> s4-2 s3-0)))
                   (when (and (= (-> s5-1 info taskname) (-> s2-0 level))
                              (zero? (-> self game task-close-times (-> s2-0 task)))
                              (= s3-0 (-> *game-info* play-list (-> s2-0 task) play-node))
                              (or (logtest? (-> s2-0 flags) (game-task-node-flag closed)) (open? s2-0))
                              (not (task-complete? (-> self game) (-> s2-0 task)))
                              (not (logtest? (game-task-node-flag utility-node) (-> s2-0 flags)))
                              )
                     (when (zero? (-> self game task-close-times (-> s2-0 task)))
                       (format #t "--------------> set task start time for ~A~%" (-> s2-0 name))
                       (set! (-> self game task-close-times (-> s2-0 task)) (-> *display* game-clock frame-counter))
                       )
                     )
                   )
                 )
               )
             )
           (update-task-masks 'level)
           (format #t "GAMEPLAY: enter ~A~%" (-> arg3 param 0))
           )
         )
       )
      (('get-attack-count)
       (set! v0-0 (+ (-> self control attack-count) (-> arg3 param 0)))
       (set! (-> self control attack-count) (the-as uint v0-0))
       v0-0
       )
      (('continue)
       (set! (-> self focus-status) (logior (focus-status teleporting) (-> self focus-status)))
       (go target-continue (the-as continue-point (-> arg3 param 0)))
       )
      (('query)
       (case (-> arg3 param 0)
         (('powerup)
          (and (= (-> (the-as fact-info-target (-> self fact-override)) eco-type) (-> arg3 param 1))
               (< 0.0 (-> (the-as fact-info-target (-> self fact-override)) eco-level))
               )
          )
         (('pickup)
          (pickup-collectable! (-> self fact-override) (the-as pickup-type (-> arg3 param 1)) 0.0 (the-as handle #f))
          )
         (('ground-height)
          (target-height-above-ground)
          )
         (('gun-type)
          (-> self gun gun-type)
          )
         )
       )
      (('release)
       (when (and (nonzero? (-> self gun)) (handle->process (-> self gun charge-active?)))
         (set! (-> self gun charge-active?) (the-as handle #f))
         (set! v0-0 (current-time))
         (set! (-> self gun fire-time) (the-as time-frame v0-0))
         v0-0
         )
       )
      (('trans)
       (case (-> arg3 param 0)
         (('save)
          (set! (-> self alt-cam-pos quad) (-> self control trans quad))
          (logior! (-> self state-flags) (state-flags sf12))
          (mem-copy! (the-as pointer (-> arg3 param 1)) (the-as pointer (-> self control trans)) 48)
          )
         (('restore)
          (logclear! (-> self state-flags) (state-flags sf12))
          (let ((gp-1 (-> arg3 param 1)))
            (move-to-point! (-> self control) (the-as vector (+ gp-1 0)))
            (quaternion-copy! (-> self control quat) (the-as quaternion (+ gp-1 16)))
            )
          (rot->dir-targ! (-> self control))
          (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
          (set! v0-0 (current-time))
          (set! (-> self control last-time-on-surface) (the-as time-frame v0-0))
          v0-0
          )
         (('reset)
          (set! v0-0 (logclear (-> self state-flags) (state-flags sf12)))
          (set! (-> self state-flags) (the-as state-flags v0-0))
          v0-0
          )
         )
       )
      (('effect)
       (the-as object (target-powerup-effect (the-as symbol (-> arg3 param 0))))
       )
      (('color-effect)
       (set! (-> self color-effect) (the-as basic (-> arg3 param 0)))
       (set! (-> self color-effect-start-time) (current-time))
       (set! v0-0 (-> arg3 param 1))
       (set! (-> self color-effect-duration) (the-as uint v0-0))
       v0-0
       )
      (('do-effect)
       (do-effect (-> self skel effect) (the-as symbol (-> arg3 param 0)) (the-as float (-> arg3 param 1)) -1)
       (if (-> self sidekick)
           (the-as object (do-effect
                            (-> self sidekick 0 skel effect)
                            (the-as symbol (-> arg3 param 0))
                            (the-as float (-> arg3 param 1))
                            -1
                            )
                   )
           )
       )
      (('effect-control)
       (when (and (focus-test? self dark) (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 32))
         (case (-> arg3 param 0)
           (('effect-walk-step-left 'effect-walk-step-right 'effect-run-step-left 'effect-run-step-right)
            (activate! *camera-smush-control* 409.6 15 75 1.0 0.98 (-> *display* camera-clock))
            )
           )
         )
       )
      (('neck)
       (set! (-> self neck flex-blend) (the-as float (-> arg3 param 0)))
       (cond
         ((-> arg3 param 1)
          (logior! (-> self state-flags) (state-flags sf13))
          (set! (-> self alt-neck-pos quad) (-> (the-as vector (-> arg3 param 1)) quad))
          (the-as object (look-at! (-> self neck) (-> self alt-neck-pos) 'force arg0))
          )
         (else
           (set! v0-0 (logclear (-> self state-flags) (state-flags sf13)))
           (set! (-> self state-flags) (the-as state-flags v0-0))
           v0-0
           )
         )
       )
      (('sidekick)
       (cond
         ((and (-> arg3 param 0) (not (-> self sidekick)))
          (let ((gp-2 (get-process *default-dead-pool* sidekick #x4000)))
            (set! v0-0
                  (when gp-2
                    (let ((t9-31 (method-of-type sidekick activate)))
                      (t9-31 (the-as sidekick gp-2) self (symbol->string (-> sidekick symbol)) (the-as pointer #x70004000))
                      )
                    (run-now-in-process gp-2 init-sidekick)
                    (-> gp-2 ppointer)
                    )
                  )
            )
          (set! (-> self sidekick) (the-as (pointer sidekick) v0-0))
          v0-0
          )
         ((and (not (-> arg3 param 0)) (-> self sidekick))
          (deactivate (-> self sidekick 0))
          (set! (-> self sidekick) (the-as (pointer sidekick) #f))
          #f
          )
         )
       )
      (('blend-shape)
       (if (-> arg3 param 0)
           (logior! (-> self skel status) (joint-control-status blend-shape))
           (logclear! (-> self skel status) (joint-control-status blend-shape))
           )
       (let ((v1-175 (new 'stack-no-clear 'event-message-block)))
         (set! (-> v1-175 from) (process->ppointer arg0))
         (set! (-> v1-175 num-params) arg1)
         (set! (-> v1-175 message) arg2)
         (set! (-> v1-175 param 0) (-> arg3 param 0))
         (set! (-> v1-175 param 1) (-> arg3 param 1))
         (set! (-> v1-175 param 2) (-> arg3 param 2))
         (set! (-> v1-175 param 3) (-> arg3 param 3))
         (set! (-> v1-175 param 4) (-> arg3 param 4))
         (set! (-> v1-175 param 5) (-> arg3 param 5))
         (send-event-function (ppointer->process (-> self sidekick)) v1-175)
         )
       )
      (('shadow)
       (cond
         ((-> arg3 param 0)
          (let ((v1-178 (-> self draw shadow-ctrl)))
            (logclear! (-> v1-178 settings flags) (shadow-flags disable-draw))
            )
          0
          )
         (else
           (let ((v1-180 (-> self draw shadow-ctrl)))
             (logior! (-> v1-180 settings flags) (shadow-flags disable-draw))
             )
           0
           )
         )
       )
      (('rotate-y-angle)
       (quaternion-rotate-y!
         (-> self control quat-for-control)
         (-> self control quat-for-control)
         (the-as float (-> arg3 param 0))
         )
       (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
           (rot->dir-targ! (-> self control))
           )
       )
      (('touched)
       (cond
         ((< 0.0 (-> (the-as fact-info-target (-> self fact-override)) shield-level))
          (let ((s4-3 (-> self control penetrate-using)))
            (set! (-> self control penetrate-using) (penetrate touch shield))
            (let* ((v1-193 (-> self game))
                   (a0-161 (+ (-> v1-193 attack-id) 1))
                   )
              (set! (-> v1-193 attack-id) a0-161)
              (set! (-> self fact-override shield-attack-id) a0-161)
              )
            (set! v0-0 (target-send-attack
                         arg0
                         'shield
                         (the-as touching-shapes-entry (-> arg3 param 0))
                         (the-as int (-> (the-as fact-info-target (-> self fact-override)) shield-attack-id))
                         0
                         (-> self control penetrate-using)
                         )
                  )
            (set! (-> self control penetrate-using) s4-3)
            )
          v0-0
          )
         ((and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
               (or (and (focus-test? self dark) (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 16))
                   (logtest? (process-mask crate) (-> arg0 mask))
                   )
               )
          (target-send-attack
            arg0
            'darkjak
            (the-as touching-shapes-entry (-> arg3 param 0))
            (the-as int (-> self darkjak attack-id))
            0
            (penetrate touch dark-skin)
            )
          )
         (else
           (send-event arg0 'touch (-> arg3 param 0))
           )
         )
       )
      (('dry)
       (set! (-> self water drip-wetness) 0.0)
       )
      (('reset-height)
       (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
       #f
       )
      (('draw)
       (if (-> arg3 param 0)
           (logclear! (-> self draw status) (draw-control-status no-draw))
           (logior! (-> self draw status) (draw-control-status no-draw))
           )
       (let ((v1-223 (new 'stack-no-clear 'event-message-block)))
         (set! (-> v1-223 from) (process->ppointer arg0))
         (set! (-> v1-223 num-params) arg1)
         (set! (-> v1-223 message) arg2)
         (set! (-> v1-223 param 0) (-> arg3 param 0))
         (set! (-> v1-223 param 1) (-> arg3 param 1))
         (set! (-> v1-223 param 2) (-> arg3 param 2))
         (set! (-> v1-223 param 3) (-> arg3 param 3))
         (set! (-> v1-223 param 4) (-> arg3 param 4))
         (set! (-> v1-223 param 5) (-> arg3 param 5))
         (send-event-function (ppointer->process (-> self manipy)) v1-223)
         )
       )
      (('no-load-wait)
       (set! v0-0 (+ (current-time) (the-as time-frame (-> arg3 param 0))))
       (set! (-> self no-load-wait) (the-as uint v0-0))
       v0-0
       )
      (('no-look-around)
       (set! (-> self no-look-around-wait) (the-as uint (+ (current-time) (the-as time-frame (-> arg3 param 0)))))
       (if (and (-> self next-state) (= (-> self next-state name) 'target-look-around))
           (send-event self 'end-mode)
           )
       )
      (('change-state)
       (go
         (the-as (state object object object object target) (-> arg3 param 0))
         (-> arg3 param 1)
         (-> arg3 param 2)
         (-> arg3 param 3)
         (-> arg3 param 4)
         )
       )
      (('tobot)
       (set! v0-0 (-> arg3 param 0))
       (set! (-> self tobot?) (the-as symbol v0-0))
       v0-0
       )
      (('carry-info)
       (-> self carry)
       )
      (('gun-type)
       (cond
         ((-> arg3 param 0)
          (the-as object (target-gun-type-set! (the-as int (-> arg3 param 0))))
          )
         (else
           (set! v0-0 #t)
           (set! (-> self gun put-away?) (the-as symbol v0-0))
           v0-0
           )
         )
       )
      (('get-notify)
       (set! v0-0 (process->handle (the-as process (-> arg3 param 0))))
       (set! (-> self notify) (the-as handle v0-0))
       v0-0
       )
      )
    )
  )

;; WARN: Return type mismatch none vs object.
(defbehavior target-standard-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (at-0 int) (s3-0 type))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let* ((v1-0 arg2)
           (a1-1 (= v1-0 'attack))
           )
      (b!
        (not (or a1-1 (begin (set! a1-1 (= v1-0 'attack-or-shove)) a1-1) (= v1-0 'attack-invinc)))
        cfg-7
        :delay (nop!)
        )
      (let ((v0-0
              (target-attacked
                arg2
                (the-as attack-info (-> arg3 param 1))
                arg0
                (the-as touching-shapes-entry (-> arg3 param 0))
                target-hit
                )
              )
            )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-7)
        (b! (!= v1-0 'shove) cfg-21 :delay (nop!))
        (set! v0-0 (when (not (and (-> self next-state) (= (-> self next-state name) 'target-hit)))
                     (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 160)
                     (when (not (logtest? (-> self attack-info-rec mask) (attack-info-mask attacker)))
                       (set! (-> self attack-info-rec attacker) (process->handle arg0))
                       (logior! (-> self attack-info-rec mask) (attack-info-mask attacker))
                       )
                     (go target-hit 'shove (-> self attack-info-rec))
                     )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-21)
        (b! (!= v1-0 'push-trans) cfg-23 :delay (nop!))
        (let ((v1-15 (-> self control additional-decaying-velocity)))
          (.lvf vf1 (&-> (the-as vector (-> arg3 param 0)) quad))
          (let ((f0-0 (-> self clock frames-per-second)))
            (.mov at-0 f0-0)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-15 quad) vf1)
          )
        (set! (-> self control additional-decaying-velocity-end-time) (current-time))
        (set! (-> self control additional-decaying-velocity-decay-start-time)
              (+ (current-time) (the-as time-frame (-> arg3 param 1)))
              )
        (set! v0-0 #t)
        (b! #t cfg-291 :delay (nop!))
        (label cfg-23)
        (b! (!= v1-0 'push-transv) cfg-25 :delay (nop!))
        (set! (-> self control additional-decaying-velocity quad) (-> (the-as vector (-> arg3 param 0)) quad))
        (set! (-> self control additional-decaying-velocity-end-time) (current-time))
        (set! (-> self control additional-decaying-velocity-decay-start-time)
              (+ (current-time) (the-as time-frame (-> arg3 param 1)))
              )
        (set! v0-0 #t)
        (b! #t cfg-291 :delay (nop!))
        (label cfg-25)
        (b! (!= v1-0 'loading) cfg-44 :delay (nop!))
        (set! v0-0
              (if (not (or (and (logtest? (-> self control mod-surface flags) (surface-flag air))
                                (not (logtest? (-> self control status) (collide-status on-surface)))
                                )
                           (or (logtest? (water-flags touch-water) (-> self water flags))
                               (logtest? (-> self control status) (collide-status on-water))
                               )
                           (or (logtest? (-> self state-flags) (state-flags sf1))
                               (focus-test? self dead dangerous hit grabbed in-head edge-grab pole flut tube board pilot mech)
                               (>= (the-as time-frame (-> self no-load-wait)) (current-time))
                               )
                           )
                       )
                  (go target-load-wait)
                  )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-44)
        (b! (!= v1-0 'gun-combo) cfg-46 :delay (nop!))
        (set! v0-0 #t)
        (b! #t cfg-291 :delay (nop!))
        (label cfg-46)
        (b! (!= v1-0 'change-mode) cfg-191 :delay (nop!))
        (let ((v1-45 (-> arg3 param 0)))
          (set! v0-0
                (cond
                  ((= v1-45 'grab)
                   (when (not (focus-test? self dead))
                     (if (not (-> arg3 param 1))
                         #t
                         (go target-grab 'stance)
                         )
                     )
                   )
                  ((= v1-45 'look-around)
                   (go target-look-around)
                   )
                  ((= v1-45 'falling)
                   (go target-falling #f)
                   )
                  ((= v1-45 'racer)
                   (if *debug-segment*
                       (load-package "racerp" global)
                       )
                   (go target-racing-start (process->handle (the-as process (-> arg3 param 1))))
                   )
                  ((= v1-45 'flut)
                   (if *debug-segment*
                       (load-package "flutp" global)
                       )
                   (go target-flut-start (process->handle (the-as process (-> arg3 param 1))))
                   )
                  ((= v1-45 'board)
                   (if (logtest? (-> self game features) (game-feature board))
                       (go target-board-start (process->handle (the-as process (-> arg3 param 1))))
                       )
                   )
                  ((or (= v1-45 'pilot) (= v1-45 'pilot-race) (= v1-45 'pilot-daxter) (= v1-45 'pilot-race-daxter))
                   (let ((s5-1 (the-as object (-> arg3 param 1))))
                     (when (not (the-as uint s5-1))
                       (let ((s4-1 (new 'stack 'traffic-object-spawn-params)))
                         (case (-> arg3 param 0)
                           (('pilot-race 'pilot-race-daxter)
                            (set! s3-0 (type-from-race-vehicle-type (-> arg3 param 2)))
                            )
                           (else
                             (set! s3-0 (type-from-vehicle-type (the-as vehicle-type (-> arg3 param 2))))
                             )
                           )
                         (when s3-0
                           (set! (-> s4-1 position quad) (-> self control trans quad))
                           (quaternion-copy! (-> s4-1 rotation) (-> self control quat))
                           (set! (-> s4-1 id) (the-as uint 0))
                           (set! (-> s4-1 behavior) (the-as uint 4))
                           (let ((a0-87 (vehicle-spawn self s3-0 s4-1)))
                             (if a0-87
                                 (set! s5-1 a0-87)
                                 )
                             )
                           )
                         )
                       )
                     (when s5-1
                       (let* ((v1-83 (-> arg3 param 0))
                              (a2-4 (if (or (= v1-83 'pilot-daxter) (= v1-83 'pilot-race-daxter))
                                        #t
                                        #f
                                        )
                                    )
                              )
                         (go target-pilot-start (process->handle s5-1) (the-as symbol (-> arg3 param 3)) a2-4)
                         )
                       )
                     )
                   )
                  ((= v1-45 'mech)
                   (if *debug-segment*
                       (load-package "mechp" global)
                       )
                   (go
                     target-mech-start
                     (process->handle (the-as process (-> arg3 param 1)))
                     (the-as float (if (>= arg1 2)
                                       (the-as int (-> arg3 param 2))
                                       #x42c80000
                                       )
                             )
                     #f
                     )
                   )
                  ((= v1-45 'indax)
                   (go target-indax-start (process->handle (the-as process (-> arg3 param 1))))
                   )
                  ((= v1-45 'gun)
                   (if (logtest? (-> self game features) (game-feature gun))
                       (the-as object (target-gun-init (the-as int (-> arg3 param 2))))
                       )
                   )
                  ((= v1-45 'tube)
                   (if (and (logtest? (-> self control status) (collide-status on-surface))
                            (not (or (logtest? (water-flags touch-water) (-> self water flags))
                                     (logtest? (-> self control status) (collide-status on-water))
                                     )
                                 )
                            )
                       (go target-tube-start (process->handle (the-as process (-> arg3 param 1))))
                       )
                   )
                  ((= v1-45 'turret)
                   (if (logtest? (-> self control status) (collide-status on-surface))
                       (go target-turret-get-on (process->handle (the-as process (-> arg3 param 1))))
                       )
                   )
                  ((= v1-45 'darkjak)
                   (cond
                     ((not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
                      (go target-darkjak-get-on (the-as int (-> arg3 param 2)))
                      )
                     ((logtest? (-> arg3 param 2) 128)
                      (set! (-> self darkjak stage) (logand -2 (-> self darkjak stage)))
                      (set! v0-0 (+ (- (seconds 20) (-> self fact-override darkjak-start-time)) (current-time)))
                      (set! (-> self fact-override darkjak-effect-time) (the-as time-frame v0-0))
                      v0-0
                      )
                     )
                   )
                  ((= v1-45 'hide)
                   (go target-hide)
                   )
                  ((= v1-45 'normal)
                   (if (and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                            (and (not (focus-test? self dead dangerous hit grabbed))
                                 (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
                                 )
                            )
                       (go target-darkjak-get-off)
                       )
                   )
                  )
                )
          )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-191)
        (b! (!= v1-0 'end-mode) cfg-212 :delay (nop!))
        (set! v0-0
              (cond
                ((and (using-gun? self) (target-gun-end-mode #f))
                 (go target-stance)
                 )
                ((and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
                      (and (not (focus-test? self dead dangerous hit grabbed))
                           (not (and (-> self next-state) (= (-> self next-state name) 'target-darkjak-get-off)))
                           )
                      )
                 (go target-darkjak-get-off)
                 )
                )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-212)
        (b! (!= v1-0 'gun) cfg-214 :delay (nop!))
        (set! v0-0 (the-as object (target-gun-fire (the-as pickup-type (-> arg3 param 0)))))
        (b! #t cfg-291 :delay (nop!))
        (label cfg-214)
        (b! (!= v1-0 'darkjak) cfg-225 :delay (nop!))
        (set! v0-0
              (when (and (and (focus-test? self dark) (nonzero? (-> self darkjak))) (zero? (-> self darkjak want-stage)))
                (let ((v1-164 (-> arg3 param 0)))
                  (when (logtest? v1-164 4)
                    (set! (-> self darkjak want-stage) v1-164)
                    (go target-darkjak-bomb0)
                    )
                  )
                )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-225)
        (b! (!= v1-0 'play-anim) cfg-227 :delay (nop!))
        (set! v0-0 (go target-play-anim (the-as string (-> arg3 param 0)) (the-as handle a1-1)))
        (b! #t cfg-291 :delay (nop!))
        (label cfg-227)
        (b! (!= v1-0 'clone-anim) cfg-234 :delay (nop!))
        (set! v0-0 (go target-clone-anim (process->handle (the-as process (-> arg3 param 0)))))
        (b! #t cfg-291 :delay (nop!))
        (label cfg-234)
        (b! (!= v1-0 'edge-grab) cfg-238 :delay (nop!))
        (b! (focus-test? self dead hit grabbed) cfg-237 :delay (set! v0-0 #f))
        (set! v0-0 (go target-edge-grab))
        (label cfg-237)
        (b! #t cfg-291 :delay (nop!))
        (label cfg-238)
        (b! (!= v1-0 'pilot-edge-grab) cfg-242 :delay (nop!))
        (b! (focus-test? self dead hit grabbed) cfg-241 :delay (set! v0-0 #f))
        (set! v0-0 (go target-pilot-edge-grab (the-as pilot-edge-grab-info (-> arg3 param 0))))
        (label cfg-241)
        (b! #t cfg-291 :delay (nop!))
        (label cfg-242)
        (b! (!= v1-0 'pole-grab) cfg-256 :delay (nop!))
        (set! v0-0
              (if (and (not (focus-test? self dead hit grabbed pole))
                       ((method-of-type touching-shapes-entry prims-touching?)
                        (the-as touching-shapes-entry (-> arg3 param 0))
                        (-> self control)
                        (the-as uint 2)
                        )
                       (-> self draw art-group data 104)
                       )
                  (go target-pole-cycle (process->handle arg0))
                  )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-256)
        (b! (!= v1-0 'swim) cfg-270 :delay (nop!))
        (set! v0-0
              (if (not (or (= (-> self control mod-surface mode) 'swim)
                           (= (-> self control mod-surface mode) 'dive)
                           (and (-> self next-state) (= (-> self next-state name) 'target-hit))
                           (focus-test? self dead hit grabbed)
                           )
                       )
                  (go target-swim-stance)
                  )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-270)
        (b! (!= v1-0 'wade) cfg-286 :delay (nop!))
        (set! v0-0
              (if (and (!= (-> self control mod-surface mode) 'wade)
                       (and (-> self next-state)
                            (let ((v1-206 (-> self next-state name)))
                              (or (= v1-206 'target-stance) (= v1-206 'target-walk) (= v1-206 'target-stance-look-around))
                              )
                            )
                       (not (logtest? (-> self focus-status) (focus-status dead hit grabbed)))
                       )
                  (go target-wade-stance)
                  )
              )
        (b! #t cfg-291 :delay (nop!))
        (label cfg-286)
        (b! (!= v1-0 'slide) cfg-290 :delay (nop!))
        (b! (focus-test? self dead hit grabbed on-water under-water) cfg-289 :delay (set! v0-0 #f))
        (set! v0-0 (go target-slide-down-to-ground))
        (label cfg-289)
        (b! #t cfg-291 :delay (nop!))
        (label cfg-290)
        (set! v0-0 (target-generic-event-handler arg0 arg1 arg2 arg3))
        (label cfg-291)
        (the-as object v0-0)
        )
      )
    )
  )

(defbehavior target-dangerous-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (cond
       ((< 0.0 (-> (the-as fact-info-target (-> self fact-override)) shield-level))
        (let ((s4-1 (-> self control penetrate-using)))
          (set! (-> self control penetrate-using) (penetrate touch shield))
          (let ((v0-0 (the-as object (target-send-attack
                                       arg0
                                       'shield
                                       (the-as touching-shapes-entry (-> arg3 param 0))
                                       (the-as int (-> (the-as fact-info-target (-> self fact-override)) shield-attack-id))
                                       0
                                       (-> self control penetrate-using)
                                       )
                              )
                      )
                )
            (set! (-> self control penetrate-using) s4-1)
            v0-0
            )
          )
        )
       (((method-of-type touching-shapes-entry prims-touching?)
         (the-as touching-shapes-entry (-> arg3 param 0))
         (-> self control)
         (the-as uint 1920)
         )
        (target-send-attack
          arg0
          (-> self control danger-mode)
          (the-as touching-shapes-entry (-> arg3 param 0))
          (the-as int (-> self control target-attack-id))
          (the-as int (-> self control attack-count))
          (-> self control penetrate-using)
          )
        )
       (else
         (target-standard-event-handler arg0 arg1 arg2 arg3)
         )
       )
     )
    (('attack 'attack-or-shove 'attack-invinc)
     (target-attacked
       arg2
       (the-as attack-info (-> arg3 param 1))
       arg0
       (the-as touching-shapes-entry (-> arg3 param 0))
       target-hit
       )
     )
    (else
      (target-standard-event-handler arg0 arg1 arg2 arg3)
      )
    )
  )

(defbehavior target-bonk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (cond
      ((and (= arg2 'touched)
            ((method-of-type touching-shapes-entry prims-touching?)
             (the-as touching-shapes-entry (-> arg3 param 0))
             (-> self control)
             (the-as uint 6)
             )
            (< (* 16384.0 (-> self clock time-adjust-ratio))
               (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control transv) (-> self control last-transv))
                 )
               )
            (begin
              (vector-normalize!
                (vector-!
                  s4-0
                  (the-as vector (-> self control collision-spheres 0 prim-core))
                  (-> self control actor-contact-pt)
                  )
                1.0
                )
              (< 0.01 (-> s4-0 y))
              )
            )
       (if (< 0.75 (-> s4-0 y))
           (send-event
             arg0
             'bonk
             (-> arg3 param 0)
             (fmax
               (-> self control ground-impact-vel)
               (- (vector-dot (-> self control transv) (-> self control dynam gravity-normal)))
               )
             )
           )
       (let ((f0-7 (vector-dot
                     (-> self control dynam gravity-normal)
                     (vector-! (new 'stack-no-clear 'vector) (-> self control highest-jump-mark) (-> self control trans))
                     )
                   )
             )
         (when (< (-> *TARGET-bank* fall-far) f0-7)
           (when (and (target-send-attack
                        arg0
                        'bonk
                        (the-as touching-shapes-entry (-> arg3 param 0))
                        (the-as int (-> self control target-attack-id))
                        (the-as int (-> self control attack-count))
                        (-> self control penetrate-using)
                        )
                      (not (logtest? (-> self focus-status) (focus-status dead hit)))
                      )
             (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
             (target-timed-invulnerable (seconds 0.1) self 1)
             (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
             )
           )
         )
       #f
       )
      ((= arg2 'jump)
       (sound-play "jump-long")
       (go
         target-jump
         (the-as float (-> arg3 param 0))
         (the-as float (-> arg3 param 1))
         (the-as surface (-> arg3 param 2))
         )
       )
      )
    )
  )

(defbehavior target-jump-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (if (and (= arg2 'swim) (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      (return #f)
      )
  (let ((v0-0 (target-bonk-event-handler arg0 arg1 arg2 arg3)))
    (cond
      (v0-0
        (empty)
        v0-0
        )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  )

(defbehavior target-walk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((v0-0 (target-bonk-event-handler arg0 arg1 arg2 arg3)))
    (cond
      (v0-0
        (empty)
        v0-0
        )
      (else
        (target-standard-event-handler arg0 arg1 arg2 arg3)
        )
      )
    )
  )

target-post

target-standard-event-handler

(defbehavior target-exit target ()
  (set! (-> self control mod-surface) *walk-mods*)
  (set! (-> self control anim-collide-offset-local quad) (the-as uint128 0))
  (set! (-> self control anim-collide-offset-world quad) (the-as uint128 0))
  (set! (-> self control old-anim-collide-offset-world quad) (the-as uint128 0))
  (set! (-> self control draw-offset quad) (the-as uint128 0))
  (set! (-> self control force-turn-to-strength) 0.0)
  (set! (-> self control bend-target) 0.0)
  (set! (-> self control bomb-scale) 0.0)
  (logclear!
    (-> self state-flags)
    (state-flags sf1 sf5 sf13 sf14 sf15 lleg-still rleg-still lleg-no-ik rleg-no-ik)
    )
  (logclear! (-> self focus-status) (focus-status hit grabbed in-head teleporting))
  (target-danger-set! 'harmless #f)
  (logior! (-> self water flags) (water-flags swim-ground))
  (logclear! (-> self water flags) (water-flags jump-out))
  (set! (-> self water drip-mult) 1.0)
  (set! (-> self neck flex-blend) 1.0)
  (set! (-> self neck base-joint) (the-as uint 6))
  (set! (-> self control duck-gun-tube-transision) 0.0)
  (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
  (logclear! (-> self control status) (collide-status touch-ceiling-sticky))
  (initialize (-> self control impact-ctrl) self -1 0.0 (collide-spec))
  (combo-tracker-method-12
    (-> self control unknown-combo-tracker00)
    *null-vector*
    *null-vector*
    (the-as process #f)
    0
    )
  (logclear! (-> self skel effect flags) (effect-control-flag ecf2))
  0
  (none)
  )

;; WARN: Return type mismatch (function none) vs none.
(defbehavior target-state-hook-exit target ()
  (set! (-> self state-hook) (the-as (function none :behavior target) nothing))
  (none)
  )

;; WARN: Return type mismatch state-flags vs none.
(defbehavior target-effect-exit target ()
  (let ((v1-1 (-> self skel effect)))
    (set! (-> v1-1 channel-offset) 0)
    )
  0
  (logclear! (-> self state-flags) (state-flags lleg-still rleg-still lleg-no-ik rleg-no-ik))
  (none)
  )
