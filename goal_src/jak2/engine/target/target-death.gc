;;-*-Lisp-*-
(in-package goal)

;; name: target-death.gc
;; name in dgo: target-death
;; dgos: ENGINE, GAME
(define-extern start-sig-recorder (function none))
(define-extern intro-play (function none))
(define-extern find-nearest-entity (function vector type entity))
(define-extern warp-gate type)

;; DECOMP BEGINS

(define *auto-continue* #f)

;; WARN: Return type mismatch object vs continue-point.
(defun next-continue ((arg0 continue-point))
  (let* ((v1-0 #f)
         (a1-0 *level-load-list*)
         (a2-0 (car a1-0))
         )
    (while (not (null? a1-0))
      (let* ((a2-2 (-> (the-as level-load-info (-> (the-as symbol a2-0) value)) continues))
             (a3-0 (car a2-2))
             )
        (while (not (null? a2-2))
          (if (and v1-0 (logtest? (continue-flags test) (-> (the-as continue-point a3-0) flags)))
              (return (the-as continue-point a3-0))
              )
          (if (= a3-0 arg0)
              (set! v1-0 #t)
              )
          (set! a2-2 (cdr a2-2))
          (set! a3-0 (car a2-2))
          )
        )
      (set! a1-0 (cdr a1-0))
      (set! a2-0 (car a1-0))
      )
    )
  (the-as continue-point #f)
  )

(defstate target-continue (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (case event-type
      (('change-mode)
       (case (-> event param 0)
         (('grab 'look-around)
          #f
          )
         (else
           (set! (-> self mode-cache) (the-as basic (-> event param 0)))
           (set! (-> self mode-param1) (if (>= arg1 2)
                                           (process->handle (the-as process (-> event param 1)))
                                           (the-as handle #f)
                                           )
                 )
           (set! (-> self mode-param2) (-> event param 2))
           (set! v0-0 (-> event param 3))
           (set! (-> self mode-param3) (the-as uint v0-0))
           v0-0
           )
         )
       )
      (('want-continue)
       (set! v0-0 (-> event param 0))
       (set! (-> self control unknown-word04) (the-as uint v0-0))
       v0-0
       )
      (else
        (target-generic-event-handler proc arg1 event-type event)
        )
      )
    )
  :exit (behavior ()
    (set! (-> *level* camera-pos 0 quad) (-> (camera-pos) quad))
    (set! (-> *level* camera-pos 1 quad) (-> *level* camera-pos 0 quad))
    (set! (-> *level* target-pos 0 quad) (-> (target-pos 0) quad))
    (set! (-> *level* target-pos 1 quad) (-> *level* target-pos 0 quad))
    (set! (-> *setting-control* user-default border-mode) (-> *level* play?))
    (set! (-> *setting-control* user-default region-mode) #t)
    (remove-setting! 'allow-pause)
    (remove-setting! 'allow-progress)
    (remove-setting! 'allow-timeout)
    (remove-setting! 'bg-a)
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (remove-setting! 'dialog-volume)
    (remove-setting! 'ambient-volume)
    (remove-setting! 'music)
    (remove-setting! 'region-mode)
    (remove-setting! 'border-mode)
    (remove-setting! 'allow-continue)
    (apply-settings *setting-control*)
    (logclear! (-> self focus-status) (focus-status teleporting))
    (set! (-> self mode-cache) #f)
    (set! (-> self teleport-time) (current-time))
    (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
    (set! (-> self game kiosk-timeout) (the-as uint (-> *display* game-clock frame-counter)))
    (none)
    )
  :code (behavior ((arg0 continue-point))
    (local-vars (v1-96 symbol))
    (set! *spawn-actors* #f)
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self state-time) (current-time))
    (set! (-> self focus-status) (logior (focus-status teleporting) (-> self focus-status)))
    (let ((a0-3 (get-continue-by-name (-> self game) (-> arg0 name))))
      (cond
        (a0-3
          (set! (-> self game last-continue) a0-3)
          )
        ((string= (-> arg0 name) "default")
         )
        (else
          (format 0 "ERROR: TARGET: attempting to goto continue ~A which is not in level-info~%" (-> arg0 name))
          )
        )
      )
    (if (-> *art-control* reserve-buffer)
        (reserve-free *art-control* (-> *art-control* reserve-buffer heap))
        )
    (when (logtest? (-> arg0 flags) (continue-flags demo demo-movie))
      (#unless DEMO_HACK
        (set! (-> ctywide memory-mode) (load-buffer-mode small-edge)))
      0
      )
    (kill-persister *setting-control* (the-as engine-pers 'fail) 'bg-a)
    (when (not (logtest? (-> arg0 flags) (continue-flags no-blackout)))
      (add-setting! 'bg-a 'abs 1.0 0)
      (set! (-> *setting-control* user-current bg-a) 1.0)
      )
    (set-setting! 'sfx-volume 'abs 0.0 0)
    (set-setting! 'ambient-volume 'abs 0.0 0)
    (set-setting! 'dialog-volume 'abs 0.0 0)
    (when (and (not (string= (-> arg0 name) "default")) (not (demo?)))
      (let ((v1-37 (lookup-level-info (-> arg0 level))))
        (when (and v1-37
                   (!= (-> v1-37 name) 'default-level)
                   (!= (-> v1-37 music-bank) (-> *setting-control* user-current music))
                   (!= (level-status *level* (-> arg0 vis-nick)) 'active)
                   )
          (set-setting! 'music #f 0.0 0)
          (set-setting! 'music-volume 'abs 0.0 0)
          )
        )
      )
    (set-setting! 'region-mode #f 0.0 0)
    (set-setting! 'border-mode #f 0.0 0)
    (set-setting! 'allow-continue #f 0.0 0)
    (set-setting! 'allow-timeout #f 0.0 0)
    (set! (-> *setting-control* user-default border-mode) #f)
    (apply-settings *setting-control*)
    (reset-target-state #t)
    (target-exit)
    (set! (-> self focus-status) (logior (focus-status teleporting) (-> self focus-status)))
    (ja-channel-set! 0)
    (quaternion-copy! (-> self control quat-for-control) (the-as quaternion (-> arg0 quat)))
    (move-to-point! (-> self control) (-> arg0 trans))
    (rot->dir-targ! (-> self control))
    (set! (-> self control camera-pos quad) (-> self control trans quad))
    (if (not (string= (-> arg0 name) "default"))
        (set! *external-cam-mode* #f)
        )
    (if (not (logtest? (-> arg0 flags) (continue-flags no-blackout)))
        (cam-stop)
        )
    (suspend)
    (let ((a0-40 (lookup-level-info (-> arg0 vis-nick))))
      (set! (-> *load-state* vis-nick) (if a0-40
                                           (-> a0-40 name)
                                           )
            )
      )
    (dotimes (v1-74 6)
      (set! (-> *load-state* want v1-74 name) (-> arg0 want v1-74 name))
      (set! (-> *load-state* want v1-74 display?) (-> arg0 want v1-74 display?))
      (set! (-> *load-state* want v1-74 force-vis?) #f)
      (set! (-> *load-state* want v1-74 force-inside?) #f)
      )
    (dotimes (v1-77 3)
      (set! (-> *load-state* want-sound v1-77) (-> arg0 want-sound v1-77))
      )
    (add-borrow-levels *load-state*)
    (when (not (string= (-> arg0 name) "default"))
      (while (begin
               (dotimes (s5-0 6)
                 (when (not (or (not (-> arg0 want s5-0 name))
                                (not (-> arg0 want s5-0 display?))
                                (= (level-status *level* (-> arg0 want s5-0 name)) 'active)
                                )
                            )
                   (set! v1-96 #t)
                   (goto cfg-63)
                   )
                 )
               (let ((s5-1 *load-state*))
                 (dotimes (s4-0 6)
                   (when (not (or (not (-> s5-1 want s4-0 name))
                                  (not (-> s5-1 want s4-0 display?))
                                  (= (level-status *level* (-> s5-1 want s4-0 name)) 'active)
                                  )
                              )
                     (set! v1-96 #t)
                     (goto cfg-63)
                     )
                   )
                 )
               (set! v1-96 #f)
               (label cfg-63)
               v1-96
               )
        (suspend)
        )
      )
    (remove-setting! 'music)
    (remove-setting! 'music-volume)
    (let ((s5-2 (-> *level* border?)))
      (set! (-> *level* border?) (-> *level* play?))
      (set-setting! 'allow-continue #t 0.0 0)
      (set-setting! 'border-mode #t 0.0 0)
      (apply-settings *setting-control*)
      (script-eval '(teleport))
      (script-eval (-> arg0 on-goto))
      (set-setting! 'allow-continue #f 0.0 0)
      (set-setting! 'border-mode #f 0.0 0)
      (apply-settings *setting-control*)
      (set! (-> *level* border?) s5-2)
      )
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (when (not (logtest? (-> arg0 flags) (continue-flags no-blackout)))
      (new 'stack 'transformq)
      (cam-start #t)
      (suspend)
      (when (not (string= (-> arg0 name) "default"))
        (set! (-> *camera-combiner* trans quad) (-> arg0 camera-trans quad))
        (let ((s5-3 (-> *camera-combiner* inv-camera-rot))
              (s4-1 (-> arg0 camera-rot))
              )
          (matrix-identity! s5-3)
          (set! (-> s5-3 vector 0 x) (-> s4-1 0 x))
          (set! (-> s5-3 vector 0 y) (-> s4-1 0 y))
          (set! (-> s5-3 vector 0 z) (-> s4-1 0 z))
          (set! (-> s5-3 vector 1 x) (-> s4-1 1 x))
          (set! (-> s5-3 vector 1 y) (-> s4-1 1 y))
          (set! (-> s5-3 vector 1 z) (-> s4-1 1 z))
          (set! (-> s5-3 vector 2 x) (-> s4-1 2 x))
          (set! (-> s5-3 vector 2 y) (-> s4-1 2 y))
          (set! (-> s5-3 vector 2 z) (-> s4-1 2 z))
          )
        )
      (cam-master-activate-slave #t)
      )
    (send-event self 'level-enter (-> arg0 level))
    (dotimes (v1-158 (-> *level* length))
      (let ((a0-87 (-> *level* level v1-158)))
        (if (= (-> a0-87 status) 'active)
            (set! (-> a0-87 all-visible?) 'loading)
            )
        )
      )
    (let ((s5-4 (level-get *level* (-> arg0 level))))
      (when s5-4
        (while (and (-> *level* vis?) (-> s5-4 vis-info 0) (= (-> s5-4 all-visible?) 'loading))
          (suspend)
          )
        )
      )
    (set! *spawn-actors* #t)
    (set! *teleport* #t)
    (set! (-> *ACTOR-bank* birth-max) 1000)
    (if (not (logtest? (-> arg0 flags) (continue-flags no-blackout)))
        (set-blackout-frames (seconds 0.1))
        )
    (let* ((a0-94 *game-info*)
           (t9-53 (method-of-object a0-94 set-continue!))
           (a1-51 (the-as basic (-> self control unknown-spool-anim00)))
           )
      (set! a1-51 (cond
                    ((the-as spool-anim a1-51)
                     (empty)
                     a1-51
                     )
                    (else
                      arg0
                      )
                    )
            )
      (t9-53 a0-94 a1-51 #f)
      )
    (cond
      ((logtest? (-> arg0 flags) (continue-flags game-start))
       (case *kernel-boot-message*
         (('kiosk)
          (let ((s5-5 (ppointer->handle (auto-save-command 'restore 0 0 *default-pool* #f))))
            (while (handle->process (the-as handle s5-5))
              (suspend)
              )
            )
          )
         )
       (let ((s5-6 (current-time)))
         (until (>= (- (current-time) s5-6) (seconds 0.05))
           (suspend)
           )
         )
       )
      ((logtest? (-> arg0 flags) (continue-flags title))
       (go target-title #t)
       )
      ((logtest? (-> arg0 flags) (continue-flags title-movie))
       (go target-title #f)
       )
      ((logtest? (-> arg0 flags) (continue-flags demo))
       (go target-demo #t)
       )
      ((logtest? (-> arg0 flags) (continue-flags demo-movie))
       (go target-demo #f)
       )
      ((logtest? (-> arg0 flags) (continue-flags intro))
       (intro-play)
       )
      ((logtest? (-> arg0 flags) (continue-flags hero-mode))
       (logior! (-> self game secrets) (game-secrets hero-mode))
       (logior! (-> self game purchase-secrets) (game-secrets hero-mode))
       (intro-play)
       )
      ((logtest? (-> arg0 flags) (continue-flags warp-gate))
       (let ((s5-7 (current-time)))
         (until (>= (- (current-time) s5-7) (seconds 0.05))
           (suspend)
           )
         )
       (let ((s5-8 (new 'static 'vector))
             (a2-26 (find-nearest-entity (-> arg0 trans) warp-gate))
             )
         (when a2-26
           (set! (-> s5-8 quad) (-> a2-26 extra trans quad))
           (set! (-> s5-8 y) (+ 9011.2 (-> s5-8 y)))
           (go target-warp-in s5-8 (-> arg0 trans) (the-as target a2-26))
           )
         )
       )
      ((logtest? (continue-flags indax) (-> arg0 flags))
       (go target-indax-start (the-as handle #f))
       )
      ((logtest? (continue-flags record-path) (-> arg0 flags))
       )
      ((logtest? (continue-flags record-sig) (-> arg0 flags))
       (start-sig-recorder)
       )
      ((logtest? (continue-flags pilot pilot-dax) (-> arg0 flags))
       (set! (-> self focus-status) (logior (focus-status pilot) (-> self focus-status)))
       (while (not (-> self mode-cache))
         (suspend)
         )
       )
      ((logtest? (-> arg0 flags) (continue-flags demo-end))
       (go target-grab 'stance)
       )
      (else
        (let ((s5-9 (current-time)))
          (until (>= (- (current-time) s5-9) (seconds 0.05))
            (suspend)
            )
          )
        )
      )
    (let* ((a0-122 *game-info*)
           (t9-66 (method-of-object a0-122 set-continue!))
           (a1-56 (the-as basic (-> self control unknown-spool-anim00)))
           )
      (set! a1-56 (cond
                    ((the-as spool-anim a1-56)
                     (empty)
                     a1-56
                     )
                    (else
                      arg0
                      )
                    )
            )
      (t9-66 a0-122 a1-56 #f)
      )
    (when *auto-continue*
      (let ((gp-1 (next-continue arg0)))
        (when gp-1
          (format 0 "~A ~A ~A~%" (-> gp-1 level) (-> gp-1 name) gp-1)
          (inspect global)
          (process-spawn-function process (lambda ((arg0 continue-point)) (start 'play arg0)) gp-1)
          )
        )
      )
    (ja-channel-set! 1)
    (ja :group! (-> self draw art-group data 5))
    (suspend)
    (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (when (-> self mode-cache)
      (set! (-> self event-hook) target-standard-event-handler)
      (send-event
        self
        'change-mode
        (-> self mode-cache)
        (handle->process (-> self mode-param1))
        (-> self mode-param2)
        (-> self mode-param3)
        )
      (set! (-> self mode-cache) #f)
      )
    (go target-stance)
    (none)
    )
  :post target-no-move-post
  )

(define *smack-mods* (new 'static 'surface
                       :name 'jump
                       :tiltv 32768.0
                       :tiltvv 131072.0
                       :transv-max 40960.0
                       :target-speed 40960.0
                       :seek0 0.3
                       :seek90 0.3
                       :seek180 0.3
                       :fric 0.05
                       :nonlin-fric-dist 1.0
                       :slip-factor 1.0
                       :slide-factor 1.0
                       :slope-up-factor 1.0
                       :slope-down-factor 1.0
                       :slope-slip-angle 1.0
                       :impact-fric 1.0
                       :bend-factor 1.0
                       :bend-speed 1.0
                       :alignv 1.0
                       :slope-up-traction 1.0
                       :align-speed 1.0
                       :tiltvf 150.0
                       :tiltvvf 15.0
                       :mult-hook (lambda :behavior target
                         ((arg0 surface) (arg1 object) (arg2 object) (arg3 int))
                         (when (= arg3 1)
                           (let ((f30-0 (-> self control unknown-floatiujh1bnb2n3i1))
                                 (f28-0 (-> self control force-turn-to-strength))
                                 )
                             (set! (-> arg0 seek0) (lerp (-> arg0 seek0) 409600.0 f28-0))
                             (set! (-> arg0 seek90) (lerp (-> arg0 seek90) 409600.0 f28-0))
                             (set! (-> arg0 seek180) (lerp (-> arg0 seek180) 409600.0 f28-0))
                             (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
                             (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
                             )
                           )
                         )
                       :mode 'air
                       :flags (surface-flag air gun-inactive gun-no-twist)
                       )
        )

(define *smack-up-mods* (new 'static 'surface
                          :name 'jump
                          :turnv 131072.0
                          :turnvv 32768.0
                          :tiltv 32768.0
                          :tiltvv 131072.0
                          :transv-max 40960.0
                          :target-speed 40960.0
                          :seek0 0.3
                          :seek90 0.3
                          :seek180 0.3
                          :fric 0.05
                          :nonlin-fric-dist 1.0
                          :slip-factor 1.0
                          :slide-factor 1.0
                          :slope-up-factor 1.0
                          :slope-down-factor 1.0
                          :slope-slip-angle 1.0
                          :impact-fric 1.0
                          :bend-factor 1.0
                          :bend-speed 1.0
                          :alignv 1.0
                          :slope-up-traction 1.0
                          :align-speed 1.0
                          :turnvf 30.0
                          :turnvvf 30.0
                          :tiltvf 150.0
                          :tiltvvf 15.0
                          :mult-hook (lambda :behavior target
                            ((arg0 surface) (arg1 object) (arg2 object) (arg3 int))
                            (when (= arg3 1)
                              (let ((f30-0 (-> self control unknown-floatiujh1bnb2n3i1))
                                    (f28-0 (-> self control force-turn-to-strength))
                                    )
                                (set! (-> arg0 seek0) (lerp (-> arg0 seek0) 409600.0 f28-0))
                                (set! (-> arg0 seek90) (lerp (-> arg0 seek90) 409600.0 f28-0))
                                (set! (-> arg0 seek180) (lerp (-> arg0 seek180) 409600.0 f28-0))
                                (set! (-> arg0 target-speed) (lerp (-> arg0 target-speed) f30-0 f28-0))
                                (set! (-> arg0 transv-max) (lerp (-> arg0 transv-max) f30-0 f28-0))
                                )
                              )
                            )
                          :mode 'air
                          :flags (surface-flag no-turn-around turn-to-pad air gun-inactive gun-no-twist)
                          )
        )

(defbehavior velocity-set-to-target! target ((arg0 vector) (arg1 float) (arg2 attack-info))
  (let* ((v1-1 (-> self control trans))
         (gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 v1-1))
         )
    (set! (-> gp-1 y) 0.0)
    (set! (-> self control force-turn-to-direction quad) (-> gp-1 quad))
    (vector-xz-normalize! (-> self control force-turn-to-direction) 1.0)
    (set! (-> self control force-turn-to-speed) 1.0)
    (set! (-> self control unknown-floatiujh1bnb2n3i1) arg1)
    (set! (-> self control force-turn-to-strength) (- 1.0 (-> arg2 control)))
    gp-1
    )
  )

(defbehavior target-hit-effect target ((arg0 attack-info))
  (let ((s5-0 (get-process *default-dead-pool* part-tracker #x4000)))
    (when s5-0
      (let ((t9-1 (method-of-type part-tracker activate)))
        (t9-1 (the-as part-tracker s5-0) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
        )
      (let ((t9-2 run-function-in-process)
            (a0-3 s5-0)
            (a1-2 part-tracker-init)
            (a2-4 (-> *part-group-id-table* 9))
            (a3-1 0)
            (t0-0 #f)
            (t1-0 #f)
            (t2-0 #f)
            (t3-0 *launch-matrix*)
            )
        (set! (-> t3-0 trans quad) (-> (the-as vector (if (logtest? (-> arg0 mask) (attack-info-mask intersection))
                                                          (-> arg0 intersection)
                                                          (the-as vector (-> self control root-prim prim-core))
                                                          )
                                               )
                                       quad
                                       )
              )
        ((the-as (function object object object object object object object object none) t9-2)
         a0-3
         a1-2
         a2-4
         a3-1
         t0-0
         t1-0
         t2-0
         t3-0
         )
        )
      (-> s5-0 ppointer)
      )
    )
  (let ((v1-8 (-> arg0 mode)))
    (cond
      ((or (= v1-8 'endlessfall) (= v1-8 'instant-death) (= v1-8 'crush))
       )
      ((begin
         (target-timed-invulnerable (-> arg0 invinc-time) self 1)
         (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
         (focus-test? self indax)
         )
       (let* ((v1-14 (rand-vu-int-count 4))
              (t0-1 (cond
                      ((zero? v1-14)
                       "ds176"
                       )
                      ((= v1-14 1)
                       "ds177"
                       )
                      ((= v1-14 2)
                       "ds178"
                       )
                      (else
                        "ds179"
                        )
                      )
                    )
              )
         (set! (-> self control unknown-sound-id00)
               (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) t0-1 -99.0 0)
               )
         )
       (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
       )
      (else
        (case (-> arg0 angle)
          (('up)
           (sound-play "hit-up")
           )
          (else
            (sound-play "oof")
            )
          )
        )
      )
    )
  (let ((v1-26 (-> arg0 mode)))
    (cond
      ((or (= v1-26 'burn) (or (= v1-26 'burnup) (= v1-26 'lava)))
       (if (not (handle->process (-> self burn-proc)))
           (set! (-> self burn-proc)
                 (ppointer->handle (process-spawn-function process process-drawable-burn-effect 1200 :to self))
                 )
           )
       )
      ((= v1-26 'tar)
       (sound-play "get-burned")
       )
      )
    )
  0
  (none)
  )

(defbehavior target-hit-push target ((arg0 vector) (arg1 matrix) (arg2 float) (arg3 float) (arg4 attack-info))
  (case (-> arg4 mode)
    (('shock 'shockup 'shock-red 'shock-green)
     (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
       (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
       (send-event self 'color-effect 'shock 60)
       (case (-> arg4 mode)
         (('shock-red)
          (process-drawable-shock-effect
            self
            (-> *lightning-spec-id-table* 3)
            lightning-probe-callback
            (the-as sparticle-launcher #f)
            0
            0
            40960.0
            )
          )
         (('shock-green)
          (process-drawable-shock-effect
            self
            (-> *lightning-spec-id-table* 4)
            lightning-probe-callback
            (the-as sparticle-launcher #f)
            0
            0
            40960.0
            )
          )
         (else
           (process-drawable-shock-effect
             self
             (-> *lightning-spec-id-table* 1)
             lightning-probe-callback
             (-> *part-id-table* 166)
             0
             0
             40960.0
             )
           )
         )
       )
     )
    )
  (case (-> arg4 angle)
    (('jump 'up 'up-forward)
     (when (and (not (focus-test? self flut pilot mech indax))
                (not (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-override health))))
                )
       (if (and (cpad-pressed? (-> self control cpad number) circle) (can-feet? #f))
           (go target-attack-air #f)
           )
       (if (and (cpad-pressed? (-> self control cpad number) square)
                (and (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 26624.0)
                     (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                     (and (>= (- (current-time) (-> self control last-time-of-stuck))
                              (the-as time-frame (-> *TARGET-bank* stuck-timeout))
                              )
                          (not (logtest? (-> self state-flags) (state-flags prevent-attack)))
                          (not (logtest? (-> self control current-surface flags) (surface-flag no-attack no-hands)))
                          (not (and (not (using-gun? self)) (!= (-> self skel top-anim interp) 0.0)))
                          )
                     )
                )
           (go
             target-flop
             65502.96
             -163840.0
             (the-as float (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                               0
                               #x47866666
                               )
                     )
             )
           )
       )
     )
    )
  (when (if (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                 (and (>= (- (current-time) (-> self state-time)) (the-as time-frame (-> *TARGET-bank* stuck-time)))
                      (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                      )
                 )
            #t
            )
    (logior! (-> self control status) (collide-status on-surface))
    (return 'stuck)
    )
  (let ((s1-0 (new-stack-vector0)))
    (set! (-> s1-0 z) arg2)
    (vector-matrix*! s1-0 s1-0 arg1)
    (vector+! s1-0 s1-0 arg0)
    (cond
      ((< (vector-vector-distance arg0 s1-0) (fabs (-> arg4 dist)))
       (velocity-set-to-target! s1-0 (fabs arg3) arg4)
       #t
       )
      (else
        (set! (-> self control unknown-floatiujh1bnb2n3i1) 0.0)
        (set! (-> self control force-turn-to-strength) (- 1.0 (-> arg4 control)))
        #f
        )
      )
    )
  )

(defbehavior target-hit-orient target ((arg0 attack-info) (arg1 vector))
  (let ((s5-0 #f))
    (if (and (!= (-> arg0 angle) 'front)
             (!= (-> arg0 angle) 'shove)
             (logtest? (-> arg0 mask) (attack-info-mask vector))
             (!= (-> arg0 shove-back) 0.0)
             )
        (forward-up-nopitch->quaternion (-> self control dir-targ) arg1 (-> self control dynam gravity-normal))
        )
    (case (-> arg0 angle)
      (('back 'air)
       (set! s5-0 #t)
       )
      (('up-forward)
       (set! (-> self control mod-surface) *smack-up-mods*)
       )
      (('front)
       (if (and (logtest? (-> arg0 mask) (attack-info-mask vector)) (!= (-> arg0 shove-back) 0.0))
           (forward-up-nopitch->quaternion
             (-> self control dir-targ)
             (vector-negate! (new 'stack-no-clear 'vector) arg1)
             (-> self control dynam gravity-normal)
             )
           )
       (set! s5-0 #t)
       )
      (('jump)
       (set! s5-0 #t)
       (set! (-> self control mod-surface) *forward-high-jump-mods*)
       )
      )
    s5-0
    )
  )

(defbehavior target-hit-setup-anim target ((arg0 attack-info))
  (let ((v1-0 (-> arg0 angle)))
    (cond
      ((= v1-0 'back)
       (let ((v1-3 (ja-group)))
         (when (not (and v1-3 (= v1-3 (-> self draw art-group data 67))))
           (when (using-gun? self)
             (set! (-> self gun top-anim-low-high) 0.0)
             (push-anim-to-targ
               (-> self skel top-anim)
               (the-as art-joint-anim (-> self draw art-group data 290))
               0.0
               0
               30
               1.0
               0.0
               #f
               )
             )
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! (-> self draw art-group data 67) :num! min)
           )
         )
       )
      ((= v1-0 'lava)
       (let ((v1-19 (ja-group)))
         (when (not (and v1-19 (= v1-19 (-> self draw art-group data 64))))
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! (-> self draw art-group data 64) :num! min)
           )
         )
       )
      ((or (= v1-0 'up) (= v1-0 'up-forward) (= v1-0 'lava))
       (let ((v1-28 (ja-group)))
         (when (not (and v1-28 (= v1-28 (-> self draw art-group data 68))))
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! (-> self draw art-group data 68) :num! min)
           )
         )
       )
      ((or (= v1-0 'air) (= v1-0 'jump))
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! (-> self draw art-group data 23)
                   :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 23)) frames num-frames) -1)))
                   :frame-num 0.0
                   )
       (when (= (-> arg0 angle) 'air)
         (sound-play "smack-surface")
         (do-effect (-> self skel effect) 'group-smack-surface 0.0 6)
         (do-effect (-> self skel effect) 'group-smack-surface-dizzy 0.0 9)
         )
       )
      ((= v1-0 'shove)
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! (-> self draw art-group data 71)
                   :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 71)) frames num-frames) -1)))
                   :frame-num 0.0
                   )
       (sound-play "smack-surface")
       )
      ((rand-vu-percent? 0.5)
       (let ((v1-77 (ja-group)))
         (when (not (and v1-77 (= v1-77 (-> self draw art-group data 65))))
           (when (using-gun? self)
             (set! (-> self gun top-anim-low-high) 0.0)
             (push-anim-to-targ
               (-> self skel top-anim)
               (the-as art-joint-anim (-> self draw art-group data 289))
               0.0
               0
               30
               1.0
               0.0
               #f
               )
             )
           (ja-channel-push! 1 (seconds 0.075))
           (ja :group! (-> self draw art-group data 65) :num! min)
           )
         )
       )
      (else
        (let ((v1-93 (ja-group)))
          (when (not (and v1-93 (= v1-93 (-> self draw art-group data 66))))
            (when (using-gun? self)
              (set! (-> self gun top-anim-low-high) 0.0)
              (push-anim-to-targ
                (-> self skel top-anim)
                (the-as art-joint-anim (-> self draw art-group data 289))
                0.0
                0
                30
                1.0
                0.0
                #f
                )
              )
            (ja-channel-push! 1 (seconds 0.075))
            (ja :group! (-> self draw art-group data 66) :num! min)
            )
          )
        )
      )
    )
  (none)
  )

(defbehavior target-hit-move target ((arg0 attack-info) (arg1 symbol) (arg2 (function none :behavior target)) (arg3 float))
  (local-vars (v1-29 symbol) (s1-1 symbol))
  (vector-identity! (-> self control transv))
  (let ((v1-1 (new-stack-vector0)))
    (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      0.0
      (vector-! v1-1 (-> self control transv) (vector-float*! v1-1 (-> self control dynam gravity-normal) f0-1))
      )
    (let* ((f0-2 (vector-length v1-1))
           (f1-1 f0-2)
           (f2-1 (+ 2048.0 (sqrtf (* 491520.0 (-> arg0 shove-up)))))
           )
      (vector+!
        (-> self control transv)
        (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-1)
        (vector-float*! v1-1 v1-1 (/ f0-2 f1-1))
        )
      )
    )
  (let ((s3-0 (new 'stack-no-clear 'vector)))
    (set! (-> s3-0 quad) (-> self control trans quad))
    (let ((s2-1 (matrix-rotate-y! (new 'stack-no-clear 'matrix) (+ 32768.0 (vector-y-angle (-> arg0 vector)))))
          (f30-1 0.0)
          )
      (set-quaternion! (-> self control) (-> self control dir-targ))
      #t
      (let ((f28-1 (* 1.05 (/ (* -60.0 arg3) (* (the float (+ (-> (ja-group) frames num-frames) -1)) (ja-step 0))))))
        (until v1-29
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (-> self clock seconds-per-frame)))
          (set! s1-1 (target-hit-push s3-0 s2-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (suspend)
          (ja :num! (seek!))
          (set! v1-29 (or (ja-done? 0) (and arg1 (logtest? (-> self control status) (collide-status on-surface)))))
          )
        (while (and (or (not (logtest? (-> self control status) (collide-status on-surface))) s1-1) (!= s1-1 'stuck))
          (arg2)
          (+! f30-1 (* (-> arg0 shove-back) f28-1 (-> self clock seconds-per-frame)))
          (set! s1-1 (target-hit-push s3-0 s2-1 f30-1 (* (-> arg0 shove-back) f28-1) arg0))
          (if (not s1-1)
              (logclear! (-> self focus-status) (focus-status hit))
              )
          (suspend)
          )
        )
      )
    )
  0
  (none)
  )

(defstate target-hit (target)
  :event target-standard-event-handler
  :exit (behavior ()
    (let ((v1-0 (new-stack-vector0))
          (f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-0 (-> self control transv) (vector-float*! v1-0 (-> self control dynam gravity-normal) f0-1))
      (let* ((f2-0 (vector-length v1-0))
             (f1-2 f2-0)
             )
        (if (< 40960.0 f2-0)
            (set! f2-0 40960.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-1)
          (vector-float*! v1-0 v1-0 (/ f2-0 f1-2))
          )
        )
      )
    (when (not (and (-> self next-state) (let ((v1-4 (-> self next-state name)))
                                           (or (= v1-4 'target-death) (= v1-4 'target-hit))
                                           )
                    )
               )
      (logclear! (-> self focus-status) (focus-status dead hit))
      (logclear! (-> self state-flags) (state-flags disable-attacks))
      )
    ((method-of-type focus clear-focused) (the-as focus (-> self gun track-target)))
    (target-exit)
    (none)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (set! (-> self control time-of-last-debug-heal) (current-time))
        (pickup-collectable! (-> self fact-override) (pickup-type health) 100.0 (the-as handle #f))
        (go target-stance)
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (local-vars (sv-32 attack-info) (sv-36 vector))
    (logclear! (-> self water flags) (water-flags jump-out))
    (set! (-> self state-time) (current-time))
    (set! (-> self neck flex-blend) 0.0)
    (set! sv-32 (-> self attack-info))
    (set! sv-36 (new 'stack-no-clear 'vector))
    (let ((v1-7 sv-32))
      (set! (-> v1-7 attacker) (the-as handle #f))
      (set! (-> v1-7 mode) 'generic)
      (set! (-> v1-7 shove-back) 6144.0)
      (set! (-> v1-7 shove-up) 4915.2)
      (set! (-> v1-7 angle) #f)
      (set! (-> v1-7 trans quad) (-> self control trans quad))
      (set! (-> v1-7 control) 0.0)
      (set! (-> v1-7 invinc-time) (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)))
      (set! (-> v1-7 damage) (-> *FACT-bank* health-default-inc))
      )
    (case arg0
      (('shove)
       (let ((v1-10 sv-32))
         (set! (-> v1-10 shove-back) (-> *TARGET-bank* smack-surface-dist))
         (set! (-> v1-10 shove-up) (-> *TARGET-bank* smack-surface-height))
         (set! (-> v1-10 angle) 'shove)
         )
       )
      )
    (combine! sv-32 arg1 self)
    (when (not (logtest? (-> sv-32 mask) (attack-info-mask vector)))
      (vector-z-quaternion! (-> sv-32 vector) (-> self control quat-for-control))
      (vector-xz-normalize! (-> sv-32 vector) (- (fabs (-> sv-32 shove-back))))
      (set! (-> sv-32 vector y) (-> sv-32 shove-up))
      )
    (when (and (focus-test? self dark) (nonzero? (-> self darkjak)))
      (set! (-> sv-32 damage) (fmax 1.0 (ceil (* 0.5 (-> sv-32 damage)))))
      (if (< (- (-> self fact-override health) (-> sv-32 damage)) 1.0)
          (set! (-> sv-32 damage) (+ -1.0 (-> self fact-override health)))
          )
      )
    (set! (-> sv-36 quad) (-> sv-32 vector quad))
    (let ((f0-20 (vector-dot
                   (vector-normalize-copy! (new 'stack-no-clear 'vector) sv-36 1.0)
                   (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                   )
                 )
          )
      (if (not (-> self attack-info angle))
          (set! (-> self attack-info angle) (if (>= 0.0 f0-20)
                                                'front
                                                'back
                                                )
                )
          )
      )
    (cond
      ((= arg0 'attack)
       (send-event (handle->process (-> self notify)) 'notify 'hit (-> sv-32 mode))
       (logior! (-> self focus-status) (focus-status hit))
       (set! (-> self game hit-time) (current-time))
       (case (-> sv-32 mode)
         (('endlessfall)
          (cond
            ((= (-> self game mode) 'debug)
             (let ((gp-1 (new-stack-vector0)))
               (set! (-> gp-1 quad) (-> self control last-trans-on-ground quad))
               (ja-channel-set! 0)
               (let ((s5-1 (current-time)))
                 (until (>= (- (current-time) s5-1) (seconds 1))
                   (suspend)
                   )
                 )
               (move-to-point! (-> self control) gp-1)
               )
             (set! (-> self control camera-pos quad) (-> self control trans quad))
             (send-event *camera* 'teleport)
             (go target-stance)
             )
            (else
              (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
              (go target-death (-> sv-32 mode))
              )
            )
          )
         (('lava 'melt)
          (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
          (let ((gp-2 (get-process *default-dead-pool* part-tracker #x4000)))
            (when gp-2
              (let ((t9-15 (method-of-type part-tracker activate)))
                (t9-15
                  (the-as part-tracker gp-2)
                  *entity-pool*
                  (symbol->string (-> part-tracker symbol))
                  (the-as pointer #x70004000)
                  )
                )
              (let ((t9-16 run-function-in-process)
                    (a0-53 gp-2)
                    (a1-13 part-tracker-init)
                    (a2-9 (-> *part-group-id-table* 57))
                    (a3-3 0)
                    (t0-0 #f)
                    (t1-0 #f)
                    (t2-0 #f)
                    (t3-0 *launch-matrix*)
                    )
                (set! (-> t3-0 trans quad) (-> self control trans quad))
                ((the-as (function object object object object object object object object none) t9-16)
                 a0-53
                 a1-13
                 a2-9
                 a3-3
                 t0-0
                 t1-0
                 t2-0
                 t3-0
                 )
                )
              (-> gp-2 ppointer)
              )
            )
          (set! (-> sv-32 angle) 'lava)
          (set! (-> sv-32 shove-up) 20480.0)
          )
         (('drown-death
            'sharkey
            'dark-eco-pool
            'instant-death
            'crush
            'death
            'grenade
            'bot
            'turret
            'centipede
            'big-explosion
            )
          (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
          (if (= (-> self game mode) 'play)
              (go target-death (-> sv-32 mode))
              )
          )
         (('explode)
          (pickup-collectable! (-> self fact-override) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-override health)))
              (go target-death (-> sv-32 mode))
              )
          )
         (('smush)
          (pickup-collectable! (-> self fact-override) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (go target-hit-ground-hard (-> *TARGET-bank* fall-far))
          )
         (('shock 'shock-red 'shock-green)
          (pickup-collectable! (-> self fact-override) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
          (let* ((v1-123 (-> sv-32 mode))
                 (gp-3 (cond
                         ((= v1-123 'shock-red)
                          (-> *part-group-id-table* 62)
                          )
                         ((= v1-123 'shock-green)
                          (-> *part-group-id-table* 61)
                          )
                         (else
                           (-> *part-group-id-table* 60)
                           )
                         )
                       )
                 )
            (process-spawn part-tracker :init part-tracker-init gp-3 300 #f #f self 6 :to self)
            )
          (let ((gp-4 (-> self post-hook)))
            (set! (-> self control mod-surface) *turn-around-mods*)
            (set! (-> self post-hook) target-no-stick-post)
            (if (using-gun? self)
                (push-anim-to-targ
                  (-> self skel top-anim)
                  (the-as art-joint-anim (-> self draw art-group data 297))
                  0.0
                  30
                  0
                  1.0
                  0.0
                  #f
                  )
                )
            (let ((v1-141 (new-stack-vector0)))
              (let ((f0-31 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                0.0
                (vector-!
                  v1-141
                  (-> self control transv)
                  (vector-float*! v1-141 (-> self control dynam gravity-normal) f0-31)
                  )
                )
              (let* ((f0-32 (vector-length v1-141))
                     (f1-7 f0-32)
                     (f2-0 0.0)
                     )
                (vector+!
                  (-> self control transv)
                  (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
                  (vector-float*! v1-141 v1-141 (/ f0-32 f1-7))
                  )
                )
              )
            (ja-channel-push! 1 (seconds 0.1))
            (ja-no-eval :group! (-> self draw art-group data 64)
                        :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 64)) frames num-frames) -1)))
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (let ((v1-157 (new-stack-vector0))
                    (f0-39 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                    )
                0.0
                (vector-!
                  v1-157
                  (-> self control transv)
                  (vector-float*! v1-157 (-> self control dynam gravity-normal) f0-39)
                  )
                (let* ((f1-10 (vector-length v1-157))
                       (f2-1 f1-10)
                       (f0-40 (+ f0-39 (* 286720.0 (-> self clock seconds-per-frame))))
                       )
                  (vector+!
                    (-> self control transv)
                    (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-40)
                    (vector-float*! v1-157 v1-157 (/ f1-10 f2-1))
                    )
                  )
                )
              (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
                (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
                (send-event self 'color-effect 'shock 60)
                (case (-> sv-32 mode)
                  (('shock-red)
                   (process-drawable-shock-effect
                     self
                     (-> *lightning-spec-id-table* 3)
                     lightning-probe-callback
                     (the-as sparticle-launcher #f)
                     0
                     0
                     40960.0
                     )
                   )
                  (('shock-green)
                   (process-drawable-shock-effect
                     self
                     (-> *lightning-spec-id-table* 4)
                     lightning-probe-callback
                     (the-as sparticle-launcher #f)
                     0
                     0
                     40960.0
                     )
                   )
                  (else
                    (process-drawable-shock-effect
                      self
                      (-> *lightning-spec-id-table* 1)
                      lightning-probe-callback
                      (-> *part-id-table* 166)
                      0
                      0
                      40960.0
                      )
                    )
                  )
                )
              (suspend)
              (ja :num! (seek!))
              )
            (set! (-> sv-32 angle) 'back)
            (set! (-> self post-hook) gp-4)
            )
          )
         (else
           (pickup-collectable! (-> self fact-override) (pickup-type health) (- (-> sv-32 damage)) (the-as handle #f))
           )
         )
       (target-hit-effect sv-32)
       )
      (else
        (case (-> sv-32 mode)
          (('burn 'burnup)
           (sound-play "get-burned")
           )
          )
        )
      )
    (when (and (= (-> self game mode) 'play) (and (>= 0.0 (-> self fact-override health)) (using-gun? self)))
      (send-event (ppointer->process (-> self gun gun)) 'die)
      (target-gun-end-mode #f)
      )
    (set! (-> self control mod-surface) *smack-mods*)
    (target-hit-setup-anim sv-32)
    (target-hit-move sv-32 (target-hit-orient sv-32 sv-36) target-falling-anim-trans 1.0)
    (if (and (and (focus-test? self dark) (nonzero? (-> self darkjak))) (>= 1.0 (-> self fact-override health)))
        (go target-darkjak-get-off)
        )
    (if (and (= (-> self game mode) 'play) (>= 0.0 (-> self fact-override health)))
        (go target-death (-> sv-32 mode))
        )
    (go target-hit-ground #f)
    (none)
    )
  :post target-post
  )

(define *death-spool-array*
  (new 'static 'boxed-array :type spool-anim
    (new 'static 'spool-anim :name "jak-death-1" :anim-name "jak-death-1" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-2" :anim-name "jak-death-2" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-3" :anim-name "jak-death-3" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-4" :anim-name "jak-death-4" :parts 1 :command-list '())
    (new 'static 'spool-anim :name "jak-death-5" :anim-name "jak-death-5" :parts 1 :command-list '())
    )
  )

(defun death-movie-remap ((arg0 int) (arg1 int))
  (let ((v1-0 (/ arg0 arg1)))
    (mod
      (if (not (logtest? v1-0 1))
          (logxor v1-0 arg0)
          (logand #xfffffff (- (logxor v1-0 arg0)))
          )
      arg1
      )
    )
  )

(deftype kill-nearby-enemies-info (basic)
  ((dist float          :offset-assert   4)
   (pos  vector :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(define *kill-nearby-enemies-info* (new 'static 'kill-nearby-enemies-info))

(defun kill-nearby-enemies ((arg0 vector) (arg1 float))
  (let ((v1-0 *kill-nearby-enemies-info*))
    (set! (-> v1-0 dist) arg1)
    (set! (-> v1-0 pos quad) (-> arg0 quad))
    )
  (iterate-process-tree
    *entity-pool*
    (lambda ((arg0 process))
      (if (and (logtest? (process-mask enemy) (-> arg0 mask))
               (type? arg0 process-drawable)
               (nonzero? (-> (the-as process-drawable arg0) root))
               (>= (-> *kill-nearby-enemies-info* dist)
                   (vector-vector-distance (-> (the-as process-drawable arg0) root trans) (-> *kill-nearby-enemies-info* pos))
                   )
               )
          (process-entity-status! arg0 (entity-perm-status bit-9) #t)
          )
      )
    *null-kernel-context*
    )
  )

(defbehavior target-death-anim-trans target ()
  (send-event *camera* 'joystick 0 -1082130432)
  (compute-alignment! (-> self align))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (when (not (logtest? (-> self align flags) (align-flags disabled)))
      (vector-matrix*! gp-0 (the-as vector (-> self align delta)) (-> self control c-R-w))
      (vector-float*! (-> self control transv) gp-0 (-> self clock frames-per-second))
      )
    )
  0
  (none)
  )

(defbehavior target-death-anim target ((arg0 spool-anim))
  (set! (-> self control mod-surface) *neutral-mods*)
  (set! (-> self state-flags) (logior (state-flags lleg-no-ik rleg-no-ik) (-> self state-flags)))
  (ja-channel-push! 1 (seconds 0.1))
  (ja-no-eval :group! (-> self draw art-group data 69) :num! (seek! (ja-aframe 30.0 0)) :frame-num 0.0)
  (until (ja-done? 0)
    (if arg0
        (gui-control-method-12
          *gui-control*
          self
          (gui-channel art-load)
          (gui-action queue)
          (-> arg0 name)
          0
          -99.0
          (new 'static 'sound-id)
          )
        )
    (target-death-anim-trans)
    (suspend)
    (ja :num! (seek! (ja-aframe 30.0 0)))
    )
  0
  (none)
  )

(defbehavior target-death-main target ((arg0 symbol))
  (case arg0
    (('tar)
     (sound-play "death-drown")
     )
    )
  (+! (-> *game-info* death-movie-tick) 1)
  (if (= (death-movie-remap (+ (-> *game-info* death-movie-tick) -1) (-> *death-spool-array* length))
         (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length))
         )
      (+! (-> *game-info* death-movie-tick) 1)
      )
  (let ((gp-2
          (-> *death-spool-array* (death-movie-remap (-> *game-info* death-movie-tick) (-> *death-spool-array* length)))
          )
        )
    (if (or (rand-vu-percent? 0.5) (nonzero? (-> *task-manager-engine* length)))
        (set! gp-2 (the-as spool-anim #f))
        )
    (set-setting! 'allow-progress #f 0.0 0)
    (target-death-anim gp-2)
    (cond
      ((or (not gp-2) (or (or (logtest? (water-flags touch-water) (-> self water flags))
                              (logtest? (-> self control status) (collide-status on-water))
                              )
                          (or (= (-> self control ground-pat material) (pat-material snow))
                              (= (-> self control ground-pat material) (pat-material deepsnow))
                              (-> *setting-control* user-current spooling)
                              (let ((v1-44 (file-status *art-control* (-> gp-2 name) 0)))
                                (not (or (= v1-44 'locked) (= v1-44 'active)))
                                )
                              )
                          )
           )
       (ja-no-eval :num! (seek!))
       (while (not (ja-done? 0))
         (target-death-anim-trans)
         (suspend)
         (ja-eval)
         )
       )
      ((string-prefix= "jak" (-> gp-2 name))
       (set! (-> self spool-anim) gp-2)
       (set! (-> self post-hook) (lambda () (target-death-anim-trans) (target-no-stick-post) (none)))
       (ja-play-spooled-anim
         gp-2
         (the-as art-joint-anim (-> self draw art-group data 5))
         (the-as art-joint-anim #f)
         (the-as (function process-drawable symbol) false-func)
         )
       (set-blackout-frames (seconds 0.1))
       (set! (-> self spool-anim) #f)
       )
      )
    )
  0
  (none)
  )

(defbehavior target-death-reset target ((arg0 symbol) (arg1 symbol))
  (let ((v1-1 (-> *task-manager-engine* alive-list next0)))
    *task-manager-engine*
    (let ((s4-0 (-> v1-1 next0)))
      (while (!= v1-1 (-> *task-manager-engine* alive-list-end))
        (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-1 from) (process->ppointer self))
          (set! (-> a1-1 num-params) 2)
          (set! (-> a1-1 message) 'target)
          (set! (-> a1-1 param 0) (the-as uint 'die))
          (set! (-> a1-1 param 1) (the-as uint arg0))
          (let ((v1-2 (send-event-function (the-as process-tree (-> (the-as connection v1-1) param1)) a1-1)))
            (case v1-2
              (('wait)
               (set! arg1 (the-as symbol v1-2))
               )
              )
            )
          )
        (set! v1-1 s4-0)
        *task-manager-engine*
        (set! s4-0 (-> s4-0 next0))
        )
      )
    )
  (cond
    ((= (the-as object arg1) 'wait)
     (set! (-> self trans-hook) #f)
     (set! (-> self control unknown-word04) (the-as uint #f))
     (when (not (focus-test? self pilot))
       (set! (-> self post-hook) target-no-ja-move-post)
       (ja-post)
       )
     (while (not (-> self control unknown-spool-anim00))
       (send-event *camera* 'joystick 0 -1082130432)
       (suspend)
       )
     )
    (else
      (suspend)
      0
      )
    )
  (set! (-> self control transv quad) (the-as uint128 0))
  (initialize!
    (-> self game)
    (if (= arg0 'bot)
        'try
        'life
        )
    (the-as game-save #f)
    (the-as string #f)
    )
  (set! (-> self state-time) (current-time))
  (sleep-code)
  0
  (none)
  )

(defstate target-death (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (cond
                       ((= v1-0 'end-mode)
                        (let ((v0-0 (the-as object #t)))
                          (set! (-> self control unknown-word04) (the-as uint v0-0))
                          v0-0
                          )
                        )
                       ((= v1-0 'change-mode)
                        (case (-> event param 0)
                          (('grab)
                           (case (-> event param 1)
                             (('dead)
                              #t
                              )
                             (else
                               #f
                               )
                             )
                           )
                          )
                        )
                       ((= v1-0 'notify)
                        (when (type? proc pov-camera)
                          (case (-> event param 0)
                            (('die 'abort-request)
                             (set! (-> self control unknown-word04) (the-as uint #t))
                             (the-as object (set-blackout-frames (seconds 0.2)))
                             )
                            )
                          )
                        )
                       ((= v1-0 'get-pickup)
                        #f
                        )
                       ((= v1-0 'touched)
                        #f
                        )
                       (else
                         (target-generic-event-handler proc arg1 event-type event)
                         )
                       )
              )
      )
    )
  :exit (behavior ()
    (let ((a0-0 (-> self spool-anim)))
      (when (and a0-0 (= (-> *setting-control* user-current spooling) (process->ppointer self)))
        (ja-abort-spooled-anim a0-0 (the-as art-joint-anim #f) -1)
        (ja-channel-set! 1)
        (ja :group! (-> self draw art-group data 5) :num! min)
        )
      )
    (logclear! (-> self focus-status) (focus-status dead hit))
    (logclear! (-> self state-flags) (state-flags disable-attacks))
    (target-exit)
    (remove-setting! 'process-mask)
    (remove-setting! 'allow-progress)
    (remove-setting! 'mode-name)
    (let ((v1-20 (-> self control root-prim)))
      (set! (-> v1-20 prim-core collide-as) (-> self control backup-collide-as))
      (set! (-> v1-20 prim-core collide-with) (-> self control backup-collide-with))
      )
    (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1))
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (send-event (ppointer->process (-> self gun gun)) 'reset)
    (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
    (none)
    )
  :trans (-> target-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control pat-ignore-mask)
          (logior (new 'static 'pat-surface :noendlessfall #x1) (-> self control pat-ignore-mask))
          )
    (target-timed-invulnerable-off self 0)
    (case arg0
      (('bot 'centipede)
       (set-setting! 'process-mask 'set 0.0 (process-mask platform projectile death))
       )
      (('endlessfall)
       (set-setting! 'process-mask 'set 0.0 (process-mask enemy projectile death))
       )
      (('instant-death 'lava 'dark-eco-pool 'melt 'explode 'grenade 'big-explosion 'turret)
       (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
       )
      (else
        (let ((v1-21 (-> self water flags)))
          (if (or (and (logtest? (water-flags touch-water) v1-21)
                       (logtest? (water-flags under-water swimming) v1-21)
                       (not (logtest? (focus-status mech) (-> self focus-status)))
                       )
                  (= (-> self control cur-pat material) (pat-material waterbottom))
                  )
              (set! arg0 'drown)
              )
          )
        (set-setting! 'process-mask 'set 0.0 (process-mask enemy platform projectile death))
        (when (using-gun? self)
          (send-event (ppointer->process (-> self gun gun)) 'die)
          (target-gun-end-mode #f)
          )
        )
      )
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (set! (-> self state-flags) (logior (state-flags disable-attacks) (-> self state-flags)))
    (let ((v1-50 arg0))
      (b! (not (or (= v1-50 'none) (= v1-50 'instant-death))) cfg-52 :delay (nop!))
      (b! #t cfg-167 :delay (nop!))
      (label cfg-52)
      (b!
        (not (or (= v1-50 'lava)
                 (= v1-50 'dark-eco-pool)
                 (= v1-50 'melt)
                 (= v1-50 'explode)
                 (= v1-50 'grenade)
                 (= v1-50 'big-explosion)
                 )
             )
        cfg-132
        :delay (nop!)
        )
      (let ((s5-0 (handle->process (-> self attack-info attacker))))
        (when (if (type? s5-0 water-vol)
                  s5-0
                  )
          (logior! (-> self state-flags) (state-flags sf14))
          (set! (-> self alt-cam-pos y) (+ 4096.0 (-> self water height)))
          )
        )
      (set! (-> self control mod-surface) *neutral-mods*)
      (let ((v1-63 arg0))
        (b! (!= v1-63 'dark-eco-pool) cfg-79 :delay (empty-form))
        (sound-play "death-darkeco")
        (let ((s5-2 (get-process *default-dead-pool* part-tracker #x4000)))
          (when s5-2
            (let ((t9-14 (method-of-type part-tracker activate)))
              (t9-14
                (the-as part-tracker s5-2)
                *entity-pool*
                (symbol->string (-> part-tracker symbol))
                (the-as pointer #x70004000)
                )
              )
            (let ((t9-15 run-function-in-process)
                  (a0-61 s5-2)
                  (a1-27 part-tracker-init)
                  (a2-10 (-> *part-group-id-table* 56))
                  (a3-6 0)
                  (t0-5 #f)
                  (t1-5 #f)
                  (t2-1 #f)
                  (t3-0 *launch-matrix*)
                  )
              (set! (-> t3-0 trans quad) (-> self control trans quad))
              ((the-as (function object object object object object object object object none) t9-15)
               a0-61
               a1-27
               a2-10
               a3-6
               t0-5
               t1-5
               t2-1
               t3-0
               )
              )
            (-> s5-2 ppointer)
            )
          )
        (let ((v1-75 (-> self control root-prim)))
          (set! (-> v1-75 prim-core collide-as) (collide-spec))
          (set! (-> v1-75 prim-core collide-with) (collide-spec))
          )
        0
        (set! (-> self post-hook) target-no-ja-move-post)
        (ja-channel-set! 0)
        (ja-post)
        (let ((s5-3 (current-time)))
          (until (>= (- (current-time) s5-3) (seconds 2))
            (suspend)
            )
          )
        (b! #t cfg-131 :delay (nop!))
        (label cfg-79)
        (b! (not (or (= v1-63 'grenade) (= v1-63 'big-explosion) (= v1-63 'explode))) cfg-122 :delay (empty-form))
        (set! (-> self post-hook) target-no-stick-post)
        (set! (-> self control dynam gravity-max) 294912.0)
        (set! (-> self control dynam gravity-length) 294912.0)
        (vector-float*!
          (-> self control dynam gravity)
          (-> self control dynam gravity-normal)
          (the-as float (-> self control dynam gravity-length))
          )
        (case arg0
          (('big-explosion)
           (sound-play "jak-explode")
           )
          (else
            (sound-play "explosion")
            )
          )
        (let ((s5-6 (get-process *default-dead-pool* part-tracker #x4000)))
          (when s5-6
            (let ((t9-23 (method-of-type part-tracker activate)))
              (t9-23
                (the-as part-tracker s5-6)
                *entity-pool*
                (symbol->string (-> part-tracker symbol))
                (the-as pointer #x70004000)
                )
              )
            (let ((t9-24 run-function-in-process)
                  (a0-80 s5-6)
                  (a1-36 part-tracker-init)
                  (a2-17 (-> *part-group-id-table* 58))
                  (a3-10 0)
                  (t0-8 #f)
                  (t1-8 #f)
                  (t2-4 #f)
                  (t3-1 *launch-matrix*)
                  )
              (set! (-> t3-1 trans quad) (-> self control trans quad))
              ((the-as (function object object object object object object object object none) t9-24)
               a0-80
               a1-36
               a2-17
               a3-10
               t0-8
               t1-8
               t2-4
               t3-1
               )
              )
            (-> s5-6 ppointer)
            )
          )
        (set-vector! (-> self control transv) 0.0 65502.96 0.0 1.0)
        (ja-channel-push! 1 (seconds 0.1))
        (ja-no-eval :group! (-> self draw art-group data 66)
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 66)) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (b!
            (not (and (logtest? (-> self control status) (collide-status on-surface))
                      (>= 409.6 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                      )
                 )
            cfg-98
            :delay (empty-form)
            )
          (b! #t cfg-106 :delay (nop!))
          (the-as none 0)
          (label cfg-98)
          (suspend)
          (ja :num! (seek!))
          )
        (while (not (or (logtest? (-> self control status) (collide-status on-surface))
                        (>= (- (current-time) (-> self state-time)) (seconds 2))
                        )
                    )
          (suspend)
          )
        (label cfg-106)
        (when (logtest? (-> self control status) (collide-status on-surface))
          (let ((v1-159 (-> self water flags)))
            (b!
              (or (and (logtest? (water-flags touch-water) v1-159)
                       (logtest? (water-flags under-water swimming) v1-159)
                       (not (logtest? (focus-status mech) (-> self focus-status)))
                       )
                  (= (-> self control cur-pat material) (pat-material waterbottom))
                  )
              cfg-149
              :delay (nop!)
              )
            )
          (set! (-> self post-hook) target-no-move-post)
          (let ((v1-171 (-> self control root-prim)))
            (set! (-> v1-171 prim-core collide-as) (collide-spec))
            (set! (-> v1-171 prim-core collide-with) (collide-spec))
            )
          0
          (ja-channel-push! 1 (seconds 0.1))
          (ja-no-eval :group! (-> self draw art-group data 70)
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 70)) frames num-frames) -1)))
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (set! (-> self control transv quad) (the-as uint128 0))
            (vector-seek!
              (-> self draw color-mult)
              (new 'static 'vector :x 0.5 :y 0.5 :z 0.5 :w 1.0)
              (* 5.0 (-> self clock seconds-per-frame))
              )
            (suspend)
            (ja :num! (seek!))
            )
          (let ((s5-7 (current-time)))
            (until (>= (- (current-time) s5-7) (seconds 2))
              (suspend)
              )
            )
          )
        (b! #t cfg-131 :delay (nop!))
        (label cfg-122)
        (when (or (= v1-63 'lava) (= v1-63 'melt))
          (sound-play "death-melt")
          (let ((s5-9 (get-process *default-dead-pool* part-tracker #x4000)))
            (when s5-9
              (let ((t9-37 (method-of-type part-tracker activate)))
                (t9-37
                  (the-as part-tracker s5-9)
                  *entity-pool*
                  (symbol->string (-> part-tracker symbol))
                  (the-as pointer #x70004000)
                  )
                )
              (let ((t9-38 run-function-in-process)
                    (a0-107 s5-9)
                    (a1-49 part-tracker-init)
                    (a2-28 (-> *part-group-id-table* 57))
                    (a3-13 0)
                    (t0-10 #f)
                    (t1-10 #f)
                    (t2-6 #f)
                    (t3-2 *launch-matrix*)
                    )
                (set! (-> t3-2 trans quad) (-> self control trans quad))
                ((the-as (function object object object object object object object object none) t9-38)
                 a0-107
                 a1-49
                 a2-28
                 a3-13
                 t0-10
                 t1-10
                 t2-6
                 t3-2
                 )
                )
              (-> s5-9 ppointer)
              )
            )
          (let ((v1-219 (-> self control root-prim)))
            (set! (-> v1-219 prim-core collide-as) (collide-spec))
            (set! (-> v1-219 prim-core collide-with) (collide-spec))
            )
          0
          (set! (-> self post-hook) target-no-ja-move-post)
          (ja-channel-set! 0)
          (ja-post)
          (let ((s5-10 (current-time)))
            (until (>= (- (current-time) s5-10) (seconds 2))
              (suspend)
              )
            )
          )
        )
      (label cfg-131)
      (b! #t cfg-167 :delay (nop!))
      (label cfg-132)
      (cond
        ((= v1-50 'turret)
         (let ((v1-228 (-> self control root-prim)))
           (set! (-> v1-228 prim-core collide-as) (collide-spec))
           (set! (-> v1-228 prim-core collide-with) (collide-spec))
           )
         0
         (set! (-> self post-hook) target-no-ja-move-post)
         (ja-channel-set! 0)
         (ja-post)
         (let ((s5-11 (current-time)))
           (until (>= (- (current-time) s5-11) (seconds 1.2))
             (suspend)
             )
           )
         )
        ((= v1-50 'endlessfall)
         ((lambda :behavior target
            ()
            (local-vars (v1-24 symbol))
            (sound-play "death-fall")
            (set! (-> self control unknown-sound-id00)
                  (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "jakfall" -99.0 0)
                  )
            (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
            (set-setting! 'mode-name 'cam-endlessfall 0.0 0)
            (logclear! (-> self water flags) (water-flags swim-ground))
            (let ((f0-1 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
              (set! (-> self control unknown-word04) (the-as uint f0-1))
              (let ((v1-13 (new-stack-vector0)))
                (let ((f1-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                  0.0
                  (vector-! v1-13 (-> self control transv) (vector-float*! v1-13 (-> self control dynam gravity-normal) f1-3))
                  )
                (let* ((f1-4 (vector-length v1-13))
                       (f2-1 f1-4)
                       )
                  (vector+!
                    (-> self control transv)
                    (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-1)
                    (vector-float*! v1-13 v1-13 (/ f1-4 f2-1))
                    )
                  )
                )
              )
            (when (and (logtest? (-> self control status) (collide-status on-surface)) (!= (-> self control cur-pat event) 2))
              (set! v1-24 'target-hit-ground-hard)
              (goto cfg-17)
              )
            (target-falling-anim 30 (seconds 0.33))
            (ja-channel-push! 1 (seconds 0.3))
            (ja-no-eval :group! (-> self draw art-group data 32) :num! (loop! 0.5) :frame-num 0.0)
            (let ((gp-1 (current-time)))
              (until (>= (- (current-time) gp-1) (seconds 0.8))
                (when (and (logtest? (-> self control status) (collide-status on-surface)) (!= (-> self control cur-pat event) 2))
                  (set! v1-24 'target-hit-ground-hard)
                  (goto cfg-17)
                  )
                (vector-seek! (-> self draw color-mult) *zero-vector* (-> self clock seconds-per-frame))
                (let ((v1-49 (new-stack-vector0))
                      (f0-7 (the-as number (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                      )
                  0.0
                  (vector-!
                    v1-49
                    (-> self control transv)
                    (vector-float*! v1-49 (-> self control dynam gravity-normal) (the-as float f0-7))
                    )
                  (let* ((f1-7 (vector-length v1-49))
                         (f2-2 f1-7)
                         )
                    (if (< (the-as float (-> self control unknown-word04)) (the-as float f0-7))
                        (set! f0-7 (-> self control unknown-word04))
                        )
                    (vector+!
                      (-> self control transv)
                      (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) (the-as float f0-7))
                      (vector-float*! v1-49 v1-49 (/ f1-7 f2-2))
                      )
                    )
                  )
                (ja :group! (-> self draw art-group data 32) :num! (loop! 0.5))
                (suspend)
                )
              )
            (set! v1-24 #f)
            (label cfg-17)
            (when (= v1-24 'target-hit-ground-hard)
              (set! (-> self control mod-surface) *neutral-mods*)
              (set! (-> self post-hook) target-no-move-post)
              (set! (-> self control transv quad) (the-as uint128 0))
              (ja-channel-push! 1 (seconds 0.05))
              (ja-no-eval :group! (-> self draw art-group data 70)
                          :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 70)) frames num-frames) -1)))
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (vector-seek! (-> self draw color-mult) *identity-vector* (-> self clock seconds-per-frame))
                (suspend)
                (ja :num! (seek!))
                )
              (let ((gp-2 (current-time)))
                (until (>= (- (current-time) gp-2) (seconds 2))
                  (suspend)
                  )
                )
              )
            (remove-setting! 'mode-name)
            (none)
            )
          )
         )
        ((or (= v1-50 'burn) (= v1-50 'burnup))
         (let ((s5-12 (get-process *default-dead-pool* part-tracker #x4000)))
           (when s5-12
             (let ((t9-45 (method-of-type part-tracker activate)))
               (t9-45
                 (the-as part-tracker s5-12)
                 *entity-pool*
                 (symbol->string (-> part-tracker symbol))
                 (the-as pointer #x70004000)
                 )
               )
             (let ((t9-46 run-function-in-process)
                   (a0-118 s5-12)
                   (a1-53 part-tracker-init)
                   (a2-33 (-> *part-group-id-table* 59))
                   (a3-15 0)
                   (t0-11 #f)
                   (t1-11 #f)
                   (t2-7 #f)
                   (t3-3 *launch-matrix*)
                   )
               (set! (-> t3-3 trans quad) (-> self control trans quad))
               ((the-as (function object object object object object object object object none) t9-46)
                a0-118
                a1-53
                a2-33
                a3-15
                t0-11
                t1-11
                t2-7
                t3-3
                )
               )
             (-> s5-12 ppointer)
             )
           )
         (target-death-anim (the-as spool-anim #f))
         )
        ((or (= v1-50 'drown) (= v1-50 'drown-death))
         (label cfg-149)
         ((lambda :behavior target
            ()
            (logior! (-> self state-flags) (state-flags sf14))
            (set! (-> self alt-cam-pos y) (+ -8192.0 (-> self water height)))
            (sound-play "death-drown")
            (logclear! (-> self water flags) (water-flags swim-ground))
            (set! (-> self control mod-surface) *dive-mods*)
            (set! (-> self control dynam gravity-max) 6144.0)
            (set! (-> self control dynam gravity-length) 6144.0)
            (ja-channel-push! 1 (seconds 0.1))
            (ja-no-eval :group! (-> self draw art-group data 89)
                        :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 89)) frames num-frames) -1)))
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (if (< (+ -10240.0 (-> self water height)) (-> self control trans y))
                  (seek!
                    (-> self control trans y)
                    (+ -10240.0 (-> self water height))
                    (* 81920.0 (-> self clock seconds-per-frame))
                    )
                  )
              (suspend)
              (ja :num! (seek!))
              )
            (dotimes (gp-1 1)
              (ja-no-eval :group! (-> self draw art-group data 90)
                          :num! (seek!
                            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 90)) frames num-frames) -1))
                            0.75
                            )
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! max 0.75))
                )
              )
            (ja-no-eval :group! (-> self draw art-group data 91)
                        :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 91)) frames num-frames) -1)) 0.5)
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max 0.5))
              )
            #f
            )
          )
         )
        ((or (= v1-50 'target-hit-ground-hard) (= v1-50 'smush))
         (set! (-> self control mod-surface) *neutral-mods*)
         (ja-channel-push! 1 (seconds 0.1))
         (ja-no-eval :group! (-> self draw art-group data 70)
                     :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 70)) frames num-frames) -1)))
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek!))
           )
         (let ((s5-13 (current-time)))
           (until (>= (- (current-time) s5-13) (seconds 2))
             (suspend)
             )
           )
         )
        ((= v1-50 'centipede)
         (set! (-> self trans-hook) #f)
         (set! (-> self control mod-surface) *neutral-mods*)
         (set! (-> self post-hook) target-no-move-post)
         (ja-channel-push! 1 (seconds 0.075))
         (ja :group! (-> self draw art-group data 67) :num! min)
         (while (not (-> self control unknown-spool-anim00))
           (suspend)
           (ja :num! (loop!))
           )
         )
        ((= v1-50 'bot)
         ((lambda :behavior target
            ()
            (set! (-> self trans-hook) #f)
            (let ((gp-0 0))
              (while (not (logtest? (-> self control status) (collide-status on-surface)))
                (target-falling-anim-trans)
                (+! gp-0 (- (current-time) (-> self clock old-frame-counter)))
                (if (-> self control unknown-spool-anim00)
                    (return #f)
                    )
                (suspend)
                )
              (if (or (> gp-0 0) (let ((v1-14 (ja-group)))
                                   (and v1-14 (or (= v1-14 (-> self draw art-group data 23))
                                                  (= v1-14 (-> self draw art-group data 27))
                                                  (= v1-14 (-> self draw art-group data 30))
                                                  )
                                        )
                                   )
                      )
                  (target-hit-ground-anim #f (are-still?))
                  )
              )
            (target-stance-push 1)
            (until #f
              (ja-no-eval :group! (-> self draw art-group data 5)
                          :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames) -1)))
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (if (-> self control unknown-spool-anim00)
                    (return #f)
                    )
                (suspend)
                (ja :num! (seek!))
                )
              )
            #f
            )
          )
         )
        (else
          (target-death-main arg0)
          )
        )
      )
    (label cfg-167)
    (target-death-reset arg0 #f)
    (none)
    )
  :post target-no-stick-post
  )
