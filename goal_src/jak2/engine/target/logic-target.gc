;;-*-Lisp-*-
(in-package goal)

;; name: logic-target.gc
;; name in dgo: logic-target
;; dgos: ENGINE, GAME

(define-extern history-draw (function history-iterator none))
(define-extern target-sidekick-setup (function symbol none :behavior target))
(define-extern target-board-setup (function symbol none :behavior target))
(define-extern target-float (state target))
(define-extern target-timed-invulnerable-off (function target int none))
(define-extern target-gun-joint-pre (function none :behavior target))
(define-extern target-gun-joint-points (function none :behavior target))
(define-extern target-board-joint-points (function none :behavior target))
(define-extern debounce-speed (function float float vector vector float :behavior target))
(define-extern ja-post (function none :behavior process-drawable))
(define-extern target-powerup-process (function none :behavior target))
(define-extern target-exit (function none :behavior target))
(define-extern target-collision-no-reaction (function control-info collide-query vector vector none))
(define-extern target-gun-setup (function symbol none :behavior target))
(define-extern target-darkjak-setup (function symbol none :behavior target))
(define-extern target-collide-set! (function symbol float int :behavior target))
(define-extern activate-hud (function target none))
(define-extern target-generic-event-handler (function process int symbol event-message-block object :behavior target))
(define-extern target-continue (state continue-point target))
(define-extern tobot-stance (state target))

;; DECOMP BEGINS

(defbehavior build-conversions target ((arg0 vector))
  (when (!= (-> self control prev-surf) (-> self control surf))
    (set! (-> self control prev-surf) (-> self control surf))
    (set! (-> self control time-of-last-surface-change) (current-time))
    )
  (surface-mult! (-> self control current-surface) (-> self control mod-surface) (-> self control surf))
  (when (and (and (= (-> (the-as fact-info-target (-> self fact-override)) eco-type) 3)
                  (>= (-> (the-as fact-info-target (-> self fact-override)) eco-level) 1.0)
                  )
             (or (= (-> self control mod-surface name) 'run) (= (-> self control mod-surface name) 'jump))
             )
    (set! (-> self control current-surface target-speed)
          (+ 20480.0 (-> self control current-surface target-speed))
          )
    (set! (-> self control current-surface transv-max) (+ 20480.0 (-> self control current-surface transv-max)))
    )
  (when (and (and (focus-test? self dark) (nonzero? (-> self darkjak)))
             (or (= (-> self control mod-surface name) 'run)
                 (= (-> self control mod-surface name) 'jump)
                 (= (-> self control mod-surface name) 'attack)
                 )
             )
    (set! (-> self control current-surface target-speed)
          (* 1.2 (-> self darkjak-giant-interp) (-> self control current-surface target-speed))
          )
    (set! (-> self control current-surface transv-max)
          (* 1.2 (-> self darkjak-giant-interp) (-> self control current-surface transv-max))
          )
    )
  (let ((f0-11 (-> *setting-control* user-current speed-mult)))
    (set! (-> self control current-surface target-speed) (* (-> self control current-surface target-speed) f0-11))
    (set! (-> self control current-surface transv-max) (* (-> self control current-surface transv-max) f0-11))
    )
  (let ((s5-0 (new-stack-vector0)))
    (vector-z-quaternion! s5-0 (-> self control quat-for-control))
    (when (logtest? (-> self control mod-surface flags) (surface-flag xz-local))
      (vector-flatten! s5-0 s5-0 (-> self control dynam gravity-normal))
      (vector-normalize! s5-0 1.0)
      )
    (forward-up-nopitch->inv-matrix (-> self control c-R-w) s5-0 (-> self control local-normal))
    )
  (matrix-transpose! (-> self control w-R-c) (-> self control c-R-w))
  (vector-matrix*! (-> self control transv-ctrl) arg0 (-> self control w-R-c))
  (set! (-> self control last-gravity-normal quad) (-> self control gravity-normal quad))
  (let ((v0-7 (-> self control gravity-normal)))
    (set! (-> v0-7 quad) (-> self control dynam gravity-normal quad))
    v0-7
    )
  )

(defbehavior vector-turn-to target ((arg0 vector))
  (forward-up-nopitch->quaternion
    (-> self control dir-targ)
    (vector-normalize-copy! (new 'stack-no-clear 'vector) arg0 1.0)
    (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (build-conversions (-> self control transv))
  )

;; WARN: Return type mismatch collide-status vs none.
(defbehavior reverse-conversions target ((arg0 vector))
  (let ((v1-1 (-> self control transv-ctrl)))
    (set! (-> self control ctrl-xz-vel) (sqrtf (+ (* (-> v1-1 x) (-> v1-1 x)) (* (-> v1-1 z) (-> v1-1 z)))))
    )
  (vector-matrix*! arg0 (-> self control transv-ctrl) (-> self control c-R-w))
  (set! (-> self control old-status) (-> self control status))
  (none)
  )

(defun-debug draw-history ((arg0 control-info))
  (when (nonzero? *display-collide-history*)
    (when (cpad-pressed? 0 l3)
      (set! (-> arg0 history-length) (logand (+ (-> arg0 history-length) 1) 3))
      (if (cpad-hold? 0 l2)
          (set! (-> arg0 history-length) (the-as uint 1000))
          )
      )
    (let* ((v1-15 (-> arg0 history-length))
           (gp-0 (cond
                   ((zero? v1-15)
                    465
                    )
                   ((= v1-15 1)
                    469
                    )
                   ((= v1-15 2)
                    473
                    )
                   ((= v1-15 3)
                    913
                    )
                   (else
                     384
                     )
                   )
                 )
           (a0-5 (new 'stack 'history-iterator (the-as uint 1800)))
           )
      (set! (-> a0-5 out) #t)
      (set! (-> a0-5 owner) (the-as uint 2))
      (set! (-> a0-5 channel-mask) (the-as uint gp-0))
      (history-draw a0-5)
      )
    )
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defun-debug target-print-stats ((arg0 target) (arg1 symbol))
  (local-vars
    (sv-64 int)
    (sv-72 int)
    (sv-80 art-joint-anim-manager)
    (sv-96 string)
    (sv-112 string)
    (sv-128 string)
    (sv-144 string)
    (sv-160 string)
    (sv-176 string)
    (sv-192 string)
    (sv-208 string)
    (sv-224 string)
    (sv-240 string)
    (sv-256 string)
    (sv-272 string)
    (sv-288 string)
    (sv-304 string)
    )
  (with-pp
    (let ((s5-0 pp))
      (set! pp arg0)
      (when (and *display-ground-stats* arg0)
        (let ((s3-0 format)
              (s2-0 arg1)
              (s1-0 "~0kpoly:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-0 (-> arg0 control poly-pat))
              )
          (set! sv-96 (pat-mode->string (-> arg0 control poly-pat)))
          (set! sv-112 (pat-material->string (-> arg0 control poly-pat)))
          (let ((t1-0 (pat-event->string (-> arg0 control poly-pat))))
            (s3-0 s2-0 s1-0 s0-0 sv-96 sv-112 t1-0)
            )
          )
        (let ((s3-1 format)
              (s2-1 arg1)
              (s1-1 "~0kgrnd:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-1 (-> arg0 control ground-pat))
              )
          (set! sv-128 (pat-mode->string (-> arg0 control ground-pat)))
          (set! sv-144 (pat-material->string (-> arg0 control ground-pat)))
          (let ((t1-1 (pat-event->string (-> arg0 control ground-pat))))
            (s3-1 s2-1 s1-1 s0-1 sv-128 sv-144 t1-1)
            )
          )
        (let ((s3-2 format)
              (s2-2 arg1)
              (s1-2 "~0kwall:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-2 (-> arg0 control wall-contact-pat))
              )
          (set! sv-160 (pat-mode->string (-> arg0 control wall-contact-pat)))
          (set! sv-176 (pat-material->string (-> arg0 control wall-contact-pat)))
          (let ((t1-2 (pat-event->string (-> arg0 control wall-contact-pat))))
            (s3-2 s2-2 s1-2 s0-2 sv-160 sv-176 t1-2)
            )
          )
        (let ((s3-3 format)
              (s2-3 arg1)
              (s1-3 "~0kgspt:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-3 (-> arg0 control gspot-pat-surfce))
              )
          (set! sv-192 (pat-mode->string (-> arg0 control gspot-pat-surfce)))
          (set! sv-208 (pat-material->string (-> arg0 control gspot-pat-surfce)))
          (let ((t1-3 (pat-event->string (-> arg0 control gspot-pat-surfce))))
            (s3-3 s2-3 s1-3 s0-3 sv-192 sv-208 t1-3)
            )
          )
        )
      (when (and *stats-target* arg0)
        (format
          arg1
          "~0ks: ~M ~X/~X ~A ~A ~A~%"
          (-> arg0 control ctrl-xz-vel)
          (-> arg0 control status)
          (-> arg0 control prev-status)
          (if (-> arg0 state)
              (-> arg0 state name)
              )
          (-> arg0 control surf name)
          (-> arg0 control mod-surface name)
          )
        (let ((s3-4 (-> arg0 focus-status)))
          (if (= (logand s3-4 (focus-status pole)) (focus-status pole))
              (format arg1 "pole ")
              )
          (if (= (logand s3-4 (focus-status dead)) (focus-status dead))
              (format arg1 "dead ")
              )
          (if (= (logand (focus-status gun) s3-4) (focus-status gun))
              (format arg1 "gun ")
              )
          (if (= (logand (focus-status mech) s3-4) (focus-status mech))
              (format arg1 "mech ")
              )
          (if (= (logand (focus-status pilot) s3-4) (focus-status pilot))
              (format arg1 "racer ")
              )
          (if (= (logand (focus-status shooting) s3-4) (focus-status shooting))
              (format arg1 "shooting ")
              )
          (if (= (logand (focus-status halfpipe) s3-4) (focus-status halfpipe))
              (format arg1 "halfpipe ")
              )
          (if (= (logand s3-4 (focus-status in-head)) (focus-status in-head))
              (format arg1 "in-head ")
              )
          (if (= (logand s3-4 (focus-status grabbed)) (focus-status grabbed))
              (format arg1 "grabbed ")
              )
          (if (= (logand s3-4 (focus-status ignore)) (focus-status ignore))
              (format arg1 "ignore ")
              )
          (if (= (logand s3-4 (focus-status under-water)) (focus-status under-water))
              (format arg1 "under-water ")
              )
          (if (= (logand s3-4 (focus-status disable)) (focus-status disable))
              (format arg1 "disable ")
              )
          (if (= (logand s3-4 (focus-status hit)) (focus-status hit))
              (format arg1 "hit ")
              )
          (if (= (logand s3-4 (focus-status inactive)) (focus-status inactive))
              (format arg1 "inactive ")
              )
          (if (= (logand s3-4 (focus-status dangerous)) (focus-status dangerous))
              (format arg1 "dangerous ")
              )
          (if (= (logand (focus-status teleporting) s3-4) (focus-status teleporting))
              (format arg1 "teleporting ")
              )
          (if (= (logand (focus-status indax) s3-4) (focus-status indax))
              (format arg1 "indax ")
              )
          (if (= (logand (focus-status tube) s3-4) (focus-status tube))
              (format arg1 "tube ")
              )
          (if (= (logand (focus-status pilot) s3-4) (focus-status pilot))
              (format arg1 "pilot ")
              )
          (if (= (logand s3-4 (focus-status edge-grab)) (focus-status edge-grab))
              (format arg1 "edge-grab ")
              )
          (if (= (logand (focus-status dark) s3-4) (focus-status dark))
              (format arg1 "dark ")
              )
          (if (= (logand (focus-status arrestable) s3-4) (focus-status arrestable))
              (format arg1 "arrestable ")
              )
          (if (= (logand (focus-status rail) s3-4) (focus-status rail))
              (format arg1 "rail ")
              )
          (if (= (logand (focus-status ice) s3-4) (focus-status ice))
              (format arg1 "ice ")
              )
          (if (= (logand s3-4 (focus-status pilot-riding)) (focus-status pilot-riding))
              (format arg1 "pilot-riding ")
              )
          (if (= (logand (focus-status board) s3-4) (focus-status board))
              (format arg1 "board ")
              )
          (if (= (logand s3-4 (focus-status on-water)) (focus-status on-water))
              (format arg1 "on-water ")
              )
          (if (= (logand s3-4 (focus-status in-air)) (focus-status in-air))
              (format arg1 "in-air ")
              )
          (if (= (logand (focus-status carry) s3-4) (focus-status carry))
              (format arg1 "carry ")
              )
          (if (= (logand s3-4 (focus-status flut)) (focus-status flut))
              (format arg1 "flut ")
              )
          (if (= (logand s3-4 (focus-status touch-water)) (focus-status touch-water))
              (format arg1 "touch-water ")
              )
          (if (= (logand (focus-status super) s3-4) (focus-status super))
              (format arg1 "super ")
              )
          )
        (if (logtest? (-> arg0 state-flags) (state-flags tinvul1))
            (format arg1 "tinvul1 ")
            )
        (if (logtest? (state-flags tinvul2) (-> arg0 state-flags))
            (format arg1 "tinvul2 ")
            )
        (if (logtest? (state-flags disable-attacks) (-> arg0 state-flags))
            (format arg1 "disable-attacks ")
            )
        (if (logtest? (state-flags lleg-still) (-> arg0 state-flags))
            (format arg1 "lleg-still ")
            )
        (if (logtest? (state-flags rleg-still) (-> arg0 state-flags))
            (format arg1 "rleg-still ")
            )
        (if (logtest? (state-flags lleg-no-ik) (-> arg0 state-flags))
            (format arg1 "lleg-no-ik ")
            )
        (if (logtest? (state-flags rleg-no-ik) (-> arg0 state-flags))
            (format arg1 "rleg-no-ik ")
            )
        (format arg1 "~%")
        (format
          arg1
          "~0k~9S ~9S ~9S ~9S ~9S ~9S~%"
          (if (logtest? (-> arg0 control status) (collide-status on-surface))
              "on-surface"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status on-ground))
              "on-ground"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status touch-surface))
              "t-surface"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status touch-wall))
              "t-wall"
              ""
              )
          (if (logtest? (-> arg0 control status) (collide-status touch-actor))
              "t-act"
              ""
              )
          (cond
            ((logtest? (-> arg0 control status) (collide-status touch-ceiling))
             "t-ceil"
             )
            ((logtest? (-> arg0 control status) (collide-status on-water))
             "on-water"
             )
            (else
              ""
              )
            )
          )
        (when (logtest? (-> arg0 water flags) (water-flags active))
          (format
            arg1
            "water at ~M ~5S ~5S ~5S ~5S "
            (-> arg0 water height)
            (if (logtest? (water-flags touch-water) (-> arg0 water flags))
                "water"
                ""
                )
            (if (logtest? (water-flags wading) (-> arg0 water flags))
                "wade"
                ""
                )
            (if (logtest? (water-flags swimming) (-> arg0 water flags))
                "swim"
                ""
                )
            (if (logtest? (-> arg0 water flags) (water-flags under-water))
                "under"
                ""
                )
            )
          (format arg1 "~2S~%" (if (logtest? (-> arg0 water flags) (water-flags swim-ground))
                                   "sg"
                                   ""
                                   )
                  )
          )
        (format
          arg1
          "~0kan:~,,3f su:~,,3f ti:~,,3f to:~,,3f pa:~,,3f~%"
          (-> arg0 control surface-angle)
          (-> arg0 control local-slope-z)
          (-> arg0 control local-slope-x)
          (-> arg0 control touch-angle)
          (-> arg0 control poly-angle)
          )
        (let ((v1-160 (-> arg0 control trans)))
          (format arg1 "pos: ~6,,2m ~6,,2m ~6,,2m  " (-> v1-160 x) (-> v1-160 y) (-> v1-160 z))
          )
        (let ((s3-5 format)
              (s2-4 arg1)
              (s1-4 "~0kpol:~X/~S/~S/~S~%")
              (s0-4 (-> arg0 control poly-pat))
              )
          (set! sv-224 (pat-mode->string (-> arg0 control poly-pat)))
          (set! sv-240 (pat-material->string (-> arg0 control poly-pat)))
          (let ((t1-10 (pat-event->string (-> arg0 control poly-pat))))
            (s3-5 s2-4 s1-4 s0-4 sv-224 sv-240 t1-10)
            )
          )
        (let ((s3-6 format)
              (s2-5 arg1)
              (s1-5 "~0kcur:~X/~S/~S/~S   ")
              (s0-5 (-> arg0 control cur-pat))
              )
          (set! sv-256 (pat-mode->string (-> arg0 control cur-pat)))
          (set! sv-272 (pat-material->string (-> arg0 control cur-pat)))
          (let ((t1-11 (pat-event->string (-> arg0 control cur-pat))))
            (s3-6 s2-5 s1-5 s0-5 sv-256 sv-272 t1-11)
            )
          )
        (let ((s3-7 format)
              (s2-6 arg1)
              (s1-6 "~0kgnd:~X/~S/~S/~S~%")
              (s0-6 (-> arg0 control ground-pat))
              )
          (set! sv-288 (pat-mode->string (-> arg0 control ground-pat)))
          (set! sv-304 (pat-material->string (-> arg0 control ground-pat)))
          (let ((t1-12 (pat-event->string (-> arg0 control ground-pat))))
            (s3-7 s2-6 s1-6 s0-6 sv-288 sv-304 t1-12)
            )
          )
        (let ((t9-74 format)
              (a0-129 arg1)
              (a1-54 "~0kvel: x:~M  y:~M  z:~M   yv:~M  xzv:~M~%")
              (a2-13 (-> arg0 control transv x))
              (a3-14 (-> arg0 control transv y))
              (t0-14 (-> arg0 control transv z))
              (t1-14 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv)))
              (v1-180 (new-stack-vector0))
              )
          (let ((f0-15 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv))))
            0.0
            (vector-!
              v1-180
              (-> arg0 control transv)
              (vector-float*! v1-180 (-> arg0 control dynam gravity-normal) f0-15)
              )
            )
          (let ((f0-16 (vector-length v1-180)))
            f0-16
            (t9-74 a0-129 a1-54 a2-13 a3-14 t0-14 t1-14 f0-16)
            )
          )
        (format
          arg1
          "~0ky:~,,2M t:~d cy: ~,,2M my: ~,,2M impv:~,,2M "
          (-> arg0 control last-trans-any-surf y)
          (- (current-time) (-> arg0 control last-time-on-surface))
          (- (-> arg0 control trans y) (-> arg0 control last-trans-any-surf y))
          (- (-> arg0 control highest-jump-mark y) (-> arg0 control last-trans-leaving-surf y))
          (-> arg0 control ground-impact-vel)
          )
        (let* ((t9-76 format)
               (a0-131 arg1)
               (a1-56 "~0k~Tcd: ~,,2M md:~,,2M~%")
               (v1-191 (vector-! (new-stack-vector0) (-> arg0 control trans) (-> arg0 control last-trans-any-surf)))
               (a2-17 (sqrtf (+ (* (-> v1-191 x) (-> v1-191 x)) (* (-> v1-191 z) (-> v1-191 z)))))
               (v1-193
                 (vector-! (new-stack-vector0) (-> arg0 control highest-jump-mark) (-> arg0 control last-trans-leaving-surf))
                 )
               )
          (t9-76 a0-131 a1-56 a2-17 (sqrtf (+ (* (-> v1-193 x) (-> v1-193 x)) (* (-> v1-193 z) (-> v1-193 z)))))
          )
        (format
          arg1
          "~0kbend b:~F t:~F s:~F~%"
          (-> arg0 control bend-amount)
          (-> arg0 control bend-target)
          (-> arg0 control bend-speed)
          )
        (set! sv-64 0)
        (set! sv-72 0)
        (set! sv-80 *anim-manager*)
        (countdown (s3-8 (-> sv-80 free-index))
          (when (= (-> sv-80 slot s3-8 time-stamp) (-> *display* base-clock frame-counter))
            (set! sv-72 (+ sv-72 1))
            (set! sv-64 (+ sv-64 (used-bytes-for-slot sv-80 s3-8)))
            )
          )
        (format
          arg1
          "anim cache ~d anims ~dK total, ~d ~dK active~%"
          (-> sv-80 free-index)
          (sar (&- (-> sv-80 kheap current) (the-as uint (-> sv-80 kheap base))) 10)
          sv-72
          (sar sv-64 10)
          )
        (debug-print-channels (-> arg0 skel) arg1)
        )
      (draw-history (-> arg0 control))
      (set! pp s5-0)
      )
    #f
    )
  )

(defbehavior read-pad target ((arg0 vector))
  (when (!= (-> self control time-of-last-pad-read) (-> *display* real-clock frame-counter))
    (set! (-> self control last-pad-xz-dir quad) (-> self control pad-xz-dir quad))
    (set! (-> self control last-pad-magnitude) (-> self control pad-magnitude))
    (set! (-> self control time-of-last-pad-read) (-> *display* real-clock frame-counter))
    )
  (set! (-> arg0 x) (sin (-> self control cpad stick0-dir)))
  (set! (-> arg0 y) 0.0)
  (set! (-> arg0 z) (cos (-> self control cpad stick0-dir)))
  (set! (-> arg0 w) 0.0)
  (set! (-> self control pad-xz-dir quad) (-> arg0 quad))
  (set! (-> self control pad-magnitude) (-> self control cpad stick0-speed))
  (when (< (-> self control update-cam-R-w-start-time) (current-time))
    (let ((s5-0 (-> self control cam-R-w))
          (t9-2 matrix-local->world)
          (a0-13 #t)
          )
      (let* ((a2-0 (t9-2 a0-13))
             (v1-24 (-> a2-0 quad 0))
             (a0-14 (-> a2-0 quad 1))
             (a1-1 (-> a2-0 quad 2))
             (a2-1 (-> a2-0 trans quad))
             )
        (set! (-> s5-0 quad 0) v1-24)
        (set! (-> s5-0 quad 1) a0-14)
        (set! (-> s5-0 quad 2) a1-1)
        (set! (-> s5-0 trans quad) a2-1)
        )
      )
    )
  (vector-matrix*! arg0 arg0 (-> self control cam-R-w))
  )

(defbehavior set-pad target ((arg0 vector))
  (set! (-> self control pad-magnitude) (vector-length arg0))
  (vector-matrix*! (-> self control pad-xz-dir) arg0 (matrix-world->local #t #f))
  arg0
  )

(defun warp-vector-into-surface! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 matrix))
  (let ((a2-1 (matrix-from-two-vectors! (new-stack-matrix0) (-> arg3 vector 1) arg2)))
    (vector-matrix*! arg0 arg1 a2-1)
    )
  )

(defbehavior vector<-pad-in-surface! target ((arg0 vector) (arg1 symbol))
  (let ((a1-1 (read-pad (new-stack-vector0))))
    (warp-vector-into-surface! arg0 a1-1 (-> self control local-normal) (-> self control cam-R-w))
    )
  (if arg1
      (vector-float*! arg0 arg0 (-> self control pad-magnitude))
      )
  arg0
  )

;; WARN: Return type mismatch vector vs none.
(defun vector<-pad-in-matrix! ((arg0 vector) (arg1 cpad-info) (arg2 matrix))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (t9-0 matrix-local->world)
        (a0-1 #t)
        )
    (let ((s5-0 (t9-0 a0-1)))
      (set! (-> gp-0 x) (* -0.0078125 (+ -128.0 (the float (-> arg1 leftx)))))
      (set! (-> gp-0 y) 0.0)
      (set! (-> gp-0 z) (* -0.0078125 (+ -128.0 (the float (-> arg1 lefty)))))
      (set! (-> gp-0 w) 0.0)
      (let ((f30-0 (vector-length gp-0)))
        (vector-matrix*! gp-0 gp-0 s5-0)
        (warp-vector-into-surface! arg0 gp-0 (-> arg2 vector 1) s5-0)
        (vector-matrix*! arg0 arg0 arg2)
        (vector-normalize! arg0 f30-0)
        )
      )
    )
  (none)
  )

(defbehavior local-pad-angle target ()
  (let ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f)))
    (vector-dot
      (vector-normalize! a0-1 1.0)
      (vector-z-quaternion! (new-stack-vector0) (-> self control quat-for-control))
      )
    )
  )

(defbehavior turn-around? target ()
  (let* ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f))
         (gp-0 (vector-normalize! a0-1 1.0))
         (t9-2 vector-normalize!)
         (a0-2 (new-stack-vector0))
         )
    (set! (-> a0-2 quad) (-> self control transv quad))
    (let ((f0-1 (vector-dot gp-0 (t9-2 a0-2 1.0)))
          (a1-3 (-> self control transv-history))
          (f2-0 -1000.0)
          (f1-0 0.0)
          (a0-3 -1)
          (v1-7 (new 'static 'array time-frame 1 (seconds 0)))
          )
      (countdown (a2-0 15)
        (let ((a3-2 (-> a1-3 a2-0 quad)))
          (set! (-> a1-3 (+ a2-0 1) quad) a3-2)
          )
        )
      (set! (-> a1-3 0 quad) (-> self control transv quad))
      (set! (-> a1-3 0 w) (-> self control ctrl-xz-vel))
      (dotimes (a2-6 16)
        (+! f1-0 (-> a1-3 a2-6 w))
        (when (< f2-0 (-> a1-3 a2-6 w))
          (set! a0-3 a2-6)
          (set! f2-0 (-> a1-3 a2-6 w))
          )
        )
      (let ((f1-1 (* 0.0625 f1-0)))
        (set! (-> self control idx-of-fastest-xz-vel) a0-3)
        (set! (-> self control average-xz-vel) f1-1)
        (if (logtest? (-> self control current-surface flags) (surface-flag no-turn-around))
            (set! (-> v1-7 0) (current-time))
            )
        (and (>= (the-as uint (- (current-time) (-> v1-7 0))) (the-as uint 300))
             (< f0-1 0.0)
             (< 32768.0 f1-1)
             (< 0.7 (-> self control pad-magnitude))
             (>= (- (current-time) (-> self control last-time-touching-actor)) (seconds 0.3))
             (>= (- (current-time) (-> self control time-of-last-lc)) (seconds 0.3))
             (logtest? (-> self control status) (collide-status on-surface))
             (and (< 0.7 (-> self control surface-angle)) #t)
             )
        )
      )
    )
  )

(defbehavior wall-hide? target ()
  (when (and (< 0.7 (-> self control pad-magnitude))
             (< 0.7 (-> self control blocked-factor))
             (and (< (-> self control ctrl-xz-vel) 8192.0)
                  (logtest? (-> self control status) (collide-status touch-wall))
                  (not (logtest? (-> self control status) (collide-status touch-actor)))
                  (or (= (-> self control wall-contact-pat event) (pat-event hide))
                      (let ((a0-2 (level-get-target-inside *level*)))
                        (and a0-2 (logtest? (-> a0-2 info level-flags) 1))
                        )
                      )
                  )
             )
    (if (>= (- (current-time) (-> self control time-of-last-wall-hide-first-check-pass)) (seconds 0.1))
        (set! (-> self control time-of-first-wall-hide-first-check-pass) (current-time))
        )
    (set! (-> self control time-of-last-wall-hide-first-check-pass) (current-time))
    (when (>= (- (current-time) (-> self control time-of-first-wall-hide-first-check-pass)) (seconds 0.5))
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (let ((v1-34 (-> gp-0 bbox))
              (a0-13 (-> self control trans))
              (a1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-0 x) 8192.0)
          (set! (-> a1-0 y) 10240.0)
          (set! (-> a1-0 z) 8192.0)
          (set! (-> a1-0 w) 1.0)
          (vector-! (the-as vector v1-34) a0-13 a1-0)
          )
        (let ((v1-36 (-> gp-0 bbox max))
              (a0-15 (-> self control trans))
              (a1-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-1 x) 8192.0)
          (set! (-> a1-1 y) 10240.0)
          (set! (-> a1-1 z) 8192.0)
          (set! (-> a1-1 w) 1.0)
          (vector+! v1-36 a0-15 a1-1)
          )
        (set! (-> gp-0 collide-with) (-> self control root-prim prim-core collide-with))
        (set! (-> gp-0 ignore-process0) self)
        (set! (-> gp-0 ignore-process1) #f)
        (set! (-> gp-0 ignore-pat) (-> self control pat-ignore-mask))
        (fill-using-bounding-box *collide-cache* gp-0)
        (dotimes (s5-0 3)
          (set! (-> gp-0 start-pos quad) (-> self control collision-spheres s5-0 prim-core world-sphere quad))
          (vector-float*! (-> gp-0 move-dist) (-> self control wall-contact-normal) -8192.0)
          (let ((v1-48 gp-0))
            (set! (-> v1-48 radius) 4.096)
            (set! (-> v1-48 collide-with) (-> gp-0 collide-with))
            (set! (-> v1-48 ignore-process0) #f)
            (set! (-> v1-48 ignore-process1) #f)
            (set! (-> v1-48 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
            (set! (-> v1-48 action-mask) (collide-action solid))
            )
          (cond
            ((and (>= (probe-using-line-sphere *collide-cache* gp-0) 0.0)
                  (< 0.8 (vector-dot (-> gp-0 best-other-tri normal) (-> self control wall-contact-normal)))
                  )
             )
            (else
              (return #f)
              )
            )
          )
        )
      #t
      )
    )
  )

(defbehavior target-log-trans target ()
  (let ((v1-1 (-> self control trans-log-idx)))
    (set! (-> self control trans-log-times v1-1) (current-time))
    (set! (-> self control trans-log-trans v1-1 quad) (-> self control trans quad))
    (set! (-> self control trans-log-idx) (logand (+ v1-1 1) 127))
    )
  0
  (none)
  )

(defbehavior target-move-dist target ((arg0 time-frame))
  (let ((s5-0 (new-stack-vector0))
        (f30-0 0.0)
        (gp-0 0)
        )
    (let ((s4-0 (-> self control)))
      (let* ((v1-0 127)
             (a1-2 (logand (+ (-> s4-0 trans-log-idx) v1-0) 127))
             )
        (while (and (< (- (current-time) (-> s4-0 trans-log-times a1-2)) arg0) (> v1-0 0))
          (vector+! s5-0 s5-0 (-> s4-0 trans-log-trans a1-2))
          (+! gp-0 1)
          (+! v1-0 -1)
          (set! a1-2 (logand (+ a1-2 v1-0) 127))
          )
        )
      (vector-float/! s5-0 s5-0 (the float gp-0))
      (let ((s3-0 (- 128 gp-0)))
        (while (< s3-0 128)
          (let ((v1-5 (logand (+ (-> s4-0 trans-log-idx) s3-0) 127)))
            (+! f30-0 (vector-vector-distance s5-0 (-> s4-0 trans-log-trans v1-5)))
            )
          (+! s3-0 1)
          )
        )
      )
    (/ f30-0 (the float gp-0))
    )
  )

(defbehavior turn-to-vector target ((arg0 vector) (arg1 float))
  (let ((gp-0 (new-stack-vector0)))
    (warp-vector-into-surface! gp-0 arg0 (-> self control local-normal) (-> self control cam-R-w))
    (set! (-> self control last-turn-to-magnitude) (-> self control turn-to-magnitude))
    (set! (-> self control last-turn-to-angle) (-> self control turn-to-angle))
    (set! (-> self control last-to-target-pt-xz quad) (-> self control to-target-pt-xz quad))
    (set! (-> self control last-turn-to-target quad) (-> self control turn-to-target quad))
    (vector-float*! (-> self control turn-to-target) gp-0 arg1)
    (if (< 0.0 arg1)
        (warp-vector-into-surface! (-> self control to-target-pt-xz) arg0 *up-vector* (-> self control cam-R-w))
        )
    (dotimes (v1-17 7)
      (set! (-> self control turn-history-ctrl (+ v1-17 1) quad) (-> self control turn-history-ctrl v1-17 quad))
      )
    (set! (-> self control turn-history-ctrl 0 quad)
          (-> (vector-matrix*! gp-0 gp-0 (-> self control w-R-c)) quad)
          )
    (let ((f0-6 (atan (-> gp-0 x) (-> gp-0 z))))
      (set! (-> self control turn-to-magnitude) arg1)
      (set! (-> self control turn-to-angle) f0-6)
      )
    (let ((f0-8 (* arg1 (-> self control current-surface target-speed))))
      (set! (-> self control target-transv quad) (-> (vector-normalize! gp-0 f0-8) quad))
      )
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control target-transv) (-> self control c-R-w))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "target"
      (new 'static 'rgba :r #xff :g #xff :a #x80)
      )
    )
  )

(defbehavior target-bend-vel-turn target ((arg0 vector))
  (cond
    ((= (-> self control current-surface vel-turn) 0.0)
     )
    ((< (-> self control current-surface vel-turn) 0.0)
     (let* ((v1-5 arg0)
            (f0-6 (sqrtf (+ (* (-> v1-5 x) (-> v1-5 x)) (* (-> v1-5 z) (-> v1-5 z)))))
            )
       (set-vector! arg0 0.0 (-> arg0 y) f0-6 1.0)
       )
     )
    (else
      (let ((f0-10 (atan (-> arg0 x) (-> arg0 z))))
        (vector-rotate-y!
          arg0
          arg0
          (fmin
            (* 0.03 (-> self clock time-adjust-ratio) (- f0-10))
            (* (-> self control current-surface vel-turn) (-> self clock seconds-per-frame))
            )
          )
        )
      )
    )
  arg0
  )

(defbehavior target-add-slide-factor target ((arg0 vector))
  (let* ((a1-2 (vector-flatten!
                 (new 'stack-no-clear 'vector)
                 (vector-negate! (new-stack-vector0) (-> self control dynam gravity-normal))
                 (-> self control local-normal)
                 )
               )
         (s4-1 (vector-matrix*! (new 'stack-no-clear 'vector) a1-2 (-> self control w-R-c)))
         (s5-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-1 1.0))
         )
    (vector+float*! arg0 arg0 s4-1 (-> self control current-surface slide-factor))
    (let ((a1-5 (-> self control low-coverage-tangent)))
      (when (not (or (= (- 1.0 (-> self control current-surface slope-up-traction)) 0.0) (< (vector-length s4-1) 0.1)))
        (let* ((a0-7 (vector-matrix*! (new 'stack-no-clear 'vector) a1-5 (-> self control w-R-c)))
               (v1-15 (new-stack-vector0))
               (f0-5 (vector-dot a0-7 arg0))
               )
          0.0
          (vector-! v1-15 arg0 (vector-float*! v1-15 a0-7 f0-5))
          (let* ((f1-5 (vector-length v1-15))
                 (f2-0 f1-5)
                 )
            (if (< f0-5 0.0)
                (set! f0-5 (* f0-5 (-> self control current-surface slope-up-traction)))
                )
            (let ((f0-6 (+ f0-5 (-> self control current-surface slope-down-factor))))
              (vector+! arg0 (vector-float*! arg0 a0-7 f0-6) (vector-float*! v1-15 v1-15 (/ f1-5 f2-0)))
              )
            )
          )
        )
      )
    (let ((t9-5 vector-xz-normalize!)
          (a0-10 (new-stack-vector0))
          )
      (set! (-> a0-10 quad) (-> arg0 quad))
      (let ((v1-18 (t9-5 a0-10 1.0)))
        (set! (-> v1-18 y) 0.0)
        (let* ((f0-10 (vector-dot s5-1 v1-18))
               (v1-20 arg0)
               (f1-10 (sqrtf (+ (* (-> v1-20 x) (-> v1-20 x)) (* (-> v1-20 z) (-> v1-20 z)))))
               )
          (if (>= f0-10 0.0)
              (vector-xz-normalize! arg0 (fmax 0.0 (+ f1-10 (* f0-10 (-> self control current-surface slope-down-factor)))))
              (vector-xz-normalize!
                arg0
                (fmax 0.0 (- f1-10 (* (- f0-10) (-> self control current-surface slope-up-factor))))
                )
              )
          )
        )
      )
    )
  arg0
  )

(defbehavior add-thrust target ()
  (let ((s5-0 (-> self control target-transv))
        (gp-0 (-> self control transv-ctrl))
        )
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> self control target-transv quad))
      (target-bend-vel-turn gp-0)
      (target-add-slide-factor s5-0)
      (let ((t9-2 vector-xz-normalize!)
            (a0-2 (new-stack-vector0))
            )
        (set! (-> a0-2 quad) (-> s5-0 quad))
        (let ((s3-0 (t9-2 a0-2 1.0)))
          (let ((t9-3 vector-xz-normalize!)
                (a0-3 (new-stack-vector0))
                )
            (set! (-> a0-3 quad) (-> gp-0 quad))
            (let ((v1-9 (t9-3 a0-3 1.0)))
              (set! (-> s3-0 y) 0.0)
              (set! (-> v1-9 y) 0.0)
              )
            )
          (let* ((f0-2 (-> s3-0 z))
                 (v1-10 gp-0)
                 (f1-4 (sqrtf (+ (* (-> v1-10 x) (-> v1-10 x)) (* (-> v1-10 z) (-> v1-10 z)))))
                 (v1-12 s5-0)
                 (f30-0
                   (cond
                     ((>= f1-4 (sqrtf (+ (* (-> v1-12 x) (-> v1-12 x)) (* (-> v1-12 z) (-> v1-12 z)))))
                      (let ((f0-3 (-> self control current-surface fric))
                            (f1-5 1.0)
                            (v1-17 gp-0)
                            )
                        (* f0-3 (fmax f1-5 (/ (sqrtf (+ (* (-> v1-17 x) (-> v1-17 x)) (* (-> v1-17 z) (-> v1-17 z))))
                                              (-> self control current-surface nonlin-fric-dist)
                                              )
                                      )
                           )
                        )
                      )
                     ((>= f0-2 0.0)
                      (+ (* f0-2 (-> self control current-surface seek0)) (* (- 1.0 f0-2) (-> self control current-surface seek90)))
                      )
                     (else
                       (+ (* (fabs f0-2) (-> self control current-surface seek180))
                          (* (+ 1.0 f0-2) (-> self control current-surface seek90))
                          )
                       )
                     )
                   )
                 )
            (let* ((s2-0 (-> self control btransv))
                   (s3-1 (vector-matrix*! (new 'stack-no-clear 'vector) s2-0 (-> self control w-R-c)))
                   )
              (if (< (-> s4-0 x) 0.0)
                  (set! (-> s3-1 x) (fmax (fmin 0.0 (-> s3-1 x)) (-> s4-0 x)))
                  (set! (-> s3-1 x) (fmax 0.0 (fmin (-> s3-1 x) (-> s4-0 x))))
                  )
              (if (< (-> s4-0 y) 0.0)
                  (set! (-> s3-1 y) (fmax (fmin 0.0 (-> s3-1 y)) (-> s4-0 y)))
                  (set! (-> s3-1 y) (fmax 0.0 (fmin (-> s3-1 y) (-> s4-0 y))))
                  )
              (if (< (-> s4-0 z) 0.0)
                  (set! (-> s3-1 z) (fmax (fmin 0.0 (-> s3-1 z)) (-> s4-0 z)))
                  (set! (-> s3-1 z) (fmax 0.0 (fmin (-> s3-1 z) (-> s4-0 z))))
                  )
              (if (< 0.2 (-> self control blocked-factor))
                  (vector-seek! s3-1 s4-0 (* 122880.0 (-> self clock seconds-per-frame)))
                  )
              (vector-matrix*! s2-0 s3-1 (-> self control c-R-w))
              (let ((f28-0 (vector-vector-xz-distance s3-1 s4-0)))
                (when (and (not (logtest? (-> self control status) (collide-status touch-surface)))
                           (let ((v1-51 gp-0))
                             (< (sqrtf (+ (* (-> v1-51 x) (-> v1-51 x)) (* (-> v1-51 z) (-> v1-51 z))))
                                (sqrtf (+ (* (-> s3-1 x) (-> s3-1 x)) (* (-> s3-1 z) (-> s3-1 z))))
                                )
                             )
                           )
                  (let ((f0-37 (lerp-scale 163840.0 0.0 f28-0 0.0 20480.0)))
                    (if (and (< f28-0 20480.0) (< (-> s4-0 z) 0.0))
                        (set! f0-37 (* 2.0 f0-37))
                        )
                    (+! f30-0 f0-37)
                    )
                  )
                )
              )
            (if (and (not (logtest? (-> self control status) (collide-status touch-wall)))
                     (logtest? (-> self control old-status) (collide-status touch-wall))
                     (logtest? (-> self control mod-surface flags) (surface-flag air))
                     (< 0.0 (-> gp-0 y))
                     (< 0.0 (vector-dot
                              (-> self control dynam gravity-normal)
                              (vector-!
                                (new 'stack-no-clear 'vector)
                                (the-as vector (-> self control collision-spheres 1 prim-core))
                                (-> self control wall-contact-pt)
                                )
                              )
                        )
                     )
                (set! (-> self control time-of-last-clear-wall-in-jump) (current-time))
                )
            (if (< (- (current-time) (-> self control time-of-last-clear-wall-in-jump)) (seconds 0.2))
                (set! f30-0 (+ 204800.0 f30-0))
                )
            (if (and (not (logtest? (-> self control status) (collide-status touch-wall)))
                     (and (logtest? (-> self control old-status) (collide-status touch-wall))
                          (logtest? (-> self control mod-surface flags) (surface-flag air))
                          (< 0.0 (-> gp-0 y))
                          (< (-> gp-0 z) 0.0)
                          )
                     )
                (set! (-> gp-0 z) 0.0)
                )
            (let ((s4-2 (vector-! (new-stack-vector0) s5-0 gp-0)))
              (let ((f0-45 (* f30-0 (-> self clock seconds-per-frame))))
                (set! (-> s4-2 y) 0.0)
                (let ((v1-104 s4-2))
                  (if (< f0-45 (sqrtf (+ (* (-> v1-104 x) (-> v1-104 x)) (* (-> v1-104 z) (-> v1-104 z)))))
                      (vector-xz-normalize! s4-2 f0-45)
                      )
                  )
                )
              (vector+! gp-0 gp-0 s4-2)
              )
            )
          )
        )
      )
    (set! (-> self control velocity-after-thrust) (vector-length gp-0))
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control transv-ctrl) (-> self control c-R-w))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "ltransv"
      (new 'static 'rgba :g #xff :a #x80)
      )
    (set! (-> gp-1 quad) (-> self control btransv quad))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "btransv"
      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
      )
    )
  )

(defbehavior add-gravity target ()
  (let ((s5-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (compute-acc-due-to-gravity (-> self control) s5-0 (-> self control current-surface slip-factor))
    (vector-matrix*! gp-0 s5-0 (-> self control w-R-c))
    (vector-v++! (-> self control transv-ctrl) gp-0)
    )
  (let* ((a0-4
           (vector-matrix*! (new 'stack-no-clear 'vector) (-> self control dynam gravity-normal) (-> self control w-R-c))
           )
         (v1-9 (new-stack-vector0))
         (f0-2 (vector-dot a0-4 (-> self control transv-ctrl)))
         )
    0.0
    (vector-! v1-9 (-> self control transv-ctrl) (vector-float*! v1-9 a0-4 f0-2))
    (let* ((f1-2 (vector-length v1-9))
           (f2-0 f1-2)
           )
      (if (< f1-2 0.00004096)
          (set! f1-2 0.0)
          )
      (if (< f0-2 (- (-> self control dynam gravity-max)))
          (set! f0-2 (- (-> self control dynam gravity-max)))
          )
      (vector+!
        (-> self control transv-ctrl)
        (vector-float*! (-> self control transv-ctrl) a0-4 f0-2)
        (vector-float*! v1-9 v1-9 (/ f1-2 f2-0))
        )
      )
    )
  )

(defbehavior target-compute-slopes target ((arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (s4-0 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control)))
        (s3-0 (new 'stack-no-clear 'matrix))
        (s5-0 (vector-flatten!
                (new 'stack-no-clear 'vector)
                (-> self control dynam gravity-normal)
                (-> self control local-normal)
                )
              )
        )
    (forward-up-nopitch->inv-matrix s3-0 (-> self control c-R-w vector 2) arg0)
    (set-vector! gp-0 0.0 0.0 1.0 1.0)
    (vector-matrix*! gp-0 gp-0 s3-0)
    (set! (-> self control surface-slope-z) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control local-slope-z) (- (vector-dot (-> self control local-normal) gp-0)))
    (set! (-> self control gspot-slope-z) (- (vector-dot (-> self control gspot-normal) gp-0)))
    (set! (-> self control ctrl-slope-z) (- (vector-dot s4-0 gp-0)))
    (set-vector! gp-0 1.0 0.0 0.0 1.0)
    (vector-matrix*! gp-0 gp-0 s3-0)
    (set! (-> self control surface-slope-x) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control local-slope-x) (- (vector-dot (-> self control local-normal) gp-0)))
    (set! (-> self control gspot-slope-x) (- (vector-dot (-> self control gspot-normal) gp-0)))
    (set! (-> self control ctrl-slope-x) (- (vector-dot s4-0 gp-0)))
    (set-vector! gp-0 1.0 0.0 0.0 1.0)
    (vector-matrix*! gp-0 gp-0 (-> self control c-R-w))
    (set! (-> self control ctrl-slope-heading) (vector-dot gp-0 s5-0))
    )
  0
  )

(defbehavior do-rotations1 target ()
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    0.0
    (-> self control current-surface tiltv)
    150
    (the int (-> self control current-surface tiltvf))
    0.0
    )
  )

(defbehavior do-rotations2 target ()
  (let ((gp-0 (vector-z-quaternion! (new-stack-vector0) (-> self control dir-targ)))
        (s5-0
          (cond
            ((logtest? (surface-flag turn-to-alt) (-> self control current-surface flags))
             (-> self control turn-to-alt-heading)
             )
            ((and (or (not (logtest? (logior (-> self control status) (-> self control old-status))
                                     (collide-status on-surface touch-surface)
                                     )
                           )
                      (< (- (current-time) (-> self control last-time-touching-actor)) (seconds 0.5))
                      (not (and (-> self next-state) (let ((v1-15 (-> self next-state name)))
                                                       (or (= v1-15 'target-walk) (= v1-15 'target-gun-walk))
                                                       )
                                )
                           )
                      (< (- (current-time) (-> self state-time)) (seconds 0.5))
                      (< (- (current-time) (-> self control time-of-last-lc)) (seconds 0.5))
                      (logtest? (-> self control current-surface flags) (surface-flag turn-to-pad))
                      (!= (-> self control force-turn-to-strength) 0.0)
                      )
                  (not (logtest? (-> self control current-surface flags) (surface-flag turn-to-vel)))
                  )
             (-> self control to-target-pt-xz)
             )
            (else
              (-> self control transv)
              )
            )
          )
        )
    (let* ((s3-0 (-> self control bent-gravity-normal))
           (s4-0 (forward-up-nopitch->quaternion (new-stack-quaternion0) gp-0 s3-0))
           (s3-1 (forward-up-nopitch->quaternion (new-stack-quaternion0) s5-0 s3-0))
           (f0-2 (acos (vector-dot gp-0 s5-0)))
           (f1-2 (* (-> self control current-surface turnvv) (-> self clock seconds-per-frame)))
           )
      (quaternion-slerp!
        (-> self control dir-targ)
        s4-0
        s3-1
        (cond
          ((and (or (>= 0.0 (-> self control turn-to-magnitude)) (< (current-time) (-> self control turn-lockout-end-time)))
                (not (logtest? (-> self control current-surface flags) (surface-flag turn-when-centered)))
                )
           0.0
           )
          ((< f0-2 f1-2)
           1.0
           )
          (else
            (/ f1-2 f0-2)
            )
          )
        )
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      (-> self control trans)
      gp-0
      (meters 2)
      (new 'static 'rgba :r #xff :g #xff :a #x80)
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      (-> self control trans)
      s5-0
      (meters 2)
      (new 'static 'rgba :r #xff :g #x80 :a #x80)
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control c-R-w vector 2)
    (meters 2)
    (new 'static 'rgba :r #xff :b #xff :a #x80)
    )
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    (-> self control current-surface turnv)
    0.0
    (the int (-> self control current-surface turnvf))
    150
    (-> self control turn-go-the-long-way)
    )
  (if (and (!= (-> self control turn-go-the-long-way) 0.0)
           (< (fabs
                (deg-diff
                  (quaternion-y-angle (-> self control quat-for-control))
                  (quaternion-y-angle (-> self control dir-targ))
                  )
                )
              182.04445
              )
           )
      (set! (-> self control turn-go-the-long-way) 0.0)
      )
  (quaternion-slerp!
    (-> self control quat)
    (-> self control quat-for-control)
    (-> self control override-quat)
    (-> self control override-quat-alpha)
    )
  (target-compute-slopes (-> self control dynam gravity-normal))
  )

(defun leg-ik-callback ((arg0 joint-mod-ik) (arg1 object) (arg2 object) (arg3 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg3 quad))
      (let ((f0-1 (- (-> arg3 y) (-> (target-pos 0) y))))
        (if (< 1228.8 f0-1)
            (set! f0-1 1228.8)
            )
        (if (< f0-1 409.6)
            (set! f0-1 409.6)
            )
        (+! (-> arg0 user-position y) f0-1)
        )
      (let* ((f0-4
               (vector-dot (-> arg0 user-normal) (vector-! (new 'stack-no-clear 'vector) arg3 (-> arg0 user-position)))
               )
             (f30-1 (lerp-scale 1.0 0.0 f0-4 0.0 2048.0))
             (s3-0 (new 'stack-no-clear 'vector))
             )
        (let ((v1-13 s5-0))
          (let ((a0-4 (-> arg0 user-normal)))
            (let ((a1-4 4096.0))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.lvf vf4 (&-> v1-13 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s3-0 quad) vf6)
        (vector-float*! (new 'stack-no-clear 'vector) (-> arg0 user-normal) -8192.0)
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          0.0
          (let ((f0-8 (intersect-ray-plane s3-0 (-> arg0 user-normal) (-> arg0 user-position) (-> arg0 user-normal)))
                (a0-7 s4-1)
                )
            (let ((v1-16 (-> arg0 user-normal)))
              (let ((a1-7 f0-8))
                (.mov vf7 a1-7)
                )
              (.lvf vf5 (&-> v1-16 quad))
              )
            (.lvf vf4 (&-> s3-0 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-7 quad) vf6)
            )
          (let ((a1-8 s4-1))
            (let ((v1-17 s4-1))
              (let ((a0-8 (-> arg0 user-normal)))
                (let ((a2-6
                        (- (vector-dot (-> arg0 user-normal) (vector-! (new 'stack-no-clear 'vector) s4-1 (-> arg0 user-position))))
                        )
                      )
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-8 quad))
                )
              (.lvf vf4 (&-> v1-17 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-8 quad) vf6)
            )
          (let ((a1-9 s5-0))
            (let ((v1-18 s5-0))
              (let ((a0-10 (vector-! (new 'stack-no-clear 'vector) s4-1 s5-0)))
                (let ((a2-9 (fmin 1.0 (* (-> arg0 user-blend) f30-1))))
                  (.mov vf7 a2-9)
                  )
                (.lvf vf5 (&-> a0-10 quad))
                )
              (.lvf vf4 (&-> v1-18 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-9 quad) vf6)
            )
          )
        )
      (handle-copy! arg0 s5-0)
      )
    (none)
    )
  )

(defbehavior target-update-ik target ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-query)))
      (let ((v1-0 (-> gp-0 bbox))
            (a0-1 (-> self control trans))
            (a1-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-0 x) 8192.0)
        (set! (-> a1-0 y) 6144.0)
        (set! (-> a1-0 z) 8192.0)
        (set! (-> a1-0 w) 1.0)
        (vector-! (the-as vector v1-0) a0-1 a1-0)
        )
      (let ((v1-2 (-> gp-0 bbox max))
            (a0-3 (-> self control trans))
            (a1-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-1 x) 8192.0)
        (set! (-> a1-1 y) 6144.0)
        (set! (-> a1-1 z) 8192.0)
        (set! (-> a1-1 w) 1.0)
        (vector+! v1-2 a0-3 a1-1)
        )
      (set! (-> gp-0 collide-with) (-> self control root-prim prim-core collide-with))
      (set! (-> gp-0 ignore-process0) self)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat) (-> self control pat-ignore-mask))
      (fill-using-bounding-box *collide-cache* gp-0)
      (dotimes (s5-0 2)
        (let ((a1-4 (not (or (logtest? (state-flags lleg-no-ik rleg-no-ik) (-> self state-flags))
                             (and (logtest? (-> self control mod-surface flags) (surface-flag air))
                                  (not (logtest? (-> self control status) (collide-status on-surface)))
                                  )
                             (focus-test? self edge-grab pole flut pilot mech)
                             )
                         )
                    )
              )
          (enable-set! (-> self leg-ik s5-0) a1-4)
          )
        (set! (-> self foot s5-0 twist-max quad) (-> self control ground-contact-normal quad))
        (set! (-> self foot s5-0 trans quad) (-> self control gspot-pos quad))
        (vector-y-quaternion! (-> self foot s5-0 target) (-> self control quat-for-control))
        (set! (-> self foot s5-0 flex-blend) (if (if (zero? s5-0)
                                                     (logtest? (state-flags lleg-no-ik) (-> self state-flags))
                                                     (logtest? (state-flags rleg-no-ik) (-> self state-flags))
                                                     )
                                                 0.0
                                                 1.0
                                                 )
              )
        (-> self leg-ik s5-0 shoulder-matrix-no-ik)
        (let ((v1-51 (-> self leg-ik s5-0 elbow-matrix-no-ik))
              (s2-0 (new 'stack-no-clear 'vector))
              (s1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s1-0 quad) (-> *y-vector* quad))
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (new 'stack-no-clear 'vector)
            (new 'stack-no-clear 'vector)
            (let ((s4-0 (new 'stack-no-clear 'vector)))
              (let ((a2-8 s2-0))
                (let ((a0-27 (-> v1-51 trans)))
                  (let ((a1-8 (-> v1-51 vector 1)))
                    (let ((a3-3 (-> self leg-ik s5-0 hand-dist)))
                      (.mov vf7 a3-3)
                      )
                    (.lvf vf5 (&-> a1-8 quad))
                    )
                  (.lvf vf4 (&-> a0-27 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a2-8 quad) vf6)
                )
              (let ((a1-9 s2-0))
                (let ((a0-28 (-> v1-51 trans)))
                  (let ((v1-52 (-> v1-51 vector 1)))
                    (let ((a2-12 (-> self leg-ik s5-0 hand-dist)))
                      (.mov vf7 a2-12)
                      )
                    (.lvf vf5 (&-> v1-52 quad))
                    )
                  (.lvf vf4 (&-> a0-28 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-9 quad) vf6)
                )
              (let ((f0-13 (lerp-scale 1.0 0.0 (- (-> s2-0 y) (-> self control gspot-pos y)) 819.2 2048.0)))
                (seek! (-> self leg-ik s5-0 user-blend) f0-13 (* 4.0 (-> self clock seconds-per-frame)))
                )
              (let ((a1-12 (-> gp-0 start-pos)))
                (let ((v1-63 s2-0))
                  (let ((a0-31 s1-0))
                    (let ((a2-16 4096.0))
                      (.mov vf7 a2-16)
                      )
                    (.lvf vf5 (&-> a0-31 quad))
                    )
                  (.lvf vf4 (&-> v1-63 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-12 quad) vf6)
                )
              (vector-float*! (-> gp-0 move-dist) s1-0 -8192.0)
              (let ((v1-66 gp-0))
                (set! (-> v1-66 radius) 4.096)
                (set! (-> v1-66 collide-with) (-> gp-0 collide-with))
                (set! (-> v1-66 ignore-process0) #f)
                (set! (-> v1-66 ignore-process1) #f)
                (set! (-> v1-66 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                (set! (-> v1-66 action-mask) (collide-action solid))
                )
              (let ((f30-0 (probe-using-line-sphere *collide-cache* gp-0)))
                (cond
                  ((and (>= f30-0 0.0) (< 0.5 (-> gp-0 best-other-tri normal y)))
                   (set! (-> s4-0 quad) (-> gp-0 best-other-tri normal quad))
                   (when (< 8192.0 (vector-vector-angle-safe *y-vector* s4-0))
                     (let* ((a1-17 (vector-normalize! (vector-cross! (new 'stack-no-clear 'vector) *y-vector* s4-0) 1.0))
                            (a2-18 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) a1-17 8192.0))
                            )
                       (vector-orient-by-quat! s4-0 *y-vector* a2-18)
                       )
                     )
                   (let ((a1-19 s3-0))
                     (let ((v1-77 (-> gp-0 start-pos)))
                       (let ((a0-45 (-> gp-0 move-dist)))
                         (let ((a2-19 f30-0))
                           (.mov vf7 a2-19)
                           )
                         (.lvf vf5 (&-> a0-45 quad))
                         )
                       (.lvf vf4 (&-> v1-77 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> a1-19 quad) vf6)
                     )
                   (set! (-> self leg-ik s5-0 user-position quad) (-> s3-0 quad))
                   (set! (-> self leg-ik s5-0 user-normal quad) (-> s4-0 quad))
                   (set! (-> self foot s5-0 twist-max quad) (-> s4-0 quad))
                   )
                  (else
                    (set! (-> self leg-ik s5-0 user-position quad) (-> s2-0 quad))
                    (set! (-> self leg-ik s5-0 user-normal quad) (-> *y-vector* quad))
                    (set! (-> self foot s5-0 twist-max quad) (-> *y-vector* quad))
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defbehavior pre-collide-setup target ()
  (if (>= (current-time) (-> self control additional-decaying-velocity-decay-start-time))
      (vector-normalize!
        (-> self control additional-decaying-velocity)
        (seek
          (vector-length (-> self control additional-decaying-velocity))
          0.0
          (* 40960.0 (-> self clock seconds-per-frame))
          )
        )
      )
  (cond
    ((logtest? (-> self control old-status) (collide-status on-surface))
     (if (>= (+ (current-time) (seconds -0.035)) (-> self control additional-decaying-velocity-end-time))
         (vector-reset! (-> self control additional-decaying-velocity))
         )
     )
    (else
      (let ((f30-0 (vector-length (-> self control additional-decaying-velocity))))
        (let* ((v1-22
                 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control additional-decaying-velocity) 1.0)
                 )
               (f0-3 (vector-dot (-> self control transv) v1-22))
               )
          (if (< f0-3 0.0)
              (set! f30-0 (seek f30-0 0.0 (* -1.0 (-> self clock seconds-per-frame) f0-3)))
              )
          )
        (let ((f0-7 (seek f30-0 0.0 (* 28672.0 (-> self clock seconds-per-frame)))))
          (vector-normalize! (-> self control additional-decaying-velocity) f0-7)
          )
        )
      )
    )
  (set! (-> self control collide-extra-velocity quad) (-> self control additional-decaying-velocity quad))
  (set! (-> self control pre-collide-local-normal quad) (-> self control local-normal quad))
  0
  (none)
  )

(defbehavior level-setup target ()
  (let ((gp-0 (-> self current-level)))
    (set! (-> self current-level) (level-get-target-inside *level*))
    (if (-> self current-level)
        (+! (-> self game task-in-times (-> self current-level info task-level))
            (- (current-time) (-> self clock old-frame-counter))
            )
        )
    (if (and (-> self current-level) (or (not gp-0) (!= (-> gp-0 name) (-> self current-level name))))
        (send-event self 'level-enter (-> self current-level name))
        )
    )
  0
  (none)
  )

(defbehavior flag-setup target ()
  (cond
    ((= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
     (if (zero? (-> self control time-between-zero-inputs))
         (set! (-> self control time-between-zero-inputs) (- (current-time) (-> self control time-of-last-zero-input)))
         )
     (set! (-> self control time-of-last-zero-input) (current-time))
     (quaternion-copy! (-> self control last-nonzero-input-dir-targ) (-> self control dir-targ))
     )
    (else
      (set! (-> self control time-of-last-nonzero-input) (current-time))
      (set! (-> self control time-between-zero-inputs) 0)
      0
      )
    )
  (level-setup)
  (set! (-> self control last-transv quad) (-> self control transv quad))
  (quaternion-copy! (-> self control last-quat-for-control) (-> self control quat-for-control))
  ((-> self control current-surface active-hook))
  (cond
    ((logtest? (-> self control status) (collide-status on-surface))
     (set! (-> self control last-time-on-surface) (current-time))
     (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
     (if (and (>= (-> self control coverage) 1.0)
              (not (logtest? (-> self control status) (collide-status touch-actor on-water)))
              (logtest? (-> self control status) (collide-status on-ground))
              )
         (set! (-> self control last-trans-on-ground quad) (-> self control trans quad))
         )
     ((-> self control current-surface touch-hook))
     )
    (else
      (let ((v1-49 (-> self control trans)))
        (when (logtest? (-> self control old-status) (collide-status on-surface))
          (set! (-> self control last-trans-leaving-surf quad) (-> self control last-trans-any-surf quad))
          (set! (-> self control highest-jump-mark quad) (-> self control last-trans-any-surf quad))
          )
        (set! (-> self control highest-jump-mark x) (-> v1-49 x))
        (set! (-> self control highest-jump-mark z) (-> v1-49 z))
        (if (< (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control highest-jump-mark) v1-49)
                 )
               0.0
               )
            (set! (-> self control highest-jump-mark y) (-> v1-49 y))
            )
        )
      )
    )
  (when (and (cpad-pressed? (-> self control cpad number) r3)
             (zero? (-> self control remaining-ctrl-iterations))
             (not (logtest? (-> *kernel-context* prevent-from-run) (process-mask movie)))
             (not *pause-lock*)
             )
    (if (and (= (-> self cam-user-mode) 'normal)
             (logtest? (-> self control mod-surface flags) (surface-flag look-around))
             (not (focus-test? self edge-grab pole flut tube board pilot dark))
             (-> *setting-control* user-current allow-look-around)
             (>= (- (current-time) (the-as int (-> self no-look-around-wait))) (seconds 0.05))
             (not (and (= (-> self control ground-pat material) (pat-material ice)) (< 4096.0 (-> self control ctrl-xz-vel)))
                  )
             )
        (send-event self 'change-mode 'look-around)
        )
    )
  (if (!= (not (logtest? (-> self game features) (game-feature sidekick))) (not (-> self sidekick)))
      (target-sidekick-setup (logtest? (-> self game features) (game-feature sidekick)))
      )
  (if (and (!= (not (logtest? (-> self game features) (game-feature board))) (not (-> self board board)))
           (not (logtest? (focus-status board) (-> self focus-status)))
           )
      (target-board-setup (logtest? (-> self game features) (game-feature board)))
      )
  (if (want-to-board?)
      (send-event self 'change-mode 'board #f)
      )
  (when (!= (not (-> *setting-control* user-current mirror)) (not (-> self mirror)))
    (cond
      ((-> self mirror)
       (deactivate (-> self mirror 0))
       (set! (-> self mirror) (the-as (pointer process-drawable) #f))
       )
      (else
        (let ((gp-1 (process-spawn
                      manipy
                      :init manipy-init
                      (-> self control trans)
                      (-> self entity)
                      (art-group-get-by-name *level* "skel-jchar" (the-as (pointer uint32) #f))
                      #f
                      0
                      :to self
                      )
                    )
              )
          (send-event (ppointer->process gp-1) 'anim-mode 'mirror)
          (send-event (ppointer->process gp-1) 'mirror #t)
          (set! (-> self mirror) (the-as (pointer process-drawable) gp-1))
          )
        )
      )
    )
  (when (and (= *cheat-mode* 'debug)
             (cpad-hold? (-> self control cpad number) r2)
             (cpad-hold? (-> self control cpad number) l2)
             (not *pause-lock*)
             (not (focus-test? self grabbed in-head pilot))
             (not (and (-> self next-state) (let ((v1-167 (-> self next-state name)))
                                              (or (= v1-167 'target-darkjak-get-on) (= v1-167 'target-float))
                                              )
                       )
                  )
             )
    (send-event *camera* 'reset-follow)
    (set! (-> self control time-of-last-debug-float) (current-time))
    (cond
      ((focus-test? self mech indax)
       (if (not (and (-> self next-state) (let ((v1-179 (-> self next-state name)))
                                            (or (= v1-179 'target-falling)
                                                (= v1-179 'target-board-falling)
                                                (= v1-179 'target-gun-falling)
                                                (= v1-179 'target-mech-falling)
                                                (= v1-179 'target-mech-carry-falling)
                                                (= v1-179 'target-carry-falling)
                                                (= v1-179 'target-indax-falling)
                                                )
                                            )
                     )
                )
           (send-event self 'change-mode 'falling)
           )
       (set! (-> self control additional-decaying-velocity-end-time) 0)
       (vector-reset! (-> self control additional-decaying-velocity))
       (let ((v1-189 (new-stack-vector0)))
         (let ((f0-9 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
           0.0
           (vector-! v1-189 (-> self control transv) (vector-float*! v1-189 (-> self control dynam gravity-normal) f0-9))
           )
         (let* ((f0-10 (vector-length v1-189))
                (f1-5 f0-10)
                (f2-0 0.0)
                )
           (vector+!
             (-> self control transv)
             (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
             (vector-float*! v1-189 v1-189 (/ f0-10 f1-5))
             )
           )
         )
       (let ((a1-36 (new 'stack-no-clear 'vector)))
         (set! (-> a1-36 quad) (-> self control trans quad))
         (let ((v1-193 (new-stack-vector0))
               (f0-13 (vector-dot (-> self control dynam gravity-normal) a1-36))
               )
           0.0
           (vector-! v1-193 a1-36 (vector-float*! v1-193 (-> self control dynam gravity-normal) f0-13))
           (let* ((f1-8 (vector-length v1-193))
                  (f2-1 f1-8)
                  (f0-14 (+ 512.0 f0-13))
                  )
             (vector+!
               a1-36
               (vector-float*! a1-36 (-> self control dynam gravity-normal) f0-14)
               (vector-float*! v1-193 v1-193 (/ f1-8 f2-1))
               )
             )
           )
         (move-to-point! (-> self control) a1-36)
         )
       (set! (-> self control surf) *standard-ground-surface*)
       )
      (else
        (go target-float)
        )
      )
    )
  (let ((f0-17 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
    (if (and (or (logtest? (-> self control current-surface flags) (surface-flag check-edge))
                 (and (and (-> self next-state) (let ((v1-211 (-> self next-state name)))
                                                  (or (= v1-211 'target-walk) (= v1-211 'target-gun-walk))
                                                  )
                           )
                      (not (logtest? (-> self control status) (collide-status on-surface)))
                      )
                 )
             (and (< f0-17 0.0)
                  (and (or (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2))) *pause-lock*)
                       (not (focus-test? self flut pilot mech indax))
                       (not (logtest? (-> self state-flags) (state-flags prevent-jump)))
                       #t
                       )
                  )
             )
        (logior! (-> self control root-prim prim-core action) (collide-action check-edge))
        (logclear! (-> self control root-prim prim-core action) (collide-action check-edge))
        )
    )
  (let ((v1-229 (-> self current-level)))
    (when (and (or (>= (- (current-time) (-> self control last-time-on-surface)) (seconds 2)) (focus-test? self pilot))
               (and v1-229
                    (< (-> self control trans y) (-> v1-229 info buttom-height))
                    (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
                    )
               )
      (let ((a1-45 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-45 from) (process->ppointer self))
        (set! (-> a1-45 num-params) 2)
        (set! (-> a1-45 message) 'attack-invinc)
        (set! (-> a1-45 param 0) (the-as uint #f))
        (let ((v1-240 (new 'static 'attack-info :mask (attack-info-mask mode id))))
          (let* ((a0-162 *game-info*)
                 (a2-22 (+ (-> a0-162 attack-id) 1))
                 )
            (set! (-> a0-162 attack-id) a2-22)
            (set! (-> v1-240 id) a2-22)
            )
          (set! (-> v1-240 mode) 'endlessfall)
          (set! (-> a1-45 param 1) (the-as uint v1-240))
          )
        (send-event-function self a1-45)
        )
      )
    )
  (set! (-> self control bend-speed) (if (logtest? (-> self control status) (collide-status on-surface))
                                         32.0
                                         2.0
                                         )
        )
  (let ((v1-248 (-> *setting-control* user-current beard)))
    (when (!= (-> self beard?) v1-248)
      (cond
        (v1-248
          (setup-masks (-> self draw) 2 0)
          (set! (-> self beard?) #t)
          )
        (else
          (setup-masks (-> self draw) 0 2)
          (set! (-> self beard?) #f)
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior post-flag-setup target ()
  (if (logtest? (-> self control status) (collide-status touch-wall touch-actor))
      (set! (-> self control last-time-touching-actor) (current-time))
      )
  (when (logtest? (-> self state-flags) (state-flags tinvul1))
    (if (< (logand (- (current-time) (-> self control invul1-on-time)) 3) 1)
        (logior! (-> self draw status) (draw-control-status no-draw-bounds))
        (logclear! (-> self draw status) (draw-control-status no-draw-bounds))
        )
    (if (>= (- (current-time) (-> self control invul1-on-time)) (-> self control invul1-off-time))
        (target-timed-invulnerable-off self 1)
        )
    )
  (when (logtest? (state-flags tinvul2) (-> self state-flags))
    (if (>= (- (current-time) (-> self control invul2-on-time)) (-> self control invul2-off-time))
        (target-timed-invulnerable-off self 2)
        )
    )
  (set! (-> self control jump-kind) #f)
  (target-gun-joint-pre)
  ((-> self pre-joint-hook))
  (target-log-trans)
  (seek!
    (-> self hair 0 twist-max z)
    (lerp-scale 0.0 1820.4445 (vector-length (-> self control transv)) 0.0 122880.0)
    (* 65536.0 (-> self clock seconds-per-frame))
    )
  (seek!
    (-> self hair 0 twist-speed-x)
    (lerp-scale 0.5 4.0 (vector-length (-> self control transv)) 0.0 122880.0)
    (* 10.0 (-> self clock seconds-per-frame))
    )
  (let ((f0-9 (+ (-> self hair 0 twist z) (* (-> self hair 0 twist-speed-x) (-> self clock seconds-per-frame)))))
    (set! (-> self hair 0 twist z) (- f0-9 (* (the float (the int (/ f0-9 1.0))) 1.0)))
    )
  (if (and (focus-test? self pilot) (nonzero? (-> self pilot)) (= (-> self pilot stance) 1))
      (seek!
        (-> self hair 0 twist-max w)
        (lerp-scale 0.0 9102.223 (vector-length (-> self control transv)) 0.0 122880.0)
        (* 65536.0 (-> self clock seconds-per-frame))
        )
      (seek! (-> self hair 0 twist-max w) 0.0 (* 65536.0 (-> self clock seconds-per-frame)))
      )
  (trs-set!
    (-> self hair 0)
    (the-as vector #f)
    (quaternion-rotate-x!
      (new 'stack-no-clear 'quaternion)
      (the-as quaternion *null-vector*)
      (+ (-> self hair 0 twist-max w) (* (sin (* 32768.0 (-> self hair 0 twist z))) (-> self hair 0 twist-max z)))
      )
    (the-as vector #f)
    )
  (seek!
    (-> self hair 1 twist-max z)
    (lerp-scale 0.0 5461.3335 (vector-length (-> self control transv)) 4096.0 122880.0)
    (* 65536.0 (-> self clock seconds-per-frame))
    )
  (seek!
    (-> self hair 1 twist-speed-x)
    (lerp-scale 1.0 8.0 (vector-length (-> self control transv)) 4096.0 122880.0)
    (* 10.0 (-> self clock seconds-per-frame))
    )
  (let ((f0-33 (+ (-> self hair 1 twist z) (* (-> self hair 1 twist-speed-x) (-> self clock seconds-per-frame)))))
    (set! (-> self hair 1 twist z) (- f0-33 (* (the float (the int (/ f0-33 1.0))) 1.0)))
    )
  (trs-set!
    (-> self hair 1)
    (the-as vector #f)
    (quaternion-rotate-x!
      (new 'stack-no-clear 'quaternion)
      (the-as quaternion *null-vector*)
      (* (sin (* 32768.0 (-> self hair 1 twist z))) (-> self hair 1 twist-max z))
      )
    (the-as vector #f)
    )
  (target-update-ik)
  0
  (none)
  )

(defbehavior bend-gravity target ()
  (if (and (logtest? (-> self control root-prim prim-core action) (collide-action no-normal-reset))
           (not (logtest? (-> self control status) (collide-status on-surface)))
           )
      (return #f)
      )
  (let ((f0-1
          (if (and (logtest? (-> self control status) (collide-status touch-wall))
                   (not (logtest? (-> self control status) (collide-status on-surface)))
                   )
              0.0
              (-> self control bend-target)
              )
          )
        )
    (seek! (-> self control bend-amount) f0-1 (* (-> self control bend-speed) (-> self clock seconds-per-frame)))
    )
  (set! (-> self control dynam gravity-normal quad) (-> self control standard-dynamics gravity-normal quad))
  (vector-float*!
    (-> self control dynam gravity)
    (-> self control dynam gravity-normal)
    (the-as float (-> self control dynam gravity-length))
    )
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (new 'stack-no-clear 'vector)
    (let ((f30-0 (-> self control current-surface tiltvv))
          (gp-0 (-> self control gspot-normal))
          )
      (vector-deg-slerp s5-0 (-> self control standard-dynamics gravity-normal) gp-0 (-> self control bend-amount))
      (let ((a2-3
              (matrix-from-two-vectors-smooth!
                (new 'stack-no-clear 'matrix)
                (-> self control bent-gravity-normal)
                s5-0
                f30-0
                (the int (-> self control current-surface tiltvvf))
                )
              )
            )
        (vector-matrix*! (-> self control bent-gravity-normal) (-> self control bent-gravity-normal) a2-3)
        )
      (vector-normalize! (-> self control bent-gravity-normal) 1.0)
      (add-debug-vector
        *display-target-marks*
        (bucket-id debug-no-zbuf1)
        (-> self control trans)
        gp-0
        (meters 2)
        (new 'static 'rgba :b #xff :a #x80)
        )
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control local-normal)
    (meters 2)
    (new 'static 'rgba :r #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control standard-dynamics gravity-normal)
    (meters 2.5)
    (new 'static 'rgba :r #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control dynam gravity-normal)
    (meters 3)
    (new 'static 'rgba :r #xff :b #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (-> self control bent-gravity-normal)
    (meters 3)
    (new 'static 'rgba :r #xff :b #xff :a #x80)
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id debug-no-zbuf1)
    (-> self control trans)
    (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
    (meters 3)
    (new 'static 'rgba :r #xff :a #x80)
    )
  )

(defbehavior target-compute-edge target ()
  (let ((s5-0 *edge-grab-info*))
    (cond
      ((-> s5-0 pilot-edge-grab?)
       (set! (-> self control ground-pat) (new 'static 'pat-surface :material (pat-material metal)))
       (cond
         ((send-event (handle->process (-> s5-0 pilot-edge-grab handle)) 'pilot-edge-grab s5-0)
          (let ((a0-7 (handle->process (-> s5-0 pilot-edge-grab handle))))
            (set! (-> s5-0 center-hold-old quad) (-> s5-0 center-hold quad))
            (let ((gp-0 (new 'stack-no-clear 'bone)))
              (let* ((v1-13 (-> gp-0 transform))
                     (a3-0 (-> (the-as process-drawable a0-7) node-list data 0 bone transform))
                     (a0-12 (-> a3-0 quad 0))
                     (a1-4 (-> a3-0 quad 1))
                     (a2-1 (-> a3-0 quad 2))
                     (a3-1 (-> a3-0 trans quad))
                     )
                (set! (-> v1-13 quad 0) a0-12)
                (set! (-> v1-13 quad 1) a1-4)
                (set! (-> v1-13 quad 2) a2-1)
                (set! (-> v1-13 trans quad) a3-1)
                )
              (vector-matrix*! (-> gp-0 scale) (the-as vector (-> s5-0 pilot-edge-grab)) (-> gp-0 transform))
              (vector-rotate*! (the-as vector (&+ gp-0 80)) (-> s5-0 pilot-edge-grab local-dir) (-> gp-0 transform))
              (set! (-> s5-0 center-hold quad) (-> gp-0 scale quad))
              (set! (-> self control edge-grab-edge-dir quad) (-> (&+ gp-0 80) transform quad 0))
              )
            )
          )
         (else
           (send-event self 'end-mode)
           )
         )
       )
      (else
        (if (not (edge-grab-info-method-9 s5-0))
            (send-event self 'end-mode)
            )
        (if *display-edge-collision-marks*
            (debug-draw s5-0)
            )
        (set! (-> self control ground-pat) (the-as pat-surface (-> s5-0 edge-tri-pat)))
        (vector-normalize!
          (vector-!
            (-> self control edge-grab-edge-dir)
            (the-as vector (-> s5-0 world-vertex))
            (-> s5-0 world-vertex 1)
            )
          1.0
          )
        )
      )
    (let ((gp-2 (vector-cross!
                  (-> self control edge-grab-across-edge-dir)
                  (-> self control edge-grab-edge-dir)
                  (-> self control dynam gravity-normal)
                  )
                )
          )
      (let ((s4-1 (vector-! (new-stack-vector0) (-> s5-0 center-hold) (-> self control midpoint-of-hands))))
        (set! (-> self control hand-to-edge-dist) (vector-length s4-1))
        (cond
          ((and (< 819.2 (-> self control hand-to-edge-dist))
                (>= (- (current-time) (-> self control last-successful-compute-edge-time)) (seconds 0.2))
                )
           (cond
             ((-> s5-0 pilot-edge-grab?)
              (case (-> s5-0 pilot-edge-grab?)
                (('target-jump)
                 (seek! (-> s5-0 pilot-grab-interp) 1.0 (* 2.0 (-> self clock seconds-per-frame)))
                 )
                (else
                  (seek! (-> s5-0 pilot-grab-interp) 1.0 (* 1.5 (-> self clock seconds-per-frame)))
                  )
                )
              (let* ((f0-11 (fmin 1.0 (* 1.5 (-> s5-0 pilot-grab-interp))))
                     (s3-1 (vector-lerp!
                             (new 'stack-no-clear 'vector)
                             (-> s5-0 pilot-start-grab-pos)
                             (vector-! (new 'stack-no-clear 'vector) (-> s5-0 center-hold) (-> self control ctrl-to-hands-offset))
                             (smooth-step f0-11)
                             )
                           )
                     )
                (set! (-> s3-1 y) (+ (lerp
                                       (-> s5-0 pilot-start-grab-pos y)
                                       (- (-> s5-0 center-hold y) (-> self control ctrl-to-hands-offset y))
                                       (smooth-step (-> s5-0 pilot-grab-interp))
                                       )
                                     (cond
                                       ((= (-> s5-0 pilot-edge-grab?) 'target-jump)
                                        (let ((f1-6 (-> s5-0 pilot-grab-interp)))
                                          (* 8192.0 (- 1.0 f1-6) f1-6)
                                          )
                                        )
                                       ((>= (-> s5-0 pilot-grab-interp) 0.5)
                                        (let ((f1-10 (* 2.0 (+ -0.5 (-> s5-0 pilot-grab-interp)))))
                                          (* 8192.0 (- 1.0 f1-10) f1-10)
                                          )
                                        )
                                       (else
                                         (let ((f1-13 (* 2.0 (-> s5-0 pilot-grab-interp))))
                                           (* 32768.0 (- 1.0 f1-13) f1-13)
                                           )
                                         )
                                       )
                                     )
                      )
                (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
                (set! (-> self control rider-time) (current-time))
                (vector+! s3-1 s3-1 (-> self control cspace-offset))
                (move-to-point! (-> self control) s3-1)
                )
              (set! (-> self control hand-to-edge-dist) 0.0)
              (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
              )
             (else
               (vector-normalize! s4-1 1228.8)
               (let ((a1-20 (vector+! (new 'stack-no-clear 'vector) s4-1 (-> self control cspace-offset))))
                 (move-by-vector! (-> self control) a1-20)
                 )
               (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
               (set! (-> self control rider-time) (current-time))
               (if (and (>= (- (current-time) (-> self control edge-grab-start-time)) (seconds 0.5))
                        (>= (- (current-time) (-> self control last-successful-compute-edge-time)) (seconds 0.5))
                        )
                   (send-event self 'end-mode)
                   )
               )
             )
           )
          (else
            (let ((a1-23 (new 'stack-no-clear 'vector)))
              (vector-! a1-23 (-> s5-0 center-hold) (-> self control ctrl-to-hands-offset))
              (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
              (set! (-> self control rider-time) (current-time))
              (vector+! a1-23 a1-23 (-> self control cspace-offset))
              (move-to-point! (-> self control) a1-23)
              )
            (set! (-> self control hand-to-edge-dist) 0.0)
            (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
            (set! (-> self control last-successful-compute-edge-time) (current-time))
            )
          )
        )
      (forward-up-nopitch->quaternion (-> self control dir-targ) gp-2 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (update-anim-data (-> self skel))
  (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
  (none)
  )

(defbehavior target-compute-edge-rider target ()
  (let ((gp-0 *edge-grab-info*))
    (cond
      ((-> gp-0 pilot-edge-grab?)
       (set! (-> self control ground-pat) (new 'static 'pat-surface :material (pat-material metal)))
       (cond
         ((send-event (handle->process (-> gp-0 pilot-edge-grab handle)) 'pilot-edge-grab gp-0)
          (let ((a0-7 (handle->process (-> gp-0 pilot-edge-grab handle))))
            (set! (-> gp-0 center-hold-old quad) (-> gp-0 center-hold quad))
            (let ((s5-0 (new 'stack-no-clear 'bone)))
              (let* ((v1-13 (-> s5-0 transform))
                     (a3-0 (-> (the-as process-drawable a0-7) node-list data 0 bone transform))
                     (a0-12 (-> a3-0 quad 0))
                     (a1-4 (-> a3-0 quad 1))
                     (a2-1 (-> a3-0 quad 2))
                     (a3-1 (-> a3-0 trans quad))
                     )
                (set! (-> v1-13 quad 0) a0-12)
                (set! (-> v1-13 quad 1) a1-4)
                (set! (-> v1-13 quad 2) a2-1)
                (set! (-> v1-13 trans quad) a3-1)
                )
              (vector-matrix*! (-> s5-0 scale) (the-as vector (-> gp-0 pilot-edge-grab)) (-> s5-0 transform))
              (vector-rotate*! (the-as vector (&+ s5-0 80)) (-> gp-0 pilot-edge-grab local-dir) (-> s5-0 transform))
              (set! (-> gp-0 center-hold quad) (-> s5-0 scale quad))
              (set! (-> self control edge-grab-edge-dir quad) (-> (&+ s5-0 80) transform quad 0))
              )
            )
          )
         (else
           (send-event self 'end-mode)
           )
         )
       )
      (else
        (if (not (edge-grab-info-method-9 gp-0))
            (send-event self 'end-mode)
            )
        (if *display-edge-collision-marks*
            (debug-draw gp-0)
            )
        (vector-normalize!
          (vector-!
            (-> self control edge-grab-edge-dir)
            (the-as vector (-> gp-0 world-vertex))
            (-> gp-0 world-vertex 1)
            )
          1.0
          )
        )
      )
    (vector-cross!
      (-> self control edge-grab-across-edge-dir)
      (-> self control edge-grab-edge-dir)
      (-> self control dynam gravity-normal)
      )
    (let ((a1-15 (vector-! (new-stack-vector0) (-> gp-0 center-hold) (-> gp-0 center-hold-old))))
      (vector-float*! (-> self control rider-last-move) a1-15 (-> self clock frames-per-second))
      (set! (-> self control rider-time) (current-time))
      (move-by-vector! (-> self control) a1-15)
      )
    )
  (set! (-> self control hand-to-edge-dist) 0.0)
  (update-anim-data (-> self skel))
  (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
  (none)
  )

(defbehavior target-compute-pole target ()
  (let* ((s2-0 (handle->process (-> self control anim-handle)))
         (gp-0 (-> (the-as swingpole s2-0) dir))
         )
    (set! (-> self control edge-grab-edge-dir quad) (-> gp-0 quad))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (let ((s4-1 (vector+float*!
                    (new 'stack-no-clear 'vector)
                    (-> (the-as swingpole s2-0) root-override trans)
                    gp-0
                    (the-as float (-> (the-as swingpole s2-0) edge-length))
                    )
                  )
            (s3-1 (vector+float*!
                    (new 'stack-no-clear 'vector)
                    (-> (the-as swingpole s2-0) root-override trans)
                    gp-0
                    (- (-> (the-as swingpole s2-0) edge-length))
                    )
                  )
            )
        (let ((v1-10 (new 'stack-no-clear 'vector)))
          (vector+! v1-10 s4-1 s3-1)
          (vector-float*! v1-10 v1-10 0.5)
          (set! (-> v1-10 y) (+ -6144.0 (-> v1-10 y)))
          (send-event *camera* 'ease-in #x3f000000 v1-10)
          )
        (vector-segment-distance-point! (-> self control midpoint-of-hands) s4-1 s3-1 s5-0)
        (if (< (- (current-time) (-> self state-time)) (seconds 0.05))
            (set! (-> self control hand-to-edge-dist)
                  (fmax 0.0 (fmin 1.0 (/ (vector-vector-distance s4-1 s5-0) (* 2.0 (-> (the-as swingpole s2-0) edge-length)))))
                  )
            (vector-lerp! s5-0 s4-1 s3-1 (-> self control hand-to-edge-dist))
            )
        (when *display-edge-collision-marks*
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (-> (the-as swingpole s2-0) root-override trans)
            (-> (the-as swingpole s2-0) dir)
            (meters 3)
            (new 'static 'rgba :r #xff :b #xff :a #x80)
            )
          (add-debug-sphere
            #t
            (bucket-id debug2)
            (-> self control midpoint-of-hands)
            (meters 0.2)
            (new 'static 'rgba :r #xff :a #x80)
            )
          (add-debug-sphere #t (bucket-id debug-no-zbuf1) s4-1 (meters 0.2) (new 'static 'rgba :g #xff :a #x80))
          (add-debug-sphere #t (bucket-id debug-no-zbuf1) s3-1 (meters 0.2) (new 'static 'rgba :g #xff :b #x40 :a #x80))
          (add-debug-sphere #t (bucket-id debug-no-zbuf1) s5-0 (meters 0.2) (new 'static 'rgba :b #xff :a #x80))
          )
        )
      (let ((a0-26 (vector-! (new-stack-vector0) s5-0 (-> self control midpoint-of-hands))))
        (cond
          ((and (< 2457.6 (vector-length a0-26)) (not (-> self control did-move-to-pole-or-max-jump-height)))
           (move-by-vector! (-> self control) (vector-normalize! a0-26 2457.6))
           )
          (else
            (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float #t))
            (move-to-point!
              (-> self control)
              (vector-! (new 'stack-no-clear 'vector) s5-0 (-> self control ctrl-to-hands-offset))
              )
            (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
            )
          )
        )
      )
    (let ((s5-3 (vector-cross! (-> self control edge-grab-across-edge-dir) gp-0 (-> self control dynam gravity-normal)))
          )
      (if (>= 0.0
              (vector-dot s5-3 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control)))
              )
          (vector-negate! s5-3 s5-3)
          )
      (forward-up-nopitch->quaternion (-> self control dir-targ) s5-3 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (update-anim-data (-> self skel))
  (do-joint-math (-> self draw) (-> self node-list) (-> self skel))
  (update-transforms (-> self control))
  (none)
  )

(defbehavior target-calc-camera-pos target ()
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (cond
      ((and (and (-> self next-state) (= (-> self next-state name) 'target-clone-anim))
            (and (not (logtest? (-> self draw status) (draw-control-status no-draw)))
                 (begin
                   (vector<-cspace! s5-0 (-> self node-list data 3))
                   (set! (-> s5-0 y) (+ -5896.192 (-> s5-0 y)))
                   (< (fabs (- (-> s5-0 y) (-> self control trans y))) 8192.0)
                   )
                 )
            )
       (set! (-> self control camera-pos quad) (-> s5-0 quad))
       )
      ((focus-test? self board pilot mech indax)
       (set! (-> self control camera-pos quad) (-> self control trans quad))
       )
      ((or (logtest? (-> self control status) (collide-status on-water))
           (let ((v1-23 (-> self water flags)))
             (and (logtest? (water-flags touch-water) v1-23)
                  (logtest? (water-flags under-water swimming) v1-23)
                  (not (logtest? (focus-status mech) (-> self focus-status)))
                  )
             )
           )
       (vector<-cspace! s5-0 (the-as cspace (-> self node-list data)))
       (if (not (and (logtest? (-> self water flags) (water-flags under-water))
                     (not (logtest? (-> self water flags) (water-flags swim-ground)))
                     )
                )
           (set! (-> s5-0 y) (- (-> self water surface-height) (-> self water swim-height)))
           )
       (vector<-cspace! gp-0 (-> self node-list data 6))
       (cond
         ((>= (+ (current-time) (seconds -2)) (-> self control unknown-time-frame26))
          (set! (-> self control camera-pos quad) (-> s5-0 quad))
          )
         ((not (and (logtest? (-> self water flags) (water-flags under-water))
                    (not (logtest? (-> self water flags) (water-flags swim-ground)))
                    )
               )
          (vector-lerp!
            (-> self control camera-pos)
            gp-0
            s5-0
            (* 0.0016666667 (the float (- (current-time) (-> self control unknown-time-frame26))))
            )
          )
         (else
           (vector-lerp!
             (-> self control camera-pos)
             s5-0
             gp-0
             (fmax 0.0 (fmin 1.0 (* 0.0011111111 (the float (- (current-time) (-> self control unknown-time-frame27))))))
             )
           )
         )
       (-> self control camera-pos)
       )
      ((and (or (logtest? (water-flags touch-water) (-> self water flags))
                (logtest? (-> self control status) (collide-status on-water))
                )
            (logtest? (-> self water flags) (water-flags mud))
            )
       (vector<-cspace! (-> self control camera-pos) (the-as cspace (-> self node-list data)))
       (set! (-> self control camera-pos y) (-> self water base-height))
       )
      ((focus-test? self tube)
       (set! (-> self control camera-pos quad) (-> self control gspot-pos quad))
       )
      ((logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp))
       (set! (-> self control camera-pos quad) (-> self control trans quad))
       )
      (else
        (vector<-cspace! (-> self control camera-pos) (the-as cspace (-> self node-list data)))
        )
      )
    )
  0
  (none)
  )

(defbehavior joint-points target ()
  (let ((f0-1 (* 0.00078125 (the float (-> self neck loock-at-count)))))
    (if (!= f0-1 0.0)
        (set! f0-1 (+ 0.12 f0-1))
        )
    (cond
      ((>= f0-1 (-> self excitement))
       (seek! (-> self excitement) f0-1 (* 6.0 (-> self clock seconds-per-frame)))
       )
      ((focus-test? self dead ignore hit)
       )
      (else
        (seek! (-> self excitement) f0-1 (* 0.25 (-> self clock seconds-per-frame)))
        )
      )
    )
  (set-setting! 'sound-excitement 'add (-> self excitement) 0)
  (let ((v1-17 (-> self neck)))
    (set! (-> v1-17 blend) 0.0)
    )
  (set! (-> self neck loock-at-count) (the-as uint 0))
  (if (and (logtest? (-> self control current-surface flags) (surface-flag duck))
           (< 0.5 (-> self control duck-gun-tube-transision))
           (not (using-gun? self))
           )
      (set! (-> self neck base-nose) (the-as uint 1))
      (set! (-> self neck base-nose) (the-as uint 2))
      )
  (let ((v1-29 (-> self upper-body)))
    (set! (-> v1-29 blend) 0.0)
    )
  (cond
    ((focus-test? self tube pilot indax)
     )
    ((logtest? (water-flags wading) (-> self water flags))
     (let ((f30-0 (- (- (-> self control trans y) (- (-> self water height) (-> self water wade-height))))))
       (set! (-> *wade-surface* alignv)
             (lerp-scale 1.0 0.5 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))
             )
       (set! (-> *wade-surface* align-speed) (-> *wade-surface* alignv))
       (let ((f0-20 (lerp-scale 0.8 0.6 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))))
         (set! (-> *wade-surface* target-speed) f0-20)
         (set! (-> *wade-surface* transv-max) f0-20)
         )
       )
     (set! (-> self control surf) *wade-surface*)
     )
    ((logtest? (water-flags swimming) (-> self water flags))
     (set! (-> self control surf) *swim-surface*)
     )
    ((and (logtest? (water-flags touch-water) (-> self water flags))
          (logtest? (-> self water flags) (water-flags mud))
          )
     (set! (-> self control surf) *quicksand-surface*)
     )
    )
  (let ((a2-5
          (matrix<-no-trans-transformq! (-> self control ctrl-orientation) (the-as transformq (-> self control trans)))
          )
        )
    (vector-matrix*! (-> self control ctrl-to-head-offset) (-> *TARGET-bank* head-offset) a2-5)
    )
  (vector<-cspace!
    (the-as vector (&-> (-> self control) sidekick-root bone))
    (-> self control sidekick-root parent)
    )
  (let ((gp-0 (new-stack-vector0))
        (s5-0 (new-stack-vector0))
        )
    (vector<-cspace! gp-0 (-> self control lhand-cspace))
    (vector<-cspace! s5-0 (-> self control rhand-cspace))
    (vector-average! (-> self control midpoint-of-hands) gp-0 s5-0)
    )
  (vector-! (-> self control ctrl-to-hands-offset) (-> self control midpoint-of-hands) (-> self control trans))
  (update-from-cspace (-> self control impact-ctrl))
  (cond
    ((focus-test? self edge-grab)
     (target-compute-edge)
     )
    ((focus-test? self pole)
     (target-compute-pole)
     )
    )
  (target-calc-camera-pos)
  (set! (-> self control tongue-counter) 0)
  (cond
    ((focus-test? self indax)
     )
    (else
      (target-gun-joint-points)
      (target-board-joint-points)
      )
    )
  0
  (none)
  )

(defbehavior do-target-gspot target ()
  (cond
    ((and (logtest? (-> self control status) (collide-status on-surface))
          (!= (-> self control mod-surface mode) 'swim)
          (!= (-> self control mod-surface mode) 'dive)
          (not (and (-> self next-state) (= (-> self next-state name) 'target-flop)))
          (not (logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp no-draw-bounds)))
          )
     (set! (-> self control gspot-pos quad) (-> self control trans quad))
     (set! (-> self control gspot-normal quad) (-> self control ground-poly-normal quad))
     (set! (-> self control gspot-pat-surfce) (-> self control ground-pat))
     )
    (else
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (if (find-ground
              (-> self control)
              gp-0
              (logclear (-> self control root-prim prim-core collide-with) (collide-spec water))
              8192.0
              81920.0
              1024.0
              )
            (set! (-> self control gspot-pat-surfce) (-> gp-0 best-other-tri pat))
            )
        )
      )
    )
  0
  (none)
  )

(defbehavior target-real-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (if (< (-> self control force-turn-to-strength) 0.0)
            (set! (-> self control force-turn-to-strength) (- 1.0 (-> self control cpad stick0-speed)))
            )
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (let ((f28-0 (debounce-speed
                         (-> self control pad-magnitude)
                         (-> self control last-pad-magnitude)
                         (-> self control pad-xz-dir)
                         (-> self control last-pad-xz-dir)
                         )
                       )
                )
            (when (!= (-> self control force-turn-to-strength) 0.0)
              (let ((f0-12 (fmin 1.0 (-> self control force-turn-to-strength))))
                (set! (-> self control force-turn-to-strength) f0-12)
                (let ((a1-3 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (if (= f28-0 0.0)
                                  *zero-vector*
                                  s5-0
                                  )
                              f28-0
                              )
                            )
                      (a2-2 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (-> self control force-turn-to-direction)
                              (-> self control force-turn-to-speed)
                              )
                            )
                      )
                  (vector-lerp! s5-0 a1-3 a2-2 f0-12)
                  )
                )
              (set! f28-0 (vector-length s5-0))
              (vector-normalize! s5-0 1.0)
              )
            (turn-to-vector s5-0 f28-0)
            )
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-38 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-38)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (set! (-> self control reaction) target-collision-reaction)
        (let ((a2-3 (new 'stack-no-clear 'collide-query)))
          (let ((v1-52 (-> self control)))
            (set! (-> a2-3 collide-with) (-> v1-52 root-prim prim-core collide-with))
            (set! (-> a2-3 ignore-process0) self)
            (set! (-> a2-3 ignore-process1) #f)
            (set! (-> a2-3 ignore-pat) (-> v1-52 pat-ignore-mask))
            )
          (set! (-> a2-3 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-3 (meters 1))
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (do-edge-grabs *target* *collide-cache* *collide-edge-spec*)
            )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-83 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-83))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-83 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-100 'target-post)
          (s5-3 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-2 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-2 (-> gp-2 base-time)))
            (set! (-> s4-2 name) v1-100)
            (set! (-> s4-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
            )
          (set! (-> s4-2 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-2 color) s5-3)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-2)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-124 (+ (-> gp-3 depth) -1))
               (s5-4 (-> gp-3 segment v1-124))
               (s4-3 (-> gp-3 base-time))
               )
          (when (>= v1-124 0)
            (set! (-> s5-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-post target ()
  (target-real-post)
  (none)
  )

(defbehavior target-swim-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (turn-to-vector s5-0 (-> self control pad-magnitude))
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-17 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-17)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (let ((a2-0 (new 'stack-no-clear 'collide-query)))
          (let ((v1-30 (-> self control)))
            (set! (-> a2-0 collide-with) (-> v1-30 root-prim prim-core collide-with))
            (set! (-> a2-0 ignore-process0) self)
            (set! (-> a2-0 ignore-process1) #f)
            (set! (-> a2-0 ignore-pat) (-> v1-30 pat-ignore-mask))
            )
          (set! (-> a2-0 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-0 (meters 1))
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (do-edge-grabs *target* *collide-cache* *collide-edge-spec*)
            )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-61 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-61))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-61 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-78 'target-post)
          (s5-3 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-2 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-2 (-> gp-2 base-time)))
            (set! (-> s4-2 name) v1-78)
            (set! (-> s4-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
            )
          (set! (-> s4-2 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-2 color) s5-3)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-2)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-102 (+ (-> gp-3 depth) -1))
               (s5-4 (-> gp-3 segment v1-102))
               (s4-3 (-> gp-3 base-time))
               )
          (when (>= v1-102 0)
            (set! (-> s5-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-stick-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (turn-to-vector s5-0 0.0)
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-16 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-16)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (let ((a2-0 (new 'stack-no-clear 'collide-query)))
          (let ((v1-29 (-> self control)))
            (set! (-> a2-0 collide-with) (-> v1-29 root-prim prim-core collide-with))
            (set! (-> a2-0 ignore-process0) self)
            (set! (-> a2-0 ignore-process1) #f)
            (set! (-> a2-0 ignore-pat) (-> v1-29 pat-ignore-mask))
            )
          (set! (-> a2-0 action-mask) (collide-action solid))
          (fill-cache-integrate-and-collide (-> self control) (-> self control transv) a2-0 (meters 1))
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (do-edge-grabs *target* *collide-cache* *collide-edge-spec*)
            )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-60 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-60))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-60 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-77 'target-post)
          (s5-3 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-2 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-2 (-> gp-2 base-time)))
            (set! (-> s4-2 name) v1-77)
            (set! (-> s4-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
            )
          (set! (-> s4-2 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-2 color) s5-3)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-2)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-101 (+ (-> gp-3 depth) -1))
               (s5-4 (-> gp-3 segment v1-101))
               (s4-3 (-> gp-3 base-time))
               )
          (when (>= v1-101 0)
            (set! (-> s5-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-move-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (vector-!
          (-> self control cspace-offset)
          (-> self control draw-offset)
          (-> self control anim-collide-offset-world)
          )
        (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a1-3 options) (overlaps-others-options oo0))
          (set! (-> a1-3 collide-with-filter) (the-as collide-spec -1))
          (set! (-> a1-3 tlist) *touching-list*)
          (find-overlapping-shapes (-> self control) a1-3)
          )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-27 'target-post)
          (s5-0 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-0 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-0 (-> gp-2 base-time)))
            (set! (-> s4-0 name) v1-27)
            (set! (-> s4-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-0))))
            )
          (set! (-> s4-0 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-0 color) s5-0)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-0)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-51 (+ (-> gp-3 depth) -1))
               (s5-1 (-> gp-3 segment v1-51))
               (s4-1 (-> gp-3 base-time))
               )
          (when (>= v1-51 0)
            (set! (-> s5-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (when *debug-segment*
    (let ((gp-4 (-> self control)))
      (+! (-> gp-4 history-idx) 1)
      (let ((v1-62 (clear-record-tags! *history* (history-channel transv) (-> gp-4 history-idx) (the-as uint 2))))
        (set! (-> v1-62 origin quad) (-> gp-4 trans quad))
        (set! (-> v1-62 vector quad) (-> gp-4 transv quad))
        )
      (set! (-> (clear-record-tags! *history* (history-channel trans) (-> gp-4 history-idx) (the-as uint 2)) vector quad)
            (-> gp-4 trans quad)
            )
      (let ((v1-68 (clear-record-tags! *history* (history-channel collide-status) (-> gp-4 history-idx) (the-as uint 2)))
            )
        (set! (-> v1-68 collide-status) (logior (-> gp-4 status) (collide-status no-touch)))
        (set! (-> v1-68 vector z) (the-as float (-> gp-4 reaction-flag)))
        )
      )
    )
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-ja-move-post target ()
  (vector-!
    (-> self control cspace-offset)
    (-> self control draw-offset)
    (-> self control anim-collide-offset-world)
    )
  (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
    (set! (-> a1-2 options) (overlaps-others-options oo0))
    (set! (-> a1-2 collide-with-filter) (the-as collide-spec -1))
    (set! (-> a1-2 tlist) *touching-list*)
    (find-overlapping-shapes (-> self control) a1-2)
    )
  (target-calc-camera-pos)
  (do-target-gspot)
  (target-powerup-process)
  (target-board-joint-points)
  (none)
  )

(defbehavior reset-target-state target ((arg0 symbol))
  (when arg0
    (vector-identity! (-> self control scale))
    (quaternion-identity! (-> self control quat))
    (quaternion-identity! (-> self control quat-for-control))
    (quaternion-identity! (-> self control dir-targ))
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control camera-pos quad) (-> self control trans quad))
    )
  (target-exit)
  (target-timed-invulnerable-off self 0)
  (target-timed-invulnerable-off self 2)
  (set! (-> self control status) (collide-status))
  (set! (-> self control standard-dynamics) *standard-dynamics*)
  (set! (-> self control surf) *standard-ground-surface*)
  (set! (-> self control bent-gravity-normal quad) (-> self control standard-dynamics gravity-normal quad))
  (quaternion-identity! (-> self control override-quat))
  (set! (-> self control override-quat-alpha) 0.0)
  (set! (-> self control last-time-on-surface) (current-time))
  (set! (-> self control bend-amount) 0.0)
  (set! (-> self control bend-speed) 32.0)
  (set! (-> self cam-user-mode) 'normal)
  (set! (-> self control anim-handle) (the-as handle #f))
  (set! (-> self control actor-contact-handle) (the-as handle #f))
  (set! (-> self control yellow-eco-last-use-time) 0)
  (buzz-stop! 0)
  self
  )

(defmethod init-target target ((obj target) (arg0 continue-point) (arg1 symbol))
  (local-vars (s1-0 int) (s2-0 int) (s3-0 int) (s4-0 int) (sv-16 collide-shape-prim-group))
  (set! (-> obj tobot?) arg1)
  (set! (-> obj tobot-recorder) #f)
  (set! (-> obj mode-cache) #f)
  (set! (-> obj color-effect) #f)
  (set-setting! 'allow-pause #f 0.0 0)
  (set-setting! 'allow-progress #f 0.0 0)
  (set! (-> *setting-control* cam-default mode-name) 'cam-string)
  (apply-settings *setting-control*)
  (if (not arg0)
      (set! arg0 (get-current-continue-forced *game-info*))
      )
  (set-continue! *game-info* arg0 #f)
  (stack-size-set! (-> obj main-thread) 2048) ;; changed from 1024
  (logior! (-> obj mask) (process-mask target))
  (set! (-> obj state-hook) (the-as (function none :behavior target) nothing))
  (cond
    ((= (-> obj tobot?) 'tobot)
     (set! s4-0 #x40000)
     (set! s3-0 #x2183f7f)
     (set! s2-0 #x40000)
     (set! s1-0 #x218377e)
     )
    (else
      (set! s4-0 2)
      (set! s3-0 #x21c3f7d)
      (set! s2-0 2)
      (set! s1-0 #x21c377c)
      )
    )
  (let ((s0-0 (new 'process 'control-info obj (collide-list-enum hit-by-others))))
    (set! (-> s0-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s0-0 reaction) target-collision-reaction)
    (set! (-> s0-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) target-collision-no-reaction)
          )
    (set! sv-16 (new 'process 'collide-shape-prim-group s0-0 (the-as uint 9) 1))
    (set! (-> s0-0 total-prims) (the-as uint 10))
    (set! (-> sv-16 prim-core action) (collide-action solid can-ride))
    (set-vector! (-> sv-16 local-sphere) 0.0 0.0 0.0 4096.0)
    (set! (-> s0-0 root-prim) sv-16)
    (set! (-> sv-16 prim-core collide-as) (the-as collide-spec s4-0))
    (set! (-> sv-16 prim-core collide-with) (the-as collide-spec s3-0))
    (let ((v0-9 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 6))))
      (set! (-> v0-9 prim-core action) (collide-action solid can-ride))
      (set-vector! (-> v0-9 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 0) v0-9)
      (set! (-> v0-9 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-9 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-10 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 10))))
      (set! (-> v0-10 prim-core action) (collide-action solid))
      (set-vector! (-> v0-10 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 1) v0-10)
      (set! (-> v0-10 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-10 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-11 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 18))))
      (set! (-> v0-11 prim-core action) (collide-action solid))
      (set-vector! (-> v0-11 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 2) v0-11)
      (set! (-> v0-11 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-11 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-12 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 34))))
      (set! (-> v0-12 prim-core action) (collide-action solid))
      (set-vector! (-> v0-12 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 3) v0-12)
      (set! (-> v0-12 prim-core collide-as) (collide-spec))
      (set! (-> v0-12 prim-core collide-with) (collide-spec))
      )
    (let ((v0-13 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 0))))
      (set! (-> v0-13 prim-core action) (collide-action semi-solid))
      (set! (-> v0-13 transform-index) 6)
      (set-vector! (-> v0-13 local-sphere) 0.0 0.0 0.0 2048.0)
      (set! (-> s0-0 collision-spheres 4) v0-13)
      (set! (-> v0-13 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-13 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-14 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 128))))
      (set! (-> v0-14 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-14 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 6) v0-14)
      )
    (let ((v0-15 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 256))))
      (set! (-> v0-15 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-15 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 7) v0-15)
      )
    (let ((v0-16 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 512))))
      (set! (-> v0-16 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-16 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 8) v0-16)
      )
    (let ((v0-17 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 1024))))
      (set! (-> v0-17 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-17 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 collision-spheres 9) v0-17)
      )
    (set! (-> s0-0 nav-radius) (* 0.75 (-> s0-0 root-prim local-sphere w)))
    (let ((v1-66 (-> s0-0 root-prim)))
      (set! (-> s0-0 backup-collide-as) (-> v1-66 prim-core collide-as))
      (set! (-> s0-0 backup-collide-with) (-> v1-66 prim-core collide-with))
      )
    (set! (-> s0-0 event-priority) (the-as uint 9))
    (set! (-> obj control) s0-0)
    )
  (let ((v1-69 (-> obj control)))
    (set! (-> v1-69 default-collide-as-all) (the-as collide-spec s4-0))
    (set! (-> v1-69 default-collide-with-all) (the-as collide-spec s3-0))
    (set! (-> v1-69 default-collide-as-fgnd) (the-as collide-spec s2-0))
    (set! (-> v1-69 default-collide-with-fgnd) (the-as collide-spec s1-0))
    (set! (-> v1-69 max-iteration-count) (the-as uint 8))
    (set! (-> v1-69 event-self) 'touched)
    )
  (set! (-> obj game) *game-info*)
  (move-to-point! (-> obj control) (-> arg0 trans))
  (set! (-> obj control camera-pos quad) (-> arg0 trans quad))
  (set! (-> obj focus-search) (new 'process 'boxed-array collide-shape 128))
  (set! (-> obj focus-search length) 0)
  (set! (-> obj control cpad) (-> *cpad-list* cpads 0))
  (set! (-> obj control current-surface) (new 'process 'surface))
  (set! (-> obj control current-surface name) 'current)
  (set! (-> obj control current-surface active-hook) nothing)
  (set! (-> obj control current-surface touch-hook) nothing)
  (set! (-> obj control send-attack-dest) (the-as handle #f))
  (dotimes (v1-84 8)
    (set! (-> obj attack-info-old v1-84 attacker) (the-as handle #f))
    )
  (set! (-> obj notify) (the-as handle #f))
  (set! (-> obj mirror) (the-as (pointer process-drawable) #f))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-jchar" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> obj skel effect flags) (effect-control-flag ecf0 ecf1))
  (let ((v1-94 (-> obj node-list data)))
    (set! (-> v1-94 0 param0) (the-as (function cspace transformq none) cspace<-transformq+trans!))
    (set! (-> v1-94 0 param1) (the-as basic (-> obj control trans)))
    (set! (-> v1-94 0 param2) (the-as basic (-> obj control cspace-offset)))
    )
  (set! (-> obj skel override) (new 'process 'boxed-array float 54))
  (set! (-> obj draw light-index) (the-as uint 30))
  (set! (-> obj beard?) #t)
  (set! (-> obj draw lod-set max-lod) 0)
  (logior! (-> obj skel status) (joint-control-status sync-math blend-shape eye-anim))
  (set! (-> obj draw shadow-ctrl) *target-shadow-control*)
  (set! (-> obj shadow-backup) (-> obj draw shadow))
  (set! (-> obj carry)
        (new 'process 'carry-info obj 41 (new 'static 'vector :w 1.0) (new 'static 'vector :z 1.0 :w 1.0) 12743.111)
        )
  (set! (-> obj control lhand-cspace) (-> obj node-list data 45))
  (set! (-> obj control rhand-cspace) (-> obj node-list data 55))
  (set! (-> obj control rhand-cspace) (-> obj node-list data 55))
  (set! (-> obj control sidekick-root parent) (-> obj node-list data 23))
  (set! (-> obj neck) (new 'process 'joint-mod (joint-mod-mode look-at) obj 8))
  (set! (-> obj neck parented-scale?) #t)
  (set! (-> obj neck base-joint) (the-as uint 6))
  (set! (-> obj neck ignore-angle) 16384.0)
  (set! (-> obj head) (new 'process 'joint-mod (joint-mod-mode flex-blend) obj 7))
  (set! (-> obj head parented-scale?) #t)
  (set! (-> obj upper-body) (new 'process 'joint-mod (joint-mod-mode gun-look-at) obj 4))
  (set! (-> obj upper-body parented-scale?) #t)
  (set! (-> obj horns) (new 'process 'joint-mod (joint-mod-mode joint-set) obj 42))
  (set! (-> obj horns parented-scale?) #t)
  (set! (-> obj horns track-mode) (track-mode no-trans no-rotate))
  (set! (-> obj hair 0) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 9))
  (set! (-> obj hair 0 parented-scale?) #t)
  (set! (-> obj hair 1) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 10))
  (set! (-> obj hair 1 parented-scale?) #t)
  (set! (-> obj arm-ik 0) (new 'process 'joint-mod-ik obj 17 1228.8))
  (set! (-> obj arm-ik 1) (new 'process 'joint-mod-ik obj 21 -1228.8))
  (set! (-> obj arm-ik 1 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> obj arm-ik 1 elbow-rotation-axis) (the-as uint 0))
  (set! (-> obj leg-ik 0) (new 'process 'joint-mod-ik obj 28 1687.552))
  (set! (-> obj leg-ik 0 callback) (the-as (function joint-mod-ik matrix matrix vector object) leg-ik-callback))
  (set! (-> obj leg-ik 0 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> obj leg-ik 0 elbow-rotation-axis) (the-as uint 0))
  (logior! (-> obj leg-ik 0 flags) (joint-mod-ik-flags elbow-trans-neg))
  (set! (-> obj leg-ik 1) (new 'process 'joint-mod-ik obj 35 -1687.552))
  (set! (-> obj leg-ik 1 callback) (the-as (function joint-mod-ik matrix matrix vector object) leg-ik-callback))
  (set! (-> obj leg-ik 1 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> obj leg-ik 1 elbow-rotation-axis) (the-as uint 0))
  (set! (-> obj foot 0) (new 'process 'joint-mod (joint-mod-mode foot-rot) obj 29))
  (set! (-> obj foot 1) (new 'process 'joint-mod (joint-mod-mode foot-rot) obj 36))
  (set! (-> obj fact-override)
        (new 'process 'fact-info-target obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (target-gun-setup (logtest? (-> obj game features) (game-feature gun)))
  (target-board-setup (logtest? (-> obj game features) (game-feature board)))
  (target-sidekick-setup (logtest? (-> obj game features) (game-feature sidekick)))
  (target-darkjak-setup (logtest? (-> obj game features) (game-feature darkjak)))
  (target-collide-set! 'normal 0.0)
  (let ((v1-163 (-> obj control root-prim)))
    (set! (-> obj control backup-collide-as) (-> v1-163 prim-core collide-as))
    (set! (-> obj control backup-collide-with) (-> v1-163 prim-core collide-with))
    )
  (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj control trans)))
  (set! (-> obj control unknown-sound-id04) (new-sound-id))
  (set! (-> obj control bubbles-sound) (new-sound-id))
  (set! (-> obj control board-jump-and-swim-sound) (new-sound-id))
  (if (and *debug-segment* (!= (-> obj tobot?) 'tobot))
      (add-connection *debug-engine* obj target-print-stats obj *stdcon0* #f)
      )
  (if (!= (-> obj tobot?) 'tobot)
      (activate-hud obj)
      )
  (set! (-> obj fp-hud) (the-as handle #f))
  (set! (-> obj burn-proc) (the-as handle #f))
  (set! (-> obj water) (new 'process 'water-control obj 10 0.0 8192.0 2048.0))
  (set! (-> obj water flags) (water-flags swim-ground part-splash part-drip part-rings part-water find-water))
  (reset-target-state #t)
  (set! (-> obj control last-trans-any-surf quad) (-> obj control trans quad))
  (set! (-> obj control last-trans-any-surf y) (+ -819200.0 (-> obj control last-trans-any-surf y)))
  (set! (-> obj align) (new 'process 'align-control obj))
  (set! (-> obj manipy) (the-as (pointer manipy) #f))
  (set! (-> obj event-hook) target-generic-event-handler)
  (set! (-> obj current-level) #f)
  (level-setup)
  (set! (-> obj pre-joint-hook) (the-as (function none :behavior target) nothing))
  (set! (-> obj init-time) (current-time))
  (set! (-> obj spool-anim) (the-as spool-anim #t))
  (set! (-> obj ambient-time) (current-time))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-init target ((arg0 continue-point))
  (init-target self arg0 #f)
  (set! (-> self event-hook) (-> target-continue event))
  (set! (-> self focus-status) (logior (focus-status teleporting) (-> self focus-status)))
  (go target-continue arg0)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior tobot-init target ((arg0 symbol))
  (init-target self (the-as continue-point #f) 'tobot)
  (set! (-> self name) "tobot")
  (set! (-> self tobot-recorder) (the-as basic arg0))
  (send-event *target* 'tobot 'tobot)
  (go tobot-stance)
  (none)
  )

(defmethod deactivate target ((obj target))
  (kill-persister *setting-control* (the-as engine-pers 'bg-a-speed) 'bg-a-speed)
  (if (nonzero? (-> obj darkjak))
      (sound-stop (-> obj darkjak tone))
      )
  (set! (-> *setting-control* cam-default mode-name) #f)
  (set-zero! *camera-smush-control*)
  ((the-as (function target none) (find-parent-method target 10)) obj)
  (none)
  )

(defun stop ((arg0 symbol))
  (when *target*
    (kill-by-name "target" *active-pool*)
    (set! *target* #f)
    )
  (set! (-> *game-info* mode) arg0)
  0
  )

(defun start ((arg0 symbol) (arg1 continue-point))
  (let ((v1-0 arg0))
    (set! (-> *level* play?) (if (= v1-0 'play)
                                 #t
                                 (-> *setting-control* user-default border-mode)
                                 )
          )
    )
  (set! (-> *setting-control* user-default border-mode) #f)
  (set! (-> *setting-control* user-default region-mode) #f)
  (apply-settings *setting-control*)
  (stop arg0)
  (let ((v1-8 (process-spawn
                target
                :init target-init
                arg1
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                )
              )
        )
    (if v1-8
        (set! *target* (the-as target (-> v1-8 0 self)))
        (set! *target* #f)
        )
    )
  *target*
  )

;; WARN: Return type mismatch (pointer process) vs target.
(defun tobot-start ((arg0 symbol))
  (the-as target (process-spawn
                   target
                   :init tobot-init
                   arg0
                   :from *target-dead-pool*
                   :to *target-pool*
                   :stack *kernel-dram-stack*
                   )
          )
  )

(defun tobot-stop ()
  (kill-by-name "tobot" *active-pool*)
  0
  )
