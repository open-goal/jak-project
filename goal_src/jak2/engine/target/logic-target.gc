;;-*-Lisp-*-
(in-package goal)

;; name: logic-target.gc
;; name in dgo: logic-target
;; dgos: ENGINE, GAME

(define-extern history-draw (function history-iterator none))
(define-extern target-sidekick-setup (function symbol none :behavior target))
(define-extern target-board-setup (function symbol none :behavior target))
(define-extern manipy-init (function vector entity-actor skeleton-group vector none :behavior manipy))
(define-extern target-float (state target))
(define-extern target-timed-invulnerable-off (function target int none))
(define-extern target-gun-joint-pre (function none :behavior target))
(define-extern target-gun-joint-points (function none :behavior target))
(define-extern target-board-joint-points (function none :behavior target))
(define-extern debounce-speed (function float float vector vector float :behavior target))
(define-extern target-collision-reaction (function control-info collide-query vector vector cshape-moving-flags))
(define-extern ja-post (function none :behavior process-drawable))
(define-extern target-powerup-process (function none :behavior target))
(define-extern target-exit (function none :behavior target))
(define-extern target-collision-no-reaction (function control-info collide-query vector vector none))
(define-extern target-gun-setup (function symbol none :behavior target))
(define-extern target-darkjak-setup (function symbol none :behavior target))
(define-extern target-collide-set! (function symbol float int :behavior target))
(define-extern activate-hud (function target none))
(define-extern target-generic-event-handler (function process int symbol event-message-block object :behavior target))
(define-extern target-continue (state continue-point target))
(define-extern tobot-stance (state target))

;; DECOMP BEGINS

(defbehavior build-conversions target ((arg0 vector))
  (when (!= (-> self control unknown-surface02) (-> self control surf))
    (set! (-> self control unknown-surface02) (-> self control surf))
    (set! (-> self control unknown-time-frame02) (-> self clock frame-counter))
    )
  (surface-mult! (-> self control unknown-surface01) (-> self control unknown-surface00) (-> self control surf))
  (when (and (and (= (-> (the-as fact-info-target (-> self fact)) eco-type) 3)
                  (>= (-> (the-as fact-info-target (-> self fact)) eco-level) 1.0)
                  )
             (or (= (-> self control unknown-surface00 name) 'run) (= (-> self control unknown-surface00 name) 'jump))
             )
    (set! (-> self control unknown-surface01 target-speed)
          (+ 20480.0 (-> self control unknown-surface01 target-speed))
          )
    (set! (-> self control unknown-surface01 transv-max)
          (+ 20480.0 (-> self control unknown-surface01 transv-max))
          )
    )
  (when (and (and (logtest? (focus-status dark) (-> self focus-status)) (nonzero? (-> self darkjak)))
             (or (= (-> self control unknown-surface00 name) 'run)
                 (= (-> self control unknown-surface00 name) 'jump)
                 (= (-> self control unknown-surface00 name) 'attack)
                 )
             )
    (set! (-> self control unknown-surface01 target-speed)
          (* 1.2 (-> self darkjak-giant-interp) (-> self control unknown-surface01 target-speed))
          )
    (set! (-> self control unknown-surface01 transv-max)
          (* 1.2 (-> self darkjak-giant-interp) (-> self control unknown-surface01 transv-max))
          )
    )
  (let ((f0-11 (-> *setting-control* user-current speed-mult)))
    (set! (-> self control unknown-surface01 target-speed)
          (* (-> self control unknown-surface01 target-speed) f0-11)
          )
    (set! (-> self control unknown-surface01 transv-max) (* (-> self control unknown-surface01 transv-max) f0-11))
    )
  (let ((s5-0 (new-stack-vector0)))
    (vector-z-quaternion! s5-0 (-> self control unknown-quaternion00))
    (when (logtest? (-> self control unknown-surface00 flags) (surface-flag xz-local))
      (vector-flatten! s5-0 s5-0 (-> self control dynam gravity-normal))
      (vector-normalize! s5-0 1.0)
      )
    (forward-up-nopitch->inv-matrix (-> self control unknown-matrix01) s5-0 (-> self control local-normal))
    )
  (matrix-transpose! (-> self control unknown-matrix00) (-> self control unknown-matrix01))
  (vector-matrix*! (-> self control unknown-vector00) arg0 (-> self control unknown-matrix00))
  (set! (-> self control unknown-vector20 quad) (-> self control unknown-vector19 quad))
  (let ((v0-7 (-> self control unknown-vector19)))
    (set! (-> v0-7 quad) (-> self control dynam gravity-normal quad))
    v0-7
    )
  )

(defbehavior vector-turn-to target ((arg0 vector))
  (forward-up-nopitch->quaternion
    (-> self control dir-targ)
    (vector-normalize-copy! (new 'stack-no-clear 'vector) arg0 1.0)
    (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (build-conversions (-> self control transv))
  )

;; WARN: Return type mismatch cshape-moving-flags vs none.
(defbehavior reverse-conversions target ((arg0 vector))
  (let ((v1-1 (-> self control unknown-vector00)))
    (set! (-> self control unknown-float05) (sqrtf (+ (* (-> v1-1 x) (-> v1-1 x)) (* (-> v1-1 z) (-> v1-1 z)))))
    )
  (vector-matrix*! arg0 (-> self control unknown-vector00) (-> self control unknown-matrix01))
  (set! (-> self control old-status) (-> self control status))
  (none)
  )

(defun-debug draw-history ((arg0 control-info))
  (when (nonzero? *display-collide-history*)
    (when (cpad-pressed? 0 l3)
      (set! (-> arg0 history-length) (logand (+ (-> arg0 history-length) 1) 3))
      (if (cpad-hold? 0 l2)
          (set! (-> arg0 history-length) (the-as uint 1000))
          )
      )
    (let* ((v1-15 (-> arg0 history-length))
           (gp-0 (cond
                   ((zero? v1-15)
                    465
                    )
                   ((= v1-15 1)
                    469
                    )
                   ((= v1-15 2)
                    473
                    )
                   ((= v1-15 3)
                    913
                    )
                   (else
                     384
                     )
                   )
                 )
           (a0-5 (new 'stack 'history-iterator (the-as uint 1800)))
           )
      (set! (-> a0-5 out) #t)
      (set! (-> a0-5 owner) (the-as uint 2))
      (set! (-> a0-5 channel-mask) (the-as uint gp-0))
      (history-draw a0-5)
      )
    )
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defun-debug target-print-stats ((arg0 target) (arg1 symbol))
  (local-vars
    (sv-64 int)
    (sv-72 int)
    (sv-80 art-joint-anim-manager)
    (sv-96 string)
    (sv-112 string)
    (sv-128 string)
    (sv-144 string)
    (sv-160 string)
    (sv-176 string)
    (sv-192 string)
    (sv-208 string)
    (sv-224 string)
    (sv-240 string)
    (sv-256 string)
    (sv-272 string)
    (sv-288 string)
    (sv-304 string)
    )
  (with-pp
    (let ((s5-0 pp))
      (set! pp arg0)
      (when (and *display-ground-stats* arg0)
        (let ((s3-0 format)
              (s2-0 arg1)
              (s1-0 "~0kpoly:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-0 (-> arg0 control poly-pat))
              )
          (set! sv-96 (pat-mode->string (-> arg0 control poly-pat)))
          (set! sv-112 (pat-material->string (-> arg0 control poly-pat)))
          (let ((t1-0 (pat-event->string (-> arg0 control poly-pat))))
            (s3-0 s2-0 s1-0 s0-0 sv-96 sv-112 t1-0)
            )
          )
        (let ((s3-1 format)
              (s2-1 arg1)
              (s1-1 "~0kgrnd:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-1 (-> arg0 control ground-pat))
              )
          (set! sv-128 (pat-mode->string (-> arg0 control ground-pat)))
          (set! sv-144 (pat-material->string (-> arg0 control ground-pat)))
          (let ((t1-1 (pat-event->string (-> arg0 control ground-pat))))
            (s3-1 s2-1 s1-1 s0-1 sv-128 sv-144 t1-1)
            )
          )
        (let ((s3-2 format)
              (s2-2 arg1)
              (s1-2 "~0kwall:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-2 (-> arg0 control unknown-pat-surface00))
              )
          (set! sv-160 (pat-mode->string (-> arg0 control unknown-pat-surface00)))
          (set! sv-176 (pat-material->string (-> arg0 control unknown-pat-surface00)))
          (let ((t1-2 (pat-event->string (-> arg0 control unknown-pat-surface00))))
            (s3-2 s2-2 s1-2 s0-2 sv-160 sv-176 t1-2)
            )
          )
        (let ((s3-3 format)
              (s2-3 arg1)
              (s1-3 "~0kgspt:~6X  mode:~-8S  material:~-10S  event:~S~%")
              (s0-3 (-> arg0 control unknown-pat-surface01))
              )
          (set! sv-192 (pat-mode->string (-> arg0 control unknown-pat-surface01)))
          (set! sv-208 (pat-material->string (-> arg0 control unknown-pat-surface01)))
          (let ((t1-3 (pat-event->string (-> arg0 control unknown-pat-surface01))))
            (s3-3 s2-3 s1-3 s0-3 sv-192 sv-208 t1-3)
            )
          )
        )
      (when (and *stats-target* arg0)
        (format
          arg1
          "~0ks: ~M ~X/~X ~A ~A ~A~%"
          (-> arg0 control unknown-float05)
          (-> arg0 control status)
          (-> arg0 control prev-status)
          (if (-> arg0 state)
              (-> arg0 state name)
              )
          (-> arg0 control surf name)
          (-> arg0 control unknown-surface00 name)
          )
        (let ((s3-4 (-> arg0 focus-status)))
          (if (= (logand s3-4 (focus-status pole)) (focus-status pole))
              (format arg1 "pole ")
              )
          (if (= (logand s3-4 (focus-status dead)) (focus-status dead))
              (format arg1 "dead ")
              )
          (if (= (logand (focus-status gun) s3-4) (focus-status gun))
              (format arg1 "gun ")
              )
          (if (= (logand (focus-status mech) s3-4) (focus-status mech))
              (format arg1 "mech ")
              )
          (if (= (logand (focus-status pilot) s3-4) (focus-status pilot))
              (format arg1 "racer ")
              )
          (if (= (logand (focus-status shooting) s3-4) (focus-status shooting))
              (format arg1 "shooting ")
              )
          (if (= (logand (focus-status halfpipe) s3-4) (focus-status halfpipe))
              (format arg1 "halfpipe ")
              )
          (if (= (logand s3-4 (focus-status in-head)) (focus-status in-head))
              (format arg1 "in-head ")
              )
          (if (= (logand s3-4 (focus-status grabbed)) (focus-status grabbed))
              (format arg1 "grabbed ")
              )
          (if (= (logand s3-4 (focus-status ignore)) (focus-status ignore))
              (format arg1 "ignore ")
              )
          (if (= (logand s3-4 (focus-status under-water)) (focus-status under-water))
              (format arg1 "under-water ")
              )
          (if (= (logand s3-4 (focus-status disable)) (focus-status disable))
              (format arg1 "disable ")
              )
          (if (= (logand s3-4 (focus-status hit)) (focus-status hit))
              (format arg1 "hit ")
              )
          (if (= (logand s3-4 (focus-status inactive)) (focus-status inactive))
              (format arg1 "inactive ")
              )
          (if (= (logand s3-4 (focus-status dangerous)) (focus-status dangerous))
              (format arg1 "dangerous ")
              )
          (if (= (logand (focus-status teleporting) s3-4) (focus-status teleporting))
              (format arg1 "teleporting ")
              )
          (if (= (logand (focus-status indax) s3-4) (focus-status indax))
              (format arg1 "indax ")
              )
          (if (= (logand (focus-status tube) s3-4) (focus-status tube))
              (format arg1 "tube ")
              )
          (if (= (logand (focus-status pilot) s3-4) (focus-status pilot))
              (format arg1 "pilot ")
              )
          (if (= (logand s3-4 (focus-status edge-grab)) (focus-status edge-grab))
              (format arg1 "edge-grab ")
              )
          (if (= (logand (focus-status dark) s3-4) (focus-status dark))
              (format arg1 "dark ")
              )
          (if (= (logand (focus-status arrestable) s3-4) (focus-status arrestable))
              (format arg1 "arrestable ")
              )
          (if (= (logand (focus-status rail) s3-4) (focus-status rail))
              (format arg1 "rail ")
              )
          (if (= (logand (focus-status ice) s3-4) (focus-status ice))
              (format arg1 "ice ")
              )
          (if (= (logand s3-4 (focus-status pilot-riding)) (focus-status pilot-riding))
              (format arg1 "pilot-riding ")
              )
          (if (= (logand (focus-status board) s3-4) (focus-status board))
              (format arg1 "board ")
              )
          (if (= (logand s3-4 (focus-status on-water)) (focus-status on-water))
              (format arg1 "on-water ")
              )
          (if (= (logand s3-4 (focus-status in-air)) (focus-status in-air))
              (format arg1 "in-air ")
              )
          (if (= (logand (focus-status carry) s3-4) (focus-status carry))
              (format arg1 "carry ")
              )
          (if (= (logand s3-4 (focus-status flut)) (focus-status flut))
              (format arg1 "flut ")
              )
          (if (= (logand s3-4 (focus-status touch-water)) (focus-status touch-water))
              (format arg1 "touch-water ")
              )
          (if (= (logand (focus-status super) s3-4) (focus-status super))
              (format arg1 "super ")
              )
          )
        (if (logtest? (-> arg0 state-flags) (state-flags tinvul1))
            (format arg1 "tinvul1 ")
            )
        (if (logtest? (state-flags tinvul2) (-> arg0 state-flags))
            (format arg1 "tinvul2 ")
            )
        (if (logtest? (state-flags disable-attacks) (-> arg0 state-flags))
            (format arg1 "disable-attacks ")
            )
        (if (logtest? (state-flags lleg-still) (-> arg0 state-flags))
            (format arg1 "lleg-still ")
            )
        (if (logtest? (state-flags rleg-still) (-> arg0 state-flags))
            (format arg1 "rleg-still ")
            )
        (if (logtest? (state-flags lleg-no-ik) (-> arg0 state-flags))
            (format arg1 "lleg-no-ik ")
            )
        (if (logtest? (state-flags rleg-no-ik) (-> arg0 state-flags))
            (format arg1 "rleg-no-ik ")
            )
        (format arg1 "~%")
        (format
          arg1
          "~0k~9S ~9S ~9S ~9S ~9S ~9S~%"
          (if (logtest? (-> arg0 control status) (cshape-moving-flags on-surface))
              "on-surface"
              ""
              )
          (if (logtest? (-> arg0 control status) (cshape-moving-flags on-ground))
              "on-ground"
              ""
              )
          (if (logtest? (-> arg0 control status) (cshape-moving-flags t-surface))
              "t-surface"
              ""
              )
          (if (logtest? (-> arg0 control status) (cshape-moving-flags t-wall))
              "t-wall"
              ""
              )
          (if (logtest? (-> arg0 control status) (cshape-moving-flags t-act))
              "t-act"
              ""
              )
          (cond
            ((logtest? (-> arg0 control status) (cshape-moving-flags t-ceil))
             "t-ceil"
             )
            ((logtest? (-> arg0 control status) (cshape-moving-flags on-water))
             "on-water"
             )
            (else
              ""
              )
            )
          )
        (when (logtest? (-> arg0 water flags) (water-flags active))
          (format
            arg1
            "water at ~M ~5S ~5S ~5S ~5S "
            (-> arg0 water height)
            (if (logtest? (water-flags touch-water) (-> arg0 water flags))
                "water"
                ""
                )
            (if (logtest? (water-flags wading) (-> arg0 water flags))
                "wade"
                ""
                )
            (if (logtest? (water-flags swimming) (-> arg0 water flags))
                "swim"
                ""
                )
            (if (logtest? (-> arg0 water flags) (water-flags under-water))
                "under"
                ""
                )
            )
          (format arg1 "~2S~%" (if (logtest? (-> arg0 water flags) (water-flags swim-ground))
                                   "sg"
                                   ""
                                   )
                  )
          )
        (format
          arg1
          "~0kan:~,,3f su:~,,3f ti:~,,3f to:~,,3f pa:~,,3f~%"
          (-> arg0 control surface-angle)
          (-> arg0 control unknown-float17)
          (-> arg0 control unknown-float18)
          (-> arg0 control touch-angle)
          (-> arg0 control poly-angle)
          )
        (let ((v1-160 (-> arg0 control trans)))
          (format arg1 "pos: ~6,,2m ~6,,2m ~6,,2m  " (-> v1-160 x) (-> v1-160 y) (-> v1-160 z))
          )
        (let ((s3-5 format)
              (s2-4 arg1)
              (s1-4 "~0kpol:~X/~S/~S/~S~%")
              (s0-4 (-> arg0 control poly-pat))
              )
          (set! sv-224 (pat-mode->string (-> arg0 control poly-pat)))
          (set! sv-240 (pat-material->string (-> arg0 control poly-pat)))
          (let ((t1-10 (pat-event->string (-> arg0 control poly-pat))))
            (s3-5 s2-4 s1-4 s0-4 sv-224 sv-240 t1-10)
            )
          )
        (let ((s3-6 format)
              (s2-5 arg1)
              (s1-5 "~0kcur:~X/~S/~S/~S   ")
              (s0-5 (-> arg0 control cur-pat))
              )
          (set! sv-256 (pat-mode->string (-> arg0 control cur-pat)))
          (set! sv-272 (pat-material->string (-> arg0 control cur-pat)))
          (let ((t1-11 (pat-event->string (-> arg0 control cur-pat))))
            (s3-6 s2-5 s1-5 s0-5 sv-256 sv-272 t1-11)
            )
          )
        (let ((s3-7 format)
              (s2-6 arg1)
              (s1-6 "~0kgnd:~X/~S/~S/~S~%")
              (s0-6 (-> arg0 control ground-pat))
              )
          (set! sv-288 (pat-mode->string (-> arg0 control ground-pat)))
          (set! sv-304 (pat-material->string (-> arg0 control ground-pat)))
          (let ((t1-12 (pat-event->string (-> arg0 control ground-pat))))
            (s3-7 s2-6 s1-6 s0-6 sv-288 sv-304 t1-12)
            )
          )
        (let ((t9-74 format)
              (a0-129 arg1)
              (a1-54 "~0kvel: x:~M  y:~M  z:~M   yv:~M  xzv:~M~%")
              (a2-13 (-> arg0 control transv x))
              (a3-14 (-> arg0 control transv y))
              (t0-14 (-> arg0 control transv z))
              (t1-14 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv)))
              (v1-180 (new-stack-vector0))
              )
          (let ((f0-15 (vector-dot (-> arg0 control dynam gravity-normal) (-> arg0 control transv))))
            0.0
            (vector-!
              v1-180
              (-> arg0 control transv)
              (the-as vector (vector-float*! v1-180 (-> arg0 control dynam gravity-normal) f0-15))
              )
            )
          (let ((f0-16 (vector-length v1-180)))
            f0-16
            (t9-74 a0-129 a1-54 a2-13 a3-14 t0-14 t1-14 f0-16)
            )
          )
        (format
          arg1
          "~0ky:~,,2M t:~d cy: ~,,2M my: ~,,2M impv:~,,2M "
          (-> arg0 control unknown-vector21 y)
          (- (-> (the-as target pp) clock frame-counter) (-> arg0 control unknown-time-frame06))
          (- (-> arg0 control trans y) (-> arg0 control unknown-vector21 y))
          (- (-> arg0 control unknown-vector37 y) (-> arg0 control unknown-vector36 y))
          (-> arg0 control ground-impact-vel)
          )
        (let* ((t9-76 format)
               (a0-131 arg1)
               (a1-56 "~0k~Tcd: ~,,2M md:~,,2M~%")
               (v1-191 (vector-! (new-stack-vector0) (-> arg0 control trans) (-> arg0 control unknown-vector21)))
               (a2-17 (sqrtf (+ (* (-> v1-191 x) (-> v1-191 x)) (* (-> v1-191 z) (-> v1-191 z)))))
               (v1-193 (vector-! (new-stack-vector0) (-> arg0 control unknown-vector37) (-> arg0 control unknown-vector36)))
               )
          (t9-76 a0-131 a1-56 a2-17 (sqrtf (+ (* (-> v1-193 x) (-> v1-193 x)) (* (-> v1-193 z) (-> v1-193 z)))))
          )
        (format
          arg1
          "~0kbend b:~F t:~F s:~F~%"
          (-> arg0 control unknown-float27)
          (-> arg0 control unknown-float28)
          (-> arg0 control unknown-float29)
          )
        (set! sv-64 0)
        (set! sv-72 0)
        (set! sv-80 *anim-manager*)
        (countdown (s3-8 (-> sv-80 free-index))
          (when (= (-> sv-80 slot s3-8 time-stamp) (-> *display* base-clock frame-counter))
            (set! sv-72 (+ sv-72 1))
            (set! sv-64 (+ sv-64 (used-bytes-for-slot sv-80 s3-8)))
            )
          )
        (format
          arg1
          "anim cache ~d anims ~dK total, ~d ~dK active~%"
          (-> sv-80 free-index)
          (sar (&- (-> sv-80 kheap current) (the-as uint (-> sv-80 kheap base))) 10)
          sv-72
          (sar sv-64 10)
          )
        (debug-print-channels (-> arg0 skel) arg1)
        )
      (draw-history (-> arg0 control))
      (set! pp s5-0)
      )
    #f
    )
  )

(defbehavior read-pad target ((arg0 vector))
  (when (!= (-> self control unknown-dword01) (-> *display* real-clock frame-counter))
    (set! (-> self control unknown-vector13 quad) (-> self control unknown-vector12 quad))
    (set! (-> self control unknown-float13) (-> self control unknown-float12))
    (set! (-> self control unknown-dword01) (the-as int (-> *display* real-clock frame-counter)))
    )
  (set! (-> arg0 x) (sin (-> self control unknown-cpad-info00 stick0-dir)))
  (set! (-> arg0 y) 0.0)
  (set! (-> arg0 z) (cos (-> self control unknown-cpad-info00 stick0-dir)))
  (set! (-> arg0 w) 0.0)
  (set! (-> self control unknown-vector12 quad) (-> arg0 quad))
  (set! (-> self control unknown-float12) (-> self control unknown-cpad-info00 stick0-speed))
  (when (< (-> self control unknown-dword02) (-> self clock frame-counter))
    (let ((s5-0 (-> self control unknown-matrix03))
          (t9-2 matrix-local->world)
          (a0-13 #t)
          )
      (let* ((a2-0 (t9-2 a0-13))
             (v1-24 (-> a2-0 vector 0 quad))
             (a0-14 (-> a2-0 vector 1 quad))
             (a1-1 (-> a2-0 vector 2 quad))
             (a2-1 (-> a2-0 trans quad))
             )
        (set! (-> s5-0 vector 0 quad) v1-24)
        (set! (-> s5-0 vector 1 quad) a0-14)
        (set! (-> s5-0 vector 2 quad) a1-1)
        (set! (-> s5-0 trans quad) a2-1)
        )
      )
    )
  (vector-matrix*! arg0 arg0 (-> self control unknown-matrix03))
  )

(defbehavior set-pad target ((arg0 vector))
  (set! (-> self control unknown-float12) (vector-length arg0))
  (let ((s5-0 vector-matrix*!)
        (s4-0 (-> self control unknown-vector12))
        (s3-0 arg0)
        (t9-0 matrix-world->local)
        )
    #t
    (s5-0 s4-0 s3-0 (t9-0))
    )
  arg0
  )

(defun warp-vector-into-surface! ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 matrix))
  (let ((a2-1 (matrix-from-two-vectors! (new-stack-matrix0) (-> arg3 vector 1) arg2)))
    (vector-matrix*! arg0 arg1 a2-1)
    )
  )

(defbehavior vector<-pad-in-surface! target ((arg0 vector) (arg1 symbol))
  (let ((a1-1 (read-pad (new-stack-vector0))))
    (warp-vector-into-surface! arg0 a1-1 (-> self control local-normal) (-> self control unknown-matrix03))
    )
  (if arg1
      (vector-float*! arg0 arg0 (-> self control unknown-float12))
      )
  arg0
  )

;; WARN: Return type mismatch vector vs none.
(defun vector<-pad-in-matrix! ((arg0 vector) (arg1 cpad-info) (arg2 matrix))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (t9-0 matrix-local->world)
        (a0-1 #t)
        )
    (let ((s5-0 (t9-0 a0-1)))
      (set! (-> gp-0 x) (* -0.0078125 (+ -128.0 (the float (-> arg1 leftx)))))
      (set! (-> gp-0 y) 0.0)
      (set! (-> gp-0 z) (* -0.0078125 (+ -128.0 (the float (-> arg1 lefty)))))
      (set! (-> gp-0 w) 0.0)
      (let ((f30-0 (vector-length gp-0)))
        (vector-matrix*! gp-0 gp-0 s5-0)
        (warp-vector-into-surface! arg0 gp-0 (-> arg2 vector 1) s5-0)
        (vector-matrix*! arg0 arg0 arg2)
        (vector-normalize! arg0 f30-0)
        )
      )
    )
  (none)
  )

(defbehavior local-pad-angle target ()
  (let ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f)))
    (vector-dot
      (vector-normalize! a0-1 1.0)
      (vector-z-quaternion! (new-stack-vector0) (-> self control unknown-quaternion00))
      )
    )
  )

(defbehavior turn-around? target ()
  (let* ((a0-1 (vector<-pad-in-surface! (new-stack-vector0) #f))
         (gp-0 (vector-normalize! a0-1 1.0))
         (t9-2 vector-normalize!)
         (a0-2 (new-stack-vector0))
         )
    (set! (-> a0-2 quad) (-> self control transv quad))
    (let ((f0-1 (vector-dot gp-0 (t9-2 a0-2 1.0)))
          (a1-3 (-> self control unknown-vector-array02))
          (f2-0 -1000.0)
          (f1-0 0.0)
          (a0-3 -1)
          (v1-7 (new 'static 'array time-frame 1 (seconds 0)))
          )
      (countdown (a2-0 15)
        (let ((a3-2 (-> a1-3 a2-0 quad)))
          (set! (-> a1-3 (+ a2-0 1) quad) a3-2)
          )
        )
      (set! (-> a1-3 0 quad) (-> self control transv quad))
      (set! (-> a1-3 0 w) (-> self control unknown-float05))
      (dotimes (a2-6 16)
        (+! f1-0 (-> a1-3 a2-6 w))
        (when (< f2-0 (-> a1-3 a2-6 w))
          (set! a0-3 a2-6)
          (set! f2-0 (-> a1-3 a2-6 w))
          )
        )
      (let ((f1-1 (* 0.0625 f1-0)))
        (set! (-> self control unknown-word02) a0-3)
        (set! (-> self control unknown-float32) f1-1)
        (if (logtest? (-> self control unknown-surface01 flags) (surface-flag no-turn-around))
            (set! (-> v1-7 0) (-> self clock frame-counter))
            )
        (and (>= (the-as uint (- (-> self clock frame-counter) (-> v1-7 0))) (the-as uint 300))
             (< f0-1 0.0)
             (< 32768.0 f1-1)
             (< 0.7 (-> self control unknown-float12))
             (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame07)) (seconds 0.3))
             (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame08)) (seconds 0.3))
             (logtest? (-> self control status) (cshape-moving-flags on-surface))
             (and (< 0.7 (-> self control surface-angle)) #t)
             )
        )
      )
    )
  )

(defbehavior wall-hide? target ()
  (when (and (< 0.7 (-> self control unknown-float12))
             (< 0.7 (-> self control unknown-float26))
             (and (< (-> self control unknown-float05) 8192.0)
                  (logtest? (-> self control status) (cshape-moving-flags t-wall))
                  (zero? (logand (-> self control status) (cshape-moving-flags t-act)))
                  (or (= (-> self control unknown-pat-surface00 event) (pat-event hide))
                      (let ((a0-2 (level-get-target-inside *level*)))
                        (and a0-2 (logtest? (-> a0-2 info level-flags) 1))
                        )
                      )
                  )
             )
    (if (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame22)) (seconds 0.1))
        (set! (-> self control unknown-time-frame23) (-> self clock frame-counter))
        )
    (set! (-> self control unknown-time-frame22) (-> self clock frame-counter))
    (when (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame23)) (seconds 0.5))
      (let ((gp-0 (new 'stack-no-clear 'collide-query)))
        (let ((v1-34 (-> gp-0 bbox))
              (a0-13 (-> self control trans))
              (a1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-0 x) 8192.0)
          (set! (-> a1-0 y) 10240.0)
          (set! (-> a1-0 z) 8192.0)
          (set! (-> a1-0 w) 1.0)
          (vector-! (the-as vector v1-34) a0-13 a1-0)
          )
        (let ((v1-36 (-> gp-0 bbox max))
              (a0-15 (-> self control trans))
              (a1-1 (new 'stack-no-clear 'vector))
              )
          (set! (-> a1-1 x) 8192.0)
          (set! (-> a1-1 y) 10240.0)
          (set! (-> a1-1 z) 8192.0)
          (set! (-> a1-1 w) 1.0)
          (vector+! v1-36 a0-15 a1-1)
          )
        (set! (-> gp-0 collide-with) (-> self control root-prim prim-core collide-with))
        (set! (-> gp-0 ignore-process0) self)
        (set! (-> gp-0 ignore-process1) #f)
        (set! (-> gp-0 ignore-pat) (-> self control pat-ignore-mask))
        (collide-cache-method-12 *collide-cache* gp-0)
        (dotimes (s5-0 3)
          (set! (-> gp-0 start-pos quad) (-> self control unknown-sphere-array00 s5-0 prim-core world-sphere quad))
          (vector-float*! (-> gp-0 move-dist) (-> self control unknown-vector25) -8192.0)
          (let ((v1-48 gp-0))
            (set! (-> v1-48 radius) 4.096)
            (set! (-> v1-48 collide-with) (-> gp-0 collide-with))
            (set! (-> v1-48 ignore-process0) #f)
            (set! (-> v1-48 ignore-process1) #f)
            (set! (-> v1-48 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
            (set! (-> v1-48 action-mask) (collide-action solid))
            )
          (cond
            ((and (>= (collide-cache-method-16 *collide-cache* gp-0) 0.0)
                  (< 0.8 (vector-dot (-> gp-0 best-other-tri normal) (-> self control unknown-vector25)))
                  )
             )
            (else
              (return #f)
              )
            )
          )
        )
      #t
      )
    )
  )

;; WARN: Return type mismatch int vs none.
(defbehavior target-log-trans target ()
  (let ((v1-1 (-> self control unknown-word00)))
    (set! (-> self control unknown-time-frame-array00 v1-1) (-> self clock frame-counter))
    (set! (-> self control unknown-vector-array00 v1-1 quad) (-> self control trans quad))
    (set! (-> self control unknown-word00) (logand (+ v1-1 1) 127))
    )
  0
  (none)
  )

(defbehavior target-move-dist target ((arg0 time-frame))
  (let ((s5-0 (new-stack-vector0))
        (f30-0 0.0)
        (gp-0 0)
        )
    (let ((s4-0 (-> self control)))
      (let* ((v1-0 127)
             (a1-2 (logand (+ (-> s4-0 unknown-word00) v1-0) 127))
             )
        (while (and (< (- (-> self clock frame-counter) (-> s4-0 unknown-time-frame-array00 a1-2)) arg0) (> v1-0 0))
          (vector+! s5-0 s5-0 (-> s4-0 unknown-vector-array00 a1-2))
          (+! gp-0 1)
          (+! v1-0 -1)
          (set! a1-2 (logand (+ a1-2 v1-0) 127))
          )
        )
      (vector-float/! s5-0 s5-0 (the float gp-0))
      (let ((s3-0 (- 128 gp-0)))
        (while (< s3-0 128)
          (let ((v1-5 (logand (+ (-> s4-0 unknown-word00) s3-0) 127)))
            (+! f30-0 (vector-vector-distance s5-0 (-> s4-0 unknown-vector-array00 v1-5)))
            )
          (+! s3-0 1)
          )
        )
      )
    (/ f30-0 (the float gp-0))
    )
  )

(defbehavior turn-to-vector target ((arg0 vector) (arg1 float))
  (let ((gp-0 (new-stack-vector0)))
    (warp-vector-into-surface! gp-0 arg0 (-> self control local-normal) (-> self control unknown-matrix03))
    (set! (-> self control unknown-float11) (-> self control unknown-float10))
    (set! (-> self control unknown-float09) (-> self control unknown-float08))
    (set! (-> self control unknown-vector08 quad) (-> self control unknown-vector07 quad))
    (set! (-> self control unknown-vector10 quad) (-> self control unknown-vector09 quad))
    (vector-float*! (-> self control unknown-vector09) gp-0 arg1)
    (if (< 0.0 arg1)
        (warp-vector-into-surface!
          (-> self control unknown-vector07)
          arg0
          *up-vector*
          (-> self control unknown-matrix03)
          )
        )
    (dotimes (v1-17 7)
      (set! (-> self control unknown-vector-array01 (+ v1-17 1) quad)
            (-> self control unknown-vector-array01 v1-17 quad)
            )
      )
    (set! (-> self control unknown-vector-array01 0 quad)
          (-> (vector-matrix*! gp-0 gp-0 (-> self control unknown-matrix00)) quad)
          )
    (let ((f0-6 (atan (-> gp-0 x) (-> gp-0 z))))
      (set! (-> self control unknown-float10) arg1)
      (set! (-> self control unknown-float08) f0-6)
      )
    (let ((f0-8 (* arg1 (-> self control unknown-surface01 target-speed))))
      (set! (-> self control unknown-vector01 quad) (-> (vector-normalize! gp-0 f0-8) quad))
      )
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control unknown-vector01) (-> self control unknown-matrix01))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id bucket-318)
      gp-1
      (the-as meters #x444ccccd)
      "target"
      (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
      )
    )
  )

(defbehavior target-bend-vel-turn target ((arg0 vector))
  (cond
    ((= (-> self control unknown-surface01 vel-turn) 0.0)
     )
    ((< (-> self control unknown-surface01 vel-turn) 0.0)
     (let* ((v1-5 arg0)
            (f0-6 (sqrtf (+ (* (-> v1-5 x) (-> v1-5 x)) (* (-> v1-5 z) (-> v1-5 z)))))
            )
       (set-vector! arg0 0.0 (-> arg0 y) f0-6 1.0)
       )
     )
    (else
      (let ((f0-10 (atan (-> arg0 x) (-> arg0 z))))
        (vector-rotate-y!
          arg0
          arg0
          (fmin
            (* 0.03 (-> self clock time-adjust-ratio) (- f0-10))
            (* (-> self control unknown-surface01 vel-turn) (-> self clock seconds-per-frame))
            )
          )
        )
      )
    )
  arg0
  )

(defbehavior target-add-slide-factor target ((arg0 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (let* ((a1-2 (vector-flatten!
                   (new 'stack-no-clear 'vector)
                   (vector-negate! (new-stack-vector0) (-> self control dynam gravity-normal))
                   (-> self control local-normal)
                   )
                 )
           (s4-1 (vector-matrix*! (new 'stack-no-clear 'vector) a1-2 (-> self control unknown-matrix00)))
           (s5-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) s4-1 1.0))
           )
      (let ((v1-4 arg0))
        (let ((a0-5 arg0)
              (a1-4 s4-1)
              (f0-0 (-> self control unknown-surface01 slide-factor))
              )
          (.lvf vf2 (&-> a1-4 quad))
          (.lvf vf1 (&-> a0-5 quad))
          (let ((a0-6 f0-0))
            (.mov vf3 a0-6)
            )
          )
        (.add.x.vf vf4 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf2 vf3)
        (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
        (.svf (&-> v1-4 quad) vf4)
        )
      (let ((a1-5 (-> self control unknown-vector26)))
        (when (not (or (= (- 1.0 (-> self control unknown-surface01 slope-up-traction)) 0.0) (< (vector-length s4-1) 0.1)))
          (let* ((a0-8 (vector-matrix*! (new 'stack-no-clear 'vector) a1-5 (-> self control unknown-matrix00)))
                 (v1-14 (new-stack-vector0))
                 (f0-5 (vector-dot a0-8 arg0))
                 )
            0.0
            (vector-! v1-14 arg0 (the-as vector (vector-float*! v1-14 a0-8 f0-5)))
            (let* ((f1-5 (vector-length v1-14))
                   (f2-0 f1-5)
                   )
              (if (< f0-5 0.0)
                  (set! f0-5 (* f0-5 (-> self control unknown-surface01 slope-up-traction)))
                  )
              (let ((f0-6 (+ f0-5 (-> self control unknown-surface01 slope-down-factor))))
                (vector+!
                  arg0
                  (the-as vector (vector-float*! arg0 a0-8 f0-6))
                  (the-as vector (vector-float*! v1-14 v1-14 (/ f1-5 f2-0)))
                  )
                )
              )
            )
          )
        )
      (let ((t9-5 vector-xz-normalize!)
            (a0-11 (new-stack-vector0))
            )
        (set! (-> a0-11 quad) (-> arg0 quad))
        (let ((v1-17 (t9-5 a0-11 1.0)))
          (set! (-> v1-17 y) 0.0)
          (let* ((f0-10 (vector-dot s5-1 v1-17))
                 (v1-19 arg0)
                 (f1-10 (sqrtf (+ (* (-> v1-19 x) (-> v1-19 x)) (* (-> v1-19 z) (-> v1-19 z)))))
                 )
            (if (>= f0-10 0.0)
                (vector-xz-normalize!
                  arg0
                  (fmax 0.0 (+ f1-10 (* f0-10 (-> self control unknown-surface01 slope-down-factor))))
                  )
                (vector-xz-normalize!
                  arg0
                  (fmax 0.0 (- f1-10 (* (- f0-10) (-> self control unknown-surface01 slope-up-factor))))
                  )
                )
            )
          )
        )
      )
    arg0
    )
  )

(defbehavior add-thrust target ()
  (let ((s5-0 (-> self control unknown-vector01))
        (gp-0 (-> self control unknown-vector00))
        )
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (set! (-> s4-0 quad) (-> self control unknown-vector01 quad))
      (target-bend-vel-turn gp-0)
      (target-add-slide-factor s5-0)
      (let ((t9-2 vector-xz-normalize!)
            (a0-2 (new-stack-vector0))
            )
        (set! (-> a0-2 quad) (-> s5-0 quad))
        (let ((s3-0 (t9-2 a0-2 1.0)))
          (let ((t9-3 vector-xz-normalize!)
                (a0-3 (new-stack-vector0))
                )
            (set! (-> a0-3 quad) (-> gp-0 quad))
            (let ((v1-9 (t9-3 a0-3 1.0)))
              (set! (-> s3-0 y) 0.0)
              (set! (-> v1-9 y) 0.0)
              )
            )
          (let* ((f0-2 (-> s3-0 z))
                 (v1-10 gp-0)
                 (f1-4 (sqrtf (+ (* (-> v1-10 x) (-> v1-10 x)) (* (-> v1-10 z) (-> v1-10 z)))))
                 (v1-12 s5-0)
                 (f30-0 (cond
                          ((>= f1-4 (sqrtf (+ (* (-> v1-12 x) (-> v1-12 x)) (* (-> v1-12 z) (-> v1-12 z)))))
                           (let ((f0-3 (-> self control unknown-surface01 fric))
                                 (f1-5 1.0)
                                 (v1-17 gp-0)
                                 )
                             (* f0-3 (fmax f1-5 (/ (sqrtf (+ (* (-> v1-17 x) (-> v1-17 x)) (* (-> v1-17 z) (-> v1-17 z))))
                                                   (-> self control unknown-surface01 nonlin-fric-dist)
                                                   )
                                           )
                                )
                             )
                           )
                          ((>= f0-2 0.0)
                           (+ (* f0-2 (-> self control unknown-surface01 seek0))
                              (* (- 1.0 f0-2) (-> self control unknown-surface01 seek90))
                              )
                           )
                          (else
                            (+ (* (fabs f0-2) (-> self control unknown-surface01 seek180))
                               (* (+ 1.0 f0-2) (-> self control unknown-surface01 seek90))
                               )
                            )
                          )
                        )
                 )
            (let* ((s2-0 (-> self control unknwon-vector27))
                   (s3-1 (vector-matrix*! (new 'stack-no-clear 'vector) s2-0 (-> self control unknown-matrix00)))
                   )
              (if (< (-> s4-0 x) 0.0)
                  (set! (-> s3-1 x) (fmax (fmin 0.0 (-> s3-1 x)) (-> s4-0 x)))
                  (set! (-> s3-1 x) (fmax 0.0 (fmin (-> s3-1 x) (-> s4-0 x))))
                  )
              (if (< (-> s4-0 y) 0.0)
                  (set! (-> s3-1 y) (fmax (fmin 0.0 (-> s3-1 y)) (-> s4-0 y)))
                  (set! (-> s3-1 y) (fmax 0.0 (fmin (-> s3-1 y) (-> s4-0 y))))
                  )
              (if (< (-> s4-0 z) 0.0)
                  (set! (-> s3-1 z) (fmax (fmin 0.0 (-> s3-1 z)) (-> s4-0 z)))
                  (set! (-> s3-1 z) (fmax 0.0 (fmin (-> s3-1 z) (-> s4-0 z))))
                  )
              (if (< 0.2 (-> self control unknown-float26))
                  (vector-seek! s3-1 s4-0 (* 122880.0 (-> self clock seconds-per-frame)))
                  )
              (vector-matrix*! s2-0 s3-1 (-> self control unknown-matrix01))
              (let ((f28-0 (vector-vector-xz-distance s3-1 s4-0)))
                (when (and (zero? (logand (-> self control status) (cshape-moving-flags t-surface)))
                           (let ((v1-51 gp-0))
                             (< (sqrtf (+ (* (-> v1-51 x) (-> v1-51 x)) (* (-> v1-51 z) (-> v1-51 z))))
                                (sqrtf (+ (* (-> s3-1 x) (-> s3-1 x)) (* (-> s3-1 z) (-> s3-1 z))))
                                )
                             )
                           )
                  (let ((f0-37 (lerp-scale 163840.0 0.0 f28-0 0.0 20480.0)))
                    (if (and (< f28-0 20480.0) (< (-> s4-0 z) 0.0))
                        (set! f0-37 (* 2.0 f0-37))
                        )
                    (+! f30-0 f0-37)
                    )
                  )
                )
              )
            (if (and (zero? (logand (-> self control status) (cshape-moving-flags t-wall)))
                     (logtest? (-> self control old-status) (cshape-moving-flags t-wall))
                     (logtest? (-> self control unknown-surface00 flags) (surface-flag air))
                     (< 0.0 (-> gp-0 y))
                     (< 0.0 (vector-dot
                              (-> self control dynam gravity-normal)
                              (vector-!
                                (new 'stack-no-clear 'vector)
                                (the-as vector (-> self control unknown-sphere-array00 1 prim-core))
                                (-> self control unknown-vector24)
                                )
                              )
                        )
                     )
                (set! (-> self control unknown-time-frame09) (-> self clock frame-counter))
                )
            (if (< (- (-> self clock frame-counter) (-> self control unknown-time-frame09)) (seconds 0.2))
                (set! f30-0 (+ 204800.0 f30-0))
                )
            (if (and (zero? (logand (-> self control status) (cshape-moving-flags t-wall)))
                     (and (logtest? (-> self control old-status) (cshape-moving-flags t-wall))
                          (logtest? (-> self control unknown-surface00 flags) (surface-flag air))
                          (< 0.0 (-> gp-0 y))
                          (< (-> gp-0 z) 0.0)
                          )
                     )
                (set! (-> gp-0 z) 0.0)
                )
            (let ((s4-2 (vector-! (new-stack-vector0) s5-0 gp-0)))
              (let ((f0-45 (* f30-0 (-> self clock seconds-per-frame))))
                (set! (-> s4-2 y) 0.0)
                (let ((v1-104 s4-2))
                  (if (< f0-45 (sqrtf (+ (* (-> v1-104 x) (-> v1-104 x)) (* (-> v1-104 z) (-> v1-104 z)))))
                      (vector-xz-normalize! s4-2 f0-45)
                      )
                  )
                )
              (vector+! gp-0 gp-0 s4-2)
              )
            )
          )
        )
      )
    (set! (-> self control unknown-float07) (vector-length gp-0))
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control unknown-vector00) (-> self control unknown-matrix01))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id bucket-318)
      gp-1
      (the-as meters #x444ccccd)
      "ltransv"
      (the-as rgba (-> (new 'static 'array uint64 1 #x8000ff00) 0))
      )
    (set! (-> gp-1 quad) (-> self control unknwon-vector27 quad))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id bucket-318)
      gp-1
      (the-as meters #x444ccccd)
      "btransv"
      (the-as rgba (-> (new 'static 'array uint64 1 #x80ffffff) 0))
      )
    )
  )

(defbehavior add-gravity target ()
  (let ((s5-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (let* ((a0-0 (-> self control))
           (t9-0 (method-of-object a0-0 collide-shape-moving-method-62))
           )
      (-> self control unknown-surface01 slip-factor)
      (t9-0 a0-0)
      )
    (vector-matrix*! gp-0 s5-0 (-> self control unknown-matrix00))
    (vector-v++! (-> self control unknown-vector00) gp-0)
    )
  (let* ((a0-4 (vector-matrix*!
                 (new 'stack-no-clear 'vector)
                 (-> self control dynam gravity-normal)
                 (-> self control unknown-matrix00)
                 )
               )
         (v1-9 (new-stack-vector0))
         (f0-2 (vector-dot a0-4 (-> self control unknown-vector00)))
         )
    0.0
    (vector-! v1-9 (-> self control unknown-vector00) (the-as vector (vector-float*! v1-9 a0-4 f0-2)))
    (let* ((f1-2 (vector-length v1-9))
           (f2-0 f1-2)
           )
      (if (< f1-2 0.00004096)
          (set! f1-2 0.0)
          )
      (if (< f0-2 (- (-> self control dynam gravity-max)))
          (set! f0-2 (- (-> self control dynam gravity-max)))
          )
      (vector+!
        (-> self control unknown-vector00)
        (the-as vector (vector-float*! (-> self control unknown-vector00) a0-4 f0-2))
        (the-as vector (vector-float*! v1-9 v1-9 (/ f1-2 f2-0)))
        )
      )
    )
  )

(defbehavior target-compute-slopes target ((arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector))
        (s4-0 (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00)))
        (s3-0 (new 'stack-no-clear 'matrix))
        (s5-0 (vector-flatten!
                (new 'stack-no-clear 'vector)
                (-> self control dynam gravity-normal)
                (-> self control local-normal)
                )
              )
        )
    (forward-up-nopitch->inv-matrix s3-0 (-> self control unknown-matrix01 vector 2) arg0)
    (set-vector! gp-0 0.0 0.0 1.0 1.0)
    (vector-matrix*! gp-0 gp-0 s3-0)
    (set! (-> self control unknown-float19) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control unknown-float17) (- (vector-dot (-> self control local-normal) gp-0)))
    (set! (-> self control unknown-float21) (- (vector-dot (-> self control gspot-normal) gp-0)))
    (set! (-> self control unknown-float24) (- (vector-dot s4-0 gp-0)))
    (set-vector! gp-0 1.0 0.0 0.0 1.0)
    (vector-matrix*! gp-0 gp-0 s3-0)
    (set! (-> self control unknown-float20) (- (vector-dot (-> self control surface-normal) gp-0)))
    (set! (-> self control unknown-float18) (- (vector-dot (-> self control local-normal) gp-0)))
    (set! (-> self control unknown-float22) (- (vector-dot (-> self control gspot-normal) gp-0)))
    (set! (-> self control unknown-float25) (- (vector-dot s4-0 gp-0)))
    (set-vector! gp-0 1.0 0.0 0.0 1.0)
    (vector-matrix*! gp-0 gp-0 (-> self control unknown-matrix01))
    (set! (-> self control unknown-float23) (vector-dot gp-0 s5-0))
    )
  0
  )

(defbehavior do-rotations1 target ()
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    0.0
    (-> self control unknown-surface01 tiltv)
    150
    (the-as float (the int (-> self control unknown-surface01 tiltvf)))
    0.0
    )
  )

(defbehavior do-rotations2 target ()
  (let ((gp-0 (vector-z-quaternion! (new-stack-vector0) (-> self control dir-targ)))
        (s5-0
          (cond
            ((logtest? (surface-flag turn-to-alt) (-> self control unknown-surface01 flags))
             (-> self control unknown-vector03)
             )
            ((and (or (zero? (logand (logior (-> self control status) (-> self control old-status))
                                     (cshape-moving-flags on-surface t-surface)
                                     )
                             )
                      (< (- (-> self clock frame-counter) (-> self control unknown-time-frame07)) (seconds 0.5))
                      (not (and (-> self next-state) (let ((v1-15 (-> self next-state name)))
                                                       (or (= v1-15 'target-walk) (= v1-15 'target-gun-walk))
                                                       )
                                )
                           )
                      (< (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.5))
                      (< (- (-> self clock frame-counter) (-> self control unknown-time-frame08)) (seconds 0.5))
                      (logtest? (-> self control unknown-surface01 flags) (surface-flag turn-to-pad))
                      (!= (-> self control unknown-float15) 0.0)
                      )
                  (zero? (logand (-> self control unknown-surface01 flags) (surface-flag turn-to-vel)))
                  )
             (-> self control unknown-vector07)
             )
            (else
              (-> self control transv)
              )
            )
          )
        )
    (let* ((s3-0 (-> self control unknown-vector02))
           (s4-0 (forward-up-nopitch->quaternion (new-stack-quaternion0) gp-0 s3-0))
           (s3-1 (forward-up-nopitch->quaternion (new-stack-quaternion0) s5-0 s3-0))
           (f0-2 (acos (vector-dot gp-0 s5-0)))
           (f1-2 (* (-> self control unknown-surface01 turnvv) (-> self clock seconds-per-frame)))
           )
      (quaternion-slerp!
        (-> self control dir-targ)
        s4-0
        s3-1
        (cond
          ((and (or (>= 0.0 (-> self control unknown-float10))
                    (< (-> self clock frame-counter) (-> self control unknown-time-frame00))
                    )
                (zero? (logand (-> self control unknown-surface01 flags) (surface-flag turn-when-centered)))
                )
           0.0
           )
          ((< f0-2 f1-2)
           1.0
           )
          (else
            (/ f1-2 f0-2)
            )
          )
        )
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id bucket-318)
      (-> self control trans)
      gp-0
      (the-as meters #x46000000)
      (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
      )
    (add-debug-vector
      *display-target-marks*
      (bucket-id bucket-318)
      (-> self control trans)
      s5-0
      (the-as meters #x46000000)
      (the-as rgba (-> (new 'static 'array uint64 1 #x800080ff) 0))
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id bucket-318)
    (-> self control trans)
    (-> self control unknown-matrix01 vector 2)
    (the-as meters #x46000000)
    (the-as rgba (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
    )
  (rotate-toward-orientation!
    (-> self control)
    (-> self control dir-targ)
    (-> self control unknown-surface01 turnv)
    0.0
    (the int (-> self control unknown-surface01 turnvf))
    0.00000000000000000000000000000000000000000021
    (-> self control unknown-float06)
    )
  (if (and (!= (-> self control unknown-float06) 0.0)
           (< (fabs
                (deg-diff
                  (quaternion-y-angle (-> self control unknown-quaternion00))
                  (quaternion-y-angle (-> self control dir-targ))
                  )
                )
              182.04445
              )
           )
      (set! (-> self control unknown-float06) 0.0)
      )
  (quaternion-slerp!
    (-> self control quat)
    (-> self control unknown-quaternion00)
    (-> self control unknown-quaternion01)
    (-> self control unknown-float04)
    )
  (target-compute-slopes (-> self control dynam gravity-normal))
  )

(defun leg-ik-callback ((arg0 joint-mod-ik) (arg1 object) (arg2 object) (arg3 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg3 quad))
      (let ((f0-1 (- (-> arg3 y) (-> (target-pos 0) y))))
        (if (< 1228.8 f0-1)
            (set! f0-1 1228.8)
            )
        (if (< f0-1 409.6)
            (set! f0-1 409.6)
            )
        (+! (-> arg0 user-position y) f0-1)
        )
      (let* ((f0-4
               (vector-dot (-> arg0 user-normal) (vector-! (new 'stack-no-clear 'vector) arg3 (-> arg0 user-position)))
               )
             (f30-1 (lerp-scale 1.0 0.0 f0-4 0.0 2048.0))
             (s3-0 (new 'stack-no-clear 'vector))
             )
        (let ((v1-13 s5-0))
          (let ((a0-4 (-> arg0 user-normal)))
            (let ((a1-4 4096.0))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.lvf vf4 (&-> v1-13 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s3-0 quad) vf6)
        (vector-float*! (new 'stack-no-clear 'vector) (-> arg0 user-normal) -8192.0)
        (let ((s4-1 (new 'stack-no-clear 'vector)))
          0.0
          (let ((f0-8 (intersect-ray-plane s3-0 (-> arg0 user-normal) (-> arg0 user-position) (-> arg0 user-normal)))
                (a0-7 s4-1)
                )
            (let ((v1-16 (-> arg0 user-normal)))
              (let ((a1-7 f0-8))
                (.mov vf7 a1-7)
                )
              (.lvf vf5 (&-> v1-16 quad))
              )
            (.lvf vf4 (&-> s3-0 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-7 quad) vf6)
            )
          (let ((a1-8 s4-1))
            (let ((v1-17 s4-1))
              (let ((a0-8 (-> arg0 user-normal)))
                (let ((a2-6
                        (- (vector-dot (-> arg0 user-normal) (vector-! (new 'stack-no-clear 'vector) s4-1 (-> arg0 user-position))))
                        )
                      )
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-8 quad))
                )
              (.lvf vf4 (&-> v1-17 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-8 quad) vf6)
            )
          (let ((a1-9 s5-0))
            (let ((v1-18 s5-0))
              (let ((a0-10 (vector-! (new 'stack-no-clear 'vector) s4-1 s5-0)))
                (let ((a2-9 (fmin 1.0 (* (-> arg0 user-blend) f30-1))))
                  (.mov vf7 a2-9)
                  )
                (.lvf vf5 (&-> a0-10 quad))
                )
              (.lvf vf4 (&-> v1-18 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-9 quad) vf6)
            )
          )
        )
      (handle-copy! arg0 s5-0)
      )
    (none)
    )
  )

;; WARN: Return type mismatch int vs none.
(defbehavior target-update-ik target ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-query)))
      (let ((v1-0 (-> gp-0 bbox))
            (a0-1 (-> self control trans))
            (a1-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-0 x) 8192.0)
        (set! (-> a1-0 y) 6144.0)
        (set! (-> a1-0 z) 8192.0)
        (set! (-> a1-0 w) 1.0)
        (vector-! (the-as vector v1-0) a0-1 a1-0)
        )
      (let ((v1-2 (-> gp-0 bbox max))
            (a0-3 (-> self control trans))
            (a1-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-1 x) 8192.0)
        (set! (-> a1-1 y) 6144.0)
        (set! (-> a1-1 z) 8192.0)
        (set! (-> a1-1 w) 1.0)
        (vector+! v1-2 a0-3 a1-1)
        )
      (set! (-> gp-0 collide-with) (-> self control root-prim prim-core collide-with))
      (set! (-> gp-0 ignore-process0) self)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat) (-> self control pat-ignore-mask))
      (collide-cache-method-12 *collide-cache* gp-0)
      (dotimes (s5-0 2)
        (let ((a1-4 (not (or (logtest? (state-flags lleg-no-ik rleg-no-ik) (-> self state-flags))
                             (and (logtest? (-> self control unknown-surface00 flags) (surface-flag air))
                                  (zero? (logand (-> self control status) (cshape-moving-flags on-surface)))
                                  )
                             (logtest? (focus-status edge-grab pole flut pilot mech) (-> self focus-status))
                             )
                         )
                    )
              )
          (enable-set! (-> self leg-ik s5-0) a1-4)
          )
        (set! (-> self foot s5-0 twist-max quad) (-> self control unknown-vector22 quad))
        (set! (-> self foot s5-0 trans quad) (-> self control gspot-pos quad))
        (vector-y-quaternion! (-> self foot s5-0 target) (-> self control unknown-quaternion00))
        (set! (-> self foot s5-0 flex-blend) (if (if (zero? s5-0)
                                                     (logtest? (state-flags lleg-no-ik) (-> self state-flags))
                                                     (logtest? (state-flags rleg-no-ik) (-> self state-flags))
                                                     )
                                                 0.0
                                                 1.0
                                                 )
              )
        (-> self leg-ik s5-0 shoulder-matrix-no-ik)
        (let ((v1-51 (-> self leg-ik s5-0 elbow-matrix-no-ik))
              (s2-0 (new 'stack-no-clear 'vector))
              (s1-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s1-0 quad) (-> *y-vector* quad))
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (new 'stack-no-clear 'vector)
            (new 'stack-no-clear 'vector)
            (let ((s4-0 (new 'stack-no-clear 'vector)))
              (let ((a2-8 s2-0))
                (let ((a0-27 (-> v1-51 trans)))
                  (let ((a1-8 (-> v1-51 vector 1)))
                    (let ((a3-3 (-> self leg-ik s5-0 hand-dist)))
                      (.mov vf7 a3-3)
                      )
                    (.lvf vf5 (&-> a1-8 quad))
                    )
                  (.lvf vf4 (&-> a0-27 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a2-8 quad) vf6)
                )
              (let ((a1-9 s2-0))
                (let ((a0-28 (-> v1-51 trans)))
                  (let ((v1-52 (-> v1-51 vector 1)))
                    (let ((a2-12 (-> self leg-ik s5-0 hand-dist)))
                      (.mov vf7 a2-12)
                      )
                    (.lvf vf5 (&-> v1-52 quad))
                    )
                  (.lvf vf4 (&-> a0-28 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-9 quad) vf6)
                )
              (let ((f0-13 (lerp-scale 1.0 0.0 (- (-> s2-0 y) (-> self control gspot-pos y)) 819.2 2048.0)))
                (seek! (-> self leg-ik s5-0 user-blend) f0-13 (* 4.0 (-> self clock seconds-per-frame)))
                )
              (let ((a1-12 (-> gp-0 start-pos)))
                (let ((v1-63 s2-0))
                  (let ((a0-31 s1-0))
                    (let ((a2-16 4096.0))
                      (.mov vf7 a2-16)
                      )
                    (.lvf vf5 (&-> a0-31 quad))
                    )
                  (.lvf vf4 (&-> v1-63 quad))
                  )
                (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                (.mul.x.vf acc vf5 vf7 :mask #b111)
                (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                (.svf (&-> a1-12 quad) vf6)
                )
              (vector-float*! (-> gp-0 move-dist) s1-0 -8192.0)
              (let ((v1-66 gp-0))
                (set! (-> v1-66 radius) 4.096)
                (set! (-> v1-66 collide-with) (-> gp-0 collide-with))
                (set! (-> v1-66 ignore-process0) #f)
                (set! (-> v1-66 ignore-process1) #f)
                (set! (-> v1-66 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                (set! (-> v1-66 action-mask) (collide-action solid))
                )
              (let ((f30-0 (collide-cache-method-16 *collide-cache* gp-0)))
                (cond
                  ((and (>= f30-0 0.0) (< 0.5 (-> gp-0 best-other-tri normal y)))
                   (set! (-> s4-0 quad) (-> gp-0 best-other-tri normal quad))
                   (when (< 8192.0 (vector-vector-angle-safe *y-vector* s4-0))
                     (let* ((a1-17 (vector-normalize! (vector-cross! (new 'stack-no-clear 'vector) *y-vector* s4-0) 1.0))
                            (a2-18 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) a1-17 8192.0))
                            )
                       (vector-orient-by-quat! s4-0 *y-vector* a2-18)
                       )
                     )
                   (let ((a1-19 s3-0))
                     (let ((v1-77 (-> gp-0 start-pos)))
                       (let ((a0-45 (-> gp-0 move-dist)))
                         (let ((a2-19 f30-0))
                           (.mov vf7 a2-19)
                           )
                         (.lvf vf5 (&-> a0-45 quad))
                         )
                       (.lvf vf4 (&-> v1-77 quad))
                       )
                     (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                     (.mul.x.vf acc vf5 vf7 :mask #b111)
                     (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                     (.svf (&-> a1-19 quad) vf6)
                     )
                   (set! (-> self leg-ik s5-0 user-position quad) (-> s3-0 quad))
                   (set! (-> self leg-ik s5-0 user-normal quad) (-> s4-0 quad))
                   (set! (-> self foot s5-0 twist-max quad) (-> s4-0 quad))
                   )
                  (else
                    (set! (-> self leg-ik s5-0 user-position quad) (-> s2-0 quad))
                    (set! (-> self leg-ik s5-0 user-normal quad) (-> *y-vector* quad))
                    (set! (-> self foot s5-0 twist-max quad) (-> *y-vector* quad))
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch int vs none.
(defbehavior pre-collide-setup target ()
  (if (>= (-> self clock frame-counter) (-> self control unknown-time-frame04))
      (vector-normalize!
        (-> self control unknown-vector18)
        (seek (vector-length (-> self control unknown-vector18)) 0.0 (* 40960.0 (-> self clock seconds-per-frame)))
        )
      )
  (cond
    ((logtest? (-> self control old-status) (cshape-moving-flags on-surface))
     (if (>= (+ (-> self clock frame-counter) (seconds -0.035)) (-> self control unknown-time-frame03))
         (vector-reset! (-> self control unknown-vector18))
         )
     )
    (else
      (let ((f30-0 (vector-length (-> self control unknown-vector18))))
        (let* ((v1-22 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control unknown-vector18) 1.0))
               (f0-3 (vector-dot (-> self control transv) v1-22))
               )
          (if (< f0-3 0.0)
              (set! f30-0 (seek f30-0 0.0 (* -1.0 (-> self clock seconds-per-frame) f0-3)))
              )
          )
        (let ((f0-7 (seek f30-0 0.0 (* 28672.0 (-> self clock seconds-per-frame)))))
          (vector-normalize! (-> self control unknown-vector18) f0-7)
          )
        )
      )
    )
  (set! (-> self control unknown-vector17 quad) (-> self control unknown-vector18 quad))
  (set! (-> self control unknown-vector14 quad) (-> self control local-normal quad))
  0
  (none)
  )

;; WARN: Return type mismatch int vs none.
(defbehavior level-setup target ()
  (let ((gp-0 (-> self current-level)))
    (set! (-> self current-level) (level-get-target-inside *level*))
    (if (-> self current-level)
        (+! (-> self game unknown-array3 (-> self current-level info task-level))
            (- (-> self clock frame-counter) (-> self clock old-frame-counter))
            )
        )
    (if (and (-> self current-level) (or (not gp-0) (!= (-> gp-0 name) (-> self current-level name))))
        (send-event self 'level-enter (-> self current-level name))
        )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs none.
(defbehavior flag-setup target ()
  (cond
    ((= (-> *cpad-list* cpads (-> self control unknown-cpad-info00 number) stick0-speed) 0.0)
     (if (zero? (-> self control unknown-dword07))
         (set! (-> self control unknown-dword07)
               (the-as int (- (-> self clock frame-counter) (-> self control unknown-time-frame19)))
               )
         )
     (set! (-> self control unknown-time-frame19) (-> self clock frame-counter))
     (quaternion-copy! (-> self control unknown-quaternion04) (-> self control dir-targ))
     )
    (else
      (set! (-> self control unknown-time-frame20) (-> self clock frame-counter))
      (set! (-> self control unknown-dword07) 0)
      0
      )
    )
  (level-setup)
  (set! (-> self control unknown-quaternion02 vec quad) (-> self control transv quad))
  (quaternion-copy! (-> self control unknown-quaternion03) (-> self control unknown-quaternion00))
  ((-> self control unknown-surface01 active-hook))
  (cond
    ((logtest? (-> self control status) (cshape-moving-flags on-surface))
     (set! (-> self control unknown-time-frame06) (-> self clock frame-counter))
     (set! (-> self control unknown-vector21 quad) (-> self control trans quad))
     (if (and (>= (-> self control coverage) 1.0)
              (zero? (logand (-> self control status) (cshape-moving-flags t-act on-water)))
              (logtest? (-> self control status) (cshape-moving-flags on-ground))
              )
         (set! (-> self control unknown-vector23 quad) (-> self control trans quad))
         )
     ((-> self control unknown-surface01 touch-hook))
     )
    (else
      (let ((v1-49 (-> self control trans)))
        (when (logtest? (-> self control old-status) (cshape-moving-flags on-surface))
          (set! (-> self control unknown-vector36 quad) (-> self control unknown-vector21 quad))
          (set! (-> self control unknown-vector37 quad) (-> self control unknown-vector21 quad))
          )
        (set! (-> self control unknown-vector37 x) (-> v1-49 x))
        (set! (-> self control unknown-vector37 z) (-> v1-49 z))
        (if (< (vector-dot
                 (-> self control dynam gravity-normal)
                 (vector-! (new 'stack-no-clear 'vector) (-> self control unknown-vector37) v1-49)
                 )
               0.0
               )
            (set! (-> self control unknown-vector37 y) (-> v1-49 y))
            )
        )
      )
    )
  (when (and (cpad-pressed? (-> self control unknown-cpad-info00 number) r3)
             (zero? (-> self control unknown-word03))
             (zero? (logand (-> *kernel-context* prevent-from-run) (process-mask movie)))
             (not *pause-lock*)
             )
    (if (and (= (-> self cam-user-mode) 'normal)
             (logtest? (-> self control unknown-surface00 flags) (surface-flag look-around))
             (zero? (logand (focus-status edge-grab pole flut tube board pilot dark) (-> self focus-status)))
             (-> *setting-control* user-current allow-look-around)
             (>= (- (-> self clock frame-counter) (the-as int (-> self no-look-around-wait))) (seconds 0.05))
             (not (and (= (-> self control ground-pat material) (pat-material ice))
                       (< 4096.0 (-> self control unknown-float05))
                       )
                  )
             )
        (send-event self 'change-mode 'look-around)
        )
    )
  (if (!= (zero? (logand (-> self game features) (game-feature sidekick))) (not (-> self sidekick)))
      (target-sidekick-setup (logtest? (-> self game features) (game-feature sidekick)))
      )
  (if (and (!= (zero? (logand (-> self game features) (game-feature board))) (not (-> self board board)))
           (zero? (logand (focus-status board) (-> self focus-status)))
           )
      (target-board-setup (logtest? (-> self game features) (game-feature board)))
      )
  (if (want-to-board?)
      (send-event self 'change-mode 'board #f)
      )
  (when (!= (not (-> *setting-control* user-current mirror)) (not (-> self mirror)))
    (cond
      ((-> self mirror)
       (deactivate (-> self mirror 0))
       (set! (-> self mirror) (the-as (pointer process-drawable) #f))
       )
      (else
        (let* ((s5-0 (get-process *default-dead-pool* manipy #x4000))
               (gp-1
                 (when s5-0
                   (let ((t9-12 (method-of-type manipy activate)))
                     (t9-12 (the-as manipy s5-0) self (symbol->string (-> manipy symbol)) (the-as pointer #x70004000))
                     )
                   (let ((gp-2 run-function-in-process)
                         (s4-0 s5-0)
                         (s3-0 manipy-init)
                         (s2-0 (-> self control trans))
                         (s1-0 (-> self entity))
                         (t0-0 (art-group-get-by-name *level* "skel-jchar" (the-as (pointer uint32) #f)))
                         (t1-0 #f)
                         )
                     0
                     ((the-as (function object object object object object object none) gp-2) s4-0 s3-0 s2-0 s1-0 t0-0 t1-0)
                     )
                   (-> s5-0 ppointer)
                   )
                 )
               )
          (send-event (ppointer->process gp-1) 'anim-mode 'mirror)
          (send-event (ppointer->process gp-1) 'mirror #t)
          (set! (-> self mirror) (the-as (pointer process-drawable) gp-1))
          )
        )
      )
    )
  (when (and (= *cheat-mode* 'debug)
             (cpad-hold? (-> self control unknown-cpad-info00 number) r2)
             (cpad-hold? (-> self control unknown-cpad-info00 number) l2)
             (not *pause-lock*)
             (zero? (logand (focus-status grabbed in-head pilot) (-> self focus-status)))
             (not (and (-> self next-state) (let ((v1-167 (-> self next-state name)))
                                              (or (= v1-167 'target-darkjak-get-on) (= v1-167 'target-float))
                                              )
                       )
                  )
             )
    (send-event *camera* 'reset-follow)
    (set! (-> self control unknown-time-frame12) (-> self clock frame-counter))
    (cond
      ((logtest? (focus-status mech indax) (-> self focus-status))
       (if (not (and (-> self next-state)
                     (let ((v1-179 (-> self next-state name)))
                       (or (= v1-179 'target-falling)
                           (= v1-179 'target-board-falling)
                           (= v1-179 'target-gun-falling)
                           (= v1-179 'target-mech-falling)
                           (= v1-179 'target-mech-carry-falling)
                           (= v1-179 'target-carry-falling)
                           (= v1-179 'target-indax-falling)
                           )
                       )
                     )
                )
           (send-event self 'change-mode 'falling)
           )
       (set! (-> self control unknown-time-frame03) 0)
       (vector-reset! (-> self control unknown-vector18))
       (let ((v1-189 (new-stack-vector0)))
         (let ((f0-9 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
           0.0
           (vector-!
             v1-189
             (-> self control transv)
             (the-as vector (vector-float*! v1-189 (-> self control dynam gravity-normal) f0-9))
             )
           )
         (let* ((f0-10 (vector-length v1-189))
                (f1-5 f0-10)
                (f2-0 0.0)
                )
           (vector+!
             (-> self control transv)
             (the-as vector (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0))
             (the-as vector (vector-float*! v1-189 v1-189 (/ f0-10 f1-5)))
             )
           )
         )
       (let ((a1-36 (new 'stack-no-clear 'vector)))
         (set! (-> a1-36 quad) (-> self control trans quad))
         (let ((v1-193 (new-stack-vector0))
               (f0-13 (vector-dot (-> self control dynam gravity-normal) a1-36))
               )
           0.0
           (vector-! v1-193 a1-36 (the-as vector (vector-float*! v1-193 (-> self control dynam gravity-normal) f0-13)))
           (let* ((f1-8 (vector-length v1-193))
                  (f2-1 f1-8)
                  (f0-14 (+ 512.0 f0-13))
                  )
             (vector+!
               a1-36
               (the-as vector (vector-float*! a1-36 (-> self control dynam gravity-normal) f0-14))
               (the-as vector (vector-float*! v1-193 v1-193 (/ f1-8 f2-1)))
               )
             )
           )
         (collide-shape-method-29 (-> self control) a1-36)
         )
       (set! (-> self control surf) *standard-ground-surface*)
       )
      (else
        (go target-float)
        )
      )
    )
  (let ((f0-17 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
    (if (and (or (logtest? (-> self control unknown-surface01 flags) (surface-flag check-edge))
                 (and (and (-> self next-state) (let ((v1-211 (-> self next-state name)))
                                                  (or (= v1-211 'target-walk) (= v1-211 'target-gun-walk))
                                                  )
                           )
                      (zero? (logand (-> self control status) (cshape-moving-flags on-surface)))
                      )
                 )
             (and (< f0-17 0.0)
                  (and (or (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control unknown-cpad-info00 number) r2)))
                           *pause-lock*
                           )
                       (zero? (logand (focus-status flut pilot mech indax) (-> self focus-status)))
                       (zero? (logand (-> self state-flags) (state-flags sf7)))
                       #t
                       )
                  )
             )
        (logior! (-> self control root-prim prim-core action) (collide-action check-edge))
        (logclear! (-> self control root-prim prim-core action) (collide-action check-edge))
        )
    )
  (let ((v1-229 (-> self current-level)))
    (when (and (or (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame06)) (seconds 2))
                   (logtest? (focus-status pilot) (-> self focus-status))
                   )
               (and v1-229
                    (< (-> self control trans y) (-> v1-229 info buttom-height))
                    (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control unknown-cpad-info00 number) r2)))
                    )
               )
      (let ((a1-45 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-45 from) (process->ppointer self))
        (set! (-> a1-45 num-params) 2)
        (set! (-> a1-45 message) 'attack-invinc)
        (set! (-> a1-45 param 0) (the-as uint #f))
        (let ((v1-240 (new 'static 'attack-info :mask (attack-info-mask mode id))))
          (let* ((a0-162 *game-info*)
                 (a2-22 (+ (-> a0-162 attack-id) 1))
                 )
            (set! (-> a0-162 attack-id) a2-22)
            (set! (-> v1-240 id) a2-22)
            )
          (set! (-> v1-240 mode) 'endlessfall)
          (set! (-> a1-45 param 1) (the-as uint v1-240))
          )
        (send-event-function self a1-45)
        )
      )
    )
  (set! (-> self control unknown-float29)
        (if (logtest? (-> self control status) (cshape-moving-flags on-surface))
            32.0
            2.0
            )
        )
  (let ((v1-248 (-> *setting-control* user-current beard)))
    (when (!= (-> self beard?) v1-248)
      (cond
        (v1-248
          (let ((t9-22 (method-of-object (-> self draw) draw-control-method-12)))
            2
            0
            (t9-22)
            )
          (set! (-> self beard?) #t)
          )
        (else
          (let ((t9-23 (method-of-object (-> self draw) draw-control-method-12)))
            0
            2
            (t9-23)
            )
          (set! (-> self beard?) #f)
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs none.
(defbehavior post-flag-setup target ()
  (if (logtest? (-> self control status) (cshape-moving-flags t-wall t-act))
      (set! (-> self control unknown-time-frame07) (-> self clock frame-counter))
      )
  (when (logtest? (-> self state-flags) (state-flags tinvul1))
    (if (< (logand (- (-> self clock frame-counter) (-> self control unknown-time-frame13)) 3) 1)
        (logior! (-> self draw status) (draw-control-status no-draw-bounds))
        (logclear! (-> self draw status) (draw-control-status no-draw-bounds))
        )
    (if (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame13))
            (-> self control unknown-time-frame14)
            )
        (target-timed-invulnerable-off self 1)
        )
    )
  (when (logtest? (state-flags tinvul2) (-> self state-flags))
    (if (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame15))
            (-> self control unknown-time-frame16)
            )
        (target-timed-invulnerable-off self 2)
        )
    )
  (set! (-> self control unknown-symbol01) #f)
  (target-gun-joint-pre)
  ((-> self pre-joint-hook))
  (target-log-trans)
  (seek!
    (-> self hair 0 twist-max z)
    (lerp-scale 0.0 1820.4445 (vector-length (-> self control transv)) 0.0 122880.0)
    (* 65536.0 (-> self clock seconds-per-frame))
    )
  (seek!
    (-> self hair 0 twist-speed-x)
    (lerp-scale 0.5 4.0 (vector-length (-> self control transv)) 0.0 122880.0)
    (* 10.0 (-> self clock seconds-per-frame))
    )
  (let ((f0-9 (+ (-> self hair 0 twist z) (* (-> self hair 0 twist-speed-x) (-> self clock seconds-per-frame)))))
    (set! (-> self hair 0 twist z) (- f0-9 (* (the float (the int (/ f0-9 1.0))) 1.0)))
    )
  (if (and (logtest? (focus-status pilot) (-> self focus-status))
           (nonzero? (-> self pilot))
           (= (-> self pilot stance) 1)
           )
      (seek!
        (-> self hair 0 twist-max w)
        (lerp-scale 0.0 9102.223 (vector-length (-> self control transv)) 0.0 122880.0)
        (* 65536.0 (-> self clock seconds-per-frame))
        )
      (seek! (-> self hair 0 twist-max w) 0.0 (* 65536.0 (-> self clock seconds-per-frame)))
      )
  (trs-set!
    (-> self hair 0)
    (the-as vector #f)
    (quaternion-rotate-x!
      (new 'stack-no-clear 'quaternion)
      (the-as quaternion *null-vector*)
      (+ (-> self hair 0 twist-max w) (* (sin (* 32768.0 (-> self hair 0 twist z))) (-> self hair 0 twist-max z)))
      )
    (the-as vector #f)
    )
  (seek!
    (-> self hair 1 twist-max z)
    (lerp-scale 0.0 5461.3335 (vector-length (-> self control transv)) 4096.0 122880.0)
    (* 65536.0 (-> self clock seconds-per-frame))
    )
  (seek!
    (-> self hair 1 twist-speed-x)
    (lerp-scale 1.0 8.0 (vector-length (-> self control transv)) 4096.0 122880.0)
    (* 10.0 (-> self clock seconds-per-frame))
    )
  (let ((f0-33 (+ (-> self hair 1 twist z) (* (-> self hair 1 twist-speed-x) (-> self clock seconds-per-frame)))))
    (set! (-> self hair 1 twist z) (- f0-33 (* (the float (the int (/ f0-33 1.0))) 1.0)))
    )
  (trs-set!
    (-> self hair 1)
    (the-as vector #f)
    (quaternion-rotate-x!
      (new 'stack-no-clear 'quaternion)
      (the-as quaternion *null-vector*)
      (* (sin (* 32768.0 (-> self hair 1 twist z))) (-> self hair 1 twist-max z))
      )
    (the-as vector #f)
    )
  (target-update-ik)
  0
  (none)
  )

(defbehavior bend-gravity target ()
  (if (and (logtest? (-> self control root-prim prim-core action) (collide-action no-normal-reset))
           (zero? (logand (-> self control status) (cshape-moving-flags on-surface)))
           )
      (return #f)
      )
  (let ((f0-1
          (if (and (logtest? (-> self control status) (cshape-moving-flags t-wall))
                   (zero? (logand (-> self control status) (cshape-moving-flags on-surface)))
                   )
              0.0
              (-> self control unknown-float28)
              )
          )
        )
    (seek!
      (-> self control unknown-float27)
      f0-1
      (* (-> self control unknown-float29) (-> self clock seconds-per-frame))
      )
    )
  (set! (-> self control dynam gravity-normal quad) (-> self control unknown-dynamics00 gravity-normal quad))
  (vector-float*!
    (-> self control dynam gravity)
    (-> self control dynam gravity-normal)
    (the-as float (-> self control dynam gravity-length))
    )
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (new 'stack-no-clear 'vector)
    (let ((f30-0 (-> self control unknown-surface01 tiltvv))
          (gp-0 (-> self control gspot-normal))
          )
      (vector-deg-slerp
        s5-0
        (-> self control unknown-dynamics00 gravity-normal)
        gp-0
        (-> self control unknown-float27)
        )
      (let ((a2-3
              (matrix-from-two-vectors-smooth!
                (new 'stack-no-clear 'matrix)
                (-> self control unknown-vector02)
                s5-0
                f30-0
                (the int (-> self control unknown-surface01 tiltvvf))
                )
              )
            )
        (vector-matrix*! (-> self control unknown-vector02) (-> self control unknown-vector02) a2-3)
        )
      (vector-normalize! (-> self control unknown-vector02) 1.0)
      (add-debug-vector
        *display-target-marks*
        (bucket-id bucket-318)
        (-> self control trans)
        gp-0
        (the-as meters #x46000000)
        (new 'static 'rgba :b #xff :a #x80)
        )
      )
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id bucket-318)
    (-> self control trans)
    (-> self control local-normal)
    (the-as meters #x46000000)
    (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id bucket-318)
    (-> self control trans)
    (-> self control unknown-dynamics00 gravity-normal)
    (the-as meters #x46200000)
    (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id bucket-318)
    (-> self control trans)
    (-> self control dynam gravity-normal)
    (the-as meters #x46400000)
    (the-as rgba (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id bucket-318)
    (-> self control trans)
    (-> self control unknown-vector02)
    (the-as meters #x46400000)
    (the-as rgba (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
    )
  (add-debug-vector
    *display-target-marks*
    (bucket-id bucket-318)
    (-> self control trans)
    (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00))
    (the-as meters #x46400000)
    (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
    )
  )

(defbehavior target-compute-edge target ()
  (let ((s5-0 *edge-grab-info*))
    (cond
      ((-> s5-0 pilot-edge-grab?)
       (set! (-> self control ground-pat) (new 'static 'pat-surface :material (pat-material metal)))
       (cond
         ((send-event (handle->process (-> s5-0 pilot-edge-grab handle)) 'pilot-edge-grab s5-0)
          (let ((a0-7 (handle->process (-> s5-0 pilot-edge-grab handle))))
            (set! (-> s5-0 center-hold-old quad) (-> s5-0 center-hold quad))
            (let ((gp-0 (new 'stack-no-clear 'bone)))
              (let* ((v1-13 (-> gp-0 transform))
                     (a3-0 (-> (the-as process-drawable a0-7) node-list data 0 bone transform))
                     (a0-12 (-> a3-0 vector 0 quad))
                     (a1-4 (-> a3-0 vector 1 quad))
                     (a2-1 (-> a3-0 vector 2 quad))
                     (a3-1 (-> a3-0 trans quad))
                     )
                (set! (-> v1-13 vector 0 quad) a0-12)
                (set! (-> v1-13 vector 1 quad) a1-4)
                (set! (-> v1-13 vector 2 quad) a2-1)
                (set! (-> v1-13 trans quad) a3-1)
                )
              (vector-matrix*! (-> gp-0 scale) (the-as vector (-> s5-0 pilot-edge-grab)) (-> gp-0 transform))
              (vector-rotate*! (the-as vector (&+ gp-0 80)) (-> s5-0 pilot-edge-grab local-dir) (-> gp-0 transform))
              (set! (-> s5-0 center-hold quad) (-> gp-0 scale quad))
              (set! (-> self control unknown-vector34 quad) (-> (&+ gp-0 80) transform vector 0 quad))
              )
            )
          )
         (else
           (send-event self 'end-mode)
           )
         )
       )
      (else
        (if (not (edge-grab-info-method-9 s5-0))
            (send-event self 'end-mode)
            )
        (if *display-edge-collision-marks*
            (debug-draw s5-0)
            )
        (set! (-> self control ground-pat) (the-as pat-surface (-> s5-0 edge-tri-pat)))
        (vector-normalize!
          (vector-! (-> self control unknown-vector34) (the-as vector (-> s5-0 world-vertex)) (-> s5-0 world-vertex 1))
          1.0
          )
        )
      )
    (let ((gp-2 (vector-cross!
                  (-> self control unknown-vector35)
                  (-> self control unknown-vector34)
                  (-> self control dynam gravity-normal)
                  )
                )
          )
      (let ((s4-1 (vector-! (new-stack-vector0) (-> s5-0 center-hold) (-> self control unknown-vector30))))
        (set! (-> self control unknown-float33) (vector-length s4-1))
        (cond
          ((and (< 819.2 (-> self control unknown-float33))
                (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame10)) (seconds 0.2))
                )
           (cond
             ((-> s5-0 pilot-edge-grab?)
              (case (-> s5-0 pilot-edge-grab?)
                (('target-jump)
                 (seek! (-> s5-0 pilot-grab-interp) 1.0 (* 2.0 (-> self clock seconds-per-frame)))
                 )
                (else
                  (seek! (-> s5-0 pilot-grab-interp) 1.0 (* 1.5 (-> self clock seconds-per-frame)))
                  )
                )
              (let* ((f0-11 (fmin 1.0 (* 1.5 (-> s5-0 pilot-grab-interp))))
                     (s3-1 (vector-lerp!
                             (new 'stack-no-clear 'vector)
                             (-> s5-0 pilot-start-grab-pos)
                             (vector-! (new 'stack-no-clear 'vector) (-> s5-0 center-hold) (-> self control unknown-vector31))
                             (smooth-step f0-11)
                             )
                           )
                     )
                (set! (-> s3-1 y) (+ (lerp
                                       (-> s5-0 pilot-start-grab-pos y)
                                       (- (-> s5-0 center-hold y) (-> self control unknown-vector31 y))
                                       (smooth-step (-> s5-0 pilot-grab-interp))
                                       )
                                     (cond
                                       ((= (-> s5-0 pilot-edge-grab?) 'target-jump)
                                        (let ((f1-6 (-> s5-0 pilot-grab-interp)))
                                          (* 8192.0 (- 1.0 f1-6) f1-6)
                                          )
                                        )
                                       ((>= (-> s5-0 pilot-grab-interp) 0.5)
                                        (let ((f1-10 (* 2.0 (+ -0.5 (-> s5-0 pilot-grab-interp)))))
                                          (* 8192.0 (- 1.0 f1-10) f1-10)
                                          )
                                        )
                                       (else
                                         (let ((f1-13 (* 2.0 (-> s5-0 pilot-grab-interp))))
                                           (* 32768.0 (- 1.0 f1-13) f1-13)
                                           )
                                         )
                                       )
                                     )
                      )
                (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
                (set! (-> self control rider-time) (-> self clock frame-counter))
                (vector+! s3-1 s3-1 (-> self control unknown-vector05))
                (collide-shape-method-29 (-> self control) s3-1)
                )
              (set! (-> self control unknown-float33) 0.0)
              (set! (-> self control unknown-vector21 quad) (-> self control trans quad))
              )
             (else
               (vector-normalize! s4-1 1228.8)
               (vector+! (new 'stack-no-clear 'vector) s4-1 (-> self control unknown-vector05))
               ((method-of-object (-> self control) collide-shape-method-28))
               (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
               (set! (-> self control rider-time) (-> self clock frame-counter))
               (if (and (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame11)) (seconds 0.5))
                        (>= (- (-> self clock frame-counter) (-> self control unknown-time-frame10)) (seconds 0.5))
                        )
                   (send-event self 'end-mode)
                   )
               )
             )
           )
          (else
            (let ((a1-23 (new 'stack-no-clear 'vector)))
              (vector-! a1-23 (-> s5-0 center-hold) (-> self control unknown-vector31))
              (vector-float*! (-> self control rider-last-move) s4-1 (-> self clock frames-per-second))
              (set! (-> self control rider-time) (-> self clock frame-counter))
              (vector+! a1-23 a1-23 (-> self control unknown-vector05))
              (collide-shape-method-29 (-> self control) a1-23)
              )
            (set! (-> self control unknown-float33) 0.0)
            (set! (-> self control unknown-vector21 quad) (-> self control trans quad))
            (set! (-> self control unknown-time-frame10) (-> self clock frame-counter))
            )
          )
        )
      (forward-up-nopitch->quaternion (-> self control dir-targ) gp-2 (-> self control dynam gravity-normal))
      )
    )
  (set-quaternion! (-> self control) (-> self control dir-targ))
  (joint-control-method-10 (-> self skel))
  (draw-control-method-14 (-> self draw) (-> self node-list) (-> self skel))
  (none)
  )

(defbehavior target-compute-edge-rider target ()
  (let ((gp-0 *edge-grab-info*))
    (cond
      ((-> gp-0 pilot-edge-grab?)
       (set! (-> self control ground-pat) (new 'static 'pat-surface :material (pat-material metal)))
       (cond
         ((send-event (handle->process (-> gp-0 pilot-edge-grab handle)) 'pilot-edge-grab gp-0)
          (let ((a0-7 (handle->process (-> gp-0 pilot-edge-grab handle))))
            (set! (-> gp-0 center-hold-old quad) (-> gp-0 center-hold quad))
            (let ((s5-0 (new 'stack-no-clear 'bone)))
              (let* ((v1-13 (-> s5-0 transform))
                     (a3-0 (-> (the-as process-drawable a0-7) node-list data 0 bone transform))
                     (a0-12 (-> a3-0 vector 0 quad))
                     (a1-4 (-> a3-0 vector 1 quad))
                     (a2-1 (-> a3-0 vector 2 quad))
                     (a3-1 (-> a3-0 trans quad))
                     )
                (set! (-> v1-13 vector 0 quad) a0-12)
                (set! (-> v1-13 vector 1 quad) a1-4)
                (set! (-> v1-13 vector 2 quad) a2-1)
                (set! (-> v1-13 trans quad) a3-1)
                )
              (vector-matrix*! (-> s5-0 scale) (the-as vector (-> gp-0 pilot-edge-grab)) (-> s5-0 transform))
              (vector-rotate*! (the-as vector (&+ s5-0 80)) (-> gp-0 pilot-edge-grab local-dir) (-> s5-0 transform))
              (set! (-> gp-0 center-hold quad) (-> s5-0 scale quad))
              (set! (-> self control unknown-vector34 quad) (-> (&+ s5-0 80) transform vector 0 quad))
              )
            )
          )
         (else
           (send-event self 'end-mode)
           )
         )
       )
      (else
        (if (not (edge-grab-info-method-9 gp-0))
            (send-event self 'end-mode)
            )
        (if *display-edge-collision-marks*
            (debug-draw gp-0)
            )
        (vector-normalize!
          (vector-! (-> self control unknown-vector34) (the-as vector (-> gp-0 world-vertex)) (-> gp-0 world-vertex 1))
          1.0
          )
        )
      )
    (vector-cross!
      (-> self control unknown-vector35)
      (-> self control unknown-vector34)
      (-> self control dynam gravity-normal)
      )
    (let ((a1-15 (vector-! (new-stack-vector0) (-> gp-0 center-hold) (-> gp-0 center-hold-old))))
      (vector-float*! (-> self control rider-last-move) a1-15 (-> self clock frames-per-second))
      )
    )
  (set! (-> self control rider-time) (-> self clock frame-counter))
  ((method-of-object (-> self control) collide-shape-method-28))
  (set! (-> self control unknown-float33) 0.0)
  (joint-control-method-10 (-> self skel))
  (draw-control-method-14 (-> self draw) (-> self node-list) (-> self skel))
  (none)
  )

(defbehavior target-compute-pole target ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (let* ((s2-0 (handle->process (-> self control unknown-handle00)))
           (gp-0 (-> (the-as swingpole s2-0) dir))
           )
      (set! (-> self control unknown-vector34 quad) (-> gp-0 quad))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((s4-0 (new 'stack-no-clear 'vector)))
          (let ((v1-7 (-> (the-as swingpole s2-0) root trans))
                (a0-5 gp-0)
                (f0-0 (-> (the-as swingpole s2-0) edge-length))
                )
            (.lvf vf2 (&-> a0-5 quad))
            (.lvf vf1 (&-> v1-7 quad))
            (let ((v1-8 f0-0))
              (.mov vf3 v1-8)
              )
            )
          (.add.x.vf vf4 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf2 vf3)
          (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
          (.svf (&-> s4-0 quad) vf4)
          (let ((s3-0 (new 'stack-no-clear 'vector)))
            (let ((v1-10 (-> (the-as swingpole s2-0) root trans))
                  (a0-6 gp-0)
                  (f0-2 (- (-> (the-as swingpole s2-0) edge-length)))
                  )
              (.lvf vf2 (&-> a0-6 quad))
              (.lvf vf1 (&-> v1-10 quad))
              (let ((v1-11 f0-2))
                (.mov vf3 v1-11)
                )
              )
            (.add.x.vf vf4 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf2 vf3)
            (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
            (.svf (&-> s3-0 quad) vf4)
            (let ((v1-12 (new 'stack-no-clear 'vector)))
              (vector+! v1-12 s4-0 s3-0)
              (vector-float*! v1-12 v1-12 0.5)
              (set! (-> v1-12 y) (+ -6144.0 (-> v1-12 y)))
              (send-event *camera* 'ease-in #x3f000000 v1-12)
              )
            (vector-segment-distance-point! (-> self control unknown-vector30) s4-0 s3-0 s5-0)
            (if (< (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.05))
                (set! (-> self control unknown-float33)
                      (fmax 0.0 (fmin 1.0 (/ (vector-vector-distance s4-0 s5-0) (* 2.0 (-> (the-as swingpole s2-0) edge-length)))))
                      )
                (vector-lerp! s5-0 s4-0 s3-0 (-> self control unknown-float33))
                )
            (when *display-edge-collision-marks*
              (add-debug-vector
                #t
                (bucket-id bucket-318)
                (-> (the-as swingpole s2-0) root trans)
                (the-as vector (&-> s2-0 stack 96))
                (the-as meters #x46400000)
                (the-as rgba (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
                )
              (add-debug-sphere
                #t
                (bucket-id bucket-324)
                (-> self control unknown-vector30)
                (the-as meters #x444ccccd)
                (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
                )
              (add-debug-sphere
                #t
                (bucket-id bucket-318)
                s4-0
                (the-as meters #x444ccccd)
                (the-as rgba (-> (new 'static 'array uint64 1 #x8000ff00) 0))
                )
              (add-debug-sphere
                #t
                (bucket-id bucket-318)
                s3-0
                (the-as meters #x444ccccd)
                (the-as rgba (-> (new 'static 'array uint64 1 #x8040ff00) 0))
                )
              (add-debug-sphere
                #t
                (bucket-id bucket-318)
                s5-0
                (the-as meters #x444ccccd)
                (new 'static 'rgba :b #xff :a #x80)
                )
              )
            )
          )
        (let ((a0-26 (vector-! (new-stack-vector0) s5-0 (-> self control unknown-vector30))))
          (cond
            ((and (< 2457.6 (vector-length a0-26)) (not (-> self control unknown-symbol00)))
             (let ((s4-1 (method-of-object (-> self control) collide-shape-method-28)))
               (vector-normalize! a0-26 2457.6)
               (s4-1)
               )
             )
            (else
              (set! (-> self control unknown-symbol00) #t)
              (collide-shape-method-29
                (-> self control)
                (vector-! (new 'stack-no-clear 'vector) s5-0 (-> self control unknown-vector31))
                )
              (set! (-> self control unknown-vector21 quad) (-> self control trans quad))
              )
            )
          )
        )
      (let ((s5-3 (vector-cross! (-> self control unknown-vector35) gp-0 (-> self control dynam gravity-normal))))
        (if (>= 0.0
                (vector-dot s5-3 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control unknown-quaternion00)))
                )
            (vector-negate! s5-3 s5-3)
            )
        (forward-up-nopitch->quaternion (-> self control dir-targ) s5-3 (-> self control dynam gravity-normal))
        )
      )
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (joint-control-method-10 (-> self skel))
    (draw-control-method-14 (-> self draw) (-> self node-list) (-> self skel))
    (collide-shape-method-46 (-> self control))
    (none)
    )
  )

;; WARN: Return type mismatch int vs none.
(defbehavior target-calc-camera-pos target ()
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (cond
      ((and (and (-> self next-state) (= (-> self next-state name) 'target-clone-anim))
            (and (zero? (logand (-> self draw status) (draw-control-status no-draw)))
                 (begin
                   (vector<-cspace! s5-0 (-> self node-list data 3))
                   (set! (-> s5-0 y) (+ -5896.192 (-> s5-0 y)))
                   (< (fabs (- (-> s5-0 y) (-> self control trans y))) 8192.0)
                   )
                 )
            )
       (set! (-> self control unknown-vector15 quad) (-> s5-0 quad))
       )
      ((logtest? (focus-status board pilot mech indax) (-> self focus-status))
       (set! (-> self control unknown-vector15 quad) (-> self control trans quad))
       )
      ((or (logtest? (-> self control status) (cshape-moving-flags on-water))
           (let ((v1-23 (-> self water flags)))
             (and (logtest? (water-flags touch-water) v1-23)
                  (logtest? (water-flags under-water swimming) v1-23)
                  (zero? (logand (focus-status mech) (-> self focus-status)))
                  )
             )
           )
       (vector<-cspace! s5-0 (the-as cspace (-> self node-list data)))
       (if (not (and (logtest? (-> self water flags) (water-flags under-water))
                     (zero? (logand (-> self water flags) (water-flags swim-ground)))
                     )
                )
           (set! (-> s5-0 y) (- (-> self water surface-height) (-> self water swim-height)))
           )
       (vector<-cspace! gp-0 (-> self node-list data 6))
       (cond
         ((>= (+ (-> self clock frame-counter) (seconds -2)) (-> self control unknown-time-frame17))
          (set! (-> self control unknown-vector15 quad) (-> s5-0 quad))
          )
         ((not (and (logtest? (-> self water flags) (water-flags under-water))
                    (zero? (logand (-> self water flags) (water-flags swim-ground)))
                    )
               )
          (vector-lerp!
            (-> self control unknown-vector15)
            gp-0
            s5-0
            (* 0.0016666667 (the float (- (-> self clock frame-counter) (-> self control unknown-time-frame17))))
            )
          )
         (else
           (vector-lerp!
             (-> self control unknown-vector15)
             s5-0
             gp-0
             (fmax
               0.0
               (fmin
                 1.0
                 (* 0.0011111111 (the float (- (-> self clock frame-counter) (-> self control unknown-time-frame18))))
                 )
               )
             )
           )
         )
       (-> self control unknown-vector15)
       )
      ((and (or (logtest? (water-flags touch-water) (-> self water flags))
                (logtest? (-> self control status) (cshape-moving-flags on-water))
                )
            (logtest? (-> self water flags) (water-flags mud))
            )
       (vector<-cspace! (-> self control unknown-vector15) (the-as cspace (-> self node-list data)))
       (set! (-> self control unknown-vector15 y) (-> self water base-height))
       )
      ((logtest? (focus-status tube) (-> self focus-status))
       (set! (-> self control unknown-vector15 quad) (-> self control gspot-pos quad))
       )
      ((logtest? (-> self draw status) (draw-control-status no-draw no-draw-temp))
       (set! (-> self control unknown-vector15 quad) (-> self control trans quad))
       )
      (else
        (vector<-cspace! (-> self control unknown-vector15) (the-as cspace (-> self node-list data)))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs none.
(defbehavior joint-points target ()
  (let ((f0-1 (* 0.00078125 (the float (-> self neck loock-at-count)))))
    (if (!= f0-1 0.0)
        (set! f0-1 (+ 0.12 f0-1))
        )
    (cond
      ((>= f0-1 (-> self excitement))
       (seek! (-> self excitement) f0-1 (* 6.0 (-> self clock seconds-per-frame)))
       )
      ((logtest? (-> self focus-status) (focus-status dead ignore hit))
       )
      (else
        (seek! (-> self excitement) f0-1 (* 0.25 (-> self clock seconds-per-frame)))
        )
      )
    )
  (set-setting! 'sound-excitement 'add (-> self excitement) 0)
  (let ((v1-17 (-> self neck)))
    (set! (-> v1-17 blend) 0.0)
    )
  (set! (-> self neck loock-at-count) (the-as uint 0))
  (if (and (logtest? (-> self control unknown-surface01 flags) (surface-flag duck))
           (< 0.5 (-> self control unknown-float31))
           (not (using-gun? self))
           )
      (set! (-> self neck base-nose) (the-as uint 1))
      (set! (-> self neck base-nose) (the-as uint 2))
      )
  (let ((v1-29 (-> self upper-body)))
    (set! (-> v1-29 blend) 0.0)
    )
  (cond
    ((logtest? (focus-status tube pilot indax) (-> self focus-status))
     )
    ((logtest? (water-flags wading) (-> self water flags))
     (let ((f30-0 (- (- (-> self control trans y) (- (-> self water height) (-> self water wade-height))))))
       (set! (-> *wade-surface* alignv)
             (lerp-scale 1.0 0.5 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))
             )
       (set! (-> *wade-surface* align-speed) (-> *wade-surface* alignv))
       (let ((f0-20 (lerp-scale 0.8 0.6 f30-0 0.0 (- (-> self water swim-height) (-> self water wade-height)))))
         (set! (-> *wade-surface* target-speed) f0-20)
         (set! (-> *wade-surface* transv-max) f0-20)
         )
       )
     (set! (-> self control surf) *wade-surface*)
     )
    ((logtest? (water-flags swimming) (-> self water flags))
     (set! (-> self control surf) *swim-surface*)
     )
    ((and (logtest? (water-flags touch-water) (-> self water flags))
          (logtest? (-> self water flags) (water-flags mud))
          )
     (set! (-> self control surf) *quicksand-surface*)
     )
    )
  (let ((a2-5
          (matrix<-no-trans-transformq! (-> self control unknown-matrix02) (the-as transformq (-> self control trans)))
          )
        )
    (vector-matrix*! (-> self control unknown-vector28) (-> *TARGET-bank* head-offset) a2-5)
    )
  (vector<-cspace! (-> self control unknown-vector33) (the-as cspace (-> self control unknown-vector32 x)))
  (let ((gp-0 (new-stack-vector0))
        (s5-0 (new-stack-vector0))
        )
    (vector<-cspace! gp-0 (the-as cspace (-> self control unknown-vector29 x)))
    (vector<-cspace! s5-0 (the-as cspace (-> self control unknown-vector29 y)))
    (vector-average! (-> self control unknown-vector30) gp-0 s5-0)
    )
  (vector-! (-> self control unknown-vector31) (-> self control unknown-vector30) (-> self control trans))
  ((method-of-type impact-control update-from-cspace)
   (the-as impact-control (-> self control unknown-cspace02))
   )
  (cond
    ((logtest? (-> self focus-status) (focus-status edge-grab))
     (target-compute-edge)
     )
    ((logtest? (-> self focus-status) (focus-status pole))
     (target-compute-pole)
     )
    )
  (target-calc-camera-pos)
  (set! (-> self control unknown-word01) 0)
  (cond
    ((logtest? (focus-status indax) (-> self focus-status))
     )
    (else
      (target-gun-joint-points)
      (target-board-joint-points)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs none.
(defbehavior do-target-gspot target ()
  (cond
    ((and (logtest? (-> self control status) (cshape-moving-flags on-surface))
          (!= (-> self control unknown-surface00 mode) 'swim)
          (!= (-> self control unknown-surface00 mode) 'dive)
          (not (and (-> self next-state) (= (-> self next-state name) 'target-flop)))
          (zero? (logand (-> self draw status) (draw-control-status no-draw no-draw-temp no-draw-bounds)))
          )
     (set! (-> self control gspot-pos quad) (-> self control trans quad))
     (set! (-> self control gspot-normal quad) (-> self control ground-poly-normal quad))
     (set! (-> self control unknown-pat-surface01) (-> self control ground-pat))
     )
    (else
      (let* ((gp-0 (new 'stack-no-clear 'collide-query))
             (a0-15 (-> self control))
             (t9-0 (method-of-object a0-15 collide-shape-moving-method-55))
             )
        (logclear (-> self control root-prim prim-core collide-with) (collide-spec water))
        #x46000000
        #x47a00000
        #x44800000
        (if (t9-0 a0-15)
            (set! (-> self control unknown-pat-surface01) (-> gp-0 best-other-tri pat))
            )
        )
      )
    )
  0
  (none)
  )

(defbehavior target-real-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control unknown-word03) gp-1)
        (flag-setup)
        (if (< (-> self control unknown-float15) 0.0)
            (set! (-> self control unknown-float15) (- 1.0 (-> self control unknown-cpad-info00 stick0-speed)))
            )
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (let ((f28-0 (debounce-speed
                         (-> self control unknown-float12)
                         (-> self control unknown-float13)
                         (-> self control unknown-vector12)
                         (-> self control unknown-vector13)
                         )
                       )
                )
            (when (!= (-> self control unknown-float15) 0.0)
              (let ((f0-12 (fmin 1.0 (-> self control unknown-float15))))
                (set! (-> self control unknown-float15) f0-12)
                (let ((a1-3 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (if (= f28-0 0.0)
                                  *zero-vector*
                                  s5-0
                                  )
                              f28-0
                              )
                            )
                      (a2-2 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (-> self control unknown-vector16)
                              (-> self control unknown-float14)
                              )
                            )
                      )
                  (vector-lerp! s5-0 (the-as vector a1-3) (the-as vector a2-2) f0-12)
                  )
                )
              (set! f28-0 (vector-length s5-0))
              (vector-normalize! s5-0 1.0)
              )
            (turn-to-vector s5-0 f28-0)
            )
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-38 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-38)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (set! (-> self control reaction) target-collision-reaction)
        (let ((a2-3 (new 'stack-no-clear 'collide-query)))
          (let ((v1-52 (-> self control)))
            (set! (-> a2-3 collide-with) (-> v1-52 root-prim prim-core collide-with))
            (set! (-> a2-3 ignore-process0) self)
            (set! (-> a2-3 ignore-process1) #f)
            (set! (-> a2-3 ignore-pat) (-> v1-52 pat-ignore-mask))
            )
          (set! (-> a2-3 action-mask) (collide-action solid))
          (collide-shape-method-32 (-> self control) (-> self control transv) (the-as uint a2-3) #x45800000)
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (target-method-27 *target* *collide-cache* *collide-edge-spec*)
            )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-83 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-83))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-83 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-100 'target-post)
          (s5-3 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-2 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-2 (-> gp-2 base-time)))
            (set! (-> s4-2 name) v1-100)
            (set! (-> s4-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
            )
          (set! (-> s4-2 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-2 color) s5-3)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-2)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-124 (+ (-> gp-3 depth) -1))
               (s5-4 (-> gp-3 segment v1-124))
               (s4-3 (-> gp-3 base-time))
               )
          (when (>= v1-124 0)
            (set! (-> s5-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-post target ()
  (target-real-post)
  (none)
  )

(defbehavior target-swim-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control unknown-word03) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (turn-to-vector s5-0 (-> self control unknown-float12))
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-17 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-17)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (let ((a2-0 (new 'stack-no-clear 'collide-query)))
          (let ((v1-30 (-> self control)))
            (set! (-> a2-0 collide-with) (-> v1-30 root-prim prim-core collide-with))
            (set! (-> a2-0 ignore-process0) self)
            (set! (-> a2-0 ignore-process1) #f)
            (set! (-> a2-0 ignore-pat) (-> v1-30 pat-ignore-mask))
            )
          (set! (-> a2-0 action-mask) (collide-action solid))
          (collide-shape-method-32 (-> self control) (-> self control transv) (the-as uint a2-0) #x45800000)
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (target-method-27 *target* *collide-cache* *collide-edge-spec*)
            )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-61 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-61))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-61 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-78 'target-post)
          (s5-3 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-2 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-2 (-> gp-2 base-time)))
            (set! (-> s4-2 name) v1-78)
            (set! (-> s4-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
            )
          (set! (-> s4-2 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-2 color) s5-3)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-2)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-102 (+ (-> gp-3 depth) -1))
               (s5-4 (-> gp-3 segment v1-102))
               (s4-3 (-> gp-3 base-time))
               )
          (when (>= v1-102 0)
            (set! (-> s5-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-stick-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control unknown-word03) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (turn-to-vector s5-0 0.0)
          )
        (add-thrust)
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (when *debug-segment*
          (let ((s5-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
                (v1-16 'target)
                (s4-0 *profile-target-color*)
                )
            (when (and *dproc* *debug-segment*)
              (let ((s3-0 (-> s5-1 data (-> s5-1 count))))
                (let ((s2-0 (-> s5-1 base-time)))
                  (set! (-> s3-0 name) v1-16)
                  (set! (-> s3-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s2-0))))
                  )
                (set! (-> s3-0 depth) (the-as uint (-> s5-1 depth)))
                (set! (-> s3-0 color) s4-0)
                (set! (-> s5-1 segment (-> s5-1 depth)) s3-0)
                )
              (+! (-> s5-1 count) 1)
              (+! (-> s5-1 depth) 1)
              (set! (-> s5-1 max-depth) (max (-> s5-1 max-depth) (-> s5-1 depth)))
              )
            )
          0
          )
        (let ((a2-0 (new 'stack-no-clear 'collide-query)))
          (let ((v1-29 (-> self control)))
            (set! (-> a2-0 collide-with) (-> v1-29 root-prim prim-core collide-with))
            (set! (-> a2-0 ignore-process0) self)
            (set! (-> a2-0 ignore-process1) #f)
            (set! (-> a2-0 ignore-pat) (-> v1-29 pat-ignore-mask))
            )
          (set! (-> a2-0 action-mask) (collide-action solid))
          (collide-shape-method-32 (-> self control) (-> self control transv) (the-as uint a2-0) #x45800000)
          )
        (if (and (logtest? (-> self control root-prim prim-core action) (collide-action check-edge))
                 (>= (vector-dot
                       (-> self control dynam gravity-normal)
                       (vector-! (new 'stack-no-clear 'vector) (-> self control trans) (-> self control gspot-pos))
                       )
                     (-> *TARGET-bank* edge-grab-height-off-ground)
                     )
                 )
            (target-method-27 *target* *collide-cache* *collide-edge-spec*)
            )
        (when *debug-segment*
          (let ((s5-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
            (when (and *dproc* *debug-segment*)
              (let* ((v1-60 (+ (-> s5-2 depth) -1))
                     (s4-1 (-> s5-2 segment v1-60))
                     (s3-1 (-> s5-2 base-time))
                     )
                (when (>= v1-60 0)
                  (set! (-> s4-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                  (+! (-> s5-2 depth) -1)
                  )
                )
              )
            )
          0
          )
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-77 'target-post)
          (s5-3 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-2 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-2 (-> gp-2 base-time)))
            (set! (-> s4-2 name) v1-77)
            (set! (-> s4-2 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-2))))
            )
          (set! (-> s4-2 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-2 color) s5-3)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-2)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-101 (+ (-> gp-3 depth) -1))
               (s5-4 (-> gp-3 segment v1-101))
               (s4-3 (-> gp-3 base-time))
               )
          (when (>= v1-101 0)
            (set! (-> s5-4 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-3))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-move-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control unknown-word03) gp-1)
        (flag-setup)
        (build-conversions (-> self control transv))
        (do-rotations1)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (vector-!
          (-> self control unknown-vector05)
          (-> self control unknown-vector04)
          (-> self control unknown-vector06)
          )
        (let ((a1-3 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a1-3 options) (overlaps-others-options oo0))
          (set! (-> a1-3 collide-with-filter) (the-as collide-spec -1))
          (set! (-> a1-3 tlist) *touching-list*)
          (find-overlapping-shapes (-> self control) a1-3)
          )
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-27 'target-post)
          (s5-0 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-0 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-0 (-> gp-2 base-time)))
            (set! (-> s4-0 name) v1-27)
            (set! (-> s4-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-0))))
            )
          (set! (-> s4-0 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-0 color) s5-0)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-0)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-51 (+ (-> gp-3 depth) -1))
               (s5-1 (-> gp-3 segment v1-51))
               (s4-1 (-> gp-3 base-time))
               )
          (when (>= v1-51 0)
            (set! (-> s5-1 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (when *debug-segment*
    (let ((gp-4 (-> self control)))
      (+! (-> gp-4 unknown-halfword00) 1)
      (let ((v1-62 (clear-record-tags! *history* (history-channel transv) (-> gp-4 unknown-halfword00) (the-as uint 2))))
        (set! (-> v1-62 origin quad) (-> gp-4 trans quad))
        (set! (-> v1-62 vector quad) (-> gp-4 transv quad))
        )
      (set! (-> (clear-record-tags! *history* (history-channel trans) (-> gp-4 unknown-halfword00) (the-as uint 2))
                vector
                quad
                )
            (-> gp-4 trans quad)
            )
      (let ((v1-68
              (clear-record-tags! *history* (history-channel collide-status) (-> gp-4 unknown-halfword00) (the-as uint 2))
              )
            )
        (set! (-> v1-68 collide-status)
              (the-as collide-status (logior (-> gp-4 status) (cshape-moving-flags csmf08)))
              )
        (set! (-> v1-68 vector z) (the-as float (-> gp-4 reaction-flag)))
        )
      )
    )
  (do-target-gspot)
  (target-powerup-process)
  (none)
  )

(defbehavior target-no-ja-move-post target ()
  (vector-!
    (-> self control unknown-vector05)
    (-> self control unknown-vector04)
    (-> self control unknown-vector06)
    )
  (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
    (set! (-> a1-2 options) (overlaps-others-options oo0))
    (set! (-> a1-2 collide-with-filter) (the-as collide-spec -1))
    (set! (-> a1-2 tlist) *touching-list*)
    (find-overlapping-shapes (-> self control) a1-2)
    )
  (target-calc-camera-pos)
  (do-target-gspot)
  (target-powerup-process)
  (target-board-joint-points)
  (none)
  )

(defbehavior reset-target-state target ((arg0 symbol))
  (when arg0
    (vector-identity! (-> self control scale))
    (quaternion-identity! (-> self control quat))
    (quaternion-identity! (-> self control unknown-quaternion00))
    (quaternion-identity! (-> self control dir-targ))
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control unknown-vector15 quad) (-> self control trans quad))
    )
  (target-exit)
  (target-timed-invulnerable-off self 0)
  (target-timed-invulnerable-off self 2)
  (set! (-> self control status) (cshape-moving-flags))
  (set! (-> self control unknown-dynamics00) *standard-dynamics*)
  (set! (-> self control surf) *standard-ground-surface*)
  (set! (-> self control unknown-vector02 quad) (-> self control unknown-dynamics00 gravity-normal quad))
  (quaternion-identity! (-> self control unknown-quaternion01))
  (set! (-> self control unknown-float04) 0.0)
  (set! (-> self control unknown-time-frame06) (-> self clock frame-counter))
  (set! (-> self control unknown-float27) 0.0)
  (set! (-> self control unknown-float29) 32.0)
  (set! (-> self cam-user-mode) 'normal)
  (set! (-> self control unknown-handle00) (the-as handle #f))
  (set! (-> self control unknown-handle01) (the-as handle #f))
  (set! (-> self control unknown-dword06) 0)
  (buzz-stop! 0)
  self
  )

;; WARN: Return type mismatch int vs none.
(defmethod init-target target ((obj target) (arg0 continue-point) (arg1 symbol))
  (local-vars (s1-0 int) (s2-0 int) (s3-0 int) (s4-0 int) (sv-16 collide-shape-prim-group))
  (set! (-> obj tobot?) arg1)
  (set! (-> obj tobot-recorder) #f)
  (set! (-> obj mode-cache) #f)
  (set! (-> obj color-effect) #f)
  (set-setting! 'allow-pause #f 0 0)
  (set-setting! 'allow-progress #f 0 0)
  (set! (-> *setting-control* cam-default mode-name) 'cam-string)
  (apply-settings *setting-control*)
  (if (not arg0)
      (set! arg0 (get-current-continue-point *game-info*))
      )
  (let* ((a0-6 *game-info*)
         (t9-4 (method-of-object a0-6 set-continue!))
         (a1-3 arg0)
         )
    (t9-4 a0-6 a1-3)
    )
  (stack-size-set! (-> obj main-thread) 1024)
  (logior! (-> obj mask) (process-mask target))
  (set! (-> obj state-hook) (the-as (function none :behavior target) nothing))
  (cond
    ((= (-> obj tobot?) 'tobot)
     (set! s4-0 #x40000)
     (set! s3-0 #x2183f7f)
     (set! s2-0 #x40000)
     (set! s1-0 #x218377e)
     )
    (else
      (set! s4-0 2)
      (set! s3-0 #x21c3f7d)
      (set! s2-0 2)
      (set! s1-0 #x21c377c)
      )
    )
  (let ((s0-0 (new 'process 'control-info obj (collide-list-enum hit-by-others))))
    (set! (-> s0-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s0-0 reaction) target-collision-reaction)
    (set! (-> s0-0 no-reaction) target-collision-no-reaction)
    (set! sv-16 (new 'process 'collide-shape-prim-group s0-0 (the-as uint 9) 1))
    (set! (-> s0-0 total-prims) (the-as uint 10))
    (set! (-> sv-16 prim-core action) (collide-action solid can-ride))
    (set-vector! (-> sv-16 local-sphere) 0.0 0.0 0.0 4096.0)
    (set! (-> s0-0 root-prim) sv-16)
    (set! (-> sv-16 prim-core collide-as) (the-as collide-spec s4-0))
    (set! (-> sv-16 prim-core collide-with) (the-as collide-spec s3-0))
    (let ((v0-9 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 6))))
      (set! (-> v0-9 prim-core action) (collide-action solid can-ride))
      (set-vector! (-> v0-9 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 0) v0-9)
      (set! (-> v0-9 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-9 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-10 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 10))))
      (set! (-> v0-10 prim-core action) (collide-action solid))
      (set-vector! (-> v0-10 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 1) v0-10)
      (set! (-> v0-10 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-10 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-11 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 18))))
      (set! (-> v0-11 prim-core action) (collide-action solid))
      (set-vector! (-> v0-11 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 2) v0-11)
      (set! (-> v0-11 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-11 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-12 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 34))))
      (set! (-> v0-12 prim-core action) (collide-action solid))
      (set-vector! (-> v0-12 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 3) v0-12)
      (set! (-> v0-12 prim-core collide-as) (collide-spec))
      (set! (-> v0-12 prim-core collide-with) (collide-spec))
      )
    (let ((v0-13 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 0))))
      (set! (-> v0-13 prim-core action) (collide-action semi-solid))
      (set! (-> v0-13 transform-index) 6)
      (set-vector! (-> v0-13 local-sphere) 0.0 0.0 0.0 2048.0)
      (set! (-> s0-0 unknown-sphere-array00 4) v0-13)
      (set! (-> v0-13 prim-core collide-as) (the-as collide-spec s4-0))
      (set! (-> v0-13 prim-core collide-with) (the-as collide-spec s3-0))
      )
    (let ((v0-14 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 128))))
      (set! (-> v0-14 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-14 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 6) v0-14)
      )
    (let ((v0-15 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 256))))
      (set! (-> v0-15 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-15 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 7) v0-15)
      )
    (let ((v0-16 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 512))))
      (set! (-> v0-16 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-16 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 8) v0-16)
      )
    (let ((v0-17 (new 'process 'collide-shape-prim-sphere s0-0 (the-as uint 1024))))
      (set! (-> v0-17 prim-core action) (collide-action deadly))
      (set-vector! (-> v0-17 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> s0-0 unknown-sphere-array00 9) v0-17)
      )
    (set! (-> s0-0 nav-radius) (* 0.75 (-> s0-0 root-prim local-sphere w)))
    (let ((v1-66 (-> s0-0 root-prim)))
      (set! (-> s0-0 backup-collide-as) (-> v1-66 prim-core collide-as))
      (set! (-> s0-0 backup-collde-with) (-> v1-66 prim-core collide-with))
      )
    (set! (-> s0-0 event-priority) (the-as uint 9))
    (set! (-> obj control) s0-0)
    )
  (let ((v1-69 (-> obj control)))
    (set! (-> v1-69 unknown-word04) s4-0)
    (set! (-> v1-69 unknown-word06) s3-0)
    (set! (-> v1-69 unknown-word05) s2-0)
    (set! (-> v1-69 unknown-word07) s1-0)
    (set! (-> v1-69 max-iteration-count) (the-as uint 8))
    (set! (-> v1-69 event-self) 'touched)
    )
  (set! (-> obj game) *game-info*)
  (collide-shape-method-29 (-> obj control) (-> arg0 trans))
  (set! (-> obj control unknown-vector15 quad) (-> arg0 trans quad))
  (set! (-> obj focus-search) (the-as (array collide-shape) (new 'process 'boxed-array collide-shape 128)))
  (set! (-> obj focus-search length) 0)
  (set! (-> obj control unknown-cpad-info00) (-> *cpad-list* cpads 0))
  (set! (-> obj control unknown-surface01) (new 'process 'surface))
  (set! (-> obj control unknown-surface01 name) 'current)
  (set! (-> obj control unknown-surface01 active-hook) nothing)
  (set! (-> obj control unknown-surface01 touch-hook) nothing)
  (set! (-> obj control unknown-dword05) (the-as uint #f))
  (dotimes (v1-84 8)
    (set! (-> obj attack-info-old v1-84 attacker) (the-as handle #f))
    )
  (set! (-> obj notify) (the-as uint #f))
  (set! (-> obj mirror) (the-as (pointer process-drawable) #f))
  (initialize-skeleton
    obj
    (the-as skeleton-group (art-group-get-by-name *level* "skel-jchar" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> obj skel effect flags) (effect-control-flag ecf0 ecf1))
  (let ((v1-94 (-> obj node-list data)))
    (set! (-> v1-94 0 param0) cspace<-transformq+trans!)
    (set! (-> v1-94 0 param1) (the-as basic (-> obj control trans)))
    (set! (-> v1-94 0 param2) (the-as basic (-> obj control unknown-vector05)))
    )
  (set! (-> obj skel override) (new 'process 'boxed-array float 54))
  (set! (-> obj draw light-index) (the-as uint 30))
  (set! (-> obj beard?) #t)
  (set! (-> obj draw lod-set max-lod) 0)
  (logior! (-> obj skel status) (joint-control-status sync-math blend-shape eye-anim))
  (set! (-> obj draw shadow-ctrl) *target-shadow-control*)
  (set! (-> obj shadow-backup) (-> obj draw shadow))
  (let ((t9-24 (method-of-type carry-info new))
        (a0-65 'process)
        (a1-23 carry-info)
        )
    41
    (new 'static 'array float 1 0.0)
    (new 'static 'array float 1 0.0)
    #x46471c72
    (set! (-> obj carry) (t9-24 a0-65 a1-23))
    )
  (set! (-> obj control unknown-vector29 x) (the-as float (-> obj node-list data 45)))
  (set! (-> obj control unknown-vector29 y) (the-as float (-> obj node-list data 55)))
  (set! (-> obj control unknown-vector29 y) (the-as float (-> obj node-list data 55)))
  (set! (-> obj control unknown-vector32 x) (the-as float (-> obj node-list data 23)))
  (set! (-> obj neck) (new 'process 'joint-mod (joint-mod-mode look-at) obj 8))
  (set! (-> obj neck parented-scale?) #t)
  (set! (-> obj neck base-joint) (the-as uint 6))
  (set! (-> obj neck ignore-angle) 16384.0)
  (set! (-> obj head) (new 'process 'joint-mod (joint-mod-mode flex-blend) obj 7))
  (set! (-> obj head parented-scale?) #t)
  (set! (-> obj upper-body) (new 'process 'joint-mod (joint-mod-mode gun-look-at) obj 4))
  (set! (-> obj upper-body parented-scale?) #t)
  (set! (-> obj horns) (new 'process 'joint-mod (joint-mod-mode joint-set) obj 42))
  (set! (-> obj horns parented-scale?) #t)
  (set! (-> obj horns track-mode) (track-mode no-trans no-rotate))
  (set! (-> obj hair 0) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 9))
  (set! (-> obj hair 0 parented-scale?) #t)
  (set! (-> obj hair 1) (new 'process 'joint-mod (joint-mod-mode joint-set*) obj 10))
  (set! (-> obj hair 1 parented-scale?) #t)
  (set! (-> obj arm-ik 0) (new 'process 'joint-mod-ik obj 17 1228.8))
  (set! (-> obj arm-ik 1) (new 'process 'joint-mod-ik obj 21 -1228.8))
  (set! (-> obj arm-ik 1 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> obj arm-ik 1 elbow-rotation-axis) (the-as uint 0))
  (set! (-> obj leg-ik 0) (new 'process 'joint-mod-ik obj 28 1687.552))
  (set! (-> obj leg-ik 0 callback) (the-as (function joint-mod-ik matrix matrix vector object) leg-ik-callback))
  (set! (-> obj leg-ik 0 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> obj leg-ik 0 elbow-rotation-axis) (the-as uint 0))
  (logior! (-> obj leg-ik 0 flags) (joint-mod-ik-flags elbow-trans-neg))
  (set! (-> obj leg-ik 1) (new 'process 'joint-mod-ik obj 35 -1687.552))
  (set! (-> obj leg-ik 1 callback) (the-as (function joint-mod-ik matrix matrix vector object) leg-ik-callback))
  (set! (-> obj leg-ik 1 elbow-pole-vector-axis) (the-as uint 2))
  (set! (-> obj leg-ik 1 elbow-rotation-axis) (the-as uint 0))
  (set! (-> obj foot 0) (new 'process 'joint-mod (joint-mod-mode foot-rot) obj 29))
  (set! (-> obj foot 1) (new 'process 'joint-mod (joint-mod-mode foot-rot) obj 36))
  (set! (-> obj fact)
        (new 'process 'fact-info-target obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (target-gun-setup (logtest? (-> obj game features) (game-feature unk-game-feature-06)))
  (target-board-setup (logtest? (-> obj game features) (game-feature board)))
  (target-sidekick-setup (logtest? (-> obj game features) (game-feature sidekick)))
  (target-darkjak-setup (logtest? (-> obj game features) (game-feature darkjak)))
  (target-collide-set! 'normal 0.0)
  (let ((v1-163 (-> obj control root-prim)))
    (set! (-> obj control backup-collide-as) (-> v1-163 prim-core collide-as))
    (set! (-> obj control backup-collde-with) (-> v1-163 prim-core collide-with))
    )
  (set! (-> obj sound) (new 'process 'ambient-sound "none" (-> obj control trans)))
  (set! (-> obj control unknown-sound-id02) (new-sound-id))
  (set! (-> obj control unknown-sound-id01) (new-sound-id))
  (set! (-> obj control unknown-sound-id00) (new-sound-id))
  (if (and *debug-segment* (!= (-> obj tobot?) 'tobot))
      (add-connection *debug-engine* obj target-print-stats obj *stdcon0* #f)
      )
  (if (!= (-> obj tobot?) 'tobot)
      (activate-hud obj)
      )
  (set! (-> obj fp-hud) (the-as handle #f))
  (set! (-> obj burn-proc) (the-as handle #f))
  (set! (-> obj water) (new 'process 'water-control obj 10 0.0 8192.0 2048.0))
  (set! (-> obj water flags) (water-flags swim-ground part-splash part-drip part-rings part-water find-water))
  (reset-target-state #t)
  (set! (-> obj control unknown-vector21 quad) (-> obj control trans quad))
  (set! (-> obj control unknown-vector21 y) (+ -819200.0 (-> obj control unknown-vector21 y)))
  (set! (-> obj align) (new 'process 'align-control obj))
  (set! (-> obj manipy) (the-as (pointer manipy) #f))
  (set! (-> obj event-hook) target-generic-event-handler)
  (set! (-> obj current-level) #f)
  (level-setup)
  (set! (-> obj pre-joint-hook) (the-as (function none :behavior target) nothing))
  (set! (-> obj init-time) (-> self clock frame-counter))
  (set! (-> obj spool-anim) #t)
  (set! (-> obj ambient-time) (-> self clock frame-counter))
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-init target ((arg0 continue-point))
  (init-target self arg0 #f)
  (set! (-> self event-hook) (-> target-continue event))
  (set! (-> self focus-status) (logior (focus-status teleporting) (-> self focus-status)))
  (go target-continue arg0)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior tobot-init target ((arg0 symbol))
  (init-target self (the-as continue-point #f) 'tobot)
  (set! (-> self name) "tobot")
  (set! (-> self tobot-recorder) (the-as basic arg0))
  (send-event *target* 'tobot 'tobot)
  (go tobot-stance)
  (none)
  )

(defmethod deactivate target ((obj target))
  (kill-persister *setting-control* (the-as engine-pers 'bg-a-speed) 'bg-a-speed)
  (if (nonzero? (-> obj darkjak))
      (sound-stop (the-as sound-id (-> obj darkjak tone)))
      )
  (set! (-> *setting-control* cam-default mode-name) #f)
  (set-zero! *camera-smush-control*)
  ((the-as (function target none) (find-parent-method target 10)) obj)
  (none)
  )

(defun stop ((arg0 symbol))
  (when *target*
    (kill-by-name "target" *active-pool*)
    (set! *target* #f)
    )
  (set! (-> *game-info* mode) arg0)
  0
  )

(defun start ((arg0 symbol) (arg1 continue-point))
  (let ((v1-0 arg0))
    (set! (-> *level* play?) (if (= v1-0 'play)
                                 #t
                                 (-> *setting-control* user-default border-mode)
                                 )
          )
    )
  (set! (-> *setting-control* user-default border-mode) #f)
  (set! (-> *setting-control* user-default region-mode) #f)
  (apply-settings *setting-control*)
  (stop arg0)
  (let ((v1-8 (process-spawn
                target
                :init target-init
                arg1
                :from *target-dead-pool*
                :to *target-pool*
                :stack *kernel-dram-stack*
                )
              )
        )
    (if v1-8
        (set! *target* (the-as target (-> v1-8 0 self)))
        (set! *target* #f)
        )
    )
  *target*
  )

;; WARN: Return type mismatch (pointer process) vs target.
(defun tobot-start ((arg0 symbol))
  (the-as target (process-spawn
                   target
                   :init tobot-init
                   arg0
                   :from *target-dead-pool*
                   :to *target-pool*
                   :stack *kernel-dram-stack*
                   )
          )
  )

(defun tobot-stop ()
  (kill-by-name "tobot" *active-pool*)
  0
  )




