;;-*-Lisp-*-
(in-package goal)

;; name: mech-states.gc
;; name in dgo: mech-states
;; dgos: DRILLMTN, UNB, RUI

;; DECOMP BEGINS

(define *mech-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 14 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 15 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 16 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 17 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 18 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 19 :parent-joint-index -1)
      )
    :collide-spec #x1
    )
  )

(defstate target-mech-start (target)
  :event target-mech-handler
  :exit target-mech-exit
  :code target-mech-init
  :post target-post
  )

(defstate target-mech-stance (target)
  :event target-mech-handler
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (set! (-> self control mod-surface turnvv) 40049.777)
    (set! (-> self control did-move-to-pole-or-max-jump-height) 0.0)
    (rot->dir-targ! (-> self control))
    (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
    (none)
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-mech-exit)
    (rot->dir-targ! (-> self control))
    (none)
    )
  :trans (behavior ()
    (if (and (move-legs?)
             (and (< (fabs
                       (deg-diff (quaternion-y-angle (-> self control dir-targ)) (vector-y-angle (-> self control to-target-pt-xz)))
                       )
                     1820.4445
                     )
                  (>= (- (current-time) (-> self control time-of-last-zero-input)) (seconds 0.05))
                  )
             )
        (go target-mech-walk)
        )
    (if (and (cpad-pressed? (-> self control cpad number) circle square) (can-hands? #t))
        (go target-mech-punch)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-mech-jump
          (-> *TARGET-bank* mech-jump-height-min)
          (-> *TARGET-bank* mech-jump-height-max)
          (the-as surface #f)
          )
        )
    (if (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                  (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                  )
                          (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                          )
                  (pad-buttons r1)
                  )
        (go target-mech-carry-pickup)
        )
    (if (and (or (cpad-pressed? (-> self control cpad number) triangle) (not (-> *setting-control* user-current pilot)))
             (target-mech-get-off?)
             )
        (go target-mech-get-off)
        )
    (fall-test target-mech-falling (-> *TARGET-bank* fall-height))
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 (-> self draw art-group data 327))))
        (let ((v1-8 (ja-group)))
          (if (and v1-8 (= v1-8 (-> self draw art-group data 326)))
              (sound-play "mech-stop")
              )
          )
        (ja-channel-push! 3 (seconds 0.2))
        (ja :group! (-> self draw art-group data 327) :dist 16384.0)
        (ja :chan 1 :group! (-> self draw art-group data 332) :dist 3640.889)
        (ja :chan 2 :group! (-> self draw art-group data 324) :dist 0.0)
        )
      )
    (let ((f28-0 0.0)
          (f30-0 0.0)
          (gp-1 #f)
          )
      (until #f
        (let ((f26-0 (y-angle (-> self control))))
          (deg-diff f26-0 (quaternion-y-angle (-> self control dir-targ)))
          (suspend)
          (let ((f26-1 (* (deg-diff f26-0 (y-angle (-> self control))) (-> self clock frames-per-second))))
            (cond
              ((< 910.2222 (fabs f26-1))
               (set! f28-0 (seek f28-0 1.0 (* 16.0 (-> self clock seconds-per-frame))))
               (set! gp-1 #t)
               )
              (else
                (set! f28-0 (seek f28-0 0.0 (* 6.0 (-> self clock seconds-per-frame))))
                (when (and gp-1 (= f28-0 0.0))
                  (set! gp-1 #f)
                  (sound-play "mech-twitch")
                  )
                )
              )
            (set! f30-0
                  (seek f30-0 (lerp-scale 1.0 0.0 (fabs f26-1) 3640.889 16384.0) (* 10.0 (-> self clock seconds-per-frame)))
                  )
            (let ((v1-41 (-> self skel effect)))
              (set! (-> v1-41 channel-offset) (cond
                                                ((< 0.8 (- 1.0 f28-0))
                                                 2
                                                 )
                                                ((< 0.5 f30-0)
                                                 1
                                                 )
                                                (else
                                                  0
                                                  )
                                                )
                    )
              )
            0
            (ja :num! (loop! (/ f26-1 (current-cycle-distance (-> self skel)))))
            (let ((a0-41 (-> self skel root-channel 1)))
              (set! (-> a0-41 frame-interp 1) f30-0)
              (set! (-> a0-41 frame-interp 0) f30-0)
              (set! (-> a0-41 param 0) 0.0)
              (joint-control-channel-group-eval! a0-41 (the-as art-joint-anim #f) num-func-chan)
              )
            (ja-no-eval :chan 1 :num! (loop! (/ f26-1 (current-cycle-distance (-> self skel)))))
            )
          )
        (let ((a0-44 (-> self skel root-channel 2)))
          (let ((f0-22 (- 1.0 f28-0)))
            (set! (-> a0-44 frame-interp 1) f0-22)
            (set! (-> a0-44 frame-interp 0) f0-22)
            )
          (set! (-> a0-44 param 0) 1.0)
          (joint-control-channel-group-eval! a0-44 (the-as art-joint-anim #f) num-func-loop!)
          )
        (can-play-stance-amibent?)
        )
      )
    #f
    (none)
    )
  :post target-mech-post
  )

(defstate target-mech-walk (target)
  :event target-mech-handler
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-walk-mods*)
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control unknown-word04) (the-as uint 0.0))
    (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
    (none)
    )
  :exit (behavior ()
    (target-effect-exit)
    (target-mech-exit)
    (none)
    )
  :trans (behavior ()
    (if (and (cpad-pressed? (-> self control cpad number) circle square) (can-hands? #t))
        (go target-mech-punch)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-mech-jump
          (-> *TARGET-bank* mech-jump-height-min)
          (-> *TARGET-bank* mech-jump-height-max)
          (the-as surface #f)
          )
        )
    (let ((gp-0 (ja-group))
          (f0-2 (ja-aframe-num 0))
          )
      (when (if (or (and (= gp-0 (-> self draw art-group data 326)) (>= f0-2 5.5) (>= 9.5 f0-2))
                    (and (= gp-0 (-> self draw art-group data 326)) (>= f0-2 20.5) (>= 24.5 f0-2))
                    )
                #t
                )
        (case (-> self control unknown-spool-anim00)
          (('punch)
           (go target-mech-punch)
           )
          (('jump)
           (if (can-jump? #f)
               (go
                 target-mech-jump
                 (-> *TARGET-bank* mech-jump-height-min)
                 (-> *TARGET-bank* mech-jump-height-max)
                 (the-as surface #f)
                 )
               (set! (-> self control unknown-word04) (the-as uint #f))
               )
           )
          )
        (when (and (< 5.0 (the-as float (-> self control unknown-word04)))
                   (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                   )
          (set-forward-vel 0.0)
          (go target-mech-stance)
          )
        (if (and (or (cpad-pressed? (-> self control cpad number) triangle) (not (-> *setting-control* user-current pilot)))
                 (target-mech-get-off?)
                 )
            (go target-mech-get-off)
            )
        )
      )
    (if (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                  (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                  )
                          (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                          )
                  (pad-buttons r1)
                  )
        (go target-mech-carry-pickup)
        )
    (fall-test target-mech-falling (-> *TARGET-bank* fall-height))
    (none)
    )
  :code (behavior ()
    (let ((f30-0 0.0)
          (f28-0 0.0)
          )
      (let ((f26-0 (cond
                     ((zero? (-> self mech walk-anim-leg))
                      (set! (-> self mech walk-anim-leg) 1)
                      7.0
                      )
                     (else
                       (set! (-> self mech walk-anim-leg) 0)
                       22.0
                       )
                     )
                   )
            (v1-7 (ja-group))
            )
        (when (not (and v1-7 (= v1-7 (-> self draw art-group data 326))))
          (ja-channel-push! 3 (seconds 0.1))
          (ja :group! (-> self draw art-group data 326)
              :num! (identity (ja-aframe f26-0 0))
              :dist (-> *TARGET-bank* mech-walk-cycle-dist)
              )
          (ja :chan 1 :group! (-> self draw art-group data 325) :dist (-> *TARGET-bank* mech-run-cycle-dist))
          (ja :chan 2 :group! (-> self draw art-group data 324) :dist 0.0)
          )
        )
      (until #f
        (if (< (-> self control ctrl-xz-vel) 8192.0)
            (set-forward-vel 8192.0)
            )
        (suspend)
        (let* ((f0-5 (current-cycle-distance (-> self skel)))
               (f26-1 (/ (-> self control ctrl-xz-vel) f0-5))
               )
          (set! (-> self control unknown-word04)
                (the-as uint (+ (the-as float (-> self control unknown-word04)) f26-1))
                )
          (set! f30-0 (seek
                        f30-0
                        (lerp-scale 0.0 1.0 (-> self control ctrl-xz-vel) 16384.0 32768.0)
                        (* 2.0 (-> self clock seconds-per-frame))
                        )
                )
          (set! f28-0 (seek
                        f28-0
                        (lerp-scale 1.0 0.0 (-> self control ctrl-xz-vel) 0.0 12288.0)
                        (* 2.0 (-> self clock seconds-per-frame))
                        )
                )
          (let ((v1-39 (-> self skel effect)))
            (set! (-> v1-39 channel-offset) (if (< 0.5 f30-0)
                                                1
                                                0
                                                )
                  )
            )
          0
          (ja :num! (loop! f26-1))
          )
        (let ((a0-24 (-> self skel root-channel 1)))
          (set! (-> a0-24 frame-interp 1) f30-0)
          (set! (-> a0-24 frame-interp 0) f30-0)
          (set! (-> a0-24 param 0) 0.0)
          (joint-control-channel-group-eval! a0-24 (the-as art-joint-anim #f) num-func-chan)
          )
        (let ((a0-25 (-> self skel root-channel 2)))
          (set! (-> a0-25 frame-interp 1) f28-0)
          (set! (-> a0-25 frame-interp 0) f28-0)
          (set! (-> a0-25 param 0) 0.0)
          (joint-control-channel-group-eval! a0-25 (the-as art-joint-anim #f) num-func-chan)
          )
        )
      )
    #f
    (none)
    )
  :post target-mech-post
  )

(defbehavior target-mech-punch-pick target ((arg0 symbol))
  (local-vars (sv-64 float))
  (combo-tracker-method-12
    (-> self control unknown-combo-tracker00)
    *null-vector*
    *null-vector*
    (the-as process #f)
    (current-time)
    )
  (let* ((s4-0 (get-trans self 3))
         (a0-4 (the-as process-focusable (combo-tracker-method-13
                                           (-> self control unknown-combo-tracker00)
                                           (-> self control send-attack-dest)
                                           s4-0
                                           32768.0
                                           (-> self control c-R-w vector 2)
                                           65536.0
                                           )
                       )
               )
         (s5-0 (the-as art-element #f))
         )
    (when a0-4
      (let ((s3-0 (get-trans a0-4 3)))
        (let ((s0-0 (-> self control))
              (s1-0 s3-0)
              (s2-0 deg-diff)
              )
          (set! sv-64 (y-angle s0-0))
          (let* ((a1-4 (vector-y-angle (vector-! (new 'stack-no-clear 'vector) s1-0 (-> s0-0 trans))))
                 (f0-0 (s2-0 sv-64 a1-4))
                 )
            (cond
              ((< (+ 12288.0 (-> s4-0 y)) (-> s3-0 y))
               (set! (-> self mech walk-anim-leg) 3)
               )
              ((>= f0-0 5461.3335)
               (set! (-> self mech walk-anim-leg) 0)
               0
               )
              ((>= -5461.3335 f0-0)
               (set! (-> self mech walk-anim-leg) 1)
               )
              (else
                (set! (-> self mech walk-anim-leg) 2)
                )
              )
            )
          )
        (if (< (vector-vector-distance s3-0 s4-0) 32768.0)
            (forward-up-nopitch->quaternion
              (-> self control dir-targ)
              (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s3-0 s4-0) 1.0)
              (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
              )
            )
        )
      )
    (let ((v1-26 (-> self mech walk-anim-leg)))
      (cond
        ((zero? v1-26)
         (set! (-> self mech walk-anim-leg) 1)
         (set! s5-0 (-> self draw art-group data 333))
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (the-as process-drawable (ppointer->process (-> self manipy)))
          7
          6963.2
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        ((= v1-26 1)
         (set! (-> self mech walk-anim-leg) 0)
         (set! s5-0 (-> self draw art-group data 334))
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (the-as process-drawable (ppointer->process (-> self manipy)))
          17
          6963.2
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        ((= v1-26 2)
         (set! (-> self mech walk-anim-leg) 0)
         (set! s5-0 (-> self draw art-group data 335))
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (the-as process-drawable (ppointer->process (-> self manipy)))
          39
          11141.12
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        ((= v1-26 3)
         (set! (-> self mech walk-anim-leg) 0)
         (set! s5-0 (-> self draw art-group data 353))
         ((method-of-type impact-control initialize)
          (the-as impact-control (-> self mech state-impact))
          (the-as process-drawable (ppointer->process (-> self manipy)))
          39
          11141.12
          (logior (collide-spec mech-punch) (-> self control root-prim prim-core collide-with))
          )
         )
        )
      )
    (ja-channel-push! 1 (seconds 0.1))
    (if (zero? arg0)
        (ja-no-eval :group! s5-0 :num! (seek! (the float (+ (-> (the-as art-joint-anim s5-0) frames num-frames) -1))))
        (ja-no-eval :group! s5-0
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim s5-0) frames num-frames) -1)))
                    :frame-num (ja-aframe 10.0 0)
                    )
        )
    )
  (-> self mech walk-anim-leg)
  )

(defstate target-mech-punch (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (cond
      ((focus-test? self dangerous)
       (case event-type
         (('touched)
          (if ((method-of-type touching-shapes-entry prims-touching?)
               (the-as touching-shapes-entry (-> event param 0))
               (-> self control)
               (the-as uint 1920)
               )
              (target-send-attack
                proc
                (-> self control danger-mode)
                (the-as touching-shapes-entry (-> event param 0))
                (the-as int (-> self control target-attack-id))
                (the-as int (-> self control attack-count))
                (-> self control penetrate-using)
                )
              (target-mech-handler proc arg1 event-type event)
              )
          )
         (('impact-control)
          (when (-> self control danger-mode)
            (-> event param 1)
            (let* ((gp-1 (the-as object (-> event param 3)))
                   (s5-1 (-> (the-as collide-query gp-1) best-other-tri collide-ptr))
                   (s4-1 (if (type? s5-1 collide-shape-prim)
                             (the-as collide-shape-prim s5-1)
                             )
                         )
                   (s3-1 (if s4-1
                             (-> s4-1 cshape process)
                             (the-as process-drawable #f)
                             )
                         )
                   (s5-2 (if (type? s3-1 process-focusable)
                             s3-1
                             )
                         )
                   )
              (if (and s4-1
                       (and (or (and s5-2 (focus-test? (the-as process-focusable s5-2) dead))
                                (let ((a1-6 (new 'stack-no-clear 'event-message-block)))
                                  (set! (-> a1-6 from) (process->ppointer self))
                                  (set! (-> a1-6 num-params) 2)
                                  (set! (-> a1-6 message) 'attack)
                                  (set! (-> a1-6 param 0) (the-as uint #f))
                                  (let ((v1-20 (new 'static 'attack-info :mask (attack-info-mask intersection mode id count penetrate-using))))
                                    (set! (-> v1-20 id) (-> self control target-attack-id))
                                    (set! (-> v1-20 mode) (-> self control danger-mode))
                                    (set! (-> v1-20 count) (-> self control attack-count))
                                    (set! (-> v1-20 penetrate-using) (penetrate touch punch mech mech-punch))
                                    (set! (-> v1-20 intersection quad) (-> (the-as collide-query gp-1) best-other-tri intersect quad))
                                    (set! (-> a1-6 param 1) (the-as uint v1-20))
                                    )
                                  (when (send-event-function (-> s4-1 cshape process) a1-6)
                                    (set! (-> self control send-attack-dest) (process->handle s5-2))
                                    (set! (-> self control send-attack-time) (current-time))
                                    #t
                                    )
                                  )
                                )
                            s5-2
                            (focus-test? (the-as process-focusable s5-2) dead)
                            )
                       )
                  (set! (-> self mech forward-vel) 0.0)
                  (set! (-> self mech forward-vel) -40960.0)
                  )
              (when (or (not s5-2) (= (-> self control send-attack-time) (current-time)))
                (let ((s5-3 (get-process *default-dead-pool* part-tracker #x4000)))
                  (when s5-3
                    (let ((t9-7 (method-of-type part-tracker activate)))
                      (t9-7 (the-as part-tracker s5-3) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                      )
                    (let ((t9-8 run-function-in-process)
                          (a0-33 s5-3)
                          (a1-9 part-tracker-init)
                          (a2-8 (-> *part-group-id-table* 11))
                          (a3-4 0)
                          (t0-1 #f)
                          (t1-1 #f)
                          (t2-0 #f)
                          (t3-0 *launch-matrix*)
                          )
                      (set! (-> t3-0 trans quad) (-> (the-as collide-query gp-1) best-other-tri intersect quad))
                      ((the-as (function object object object object object object object object none) t9-8)
                       a0-33
                       a1-9
                       a2-8
                       a3-4
                       t0-1
                       t1-1
                       t2-0
                       t3-0
                       )
                      )
                    (-> s5-3 ppointer)
                    )
                  )
                (sound-play "mech-punch-hit" :position (+ (the-as uint gp-1) 48))
                (activate! *camera-smush-control* 1638.4 15 75 1.0 0.9 (-> *display* camera-clock))
                )
              )
            )
          )
         (else
           (target-mech-handler proc arg1 event-type event)
           )
         )
       )
      (else
        (target-mech-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *mech-punch-mods*)
    (set! (-> self mech state-impact? 0) #f)
    (rot->dir-targ! (-> self control))
    (none)
    )
  :exit (behavior ()
    (set! (-> *mech-punch-mods* turnvv) 0.0)
    (set! (-> self mech state-impact? 0) #f)
    (set! (-> self control last-running-attack-end-time) (current-time))
    (target-exit)
    (target-mech-exit)
    (none)
    )
  :code (behavior ()
    (set! (-> self mech forward-vel) (-> self control ctrl-xz-vel))
    1.0
    (let ((s5-0 #f)
          (gp-0 0)
          (s4-0 30)
          )
      (target-mech-punch-pick (the-as symbol gp-0))
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (when (and (not (focus-test? self dangerous))
                   (let ((v1-10 (ja-group)))
                     (and v1-10 (or (= v1-10 (-> self draw art-group data 333))
                                    (= v1-10 (-> self draw art-group data 334))
                                    (= v1-10 (-> self draw art-group data 335))
                                    (= v1-10 (-> self draw art-group data 353))
                                    )
                          )
                     )
                   (>= (ja-aframe-num 0) 12.0)
                   )
          (target-start-attack)
          (target-danger-set! 'mech-punch #f)
          )
        (when (and (cpad-pressed? (-> self control cpad number) circle square) (< gp-0 2))
          (let ((s3-0 (ja-group))
                (f30-0 (ja-aframe-num 0))
                )
            (if (or (and (= s3-0 (-> self draw art-group data 333))
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 333)) frames num-frames) -1))
                             (ja-frame-num 0)
                             )
                         )
                    (and (= s3-0 (-> self draw art-group data 334))
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 334)) frames num-frames) -1))
                             (ja-frame-num 0)
                             )
                         )
                    (and (= s3-0 (-> self draw art-group data 335))
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 335)) frames num-frames) -1))
                             (ja-frame-num 0)
                             )
                         )
                    (and (= s3-0 (-> self draw art-group data 353))
                         (>= f30-0 2.0)
                         (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 353)) frames num-frames) -1))
                             (ja-frame-num 0)
                             )
                         )
                    )
                (set! s5-0 #t)
                )
            )
          )
        (when s5-0
          (let ((s3-1 (ja-group))
                (f30-2 (ja-aframe-num 0))
                )
            (when (or (and (= s3-1 (-> self draw art-group data 333))
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 333)) frames num-frames) -1))
                               (ja-frame-num 0)
                               )
                           )
                      (and (= s3-1 (-> self draw art-group data 334))
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 334)) frames num-frames) -1))
                               (ja-frame-num 0)
                               )
                           )
                      (and (= s3-1 (-> self draw art-group data 335))
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 335)) frames num-frames) -1))
                               (ja-frame-num 0)
                               )
                           )
                      (and (= s3-1 (-> self draw art-group data 353))
                           (>= f30-2 21.0)
                           (>= (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 353)) frames num-frames) -1))
                               (ja-frame-num 0)
                               )
                           )
                      )
              (+! gp-0 1)
              (target-mech-punch-pick (the-as symbol gp-0))
              (set! (-> self state-time) (+ (current-time) (seconds -0.465)))
              (set! (-> self mech forward-vel) (fmax 0.0 (-> self mech forward-vel)))
              (set! s4-0 159)
              (set! s5-0 #f)
              )
            )
          )
        (let ((v1-142 (- (current-time) (-> self state-time)))
              (s3-2 #t)
              (f30-4 1.0)
              )
          (cond
            ((< (-> self mech forward-vel) 0.0)
             (seek! (-> self mech forward-vel) -0.04096 (* 122880.0 (-> self clock seconds-per-frame)))
             )
            ((let ((a0-43 (ja-group)))
               (and a0-43 (or (= a0-43 (-> self draw art-group data 335)) (= a0-43 (-> self draw art-group data 353))))
               )
             (cond
               ((< v1-142 (seconds 0.465))
                (set! s3-2 #f)
                )
               ((< v1-142 (seconds 0.53))
                (set! (-> self mech forward-vel) (lerp-scale 40960.0 81920.0 (the float v1-142) 139.8 159.98999))
                )
               (else
                 (set! (-> self mech forward-vel) (lerp-scale 81920.0 0.0 (the float v1-142) 159.98999 300.0))
                 )
               )
             )
            (else
              (let ((a0-50 (ja-group)))
                (cond
                  ((and a0-50 (= a0-50 (-> self draw art-group data 333)))
                   (cond
                     ((< v1-142 (seconds 0.465))
                      (seek! (-> self mech forward-vel) 0.0 (* 20480.0 (-> self clock seconds-per-frame)))
                      (set! s3-2 #f)
                      )
                     ((< v1-142 (seconds 0.53))
                      (set! (-> self mech forward-vel) (lerp-scale 20480.0 40960.0 (the float v1-142) 139.8 159.98999))
                      )
                     (else
                       (set! (-> self mech forward-vel) (lerp-scale 40960.0 0.0 (the float v1-142) 159.98999 300.0))
                       )
                     )
                   )
                  ((< v1-142 (seconds 0.465))
                   (seek! (-> self mech forward-vel) 0.0 (* 20480.0 (-> self clock seconds-per-frame)))
                   (set! s3-2 #f)
                   )
                  ((< v1-142 (seconds 0.53))
                   (set! (-> self mech forward-vel) (lerp-scale 20480.0 40960.0 (the float v1-142) 139.8 159.98999))
                   )
                  (else
                    (set! (-> self mech forward-vel) (lerp-scale 40960.0 0.0 (the float v1-142) 159.98999 300.0))
                    )
                  )
                )
              )
            )
          (set! s3-2
                (and (>= (- (current-time) (-> self state-time)) s4-0) (and (>= (-> self mech forward-vel) 0.0) s3-2))
                )
          (set! (-> self mech state-impact? 0) s3-2)
          (set-forward-vel (-> self mech forward-vel))
          (when (< 20480.0 (vector-length (-> self control transv)))
            (do-effect (-> self skel effect) 'effect-slide-poof (ja-frame-num 0) 38)
            (do-effect (-> self skel effect) 'effect-slide-poof (ja-frame-num 0) 31)
            )
          (suspend)
          (ja :num! (seek! max (* (-> self control current-surface align-speed) f30-4)))
          )
        )
      )
    (go target-mech-stance)
    (none)
    )
  :post target-mech-post
  )

(defstate target-mech-falling (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v0-0 (target-mech-bonk-event-handler proc arg1 event-type event)))
      (cond
        (v0-0
          (empty)
          v0-0
          )
        (else
          (target-mech-handler proc arg1 event-type event)
          )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *mech-jump-mods*)
    (set! (-> self mech jump-thrust) 0.0)
    (let* ((v1-4 *game-info*)
           (v0-0 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) v0-0)
      (set! (-> self control target-attack-id) v0-0)
      )
    (none)
    )
  :exit (behavior ()
    (set! (-> self mech jump-thrust) 0.0)
    (set! (-> self mech thruster-flame-width) 0.0)
    (set! (-> self mech thruster-flame-length) 0.0)
    (target-exit)
    (target-mech-exit)
    (none)
    )
  :trans (behavior ()
    (local-vars (a0-0 none))
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-mech-hit-ground (the-as symbol a0-0))
        )
    (let ((f0-0 (target-move-dist (-> *TARGET-bank* stuck-time)))
          (v1-9 (ja-group))
          )
      (when (if (and (and v1-9 (= v1-9 (-> self draw art-group data 330)))
                     (< f0-0 (-> *TARGET-bank* stuck-distance))
                     (and (>= (- (current-time) (-> self state-time)) (seconds 2))
                          (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                          )
                     )
                #t
                )
        (logior! (-> self control status) (collide-status on-surface))
        (go target-mech-hit-ground 'stuck)
        )
      )
    (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
      (let ((f0-2 (-> self mech jump-thrust-fuel)))
        (cond
          ((cpad-hold? (-> self control cpad number) x)
           (cond
             ((= f0-2 0.0)
              (seek! (-> self mech jump-thrust) 0.0 (* 245760.0 (-> self clock seconds-per-frame)))
              )
             ((!= f0-2 (-> *TARGET-bank* mech-jump-thrust-fuel))
              (let ((f26-0
                      (lerp-scale 122880.0 8192.0 (-> self mech jump-thrust-fuel) 600.0 (-> *TARGET-bank* mech-jump-thrust-fuel))
                      )
                    (f28-0
                      (lerp-scale 409.6 8192.0 (-> self mech jump-thrust-fuel) 600.0 (-> *TARGET-bank* mech-jump-thrust-fuel))
                      )
                    )
                (seek!
                  (-> self mech jump-thrust)
                  (- (- (-> self control dynam gravity-length) f30-0) f26-0)
                  (* 8192000.0 (-> self clock seconds-per-frame))
                  )
                (set! (-> self mech thruster-flame-width) (* 0.75 f28-0))
                (set! (-> self mech thruster-flame-length) f28-0)
                )
              )
             (else
               (set! (-> self mech jump-thrust) 0.0)
               (set! (-> self mech thruster-flame-width) 12288.0)
               (set! (-> self mech thruster-flame-length) 20480.0)
               )
             )
           (seek! (-> self mech jump-thrust-fuel) 0.0 (the float (- (current-time) (-> self clock old-frame-counter))))
           )
          (else
            (seek! (-> self mech jump-thrust) 0.0 (* 491520.0 (-> self clock seconds-per-frame)))
            (set! (-> self mech thruster-flame-width) (* 0.021428572 (-> self mech jump-thrust)))
            (set! (-> self mech thruster-flame-length) (* 0.028571429 (-> self mech jump-thrust)))
            )
          )
        )
      (let ((v1-85 (new-stack-vector0)))
        (let ((f0-36 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
          0.0
          (vector-! v1-85 (-> self control transv) (vector-float*! v1-85 (-> self control dynam gravity-normal) f0-36))
          )
        (let* ((f0-37 (vector-length v1-85))
               (f1-9 f0-37)
               (f2-2 (+ f30-0 (* (-> self mech jump-thrust) (-> self clock seconds-per-frame))))
               )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
            (vector-float*! v1-85 v1-85 (/ f0-37 f1-9))
            )
          )
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol))
    (until #f
      (cond
        ((< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
         (let ((v1-7 (ja-group)))
           (when (not (and v1-7 (= v1-7 (-> self draw art-group data 329))))
             (ja-channel-push! 1 (seconds 0.1))
             (ja :group! (-> self draw art-group data 329) :num! min)
             )
           )
         (suspend)
         (ja :num! (loop! 0.75))
         )
        (else
          (let ((v1-22 (ja-group)))
            (when (not (and v1-22 (= v1-22 (-> self draw art-group data 330))))
              (ja-channel-push! 1 (seconds 0.5))
              (ja :group! (-> self draw art-group data 330) :num! min)
              )
            )
          (suspend)
          (ja :num! (loop!))
          )
        )
      )
    #f
    (none)
    )
  :post target-mech-post
  )

(defstate target-mech-jump (target)
  :event (-> target-mech-falling event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (set! (-> self state-time) (current-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (let* ((v1-4 *game-info*)
           (a2-5 (+ (-> v1-4 attack-id) 1))
           )
      (set! (-> v1-4 attack-id) a2-5)
      (set! (-> self control target-attack-id) a2-5)
      )
    (set! (-> self mech jump-thrust) 0.0)
    (init-var-jump arg0 arg1 #t #f (-> self control transv) 2.0)
    (set! (-> self control unknown-symbol03) (the-as float arg2))
    (set! (-> self control mod-surface) *mech-jump-mods*)
    (none)
    )
  :exit (-> target-mech-falling exit)
  :trans (-> target-mech-falling trans)
  :code (behavior ((arg0 float) (arg1 float) (arg2 surface))
    (let ((v1-2 (ja-group)))
      (if (and v1-2 (= v1-2 (-> self draw art-group data 331)))
          (ja-channel-push! 1 (seconds 0.5))
          (ja-channel-push! 1 (seconds 0.05))
          )
      )
    ((the-as (function none) (-> target-mech-falling code)))
    (none)
    )
  :post target-mech-post
  )

(defstate target-mech-hit-ground (target)
  :event target-mech-handler
  :enter (behavior ((arg0 symbol))
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self mech thrust-sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 48)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
    (set! (-> self state-time) (current-time))
    (cond
      ((= arg0 'stuck)
       )
      (else
        (target-land-effect)
        )
      )
    (set! (-> self control last-running-attack-end-time) 0)
    (set! (-> self control last-attack-end-time) 0)
    (if (!= (-> self control ground-pat material) (pat-material ice))
        (delete-back-vel)
        )
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (start-bobbing!
      (-> self water)
      (lerp-scale 0.0 4096.0 (-> self control ground-impact-vel) 40960.0 102400.0)
      600
      1500
      )
    (activate! *camera-smush-control* 1638.4 15 75 1.0 0.9 (-> *display* camera-clock))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
    (target-mech-exit)
    (none)
    )
  :trans (behavior ()
    (if (and (cpad-pressed? (-> self control cpad number) circle square) (can-hands? #t))
        (go target-mech-punch)
        )
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.25))
      (if (move-legs?)
          (go target-mech-walk)
          )
      (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? #f)
               )
          (go
            target-mech-jump
            (-> *TARGET-bank* mech-jump-height-min)
            (-> *TARGET-bank* mech-jump-height-max)
            (the-as surface #f)
            )
          )
      (if (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                    (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                    )
                            (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                            )
                    (pad-buttons r1)
                    )
          (go target-mech-carry-pickup)
          )
      )
    (set-forward-vel 0.0)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (target-hit-ground-anim #f (are-still?))
    (go target-mech-stance)
    (none)
    )
  :post target-mech-post
  )

(defstate target-mech-hit (target)
  :event target-mech-handler
  :exit (behavior ()
    ((-> target-hit exit))
    (target-mech-exit)
    (none)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (set! (-> self control time-of-last-debug-heal) (current-time))
        (pickup-collectable! (-> self fact-override) (pickup-type health) 100.0 (the-as handle #f))
        (go target-mech-stance)
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flags jump-out))
    (set! (-> self state-time) (current-time))
    (let ((gp-0 (-> self attack-info))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (let ((v1-4 gp-0))
        (set! (-> v1-4 attacker) (the-as handle #f))
        (set! (-> v1-4 mode) 'generic)
        (set! (-> v1-4 shove-back) 10240.0)
        (set! (-> v1-4 shove-up) 6144.0)
        (set! (-> v1-4 angle) #f)
        (set! (-> v1-4 trans quad) (-> self control trans quad))
        (set! (-> v1-4 control) 0.0)
        (set! (-> v1-4 invinc-time) (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)))
        )
      (case arg0
        (('shove)
         (let ((v1-7 gp-0))
           (set! (-> v1-7 shove-back) (-> *TARGET-bank* smack-surface-dist))
           (set! (-> v1-7 shove-up) (-> *TARGET-bank* smack-surface-height))
           (set! (-> v1-7 angle) 'shove)
           )
         )
        )
      (combine! gp-0 arg1 self)
      (when (not (logtest? (-> gp-0 mask) (attack-info-mask vector)))
        (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-for-control))
        (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
        (set! (-> gp-0 vector y) (-> gp-0 shove-up))
        )
      (set! (-> s5-0 quad) (-> gp-0 vector quad))
      (let ((f0-10 (vector-dot
                     (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)
                     (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                     )
                   )
            )
        (if (not (-> self attack-info angle))
            (set! (-> self attack-info angle) (if (>= 0.0 f0-10)
                                                  'front
                                                  'back
                                                  )
                  )
            )
        )
      (cond
        ((= arg0 'attack)
         (logior! (-> self focus-status) (focus-status hit))
         (set! (-> self game hit-time) (current-time))
         (case (-> gp-0 mode)
           (('endlessfall)
            (cond
              ((= (-> self game mode) 'debug)
               (let ((s4-1 (new-stack-vector0)))
                 (set! (-> s4-1 quad) (-> self control last-trans-on-ground quad))
                 (ja-channel-set! 0)
                 (let ((s3-1 (current-time)))
                   (until (>= (- (current-time) s3-1) (seconds 1))
                     (suspend)
                     )
                   )
                 (move-to-point! (-> self control) s4-1)
                 )
               (set! (-> self control camera-pos quad) (-> self control trans quad))
               (send-event *camera* 'teleport)
               (go target-mech-stance)
               )
              (else
                (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
                (go target-mech-death (-> gp-0 mode))
                )
              )
            )
           )
         (target-hit-effect gp-0)
         (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
         (go target-mech-death (-> gp-0 mode))
         )
        (else
          (case (-> gp-0 mode)
            (('burn 'burnup)
             (sound-play "get-burned")
             )
            )
          )
        )
      (set! (-> self control mod-surface) *smack-mods*)
      (let ((v1-63 (ja-group)))
        (when (not (and v1-63 (= v1-63 (-> self draw art-group data 348))))
          (ja-channel-push! 1 (seconds 0.075))
          (ja :group! (-> self draw art-group data 348) :num! min)
          )
        )
      (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-mech-falling-anim-trans 1.0)
      )
    (go target-mech-hit-ground #f)
    (none)
    )
  :post (behavior ()
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (vector-float*!
      (-> self control dynam gravity)
      (-> self control dynam gravity-normal)
      (the-as float (-> self control dynam gravity-length))
      )
    (target-mech-post)
    (none)
    )
  )

(defstate target-mech-death (target)
  :event (-> target-death event)
  :exit (behavior ()
    (set! (-> self mech stick-off) #f)
    (target-mech-exit)
    ((-> target-death exit))
    (none)
    )
  :trans (-> target-mech-hit trans)
  :code (behavior ((arg0 symbol))
    (set! (-> self mech stick-off) (the-as basic #t))
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height)
          (the-as float (send-event (handle->process (-> self attack-info attacker)) 'target 'die arg0))
          )
    (set! (-> self neck flex-blend) 0.0)
    (target-timed-invulnerable-off self 0)
    (target-timed-invulnerable-off self 0)
    (set-setting! 'process-mask 'set 0.0 (process-mask platform projectile death))
    (apply-settings *setting-control*)
    (set! (-> self control transv quad) (the-as uint128 0))
    (logior! (-> self focus-status) (focus-status dead))
    (cond
      ((or (= arg0 'none) (= arg0 'instant-death) (= arg0 'bot) (= arg0 'big-explosion))
       )
      ((= arg0 'grenade)
       (sound-play "explosion")
       )
      ((= arg0 'endlessfall)
       (sound-play "mech-death-fall")
       (set! (-> self control unknown-sound-id00)
             (add-process *gui-control* *target* (gui-channel daxter) (gui-action play) "jakfall" -99.0 0)
             )
       (set-falloff! *gui-control* (-> self control unknown-sound-id00) #t -1 100 2)
       (set-setting! 'mode-name 'cam-endlessfall 0.0 0)
       (set! (-> self control pat-ignore-mask)
             (logior (new 'static 'pat-surface :noendlessfall #x1) (-> self control pat-ignore-mask))
             )
       (logclear! (-> self water flags) (water-flags swim-ground))
       (let ((f0-2 (fmin -4096.0 (- (-> self control ground-impact-vel)))))
         (set! (-> self control unknown-word04) (the-as uint f0-2))
         (let ((v1-45 (new-stack-vector0)))
           (let ((f1-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-45 (-> self control transv) (vector-float*! v1-45 (-> self control dynam gravity-normal) f1-3))
             )
           (let* ((f1-4 (vector-length v1-45))
                  (f2-1 f1-4)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
               (vector-float*! v1-45 v1-45 (/ f1-4 f2-1))
               )
             )
           )
         )
       (set! (-> self trans-hook)
             (lambda :behavior target
               ()
               (vector-seek! (-> self draw color-mult) *zero-vector* (-> self clock seconds-per-frame))
               (let ((v1-2 (new-stack-vector0))
                     (f0-2 (the-as number (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                     )
                 0.0
                 (vector-!
                   v1-2
                   (-> self control transv)
                   (vector-float*! v1-2 (-> self control dynam gravity-normal) (the-as float f0-2))
                   )
                 (let* ((f1-2 (vector-length v1-2))
                        (f2-0 f1-2)
                        )
                   (if (< (the-as float (-> self control unknown-word04)) (the-as float f0-2))
                       (set! f0-2 (-> self control unknown-word04))
                       )
                   (vector+!
                     (-> self control transv)
                     (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) (the-as float f0-2))
                     (vector-float*! v1-2 v1-2 (/ f1-2 f2-0))
                     )
                   )
                 )
               ((-> target-mech-hit trans))
               (none)
               )
             )
       (ja-channel-push! 1 (seconds 0.3))
       (ja-no-eval :group! (-> self draw art-group data 330) :num! (loop! 0.5) :frame-num 0.0)
       (let ((gp-3 (current-time)))
         (until (>= (- (current-time) gp-3) (seconds 0.8))
           (ja :group! (-> self draw art-group data 330) :num! (loop! 0.5))
           (suspend)
           )
         )
       (remove-setting! 'mode-name)
       )
      (else
        (set! (-> self control mod-surface) *empty-mods*)
        (rot->dir-targ! (-> self control))
        (remove-setting! 'slave-options)
        (remove-setting! 'fov)
        (remove-setting! 'head-offset)
        (send-event *camera* 'set-dist #f #f)
        (set! (-> self burn-proc)
              (ppointer->handle
                (process-spawn-function process process-drawable-burn-effect 1200 :to (ppointer->process (-> self manipy)))
                )
              )
        (let ((gp-5 (if (zero? (rand-vu-int-count 2))
                        (-> self draw art-group data 351)
                        (-> self draw art-group data 352)
                        )
                    )
              )
          (ja-channel-push! 1 (seconds 0.1))
          (let ((f30-0 (if (logtest? (-> self water flags) (water-flags under-water))
                           0.55
                           1.0
                           )
                       )
                )
            (ja-no-eval :group! gp-5
                        :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-5) frames num-frames) -1)) f30-0)
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
                (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
                (process-drawable-shock-effect
                  (the-as process-drawable (ppointer->process (-> self manipy)))
                  (-> *lightning-spec-id-table* 1)
                  lightning-probe-callback
                  (-> *part-id-table* 166)
                  0
                  0
                  40960.0
                  )
                )
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          )
        (sound-play "mech-eject")
        (let ((gp-7 (get-process *default-dead-pool* part-tracker #x4000)))
          (when gp-7
            (let ((t9-33 (method-of-type part-tracker activate)))
              (t9-33 (the-as part-tracker gp-7) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
              )
            (let ((t9-34 run-function-in-process)
                  (a0-72 gp-7)
                  (a1-35 part-tracker-init)
                  (a2-31 (-> *part-group-id-table* 202))
                  (a3-13 0)
                  (t0-8 #f)
                  (t1-8 #f)
                  (t2-5 #f)
                  (t3-0 *launch-matrix*)
                  )
              (set! (-> t3-0 trans quad) (-> self control trans quad))
              ((the-as (function object object object object object object object object none) t9-34)
               a0-72
               a1-35
               a2-31
               a3-13
               t0-8
               t1-8
               t2-5
               t3-0
               )
              )
            (-> gp-7 ppointer)
            )
          )
        (rot->dir-targ! (-> self control))
        (ja-post)
        (let ((gp-8 (new 'stack 'joint-exploder-tuning (the-as uint 0))))
          (cond
            ((logtest? (-> self water flags) (water-flags under-water))
             (set! (-> gp-8 duration) (seconds 8))
             (set! (-> gp-8 gravity) -20480.0)
             (set! (-> gp-8 rot-speed) 4.2)
             (set-vector! (-> gp-8 fountain-rand-transv-lo) -20480.0 12288.0 -20480.0 1.0)
             (set-vector! (-> gp-8 fountain-rand-transv-hi) 20480.0 24576.0 20480.0 1.0)
             )
            (else
              (set! (-> gp-8 gravity) -204800.0)
              (set-vector! (-> gp-8 fountain-rand-transv-lo) -61440.0 12288.0 -61440.0 1.0)
              (set-vector! (-> gp-8 fountain-rand-transv-hi) 61440.0 49152.0 61440.0 1.0)
              )
            )
          (process-spawn
            joint-exploder
            (art-group-get-by-name *level* "skel-mech-explode" (the-as (pointer uint32) #f))
            41
            gp-8
            *mech-exploder-params*
            :to (ppointer->process (-> self manipy))
            )
          )
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (logior! (-> self state-flags) (state-flags sf6))
        (set! (-> self alt-cam-pos quad) (-> self control trans quad))
        (set! (-> self post-hook) target-no-move-post)
        (ja-channel-set! 1)
        (ja-no-eval :group! (-> self draw art-group data 70)
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 70)) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (set! (-> self control transv quad) (the-as uint128 0))
          (vector-seek!
            (-> self draw color-mult)
            (new 'static 'vector :x 0.5 :y 0.5 :z 0.5 :w 1.0)
            (* 5.0 (-> self clock seconds-per-frame))
            )
          (suspend)
          (ja :num! (seek!))
          )
        (let ((gp-9 (current-time)))
          (until (>= (- (current-time) gp-9) (seconds 2))
            (suspend)
            )
          )
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (initialize! (-> self game) 'life (the-as game-save #f) (the-as string #f))
    (if (!= (-> self game mode) 'play)
        (go target-jump 16384.0 16384.0 (the-as surface #f))
        )
    (set! (-> self state-time) (current-time))
    (sleep-code)
    (none)
    )
  :post target-mech-post
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-mech-carry-update target ()
  (carry-info-method-9 (-> self carry))
  (when (and (= (-> self control collide-mode) 'mech-carry) (< (-> self control collide-mode-transition) 1.0))
    (let ((gp-0 (new 'stack-no-clear 'collide-query))
          (s5-0 (new 'stack-no-clear 'sphere))
          )
      (dotimes (s4-0 1)
        ((method-of-type sphere new) (the-as symbol (+ (the-as uint s5-0) (* s4-0 16))) sphere)
        )
      (let ((f30-0 (seek (-> self control collide-mode-transition) 1.0 (* 0.1 (-> self clock time-adjust-ratio)))))
        (set! (-> (the-as sphere (&-> s5-0 x)) quad)
              (-> self control collision-spheres 2 prim-core world-sphere quad)
              )
        (set! (-> s5-0 r) (lerp-scale (-> *TARGET-bank* body-radius) 11468.8 f30-0 0.0 1.0))
        (let ((v1-17 gp-0))
          (set! (-> v1-17 best-dist) (the-as float s5-0))
          (set! (-> v1-17 num-spheres) (the-as uint 1))
          (set! (-> v1-17 collide-with) (-> self control root-prim prim-core collide-with))
          (set! (-> v1-17 ignore-process0) #f)
          (set! (-> v1-17 ignore-process1) #f)
          (set! (-> v1-17 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-17 best-my-prim) (the-as collide-shape-prim #t))
          (set! (-> v1-17 action-mask) (collide-action solid))
          )
        (if (not (fill-and-probe-using-spheres *collide-cache* gp-0))
            (target-collide-set! 'mech-carry f30-0)
            )
        )
      )
    )
  (send-event (handle->process (-> self carry other)) 'carry (-> self carry))
  (none)
  )

(defbehavior target-mech-carry-post target ()
  (set! (-> self focus-status) (logior (focus-status carry) (-> self focus-status)))
  (target-mech-post)
  (target-mech-carry-update)
  (none)
  )

(defstate target-mech-carry-pickup (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touched)
       (cond
         (((method-of-type touching-shapes-entry prims-touching?)
           (the-as touching-shapes-entry (-> event param 0))
           (-> self control)
           (the-as uint 1920)
           )
          (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-2 from) (process->ppointer self))
            (set! (-> a1-2 num-params) 0)
            (set! (-> a1-2 message) 'carry?)
            (let ((a1-3 (send-event-function proc a1-2)))
              (when a1-3
                (let ((f0-0 (distance-from-destination (-> self carry) (the-as carry-info a1-3))))
                  (when (and (>= f0-0 0.0) (< f0-0 (-> self carry other-value)))
                    (set! (-> self carry other) (process->handle proc))
                    (set! (-> self carry other-value) f0-0)
                    )
                  )
                )
              )
            )
          #f
          )
         (else
           (target-mech-handler proc arg1 event-type event)
           )
         )
       )
      (('change-mode 'end-mode)
       #f
       )
      (else
        (target-mech-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-pickup-mods*)
    (set! (-> self mech stick-off) (the-as basic #t))
    (set! (-> self state-time) (current-time))
    (set-forward-vel 0.0)
    (set! (-> self carry other) (the-as handle #f))
    (set! (-> self carry other-value) 100000000000.0)
    (set! (-> self carry max-distance) 32768.0)
    (set! (-> self carry mode) (carry-mode carry mech-carry mech-drag))
    (carry-info-method-9 (-> self carry))
    (none)
    )
  :exit (behavior ()
    (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                           (or (= v1-3 'target-mech-carry-stance)
                                               (= v1-3 'target-mech-carry-walk)
                                               (= v1-3 'target-mech-carry-drop)
                                               (= v1-3 'target-mech-carry-throw)
                                               (= v1-3 'target-mech-carry-jump)
                                               (= v1-3 'target-mech-carry-falling)
                                               (= v1-3 'target-mech-carry-hit-ground)
                                               (= v1-3 'target-mech-carry-throw)
                                               (= v1-3 'target-mech-carry-drag)
                                               )
                                           )
                    )
               )
      (logclear! (-> self focus-status) (focus-status carry))
      (send-event (handle->process (-> self carry other)) 'drop (-> self carry) *null-vector*)
      (target-collide-set! 'mech 0.0)
      (target-exit)
      )
    (set! (-> self mech stick-off) #f)
    (target-mech-exit)
    (none)
    )
  :code (behavior ()
    (let ((f30-0 0.0)
          (f28-0 0.0)
          (gp-0 #f)
          )
      (ja-channel-push! 2 1)
      (ja :group! (-> self draw art-group data 337) :num! min)
      (let ((a0-2 (-> self skel root-channel 1)))
        (set! (-> a0-2 frame-interp 1) f30-0)
        (set! (-> a0-2 frame-interp 0) f30-0)
        (set! (-> a0-2 frame-group) (the-as art-joint-anim (-> self draw art-group data 336)))
        (set! (-> a0-2 param 0) 0.0)
        (joint-control-channel-group-eval!
          a0-2
          (the-as art-joint-anim (-> self draw art-group data 336))
          num-func-chan
          )
        )
      (suspend)
      (ja :num! (seek!))
      (ja :chan 1 :num! (chan 0))
      (target-danger-set! 'carry? #f)
      (suspend)
      (ja :num! (seek!))
      (ja :chan 1 :num! (chan 0))
      (format #t "carry picked ~A~%" (handle->process (-> self carry other)))
      (let ((a1-9 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-9 from) (process->ppointer self))
        (set! (-> a1-9 num-params) 0)
        (set! (-> a1-9 message) 'carry-info)
        (let ((s5-1 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-9))))
          (cond
            (s5-1
              (let* ((s4-1 (vector-! (new 'stack-no-clear 'vector) (-> s5-1 point) (-> self control trans)))
                     (s3-0 (new-stack-vector0))
                     (f26-0 (vector-dot (-> self control local-normal) s4-1))
                     )
                0.0
                (vector-! s3-0 s4-1 (vector-float*! s3-0 (-> self control local-normal) f26-0))
                (let* ((f24-0 (vector-length s3-0))
                       (f22-0 f24-0)
                       )
                  (set! f28-0 (lerp-scale 1.0 0.0 f26-0 3072.0 7168.0))
                  (vector+!
                    s4-1
                    (vector-float*! s4-1 (-> self control local-normal) f26-0)
                    (vector-float*! s3-0 s3-0 (/ f24-0 f22-0))
                    )
                  )
                )
              (cond
                ((logtest? (-> s5-1 mode) (carry-mode mech-drag))
                 (sound-play "mech-drag-pikup")
                 (let ((s4-5 (vector-! (new 'stack-no-clear 'vector) (-> self carry point) (-> s5-1 point))))
                   (set! gp-0 #t)
                   (vector-xz-normalize! s4-5 (-> s5-1 max-pull))
                   (vector+! s4-5 s4-5 (-> s5-1 point))
                   )
                 (let* ((f26-1 (y-angle (-> s5-1 process 0 control)))
                        (f0-15 (vector-y-angle (vector-! (new 'stack-no-clear 'vector) (-> s5-1 point) (-> self carry point))))
                        (f0-21 (the float (the int (* 0.000061035156 (+ 73728.0 (deg- f0-15 f26-1))))))
                        (s5-2 (new 'stack-no-clear 'vector))
                        )
                   (set! (-> self carry face-dir) (the int f0-21))
                   (let ((f24-2 (the float (sar (shl (the int (* 16384.0 f0-21)) 48) 48))))
                     (set! (-> self control unknown-word04) (the-as uint (+ f26-1 f24-2)))
                     (set-vector! s5-2 (sin (+ f26-1 f24-2)) 0.0 (cos (+ f26-1 f24-2)) 1.0)
                     )
                   (forward-up-nopitch->quaternion
                     (-> self control dir-targ)
                     s5-2
                     (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
                     )
                   )
                 )
                (else
                  (sound-play "mech-drag-pikup")
                  (forward-up-nopitch->quaternion
                    (-> self control dir-targ)
                    (vector-normalize! (vector-! (new-stack-vector0) (-> s5-1 point) (-> self control trans)) 1.0)
                    (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
                    )
                  )
                )
              )
            (else
              (sound-play "mech-pickup-1")
              )
            )
          )
        )
      (target-danger-set! 'harmless #f)
      (cond
        (gp-0
          (ja-channel-push! 1 (seconds 0.01))
          (ja-no-eval :group! (-> self draw art-group data 347)
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 347)) frames num-frames) -1)))
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (suspend)
            (ja :num! (seek!))
            )
          )
        (else
          (ja-no-eval :num! (seek! (ja-aframe 8.0 0)))
          (while (not (ja-done? 0))
            (set! f30-0 (seek f30-0 f28-0 (* 5.0 (-> self clock seconds-per-frame))))
            (let ((v1-120 (-> self skel root-channel 1)))
              (set! (-> v1-120 frame-interp 1) f30-0)
              (set! (-> v1-120 frame-interp 0) f30-0)
              )
            (suspend)
            (ja-eval)
            )
          )
        )
      (let ((s4-11 (new 'stack-no-clear 'vector))
            (s5-6 (new 'stack-no-clear 'vector))
            )
        (when (send-event (handle->process (-> self carry other)) 'pickup (-> self carry) s4-11 s5-6)
          (target-collide-set! 'mech-carry 0.0)
          (when gp-0
            (sound-play "mech-drag-grab")
            (let ((s3-6 (vector-! (new 'stack-no-clear 'vector) s4-11 (-> self control trans)))
                  (a1-37 (new 'stack-no-clear 'event-message-block))
                  )
              (set! (-> a1-37 from) (process->ppointer self))
              (set! (-> a1-37 num-params) 0)
              (set! (-> a1-37 message) 'carry-info)
              (let ((s4-12 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-37))))
                (vector-flatten! s3-6 s3-6 s5-6)
                (let ((f0-43 (vector-length s3-6)))
                  (when (< 1228.8 f0-43)
                    (vector-normalize! s3-6 (+ -1228.8 f0-43))
                    (move-by-vector! (-> self control) s3-6)
                    (vector+! (-> s4-12 hold-trans) (-> s4-12 hold-trans) s3-6)
                    )
                  )
                )
              )
            (set-yaw-angle-clear-roll-pitch! (-> self control) (the-as float (-> self control unknown-word04)))
            (rot->dir-targ! (-> self control))
            (go target-mech-carry-drag)
            )
          (sound-play "mech-servo-up")
          (ja-no-eval :num! (seek!))
          (while (not (ja-done? 0))
            (set! f30-0 (seek f30-0 f28-0 (* 5.0 (-> self clock seconds-per-frame))))
            (let ((v1-174 (-> self skel root-channel 1)))
              (set! (-> v1-174 frame-interp 1) f30-0)
              (set! (-> v1-174 frame-interp 0) f30-0)
              )
            (suspend)
            (ja-eval)
            )
          (go target-mech-carry-stance)
          )
        )
      (cond
        (gp-0
          (ja-no-eval :num! (seek! 0.0))
          (while (not (ja-done? 0))
            (suspend)
            (ja-eval)
            )
          )
        (else
          (ja-no-eval :num! (seek! (ja-aframe 11.0 0)))
          (while (not (ja-done? 0))
            (let ((v1-190 (-> self skel root-channel 1)))
              (set! (-> v1-190 frame-interp 1) f30-0)
              (set! (-> v1-190 frame-interp 0) f30-0)
              )
            (suspend)
            (ja-eval)
            )
          (suspend)
          (ja-no-eval :num! (seek! 0.0))
          (while (not (ja-done? 0))
            (let ((v1-199 (-> self skel root-channel 1)))
              (set! (-> v1-199 frame-interp 1) f30-0)
              (set! (-> v1-199 frame-interp 0) f30-0)
              )
            (suspend)
            (ja-eval)
            )
          )
        )
      )
    (go target-mech-stance)
    (none)
    )
  :post (behavior ()
    (target-mech-post)
    (carry-info-method-9 (-> self carry))
    (target-mech-carry-update)
    (none)
    )
  )

(defstate target-mech-carry-drop (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('change-mode 'end-mode)
       #f
       )
      (else
        (target-mech-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-walk-mods*)
    (set! (-> self state-time) (current-time))
    (set-forward-vel 0.0)
    (set! (-> self mech stick-off) (the-as basic #t))
    (none)
    )
  :exit (-> target-mech-carry-pickup exit)
  :code (behavior ()
    (let ((f30-0 1.0)
          (gp-1 (sound-play "mech-servo-down"))
          )
      (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-1 from) (process->ppointer self))
        (set! (-> a1-1 num-params) 0)
        (set! (-> a1-1 message) 'carry-info)
        (let ((a0-8 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-1))))
          (when a0-8
            (let ((s5-1 (new 'stack-no-clear 'vector)))
              (set! (-> s5-1 quad) (-> a0-8 point quad))
              (set! (-> s5-1 y) (- (-> s5-1 y) (-> a0-8 process 0 control root-prim prim-core world-sphere w)))
              (let ((s4-0 (new-stack-vector0))
                    (f28-0 (vector-dot (-> self control local-normal) s5-1))
                    )
                0.0
                (vector-! s4-0 s5-1 (vector-float*! s4-0 (-> self control local-normal) f28-0))
                (let* ((f26-0 (vector-length s4-0))
                       (f24-0 f26-0)
                       )
                  (set! f30-0 (lerp-scale 1.0 0.0 f28-0 3072.0 7168.0))
                  (vector+!
                    s5-1
                    (vector-float*! s5-1 (-> self control local-normal) f28-0)
                    (vector-float*! s4-0 s4-0 (/ f26-0 f24-0))
                    )
                  )
                )
              )
            )
          )
        )
      (ja-channel-push! 2 (seconds 0.1))
      (ja :group! (-> self draw art-group data 337)
          :num! (identity (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 337)) frames num-frames) -1)))
          )
      (let ((a0-19 (-> self skel root-channel 1)))
        (set! (-> a0-19 frame-interp 1) f30-0)
        (set! (-> a0-19 frame-interp 0) f30-0)
        (set! (-> a0-19 frame-group) (the-as art-joint-anim (-> self draw art-group data 336)))
        (set! (-> a0-19 param 0) 0.0)
        (joint-control-channel-group-eval!
          a0-19
          (the-as art-joint-anim (-> self draw art-group data 336))
          num-func-chan
          )
        )
      (suspend)
      (ja-no-eval :num! (seek! (ja-aframe 8.0 0)))
      (while (not (ja-done? 0))
        (let ((a1-10 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-10 from) (process->ppointer self))
          (set! (-> a1-10 num-params) 0)
          (set! (-> a1-10 message) 'carry-info)
          (let ((s5-5 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-10))))
            (when s5-5
              (if (< 20.0 (ja-aframe-num 0))
                  (seek! (-> s5-5 grab-trans-blend) 1.0 (* 2.0 (-> self clock seconds-per-frame)))
                  )
              (let ((s3-0 (-> s5-5 process 0 control))
                    (s5-6 (new 'stack-no-clear 'collide-query))
                    )
                (let ((s4-1 (new 'stack-no-clear 'sphere)))
                  (dotimes (s2-0 1)
                    ((method-of-type sphere new) (the-as symbol (+ (the-as uint s4-1) (* s2-0 16))) sphere)
                    )
                  (set! (-> (the-as sphere (&-> s4-1 x)) quad) (-> s3-0 root-prim prim-core world-sphere quad))
                  (let ((v1-66 s5-6))
                    (set! (-> v1-66 best-dist) (the-as float s4-1))
                    (set! (-> v1-66 num-spheres) (the-as uint 1))
                    (set! (-> v1-66 collide-with) (-> self control root-prim prim-core collide-with))
                    (set! (-> v1-66 ignore-process0) #f)
                    (set! (-> v1-66 ignore-process1) #f)
                    (set! (-> v1-66 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                    (set! (-> v1-66 best-my-prim) (the-as collide-shape-prim #t))
                    (set! (-> v1-66 action-mask) (collide-action solid))
                    )
                  )
                (when (fill-and-probe-using-spheres *collide-cache* s5-6)
                  (sound-play "mech-setdown")
                  (let ((v1-71 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                    (set! (-> v1-71 command) (sound-command set-param))
                    (set! (-> v1-71 id) gp-1)
                    (set! (-> v1-71 params volume) -4)
                    (set! (-> v1-71 auto-time) 48)
                    (set! (-> v1-71 auto-from) 2)
                    (set! (-> v1-71 params mask) (the-as uint 17))
                    (-> v1-71 id)
                    )
                  (set! gp-1 (sound-play "mech-servo-up"))
                  (let ((v1-75 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                    (set! (-> v1-75 command) (sound-command set-param))
                    (set! (-> v1-75 id) gp-1)
                    (set! (-> v1-75 params volume) -4)
                    (set! (-> v1-75 auto-time) 192)
                    (set! (-> v1-75 auto-from) 2)
                    (set! (-> v1-75 params mask) (the-as uint 17))
                    (-> v1-75 id)
                    )
                  (ja-no-eval :num! (seek!))
                  (while (not (ja-done? 0))
                    (suspend)
                    (ja-eval)
                    )
                  (go target-mech-carry-stance)
                  )
                )
              )
            )
          )
        (suspend)
        (ja-eval)
        )
      )
    (sound-play "mech-setdown")
    (let ((v1-91 (vector-float*! (new 'stack-no-clear 'vector) (-> self control local-normal) 0.0)))
      (vector+float*! v1-91 v1-91 (-> self control c-R-w vector 2) 20480.0)
      (send-event (handle->process (-> self carry other)) 'drop (-> self carry) v1-91)
      )
    (target-collide-set! 'mech 0.0)
    (ja-no-eval :num! (seek! 0.0))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (go target-mech-stance)
    (none)
    )
  :post (-> target-mech-carry-pickup post)
  )

(defstate target-mech-carry-stance (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('change-mode)
       (case (-> event param 0)
         (('falling)
          (if (and (-> self next-state) (= (-> self next-state name) 'target-mech-carry-drag))
              #f
              (go target-mech-carry-falling)
              )
          )
         (('grab)
          (if (not (-> event param 1))
              #t
              (go target-mech-grab)
              )
          )
         )
       )
      (else
        (target-mech-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (set! (-> self control mod-surface turnvv) 20024.889)
    (set! (-> self control did-move-to-pole-or-max-jump-height) 0.0)
    (rot->dir-targ! (-> self control))
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    ((-> target-mech-carry-pickup exit))
    (rot->dir-targ! (-> self control))
    (none)
    )
  :trans (behavior ()
    (if (and (move-legs?)
             (and (< (fabs
                       (deg-diff (quaternion-y-angle (-> self control dir-targ)) (vector-y-angle (-> self control to-target-pt-xz)))
                       )
                     1820.4445
                     )
                  (>= (- (current-time) (-> self control time-of-last-zero-input)) (seconds 0.05))
                  )
             )
        (go target-mech-carry-walk)
        )
    (if (and (cpad-pressed? (-> self control cpad number) r1)
             (>= (- (current-time) (-> self carry pickup-time)) (seconds 0.1))
             )
        (go target-mech-carry-drop)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-mech-carry-jump
          (-> *TARGET-bank* mech-carry-jump-height-min)
          (-> *TARGET-bank* mech-carry-jump-height-max)
          #f
          )
        )
    (if (and (cpad-pressed? (-> self control cpad number) circle square) (can-hands? #t))
        (go target-mech-carry-throw)
        )
    (fall-test (the-as (state symbol target) target-mech-carry-falling) (-> *TARGET-bank* fall-height))
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 (-> self draw art-group data 344))))
        (ja-channel-push! 2 (seconds 0.2))
        (ja :group! (-> self draw art-group data 344) :dist 8192.0)
        (ja :chan 1 :group! (-> self draw art-group data 338) :dist 0.0)
        )
      )
    (let ((f30-0 0.0))
      (until #f
        (let ((f28-0 (y-angle (-> self control))))
          (deg-diff f28-0 (quaternion-y-angle (-> self control dir-targ)))
          (suspend)
          (let ((f28-1 (* (deg-diff f28-0 (y-angle (-> self control))) (-> self clock frames-per-second))))
            (set! f30-0 (if (< 910.2222 (fabs f28-1))
                            (seek f30-0 1.0 (* 16.0 (-> self clock seconds-per-frame)))
                            (seek f30-0 0.0 (* 6.0 (-> self clock seconds-per-frame)))
                            )
                  )
            (let* ((f0-9 (current-cycle-distance (-> self skel)))
                   (v1-26 (if (= f0-9 0.0)
                              0.0
                              (/ f28-1 f0-9)
                              )
                          )
                   (f0-11 v1-26)
                   )
              (ja :num! (loop! f0-11))
              )
            )
          )
        (let ((v1-32 (-> self skel root-channel 1))
              (f0-13 (- 1.0 f30-0))
              )
          (set! (-> v1-32 frame-interp 1) f0-13)
          (set! (-> v1-32 frame-interp 0) f0-13)
          )
        )
      )
    #f
    (none)
    )
  :post target-mech-carry-post
  )

(defstate target-mech-carry-walk (target)
  :event (-> target-mech-carry-stance event)
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *mech-carry-walk-mods*)
    (set! (-> self control unknown-word04) (the-as uint 0.0))
    (none)
    )
  :exit (-> target-mech-carry-pickup exit)
  :trans (behavior ()
    (let ((gp-0 (ja-group))
          (f0-0 (ja-aframe-num 0))
          )
      (when (if (or (and (= gp-0 (-> self draw art-group data 339)) (>= f0-0 5.5) (>= 9.5 f0-0))
                    (and (= gp-0 (-> self draw art-group data 339)) (>= f0-0 20.5) (>= 24.5 f0-0))
                    )
                #t
                )
        (when (and (< 5.0 (the-as float (-> self control unknown-word04)))
                   (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
                   )
          (set-forward-vel 0.0)
          (go target-mech-carry-stance)
          )
        )
      )
    (if (and (cpad-pressed? (-> self control cpad number) r1)
             (>= (- (current-time) (-> self carry pickup-time)) (seconds 0.1))
             )
        (go target-mech-carry-drop)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-mech-carry-jump
          (-> *TARGET-bank* mech-carry-jump-height-min)
          (-> *TARGET-bank* mech-carry-jump-height-max)
          #f
          )
        )
    (if (and (cpad-pressed? (-> self control cpad number) circle square) (can-hands? #t))
        (go target-mech-carry-throw)
        )
    (fall-test (the-as (state symbol target) target-mech-carry-falling) (-> *TARGET-bank* fall-height))
    (none)
    )
  :code (behavior ()
    (let ((f30-0 0.0))
      (let ((f28-0 (cond
                     ((zero? (-> self mech walk-anim-leg))
                      (set! (-> self mech walk-anim-leg) 1)
                      7.0
                      )
                     (else
                       (set! (-> self mech walk-anim-leg) 0)
                       22.0
                       )
                     )
                   )
            (v1-7 (ja-group))
            )
        (when (not (and v1-7 (= v1-7 (-> self draw art-group data 339))))
          (ja-channel-push! 2 (seconds 0.1))
          (ja :group! (-> self draw art-group data 339)
              :num! (identity (ja-aframe f28-0 0))
              :dist (-> *TARGET-bank* mech-walk-cycle-dist)
              )
          (ja :chan 1 :group! (-> self draw art-group data 338) :dist 0.0)
          )
        )
      (until #f
        (if (< (-> self control ctrl-xz-vel) 4096.0)
            (set-forward-vel 4096.0)
            )
        (suspend)
        (let* ((f0-4 (current-cycle-distance (-> self skel)))
               (f28-1 (/ (-> self control ctrl-xz-vel) f0-4))
               )
          (set! (-> self control unknown-word04)
                (the-as uint (+ (the-as float (-> self control unknown-word04)) f28-1))
                )
          (set! f30-0 (seek
                        f30-0
                        (lerp-scale 1.0 0.0 (-> self control ctrl-xz-vel) 0.0 8192.0)
                        (* 2.0 (-> self clock seconds-per-frame))
                        )
                )
          (ja :num! (loop! f28-1))
          )
        (let ((a0-16 (-> self skel root-channel 1)))
          (set! (-> a0-16 frame-interp 1) f30-0)
          (set! (-> a0-16 frame-interp 0) f30-0)
          (set! (-> a0-16 param 0) 0.0)
          (joint-control-channel-group-eval! a0-16 (the-as art-joint-anim #f) num-func-chan)
          )
        )
      )
    #f
    (none)
    )
  :post target-mech-carry-post
  )

(defstate target-mech-carry-drag (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('push)
       (when (zero? (-> self control sliding-start-time))
         (set! (-> self control sliding-start-time) (+ (current-time) (the-as time-frame (-> event param 0))))
         (let ((v0-0 (the-as object #t)))
           (set! (-> self control unknown-word04) (the-as uint v0-0))
           v0-0
           )
         )
       )
      (('drop)
       (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons r1))
       (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons r1))
       (send-event (handle->process (-> self carry other)) 'drop (-> self carry) *null-vector*)
       (target-collide-set! 'mech 0.0)
       (go target-mech-stance)
       )
      (else
        ((-> target-mech-carry-stance event) proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self control sliding-start-time) 0)
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control mod-surface) *mech-carry-drag-mods*)
    (set-forward-vel 0.0)
    (none)
    )
  :exit (behavior ()
    (set! (-> self mech jump-thrust) 0.0)
    (set! (-> self mech thruster-flame-width) 0.0)
    (set! (-> self mech thruster-flame-length) 0.0)
    (let ((v1-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-3 command) (sound-command set-param))
      (set! (-> v1-3 id) (-> self mech thrust-sound-id))
      (set! (-> v1-3 params volume) -4)
      (set! (-> v1-3 auto-time) 48)
      (set! (-> v1-3 auto-from) 2)
      (set! (-> v1-3 params mask) (the-as uint 17))
      (-> v1-3 id)
      )
    (let ((v1-5 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-5 command) (sound-command set-param))
      (set! (-> v1-5 id) (-> self mech drag-sound-id))
      (set! (-> v1-5 params volume) -4)
      (set! (-> v1-5 auto-time) 48)
      (set! (-> v1-5 auto-from) 2)
      (set! (-> v1-5 params mask) (the-as uint 17))
      (-> v1-5 id)
      )
    ((-> target-mech-carry-pickup exit))
    (none)
    )
  :trans (behavior ()
    (when (and (not (cpad-hold? (-> self control cpad number) r1))
               (>= (- (current-time) (-> self carry pickup-time)) (seconds 0.5))
               )
      (sound-play "mech-drag-off")
      (if (or (and (>= (-> self mech back-touch-time) (-> self state-time))
                   (< (vector-vector-distance (-> self control trans) (-> self mech back-touch-trans)) 4096.0)
                   )
              (let ((gp-1 (new 'stack-no-clear 'collide-query)))
                (let ((s5-1 (new 'stack-no-clear 'sphere)))
                  (dotimes (s4-0 1)
                    ((method-of-type sphere new) (the-as symbol (+ (the-as uint s5-1) (* s4-0 16))) sphere)
                    )
                  (set! (-> (the-as sphere (&-> s5-1 x)) quad)
                        (-> self control collision-spheres 0 prim-core world-sphere quad)
                        )
                  (vector+float*!
                    (the-as vector (&-> s5-1 x))
                    (the-as vector (&-> s5-1 x))
                    (-> self control c-R-w vector 2)
                    -4096.0
                    )
                  (set! (-> s5-1 r) (-> self control collision-spheres 0 prim-core world-sphere w))
                  (let ((v1-30 gp-1))
                    (set! (-> v1-30 best-dist) (the-as float s5-1))
                    (set! (-> v1-30 num-spheres) (the-as uint 1))
                    (set! (-> v1-30 collide-with) (-> self control root-prim prim-core collide-with))
                    (set! (-> v1-30 ignore-process0) #f)
                    (set! (-> v1-30 ignore-process1) #f)
                    (set! (-> v1-30 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                    (set! (-> v1-30 best-my-prim) (the-as collide-shape-prim #t))
                    (set! (-> v1-30 action-mask) (collide-action solid))
                    )
                  )
                (fill-and-probe-using-spheres *collide-cache* gp-1)
                )
              )
          (send-event self 'push 150)
          (send-event self 'drop)
          )
      )
    (none)
    )
  :code (behavior ()
    (let ((f28-0 0.0)
          (f30-0 0.0)
          )
      (until #f
        (let ((f0-2
                (* (vector-dot (-> self control to-target-pt-xz) (-> self control c-R-w vector 2))
                   (-> self control turn-to-magnitude)
                   )
                )
              (f26-0 0.0)
              )
          (if (and (nonzero? (-> self control sliding-start-time)) (< (-> self control sliding-start-time) (current-time)))
              (send-event self 'drop)
              (set! f28-0
                    (cond
                      ((nonzero? (-> self control sliding-start-time))
                       (let ((v1-17 (ja-group)))
                         (when (not (and v1-17 (= v1-17 (-> self draw art-group data 345))))
                           (let ((v1-23 (ja-group)))
                             (if (and v1-23 (= v1-23 (-> self draw art-group data 346)))
                                 (set! f26-0 (ja-aframe-num 0))
                                 )
                             )
                           (sound-play "mech-drag-push")
                           (ja-channel-push! 1 (seconds 0.3))
                           (ja :group! (-> self draw art-group data 345) :num! (identity (ja-aframe f26-0 0)) :dist 16384.0)
                           )
                         )
                       (when (-> self control unknown-spool-anim00)
                         (set! (-> self control unknown-word04) (the-as uint #f))
                         (set! f28-0 32768.0)
                         )
                       (seek f28-0 0.0 (* 65536.0 (-> self clock seconds-per-frame)))
                       )
                      ((< 0.0 f0-2)
                       (let ((v1-47 (ja-group)))
                         (when (not (and v1-47 (= v1-47 (-> self draw art-group data 345))))
                           (let ((v1-53 (ja-group)))
                             (if (and v1-53 (= v1-53 (-> self draw art-group data 346)))
                                 (set! f26-0 (ja-aframe-num 0))
                                 )
                             )
                           (sound-play "mech-drag-push")
                           (ja-channel-push! 1 (seconds 0.3))
                           (ja :group! (-> self draw art-group data 345) :num! (identity (ja-aframe f26-0 0)) :dist 16384.0)
                           )
                         )
                       (seek f28-0 49152.0 (* 24576.0 (-> self clock seconds-per-frame)))
                       )
                      ((< f0-2 0.0)
                       (let ((v1-71 (ja-group)))
                         (when (not (and v1-71 (= v1-71 (-> self draw art-group data 346))))
                           (let ((v1-77 (ja-group)))
                             (if (and v1-77 (= v1-77 (-> self draw art-group data 345)))
                                 (set! f26-0 (ja-aframe-num 0))
                                 )
                             )
                           (sound-play "mech-drag-pull")
                           (ja-channel-push! 1 (seconds 0.3))
                           (ja :group! (-> self draw art-group data 346) :num! (identity (ja-aframe f26-0 0)) :dist 16384.0)
                           )
                         )
                       (seek f28-0 -49152.0 (* 24576.0 (-> self clock seconds-per-frame)))
                       )
                      (else
                        (seek f28-0 0.0 (* 32768.0 (-> self clock seconds-per-frame)))
                        )
                      )
                    )
              )
          )
        (set! f30-0
              (seek
                f30-0
                (lerp-scale
                  0.0
                  1.0
                  (* (vector-vector-distance (-> self control trans) (-> self control trans-old-old))
                     (-> self clock frames-per-second)
                     )
                  0.0
                  49152.0
                  )
                (* 2.0 (-> self clock seconds-per-frame))
                )
              )
        (sound-play-by-name
          (static-sound-name "mech-drag-grind")
          (-> self mech drag-sound-id)
          (the int (* 1024.0 f30-0))
          0
          0
          (sound-group sfx)
          #t
          )
        (set-forward-vel f28-0)
        (let* ((f0-24 (current-cycle-distance (-> self skel)))
               (f26-1 (/ f28-0 (* 2.0 f0-24)))
               )
          (seek!
            (-> self mech jump-thrust)
            (lerp-scale 0.0 245760.0 (fabs f28-0) 0.0 49152.0)
            (* 491520.0 (-> self clock seconds-per-frame))
            )
          (set! (-> self mech thruster-flame-width) (* 0.021428572 (-> self mech jump-thrust)))
          (set! (-> self mech thruster-flame-length) (* 0.028571429 (-> self mech jump-thrust)))
          (let ((v1-120 (ja-group)))
            (if (and v1-120 (or (= v1-120 (-> self draw art-group data 345)) (= v1-120 (-> self draw art-group data 346))))
                (ja :num! (loop! f26-1))
                )
            )
          )
        (suspend)
        0
        )
      )
    #f
    (none)
    )
  :post target-mech-carry-post
  )

(defstate target-mech-carry-falling (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v0-0 (target-mech-bonk-event-handler proc arg1 event-type event)))
      (cond
        (v0-0
          (empty)
          v0-0
          )
        (else
          ((-> target-mech-carry-stance event) proc arg1 event-type event)
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-carry-jump-mods*)
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (-> target-mech-carry-pickup exit)
  :trans (behavior ()
    (if (logtest? (-> self control status) (collide-status on-surface))
        (go target-mech-carry-hit-ground #f)
        )
    (when (if (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                   (>= (- (current-time) (-> self state-time)) (seconds 0.05))
                   (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                   )
              #t
              )
      (logior! (-> self control status) (collide-status on-surface))
      (go target-mech-carry-hit-ground 'stuck)
      )
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 341)))
         )
        (else
          (ja-channel-push! 1 (seconds 0.33))
          (ja :group! (-> self draw art-group data 341))
          (while (!= (-> self skel root-channel 0) (-> self skel channel))
            (suspend)
            )
          )
        )
      )
    (ja-no-eval :group! (-> self draw art-group data 341) :num! (loop!) :frame-num 0.0)
    (until #f
      (suspend)
      (ja :group! (-> self draw art-group data 341) :num! (loop!))
      )
    #f
    (none)
    )
  :post target-mech-carry-post
  )

(defstate target-mech-carry-hit-ground (target)
  :event (-> target-mech-carry-falling event)
  :enter (behavior ((arg0 symbol))
    (let ((v1-0 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-0 command) (sound-command set-param))
      (set! (-> v1-0 id) (-> self mech thrust-sound-id))
      (set! (-> v1-0 params volume) -4)
      (set! (-> v1-0 auto-time) 48)
      (set! (-> v1-0 auto-from) 2)
      (set! (-> v1-0 params mask) (the-as uint 17))
      (-> v1-0 id)
      )
    (rot->dir-targ! (-> self control))
    (cond
      ((= arg0 'stuck)
       )
      (else
        (target-land-effect)
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3))
        )
      )
    (set! (-> self control last-running-attack-end-time) 0)
    (set! (-> self control last-attack-end-time) 0)
    (if (!= (-> self control ground-pat material) (pat-material ice))
        (delete-back-vel)
        )
    (set! (-> self control mod-surface) *mech-stance-mods*)
    (set! (-> self control mod-surface turnvv) 0.0)
    (start-bobbing!
      (-> self water)
      (lerp-scale 0.0 4096.0 (-> self control ground-impact-vel) 40960.0 102400.0)
      600
      1500
      )
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
    ((-> target-mech-carry-pickup exit))
    (none)
    )
  :trans (behavior ()
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (go
          target-mech-carry-jump
          (-> *TARGET-bank* mech-carry-jump-height-min)
          (-> *TARGET-bank* mech-carry-jump-height-max)
          #f
          )
        )
    (if (and (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
             (let ((v1-26 (ja-group)))
               (and (and v1-26 (= v1-26 (-> self draw art-group data 342))) (>= (ja-aframe-num 0) 30.0))
               )
             )
        (go target-mech-carry-walk)
        )
    (fall-test (the-as (state symbol target) target-mech-carry-falling) (-> *TARGET-bank* fall-height))
    (none)
    )
  :code (behavior ((arg0 symbol))
    (target-hit-ground-anim #f (are-still?))
    (go target-mech-carry-stance)
    (none)
    )
  :post target-mech-carry-post
  )

(defstate target-mech-carry-jump (target)
  :event (-> target-mech-carry-falling event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self state-time) (current-time))
    (init-var-jump arg0 arg1 #t #f (-> self control transv) 2.0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control mod-surface) *mech-carry-jump-mods*)
    (set! (-> self control unknown-float36)
          (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
          )
    (none)
    )
  :exit (behavior ()
    (rot->dir-targ! (-> self control))
    ((-> target-mech-carry-pickup exit))
    (set! (-> self mech jump-thrust) 0.0)
    (set! (-> self mech thruster-flame-width) 0.0)
    (set! (-> self mech thruster-flame-length) 0.0)
    (target-exit)
    (none)
    )
  :trans (behavior ()
    (set! (-> self control unknown-float36)
          (fmax
            (-> self control unknown-float36)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
            )
          )
    ((-> target-mech-carry-falling trans))
    (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (cond
      ((>= (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 0.0)
       (set! (-> self mech jump-thrust) 0.0)
       (set! (-> self mech thruster-flame-width) 2048.0)
       (set! (-> self mech thruster-flame-length) 6144.0)
       )
      (else
        (set! (-> self mech jump-thrust) 0.0)
        (set! (-> self mech thruster-flame-width) 0.0)
        (set! (-> self mech thruster-flame-length) 0.0)
        )
      )
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (ja-channel-push! 1 (seconds 0.05))
    (ja :group! (-> self draw art-group data 340) :num! min)
    (suspend)
    (ja :group! (-> self draw art-group data 340) :num! (+!))
    (suspend)
    (until (ja-done? 0)
      (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            (f0-4 (- 10.0 (ja-aframe-num 0)))
            (gp-1 (-> self skel root-channel 0))
            )
        (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
        (let ((v1-27 (and (< 0.0 f30-0) (< 0.0 f0-4))))
          (set! (-> gp-1 param 1)
                (if v1-27
                    (fmin (fmin 3.0 f0-4) (/ (* 5.0 f0-4) (the float (time-to-apex f30-0 -245760.0))))
                    1.8
                    )
                )
          )
        (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
        )
      (suspend)
      )
    (go target-mech-carry-falling)
    (none)
    )
  :post target-mech-carry-post
  )

(defstate target-mech-carry-throw (target)
  :event (-> target-mech-carry-drop event)
  :enter (behavior ()
    (set! (-> self control mod-surface) *mech-walk-mods*)
    (set! (-> self state-time) (current-time))
    (set-forward-vel 0.0)
    (set! (-> self mech stick-off) (the-as basic #t))
    (none)
    )
  :exit (-> target-mech-carry-pickup exit)
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data 343) :num! (seek! (ja-aframe 16.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
        (set! (-> a1-3 from) (process->ppointer self))
        (set! (-> a1-3 num-params) 0)
        (set! (-> a1-3 message) 'carry-info)
        (let ((gp-1 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-3))))
          (if gp-1
              (seek! (-> gp-1 grab-trans-blend) 1.0 (* 4.0 (-> self clock seconds-per-frame)))
              )
          )
        )
      (suspend)
      (ja :num! (seek! (ja-aframe 16.0 0)))
      )
    (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-7 from) (process->ppointer self))
      (set! (-> a1-7 num-params) 0)
      (set! (-> a1-7 message) 'carry-info)
      (let ((v1-30 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-7))))
        (when v1-30
          (let ((s4-0 (-> v1-30 process 0 control))
                (gp-3 (new 'stack-no-clear 'collide-query))
                )
            (let ((s5-0 (new 'stack-no-clear 'sphere)))
              (dotimes (s3-0 1)
                ((method-of-type sphere new) (the-as symbol (+ (the-as uint s5-0) (* s3-0 16))) sphere)
                )
              (set! (-> (the-as sphere (&-> s5-0 x)) quad) (-> s4-0 root-prim prim-core world-sphere quad))
              (let ((v1-38 gp-3))
                (set! (-> v1-38 best-dist) (the-as float s5-0))
                (set! (-> v1-38 num-spheres) (the-as uint 1))
                (set! (-> v1-38 collide-with) (-> self control root-prim prim-core collide-with))
                (set! (-> v1-38 ignore-process0) #f)
                (set! (-> v1-38 ignore-process1) #f)
                (set! (-> v1-38 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                (set! (-> v1-38 best-my-prim) (the-as collide-shape-prim #t))
                (set! (-> v1-38 action-mask) (collide-action solid))
                )
              )
            (when (fill-and-probe-using-spheres *collide-cache* gp-3)
              (ja-no-eval :num! (seek! 0.0))
              (while (not (ja-done? 0))
                (suspend)
                (ja-eval)
                )
              (go target-mech-carry-stance)
              )
            )
          )
        )
      )
    (let ((v1-48 (vector-float*! (new 'stack-no-clear 'vector) (-> self control local-normal) 2048.0)))
      (vector+float*! v1-48 v1-48 (-> self control c-R-w vector 2) 131072.0)
      (send-event (handle->process (-> self carry other)) 'drop (-> self carry) v1-48)
      )
    (target-collide-set! 'normal 0.0)
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (go target-mech-stance)
    (none)
    )
  :post (-> target-mech-carry-pickup post)
  )

(defstate target-mech-get-on (target)
  :event target-generic-event-handler
  :exit (behavior ()
    (target-mech-exit)
    (set! (-> self mech stick-off) #f)
    (set! (-> self neck flex-blend) 1.0)
    (logclear! (-> self state-flags) (state-flags sf5))
    (none)
    )
  :code (behavior ((arg0 handle))
    (logior! (-> self state-flags) (state-flags sf5))
    (ja-channel-set! 1)
    (set! (-> self control mod-surface) *empty-mods*)
    (send-event (ppointer->process (-> self manipy)) 'draw #t)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector38 quad) (-> self control trans quad))
    (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
    (set! (-> self control unknown-vector40 quad) (-> self control quat quad))
    (let* ((gp-1 (handle->process arg0))
           (v1-23 (if (type? gp-1 process-drawable)
                      gp-1
                      )
                  )
           )
      (when v1-23
        (set! (-> self control unknown-vector38 quad) (-> (the-as process-drawable v1-23) root trans quad))
        (set! (-> self control unknown-vector40 quad) (-> (the-as process-drawable v1-23) root quat quad))
        )
      )
    (set! (-> self mech mech-trans quad) (-> self control unknown-vector38 quad))
    (quaternion-copy!
      (the-as quaternion (-> self mech mech-quat))
      (the-as quaternion (-> self control unknown-vector40))
      )
    (set! (-> self mech mech-scale quad) (-> self control scale quad))
    (set! (-> self mech stick-off) (the-as basic #t))
    (ja-no-eval :group! (-> self draw art-group data 350)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 350)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (let ((f30-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 70.0 80.0))))
        (let ((f28-0 (lerp-scale 0.0 1.0 (ja-aframe-num 0) 70.0 80.0)))
          (vector-lerp!
            (-> self control trans)
            (-> self control unknown-vector37)
            (-> self control unknown-vector38)
            f30-0
            )
          (set! (-> self control trans y)
                (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f28-0)
                )
          )
        (quaternion-slerp!
          (-> self control quat-for-control)
          (the-as quaternion (-> self control unknown-vector39))
          (the-as quaternion (-> self control unknown-vector40))
          f30-0
          )
        )
      (rot->dir-targ! (-> self control))
      (set! (-> self alt-cam-pos quad) (-> self control camera-pos quad))
      (suspend)
      (ja :num! (seek!))
      )
    (go target-mech-stance)
    (none)
    )
  :post (behavior ()
    (target-no-move-post)
    (target-mech-effect)
    (none)
    )
  )

(defstate target-mech-get-off (target)
  :event target-generic-event-handler
  :exit (behavior ()
    ((-> target-mech-start exit))
    (logclear! (-> self state-flags) (state-flags sf5))
    (none)
    )
  :code (behavior ()
    (logior! (-> self state-flags) (state-flags sf5))
    (set! (-> self control mod-surface) *empty-mods*)
    (rot->dir-targ! (-> self control))
    (set-setting! 'slave-options 'clear 0.0 (cam-slave-options BIKE_MODE))
    (remove-setting! 'fov)
    (remove-setting! 'head-offset)
    (send-event *camera* 'set-dist #f #f)
    (set! (-> self neck flex-blend) 0.0)
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data 349)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 349)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (when (< 51.0 (ja-aframe-num 0))
        (logior! (-> self state-flags) (state-flags sf6))
        (vector<-cspace! (-> self alt-cam-pos) (-> self node-list data 36))
        )
      (suspend)
      (ja :num! (seek!))
      )
    (process-spawn
      mech
      :init mech-init
      (-> self mech entity)
      (-> self control trans)
      (process->handle self)
      (-> self mech shield-value)
      :to self
      )
    (rot->dir-targ! (-> self control))
    (ja-post)
    (let ((gp-1 (new 'stack-no-clear 'vector)))
      (vector<-cspace! gp-1 (-> self node-list data 3))
      (set! (-> gp-1 y) (+ -9011.2 (-> gp-1 y)))
      (move-to-point! (-> self control) gp-1)
      )
    (send-event *camera* 'ease-in)
    (ja-channel-set! 0)
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (let ((v1-68 (new-stack-vector0)))
      (let ((f0-13 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-68 (-> self control transv) (vector-float*! v1-68 (-> self control dynam gravity-normal) f0-13))
        )
      (let* ((f0-14 (vector-length v1-68))
             (f1-2 f0-14)
             (f2-0 -49152.0)
             (a0-36 (vector+!
                      (-> self control transv)
                      (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
                      (vector-float*! v1-68 v1-68 (/ f0-14 f1-2))
                      )
                    )
             )
        (go target-falling (the-as symbol a0-36))
        )
      )
    (none)
    )
  :post (-> target-mech-get-on post)
  )

(defstate target-mech-grab (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (cond
      ((and (= event-type 'query) (= (-> event param 0) 'mode))
       (-> self state name)
       )
      (else
        (case event-type
          (('end-mode)
           (go target-mech-stance)
           )
          (('clone-anim)
           (go target-mech-clone-anim (process->handle (the-as process (-> event param 0))))
           )
          (else
            (target-generic-event-handler proc arg1 event-type event)
            )
          )
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self state-flags) (state-flags sf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    (set! (-> self mech stick-off) (the-as basic #t))
    (sound-stop (-> self mech engine-sound-id))
    (sound-stop (-> self mech thrust-sound-id))
    (sound-stop (-> self mech drag-sound-id))
    (sound-stop (-> self mech whine-sound-id))
    (none)
    )
  :exit (behavior ()
    (set! (-> self mech stick-off) #f)
    (logclear! (-> self state-flags) (state-flags sf2))
    (logclear! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self water flags) (water-flags jump-out))
    ((-> target-mech-start exit))
    (none)
    )
  :code (-> target-mech-stance code)
  :post target-mech-post
  )

(defstate target-mech-clone-anim (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (if (and (= event-type 'trans) (= (-> event param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-mech-grab event) proc arg1 event-type event)
    )
  :enter (-> target-clone-anim enter)
  :exit (behavior ()
    (set! (-> self control draw-offset y) (the-as float (-> self control unknown-word04)))
    (set! (-> self control cspace-offset y) (-> self control draw-offset y))
    (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
    ((-> target-clone-anim exit))
    ((-> target-mech-start exit))
    (vector-reset! (-> self control transv))
    (none)
    )
  :code (behavior ((arg0 handle))
    (set! (-> self control unknown-word04) (the-as uint (-> self control draw-offset y)))
    (set! (-> self control draw-offset y) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
    (clone-anim arg0 #t "")
    (go target-mech-stance)
    (none)
    )
  :post (behavior ()
    (vector+! (-> self mech mech-trans) (-> self control trans) (-> self control cspace-offset))
    (quaternion-copy! (the-as quaternion (-> self mech mech-quat)) (-> self control quat))
    (set! (-> self mech mech-scale quad) (-> self control scale quad))
    (target-no-ja-move-post)
    (none)
    )
  )
