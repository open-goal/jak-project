;;-*-Lisp-*-
(in-package goal)

;; name: gun-red-shot.gc
;; name in dgo: gun-red-shot
;; dgos: ENGINE, GAME

(declare-type gun-red-shot process-drawable)
(define-extern gun-red-shot-init-by-other (function vector vector gun-red-shot :behavior gun-red-shot))

;; DECOMP BEGINS

(deftype gun-red-shot (process-drawable)
  ((root        collide-shape-moving            :override)
   (probe-count int32                           :offset-assert 200)
   (probe-mask  uint32                          :offset-assert 204)
   (actor-count int32                           :offset-assert 208)
   (attack-id   uint32                          :offset-assert 212)
   (start-pos   vector               :inline    :offset-assert 224)
   (start-dir   vector               :inline    :offset-assert 240)
   (start-rot   vector               :inline    :offset-assert 256)
   (probe-dir   vector               19 :inline :offset-assert 272)
   )
  :heap-base #x1c0
  :method-count-assert 30
  :size-assert         #x240
  :flag-assert         #x1e01c00240
  (:methods
    (blocked () _type_ :state 20)
    (debug-idle () _type_ :state 21)
    (idle () _type_ :state 22)
    (init-probes! (_type_ collide-shape) none 23)
    (gun-red-shot-method-24 (_type_) symbol 24)
    (noop (_type_) none 25)
    (gun-red-shot-method-26 (_type_) none 26)
    (gun-red-shot-method-27 (_type_) none 27)
    (gun-red-shot-method-28 (_type_ vector) sound-id 28)
    (fire! (_type_ process-drawable int) object :behavior gun-red-shot 29)
    )
  )


;; WARN: Return type mismatch (pointer process) vs (pointer gun-red-shot).
(defbehavior target-gun-fire-red target ()
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (-> self gun)))
      (let ((s5-0 (-> *part-id-table* 190)))
        (get-field-spec-by-id s5-0 (sp-field-id spt-omega))
        (let ((s5-1 (get-field-spec-by-id s5-0 (sp-field-id spt-rotate-y))))
          (if s5-1
              (set! (-> s5-1 initial-valuef) (y-angle (-> self control)))
              )
          )
        )
      (launch-particles (-> *part-id-table* 190) (-> gp-0 fire-point))
      (let ((s5-2 (new 'stack-no-clear 'vector)))
        (let ((v1-10 (-> gp-0 fire-point)))
          (let ((a0-4 (-> gp-0 fire-dir-out)))
            (let ((a1-4 24576.0))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.lvf vf4 (&-> v1-10 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s5-2 quad) vf6)
        (set! (-> s5-2 w) 24576.0)
        (when (and (sphere-in-view-frustum? (the-as sphere s5-2))
                   (< 24576.0 (vector-vector-distance s5-2 (math-camera-pos)))
                   )
          (let ((s5-3 (process-spawn
                        manipy
                        :init manipy-init
                        (-> gp-0 fire-point)
                        (-> self entity)
                        (art-group-get-by-name *level* "skel-gun-red-cone" (the-as (pointer uint32) #f))
                        #f
                        0
                        :to self
                        )
                      )
                )
            (when s5-3
              (send-event (ppointer->process s5-3) 'anim-mode 'play1)
              (send-event (ppointer->process s5-3) 'anim "idle")
              (forward-up->quaternion
                (-> (the-as process-drawable (-> s5-3 0)) root quat)
                (-> gp-0 fire-dir-out)
                *up-vector*
                )
              (let ((f30-1 (vector-dot
                             (-> gp-0 fire-dir-out)
                             (vector-! (new 'stack-no-clear 'vector) (-> gp-0 fire-point) (math-camera-pos))
                             )
                           )
                    (f0-5 (vector-vector-xz-distance (-> gp-0 fire-point) (math-camera-pos)))
                    )
                (when (and (< f30-1 0.0) (< f0-5 32768.0))
                  (set! (-> (the-as process-drawable (-> s5-3 0)) root scale z)
                        (lerp-scale 0.2 1.0 (fabs f0-5) 20480.0 32768.0)
                        )
                  (set! (-> (the-as process-drawable (-> s5-3 0)) root scale x)
                        (-> (the-as process-drawable (-> s5-3 0)) root scale z)
                        )
                  )
                )
              )
            )
          )
        )
      (process-spawn gun-red-shot (-> gp-0 fire-point) (-> gp-0 fire-dir-out) :to (ppointer->process (-> gp-0 gun)))
      )
    )
  )

(defbehavior gun-red-shot-event-handler gun-red-shot ((arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('touched)
     (fire! self arg0 (the-as int (-> arg3 param 0)))
     )
    )
  )

(defmethod fire! gun-red-shot ((obj gun-red-shot) (arg0 process-drawable) (arg1 int))
  (let* ((s5-0 arg0)
         (v1-0 (if (type? s5-0 process-drawable)
                   s5-0
                   )
               )
         )
    (when v1-0
      (let* ((s5-2 (vector-! (new 'stack-no-clear 'vector) (-> v1-0 root trans) (-> obj start-pos)))
             (f30-0 (* (if (< (vector-length s5-2) 24576.0)
                           3.0
                           2.0
                           )
                       (if (logtest? (game-feature gun-upgrade-damage) (-> *game-info* features))
                           2.0
                           1.0
                           )
                       )
                    )
             )
        (let ((s2-0 (new 'stack-no-clear 'vector)))
          (rot-zxy-from-vector! s2-0 s5-2)
          (let ((f28-0 (deg- (-> s2-0 x) (-> obj start-rot x)))
                (f0-6 (deg- (-> s2-0 y) (-> obj start-rot y)))
                )
            (when (or (< 2730.6667 (fabs f28-0)) (< 8192.0 (fabs f0-6)))
              (let ((f1-5 (fmax -2730.6667 (fmin 2730.6667 f28-0)))
                    (f0-8 (fmax -8192.0 (fmin 8192.0 f0-6)))
                    )
                (set! (-> s2-0 x) (+ (-> obj start-rot x) f1-5))
                (set! (-> s2-0 y) (+ (-> obj start-rot y) f0-8))
                )
              (set-vector! s5-2 0.0 0.0 1.0 1.0)
              (vector-rotate-around-x! s5-2 s5-2 (-> s2-0 x))
              (vector-rotate-around-y! s5-2 s5-2 (-> s2-0 y))
              )
            )
          )
        (let ((a1-7 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-7 from) (process->ppointer self))
          (set! (-> a1-7 num-params) 2)
          (set! (-> a1-7 message) 'attack)
          (set! (-> a1-7 param 0) (the-as uint arg1))
          (let ((v1-24 (new 'static 'attack-info :mask (attack-info-mask mode id attacker-velocity damage))))
            (set! (-> v1-24 id) (-> obj attack-id))
            (set! (-> v1-24 mode) 'eco-red)
            (set! (-> v1-24 attacker-velocity quad) (-> s5-2 quad))
            (set! (-> v1-24 damage) f30-0)
            (set! (-> a1-7 param 1) (the-as uint v1-24))
            )
          (send-event-function arg0 a1-7)
          )
        )
      )
    )
  )

(defmethod noop gun-red-shot ((obj gun-red-shot))
  "Does nothing"
  0
  (none)
  )

(defmethod init-probes! gun-red-shot ((obj gun-red-shot) (arg0 collide-shape))
  "Create all 19 probe vectors"
  (let ((s5-0 (-> obj probe-count)))
    (when (< s5-0 19)
      (let* ((s4-0 (-> arg0 process))
             (a0-2 (if (type? s4-0 process-focusable)
                       (the-as process-focusable s4-0)
                       )
                   )
             (s4-1 (new 'stack-no-clear 'vector))
             )
        (if a0-2
            (set! (-> s4-1 quad) (-> (get-trans a0-2 3) quad))
            (set! (-> s4-1 quad) (-> arg0 root-prim prim-core world-sphere quad))
            )
        (vector-! s4-1 s4-1 (-> obj start-pos))
        (vector-normalize! s4-1 1.0)
        (let ((s3-2 (new 'stack-no-clear 'vector)))
          (rot-zxy-from-vector! s3-2 s4-1)
          (let ((f30-0 (deg- (-> s3-2 x) (-> obj start-rot x)))
                (f0-4 (deg- (-> s3-2 y) (-> obj start-rot y)))
                )
            (when (or (< 2730.6667 (fabs f30-0)) (< 8192.0 (fabs f0-4)))
              (let ((f1-3 (fmax -2730.6667 (fmin 2730.6667 f30-0)))
                    (f0-6 (fmax -8192.0 (fmin 8192.0 f0-4)))
                    )
                (set! (-> s3-2 x) (+ (-> obj start-rot x) f1-3))
                (set! (-> s3-2 y) (+ (-> obj start-rot y) f0-6))
                )
              (set-vector! s4-1 0.0 0.0 1.0 1.0)
              (vector-rotate-around-x! s4-1 s4-1 (-> s3-2 x))
              (vector-rotate-around-y! s4-1 s4-1 (-> s3-2 y))
              )
            )
          )
        (set! (-> obj probe-dir s5-0 quad) (-> s4-1 quad))
        )
      (set! (-> obj probe-count) (+ s5-0 1))
      )
    )
  (none)
  )

(defmethod gun-red-shot-method-26 gun-red-shot ((obj gun-red-shot))
  (local-vars (a2-5 float) (a2-12 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> obj start-dir quad))
      (vector-float*! s5-0 s5-0 43417.6)
      (vector+! s5-0 s5-0 (-> obj start-pos))
      (set! (-> s5-0 w) 43827.2)
      (let ((s4-0 (-> obj root root-prim prim-core collide-with)))
        (set! *actor-list-length* 0)
        (if (logtest? s4-0 (collide-spec hit-by-others-list))
            (set! *actor-list-length* (fill-actor-list-for-sphere *actor-hash* (the-as sphere s5-0) *actor-list* 256))
            )
        (when (logtest? s4-0 (collide-spec player-list))
          (let ((a0-6 (-> *collide-player-list* alive-list next0)))
            *collide-player-list*
            (let ((v1-18 (-> a0-6 next0)))
              (while (!= a0-6 (-> *collide-player-list* alive-list-end))
                (let* ((a0-7 (-> (the-as connection a0-6) param1))
                       (a1-4 (-> (the-as collide-shape a0-7) root-prim))
                       )
                  (when (logtest? s4-0 (-> a1-4 prim-core collide-as))
                    (let ((a1-5 (-> a1-4 prim-core)))
                      (let ((a2-4 a1-5)
                            (a3-1 s5-0)
                            )
                        (.lvf vf2 (&-> a2-4 world-sphere quad))
                        (.lvf vf3 (&-> a3-1 quad))
                        )
                      (.sub.vf vf1 vf3 vf2)
                      (.mul.vf vf1 vf1 vf1)
                      (.add.y.vf vf1 vf1 vf1 :mask #b1)
                      (.add.z.vf vf1 vf1 vf1 :mask #b1)
                      (.mov a2-5 vf1)
                      (let ((f0-2 a2-5)
                            (f1-1 (+ (-> a1-5 world-sphere w) (-> s5-0 w)))
                            )
                        (when (< f0-2 (* f1-1 f1-1))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-7))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! a0-6 v1-18)
                *collide-player-list*
                (set! v1-18 (-> v1-18 next0))
                )
              )
            )
          )
        (when (logtest? s4-0 (collide-spec hit-by-player-list))
          (let ((a0-9 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((v1-26 (-> a0-9 next0)))
              (while (!= a0-9 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((a0-10 (-> (the-as connection a0-9) param1))
                       (a1-16 (-> (the-as collide-shape a0-10) root-prim))
                       )
                  (when (logtest? s4-0 (-> a1-16 prim-core collide-as))
                    (let ((a1-17 (-> a1-16 prim-core)))
                      (let ((a2-11 a1-17)
                            (a3-2 s5-0)
                            )
                        (.lvf vf2 (&-> a2-11 world-sphere quad))
                        (.lvf vf3 (&-> a3-2 quad))
                        )
                      (.sub.vf vf1 vf3 vf2)
                      (.mul.vf vf1 vf1 vf1)
                      (.add.y.vf vf1 vf1 vf1 :mask #b1)
                      (.add.z.vf vf1 vf1 vf1 :mask #b1)
                      (.mov a2-12 vf1)
                      (let ((f0-3 a2-12)
                            (f1-5 (+ (-> a1-17 world-sphere w) (-> s5-0 w)))
                            )
                        (when (< f0-3 (* f1-5 f1-5))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-10))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! a0-9 v1-26)
                *collide-hit-by-player-list*
                (set! v1-26 (-> v1-26 next0))
                )
              )
            )
          )
        (dotimes (s5-1 *actor-list-length*)
          (let ((a1-28 (-> *actor-list* s5-1)))
            (if (logtest? s4-0 (-> a1-28 root-prim prim-core collide-as))
                (init-probes! obj a1-28)
                )
            )
          )
        )
      )
    (set! (-> obj actor-count) (-> obj probe-count))
    0
    (none)
    )
  )

(defmethod gun-red-shot-method-27 gun-red-shot ((obj gun-red-shot))
  (gun-red-shot-method-26 obj)
  (let ((s5-0 (-> obj probe-count)))
    (while (< s5-0 19)
      (let ((f28-0 (rand-vu-float-range -2730.6667 2730.6667))
            (f30-0 (rand-vu-float-range -8192.0 8192.0))
            (s4-0 (-> obj probe-dir s5-0))
            )
        (set-vector! s4-0 0.0 0.0 1.0 1.0)
        (vector-rotate-around-x! s4-0 s4-0 (+ (-> obj start-rot x) f28-0))
        (vector-rotate-around-y! s4-0 s4-0 (+ (-> obj start-rot y) f30-0))
        )
      (+! s5-0 1)
      )
    (set! (-> obj probe-count) s5-0)
    )
  0
  (none)
  )

(defmethod gun-red-shot-method-28 gun-red-shot ((obj gun-red-shot) (arg0 vector))
  (local-vars (at-0 int))
  (with-pp
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (-> obj root)))
        (let ((v1-0 (new 'stack-no-clear 'collide-query)))
          (set! (-> gp-0 trans quad) (-> obj start-pos quad))
          (vector-float*! (-> gp-0 transv) arg0 61440.0)
          (let ((a1-1 v1-0))
            (set! (-> a1-1 radius) (-> gp-0 root-prim local-sphere w))
            (set! (-> a1-1 collide-with) (-> gp-0 root-prim prim-core collide-with))
            (set! (-> a1-1 ignore-process0) obj)
            (set! (-> a1-1 ignore-process1) (ppointer->process (-> obj parent)))
            (set! (-> a1-1 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
            (set! (-> a1-1 action-mask) (collide-action solid))
            )
          (set! (-> v1-0 start-pos quad) (-> gp-0 trans quad))
          (set! (-> v1-0 move-dist quad) (-> gp-0 transv quad))
          (fill-using-line-sphere *collide-cache* v1-0)
          )
        (let ((v1-2 (-> gp-0 transv)))
          (.lvf vf1 (&-> (-> gp-0 transv) quad))
          (let ((f0-2 (-> pp clock frames-per-second)))
            (.mov at-0 f0-2)
            )
          (.mov vf2 at-0)
          (.mov.vf vf1 vf0 :mask #b1000)
          (.mul.x.vf vf1 vf1 vf2 :mask #b111)
          (.svf (&-> v1-2 quad) vf1)
          )
        (integrate-and-collide! gp-0 (-> gp-0 transv))
        (if (logtest? (-> gp-0 status) (collide-status touch-surface touch-wall))
            (sound-play "red-shot-hit")
            )
        )
      )
    )
  )

(defmethod gun-red-shot-method-24 gun-red-shot ((obj gun-red-shot))
  (let ((v1-0 (-> obj root))
        (t1-0 (new 'stack-no-clear 'collide-query))
        )
    (let ((a1-0 t1-0))
      (set! (-> a1-0 radius) (-> v1-0 root-prim prim-core world-sphere w))
      (set! (-> a1-0 collide-with) (-> v1-0 root-prim prim-core collide-with))
      (set! (-> a1-0 ignore-process0) obj)
      (set! (-> a1-0 ignore-process1) (ppointer->process (-> obj parent)))
      (set! (-> a1-0 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> a1-0 action-mask) (collide-action solid))
      )
    (if (fill-and-try-snap-to-surface v1-0 (-> v1-0 transv) -6144.0 0.0 -2048.0 t1-0)
        #t
        )
    )
  )

(defstate debug-idle (gun-red-shot)
  :virtual #t
  :code (behavior ()
    (set! (-> self state-time) (current-time))
    (until (>= (- (current-time) (-> self state-time)) (seconds 3))
      (let ((gp-0 (new 'stack-no-clear 'vector)))
        (dotimes (s5-0 (-> self probe-count))
          (vector-float*! gp-0 (-> self probe-dir s5-0) 61440.0)
          (vector+! gp-0 gp-0 (-> self start-pos))
          (add-debug-sphere
            #t
            (bucket-id debug-no-zbuf1)
            gp-0
            (meters 0.5)
            (if (< s5-0 (-> self actor-count))
                (new 'static 'rgba :r #xff :a #x80)
                (new 'static 'rgba :r #xff :g #xff :a #x60)
                )
            )
          )
        )
      (add-debug-vector
        #t
        (bucket-id debug2)
        (-> self start-pos)
        (-> self start-dir)
        (meters 6)
        (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
        )
      (suspend)
      )
    (none)
    )
  )

(defstate blocked (gun-red-shot)
  :virtual #t
  :event gun-red-shot-event-handler
  :code (behavior ()
    (suspend)
    0
    (none)
    )
  )

(defstate idle (gun-red-shot)
  :virtual #t
  :event gun-red-shot-event-handler
  :code (behavior ()
    (let ((gp-0 0))
      (countdown (s5-0 3)
        (countdown (s4-0 7)
          (when (< gp-0 19)
            (gun-red-shot-method-28 self (-> self probe-dir gp-0))
            (+! gp-0 1)
            )
          )
        (suspend)
        )
      )
    (none)
    )
  )

;; WARN: Return type mismatch object vs gun-red-shot.
(defbehavior gun-red-shot-init-by-other gun-red-shot ((arg0 vector) (arg1 vector))
  (set! (-> self start-pos quad) (-> arg0 quad))
  (set! (-> self start-dir quad) (-> arg1 quad))
  (rot-zxy-from-vector! (-> self start-rot) arg1)
  (let* ((v1-2 *game-info*)
         (a0-7 (+ (-> v1-2 attack-id) 1))
         )
    (set! (-> v1-2 attack-id) a0-7)
    (set! (-> self attack-id) a0-7)
    )
  (let ((s5-0 (new 'process 'collide-shape-moving self (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction)
          (the-as (function control-info collide-query vector vector collide-status) cshape-reaction-just-move)
          )
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrate-using) (penetrate jak-red-shot))
    (let ((v1-10 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec projectile))
      (set! (-> v1-10 prim-core collide-with)
            (collide-spec backgnd bot crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> v1-10 prim-core action) (collide-action solid))
      (set-vector! (-> v1-10 local-sphere) 0.0 0.0 0.0 819.2)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) v1-10)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 1))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> self root) s5-0)
    )
  (let ((s5-1 (-> self root)))
    (set! (-> s5-1 trans quad) (-> arg0 quad))
    (quaternion-copy! (-> s5-1 quat) (-> (the-as process-drawable (-> self parent 0)) root quat))
    (vector-identity! (-> s5-1 scale))
    )
  (update-transforms (-> self root))
  (set! (-> self event-hook) gun-red-shot-event-handler)
  (logior! (-> self mask) (process-mask projectile))
  (logclear! (-> self mask) (process-mask enemy))
  (gun-red-shot-method-27 self)
  (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 204 (seconds 0.1))
  (let ((gp-1 (get-process *default-dead-pool* part-tracker #x4000)))
    (when gp-1
      (let ((t9-10 (method-of-type part-tracker activate)))
        (t9-10
          (the-as part-tracker gp-1)
          *entity-pool*
          (symbol->string (-> part-tracker symbol))
          (the-as pointer #x70004000)
          )
        )
      (let ((t9-11 run-function-in-process)
            (a0-27 gp-1)
            (a1-9 part-tracker-init)
            (a2-7 (-> *part-group-id-table* 66))
            (a3-4 0)
            (t0-0 #f)
            (t1-0 #f)
            (t2-0 #f)
            (t3-0 *launch-matrix*)
            )
        (set! (-> t3-0 trans quad) (-> self start-pos quad))
        ((the-as (function object object object object object object object object none) t9-11)
         a0-27
         a1-9
         a2-7
         a3-4
         t0-0
         t1-0
         t2-0
         t3-0
         )
        )
      (-> gp-1 ppointer)
      )
    )
  (draw-beam (-> *part-id-table* 187) (-> self start-pos) (-> self start-dir) #f #t)
  (sound-play "red-shot-fire")
  (vector-float*! (-> self root transv) (-> self start-dir) 61440.0)
  (the-as gun-red-shot (if (gun-red-shot-method-24 self)
                           (go-virtual blocked)
                           (go-virtual idle)
                           )
          )
  )
