;;-*-Lisp-*-
(in-package goal)

;; name: target-mech.gc
;; name in dgo: target-mech
;; dgos: DRILLMTN, UNB, RUI

;; DECOMP BEGINS

(defmethod draw hud-heatmeter ((obj hud-heatmeter))
  (set-hud-piece-position!
    (the-as hud-sprite (-> obj sprites))
    256
    (the int (+ 25.0 (* -100.0 (-> obj offset))))
    )
  (set! (-> obj sprites 0 pos z) #xfffff0)
  (set-as-offset-from!
    (-> obj sprites 1)
    (the-as vector4w (-> obj sprites))
    (+ (the int (* 0.128 (the float (-> obj values 0 current)))) -63)
    1
    )
  (set! (-> obj sprites 1 pos z) #xfffff0)
  ((method-of-type hud draw) obj)
  0
  (none)
  )

(defmethod update-values hud-heatmeter ((obj hud-heatmeter))
  (set! (-> obj values 0 target) (the int (* 1000.0 (-> *game-info* distance))))
  (logclear! (-> obj flags) (hud-flags disable))
  ((method-of-type hud update-values) obj)
  0
  (none)
  )

(defmethod init-callback hud-heatmeter ((obj hud-heatmeter))
  (set! (-> obj gui-id)
        (add-process *gui-control* obj (gui-channel hud-upper-center-2) (gui-action hidden) (-> obj name) 81920.0 0)
        )
  (logior! (-> obj flags) (hud-flags show))
  (set! (-> obj sprites 0 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x43 :page #x67a)))
  (set! (-> obj sprites 0 flags) (the-as uint 8))
  (set! (-> obj sprites 0 scale-x) 1.2)
  (set! (-> obj sprites 0 scale-y) 1.2)
  (set! (-> obj sprites 1 tex) (lookup-texture-by-id (new 'static 'texture-id :index #x34 :page #x67a)))
  (set! (-> obj sprites 1 flags) (the-as uint 8))
  (set! (-> obj sprites 1 scale-x) 1.8)
  (set! (-> obj sprites 1 scale-y) 1.8)
  0
  (none)
  )

(define *mech-stance-mods*
  (new 'static 'surface
    :name 'run
    :turnv 18204262.0
    :turnvv 40049.777
    :tiltv 65536.0
    :tiltvv 262144.0
    :fric 0.3
    :nonlin-fric-dist 1.0
    :slip-factor 1.0
    :slide-factor 1.0
    :slope-up-factor 1.0
    :slope-down-factor 4.0
    :slope-slip-angle 1.0
    :impact-fric 1.0
    :bend-factor 1.0
    :bend-speed 1.0
    :slope-up-traction 1.0
    :turnvf 0.03
    :turnvvf 30.0
    :tiltvf 150.0
    :tiltvvf 15.0
    :mult-hook (lambda :behavior target
      ((arg0 surface) (arg1 object) (arg2 surface) (arg3 int))
      (case arg3
        ((1)
         (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
             (seek! (-> self control did-move-to-pole-or-max-jump-height) 0.0 (* 127431.11 (seconds-per-frame)))
             (seek!
               (-> self control did-move-to-pole-or-max-jump-height)
               (* (-> self control turn-to-magnitude) (-> arg0 turnvv))
               (* 127431.11 (seconds-per-frame))
               )
             )
         (set! (-> arg0 turnvv) (-> self control did-move-to-pole-or-max-jump-height))
         (when (= (-> arg2 name) '*edge-surface*)
           (set! (-> arg0 target-speed) 32768.0)
           (set! (-> arg0 transv-max) 32768.0)
           (set! (-> arg0 seek0) (* 1.6666 (-> arg2 seek0)))
           (set! (-> arg0 seek90) (* 1.6666 (-> arg2 seek90)))
           (set! (-> arg0 seek180) (* 1.6666 (-> arg2 seek180)))
           )
         )
        )
      (none)
      )
    :flags (surface-flag look-around no-turn-around)
    )
  )

(define *mech-walk-mods*
  (new 'static 'surface
    :name 'run
    :turnv 32768.0
    :turnvv 524288.0
    :tiltv 65536.0
    :tiltvv 262144.0
    :transv-max 32768.0
    :target-speed 32768.0
    :seek0 1.6666
    :seek90 1.6666
    :seek180 1.0
    :fric 0.1
    :nonlin-fric-dist 1.0
    :slip-factor 1.0
    :slide-factor 1.0
    :slope-up-factor 1.0
    :slope-down-factor 1.0
    :slope-slip-angle 1.0
    :impact-fric 1.0
    :bend-factor 1.0
    :bend-speed 1.0
    :alignv 1.0
    :slope-up-traction 1.0
    :align-speed 1.0
    :turnvf 120.0
    :turnvvf 30.0
    :tiltvf 150.0
    :tiltvvf 15.0
    :vel-turn -1.0
    :mult-hook (lambda :behavior target
      ((arg0 surface) (arg1 object) (arg2 surface) (arg3 int))
      (case arg3
        ((1)
         (when (= (-> arg2 name) '*edge-surface*)
           (let ((v1-5 (vector-flatten!
                         (new 'stack-no-clear 'vector)
                         (vector-negate! (new-stack-vector0) (-> self control dynam gravity-normal))
                         (-> self control local-normal)
                         )
                       )
                 )
             (set! (-> arg0 vel-turn) 0.0)
             (vector+float*! (-> self control transv) (-> self control transv) v1-5 (* 409600.0 (seconds-per-frame)))
             )
           )
         )
        )
      (none)
      )
    :flags (surface-flag look-around no-turn-around)
    )
  )

(define *mech-jump-mods* (new 'static 'surface
                           :name 'jump
                           :turnv 131072.0
                           :turnvv 18204.445
                           :tiltv 32768.0
                           :tiltvv 262144.0
                           :transv-max 32768.0
                           :target-speed 32768.0
                           :seek0 0.3
                           :seek90 0.3
                           :seek180 0.3
                           :fric 0.2
                           :nonlin-fric-dist 1.0
                           :slip-factor 1.0
                           :slide-factor 1.0
                           :slope-up-factor 1.0
                           :slope-down-factor 1.0
                           :slope-slip-angle 1.0
                           :impact-fric 1.0
                           :bend-factor 1.0
                           :bend-speed 1.0
                           :alignv 1.0
                           :slope-up-traction 1.0
                           :align-speed 1.0
                           :turnvf 90.0
                           :turnvvf 30.0
                           :tiltvf 150.0
                           :tiltvvf 15.0
                           :mode 'air
                           :flags (surface-flag no-turn-around air)
                           )
        )

(define *mech-punch-mods* (new 'static 'surface
                            :name 'punch
                            :turnv 131072.0
                            :tiltv 32768.0
                            :tiltvv 262144.0
                            :transv-max 91750.4
                            :target-speed 122880.0
                            :seek90 0.5
                            :seek180 0.15
                            :slip-factor 1.0
                            :slide-factor 1.0
                            :slope-up-factor 0.25
                            :slope-down-factor 1.0
                            :slope-slip-angle 1.0
                            :impact-fric 1.0
                            :bend-factor 1.0
                            :bend-speed 1.0
                            :alignv 1.0
                            :slope-up-traction 1.0
                            :align-speed 1.0
                            :tiltvf 150.0
                            :tiltvvf 15.0
                            :mode 'attack
                            :flags (surface-flag no-turn-around turn-to-pad attack)
                            )
        )

(define *mech-pickup-mods* (new 'static 'surface
                             :name 'run
                             :turnv 16384.0
                             :tiltv 65536.0
                             :tiltvv 262144.0
                             :transv-max 12288.0
                             :target-speed 12288.0
                             :seek0 1.0
                             :seek90 1.0
                             :seek180 1.0
                             :fric 0.5
                             :nonlin-fric-dist 1.0
                             :slip-factor 1.0
                             :slide-factor 1.0
                             :slope-up-factor 1.0
                             :slope-down-factor 1.0
                             :slope-slip-angle 1.0
                             :impact-fric 1.0
                             :bend-factor 1.0
                             :bend-speed 1.0
                             :alignv 1.0
                             :slope-up-traction 1.0
                             :align-speed 1.0
                             :turnvf 240.0
                             :tiltvf 150.0
                             :tiltvvf 15.0
                             :vel-turn -1.0
                             :flags (surface-flag look-around no-turn-around)
                             )
        )

(define *mech-carry-walk-mods* (new 'static 'surface
                                 :name 'run
                                 :turnv 16384.0
                                 :turnvv 524288.0
                                 :tiltv 65536.0
                                 :tiltvv 262144.0
                                 :transv-max 12288.0
                                 :target-speed 12288.0
                                 :seek0 1.0
                                 :seek90 1.0
                                 :seek180 1.0
                                 :fric 0.5
                                 :nonlin-fric-dist 1.0
                                 :slip-factor 1.0
                                 :slide-factor 1.0
                                 :slope-up-factor 1.0
                                 :slope-down-factor 1.0
                                 :slope-slip-angle 1.0
                                 :impact-fric 1.0
                                 :bend-factor 1.0
                                 :bend-speed 1.0
                                 :alignv 1.0
                                 :slope-up-traction 1.0
                                 :align-speed 1.0
                                 :turnvf 240.0
                                 :turnvvf 30.0
                                 :tiltvf 150.0
                                 :tiltvvf 15.0
                                 :vel-turn -1.0
                                 :flags (surface-flag look-around no-turn-around)
                                 )
        )

(set! (-> *mech-carry-walk-mods* mult-hook) (-> *mech-walk-mods* mult-hook))

(define *mech-carry-drag-mods* (new 'static 'surface
                                 :name 'run
                                 :tiltv 65536.0
                                 :tiltvv 262144.0
                                 :transv-max 12288.0
                                 :fric 1.0
                                 :nonlin-fric-dist 1.0
                                 :slip-factor 1.0
                                 :slide-factor 1.0
                                 :slope-up-factor 1.0
                                 :slope-down-factor 1.0
                                 :slope-slip-angle 1.0
                                 :impact-fric 1.0
                                 :bend-factor 1.0
                                 :bend-speed 1.0
                                 :alignv 1.0
                                 :slope-up-traction 1.0
                                 :align-speed 1.0
                                 :tiltvf 150.0
                                 :tiltvvf 15.0
                                 :flags (surface-flag look-around no-turn-around)
                                 )
        )

(define *mech-carry-jump-mods* (new 'static 'surface
                                 :name 'jump
                                 :turnv 131072.0
                                 :turnvv 18204.445
                                 :tiltv 32768.0
                                 :tiltvv 262144.0
                                 :transv-max 24576.0
                                 :target-speed 24576.0
                                 :seek0 0.3
                                 :seek90 0.3
                                 :seek180 0.3
                                 :fric 0.2
                                 :nonlin-fric-dist 1.0
                                 :slip-factor 1.0
                                 :slide-factor 1.0
                                 :slope-up-factor 1.0
                                 :slope-down-factor 1.0
                                 :slope-slip-angle 1.0
                                 :impact-fric 1.0
                                 :bend-factor 1.0
                                 :bend-speed 1.0
                                 :alignv 1.0
                                 :slope-up-traction 1.0
                                 :align-speed 1.0
                                 :turnvf 90.0
                                 :turnvvf 30.0
                                 :tiltvf 150.0
                                 :tiltvvf 15.0
                                 :mode 'air
                                 :flags (surface-flag air)
                                 )
        )

(defbehavior target-mech-falling-anim-trans target ()
  0
  (none)
  )

(defbehavior target-mech-mech-effect mech ((arg0 target))
  (when (!= (-> arg0 mech thruster-flame-length) 0.0)
    (let ((f30-0 0.0))
      (if (!= (-> *setting-control* user-current under-water-pitch-mod) 0.0)
          (set! f30-0 -2.0)
          )
      (sound-play-by-name
        (static-sound-name "mech-thrust")
        (-> arg0 mech thrust-sound-id)
        (the int (* 1024.0 (lerp-scale 0.3 1.0 (-> arg0 mech thruster-flame-length) 0.0 4096.0)))
        (the int (* 1524.0 f30-0))
        0
        (sound-group sfx)
        #t
        )
      )
    (dotimes (s5-1 2)
      (let* ((s3-1 (-> self node-list data (if (zero? s5-1)
                                               37
                                               38
                                               )
                       )
                   )
             (s4-1 (vector<-cspace! (new 'stack-no-clear 'vector) s3-1))
             (a2-2 (vector-negate! (new 'stack-no-clear 'vector) (-> s3-1 bone transform vector 1)))
             )
        (mech-spawn-thruster
          (-> arg0 mech)
          s4-1
          a2-2
          (-> arg0 mech thruster-flame-width)
          (-> arg0 mech thruster-flame-length)
          )
        )
      )
    )
  (when (logtest? (water-flags touch-water) (-> arg0 water flags))
    (let ((f30-1 (-> arg0 water height)))
      (let ((s5-2 (-> *part-id-table* 947)))
        (let ((v1-28 (get-field-spec-by-id s5-2 (sp-field-id spt-userdata))))
          (if v1-28
              (set! (-> v1-28 initial-valuef) f30-1)
              )
          )
        (let ((t9-6 sp-launch-particles-var)
              (a0-12 *sp-particle-system-2d*)
              (a2-3 *launch-matrix*)
              )
          (set! (-> a2-3 trans quad) (-> self root trans quad))
          (t9-6 a0-12 s5-2 a2-3 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
          )
        )
      (let ((s5-3 (-> *part-id-table* 950)))
        (let ((v1-34 (get-field-spec-by-id s5-3 (sp-field-id spt-userdata))))
          (if v1-34
              (set! (-> v1-34 initial-valuef) f30-1)
              )
          )
        (let ((t9-8 sp-launch-particles-var)
              (a0-15 *sp-particle-system-2d*)
              (a2-4 *launch-matrix*)
              )
          (set! (-> a2-4 trans quad) (-> self root trans quad))
          (t9-8 a0-15 s5-3 a2-4 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
          )
        )
      (let* ((s5-4 (-> *part-id-table* 953))
             (v1-40 (get-field-spec-by-id s5-4 (sp-field-id spt-userdata)))
             (s4-2 (new 'stack-no-clear 'vector))
             )
        (if v1-40
            (set! (-> v1-40 initial-valuef) f30-1)
            )
        (let ((s3-2 (get-field-spec-by-id s5-4 (sp-field-id spt-num))))
          (if s3-2
              (set! (-> s3-2 initial-valuef) (lerp-scale 0.1 2.0 (-> arg0 control ctrl-xz-vel) 0.0 40960.0))
              )
          )
        (process-drawable-random-point! self s4-2)
        (let ((t9-13 sp-launch-particles-var)
              (a0-21 *sp-particle-system-2d*)
              (a2-6 *launch-matrix*)
              )
          (set! (-> a2-6 trans quad) (-> s4-2 quad))
          (t9-13 a0-21 s5-4 a2-6 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior mech-on-ground? target ()
  (logtest? (-> self control status) (collide-status on-surface))
  )

(defbehavior target-mech-get-off? target ()
  (when (and (mech-on-ground?)
             (< (-> self mech no-get-off-time) (current-time))
             (-> *setting-control* user-current pilot-exit)
             )
    (let ((gp-0 (new 'stack-no-clear 'collide-query))
          (s4-0 (new 'stack-no-clear 'sphere))
          )
      (dotimes (s5-0 1)
        ((method-of-type sphere new) (the-as symbol (+ (the-as uint s4-0) (* s5-0 16))) sphere)
        )
      (let ((s5-1 (-> self node-list data 0 bone transform)))
        (vector-matrix*! (the-as vector (&-> s4-0 x)) (new 'static 'vector :y 14336.0 :z 12288.0 :w 1.0) s5-1)
        (set! (-> s4-0 r) 10240.0)
        (let ((v1-11 gp-0))
          (set! (-> v1-11 best-dist) (the-as float s4-0))
          (set! (-> v1-11 num-spheres) (the-as uint 1))
          (set! (-> v1-11 collide-with) (-> self control root-prim prim-core collide-with))
          (set! (-> v1-11 ignore-process0) #f)
          (set! (-> v1-11 ignore-process1) #f)
          (set! (-> v1-11 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
          (set! (-> v1-11 best-my-prim) (the-as collide-shape-prim #t))
          (set! (-> v1-11 action-mask) (collide-action solid))
          )
        (let ((s4-1 (fill-and-probe-using-spheres *collide-cache* gp-0)))
          (when (not s4-1)
            (vector-matrix*! (-> gp-0 start-pos) (new 'static 'vector :y 8192.0 :z 4096.0 :w 1.0) s5-1)
            (set-vector! (-> gp-0 move-dist) 0.0 -40960.0 0.0 0.0)
            (let ((v1-15 gp-0))
              (set! (-> v1-15 radius) 409.6)
              (set! (-> v1-15 collide-with) (collide-spec backgnd obstacle hit-by-others-list pusher))
              (set! (-> v1-15 ignore-process0) self)
              (set! (-> v1-15 ignore-process1) #f)
              (set! (-> v1-15 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
              (set! (-> v1-15 action-mask) (collide-action solid))
              )
            (set! s4-1 (< (fill-and-probe-using-line-sphere *collide-cache* gp-0) 0.0))
            )
          (if (and s4-1 (-> *setting-control* user-current pilot))
              (talker-spawn-func (-> *talker-speech* 460) *entity-pool* (target-pos 0) (the-as region #f))
              )
          (not s4-1)
          )
        )
      )
    )
  )

(defbehavior target-mech-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object) (a0-18 symbol) (sv-96 target) (sv-112 process))
  (cond
    ((and (= arg2 'query) (= (-> arg3 param 0) 'mode))
     'mech
     )
    (else
      (case arg2
        (('end-mode)
         enter-state
         (process->handle arg0)
         (go target-mech-get-off)
         )
        (('change-mode)
         (let ((v1-7 (-> arg3 param 0)))
           (cond
             ((= v1-7 'grab)
              (when (not (focus-test? self dead))
                (if (not (-> arg3 param 1))
                    #t
                    (go target-mech-grab)
                    )
                )
              )
             ((= v1-7 'normal)
              enter-state
              (process->handle arg0)
              (go target-mech-get-off)
              )
             ((begin (set! a0-18 'falling) (= v1-7 a0-18))
              (go target-mech-falling a0-18)
              )
             )
           )
         )
        (('swim 'slide 'edge-grab)
         #f
         )
        (('clone-anim)
         (go target-mech-clone-anim (process->handle (the-as process (-> arg3 param 0))))
         )
        (('touched)
         (cond
           ((logtest? (process-mask crate) (-> arg0 mask))
            (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
              (set! (-> a1-1 from) (process->ppointer self))
              (set! (-> a1-1 num-params) 2)
              (set! (-> a1-1 message) 'attack)
              (set! (-> a1-1 param 0) (-> arg3 param 0))
              (set! (-> a1-1 param 1)
                    (the-as
                      uint
                      (static-attack-info
                        ((id (-> self mech attack-id)) (mode 'mech) (penetrate-using (-> self control penetrate-using)))
                        )
                      )
                    )
              (set! v0-0 (send-event-function arg0 a1-1))
              )
            (when v0-0
              (let* ((v1-27 (-> self game))
                     (a0-39 (+ (-> v1-27 attack-id) 1))
                     )
                (set! (-> v1-27 attack-id) a0-39)
                (set! (-> self mech attack-id) a0-39)
                )
              )
            v0-0
            )
           (else
             (target-standard-event-handler arg0 arg1 arg2 arg3)
             )
           )
         )
        (('attack 'attack-or-shove 'attack-invinc)
         (let ((s3-0 (the-as
                       attack-info
                       (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 160)
                       )
                     )
               )
           (let ((s2-0 s3-0)
                 (s1-0 (method-of-type attack-info compute-intersect-info))
                 (s0-0 (-> arg3 param 1))
                 )
             (set! sv-96 self)
             (set! sv-112 arg0)
             (let ((a3-2 (if (type? sv-112 process-drawable)
                             sv-112
                             )
                         )
                   (t0-0 (-> arg3 param 0))
                   )
               (s1-0 s2-0 s0-0 sv-96 a3-2 (the-as touching-shapes-entry t0-0))
               )
             )
           (let* ((v1-30 (-> s3-0 mode))
                  (f30-0 (cond
                           ((= v1-30 'tar)
                            (set! (-> s3-0 id) (the-as uint 2))
                            (* 100.0 (seconds-per-frame))
                            )
                           ((= v1-30 'melt)
                            (set! (-> s3-0 id) (the-as uint 2))
                            (let ((s2-1 (if (logtest? (-> s3-0 mask) (attack-mask intersection))
                                            (-> s3-0 intersection)
                                            (-> self control trans)
                                            )
                                        )
                                  )
                              (launch-particles (-> *part-id-table* 955) s2-1)
                              (launch-particles (-> *part-id-table* 957) s2-1)
                              )
                            (* 100.0 (seconds-per-frame))
                            )
                           ((or (= v1-30 'burn) (= v1-30 'burnup))
                            (set! (-> s3-0 id) (the-as uint 2))
                            (if (logtest? (-> s3-0 mask) (attack-mask intersection))
                                (-> s3-0 intersection)
                                (-> self control trans)
                                )
                            (launch-particles (-> *part-id-table* 955) (-> self control trans))
                            (launch-particles (-> *part-id-table* 957) (-> self control trans))
                            (* 20.0 (seconds-per-frame))
                            )
                           ((= v1-30 'shock)
                            (let ((s2-2 (if (logtest? (-> s3-0 mask) (attack-mask intersection))
                                            (-> s3-0 intersection)
                                            (-> self control trans)
                                            )
                                        )
                                  )
                              (launch-particles (-> *part-id-table* 959) s2-2)
                              (launch-particles (-> *part-id-table* 960) s2-2)
                              )
                            (set! (-> s3-0 id) (the-as uint 2))
                            (* 20.0 (seconds-per-frame))
                            )
                           ((= v1-30 'explode)
                            20.0
                            )
                           ((= v1-30 'grunt)
                            1.0
                            )
                           ((= v1-30 'air)
                            100.0
                            )
                           ((or (= v1-30 'endlessfall) (= v1-30 'crush) (= v1-30 'instant-death))
                            100.0
                            )
                           (else
                             3.0
                             )
                           )
                         )
                  )
             (when (target-log-attack s3-0 'background)
               (case arg2
                 (('attack 'attack-or-shove 'attack-invinc)
                  (if (not (or (logtest? (-> self state-flags) (state-flags sf2))
                               (logtest? (-> self game secrets) (game-secrets invulnerable))
                               )
                           )
                      (seek! (-> self mech shield-value) 0.0 f30-0)
                      )
                  )
                 )
               (if (and (= arg2 'attack-or-shove) (< 0.0 (-> self mech shield-value)))
                   (set! arg2 'shove)
                   )
               (if (= arg2 'attack-invinc)
                   (set! (-> self mech shield-value) 0.0)
                   )
               (if (or (= (-> self mech shield-value) 0.0) (= arg2 'shove))
                   (target-attacked arg2 s3-0 arg0 (the-as touching-shapes-entry (-> arg3 param 0)) target-mech-hit)
                   'block
                   )
               )
             )
           )
         )
        (('shove)
         (when (not (focus-test? self dead hit))
           (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 160)
           (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
             (set! (-> self attack-info-rec attacker) (process->handle arg0))
             (logior! (-> self attack-info-rec mask) (attack-mask attacker))
             )
           (go target-mech-hit 'shove (-> self attack-info-rec))
           )
         )
        (('effect-control)
         (case (-> arg3 param 0)
           (('target-mech-walk)
            (sound-play-by-name
              (static-sound-name "mech-walk")
              (new-sound-id)
              1024
              (the int (* 1524.0 (lerp-scale -0.2 0.0 (-> self control ctrl-xz-vel) 12288.0 32768.0)))
              0
              (sound-group sfx)
              #t
              )
            )
           )
         )
        (('target-mech-get-off)
         (set! v0-0 (+ (current-time) (the-as time-frame (-> arg3 param 0))))
         (set! (-> self mech no-get-off-time) (the-as time-frame v0-0))
         v0-0
         )
        (else
          (target-standard-event-handler arg0 arg1 arg2 arg3)
          )
        )
      )
    )
  )

;; WARN: Return type mismatch symbol vs object.
(defbehavior target-mech-bonk-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (the-as
      object
      (when (and (= arg2 'touched)
                 ((method-of-type touching-shapes-entry prims-touching?)
                  (the-as touching-shapes-entry (-> arg3 param 0))
                  (-> self control)
                  (the-as uint 6)
                  )
                 (>= 409.6 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                 (begin
                   (vector-normalize!
                     (vector-!
                       s4-0
                       (the-as vector (-> self control collision-spheres 0 prim-core))
                       (-> self control actor-contact-pt)
                       )
                     1.0
                     )
                   (< 0.01 (-> s4-0 y))
                   )
                 )
        (if (< 0.75 (-> s4-0 y))
            (send-event
              arg0
              'bonk
              (-> arg3 param 0)
              (fmax
                (-> self control ground-impact-vel)
                (- (vector-dot (-> self control transv) (-> self control dynam gravity-normal)))
                )
              )
            )
        (when (and (= (target-send-attack
                        arg0
                        'bonk
                        (the-as touching-shapes-entry (-> arg3 param 0))
                        (the-as int (-> self control target-attack-id))
                        (the-as int (-> self control attack-count))
                        (penetrate touch bonk mech-bonk)
                        )
                      'bounce
                      )
                   (not (logtest? (-> self focus-status) (focus-status dead hit)))
                   )
          (set! (-> self control last-trans-any-surf quad) (-> self control trans quad))
          (target-timed-invulnerable (seconds 0.1) self 1)
          (if (focus-test? self carry)
              (go
                target-mech-carry-jump
                (-> *TARGET-bank* mech-carry-jump-height-min)
                (-> *TARGET-bank* mech-carry-jump-height-max)
                #f
                )
              (go
                target-mech-jump
                (-> *TARGET-bank* mech-jump-height-min)
                (-> *TARGET-bank* mech-jump-height-max)
                (the-as surface #f)
                )
              )
          )
        #f
        )
      )
    )
  )

;; WARN: Return type mismatch none vs object.
(defbehavior mech-leg-ik-callback target ((arg0 joint-mod-ik) (arg1 matrix) (arg2 matrix) (arg3 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (set! (-> s5-0 quad) (-> arg3 quad))
      (let ((f0-1 (- (-> arg3 y) (-> (target-pos 0) y))))
        (if (< 6144.0 f0-1)
            (set! f0-1 6144.0)
            )
        (if (< f0-1 -6144.0)
            (set! f0-1 -6144.0)
            )
        (+! (-> arg0 user-position y) f0-1)
        )
      (let ((f0-4 (- (-> arg3 y) (-> arg0 user-position y))))
        (seek! (-> arg0 user-float) f0-4 (* 40960.0 (seconds-per-frame)))
        )
      (let* ((f28-0 (-> arg0 user-float))
             (f30-1 (lerp-scale 1.0 0.0 f28-0 0.0 12288.0))
             (s3-0 (new 'stack-no-clear 'vector))
             )
        (let ((v1-12 s5-0))
          (let ((a0-4 *up-vector*))
            (let ((a1-4 8192.0))
              (.mov vf7 a1-4)
              )
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.lvf vf4 (&-> v1-12 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> s3-0 quad) vf6)
        (vector-float*! (new 'stack-no-clear 'vector) *up-vector* -16384.0)
        (let ((s2-0 (new 'stack-no-clear 'vector)))
          0.0
          (let ((f0-11 (intersect-ray-plane s3-0 *up-vector* (-> arg0 user-position) *up-vector*))
                (a0-7 s2-0)
                )
            (let ((v1-15 *up-vector*))
              (let ((a1-7 f0-11))
                (.mov vf7 a1-7)
                )
              (.lvf vf5 (&-> v1-15 quad))
              )
            (.lvf vf4 (&-> s3-0 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-7 quad) vf6)
            )
          (let ((a0-8 s2-0))
            (let ((v1-16 *up-vector*))
              (let ((a1-8 (- f28-0)))
                (.mov vf7 a1-8)
                )
              (.lvf vf5 (&-> v1-16 quad))
              )
            (.lvf vf4 (&-> arg3 quad))
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a0-8 quad) vf6)
            )
          (let ((a1-9 s5-0))
            (let ((v1-17 s5-0))
              (let ((a0-10 (vector-! (new 'stack-no-clear 'vector) s2-0 s5-0)))
                (let ((a2-6 (fmin 1.0 (* (-> arg0 user-blend) f30-1))))
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-10 quad))
                )
              (.lvf vf4 (&-> v1-17 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-9 quad) vf6)
            )
          )
        )
      (the-as object (handle-copy! arg0 s5-0))
      )
    )
  )

(defbehavior mech-update-ik target ()
  (local-vars (sv-720 vector))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (new 'stack-no-clear 'collide-query))
          (s5-0 (-> (the-as process-drawable (-> self parent 0)) root))
          )
      (let ((a1-0 (-> gp-0 bbox))
            (v1-2 (-> s5-0 trans))
            (a0-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> a0-0 x) 10240.0)
        (set! (-> a0-0 y) 10240.0)
        (set! (-> a0-0 z) 10240.0)
        (set! (-> a0-0 w) 1.0)
        (vector-! (the-as vector a1-0) v1-2 a0-0)
        )
      (let ((a1-2 (-> gp-0 bbox max))
            (v1-3 (-> s5-0 trans))
            (a0-1 (new 'stack-no-clear 'vector))
            )
        (set! (-> a0-1 x) 10240.0)
        (set! (-> a0-1 y) 10240.0)
        (set! (-> a0-1 z) 10240.0)
        (set! (-> a0-1 w) 1.0)
        (vector+! a1-2 v1-3 a0-1)
        )
      (set! (-> gp-0 collide-with) (-> (the-as collide-shape-moving s5-0) root-prim prim-core collide-with))
      (set! (-> gp-0 ignore-process0) #f)
      (set! (-> gp-0 ignore-process1) #f)
      (set! (-> gp-0 ignore-pat) (-> (the-as collide-shape-moving s5-0) pat-ignore-mask))
      (fill-using-bounding-box *collide-cache* gp-0)
      (dotimes (s4-0 2)
        (let ((s3-0 (-> (the-as (array joint-mod-ik) (+ (* s4-0 4) (the-as int self))) 64)))
          #t
          (set! (-> s3-0 callback) mech-leg-ik-callback)
          (-> s3-0 shoulder-matrix-no-ik)
          (let ((v1-13 (-> s3-0 elbow-matrix-no-ik))
                (s0-0 (new 'stack-no-clear 'vector))
                )
            (set! sv-720 (new 'stack-no-clear 'vector))
            (let ((a0-5 (-> *y-vector* quad)))
              (set! (-> sv-720 quad) a0-5)
              )
            (let ((s2-0 (new 'stack-no-clear 'vector)))
              (new 'stack-no-clear 'vector)
              (new 'stack-no-clear 'vector)
              (let ((s1-0 (new 'stack-no-clear 'vector)))
                (let ((a1-6 s0-0))
                  (let ((a0-8 (-> v1-13 trans)))
                    (let ((v1-14 (-> v1-13 vector 1)))
                      (let ((a2-8 (-> s3-0 hand-dist)))
                        (.mov vf7 a2-8)
                        )
                      (.lvf vf5 (&-> v1-14 quad))
                      )
                    (.lvf vf4 (&-> a0-8 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a1-6 quad) vf6)
                  )
                (let ((f0-11
                        (lerp-scale 1.0 0.0 (- (-> s0-0 y) (-> (the-as collide-shape-moving s5-0) gspot-pos y)) 2048.0 12288.0)
                        )
                      )
                  (seek! (-> s3-0 user-blend) f0-11 (* 4.0 (seconds-per-frame)))
                  )
                (let ((a1-9 (-> gp-0 start-pos)))
                  (let ((v1-18 s0-0))
                    (let ((a0-11 sv-720))
                      (let ((a2-12 6144.0))
                        (.mov vf7 a2-12)
                        )
                      (.lvf vf5 (&-> a0-11 quad))
                      )
                    (.lvf vf4 (&-> v1-18 quad))
                    )
                  (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                  (.mul.x.vf acc vf5 vf7 :mask #b111)
                  (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                  (.svf (&-> a1-9 quad) vf6)
                  )
                (let ((v1-19 (-> gp-0 move-dist))
                      (f0-16 -20480.0)
                      )
                  (vector-float*! v1-19 sv-720 f0-16)
                  )
                (let ((v1-21 gp-0))
                  (set! (-> v1-21 radius) 4.096)
                  (set! (-> v1-21 collide-with) (-> gp-0 collide-with))
                  (set! (-> v1-21 ignore-process0) #f)
                  (set! (-> v1-21 ignore-process1) #f)
                  (set! (-> v1-21 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                  (set! (-> v1-21 action-mask) (collide-action solid))
                  )
                (let ((f30-0 (probe-using-line-sphere *collide-cache* gp-0)))
                  (cond
                    ((>= f30-0 0.0)
                     (set! (-> s1-0 quad) (-> gp-0 best-other-tri normal quad))
                     (when (< 8192.0 (vector-vector-angle-safe *y-vector* s1-0))
                       (let* ((a1-14 (vector-normalize! (vector-cross! (new 'stack-no-clear 'vector) *y-vector* s1-0) 1.0))
                              (a2-14 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) a1-14 8192.0))
                              )
                         (vector-orient-by-quat! s1-0 *y-vector* a2-14)
                         )
                       )
                     (let ((a1-16 s2-0))
                       (let ((v1-28 (-> gp-0 start-pos)))
                         (let ((a0-26 (-> gp-0 move-dist)))
                           (let ((a2-15 f30-0))
                             (.mov vf7 a2-15)
                             )
                           (.lvf vf5 (&-> a0-26 quad))
                           )
                         (.lvf vf4 (&-> v1-28 quad))
                         )
                       (.add.x.vf vf6 vf0 vf0 :mask #b1000)
                       (.mul.x.vf acc vf5 vf7 :mask #b111)
                       (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
                       (.svf (&-> a1-16 quad) vf6)
                       )
                     (set! (-> s3-0 user-position quad) (-> s2-0 quad))
                     (set! (-> s3-0 user-normal quad) (-> s1-0 quad))
                     )
                    (else
                      (set! (-> s0-0 y) (-> (target-pos 0) y))
                      (set! (-> s3-0 user-position quad) (-> s0-0 quad))
                      (set! (-> s3-0 user-normal quad) (-> *y-vector* quad))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-mech-init target ((arg0 handle) (arg1 float) (arg2 symbol))
  (local-vars
    (sv-96 (function vector entity-actor skeleton-group vector object none :behavior manipy))
    (sv-112 vector)
    (sv-128 entity-actor)
    )
  (target-gun-end-mode #f)
  (target-exit)
  (when (zero? (-> self mech))
    (set! (-> self mech) (new 'process 'mech-info))
    (set! (-> self mech hud 0) (the-as handle #f))
    (set! (-> self mech engine-sound-id) (new-sound-id))
    (set! (-> self mech thrust-sound-id) (new-sound-id))
    (set! (-> self mech drag-sound-id) (new-sound-id))
    (set! (-> self mech whine-sound-id) (new-sound-id))
    )
  (set! (-> self board latch?) #f)
  (set! (-> self mech stick-lock) #f)
  (set! (-> self mech stick-off) #f)
  (set! (-> self mech unstuck-time) (current-time))
  (set! (-> self mech stuck-count) 0)
  (set! (-> self mech mech-start-time) (current-time))
  (set! (-> self mech jump-thrust) 0.0)
  (set! (-> self mech jump-thrust-fuel) (-> *TARGET-bank* mech-jump-thrust-fuel))
  (set! (-> self mech state-impact? 0) #f)
  ((method-of-type impact-control initialize)
   (the-as impact-control (-> self mech state-impact))
   self
   -1
   0.0
   (collide-spec)
   )
  (set! (-> self mech shield-max) 100.0)
  (set! (-> self mech shield-value) arg1)
  (set! (-> self mech entity) #f)
  (let ((v1-27 (handle->process arg0)))
    (if v1-27
        (set! (-> self mech entity) (-> v1-27 entity))
        )
    )
  (let ((v1-30 (-> self mech)))
    (set! (-> v1-30 particle-system-2d) *sp-particle-system-2d*)
    (set! (-> v1-30 particle-system-3d) *sp-particle-system-3d*)
    (set! (-> v1-30 part-quat) *particle-quat*)
    (set! (-> v1-30 part-vel) *particle-vel*)
    (set! (-> v1-30 part-thruster) (-> *part-id-table* 939))
    (set! (-> v1-30 part-thruster-scale-x) (-> *part-id-table* 939 init-specs 4))
    (set! (-> v1-30 part-thruster-scale-y) (-> *part-id-table* 939 init-specs 5))
    (set! (-> v1-30 thruster-flame-width) 0.0)
    (set! (-> v1-30 thruster-flame-length) 0.0)
    )
  (set! (-> self control reaction) target-collision-reaction)
  (set! (-> self control transv quad) (the-as uint128 0))
  (set! (-> self control ctrl-xz-vel) 0.0)
  (logior! (-> self focus-status) (focus-status mech))
  (set! (-> self control bend-target) 0.0)
  (let ((v1-40 (-> self node-list data)))
    (set! (-> v1-40 0 param0) (the-as (function cspace transformq none) cspace<-transformq+world-trans!))
    (set! (-> v1-40 0 param1) (the-as basic (-> self control trans)))
    (set! (-> v1-40 0 param2) (the-as basic (-> self control cspace-offset)))
    )
  (target-collide-set! 'mech 0.0)
  (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noentity #x1 :nomech #x1))
  (set! (-> self draw shadow) #f)
  (let ((s4-1 (-> self entity))
        (s3-0 (-> self level))
        )
    (process-entity-set! self (the-as entity (-> self mech entity)))
    (let ((s2-0 (get-process *16k-dead-pool* manipy #x4000)))
      (set! (-> self manipy)
            (the-as
              (pointer manipy)
              (when s2-0
                (let ((t9-11 (method-of-type manipy activate)))
                  (t9-11 (the-as manipy s2-0) self (symbol->string (-> manipy symbol)) (the-as pointer #x70004000))
                  )
                (let ((s1-0 run-function-in-process)
                      (s0-0 s2-0)
                      )
                  (set! sv-96 manipy-init)
                  (set! sv-112 (-> self control trans))
                  (set! sv-128 (-> self entity))
                  (let ((t0-1 (art-group-get-by-name *level* "skel-mech" (the-as (pointer uint32) #f)))
                        (t1-0 #f)
                        (t2-0 0)
                        )
                    ((the-as (function object object object object object object object none) s1-0)
                     s0-0
                     sv-96
                     sv-112
                     sv-128
                     t0-1
                     t1-0
                     t2-0
                     )
                    )
                  )
                (-> s2-0 ppointer)
                )
              )
            )
      )
    (set! (-> self entity) s4-1)
    (set! (-> self level) s3-0)
    )
  (when (-> self manipy)
    (send-event
      (ppointer->process (-> self manipy))
      'trans-hook
      (lambda :behavior manipy
        ()
        (let ((v1-0 (ppointer->process (the-as (pointer target) (-> self parent)))))
          (set! (-> self root trans quad) (-> v1-0 mech mech-trans quad))
          (let ((a0-4 (-> v1-0 mech mech-quat quad)))
            (set! (-> self root quat quad) a0-4)
            )
          (set! (-> self root scale quad) (-> v1-0 mech mech-scale quad))
          (set! (-> self draw light-index) (-> v1-0 draw light-index))
          (let ((a0-10 (-> v1-0 draw color-mult quad)))
            (set! (-> self draw color-mult quad) a0-10)
            )
          (let ((a0-12 (-> v1-0 draw color-emissive quad)))
            (set! (-> self draw color-emissive quad) a0-12)
            )
          (let ((v1-4 (-> v1-0 draw shadow-ctrl settings shadow-dir quad)))
            (set! (-> self draw shadow-ctrl settings shadow-dir quad) v1-4)
            )
          )
        (dotimes (gp-0 2)
          (target-set! (-> self joint gp-0) (the-as vector #t))
          )
        (none)
        )
      )
    (send-event
      (ppointer->process (-> self manipy))
      'post-hook
      (lambda :behavior mech
        ()
        (let ((gp-0 (ppointer->process (-> self parent))))
          ((method-of-type impact-control update-from-cspace)
           (the-as impact-control (-> (the-as target gp-0) mech state-impact))
           )
          (when (-> (the-as target gp-0) mech state-impact? 0)
            (let ((a1-0 (new 'stack-no-clear 'collide-query)))
              ((method-of-type impact-control impact-control-method-11)
               (the-as impact-control (-> (the-as target gp-0) mech state-impact))
               a1-0
               (the-as process gp-0)
               (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1)
               )
              )
            )
          (mech-update-ik)
          (target-mech-mech-effect (the-as target gp-0))
          )
        (none)
        )
      )
    (send-event (ppointer->process (-> self manipy)) 'anim-mode 'clone-anim)
    (send-event (ppointer->process (-> self manipy)) 'sync #t)
    (send-event
      (ppointer->process (-> self manipy))
      'eval
      (lambda :behavior target
        ()
        (set! (-> self state-hook) #f)
        (set! (-> self draw shadow-ctrl) *mech-shadow-control*)
        (set! (-> self mech-ik 0) (new 'process 'joint-mod-ik self 27 5283.84))
        (set! (-> self mech-ik 1) (new 'process 'joint-mod-ik self 33 5283.84))
        (dotimes (v1-3 2)
          (let ((a0-5 (-> (the-as (array joint-mod-ik) (+ (* v1-3 4) (the-as int self))) 64)))
            (set! (-> a0-5 elbow-pole-vector-axis) (the-as uint 2))
            (set! (-> a0-5 elbow-rotation-axis) (the-as uint 0))
            (set! (-> a0-5 callback) mech-leg-ik-callback)
            (logior! (-> a0-5 flags) (joint-mod-ik-flags elbow-trans-neg))
            )
          )
        (none)
        )
      )
    )
  (logior! (-> self state-flags) (state-flags sf6))
  (set-setting! 'string-max-length 'low (meters 7) 0)
  (set-setting! 'string-min-length 'low (meters 4) 0)
  (set-setting! 'string-max-height 'low (meters 5) 0)
  (set-setting! 'string-min-height 'low (meters 3.5) 0)
  (set-setting! 'fov 'abs (degrees 75.0) 0)
  (set-setting! 'head-offset 'abs (meters 4.5) 0)
  (set-setting! 'mode-sound-bank 'mech 0.0 0)
  (set-setting! 'sound-flava #f 30.0 3)
  (set! (-> self mech hud 0) (ppointer->handle (process-spawn hud-heatmeter :init hud-init-by-other :to self)))
  (remove-exit)
  (if arg2
      (go target-mech-stance)
      (go target-mech-get-on arg0)
      )
  (none)
  )

(defbehavior target-mech-exit target ()
  (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                         (or (= v1-3 'target-mech-stance)
                                             (= v1-3 'target-mech-walk)
                                             (= v1-3 'target-mech-jump)
                                             (= v1-3 'target-mech-jump-jump)
                                             (= v1-3 'target-mech-falling)
                                             (= v1-3 'target-mech-hit-ground)
                                             (= v1-3 'target-mech-punch)
                                             (= v1-3 'target-mech-hit)
                                             (= v1-3 'target-mech-death)
                                             (= v1-3 'target-mech-carry-drag)
                                             (= v1-3 'target-mech-carry-pickup)
                                             (= v1-3 'target-mech-carry-drop)
                                             (= v1-3 'target-mech-carry-stance)
                                             (= v1-3 'target-mech-carry-walk)
                                             (= v1-3 'target-mech-carry-jump)
                                             (= v1-3 'target-mech-carry-falling)
                                             (= v1-3 'target-mech-carry-hit-ground)
                                             (= v1-3 'target-mech-carry-throw)
                                             (= v1-3 'target-mech-get-off)
                                             (= v1-3 'target-mech-get-off-jump)
                                             (= v1-3 'target-mech-grab)
                                             (= v1-3 'target-mech-clone-anim)
                                             )
                                         )
                  )
             )
    (let ((v1-4 (-> self manipy)))
      (when v1-4
        (deactivate (-> v1-4 0))
        (set! (-> self manipy) (the-as (pointer manipy) #f))
        )
      )
    (logclear! (-> self focus-status) (focus-status mech))
    (logclear! (-> self control root-prim prim-core action) (collide-action stuck-wall-escape))
    (set! (-> self control mod-surface) *walk-mods*)
    (logclear! (-> self state-flags) (state-flags sf6))
    (remove-setting! 'string-max-length)
    (remove-setting! 'string-min-length)
    (remove-setting! 'string-max-height)
    (remove-setting! 'string-min-height)
    (remove-setting! 'fov)
    (remove-setting! 'head-offset)
    (remove-setting! 'mode-sound-bank)
    (remove-setting! 'sound-flava)
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (let ((v1-39 (-> self node-list data)))
      (set! (-> v1-39 0 param0) (the-as (function cspace transformq none) cspace<-transformq+trans!))
      (set! (-> v1-39 0 param1) (the-as basic (-> self control trans)))
      (set! (-> v1-39 0 param2) (the-as basic (-> self control cspace-offset)))
      )
    (target-collide-set! 'normal 0.0)
    (set! (-> self control reaction) target-collision-reaction)
    (set! (-> self control pat-ignore-mask) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1))
    (sound-stop (-> self mech engine-sound-id))
    (sound-stop (-> self mech thrust-sound-id))
    (sound-stop (-> self mech drag-sound-id))
    (sound-stop (-> self mech whine-sound-id))
    (send-event (handle->process (-> self mech hud 0)) 'hide-and-die)
    (set! (-> self draw shadow) (-> self shadow-backup))
    (set! (-> self control cspace-offset quad) (the-as uint128 0))
    (remove-setting! 'sound-flava)
    (target-exit)
    )
  (none)
  )

(defbehavior target-mech-effect target ()
  (sound-play "mech-pulse" :id (-> self mech engine-sound-id))
  (set! (-> self game distance) (/ (-> self mech shield-value) (-> self mech shield-max)))
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior target-mech-add-thrust target ()
  (let ((s5-0 (-> self control target-transv))
        (gp-0 (-> self control transv-ctrl))
        )
    (set! (-> (new 'stack-no-clear 'vector) quad) (-> self control target-transv quad))
    (target-bend-vel-turn gp-0)
    (target-add-slide-factor s5-0)
    (let ((t9-2 vector-xz-normalize!)
          (a0-5 (new-stack-vector0))
          )
      (set! (-> a0-5 quad) (-> s5-0 quad))
      (let ((s4-0 (t9-2 a0-5 1.0)))
        (let ((t9-3 vector-xz-normalize!)
              (a0-6 (new-stack-vector0))
              )
          (set! (-> a0-6 quad) (-> gp-0 quad))
          (let ((v1-7 (t9-3 a0-6 1.0)))
            (set! (-> s4-0 y) 0.0)
            (set! (-> v1-7 y) 0.0)
            )
          )
        (let* ((f0-2 (-> s4-0 z))
               (v1-8 gp-0)
               (f1-4 (sqrtf (+ (* (-> v1-8 x) (-> v1-8 x)) (* (-> v1-8 z) (-> v1-8 z)))))
               (v1-10 s5-0)
               (f0-11
                 (cond
                   ((>= f1-4 (sqrtf (+ (* (-> v1-10 x) (-> v1-10 x)) (* (-> v1-10 z) (-> v1-10 z)))))
                    (let ((f0-3 (-> self control current-surface fric))
                          (f1-5 1.0)
                          (v1-15 gp-0)
                          )
                      (* f0-3 (fmax f1-5 (/ (sqrtf (+ (* (-> v1-15 x) (-> v1-15 x)) (* (-> v1-15 z) (-> v1-15 z))))
                                            (-> self control current-surface nonlin-fric-dist)
                                            )
                                    )
                         )
                      )
                    )
                   ((>= f0-2 0.0)
                    (+ (* f0-2 (-> self control current-surface seek0)) (* (- 1.0 f0-2) (-> self control current-surface seek90)))
                    )
                   (else
                     (+ (* (fabs f0-2) (-> self control current-surface seek180))
                        (* (+ 1.0 f0-2) (-> self control current-surface seek90))
                        )
                     )
                   )
                 )
               (s4-1 vector-xz-normalize!)
               (s3-0 gp-0)
               (t9-4 seek)
               (v1-30 gp-0)
               )
          (s4-1 s3-0 (t9-4
                       (sqrtf (+ (* (-> v1-30 x) (-> v1-30 x)) (* (-> v1-30 z) (-> v1-30 z))))
                       (sqrtf (+ (* (-> s5-0 x) (-> s5-0 x)) (* (-> s5-0 z) (-> s5-0 z))))
                       (* f0-11 (seconds-per-frame))
                       )
                )
          )
        )
      )
    (set! (-> self control velocity-after-thrust) (vector-length gp-0))
    )
  (let ((gp-1 (new-stack-vector0)))
    (vector-matrix*! gp-1 (-> self control transv-ctrl) (-> self control c-R-w))
    (vector-float*! gp-1 gp-1 0.5)
    (vector+! gp-1 gp-1 (-> self control trans))
    (add-debug-text-sphere
      *display-target-marks*
      (bucket-id debug-no-zbuf1)
      gp-1
      (meters 0.2)
      "ltransv"
      (new 'static 'rgba :g #xff :a #x80)
      )
    )
  (none)
  )

(defbehavior target-mech-collision target ()
  (cond
    ((and (-> self next-state) (= (-> self next-state name) 'target-mech-carry-drag))
     (let ((s5-0 (new 'stack-no-clear 'vector))
           (gp-0 (new 'stack-no-clear 'vector))
           )
       (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
         (set! (-> a1-0 from) (process->ppointer self))
         (set! (-> a1-0 num-params) 2)
         (set! (-> a1-0 message) 'move)
         (set! (-> a1-0 param 0) (the-as uint (-> self control transv)))
         (set! (-> a1-0 param 1) (the-as uint s5-0))
         (let ((s3-0 (send-event-function (handle->process (-> self carry other)) a1-0))
               (s4-0 (new 'stack-no-clear 'vector))
               )
           (set! (-> s4-0 quad) (-> self control trans quad))
           (set! (-> (new 'stack-no-clear 'vector) quad) (-> self control transv quad))
           (let ((a2-1 (new 'stack-no-clear 'collide-query))
                 (v1-18 (-> self control))
                 )
             (set! (-> a2-1 collide-with) (-> v1-18 root-prim prim-core collide-with))
             (set! (-> a2-1 ignore-process0) self)
             (set! (-> a2-1 ignore-process1) #f)
             (set! (-> a2-1 ignore-pat) (-> v1-18 pat-ignore-mask))
             (set! (-> a2-1 action-mask) (collide-action solid))
             (fill-cache-integrate-and-collide v1-18 (-> v1-18 transv) a2-1 (meters 1))
             )
           (vector-! gp-0 (-> self control trans) s4-0)
           (let* ((s2-0 (-> self control dynam gravity-normal))
                  (f30-0 (- (vector-dot s2-0 gp-0) (vector-dot s2-0 s5-0)))
                  (a1-4 (new 'stack-no-clear 'event-message-block))
                  )
             (set! (-> a1-4 from) (process->ppointer self))
             (set! (-> a1-4 num-params) 0)
             (set! (-> a1-4 message) 'carry-info)
             (let* ((s1-0 (the-as carry-info (send-event-function (handle->process (-> self carry other)) a1-4)))
                    (f0-2 (distance-from-destination (-> self carry) s1-0))
                    )
               (cond
                 ((not s3-0)
                  )
                 ((>= f0-2 0.0)
                  (let ((v1-38 (vector-float*! (new 'stack-no-clear 'vector) s2-0 f30-0)))
                    (vector+! (-> s1-0 hold-trans) (-> s1-0 hold-trans) v1-38)
                    )
                  (let ((v1-39 (new-stack-vector0)))
                    (let ((f0-4 (vector-dot (-> self control dynam gravity-normal) s5-0)))
                      0.0
                      (vector-! v1-39 s5-0 (vector-float*! v1-39 (-> self control dynam gravity-normal) f0-4))
                      )
                    (let ((f0-5 (vector-length v1-39)))
                      f0-5
                      (let ((f0-6 f0-5)
                            (v1-42 (new-stack-vector0))
                            )
                        (let ((f1-6 (vector-dot (-> self control dynam gravity-normal) gp-0)))
                          0.0
                          (vector-! v1-42 gp-0 (vector-float*! v1-42 (-> self control dynam gravity-normal) f1-6))
                          )
                        (let ((f1-7 (vector-length v1-42)))
                          f1-7
                          (when (< f0-6 f1-7)
                            (let ((v1-46 (new-stack-vector0))
                                  (f0-8 (vector-dot (-> self control dynam gravity-normal) gp-0))
                                  )
                              0.0
                              (vector-! v1-46 gp-0 (vector-float*! v1-46 (-> self control dynam gravity-normal) f0-8))
                              (let ((f1-11 (vector-length v1-46))
                                    (a0-43 (new-stack-vector0))
                                    )
                                (let ((f2-3 (vector-dot (-> self control dynam gravity-normal) s5-0)))
                                  0.0
                                  (vector-! a0-43 s5-0 (vector-float*! a0-43 (-> self control dynam gravity-normal) f2-3))
                                  )
                                (let ((f2-4 (vector-length a0-43)))
                                  f2-4
                                  (let ((f2-5 f2-4))
                                    (vector+!
                                      gp-0
                                      (vector-float*! gp-0 (-> self control dynam gravity-normal) f0-8)
                                      (vector-float*! v1-46 v1-46 (/ f2-5 f1-11))
                                      )
                                    )
                                  )
                                )
                              )
                            (let ((a1-25 (vector+! (new 'stack-no-clear 'vector) s4-0 gp-0)))
                              (move-to-point! (-> self control) a1-25)
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                 (else
                   (send-event self 'drop (seconds 0.5))
                   )
                 )
               )
             )
           )
         )
       )
     )
    (else
      (when *debug-segment*
        (let ((gp-1 (-> *display* frames (-> *display* on-screen) profile-array data 0))
              (v1-61 'target)
              (s5-1 *profile-target-color*)
              )
          (when (and *dproc* *debug-segment*)
            (let ((s4-1 (-> gp-1 data (-> gp-1 count))))
              (let ((s3-1 (-> gp-1 base-time)))
                (set! (-> s4-1 name) v1-61)
                (set! (-> s4-1 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-1))))
                )
              (set! (-> s4-1 depth) (the-as uint (-> gp-1 depth)))
              (set! (-> s4-1 color) s5-1)
              (set! (-> gp-1 segment (-> gp-1 depth)) s4-1)
              )
            (+! (-> gp-1 count) 1)
            (+! (-> gp-1 depth) 1)
            (set! (-> gp-1 max-depth) (max (-> gp-1 max-depth) (-> gp-1 depth)))
            )
          )
        0
        )
      (let ((a2-17 (new 'stack-no-clear 'collide-query))
            (v1-74 (-> self control))
            )
        (set! (-> a2-17 collide-with) (-> v1-74 root-prim prim-core collide-with))
        (set! (-> a2-17 ignore-process0) self)
        (set! (-> a2-17 ignore-process1) #f)
        (set! (-> a2-17 ignore-pat) (-> v1-74 pat-ignore-mask))
        (set! (-> a2-17 action-mask) (collide-action solid))
        (fill-cache-integrate-and-collide v1-74 (-> v1-74 transv) a2-17 (meters 1))
        )
      (when *debug-segment*
        (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
          (when (and *dproc* *debug-segment*)
            (let* ((v1-87 (+ (-> gp-2 depth) -1))
                   (s5-2 (-> gp-2 segment v1-87))
                   (s4-2 (-> gp-2 base-time))
                   )
              (when (>= v1-87 0)
                (set! (-> s5-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-2))))
                (+! (-> gp-2 depth) -1)
                )
              )
            )
          )
        0
        )
      )
    )
  (when (logtest? (-> self control status) (collide-status touch-wall))
    (let ((v1-98 (vector-! (new 'stack-no-clear 'vector) (-> self control wall-contact-pt) (-> self control trans))))
      (set! (-> v1-98 y) 0.0)
      (when (< (vector-dot v1-98 (-> self control c-R-w vector 2)) 0.0)
        (set! (-> self mech back-touch-time) (current-time))
        (set! (-> self mech back-touch-point quad) (-> self control wall-contact-pt quad))
        (set! (-> self mech back-touch-trans quad) (-> self control trans quad))
        )
      )
    )
  0
  (none)
  )

(defbehavior target-mech-real-post target ()
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-1 (max 1 (the int (-> self clock time-adjust-ratio)))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-1)))
      (while (nonzero? gp-1)
        (+! gp-1 -1)
        (set! (-> self control remaining-ctrl-iterations) gp-1)
        (flag-setup)
        (if (< (-> self control force-turn-to-strength) 0.0)
            (set! (-> self control force-turn-to-strength) (- 1.0 (-> self control cpad stick0-speed)))
            )
        (build-conversions (-> self control transv))
        (do-rotations1)
        (let ((s5-0 (new-stack-vector0)))
          (read-pad s5-0)
          (let ((f28-0 (-> self control pad-magnitude)))
            (if (or (and (< 0.0 f28-0)
                         (< 0.3 (-> self control pad-magnitude))
                         (< (vector-dot (-> self control pad-xz-dir) (-> self control last-pad-xz-dir)) 0.2)
                         (< f28-0 0.7)
                         )
                    (-> self mech stick-off)
                    )
                (set! f28-0 0.0)
                )
            (when (!= (-> self control force-turn-to-strength) 0.0)
              (let ((f0-15 (fmin 1.0 (-> self control force-turn-to-strength))))
                (set! (-> self control force-turn-to-strength) f0-15)
                (let ((a1-2 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (if (= f28-0 0.0)
                                  *zero-vector*
                                  s5-0
                                  )
                              f28-0
                              )
                            )
                      (a2-1 (vector-float*!
                              (new 'stack-no-clear 'vector)
                              (-> self control force-turn-to-direction)
                              (-> self control force-turn-to-speed)
                              )
                            )
                      )
                  (vector-lerp! s5-0 a1-2 a2-1 f0-15)
                  )
                )
              (set! f28-0 (vector-length s5-0))
              (vector-normalize! s5-0 1.0)
              )
            (turn-to-vector s5-0 f28-0)
            )
          )
        (cond
          ((and (logtest? (-> self control mod-surface flags) (surface-flag air))
                (not (logtest? (-> self control status) (collide-status on-surface)))
                )
           (add-thrust)
           )
          (else
            (let* ((v1-51 (-> self control target-transv))
                   (f0-20 (sqrtf (+ (* (-> v1-51 x) (-> v1-51 x)) (* (-> v1-51 z) (-> v1-51 z)))))
                   )
              (set-vector! (-> self control target-transv) 0.0 0.0 f0-20 1.0)
              )
            (target-mech-add-thrust)
            )
          )
        (add-gravity)
        (do-rotations2)
        (reverse-conversions (-> self control transv))
        (pre-collide-setup)
        (target-mech-collision)
        (bend-gravity)
        (post-flag-setup)
        )
      )
    (update-rates! (-> self clock) f30-0)
    )
  (when *debug-segment*
    (let ((gp-2 (-> *display* frames (-> *display* on-screen) profile-array data 0))
          (v1-68 'target-post)
          (s5-1 *profile-target-post-color*)
          )
      (when (and *dproc* *debug-segment*)
        (let ((s4-0 (-> gp-2 data (-> gp-2 count))))
          (let ((s3-0 (-> gp-2 base-time)))
            (set! (-> s4-0 name) v1-68)
            (set! (-> s4-0 start-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s3-0))))
            )
          (set! (-> s4-0 depth) (the-as uint (-> gp-2 depth)))
          (set! (-> s4-0 color) s5-1)
          (set! (-> gp-2 segment (-> gp-2 depth)) s4-0)
          )
        (+! (-> gp-2 count) 1)
        (+! (-> gp-2 depth) 1)
        (set! (-> gp-2 max-depth) (max (-> gp-2 max-depth) (-> gp-2 depth)))
        )
      )
    0
    )
  (ja-post)
  (when *debug-segment*
    (let ((gp-3 (-> *display* frames (-> *display* on-screen) profile-array data 0)))
      (when (and *dproc* *debug-segment*)
        (let* ((v1-92 (+ (-> gp-3 depth) -1))
               (s5-2 (-> gp-3 segment v1-92))
               (s4-1 (-> gp-3 base-time))
               )
          (when (>= v1-92 0)
            (set! (-> s5-2 end-time) (the-as int (- (timer-count (the-as timer-bank #x10000800)) (the-as uint s4-1))))
            (+! (-> gp-3 depth) -1)
            )
          )
        )
      )
    0
    )
  (joint-points)
  (do-target-gspot)
  (target-powerup-process)
  (vector+! (-> self mech mech-trans) (-> self control trans) (-> self control cspace-offset))
  (quaternion-copy! (the-as quaternion (-> self mech mech-quat)) (-> self control quat))
  (set! (-> self mech mech-scale quad) (-> self control scale quad))
  (vector+! (-> self alt-cam-pos) (-> self control camera-pos) (new 'static 'vector :y 4096.0 :w 1.0))
  (set! (-> self mech mech-time) (current-time))
  (target-mech-effect)
  0
  (none)
  )

(defbehavior target-mech-post target ()
  (target-mech-real-post)
  (none)
  )
