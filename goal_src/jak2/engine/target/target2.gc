;;-*-Lisp-*-
(in-package goal)

;; name: target2.gc
;; name in dgo: target2
;; dgos: ENGINE, GAME

(define-extern *trip-mods* surface)
(define-extern *look-around-mods* surface)

;; DECOMP BEGINS

(let ((a0-1 (copy *walk-no-turn-mods* 'global)))
  (set! (-> a0-1 flags) (surface-flag gun-off gun-fast-exit))
  (set! *trip-mods* a0-1)
  )

(defstate target-load-wait (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('loading)
       (set! (-> self state-time) (current-time))
       #f
       )
      (else
        (target-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :exit target-exit
  :code (behavior ()
    (set! (-> self control mod-surface) *trip-mods*)
    (set! (-> self state-time) (current-time))
    (while (< (- (current-time) (-> self state-time)) (seconds 0.05))
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! (-> self draw art-group data 63)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 63)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (align! (-> self align) (align-opts adjust-xz-vel) 1.0 1.0 1.0)
        (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
          (let ((v1-22 (process->ppointer self)))
            (set! (-> a1-3 from) v1-22)
            )
          (set! (-> a1-3 num-params) 2)
          (set! (-> a1-3 message) 'joystick)
          (set! (-> a1-3 param 0) (the-as uint 0))
          (set! (-> a1-3 param 1) (the-as uint 0))
          (send-event-function *camera* a1-3)
          )
        (suspend)
        (ja :num! (seek!))
        )
      (let ((gp-0 (current-time)))
        (until (>= (- (current-time) gp-0) (seconds 0.3))
          (suspend)
          (ja :num! (seek! (ja-aframe 19.0 0) 0.05))
          (suspend)
          )
        )
      (ja-channel-push! 1 (seconds 0.3))
      (ja-no-eval :group! (-> self draw art-group data 25)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 25)) frames num-frames) -1)))
                  :frame-num (ja-aframe 40.0 0)
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      (ja-no-eval :group! (-> self draw art-group data 26)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 26)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    (go target-stance)
    (none)
    )
  :post target-no-stick-post
  )

(defstate target-stance-ambient (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('movie)
       (go target-stance)
       )
      (else
        (target-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self neck flex-blend) 0.0)
    ((-> target-stance enter))
    (let ((v1-2 (rand-vu-int-count 7)))
      (cond
        ((zero? v1-2)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-1" :anim-name "jak-ambient-1" :parts 1 :command-list '())
               )
         )
        ((= v1-2 1)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-2" :anim-name "jak-ambient-2" :parts 1 :command-list '())
               )
         )
        ((= v1-2 2)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-3" :anim-name "jak-ambient-3" :parts 1 :command-list '())
               )
         )
        ((= v1-2 3)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-4" :anim-name "jak-ambient-4" :parts 1 :command-list '())
               )
         )
        ((= v1-2 4)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-5" :anim-name "jak-ambient-5" :parts 1 :command-list '())
               )
         )
        ((= v1-2 5)
         (set! (-> self spool-anim)
               (new 'static 'spool-anim :name "jak-ambient-6" :anim-name "jak-ambient-6" :parts 1 :command-list '())
               )
         )
        (else
          (set! (-> self spool-anim)
                (new 'static 'spool-anim :name "jak-ambient-7" :anim-name "jak-ambient-7" :parts 1 :command-list '())
                )
          )
        )
      )
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (set! (-> self ambient-time) (current-time))
    (let ((a0-0 (-> self spool-anim)))
      (when (and a0-0 (= (-> *setting-control* user-current spooling) (process->ppointer self)))
        (ja-abort-spooled-anim a0-0 (the-as art-joint-anim #f) -1)
        (ja-channel-set! 1)
        (ja :group! (-> self draw art-group data 5) :num! min)
        )
      )
    (set! (-> self spool-anim) #f)
    ((-> target-stance exit))
    (target-exit)
    (none)
    )
  :trans (behavior ()
    (gui-control-method-12
      *gui-control*
      self
      (gui-channel art-load)
      (gui-action queue)
      (-> self spool-anim name)
      0
      -99.0
      (new 'static 'sound-id)
      )
    (if (or (cpad-hold? (-> self control cpad number) start l1 r1 triangle circle x square)
            *progress-process*
            (want-to-darkjak?)
            )
        (go target-stance)
        )
    (none)
    )
  :code (behavior ()
    (while (let ((v1-15 (file-status *art-control* (-> self spool-anim name) 0)))
             (not (or (= v1-15 'locked) (= v1-15 'active)))
             )
      (if (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
          (go target-stance)
          )
      (suspend)
      (ja :num! (loop!))
      )
    (ja-play-spooled-anim
      (-> self spool-anim)
      (the-as art-joint-anim (-> self draw art-group data 5))
      (the-as art-joint-anim (-> self draw art-group data 5))
      (lambda ((arg0 process-drawable)) (!= (-> *cpad-list* cpads 0 stick0-speed) 0.0))
      )
    (go target-stance)
    (none)
    )
  :post target-post
  )

(defstate target-stance-look-around (target)
  :event target-standard-event-handler
  :enter (-> target-stance enter)
  :exit (-> target-stance exit)
  :trans (-> target-stance trans)
  :code (behavior ()
    (while (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-0 from) (process->ppointer self))
             (set! (-> a1-0 num-params) 0)
             (set! (-> a1-0 message) 'dist-from-interp-src)
             (and (or (< (send-event-function *camera* a1-0) 4915.2) (< (- (current-time) (-> self state-time)) (seconds 0.05)))
                  (and (< (- (current-time) (-> self state-time)) (seconds 0.07)) (zero? (ja-group-size)))
                  )
             )
      (suspend)
      )
    (go target-stance)
    (none)
    )
  :post target-post
  )

(let ((a0-22 (copy *duck-mods* 'global)))
  (set! (-> a0-22 flags) (surface-flag gun-inactive))
  (set! *look-around-mods* a0-22)
  )

(defstate target-look-around (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (cond
                     ((and (= event-type 'query) (= (-> event param 0) 'mode))
                      (-> self state name)
                      )
                     (else
                       (let ((v1-4 event-type))
                         (cond
                           ((= v1-4 'end-mode)
                            (if (not (focus-test? self dead))
                                (go target-stance-look-around)
                                )
                            )
                           ((= v1-4 'gun)
                            (the-as object (target-gun-fire (the-as pickup-type (-> event param 0))))
                            )
                           ((-> self control danger-mode)
                            (target-dangerous-event-handler proc arg1 event-type event)
                            )
                           (else
                             (target-standard-event-handler proc arg1 event-type event)
                             )
                           )
                         )
                       )
                     )
            )
    )
  :enter (behavior ()
    (set! (-> self cam-user-mode) 'look-around)
    (set! (-> self control mod-surface) *look-around-mods*)
    (logior! (-> self focus-status) (focus-status in-head))
    (set-setting! 'mode-name 'cam-eye 0.0 0)
    (none)
    )
  :exit (behavior ()
    (set! (-> self cam-user-mode) 'normal)
    (target-exit)
    (remove-setting! 'mode-name)
    (none)
    )
  :trans (behavior ()
    (when (or (cpad-pressed? (-> self control cpad number) r3) (< 2048.0 (target-height-above-ground)))
      (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons r3))
      (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons r3))
      (set! (-> self cam-user-mode) 'normal)
      )
    (none)
    )
  :code (behavior ()
    (local-vars (a1-0 event-message-block) (f30-0 float))
    (until (>= f30-0 (send-event-function *camera* a1-0))
      (if (!= (-> self cam-user-mode) 'look-around)
          (go target-stance)
          )
      (suspend)
      (set! f30-0 8192.0)
      (set! a1-0 (new 'stack-no-clear 'event-message-block))
      (let ((v1-5 (process->ppointer self)))
        (set! (-> a1-0 from) v1-5)
        )
      (set! (-> a1-0 num-params) 0)
      (set! (-> a1-0 message) 'dist-from-interp-dest)
      )
    (ja-channel-set! 0)
    (set! (-> self control transv quad) (the-as uint128 0))
    (until #f
      (if (!= (-> self cam-user-mode) 'look-around)
          (go target-stance-look-around)
          )
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (target-no-move-post)
    (when (using-gun? self)
      (let ((gp-0 (camera-matrix)))
        (let ((s5-1 (vector-float*! (new-stack-vector0) (-> gp-0 vector 2) 8192.0)))
          (vector+float*! s5-1 s5-1 (-> gp-0 vector 1) -4096.0)
          (vector+! (-> self gun fire-point) (camera-pos) s5-1)
          )
        (set! (-> self gun fire-dir-out quad) (-> gp-0 vector 2 quad))
        )
      (set! (-> self gun track?) (the-as uint 6))
      (target-gun-check)
      )
    (none)
    )
  )

(defstate target-grab (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (cond
                     ((and (= event-type 'query) (= (-> event param 0) 'mode))
                      (-> self state name)
                      )
                     (else
                       (case event-type
                         (('end-mode)
                          (go target-stance)
                          )
                         (('play-anim)
                          (go target-grab (the-as symbol (-> event param 0)))
                          )
                         (('clone-anim)
                          (go target-clone-anim (process->handle (the-as process (-> event param 0))))
                          )
                         (('change-mode)
                          (case (-> event param 0)
                            (('normal)
                             (cond
                               ((and (focus-test? self dark) (nonzero? (-> self darkjak)))
                                (the-as object (target-darkjak-end-mode))
                                )
                               ((using-gun? self)
                                (target-gun-end-mode #t)
                                )
                               )
                             )
                            (('gun)
                             (cond
                               ((using-gun? self)
                                (send-event self 'gun-type (-> event param 2))
                                )
                               ((want-to-gun? self #t)
                                (if (logtest? (-> self game features) (game-feature gun))
                                    (the-as object (target-gun-init (the-as int (-> event param 2))))
                                    )
                                )
                               )
                             )
                            (('demo)
                             (go target-demo #f)
                             )
                            (('title)
                             (go target-title #f)
                             )
                            )
                          )
                         (('anim)
                          (let ((v0-0 (the-as object (-> event param 0))))
                            (set! (-> self control unknown-word04) (the-as uint v0-0))
                            v0-0
                            )
                          )
                         (else
                           (target-generic-event-handler proc arg1 event-type event)
                           )
                         )
                       )
                     )
            )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self state-flags) (state-flags sf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    (set! (-> self control unknown-word04) (the-as uint arg0))
    (logior! (-> self skel effect flags) (effect-control-flag ecf2))
    (none)
    )
  :exit (behavior ()
    (set! (-> self ambient-time) (current-time))
    (logclear! (-> self state-flags) (state-flags sf2))
    (target-exit)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (set-forward-vel 0.0)
    (let ((gp-0 0))
      (while (not (logtest? (-> self control status) (collide-status on-surface)))
        (target-falling-anim-trans)
        (+! gp-0 (- (current-time) (-> self clock old-frame-counter)))
        (suspend)
        )
      (if (or (> gp-0 0) (let ((v1-10 (ja-group)))
                           (and v1-10 (or (= v1-10 (-> self draw art-group data 23))
                                          (= v1-10 (-> self draw art-group data 27))
                                          (= v1-10 (-> self draw art-group data 30))
                                          )
                                )
                           )
              )
          (target-hit-ground-anim #f (are-still?))
          )
      )
    (-> self control unknown-spool-anim00)
    (until #f
      (let ((gp-2 (-> self control unknown-spool-anim00)))
        (case gp-2
          (('stance)
           (cond
             ((logtest? (water-flags swimming) (-> self water flags))
              (ja-channel-push! 1 (seconds 0.15))
              (until #f
                (ja :group! (-> self draw art-group data 96) :num! min)
                (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
                  (if (!= gp-2 (-> self control unknown-spool-anim00))
                      (goto cfg-82)
                      )
                  (suspend)
                  (if (= (-> self skel root-channel 0) (-> self skel channel))
                      (ja :num! (seek!))
                      )
                  )
                )
              #f
              )
             ((using-gun? self)
              (let* ((v1-49 (-> self gun gun-type))
                     (s5-2 (cond
                             ((= v1-49 (pickup-type eco-blue))
                              (-> self draw art-group data 255)
                              )
                             ((= v1-49 (pickup-type eco-yellow))
                              (-> self draw art-group data 254)
                              )
                             ((= v1-49 (pickup-type eco-dark))
                              (-> self draw art-group data 253)
                              )
                             (else
                               (-> self draw art-group data 244)
                               )
                             )
                           )
                     )
                (ja-channel-push! 1 (seconds 0.15))
                (until #f
                  (ja :group! s5-2 :num! min)
                  (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
                    (if (!= gp-2 (-> self control unknown-spool-anim00))
                        (goto cfg-82)
                        )
                    (suspend)
                    (if (= (-> self skel root-channel 0) (-> self skel channel))
                        (ja :num! (seek!))
                        )
                    )
                  )
                )
              #f
              )
             (else
               (target-stance-push 1)
               (until #f
                 (ja-no-eval :group! (-> self draw art-group data 5)
                             :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 5)) frames num-frames) -1)))
                             :frame-num 0.0
                             )
                 (until (ja-done? 0)
                   (if (!= gp-2 (-> self control unknown-spool-anim00))
                       (goto cfg-82)
                       )
                   (suspend)
                   (ja :num! (seek!))
                   )
                 )
               #f
               )
             )
           )
          (('shock-in)
           (ja-channel-push! 1 (seconds 0.2))
           (ja-no-eval :group! (-> self draw art-group data 73) :num! (seek! (ja-aframe 15.0 0)) :frame-num 0.0)
           (until (ja-done? 0)
             (if (!= gp-2 (-> self control unknown-spool-anim00))
                 (goto cfg-82)
                 )
             (suspend)
             (ja :num! (seek! (ja-aframe 15.0 0)))
             )
           (until #f
             (ja-no-eval :group! (-> self draw art-group data 73)
                         :num! (seek! (ja-aframe 26.0 0))
                         :frame-num (ja-aframe 16.0 0)
                         )
             (until (ja-done? 0)
               (if (!= gp-2 (-> self control unknown-spool-anim00))
                   (goto cfg-82)
                   )
               (suspend)
               (ja :num! (seek! (ja-aframe 26.0 0)))
               )
             )
           #f
           )
          (('shock-out)
           (ja-channel-push! 1 (seconds 0.2))
           (ja-no-eval :group! (-> self draw art-group data 73)
                       :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 73)) frames num-frames) -1)))
                       :frame-num (ja-aframe 17.0 0)
                       )
           (until (ja-done? 0)
             (if (!= gp-2 (-> self control unknown-spool-anim00))
                 (goto cfg-82)
                 )
             (suspend)
             (ja :num! (seek!))
             )
           (set! (-> self control unknown-word04) (the-as uint 'stance))
           )
          )
        )
      (label cfg-82)
      )
    #f
    (none)
    )
  :post (behavior ()
    (if (logtest? (-> self control status) (collide-status on-surface))
        (set! (-> self control transv quad) (the-as uint128 0))
        )
    (set! (-> self game kiosk-timeout) (the-as uint (-> *display* game-clock frame-counter)))
    (target-no-stick-post)
    (none)
    )
  )

(defstate target-pole-cycle (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (if (and (= event-type 'query) (= (-> event param 0) 'mode))
        (-> self state name)
        (target-standard-event-handler proc arg1 event-type event)
        )
    )
  :enter (behavior ((arg0 handle))
    (set! (-> self control anim-handle) arg0)
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *pole-mods*)
    (logior! (-> self focus-status) (focus-status pole))
    (target-collide-set! 'pole 0.0)
    (set! (-> self control unknown-vector37 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    (send-event *camera* 'ease-in)
    (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float #f))
    (set! (-> self control hand-to-edge-dist) 0.5)
    (none)
    )
  :exit (behavior ()
    (target-collide-set! 'normal 0.0)
    (logclear! (-> self focus-status) (focus-status pole))
    (set! (-> self control anim-handle) (the-as handle #f))
    (none)
    )
  :trans (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (not (logtest? (-> self state-flags) (state-flags prevent-jump)))
               (>= (- (current-time) (-> self state-time)) (seconds 0.4))
               )
      (set! (-> self control transv quad) (the-as uint128 0))
      (cond
        ((< 44.0 (ja-aframe-num 0))
         (set-forward-vel -49152.0)
         (let ((v1-19 (new-stack-vector0)))
           (let ((f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-19 (-> self control transv) (vector-float*! v1-19 (-> self control dynam gravity-normal) f0-2))
             )
           (let* ((f0-3 (vector-length v1-19))
                  (f1-1 f0-3)
                  (f2-0 -81920.0)
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
               (vector-float*! v1-19 v1-19 (/ f0-3 f1-1))
               )
             )
           )
         (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
         (go target-falling 'target-pole-cycle)
         )
        ((>= (ja-aframe-num 0) 14.0)
         (remove-exit)
         (go target-pole-flip-up #x46e00000 #x46e00000 (* 1024.0 (- 26.0 (ja-aframe-num 0))))
         )
        (else
          (remove-exit)
          (go target-pole-flip-forward 14336.0 14336.0 57344.0)
          )
        )
      )
    (none)
    )
  :code (behavior ((arg0 handle))
    (sound-play "edge-grab")
    (target-compute-pole)
    (set! (-> self control unknown-word04)
          (the-as
            uint
            (vector-dot (-> self control edge-grab-edge-dir) (vector-normalize! (-> self control unknown-vector37) 1.0))
            )
          )
    (let ((v1-8 (ja-group)))
      (cond
        ((and v1-8 (= v1-8 (-> self draw art-group data 107)))
         (while (not (-> self control did-move-to-pole-or-max-jump-height))
           (ja :num! (seek!))
           (suspend)
           )
         (ja :num-func num-func-identity :frame-num (ja-aframe 37.0 0))
         )
        (else
          (while (not (-> self control did-move-to-pole-or-max-jump-height))
            (suspend)
            )
          (suspend)
          (ja-channel-push! 1 (seconds 0.15))
          )
        )
      )
    (ja-no-eval :group! (-> self draw art-group data 104)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 104)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (until #f
      (set! (-> self anim-seed) (the-as uint (if (rand-vu-percent? 0.1)
                                                 0
                                                 1
                                                 )
                                        )
            )
      (ja-no-eval :group! (-> self draw art-group data 104)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 104)) frames num-frames) -1)))
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (can-play-stance-amibent?)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post target-no-move-post
  )

(defstate target-pole-flip-up (target)
  :event target-standard-event-handler
  :exit (-> target-pole-cycle exit)
  :code (behavior ((arg0 object) (arg1 object) (arg2 float))
    (let ((f0-2 (+ 1.0 (fmin 17.0 (ja-aframe-num 0)))))
      (ja-no-eval :group! (-> self draw art-group data 105)
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 105)) frames num-frames) -1)))
                  :frame-num (ja-aframe f0-2 0)
                  )
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (set-forward-vel arg2)
    (go target-pole-flip-up-jump (the-as float arg0) (the-as float arg1))
    (none)
    )
  :post target-no-move-post
  )

(defstate target-pole-flip-up-jump (target)
  :event target-standard-event-handler
  :enter (behavior ((arg0 float) (arg1 float))
    ((-> target-jump-forward enter) arg0 arg1)
    (set! (-> self control mod-surface) *forward-pole-jump-mods*)
    (none)
    )
  :exit target-exit
  :trans (behavior ()
    ((-> target-jump-forward trans))
    (vector-flatten! (-> self control transv) (-> self control transv) (-> self control edge-grab-edge-dir))
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float))
    (send-event *camera* 'damp-up)
    (ja :group! (-> self draw art-group data 107) :num! min)
    (let ((f0-1 (target-height-above-ground))
          (f1-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      (while (not (and (< (fabs (/ f0-1 (* 0.0033333334 f1-1))) 40.0) (and (< f1-1 0.0) (ja-min? 0))))
        (suspend)
        (ja :num! (loop!))
        (set! f0-1 (target-height-above-ground))
        (set! f1-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
        )
      )
    (ja-channel-push! 1 (seconds 0.25))
    (ja-no-eval :group! (-> self draw art-group data 27) :num! (loop!) :frame-num 0.0)
    (until #f
      (suspend)
      (ja :group! (-> self draw art-group data 27) :num! (loop!))
      )
    #f
    (none)
    )
  :post target-post
  )

(defstate target-pole-flip-forward (target)
  :event target-standard-event-handler
  :exit (-> target-pole-cycle exit)
  :code (behavior ((arg0 float) (arg1 float) (arg2 float))
    (let ((f30-1 (+ 4.0 (ja-aframe-num 0))))
      (ja-no-eval :group! (-> self draw art-group data 106)
                  :num! (seek! (ja-aframe 16.0 0))
                  :frame-num (ja-aframe f30-1 0)
                  )
      )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 16.0 0)))
      )
    (set-forward-vel arg2)
    (go target-pole-flip-forward-jump arg0 arg1)
    (none)
    )
  :post target-no-move-post
  )

(defstate target-pole-flip-forward-jump (target)
  :event target-standard-event-handler
  :enter (behavior ((arg0 float) (arg1 float))
    ((-> target-jump enter) arg0 arg1 (the-as surface #f))
    (set! (-> self control mod-surface) *forward-pole-jump-mods*)
    (none)
    )
  :exit target-exit
  :trans (behavior ()
    ((-> target-jump-forward trans))
    (vector-flatten! (-> self control transv) (-> self control transv) (-> self control edge-grab-edge-dir))
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float))
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    ((the-as (function none :behavior target) (-> target-pole-flip-up-jump code)))
    (none)
    )
  :post target-post
  )

(defstate target-edge-grab (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('end-mode)
       (go target-falling 'target-edge-grab)
       )
      (else
        (target-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> *edge-grab-info* pilot-edge-grab?) #f)
    (set! (-> self control unknown-handle000) (the-as handle #f))
    (set! (-> self control mod-surface) *edge-grab-mods*)
    (set! (-> self control edge-grab-start-time) (current-time))
    (logior! (-> self control root-prim prim-core action) (collide-action dont-push-away))
    (logior! (-> self focus-status) (focus-status edge-grab))
    (set! (-> self control unknown-vector37 quad) (-> self control transv quad))
    (set! (-> self control transv quad) (the-as uint128 0))
    (send-event *camera* 'ease-in)
    (if (!= (-> self skel top-anim interp) 0.0)
        (set! (-> self skel top-anim interp) 0.000000000000000000000000000000001)
        )
    (none)
    )
  :exit (behavior ()
    (let ((v1-2 (handle->process (-> self control unknown-handle000))))
      (when v1-2
        (if (not (-> self control unknown-symbol000))
            (logclear!
              (-> (the-as collide-shape-moving (-> (the-as process-drawable v1-2) root)) root-prim prim-core action)
              (collide-action edge-grabbed)
              )
            )
        )
      )
    (set! (-> self control unknown-handle000) (the-as handle #f))
    (when (focus-test? self edge-grab)
      (logclear! (-> self focus-status) (focus-status edge-grab))
      (logclear! (-> self control root-prim prim-core action) (collide-action dont-push-away))
      (send-event *camera* 'damp-up)
      )
    (if (!= (-> self skel top-anim interp) 0.0)
        (set! (-> self skel top-anim interp) 1.0)
        )
    (set! (-> self control draw-offset y) 0.0)
    (none)
    )
  :trans (behavior ()
    (when (and (>= (- (current-time) (-> self state-time)) (seconds 0.2))
               (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (not (logtest? (-> self state-flags) (state-flags prevent-jump)))
               )
      (cond
        ((or (< -0.2 (local-pad-angle)) (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0))
         (let ((a1-2 (new 'stack-no-clear 'collide-query)))
           (let ((v1-25 a1-2))
             (set! (-> v1-25 best-dist) (the-as float (-> *collide-edge-work* world-player-leap-up-spheres)))
             (set! (-> v1-25 num-spheres) (the-as uint 6))
             (set! (-> v1-25 collide-with) (-> self control root-prim prim-core collide-with))
             (set! (-> v1-25 ignore-process0) #f)
             (set! (-> v1-25 ignore-process1) #f)
             (set! (-> v1-25 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
             (set! (-> v1-25 best-my-prim) (the-as collide-shape-prim #t))
             (set! (-> v1-25 action-mask) (collide-action solid))
             )
           (when (not (fill-and-probe-using-spheres *collide-cache* a1-2))
             (if (!= (-> self skel top-anim interp) 0.0)
                 (set! (-> self skel top-anim interp) 1.0)
                 )
             (remove-exit)
             (go
               target-edge-grab-jump
               (-> *TARGET-bank* edge-grab-jump-height-min)
               (-> *TARGET-bank* edge-grab-jump-height-max)
               )
             )
           )
         )
        (else
          (when (!= (-> self skel top-anim interp) 0.0)
            (set! (-> self skel top-anim interp) 1.0)
            (let* ((v1-47 (-> self skel float-channels))
                   (v1-52 (cond
                            ((= v1-47 1)
                             (-> self skel channel (-> self skel active-channels))
                             )
                            ((= v1-47 2)
                             (-> self skel channel (+ (-> self skel active-channels) 1))
                             )
                            (else
                              (the-as joint-control-channel #f)
                              )
                            )
                          )
                   )
              (if v1-52
                  (set! (-> v1-52 frame-interp 1) 1.0)
                  )
              )
            )
          (remove-exit)
          (go target-edge-grab-off)
          )
        )
      )
    (if (using-gun? self)
        (seek! (-> self control draw-offset y) 778.24 (* 4096.0 (-> self clock seconds-per-frame)))
        )
    (none)
    )
  :code (behavior ()
    (target-compute-edge)
    (let ((gp-0 *edge-grab-info*))
      (set! (-> self control unknown-handle000) (-> gp-0 actor-handle))
      (set! (-> self control unknown-symbol000) #f)
      (let ((v1-4 (handle->process (-> self control unknown-handle000))))
        (if v1-4
            (logior!
              (-> (the-as collide-shape-moving (-> (the-as process-drawable v1-4) root)) root-prim prim-core action)
              (collide-action edge-grabbed)
              )
            )
        )
      (set! (-> self control unknown-word04)
            (the-as
              uint
              (vector-dot (-> self control edge-grab-edge-dir) (vector-normalize! (-> self control unknown-vector37) 1.0))
              )
            )
      (cond
        ((= (-> gp-0 pilot-edge-grab?) 'target-double-jump)
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! (-> self draw art-group data 23) :num! (seek! (ja-aframe 14.0 0) 0.75) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe 14.0 0) 0.75))
           )
         (sound-play "jump-double")
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! (-> self draw art-group data 23)
                     :num! (seek! (ja-aframe 14.0 0))
                     :frame-num (ja-aframe 5.0 0)
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe 14.0 0)))
           )
         )
        ((-> gp-0 pilot-edge-grab?)
         (ja-channel-push! 1 (seconds 0.05))
         (ja-no-eval :group! (-> self draw art-group data 23) :num! (seek! (ja-aframe 14.0 0)) :frame-num 0.0)
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! (ja-aframe 14.0 0)))
           )
         )
        (else
          (while (< 0.0 (-> self control hand-to-edge-dist))
            (let ((v1-60 (ja-group)))
              (when (not (and v1-60 (= v1-60 (-> self draw art-group data 27))))
                (ja-channel-push! 1 (seconds 0.15))
                (ja :group! (-> self draw art-group data 27) :num! min)
                )
              )
            (suspend)
            )
          )
        )
      )
    (target-edge-grab-anim (the-as float (-> self control unknown-word04)))
    (none)
    )
  :post target-no-move-post
  )

(defstate target-edge-grab-jump (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('end-mode)
       (go target-falling 'target-edge-grab)
       )
      (else
        (target-standard-event-handler proc arg1 event-type event)
        )
      )
    )
  :exit (-> target-edge-grab exit)
  :code (behavior ((arg0 float) (arg1 float))
    (when (-> *edge-grab-info* pilot-edge-grab?)
      (set! arg0 (+ 8192.0 arg0))
      (set! arg1 (+ 8192.0 arg1))
      )
    (ja-channel-set! 1)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (logclear! (-> self focus-status) (focus-status edge-grab))
    (logclear! (-> self control root-prim prim-core action) (collide-action dont-push-away))
    (set! (-> self control transv quad) (the-as uint128 0))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (let ((a1-3
              (cond
                ((using-gun? self)
                 (push-anim-to-targ
                   (-> self skel top-anim)
                   (the-as art-joint-anim (-> self draw art-group data 281))
                   0.0
                   0
                   30
                   1.0
                   0.0
                   #f
                   )
                 (-> self draw art-group data 281)
                 )
                (else
                  (-> self draw art-group data 38)
                  )
                )
              )
            )
        (ja-no-eval :group! a1-3
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim a1-3) frames num-frames) -1)))
                    :frame-num 0.0
                    )
        )
      (until (ja-done? 0)
        (target-compute-edge-rider)
        (compute-alignment! (-> self align))
        (when (not (logtest? (-> self align flags) (align-flags disabled)))
          (vector-matrix*! s4-0 (the-as vector (-> self align delta)) (-> self control c-R-w))
          (move-by-vector! (-> self control) s4-0)
          )
        (suspend)
        (ja :num! (seek!))
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (set! (-> self control time-of-last-clear-wall-in-jump) 0)
    (set-forward-vel 16384.0)
    (set! (-> self gun surpress-time) (+ (current-time) (seconds 0.2)))
    (send-event *camera* 'damp-up)
    (go target-jump-forward arg0 arg1)
    (none)
    )
  :post target-no-move-post
  )

(defstate target-edge-grab-off (target)
  :event target-standard-event-handler
  :exit (-> target-edge-grab exit)
  :code (behavior ()
    (ja-channel-set! 1)
    (set-quaternion! (-> self control) (-> self control dir-targ))
    (send-event *camera* 'damp-up)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (if (using-gun? self)
          (push-anim-to-targ
            (-> self skel top-anim)
            (the-as art-joint-anim (-> self draw art-group data 280))
            0.0
            0
            30
            1.0
            0.0
            #f
            )
          )
      (ja-no-eval :group! (-> self draw art-group data 39) :num! (seek! (ja-aframe 191.0 0)) :frame-num 0.0)
      (until (ja-done? 0)
        (compute-alignment! (-> self align))
        (when (not (logtest? (-> self align flags) (align-flags disabled)))
          (vector-matrix*! gp-0 (the-as vector (-> self align delta)) (-> self control c-R-w))
          (move-by-vector! (-> self control) gp-0)
          )
        (suspend)
        (ja :num! (seek! (ja-aframe 191.0 0)))
        )
      )
    (set! (-> self control transv quad) (the-as uint128 0))
    (logclear! (-> self focus-status) (focus-status edge-grab))
    (logclear! (-> self control root-prim prim-core action) (collide-action dont-push-away))
    (set! (-> self gun surpress-time) (+ (current-time) (seconds 0.2)))
    (vector-float*! (-> self control transv) (-> self control edge-grab-across-edge-dir) -40960.0)
    (if (< (- (current-time) (-> self control rider-time)) (seconds 0.2))
        (send-event self 'push-transv (-> self control rider-last-move) #x7530)
        )
    (go target-falling 'target-edge-grab)
    (none)
    )
  :post target-no-move-post
  )

(let ((a0-79 (copy *walk-mods* 'global)))
  (set! (-> a0-79 flags) (surface-flag gun-off gun-fast-exit))
  (set! *hit-ground-hard-mods* a0-79)
  )

(defstate target-hit-ground-hard (target)
  :event target-standard-event-handler
  :enter (behavior ((arg0 float))
    (set! (-> self control last-running-attack-end-time) 0)
    (set! (-> self control last-attack-end-time) 0)
    (set-forward-vel 0.0)
    (set! (-> self control mod-surface) *hit-ground-hard-mods*)
    (logior! (-> self focus-status) (focus-status hit))
    (none)
    )
  :exit (behavior ()
    (if (not (and (-> self next-state) (= (-> self next-state name) 'target-death)))
        (logclear! (-> self focus-status) (focus-status dead hit))
        )
    (target-exit)
    (none)
    )
  :code (behavior ((arg0 float))
    (when (!= arg0 0.0)
      (let ((f0-5 (the float (the int (+ 1.0 (/ (- arg0 (-> *TARGET-bank* fall-far)) (-> *TARGET-bank* fall-far-inc))))))
            )
        (pickup-collectable!
          (-> self fact-override)
          (pickup-type health)
          (* (-> *FACT-bank* health-single-inc) (- (fmax 0.0 f0-5)))
          (the-as handle #f)
          )
        )
      (target-timed-invulnerable (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)) self 1)
      )
    (cond
      ((and (= (-> self game mode) 'play) (>= 0.0 (-> (the-as fact-info-target (-> self fact-override)) health)))
       (set! (-> self attack-info attacker) (the-as handle #f))
       (go target-death 'target-hit-ground-hard)
       )
      (else
        (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.1))
        (ja-channel-push! 1 1)
        (ja :group! (-> self draw art-group data 25) :num! min)
        (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
          (suspend)
          (if (= (-> self skel root-channel 0) (-> self skel channel))
              (ja :num! (seek!))
              )
          )
        (ja :group! (-> self draw art-group data 26) :num! min)
        (until (and (ja-done? 0) (= (-> self skel root-channel 0) (-> self skel channel)))
          (suspend)
          (if (= (-> self skel root-channel 0) (-> self skel channel))
              (ja :num! (seek!))
              )
          )
        (go target-stance)
        )
      )
    (none)
    )
  :post target-no-stick-post
  )

(define *hide-mods* (new 'static 'surface
                      :name 'run
                      :turnv 262144.0
                      :tiltv 65536.0
                      :tiltvv 262144.0
                      :transv-max 40960.0
                      :seek0 0.5
                      :seek90 0.5
                      :seek180 0.5
                      :fric 1.0
                      :nonlin-fric-dist 1.0
                      :slip-factor 1.0
                      :slide-factor 1.0
                      :slope-up-factor 1.0
                      :slope-down-factor 1.0
                      :slope-slip-angle 1.0
                      :impact-fric 1.0
                      :bend-factor 1.0
                      :bend-speed 1.0
                      :alignv 1.0
                      :slope-up-traction 1.0
                      :align-speed 1.0
                      :turnvf 15.0
                      :tiltvf 150.0
                      :tiltvvf 15.0
                      :flags (surface-flag look-around gun-off)
                      )
        )

(defstate target-hide (target)
  :event target-standard-event-handler
  :enter (behavior ()
    (set! (-> self control mod-surface) *hide-mods*)
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control wall-contact-normal)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control quat))
      )
    (set! (-> self state-time) (current-time))
    (none)
    )
  :exit (behavior ()
    (if (using-gun? self)
        (target-top-anim-base-mode 37)
        )
    (logclear! (-> self state-flags) (state-flags lleg-still rleg-still))
    (set! (-> self control bend-target) 0.0)
    (none)
    )
  :trans (behavior ()
    (if (and (logtest? (water-flags wading) (-> self water flags)) (not (using-gun? self)))
        (go target-wade-stance)
        )
    (if (= (-> self control ground-pat material) (pat-material ice))
        (go target-ice-stance)
        )
    (if (and (move-legs?)
             (and (>= (- (current-time) (-> self state-time)) (seconds 1))
                  (let ((f0-1 (vector-dot (-> self control to-target-pt-xz) (-> self control wall-contact-normal))))
                    (< 0.1 f0-1)
                    )
                  )
             )
        (go target-walk)
        )
    (if (want-to-darkjak?)
        (go target-darkjak-get-on 2)
        )
    (if (and (cpad-hold? (-> self control cpad number) l1) (can-duck?))
        (go target-duck-stance #f)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons x)
                       )
             (can-jump? #f)
             )
        (target-jump-go)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons circle)
                       )
             (can-feet? #t)
             )
        (go target-attack)
        )
    (if (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons square)
                       )
             (can-hands? #t)
             )
        (go target-running-attack)
        )
    (if (and (using-gun? self)
             (and (-> self next-state) (= (-> self next-state name) 'target-stance))
             (let ((v1-85 (ja-group)))
               (and v1-85 (= v1-85 (-> self draw art-group data 5)))
               )
             )
        (go target-gun-stance)
        )
    (if (and (logtest? (-> self game features) (game-feature carry))
             (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                       (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                       )
                               (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                               )
                       (pad-buttons r1)
                       )
             )
        (go target-carry-pickup)
        )
    (slide-down-test)
    (fall-test target-falling -4096000.0)
    (set-forward-vel (* 0.7 (-> self control ctrl-xz-vel)))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data 81)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 81)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 2 (seconds 0.05))
    (let ((a0-5 (-> self skel root-channel 1)))
      (let ((f0-7 0.2))
        (set! (-> a0-5 frame-interp 1) f0-7)
        (set! (-> a0-5 frame-interp 0) f0-7)
        )
      (set! (-> a0-5 frame-group) (the-as art-joint-anim (-> self draw art-group data 88)))
      (set! (-> a0-5 param 0) 1.0)
      (joint-control-channel-group-eval!
        a0-5
        (the-as art-joint-anim (-> self draw art-group data 88))
        num-func-loop!
        )
      )
    (set! (-> self control unknown-word04) (the-as uint 0.5))
    (set! (-> self control did-move-to-pole-or-max-jump-height) 0.5)
    (set! (-> self control unknown-float35) (the-as float #f))
    (let ((gp-0
            (lambda :behavior target
              ()
              (ja :chan 1 :num! (loop! (the-as float (-> self control unknown-word04))))
              (if (rand-vu-percent? 0.05)
                  (set! (-> self control did-move-to-pole-or-max-jump-height) (rand-vu-float-range 0.5 1.5))
                  )
              (set! (-> self control unknown-word04) (the-as uint (seek
                                                                    (the-as float (-> self control unknown-word04))
                                                                    (-> self control did-move-to-pole-or-max-jump-height)
                                                                    (* 2.0 (-> self clock seconds-per-frame))
                                                                    )
                                                             )
                    )
              (set! (-> self control unknown-float35) (the-as float (> (-> self neck loock-at-count) 0)))
              (none)
              )
            )
          )
      (until #f
        (let ((s5-0 (rand-vu-int-range 30 600)))
          (ja :group! (-> self draw art-group data 85))
          (let ((s4-0 (current-time)))
            (until (>= (- (current-time) s4-0) s5-0)
              (gp-0)
              (suspend)
              )
            )
          )
        (let ((f30-0 (rand-vu-float-range 0.5 1.5)))
          (cond
            ((or (cpad-hold? 1 r3) (-> self control unknown-float35))
             (let ((f30-1 (rand-vu-float-range 0.25 0.75)))
               (ja-no-eval :group! (-> self draw art-group data 82)
                           :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 82)) frames num-frames) -1)))
                           :frame-num 0.0
                           )
               (until (ja-done? 0)
                 (gp-0)
                 (suspend)
                 (ja :num! (seek!))
                 )
               (let ((s5-1 (rand-vu-int-range 1 10)))
                 (dotimes (s4-1 s5-1)
                   (ja-no-eval :group! (-> self draw art-group data 83)
                               :num! (seek!
                                 (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 83)) frames num-frames) -1))
                                 f30-1
                                 )
                               :frame-num 0.0
                               )
                   (until (ja-done? 0)
                     (gp-0)
                     (suspend)
                     (ja :num! (seek! max f30-1))
                     )
                   )
                 )
               )
             (ja-no-eval :group! (-> self draw art-group data 84)
                         :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 84)) frames num-frames) -1)))
                         :frame-num 0.0
                         )
             (until (ja-done? 0)
               (gp-0)
               (suspend)
               (ja :num! (seek!))
               )
             )
            ((rand-vu-percent? 0.5)
             (ja-no-eval :group! (-> self draw art-group data 86)
                         :num! (seek!
                           (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 86)) frames num-frames) -1))
                           f30-0
                           )
                         :frame-num 0.0
                         )
             (until (ja-done? 0)
               (gp-0)
               (suspend)
               (ja :num! (seek! max f30-0))
               )
             (let ((s5-2 (rand-vu-int-range 60 300))
                   (s4-2 (current-time))
                   )
               (until (>= (- (current-time) s4-2) s5-2)
                 (gp-0)
                 (suspend)
                 )
               )
             (ja-no-eval :group! (-> self draw art-group data 86)
                         :num! (seek! 0.0 f30-0)
                         :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 86)) frames num-frames) -1))
                         )
             (until (ja-done? 0)
               (gp-0)
               (suspend)
               (ja :num! (seek! 0.0 f30-0))
               )
             )
            (else
              (ja-no-eval :group! (-> self draw art-group data 87)
                          :num! (seek! 0.0 f30-0)
                          :frame-num (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 87)) frames num-frames) -1))
                          )
              (until (ja-done? 0)
                (gp-0)
                (suspend)
                (ja :num! (seek! 0.0 f30-0))
                )
              (let ((s5-3 (rand-vu-int-range 60 300))
                    (s4-3 (current-time))
                    )
                (until (>= (- (current-time) s4-3) s5-3)
                  (gp-0)
                  (suspend)
                  )
                )
              (ja-no-eval :group! (-> self draw art-group data 87)
                          :num! (seek!
                            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 87)) frames num-frames) -1))
                            f30-0
                            )
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (gp-0)
                (suspend)
                (ja :num! (seek! max f30-0))
                )
              )
            )
          )
        )
      )
    #f
    (none)
    )
  :post target-post
  )

(defstate target-launch (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (if (and (= event-type 'query) (= (-> event param 0) 'mode))
        'target-launch
        (target-standard-event-handler proc arg1 event-type event)
        )
    )
  :code (behavior ((arg0 float) (arg1 symbol) (arg2 vector) (arg3 int))
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *turn-around-mods*)
    (ja-channel-push! 1 (seconds 0.15))
    (set-forward-vel 0.0)
    (ja-no-eval :group! (-> self draw art-group data 20) :num! (seek! (ja-aframe 15.0 0) 3.0) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 15.0 0) 3.0))
      )
    (if arg1
        (send-event *camera* 'change-state arg1 (seconds 0.6))
        )
    (if (nonzero? arg3)
        (process-spawn-function
          process
          (lambda :behavior target
            ((arg0 vector) (arg1 time-frame) (arg2 float))
            (local-vars (sv-32 time-frame) (sv-40 vector) (sv-44 symbol))
            (set! sv-32 (current-time))
            (let ((v1-2 (new-stack-vector0)))
              (set! (-> v1-2 quad) (-> arg0 quad))
              (set! sv-40 v1-2)
              )
            (set! sv-44 #t)
            (until (>= (- (current-time) sv-32) arg1)
              (let ((s4-0 (ppointer->process (-> self parent))))
                (cond
                  ((and sv-44
                        (< (- (-> (the-as target s4-0) control trans y) (-> (the-as target s4-0) control last-trans-any-surf y)) arg2)
                        )
                   (vector-xz-normalize! (-> (the-as target s4-0) control transv) 0.0)
                   (when (< (vector-vector-xz-distance (-> (the-as target s4-0) control trans) sv-40) 20480.0)
                     (let ((v1-15 (vector-! (new-stack-vector0) (-> (the-as target s4-0) control trans) sv-40)))
                       (set! (-> (the-as target s4-0) control trans x) (+ (-> sv-40 x) (fmax -2867.2 (fmin 2867.2 (-> v1-15 x)))))
                       (set! (-> (the-as target s4-0) control trans z) (+ (-> sv-40 z) (fmax -2867.2 (fmin 2867.2 (-> v1-15 z)))))
                       )
                     )
                   )
                  (else
                    (if sv-44
                        (set! sv-32 (current-time))
                        )
                    (set! sv-44 (the-as symbol #f))
                    (when (and (-> (the-as target s4-0) next-state)
                               (let ((v1-25 (-> (the-as target s4-0) next-state name)))
                                 (or (= v1-25 'target-duck-high-jump-jump) (= v1-25 'target-falling))
                                 )
                               )
                      (let ((v1-28 (-> (the-as target s4-0) control trans))
                            (s3-0 (-> (the-as target s4-0) control transv))
                            )
                        (set! (-> s3-0 x) (- (-> sv-40 x) (-> v1-28 x)))
                        (set! (-> s3-0 z) (- (-> sv-40 z) (-> v1-28 z)))
                        (let* ((v1-29 s3-0)
                               (f30-0 (sqrtf (+ (* (-> v1-29 x) (-> v1-29 x)) (* (-> v1-29 z) (-> v1-29 z)))))
                               )
                          (if (< 122880.0 f30-0)
                              (vector-xz-normalize! s3-0 122880.0)
                              )
                          (if (< 4096.0 f30-0)
                              (forward-up-nopitch->quaternion
                                (-> (the-as target s4-0) control dir-targ)
                                (vector-normalize-copy! (new 'stack-no-clear 'vector) s3-0 1.0)
                                (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> (the-as target s4-0) control quat))
                                )
                              )
                          )
                        )
                      )
                    )
                  )
                )
              (suspend)
              0
              )
            (none)
            )
          arg2
          arg3
          #x480c0000
          :to self
          )
        )
    (go target-high-jump arg0 arg0 'launch)
    (none)
    )
  :post target-no-stick-post
  )

(defstate target-play-anim (target)
  :event target-generic-event-handler
  :enter (behavior ((arg0 string) (arg1 handle))
    (set! (-> self control anim-handle) arg1)
    (move-to-ground (-> self control) 40960.0 40960.0 #f (-> self control root-prim prim-core collide-with))
    (logior! (-> self focus-status) (focus-status grabbed))
    (set! (-> self neck flex-blend) 0.0)
    (none)
    )
  :exit (behavior ()
    (send-event (handle->process (-> self control anim-handle)) 'end-mode)
    (target-exit)
    (none)
    )
  :code (behavior ((arg0 string) (arg1 handle))
    (let ((gp-0 (get-art-by-name (-> self draw art-group) arg0 art-joint-anim)))
      (when gp-0
        (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
        (ja-channel-set! 1)
        (ja-no-eval :group! gp-0 :num! (seek! (the float (+ (-> gp-0 frames num-frames) -1))) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek!))
          )
        (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
        )
      )
    (go target-stance)
    (none)
    )
  :post target-no-stick-post
  )

(defstate target-clone-anim (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (if (and (= event-type 'trans) (= (-> event param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-grab event) proc arg1 event-type event)
    )
  :enter (behavior ((arg0 handle))
    (set! (-> self control anim-handle) arg0)
    (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
    (set! (-> self control unknown-word04) (the-as uint #t))
    (quaternion-copy! (the-as quaternion (-> self control unknown-vector38)) (-> self control quat))
    (logior! (-> self focus-status) (focus-status grabbed))
    (vector-reset! (-> self control transv))
    (set! (-> self neck flex-blend) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
    (none)
    )
  :exit (behavior ()
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
    (send-event (ppointer->process (-> self sidekick)) 'shadow #t)
    (let ((gp-0 (-> self node-list data 3))
          (a1-2 (-> self control camera-pos))
          )
      (cond
        ((not (-> self control unknown-spool-anim00))
         )
        ((not (logtest? (-> self draw status) (draw-control-status no-draw)))
         (move-to-point! (-> self control) a1-2)
         (matrix->quaternion (-> self control quat-for-control) (-> gp-0 bone transform))
         (quaternion-copy! (-> self control quat) (-> self control quat-for-control))
         (move-to-ground (-> self control) 4096.0 40960.0 #t (-> self control root-prim prim-core collide-with))
         (when (logtest? (-> self control status) (collide-status on-water))
           (let ((a1-6 (new-stack-vector0)))
             (set! (-> a1-6 x) (-> self control trans x))
             (set! (-> a1-6 y) (-> self water height))
             (set! (-> a1-6 z) (-> self control trans z))
             (set! (-> a1-6 w) 1.0)
             (move-to-point! (-> self control) a1-6)
             )
           )
         )
        (else
          (format 0 "ERROR: <ASG>: camera used backup position~%")
          (move-to-point! (-> self control) (-> self control unknown-vector37))
          (quaternion-copy! (-> self control quat) (the-as quaternion (-> self control unknown-vector38)))
          )
        )
      )
    (rot->dir-targ! (-> self control))
    (logior! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control last-time-on-surface) (current-time))
    (ja-channel-set! 0)
    (ja-post)
    (target-exit)
    (none)
    )
  :code (behavior ((arg0 handle))
    (clone-anim arg0 #t "")
    (go target-stance)
    (none)
    )
  :post target-no-ja-move-post
  )

(let ((v1-26 (copy *walk-mods* 'global)))
  (set! (-> v1-26 name) 'float)
  (set! (-> v1-26 target-speed) 81920.0)
  (set! (-> v1-26 transv-max) 81920.0)
  (set! (-> v1-26 flags) (surface-flag gun-off))
  (set! *float-mods* v1-26)
  )

(defstate target-float (target)
  :event target-generic-event-handler
  :enter (behavior ()
    (sound-play-by-spec (static-sound-spec "menu-pick" :fo-curve 1) (new-sound-id) (the-as vector #t))
    (set! (-> self control additional-decaying-velocity-end-time) 0)
    (vector-reset! (-> self control additional-decaying-velocity))
    (let ((v1-3 (new-stack-vector0)))
      (let ((f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-3 (-> self control transv) (vector-float*! v1-3 (-> self control dynam gravity-normal) f0-1))
        )
      (let* ((f0-2 (vector-length v1-3))
             (f1-1 f0-2)
             (f2-0 0.0)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-0)
          (vector-float*! v1-3 v1-3 (/ f0-2 f1-1))
          )
        )
      )
    (set! (-> self control dynam gravity-max) 0.0)
    (set! (-> self control dynam gravity-length) 0.0)
    (set! (-> self control mod-surface) *float-mods*)
    (target-darkjak-end-mode)
    (none)
    )
  :exit (behavior ()
    (sound-play-by-spec (static-sound-spec "menu-back" :fo-curve 1) (new-sound-id) (the-as vector #t))
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (target-exit)
    (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-abs 0) (pad-buttons l2 r2 l1 r1 x))
    (logclear! (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0) (pad-buttons l2 r2 l1 r1 x))
    (when (nonzero? (-> self gun))
      (set! (-> self gun using-gun-type) (pickup-type none))
      (set! (-> self gun latch?) #f)
      )
    (if (nonzero? (-> self board))
        (set! (-> self board latch?) #f)
        )
    (none)
    )
  :trans (behavior ()
    (set! (-> self control time-of-last-debug-float) (current-time))
    (cond
      ((and (cpad-hold? (-> self control cpad number) r2)
            (not *pause-lock*)) ;; no debug hover when paused.
       (let ((a1-0 (new 'stack-no-clear 'vector)))
         (set! (-> a1-0 quad) (-> self control trans quad))
         (let ((v1-14 (new-stack-vector0))
               (f0-1 (vector-dot (-> self control dynam gravity-normal) a1-0))
               )
           0.0
           (vector-! v1-14 a1-0 (vector-float*! v1-14 (-> self control dynam gravity-normal) f0-1))
           (let* ((f1-2 (vector-length v1-14))
                  (f2-0 f1-2)
                  (f0-2 (+ 512.0 f0-1))
                  )
             (vector+!
               a1-0
               (vector-float*! a1-0 (-> self control dynam gravity-normal) f0-2)
               (vector-float*! v1-14 v1-14 (/ f1-2 f2-0))
               )
             )
           )
         (move-to-point! (-> self control) a1-0)
         )
       )
      ((cpad-hold? (-> self control cpad number) l2)
       (let ((a1-1 (new 'stack-no-clear 'vector)))
         (set! (-> a1-1 quad) (-> self control trans quad))
         (let ((v1-29 (new-stack-vector0))
               (f0-5 (vector-dot (-> self control dynam gravity-normal) a1-1))
               )
           0.0
           (vector-! v1-29 a1-1 (vector-float*! v1-29 (-> self control dynam gravity-normal) f0-5))
           (let* ((f1-5 (vector-length v1-29))
                  (f2-1 f1-5)
                  (f0-6 (+ -512.0 f0-5))
                  )
             (vector+!
               a1-1
               (vector-float*! a1-1 (-> self control dynam gravity-normal) f0-6)
               (vector-float*! v1-29 v1-29 (/ f1-5 f2-1))
               )
             )
           )
         (move-to-point! (-> self control) a1-1)
         )
       )
      ((cpad-pressed? (-> self control cpad number) l1 x)
       (go (the-as (state target) target-falling))
       )
      )
    (let ((v1-43 (new-stack-vector0)))
      (let ((f0-9 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
        0.0
        (vector-! v1-43 (-> self control transv) (vector-float*! v1-43 (-> self control dynam gravity-normal) f0-9))
        )
      (let* ((f0-10 (vector-length v1-43))
             (f1-7 f0-10)
             (f2-2 0.0)
             )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
          (vector-float*! v1-43 v1-43 (/ f0-10 f1-7))
          )
        )
      )
    (none)
    )
  :code target-stance-anim
  :post target-post
  )
