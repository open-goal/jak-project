;;-*-Lisp-*-
(in-package goal)

;; name: board-states.gc
;; name in dgo: board-states
;; dgos: ENGINE, GAME

(define-extern target-time-to-ground (function time-frame :behavior target))
(define-extern jump-hit-ground-stuck? (function symbol :behavior target))
(define-extern target-board-start (state object target))
(define-extern target-board-handler (function process int symbol event-message-block object :behavior target))
(define-extern ground-tween-initialize (function ground-tween-info uint uint uint uint uint uint float ground-tween-info :behavior target))
(define-extern ground-tween-update (function ground-tween-info float float float none :behavior target))
(define-extern can-play-stance-amibent? (function symbol :behavior target))
(define-extern ja-blend-eval (function int :behavior process-drawable))
(define-extern spawn-projectile (function type projectile-init-by-other-params process-tree dead-pool (pointer process)))
(define-extern target-attacked (function symbol attack-info process touching-shapes-entry (state symbol attack-info target) object :behavior target))
(define-extern target-clone-anim (state handle target))
(define-extern clone-anim (function handle symbol string none :behavior process-drawable))
(define-extern lightning-probe-callback (function lightning-tracker none))
(define-extern target-death (state symbol target))
(define-extern target-hit-effect (function attack-info none :behavior target))
(define-extern hide-hud-quick (function symbol none))
(define-extern *smack-mods* surface)
(define-extern target-hit-orient (function attack-info vector symbol :behavior target))
(define-extern target-hit-move (function attack-info symbol (function none :behavior target) float none :behavior target))

(declare-type grenade projectile)

;; DECOMP BEGINS

(defun vector-vector-angle ((arg0 vector) (arg1 vector))
  (let ((s4-0 (new 'stack-no-clear 'matrix))
        (gp-0 (new 'stack-no-clear 'matrix))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (forward-up-nopitch->inv-matrix gp-0 (new 'static 'vector :z 1.0 :w 1.0) arg1)
    (matrix-transpose! s4-0 gp-0)
    (vector-matrix*! s3-0 arg0 s4-0)
    (vector-y-angle s3-0)
    )
  )

;; WARN: Return type mismatch float vs none.
(defbehavior target-board-anim-trans target ()
  (let ((f26-0
          (deg-
            (quaternion-vector-y-angle (-> self control dir-targ) (-> self control local-normal))
            (quaternion-vector-y-angle (-> self control quat-for-control) (-> self control local-normal))
            )
          )
        (f28-0
          (* (deg-
               (quaternion-vector-y-angle (-> self control quat-for-control) (-> self control local-normal))
               (quaternion-vector-y-angle (-> self control last-quat-for-control) (-> self control local-normal))
               )
             (-> self clock frames-per-second)
             )
          )
        (f30-0 (-> self board turn-anim-targ))
        )
    (let ((f0-1 (lerp-scale 1.0 -1.0 f28-0 -32768.0 32768.0)))
      (if (or (< (fabs f0-1) 0.1) (< (-> self control turn-to-magnitude) 0.3))
          (seek! (-> self board turn-anim-mag) 0.0 (* 8.0 (-> self clock seconds-per-frame)))
          (seek! (-> self board turn-anim-mag) f0-1 (* 2.0 (-> self clock seconds-per-frame)))
          )
      )
    (set! (-> self board turn-anim-targ) (+ (lerp-scale
                                              (* 0.5 (-> *TARGET_BOARD-bank* turn-frames))
                                              (* -0.5 (-> *TARGET_BOARD-bank* turn-frames))
                                              f26-0
                                              -5461.3335
                                              5461.3335
                                              )
                                            (lerp-scale
                                              (* 0.3 (-> *TARGET_BOARD-bank* turn-frames))
                                              (* -0.3 (-> *TARGET_BOARD-bank* turn-frames))
                                              f28-0
                                              -32768.0
                                              32768.0
                                              )
                                            (lerp-scale
                                              (* 0.2 (-> *TARGET_BOARD-bank* turn-frames))
                                              (* -0.2 (-> *TARGET_BOARD-bank* turn-frames))
                                              (-> self board turn-anim-mag)
                                              1.0
                                              -1.0
                                              )
                                            )
          )
    (when (and (or (< (* f30-0 (-> self board turn-anim-targ)) 0.0) (= f30-0 0.0))
               (and (< (* 0.2 (-> *TARGET_BOARD-bank* turn-frames)) (fabs (- f30-0 (-> self board turn-anim-targ))))
                    (>= (current-time) (-> self control turn-lockout-end-time))
                    )
               )
      (let ((v1-50 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
        (set! (-> v1-50 command) (sound-command set-param))
        (set! (-> v1-50 id) (-> self board unknown-sound-id00))
        (set! (-> v1-50 params volume) -4)
        (set! (-> v1-50 auto-time) 120)
        (set! (-> v1-50 auto-from) 2)
        (set! (-> v1-50 params mask) (the-as uint 17))
        (-> v1-50 id)
        )
      (set! (-> self board unknown-sound-id00) (sound-play "board-turn"))
      )
    )
  (set! (-> self board turn-anim-duck-vel) (* 0.98 (-> self board turn-anim-duck-vel)))
  (+! (-> self board turn-anim-duck-vel) (* -8.0 (-> self clock seconds-per-frame)))
  (when (and (board-on-ground?) (>= (- (current-time) (-> self board unknown-time-frame02)) (seconds 0.2)))
    (if (logtest? (-> self control status) (collide-status impact-surface))
        (+! (-> self board turn-anim-duck-vel) (lerp-scale 0.0 15.0 (-> self control normal-impact-vel) 0.0 81920.0))
        )
    (let ((f0-38 (vector-dot (the-as vector (-> self board up-vector)) (-> self board up-vector 1))))
      (if (< f0-38 1.0)
          (+! (-> self board turn-anim-duck-vel)
              (* (lerp-scale 400.0 0.0 f0-38 0.6 1.0) (-> self clock seconds-per-frame))
              )
          )
      )
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-board-spin-check target ()
  (when (and (or (cpad-pressed? (-> self control cpad number) r1)
                 (and (cpad-hold? (-> self control cpad number) r1)
                      (>= (- (current-time) (-> self board spin-check-time)) (seconds 0.3))
                      )
                 )
             (not (and (and (-> self next-state) (let ((v1-24 (-> self next-state name)))
                                                   (or (= v1-24 'target-board-trickx) (= v1-24 'target-board-hold))
                                                   )
                            )
                       (< (- (current-time) (-> self board spin-start-time)) (seconds 0.5))
                       )
                  )
             (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
             )
    (set! (-> self board spin-start-time) (current-time))
    (set! (-> self board spin-start-dir quad) (-> self node-list data 3 bone transform vector 2 quad))
    (vector-flatten! (-> self control turn-to-alt-heading) (-> self control c-R-w vector 2) *up-vector*)
    (vector-normalize! (-> self control turn-to-alt-heading) 1.0)
    (rot->dir-targ! (-> self control))
    (set! (-> self board trotyv-max) (lerp-scale
                                       218453.33
                                       91022.22
                                       (the float (- (current-time) (-> self control last-time-on-surface)))
                                       0.0
                                       300.0
                                       )
          )
    (set! (-> self board trotyv) 0.0)
    (set! (-> self board troty) 0.0)
    (set! (-> self board troty-cum) 0.0)
    (set! (-> self board unknown-deg00) 0.0)
    (set! (-> self board spin-sound-id) (new 'static 'sound-id))
    (set! (-> self control mod-surface) *board-spin-mods*)
    )
  (cond
    ((and (cpad-hold? (-> self control cpad number) r1)
          (and (or (= (-> self control mod-surface name) 'spin)
                   (< (- (current-time) (-> self board spin-time)) (seconds 0.05))
                   )
               (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
               )
          )
     (set! (-> self board turn-anim-tilt?) #f)
     (set! (-> self control mod-surface) *board-spin-mods*)
     (set! (-> self board spin-time) (current-time))
     (let ((gp-0 (new 'stack-no-clear 'vector)))
       (set! (-> gp-0 x) (* -0.0078125 (+ -128.0 (the float (-> self control cpad leftx)))))
       (set! (-> gp-0 y) 0.0)
       (set! (-> gp-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
       (set! (-> gp-0 w) 0.0)
       (let ((f28-0 (analog-input (the int (* 128.0 (-> gp-0 x))) 0.0 64.0 110.0 2184533.2))
             (f30-0 (analog-input (the int (* 128.0 (-> gp-0 z))) 0.0 96.0 110.0 1.0))
             )
         (if (and (zero? (-> self board spin-sound-id)) (< 5461.3335 (fabs (-> self board trotyv))))
             (set! (-> self board spin-sound-id) (sound-play "board-spin-loop"))
             )
         (if (and (< (* 0.9 (fabs (-> self board spin-control))) (fabs f28-0))
                  (>= (* (-> self board spin-control) f28-0) 0.0)
                  )
             (set! (-> self board spin-control) f28-0)
             )
         (if (not (-> self control danger-mode))
             (target-danger-set! 'board-spin #f)
             )
         (+! (-> self board trotyv) (* (-> self board spin-control) (-> self clock seconds-per-frame)))
         (when (and (< (fabs f28-0) 1092266.6)
                    (< (fabs (-> self board spin-control)) 1092266.6)
                    (< (* 0.9 (fabs (-> self board flip-control))) (fabs f30-0))
                    (>= (* (-> self board flip-control) f30-0) 0.0)
                    (not (board-on-ground?))
                    (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                    (>= (target-height-above-ground) 4096.0)
                    )
           (set! (-> self board flip-control) f30-0)
           (go
             target-board-flip
             (-> *TARGET_BOARD-bank* jump-height-min)
             (-> *TARGET_BOARD-bank* jump-height-max)
             (if (focus-test? self halfpipe)
                 'halfpipe
                 )
             )
           )
         )
       )
     )
    (else
      (set! (-> self control mod-surface) (the-as surface (-> self board mods-backup)))
      )
    )
  (set! (-> self board spin-check-time) (current-time))
  (when (and (or (cpad-pressed? (-> self control cpad number) l1)
                 (< (-> self control last-time-on-surface) (-> self board unknown-time-frame06))
                 )
             (not (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2)))
             )
    (set! (-> self board turn-anim-tilt?) #f)
    (set! (-> self control mod-surface) *board-spin-mods*)
    (set! (-> self board unknown-time-frame03) (current-time))
    (let ((gp-2 (new 'stack-no-clear 'vector)))
      (set! (-> gp-2 x) (* -0.0078125 (+ -128.0 (the float (-> self control cpad leftx)))))
      (set! (-> gp-2 y) 0.0)
      (set! (-> gp-2 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
      (set! (-> gp-2 w) 0.0)
      (let ((f30-1 (analog-input (the int (* 128.0 (-> gp-2 x))) 0.0 64.0 110.0 1.0))
            (f28-1 (analog-input (the int (* 128.0 (-> gp-2 z))) 0.0 96.0 110.0 1.0))
            )
        (when (and (< (fabs f30-1) 0.5)
                   (< (fabs (-> self board unknown-float00)) 0.5)
                   (= (-> self board unknown-float01) 0.0)
                   (< (* 0.9 (fabs (-> self board unknown-float01))) (fabs f28-1))
                   (>= (* (-> self board unknown-float01) f28-1) 0.0)
                   (and (not (board-on-ground?))
                        (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                        (and (>= (target-height-above-ground) 4096.0)
                             (< (seconds 0.165) (target-time-to-ground))
                             (>= (- (current-time) (-> self board unknown-time-frame05)) (seconds 0.05))
                             (< (-> self board unknown-time-frame05) (-> self board unknown-time-frame06))
                             )
                        )
                   )
          (set! (-> self board unknown-float01) f28-1)
          (go
            target-board-hold
            (-> *TARGET_BOARD-bank* tricky-jump-height-min)
            (-> *TARGET_BOARD-bank* tricky-jump-height-max)
            (if (focus-test? self halfpipe)
                'halfpipe
                )
            )
          )
        (when (and (< (fabs f28-1) 0.5)
                   (< (fabs (-> self board unknown-float01)) 0.5)
                   (= (-> self board unknown-float00) 0.0)
                   (< (* 0.9 (fabs (-> self board unknown-float00))) (fabs f30-1))
                   (>= (* (-> self board unknown-float00) f30-1) 0.0)
                   (and (not (board-on-ground?))
                        (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                        (and (>= (target-height-above-ground) 4096.0)
                             (< (seconds 0.165) (target-time-to-ground))
                             (>= (- (current-time) (-> self board unknown-time-frame05)) (seconds 0.05))
                             )
                        )
                   )
          (set! (-> self board unknown-float00) f30-1)
          (go
            target-board-trickx
            (-> *TARGET_BOARD-bank* trickx-jump-height-min)
            (-> *TARGET_BOARD-bank* trickx-jump-height-max)
            (if (focus-test? self halfpipe)
                'halfpipe
                )
            )
          )
        )
      )
    )
  (none)
  )

(defbehavior target-board-halfpipe-trans target ()
  (when (and (focus-test? self halfpipe) *camera*)
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (let ((s5-0 (camera-master-method-15 *camera* (new 'stack-no-clear 'vector))))
        (vector-flatten! gp-0 (-> self control edge-grab-across-edge-dir) (-> *camera* local-down))
        (when (< (vector-dot gp-0 s5-0) 0.0)
          (let* ((v1-11 (camera-master-method-14 *camera* (new 'stack-no-clear 'vector)))
                 (f0-3 (vector-dot (-> self control edge-grab-edge-dir) v1-11))
                 (s4-1 (vector-float*! (new 'stack-no-clear 'vector) (-> self control edge-grab-edge-dir) f0-3))
                 )
            (vector-flatten! s4-1 s4-1 (-> *camera* local-down))
            (if (< 0.0 (vector-dot s4-1 s5-0))
                (vector-negate! gp-0 s4-1)
                )
            )
          )
        )
      (vector-normalize! gp-0 8192.0)
      (set! (-> gp-0 y) (+ 40960.0 (-> gp-0 y)))
      (vector+! gp-0 gp-0 (get-trans self 6))
      (vector-! gp-0 gp-0 (get-trans self 0))
      (send-event *camera* 'relative-position gp-0)
      )
    (set-setting! 'matrix-blend-max-angle 'abs (degrees 12.000001) 0)
    (set-setting! 'matrix-blend-max-partial 'abs 0.5 0)
    )
  0
  (none)
  )

(defbehavior target-board-resolve-points target ()
  (when (= (-> self board main mode) (joint-mod-mode rotate))
    (let ((f0-1 (fabs (-> self board troty-cum))))
      (cond
        ((>= f0-1 191146.67)
         (add-to-trick-list (-> self board) (board-tricks board-spin) 4000.0)
         )
        ((>= f0-1 126520.89)
         (add-to-trick-list (-> self board) (board-tricks board-spin) 2000.0)
         )
        ((>= f0-1 49152.0)
         (add-to-trick-list (-> self board) (board-tricks board-spin) 500.0)
         )
        )
      )
    )
  (set! (-> self board troty-cum) 0.0)
  (set! (-> self board flip-count) 0)
  (if (>= (- (current-time) (-> self board in-air-time)) (seconds 0.2))
      (flush-trick-list (-> self board))
      )
  0
  (none)
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior target-board-ground-check target ()
  (when (board-on-ground?)
    (when (!= (-> self board troty-cum) 0.0)
      (let ((f30-0 (fabs (-> self board troty-cum)))
            (f28-0 (vector-y-angle (-> self control transv)))
            (f0-2 (y-angle (-> self control)))
            )
        (if (< (- (current-time) (-> self board halfpipe-time)) (seconds 0.1))
            (set! f28-0 (+ 32768.0 f28-0))
            )
        (let ((f0-5 (fabs (deg-diff f0-2 f28-0))))
          (when (and (>= f30-0 49152.0) (>= 4551.1113 f0-5))
            (cond
              ((>= f30-0 191146.67)
               (add-to-trick-list (-> self board) (board-tricks board-boost) 2000.0)
               )
              ((>= f30-0 126520.89)
               (add-to-trick-list (-> self board) (board-tricks board-boost) 1000.0)
               )
              (else
                (add-to-trick-list (-> self board) (board-tricks board-boost) 500.0)
                )
              )
            (let ((f0-8 (lerp-scale 20480.0 40960.0 f30-0 49152.0 182044.44)))
              (vector+float*! (-> self control transv) (-> self control transv) (-> self control c-R-w vector 2) f0-8)
              )
            (if (< (vector-length (-> self control transv)) 114688.0)
                (vector-normalize! (-> self control transv) 114688.0)
                )
            (when (not (logtest? (-> self control old-status) (collide-status on-surface)))
              (let ((gp-0 (new 'stack-no-clear 'vector)))
                (set! (-> gp-0 quad) (-> self control trans quad))
                (set! (-> gp-0 y) (+ 2048.0 (-> gp-0 y)))
                (let ((s5-0 (get-process *default-dead-pool* part-tracker #x4000)))
                  (when s5-0
                    (let ((t9-10 (method-of-type part-tracker activate)))
                      (t9-10 (the-as part-tracker s5-0) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                      )
                    (let ((t9-11 run-function-in-process)
                          (a0-14 s5-0)
                          (a1-10 part-tracker-init)
                          (a2-8 (-> *part-group-id-table* 119))
                          (a3-2 0)
                          (t0-1 #f)
                          (t1-0 #f)
                          (t2-0 #f)
                          (t3-0 *launch-matrix*)
                          )
                      (set! (-> t3-0 trans quad) (-> gp-0 quad))
                      ((the-as (function object object object object object object object object none) t9-11)
                       a0-14
                       a1-10
                       a2-8
                       a3-2
                       t0-1
                       t1-0
                       t2-0
                       t3-0
                       )
                      )
                    (-> s5-0 ppointer)
                    )
                  )
                (let ((s5-1 (process-spawn
                              manipy
                              :init manipy-init
                              gp-0
                              (-> self entity)
                              (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer uint32) #f))
                              #f
                              0
                              :to self
                              )
                            )
                      )
                  (when s5-1
                    (quaternion-copy! (-> (the-as board (-> s5-1 0)) root quat) (-> self control quat-for-control))
                    (send-event (ppointer->process s5-1) 'anim-mode 'play1)
                    (send-event (ppointer->process s5-1) 'anim "idle")
                    (send-event (ppointer->process s5-1) 'speed #x3fc00000)
                    (set-vector! (-> (the-as board (-> s5-1 0)) root scale) 0.2 0.4 0.2 1.0)
                    )
                  )
                )
              (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 255 (seconds 0.3))
              (sound-play "board-boost")
              )
            )
          )
        )
      )
    (target-board-resolve-points)
    )
  (set! (-> self board turn-anim-tilt?) #t)
  (none)
  )

(defbehavior target-board-halfpipe-check target ()
  (local-vars (v0-3 collide-action))
  (let ((gp-0 (vector-flatten!
                (new-stack-vector0)
                (-> self control dynam gravity-normal)
                (-> self control ground-contact-normal)
                )
              )
        )
    (vector-normalize! gp-0 1.0)
    (cond
      ((and (board-on-ground?)
            (= (-> self control ground-pat mode) (pat-mode halfpipe))
            (< 0.0 (vector-dot (-> self control transv) gp-0))
            (and (< (-> self control surface-angle) 0.3) (zero? (-> self board halfpipe-side-time)))
            )
       (set! (-> self board halfpipe-side-time) (current-time))
       (set! v0-3 (logior (-> self control root-prim prim-core action) (collide-action no-normal-reset)))
       (set! (-> self control root-prim prim-core action) v0-3)
       v0-3
       )
      (else
        (if (and (not (board-on-ground?))
                 (nonzero? (-> self board halfpipe-side-time))
                 (>= (- (current-time) (-> self board halfpipe-side-time)) (seconds 0.05))
                 )
            (go target-board-halfpipe)
            )
        (when (>= (- (current-time) (-> self board halfpipe-side-time)) (seconds 0.2))
          (set! (-> self board halfpipe-side-time) 0)
          (set! v0-3 (logclear (-> self control root-prim prim-core action) (collide-action no-normal-reset)))
          (set! (-> self control root-prim prim-core action) v0-3)
          v0-3
          )
        )
      )
    )
  )

(defbehavior target-board-jump-trans target ()
  (when (and (!= (-> self state-time) (current-time)) (jump-hit-ground-stuck?))
    (set! (-> self board jump-land-time) (current-time))
    (go target-board-hit-ground)
    )
  (if (>= (- (current-time) (-> self state-time)) (seconds 0.1))
      (target-board-smack-surface?)
      )
  (if (and (cpad-pressed? (-> self control cpad number) x)
           (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 12288.0)
           (< -61440.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
           (and (not (logtest? (water-flags touch-water) (-> self water flags)))
                (not (logtest? (-> self state-flags) (state-flags prevent-jump)))
                (not (and (-> self next-state) (= (-> self next-state name) 'target-board-wall-kick)))
                )
           )
      (go target-board-jump-kick)
      )
  (target-board-spin-check)
  (none)
  )

(defstate target-board-start (target)
  :event target-board-handler
  :exit target-board-exit
  :code (behavior ((arg0 object))
    (target-board-init)
    (remove-exit)
    (go target-board-get-on)
    (none)
    )
  :post target-post
  )

(defstate target-board-stance (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('lip)
       (when (and (= (-> self control ground-pat mode) (pat-mode halfpipe))
                  (< (-> self control poly-angle) 0.5)
                  (let ((s5-0 (vector-flatten!
                                (new-stack-vector0)
                                (-> self control dynam gravity-normal)
                                (-> self control ground-contact-normal)
                                )
                              )
                        )
                    (vector-normalize! s5-0 1.0)
                    (< 0.0 (vector-dot (-> self control transv) s5-0))
                    )
                  )
         (set! (-> self board halfpipe-lip-time) (current-time))
         (set! (-> self board halfpipe-side-time) (current-time))
         (set! (-> self board halfpipe-lip-event) (the-as symbol (-> event param 0)))
         (let ((v0-2 (the-as object (logior (-> self control root-prim prim-core action) (collide-action no-normal-reset))))
               )
           (set! (-> self control root-prim prim-core action) (the-as collide-action v0-2))
           v0-2
           )
         )
       )
      (('jump)
       (go
         target-board-jump
         (the-as meters (-> event param 0))
         (the-as meters (-> event param 1))
         (the-as symbol (-> event param 2))
         )
       )
      (else
        (target-board-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self control mod-surface) *board-walk-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (none)
    )
  :exit (behavior ()
    (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                           (or (= v1-3 'target-board-stance) (= v1-3 'target-board-duck-stance))
                                           )
                    )
               )
      (set! (-> self board halfpipe-side-time) 0)
      0
      )
    (logclear! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (set! (-> self board turn-anim-tilt?) #f)
    (when (not (and (-> self next-state)
                    (let ((v1-13 (-> self next-state name)))
                      (or (= v1-13 'target-board-stance) (= v1-13 'target-board-duck-stance) (= v1-13 'target-board-ride-edge))
                      )
                    )
               )
      (set! (-> self board turn-anim-frame) 0.0)
      (set! (-> self board turn-anim-mag) 0.0)
      (set! (-> self board turn-anim-vel) 0.0)
      (set! (-> self board turn-anim-duck) 0.0)
      )
    (target-board-exit)
    (none)
    )
  :trans (behavior ()
    (if (and (cpad-hold? (-> self control cpad number) l1)
             (not (logtest? (-> self state-flags) (state-flags prevent-duck)))
             (< (- (current-time) (-> self control last-time-on-surface))
                (the-as time-frame (-> *TARGET-bank* ground-timeout))
                )
             )
        (go target-board-duck-stance)
        )
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? 'board)
               )
      (let ((gp-0 (vector-flatten!
                    (new-stack-vector0)
                    (-> self control dynam gravity-normal)
                    (-> self control ground-contact-normal)
                    )
                  )
            )
        (vector-normalize! gp-0 1.0)
        (cond
          ((and (< (- (current-time) (-> self board halfpipe-jump-time)) (seconds 0.5))
                (= (-> self control ground-pat mode) (pat-mode halfpipe))
                )
           )
          ((and (= (-> self control ground-pat mode) (pat-mode halfpipe))
                (< 0.0 (vector-dot (-> self control transv) gp-0))
                (< (-> self control surface-angle) 0.5)
                )
           (set! (-> self board halfpipe-jump-time) (current-time))
           (vector-float*! (-> self control transv) (-> self control transv) 1.5)
           )
          (else
            (flush-trick-list (-> self board))
            (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
            )
          )
        )
      )
    (if (cpad-pressed? (-> self control cpad number) r1)
        (set! (-> self board spin-ground-press-time) (current-time))
        )
    (if (and (cpad-hold? (-> self control cpad number) r1)
             (can-feet? #t)
             (< (- (current-time) (-> self board spin-ground-press-time)) (seconds 0.3))
             (turn-around?)
             )
        (set! (-> self board spin-ground-start-time) (current-time))
        )
    (target-board-halfpipe-check)
    (if (target-board-smack-surface?)
        0
        )
    (target-board-anim-trans)
    (cond
      ((board-on-ground?)
       (target-board-ground-check)
       (set! (-> self control mod-surface) *board-walk-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       )
      ((and (>= (- (current-time) (-> self control last-time-on-surface)) (seconds 0.1))
            (or (= (-> self control mod-surface name) 'spin) (< 4096.0 (target-height-above-ground)))
            )
       (set! (-> self control mod-surface) *board-jump-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       (target-board-spin-check)
       )
      (else
        (set! (-> self control mod-surface) *board-air-mods*)
        (set! (-> self board mods-backup) (-> self control mod-surface))
        )
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self board stance-info)))
      (let ((f30-0 0.0))
        (let ((s5-0 30)
              (v1-3 (ja-group))
              )
          (when (not (and (and v1-3 (= v1-3 (-> self draw art-group data 161))) (= (ja-group-size) 4)))
            (let ((v1-10 (ja-group)))
              (when (and v1-10 (= v1-10 (-> self draw art-group data 170)))
                (ja-channel-set! 1)
                (ja-no-eval :group! (-> self draw art-group data 190)
                            :num! (seek!
                              (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 190)) frames num-frames) -1))
                              1.8
                              )
                            :frame-num 0.0
                            )
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek! max 1.8))
                  )
                (suspend)
                (set! (-> self board turn-anim-duck) 1.0)
                (set! (-> self board turn-anim-duck-vel) 15.0)
                )
              )
            (ja-channel-push! 4 (the-as time-frame s5-0))
            (set! f30-0 (ja-frame-num 0))
            )
          )
        (ground-tween-initialize
          gp-0
          (the-as uint 0)
          (the-as uint (-> self draw art-group data 153))
          (the-as uint (-> self draw art-group data 163))
          (the-as uint (-> self draw art-group data 164))
          (the-as uint (-> self draw art-group data 162))
          (the-as uint (-> self draw art-group data 161))
          f30-0
          )
        )
      (ja :chan 3 :group! (-> self draw art-group data 152))
      (until #f
        (target-board-turn-anim 0)
        (let ((f0-10 (* 1.6 (-> self control ctrl-slope-z)))
              (f1-2 (* 1.6 (-> self control ctrl-slope-x)))
              )
          (cond
            ((not (-> self board turn-anim-tilt?))
             (set! f0-10 0.0)
             (set! f1-2 0.0)
             )
            ((= (-> self control ground-pat mode) (pat-mode halfpipe))
             (set! f0-10 0.0)
             )
            )
          (ground-tween-update gp-0 f0-10 f1-2 0.1)
          )
        (ja :chan 1 :num! (chan 0))
        (ja :chan 2 :num! (chan 0))
        (cond
          ((>= (-> self board turn-anim-duck) 0.0)
           (let ((a0-27 (-> self skel root-channel 3)))
             (let ((f0-14 (-> self board turn-anim-duck)))
               (set! (-> a0-27 frame-interp 1) f0-14)
               (set! (-> a0-27 frame-interp 0) f0-14)
               )
             (set! (-> a0-27 frame-group) (the-as art-joint-anim (-> self draw art-group data 152)))
             (set! (-> a0-27 param 0) 0.0)
             (joint-control-channel-group-eval!
               a0-27
               (the-as art-joint-anim (-> self draw art-group data 152))
               num-func-chan
               )
             )
           )
          (else
            (let ((a0-28 (-> self skel root-channel 3)))
              (let ((f0-17 (- (-> self board turn-anim-duck))))
                (set! (-> a0-28 frame-interp 1) f0-17)
                (set! (-> a0-28 frame-interp 0) f0-17)
                )
              (set! (-> a0-28 frame-group) (the-as art-joint-anim (-> self draw art-group data 177)))
              (set! (-> a0-28 param 0) 0.0)
              (joint-control-channel-group-eval!
                a0-28
                (the-as art-joint-anim (-> self draw art-group data 177))
                num-func-chan
                )
              )
            )
          )
        (suspend)
        (can-play-stance-amibent?)
        )
      )
    #f
    (none)
    )
  :post target-board-post
  )

(defstate target-board-duck-stance (target)
  :event (-> target-board-stance event)
  :enter (behavior ()
    (set! (-> self control mod-surface) *board-duck-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (none)
    )
  :exit (behavior ()
    (set! (-> self board turn-anim-duck-vel) -8.0)
    ((-> target-board-stance exit))
    (none)
    )
  :trans (behavior ()
    (if (and (or (not (cpad-hold? (-> self control cpad number) l1))
                 (logtest? (-> self state-flags) (state-flags prevent-duck))
                 (>= (- (current-time) (-> self control last-time-on-surface))
                     (the-as time-frame (-> *TARGET-bank* ground-timeout))
                     )
                 )
             (can-exit-duck? self)
             )
        (go target-board-stance)
        )
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? 'board)
               )
      (let ((gp-0 (vector-flatten!
                    (new-stack-vector0)
                    (-> self control dynam gravity-normal)
                    (-> self control ground-contact-normal)
                    )
                  )
            )
        (vector-normalize! gp-0 1.0)
        (cond
          ((and (< (- (current-time) (-> self board halfpipe-jump-time)) (seconds 0.5))
                (= (-> self control ground-pat mode) (pat-mode halfpipe))
                )
           )
          ((and (= (-> self control ground-pat mode) (pat-mode halfpipe))
                (< 0.0 (vector-dot (-> self control transv) gp-0))
                (< (-> self control surface-angle) 0.5)
                )
           (set! (-> self board halfpipe-jump-time) (current-time))
           (vector-float*! (-> self control transv) (-> self control transv) 1.5)
           )
          (else
            (flush-trick-list (-> self board))
            (deg-diff
              (vector-y-angle (-> self control c-R-w vector 2))
              (vector-y-angle (-> self control to-target-pt-xz))
              )
            (go
              target-board-jump
              (-> *TARGET_BOARD-bank* duck-jump-height-min)
              (-> *TARGET_BOARD-bank* duck-jump-height-max)
              (the-as symbol *board-duck-jump-mods*)
              )
            )
          )
        )
      )
    (if (cpad-pressed? (-> self control cpad number) r1)
        (set! (-> self board spin-ground-press-time) (current-time))
        )
    (if (and (cpad-hold? (-> self control cpad number) r1)
             (can-feet? #t)
             (< (- (current-time) (-> self board spin-ground-press-time)) (seconds 0.3))
             (turn-around?)
             )
        (set! (-> self board spin-ground-start-time) (current-time))
        )
    (target-board-halfpipe-check)
    (if (target-board-smack-surface?)
        0
        )
    (target-board-anim-trans)
    (set! (-> self board turn-anim-duck-vel) 8.0)
    (cond
      ((board-on-ground?)
       (target-board-ground-check)
       (set! (-> self control mod-surface) *board-duck-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       )
      ((and (>= (- (current-time) (-> self control last-time-on-surface)) (seconds 0.1))
            (or (= (-> self control mod-surface name) 'spin) (< 4096.0 (target-height-above-ground)))
            )
       (set! (-> self control mod-surface) *board-duck-jump-mods*)
       (set! (-> self board mods-backup) (-> self control mod-surface))
       (target-board-spin-check)
       )
      (else
        (set! (-> self control mod-surface) *board-air-mods*)
        (set! (-> self board mods-backup) (-> self control mod-surface))
        )
      )
    (none)
    )
  :code (-> target-board-stance code)
  :post target-board-post
  )

(defstate target-board-jump (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (if (and (= event-type 'edge-grab) (< (- (current-time) (-> self state-time)) (seconds 0.1)))
        (return #f)
        )
    (target-board-handler proc arg1 event-type event)
    )
  :enter (behavior ((arg0 meters) (arg1 meters) (arg2 symbol))
    (local-vars
      (sv-144 (function vector entity-actor skeleton-group vector object none :behavior manipy))
      (sv-160 entity-actor)
      )
    (if (= arg2 'hit)
        (set! arg2 #f)
        )
    (when (< (- (current-time) (-> self board ride-time)) (seconds 0.5))
      (set! arg2 (the-as symbol *board-ride-jump-mods*))
      (let ((s2-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control transv) 1.0)))
        (forward-up-nopitch->quaternion
          (-> self control dir-targ)
          s2-0
          (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
          )
        (set! (-> self control turn-lockout-end-time)
              (+ (current-time)
                 (the int (lerp-scale 225.0 0.0 (vector-dot s2-0 (-> self control c-R-w vector 2)) -1.0 1.0))
                 )
              )
        )
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set! (-> self state-time) (current-time))
    (let ((f30-0 0.0))
      (cond
        ((and (< 0.0 (-> self board shock-offsetv))
              (< (- (current-time) (-> self board jump-land-time)) (seconds 0.5))
              (>= (- (current-time) (-> self board ride-time)) (seconds 0.5))
              )
         (let ((s3-2 (new 'stack-no-clear 'vector)))
           (set! (-> s3-2 quad) (-> self control trans quad))
           (set! (-> s3-2 y) (+ 2048.0 (-> s3-2 y)))
           (let ((s2-1 (get-process *default-dead-pool* part-tracker #x4000)))
             (when s2-1
               (let ((t9-5 (method-of-type part-tracker activate)))
                 (t9-5 (the-as part-tracker s2-1) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                 )
               (let ((t9-6 run-function-in-process)
                     (a0-15 s2-1)
                     (a1-7 part-tracker-init)
                     (a2-8 (-> *part-group-id-table* 120))
                     (a3-2 0)
                     (t0-1 #f)
                     (t1-0 #f)
                     (t2-0 #f)
                     (t3-0 *launch-matrix*)
                     )
                 (set! (-> t3-0 trans quad) (-> s3-2 quad))
                 ((the-as (function object object object object object object object object none) t9-6)
                  a0-15
                  a1-7
                  a2-8
                  a3-2
                  t0-1
                  t1-0
                  t2-0
                  t3-0
                  )
                 )
               (-> s2-1 ppointer)
               )
             )
           (let* ((s1-1 (get-process *default-dead-pool* manipy #x4000))
                  (s2-2
                    (when s1-1
                      (let ((t9-8 (method-of-type manipy activate)))
                        (t9-8 (the-as manipy s1-1) self (symbol->string (-> manipy symbol)) (the-as pointer #x70004000))
                        )
                      (let ((s2-3 run-function-in-process)
                            (s0-1 s1-1)
                            )
                        (set! sv-144 manipy-init)
                        (set! sv-160 (-> self entity))
                        (let ((t0-2 (art-group-get-by-name *level* "skel-generic-blast" (the-as (pointer uint32) #f)))
                              (t1-1 #f)
                              (t2-1 0)
                              )
                          ((the-as (function object object object object object object object none) s2-3)
                           s0-1
                           sv-144
                           s3-2
                           sv-160
                           t0-2
                           t1-1
                           t2-1
                           )
                          )
                        )
                      (-> s1-1 ppointer)
                      )
                    )
                  )
             (when s2-2
               (quaternion-copy! (-> (the-as board (-> s2-2 0)) root quat) (-> self control quat-for-control))
               (send-event (ppointer->process s2-2) 'anim-mode 'play1)
               (send-event (ppointer->process s2-2) 'anim "idle")
               (send-event (ppointer->process s2-2) 'speed #x3fc00000)
               (set-vector! (-> (the-as board (-> s2-2 0)) root scale) 0.2 0.4 0.2 1.0)
               )
             )
           )
         (set! f30-0 (+ 8192.0 f30-0))
         (add-to-trick-list (-> self board) (board-tricks board-quick-jump) 0.0)
         (sound-play "board-q-jump")
         )
        (else
          (if (= (the-as object arg2) *board-duck-jump-mods*)
              (add-to-trick-list (-> self board) (board-tricks board-duck-jump) 0.0)
              (add-to-trick-list (-> self board) (board-tricks board-jump) 0.0)
              )
          (set! (-> self board unknown-sound-id02) (sound-play "board-jump"))
          )
        )
      (init-var-jump
        (+ arg0 f30-0)
        (+ arg1 f30-0)
        #t
        #f
        (-> self control transv)
        (if (>= (- (current-time) (-> self board unknown-time-frame00)) (seconds 0.1))
            2.0
            0.0
            )
        )
      )
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! arg2 (cond
                 ((the-as object arg2)
                  (empty)
                  arg2
                  )
                 (else
                   (the-as symbol *board-jump-mods*)
                   )
                 )
          )
    (set! (-> self control mod-surface) (the-as surface arg2))
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self board shock-offsetv) 0.0)
    (set! (-> self control unknown-float36)
          (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
          )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (none)
    )
  :exit target-board-exit
  :trans (behavior ()
    (target-board-jump-trans)
    (set! (-> self control unknown-float36)
          (fmax
            (-> self control unknown-float36)
            (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
            )
          )
    (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (set! (-> self board shock-offset) (* 0.8 (-> self board shock-offset)))
    (none)
    )
  :code (behavior ((arg0 meters) (arg1 meters) (arg2 symbol))
    (case arg2
      (('hit)
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! (-> self draw art-group data 158)
                   :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 158)) frames num-frames) -1)))
                   :frame-num 0.0
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek!))
         )
       (ja-channel-push! 1 (seconds 0.05))
       )
      (else
        (ja-channel-push! 1 (seconds 0.05))
        (ja :group! (-> self draw art-group data 155) :num! min)
        (suspend)
        (until (ja-done? 0)
          (let ((f30-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
                (f0-10 (- 10.0 (ja-aframe-num 0)))
                (gp-1 (-> self skel root-channel 0))
                )
            (set! (-> gp-1 param 0) (the float (+ (-> gp-1 frame-group frames num-frames) -1)))
            (let ((v1-44 (and (< 0.0 f30-0) (< 0.0 f0-10))))
              (set! (-> gp-1 param 1)
                    (cond
                      (v1-44
                        (fmin (fmin 1.5 f0-10) (/ (* 5.0 f0-10) (the float (time-to-apex f30-0 -245760.0))))
                        )
                      ((< (seconds 0.165) (target-time-to-ground))
                       0.5
                       )
                      (else
                        0.25
                        )
                      )
                    )
              )
            (joint-control-channel-group-eval! gp-1 (the-as art-joint-anim #f) num-func-seek!)
            )
          (suspend)
          )
        (ja-channel-push! 1 (seconds 0.05))
        )
      )
    (ja :group! (-> self draw art-group data 156))
    (until #f
      (suspend)
      (ja :num! (loop!))
      )
    #f
    (none)
    )
  :post target-board-post
  )

(defstate target-board-halfpipe (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('edge-grab)
       (format
         #t
         "halfpipe found edge ~m~%"
         (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
         )
       (set! (-> self control unknown-word04) (the-as uint #t))
       (let ((v1-6 *edge-grab-info*))
         (vector-normalize!
           (vector-!
             (-> self control edge-grab-edge-dir)
             (the-as vector (-> v1-6 world-vertex))
             (-> v1-6 world-vertex 1)
             )
           1.0
           )
         )
       (vector-cross!
         (-> self control edge-grab-across-edge-dir)
         (-> self control edge-grab-edge-dir)
         (-> self control dynam gravity-normal)
         )
       (let ((v1-11 (new-stack-vector0)))
         (let ((f0-2 (vector-dot (-> self control edge-grab-across-edge-dir) (-> self control transv))))
           0.0
           (vector-!
             v1-11
             (-> self control transv)
             (vector-float*! v1-11 (-> self control edge-grab-across-edge-dir) f0-2)
             )
           )
         (let* ((f0-3 (vector-length v1-11))
                (f1-1 f0-3)
                (f2-0 -2048.0)
                )
           (vector+!
             (-> self control transv)
             (vector-float*! (-> self control transv) (-> self control edge-grab-across-edge-dir) f2-0)
             (vector-float*! v1-11 v1-11 (/ f0-3 f1-1))
             )
           )
         )
       )
      (('ramp)
       (when (not (-> self control did-move-to-pole-or-max-jump-height))
         (let ((v0-3 (the-as object #t)))
           (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float v0-3))
           v0-3
           )
         )
       )
      (('grenade)
       (if (< (the-as float (-> event param 0))
              (vector-dot (-> self control dynam gravity-normal) (-> self control transv))
              )
           (go target-board-grenade (process->handle proc))
           )
       )
      (else
        (target-board-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self focus-status) (logior (focus-status halfpipe) (-> self focus-status)))
    (set! (-> self state-time) (current-time))
    (logior! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (set! (-> self control mod-surface) *board-halfpipe-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control sliding-start-time) 0)
    (when (< (vector-dot (-> self control c-R-w vector 1) (-> self control dynam gravity-normal)) 0.7)
      (vector-matrix*! (-> self control transv-ctrl) (-> self control transv) (-> self control w-R-c))
      (set! (-> self control transv-ctrl y) 0.0)
      (vector-matrix*! (-> self control transv) (-> self control transv-ctrl) (-> self control c-R-w))
      )
    (set! (-> self control unknown-word04) (the-as uint #f))
    (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float #f))
    (do-edge-grabs *target* *collide-cache* *collide-edge-board-halfpipe-spec*)
    (when (not (-> self control unknown-spool-anim00))
      (let ((gp-0 (vector-flatten!
                    (-> self control edge-grab-across-edge-dir)
                    (-> self control dynam gravity-normal)
                    (-> self control ground-contact-normal)
                    )
                  )
            )
        (set! (-> gp-0 y) 0.0)
        (vector-normalize! gp-0 1.0)
        (vector-rotate-y! (-> self control edge-grab-edge-dir) (-> self control edge-grab-across-edge-dir) 16384.0)
        (let ((v1-40 (new-stack-vector0)))
          (let ((f0-5 (vector-dot gp-0 (-> self control transv))))
            0.0
            (vector-! v1-40 (-> self control transv) (vector-float*! v1-40 gp-0 f0-5))
            )
          (let* ((f0-6 (vector-length v1-40))
                 (f1-2 f0-6)
                 (f2-0 -2048.0)
                 )
            (vector+!
              (-> self control transv)
              (vector-float*! (-> self control transv) gp-0 f2-0)
              (vector-float*! v1-40 v1-40 (/ f0-6 f1-2))
              )
            )
          )
        )
      )
    (if (or (< (vector-dot (-> self control dynam gravity-normal) (-> self control transv)) 20480.0)
            (< (vector-dot
                 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> self control transv) 1.0)
                 )
               0.3
               )
            )
        (go target-board-turn-to (-> self control transv) (seconds 0.5))
        )
    (none)
    )
  :exit (behavior ()
    (if (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                         (or (= v1-3 'target-board-flip)
                                             (= v1-3 'target-board-hold)
                                             (= v1-3 'target-board-trickx)
                                             (= v1-3 'target-board-grenade)
                                             (= v1-3 'target-board-falling)
                                             )
                                         )
                  )
             )
        (logclear! (-> self focus-status) (focus-status halfpipe))
        )
    (send-event *camera* 'relative-position #f)
    (remove-setting! 'matrix-blend-max-angle)
    (remove-setting! 'matrix-blend-max-partial)
    (logclear! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (target-board-exit)
    (none)
    )
  :trans (behavior ()
    (when (and (or (= (the-as int (-> self control did-move-to-pole-or-max-jump-height)) #t)
                   (and (< (- (current-time) (-> self board halfpipe-lip-time)) (seconds 0.1))
                        (= (-> self board halfpipe-lip-event) 'lipramp)
                        )
                   )
               (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
               )
      (set! (-> self control did-move-to-pole-or-max-jump-height) (the-as float 'done))
      (let ((v1-16 (new-stack-vector0))
            (f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            )
        0.0
        (vector-! v1-16 (-> self control transv) (vector-float*! v1-16 (-> self control dynam gravity-normal) f0-2))
        (let* ((f1-4 (vector-length v1-16))
               (f2-0 f1-4)
               )
          (if (!= f1-4 0.0)
              (set! f1-4 0.0)
              )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
            (vector-float*! v1-16 v1-16 (/ f1-4 f2-0))
            )
          )
        )
      )
    (set! (-> self board halfpipe-time) (current-time))
    (if (= (-> self control gspot-pat-surfce mode) (pat-mode halfpipe))
        (set! (-> self board halfpipe-gspot-time) (current-time))
        )
    (when (jump-hit-ground-stuck?)
      (vector-float*! (-> self control transv) (-> self control transv) 1.5)
      (go target-board-turn-to (-> self control transv) (seconds 0.5))
      )
    (when (and (cpad-pressed? (-> self control cpad number) x)
               (>= (- (current-time) (-> self board halfpipe-jump-time)) (seconds 0.6))
               (< (- (current-time) (-> self state-time)) (the-as time-frame (-> *TARGET-bank* ground-timeout)))
               (< 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
               )
      (set! (-> self board halfpipe-jump-time) (current-time))
      (vector-float*! (-> self control transv) (-> self control transv) 1.5)
      )
    (target-board-spin-check)
    (cond
      ((> (-> self control sliding-start-time) 0)
       (cond
         ((< 0.7 (-> self control turn-to-magnitude))
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (set! (-> gp-0 quad) (-> self control edge-grab-across-edge-dir quad))
            (set! (-> gp-0 y) 0.0)
            (vector-normalize! gp-0 1.0)
            (if (< 0.7 (vector-dot (-> self control to-target-pt-xz) gp-0))
                (+! (-> self control sliding-start-time) (- (current-time) (-> self clock old-frame-counter)))
                (set! (-> self control sliding-start-time) 1)
                )
            )
          )
         (else
           (set! (-> self control sliding-start-time) 1)
           )
         )
       )
      ((and (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
            (< (-> self board halfpipe-lip-time) (+ (-> self state-time) (seconds -0.2)))
            )
       (set! (-> self control sliding-start-time) 1)
       )
      )
    (when (or (>= (-> self control sliding-start-time) (seconds 0.05))
              (and (>= (- (current-time) (-> self board halfpipe-gspot-time)) (seconds 0.5))
                   (< (-> self board halfpipe-lip-time) (+ (-> self state-time) (seconds -0.2)))
                   )
              )
      (+! (-> self control transv x) (* 20480.0 (-> self control edge-grab-across-edge-dir x)))
      (+! (-> self control transv z) (* 20480.0 (-> self control edge-grab-across-edge-dir z)))
      (go target-board-stance)
      )
    (target-board-halfpipe-trans)
    (none)
    )
  :code (behavior ()
    (cond
      ((< (- (current-time) (-> self board halfpipe-jump-time)) (seconds 0.5))
       (ja-channel-push! 1 (seconds 0.05))
       (ja-no-eval :group! (-> self draw art-group data 155) :num! (seek! (ja-aframe 8.0 0) 0.5) :frame-num 0.0)
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 8.0 0) 0.5))
         )
       (ja-no-eval :group! (-> self draw art-group data 155)
                   :num! (seek! (ja-aframe 10.0 0) 0.2)
                   :frame-num (ja-aframe 8.0 0)
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 10.0 0) 0.2))
         )
       (ja-no-eval :group! (-> self draw art-group data 155)
                   :num! (seek! (ja-aframe 12.0 0) 0.1)
                   :frame-num (ja-aframe 10.0 0)
                   )
       (until (ja-done? 0)
         (suspend)
         (ja :num! (seek! (ja-aframe 12.0 0) 0.1))
         )
       (sleep-code)
       )
      (else
        ((the-as (function none :behavior target) (-> target-board-stance code)))
        )
      )
    (none)
    )
  :post target-board-post
  )

(defstate target-board-falling (target)
  :event target-board-handler
  :enter (behavior ()
    (if (and (= *cheat-mode* 'debug) (cpad-hold? (-> self control cpad number) r2) (not *pause-lock*))
        (set! (-> self control mod-surface) *board-air-mods*)
        (set! (-> self control mod-surface) *board-jump-mods*)
        )
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (none)
    )
  :exit (-> target-board-halfpipe exit)
  :trans (behavior ()
    (target-board-jump-trans)
    (if (focus-test? self halfpipe)
        (target-board-halfpipe-trans)
        )
    (when (and (= *cheat-mode* 'debug) (and (cpad-hold? (-> self control cpad number) r2) (not *pause-lock*)))
      (set! (-> self control mod-surface) *board-air-mods*)
      (set! (-> self board mods-backup) (-> self control mod-surface))
      )
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (cond
        ((and v1-2 (= v1-2 (-> self draw art-group data 156)))
         )
        ((let ((v1-8 (ja-group)))
           (and v1-8 (= v1-8 (-> self draw art-group data 187)))
           )
         (ja-no-eval :num! (seek!))
         (ja-channel-push! 1 (seconds 0.5))
         )
        ((let ((v1-22 (ja-group)))
           (and v1-22 (or (= v1-22 (-> self draw art-group data 178))
                          (= v1-22 (-> self draw art-group data 182))
                          (= v1-22 (-> self draw art-group data 159))
                          (= v1-22 (-> self draw art-group data 181))
                          )
                )
           )
         (ja-no-eval :num! (seek!))
         (ja-channel-push! 1 (seconds 0.2))
         )
        (else
          (let ((v1-36 (ja-group)))
            (cond
              ((and v1-36 (= v1-36 (-> self draw art-group data 176)))
               (ja-no-eval :num! (seek!))
               (ja-channel-push! 1 (seconds 0.1))
               )
              (else
                (ja-channel-push! 1 (seconds 0.5))
                )
              )
            )
          )
        )
      )
    (cond
      ((focus-test? self halfpipe)
       (ja :group! (-> self draw art-group data 152) :num! (identity (ja-aframe 0.0 0)))
       (loop
         (suspend)
         (ja-blend-eval)
         )
       )
      (else
        (ja :group! (-> self draw art-group data 156))
        (loop
          (suspend)
          (ja-blend-eval)
          (ja :num! (loop!))
          )
        )
      )
    (none)
    )
  :post target-board-post
  )

(defstate target-board-jump-kick (target)
  :event target-board-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *board-jump-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (sound-play "board-k-jump")
    (none)
    )
  :exit target-board-exit
  :trans (behavior ()
    (if (jump-hit-ground-stuck?)
        (go target-board-hit-ground)
        )
    (target-board-smack-surface?)
    (cond
      ((< (- (current-time) (-> self board smack-surface-time)) (seconds 0.2))
       (go target-board-wall-kick (-> self board smack-normal) (-> self board smack-speed))
       )
      ((< (- (current-time) (-> self board glance-time)) (seconds 0.2))
       (go
         target-board-wall-kick
         (vector-normalize-copy! (-> self control unknown-vector38) (-> self board glance-out-transv) 1.0)
         (-> self board glance-speed)
         )
       )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja-no-eval :group! (-> self draw art-group data 154)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 154)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (ja-channel-push! 1 (seconds 2))
    (ja :group! (-> self draw art-group data 156))
    (until #f
      (suspend)
      (ja :num! (loop!))
      )
    #f
    (none)
    )
  :post target-board-post
  )

(defstate target-board-wall-kick (target)
  :event target-board-handler
  :enter (behavior ((arg0 vector) (arg1 float))
    (sound-play "board-kick")
    (set! (-> self control transv quad) (-> arg0 quad))
    (vector-xz-normalize! (-> self control transv) (* 0.8 arg1))
    (set! (-> self control unknown-word04) (the-as uint (fmax 81920.0 (* 0.8 arg1))))
    (set! (-> self control unknown-vector38 quad) (-> arg0 quad))
    (set! (-> self control transv y) 0.0)
    (vector-turn-to (vector-negate! (new 'stack-no-clear 'vector) (-> self control transv)))
    (set! (-> self control transv y) (- (sqrtf (* 24576.0 (-> self control dynam gravity-length)))
                                        (* 0.008333334 (- (-> self control dynam gravity-length)))
                                        )
          )
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *board-wall-kick-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self board smack-surface-time) 0)
    0
    (none)
    )
  :exit target-board-exit
  :trans target-board-jump-trans
  :code (behavior ((arg0 vector) (arg1 float))
    (ja-no-eval :group! (-> self draw art-group data 188)
                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 188)) frames num-frames) -1)))
                :frame-num 0.0
                )
    (until (ja-done? 0)
      (if (and (jump-hit-ground-stuck?) (< 31.0 (ja-aframe-num 0)))
          (go target-board-hit-ground)
          )
      (let ((v1-21 (-> self control unknown-vector38)))
        (set! (-> self control transv x) (-> v1-21 x))
        (set! (-> self control transv z) (-> v1-21 z))
        )
      (vector-xz-normalize! (-> self control transv) (the-as float (-> self control unknown-word04)))
      (compute-alignment! (-> self align))
      (align! (-> self align) (align-opts adjust-quat) 1.0 1.0 1.0)
      (suspend)
      (ja :num! (seek!))
      )
    enter-state
    (go target-board-falling)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-flip (target)
  :event (-> target-board-jump event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self control unknown-word04) (the-as uint arg2))
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control transv)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ))
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set! (-> self state-time) (current-time))
    (cond
      ((= arg2 'halfpipe)
       (set! (-> self focus-status) (logior (focus-status halfpipe) (-> self focus-status)))
       (target-board-halfpipe-trans)
       )
      (else
        (init-var-jump arg0 arg1 #t #f (-> self control transv) 1.0)
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (set! (-> self control unknown-float36)
              (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
              )
        )
      )
    (set! (-> self control mod-surface) *board-flip-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((v1-25 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-25 command) (sound-command set-param))
      (set! (-> v1-25 id) (-> self board unknown-sound-id02))
      (set! (-> v1-25 params volume) -4)
      (set! (-> v1-25 auto-time) 72)
      (set! (-> v1-25 auto-from) 2)
      (set! (-> v1-25 params mask) (the-as uint 17))
      (-> v1-25 id)
      )
    (set! (-> self control unknown-sound-id00) (sound-play "board-flip"))
    (target-start-attack)
    (target-danger-set! 'board-spin #f)
    (none)
    )
  :exit (behavior ()
    (target-danger-set! 'harmless #f)
    (set! (-> self board flip-control) 0.0)
    (add-to-trick-list
      (-> self board)
      (board-tricks board-flip)
      (+ (* 500.0 (the float (-> self board flip-count))) (if (>= (-> self board flip-count) 2)
                                                              2000.0
                                                              0.0
                                                              )
         )
      )
    (let ((v1-9 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-9 command) (sound-command set-param))
      (set! (-> v1-9 id) (-> self control unknown-sound-id00))
      (set! (-> v1-9 params volume) -4)
      (set! (-> v1-9 auto-time) 24)
      (set! (-> v1-9 auto-from) 2)
      (set! (-> v1-9 params mask) (the-as uint 17))
      (-> v1-9 id)
      )
    ((-> target-board-halfpipe exit))
    (none)
    )
  :trans (behavior ()
    (cond
      ((= (-> self control unknown-spool-anim00) 'halfpipe)
       (target-board-halfpipe-trans)
       )
      (else
        (set! (-> self control unknown-float36)
              (fmax
                (-> self control unknown-float36)
                (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
                )
              )
        (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((gp-0 (>= (-> self board flip-control) 0.0)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (set! (-> s5-0 x) 0.0)
        (set! (-> s5-0 y) 0.0)
        (set! (-> s5-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
        (set! (-> s5-0 w) 1.0)
        (let ((f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
              (s4-0 0)
              )
          (while (not (and (or (not (cpad-hold? (-> self control cpad number) r1))
                               (or (= f0-9 0.0) (jump-hit-ground-stuck?) (< (target-time-to-ground) (seconds 0.5)))
                               )
                           (nonzero? s4-0)
                           )
                      )
            (cond
              (gp-0
                (cond
                  ((zero? s4-0)
                   (ja-channel-push! 1 (seconds 0.1))
                   (ja-no-eval :group! (-> self draw art-group data 159) :num! (seek! (ja-aframe 15.0 0)) :frame-num 0.0)
                   (until (ja-done? 0)
                     (suspend)
                     (ja :num! (seek! (ja-aframe 15.0 0)))
                     )
                   )
                  (else
                    (ja-no-eval :group! (-> self draw art-group data 181)
                                :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 181)) frames num-frames) -1)))
                                :frame-num 0.0
                                )
                    (until (ja-done? 0)
                      (suspend)
                      (ja :num! (seek!))
                      )
                    )
                  )
                )
              ((zero? s4-0)
               (ja-channel-push! 1 (seconds 0.1))
               (ja-no-eval :group! (-> self draw art-group data 178) :num! (seek! (ja-aframe 10.0 0)) :frame-num 0.0)
               (until (ja-done? 0)
                 (suspend)
                 (ja :num! (seek! (ja-aframe 10.0 0)))
                 )
               )
              (else
                (ja-no-eval :group! (-> self draw art-group data 182)
                            :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 182)) frames num-frames) -1)))
                            :frame-num 0.0
                            )
                (until (ja-done? 0)
                  (suspend)
                  (ja :num! (seek!))
                  )
                )
              )
            (+! (-> self board flip-count) 1)
            (set! f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
            (+! s4-0 1)
            )
          )
        )
      (cond
        (gp-0
          (ja-no-eval :group! (-> self draw art-group data 159)
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 159)) frames num-frames) -1)))
                      :frame-num (ja-aframe 15.0 0)
                      )
          (until (ja-done? 0)
            (if (jump-hit-ground-stuck?)
                (go target-board-hit-ground)
                )
            (suspend)
            (ja :num! (seek!))
            )
          )
        (else
          (ja-no-eval :group! (-> self draw art-group data 178)
                      :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 178)) frames num-frames) -1)))
                      :frame-num (ja-aframe 10.0 0)
                      )
          (until (ja-done? 0)
            (if (jump-hit-ground-stuck?)
                (go target-board-hit-ground)
                )
            (suspend)
            (ja :num! (seek!))
            )
          )
        )
      )
    (go target-board-falling)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-hold (target)
  :event (-> target-board-jump event)
  :enter (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (set! (-> self control unknown-word04) (the-as uint arg2))
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control transv)
      (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> self control dir-targ))
      )
    (set! (-> self control dynam gravity-length) 245760.0)
    (set! (-> self state-time) (current-time))
    (set! (-> self board unknown-time-frame04) (current-time))
    (cond
      ((= arg2 'halfpipe)
       (set! (-> self focus-status) (logior (focus-status halfpipe) (-> self focus-status)))
       (target-board-halfpipe-trans)
       )
      (else
        (init-var-jump arg0 arg1 #t #f (-> self control transv) 1.0)
        (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
        (set! (-> self control unknown-float36)
              (fmax 0.0 (fmin 1.0 (* 0.00004359654 (+ -11468.8 (-> self control ctrl-xz-vel)))))
              )
        )
      )
    (set! (-> self control mod-surface) *board-flip-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control dynam gravity-length) 147456.0)
    (none)
    )
  :exit (behavior ()
    (set! (-> self board unknown-float01) 0.0)
    (set! (-> self board unknown-time-frame05) (current-time))
    (let ((v1-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-3 command) (sound-command set-param))
      (set! (-> v1-3 id) (-> self board unknown-sound-id01))
      (set! (-> v1-3 params volume) -4)
      (set! (-> v1-3 auto-time) 24)
      (set! (-> v1-3 auto-from) 2)
      (set! (-> v1-3 params mask) (the-as uint 17))
      (-> v1-3 id)
      )
    (let ((v1-7 (ja-group)))
      (if (and v1-7 (= v1-7 (-> self draw art-group data 187)))
          (sound-play "board-boots")
          )
      )
    ((-> target-board-halfpipe exit))
    (none)
    )
  :trans (behavior ()
    (target-board-spin-check)
    (cond
      ((= (-> self control unknown-spool-anim00) 'halfpipe)
       (target-board-halfpipe-trans)
       )
      (else
        (set! (-> self control unknown-float36)
              (fmax
                (-> self control unknown-float36)
                (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
                )
              )
        (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (set! (-> v1-0 x) 0.0)
      (set! (-> v1-0 y) 0.0)
      (set! (-> v1-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
      (set! (-> v1-0 w) 1.0)
      (let ((f30-0 (analog-input (the int (* 128.0 (-> v1-0 z))) 0.0 96.0 110.0 1.0)))
        (while (not (or (not (cpad-hold? (-> self control cpad number) l1))
                        (jump-hit-ground-stuck?)
                        (< (target-time-to-ground) (seconds 0.3))
                        )
                    )
          (cond
            ((< f30-0 0.0)
             (let ((v1-3 (ja-group)))
               (cond
                 ((and v1-3 (= v1-3 (-> self draw art-group data 183)))
                  (ja :num! (loop!))
                  )
                 (else
                   (add-to-trick-list (-> self board) (board-tricks board-method) 500.0)
                   (set! (-> self board unknown-sound-id01) (sound-play "board-method"))
                   (ja-channel-push! 1 (seconds 0.08))
                   (ja-no-eval :group! (-> self draw art-group data 174)
                               :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 174)) frames num-frames) -1)))
                               :frame-num 0.0
                               )
                   (until (ja-done? 0)
                     (suspend)
                     (ja :num! (seek!))
                     )
                   (ja :group! (-> self draw art-group data 183) :num! min)
                   )
                 )
               )
             )
            ((let ((v1-45 (ja-group)))
               (and v1-45 (= v1-45 (-> self draw art-group data 185)))
               )
             (ja :num! (loop!))
             )
            ((< 40960.0 (target-height-above-ground))
             (add-to-trick-list (-> self board) (board-tricks board-nosegrab) 500.0)
             (set! (-> self board unknown-sound-id01) (sound-play "board-nosegrab"))
             (ja-channel-push! 1 (seconds 0.08))
             (ja-no-eval :group! (-> self draw art-group data 173)
                         :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 173)) frames num-frames) -1)))
                         :frame-num 0.0
                         )
             (until (ja-done? 0)
               (suspend)
               (ja :num! (seek!))
               )
             (ja :group! (-> self draw art-group data 185) :num! min)
             )
            (else
              (add-to-trick-list (-> self board) (board-tricks board-noseflip) 500.0)
              (set! (-> self board unknown-sound-id01) (sound-play "board-noseflip"))
              (ja-channel-push! 1 (seconds 0.08))
              (ja-no-eval :group! (-> self draw art-group data 187) :num! (seek! (ja-aframe 20.0 0)) :frame-num 0.0)
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! (ja-aframe 20.0 0)))
                )
              (goto cfg-36)
              )
            )
          (suspend)
          )
        )
      )
    (label cfg-36)
    (let ((v1-121 (ja-group)))
      (cond
        ((and v1-121 (= v1-121 (-> self draw art-group data 183)))
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! (-> self draw art-group data 184)
                     :num! (seek!
                       (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 184)) frames num-frames) -1))
                       1.5
                       )
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        ((let ((v1-151 (ja-group)))
           (and v1-151 (= v1-151 (-> self draw art-group data 185)))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! (-> self draw art-group data 186)
                     :num! (seek!
                       (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 186)) frames num-frames) -1))
                       1.5
                       )
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        )
      )
    (let ((v1-179 (new-stack-vector0))
          (f0-48 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-!
        v1-179
        (-> self control transv)
        (vector-float*! v1-179 (-> self control dynam gravity-normal) f0-48)
        )
      (let* ((f1-5 (vector-length v1-179))
             (f2-2 f1-5)
             )
        (if (< 0.0 f0-48)
            (set! f0-48 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-48)
          (vector-float*! v1-179 v1-179 (/ f1-5 f2-2))
          )
        )
      )
    (go target-board-falling)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-trickx (target)
  :event (-> target-board-jump event)
  :enter (-> target-board-hold enter)
  :exit (behavior ()
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    (sound-play "board-boots")
    ((-> target-board-hold exit))
    (none)
    )
  :trans (behavior ()
    (target-board-spin-check)
    (when (!= (-> self control unknown-spool-anim00) 'halfpipe)
      (set! (-> self control unknown-float36)
            (fmax
              (-> self control unknown-float36)
              (* 0.003921569 (the float (-> *cpad-list* cpads (-> self control cpad number) abutton 6)))
              )
            )
      (mod-var-jump #t #f (cpad-hold? (-> self control cpad number) x) (-> self control transv))
      )
    (when (jump-hit-ground-stuck?)
      (set! (-> self board jump-land-time) (current-time))
      (go target-board-hit-ground)
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (none)
    )
  :code (behavior ((arg0 float) (arg1 float) (arg2 symbol))
    (let ((gp-0 (>= (-> self board unknown-float00) 0.0))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-0 x) 0.0)
      (set! (-> s5-0 y) 0.0)
      (set! (-> s5-0 z) (* -0.0078125 (+ -128.0 (the float (-> self control cpad lefty)))))
      (set! (-> s5-0 w) 1.0)
      (let ((f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
            (s4-0 0)
            )
        (while (not (and (or (not (cpad-hold? (-> self control cpad number) r1))
                             (or (= f0-9 0.0) (jump-hit-ground-stuck?) (< (target-time-to-ground) (seconds 0.5)))
                             )
                         (nonzero? s4-0)
                         )
                    )
          (cond
            (gp-0
              (add-to-trick-list (-> self board) (board-tricks board-kickflip) 500.0)
              (set! (-> self board unknown-sound-id01) (sound-play "board-kickflip"))
              (ja-channel-push! 1 (seconds 0.07))
              (ja-no-eval :group! (-> self draw art-group data 175)
                          :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 175)) frames num-frames) -1)))
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              (send-event (ppointer->process (-> self sidekick)) 'matrix #f)
              (ja-no-eval :group! (-> self draw art-group data 192)
                          :num! (seek!
                            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 192)) frames num-frames) -1))
                            1.05
                            )
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! max 1.05))
                )
              (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
              (ja-no-eval :group! (-> self draw art-group data 193)
                          :num! (seek! (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 193)) frames num-frames) -1)))
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              )
            (else
              (add-to-trick-list (-> self board) (board-tricks board-board-spin) 500.0)
              (set! (-> self board unknown-sound-id01) (sound-play "board-boardspin"))
              (ja-channel-push! 1 (seconds 0.05))
              (ja-no-eval :group! (-> self draw art-group data 176)
                          :num! (seek!
                            (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 176)) frames num-frames) -1))
                            0.95
                            )
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek! max 0.95))
                )
              )
            )
          (+! (-> self board trickx-count) 1)
          (set! f0-9 (analog-input (the int (* 128.0 (-> s5-0 z))) 0.0 96.0 110.0 1.0))
          (+! s4-0 1)
          )
        )
      )
    (go target-board-falling)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-hit-ground (target)
  :event target-board-handler
  :enter (behavior ()
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (if (= (-> self control ground-pat mode) (pat-mode halfpipe))
        (go target-board-turn-to (-> self control transv) (seconds 0.5))
        )
    (none)
    )
  :exit target-board-exit
  :trans (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? 'board)
               )
      (flush-trick-list (-> self board))
      (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
      )
    (if (and (cpad-hold? (-> self control cpad number) l1)
             (not (logtest? (-> self state-flags) (state-flags prevent-duck)))
             )
        (go target-board-duck-stance)
        )
    (if (target-board-smack-surface?)
        0
        )
    (none)
    )
  :code (behavior ()
    (set! (-> self control mod-surface) *board-walk-mods*)
    (let ((v1-3 (ja-group)))
      (cond
        ((and v1-3 (or (= v1-3 (-> self draw art-group data 184)) (= v1-3 (-> self draw art-group data 186))))
         (ja-no-eval :num! (seek! max 1.5))
         (while (not (ja-done? 0))
           (suspend)
           (ja-eval)
           )
         )
        ((let ((v1-18 (ja-group)))
           (and v1-18 (= v1-18 (-> self draw art-group data 183)))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! (-> self draw art-group data 184)
                     :num! (seek!
                       (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 184)) frames num-frames) -1))
                       1.5
                       )
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        ((let ((v1-48 (ja-group)))
           (and v1-48 (= v1-48 (-> self draw art-group data 185)))
           )
         (ja-channel-push! 1 (seconds 0.08))
         (ja-no-eval :group! (-> self draw art-group data 186)
                     :num! (seek!
                       (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 186)) frames num-frames) -1))
                       1.5
                       )
                     :frame-num 0.0
                     )
         (until (ja-done? 0)
           (suspend)
           (ja :num! (seek! max 1.5))
           )
         )
        )
      )
    (go target-board-stance)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-turn-to (target)
  :event target-board-handler
  :enter (behavior ((arg0 vector) (arg1 time-frame))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (when (!= (-> self control dynam gravity-length) 245760.0)
      (let ((v1-6 (new-stack-vector0))
            (f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
            )
        0.0
        (vector-! v1-6 (-> self control transv) (vector-float*! v1-6 (-> self control dynam gravity-normal) f0-2))
        (let* ((f1-3 (vector-length v1-6))
               (f2-0 f1-3)
               )
          (if (< f0-2 0.0)
              (set! f0-2 (* 5.0 f0-2))
              )
          (vector+!
            (-> self control transv)
            (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-2)
            (vector-float*! v1-6 v1-6 (/ f1-3 f2-0))
            )
          )
        )
      )
    (set! (-> self state-time) (current-time))
    (set! (-> self control mod-surface) *board-turn-to-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (set! (-> self control sliding-start-time) arg1)
    (vector-normalize-copy! (-> self control unknown-vector38) arg0 1.0)
    (forward-up-nopitch->quaternion
      (-> self control dir-targ)
      (-> self control unknown-vector38)
      (vector-y-quaternion! (new-stack-vector0) (-> self control dir-targ))
      )
    (set! (-> self control turn-lockout-end-time) (+ (current-time) arg1))
    (none)
    )
  :exit target-board-exit
  :trans (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? 'board)
               )
      (flush-trick-list (-> self board))
      (go target-board-jump (-> *TARGET_BOARD-bank* jump-height-min) (-> *TARGET_BOARD-bank* jump-height-max) #f)
      )
    (if (>= (- (current-time) (-> self state-time)) (-> self control sliding-start-time))
        (go target-board-stance)
        )
    (target-board-anim-trans)
    (when (board-on-ground?)
      (let ((gp-0 (-> self board turn-anim-tilt?)))
        (target-board-ground-check)
        (set! (-> self board turn-anim-tilt?) gp-0)
        )
      )
    (set! (-> self board turn-anim-targ) (* 10.0 (-> self board turn-anim-targ)))
    (none)
    )
  :code (-> target-board-stance code)
  :post target-board-post
  )

(defstate target-board-ride-edge (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('edge-grab 'push-transv 'push-trans)
       #f
       )
      (('end-mode)
       (when (-> event param 0)
         (let ((v1-6 (/ (- (current-time) (-> self board ride-start-time)) 300)))
           (if (> v1-6 0)
               (add-to-trick-list (-> self board) (board-tricks board-rail) (* 100.0 (the float v1-6)))
               )
           )
         )
       (go target-board-turn-to (-> self control transv) (seconds 0.2))
       )
      (else
        (target-board-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ((arg0 symbol) (arg1 object) (arg2 object) (arg3 float))
    (set! (-> self state-time) (current-time))
    (set! (-> self focus-status) (logior (focus-status rail) (-> self focus-status)))
    (logior! (-> self control root-prim prim-core action) (collide-action can-ride))
    (set! (-> self control mod-surface) *board-ride-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((v1-12 (-> self control transv-ctrl)))
      (set! (-> self board ride-speed) (sqrtf (+ (* (-> v1-12 x) (-> v1-12 x)) (* (-> v1-12 z) (-> v1-12 z)))))
      )
    (set! (-> self board ride-lean-targ) 0.0)
    (set! (-> self board ride-lean) 0.0)
    (set! (-> self board ride-leanv) 0.0)
    (set! (-> self board ride-tilt-targ) 0.0)
    (set! (-> self board ride-tilt) 0.0)
    (set! (-> self board ride-tiltv) 0.0)
    (set! (-> self neck flex-blend) 0.0)
    (set! (-> self board spin-control) 0.0)
    (set! (-> self board flip-control) 0.0)
    (set! (-> self board flip-count) 0)
    (set! (-> self board unknown-float00) 0.0)
    (set! (-> self board unknown-float01) 0.0)
    (set! (-> self control unknown-word04) (the-as uint #t))
    (target-board-compute-edge)
    (let ((f0-17 (vector-dot (-> self control c-R-w vector 2) (-> self control edge-grab-edge-dir))))
      (cond
        ((< 0.7 f0-17)
         (set! (-> self board ride-mode) (the-as uint 0))
         (set! (-> self board ride-rot) 0.0)
         )
        ((< f0-17 -0.7)
         (set! (-> self board ride-mode) (the-as uint 1))
         (set! (-> self board ride-rot) 32768.0)
         )
        (else
          (let ((f0-21 (vector-dot (the-as vector (-> self control c-R-w)) (-> self control edge-grab-edge-dir))))
            (cond
              ((< 0.7 f0-21)
               (set! (-> self board ride-mode) (the-as uint 2))
               (set! (-> self board ride-rot) -16384.0)
               )
              (else
                (set! (-> self board ride-mode) (the-as uint 3))
                (set! (-> self board ride-rot) 16384.0)
                )
              )
            )
          )
        )
      )
    (let ((f0-24 0.0))
      (if arg0
          (set! f0-24 (+ 250.0 f0-24))
          )
      (if (and (!= (-> self board ride-rot-old) -1.0) (!= (-> self board ride-rot) (-> self board ride-rot-old)))
          (set! f0-24 (+ 500.0 f0-24))
          )
      (add-to-trick-list (-> self board) (board-tricks board-rail-jump) f0-24)
      )
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self control status) (collide-status probe-hit))
    (let ((v1-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
      (set! (-> v1-2 command) (sound-command set-param))
      (set! (-> v1-2 id) (-> self board ride-sound-id))
      (set! (-> v1-2 params volume) -4)
      (set! (-> v1-2 auto-time) 24)
      (set! (-> v1-2 auto-from) 2)
      (set! (-> v1-2 params mask) (the-as uint 17))
      (-> v1-2 id)
      )
    ((-> target-board-stance exit))
    (set! (-> self neck flex-blend) 1.0)
    (logclear! (-> self focus-status) (focus-status rail))
    (logclear! (-> self control root-prim prim-core action) (collide-action can-ride))
    (set! (-> self board ride-rot-old) (-> self board ride-rot))
    (let ((gp-0 (new 'stack-no-clear 'vector)))
      (set! (-> gp-0 quad) (-> self control trans quad))
      (let ((s5-0 (new 'stack-no-clear 'collide-query)))
        (if (find-ground
              (-> self control)
              s5-0
              (logclear (-> self control root-prim prim-core collide-with) (collide-spec water))
              8192.0
              81920.0
              1024.0
              )
            (set! (-> self control gspot-pat-surfce) (-> s5-0 best-other-tri pat))
            )
        )
      (if (< (-> self control trans y) (-> self control gspot-pos y))
          (set! (-> gp-0 quad) (-> self control gspot-pos quad))
          )
      (move-to-point!
        (-> self control)
        (vector+! (new 'stack-no-clear 'vector) gp-0 (new 'static 'vector :y 204.8 :w 1.0))
        )
      )
    (none)
    )
  :trans (behavior ()
    (when (and (logtest? (logior (logior (-> *cpad-list* cpads (-> self control cpad number) button0-rel 0)
                                         (-> *cpad-list* cpads (-> self control cpad number) button0-rel 1)
                                         )
                                 (-> *cpad-list* cpads (-> self control cpad number) button0-rel 2)
                                 )
                         (pad-buttons x)
                         )
               (can-jump? 'board)
               )
      (let ((v1-15 (/ (- (current-time) (-> self board ride-start-time)) 300)))
        (if (> v1-15 0)
            (add-to-trick-list (-> self board) (board-tricks board-rail) (* 100.0 (the float v1-15)))
            )
        )
      (set! (-> self control trans y) (+ 1228.8 (-> self control trans y)))
      (go
        target-board-jump
        (-> *TARGET_BOARD-bank* jump-height-min)
        (-> *TARGET_BOARD-bank* jump-height-max)
        (the-as symbol *board-ride-jump-mods*)
        )
      )
    (if (cpad-pressed? (-> self control cpad number) circle square)
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    (if (-> self control unknown-spool-anim00)
        (set! (-> self board ride-button-time) (current-time))
        )
    (set! (-> self board turn-anim-targ) (* (-> self board ride-lean) (- (-> *TARGET_BOARD-bank* turn-frames))))
    (cond
      ((= (-> self board ride-speed) 0.0)
       (let ((v1-43 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
         (set! (-> v1-43 command) (sound-command set-param))
         (set! (-> v1-43 id) (-> self board ride-sound-id))
         (set! (-> v1-43 params volume) -4)
         (set! (-> v1-43 auto-time) 24)
         (set! (-> v1-43 auto-from) 2)
         (set! (-> v1-43 params mask) (the-as uint 17))
         (-> v1-43 id)
         )
       )
      (else
        (let ((f30-1
                (* (lerp-scale 0.7 1.0 (fabs (-> self board ride-lean)) 0.0 1.0)
                   (lerp-scale 0.8 1.0 (fabs (-> self board ride-speed)) 0.0 (* 0.5 (-> self control mod-surface transv-max)))
                   )
                )
              (f0-23
                (+ (lerp-scale 0.0 0.05 (fabs (-> self board ride-lean)) 0.0 1.0)
                   (lerp-scale -0.05 0.0 (fabs (-> self board ride-speed)) 0.0 (* 0.3 (-> self control mod-surface transv-max)))
                   )
                )
              )
          (sound-play-by-name
            (static-sound-name "board-rail")
            (-> self board ride-sound-id)
            (the int (* 1024.0 f30-1))
            (the int (* 1524.0 f0-23))
            0
            (sound-group sfx)
            #t
            )
          )
        )
      )
    (when (< 4096.0 (-> self board ride-speed))
      (let ((gp-1 (vector+float*! (new 'stack-no-clear 'vector) (-> self control trans) (-> self board ride-dir) -4096.0))
            )
        (set! (-> *part-id-table* 431 init-specs 1 initial-valuef)
              (lerp-scale 0.1 2.0 (fabs (-> self board ride-speed)) 0.0 (* 0.3 (-> self control mod-surface transv-max)))
              )
        (let ((t9-10 sp-launch-particles-var)
              (a0-42 *sp-particle-system-2d*)
              (a1-12 (-> *part-id-table* 431))
              (a2-9 *launch-matrix*)
              )
          (set! (-> a2-9 trans quad) (-> gp-1 quad))
          (t9-10 a0-42 a1-12 a2-9 (the-as sparticle-launch-state #f) (the-as sparticle-launch-control #f) 1.0)
          )
        )
      )
    (none)
    )
  :code (behavior ((arg0 symbol) (arg1 object) (arg2 object) (arg3 float))
    (let* ((v1-1 (-> self board ride-mode))
           (gp-0 (cond
                   ((zero? v1-1)
                    (-> self draw art-group data 167)
                    )
                   ((= v1-1 1)
                    (-> self draw art-group data 166)
                    )
                   ((= v1-1 2)
                    (-> self draw art-group data 169)
                    )
                   ((= v1-1 3)
                    (-> self draw art-group data 168)
                    )
                   (else
                     (the-as art-element #f)
                     )
                   )
                 )
           )
      (when (!= (ja-group) gp-0)
        (ja-channel-push! 1 (seconds 0.1))
        (set! (-> self skel root-channel 0 frame-group) (the-as art-joint-anim gp-0))
        )
      )
    (until #f
      (ja :num-func num-func-identity
          :frame-num (ja-aframe
            (fmax -5.0 (fmin 5.0 (+ (* 3.0 (-> self board ride-lean))
                                    (* 0.5 (sin (* 145.63556 (the float (- (current-time) (-> self state-time))))))
                                    )
                             )
                  )
            0
            )
          )
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (target-board-ride-post)
    (none)
    )
  )

(defstate target-board-grenade (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('target)
       (handle->process (-> self control unknown-handle02))
       )
      (else
        (target-board-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ((arg0 handle))
    (set! (-> self focus-status) (logior (focus-status halfpipe) (-> self focus-status)))
    (set! (-> self control unknown-handle02) arg0)
    (set! (-> self state-time) (current-time))
    (logior! (-> self control root-prim prim-core action) (collide-action no-normal-reset))
    (set! (-> self control mod-surface) *board-halfpipe-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((v1-12 (new-stack-vector0))
          (f0-1 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-12 (-> self control transv) (vector-float*! v1-12 (-> self control dynam gravity-normal) f0-1))
      (let* ((f1-2 (vector-length v1-12))
             (f2-0 f1-2)
             )
        (if (and (!= f1-2 0.0) (< 2.0 (/ f0-1 f1-2)))
            (set! f1-2 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-1)
          (vector-float*! v1-12 v1-12 (/ f1-2 f2-0))
          )
        )
      )
    (none)
    )
  :exit (behavior ()
    (send-event (handle->process (-> self control unknown-handle02)) 'exit)
    ((-> target-board-halfpipe exit))
    (none)
    )
  :trans (behavior ()
    (set! (-> self board halfpipe-time) (current-time))
    (if (= (-> self control gspot-pat-surfce mode) (pat-mode halfpipe))
        (set! (-> self board halfpipe-gspot-time) (current-time))
        )
    (if (< (- (current-time) (-> self state-time)) (seconds 1))
        (vector+float*!
          (-> self control transv)
          (-> self control transv)
          (-> self control dynam gravity-normal)
          (* 122880.0 (-> self clock seconds-per-frame))
          )
        )
    (when (jump-hit-ground-stuck?)
      (vector-float*! (-> self control transv) (-> self control transv) 1.5)
      (go target-board-turn-to (-> self control transv) (seconds 0.5))
      )
    (when (>= (- (current-time) (-> self board halfpipe-gspot-time)) (seconds 0.5))
      (+! (-> self control transv x) (* 20480.0 (-> self control edge-grab-across-edge-dir x)))
      (+! (-> self control transv z) (* 20480.0 (-> self control edge-grab-across-edge-dir z)))
      (go target-board-stance)
      )
    (none)
    )
  :code (behavior ((arg0 handle))
    (ja-channel-push! 1 (seconds 0.05))
    (ja-no-eval :group! (-> self draw art-group data 172) :num! (seek! (ja-aframe 19.0 0)) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! (ja-aframe 19.0 0)))
      )
    (let ((a1-5 (-> self node-list data 41))
          (s5-2 (new 'stack-no-clear 'projectile-init-by-other-params))
          )
      (let ((a0-7 (handle->process arg0)))
        (set! (-> s5-2 ent) (if a0-7
                                (-> a0-7 entity)
                                )
              )
        )
      (set! (-> s5-2 charge) 0.1)
      (set! (-> s5-2 options) (projectile-options))
      (set! (-> s5-2 notify-handle) (the-as handle #f))
      (set! (-> s5-2 owner-handle) (the-as handle #f))
      (set! (-> s5-2 ignore-handle) (process->handle self))
      (let* ((v1-24 *game-info*)
             (a0-13 (+ (-> v1-24 attack-id) 1))
             )
        (set! (-> v1-24 attack-id) a0-13)
        (set! (-> s5-2 attack-id) a0-13)
        )
      (set! (-> s5-2 timeout) (seconds 4))
      (vector<-cspace! (-> s5-2 pos) a1-5)
      (set! (-> s5-2 vel quad) (-> *zero-vector* quad))
      (spawn-projectile grenade s5-2 self *default-dead-pool*)
      )
    (ja-no-eval :num! (seek!))
    (while (not (ja-done? 0))
      (suspend)
      (ja-eval)
      )
    (sleep-code)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-get-on (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('attack 'attack-or-shove 'attack-invinc)
       (target-attacked
         event-type
         (the-as attack-info (-> event param 1))
         proc
         (the-as touching-shapes-entry (-> event param 0))
         target-hit
         )
       )
      (else
        (target-generic-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ()
    (set! (-> self board shock-offsetv) 0.0)
    (set! (-> self state-time) (current-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control mod-surface) *board-jump-mods*)
    (set! (-> self board mods-backup) (-> self control mod-surface))
    (let ((a0-5 (target-time-to-ground)))
      (cond
        ((logtest? (water-flags touch-water) (-> self water flags))
         (let ((v1-10 (new-stack-vector0)))
           (let ((f0-2 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-10 (-> self control transv) (vector-float*! v1-10 (-> self control dynam gravity-normal) f0-2))
             )
           (let* ((f0-3 (vector-length v1-10))
                  (f1-1 f0-3)
                  (f2-2
                    (+ (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                       (* 0.33 (-> self control dynam gravity-length))
                       )
                    )
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
               (vector-float*! v1-10 v1-10 (/ f0-3 f1-1))
               )
             )
           )
         (set! (-> self control unknown-word04) (the-as uint #t))
         )
        ((< a0-5 (seconds 0.25))
         (let ((v1-12 (new-stack-vector0)))
           (let ((f0-6 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-12 (-> self control transv) (vector-float*! v1-12 (-> self control dynam gravity-normal) f0-6))
             )
           (let* ((f0-7 (vector-length v1-12))
                  (f1-3 f0-7)
                  (f2-5
                    (+ (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                       (* 0.0016666667 (the float (- (seconds 0.66) a0-5)) (-> self control dynam gravity-length))
                       )
                    )
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-5)
               (vector-float*! v1-12 v1-12 (/ f0-7 f1-3))
               )
             )
           )
         (set! (-> self control unknown-word04) (the-as uint #t))
         )
        (else
          (let ((v1-14 (new-stack-vector0)))
            (let ((f0-10 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
              0.0
              (vector-! v1-14 (-> self control transv) (vector-float*! v1-14 (-> self control dynam gravity-normal) f0-10))
              )
            (let* ((f0-11 (vector-length v1-14))
                   (f1-5 f0-11)
                   (f2-7 (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))))
                   )
              (vector+!
                (-> self control transv)
                (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-7)
                (vector-float*! v1-14 v1-14 (/ f0-11 f1-5))
                )
              )
            )
          (set! (-> self control unknown-word04) (the-as uint #f))
          )
        )
      )
    (let ((v1-17 (new-stack-vector0))
          (f0-14 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
          )
      0.0
      (vector-! v1-17 (-> self control transv) (vector-float*! v1-17 (-> self control dynam gravity-normal) f0-14))
      (let* ((f2-8 (vector-length v1-17))
             (f1-8 f2-8)
             )
        (if (< 81920.0 f2-8)
            (set! f2-8 81920.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f0-14)
          (vector-float*! v1-17 v1-17 (/ f2-8 f1-8))
          )
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (none)
    )
  :exit target-board-exit
  :code (behavior ()
    (send-event (ppointer->process (-> self board board)) 'open)
    (ja-channel-push! 1 (the-as time-frame (if (-> self control unknown-spool-anim00)
                                               9
                                               60
                                               )
                                )
                      )
    (let ((f30-1 (if (-> self control unknown-spool-anim00)
                     1.25
                     (fmax 1.0 (fmin 2.0 (/ 249.99 (the float (target-time-to-ground)))))
                     )
                 )
          )
      (ja-no-eval :group! (-> self draw art-group data 170)
                  :num! (seek!
                    (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 170)) frames num-frames) -1))
                    f30-1
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (when (logtest? (-> self control status) (collide-status on-surface))
          (set! (-> self board turn-anim-duck-vel) 0.0)
          (goto cfg-19)
          )
        (suspend)
        (ja :num! (seek! max f30-1))
        )
      )
    (set! (-> self board turn-anim-duck-vel) 15.0)
    (while (not (jump-hit-ground-stuck?))
      (suspend)
      )
    (label cfg-19)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    (logior! (-> self control status) (collide-status on-surface))
    (go target-board-hit-ground)
    (none)
    )
  :post target-board-post
  )

(defstate target-board-pegasus (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('end-mode)
       (go target-jump 16384.0 16384.0 (the-as surface #f))
       )
      (else
        (target-generic-event-handler proc arg1 event-type event)
        )
      )
    )
  :enter (behavior ((arg0 handle))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self board shock-offsetv) 0.0)
    (set! (-> self state-time) (current-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (none)
    )
  :exit target-board-exit
  :code (behavior ((arg0 handle))
    (let ((s4-0 (-> self draw art-group data 195))
          (f30-0 0.0)
          (s5-0 #t)
          )
      (ja-channel-push! 1 (seconds 0.05))
      (set! (-> self control mod-surface) *empty-mods*)
      (set! (-> self neck flex-blend) 0.0)
      (set! (-> self control unknown-vector37 quad) (-> self control trans quad))
      (set! (-> self control unknown-vector39 quad) (-> self control quat quad))
      (ja :group! s4-0
          :num! (seek! (the float (+ (-> (the-as art-joint-anim s4-0) frames num-frames) -1)))
          :frame-num 0.0
          )
      (until #f
        (let* ((s3-0 (handle->process arg0))
               (s4-1 (if (type? s3-0 process-focusable)
                         s3-0
                         )
                     )
               )
          (when s4-1
            (set! (-> self control unknown-vector38 quad) (-> (get-trans (the-as process-focusable s4-1) 0) quad))
            (set! (-> self control unknown-vector38 y) (+ 4096.0 (-> self control unknown-vector38 y)))
            (set! (-> self control unknown-vector40 quad) (-> (get-quat (the-as process-focusable s4-1) 0) quad))
            )
          (let ((f28-0 (sin (lerp-scale 0.0 16384.0 (ja-aframe-num 0) 0.0 30.0))))
            (let ((f26-0 f28-0))
              (vector-lerp!
                (-> self control trans)
                (-> self control unknown-vector37)
                (-> self control unknown-vector38)
                f28-0
                )
              (set! (-> self control trans y)
                    (lerp (-> self control unknown-vector37 y) (-> self control unknown-vector38 y) f26-0)
                    )
              )
            (quaternion-slerp!
              (-> self control quat-for-control)
              (the-as quaternion (-> self control unknown-vector39))
              (the-as quaternion (-> self control unknown-vector40))
              f28-0
              )
            )
          (rot->dir-targ! (-> self control))
          (when s4-1
            (let ((s3-4 self))
              (set! self (the-as target s4-1))
              (set! f30-0 (ja-aframe-num 0))
              f30-0
              (set! self s3-4)
              )
            (ja :num-func num-func-identity :frame-num (ja-aframe f30-0 0))
            )
          )
        (when (and s5-0 (>= f30-0 17.0))
          (send-event (ppointer->process (-> self board board)) 'close)
          (logclear! (-> self focus-status) (focus-status board))
          (set! s5-0 #f)
          )
        (suspend)
        0
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (set! (-> self control bend-speed) 0.0)
    (set! (-> self control bend-target) 0.0)
    (vector-seek! (-> self control draw-offset) *null-vector* (* 16384.0 (-> self clock seconds-per-frame)))
    (target-no-move-post)
    (target-board-effect)
    (none)
    )
  )

(defstate target-board-get-off (target)
  :event (-> target-board-get-on event)
  :enter (behavior ((arg0 object) (arg1 symbol))
    (case arg1
      (('pegasus)
       (go target-board-pegasus (the-as handle arg0))
       )
      )
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self board shock-offsetv) 0.0)
    (set! (-> self state-time) (current-time))
    (logclear! (-> self control status) (collide-status on-surface on-ground touch-surface))
    (set! (-> self control mod-surface) (new 'static 'surface
                                          :name 'jump
                                          :turnv 131072.0
                                          :turnvv 18204.445
                                          :tiltv 131072.0
                                          :tiltvv 262144.0
                                          :transv-max 65536.0
                                          :target-speed 65536.0
                                          :seek0 0.3
                                          :seek90 0.3
                                          :seek180 0.3
                                          :fric 0.05
                                          :nonlin-fric-dist 1.0
                                          :slip-factor 1.0
                                          :slide-factor 1.0
                                          :slope-up-factor 1.0
                                          :slope-down-factor 1.0
                                          :slope-slip-angle 1.0
                                          :impact-fric 1.0
                                          :bend-factor 1.0
                                          :bend-speed 1.0
                                          :alignv 1.0
                                          :slope-up-traction 1.0
                                          :align-speed 1.0
                                          :turnvf 30.0
                                          :turnvvf 30.0
                                          :tiltvf 30.0
                                          :tiltvvf 15.0
                                          :mode 'air
                                          :flags (surface-flag check-edge air)
                                          )
          )
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (let ((a0-6 (target-time-to-ground)))
      (cond
        ((< a0-6 (seconds 0.207))
         (let ((v1-16 (new-stack-vector0)))
           (let ((f0-3 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
             0.0
             (vector-! v1-16 (-> self control transv) (vector-float*! v1-16 (-> self control dynam gravity-normal) f0-3))
             )
           (let* ((f0-4 (vector-length v1-16))
                  (f1-1 f0-4)
                  (f2-2
                    (+ (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
                       (* 0.0016666667 (the float (- (seconds 0.66) a0-6)) (-> self control dynam gravity-length))
                       )
                    )
                  )
             (vector+!
               (-> self control transv)
               (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-2)
               (vector-float*! v1-16 v1-16 (/ f0-4 f1-1))
               )
             )
           )
         (set! (-> self control unknown-word04) (the-as uint #t))
         )
        (else
          (let ((v1-18 (new-stack-vector0)))
            (let ((f0-7 (vector-dot (-> self control dynam gravity-normal) (-> self control transv))))
              0.0
              (vector-! v1-18 (-> self control transv) (vector-float*! v1-18 (-> self control dynam gravity-normal) f0-7))
              )
            (let* ((f0-8 (vector-length v1-18))
                   (f1-3 f0-8)
                   (f2-4 (fmax 0.0 (fmin 40960.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))))
                   )
              (vector+!
                (-> self control transv)
                (vector-float*! (-> self control transv) (-> self control dynam gravity-normal) f2-4)
                (vector-float*! v1-18 v1-18 (/ f0-8 f1-3))
                )
              )
            )
          (set! (-> self control unknown-word04) (the-as uint #f))
          )
        )
      )
    (set! (-> self board slow-transv quad) (-> self control transv quad))
    (none)
    )
  :exit target-board-exit
  :code (behavior ((arg0 object) (arg1 symbol))
    (local-vars (v1-116 symbol) (a0-35 int))
    (let ((f30-0 1.5151515))
      (let ((v1-1 arg1))
        (cond
          ((= v1-1 'hit)
           (ja-channel-push! 1 (seconds 0.1))
           (ja-no-eval :group! (-> self draw art-group data 194) :num! (seek! (ja-aframe 24.0 0) 2.5) :frame-num 0.0)
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek! (ja-aframe 24.0 0) 2.5))
             )
           )
          ((-> self control unknown-spool-anim00)
           (ja-channel-push! 1 (seconds 0.1))
           (ja-no-eval :group! (-> self draw art-group data 191)
                       :num! (seek!
                         (the float (+ (-> (the-as art-joint-anim (-> self draw art-group data 191)) frames num-frames) -1))
                         f30-0
                         )
                       :frame-num 0.0
                       )
           (until (ja-done? 0)
             (suspend)
             (ja :num! (seek! max f30-0))
             )
           (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
           (ja-no-eval :group! (-> self draw art-group data 171) :num! (seek! (ja-aframe 24.0 0) f30-0) :frame-num 0.0)
           (until (ja-done? 0)
             (if (and (jump-hit-ground-stuck?) (>= (ja-aframe-num 0) 14.0))
                 (go target-falling #f)
                 )
             (suspend)
             (ja :num! (seek! (ja-aframe 24.0 0) f30-0))
             )
           )
          (else
            (set! f30-0 (fmax 0.5 (fmin 2.0 (/ 150.0 (the float (target-time-to-ground))))))
            (ja-channel-push! 1 (seconds 0.1))
            (send-event (ppointer->process (-> self sidekick)) 'matrix 'normal)
            (ja-no-eval :group! (-> self draw art-group data 171)
                        :num! (seek! (ja-aframe 24.0 0) f30-0)
                        :frame-num (ja-aframe 11.0 0)
                        )
            (until (ja-done? 0)
              (if (and (jump-hit-ground-stuck?) (>= (ja-aframe-num 0) 14.0))
                  (go target-falling #f)
                  )
              (suspend)
              (ja :num! (seek! (ja-aframe 24.0 0) f30-0))
              )
            )
          )
        )
      (send-event (ppointer->process (-> self board board)) 'close)
      (logclear! (-> self focus-status) (focus-status board))
      (ja-no-eval :num! (seek! max f30-0))
      )
    (while (let ((t9-36 ja-done?))
             (set! a0-35 0)
             (not (t9-36 a0-35))
             )
      (if (jump-hit-ground-stuck?)
          (go target-falling #f)
          )
      (suspend)
      (ja-eval)
      )
    (set! (-> self board turn-anim-duck-vel) 15.0)
    (if (and (board-on-ground?)
             (let ((v1-114 #x100000))
               (set! a0-35 (the-as int (-> self water flags)))
               (not (or (logtest? v1-114 (the-as water-flags a0-35))
                        (begin
                          (let ((v1-117 #t))
                            (set! a0-35 (the-as int (logand (-> self control status) (collide-status on-water))))
                            (set! a0-35 a0-35)
                            (cmove-#f-zero v1-116 (the-as collide-status a0-35) v1-117)
                            )
                          v1-116
                          )
                        )
                    )
               )
             )
        (go target-hit-ground (the-as symbol a0-35))
        (go target-falling (if (= arg1 'hit)
                               'hit
                               )
            )
        )
    (none)
    )
  :post (behavior ()
    (set! (-> self control bend-speed) 0.0)
    (set! (-> self control bend-target) 0.0)
    (vector-seek! (-> self control draw-offset) *null-vector* (* 16384.0 (-> self clock seconds-per-frame)))
    (target-post)
    (target-board-effect)
    (none)
    )
  )

(defstate target-board-grab (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (cond
      ((and (= event-type 'query) (= (-> event param 0) 'mode))
       (-> self state name)
       )
      (else
        (case event-type
          (('end-mode)
           (go target-board-stance)
           )
          (('clone-anim)
           (go target-board-clone-anim (process->handle (the-as process (-> event param 0))))
           )
          (('change-mode)
           (case (-> event param 0)
             (('normal)
              (go target-grab 'stance)
              )
             )
           )
          (else
            (target-generic-event-handler proc arg1 event-type event)
            )
          )
        )
      )
    )
  :enter (behavior ((arg0 symbol))
    (set! (-> self control mod-surface) *grab-mods*)
    (set! (-> self neck flex-blend) 0.0)
    (logior! (-> self state-flags) (state-flags sf2))
    (logior! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self board stick-off) #t)
    (none)
    )
  :exit (behavior ()
    (set! (-> self board stick-off) #f)
    (logclear! (-> self state-flags) (state-flags sf2))
    (logclear! (-> self focus-status) (focus-status grabbed))
    (logclear! (-> self water flags) (water-flags jump-out))
    (target-board-exit)
    (none)
    )
  :code (behavior ((arg0 symbol))
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 (-> self draw art-group data 151))))
        (ja-channel-push! 1 (seconds 0.1))
        (ja :group! (-> self draw art-group data 151) :num! (identity (ja-aframe 0.0 0)))
        )
      )
    (until #f
      (set-forward-vel 0.0)
      (suspend)
      )
    #f
    (none)
    )
  :post target-board-post
  )

(defstate target-board-clone-anim (target)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (if (and (= event-type 'trans) (= (-> event param 0) 'restore))
        (set! (-> self control unknown-word04) (the-as uint #f))
        )
    ((-> target-board-grab event) proc arg1 event-type event)
    )
  :enter (-> target-clone-anim enter)
  :exit (behavior ()
    (set! (-> self control draw-offset y) (the-as float (-> self control unknown-word04)))
    (set! (-> self control cspace-offset y) (-> self control draw-offset y))
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'board)
    ((-> target-clone-anim exit))
    ((-> target-board-start exit))
    (vector-reset! (-> self control transv))
    (none)
    )
  :code (behavior ((arg0 handle))
    (set! (-> self control unknown-word04) (the-as uint (-> self control draw-offset y)))
    (set! (-> self control draw-offset y) 0.0)
    (send-event (ppointer->process (-> self sidekick)) 'matrix 'play-anim)
    (clone-anim arg0 #t "")
    (go target-board-stance)
    (none)
    )
  :post target-no-ja-move-post
  )

(defstate target-board-hit (target)
  :event target-board-handler
  :exit (behavior ()
    (when (not (and (-> self next-state) (let ((v1-3 (-> self next-state name)))
                                           (or (= v1-3 'target-death) (= v1-3 'target-board-get-off))
                                           )
                    )
               )
      (logclear! (-> self focus-status) (focus-status dead hit))
      (logclear! (-> self state-flags) (state-flags disable-attacks))
      )
    (let ((gp-1 (focus-test? self hit)))
      (target-exit)
      (if gp-1
          (logior! (-> self focus-status) (focus-status hit))
          )
      )
    (set! (-> self state-flags) (logior (state-flags lleg-no-ik rleg-no-ik) (-> self state-flags)))
    (target-board-exit)
    (none)
    )
  :trans (behavior ()
    (when (= *cheat-mode* 'debug)
      (when (and (not *pause-lock*) (cpad-hold? (-> self control cpad number) r2))
        (set! (-> self control time-of-last-debug-heal) (current-time))
        (pickup-collectable! (-> self fact-override) (pickup-type health) 100.0 (the-as handle #f))
        (go target-board-stance)
        )
      )
    (none)
    )
  :code (behavior ((arg0 vector) (arg1 attack-info))
    (logclear! (-> self water flags) (water-flags jump-out))
    (logclear! (-> self focus-status) (focus-status halfpipe))
    (set! (-> self state-time) (current-time))
    (let ((gp-0 (-> self attack-info)))
      (let ((s5-0 (new 'stack-no-clear 'vector)))
        (let ((v1-6 gp-0))
          (set! (-> v1-6 attacker) (the-as handle #f))
          (set! (-> v1-6 mode) 'generic)
          (set! (-> v1-6 shove-back) 6144.0)
          (set! (-> v1-6 shove-up) 4915.2)
          (set! (-> v1-6 angle) #f)
          (set! (-> v1-6 trans quad) (-> self control trans quad))
          (set! (-> v1-6 control) 0.0)
          (set! (-> v1-6 invinc-time) (the-as time-frame (-> *TARGET-bank* hit-invulnerable-timeout)))
          (set! (-> v1-6 speed) 1.0)
          (set! (-> v1-6 damage) (-> *FACT-bank* health-default-inc))
          (set! (-> v1-6 knock) (the-as uint 0))
          )
        (case arg0
          (('shove)
           (let ((v1-9 gp-0))
             (set! (-> v1-9 shove-back) (-> *TARGET-bank* smack-surface-dist))
             (set! (-> v1-9 shove-up) (-> *TARGET-bank* smack-surface-height))
             (set! (-> v1-9 angle) 'shove)
             )
           )
          )
        (combine! gp-0 arg1 self)
        (when (not (logtest? (-> gp-0 mask) (attack-info-mask vector)))
          (vector-z-quaternion! (-> gp-0 vector) (-> self control quat-for-control))
          (vector-xz-normalize! (-> gp-0 vector) (- (fabs (-> gp-0 shove-back))))
          (set! (-> gp-0 vector y) (-> gp-0 shove-up))
          )
        (set! (-> s5-0 quad) (-> gp-0 vector quad))
        (let ((f0-12 (vector-dot
                       (vector-normalize-copy! (new 'stack-no-clear 'vector) s5-0 1.0)
                       (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> self control quat-for-control))
                       )
                     )
              )
          (if (not (-> self attack-info angle))
              (set! (-> self attack-info angle) (if (>= 0.0 f0-12)
                                                    'front
                                                    'back
                                                    )
                    )
              )
          )
        (cond
          ((= arg0 'attack)
           (logior! (-> self focus-status) (focus-status hit))
           (set! (-> self game hit-time) (current-time))
           (case (-> gp-0 mode)
             (('endlessfall)
              (cond
                ((= (-> self game mode) 'debug)
                 (let ((s4-1 (new-stack-vector0)))
                   (set! (-> s4-1 quad) (-> self control last-trans-on-ground quad))
                   (ja-channel-set! 0)
                   (let ((s3-1 (current-time)))
                     (until (>= (- (current-time) s3-1) (seconds 1))
                       (suspend)
                       )
                     )
                   (move-to-point! (-> self control) s4-1)
                   )
                 (set! (-> self control camera-pos quad) (-> self control trans quad))
                 (send-event *camera* 'teleport)
                 (go target-stance)
                 )
                (else
                  (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
                  (go target-death (-> gp-0 mode))
                  )
                )
              )
             (('drown-death 'sharkey 'lava 'dark-eco-pool 'melt 'instant-death 'crush 'death 'grenade 'big-explosion 'bot)
              (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
              (if (= (-> self game mode) 'play)
                  (go target-death (-> gp-0 mode))
                  )
              )
             (('death)
              (pickup-collectable! (-> self fact-override) (pickup-type health) -1000.0 (the-as handle #f))
              )
             (else
               (pickup-collectable! (-> self fact-override) (pickup-type health) (- (-> gp-0 damage)) (the-as handle #f))
               )
             )
           (target-hit-effect gp-0)
           )
          (else
            (case (-> gp-0 mode)
              (('burn 'burnup)
               (sound-play "get-burned")
               )
              )
            )
          )
        (when (not (and (= (-> self game mode) 'play) (>= 0.0 (-> (the-as fact-info-target (-> self fact-override)) health)))
                   )
          (when (= (-> gp-0 knock) 8)
            (set-quaternion! (-> self control) (-> self control dir-targ))
            (set-forward-vel (* -3.0 (-> gp-0 shove-back)))
            (when (demo?)
              (if (nonzero? (talker-spawn-func (-> *talker-speech* 78) *entity-pool* (target-pos 0) (the-as region #f)))
                  (hide-hud-quick #f)
                  )
              )
            (go target-board-get-off #f 'hit)
            )
          (if (= (-> gp-0 control) 1.0)
              (go target-board-jump (-> gp-0 shove-up) (-> gp-0 shove-up) 'hit)
              )
          )
        (set! (-> self control mod-surface) *smack-mods*)
        (let ((v1-92 (ja-group)))
          (when (not (and v1-92 (or (= v1-92 (-> self draw art-group data 158)) (= v1-92 (-> self draw art-group data 165)))))
            (ja-channel-push! 1 (seconds 0.075))
            (if (or (= (-> gp-0 mode) 'shock) (= (-> gp-0 mode) 'shock-red) (= (-> gp-0 mode) 'shockup))
                (ja :group! (-> self draw art-group data 189) :num! min)
                (ja :group! (-> self draw art-group data 158) :num! min)
                )
            )
          )
        (target-hit-move gp-0 (target-hit-orient gp-0 s5-0) target-board-falling-anim-trans (-> gp-0 speed))
        )
      (if (and (= (-> self game mode) 'play) (>= 0.0 (-> (the-as fact-info-target (-> self fact-override)) health)))
          (go target-death (-> gp-0 mode))
          )
      )
    enter-state
    (go target-board-hit-ground)
    (none)
    )
  :post (behavior ()
    (set! (-> self control dynam gravity-max) (-> self control standard-dynamics gravity-max))
    (set! (-> self control dynam gravity-length) (-> self control standard-dynamics gravity-length))
    (vector-float*!
      (-> self control dynam gravity)
      (-> self control dynam gravity-normal)
      (the-as float (-> self control dynam gravity-length))
      )
    (target-post)
    (target-board-effect)
    (case (-> self attack-info mode)
      (('shock 'shock-red 'shockup)
       (when (>= (- (-> *display* game-clock frame-counter) (-> self shock-effect-time)) (seconds 0.03))
         (set! (-> self shock-effect-time) (-> *display* game-clock frame-counter))
         (send-event self 'color-effect 'shock 60)
         (process-drawable-shock-effect
           self
           (-> *lightning-spec-id-table* 1)
           lightning-probe-callback
           (-> *part-id-table* 166)
           0
           0
           40960.0
           )
         )
       )
      )
    (target-board-joint-points)
    (none)
    )
  )
