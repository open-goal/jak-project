;;-*-Lisp-*-
(in-package goal)

;; name: target-util.gc
;; name in dgo: target-util
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(defskelgroup skel-jchar jakb jakb-lod0-jg -1
              ((jakb-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jakb-shadow-mg
              :texture-level 6
              :sort 1
              :origin-joint-index 3
              :shadow-joint-index 3
              )

(define *target-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags disable-fade)
                                           :shadow-dir (new 'static 'vector :x -0.4226 :y -0.9063 :w 409600.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 37683.2)
                                           :top-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           )
                               )
  )

(defskelgroup skel-jak-highres jak-highres jak-highres-lod0-jg -1
              ((jak-highres-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 3.2)
              :longest-edge (meters 1)
              :shadow jak-highres-shadow-mg
              :sort 1
              :origin-joint-index 3
              :shadow-joint-index 3
              )

(defskelgroup skel-generic-blast collectables collectables-generic-blast-lod0-jg collectables-generic-blast-idle-ja
              ((collectables-generic-blast-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              :texture-level 6
              :sort 4
              )

(defskelgroup skel-generic-ripples collectables collectables-generic-ripples-lod0-jg collectables-generic-ripples-idle-ja
              ((collectables-generic-ripples-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 6)
              :texture-level 6
              :sort 4
              )

(defskelgroup skel-bomb-blast collectables collectables-bomb-blast-lod0-jg collectables-bomb-blast-idle-ja
              ((collectables-bomb-blast-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 50)
              :texture-level 6
              :sort 4
              )

(deftype target-bank (basic)
  ((jump-collide-offset              meters          :offset-assert   4)
   (jump-height-min                  meters          :offset-assert   8)
   (jump-height-max                  meters          :offset-assert  12)
   (double-jump-height-min           meters          :offset-assert  16)
   (double-jump-height-max           meters          :offset-assert  20)
   (flip-jump-height-min             meters          :offset-assert  24)
   (flip-jump-height-max             meters          :offset-assert  28)
   (duck-jump-height-min             meters          :offset-assert  32)
   (duck-jump-height-max             meters          :offset-assert  36)
   (flop-jump-height-min             meters          :offset-assert  40)
   (flop-jump-height-max             meters          :offset-assert  44)
   (attack-jump-height-min           meters          :offset-assert  48)
   (attack-jump-height-max           meters          :offset-assert  52)
   (edge-grab-jump-height-min        meters          :offset-assert  56)
   (edge-grab-jump-height-max        meters          :offset-assert  60)
   (swim-jump-height-min             meters          :offset-assert  64)
   (swim-jump-height-max             meters          :offset-assert  68)
   (tube-jump-height-min             meters          :offset-assert  72)
   (tube-jump-height-max             meters          :offset-assert  76)
   (carry-jump-height-min            meters          :offset-assert  80)
   (carry-jump-height-max            meters          :offset-assert  84)
   (mech-jump-height-min             meters          :offset-assert  88)
   (mech-jump-height-max             meters          :offset-assert  92)
   (mech-carry-jump-height-min       meters          :offset-assert  96)
   (mech-carry-jump-height-max       meters          :offset-assert 100)
   (indax-jump-height-min            meters          :offset-assert 104)
   (indax-jump-height-max            meters          :offset-assert 108)
   (indax-double-jump-height-min     meters          :offset-assert 112)
   (indax-double-jump-height-max     meters          :offset-assert 116)
   (roll-duration                    uint64          :offset-assert 120)
   (roll-jump-pre-window             uint64          :offset-assert 128)
   (roll-jump-post-window            uint64          :offset-assert 136)
   (roll-timeout                     uint64          :offset-assert 144)
   (roll-speed-min                   meters          :offset-assert 152)
   (roll-speed-inc                   meters          :offset-assert 156)
   (roll-flip-duration               uint64          :offset-assert 160)
   (roll-flip-height                 meters          :offset-assert 168)
   (roll-flip-dist                   meters          :offset-assert 172)
   (roll-flip-art-height             meters          :offset-assert 176)
   (roll-flip-art-dist               meters          :offset-assert 180)
   (duck-slide-distance              meters          :offset-assert 184)
   (fall-far                         meters          :offset-assert 188)
   (fall-far-inc                     meters          :offset-assert 192)
   (attack-timeout                   uint64          :offset-assert 200)
   (ground-timeout                   uint64          :offset-assert 208)
   (slide-down-timeout               uint64          :offset-assert 216)
   (fall-timeout                     uint64          :offset-assert 224)
   (fall-stumble-threshold           meters          :offset-assert 232)
   (yellow-projectile-speed          meters          :offset-assert 236)
   (hit-invulnerable-timeout         uint64          :offset-assert 240)
   (same-attack-invulnerable-timeout uint64          :offset-assert 248)
   (run-cycle-length                 float           :offset-assert 256)
   (walk-cycle-dist                  meters          :offset-assert 260)
   (walk-up-cycle-dist               meters          :offset-assert 264)
   (walk-down-cycle-dist             meters          :offset-assert 268)
   (walk-side-cycle-dist             meters          :offset-assert 272)
   (run-cycle-dist                   meters          :offset-assert 276)
   (run-up-cycle-dist                meters          :offset-assert 280)
   (run-down-cycle-dist              meters          :offset-assert 284)
   (run-side-cycle-dist              meters          :offset-assert 288)
   (run-wall-cycle-dist              meters          :offset-assert 292)
   (duck-walk-cycle-dist             meters          :offset-assert 296)
   (wade-shallow-walk-cycle-dist     meters          :offset-assert 300)
   (wade-deep-walk-cycle-dist        meters          :offset-assert 304)
   (mech-walk-cycle-dist             meters          :offset-assert 308)
   (mech-run-cycle-dist              meters          :offset-assert 312)
   (smack-surface-dist               meters          :offset-assert 316)
   (smack-surface-height             meters          :offset-assert 320)
   (min-dive-depth                   meters          :offset-assert 324)
   (root-radius                      meters          :offset-assert 328)
   (root-offset                      vector  :inline :offset-assert 336)
   (body-radius                      meters          :offset-assert 352)
   (edge-radius                      meters          :offset-assert 356)
   (edge-offset                      vector  :inline :offset-assert 368)
   (edge-grab-height-off-ground      meters          :offset-assert 384)
   (head-radius                      meters          :offset-assert 388)
   (head-height                      meters          :offset-assert 392)
   (head-offset                      vector  :inline :offset-assert 400)
   (spin-radius                      meters          :offset-assert 416)
   (spin-offset                      vector  :inline :offset-assert 432)
   (duck-spin-radius                 meters          :offset-assert 448)
   (duck-spin-offset                 vector  :inline :offset-assert 464)
   (punch-radius                     meters          :offset-assert 480)
   (punch-offset                     vector  :inline :offset-assert 496)
   (uppercut-radius                  meters          :offset-assert 512)
   (uppercut0-offset                 vector  :inline :offset-assert 528)
   (uppercut1-offset                 vector  :inline :offset-assert 544)
   (flop-radius                      meters          :offset-assert 560)
   (flop0-offset                     vector  :inline :offset-assert 576)
   (flop1-offset                     vector  :inline :offset-assert 592)
   (stuck-time                       seconds         :offset-assert 608)
   (stuck-timeout                    seconds         :offset-assert 616)
   (stuck-distance                   meters          :offset-assert 624)
   (tongue-pull-speed-min            float           :offset-assert 628)
   (tongue-pull-speed-max            float           :offset-assert 632)
   (yellow-attack-timeout            uint64          :offset-assert 640)
   (fall-height                      meters          :offset-assert 648)
   (mech-jump-thrust-fuel            float           :offset-assert 652)
   (strafe-jump-pre-window           uint64          :offset-assert 656)
   (strafe-jump                      basic           :offset-assert 664)
   (strafe-duck-jump                 basic           :offset-assert 668)
   (dark-jump-height-min             meters          :offset-assert 672)
   (dark-jump-height-max             meters          :offset-assert 676)
   )
  :method-count-assert 9
  :size-assert         #x2a8
  :flag-assert         #x9000002a8
  )


(define *TARGET-bank* (new 'static 'target-bank
                        :jump-collide-offset (meters 0.7)
                        :jump-height-min (meters 1.01)
                        :jump-height-max (meters 3.5)
                        :double-jump-height-min (meters 1)
                        :double-jump-height-max (meters 2.5)
                        :flip-jump-height-min (meters 5)
                        :flip-jump-height-max (meters 7)
                        :duck-jump-height-min (meters 7)
                        :duck-jump-height-max (meters 7)
                        :flop-jump-height-min (meters 5)
                        :flop-jump-height-max (meters 7)
                        :attack-jump-height-min (meters 5)
                        :attack-jump-height-max (meters 6.5)
                        :edge-grab-jump-height-min (meters 1.7)
                        :edge-grab-jump-height-max (meters 1.7)
                        :swim-jump-height-min (meters 5)
                        :swim-jump-height-max (meters 5)
                        :tube-jump-height-min (meters 1.75)
                        :tube-jump-height-max (meters 2.5)
                        :carry-jump-height-min (meters 1.75)
                        :carry-jump-height-max (meters 2)
                        :mech-jump-height-min (meters 1.5)
                        :mech-jump-height-max (meters 1.5)
                        :mech-carry-jump-height-min (meters 2.5)
                        :mech-carry-jump-height-max (meters 3)
                        :indax-jump-height-min (meters 1.01)
                        :indax-jump-height-max (meters 3.5)
                        :indax-double-jump-height-min (meters 1)
                        :indax-double-jump-height-max (meters 2.5)
                        :roll-duration #x96
                        :roll-jump-pre-window #x12c
                        :roll-jump-post-window #x1e
                        :roll-speed-min (meters 11.5)
                        :roll-speed-inc (meters 1.5)
                        :roll-flip-duration #xd2
                        :roll-flip-height (meters 3.52)
                        :roll-flip-dist (meters 17.3)
                        :roll-flip-art-height (meters 3.2969)
                        :roll-flip-art-dist (meters 12.5)
                        :duck-slide-distance (meters 5.75)
                        :fall-far (meters 30)
                        :fall-far-inc (meters 20)
                        :attack-timeout #x5a
                        :ground-timeout #x3c
                        :slide-down-timeout #x3c
                        :fall-timeout #x12c
                        :fall-stumble-threshold (meters 39.9)
                        :yellow-projectile-speed (meters 60)
                        :hit-invulnerable-timeout #x12c
                        :same-attack-invulnerable-timeout #x258
                        :run-cycle-length 60.0
                        :walk-cycle-dist (meters 2.8)
                        :walk-up-cycle-dist (meters 2.8)
                        :walk-down-cycle-dist (meters 2.8)
                        :walk-side-cycle-dist (meters 2.8)
                        :run-cycle-dist (meters 6.25)
                        :run-up-cycle-dist (meters 5)
                        :run-down-cycle-dist (meters 5)
                        :run-side-cycle-dist (meters 6.25)
                        :run-wall-cycle-dist (meters 2.8)
                        :duck-walk-cycle-dist (meters 3.25)
                        :wade-shallow-walk-cycle-dist (meters 6)
                        :wade-deep-walk-cycle-dist (meters 6)
                        :mech-walk-cycle-dist (meters 4)
                        :mech-run-cycle-dist (meters 8)
                        :smack-surface-dist (meters 1.25)
                        :min-dive-depth (meters 2)
                        :root-radius (meters 2.2)
                        :root-offset (new 'static 'vector :y 4915.2 :w 1.0)
                        :body-radius (meters 0.7)
                        :edge-radius (meters 0.35)
                        :edge-offset (new 'static 'vector :y 4915.2 :z 4096.0 :w 1.0)
                        :edge-grab-height-off-ground (meters 2.3)
                        :head-radius (meters 0.7)
                        :head-height (meters 1.4)
                        :head-offset (new 'static 'vector :y 4915.2 :w 1.0)
                        :spin-radius (meters 2.2)
                        :spin-offset (new 'static 'vector :y 6553.6 :w 1.0)
                        :duck-spin-radius (meters 1.2)
                        :duck-spin-offset (new 'static 'vector :y 4096.0 :w 1.0)
                        :punch-radius (meters 1.3)
                        :punch-offset (new 'static 'vector :y 5324.8 :w 1.0)
                        :uppercut-radius (meters 1)
                        :uppercut0-offset (new 'static 'vector :y 3276.8 :w 1.0)
                        :uppercut1-offset (new 'static 'vector :y 9011.2 :w 1.0)
                        :flop-radius (meters 1.4)
                        :flop0-offset (new 'static 'vector :y 3276.8 :w 1.0)
                        :flop1-offset (new 'static 'vector :y 9011.2 :w 1.0)
                        :stuck-time (seconds 0.3)
                        :stuck-timeout (seconds 2)
                        :stuck-distance (meters 0.05)
                        :tongue-pull-speed-min 0.15
                        :tongue-pull-speed-max 0.22
                        :yellow-attack-timeout #x3c
                        :fall-height (meters 1)
                        :mech-jump-thrust-fuel 900.0
                        :strafe-jump-pre-window #x96
                        :strafe-jump #f
                        :strafe-duck-jump #f
                        :dark-jump-height-min (meters 20.5)
                        :dark-jump-height-max (meters 20.5)
                        )
        )

(defbehavior target-start-attack target ()
  (let* ((v1-0 *game-info*)
         (a0-1 (+ (-> v1-0 attack-id) 1))
         )
    (set! (-> v1-0 attack-id) a0-1)
    (set! (-> self control target-attack-id) a0-1)
    )
  (set! (-> self control attack-count) (the-as uint 0))
  (set! (-> self control bomb-scale) 0.0)
  (+! (-> self anim-seed) 1)
  0
  (none)
  )

(defbehavior target-danger-set! target ((arg0 symbol) (arg1 symbol))
  (let ((s4-0 (-> self control collision-spheres 6))
        (s5-0 (-> self control collision-spheres 7))
        (gp-0 (-> self control collision-spheres 8))
        )
    (let* ((s2-0 (-> self control collision-spheres 9))
           (v1-4 arg1)
           (f30-0 (if (or (= v1-4 'cone) (= v1-4 'eco-red))
                      2.0
                      1.0
                      )
                  )
           )
      (if (and (focus-test? self dark) (and (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 32)))
          (set! f30-0 1.0)
          )
      (set! (-> self control penetrate-using) (penetrate touch))
      (set! (-> self control penetrated-by) (penetrate lunge))
      (sphere<-vector+r!
        (the-as sphere (-> self control root-prim local-sphere))
        (-> *TARGET-bank* root-offset)
        (-> *TARGET-bank* root-radius)
        )
      (set! (-> self control danger-mode) arg0)
      (logclear! (-> self focus-status) (focus-status dangerous))
      (set! (-> s4-0 transform-index) -2)
      (set! (-> s4-0 prim-core collide-as) (collide-spec))
      (set! (-> s4-0 prim-core collide-with) (collide-spec))
      (set! (-> s4-0 local-sphere w) 0.0)
      (set! (-> s5-0 transform-index) -2)
      (set! (-> s5-0 prim-core collide-as) (collide-spec))
      (set! (-> s5-0 prim-core collide-with) (collide-spec))
      (set! (-> s5-0 local-sphere w) 0.0)
      (set! (-> gp-0 transform-index) -2)
      (set! (-> gp-0 prim-core collide-as) (collide-spec))
      (set! (-> gp-0 prim-core collide-with) (collide-spec))
      (set! (-> gp-0 local-sphere w) 0.0)
      (set! (-> s2-0 transform-index) -2)
      (set! (-> s2-0 prim-core collide-as) (collide-spec))
      (set! (-> s2-0 prim-core collide-with) (collide-spec))
      (set! (-> s2-0 local-sphere w) 0.0)
      (case arg0
        (('harmless #f)
         (set! (-> self control danger-mode) #f)
         (target-collide-set! (-> self control collide-mode) (-> self control collide-mode-transition))
         )
        (('carry?)
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* spin-offset)
           (+ 8192.0 (-> *TARGET-bank* spin-radius))
           )
         (set! (-> self control root-prim local-sphere quad) (-> s4-0 local-sphere quad))
         )
        (('spin 'spin-air)
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (new 'static 'vector :y 6553.6 :w 1.0)
           9830.4
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* spin-offset)
           (-> *TARGET-bank* spin-radius)
           )
         (set! (-> self control penetrate-using) (penetrate touch spin))
         )
        (('board-spin)
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (new 'static 'vector :y 6553.6 :w 1.0)
           9830.4
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s4-0 local-sphere)) (-> *TARGET-bank* spin-offset) 6963.2)
         (set! (-> self control penetrate-using) (penetrate touch spin board))
         )
        (('duck-spin)
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (new 'static 'vector :y 6553.6 :w 1.0)
           10649.6
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* duck-spin-offset)
           (-> *TARGET-bank* duck-spin-radius)
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
         (set! (-> s5-0 transform-index) 35)
         (set! (-> self control penetrate-using) (penetrate touch spin))
         )
        (('duck-slide)
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* duck-spin-offset)
           (-> *TARGET-bank* duck-spin-radius)
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
         (set! (-> s5-0 transform-index) 28)
         (set! (-> self control penetrate-using) (penetrate touch punch))
         )
        (('roll-solid)
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* duck-spin-offset)
           (+ 819.2 (-> *TARGET-bank* duck-spin-radius))
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
         (set! (-> s5-0 transform-index) 8)
         (set! (-> self control danger-mode) 'roll)
         (set! (-> self control penetrate-using) (penetrate touch roll))
         )
        (('flip)
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* duck-spin-offset)
           (+ 819.2 (-> *TARGET-bank* duck-spin-radius))
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* duck-spin-radius))
         (set! (-> s5-0 transform-index) 8)
         (set! (-> self control danger-mode) 'flip)
         (set! (-> self control penetrate-using) (penetrate touch roll))
         )
        (('punch)
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (new 'static 'vector :y 6553.6 :w 1.0)
           11878.4
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* punch-offset)
           (-> *TARGET-bank* punch-radius)
           )
         (when (not (focus-test? self indax))
           (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
           (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
           (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* punch-radius))
           (set! (-> s5-0 transform-index) 21)
           )
         (set! (-> self control penetrate-using) (penetrate touch punch))
         (if (and (focus-test? self dark) (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 2))
             (set! (-> self control penetrate-using) (logior (penetrate dark-punch) (-> self control penetrate-using)))
             )
         )
        (('uppercut)
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (new 'static 'vector :y 6553.6 :w 1.0)
           11878.4
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* uppercut0-offset)
           (-> *TARGET-bank* uppercut-radius)
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r! (the-as sphere (-> s5-0 local-sphere)) *null-vector* (-> *TARGET-bank* uppercut-radius))
         (set! (-> s5-0 transform-index) 21)
         (set! (-> gp-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> gp-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 local-sphere))
           (-> *TARGET-bank* uppercut1-offset)
           (-> *TARGET-bank* uppercut-radius)
           )
         (set! (-> self control penetrate-using) (penetrate touch uppercut))
         )
        (('flop)
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* flop0-offset)
           (-> *TARGET-bank* flop-radius)
           )
         (set! f30-0 1.0)
         (set! (-> self control danger-mode) 'flop)
         (set! (-> self control penetrate-using) (penetrate touch flop))
         )
        (('flop-down)
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* flop0-offset)
           (-> *TARGET-bank* flop-radius)
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s5-0 local-sphere))
           (-> *TARGET-bank* flop1-offset)
           (-> *TARGET-bank* flop-radius)
           )
         (if (!= f30-0 1.0)
             (set! f30-0 2.1)
             )
         (set! (-> self control danger-mode) 'flop)
         (set! (-> self control penetrate-using) (penetrate touch flop))
         )
        (('flut-attack)
         (sphere<-vector+r!
           (the-as sphere (-> self control root-prim local-sphere))
           (new 'static 'vector :y 6553.6 :w 1.0)
           12288.0
           )
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s4-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s4-0 local-sphere))
           (-> *TARGET-bank* spin-offset)
           (+ 2048.0 (-> *TARGET-bank* punch-radius))
           )
         (set! (-> s5-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
         (set! (-> s5-0 prim-core collide-with) (-> self control default-collide-with-fgnd))
         (sphere<-vector+r!
           (the-as sphere (-> s5-0 local-sphere))
           *null-vector*
           (+ 1228.8 (-> *TARGET-bank* punch-radius))
           )
         (set! (-> s5-0 transform-index) 8)
         (set! (-> self control penetrate-using) (penetrate touch flut-attack))
         )
        (('mech-punch)
         (logior! (-> self focus-status) (focus-status dangerous))
         (set! (-> self control penetrate-using) (penetrate touch mech))
         )
        (('bomb)
         (let* ((f0-32 (-> self control bomb-scale))
                (f28-0 (lerp-scale (-> *TARGET-bank* root-radius) 122880.0 f0-32 0.0 1.0))
                )
           (sphere<-vector+r!
             (the-as sphere (-> self control root-prim local-sphere))
             (-> *TARGET-bank* root-offset)
             f28-0
             )
           (logior! (-> self focus-status) (focus-status dangerous))
           (set! (-> s4-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
           (set! (-> s4-0 prim-core collide-with)
                 (logclear (-> self control default-collide-with-fgnd) (collide-spec collectable))
                 )
           (sphere<-vector+r! (the-as sphere (-> s4-0 local-sphere)) (-> *TARGET-bank* root-offset) f28-0)
           )
         (set! (-> self control penetrate-using) (penetrate touch dark-bomb))
         )
        (else
          (format 0 "ERROR: ~A unknown danger mode ~A" self arg0)
          )
        )
      (when (= arg1 'cone)
        (let ((f28-1 16384.0))
          (sphere<-vector+r!
            (the-as sphere (-> self control root-prim local-sphere))
            (-> *TARGET-bank* root-offset)
            (+ (-> *TARGET-bank* root-radius) (* 2.0 f28-1))
            )
          (logior! (-> self focus-status) (focus-status dangerous))
          (set! (-> s2-0 prim-core collide-as) (-> self control default-collide-as-fgnd))
          (set! (-> s2-0 prim-core collide-with)
                (logclear (-> self control default-collide-with-fgnd) (collide-spec collectable))
                )
          (set! (-> s2-0 transform-index) 0)
          (sphere<-vector+r!
            (the-as sphere (-> s2-0 local-sphere))
            (new 'static 'vector :y 12288.0 :z 16384.0 :w 1.0)
            f28-1
            )
          )
        (set! (-> self control penetrate-using) (penetrate touch dark-bomb))
        )
      (when (and (!= f30-0 1.0) (not (or (= arg0 'harmless) (= arg0 #f))))
        (set! (-> self control root-prim local-sphere w) (* (-> self control root-prim local-sphere w) f30-0))
        (set! (-> s4-0 local-sphere w) (* (-> s4-0 local-sphere w) f30-0))
        (set! (-> s5-0 local-sphere w) (* (-> s5-0 local-sphere w) f30-0))
        (set! (-> gp-0 local-sphere w) (* (-> gp-0 local-sphere w) f30-0))
        )
      )
    (when (and (focus-test? self dark) (nonzero? (-> self darkjak)))
      (set! (-> self control penetrate-using) (logior (penetrate dark-skin) (-> self control penetrate-using)))
      (when (and (focus-test? self dark) (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 32))
        (set! (-> self control penetrate-using) (logior (penetrate dark-giant) (-> self control penetrate-using)))
        (let ((f0-46 (lerp-scale 1.0 (-> self darkjak-giant-interp) (-> self darkjak-interp) 0.0 1.0)))
          (set! (-> self control root-prim local-sphere w) (* (-> self control root-prim local-sphere w) f0-46))
          (set! (-> self control root-prim local-sphere y) (* (-> self control root-prim local-sphere y) f0-46))
          (set! (-> s4-0 local-sphere w) (* (-> s4-0 local-sphere w) f0-46))
          (set! (-> s4-0 local-sphere y) (* (-> s4-0 local-sphere y) f0-46))
          (set! (-> s5-0 local-sphere w) (* (-> s5-0 local-sphere w) f0-46))
          (set! (-> s5-0 local-sphere y) (* (-> s5-0 local-sphere y) f0-46))
          (set! (-> gp-0 local-sphere w) (* (-> gp-0 local-sphere w) f0-46))
          (set! (-> gp-0 local-sphere y) (* (-> gp-0 local-sphere y) f0-46))
          )
        )
      )
    )
  (case (-> (the-as fact-info-target (-> self fact-override)) eco-type)
    ((1)
     (set! (-> self control penetrate-using) (logior (penetrate eco-yellow) (-> self control penetrate-using)))
     )
    ((2)
     (set! (-> self control penetrate-using) (logior (penetrate eco-red) (-> self control penetrate-using)))
     )
    ((3)
     (set! (-> self control penetrate-using) (logior (penetrate eco-blue) (-> self control penetrate-using)))
     )
    ((5)
     (set! (-> self control penetrate-using)
           (the-as penetrate (logior (penetrate eco-green) (-> self control penetrate-using)))
           )
     )
    )
  (none)
  )

(defbehavior target-collide-set! target ((arg0 symbol) (arg1 float))
  (let ((gp-0 (-> self control)))
    (if (and (= arg0 'normal)
             (enabled-gun? self)
             (not (logtest? (-> self control current-surface flags) (surface-flag duck)))
             )
        (set! arg0 'gun)
        )
    (set! (-> self control collide-mode) arg0)
    (set! (-> self control collide-mode-transition) arg1)
    (logclear! (-> self control penetrate-using) (penetrate tube vehicle board mech))
    (set! (-> self control penetrated-by) (penetrate lunge))
    (dotimes (v1-10 4)
      (set! (-> gp-0 collision-spheres v1-10 transform-index) -2)
      )
    (set! (-> gp-0 collision-spheres 3 prim-core collide-as) (collide-spec))
    (set! (-> gp-0 collision-spheres 3 prim-core collide-with) (collide-spec))
    (set! (-> gp-0 collision-spheres 4 prim-core collide-as) (collide-spec jak))
    (set! (-> gp-0 collision-spheres 4 prim-core collide-with) (collide-spec
                                                                 backgnd
                                                                 bot
                                                                 crate
                                                                 civilian
                                                                 enemy
                                                                 obstacle
                                                                 hit-by-player-list
                                                                 hit-by-others-list
                                                                 player-list
                                                                 water
                                                                 collectable
                                                                 blocking-plane
                                                                 tobot
                                                                 pusher
                                                                 vehicle-mesh
                                                                 obstacle-for-jak
                                                                 )
          )
    (cond
      ((= arg0 'pole)
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 0.0 0.0 (-> *TARGET-bank* body-radius))
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 0.0 0.0 (-> *TARGET-bank* body-radius))
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 0.0 0.0 (-> *TARGET-bank* body-radius))
       (set! (-> gp-0 collision-spheres 0 transform-index) 28)
       (set! (-> gp-0 collision-spheres 1 transform-index) 26)
       (set! (-> gp-0 collision-spheres 2 transform-index) 8)
       )
      ((= arg0 'board)
       (logior! (-> self control penetrate-using) (penetrate touch board))
       )
      ((= arg0 'racer)
       (set! (-> gp-0 draw-offset y) 4096.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 8192.0 :w 1.0)
         16384.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 6553.6 0.0 6553.6)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 9420.8 0.0 6553.6)
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 12288.0 0.0 6553.6)
       (logior! (-> self control penetrate-using) (penetrate touch vehicle))
       )
      ((= arg0 'flut)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 8192.0 :w 1.0)
         12288.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 4915.2 0.0 4915.2)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 7782.4004 0.0 4915.2)
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 10649.6 0.0 4915.2)
       )
      ((= arg0 'mech)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 8192.0 :w 1.0)
         16384.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 4096.0 0.0 4096.0)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 8601.6 0.0 6553.6)
       (set-vector! (-> gp-0 collision-spheres 2 local-sphere) 0.0 14745.6 0.0 9420.8)
       (logior! (-> self control penetrate-using) (penetrate touch mech))
       )
      ((= arg0 'mech-carry)
       (set! (-> gp-0 draw-offset y) 0.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (new 'static 'vector :y 12288.0 :w 1.0)
         20480.0
         )
       (set-vector! (-> gp-0 collision-spheres 0 local-sphere) 0.0 4096.0 0.0 4096.0)
       (set-vector! (-> gp-0 collision-spheres 1 local-sphere) 0.0 8601.6 0.0 6553.6)
       (set-vector!
         (-> gp-0 collision-spheres 2 local-sphere)
         0.0
         (+ 5734.4 (lerp-scale 9011.2 12288.0 arg1 0.0 1.0))
         0.0
         (lerp-scale 9420.8 12697.6 arg1 0.0 1.0)
         )
       )
      ((= arg0 'duck)
       (set! (-> self control duck-gun-tube-transision) arg1)
       (let ((f30-1 (- 1.0 arg1)))
         (set! (-> gp-0 draw-offset y) 0.0)
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           (-> *TARGET-bank* root-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 0 local-sphere)
           0.0
           (-> *TARGET-bank* body-radius)
           (* 0.0 f30-1)
           (-> *TARGET-bank* body-radius)
           )
         (if (using-gun? self)
             (set-vector!
               (-> gp-0 collision-spheres 1 local-sphere)
               0.0
               (+ 2867.2 (-> *TARGET-bank* body-radius))
               0.0
               (-> *TARGET-bank* body-radius)
               )
             (set-vector!
               (-> gp-0 collision-spheres 1 local-sphere)
               0.0
               (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-1))
               0.0
               (-> *TARGET-bank* body-radius)
               )
             )
         (set-vector!
           (-> gp-0 collision-spheres 2 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-1))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         )
       )
      ((= arg0 'indax)
       (let ((f30-2 0.2))
         (set! (-> gp-0 draw-offset y) 0.0)
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           (-> *TARGET-bank* root-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 0 local-sphere)
           0.0
           (-> *TARGET-bank* body-radius)
           (* 0.0 f30-2)
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 1 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-2))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 2 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-2))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         )
       (set! (-> gp-0 collision-spheres 4 prim-core collide-as) (collide-spec))
       (set! (-> gp-0 collision-spheres 4 prim-core collide-with) (collide-spec))
       0
       )
      ((= arg0 'tube)
       (set! (-> self control duck-gun-tube-transision) arg1)
       (let ((f30-3 (- 1.0 arg1)))
         (set! (-> gp-0 draw-offset y) 0.0)
         (sphere<-vector+r!
           (the-as sphere (-> gp-0 root-prim local-sphere))
           (-> *TARGET-bank* root-offset)
           (-> *TARGET-bank* root-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 0 local-sphere)
           0.0
           (-> *TARGET-bank* body-radius)
           (* 0.0 f30-3)
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 1 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 2867.2 f30-3))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         (set-vector!
           (-> gp-0 collision-spheres 2 local-sphere)
           0.0
           (+ (-> *TARGET-bank* body-radius) (* 5734.4 f30-3))
           0.0
           (-> *TARGET-bank* body-radius)
           )
         )
       (logior! (-> self control penetrate-using) (penetrate touch tube))
       )
      ((= arg0 'carry)
       (set! (-> gp-0 draw-offset y) 0.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (-> *TARGET-bank* root-offset)
         (-> *TARGET-bank* root-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 0 local-sphere)
         0.0
         (-> *TARGET-bank* body-radius)
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 1 local-sphere)
         0.0
         (+ 2867.2 (-> *TARGET-bank* body-radius))
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 2 local-sphere)
         0.0
         (+ 5734.4 (-> *TARGET-bank* body-radius))
         0.0
         (lerp-scale (-> *TARGET-bank* body-radius) 7372.8 arg1 0.0 1.0)
         )
       )
      ((= arg0 'gun)
       (set! (-> self control duck-gun-tube-transision) arg1)
       (set! (-> gp-0 draw-offset y) 0.0)
       (sphere<-vector+r!
         (the-as sphere (-> gp-0 root-prim local-sphere))
         (-> *TARGET-bank* root-offset)
         (-> *TARGET-bank* root-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 0 local-sphere)
         0.0
         (-> *TARGET-bank* body-radius)
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 1 local-sphere)
         0.0
         (+ 2867.2 (-> *TARGET-bank* body-radius))
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 2 local-sphere)
         0.0
         (+ 5734.4 (-> *TARGET-bank* body-radius))
         0.0
         (-> *TARGET-bank* body-radius)
         )
       (set-vector!
         (-> gp-0 collision-spheres 3 local-sphere)
         0.0
         (+ 5734.4 (-> *TARGET-bank* body-radius))
         0.0
         (lerp-scale (-> *TARGET-bank* body-radius) 4915.2 arg1 0.0 1.0)
         )
       (set! (-> gp-0 collision-spheres 3 prim-core collide-with) (collide-spec
                                                                    backgnd
                                                                    bot
                                                                    crate
                                                                    obstacle
                                                                    hit-by-player-list
                                                                    hit-by-others-list
                                                                    player-list
                                                                    water
                                                                    collectable
                                                                    blocking-plane
                                                                    tobot
                                                                    pusher
                                                                    vehicle-mesh
                                                                    obstacle-for-jak
                                                                    )
             )
       )
      (else
        (set! (-> self control duck-gun-tube-transision) 0.0)
        (set! (-> gp-0 draw-offset y) 0.0)
        (sphere<-vector+r!
          (the-as sphere (-> gp-0 root-prim local-sphere))
          (-> *TARGET-bank* root-offset)
          (-> *TARGET-bank* root-radius)
          )
        (set-vector!
          (-> gp-0 collision-spheres 0 local-sphere)
          0.0
          (-> *TARGET-bank* body-radius)
          0.0
          (-> *TARGET-bank* body-radius)
          )
        (set-vector!
          (-> gp-0 collision-spheres 1 local-sphere)
          0.0
          (+ 2867.2 (-> *TARGET-bank* body-radius))
          0.0
          (-> *TARGET-bank* body-radius)
          )
        (set-vector!
          (-> gp-0 collision-spheres 2 local-sphere)
          0.0
          (+ 5734.4 (-> *TARGET-bank* body-radius))
          0.0
          (-> *TARGET-bank* body-radius)
          )
        )
      )
    (when (and (focus-test? self dark) (and (nonzero? (-> self darkjak)) (logtest? (-> self darkjak stage) 32)))
      (let ((f0-183 (lerp-scale 1.0 (-> self darkjak-giant-interp) (-> self darkjak-interp) 0.0 1.0)))
        (set! (-> gp-0 collision-spheres 0 local-sphere w)
              (* 0.5 (+ 1.0 f0-183) (-> gp-0 collision-spheres 0 local-sphere w))
              )
        (set! (-> gp-0 collision-spheres 0 local-sphere y)
              (* 0.5 (+ 1.0 f0-183) (-> gp-0 collision-spheres 0 local-sphere y))
              )
        (set! (-> gp-0 collision-spheres 1 local-sphere w) (* (-> gp-0 collision-spheres 1 local-sphere w) f0-183))
        (set! (-> gp-0 collision-spheres 1 local-sphere y) (* (-> gp-0 collision-spheres 1 local-sphere y) f0-183))
        (set! (-> gp-0 collision-spheres 2 local-sphere w) (* (-> gp-0 collision-spheres 2 local-sphere w) f0-183))
        (set! (-> gp-0 collision-spheres 2 local-sphere y) (* (-> gp-0 collision-spheres 2 local-sphere y) f0-183))
        )
      )
    )
  0
  )

(defmethod get-quaternion control-info ((obj control-info))
  (-> obj quat-for-control)
  )

(defbehavior debounce-speed target ((arg0 float) (arg1 float) (arg2 vector) (arg3 vector))
  (if (and (< 0.3 arg0) (< arg0 0.7) (< 0.0 arg1) (< (vector-dot arg2 arg3) 0.2))
      (set! arg0 0.0)
      )
  arg0
  )

(defbehavior target-align-vel-z-adjust target ((arg0 float))
  (let ((f1-0 (-> self control local-slope-z)))
    (* arg0 (if (< 0.0 f1-0)
                (* (- 1.0 f1-0) (-> self control current-surface alignv))
                (-> self control current-surface alignv)
                )
       )
    )
  )

(defmethod get-inv-mass target ((obj target))
  (if (or (and (focus-test? obj dark) (nonzero? (-> obj darkjak)) (logtest? (-> obj darkjak stage) 32))
          (focus-test? obj mech)
          )
      0.1
      1.0
      )
  )

;; WARN: Return type mismatch control-info vs trsqv.
(defmethod apply-alignment target ((obj target) (arg0 align-opts) (arg1 transformq) (arg2 vector))
  (with-pp
    (let ((s2-0 (new 'stack-no-clear 'vector)))
      (set! (-> s2-0 quad) (-> arg2 quad))
      (set! (-> s2-0 z) (target-align-vel-z-adjust (-> s2-0 z)))
      (when (logtest? arg0 (align-opts adjust-x-vel adjust-y-vel adjust-xz-vel))
        (let* ((s3-0 (-> obj control c-R-w))
               (s0-0 (-> obj control w-R-c))
               (s1-0 (vector-matrix*! (new 'stack-no-clear 'vector) (-> obj control dynam gravity) s0-0))
               (a1-3 (vector-matrix*! (new 'stack-no-clear 'vector) (-> obj control transv) s0-0))
               )
          (if (logtest? arg0 (align-opts no-gravity))
              (set-vector! s1-0 0.0 0.0 0.0 1.0)
              )
          (when (logtest? arg0 (align-opts adjust-x-vel))
            (set! (-> a1-3 x) (+ (* (-> arg1 trans x) (-> s2-0 x) (-> pp clock frames-per-second))
                                 (* (-> s1-0 x) (-> pp clock seconds-per-frame))
                                 )
                  )
            (if (not (logtest? arg0 (align-opts adjust-xz-vel keep-other-velocities)))
                (set! (-> a1-3 z) 0.0)
                )
            )
          (if (and (logtest? arg0 (align-opts adjust-y-vel))
                   (not (and (logtest? arg0 (align-opts ignore-y-if-zero)) (= (-> arg1 trans y) 0.0)))
                   )
              (set! (-> a1-3 y) (+ (* (-> arg1 trans y) (-> s2-0 y) (-> pp clock frames-per-second))
                                   (* (-> s1-0 y) (-> pp clock seconds-per-frame))
                                   )
                    )
              )
          (when (logtest? arg0 (align-opts adjust-xz-vel))
            (set! (-> a1-3 z) (+ (* (-> arg1 trans z) (-> s2-0 z) (-> pp clock frames-per-second))
                                 (* (-> s1-0 z) (-> pp clock seconds-per-frame))
                                 )
                  )
            (if (not (logtest? arg0 (align-opts adjust-x-vel keep-other-velocities)))
                (set! (-> a1-3 x) 0.0)
                )
            )
          (vector-matrix*! (-> obj control transv) a1-3 s3-0)
          )
        )
      )
    (if (logtest? arg0 (align-opts adjust-quat))
        (quaternion-normalize!
          (quaternion*! (-> obj control quat-for-control) (-> obj control quat-for-control) (-> arg1 quat))
          )
        )
    (the-as trsqv (-> obj control))
    )
  )

(defun average-turn-angle ((arg0 target))
  (let ((f30-0 0.0))
    (dotimes (s5-0 8)
      (+! f30-0
          (fabs
            (deg-diff (atan (-> arg0 control turn-history-ctrl s5-0 x) (-> arg0 control turn-history-ctrl s5-0 z)) 0.0)
            )
          )
      )
    (* 0.125 f30-0)
    )
  )

(defbehavior can-play-stance-amibent? target ()
  (and (or (and (= *kernel-boot-message* 'kiosk)
                (>= (+ -300000 (-> *display* real-clock frame-counter)) (seconds 60))
                (>= (- (-> *display* base-clock frame-counter) (-> self control cpad change-time)) (seconds 60))
                (>= (- (-> *display* game-clock frame-counter) (the-as int (-> self game kiosk-timeout))) (seconds 60))
                )
           (and (>= (- (current-time) (-> self ambient-time)) (seconds 30))
                (not (logtest? (-> self control status) (collide-status touch-actor)))
                (logtest? (-> self control status) (collide-status on-surface))
                (not (or (logtest? (water-flags touch-water) (-> self water flags))
                         (logtest? (-> self control status) (collide-status on-water))
                         )
                     )
                (not (logtest? (focus-status dead hit grabbed in-head edge-grab pole flut tube board mech dark indax teleporting)
                               (-> self focus-status)
                               )
                     )
                )
           )
       (not (paused?))
       (not (movie?))
       (>= (- (-> *display* base-clock frame-counter) (-> self control cpad change-time)) (seconds 30))
       (!= (-> self tobot?) 'tobot)
       (not (-> *setting-control* user-current talking))
       (not (-> *setting-control* user-current spooling))
       (not (-> *setting-control* user-current movie))
       (not (-> *setting-control* user-current hint))
       (not (focus-test? self dead hit grabbed))
       (logtest? (-> self game features) (game-feature sidekick))
       (case *kernel-boot-message*
         (('kiosk)
          (set! (-> self control cpad change-time) (-> *display* base-clock frame-counter))
          (auto-save-command 'restore 0 0 *default-pool* #f)
          #f
          )
         (else
           #t
           )
         )
       )
  )

(defbehavior target-height-above-ground target ()
  (- (-> self control trans y) (-> self control gspot-pos y))
  )

(defbehavior can-jump? target ((arg0 symbol))
  (and (or (logtest? (-> self control status) (collide-status on-surface))
           (< (- (current-time) (-> self control last-time-on-surface))
              (the-as time-frame (-> *TARGET-bank* ground-timeout))
              )
           (and (logtest? (-> self control status) (collide-status on-surface))
                (< 0.866 (-> self control surface-angle))
                )
           (and (= arg0 'board)
                (or (< (- (current-time) (-> self board unknown-time-frame00)) (seconds 0.05))
                    (and (< (- (current-time) (-> self control last-time-of-stuck)) (seconds 0.5))
                         (< (target-height-above-ground) 2048.0)
                         )
                    )
                )
           )
       (and (not (logtest? (-> self control current-surface flags) (surface-flag no-jump)))
            (not (logtest? (-> self state-flags) (state-flags prevent-jump)))
            (or (= arg0 'board) (!= (-> self control poly-pat event) 13))
            (if (= arg0 'target-roll-flip)
                (>= 0.5 (-> self control local-slope-z))
                #t
                )
            )
       )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior target-jump-go target ()
  (go target-jump (-> *TARGET-bank* jump-height-min) (-> *TARGET-bank* jump-height-max) (the-as surface #f))
  (none)
  )

(defbehavior move-legs? target ()
  (!= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
  )

(defbehavior jump-hit-ground-stuck? target ()
  (or (logtest? (-> self control status) (collide-status on-surface))
      (when (and (< (target-move-dist (-> *TARGET-bank* stuck-time)) (-> *TARGET-bank* stuck-distance))
                 (not (and *cheat-mode* (cpad-hold? (-> self control cpad number) r2)))
                 )
        (set! (-> self control last-time-of-stuck) (current-time))
        #t
        )
      )
  )

;; WARN: Return type mismatch int vs time-frame.
(defbehavior target-time-to-ground target ()
  (let ((f0-0 (target-height-above-ground))
        (f2-0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
        (f1-1 0.0)
        )
    (while (< 0.0 f0-0)
      (set! f1-1 (+ 5.0 f1-1))
      (+! f0-0 (* f2-0 (-> self clock seconds-per-frame)))
      (set! f2-0 (- f2-0 (* (-> self control dynam gravity-length) (-> self clock seconds-per-frame))))
      )
    (the time-frame f1-1)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior fall-test target ((arg0 (state symbol target)) (arg1 float))
  (when (and (not (logtest? (-> self control status) (collide-status on-surface)))
             (>= (- (current-time) (-> self control last-time-on-surface))
                 (the-as time-frame (-> *TARGET-bank* ground-timeout))
                 )
             (>= 0.0 (vector-dot (-> self control dynam gravity-normal) (-> self control transv)))
             (>= (target-height-above-ground) arg1)
             )
    (if (< (- (current-time) (-> self control rider-time)) (the-as time-frame (-> *TARGET-bank* ground-timeout)))
        (send-event self 'push-transv (-> self control rider-last-move) #x7530)
        )
    (go arg0 #f)
    )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior slide-down-test target ()
  (if (and (not (logtest? (-> self control status) (collide-status on-surface touch-edge)))
           (>= (- (current-time) (-> self control last-time-on-surface))
               (the-as time-frame (-> *TARGET-bank* ground-timeout))
               )
           (logtest? (-> self control status) (collide-status touch-surface))
           (< 0.5 (-> self control surface-angle))
           )
      (go target-slide-down)
      )
  (none)
  )

(defbehavior smack-surface? target ((arg0 symbol))
  (and (< 0.7 (-> self control touch-angle))
       (and (< (-> self control surface-angle) 0.3)
            (logtest? (-> self control status) (collide-status touch-wall))
            (or arg0 (not (logtest? (-> self control status) (collide-status touch-actor))))
            )
       )
  )

(defbehavior can-roll? target ()
  (and (logtest? (-> self control status) (collide-status on-surface))
       (or (not (logtest? (-> self control status) (collide-status touch-wall)))
           (>= 0.7 (-> self control touch-angle))
           )
       (< (-> self control local-slope-z) 0.7)
       (not (logtest? (-> self state-flags) (state-flags prevent-attack prevent-duck)))
       (not (and (focus-test? self dark) (nonzero? (-> self darkjak))))
       (>= (- (current-time) (the-as int (-> *TARGET-bank* roll-timeout))) (-> self control last-roll-end-time))
       (or (not (enabled-gun? self))
           (not (-> *TARGET-bank* strafe-duck-jump))
           (and (< 0.3 (vector-dot (-> self control to-target-pt-xz) (-> self control c-R-w vector 2)))
                (>= (- (current-time) (-> self control time-of-last-zero-input)) (seconds 0.3))
                )
           )
       (not (and (not (using-gun? self)) (!= (-> self skel top-anim interp) 0.0)))
       )
  )

(defbehavior can-duck? target ()
  (and (logtest? (-> self control status) (collide-status on-surface))
       (>= (-> self control ground-local-norm-dot-grav) 0.7)
       (not (logtest? (water-flags under-water swimming) (-> self water flags)))
       (not (logtest? (-> self state-flags) (state-flags prevent-duck)))
       (or (not (logtest? (water-flags wading) (-> self water flags)))
           (< (- (- (-> self control trans y) (- (-> self water base-height) (-> self water wade-height)))) 2457.6)
           )
       )
  )

(defun can-exit-duck? ((arg0 target))
  (let ((gp-0 (new 'stack-no-clear 'collide-query)))
    (let ((s4-0 (new 'stack-no-clear 'inline-array 'sphere 2)))
      (dotimes (s3-0 2)
        ((method-of-type sphere new) (the-as symbol (-> s4-0 s3-0)) sphere)
        )
      (set! (-> s4-0 0 quad) (-> arg0 control trans quad))
      (set! (-> s4-0 0 y) (+ 5734.4 (-> *TARGET-bank* body-radius) (-> s4-0 0 y)))
      (set! (-> s4-0 0 r) (-> *TARGET-bank* body-radius))
      (set! (-> s4-0 1 quad) (-> arg0 control trans quad))
      (set! (-> s4-0 1 y) (+ 2867.2 (-> *TARGET-bank* body-radius) (-> s4-0 1 y)))
      (set! (-> s4-0 1 r) (-> *TARGET-bank* body-radius))
      (let ((v1-12 gp-0))
        (set! (-> v1-12 best-dist) (the-as float s4-0))
        (set! (-> v1-12 num-spheres) (the-as uint 2))
        (set! (-> v1-12 collide-with) (logclear
                                        (-> arg0 control root-prim prim-core collide-with)
                                        (collide-spec civilian enemy vehicle-sphere projectile)
                                        )
              )
        (set! (-> v1-12 ignore-process0) #f)
        (set! (-> v1-12 ignore-process1) #f)
        (set! (-> v1-12 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-12 best-my-prim) (the-as collide-shape-prim #t))
        (set! (-> v1-12 action-mask) (collide-action solid))
        )
      )
    (if (fill-and-probe-using-spheres *collide-cache* gp-0)
        #f
        #t
        )
    )
  )

(defbehavior can-hands? target ((arg0 symbol))
  (cond
    ((or (logtest? (-> self state-flags) (state-flags prevent-attack))
         (logtest? (-> self control current-surface flags) (surface-flag no-attack no-hands))
         )
     #f
     )
    ((and (or (not arg0)
              (and (< (- (current-time) (-> self control last-time-on-surface))
                      (the-as time-frame (-> *TARGET-bank* ground-timeout))
                      )
                   (< (-> self control local-slope-z) 0.7)
                   )
              )
          (>= (- (current-time) (-> self control last-running-attack-end-time))
              (the-as time-frame (if (and (= (-> (the-as fact-info-target (-> self fact-override)) eco-type) 1)
                                          (>= (-> (the-as fact-info-target (-> self fact-override)) eco-level) 1.0)
                                          )
                                     (-> *TARGET-bank* yellow-attack-timeout)
                                     (-> *TARGET-bank* attack-timeout)
                                     )
                      )
              )
          )
     #t
     )
    (else
      (set! (-> self control last-hands-attempt-time) (current-time))
      #f
      )
    )
  )

(defbehavior can-feet? target ((arg0 symbol))
  (cond
    ((or (logtest? (-> self state-flags) (state-flags prevent-attack))
         (logtest? (-> self control current-surface flags) (surface-flag no-attack no-feet))
         )
     #f
     )
    ((>= (- (current-time) (-> self control last-attack-end-time))
         (the-as time-frame (-> *TARGET-bank* attack-timeout))
         )
     #t
     )
    (else
      (set! (-> self control last-feet-attempt-time) (current-time))
      #f
      )
    )
  )

(defbehavior are-still? target ()
  (or (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
      (< (-> self control ctrl-xz-vel) 61440.0)
      )
  )

(defbehavior vector-local+! target ((arg0 vector) (arg1 vector))
  (let ((s5-0 (new-stack-vector0)))
    (vector-matrix*! s5-0 arg1 (-> self control c-R-w))
    (vector+! arg0 arg0 s5-0)
    )
  )

(defbehavior move-forward target ((arg0 float))
  (let ((a1-0 (new-stack-vector0))
        (gp-0 (new-stack-vector0))
        )
    (set-vector! a1-0 0.0 0.0 arg0 1.0)
    (vector-matrix*! gp-0 a1-0 (-> self control c-R-w))
    (vector+! (-> self control transv) (-> self control transv) gp-0)
    )
  )

(defbehavior set-forward-vel target ((arg0 float))
  (let ((gp-0 (new-stack-vector0)))
    (vector-matrix*! gp-0 (-> self control transv) (-> self control w-R-c))
    (set! (-> gp-0 z) arg0)
    (set! (-> gp-0 x) 0.0)
    (vector-matrix*! (-> self control transv) gp-0 (-> self control c-R-w))
    )
  )

(defbehavior delete-back-vel target ()
  (let ((gp-0 (new-stack-vector0)))
    (vector-z-quaternion! gp-0 (-> self control dir-targ))
    (let ((v1-1 (new-stack-vector0))
          (f0-1 (vector-dot gp-0 (-> self control transv)))
          )
      0.0
      (vector-! v1-1 (-> self control transv) (vector-float*! v1-1 gp-0 f0-1))
      (let* ((f1-2 (vector-length v1-1))
             (f2-0 f1-2)
             )
        (if (< f0-1 0.0)
            (set! f0-1 0.0)
            )
        (vector+!
          (-> self control transv)
          (vector-float*! (-> self control transv) gp-0 f0-1)
          (vector-float*! v1-1 v1-1 (/ f1-2 f2-0))
          )
        )
      )
    )
  0
  (none)
  )

(defbehavior set-side-vel target ((arg0 float))
  (let ((gp-0 (new-stack-vector0)))
    (vector-matrix*! gp-0 (-> self control transv) (-> self control w-R-c))
    (set! (-> gp-0 x) arg0)
    (set! (-> gp-0 z) 0.0)
    (vector-matrix*! (-> self control transv) gp-0 (-> self control c-R-w))
    )
  )

(defun target-timed-invulnerable ((arg0 time-frame) (arg1 target) (arg2 int))
  (case arg2
    ((1)
     (logior! (-> arg1 state-flags) (state-flags tinvul1))
     (set! (-> arg1 control invul1-on-time) (current-time))
     (set! (-> arg1 control invul1-off-time) arg0)
     )
    ((2)
     (set! (-> arg1 state-flags) (logior (state-flags tinvul2) (-> arg1 state-flags)))
     (set! (-> arg1 control invul2-on-time) (current-time))
     (set! (-> arg1 control invul2-off-time) arg0)
     )
    )
  (modify-collide-as! (-> arg1 control) 2 (collide-spec jak-vulnerable) (collide-spec))
  (logior! (-> arg1 focus-status) (focus-status ignore))
  0
  (none)
  )

(defun target-timed-invulnerable-off ((arg0 target) (arg1 int))
  (let ((v1-0 arg1))
    (cond
      ((zero? v1-0)
       (logclear! (-> arg0 state-flags) (state-flags tinvul1 tinvul2))
       )
      ((= v1-0 1)
       (logclear! (-> arg0 state-flags) (state-flags tinvul1))
       )
      ((= v1-0 2)
       (logclear! (-> arg0 state-flags) (state-flags tinvul2))
       )
      )
    )
  (when (not (logtest? (state-flags tinvul1 tinvul2) (-> arg0 state-flags)))
    (logclear! (-> arg0 draw status) (draw-control-status no-draw-bounds))
    (modify-collide-as! (-> arg0 control) 2 (collide-spec) (collide-spec jak-vulnerable))
    )
  0
  (none)
  )

(defbehavior target-log-attack target ((arg0 attack-info) (arg1 symbol))
  (if (and (= arg1 'background) (= (-> arg0 id) 2))
      (return #t)
      )
  (let ((a3-0 (the-as object (-> self attack-info-old))))
    (dotimes (a2-2 8)
      (let ((v1-9 (-> self attack-info-old a2-2)))
        (when (= (-> arg0 id) (-> v1-9 id))
          (if (< (- (current-time) (-> v1-9 attack-time))
                 (the-as time-frame (-> *TARGET-bank* same-attack-invulnerable-timeout))
                 )
              (return #f)
              )
          (cond
            ((= arg1 'test)
             )
            (else
              (mem-copy! (the-as pointer v1-9) (the-as pointer arg0) 160)
              )
            )
          (return #t)
          )
        (if (< (-> v1-9 attack-time) (-> (the-as attack-info a3-0) attack-time))
            (set! a3-0 v1-9)
            )
        )
      )
    (case arg1
      (('test)
       )
      (else
        (mem-copy! (the-as pointer a3-0) (the-as pointer arg0) 160)
        )
      )
    )
  #t
  )

(defmethod attack-info-method-9 attack-info ((obj attack-info) (arg0 attack-info) (arg1 process-drawable) (arg2 process-drawable))
  (local-vars (v1-14 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (if (type? arg1 process-drawable)
                    arg1
                    )
                )
          )
      (let ((v1-0 (if (type? arg2 process-drawable)
                      arg2
                      )
                  )
            )
        (cond
          ((logtest? (attack-info-mask attacker-velocity) (-> obj mask))
           (set! (-> arg0 attacker-velocity quad) (-> obj attacker-velocity quad))
           (vector-normalize-copy! (-> arg0 trans) (-> arg0 attacker-velocity) 1.0)
           )
          (v1-0
            (cond
              (s5-0
                (vector-! (-> arg0 trans) (-> v1-0 root trans) (-> s5-0 root trans))
                (vector-normalize! (-> arg0 trans) 1.0)
                (set! (-> arg0 attacker-velocity quad) (-> arg0 trans quad))
                )
              (else
                (vector-z-quaternion! (-> arg0 trans) (-> v1-0 root quat))
                (vector-negate-in-place! (-> arg0 trans))
                (vector-normalize! (-> arg0 trans) 1.0)
                (set! (-> arg0 attacker-velocity quad) (-> arg0 trans quad))
                )
              )
            )
          (else
            (set! (-> arg0 trans quad) (the-as uint128 0))
            (set! (-> arg0 attacker-velocity quad) (the-as uint128 0))
            )
          )
        )
      (if s5-0
          (set! (-> arg0 intersection quad) (-> s5-0 root trans quad))
          (set! (-> arg0 intersection quad) (-> (target-pos 0) quad))
          )
      )
    (.lvf vf1 (&-> (-> arg0 trans) quad))
    (.add.w.vf vf2 vf0 vf0 :mask #b1)
    (.mul.vf vf1 vf1 vf1)
    (.mul.x.vf acc vf2 vf1 :mask #b1)
    (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
    (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
    (.mov v1-14 vf1)
    (cond
      ((!= v1-14 0.0)
       (set! (-> arg0 vector quad) (-> arg0 trans quad))
       (set! (-> arg0 vector y) 0.0)
       (vector-xz-normalize! (-> arg0 vector) 1.0)
       )
      (else
        (set! (-> arg0 vector quad) (the-as uint128 0))
        )
      )
    0
    (none)
    )
  )

(defmethod compute-intersect-info attack-info ((obj attack-info) (arg0 object) (arg1 process-drawable) (arg2 process) (arg3 touching-shapes-entry))
  (when (and arg3 arg1)
    (let ((a1-2 (prims-touching? arg3 (the-as collide-shape (-> arg1 root)) (the-as uint -1))))
      (when a1-2
        (get-intersect-point (-> obj intersection) a1-2 (the-as collide-shape (-> arg1 root)) arg3)
        (logior! (-> obj mask) (attack-info-mask intersection))
        )
      )
    )
  (when arg1
    (set! (-> obj prev-state) (-> arg1 state))
    (logior! (-> obj mask) (attack-info-mask prev-state))
    )
  (when (not (logtest? (-> obj mask) (attack-info-mask attacker)))
    (set! (-> obj attacker) (process->handle arg2))
    (logior! (-> obj mask) (attack-info-mask attacker))
    )
  (when (not (logtest? (-> obj mask) (attack-info-mask attack-time)))
    (set! (-> obj attack-time) (-> *display* base-clock frame-counter))
    (logior! (-> obj mask) (attack-info-mask attack-time))
    )
  (if (not (logtest? (attack-info-mask damage) (-> obj mask)))
      (set! (-> obj damage) (-> *FACT-bank* health-default-inc))
      )
  obj
  )

(defmethod combine! attack-info ((obj attack-info) (arg0 attack-info) (arg1 process-drawable))
  (let ((s4-0 (-> arg0 mask)))
    (set! (-> obj mask) (-> arg0 mask))
    (if (logtest? s4-0 (attack-info-mask attacker))
        (set! (-> obj attacker) (-> arg0 attacker))
        )
    (if (logtest? s4-0 (attack-info-mask mode))
        (set! (-> obj mode) (-> arg0 mode))
        )
    (if (logtest? s4-0 (attack-info-mask angle))
        (set! (-> obj angle) (-> arg0 angle))
        )
    (if (logtest? s4-0 (attack-info-mask dist))
        (set! (-> obj dist) (-> arg0 dist))
        )
    (if (logtest? s4-0 (attack-info-mask control))
        (set! (-> obj control) (-> arg0 control))
        )
    (if (logtest? s4-0 (attack-info-mask speed))
        (set! (-> obj speed) (-> arg0 speed))
        )
    (if (logtest? (attack-info-mask penetrate-using) s4-0)
        (set! (-> obj penetrate-using) (-> arg0 penetrate-using))
        )
    (if (logtest? (attack-info-mask damage) s4-0)
        (set! (-> obj damage) (-> arg0 damage))
        )
    (if (logtest? (attack-info-mask shield-damage) s4-0)
        (set! (-> obj shield-damage) (-> arg0 shield-damage))
        )
    (if (logtest? (attack-info-mask knock) s4-0)
        (set! (-> obj knock) (-> arg0 knock))
        )
    (if (logtest? (attack-info-mask count) s4-0)
        (set! (-> obj count) (-> arg0 count))
        )
    (if (logtest? s4-0 (attack-info-mask id))
        (set! (-> obj id) (-> arg0 id))
        )
    (if (logtest? s4-0 (attack-info-mask shove-back))
        (set! (-> obj shove-back) (-> arg0 shove-back))
        )
    (if (logtest? s4-0 (attack-info-mask shove-up))
        (set! (-> obj shove-up) (-> arg0 shove-up))
        )
    (if (logtest? s4-0 (attack-info-mask invinc-time))
        (set! (-> obj invinc-time) (-> arg0 invinc-time))
        )
    (if (logtest? s4-0 (attack-info-mask rotate-to))
        (set! (-> obj rotate-to) (-> arg0 rotate-to))
        )
    (if (logtest? s4-0 (attack-info-mask intersection))
        (set! (-> obj intersection quad) (-> arg0 intersection quad))
        )
    (if (logtest? (attack-info-mask attacker-velocity) s4-0)
        (set! (-> obj attacker-velocity quad) (-> arg0 attacker-velocity quad))
        )
    (cond
      ((not (logtest? s4-0 (attack-info-mask vector)))
       (let* ((s2-0 (handle->process (-> obj attacker)))
              (v1-65 (if (type? s2-0 process-drawable)
                         s2-0
                         )
                     )
              )
         (when (and v1-65 (nonzero? (-> (the-as process-drawable v1-65) root)))
           (set! (-> obj trans quad) (-> (the-as process-drawable v1-65) root trans quad))
           (vector-! (-> obj vector) (-> arg1 root trans) (-> (the-as process-drawable v1-65) root trans))
           (logior! (-> obj mask) (attack-info-mask vector))
           )
         )
       )
      (else
        (let* ((s3-1 (handle->process (-> obj attacker)))
               (v1-72 (if (type? s3-1 process-drawable)
                          s3-1
                          )
                      )
               )
          (if (and v1-72 (nonzero? (-> (the-as process-drawable v1-72) root)))
              (set! (-> obj trans quad) (-> (the-as process-drawable v1-72) root trans quad))
              )
          )
        (set! (-> obj vector quad) (-> arg0 vector quad))
        (when (not (logtest? s4-0 (attack-info-mask shove-back)))
          (let ((v1-79 (-> obj vector)))
            (set! (-> obj shove-back) (sqrtf (+ (* (-> v1-79 x) (-> v1-79 x)) (* (-> v1-79 z) (-> v1-79 z)))))
            )
          )
        (if (not (logtest? s4-0 (attack-info-mask shove-up)))
            (set! (-> obj shove-up) (-> obj vector y))
            )
        )
      )
    (if (not (logtest? (-> obj mask) (attack-info-mask dist)))
        (set! (-> obj dist) (fabs (-> obj shove-back)))
        )
    (if (logtest? s4-0 (attack-info-mask trans))
        (set! (-> obj trans quad) (-> arg0 trans quad))
        )
    )
  obj
  )

(defbehavior ground-tween-initialize target ((arg0 ground-tween-info)
                                   (arg1 uint)
                                   (arg2 uint)
                                   (arg3 uint)
                                   (arg4 uint)
                                   (arg5 uint)
                                   (arg6 uint)
                                   (arg7 float)
                                   )
  (set! (-> arg0 group 0) arg2)
  (set! (-> arg0 group 1) arg3)
  (set! (-> arg0 group 2) arg4)
  (set! (-> arg0 group 3) arg5)
  (set! (-> arg0 group 4) arg6)
  (dotimes (s2-0 3)
    (set! (-> arg0 chan s2-0) (+ arg1 s2-0))
    (let ((s1-0 (-> self skel root-channel (-> arg0 chan s2-0))))
      (let ((f0-1 (fabs (-> arg0 blend s2-0))))
        (set! (-> s1-0 frame-interp 1) f0-1)
        (set! (-> s1-0 frame-interp 0) f0-1)
        )
      (joint-control-channel-group-eval! s1-0 (the-as art-joint-anim arg2) num-func-identity)
      (set! (-> s1-0 frame-num) arg7)
      )
    )
  arg0
  )

(defbehavior ground-tween-update target ((arg0 ground-tween-info) (arg1 float) (arg2 float) (arg3 float))
  (let ((f0-1 (fmax -1.0 (fmin 1.0 arg1)))
        (f30-0 (fmax -1.0 (fmin 1.0 arg2)))
        )
    (let ((f1-5 (fabs (- f0-1 (-> arg0 blend 1)))))
      (seek! (-> arg0 blend 1) f0-1 (fmax (fmin (* f1-5 arg3) (* 0.8 arg3)) (* 0.2 arg3)))
      )
    (let ((f0-9 (fabs (- f30-0 (-> arg0 blend 2)))))
      (seek! (-> arg0 blend 2) f30-0 (fmax (fmin (* f0-9 arg3) (* 0.8 arg3)) (* 0.2 arg3)))
      )
    )
  (cond
    ((>= (-> arg0 blend 1) 0.0)
     (let ((v1-12 (-> self skel root-channel (-> arg0 chan 1))))
       (let ((f0-16 (fabs (-> arg0 blend 1))))
         (set! (-> v1-12 frame-interp 1) f0-16)
         (set! (-> v1-12 frame-interp 0) f0-16)
         )
       (set! (-> v1-12 frame-group) (the-as art-joint-anim (-> arg0 group 1)))
       )
     )
    (else
      (let ((v1-15 (-> self skel root-channel (-> arg0 chan 1))))
        (let ((f0-18 (fabs (-> arg0 blend 1))))
          (set! (-> v1-15 frame-interp 1) f0-18)
          (set! (-> v1-15 frame-interp 0) f0-18)
          )
        (set! (-> v1-15 frame-group) (the-as art-joint-anim (-> arg0 group 2)))
        )
      )
    )
  (cond
    ((>= (-> arg0 blend 2) 0.0)
     (let ((v1-18 (-> self skel root-channel (-> arg0 chan 2))))
       (let ((f0-21 (fabs (-> arg0 blend 2))))
         (set! (-> v1-18 frame-interp 1) f0-21)
         (set! (-> v1-18 frame-interp 0) f0-21)
         )
       (set! (-> v1-18 frame-group) (the-as art-joint-anim (-> arg0 group 4)))
       )
     )
    (else
      (let ((v1-21 (-> self skel root-channel (-> arg0 chan 2))))
        (let ((f0-23 (fabs (-> arg0 blend 2))))
          (set! (-> v1-21 frame-interp 1) f0-23)
          (set! (-> v1-21 frame-interp 0) f0-23)
          )
        (set! (-> v1-21 frame-group) (the-as art-joint-anim (-> arg0 group 3)))
        )
      )
    )
  0
  (none)
  )

(defun target-pos ((arg0 int))
  (let ((a1-0 *target*))
    (cond
      (a1-0
        (if (zero? arg0)
            (-> a1-0 control trans)
            (vector<-cspace! (new 'static 'vector) (-> a1-0 node-list data arg0))
            )
        )
      (else
        (camera-pos)
        )
      )
    )
  )

(defun target-cam-pos ()
  (let ((gp-0 *target*))
    (cond
      ((not gp-0)
       (camera-pos)
       )
      ((logtest? (-> gp-0 state-flags) (state-flags sf6))
       (add-debug-sphere
         *display-camera-marks*
         (bucket-id debug-no-zbuf1)
         (-> gp-0 alt-cam-pos)
         (meters 0.2)
         (new 'static 'rgba :r #xff :a #x80)
         )
       (-> gp-0 alt-cam-pos)
       )
      ((logtest? (-> gp-0 state-flags) (state-flags sf12))
       (add-debug-sphere
         *display-camera-marks*
         (bucket-id debug-no-zbuf1)
         (-> gp-0 alt-cam-pos)
         (meters 0.2)
         (new 'static 'rgba :r #xff :a #x80)
         )
       (-> gp-0 alt-cam-pos)
       )
      ((logtest? (-> gp-0 state-flags) (state-flags sf14))
       (let ((s5-0 (new 'static 'vector)))
         (set! (-> s5-0 quad) (-> gp-0 control camera-pos quad))
         (set! (-> s5-0 y) (fmax (-> s5-0 y) (-> gp-0 alt-cam-pos y)))
         (add-debug-sphere
           *display-camera-marks*
           (bucket-id debug-no-zbuf1)
           s5-0
           (meters 0.2)
           (new 'static 'rgba :r #xff :a #x80)
           )
         s5-0
         )
       )
      (else
        (add-debug-sphere
          *display-camera-marks*
          (bucket-id debug-no-zbuf1)
          (-> gp-0 control camera-pos)
          (meters 0.2)
          (new 'static 'rgba :r #xff :a #x80)
          )
        (-> gp-0 control camera-pos)
        )
      )
    )
  )

(defun target-rot ()
  (let ((v1-0 *target*))
    (if v1-0
        (-> v1-0 control quat-for-control)
        *unity-quaternion*
        )
    )
  )

(defmethod get-trans target ((obj target) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (local-vars (v0-0 vector))
  (let ((v1-0 (-> obj control)))
    (cond
      ((zero? arg0)
       (-> v1-0 trans)
       )
      ((= arg0 1)
       (let ((a1-2 (-> obj water flags)))
         (cond
           ((and (logtest? (water-flags touch-water) a1-2)
                 (logtest? (water-flags under-water swimming) a1-2)
                 (not (logtest? (focus-status mech) (-> obj focus-status)))
                 )
            (set! v0-0 (new 'static 'vector :w 1.0))
            (set! (-> v0-0 quad) (-> obj control trans quad))
            (set! (-> v0-0 y) (-> obj water height))
            v0-0
            )
           (else
             (-> v1-0 gspot-pos)
             )
           )
         )
       )
      ((= arg0 2)
       (vector<-cspace! (new 'static 'vector) (-> obj node-list data 8))
       )
      ((= arg0 3)
       (set! v0-0 (vector<-cspace! (new 'static 'vector) (-> obj node-list data 6)))
       (set! (-> v0-0 w) 4096.0)
       v0-0
       )
      ((= arg0 4)
       (target-cam-pos)
       )
      ((= arg0 5)
       (if (= (-> obj draw origin w) 0.0)
           (-> v1-0 trans)
           (-> obj draw origin)
           )
       )
      ((= arg0 6)
       (let ((f0-4 (vector-dot (-> v1-0 dynam gravity-normal) (-> v1-0 transv))))
         (cond
           ((and (< 0.0 f0-4) (focus-test? obj in-air))
            (let* ((v0-1 (new 'static 'vector))
                   (f0-5 (+ (* 0.0016666667 (-> v1-0 dynam gravity-length)) f0-4))
                   (f0-8 (/ (* 0.5 f0-5 f0-5) (-> v1-0 dynam gravity-length)))
                   )
              (vector+float*! v0-1 (-> v1-0 trans) (-> v1-0 dynam gravity-normal) f0-8)
              )
            )
           (else
             (-> v1-0 trans)
             )
           )
         )
       )
      ((= arg0 7)
       (-> v1-0 last-trans-on-ground)
       )
      ((= arg0 8)
       (-> v1-0 last-trans-leaving-surf)
       )
      (else
        (-> v1-0 trans)
        )
      )
    )
  )

(defmethod time-to-apex-or-ground target ((obj target) (arg0 int))
  (let ((v1-0 (-> obj control)))
    (cond
      ((zero? arg0)
       (let ((f0-1 (vector-dot (-> v1-0 dynam gravity-normal) (-> v1-0 transv))))
         (if (and (< 0.0 f0-1) (focus-test? obj in-air))
             (time-to-apex f0-1 (- (-> v1-0 dynam gravity-length)))
             0
             )
         )
       )
      ((= arg0 1)
       (if (focus-test? obj in-air)
           (the-as int (target-time-to-ground))
           0
           )
       )
      (else
        0
        )
      )
    )
  )

(defmethod get-quat target ((obj target) (arg0 int))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (-> obj control quat)
       )
      ((= v1-0 1)
       (-> obj control quat-for-control)
       )
      ((= v1-0 2)
       (-> obj control dir-targ)
       )
      ((= v1-0 3)
       (if (using-gun? obj)
           (forward-up->quaternion
             (new 'static 'quaternion)
             (-> obj gun fire-dir-out)
             (vector-y-quaternion! (new 'stack-no-clear 'vector) (-> obj control quat-for-control))
             )
           (-> obj control quat)
           )
       )
      (else
        (-> obj control quat)
        )
      )
    )
  )

(defmethod get-water-height target ((obj target))
  (-> obj water surface-height)
  )

(defmethod get-notice-time target ((obj target))
  (-> obj neck notice-time)
  )
