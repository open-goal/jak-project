;;-*-Lisp-*-
(in-package goal)

;; name: task-arrow.gc
;; name in dgo: task-arrow
;; dgos: ENGINE, GAME

;; +++task-arrow-flags
(defenum task-arrow-flags
  :type uint32
  :bitfield #t
  (task-arrow-flag-00 0)
  (task-arrow-flag-01 1)
  (task-arrow-flag-02 2)
  (task-arrow-flag-03 3)
  )
;; ---task-arrow-flags

;; DECOMP BEGINS

(let ((a0-0 (new 'static 'skeleton-group
              :name "skel-task-arrow"
              :extra #f
              :info #f
              :art-group-name "ctywide-arrow"
              :bounds (new 'static 'vector :w 16384.0)
              :texture-level #x6
              :version #x7
              )
            )
      )
  (set! (-> a0-0 jgeo) 0)
  (set! (-> a0-0 janim) 2)
  (set! (-> a0-0 mgeo 0) 1)
  (set! (-> a0-0 lod-dist 0) 4095996000.0)
  (add-to-loading-level a0-0)
  )

(deftype task-arrow-params (structure)
  ((flags    task-arrow-flags         :offset-assert   0)
   (map-icon uint16                   :offset-assert   4)
   (pos      vector           :inline :offset-assert  16)
   (quat     quaternion       :inline :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )


(deftype task-arrow (process-drawable)
  ((pos              vector             :inline :offset-assert 208)
   (theta            float                      :offset-assert 224)
   (phi              float                      :offset-assert 228)
   (dist             float                      :offset-assert 232)
   (smoothed-dist    float                      :offset-assert 236)
   (max-dist         float                      :offset-assert 240)
   (flags            task-arrow-flags           :offset-assert 244)
   (map-icon         uint16                     :offset-assert 248)
   (minimap          connection-minimap         :offset-assert 252)
   (hud-dist         handle                     :offset-assert 256)
   (base-quat        quaternion         :inline :offset-assert 272)
   (rod-of-god-scale float                      :offset-assert 288)
   (moving           symbol                     :offset-assert 292)
   )
  :heap-base #xb0
  :method-count-assert 25
  :size-assert         #x128
  :flag-assert         #x1900b00128
  (:methods
    (idle () _type_ :state 20)
    (die () _type_ :state 21)
    (leave () _type_ :state 22)
    (task-arrow-method-23 (_type_ vector) none 23)
    (draw-arrow (_type_) none :behavior task-arrow 24)
    )
  )


;; WARN: Return type mismatch int vs none.
(defmethod deactivate task-arrow ((obj task-arrow))
  (send-event (handle->process (-> obj hud-dist)) 'hide-and-die)
  ((method-of-type process-drawable deactivate) obj)
  0
  (none)
  )

;; WARN: Return type mismatch int vs none.
(defmethod task-arrow-method-23 task-arrow ((obj task-arrow) (arg0 vector))
  "Some weird debugging code left here, but checks for collisions on the arrow"
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'collide-query-with-vec)))
      (set! (-> s5-0 vec quad) (-> arg0 quad))
      (set! (-> s5-0 cquery start-pos quad) (-> s5-0 vec quad))
      (set! (-> s5-0 cquery start-pos y) (+ 20480.0 (-> s5-0 cquery start-pos y)))
      (set-vector! (-> s5-0 cquery move-dist) 0.0 -81920.0 0.0 1.0)
      (let ((v1-4 (-> s5-0 cquery)))
        (set! (-> v1-4 radius) 1024.0)
        (set! (-> v1-4 collide-with) (collide-spec backgnd))
        (set! (-> v1-4 ignore-process0) #f)
        (set! (-> v1-4 ignore-process1) #f)
        (set! (-> v1-4 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-4 action-mask) (collide-action solid))
        )
      (let ((f0-7 (fill-and-probe-using-line-sphere *collide-cache* (-> s5-0 cquery))))
        (when (>= f0-7 0.0)
          (let ((v1-8 (-> s5-0 vec)))
            (let ((a0-12 (-> s5-0 cquery start-pos)))
              (.lvf vf2 (&-> (-> s5-0 cquery move-dist) quad))
              (.lvf vf1 (&-> a0-12 quad))
              )
            (let ((a0-13 f0-7))
              (.mov vf3 a0-13)
              )
            (.add.x.vf vf4 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf2 vf3)
            (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
            (.svf (&-> v1-8 quad) vf4)
            )
          )
        )
      (set! (-> arg0 quad) (-> s5-0 vec quad))
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch int vs none.
(defmethod draw-arrow task-arrow ((obj task-arrow))
  (cond
    ((logtest? (-> obj flags) (task-arrow-flags task-arrow-flag-00))
     (if (and (not (handle->process (-> obj hud-dist))) *target*)
         (set! (-> obj hud-dist) (ppointer->handle (process-spawn hud-progress :init hud-init-by-other :to *target*)))
         )
     (let ((s5-1 (minimap-method-10 *minimap* (-> obj minimap) (the-as minimap-trail #f))))
       (if (and s5-1 (nonzero? (-> s5-1 last-updated)))
           (set! (-> obj dist) (minimap-trail-method-9 s5-1 (target-pos 0) (-> obj pos)))
           )
       )
     (if (= (-> obj max-dist) 0.0)
         (set! (-> obj max-dist) (-> obj dist))
         )
     (let ((f0-4 (- (-> obj dist) (-> obj smoothed-dist))))
       (if (< (fabs f0-4) 40960.0)
           (+! (-> obj smoothed-dist) (* 10.0 (-> self clock seconds-per-frame) f0-4))
           (set! (-> obj smoothed-dist) (-> obj dist))
           )
       )
     (let ((f1-5 (/ (-> obj smoothed-dist) (-> obj max-dist))))
       (set! (-> *game-info* distance) (- 1.0 (fmax 0.0 (fmin 1.0 f1-5))))
       )
     )
    (else
      (let ((a0-16 (handle->process (-> obj hud-dist))))
        (when a0-16
          (send-event a0-16 'hide-and-die)
          (set! (-> obj hud-dist) (the-as handle #f))
          )
        )
      )
    )
  (cond
    ((-> obj moving)
     (set! (-> obj rod-of-god-scale) (- (-> obj rod-of-god-scale) (* 8.0 (-> self clock seconds-per-frame))))
     (when (< (-> obj rod-of-god-scale) 0.0)
       (set! (-> obj rod-of-god-scale) 0.0)
       (set! (-> obj moving) #f)
       (let ((f0-15 81920.0))
         (cond
           ((< (* f0-15 f0-15) (vector-vector-xz-distance-squared (-> obj pos) (-> obj root trans)))
            (kill-callback (-> *minimap* engine) (-> obj minimap))
            (set! (-> obj root trans quad) (-> obj pos quad))
            (set! (-> obj minimap)
                  (the-as connection-minimap (minimap-method-12 *minimap* obj (-> obj map-icon) #f #t 0))
                  )
            )
           (else
             (set! (-> obj root trans quad) (-> obj pos quad))
             )
           )
         )
       )
     )
    (else
      (set! (-> obj pos quad) (-> obj root trans quad))
      (+! (-> obj rod-of-god-scale) (* 8.0 (-> self clock seconds-per-frame)))
      (if (< 1.0 (-> obj rod-of-god-scale))
          (set! (-> obj rod-of-god-scale) 1.0)
          )
      )
    )
  (cond
    ((zero? (logand (-> obj flags) (task-arrow-flags task-arrow-flag-02)))
     (set! (-> *part-id-table* 267 init-specs 4 initial-valuef) (* 24576.0 (-> obj rod-of-god-scale)))
     (set! (-> *part-id-table* 270 init-specs 3 initial-valuef) (* 65536.0 (-> obj rod-of-god-scale)))
     (set! (-> *part-id-table* 268 init-specs 9 initial-valuef) (* 20.0 (-> obj rod-of-god-scale)))
     (sparticle-launch-control-method-11 (-> obj part) (-> obj root trans))
     )
    (else
      (+! (-> obj theta) (* 32768.0 (-> self clock seconds-per-frame)))
      (+! (-> obj phi) (* 9102.223 (-> self clock seconds-per-frame)))
      (set! (-> obj root trans quad) (-> obj pos quad))
      (set! (-> obj root trans y) (+ 28672.0 (* 4096.0 (cos (-> obj theta))) (-> obj pos y)))
      )
    )
  (when (logtest? (-> obj flags) (task-arrow-flags task-arrow-flag-01))
    (quaternion-axis-angle! (-> obj root quat) 0.0 1.0 0.0 (-> obj phi))
    (quaternion-normalize! (quaternion*! (-> obj root quat) (-> obj base-quat) (-> obj root quat)))
    )
  (ja-post)
  0
  (none)
  )

(defstate idle (task-arrow)
  :virtual #t
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (local-vars (v0-2 none))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'set-position)
           (let ((a0-3 (the-as object (-> arg3 param 0))))
             (set! (-> self pos quad) (-> (the-as vector a0-3) quad))
             )
           (if (logtest? (-> self flags) (task-arrow-flags task-arrow-flag-03))
               (task-arrow-method-23 self (-> self pos))
               )
           (let ((f0-0 4096.0))
             (when (< (* f0-0 f0-0) (vector-vector-xz-distance-squared (-> self pos) (-> self root trans)))
               (set! v0-2 (the-as none #t))
               (set! (-> self moving) (the-as symbol v0-2))
               v0-2
               )
             )
           )
          ((= v1-0 'leave)
           (if (logtest? (-> self flags) (task-arrow-flags task-arrow-flag-02))
               (go-virtual die)
               (go-virtual leave)
               )
           )
          ((= v1-0 'modify-flags)
           (let ((v1-16 (-> arg3 param 0))
                 (a1-3 (-> arg3 param 1))
                 )
             (set! v0-2 (the-as none (logior (logclear (-> self flags) a1-3) v1-16)))
             )
           (set! (-> self flags) (the-as task-arrow-flags v0-2))
           v0-2
           )
          ((= v1-0 'map-icon)
           (kill-callback (-> *minimap* engine) (-> self minimap))
           (let ((a2-1 (-> arg3 param 0)))
             (set! (-> self map-icon) a2-1)
             (set! v0-2 (minimap-method-12 *minimap* self a2-1 #f #t 0))
             )
           (set! (-> self minimap) (the-as connection-minimap v0-2))
           v0-2
           )
          ((= v1-0 'die)
           (go-virtual die)
           )
          )
        )
      )
    )
  :code (the-as (function none :behavior task-arrow) sleep-code)
  :post (behavior ()
    (draw-arrow self)
    (none)
    )
  )

(defstate leave (task-arrow)
  :virtual #t
  :code (behavior ()
    (set! (-> self moving) #t)
    (while (-> self moving)
      (suspend)
      )
    self
    ((method-of-object self process-drawable-method-17))
    (none)
    )
  :post (behavior ()
    (draw-arrow self)
    (none)
    )
  )

(defstate die (task-arrow)
  :virtual #t
  :code (behavior ()
    ((method-of-object self process-drawable-method-17))
    (none)
    )
  )

;; WARN: Return type mismatch object vs task-arrow.
(defbehavior task-arrow-init-by-other task-arrow ((arg0 task-arrow-params))
  (set! (-> self flags) (-> arg0 flags))
  (set! (-> self map-icon) (-> arg0 map-icon))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self pos quad) (-> arg0 pos quad))
  (if (logtest? (-> self flags) (task-arrow-flags task-arrow-flag-03))
      (task-arrow-method-23 self (-> self pos))
      )
  (set! (-> self root trans quad) (-> self pos quad))
  (quaternion-copy! (-> self root quat) (-> arg0 quat))
  (quaternion-copy! (-> self base-quat) (-> arg0 quat))
  (set-vector! (-> self root scale) 1.0 1.0 1.0 1.0)
  (set! (-> self hud-dist) (the-as handle #f))
  (set! (-> self max-dist) 0.0)
  (set! (-> self theta) 0.0)
  (set! (-> self phi) 0.0)
  (set! (-> self minimap)
        (the-as connection-minimap (minimap-method-12 *minimap* self (-> arg0 map-icon) #f #t 0))
        )
  (cond
    ((zero? (logand (-> self flags) (task-arrow-flags task-arrow-flag-02)))
     (set! (-> self part) (create-launch-control (-> *part-group-id-table* 78) self))
     )
    (else
      (initialize-skeleton
        self
        (the-as skeleton-group (art-group-get-by-name *level* "skel-task-arrow" (the-as (pointer uint32) #f)))
        (the-as pair 0)
        )
      (set! (-> self draw lod-set lod 0 dist) 1228800.0)
      (set-vector! (-> self draw color-mult) 0.5 0.5 0.0 1.0)
      (set-vector! (-> self draw color-emissive) 0.5 0.5 0.0 1.0)
      )
    )
  (set! (-> self rod-of-god-scale) 0.0)
  (set! (-> self moving) #f)
  (logclear! (-> self mask) (process-mask actor-pause movie))
  (process-entity-status! self (entity-perm-status bit-3) #t)
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (the-as task-arrow (go-virtual idle))
  )

;; WARN: Return type mismatch process vs none.
(defun task-arrow-spawn ((arg0 task-arrow-params) (arg1 task-arrow))
  (let* ((gp-0 (the-as process #f))
         (s3-0 (get-process *default-dead-pool* task-arrow #x4000))
         (v1-1
           (when s3-0
             (let ((t9-1 (method-of-type task-arrow activate)))
               (t9-1 (the-as task-arrow s3-0) arg1 (symbol->string (-> task-arrow symbol)) (the-as pointer #x70004000))
               )
             (run-now-in-process s3-0 task-arrow-init-by-other arg0)
             (-> s3-0 ppointer)
             )
           )
         )
    (if v1-1
        (set! gp-0 (-> v1-1 0))
        )
    )
  (none)
  )




