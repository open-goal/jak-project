;;-*-Lisp-*-
(in-package goal)

;; name: nav-mesh-h.gc
;; name in dgo: nav-mesh-h
;; dgos: ENGINE, GAME

(defenum nav-mesh-flag
  :type uint8
  :bitfield #t
  (dummy 0)
  )

(declare-type grid-hash basic)
(declare-type sphere-hash grid-hash)

(define-extern nav-mesh-connect-from-ent (function process-drawable symbol))
(define-extern find-nearest-nav-mesh (function vector float nav-mesh))

;; DECOMP BEGINS

(deftype nav-mesh-work-debug (structure)
  ((debug-vec1   vector :inline    :offset-assert   0)
   (debug-vec2   vector :inline    :offset-assert  16)
   (debug-vec3   vector :inline    :offset-assert  32)
   (debug-vec4   vector :inline    :offset-assert  48)
   (debug-vec5   vector :inline    :offset-assert  64)
   (debug-vec6   vector :inline    :offset-assert  80)
   (debug-vec7   vector :inline    :offset-assert  96)
   (debug-vec8   vector :inline    :offset-assert 112)
   (debug-vec9   vector :inline    :offset-assert 128)
   (debug-vec10  vector :inline    :offset-assert 144)
   (debug-vec11  vector :inline    :offset-assert 160)
   (debug-vec12  vector :inline    :offset-assert 176)
   (sphere-array sphere 16 :inline :offset-assert 192)
   )
  :method-count-assert 9
  :size-assert         #x1c0
  :flag-assert         #x9000001c0
  )


(deftype nav-mesh-work (structure)
  ((vert0-table            int8                4          :offset-assert   0)
   (vert1-table            int8                4          :offset-assert   4)
   (edge-mask-table        uint8               3          :offset-assert   8)
   (pad0                   uint32                         :offset-assert  12)
   (deg-to-rad             float                          :offset-assert  16)
   (rad-to-deg             float                          :offset-assert  20)
   (nav-poly-min-dist      float                          :offset-assert  24)
   (nav-poly-epsilon       float                          :offset-assert  28)
   (sphere-array           sphere              16 :inline :offset-assert  32)
   (debug                  nav-mesh-work-debug            :offset-assert 288)
   (work-struct-in-scratch int8                           :offset-assert 292)
   (mesh-struct-in-scratch int8                           :offset-assert 293)
   (polys-in-scratch       int8                           :offset-assert 294)
   (mesh                   nav-mesh                       :offset-assert 296)
   (nav                    basic                          :offset-assert 300)
   (poly0                  nav-poly                       :offset-assert 304)
   (poly1                  nav-poly                       :offset-assert 308)
   (poly-id                int32                          :offset-assert 312)
   )
  :method-count-assert 9
  :size-assert         #x13c
  :flag-assert         #x90000013c
  )


(deftype nav-mesh-link (structure)
  ((id                  uint32    :offset-assert   0)
   (dest-mesh-id        uint32    :offset-assert   4)
   (src-link-poly-id    uint8     :offset-assert   8)
   (src-switch-poly-id  uint8     :offset-assert   9)
   (dest-link-poly-id   uint8     :offset-assert  10)
   (dest-switch-poly-id uint8     :offset-assert  11)
   (dest-mesh           nav-mesh  :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(deftype nav-poly (structure)
  ((data         uint8  64        :offset-assert   0)
   (vertex       vector 4 :inline :offset          0)
   (vertex0      vector :inline   :offset          0)
   (vertex1      vector :inline   :offset         16)
   (vertex2      vector :inline   :offset         32)
   (vertex3      vector :inline   :offset         48)
   (id           uint8            :offset         12)
   (pat          uint8            :offset         13)
   (vertex-count uint8            :offset         14)
   (link         uint8            :offset         15)
   (adj-poly     uint8  4         :offset         28)
   (adj-poly0    uint8            :offset         28)
   (adj-poly1    uint8            :offset         29)
   (adj-poly2    uint8            :offset         30)
   (adj-poly3    uint8            :offset         31)
   (min-y        float            :offset         44)
   (max-y        float            :offset         60)
   )
  :method-count-assert 9
  :size-assert         #x40
  :flag-assert         #x900000040
  )


(deftype nav-vertex (vector)
  "A typedef for `vector`, not used because our code looks nicer if everything is `vector`s anyway
and declared out of order (cannot use forward declared structures in inline arrays)"
  ()
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(deftype nav-sphere (structure)
  ((trans sphere :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(deftype nav-ray (structure)
  ((current-pos  vector   :inline :offset-assert   0)
   (dir          vector   :inline :offset-assert  16)
   (dest-pos     vector   :inline :offset-assert  32)
   (current-poly nav-poly         :offset-assert  48)
   (next-poly    nav-poly         :offset-assert  52)
   (len          meters           :offset-assert  56)
   (last-edge    int8             :offset-assert  60)
   (ignore       uint8            :offset-assert  61)
   (terminated   symbol           :offset-assert  64)
   (reached-dest symbol           :offset-assert  68)
   (hit-boundary symbol           :offset-assert  72)
   (hit-gap      symbol           :offset-assert  76)
   )
  :method-count-assert 9
  :size-assert         #x50
  :flag-assert         #x900000050
  )


(deftype nav-route-portal (structure)
  ((vertex     nav-vertex 2 :inline :offset-assert   0)
   (next-poly  nav-poly             :offset-assert  32)
   (edge-index int8                 :offset-assert  36)
   )
  :method-count-assert 9
  :size-assert         #x25
  :flag-assert         #x900000025
  )


(deftype nav-find-poly-parms (structure)
  ((point         vector   :inline :offset-assert   0)
   (y-threshold   float            :offset-assert  16)
   (ignore        uint8            :offset-assert  20)
   (poly          nav-poly         :offset-assert  24)
   (dist          float            :offset-assert  28)
   (point-inside? symbol           :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  )


(deftype clamp-travel-vector-to-mesh-return-info (structure)
  ((found-boundary  symbol           :offset-assert   0)
   (intersection    vector   :inline :offset-assert  16)
   (boundary-normal vector   :inline :offset-assert  32)
   (prev-normal     vector   :inline :offset-assert  48)
   (next-normal     vector   :inline :offset-assert  64)
   (poly            nav-poly         :offset-assert  80)
   (gap-poly        nav-poly         :offset-assert  84)
   (edge            int8             :offset-assert  88)
   (ignore          uint8            :offset-assert  89)
   (vert-prev       vector   :inline :offset-assert  96)
   (vert-0          vector   :inline :offset-assert 112)
   (vert-1          vector   :inline :offset-assert 128)
   (vert-next       vector   :inline :offset-assert 144)
   )
  :method-count-assert 9
  :size-assert         #xa0
  :flag-assert         #x9000000a0
  )


(deftype nav-mesh (basic)
  ((work                  nav-mesh-work                        :offset-assert   4)
   (poly-array            (inline-array nav-poly)              :offset-assert   8)
   (static-sphere-count   uint8                                :offset-assert  12)
   (poly-count            uint8                                :offset-assert  13)
   (nav-control-count     uint8                                :offset-assert  14)
   (max-nav-control-count uint8                                :offset-assert  15)
   (route                 (pointer nav-poly)                   :offset-assert  16)
   (poly-hash             grid-hash                            :offset-assert  20)
   (nav-control-array     (inline-array nav-control)           :offset-assert  24)
   (sphere-hash           sphere-hash                          :offset-assert  28)
   (static-sphere         (inline-array sphere)                :offset-assert  32)
   (user-list             engine                               :offset-assert  36)
   (next-nav-mesh         surface                              :offset-assert  40)
   (prev-nav-mesh         surface                              :offset-assert  44)
   (bounds                vector                       :inline :offset-assert  48)
   (origin                vector                       :inline :offset         48)
   (entity                entity                               :offset-assert  64)
   (link-array            (inline-array nav-mesh-link)         :offset-assert  68)
   (link-count            uint8                                :offset-assert  72)
   (flags                 nav-mesh-flag                        :offset-assert  73)
   (pad1                  uint8                        2       :offset-assert  74)
   (nearest-y-threshold   meters                               :offset-assert  76)
   (water-max-height      meters                               :offset-assert  80)
   (pad2                  uint32                       7       :offset-assert  84)
   )
  :method-count-assert 47
  :size-assert         #x70
  :flag-assert         #x2f00000070
  (:methods
    (debug-draw (_type_) none 9)
    (nav-mesh-method-10 (_type_ vector vector nav-poly) nav-poly 10)
    (poly-centroid (_type_ nav-poly vector) vector 11)
    (poly-centroid-local (_type_ nav-poly vector) vector 12)
    (lookup-poly-on-route-to-target (_type_ nav-poly nav-poly) nav-poly 13)
    (get-route-portal (_type_ nav-poly nav-poly nav-route-portal) (inline-array nav-vertex) 14)
    (initialize-mesh! (_type_) none 15)
    (move-along-nav-ray! (_type_ nav-ray) none 16)
    (try-move-along-ray (_type_ nav-poly vector vector float) meters 17)
    (clamp-vector-to-mesh-cross-gaps (_type_ vector nav-poly vector float symbol clamp-travel-vector-to-mesh-return-info) none 18)
    (clamp-vector-to-mesh-no-gaps (_type_ vector nav-poly vector clamp-travel-vector-to-mesh-return-info) none 19)
    (set-normals-from-adjacent-bounds (_type_ clamp-travel-vector-to-mesh-return-info) none 20)
    (find-adjacent-bounds-one (_type_ vector nav-poly int int) none 21)
    (compute-bounding-box-from-vertices (_type_ vector vector) none 22)
    (init-from-entity (_type_ entity-nav-mesh) none 23)
    (handle-birth (_type_) none 24)
    (handle-kill (_type_) none 25)
    (update-navigation (_type_) none 26)
    (new-nav-control (_type_ process-drawable) nav-control 27)
    (remove-nav-control (_type_ nav-control) none 28)
    (add-process-drawable-to-navmesh (_type_ process-drawable symbol) none 29)
    (remove-process-drawable (_type_ process-drawable) none 30)
    (change-to (_type_ process-drawable) none 31)
    (link-by-id (_type_ uint) symbol 32)
    (unlink-by-id (_type_ uint) symbol 33)
    (nav-mesh-method-34 (_type_ vector vector float) float 34)
    (nav-mesh-method-35 (_type_ vector vector float) float 35)
    (debug-draw-poly (_type_ nav-poly rgba) none 36)
    (point-in-poly? (_type_ nav-poly vector) symbol 37)
    (nav-mesh-method-38 (_type_ nav-poly vector vector vector (pointer nav-poly)) vector 38)
    (closest-point-on-boundary (_type_ nav-poly vector vector) none 39)
    (project-point-onto-plane-of-poly-local (_type_ nav-poly vector vector vector) none 40)
    (project-point-into-poly-2d (_type_ nav-poly vector vector) none 41)
    (find-poly-containing-point-local (_type_ nav-find-poly-parms) nav-poly 42)
    (find-nearest-poly-to-point-local (_type_ nav-find-poly-parms) nav-find-poly-parms 43)
    (is-in-mesh-local? (_type_ vector float float) symbol 44)
    (link-to-other-mesh (_type_ nav-mesh-link) symbol 45)
    (unlink-mesh (_type_ nav-mesh-link) none 46)
    )
  )


(defun vector-normalize-unity! ((arg0 vector))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((v0-0 arg0))
      (let ((f0-0 1.0))
        (.lvf vf1 (&-> v0-0 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((v1-1 f0-0))
          (.mov vf3 v1-1)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v0-0 quad) vf1)
      v0-0
      )
    )
  )

(defun vector-normalize-unity-copy! ((arg0 vector) (arg1 vector))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (set! (-> arg0 quad) (-> arg1 quad))
    (let ((v0-0 arg0))
      (let ((f0-0 1.0))
        (.lvf vf1 (&-> v0-0 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((v1-2 f0-0))
          (.mov vf3 v1-2)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v0-0 quad) vf1)
      v0-0
      )
    )
  )

(defun-debug debug-validate-current-poly ()
  #f
  )

(defun init-ray ((arg0 nav-ray))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (vector-! (-> arg0 dir) (-> arg0 dest-pos) (-> arg0 current-pos))
    (set! (-> arg0 dir y) 0.0)
    (let ((v1-1 (-> arg0 dir)))
      (let ((f0-1 1.0))
        (.lvf vf1 (&-> v1-1 quad))
        (.mul.vf vf2 vf1 vf1 :mask #b111)
        (let ((a1-2 f0-1))
          (.mov vf3 a1-2)
          )
        )
      (.mul.x.vf acc vf0 vf2 :mask #b1000)
      (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
      (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
      (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
      (.wait.vf)
      (.mul.vf vf1 vf1 Q :mask #b111)
      (.nop.vf)
      (.nop.vf)
      (.nop.vf)
      (.svf (&-> v1-1 quad) vf1)
      )
    (set! (-> arg0 next-poly) #f)
    (set! (-> arg0 len) 0.0)
    (set! (-> arg0 last-edge) -1)
    (set! (-> arg0 terminated) #f)
    (set! (-> arg0 reached-dest) #f)
    (set! (-> arg0 hit-boundary) #f)
    (set! (-> arg0 hit-gap) #f)
    (set! (-> arg0 ignore) (the-as uint 3))
    0
    (none)
    )
  )

(defun point-poly-intersection? ((arg0 nav-mesh) (arg1 vector) (arg2 int) (arg3 (inline-array vector)))
  (let ((v1-1 (-> arg0 work vert0-table))
        (a0-2 (-> arg0 work vert1-table))
        )
    (dotimes (t0-0 arg2)
      (let* ((t1-3 (-> arg3 (-> v1-1 t0-0)))
             (t2-3 (-> arg3 (-> a0-2 t0-0)))
             (f0-1 (- (-> t1-3 z) (-> t2-3 z)))
             (f1-2 (- (-> t2-3 x) (-> t1-3 x)))
             (f2-2 (- (-> arg1 x) (-> t1-3 x)))
             (f3-2 (- (-> arg1 z) (-> t1-3 z)))
             (f0-3 (+ (* f2-2 f0-1) (* f3-2 f1-2)))
             )
        (if (< 0.0 f0-3)
            (return #f)
            )
        )
      )
    )
  #t
  )

(defmethod point-in-poly? nav-mesh ((obj nav-mesh) (arg0 nav-poly) (arg1 vector))
  (let* ((a3-0 obj)
         (v1-0 arg1)
         (a0-1 (-> arg0 vertex-count))
         (a1-1 (-> arg0 vertex))
         (a2-2 (-> a3-0 work vert0-table))
         (a3-2 (-> a3-0 work vert1-table))
         )
    (dotimes (t0-0 (the-as int a0-1))
      (let* ((t1-3 (-> a1-1 (-> a2-2 t0-0)))
             (t2-3 (-> a1-1 (-> a3-2 t0-0)))
             (f0-1 (- (-> t1-3 z) (-> t2-3 z)))
             (f1-2 (- (-> t2-3 x) (-> t1-3 x)))
             (f2-2 (- (-> v1-0 x) (-> t1-3 x)))
             (f3-2 (- (-> v1-0 z) (-> t1-3 z)))
             (f0-3 (+ (* f2-2 f0-1) (* f3-2 f1-2)))
             )
        (if (< 0.0 f0-3)
            (return #f)
            )
        )
      )
    )
  #t
  )

;; WARN: Return type mismatch vector vs none.
(defmethod closest-point-on-boundary nav-mesh ((obj nav-mesh) (arg0 nav-poly) (arg1 vector) (arg2 vector))
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 float))
  (set! sv-48 (new 'stack-no-clear 'vector))
  (set! sv-52 (new 'stack-no-clear 'vector))
  (set! sv-56 (the-as float 10000000000000000000000000000000000000.0))
  (let* ((s3-0 (-> arg0 vertex-count))
         (v1-3 (the-as int (+ s3-0 -1)))
         )
    (dotimes (s2-0 (the-as int s3-0))
      (let ((f0-1 (vector-segment-distance-point! arg2 (-> arg0 vertex v1-3) (-> arg0 vertex s2-0) sv-48)))
        (when (< f0-1 sv-56)
          (set! sv-56 f0-1)
          (set! (-> sv-52 quad) (-> sv-48 quad))
          )
        )
      (set! v1-3 s2-0)
      )
    )
  (set! (-> arg1 quad) (-> sv-52 quad))
  (none)
  )

;; WARN: Return type mismatch vector vs none.
(defmethod project-point-into-poly-2d nav-mesh ((obj nav-mesh) (arg0 nav-poly) (arg1 vector) (arg2 vector))
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 float))
  (cond
    ((point-in-poly? obj arg0 arg2)
     (set! (-> arg1 quad) (-> arg2 quad))
     )
    (else
      (let ((s5-1 arg1))
        (set! sv-48 (new 'stack-no-clear 'vector))
        (set! sv-52 (new 'stack-no-clear 'vector))
        (set! sv-56 (the-as float 10000000000000000000000000000000000000.0))
        (let* ((s2-0 (-> arg0 vertex-count))
               (v1-6 (the-as int (+ s2-0 -1)))
               )
          (dotimes (s1-0 (the-as int s2-0))
            (let ((f0-1 (vector-segment-distance-point! arg2 (-> arg0 vertex v1-6) (-> arg0 vertex s1-0) sv-48)))
              (when (< f0-1 sv-56)
                (set! sv-56 f0-1)
                (set! (-> sv-52 quad) (-> sv-48 quad))
                )
              )
            (set! v1-6 s1-0)
            )
          )
        (set! (-> s5-1 quad) (-> sv-52 quad))
        )
      )
    )
  (none)
  )

(defmethod move-along-nav-ray! nav-mesh ((obj nav-mesh) (ray nav-ray))
  (local-vars
    (next-poly-idx int)
    (work nav-mesh-work)
    (current-poly nav-poly)
    (current-poly-vtx-count uint)
    (v0-table (pointer int8))
    (v1-table (pointer int8))
    (delta-x float)
    (delta-z float)
    (adj-vtx-0 vector)
    (adj-vtx-1 vector)
    (adj-edge-dz float)
    (adj-edge-minus-dx float)
    (sv-68 uint)
    )
  (set! next-poly-idx -1)
  (set! work (-> obj work))
  (set! current-poly (-> ray current-poly))
  (set! current-poly-vtx-count (-> ray current-poly vertex-count))
  (set! v0-table (-> obj work vert0-table))
  (set! v1-table (-> obj work vert1-table))
  (set! delta-x (- (-> ray dest-pos x) (-> ray current-pos x)))
  (set! delta-z (- (-> ray dest-pos z) (-> ray current-pos z)))
  (dotimes (i (the-as int current-poly-vtx-count))
    (set! adj-vtx-0 (-> current-poly vertex (-> v0-table i)))
    (set! adj-vtx-1 (-> current-poly vertex (-> v1-table i)))
    (set! adj-edge-dz (- (-> adj-vtx-0 z) (-> adj-vtx-1 z)))
    (set! adj-edge-minus-dx (- (-> adj-vtx-1 x) (-> adj-vtx-0 x)))
    (let ((heading-dot (+ (* delta-x adj-edge-dz) (* delta-z adj-edge-minus-dx))))
      (when (< 0.0 heading-dot)
        (let ((f1-10 (+ (* adj-edge-dz (- (-> adj-vtx-0 x) (-> ray current-pos x)))
                        (* adj-edge-minus-dx (- (-> adj-vtx-0 z) (-> ray current-pos z)))
                        )
                     )
              )
          (when (< f1-10 heading-dot)
            (set! next-poly-idx i)
            (let ((f0-12 (fmax 0.0 (/ f1-10 heading-dot))))
              (set! delta-x (* delta-x f0-12))
              (set! delta-z (* delta-z f0-12))
              )
            )
          )
        )
      )
    )
  (let ((f0-16 (+ (* delta-x (-> ray dir x)) (* delta-z (-> ray dir z)))))
    (+! (-> ray len) f0-16)
    )
  0
  (set! (-> ray next-poly) #f)
  (cond
    ((= next-poly-idx -1)
     (set! (-> ray current-pos quad) (-> ray dest-pos quad))
     (set! (-> ray reached-dest) #t)
     (set! (-> ray terminated) #t)
     )
    (else
      (+! (-> ray current-pos x) delta-x)
      (+! (-> ray current-pos z) delta-z)
      (set! sv-68 (-> current-poly adj-poly next-poly-idx))
      (if (!= sv-68 255)
          (set! (-> ray next-poly) (-> obj poly-array sv-68))
          )
      (cond
        ((and (-> ray next-poly) (zero? (logand (-> ray next-poly pat) (-> ray ignore))))
         (set! (-> ray current-poly) (-> ray next-poly))
         )
        (else
          (set! (-> ray last-edge) next-poly-idx)
          (if (-> ray next-poly)
              (set! (-> ray hit-gap) #t)
              (set! (-> ray hit-boundary) #t)
              )
          (set! (-> ray terminated) #t)
          )
        )
      )
    )
  0
  (none)
  )

(defun-debug nav-sphere-from-cam ()
  (let ((v1-0 (camera-pos)))
    (format #t "SPHEREM(~4,,1M, ~4,,1M, ~4,,1M, 1.0)~%" (-> v1-0 x) (-> v1-0 y) (-> v1-0 z))
    )
  0
  (none)
  )
