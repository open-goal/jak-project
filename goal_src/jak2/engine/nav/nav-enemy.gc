;;-*-Lisp-*-
(in-package goal)

;; name: nav-enemy.gc
;; name in dgo: nav-enemy
;; dgos: GAME, COMMON

;; DECOMP BEGINS

(defmethod copy-nav-enemy-info! ((this nav-enemy-info) (obj-to-copy nav-enemy-info))
  "Copies the provided [[nav-enemy-info]] into the current object"
  (mem-copy! (&-> this type) (&-> obj-to-copy type) 492)
  0
  (none)
  )

(defmethod enemy-method-61 ((this nav-enemy) (arg0 int))
  (let* ((t9-0 (method-of-type enemy enemy-method-61))
         (s5-0 (t9-0 this arg0))
         )
    (if (and (>= 1 (the-as int (-> this focus aware))) (< 1 s5-0))
        (nav-enemy-method-161 this)
        )
    s5-0
    )
  )

(defmethod general-event-handler ((this nav-enemy) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (case arg2
    (('nav-mesh-kill)
     (deactivate this)
     #t
     )
    (('nav-mesh-new)
     (set! (-> this water-max-height) (-> this nav state mesh water-max-height))
     #t
     )
    (('debug-control-on)
     (go (method-of-object this debug-control))
     )
    (('debug-control-off)
     (react-to-focus this)
     )
    (else
      ((method-of-type enemy general-event-handler) this arg0 arg1 arg2 arg3)
      )
    )
  )

(define *nav-enemy-dummy-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags shdf03 disable-draw)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -4096.0)
                                           )
                               )
  )

(defmethod nav-enemy-method-156 ((this nav-enemy))
  (cond
    ((zero? (-> this path))
     (go process-drawable-art-error "no path")
     )
    (else
      (let ((s4-0 (-> this path curve num-cverts)))
        (if (<= s4-0 0)
            (go process-drawable-art-error "no path")
            )
        (let ((s2-0 (rnd-int-count this s4-0))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (countdown (s3-0 s4-0)
            (get-point-in-path! (-> this path) s5-0 (the float s2-0) 'interp)
            (if (< 4096.0 (vector-vector-xz-distance s5-0 (-> this root trans)))
                (goto cfg-11)
                )
            (set! s2-0 (mod (+ s2-0 1) s4-0))
            )
          (label cfg-11)
          (let ((v1-19 (-> this nav state)))
            (logclear! (-> v1-19 flags) (nav-state-flag directional-mode))
            (logior! (-> v1-19 flags) (nav-state-flag target-poly-dirty))
            (set! (-> v1-19 target-post quad) (-> s5-0 quad))
            )
          )
        )
      0
      )
    )
  0
  (none)
  )

(defmethod enemy-method-102 ((this nav-enemy))
  (let ((gp-0 (-> this root))
        (s3-0 (-> this nav state))
        )
    (do-navigation-to-destination s3-0 (-> gp-0 trans))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (cond
        ((logtest? (-> s3-0 flags) (nav-state-flag in-mesh))
         (set! (-> s4-0 quad) (-> gp-0 trans quad))
         )
        (else
          (if (or (not (cloest-point-on-mesh (-> s3-0 nav) s4-0 (-> gp-0 trans) (the-as nav-poly #f)))
                  (let ((f0-0 32768.0))
                    (< (* f0-0 f0-0) (vector-vector-xz-distance-squared s4-0 (-> gp-0 trans)))
                    )
                  )
              (return #t)
              )
          )
        )
      (cond
        ((-> this enemy-info move-to-ground)
         (let ((s3-1 (new 'stack-no-clear 'collide-query)))
           (when (enemy-above-ground? this s3-1 s4-0 (-> this enemy-info recover-gnd-collide-with) 8192.0 81920.0 1024.0)
             (let ((f0-4 (- (-> gp-0 trans y) (-> s3-1 best-other-tri intersect y))))
               (if (and (>= 12288.0 f0-4) (< -8192.0 f0-4))
                   (return #f)
                   )
               )
             )
           )
         )
        (else
          (return #f)
          )
        )
      )
    )
  #t
  )

;; WARN: Return type mismatch vector vs symbol.
(defmethod enemy-method-100 ((this nav-enemy))
  (local-vars (v0-1 vector))
  (when (not (-> this enemy-info move-to-ground))
    (enemy-method-103 this)
    (return (the-as symbol #f))
    )
  (when (not (logtest? (enemy-flag recover-applied-velocity) (-> this enemy-flags)))
    (let ((s5-0 (-> this root)))
      (if (focus-test? this under-water)
          (enemy-method-47 this (-> s5-0 transv))
          (+! (-> s5-0 transv y) (* (-> this enemy-info movement-gravity) (seconds-per-frame)))
          )
      (let ((a2-0 (new 'stack-no-clear 'move-above-ground-params)))
        (let ((v1-16 (-> this enemy-info)))
          (set! (-> a2-0 gnd-collide-with) (-> v1-16 recover-gnd-collide-with))
          (set! (-> a2-0 popup) 8192.0)
          (set! (-> a2-0 dont-move-if-overlaps?) #t)
          (set! (-> a2-0 hover-if-no-ground?) (-> v1-16 hover-if-no-ground))
          (set! (-> a2-0 overlaps-params options) (overlaps-others-options oo0 oo2))
          (set! (-> a2-0 overlaps-params collide-with-filter) (-> v1-16 overlaps-others-collide-with-filter))
          )
        (set! (-> a2-0 overlaps-params tlist) *touching-list*)
        (-> a2-0 overlaps-params)
        (enemy-method-128 this (-> s5-0 transv) a2-0)
        )
      )
    )
  (logclear! (-> this enemy-flags) (enemy-flag recover-applied-velocity))
  (if (and (enemy-method-102 this) (not (logtest? (-> this focus-status) (focus-status dead))))
      (kill-prefer-falling this)
      )
  (the-as symbol (when (logtest? (-> this nav state flags) (nav-state-flag in-mesh))
                   (let ((s5-1 (-> this root))
                         (a1-2 (new 'stack-no-clear 'collide-query))
                         (s3-0 (new 'stack-no-clear 'vector))
                         (s4-0 (new 'stack-no-clear 'vector))
                         )
                     (set! (-> s3-0 quad) (-> s5-1 gspot-pos quad))
                     (set! (-> s4-0 quad) (-> s5-1 gspot-normal quad))
                     (cond
                       ((find-ground s5-1 a1-2 (-> this enemy-info gnd-collide-with) 8192.0 81920.0 1024.0)
                        (let ((f0-4 (- (-> s5-1 trans y) (-> s5-1 gspot-pos y))))
                          (when (>= 409.6 (fabs f0-4))
                            (enemy-method-103 this)
                            (return (the-as symbol #f))
                            v0-1
                            )
                          )
                        )
                       (else
                         (set! (-> s5-1 gspot-pos quad) (-> s3-0 quad))
                         (set! v0-1 (-> s5-1 gspot-normal))
                         (set! (-> v0-1 quad) (-> s4-0 quad))
                         v0-1
                         )
                       )
                     )
                   )
          )
  )

(defmethod common-post ((self nav-enemy))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
      (set-time! (-> self last-draw-time))
      )
  (enemy-method-129 self)
  (when (logtest? (enemy-flag recover) (-> self enemy-flags))
    (if (-> self nav)
        (enemy-method-100 self)
        (enemy-method-103 self)
        )
    )
  (when *target*
    ;; og:preserve-this target-look-at-me! macro
    (target-look-at-me! :trans (the-as vector (-> self root root-prim prim-core))
                        :message (if (logtest? (-> self enemy-flags) (enemy-flag use-notice-distance))
                                      'attacking
                                      ))
    )
  (when (nonzero? (-> self neck))
    (cond
      ((logtest? (-> self enemy-flags) (enemy-flag look-at-focus))
       (let ((a0-10 (handle->process (-> self focus handle))))
         (if a0-10
             (target-set! (-> self neck) (get-trans (the-as process-focusable a0-10) 2))
             )
         )
       )
      ((logtest? (-> self enemy-flags) (enemy-flag look-at-move-dest))
       (let ((s5-1 (-> self move-dest))
             (v1-47
               (vector<-cspace! (new 'stack-no-clear 'vector) (-> self node-list data (-> self enemy-info neck-joint)))
               )
             (a1-6 (new 'stack-no-clear 'vector))
             )
         (set! (-> a1-6 x) (-> s5-1 x))
         (set! (-> a1-6 y) (-> v1-47 y))
         (set! (-> a1-6 z) (-> s5-1 z))
         (set! (-> a1-6 w) 1.0)
         (target-set! (-> self neck) a1-6)
         )
       )
      )
    )
  (when (and (logtest? (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
             (time-elapsed? (-> self auto-reset-penetrate-time) (seconds 0.1))
             )
    (logclear! (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
    (set! (-> self root penetrated-by) (get-penetrate-info self))
    (let ((v1-62 0))
      (if (logtest? (penetrate knocked) (-> self root penetrate-using))
          (set! v1-62 (logior (shl 1 32) v1-62))
          )
      (set! (-> self root penetrate-using) (the-as penetrate v1-62))
      )
    )
  (if (logtest? (-> self enemy-flags) (enemy-flag victory))
      (enemy-method-136 self)
      )
  (if (logtest? (enemy-flag check-water checking-water) (-> self enemy-flags))
      (enemy-method-54 self)
      )
  (let ((v1-73 (-> self restore-nav-radius-time)))
    (when (nonzero? v1-73)
      (when (>= (current-time) v1-73)
        (set! (-> self restore-nav-radius-time) 0)
        (set! (-> self root nav-radius) (-> self nav-radius-backup))
        )
      )
    )
  (if (and *debug-segment* (-> self enemy-info debug-draw-neck) (nonzero? (-> self neck)))
      (joint-mod-debug-draw (-> self neck))
      )
  (ja-post)
  0
  (none)
  )

(defmethod nav-enemy-method-177 ((this nav-enemy))
  (let ((v1-2 (-> this nav state current-poly)))
    (when (and v1-2 (logtest? (-> v1-2 pat) 4) (!= (-> v1-2 link) 255))
      (let ((v1-6 (-> this nav state mesh link-array (-> v1-2 link) dest-mesh)))
        (if v1-6
            (change-to v1-6 this)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod nav-enemy-method-176 ((this nav-enemy))
  (nav-enemy-method-177 this)
  (cond
    ((nav-enemy-method-174 this)
     (logior! (-> this enemy-flags) (enemy-flag recover-applied-velocity))
     (let ((s5-0 (-> this nav)))
       (when (logtest? (-> s5-0 state flags) (nav-state-flag at-gap))
         (let ((s4-0 (new 'stack-no-clear 'nav-gap-info)))
           (when (plan-over-pat1-polys-using-route (-> s5-0 state) s4-0)
             (set! (-> this enemy-flags)
                   (the-as enemy-flag (logior (enemy-flag jump-check-blocked) (-> this enemy-flags)))
                   )
             (send-event this 'jump 1 (-> s4-0 dest))
             )
           )
         )
       (cond
         ((logtest? (enemy-flag enemy-flag38) (-> this enemy-flags))
          (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag enemy-flag38))))
          )
         (else
           (when (not (logtest? (enemy-flag enemy-flag42) (-> this enemy-flags)))
             (nav-enemy-method-142 this s5-0)
             (nav-enemy-method-143 this s5-0)
             )
           )
         )
       (cond
         ((logtest? (-> s5-0 state flags) (nav-state-flag blocked))
          (if (zero? (-> this blocked-start-time))
              (set-time! (-> this blocked-start-time))
              )
          )
         (else
           (set! (-> this blocked-start-time) 0)
           0
           )
         )
       )
     )
    (else
      (set! (-> this blocked-start-time) 0)
      0
      )
    )
  (common-post this)
  (update-transforms (-> this root))
  0
  (none)
  )

(defmethod nav-enemy-method-145 ((this nav-enemy) (arg0 nav-control))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (-> arg0 state)))
      (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
      (if (< 0.0 (-> gp-0 speed))
          (set! (-> gp-0 rotation-rate)
                (fmin
                  (-> gp-0 rotation-rate)
                  (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                  )
                )
          )
      (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
        (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
        (set! (-> gp-0 heading y) 0.0)
        (let ((v1-12 (-> gp-0 heading)))
          (let ((f0-5 1.0))
            (.lvf vf1 (&-> v1-12 quad))
            (.mul.vf vf2 vf1 vf1 :mask #b111)
            (let ((a0-3 f0-5))
              (.mov vf3 a0-3)
              )
            )
          (.mul.x.vf acc vf0 vf2 :mask #b1000)
          (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
          (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
          (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
          (.wait.vf)
          (.mul.vf vf1 vf1 Q :mask #b111)
          (.nop.vf)
          (.nop.vf)
          (.nop.vf)
          (.svf (&-> v1-12 quad) vf1)
          )
        )
      (let ((a1-2 (new 'stack-no-clear 'vector)))
        (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
        (if (or (not (-> gp-0 current-poly))
                (!= (-> gp-0 current-pos x) (-> a1-2 x))
                (!= (-> gp-0 current-pos z) (-> a1-2 z))
                )
            (do-navigation-to-destination gp-0 a1-2)
            )
        )
      (logclear!
        (-> gp-0 flags)
        (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
        )
      )
    0
    0
    (none)
    )
  )

(defmethod nav-enemy-method-146 ((this nav-enemy) (arg0 nav-control))
  (navigate-using-route-portals (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-147 ((this nav-enemy) (arg0 nav-control))
  (navigate-using-best-dir-recompute-avoid-spheres-1 (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-148 ((this nav-enemy) (arg0 nav-control))
  (navigate-within-poly (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-149 ((this nav-enemy) (arg0 nav-control))
  (compute-travel-speed (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-155 ((this nav-enemy))
  (navigate-v1! (-> this nav state))
  0
  (none)
  )

(defmethod nav-enemy-method-150 ((this nav-enemy) (arg0 nav-control))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (-> arg0 state)))
      (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
      (if (< 0.0 (-> gp-0 speed))
          (set! (-> gp-0 rotation-rate)
                (fmin
                  (-> gp-0 rotation-rate)
                  (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                  )
                )
          )
      (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
        (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
        (set! (-> gp-0 heading y) 0.0)
        (let ((v1-12 (-> gp-0 heading)))
          (let ((f0-5 1.0))
            (.lvf vf1 (&-> v1-12 quad))
            (.mul.vf vf2 vf1 vf1 :mask #b111)
            (let ((a0-3 f0-5))
              (.mov vf3 a0-3)
              )
            )
          (.mul.x.vf acc vf0 vf2 :mask #b1000)
          (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
          (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
          (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
          (.wait.vf)
          (.mul.vf vf1 vf1 Q :mask #b111)
          (.nop.vf)
          (.nop.vf)
          (.nop.vf)
          (.svf (&-> v1-12 quad) vf1)
          )
        )
      (let ((a1-2 (new 'stack-no-clear 'vector)))
        (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
        (if (or (not (-> gp-0 current-poly))
                (!= (-> gp-0 current-pos x) (-> a1-2 x))
                (!= (-> gp-0 current-pos z) (-> a1-2 z))
                )
            (do-navigation-to-destination gp-0 a1-2)
            )
        )
      (logclear!
        (-> gp-0 flags)
        (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
        )
      )
    0
    0
    (none)
    )
  )

(defmethod nav-enemy-method-151 ((this nav-enemy) (arg0 nav-control))
  (navigate-using-route-portals (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-152 ((this nav-enemy) (arg0 nav-control))
  (navigate-using-best-dir-recompute-avoid-spheres-2 (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-153 ((this nav-enemy) (arg0 nav-control))
  (update-travel-dir-from-spheres (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-154 ((this nav-enemy) (arg0 nav-control))
  (compute-speed-simple (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-142 ((this nav-enemy) (arg0 nav-control))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let ((a1-1 (-> arg0 state)))
      (set! (-> s5-0 quad) (-> a1-1 heading quad))
      )
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)

    ;; og:preserve-this modified for PC, see comment near definition in collide-shape-h.gc
    (normalized-heading-to-quaternion! (-> this root quat) s5-0)
    )
  (quaternion-normalize! (-> this root quat))
  0
  (none)
  )

(defmethod nav-enemy-method-143 ((this nav-enemy) (arg0 nav-control))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (let ((a2-0 (-> arg0 state)))
      (set! (-> v1-0 quad) (-> a2-0 velocity quad))
      )
    (let ((a0-3 (-> this root transv)))
      (set! (-> a0-3 x) (-> v1-0 x))
      (set! (-> a0-3 z) (-> v1-0 z))
      )
    )
  (cond
    ((-> this enemy-info move-to-ground)
     (if (focus-test? this under-water)
         (enemy-method-47 this (-> this root transv))
         (+! (-> this root transv y) (* (-> this enemy-info movement-gravity) (seconds-per-frame)))
         )
     (let ((a2-3 (new 'stack-no-clear 'move-above-ground-params)))
       (let ((v1-14 (-> this enemy-info)))
         (set! (-> a2-3 gnd-collide-with) (the-as collide-spec (-> this gnd-collide)))
         (set! (-> a2-3 popup) 8192.0)
         (set! (-> a2-3 dont-move-if-overlaps?) #t)
         (set! (-> a2-3 hover-if-no-ground?) (-> v1-14 hover-if-no-ground))
         (set! (-> a2-3 overlaps-params options) (overlaps-others-options oo0 oo2))
         (set! (-> a2-3 overlaps-params collide-with-filter) (-> v1-14 overlaps-others-collide-with-filter))
         )
       (set! (-> a2-3 overlaps-params tlist) *touching-list*)
       (-> a2-3 overlaps-params)
       (enemy-method-128 this (-> this root transv) a2-3)
       )
     )
    (else
      (let ((a2-4 (new 'stack-no-clear 'overlaps-others-params)))
        (set! (-> a2-4 options) (overlaps-others-options oo0))
        (set! (-> a2-4 collide-with-filter) (-> this enemy-info overlaps-others-collide-with-filter))
        (set! (-> a2-4 tlist) *touching-list*)
        (integrate-for-enemy-no-mtg (-> this root) (-> this root transv) a2-4)
        )
      )
    )
  0
  (none)
  )

(define *nav-enemy-null-callback-info* (new 'static 'nav-callback-info))

(define *nav-enemy-callback-info*
  (new 'static 'nav-callback-info
    :callback-count 5
    :callback-array (new 'static 'array (function object nav-control none) 10
      (lambda ((arg0 object) (arg1 nav-control))
        (rlet ((acc :class vf)
               (Q :class vf)
               (vf0 :class vf)
               (vf1 :class vf)
               (vf2 :class vf)
               (vf3 :class vf)
               )
          (init-vf0-vector)
          (let ((gp-0 (-> arg1 state)))
            (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
            (if (< 0.0 (-> gp-0 speed))
                (set! (-> gp-0 rotation-rate)
                      (fmin
                        (-> gp-0 rotation-rate)
                        (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                        )
                      )
                )
            (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
              (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
              (set! (-> gp-0 heading y) 0.0)
              (let ((v1-14 (-> gp-0 heading)))
                (let ((f0-5 1.0))
                  (.lvf vf1 (&-> v1-14 quad))
                  (.mul.vf vf2 vf1 vf1 :mask #b111)
                  (let ((a0-3 f0-5))
                    (.mov vf3 a0-3)
                    )
                  )
                (.mul.x.vf acc vf0 vf2 :mask #b1000)
                (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
                (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
                (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
                (.wait.vf)
                (.mul.vf vf1 vf1 Q :mask #b111)
                (.nop.vf)
                (.nop.vf)
                (.nop.vf)
                (.svf (&-> v1-14 quad) vf1)
                )
              )
            (let ((a1-2 (new 'stack-no-clear 'vector)))
              (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
              (if (or (not (-> gp-0 current-poly))
                      (!= (-> gp-0 current-pos x) (-> a1-2 x))
                      (!= (-> gp-0 current-pos z) (-> a1-2 z))
                      )
                  (do-navigation-to-destination gp-0 a1-2)
                  )
              )
            (logclear!
              (-> gp-0 flags)
              (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
              )
            )
          0
          0
          0
          (none)
          )
        )
      (lambda ((arg0 object) (arg1 nav-control)) (navigate-using-route-portals (-> arg1 state)) 0 0 0 (none))
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (navigate-using-best-dir-recompute-avoid-spheres-1 (-> arg1 state))
        0
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (navigate-within-poly (-> arg1 state))
        0
        0
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control)) (compute-travel-speed (-> arg1 state)) 0 0 (none))
      )
    )
  )

(define *nav-enemy-physics-callback-info*
  (new 'static 'nav-callback-info
    :callback-count 5
    :callback-array (new 'static 'array (function object nav-control none) 10
      (lambda ((arg0 object) (arg1 nav-control))
        (rlet ((acc :class vf)
               (Q :class vf)
               (vf0 :class vf)
               (vf1 :class vf)
               (vf2 :class vf)
               (vf3 :class vf)
               )
          (init-vf0-vector)
          (let ((gp-0 (-> arg1 state)))
            (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
            (if (< 0.0 (-> gp-0 speed))
                (set! (-> gp-0 rotation-rate)
                      (fmin
                        (-> gp-0 rotation-rate)
                        (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                        )
                      )
                )
            (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
              (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
              (set! (-> gp-0 heading y) 0.0)
              (let ((v1-14 (-> gp-0 heading)))
                (let ((f0-5 1.0))
                  (.lvf vf1 (&-> v1-14 quad))
                  (.mul.vf vf2 vf1 vf1 :mask #b111)
                  (let ((a0-3 f0-5))
                    (.mov vf3 a0-3)
                    )
                  )
                (.mul.x.vf acc vf0 vf2 :mask #b1000)
                (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
                (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
                (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
                (.wait.vf)
                (.mul.vf vf1 vf1 Q :mask #b111)
                (.nop.vf)
                (.nop.vf)
                (.nop.vf)
                (.svf (&-> v1-14 quad) vf1)
                )
              )
            (let ((a1-2 (new 'stack-no-clear 'vector)))
              (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
              (if (or (not (-> gp-0 current-poly))
                      (!= (-> gp-0 current-pos x) (-> a1-2 x))
                      (!= (-> gp-0 current-pos z) (-> a1-2 z))
                      )
                  (do-navigation-to-destination gp-0 a1-2)
                  )
              )
            (logclear!
              (-> gp-0 flags)
              (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
              )
            )
          0
          0
          0
          (none)
          )
        )
      (lambda ((arg0 object) (arg1 nav-control)) (navigate-using-route-portals (-> arg1 state)) 0 0 0 (none))
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (navigate-using-best-dir-recompute-avoid-spheres-2 (-> arg1 state))
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (update-travel-dir-from-spheres (-> arg1 state))
        0
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control)) (compute-speed-simple (-> arg1 state)) 0 0 (none))
      )
    )
  )

(defmethod nav-enemy-method-170 ((this nav-enemy))
  (if (not (logtest? (enemy-flag enemy-flag36) (-> this enemy-flags)))
      (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> this enemy-flags))))
      )
  (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> this enemy-flags))))
  (set! (-> this nav callback-info) (-> this enemy-info callback-info))
  0
  (none)
  )

(defmethod nav-enemy-method-171 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag enemy-flag36))))
  (set! (-> this nav callback-info) *nav-enemy-null-callback-info*)
  0
  (none)
  )

(defmethod nav-enemy-method-172 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> this enemy-flags))))
  0
  (none)
  )

(defmethod nav-enemy-method-173 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag enemy-flag37))))
  0
  (none)
  )

(defmethod nav-enemy-method-174 ((this nav-enemy))
  (logtest? (enemy-flag enemy-flag36) (-> this enemy-flags))
  )

(defmethod nav-enemy-method-175 ((this nav-enemy))
  (logtest? (enemy-flag enemy-flag37) (-> this enemy-flags))
  )

(defmethod nav-enemy-method-157 ((this nav-enemy) (arg0 vector))
  (let ((v1-0 (-> this nav))
        (a0-1 arg0)
        (a1-1 (new 'stack-no-clear 'nav-find-poly-parms))
        )
    (vector-! (-> a1-1 point) a0-1 (-> v1-0 state mesh bounds))
    (set! (-> a1-1 y-threshold) (-> v1-0 nearest-y-threshold))
    (set! (-> a1-1 ignore) (the-as uint 2))
    (find-poly-containing-point-local (-> v1-0 state mesh) a1-1)
    )
  )

(defmethod nav-enemy-method-158 ((this nav-enemy) (arg0 vector))
  (let ((f1-0 (-> this root trans y))
        (f0-0 (-> arg0 y))
        (v1-1 (-> this fact))
        )
    (and (< f0-0 (+ f1-0 (-> v1-1 notice-top)))
         (and (< (- f1-0 (-> v1-1 notice-bottom)) f0-0) (let ((v1-3 (-> this nav))
                                                              (a0-1 arg0)
                                                              (a1-1 (new 'stack-no-clear 'nav-find-poly-parms))
                                                              )
                                                          (vector-! (-> a1-1 point) a0-1 (-> v1-3 state mesh bounds))
                                                          (set! (-> a1-1 y-threshold) (-> v1-3 nearest-y-threshold))
                                                          (set! (-> a1-1 ignore) (the-as uint 2))
                                                          (find-poly-containing-point-local (-> v1-3 state mesh) a1-1)
                                                          )
              )
         )
    )
  )

(defmethod nav-enemy-method-159 ((this nav-enemy) (arg0 vector))
  (let ((f1-0 (-> this root trans y))
        (f0-0 (-> arg0 y))
        (v1-1 (-> this fact))
        )
    (and (< f0-0 (+ f1-0 (-> v1-1 notice-top)))
         (and (< (- f1-0 (-> v1-1 notice-bottom)) f0-0)
              (is-in-mesh? (-> this nav) arg0 (-> this enemy-info notice-nav-radius))
              )
         )
    )
  )

(defmethod in-aggro-range? ((this nav-enemy) (arg0 process-focusable) (arg1 vector))
  "Should the enemy activate.
- if `activate-distance` is `0.0`, always true
- otherwise, check if the provided process is close enough
@param proc The process used to distance check
@returns true/false"
  (if (and arg0 (not arg1))
      (set! arg1 (get-trans arg0 1))
      )
  (when arg1
    (let* ((f0-0 (-> arg1 y))
           (v1-4 (-> this root))
           (f1-0 (-> v1-4 trans y))
           (a0-2 (-> this fact))
           )
      (when (and (< f0-0 (+ f1-0 (-> a0-2 notice-top))) (< (- f1-0 (-> a0-2 notice-bottom)) f0-0))
        (let* ((f30-0 (-> this enemy-info notice-nav-radius))
               (f0-1 f30-0)
               )
          (or (>= (* f0-1 f0-1) (vector-vector-xz-distance-squared (-> v1-4 trans) arg1))
              (is-in-mesh? (-> this nav) arg1 f30-0)
              )
          )
        )
      )
    )
  )

(defmethod nav-enemy-method-161 ((this nav-enemy))
  (set! (-> this enemy-flags) (the-as enemy-flag (logclear (-> this enemy-flags) (enemy-flag not-frustrated))))
  (set-time! (-> this frustration-time))
  (let ((v1-7 (handle->process (-> this focus handle))))
    (if v1-7
        (set! (-> this frustration-point quad) (-> (get-trans (the-as process-focusable v1-7) 1) quad))
        )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod nav-enemy-method-160 ((this nav-enemy))
  (let ((s5-0 (handle->process (-> this focus handle))))
    (cond
      ((or (not s5-0)
           (< 6144.0 (vector-vector-distance (get-trans (the-as process-focusable s5-0) 1) (-> this frustration-point)))
           (< (-> this enemy-info frustration-distance)
              (vector-vector-xz-distance (get-trans (the-as process-focusable s5-0) 0) (-> this root trans))
              )
           )
       (nav-enemy-method-161 this)
       )
      (else
        (when (time-elapsed? (-> this frustration-time) (+ (-> this reaction-time) (-> this enemy-info frustration-time)))
          (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag not-frustrated) (-> this enemy-flags))))
          0
          )
        )
      )
    )
  (none)
  )

(defmethod nav-enemy-method-162 ((this nav-enemy))
  (set! (-> this blocked-start-time) 0)
  0
  (none)
  )

(defmethod nav-enemy-method-163 ((this nav-enemy))
  (let ((v1-0 (-> this blocked-start-time)))
    (and (nonzero? v1-0) (time-elapsed? v1-0 (-> this enemy-info blocked-time)))
    )
  )

(defmethod nav-enemy-method-164 ((this nav-enemy))
  (if (-> this enemy-info use-momentum)
      (logior! (-> this nav flags) (nav-control-flag use-momentum))
      (logclear! (-> this nav flags) (nav-control-flag use-momentum))
      )
  0
  (none)
  )

(defmethod nav-enemy-method-167 ((this nav-enemy))
  (let ((v1-0 (-> this nav)))
    (set! (-> v1-0 target-speed) 0.0)
    )
  0
  (let ((v1-3 (-> this nav state)))
    (set! (-> v1-3 speed) 0.0)
    )
  0
  (let ((v1-5 (-> this nav)))
    (set! (-> v1-5 acceleration) (-> this enemy-info walk-acceleration))
    )
  0
  0
  (none)
  )

(defmethod nav-enemy-method-165 ((this nav-enemy))
  (let ((v1-0 (-> this nav)))
    (set! (-> v1-0 target-speed) (-> this enemy-info walk-travel-speed))
    )
  0
  (let ((v1-2 (-> this nav)))
    (set! (-> v1-2 acceleration) (-> this enemy-info walk-acceleration))
    )
  0
  (let ((v1-4 (-> this nav)))
    (set! (-> v1-4 turning-acceleration) (-> this enemy-info walk-turning-acceleration))
    )
  0
  0
  (none)
  )

(defmethod nav-enemy-method-166 ((this nav-enemy))
  (let ((v1-0 (-> this nav)))
    (set! (-> v1-0 target-speed) (-> this enemy-info run-travel-speed))
    )
  0
  (let ((v1-2 (-> this nav)))
    (set! (-> v1-2 acceleration) (-> this enemy-info run-acceleration))
    )
  0
  (let ((v1-4 (-> this nav)))
    (set! (-> v1-4 turning-acceleration) (-> this enemy-info run-turning-acceleration))
    )
  0
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod set-enemy-info! ((this nav-enemy) (arg0 nav-enemy-info))
  "In addition to setting the `enemy-info`, also init the `neck-joint` if applicable from it
@param info Set `enemy-info` accordingly"
  (set! (-> this enemy-info) arg0)
  (set! (-> arg0 callback-info) *nav-enemy-callback-info*)
  (when (and (!= (-> this enemy-info neck-joint) -1) (zero? (-> this neck)))
    (set! (-> this neck)
          (new 'process 'joint-mod (joint-mod-mode flex-blend) this (-> this enemy-info neck-joint))
          )
    (set-vector! (-> this neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> this neck up) (the-as uint 1))
    (set! (-> this neck nose) (the-as uint 2))
    (set! (-> this neck ear) (the-as uint 0))
    (set! (-> this neck max-dist) 102400.0)
    (set! (-> this neck ignore-angle) 16384.0)
    )
  (none)
  )

(defmethod init-enemy-behaviour-and-stats! ((this nav-enemy) (arg0 nav-enemy-info))
  "Initializes a bunch of enemy fields related to how they should react, how many hitpoints they should have, etc"
  (local-vars (sv-16 res-tag))
  (when (coin-flip? this)
    (let ((a0-2 (-> this node-list data 2)))
      (set! (-> a0-2 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint-flip-z!))
      (set! (-> a0-2 param1) #f)
      (set! (-> a0-2 param2) #f)
      )
    (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag drawn-mirrored) (-> this enemy-flags))))
    )
  (logior! (-> this mask) (process-mask enemy))
  (logior! (-> this mask) (process-mask actor-pause))
  (logior! (-> this enemy-flags) (enemy-flag actor-pause-backup))
  (set! (-> this nav-radius-backup) (-> this root nav-radius))
  (set-enemy-info! this arg0)
  (set! (-> this enemy-info callback-info) *nav-enemy-callback-info*)
  (let ((a1-2 (-> this enemy-info idle-anim-script)))
    (if a1-2
        (idle-control-method-9 (-> this idle-anim-player) a1-2)
        )
    )
  (if (-> this draw shadow)
      (set! (-> this draw shadow-ctrl) (new
                                         'process
                                         'shadow-control
                                         (-> this enemy-info shadow-min-y)
                                         (-> this enemy-info shadow-max-y)
                                         (-> this enemy-info shadow-locus-dist)
                                         (shadow-flags shdf00 shdf04)
                                         245760.0
                                         )
            )
      (set! (-> this draw shadow-ctrl) *nav-enemy-dummy-shadow-control*)
      )
  (get-nav-control this (-> arg0 nav-mesh))
  (set! (-> this water-max-height) (-> this nav state mesh water-max-height))
  (let ((v1-33 this))
    (set! (-> v1-33 enemy-flags) (the-as enemy-flag (logclear (-> v1-33 enemy-flags) (enemy-flag enemy-flag36))))
    (set! (-> v1-33 nav callback-info) *nav-enemy-null-callback-info*)
    )
  0
  (let ((v1-36 this))
    (set! (-> v1-36 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-36 enemy-flags))))
    )
  0
  (logior! (-> this nav flags) (nav-control-flag display-marks limit-rotation-rate))
  (logior! (-> this nav flags) (nav-control-flag update-heading-from-facing))
  (set! (-> this enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag43) (-> this enemy-flags))))
  (let ((v1-47 (-> this nav)))
    (set! (-> v1-47 target-speed) 0.0)
    )
  0
  (let ((v1-49 (-> this nav)))
    (set! (-> v1-49 acceleration) (-> this enemy-info walk-acceleration))
    )
  0
  (let ((v1-51 (-> this nav)))
    (set! (-> v1-51 turning-acceleration) (-> this enemy-info walk-turning-acceleration))
    )
  0
  (let ((v1-53 (-> this nav)))
    (set! (-> v1-53 max-rotation-rate) (-> this enemy-info maximum-rotation-rate))
    )
  0
  (nav-enemy-method-164 this)
  (set! (-> this path) (new 'process 'path-control this 'path 0.0 (the-as entity #f) #t))
  (if (nonzero? (-> this path))
      (logior! (-> this path flags) (path-control-flag display draw-line draw-point draw-text))
      )
  (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
      (set! (-> this hit-points) (* (-> this enemy-info default-hit-points) 2))
      (set! (-> this hit-points) (-> this enemy-info default-hit-points))
      )
  (let* ((v1-71 *game-info*)
         (a0-28 (+ (-> v1-71 attack-id) 1))
         )
    (set! (-> v1-71 attack-id) a0-28)
    (set! (-> this attack-id) a0-28)
    )
  (let* ((v1-72 *game-info*)
         (a0-30 (+ (-> v1-72 attack-id) 1))
         )
    (set! (-> v1-72 attack-id) a0-30)
    (set! (-> this persistent-attack-id) a0-30)
    )
  (enemy-method-124 this)
  (set! (-> this fact) (new
                         'process
                         'fact-info-enemy
                         this
                         (the-as (pointer float) (-> arg0 fact-defaults))
                         (pickup-type eco-pill-random)
                         (-> *FACT-bank* default-eco-pill-green-inc)
                         )
        )
  (let ((a1-9 (if (logtest? (enemy-option multi-focus) (-> this fact enemy-options))
                  1030
                  1026
                  )
              )
        )
    (reset-to-collide-spec (-> this focus) (the-as collide-spec a1-9))
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-82 (res-lump-data (-> this entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-82 (nonzero? (-> sv-16 elt-count)))
       (set! (-> this actor-group) (the-as (pointer actor-group) v1-82))
       (set! (-> this actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> this actor-group) (the-as (pointer actor-group) #f))
        (set! (-> this actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> this on-notice) (res-lump-struct (-> this entity) 'on-notice pair))
  (set! (-> this on-active) (res-lump-struct (-> this entity) 'on-active pair))
  (set! (-> this on-hostile) (res-lump-struct (-> this entity) 'on-hostile pair))
  (set! (-> this on-death) (res-lump-struct (-> this entity) 'on-death pair))
  (if (-> this on-notice)
      (logior! (-> this enemy-flags) (enemy-flag enable-on-notice))
      )
  (if (-> this on-active)
      (logior! (-> this enemy-flags) (enemy-flag enable-on-active))
      )
  (if (-> this on-hostile)
      (logior! (-> this enemy-flags) (enemy-flag enable-on-hostile))
      )
  (set! (-> this incoming attacker-handle) (the-as handle #f))
  (let ((s4-0 (-> this root)))
    (set! (-> this penetrated-by-all) (-> this root penetrated-by))
    (set! (-> this root penetrated-by) (get-penetrate-info this))
    (set! (-> s4-0 event-self) 'touched)
    )
  (set! (-> this penetrated-flinch) (-> arg0 penetrate-flinch))
  (set! (-> this penetrated-knocked) (-> arg0 penetrate-knocked))
  (set! (-> this reaction-time) (the-as time-frame (rnd-int-range this 30 240)))
  (let* ((v1-113 (-> this enemy-flags))
         (a0-47 (-> this fact enemy-options))
         (v1-114
           (logior (enemy-flag vulnerable vulnerable-backup use-notice-distance attackable-backup trackable trackable-backup)
                   v1-113
                   )
           )
         )
    (if (logtest? (enemy-option multi-focus) a0-47)
        (set! v1-114 (logior (enemy-flag multi-focus) v1-114))
        )
    (if (logtest? (enemy-option has-trigger) a0-47)
        (set! v1-114 (logior (enemy-flag use-trigger) v1-114))
        )
    (set! (-> this enemy-flags) v1-114)
    )
  (logior! (-> this mask) (process-mask collectable))
  (do-navigation-to-destination (-> this nav state) (-> this root trans))
  (if (and (-> this enemy-info move-to-ground)
           (not (logtest? (enemy-flag no-initial-move-to-ground) (-> this enemy-flags)))
           (not (logtest? (enemy-option ambush) (-> this fact enemy-options)))
           )
      (enemy-method-127 this 40960.0 40960.0 #t (the-as collide-spec (-> this gnd-collide)))
      )
  (if (zero? (-> this draw light-index))
      (set! (-> this draw light-index) (the-as uint 10))
      )
  0
  (none)
  )

(defmethod init-from-entity! ((this nav-enemy) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-enemy-collision! this)
  (process-drawable-from-entity! this arg0)
  (init-enemy! this)
  (when (> (-> this enemy-info gem-joint) 0)
    (cond
      ((or (and (-> this entity) (logtest? (-> this entity extra perm status) (entity-perm-status save)))
           (not (-> this entity))
           )
       (setup-masks
         (-> this draw)
         (the-as int (-> this enemy-info gem-no-seg))
         (the-as int (-> this enemy-info gem-seg))
         )
       )
      (else
        (setup-masks
          (-> this draw)
          (the-as int (-> this enemy-info gem-seg))
          (the-as int (-> this enemy-info gem-no-seg))
          )
        (add-connection *part-engine* this (-> this enemy-info gem-joint) this 314 (-> this enemy-info gem-offset))
        )
      )
    )
  (let ((v1-25 (-> this fact enemy-options)))
    (cond
      ((logtest? (enemy-option spawner) v1-25)
       (process-entity-status! this (entity-perm-status dead) #t)
       (go (method-of-object this die-fast))
       )
      (*debug-view-anims*
        (go (method-of-object this view-anims))
        )
      ((logtest? (enemy-option dormant) v1-25)
       (let ((v1-33 (-> this root root-prim)))
         (set! (-> v1-33 prim-core collide-as) (collide-spec))
         (set! (-> v1-33 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> this draw status) (draw-control-status no-draw))
       (go (method-of-object this dormant))
       )
      ((logtest? (enemy-option dormant-aware) v1-25)
       (let ((v1-43 (-> this root root-prim)))
         (set! (-> v1-43 prim-core collide-as) (collide-spec))
         (set! (-> v1-43 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> this draw status) (draw-control-status no-draw))
       (go (method-of-object this dormant-aware))
       )
      (else
        (go-idle this)
        )
      )
    )
  0
  (none)
  )

(defbehavior nav-enemy-simple-post nav-enemy ()
  (common-post self)
  (update-transforms (-> self root))
  0
  (none)
  )

(defbehavior nav-enemy-die-falling-post nav-enemy ()
  (enemy-die-falling-post)
  (none)
  )

(defbehavior nav-enemy-travel-post nav-enemy ()
  (nav-enemy-method-176 self)
  (none)
  )

(defbehavior nav-enemy-patrol-post nav-enemy ()
  (when (or (logtest? (-> self nav state flags) (nav-state-flag at-target)) (nav-enemy-method-163 self))
    (nav-enemy-method-156 self)
    (nav-enemy-method-162 self)
    )
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defbehavior nav-enemy-chase-post nav-enemy ()
  (let ((a0-1 (handle->process (-> self focus handle))))
    (when a0-1
      (let ((gp-0 (-> self nav state))
            (v1-7 (get-trans (the-as process-focusable a0-1) 1))
            )
        (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
        (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
        (set! (-> gp-0 target-post quad) (-> v1-7 quad))
        )
      0
      )
    )
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defbehavior nav-enemy-flee-post nav-enemy ()
  (let ((a0-1 (handle->process (-> self focus handle))))
    (when a0-1
      (let ((gp-1
              (vector-! (new 'stack-no-clear 'vector) (-> self root trans) (get-trans (the-as process-focusable a0-1) 0))
              )
            )
        (set! (-> gp-1 y) 0.0)
        (vector-normalize! gp-1 409600.0)
        (vector+! gp-1 gp-1 (-> self root trans))
        (let ((v1-10 (-> self nav state)))
          (logclear! (-> v1-10 flags) (nav-state-flag directional-mode))
          (logior! (-> v1-10 flags) (nav-state-flag target-poly-dirty))
          (set! (-> v1-10 target-post quad) (-> gp-1 quad))
          )
        )
      0
      )
    )
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defbehavior nav-enemy-face-focus-post nav-enemy ()
  (let ((a0-0 self))
    (when (logtest? (enemy-flag enemy-flag37) (-> a0-0 enemy-flags))
      (let ((a0-4 (handle->process (-> self focus handle))))
        (if a0-4
            (seek-to-point-toward-point!
              (-> self root)
              (get-trans (the-as process-focusable a0-4) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (nav-enemy-simple-post)
  0
  (none)
  )

(defmethod nav-enemy-method-169 ((this nav-enemy) (arg0 float) (arg1 symbol))
  (if arg1
      (set! (-> this nav-radius-backup) arg0)
      )
  (if (zero? (-> this restore-nav-radius-time))
      (set! (-> this root nav-radius) arg0)
      )
  )

(defmethod nav-enemy-method-168 ((this nav-enemy))
  (if (zero? (-> this restore-nav-radius-time))
      (set! (-> this root nav-radius) (-> this nav-radius-backup))
      )
  )

;; WARN: Return type mismatch int vs time-frame.
(defmethod nav-enemy-method-144 ((this nav-enemy))
  (set! (-> this root nav-radius) 4.096)
  (let ((s5-1 (max (-> this restore-nav-radius-time) (+ (current-time) (rnd-int-range this 1500 2400)))))
    (set! (-> this restore-nav-radius-time) (the-as time-frame s5-1))
    (the-as time-frame s5-1)
    )
  )

(defbehavior nav-enemy-stare-post nav-enemy ()
  (let ((a0-0 self))
    (when (logtest? (enemy-flag enemy-flag37) (-> a0-0 enemy-flags))
      (let ((a0-4 (handle->process (-> self focus handle))))
        (if a0-4
            (seek-to-point-toward-point!
              (-> self root)
              (get-trans (the-as process-focusable a0-4) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (nav-enemy-method-176 self)
  (if (and (nav-enemy-method-163 self)
           (zero? (-> self restore-nav-radius-time))
           (time-elapsed? (-> self blocked-start-time) (seconds 4))
           )
      (nav-enemy-method-144 self)
      )
  0
  (none)
  )

(defbehavior nav-enemy-falling-post nav-enemy ()
  (enemy-falling-post)
  (none)
  )

(defbehavior nav-enemy-turn-to-face-dir nav-enemy ((arg0 vector) (arg1 float))
  (local-vars (v1-18 symbol))
  (let ((s4-0 (current-time)))
    (ja :group! (-> self draw art-group data (-> self enemy-info turn-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (until v1-18
      (seek-toward-heading-vec! (-> self root) arg0 (-> self nav max-rotation-rate) (seconds 0.02))
      (suspend)
      (ja :num! (loop! 0.75))
      (set! v1-18 (or (time-elapsed? s4-0 (seconds 10)) (enemy-method-94 self arg0 arg1)))
      )
    )
  (forward-up->quaternion (-> self root quat) arg0 *y-vector*)
  0
  (none)
  )

(defbehavior nav-enemy-turn-to-face-point nav-enemy ((arg0 vector) (arg1 float))
  (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> self root trans))))
    (set! (-> gp-1 y) 0.0)
    (when (< 0.0 (vector-length gp-1))
      (vector-normalize! gp-1 1.0)
      (nav-enemy-turn-to-face-dir gp-1 arg1)
      )
    )
  0
  (none)
  )

(defmethod go-stare2 ((this nav-enemy))
  (if (!= (-> this enemy-info taunt-anim) -1)
      (go (method-of-object this taunt))
      )
  (go (method-of-object this stare))
  )

(defmethod go-stare ((this nav-enemy))
  (let ((s5-0 (-> this focus aware)))
    (cond
      ((or (and (-> this enemy-info use-frustration) (logtest? (enemy-flag not-frustrated) (-> this enemy-flags)))
           (nav-enemy-method-163 this)
           )
       (go-stare2 this)
       )
      ((and (= s5-0 (enemy-aware enemy-aware-3)) (-> this enemy-info use-circling))
       (go (method-of-object this circling))
       )
      ((= s5-0 (enemy-aware unaware))
       (go (method-of-object this flee))
       )
      (else
        (go-stare2 this)
        )
      )
    )
  )

(defmethod go-hostile ((this nav-enemy))
  (if (or (and (-> this enemy-info use-frustration) (logtest? (enemy-flag not-frustrated) (-> this enemy-flags)))
          (nav-enemy-method-163 this)
          )
      (go-stare2 this)
      (go (method-of-object this hostile))
      )
  )

(defmethod go-flee ((this nav-enemy))
  (go (method-of-object this flee))
  )

(define *nav-enemy-debug-control-info* (new 'static 'nav-enemy-debug-control-info))

(defbehavior nav-enemy-debug-control-post nav-enemy ()
  (let ((gp-0 *nav-enemy-debug-control-info*))
    (let ((f30-0 (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0)))
      (seek! (-> gp-0 steering) (fmax -1.0 (fmin 1.0 f30-0)) (seconds-per-frame))
      (if (cpad-hold? 0 x)
          (set! (-> gp-0 throttle) 1.0)
          (set! (-> gp-0 throttle) 0.0)
          )
      (format *stdcon* "input-x ~f  steering ~f  throttle ~f~%" f30-0 (-> gp-0 steering) (-> gp-0 throttle))
      )
    (format *stdcon* "target-speed ~M,  speed ~M~%" (-> self nav target-speed) (-> self nav state speed))
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 target-speed) (* 24576.0 (-> gp-0 throttle)))
      )
    0
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (let ((a1-4 (-> self nav state)))
        (set! (-> s4-0 quad) (-> a1-4 heading quad))
        )
      (vector-rotate-y! s4-0 s4-0 (* 1820.4445 (-> gp-0 steering)))
      (vector-float*! s4-0 s4-0 20480.0)
      (vector+! s5-0 (-> self root trans) s4-0)
      (let ((v1-26 (-> self nav state)))
        (logclear! (-> v1-26 flags) (nav-state-flag directional-mode))
        (logior! (-> v1-26 flags) (nav-state-flag target-poly-dirty))
        (set! (-> v1-26 target-post quad) (-> s5-0 quad))
        )
      )
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defstate idle (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self state-timeout) (seconds 1))
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-7 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    )
  )

(defstate dormant (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy dormant) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    )
  )

(defstate dormant-aware (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (-> (method-of-type nav-enemy dormant) enter)
  )

(defstate active (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self state-timeout) (seconds 1))
    (logior! (-> self nav state flags) (nav-state-flag at-target))
    (let ((v1-8 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-8 enemy-flags)))
          (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-8 enemy-flags))))
          )
      (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-8 enemy-flags))))
      (set! (-> v1-8 nav callback-info) (-> v1-8 enemy-info callback-info))
      )
    0
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-11 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (until #f
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info walk-anim))
                    :num! (seek! max f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        (when (rnd-go-idle? self 0.2)
          (ja-no-eval :num! (loop!))
          (ja-channel-push! 1 (seconds 0.6))
          (let ((v1-37 self))
            (set! (-> v1-37 enemy-flags) (the-as enemy-flag (logclear (-> v1-37 enemy-flags) (enemy-flag enemy-flag36))))
            (set! (-> v1-37 nav callback-info) *nav-enemy-null-callback-info*)
            )
          0
          (nav-enemy-method-167 self)
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                      :num! (seek! max f30-0)
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          (until (not (rnd-go-idle? self 0.2))
            (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                        :num! (seek! max f30-0)
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          (let ((v1-101 self))
            (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-101 enemy-flags)))
                (set! (-> v1-101 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-101 enemy-flags))))
                )
            (set! (-> v1-101 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-101 enemy-flags))))
            (set! (-> v1-101 nav callback-info) (-> v1-101 enemy-info callback-info))
            )
          0
          (nav-enemy-method-165 self)
          (ja-no-eval :num! (loop!))
          (ja-channel-push! 1 (seconds 0.6))
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info walk-anim))
                      :num! (seek! max f30-0)
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      )
    #f
    )
  :post nav-enemy-patrol-post
  )

(defstate notice (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy notice) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((a0-1 (handle->process (-> self focus handle))))
      (when a0-1
        (let ((gp-0 (-> self nav state))
              (v1-11 (get-trans (the-as process-focusable a0-1) 0))
              )
          (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
          (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
          (set! (-> gp-0 target-post quad) (-> v1-11 quad))
          )
        0
        )
      )
    (let ((v1-14 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-14 enemy-flags)))
          (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-14 enemy-flags))))
          )
      (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-14 enemy-flags))))
      (set! (-> v1-14 nav callback-info) (-> v1-14 enemy-info callback-info))
      )
    0
    (let ((v1-17 self))
      (set! (-> v1-17 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-17 enemy-flags))))
      )
    0
    (let ((v1-19 (-> self nav)))
      (set! (-> v1-19 target-speed) 0.0)
      )
    0
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (rnd-float-range self 0.8 1.2))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info notice-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (let ((a1-9 (-> self nav state)))
          (set! (-> gp-0 quad) (-> a1-9 travel quad))
          )
        (seek-toward-heading-vec! (-> self root) gp-0 (-> self nav max-rotation-rate) (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (react-to-focus self)
    )
  :post nav-enemy-simple-post
  )

(defstate hostile (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (nav-enemy-method-166 self)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (if (nav-enemy-method-163 self)
          (go-stare2 self)
          )
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (if (-> self enemy-info use-stop-chase)
               (go-virtual stop-chase)
               (go-virtual active)
               )
           )
          ((or (>= 2 (the-as int gp-0)) (not (get-enemy-target self)))
           (go-stare self)
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          )
        )
      (when (and (-> self enemy-info use-frustration) (logtest? (enemy-flag not-frustrated) (-> self enemy-flags)))
        (if (-> self enemy-info use-stop-chase)
            (go-virtual stop-chase)
            (go-stare self)
            )
        )
      )
    )
  :post nav-enemy-chase-post
  )

(defstate stop-chase (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (let ((a2-0 (-> self nav state)))
        (set! (-> a1-0 quad) (-> a2-0 target-post quad))
        )
      (let ((f0-0 (vector-vector-distance (-> self root trans) a1-0)))
        (set! (-> self state-timeout)
              (the-as
                time-frame
                (the int (+ (lerp-scale 300.0 1200.0 f0-0 32768.0 122880.0) (rnd-float-range self 0.0 30.0)))
                )
              )
        )
      )
    (nav-enemy-method-165 self)
    (let ((v1-10 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-10 enemy-flags)))
          (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-10 enemy-flags))))
          )
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-10 enemy-flags))))
      (set! (-> v1-10 nav callback-info) (-> v1-10 enemy-info callback-info))
      )
    0
    (let ((v1-13 self))
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-13 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (when (time-elapsed? (-> self state-time) (seconds 0.1))
      (if (nav-enemy-method-163 self)
          (go-stare2 self)
          )
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (if (time-elapsed? (-> self state-time) (-> self state-timeout))
               (go-virtual active)
               )
           )
          ((and (= gp-0 (enemy-aware enemy-aware-3)) (get-enemy-target self))
           (go-hostile self)
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          (else
            (if (time-elapsed? (-> self state-time) (-> self state-timeout))
                (go-stare self)
                )
            )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data (-> self enemy-info walk-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (rnd-float-range self 0.8 1.2)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    )
  :post nav-enemy-chase-post
  )

(defstate stare (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy stare) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag42) (-> self enemy-flags))))
    (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
    (let ((v1-9 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-9 enemy-flags)))
          (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-9 enemy-flags))))
          )
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-9 enemy-flags))))
      (set! (-> v1-9 nav callback-info) (-> v1-9 enemy-info callback-info))
      )
    0
    (let ((v1-12 self))
      (set! (-> v1-12 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-12 enemy-flags))))
      )
    0
    (nav-enemy-method-167 self)
    (vector-reset! (-> self root transv))
    (set-time! (-> self starting-time))
    )
  :exit (behavior ()
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf3 :class vf)
           )
      (init-vf0-vector)
      (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag42))))
      (let ((v1-4 (-> self nav state)))
        (set! (-> v1-4 speed) 0.0)
        )
      0
      (vector-reset! (-> self root transv))
      (if (logtest? (enemy-flag enemy-flag43) (-> self enemy-flags))
          (logior! (-> self nav flags) (nav-control-flag update-heading-from-facing))
          (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
          )
      (when (and (logtest? (-> self nav flags) (nav-control-flag update-heading-from-facing))
                 (not (nav-enemy-method-163 self))
                 )
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector-z-quaternion! gp-0 (-> self root quat))
          (set! (-> gp-0 y) 0.0)
          (let ((v1-23 gp-0))
            (let ((f0-2 1.0))
              (.lvf vf1 (&-> v1-23 quad))
              (.mul.vf vf2 vf1 vf1 :mask #b111)
              (let ((a0-9 f0-2))
                (.mov vf3 a0-9)
                )
              )
            (.mul.x.vf acc vf0 vf2 :mask #b1000)
            (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
            (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
            (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
            (.wait.vf)
            (.mul.vf vf1 vf1 Q :mask #b111)
            (.nop.vf)
            (.nop.vf)
            (.nop.vf)
            (.svf (&-> v1-23 quad) vf1)
            )
          (set! (-> self nav state heading quad) (-> gp-0 quad))
          )
        0
        )
      )
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag victory)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (let ((gp-0 (-> self focus aware)))
      (if (< (the-as int gp-0) 2)
          (set-time! (-> self starting-time))
          )
      (when (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (not (nav-enemy-method-163 self)))
        (cond
          ((>= 1 (the-as int gp-0))
           (go-virtual active)
           )
          ((= gp-0 (enemy-aware enemy-aware-3))
           (if (and (get-enemy-target self)
                    (not (and (-> self enemy-info use-frustration) (logtest? (enemy-flag not-frustrated) (-> self enemy-flags))))
                    (time-elapsed? (-> self starting-time) (-> self reaction-time))
                    )
               (go-hostile self)
               )
           (if (-> self enemy-info use-circling)
               (go-virtual circling)
               )
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          ((and (= gp-0 (enemy-aware enemy-aware-2))
                (-> self enemy-info use-pacing)
                (time-elapsed? (-> self starting-time) (-> self reaction-time))
                )
           (go-virtual pacing)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info idle-anim)))
          )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post nav-enemy-stare-post
  )

(defstate taunt (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    ((-> (method-of-type nav-enemy stare) enter))
    (let ((gp-0 (handle->process (-> self focus handle))))
      (when (not gp-0)
        (if (nav-enemy-method-163 self)
            (go-virtual stare)
            (go-virtual active)
            )
        )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    )
  :exit (-> (method-of-type nav-enemy stare) exit)
  :trans (behavior ()
    (when (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (not (nav-enemy-method-163 self)))
      (let ((v1-6 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int v1-6))
           (go-virtual active)
           )
          ((and (= v1-6 (enemy-aware enemy-aware-3)) (get-enemy-target self))
           (go-virtual hostile)
           )
          )
        )
      )
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.8 1.2)))
      (let ((gp-0 (rnd-int-range self 60 210))
            (s5-0 (current-time))
            (f28-0 f30-0)
            )
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info idle-anim))
                    :num! (loop! f28-0)
                    :frame-num 0.0
                    )
        (until (time-elapsed? s5-0 gp-0)
          (suspend)
          (ja :num! (loop! f28-0))
          )
        )
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info taunt-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-virtual stare)
    )
  :post nav-enemy-stare-post
  )

(defstate pacing (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (look-at-target! self (enemy-flag look-at-focus))
    (logior! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self move-dest quad) (-> self root trans quad))
    (set! (-> self state-timeout) (the-as time-frame (rnd-int-range self 2100 3300)))
    (set-time! (-> self starting-time))
    (if (zero? (rnd-int-count self 2))
        (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag40) (-> self enemy-flags))))
        (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag40))))
        )
    (let ((gp-0 (handle->process (-> self focus handle))))
      (if (not gp-0)
          (go-virtual active)
          )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (if a0-1
          (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable a0-1) 0) quad))
          )
      )
    (let ((gp-1 (-> self focus aware)))
      (if (or (!= gp-1 3) (not (get-enemy-target self)))
          (set-time! (-> self starting-time))
          )
      (when (time-elapsed? (-> self state-time) (-> self reaction-time))
        (if (>= 1 (the-as int gp-1))
            (go-virtual active)
            )
        (when (= gp-1 (enemy-aware enemy-aware-3))
          (when (and (get-enemy-target self) (time-elapsed? (-> self starting-time) (-> self reaction-time)))
            (nav-enemy-method-161 self)
            (go-virtual hostile)
            )
          (if (-> self enemy-info use-circling)
              (go-virtual circling)
              )
          )
        (if (nav-enemy-method-163 self)
            (go-stare2 self)
            )
        (when (time-elapsed? (-> self state-time) (-> self state-timeout))
          (nav-enemy-method-161 self)
          (go-stare2 self)
          )
        )
      )
    (when (>= 1024.0 (vector-vector-xz-distance (-> self root trans) (-> self move-dest)))
      (when (and (time-elapsed? (-> self state-time) (-> self reaction-time)) (zero? (rnd-int-count self 3)))
        (nav-enemy-method-161 self)
        (go-stare2 self)
        )
      (countdown (gp-4 2)
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (f30-1 16384.0)
              (v1-70 (-> self enemy-flags))
              (s5-0 (-> self move-dest))
              )
          (let ((v1-71 (logxor (shl 256 32) (the-as int v1-70))))
            (set! (-> self enemy-flags) (the-as enemy-flag v1-71))
            (if (logtest? (shl 256 32) v1-71)
                (set! f30-1 (- f30-1))
                )
            )
          (set! (-> s5-0 quad) (-> self focus-pos quad))
          (vector-! s4-0 (-> self root trans) s5-0)
          (set! (-> s4-0 y) 0.0)
          (vector-normalize! s4-0 (rnd-float-range self 16384.0 49152.0))
          (vector-rotate-around-y! s4-0 s4-0 f30-1)
          (vector+! s5-0 s5-0 s4-0)
          (if (and (cloest-point-on-mesh (-> self nav) s5-0 s5-0 (the-as nav-poly #f))
                   (< 4096.0 (vector-vector-xz-distance s5-0 (-> self root trans)))
                   )
              (return #f)
              )
          )
        )
      (go-stare2 self)
      )
    )
  :code (behavior ()
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info walk-anim)))
          )
      (let ((v1-8 (ja-group)))
        (if (not (and v1-8 (= v1-8 gp-0)))
            (ja-channel-push! 1 (seconds 0.2))
            )
        )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self move-dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    )
  )

(defstate circling (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set-time! (-> self state-time))
    (look-at-target! self (enemy-flag look-at-focus))
    (logior! (-> self enemy-flags) (enemy-flag cam-attack-mode))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-11 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((gp-0 (handle->process (-> self focus handle))))
      (if (not gp-0)
          (go-virtual active)
          )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    (let ((f30-0 (-> self enemy-info circle-dist-lo))
          (f28-0 (-> self enemy-info circle-dist-hi))
          )
      (if (zero? (rnd-int-count self 4))
          (set! (-> self desired-angle) (rnd-float-range self f30-0 f28-0))
          (set! (-> self desired-angle)
                (fmax (fmin (vector-vector-xz-distance (-> self focus-pos) (-> self root trans)) f28-0) f30-0)
                )
          )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logxor (shl 256 32) (the-as int (-> self enemy-flags)))))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag41))))
    (set-time! (-> self starting-time))
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (if a0-1
          (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable a0-1) 0) quad))
          )
      )
    (let ((gp-1 (-> self focus aware)))
      (if (or (!= gp-1 3) (not (get-enemy-target self)))
          (set-time! (-> self starting-time))
          )
      (when (time-elapsed? (-> self state-time) (-> self reaction-time))
        (when (>= 1 (the-as int gp-1))
          (nav-enemy-method-161 self)
          (if (-> self enemy-info use-stop-chase)
              (go-virtual stop-chase)
              (go-virtual active)
              )
          )
        (when (and (= gp-1 (enemy-aware enemy-aware-3))
                   (get-enemy-target self)
                   (time-elapsed? (-> self starting-time) (-> self reaction-time))
                   )
          (nav-enemy-method-161 self)
          (go-hostile self)
          )
        (if (= gp-1 (enemy-aware enemy-aware-2))
            (go-stare self)
            )
        (if (or (nav-enemy-method-163 self) (logtest? (enemy-flag enemy-flag41) (-> self enemy-flags)))
            (go-stare2 self)
            )
        )
      )
    )
  :code (behavior ()
    (let ((f30-0 (rnd-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info walk-anim)))
          )
      (let ((v1-8 (ja-group)))
        (if (not (and v1-8 (= v1-8 gp-0)))
            (ja-channel-push! 1 (seconds 0.1))
            )
        )
      (until #f
        (ja-no-eval :group! gp-0 :num! (seek! max f30-0) :frame-num 0.0)
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    )
  :post (behavior ()
    (let ((a0-0 self))
      (when (logtest? (enemy-flag enemy-flag36) (-> a0-0 enemy-flags))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (let ((f30-0 16384.0))
              (if (logtest? (enemy-flag enemy-flag40) (-> self enemy-flags))
                  (set! f30-0 (- f30-0))
                  )
              (set! (-> s5-0 quad) (-> self focus-pos quad))
              (vector-! gp-0 (-> self root trans) s5-0)
              (set! (-> gp-0 y) 0.0)
              (vector-normalize! gp-0 (-> self desired-angle))
              (vector+! s5-0 s5-0 gp-0)
              (vector-rotate-around-y! gp-0 gp-0 f30-0)
              )
            (vector-normalize! gp-0 16384.0)
            (vector+! s5-0 s5-0 gp-0)
            )
          (let ((gp-1 (new 'stack-no-clear 'vector)))
            (set! (-> gp-1 quad) (-> self root trans quad))
            (cloest-point-on-mesh (-> self nav) gp-1 s5-0 (the-as nav-poly #f))
            (if (< (vector-vector-xz-distance gp-1 (-> self root trans)) 409.6)
                (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag41) (-> self enemy-flags))))
                (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag41))))
                )
            (let ((v1-28 (-> self nav state)))
              (logclear! (-> v1-28 flags) (nav-state-flag directional-mode))
              (logior! (-> v1-28 flags) (nav-state-flag target-poly-dirty))
              (set! (-> v1-28 target-post quad) (-> gp-1 quad))
              )
            )
          )
        0
        )
      )
    (nav-enemy-travel-post)
    )
  )

(defstate flee (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy flee) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (nav-enemy-method-166 self)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    )
  :trans (behavior ()
    (when (time-elapsed? (-> self state-time) (-> self reaction-time))
      (let ((v1-3 (-> self focus aware)))
        (if (!= v1-3 (enemy-aware unaware))
            (go-stare self)
            )
        )
      (if (nav-enemy-method-163 self)
          (go-stare2 self)
          )
      )
    )
  :post nav-enemy-flee-post
  )

(defstate victory (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy victory) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (vector-reset! (-> self root transv))
    )
  :post nav-enemy-simple-post
  )

(defstate hit (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hit) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    )
  :code (behavior ()
    (local-vars (v1-37 enemy-flag) (v1-45 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (rnd-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info hit-anim))
                  :num! (seek! max f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag dangerous-backup))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-36 (-> self enemy-flags)))
      (if (logtest? v1-36 (enemy-flag vulnerable-backup))
          (set! v1-37 (logior v1-36 (enemy-flag vulnerable)))
          (set! v1-37 (logclear v1-36 (enemy-flag vulnerable)))
          )
      )
    (set! (-> self enemy-flags) v1-37)
    (if (logtest? (-> self enemy-flags) (enemy-flag attackable-backup))
        (logior! (-> self mask) (process-mask collectable))
        (logclear! (-> self mask) (process-mask collectable))
        )
    (let ((v1-44 (-> self enemy-flags)))
      (if (logtest? (enemy-flag trackable-backup) v1-44)
          (set! v1-45 (logior (enemy-flag trackable) v1-44))
          (set! v1-45 (logclear v1-44 (enemy-flag trackable)))
          )
      )
    (set! (-> self enemy-flags) v1-45)
    (logclear! (-> self enemy-flags) (enemy-flag lock-focus))
    (logclear! (-> self focus-status) (focus-status hit))
    (go-hostile self)
    )
  :post nav-enemy-simple-post
  )

(defstate knocked (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    )
  :post nav-enemy-falling-post
  )

(defstate die (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy die) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    )
  :post nav-enemy-simple-post
  )

(defstate die-falling (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy die-falling) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    )
  :post nav-enemy-die-falling-post
  )

(defmethod enemy-method-82 ((this nav-enemy) (arg0 enemy-jump-info))
  "@abstract"
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> arg0 dest-pos quad))
    (set! (-> v1-0 w) (-> this nav-radius-backup))
    (add-root-sphere-to-hash! (-> this nav) v1-0 #x80068)
    )
  )

;; WARN: Return type mismatch quaternion vs none.
(defmethod enemy-method-92 ((this nav-enemy) (arg0 int) (arg1 enemy-jump-info))
  "@abstract"
  (let ((v1-0 arg0))
    (when (or (zero? v1-0) (= v1-0 1) (= v1-0 2) (= v1-0 3))
      (let ((a1-4 this))
        (if (logtest? (enemy-flag enemy-flag37) (-> a1-4 enemy-flags))
            (seek-to-point-toward-point! (-> this root) (-> arg1 dest-pos) (-> this nav max-rotation-rate) (seconds 0.02))
            )
        )
      )
    )
  (none)
  )

(defstate jump (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (logclear! (-> self nav state flags) (nav-state-flag at-gap))
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump) exit)))
      (if t9-0
          (t9-0)
          )
      )
    ;; og:preserve-this fix potential use-after-free bug
    (if (-> self nav)
      (let ((v1-4 (-> self nav)))
        (logclear! (-> v1-4 shape nav-flags) (nav-flags has-extra-sphere))
        ))
    0
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'enemy-jump-info)))
      (let ((s5-0 0))
        (enemy-method-83 self gp-0)
        (if (and (-> self enemy-info use-jump-blocked)
                 (logtest? (enemy-flag jump-check-blocked) (-> self enemy-flags))
                 (enemy-method-82 self gp-0)
                 )
            (go-virtual jump-blocked)
            )
        (let* ((v1-13 (-> self nav))
               (a1-2 (-> gp-0 dest-pos))
               (f0-0 (-> v1-13 extra-nav-sphere w))
               )
          (set! (-> v1-13 extra-nav-sphere quad) (-> a1-2 quad))
          (set! (-> v1-13 extra-nav-sphere w) f0-0)
          )
        0
        (let ((v1-16 (-> self nav)))
          (set! (-> v1-16 extra-nav-sphere w) (-> self nav-radius-backup))
          )
        0
        (let ((v1-18 (-> self nav)))
          (logior! (-> v1-18 shape nav-flags) (nav-flags has-extra-sphere))
          )
        0
        (when (logtest? (-> gp-0 flags) (enemy-jump-flags enjflag-0))
          (until #f
            (if (enemy-method-90 self s5-0 gp-0)
                (goto cfg-12)
                )
            (enemy-method-91 self s5-0 gp-0)
            (enemy-method-92 self s5-0 gp-0)
            (suspend)
            (set! s5-0 1)
            )
          #f
          )
        )
      (label cfg-12)
      (logclear! (-> self root status) (collide-status on-surface on-ground touch-surface))
      (let ((s5-1 2))
        (logior! (-> self focus-status) (focus-status in-air))
        (until (enemy-method-86 self)
          (+! (-> gp-0 hang-time) (- (current-time) (-> self clock old-frame-counter)))
          (enemy-method-90 self s5-1 gp-0)
          (enemy-method-91 self s5-1 gp-0)
          (enemy-method-92 self s5-1 gp-0)
          (suspend)
          (set! s5-1 3)
          )
        )
      (logclear! (-> self focus-status) (focus-status in-air))
      (let ((v1-51 (-> self nav)))
        (logclear! (-> v1-51 shape nav-flags) (nav-flags has-extra-sphere))
        )
      0
      (let ((v1-55 (-> self nav state)))
        (set! (-> v1-55 current-poly) (the-as nav-poly #f))
        )
      0
      (logclear! (-> self nav state flags) (nav-state-flag at-target))
      (enemy-method-85 self)
      (let ((s5-2 4))
        (until #f
          (if (enemy-method-90 self s5-2 gp-0)
              (goto cfg-19)
              )
          (enemy-method-91 self s5-2 gp-0)
          (enemy-method-92 self s5-2 gp-0)
          (suspend)
          (set! s5-2 5)
          )
        )
      #f
      (label cfg-19)
      (if (logtest? (enemy-flag directed) (-> self enemy-flags))
          ((lambda :behavior nav-enemy
             ((arg0 enemy-jump-info))
             (send-event (ppointer->process (-> self parent)) 'child-jumped)
             (none)
             )
           gp-0
           )
          )
      )
    (enemy-method-93 self)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (cond
        ((logtest? (enemy-flag enemy-flag36) (-> a0-0 enemy-flags))
         (nav-enemy-method-176 self)
         )
        (else
          (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
            (set! (-> a1-2 options) (overlaps-others-options))
            (set! (-> a1-2 collide-with-filter) (-> self enemy-info overlaps-others-collide-with-filter))
            (set! (-> a1-2 tlist) *touching-list*)
            (find-overlapping-shapes (-> self root) a1-2)
            )
          (nav-enemy-simple-post)
          )
        )
      )
    )
  )

(defstate jump-blocked (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump-blocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    )
  :post nav-enemy-simple-post
  )

(defstate directed (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag directed-ready))
    ((-> (method-of-type nav-enemy idle) enter))
    )
  :code (-> (method-of-type nav-enemy idle) code)
  :post (-> (method-of-type nav-enemy idle) post)
  )

(defstate view-anims (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (when (-> self nav)
      (let ((v1-1 self))
        (set! (-> v1-1 enemy-flags) (the-as enemy-flag (logclear (-> v1-1 enemy-flags) (enemy-flag enemy-flag37))))
        )
      0
      (let ((v1-3 self))
        (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logclear (-> v1-3 enemy-flags) (enemy-flag enemy-flag36))))
        (set! (-> v1-3 nav callback-info) *nav-enemy-null-callback-info*)
        )
      0
      )
    )
  )

(defstate debug-control (nav-enemy)
  :virtual #t
  :event enemy-event-handler
  :code (behavior ()
    (let ((v1-0 *nav-enemy-debug-control-info*))
      (set! (-> v1-0 steering) 0.0)
      (set! (-> v1-0 throttle) 0.0)
      )
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info walk-anim)) :num! (seek!) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    )
  :post nav-enemy-debug-control-post
  )
