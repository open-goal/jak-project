;;-*-Lisp-*-
(in-package goal)

;; name: nav-enemy.gc
;; name in dgo: nav-enemy
;; dgos: GAME, COMMON

;; DECOMP BEGINS

(defmethod copy-nav-enemy-info! nav-enemy-info ((obj nav-enemy-info) (obj-to-copy nav-enemy-info))
  "Copies the provided [[nav-enemy-info]] into the current object"
  (mem-copy! (&-> obj type) (&-> obj-to-copy type) 492)
  0
  (none)
  )

(defmethod enemy-method-61 nav-enemy ((obj nav-enemy) (arg0 int))
  (let* ((t9-0 (method-of-type enemy enemy-method-61))
         (s5-0 (t9-0 obj arg0))
         )
    (if (and (>= 1 (the-as int (-> obj focus aware))) (< 1 s5-0))
        (nav-enemy-method-161 obj)
        )
    s5-0
    )
  )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 7]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 15]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 23]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 33]
(defmethod general-event-handler nav-enemy ((obj nav-enemy) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (let ((v1-0 arg2))
    (the-as object (cond
                     ((= v1-0 'nav-mesh-kill)
                      (deactivate obj)
                      #t
                      )
                     ((= v1-0 'nav-mesh-new)
                      (set! (-> obj water-max-height) (-> obj nav state mesh water-max-height))
                      #t
                      )
                     ((= v1-0 'debug-control-on)
                      (go (method-of-object obj debug-control))
                      )
                     ((= v1-0 'debug-control-off)
                      (react-to-focus obj)
                      )
                     (else
                       ((method-of-type enemy general-event-handler) obj arg0 arg1 arg2 arg3)
                       )
                     )
            )
    )
  )

(define *nav-enemy-dummy-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags shdf03 disable-draw)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -4096.0)
                                           )
                               )
  )

(defmethod nav-enemy-method-156 nav-enemy ((obj nav-enemy))
  (cond
    ((zero? (-> obj path))
     (go process-drawable-art-error "no path")
     )
    (else
      (let ((s4-0 (-> obj path curve num-cverts)))
        (if (<= s4-0 0)
            (go process-drawable-art-error "no path")
            )
        (let ((s2-0 (get-rand-int obj s4-0))
              (s5-0 (new 'stack-no-clear 'vector))
              )
          (countdown (s3-0 s4-0)
            (get-point-in-path! (-> obj path) s5-0 (the float s2-0) 'interp)
            (if (< 4096.0 (vector-vector-xz-distance s5-0 (-> obj root-override2 trans)))
                (goto cfg-11)
                )
            (set! s2-0 (mod (+ s2-0 1) s4-0))
            )
          (label cfg-11)
          (let ((v1-19 (-> obj nav state)))
            (logclear! (-> v1-19 flags) (nav-state-flag directional-mode))
            (logior! (-> v1-19 flags) (nav-state-flag target-poly-dirty))
            (set! (-> v1-19 target-post quad) (-> s5-0 quad))
            )
          )
        )
      0
      )
    )
  0
  (none)
  )

(defmethod enemy-method-102 nav-enemy ((obj nav-enemy))
  (let ((gp-0 (-> obj root-override2))
        (s3-0 (-> obj nav state))
        )
    (do-navigation-to-destination s3-0 (-> gp-0 trans))
    (let ((s4-0 (new 'stack-no-clear 'vector)))
      (cond
        ((logtest? (-> s3-0 flags) (nav-state-flag in-mesh))
         (set! (-> s4-0 quad) (-> gp-0 trans quad))
         )
        (else
          (if (or (not (cloest-point-on-mesh (-> s3-0 nav) s4-0 (-> gp-0 trans) (the-as nav-poly #f)))
                  (let ((f0-0 32768.0))
                    (< (* f0-0 f0-0) (vector-vector-xz-distance-squared s4-0 (-> gp-0 trans)))
                    )
                  )
              (return #t)
              )
          )
        )
      (cond
        ((-> obj enemy-info-override move-to-ground)
         (let ((s3-1 (new 'stack-no-clear 'collide-query)))
           (when (enemy-above-ground?
                   obj
                   s3-1
                   s4-0
                   (-> obj enemy-info-override recover-gnd-collide-with)
                   8192.0
                   81920.0
                   1024.0
                   )
             (let ((f0-4 (- (-> gp-0 trans y) (-> s3-1 best-other-tri intersect y))))
               (if (and (>= 12288.0 f0-4) (< -8192.0 f0-4))
                   (return #f)
                   )
               )
             )
           )
         )
        (else
          (return #f)
          )
        )
      )
    )
  #t
  )

;; WARN: Return type mismatch vector vs symbol.
(defmethod enemy-method-100 nav-enemy ((obj nav-enemy))
  (local-vars (v0-1 vector))
  (with-pp
    (when (not (-> obj enemy-info-override move-to-ground))
      (enemy-method-103 obj)
      (return (the-as symbol #f))
      )
    (when (not (logtest? (enemy-flag directed) (-> obj enemy-flags)))
      (let ((s5-0 (-> obj root-override2)))
        (if (focus-test? obj under-water)
            (enemy-method-47 obj (-> s5-0 transv))
            (+! (-> s5-0 transv y) (* (-> obj enemy-info-override movement-gravity) (-> pp clock seconds-per-frame)))
            )
        (let ((a2-0 (new 'stack-no-clear 'move-above-ground-params)))
          (let ((v1-16 (-> obj enemy-info-override)))
            (set! (-> a2-0 gnd-collide-with) (-> v1-16 recover-gnd-collide-with))
            (set! (-> a2-0 popup) 8192.0)
            (set! (-> a2-0 dont-move-if-overlaps?) #t)
            (set! (-> a2-0 hover-if-no-ground?) (-> v1-16 hover-if-no-ground))
            (set! (-> a2-0 overlaps-params options) (overlaps-others-options oo0 oo2))
            (set! (-> a2-0 overlaps-params collide-with-filter) (-> v1-16 overlaps-others-collide-with-filter))
            )
          (set! (-> a2-0 overlaps-params tlist) *touching-list*)
          (-> a2-0 overlaps-params)
          (enemy-method-128 obj (-> s5-0 transv) a2-0)
          )
        )
      )
    (logclear! (-> obj enemy-flags) (enemy-flag directed))
    (if (and (enemy-method-102 obj) (not (logtest? (-> obj focus-status) (focus-status dead))))
        (kill-prefer-falling obj)
        )
    (the-as
      symbol
      (when (logtest? (-> obj nav state flags) (nav-state-flag in-mesh))
        (let ((s5-1 (-> obj root-override2))
              (a1-2 (new 'stack-no-clear 'collide-query))
              (s3-0 (new 'stack-no-clear 'vector))
              (s4-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s3-0 quad) (-> s5-1 gspot-pos quad))
          (set! (-> s4-0 quad) (-> s5-1 gspot-normal quad))
          (cond
            ((find-ground s5-1 a1-2 (-> obj enemy-info-override gnd-collide-with) 8192.0 81920.0 1024.0)
             (let ((f0-4 (- (-> s5-1 trans y) (-> s5-1 gspot-pos y))))
               (when (>= 409.6 (fabs f0-4))
                 (enemy-method-103 obj)
                 (return (the-as symbol #f))
                 v0-1
                 )
               )
             )
            (else
              (set! (-> s5-1 gspot-pos quad) (-> s3-0 quad))
              (set! v0-1 (-> s5-1 gspot-normal))
              (set! (-> v0-1 quad) (-> s4-0 quad))
              v0-1
              )
            )
          )
        )
      )
    )
  )

(defmethod track-target! nav-enemy ((obj nav-enemy))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (with-pp
    (if (and (nonzero? (-> obj draw)) (logtest? (-> obj draw status) (draw-control-status on-screen)))
        (set! (-> obj last-draw-time) (-> pp clock frame-counter))
        )
    (enemy-method-129 obj)
    (when (logtest? (enemy-flag use-trigger) (-> obj enemy-flags))
      (if (-> obj nav)
          (enemy-method-100 obj)
          (enemy-method-103 obj)
          )
      )
    (when *target*
      (if *target*
          (look-at!
            (-> *target* neck)
            (the-as vector (-> obj root-override2 root-prim prim-core))
            (if (logtest? (-> obj enemy-flags) (enemy-flag use-notice-distance))
                'attacking
                )
            obj
            )
          )
      )
    (when (nonzero? (-> obj neck))
      (cond
        ((logtest? (-> obj enemy-flags) (enemy-flag lock-focus))
         (let ((a0-10 (handle->process (-> obj focus handle))))
           (if a0-10
               (target-set! (-> obj neck) (get-trans (the-as process-focusable a0-10) 2))
               )
           )
         )
        ((logtest? (-> obj enemy-flags) (enemy-flag death-start))
         (let ((s5-1 (-> obj move-dest))
               (v1-47 (vector<-cspace!
                        (new 'stack-no-clear 'vector)
                        (-> obj node-list data (-> obj enemy-info-override neck-joint))
                        )
                      )
               (a1-6 (new 'stack-no-clear 'vector))
               )
           (set! (-> a1-6 x) (-> s5-1 x))
           (set! (-> a1-6 y) (-> v1-47 y))
           (set! (-> a1-6 z) (-> s5-1 z))
           (set! (-> a1-6 w) 1.0)
           (target-set! (-> obj neck) a1-6)
           )
         )
        )
      )
    (when (and (logtest? (-> obj enemy-flags) (enemy-flag attackable-backup))
               (>= (- (-> pp clock frame-counter) (-> obj auto-reset-penetrate-time)) (seconds 0.1))
               )
      (logclear! (-> obj enemy-flags) (enemy-flag attackable-backup))
      (set! (-> obj root-override2 penetrated-by) (get-penetrate-info obj))
      (let ((v1-62 0))
        (if (logtest? (penetrate knocked) (-> obj root-override2 penetrate-using))
            (set! v1-62 (logior (shl 1 32) v1-62))
            )
        (set! (-> obj root-override2 penetrate-using) (the-as penetrate v1-62))
        )
      )
    (if (logtest? (-> obj enemy-flags) (enemy-flag look-at-focus))
        (enemy-method-136 obj)
        )
    (if (logtest? (enemy-flag trackable-backup directed-ready) (-> obj enemy-flags))
        (enemy-method-54 obj)
        )
    (let ((v1-73 (-> obj restore-nav-radius-time)))
      (when (nonzero? v1-73)
        (when (>= (-> pp clock frame-counter) v1-73)
          (set! (-> obj restore-nav-radius-time) 0)
          (set! (-> obj root-override2 nav-radius) (-> obj nav-radius-backup))
          )
        )
      )
    (if (and *debug-segment* (-> obj enemy-info-override debug-draw-neck) (nonzero? (-> obj neck)))
        (joint-mod-debug-draw (-> obj neck))
        )
    (ja-post)
    0
    (none)
    )
  )

(defmethod nav-enemy-method-177 nav-enemy ((obj nav-enemy))
  (let ((v1-2 (-> obj nav state current-poly)))
    (when (and v1-2 (logtest? (-> v1-2 pat) 4) (!= (-> v1-2 link) 255))
      (let ((v1-6 (-> obj nav state mesh link-array (-> v1-2 link) dest-mesh)))
        (if v1-6
            (change-to v1-6 obj)
            )
        )
      )
    )
  0
  (none)
  )

(defmethod nav-enemy-method-176 nav-enemy ((obj nav-enemy))
  (nav-enemy-method-177 obj)
  (cond
    ((nav-enemy-method-174 obj)
     (set! (-> obj enemy-flags) (logior (enemy-flag directed) (-> obj enemy-flags)))
     (let ((s5-0 (-> obj nav)))
       (when (logtest? (-> s5-0 state flags) (nav-state-flag at-gap))
         (let ((s4-0 (new 'stack-no-clear 'nav-gap-info)))
           (when (plan-over-pat1-polys-using-route (-> s5-0 state) s4-0)
             (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag vulnerable) (-> obj enemy-flags))))
             (send-event obj 'jump 1 (-> s4-0 dest))
             )
           )
         )
       (cond
         ((logtest? (enemy-flag enemy-flag38) (-> obj enemy-flags))
          (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag enemy-flag38))))
          )
         (else
           (when (not (logtest? (enemy-flag enemy-flag42) (-> obj enemy-flags)))
             (nav-enemy-method-142 obj s5-0)
             (nav-enemy-method-143 obj s5-0)
             )
           )
         )
       (cond
         ((logtest? (-> s5-0 state flags) (nav-state-flag blocked))
          (if (zero? (-> obj blocked-start-time))
              (set! (-> obj blocked-start-time) (-> self clock frame-counter))
              )
          )
         (else
           (set! (-> obj blocked-start-time) 0)
           0
           )
         )
       )
     )
    (else
      (set! (-> obj blocked-start-time) 0)
      0
      )
    )
  (track-target! obj)
  (update-transforms (-> obj root-override2))
  0
  (none)
  )

(defmethod nav-enemy-method-145 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (-> arg0 state)))
      (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
      (if (< 0.0 (-> gp-0 speed))
          (set! (-> gp-0 rotation-rate)
                (fmin
                  (-> gp-0 rotation-rate)
                  (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                  )
                )
          )
      (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
        (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
        (set! (-> gp-0 heading y) 0.0)
        (let ((v1-12 (-> gp-0 heading)))
          (let ((f0-5 1.0))
            (.lvf vf1 (&-> v1-12 quad))
            (.mul.vf vf2 vf1 vf1 :mask #b111)
            (let ((a0-3 f0-5))
              (.mov vf3 a0-3)
              )
            )
          (.mul.x.vf acc vf0 vf2 :mask #b1000)
          (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
          (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
          (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
          (.wait.vf)
          (.mul.vf vf1 vf1 Q :mask #b111)
          (.nop.vf)
          (.nop.vf)
          (.nop.vf)
          (.svf (&-> v1-12 quad) vf1)
          )
        )
      (let ((a1-2 (new 'stack-no-clear 'vector)))
        (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
        (if (or (not (-> gp-0 current-poly))
                (!= (-> gp-0 current-pos x) (-> a1-2 x))
                (!= (-> gp-0 current-pos z) (-> a1-2 z))
                )
            (do-navigation-to-destination gp-0 a1-2)
            )
        )
      (logclear!
        (-> gp-0 flags)
        (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
        )
      )
    0
    0
    (none)
    )
  )

(defmethod nav-enemy-method-146 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (navigate-using-route-portals (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-147 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (navigate-using-best-dir-recompute-avoid-spheres-1 (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-148 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (navigate-within-poly (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-149 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (compute-travel-speed (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-155 nav-enemy ((obj nav-enemy))
  (navigate-v1! (-> obj nav state))
  0
  (none)
  )

(defmethod nav-enemy-method-150 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (-> arg0 state)))
      (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
      (if (< 0.0 (-> gp-0 speed))
          (set! (-> gp-0 rotation-rate)
                (fmin
                  (-> gp-0 rotation-rate)
                  (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                  )
                )
          )
      (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
        (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
        (set! (-> gp-0 heading y) 0.0)
        (let ((v1-12 (-> gp-0 heading)))
          (let ((f0-5 1.0))
            (.lvf vf1 (&-> v1-12 quad))
            (.mul.vf vf2 vf1 vf1 :mask #b111)
            (let ((a0-3 f0-5))
              (.mov vf3 a0-3)
              )
            )
          (.mul.x.vf acc vf0 vf2 :mask #b1000)
          (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
          (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
          (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
          (.wait.vf)
          (.mul.vf vf1 vf1 Q :mask #b111)
          (.nop.vf)
          (.nop.vf)
          (.nop.vf)
          (.svf (&-> v1-12 quad) vf1)
          )
        )
      (let ((a1-2 (new 'stack-no-clear 'vector)))
        (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
        (if (or (not (-> gp-0 current-poly))
                (!= (-> gp-0 current-pos x) (-> a1-2 x))
                (!= (-> gp-0 current-pos z) (-> a1-2 z))
                )
            (do-navigation-to-destination gp-0 a1-2)
            )
        )
      (logclear!
        (-> gp-0 flags)
        (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
        )
      )
    0
    0
    (none)
    )
  )

(defmethod nav-enemy-method-151 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (navigate-using-route-portals (-> arg0 state))
  0
  0
  (none)
  )

(defmethod nav-enemy-method-152 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (navigate-using-best-dir-recompute-avoid-spheres-2 (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-153 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (update-travel-dir-from-spheres (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-154 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (compute-speed-simple (-> arg0 state))
  0
  (none)
  )

(defmethod nav-enemy-method-142 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (let ((s5-0 (new 'stack-no-clear 'vector)))
    (let ((a1-1 (-> arg0 state)))
      (set! (-> s5-0 quad) (-> a1-1 heading quad))
      )
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)
    (quaternion-set! (-> obj root-override2 quat) 0.0 (-> s5-0 x) 0.0 (+ 1.0 (-> s5-0 z)))
    )
  (quaternion-normalize! (-> obj root-override2 quat))
  0
  (none)
  )

(defmethod nav-enemy-method-143 nav-enemy ((obj nav-enemy) (arg0 nav-control))
  (with-pp
    (let ((v1-0 (new 'stack-no-clear 'vector)))
      (let ((a2-0 (-> arg0 state)))
        (set! (-> v1-0 quad) (-> a2-0 velocity quad))
        )
      (let ((a0-3 (-> obj root-override2 transv)))
        (set! (-> a0-3 x) (-> v1-0 x))
        (set! (-> a0-3 z) (-> v1-0 z))
        )
      )
    (cond
      ((-> obj enemy-info-override move-to-ground)
       (if (focus-test? obj under-water)
           (enemy-method-47 obj (-> obj root-override2 transv))
           (+! (-> obj root-override2 transv y)
               (* (-> obj enemy-info-override movement-gravity) (-> pp clock seconds-per-frame))
               )
           )
       (let ((a2-3 (new 'stack-no-clear 'move-above-ground-params)))
         (let ((v1-14 (-> obj enemy-info-override)))
           (set! (-> a2-3 gnd-collide-with) (the-as collide-spec (-> obj gnd-collide)))
           (set! (-> a2-3 popup) 8192.0)
           (set! (-> a2-3 dont-move-if-overlaps?) #t)
           (set! (-> a2-3 hover-if-no-ground?) (-> v1-14 hover-if-no-ground))
           (set! (-> a2-3 overlaps-params options) (overlaps-others-options oo0 oo2))
           (set! (-> a2-3 overlaps-params collide-with-filter) (-> v1-14 overlaps-others-collide-with-filter))
           )
         (set! (-> a2-3 overlaps-params tlist) *touching-list*)
         (-> a2-3 overlaps-params)
         (enemy-method-128 obj (-> obj root-override2 transv) a2-3)
         )
       )
      (else
        (let ((a2-4 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a2-4 options) (overlaps-others-options oo0))
          (set! (-> a2-4 collide-with-filter) (-> obj enemy-info-override overlaps-others-collide-with-filter))
          (set! (-> a2-4 tlist) *touching-list*)
          (integrate-for-enemy-no-mtg (-> obj root-override2) (-> obj root-override2 transv) a2-4)
          )
        )
      )
    0
    (none)
    )
  )

(define *nav-enemy-null-callback-info* (new 'static 'nav-callback-info))

(define *nav-enemy-callback-info*
  (new 'static 'nav-callback-info
    :callback-count 5
    :callback-array (new 'static 'array (function object nav-control none) 10
      (lambda ((arg0 object) (arg1 nav-control))
        (rlet ((acc :class vf)
               (Q :class vf)
               (vf0 :class vf)
               (vf1 :class vf)
               (vf2 :class vf)
               (vf3 :class vf)
               )
          (init-vf0-vector)
          (let ((gp-0 (-> arg1 state)))
            (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
            (if (< 0.0 (-> gp-0 speed))
                (set! (-> gp-0 rotation-rate)
                      (fmin
                        (-> gp-0 rotation-rate)
                        (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                        )
                      )
                )
            (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
              (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
              (set! (-> gp-0 heading y) 0.0)
              (let ((v1-14 (-> gp-0 heading)))
                (let ((f0-5 1.0))
                  (.lvf vf1 (&-> v1-14 quad))
                  (.mul.vf vf2 vf1 vf1 :mask #b111)
                  (let ((a0-3 f0-5))
                    (.mov vf3 a0-3)
                    )
                  )
                (.mul.x.vf acc vf0 vf2 :mask #b1000)
                (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
                (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
                (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
                (.wait.vf)
                (.mul.vf vf1 vf1 Q :mask #b111)
                (.nop.vf)
                (.nop.vf)
                (.nop.vf)
                (.svf (&-> v1-14 quad) vf1)
                )
              )
            (let ((a1-2 (new 'stack-no-clear 'vector)))
              (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
              (if (or (not (-> gp-0 current-poly))
                      (!= (-> gp-0 current-pos x) (-> a1-2 x))
                      (!= (-> gp-0 current-pos z) (-> a1-2 z))
                      )
                  (do-navigation-to-destination gp-0 a1-2)
                  )
              )
            (logclear!
              (-> gp-0 flags)
              (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
              )
            )
          0
          0
          0
          (none)
          )
        )
      (lambda ((arg0 object) (arg1 nav-control)) (navigate-using-route-portals (-> arg1 state)) 0 0 0 (none))
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (navigate-using-best-dir-recompute-avoid-spheres-1 (-> arg1 state))
        0
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (navigate-within-poly (-> arg1 state))
        0
        0
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control)) (compute-travel-speed (-> arg1 state)) 0 0 (none))
      )
    )
  )

(define *nav-enemy-physics-callback-info*
  (new 'static 'nav-callback-info
    :callback-count 5
    :callback-array (new 'static 'array (function object nav-control none) 10
      (lambda ((arg0 object) (arg1 nav-control))
        (rlet ((acc :class vf)
               (Q :class vf)
               (vf0 :class vf)
               (vf1 :class vf)
               (vf2 :class vf)
               (vf3 :class vf)
               )
          (init-vf0-vector)
          (let ((gp-0 (-> arg1 state)))
            (set! (-> gp-0 rotation-rate) (-> gp-0 nav max-rotation-rate))
            (if (< 0.0 (-> gp-0 speed))
                (set! (-> gp-0 rotation-rate)
                      (fmin
                        (-> gp-0 rotation-rate)
                        (* (/ (-> gp-0 nav turning-acceleration) (-> gp-0 speed)) (-> gp-0 mesh work rad-to-deg))
                        )
                      )
                )
            (when (logtest? (-> gp-0 nav flags) (nav-control-flag update-heading-from-facing))
              (vector-z-quaternion! (-> gp-0 heading) (-> gp-0 nav shape quat))
              (set! (-> gp-0 heading y) 0.0)
              (let ((v1-14 (-> gp-0 heading)))
                (let ((f0-5 1.0))
                  (.lvf vf1 (&-> v1-14 quad))
                  (.mul.vf vf2 vf1 vf1 :mask #b111)
                  (let ((a0-3 f0-5))
                    (.mov vf3 a0-3)
                    )
                  )
                (.mul.x.vf acc vf0 vf2 :mask #b1000)
                (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
                (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
                (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
                (.wait.vf)
                (.mul.vf vf1 vf1 Q :mask #b111)
                (.nop.vf)
                (.nop.vf)
                (.nop.vf)
                (.svf (&-> v1-14 quad) vf1)
                )
              )
            (let ((a1-2 (new 'stack-no-clear 'vector)))
              (set! (-> a1-2 quad) (-> gp-0 nav shape trans quad))
              (if (or (not (-> gp-0 current-poly))
                      (!= (-> gp-0 current-pos x) (-> a1-2 x))
                      (!= (-> gp-0 current-pos z) (-> a1-2 z))
                      )
                  (do-navigation-to-destination gp-0 a1-2)
                  )
              )
            (logclear!
              (-> gp-0 flags)
              (nav-state-flag blocked in-target-poly at-target avoiding-sphere touching-sphere at-gap)
              )
            )
          0
          0
          0
          (none)
          )
        )
      (lambda ((arg0 object) (arg1 nav-control)) (navigate-using-route-portals (-> arg1 state)) 0 0 0 (none))
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (navigate-using-best-dir-recompute-avoid-spheres-2 (-> arg1 state))
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control))
        (let* ((v1-0 arg1)
               (a2-2 (-> v1-0 state mesh sphere-hash sphere-array))
               (a3-0 (-> v1-0 sphere-id-array))
               (t0-1 (-> v1-0 state mesh bounds))
               (t1-0 (-> v1-0 root-nav-sphere))
               (t2-0 (-> v1-0 sphere-count))
               )
          (dotimes (t3-0 t2-0)
            (let ((t5-0 (-> a2-2 (-> a3-0 t3-0)))
                  (t4-4 (-> v1-0 sphere-array t3-0))
                  )
              (vector-! (the-as vector t4-4) (the-as vector t5-0) t0-1)
              (set! (-> t4-4 r) (+ (-> t5-0 r) (-> t1-0 w)))
              )
            )
          )
        0
        (update-travel-dir-from-spheres (-> arg1 state))
        0
        0
        (none)
        )
      (lambda ((arg0 object) (arg1 nav-control)) (compute-speed-simple (-> arg1 state)) 0 0 (none))
      )
    )
  )

(defmethod nav-enemy-method-170 nav-enemy ((obj nav-enemy))
  (if (not (logtest? (enemy-flag enemy-flag36) (-> obj enemy-flags)))
      (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> obj enemy-flags))))
      )
  (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> obj enemy-flags))))
  (set! (-> obj nav callback-info) (-> obj enemy-info-override callback-info))
  0
  (none)
  )

(defmethod nav-enemy-method-171 nav-enemy ((obj nav-enemy))
  (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag enemy-flag36))))
  (set! (-> obj nav callback-info) *nav-enemy-null-callback-info*)
  0
  (none)
  )

(defmethod nav-enemy-method-172 nav-enemy ((obj nav-enemy))
  (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> obj enemy-flags))))
  0
  (none)
  )

(defmethod nav-enemy-method-173 nav-enemy ((obj nav-enemy))
  (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag enemy-flag37))))
  0
  (none)
  )

(defmethod nav-enemy-method-174 nav-enemy ((obj nav-enemy))
  (logtest? (enemy-flag enemy-flag36) (-> obj enemy-flags))
  )

(defmethod nav-enemy-method-175 nav-enemy ((obj nav-enemy))
  (logtest? (enemy-flag enemy-flag37) (-> obj enemy-flags))
  )

(defmethod nav-enemy-method-157 nav-enemy ((obj nav-enemy) (arg0 vector))
  (let ((v1-0 (-> obj nav))
        (a0-1 arg0)
        (a1-1 (new 'stack-no-clear 'nav-find-poly-parms))
        )
    (vector-! (-> a1-1 point) a0-1 (-> v1-0 state mesh bounds))
    (set! (-> a1-1 y-threshold) (-> v1-0 nearest-y-threshold))
    (set! (-> a1-1 ignore) (the-as uint 2))
    (find-poly-containing-point-local (-> v1-0 state mesh) a1-1)
    )
  )

(defmethod nav-enemy-method-158 nav-enemy ((obj nav-enemy) (arg0 vector))
  (let ((f1-0 (-> obj root-override2 trans y))
        (f0-0 (-> arg0 y))
        (v1-1 (-> obj fact-info-override))
        )
    (and (< f0-0 (+ f1-0 (-> v1-1 notice-top)))
         (and (< (- f1-0 (-> v1-1 notice-bottom)) f0-0) (let ((v1-3 (-> obj nav))
                                                              (a0-1 arg0)
                                                              (a1-1 (new 'stack-no-clear 'nav-find-poly-parms))
                                                              )
                                                          (vector-! (-> a1-1 point) a0-1 (-> v1-3 state mesh bounds))
                                                          (set! (-> a1-1 y-threshold) (-> v1-3 nearest-y-threshold))
                                                          (set! (-> a1-1 ignore) (the-as uint 2))
                                                          (find-poly-containing-point-local (-> v1-3 state mesh) a1-1)
                                                          )
              )
         )
    )
  )

(defmethod nav-enemy-method-159 nav-enemy ((obj nav-enemy) (arg0 vector))
  (let ((f1-0 (-> obj root-override2 trans y))
        (f0-0 (-> arg0 y))
        (v1-1 (-> obj fact-info-override))
        )
    (and (< f0-0 (+ f1-0 (-> v1-1 notice-top)))
         (and (< (- f1-0 (-> v1-1 notice-bottom)) f0-0)
              (is-in-mesh? (-> obj nav) arg0 (-> obj enemy-info-override notice-nav-radius))
              )
         )
    )
  )

(defmethod in-aggro-range? nav-enemy ((obj nav-enemy) (arg0 process-focusable) (arg1 vector))
  "Should the enemy activate.
- if `activate-distance` is `0.0`, always true
- otherwise, check if the provided process is close enough
@param proc The process used to distance check
@returns true/false"
  (if (and arg0 (not arg1))
      (set! arg1 (get-trans arg0 1))
      )
  (when arg1
    (let* ((f0-0 (-> arg1 y))
           (v1-4 (-> obj root-override2))
           (f1-0 (-> v1-4 trans y))
           (a0-2 (-> obj fact-info-override))
           )
      (when (and (< f0-0 (+ f1-0 (-> a0-2 notice-top))) (< (- f1-0 (-> a0-2 notice-bottom)) f0-0))
        (let* ((f30-0 (-> obj enemy-info-override notice-nav-radius))
               (f0-1 f30-0)
               )
          (or (>= (* f0-1 f0-1) (vector-vector-xz-distance-squared (-> v1-4 trans) arg1))
              (is-in-mesh? (-> obj nav) arg1 f30-0)
              )
          )
        )
      )
    )
  )

(defmethod nav-enemy-method-161 nav-enemy ((obj nav-enemy))
  (with-pp
    (set! (-> obj enemy-flags) (the-as enemy-flag (logclear (-> obj enemy-flags) (enemy-flag enemy-flag39))))
    (set! (-> obj frustration-time) (-> pp clock frame-counter))
    (let ((v1-7 (handle->process (-> obj focus handle))))
      (if v1-7
          (set! (-> obj frustration-point quad) (-> (get-trans (the-as process-focusable v1-7) 1) quad))
          )
      )
    0
    (none)
    )
  )

(defmethod nav-enemy-method-160 nav-enemy ((obj nav-enemy))
  (with-pp
    (let ((s5-0 (handle->process (-> obj focus handle))))
      (cond
        ((or (not s5-0)
             (< 6144.0 (vector-vector-distance (get-trans (the-as process-focusable s5-0) 1) (-> obj frustration-point)))
             (< (-> obj enemy-info-override frustration-distance)
                (vector-vector-xz-distance (get-trans (the-as process-focusable s5-0) 0) (-> obj root-override2 trans))
                )
             )
         (nav-enemy-method-161 obj)
         )
        (else
          (when (>= (- (-> pp clock frame-counter) (-> obj frustration-time))
                    (+ (-> obj reaction-time) (-> obj enemy-info-override frustration-time))
                    )
            (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag39) (-> obj enemy-flags))))
            0
            )
          )
        )
      )
    (none)
    )
  )

(defmethod nav-enemy-method-162 nav-enemy ((obj nav-enemy))
  (set! (-> obj blocked-start-time) 0)
  0
  (none)
  )

(defmethod nav-enemy-method-163 nav-enemy ((obj nav-enemy))
  (with-pp
    (let ((v1-0 (-> obj blocked-start-time)))
      (and (nonzero? v1-0) (>= (- (-> pp clock frame-counter) v1-0) (-> obj enemy-info-override blocked-time)))
      )
    )
  )

(defmethod nav-enemy-method-164 nav-enemy ((obj nav-enemy))
  (if (-> obj enemy-info-override use-momentum)
      (logior! (-> obj nav flags) (nav-control-flag use-momentum))
      (logclear! (-> obj nav flags) (nav-control-flag use-momentum))
      )
  0
  (none)
  )

(defmethod nav-enemy-method-167 nav-enemy ((obj nav-enemy))
  (let ((v1-0 (-> obj nav)))
    (set! (-> v1-0 target-speed) 0.0)
    )
  0
  (let ((v1-3 (-> obj nav state)))
    (set! (-> v1-3 speed) 0.0)
    )
  0
  (let ((v1-5 (-> obj nav)))
    (set! (-> v1-5 acceleration) (-> obj enemy-info-override walk-acceleration))
    )
  0
  0
  (none)
  )

(defmethod nav-enemy-method-165 nav-enemy ((obj nav-enemy))
  (let ((v1-0 (-> obj nav)))
    (set! (-> v1-0 target-speed) (-> obj enemy-info-override walk-travel-speed))
    )
  0
  (let ((v1-2 (-> obj nav)))
    (set! (-> v1-2 acceleration) (-> obj enemy-info-override walk-acceleration))
    )
  0
  (let ((v1-4 (-> obj nav)))
    (set! (-> v1-4 turning-acceleration) (-> obj enemy-info-override walk-turning-acceleration))
    )
  0
  0
  (none)
  )

(defmethod nav-enemy-method-166 nav-enemy ((obj nav-enemy))
  (let ((v1-0 (-> obj nav)))
    (set! (-> v1-0 target-speed) (-> obj enemy-info-override run-travel-speed))
    )
  0
  (let ((v1-2 (-> obj nav)))
    (set! (-> v1-2 acceleration) (-> obj enemy-info-override run-acceleration))
    )
  0
  (let ((v1-4 (-> obj nav)))
    (set! (-> v1-4 turning-acceleration) (-> obj enemy-info-override run-turning-acceleration))
    )
  0
  0
  (none)
  )

;; WARN: Return type mismatch float vs none.
(defmethod set-enemy-info! nav-enemy ((obj nav-enemy) (arg0 nav-enemy-info))
  "In addition to setting the `enemy-info`, also init the `neck-joint` if applicable from it
@param info Set `enemy-info` accordingly"
  (set! (-> obj enemy-info-override) arg0)
  (set! (-> arg0 callback-info) *nav-enemy-callback-info*)
  (when (and (!= (-> obj enemy-info-override neck-joint) -1) (zero? (-> obj neck)))
    (set! (-> obj neck)
          (new 'process 'joint-mod (joint-mod-mode flex-blend) obj (-> obj enemy-info-override neck-joint))
          )
    (set-vector! (-> obj neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> obj neck up) (the-as uint 1))
    (set! (-> obj neck nose) (the-as uint 2))
    (set! (-> obj neck ear) (the-as uint 0))
    (set! (-> obj neck max-dist) 102400.0)
    (set! (-> obj neck ignore-angle) 16384.0)
    )
  (none)
  )

(defmethod init-enemy-behaviour-and-stats! nav-enemy ((obj nav-enemy) (arg0 nav-enemy-info))
  "Initializes a bunch of enemy fields related to how they should react, how many hitpoints they should have, etc"
  (local-vars (sv-16 res-tag))
  (when (coin-flip? obj)
    (let ((a0-2 (-> obj node-list data 2)))
      (set! (-> a0-2 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint-flip-z!))
      (set! (-> a0-2 param1) #f)
      (set! (-> a0-2 param2) #f)
      )
    (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag dislike-combo) (-> obj enemy-flags))))
    )
  (set! (-> obj mask) (logior (process-mask enemy) (-> obj mask)))
  (logior! (-> obj mask) (process-mask actor-pause))
  (logior! (-> obj enemy-flags) (enemy-flag notice))
  (set! (-> obj nav-radius-backup) (-> obj root-override2 nav-radius))
  (set-enemy-info! obj arg0)
  (set! (-> obj enemy-info-override callback-info) *nav-enemy-callback-info*)
  (let ((a1-2 (-> obj enemy-info-override idle-anim-script)))
    (if a1-2
        (idle-control-method-9 (-> obj idle-anim-player) a1-2)
        )
    )
  (if (-> obj draw shadow)
      (set! (-> obj draw shadow-ctrl) (new
                                        'process
                                        'shadow-control
                                        (-> obj enemy-info-override shadow-min-y)
                                        (-> obj enemy-info-override shadow-max-y)
                                        (-> obj enemy-info-override shadow-locus-dist)
                                        (shadow-flags shdf00 shdf04)
                                        245760.0
                                        )
            )
      (set! (-> obj draw shadow-ctrl) *nav-enemy-dummy-shadow-control*)
      )
  (get-nav-control obj (-> arg0 nav-mesh))
  (set! (-> obj water-max-height) (-> obj nav state mesh water-max-height))
  (let ((v1-33 obj))
    (set! (-> v1-33 enemy-flags) (the-as enemy-flag (logclear (-> v1-33 enemy-flags) (enemy-flag enemy-flag36))))
    (set! (-> v1-33 nav callback-info) *nav-enemy-null-callback-info*)
    )
  0
  (let ((v1-36 obj))
    (set! (-> v1-36 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-36 enemy-flags))))
    )
  0
  (logior! (-> obj nav flags) (nav-control-flag display-marks limit-rotation-rate))
  (logior! (-> obj nav flags) (nav-control-flag update-heading-from-facing))
  (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag43) (-> obj enemy-flags))))
  (let ((v1-47 (-> obj nav)))
    (set! (-> v1-47 target-speed) 0.0)
    )
  0
  (let ((v1-49 (-> obj nav)))
    (set! (-> v1-49 acceleration) (-> obj enemy-info-override walk-acceleration))
    )
  0
  (let ((v1-51 (-> obj nav)))
    (set! (-> v1-51 turning-acceleration) (-> obj enemy-info-override walk-turning-acceleration))
    )
  0
  (let ((v1-53 (-> obj nav)))
    (set! (-> v1-53 max-rotation-rate) (-> obj enemy-info-override maximum-rotation-rate))
    )
  0
  (nav-enemy-method-164 obj)
  (set! (-> obj path) (new 'process 'path-control obj 'path 0.0 (the-as entity #f) #t))
  (if (nonzero? (-> obj path))
      (logior! (-> obj path flags) (path-control-flag display draw-line draw-point draw-text))
      )
  (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
      (set! (-> obj hit-points) (* (-> obj enemy-info-override default-hit-points) 2))
      (set! (-> obj hit-points) (-> obj enemy-info-override default-hit-points))
      )
  (let* ((v1-71 *game-info*)
         (a0-28 (+ (-> v1-71 attack-id) 1))
         )
    (set! (-> v1-71 attack-id) a0-28)
    (set! (-> obj attack-id) a0-28)
    )
  (let* ((v1-72 *game-info*)
         (a0-30 (+ (-> v1-72 attack-id) 1))
         )
    (set! (-> v1-72 attack-id) a0-30)
    (set! (-> obj persistent-attack-id) a0-30)
    )
  (enemy-method-124 obj)
  (set! (-> obj fact-info-override) (new
                                      'process
                                      'fact-info-enemy
                                      obj
                                      (the-as (pointer float) (-> arg0 fact-defaults))
                                      (pickup-type eco-pill-random)
                                      (-> *FACT-bank* default-eco-pill-green-inc)
                                      )
        )
  (let ((a1-9 (if (logtest? (enemy-option multi-focus) (-> obj fact-info-override enemy-options))
                  1030
                  1026
                  )
              )
        )
    (reset-to-collide-spec (-> obj focus) (the-as collide-spec a1-9))
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-82 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-82 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-82))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> obj on-notice) (res-lump-struct (-> obj entity) 'on-notice symbol))
  (set! (-> obj on-active) (res-lump-struct (-> obj entity) 'on-active symbol))
  (set! (-> obj on-hostile) (res-lump-struct (-> obj entity) 'on-hostile symbol))
  (set! (-> obj on-death) (res-lump-struct (-> obj entity) 'on-death symbol))
  (if (-> obj on-notice)
      (logior! (-> obj enemy-flags) (enemy-flag auto-reset-penetrate))
      )
  (if (-> obj on-active)
      (logior! (-> obj enemy-flags) (enemy-flag jump-check-blocked))
      )
  (if (-> obj on-hostile)
      (logior! (-> obj enemy-flags) (enemy-flag drawn-mirrored))
      )
  (set! (-> obj incoming attacker-handle) (the-as handle #f))
  (let ((s4-0 (-> obj root-override2)))
    (set! (-> obj penetrated-by-all) (-> obj root-override2 penetrated-by))
    (set! (-> obj root-override2 penetrated-by) (get-penetrate-info obj))
    (set! (-> s4-0 event-self) 'touched)
    )
  (set! (-> obj penetrated-flinch) (-> arg0 penetrate-flinch))
  (set! (-> obj penetrated-knocked) (-> arg0 penetrate-knocked))
  (set! (-> obj reaction-time) (the-as time-frame (get-rand-int-range obj 30 240)))
  (let* ((v1-113 (-> obj enemy-flags))
         (a0-47 (-> obj fact-info-override enemy-options))
         (v1-114 (logior (enemy-flag
                           enable-on-active
                           checking-water
                           enable-on-notice
                           look-at-move-dest
                           check-water-backup
                           no-initial-move-to-ground
                           )
                         v1-113
                         )
                 )
         )
    (if (logtest? (enemy-option multi-focus) a0-47)
        (set! v1-114 (logior (enemy-flag trackable) v1-114))
        )
    (if (logtest? (enemy-option has-trigger) a0-47)
        (set! v1-114 (logior (enemy-flag called-dying) v1-114))
        )
    (set! (-> obj enemy-flags) v1-114)
    )
  (set! (-> obj mask) (logior (process-mask collectable) (-> obj mask)))
  (do-navigation-to-destination (-> obj nav state) (-> obj root-override2 trans))
  (if (and (-> obj enemy-info-override move-to-ground)
           (not (logtest? (enemy-flag vulnerable-backup) (-> obj enemy-flags)))
           (not (logtest? (enemy-option ambush) (-> obj fact-info-override enemy-options)))
           )
      (enemy-method-127 obj 40960.0 40960.0 #t (the-as collide-spec (-> obj gnd-collide)))
      )
  (if (zero? (-> obj draw light-index))
      (set! (-> obj draw light-index) (the-as uint 10))
      )
  0
  (none)
  )

(defmethod init-from-entity! nav-enemy ((obj nav-enemy) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-enemy-collision! obj)
  (process-drawable-from-entity! obj arg0)
  (init-enemy! obj)
  (when (> (-> obj enemy-info-override gem-joint) 0)
    (cond
      ((or (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status save)))
           (not (-> obj entity))
           )
       (setup-masks
         (-> obj draw)
         (the-as int (-> obj enemy-info-override gem-no-seg))
         (the-as int (-> obj enemy-info-override gem-seg))
         )
       )
      (else
        (setup-masks
          (-> obj draw)
          (the-as int (-> obj enemy-info-override gem-seg))
          (the-as int (-> obj enemy-info-override gem-no-seg))
          )
        (add-connection
          *part-engine*
          obj
          (-> obj enemy-info-override gem-joint)
          obj
          314
          (-> obj enemy-info-override gem-offset)
          )
        )
      )
    )
  (let ((v1-25 (-> obj fact-info-override enemy-options)))
    (cond
      ((logtest? (enemy-option spawner) v1-25)
       (process-entity-status! obj (entity-perm-status dead) #t)
       (go (method-of-object obj die-fast))
       )
      (*debug-view-anims*
        (go (method-of-object obj view-anims))
        )
      ((logtest? (enemy-option dormant) v1-25)
       (let ((v1-33 (-> obj root-override2 root-prim)))
         (set! (-> v1-33 prim-core collide-as) (collide-spec))
         (set! (-> v1-33 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> obj draw status) (draw-control-status no-draw))
       (go (method-of-object obj dormant))
       )
      ((logtest? (enemy-option dormant-aware) v1-25)
       (let ((v1-43 (-> obj root-override2 root-prim)))
         (set! (-> v1-43 prim-core collide-as) (collide-spec))
         (set! (-> v1-43 prim-core collide-with) (collide-spec))
         )
       0
       (logior! (-> obj draw status) (draw-control-status no-draw))
       (go (method-of-object obj dormant-aware))
       )
      (else
        (go-idle obj)
        )
      )
    )
  0
  (none)
  )

(defbehavior nav-enemy-simple-post nav-enemy ()
  (track-target! self)
  (update-transforms (-> self root-override2))
  0
  (none)
  )

(defbehavior nav-enemy-die-falling-post nav-enemy ()
  (enemy-die-falling-post)
  (none)
  )

(defbehavior nav-enemy-travel-post nav-enemy ()
  (nav-enemy-method-176 self)
  (none)
  )

(defbehavior nav-enemy-patrol-post nav-enemy ()
  (when (or (logtest? (-> self nav state flags) (nav-state-flag at-target)) (nav-enemy-method-163 self))
    (nav-enemy-method-156 self)
    (nav-enemy-method-162 self)
    )
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defbehavior nav-enemy-chase-post nav-enemy ()
  (let ((a0-1 (handle->process (-> self focus handle))))
    (when a0-1
      (let ((gp-0 (-> self nav state))
            (v1-7 (get-trans (the-as process-focusable a0-1) 1))
            )
        (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
        (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
        (set! (-> gp-0 target-post quad) (-> v1-7 quad))
        )
      0
      )
    )
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defbehavior nav-enemy-flee-post nav-enemy ()
  (let ((a0-1 (handle->process (-> self focus handle))))
    (when a0-1
      (let ((gp-1 (vector-!
                    (new 'stack-no-clear 'vector)
                    (-> self root-override2 trans)
                    (get-trans (the-as process-focusable a0-1) 0)
                    )
                  )
            )
        (set! (-> gp-1 y) 0.0)
        (vector-normalize! gp-1 409600.0)
        (vector+! gp-1 gp-1 (-> self root-override2 trans))
        (let ((v1-10 (-> self nav state)))
          (logclear! (-> v1-10 flags) (nav-state-flag directional-mode))
          (logior! (-> v1-10 flags) (nav-state-flag target-poly-dirty))
          (set! (-> v1-10 target-post quad) (-> gp-1 quad))
          )
        )
      0
      )
    )
  (nav-enemy-method-176 self)
  0
  (none)
  )

(defbehavior nav-enemy-face-focus-post nav-enemy ()
  (let ((a0-0 self))
    (when (logtest? (enemy-flag enemy-flag37) (-> a0-0 enemy-flags))
      (let ((a0-4 (handle->process (-> self focus handle))))
        (if a0-4
            (seek-to-point-toward-point!
              (-> self root-override2)
              (get-trans (the-as process-focusable a0-4) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (nav-enemy-simple-post)
  0
  (none)
  )

(defmethod nav-enemy-method-169 nav-enemy ((obj nav-enemy) (arg0 float) (arg1 symbol))
  (if arg1
      (set! (-> obj nav-radius-backup) arg0)
      )
  (if (zero? (-> obj restore-nav-radius-time))
      (set! (-> obj root-override2 nav-radius) arg0)
      )
  )

(defmethod nav-enemy-method-168 nav-enemy ((obj nav-enemy))
  (if (zero? (-> obj restore-nav-radius-time))
      (set! (-> obj root-override2 nav-radius) (-> obj nav-radius-backup))
      )
  )

;; WARN: Return type mismatch int vs time-frame.
(defmethod nav-enemy-method-144 nav-enemy ((obj nav-enemy))
  (set! (-> obj root-override2 nav-radius) 4.096)
  (let ((s5-1
          (max (-> obj restore-nav-radius-time) (+ (-> self clock frame-counter) (get-rand-int-range obj 1500 2400)))
          )
        )
    (set! (-> obj restore-nav-radius-time) (the-as time-frame s5-1))
    (the-as time-frame s5-1)
    )
  )

(defbehavior nav-enemy-stare-post nav-enemy ()
  (let ((a0-0 self))
    (when (logtest? (enemy-flag enemy-flag37) (-> a0-0 enemy-flags))
      (let ((a0-4 (handle->process (-> self focus handle))))
        (if a0-4
            (seek-to-point-toward-point!
              (-> self root-override2)
              (get-trans (the-as process-focusable a0-4) 0)
              (-> self nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (nav-enemy-method-176 self)
  (if (and (nav-enemy-method-163 self)
           (zero? (-> self restore-nav-radius-time))
           (>= (- (-> self clock frame-counter) (-> self blocked-start-time)) (seconds 4))
           )
      (nav-enemy-method-144 self)
      )
  0
  (none)
  )

(defbehavior nav-enemy-falling-post nav-enemy ()
  (enemy-falling-post)
  (none)
  )

(defbehavior nav-enemy-turn-to-face-dir nav-enemy ((arg0 vector) (arg1 float))
  (local-vars (v1-18 symbol))
  (let ((s4-0 (-> self clock frame-counter)))
    (ja :group! (-> self draw art-group data (-> self enemy-info-override turn-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (until v1-18
      (seek-toward-heading-vec! (-> self root-override2) arg0 (-> self nav max-rotation-rate) (seconds 0.02))
      (suspend)
      (ja :num! (loop! 0.75))
      (set! v1-18 (or (>= (- (-> self clock frame-counter) s4-0) (seconds 10)) (enemy-method-94 self arg0 arg1)))
      )
    )
  (forward-up->quaternion (-> self root-override2 quat) arg0 *y-vector*)
  0
  (none)
  )

(defbehavior nav-enemy-turn-to-face-point nav-enemy ((arg0 vector) (arg1 float))
  (let ((gp-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> self root-override2 trans))))
    (set! (-> gp-1 y) 0.0)
    (when (< 0.0 (vector-length gp-1))
      (vector-normalize! gp-1 1.0)
      (nav-enemy-turn-to-face-dir gp-1 arg1)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-stare2 nav-enemy ((obj nav-enemy))
  (if (!= (-> obj enemy-info-override taunt-anim) -1)
      (go (method-of-object obj taunt))
      )
  (go (method-of-object obj stare))
  (none)
  )

(defmethod go-stare nav-enemy ((obj nav-enemy))
  (let ((s5-0 (-> obj focus aware)))
    (cond
      ((or (and (-> obj enemy-info-override use-frustration) (logtest? (enemy-flag enemy-flag39) (-> obj enemy-flags)))
           (nav-enemy-method-163 obj)
           )
       (go-stare2 obj)
       )
      ((and (= s5-0 (enemy-aware enemy-aware-3)) (-> obj enemy-info-override use-circling))
       (go (method-of-object obj circling))
       )
      ((= s5-0 (enemy-aware unaware))
       (go (method-of-object obj flee))
       )
      (else
        (go-stare2 obj)
        )
      )
    )
  (none)
  )

(defmethod go-hostile nav-enemy ((obj nav-enemy))
  (if (or (and (-> obj enemy-info-override use-frustration) (logtest? (enemy-flag enemy-flag39) (-> obj enemy-flags)))
          (nav-enemy-method-163 obj)
          )
      (go-stare2 obj)
      (go (method-of-object obj hostile))
      )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-flee nav-enemy ((obj nav-enemy))
  (go (method-of-object obj flee))
  (none)
  )

(define *nav-enemy-debug-control-info* (new 'static 'nav-enemy-debug-control-info))

(defbehavior nav-enemy-debug-control-post nav-enemy ()
  (let ((gp-0 *nav-enemy-debug-control-info*))
    (let ((f30-0 (analog-input (the-as int (-> *cpad-list* cpads 0 leftx)) 128.0 48.0 110.0 -1.0)))
      (seek! (-> gp-0 steering) (fmax -1.0 (fmin 1.0 f30-0)) (-> self clock seconds-per-frame))
      (if (cpad-hold? 0 x)
          (set! (-> gp-0 throttle) 1.0)
          (set! (-> gp-0 throttle) 0.0)
          )
      (format *stdcon* "input-x ~f  steering ~f  throttle ~f~%" f30-0 (-> gp-0 steering) (-> gp-0 throttle))
      )
    (format *stdcon* "target-speed ~M,  speed ~M~%" (-> self nav target-speed) (-> self nav state speed))
    (let ((v1-16 (-> self nav)))
      (set! (-> v1-16 target-speed) (* 24576.0 (-> gp-0 throttle)))
      )
    0
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          )
      (let ((a1-4 (-> self nav state)))
        (set! (-> s4-0 quad) (-> a1-4 heading quad))
        )
      (vector-rotate-y! s4-0 s4-0 (* 1820.4445 (-> gp-0 steering)))
      (vector-float*! s4-0 s4-0 20480.0)
      (vector+! s5-0 (-> self root-override2 trans) s4-0)
      (let ((v1-26 (-> self nav state)))
        (logclear! (-> v1-26 flags) (nav-state-flag directional-mode))
        (logior! (-> v1-26 flags) (nav-state-flag target-poly-dirty))
        (set! (-> v1-26 target-post quad) (-> s5-0 quad))
        )
      )
    )
  0
  (nav-enemy-method-176 self)
  (none)
  )

(defstate idle (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy idle) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self state-timeout) (seconds 1))
    (let ((v1-5 self))
      (set! (-> v1-5 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-5 enemy-flags))))
      )
    0
    (let ((v1-7 self))
      (set! (-> v1-7 enemy-flags) (the-as enemy-flag (logclear (-> v1-7 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-7 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (none)
    )
  )

(defstate dormant (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy dormant) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag37))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (none)
    )
  )

(defstate dormant-aware (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (-> (method-of-type nav-enemy dormant) enter)
  )

(defstate active (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self state-timeout) (seconds 1))
    (logior! (-> self nav state flags) (nav-state-flag at-target))
    (let ((v1-8 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-8 enemy-flags)))
          (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-8 enemy-flags))))
          )
      (set! (-> v1-8 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-8 enemy-flags))))
      (set! (-> v1-8 nav callback-info) (-> v1-8 enemy-info-override callback-info))
      )
    0
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-11 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (until #f
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override walk-anim))
                    :num! (seek!
                      (the float
                           (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override walk-anim)))
                                  frames
                                  num-frames
                                  )
                              -1
                              )
                           )
                      f30-0
                      )
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        (when (enemy-method-123 self 0.2)
          (ja-no-eval :num! (loop!))
          (ja-channel-push! 1 (seconds 0.6))
          (let ((v1-37 self))
            (set! (-> v1-37 enemy-flags) (the-as enemy-flag (logclear (-> v1-37 enemy-flags) (enemy-flag enemy-flag36))))
            (set! (-> v1-37 nav callback-info) *nav-enemy-null-callback-info*)
            )
          0
          (nav-enemy-method-167 self)
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override idle-anim))
                      :num! (seek!
                        (the float
                             (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override idle-anim)))
                                    frames
                                    num-frames
                                    )
                                -1
                                )
                             )
                        f30-0
                        )
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          (until (not (enemy-method-123 self 0.2))
            (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override idle-anim))
                        :num! (seek!
                          (the float
                               (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override idle-anim)))
                                      frames
                                      num-frames
                                      )
                                  -1
                                  )
                               )
                          f30-0
                          )
                        :frame-num 0.0
                        )
            (until (ja-done? 0)
              (suspend)
              (ja :num! (seek! max f30-0))
              )
            )
          (let ((v1-101 self))
            (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-101 enemy-flags)))
                (set! (-> v1-101 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-101 enemy-flags))))
                )
            (set! (-> v1-101 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-101 enemy-flags))))
            (set! (-> v1-101 nav callback-info) (-> v1-101 enemy-info-override callback-info))
            )
          0
          (nav-enemy-method-165 self)
          (ja-no-eval :num! (loop!))
          (ja-channel-push! 1 (seconds 0.6))
          (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override walk-anim))
                      :num! (seek!
                        (the float
                             (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override walk-anim)))
                                    frames
                                    num-frames
                                    )
                                -1
                                )
                             )
                        f30-0
                        )
                      :frame-num 0.0
                      )
          (until (ja-done? 0)
            (ja-blend-eval)
            (suspend)
            (ja :num! (seek! max f30-0))
            )
          )
        )
      )
    #f
    (none)
    )
  :post nav-enemy-patrol-post
  )

(defstate notice (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy notice) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((a0-1 (handle->process (-> self focus handle))))
      (when a0-1
        (let ((gp-0 (-> self nav state))
              (v1-11 (get-trans (the-as process-focusable a0-1) 0))
              )
          (logclear! (-> gp-0 flags) (nav-state-flag directional-mode))
          (logior! (-> gp-0 flags) (nav-state-flag target-poly-dirty))
          (set! (-> gp-0 target-post quad) (-> v1-11 quad))
          )
        0
        )
      )
    (let ((v1-14 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-14 enemy-flags)))
          (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-14 enemy-flags))))
          )
      (set! (-> v1-14 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-14 enemy-flags))))
      (set! (-> v1-14 nav callback-info) (-> v1-14 enemy-info-override callback-info))
      )
    0
    (let ((v1-17 self))
      (set! (-> v1-17 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-17 enemy-flags))))
      )
    0
    (let ((v1-19 (-> self nav)))
      (set! (-> v1-19 target-speed) 0.0)
      )
    0
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override notice-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override notice-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (let ((a1-9 (-> self nav state)))
          (set! (-> gp-0 quad) (-> a1-9 travel quad))
          )
        (seek-toward-heading-vec! (-> self root-override2) gp-0 (-> self nav max-rotation-rate) (seconds 0.02))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (react-to-focus self)
    (none)
    )
  :post nav-enemy-simple-post
  )

(defstate hostile (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hostile) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (nav-enemy-method-166 self)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info-override callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (none)
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag look-at-focus)) (-> self enemy-info-override use-victory))
        (go-virtual victory)
        )
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
      (if (nav-enemy-method-163 self)
          (go-stare2 self)
          )
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (if (-> self enemy-info-override use-stop-chase)
               (go-virtual stop-chase)
               (go-virtual active)
               )
           )
          ((or (>= 2 (the-as int gp-0)) (not (get-enemy-target self)))
           (go-stare self)
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          )
        )
      (when (and (-> self enemy-info-override use-frustration) (logtest? (enemy-flag enemy-flag39) (-> self enemy-flags)))
        (if (-> self enemy-info-override use-stop-chase)
            (go-virtual stop-chase)
            (go-stare self)
            )
        )
      )
    (none)
    )
  :post nav-enemy-chase-post
  )

(defstate stop-chase (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (let ((a1-0 (new 'stack-no-clear 'vector)))
      (let ((a2-0 (-> self nav state)))
        (set! (-> a1-0 quad) (-> a2-0 target-post quad))
        )
      (let ((f0-0 (vector-vector-distance (-> self root-override2 trans) a1-0)))
        (set! (-> self state-timeout)
              (the-as
                time-frame
                (the int (+ (lerp-scale 300.0 1200.0 f0-0 32768.0 122880.0) (get-rand-float-range self 0.0 30.0)))
                )
              )
        )
      )
    (nav-enemy-method-165 self)
    (let ((v1-10 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-10 enemy-flags)))
          (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-10 enemy-flags))))
          )
      (set! (-> v1-10 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-10 enemy-flags))))
      (set! (-> v1-10 nav callback-info) (-> v1-10 enemy-info-override callback-info))
      )
    0
    (let ((v1-13 self))
      (set! (-> v1-13 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-13 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag look-at-focus)) (-> self enemy-info-override use-victory))
        (go-virtual victory)
        )
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (seconds 0.1))
      (if (nav-enemy-method-163 self)
          (go-stare2 self)
          )
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (if (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self state-timeout))
               (go-virtual active)
               )
           )
          ((and (= gp-0 (enemy-aware enemy-aware-3)) (get-enemy-target self))
           (go-hostile self)
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          (else
            (if (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self state-timeout))
                (go-stare self)
                )
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (ja :group! (-> self draw art-group data (-> self enemy-info-override walk-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (get-rand-float-range self 0.8 1.2)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    (none)
    )
  :post nav-enemy-chase-post
  )

(defstate stare (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy stare) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag42) (-> self enemy-flags))))
    (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
    (let ((v1-9 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-9 enemy-flags)))
          (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-9 enemy-flags))))
          )
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-9 enemy-flags))))
      (set! (-> v1-9 nav callback-info) (-> v1-9 enemy-info-override callback-info))
      )
    0
    (let ((v1-12 self))
      (set! (-> v1-12 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-12 enemy-flags))))
      )
    0
    (nav-enemy-method-167 self)
    (vector-reset! (-> self root-override2 transv))
    (set! (-> self starting-time) (-> self clock frame-counter))
    (none)
    )
  :exit (behavior ()
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           (vf3 :class vf)
           )
      (init-vf0-vector)
      (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag42))))
      (let ((v1-4 (-> self nav state)))
        (set! (-> v1-4 speed) 0.0)
        )
      0
      (vector-reset! (-> self root-override2 transv))
      (if (logtest? (enemy-flag enemy-flag43) (-> self enemy-flags))
          (logior! (-> self nav flags) (nav-control-flag update-heading-from-facing))
          (logclear! (-> self nav flags) (nav-control-flag update-heading-from-facing))
          )
      (when (and (logtest? (-> self nav flags) (nav-control-flag update-heading-from-facing))
                 (not (nav-enemy-method-163 self))
                 )
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector-z-quaternion! gp-0 (-> self root-override2 quat))
          (set! (-> gp-0 y) 0.0)
          (let ((v1-23 gp-0))
            (let ((f0-2 1.0))
              (.lvf vf1 (&-> v1-23 quad))
              (.mul.vf vf2 vf1 vf1 :mask #b111)
              (let ((a0-9 f0-2))
                (.mov vf3 a0-9)
                )
              )
            (.mul.x.vf acc vf0 vf2 :mask #b1000)
            (.add.mul.y.vf acc vf0 vf2 acc :mask #b1000)
            (.add.mul.z.vf vf2 vf0 vf2 acc :mask #b1000)
            (.isqrt.vf Q vf3 vf2 :fsf #b0 :ftf #b11)
            (.wait.vf)
            (.mul.vf vf1 vf1 Q :mask #b111)
            (.nop.vf)
            (.nop.vf)
            (.nop.vf)
            (.svf (&-> v1-23 quad) vf1)
            )
          (set! (-> self nav state heading quad) (-> gp-0 quad))
          )
        0
        )
      (none)
      )
    )
  :trans (behavior ()
    (nav-enemy-method-160 self)
    (if (and (logtest? (-> self enemy-flags) (enemy-flag look-at-focus)) (-> self enemy-info-override use-victory))
        (go-virtual victory)
        )
    (let ((gp-0 (-> self focus aware)))
      (if (< (the-as int gp-0) 2)
          (set! (-> self starting-time) (-> self clock frame-counter))
          )
      (when (and (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
                 (not (nav-enemy-method-163 self))
                 )
        (cond
          ((>= 1 (the-as int gp-0))
           (go-virtual active)
           )
          ((= gp-0 (enemy-aware enemy-aware-3))
           (if (and (get-enemy-target self)
                    (not (and (-> self enemy-info-override use-frustration) (logtest? (enemy-flag enemy-flag39) (-> self enemy-flags)))
                         )
                    (>= (- (-> self clock frame-counter) (-> self starting-time)) (-> self reaction-time))
                    )
               (go-hostile self)
               )
           (if (-> self enemy-info-override use-circling)
               (go-virtual circling)
               )
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          ((and (= gp-0 (enemy-aware enemy-aware-2))
                (-> self enemy-info-override use-pacing)
                (>= (- (-> self clock frame-counter) (-> self starting-time)) (-> self reaction-time))
                )
           (go-virtual pacing)
           )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info-override idle-anim)))
          )
      (until #f
        (ja-no-eval :group! gp-0
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)) f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    (none)
    )
  :post nav-enemy-stare-post
  )

(defstate taunt (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    ((-> (method-of-type nav-enemy stare) enter))
    (let ((gp-0 (handle->process (-> self focus handle))))
      (when (not gp-0)
        (if (nav-enemy-method-163 self)
            (go-virtual stare)
            (go-virtual active)
            )
        )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    (none)
    )
  :exit (-> (method-of-type nav-enemy stare) exit)
  :trans (behavior ()
    (when (and (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
               (not (nav-enemy-method-163 self))
               )
      (let ((v1-6 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int v1-6))
           (go-virtual active)
           )
          ((and (= v1-6 (enemy-aware enemy-aware-3)) (get-enemy-target self))
           (go-virtual hostile)
           )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2)))
      (let ((gp-0 (get-rand-int-range self 60 210))
            (s5-0 (-> self clock frame-counter))
            (f28-0 f30-0)
            )
        (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override idle-anim))
                    :num! (loop! f28-0)
                    :frame-num 0.0
                    )
        (until (>= (- (-> self clock frame-counter) s5-0) gp-0)
          (suspend)
          (ja :num! (loop! f28-0))
          )
        )
      (ja-channel-push! 1 (seconds 0.1))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override taunt-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override taunt-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (go-virtual stare)
    (none)
    )
  :post nav-enemy-stare-post
  )

(defstate pacing (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (look-at-target! self (enemy-flag lock-focus))
    (logior! (-> self enemy-flags) (enemy-flag use-notice-distance))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info-override callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (nav-enemy-method-165 self)
    (logclear! (-> self mask) (process-mask actor-pause))
    (set! (-> self move-dest quad) (-> self root-override2 trans quad))
    (set! (-> self state-timeout) (the-as time-frame (get-rand-int-range self 2100 3300)))
    (set! (-> self starting-time) (-> self clock frame-counter))
    (if (zero? (get-rand-int self 2))
        (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag40) (-> self enemy-flags))))
        (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag40))))
        )
    (let ((gp-0 (handle->process (-> self focus handle))))
      (if (not gp-0)
          (go-virtual active)
          )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    (none)
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (if a0-1
          (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable a0-1) 0) quad))
          )
      )
    (let ((gp-1 (-> self focus aware)))
      (if (or (!= gp-1 3) (not (get-enemy-target self)))
          (set! (-> self starting-time) (-> self clock frame-counter))
          )
      (when (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
        (if (>= 1 (the-as int gp-1))
            (go-virtual active)
            )
        (when (= gp-1 (enemy-aware enemy-aware-3))
          (when (and (get-enemy-target self)
                     (>= (- (-> self clock frame-counter) (-> self starting-time)) (-> self reaction-time))
                     )
            (nav-enemy-method-161 self)
            (go-virtual hostile)
            )
          (if (-> self enemy-info-override use-circling)
              (go-virtual circling)
              )
          )
        (if (nav-enemy-method-163 self)
            (go-stare2 self)
            )
        (when (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self state-timeout))
          (nav-enemy-method-161 self)
          (go-stare2 self)
          )
        )
      )
    (when (>= 1024.0 (vector-vector-xz-distance (-> self root-override2 trans) (-> self move-dest)))
      (when (and (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
                 (zero? (get-rand-int self 3))
                 )
        (nav-enemy-method-161 self)
        (go-stare2 self)
        )
      (countdown (gp-4 2)
        (let ((s4-0 (new 'stack-no-clear 'vector))
              (f30-1 16384.0)
              (v1-70 (-> self enemy-flags))
              (s5-0 (-> self move-dest))
              )
          (let ((v1-71 (logxor (shl 256 32) (the-as int v1-70))))
            (set! (-> self enemy-flags) (the-as enemy-flag v1-71))
            (if (logtest? (shl 256 32) v1-71)
                (set! f30-1 (- f30-1))
                )
            )
          (set! (-> s5-0 quad) (-> self focus-pos quad))
          (vector-! s4-0 (-> self root-override2 trans) s5-0)
          (set! (-> s4-0 y) 0.0)
          (vector-normalize! s4-0 (get-rand-float-range self 16384.0 49152.0))
          (vector-rotate-around-y! s4-0 s4-0 f30-1)
          (vector+! s5-0 s5-0 s4-0)
          (if (and (cloest-point-on-mesh (-> self nav) s5-0 s5-0 (the-as nav-poly #f))
                   (< 4096.0 (vector-vector-xz-distance s5-0 (-> self root-override2 trans)))
                   )
              (return #f)
              )
          )
        )
      (go-stare2 self)
      )
    (none)
    )
  :code (behavior ()
    (let ((f30-0 (get-rand-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info-override walk-anim)))
          )
      (let ((v1-8 (ja-group)))
        (if (not (and v1-8 (= v1-8 gp-0)))
            (ja-channel-push! 1 (seconds 0.2))
            )
        )
      (until #f
        (ja-no-eval :group! gp-0
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)) f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (let ((a0-0 (-> self nav state))
          (v1-1 (-> self move-dest))
          )
      (logclear! (-> a0-0 flags) (nav-state-flag directional-mode))
      (logior! (-> a0-0 flags) (nav-state-flag target-poly-dirty))
      (set! (-> a0-0 target-post quad) (-> v1-1 quad))
      )
    0
    (nav-enemy-travel-post)
    (none)
    )
  )

(defstate circling (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self state-time) (-> self clock frame-counter))
    (look-at-target! self (enemy-flag lock-focus))
    (logior! (-> self enemy-flags) (enemy-flag use-notice-distance))
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info-override callback-info))
      )
    0
    (nav-enemy-method-165 self)
    (let ((v1-11 self))
      (set! (-> v1-11 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-11 enemy-flags))))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    (let ((gp-0 (handle->process (-> self focus handle))))
      (if (not gp-0)
          (go-virtual active)
          )
      (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable gp-0) 0) quad))
      )
    (let ((f30-0 (-> self enemy-info-override circle-dist-lo))
          (f28-0 (-> self enemy-info-override circle-dist-hi))
          )
      (if (zero? (get-rand-int self 4))
          (set! (-> self desired-angle) (get-rand-float-range self f30-0 f28-0))
          (set! (-> self desired-angle)
                (fmax (fmin (vector-vector-xz-distance (-> self focus-pos) (-> self root-override2 trans)) f28-0) f30-0)
                )
          )
      )
    (set! (-> self enemy-flags) (the-as enemy-flag (logxor (shl 256 32) (the-as int (-> self enemy-flags)))))
    (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag41))))
    (set! (-> self starting-time) (-> self clock frame-counter))
    (none)
    )
  :trans (behavior ()
    (let ((a0-1 (handle->process (-> self focus handle))))
      (if a0-1
          (set! (-> self focus-pos quad) (-> (get-trans (the-as process-focusable a0-1) 0) quad))
          )
      )
    (let ((gp-1 (-> self focus aware)))
      (if (or (!= gp-1 3) (not (get-enemy-target self)))
          (set! (-> self starting-time) (-> self clock frame-counter))
          )
      (when (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
        (when (>= 1 (the-as int gp-1))
          (nav-enemy-method-161 self)
          (if (-> self enemy-info-override use-stop-chase)
              (go-virtual stop-chase)
              (go-virtual active)
              )
          )
        (when (and (= gp-1 (enemy-aware enemy-aware-3))
                   (get-enemy-target self)
                   (>= (- (-> self clock frame-counter) (-> self starting-time)) (-> self reaction-time))
                   )
          (nav-enemy-method-161 self)
          (go-hostile self)
          )
        (if (= gp-1 (enemy-aware enemy-aware-2))
            (go-stare self)
            )
        (if (or (nav-enemy-method-163 self) (logtest? (enemy-flag enemy-flag41) (-> self enemy-flags)))
            (go-stare2 self)
            )
        )
      )
    (none)
    )
  :code (behavior ()
    (let ((f30-0 (get-rand-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info-override walk-anim)))
          )
      (let ((v1-8 (ja-group)))
        (if (not (and v1-8 (= v1-8 gp-0)))
            (ja-channel-push! 1 (seconds 0.1))
            )
        )
      (until #f
        (ja-no-eval :group! gp-0
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)) f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    (none)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (when (logtest? (enemy-flag enemy-flag36) (-> a0-0 enemy-flags))
        (let ((s5-0 (new 'stack-no-clear 'vector)))
          (let ((gp-0 (new 'stack-no-clear 'vector)))
            (let ((f30-0 16384.0))
              (if (logtest? (enemy-flag enemy-flag40) (-> self enemy-flags))
                  (set! f30-0 (- f30-0))
                  )
              (set! (-> s5-0 quad) (-> self focus-pos quad))
              (vector-! gp-0 (-> self root-override2 trans) s5-0)
              (set! (-> gp-0 y) 0.0)
              (vector-normalize! gp-0 (-> self desired-angle))
              (vector+! s5-0 s5-0 gp-0)
              (vector-rotate-around-y! gp-0 gp-0 f30-0)
              )
            (vector-normalize! gp-0 16384.0)
            (vector+! s5-0 s5-0 gp-0)
            )
          (let ((gp-1 (new 'stack-no-clear 'vector)))
            (set! (-> gp-1 quad) (-> self root-override2 trans quad))
            (cloest-point-on-mesh (-> self nav) gp-1 s5-0 (the-as nav-poly #f))
            (if (< (vector-vector-xz-distance gp-1 (-> self root-override2 trans)) 409.6)
                (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag41) (-> self enemy-flags))))
                (set! (-> self enemy-flags) (the-as enemy-flag (logclear (-> self enemy-flags) (enemy-flag enemy-flag41))))
                )
            (let ((v1-28 (-> self nav state)))
              (logclear! (-> v1-28 flags) (nav-state-flag directional-mode))
              (logior! (-> v1-28 flags) (nav-state-flag target-poly-dirty))
              (set! (-> v1-28 target-post quad) (-> gp-1 quad))
              )
            )
          )
        0
        )
      )
    (nav-enemy-travel-post)
    (none)
    )
  )

(defstate flee (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy flee) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (nav-enemy-method-166 self)
    (let ((v1-6 self))
      (if (not (logtest? (enemy-flag enemy-flag36) (-> v1-6 enemy-flags)))
          (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag38) (-> v1-6 enemy-flags))))
          )
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag36) (-> v1-6 enemy-flags))))
      (set! (-> v1-6 nav callback-info) (-> v1-6 enemy-info-override callback-info))
      )
    0
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (none)
    )
  :trans (behavior ()
    (when (>= (- (-> self clock frame-counter) (-> self state-time)) (-> self reaction-time))
      (let ((v1-3 (-> self focus aware)))
        (if (!= v1-3 (enemy-aware unaware))
            (go-stare self)
            )
        )
      (if (nav-enemy-method-163 self)
          (go-stare2 self)
          )
      )
    (none)
    )
  :post nav-enemy-flee-post
  )

(defstate victory (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy victory) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (vector-reset! (-> self root-override2 transv))
    (none)
    )
  :post nav-enemy-simple-post
  )

(defstate hit (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy hit) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (none)
    )
  :code (behavior ()
    (local-vars (v1-37 enemy-flag) (v1-45 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override hit-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override hit-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-36 (-> self enemy-flags)))
      (if (logtest? v1-36 (enemy-flag checking-water))
          (set! v1-37 (logior v1-36 (enemy-flag enable-on-active)))
          (set! v1-37 (logclear v1-36 (enemy-flag enable-on-active)))
          )
      )
    (set! (-> self enemy-flags) v1-37)
    (if (logtest? (-> self enemy-flags) (enemy-flag look-at-move-dest))
        (set! (-> self mask) (logior (process-mask collectable) (-> self mask)))
        (logclear! (-> self mask) (process-mask collectable))
        )
    (let ((v1-44 (-> self enemy-flags)))
      (if (logtest? (enemy-flag no-initial-move-to-ground) v1-44)
          (set! v1-45 (logior (enemy-flag check-water-backup) v1-44))
          (set! v1-45 (logclear v1-44 (enemy-flag check-water-backup)))
          )
      )
    (set! (-> self enemy-flags) v1-45)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (logclear! (-> self focus-status) (focus-status hit))
    (go-hostile self)
    (none)
    )
  :post nav-enemy-simple-post
  )

(defstate knocked (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy knocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logclear (-> v1-4 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-4 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (let ((v1-9 self))
      (set! (-> v1-9 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-9 enemy-flags))))
      )
    0
    (none)
    )
  :post nav-enemy-falling-post
  )

(defstate die (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy die) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (none)
    )
  :post nav-enemy-simple-post
  )

(defstate die-falling (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy die-falling) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (none)
    )
  :post nav-enemy-die-falling-post
  )

(defmethod enemy-method-82 nav-enemy ((obj nav-enemy) (arg0 enemy-jump-info))
  "@abstract"
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    (set! (-> v1-0 quad) (-> arg0 dest-pos quad))
    (set! (-> v1-0 w) (-> obj nav-radius-backup))
    (add-root-sphere-to-hash! (-> obj nav) v1-0 #x80068)
    )
  )

;; WARN: Return type mismatch quaternion vs none.
(defmethod enemy-method-92 nav-enemy ((obj nav-enemy) (arg0 int) (arg1 nav-poly))
  "TODO - nav-poly is a guess
@abstract"
  (let ((v1-0 arg0))
    (when (or (zero? v1-0) (= v1-0 1) (= v1-0 2) (= v1-0 3))
      (let ((a1-4 obj))
        (if (logtest? (enemy-flag enemy-flag37) (-> a1-4 enemy-flags))
            (seek-to-point-toward-point!
              (-> obj root-override2)
              (-> arg1 vertex2)
              (-> obj nav max-rotation-rate)
              (seconds 0.02)
              )
            )
        )
      )
    )
  (none)
  )

(defstate jump (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (logclear! (-> self nav state flags) (nav-state-flag at-gap))
    (none)
    )
  :exit (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump) exit)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 (-> self nav)))
      (logclear! (-> v1-4 shape nav-flags) (nav-flags has-extra-sphere))
      )
    0
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'enemy-jump-info)))
      (let ((s5-0 0))
        (enemy-method-83 self gp-0)
        (if (and (-> self enemy-info-override use-jump-blocked)
                 (logtest? (enemy-flag vulnerable) (-> self enemy-flags))
                 (enemy-method-82 self gp-0)
                 )
            (go-virtual jump-blocked)
            )
        (let* ((v1-13 (-> self nav))
               (a1-2 (-> gp-0 dest-pos))
               (f0-0 (-> v1-13 extra-nav-sphere w))
               )
          (set! (-> v1-13 extra-nav-sphere quad) (-> a1-2 quad))
          (set! (-> v1-13 extra-nav-sphere w) f0-0)
          )
        0
        (let ((v1-16 (-> self nav)))
          (set! (-> v1-16 extra-nav-sphere w) (-> self nav-radius-backup))
          )
        0
        (let ((v1-18 (-> self nav)))
          (logior! (-> v1-18 shape nav-flags) (nav-flags has-extra-sphere))
          )
        0
        (when (logtest? (-> gp-0 flags) 1)
          (until #f
            (if (enemy-method-90 self s5-0 gp-0)
                (goto cfg-12)
                )
            (enemy-method-91 self s5-0 gp-0)
            (enemy-method-92 self s5-0 (the-as nav-poly gp-0))
            (suspend)
            (set! s5-0 1)
            )
          #f
          )
        )
      (label cfg-12)
      (logclear! (-> self root-override2 status) (collide-status on-surface on-ground touch-surface))
      (let ((s5-1 2))
        (logior! (-> self focus-status) (focus-status in-air))
        (until (enemy-method-86 self)
          (+! (-> gp-0 hang-time) (- (-> self clock frame-counter) (-> self clock old-frame-counter)))
          (enemy-method-90 self s5-1 gp-0)
          (enemy-method-91 self s5-1 gp-0)
          (enemy-method-92 self s5-1 (the-as nav-poly gp-0))
          (suspend)
          (set! s5-1 3)
          )
        )
      (logclear! (-> self focus-status) (focus-status in-air))
      (let ((v1-51 (-> self nav)))
        (logclear! (-> v1-51 shape nav-flags) (nav-flags has-extra-sphere))
        )
      0
      (let ((v1-55 (-> self nav state)))
        (set! (-> v1-55 current-poly) (the-as nav-poly #f))
        )
      0
      (logclear! (-> self nav state flags) (nav-state-flag at-target))
      (enemy-method-85 self)
      (let ((s5-2 4))
        (until #f
          (if (enemy-method-90 self s5-2 gp-0)
              (goto cfg-19)
              )
          (enemy-method-91 self s5-2 gp-0)
          (enemy-method-92 self s5-2 (the-as nav-poly gp-0))
          (suspend)
          (set! s5-2 5)
          )
        )
      #f
      (label cfg-19)
      (if (logtest? (enemy-flag alert) (-> self enemy-flags))
          ((lambda :behavior nav-enemy
             ((arg0 enemy-jump-info))
             (send-event (ppointer->process (-> self parent)) 'child-jumped)
             (none)
             )
           gp-0
           )
          )
      )
    (enemy-method-93 self)
    (none)
    )
  :post (behavior ()
    (let ((a0-0 self))
      (cond
        ((logtest? (enemy-flag enemy-flag36) (-> a0-0 enemy-flags))
         (nav-enemy-method-176 self)
         )
        (else
          (let ((a1-2 (new 'stack-no-clear 'overlaps-others-params)))
            (set! (-> a1-2 options) (overlaps-others-options))
            (set! (-> a1-2 collide-with-filter) (-> self enemy-info-override overlaps-others-collide-with-filter))
            (set! (-> a1-2 tlist) *touching-list*)
            (find-overlapping-shapes (-> self root-override2) a1-2)
            )
          (nav-enemy-simple-post)
          )
        )
      )
    (none)
    )
  )

(defstate jump-blocked (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type enemy jump-blocked) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (let ((v1-4 self))
      (set! (-> v1-4 enemy-flags) (the-as enemy-flag (logior (enemy-flag enemy-flag37) (-> v1-4 enemy-flags))))
      )
    0
    (let ((v1-6 self))
      (set! (-> v1-6 enemy-flags) (the-as enemy-flag (logclear (-> v1-6 enemy-flags) (enemy-flag enemy-flag36))))
      (set! (-> v1-6 nav callback-info) *nav-enemy-null-callback-info*)
      )
    0
    (nav-enemy-method-167 self)
    (none)
    )
  :post nav-enemy-simple-post
  )

(defstate directed (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag victory) (-> self enemy-flags)))
    ((-> (method-of-type nav-enemy idle) enter))
    (none)
    )
  :code (-> (method-of-type nav-enemy idle) code)
  :post (-> (method-of-type nav-enemy idle) post)
  )

(defstate view-anims (nav-enemy)
  :virtual #t
  :enter (behavior ()
    (when (-> self nav)
      (let ((v1-1 self))
        (set! (-> v1-1 enemy-flags) (the-as enemy-flag (logclear (-> v1-1 enemy-flags) (enemy-flag enemy-flag37))))
        )
      0
      (let ((v1-3 self))
        (set! (-> v1-3 enemy-flags) (the-as enemy-flag (logclear (-> v1-3 enemy-flags) (enemy-flag enemy-flag36))))
        (set! (-> v1-3 nav callback-info) *nav-enemy-null-callback-info*)
        )
      0
      )
    (none)
    )
  )

(defstate debug-control (nav-enemy)
  :virtual #t
  :event (the-as (function process int symbol event-message-block object :behavior nav-enemy) enemy-event-handler)
  :code (behavior ()
    (let ((v1-0 *nav-enemy-debug-control-info*))
      (set! (-> v1-0 steering) 0.0)
      (set! (-> v1-0 throttle) 0.0)
      )
    (ja-channel-push! 1 (seconds 0.2))
    (until #f
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info-override walk-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info-override walk-anim)))
                                frames
                                num-frames
                                )
                            -1
                            )
                         )
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek!))
        )
      )
    #f
    (none)
    )
  :post nav-enemy-debug-control-post
  )
