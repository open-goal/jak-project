;;-*-Lisp-*-
(in-package goal)

;; name: entity.gc
;; name in dgo: entity
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(define *spawn-actors* #t)

(define *compact-actors* #t)

(define *vis-actors* #t)

(defmethod mem-usage drawable-actor ((obj drawable-actor) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 44 (-> arg0 length)))
  (set! (-> arg0 data 43 name) "entity")
  (+! (-> arg0 data 43 count) 1)
  (let ((v1-6 (asize-of obj)))
    (+! (-> arg0 data 43 used) v1-6)
    (+! (-> arg0 data 43 total) (logand -16 (+ v1-6 15)))
    )
  (mem-usage (-> obj actor) arg0 (logior arg1 64))
  (the-as drawable-actor 0)
  )

(defmethod mem-usage drawable-inline-array-actor ((obj drawable-inline-array-actor) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 1 (-> arg0 length)))
  (set! (-> arg0 data 0 name) (symbol->string 'drawable-group))
  (+! (-> arg0 data 0 count) 1)
  (let ((v1-7 32))
    (+! (-> arg0 data 0 used) v1-7)
    (+! (-> arg0 data 0 total) (logand -16 (+ v1-7 15)))
    )
  (dotimes (s3-0 (-> obj length))
    (mem-usage (-> obj data s3-0) arg0 arg1)
    )
  (the-as drawable-inline-array-actor 0)
  )

(defmethod print entity-links ((obj entity-links))
  (format #t "#<entity-links :process ~A @ #x~X>" (-> obj process) obj)
  obj
  )

(defmethod print entity-perm ((obj entity-perm))
  (format
    #t
    "#<entity-perm :aid ~D :task ~D :status #x~X :data #x~X @ #x~X>"
    (-> obj aid)
    (-> obj task)
    (-> obj status)
    (-> obj user-uint64)
    obj
    )
  obj
  )

(defmethod print actor-group ((obj actor-group))
  (format #t "#<actor-group")
  (dotimes (s5-0 (-> obj length))
    (format #t " ~A" (-> obj data s5-0 actor))
    )
  (format #t " @ #x~X>" obj)
  obj
  )

(defmethod inspect actor-group ((obj actor-group))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tlength: ~D~%" (-> obj length))
  (format #t "~Tallocated-length: ~D~%" (-> obj allocated-length))
  (format #t "~Tdata[~D]: @ #x~X~%" (-> obj length) (-> obj data))
  (dotimes (s5-0 (-> obj length))
    (format #t "~T  [~D] ~A / ~D~%" s5-0 (-> obj data s5-0 actor) (-> obj data s5-0 id))
    )
  obj
  )

(defmethod birth! entity ((obj entity))
  (format #t "birth ~A~%" obj)
  obj
  )

(defmethod kill! entity ((obj entity))
  (format #t "kill ~A~%" obj)
  obj
  )

(defmethod print entity ((obj entity))
  (format #t "#<~A :name ~S @ #x~X>" (-> obj type) (res-lump-struct obj 'name structure) obj)
  obj
  )

(defmethod get-level entity ((obj entity))
  (dotimes (v1-0 (-> *level* length))
    (let ((a1-3 (-> *level* level v1-0)))
      (when (= (-> a1-3 status) 'active)
        (if (and (>= (the-as int obj) (the-as int (-> a1-3 heap base)))
                 (< (the-as int obj) (the-as int (-> a1-3 heap top-base)))
                 )
            (return a1-3)
            )
        )
      )
    )
  (-> *level* default-level)
  )

(defun entity-by-name ((arg0 string))
  (dotimes (s5-0 (-> *level* length))
    (let ((s4-0 (-> *level* level s5-0)))
      (when (= (-> s4-0 status) 'active)
        (let ((s3-0 (-> s4-0 bsp actors)))
          (when (nonzero? s3-0)
            (dotimes (s2-0 (-> s3-0 length))
              (let ((s1-0 (-> s3-0 data s2-0 actor)))
                (if (string= (res-lump-struct s1-0 'name string) arg0)
                    (return s1-0)
                    )
                )
              )
            )
          )
        (let ((s3-1 (-> s4-0 bsp nav-meshes)))
          (when (nonzero? s3-1)
            (dotimes (s2-1 (-> s3-1 length))
              (let ((s1-1 (-> s3-1 s2-1)))
                (if (string= (res-lump-struct s1-1 'name string) arg0)
                    (return s1-1)
                    )
                )
              )
            )
          )
        (let ((s3-2 (-> s4-0 bsp race-meshes)))
          (when (nonzero? s3-2)
            (dotimes (s2-2 (-> s3-2 length))
              (let ((s1-2 (-> s3-2 s2-2)))
                (if (string= (res-lump-struct s1-2 'name string) arg0)
                    (return s1-2)
                    )
                )
              )
            )
          )
        (let ((s4-1 (-> s4-0 bsp cameras)))
          (when (nonzero? s4-1)
            (dotimes (s3-3 (-> s4-1 length))
              (let ((s2-3 (-> s4-1 s3-3)))
                (if (string= (res-lump-struct s2-3 'name string) arg0)
                    (return s2-3)
                    )
                )
              )
            )
          )
        )
      )
    )
  (the-as entity #f)
  )

;; definition for function entity-by-type
(defun entity-by-type ((arg0 type))
  (dotimes (s5-0 (-> *level* length))
    (let ((v1-3 (-> *level* level s5-0)))
      (when (= (-> v1-3 status) 'active)
        (let ((s4-0 (-> v1-3 bsp actors)))
          (when (nonzero? s4-0)
            (dotimes (s3-0 (-> s4-0 length))
              (let ((s2-0 (-> s4-0 data s3-0 actor)))
                (if (and (type? s2-0 entity-actor) (= (-> s2-0 etype) arg0))
                    (return s2-0)
                    )
                )
              )
            )
          )
        )
      )
    )
  (the-as entity-actor #f)
  )

;; definition for function entity-by-aid
(defun entity-by-aid ((arg0 uint))
  (dotimes (v1-0 (-> *level* length))
    (let ((a1-3 (-> *level* level v1-0)))
      (when (= (-> a1-3 status) 'active)
        (let ((a1-4 (-> a1-3 entity)))
          (when (nonzero? a1-4)
            (let ((a2-4 0)
                  (a3-2 (+ (-> a1-4 length) -1))
                  )
              0
              (while (>= a3-2 a2-4)
                (let* ((t0-3 (+ a2-4 (/ (- a3-2 a2-4) 2)))
                       (t1-2 (-> a1-4 data t0-3))
                       (t2-0 (-> t1-2 perm aid))
                       )
                  (cond
                    ((= t2-0 arg0)
                     (return (-> t1-2 entity))
                     )
                    ((< (the-as uint t2-0) arg0)
                     (set! a2-4 (+ t0-3 1))
                     )
                    (else
                      (set! a3-2 (+ t0-3 -1))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (the-as entity #f)
  )

;; definition for function entity-actor-from-level-name
;; WARN: Return type mismatch entity vs entity-actor.
(defun entity-actor-from-level-name ((arg0 level))
  (let ((v0-0 (the-as entity #f)))
    (dotimes (s5-0 (-> *level* length))
      (let ((s4-0 (-> *level* level s5-0)))
        (when (= (-> s4-0 status) 'active)
          (when (= (-> s4-0 name) arg0)
            (when (zero? (-> s4-0 entity length))
              (format 0 "ERROR: level ~s has no entities!!" (-> s4-0 name))
              (when *debug-segment*
                (break!)
                0
                )
              )
            (set! v0-0 (-> s4-0 entity data 0 entity))
            )
          )
        )
      )
    (the-as entity-actor v0-0)
    )
  )

;; TODO HUGE GAP

(defmethod add-to-level! entity-actor ((obj entity-actor) (arg0 level-group) (arg1 level) (arg2 actor-id))
  (let ((v1-4 (-> arg1 entity data (-> arg1 entity length))))
    (+! (-> arg1 entity length) 1)
    (set! (-> v1-4 process) #f)
    (set! (-> v1-4 entity) obj)
    (set! (-> obj extra) v1-4)
    (cond
      ((-> arg0 entity-link)
       (let* ((a0-6 (-> arg0 entity-link))
              (t0-1 (-> a0-6 next-link))
              )
         (set! (-> a0-6 next-link) v1-4)
         (set! (-> v1-4 prev-link) a0-6)
         (set! (-> v1-4 next-link) t0-1)
         (set! (-> t0-1 prev-link) v1-4)
         )
       )
      (else
        (set! (-> v1-4 prev-link) v1-4)
        (set! (-> v1-4 next-link) v1-4)
        )
      )
    (set! (-> arg0 entity-link) v1-4)
    (set! (-> v1-4 trans quad) (-> obj trans quad))
    )
  (set! (-> obj extra perm aid) arg2)
  (set! (-> obj extra level) arg1)
  (set! (-> obj extra kill-mask)
        (logior (logand (-> obj kill-mask)
                        (task-mask
                          task0
                          task1
                          task2
                          task3
                          task4
                          task5
                          task6
                          task7
                          done
                          dummy0
                          dummy1
                          dummy2
                          special
                          primary0
                          ctywide
                          never
                          )
                        )
                (logclear
                  (task-mask movie0 movie1 movie2 tm19 tm20 tm21 tm22 tm23 tm24 tm25 tm26 tm27 tm28 tm29 tm30 tm31)
                  (-> obj kill-mask)
                  )
                )
        )
  (if (not (-> arg1 vis-info 0))
      (set! (-> obj extra vis-dist) (res-lump-float obj 'vis-dist :default 40960000.0))
      )
  (cond
    ((= (-> obj type) entity-actor)
     (set! (-> obj extra perm task) (the-as uint (-> obj task)))
     (set! (-> obj extra vis-id) (-> obj vis-id))
     )
    (else
      (set! (-> obj extra perm task) (the-as uint 0))
      (set! (-> obj extra vis-id) 0)
      0
      )
    )
  (none)
  )

(defmethod birth bsp-header ((obj bsp-header))
  (local-vars (v1-74 int) (s5-0 int) (sv-16 int))
  (.mfc0 s5-0 Count)
  (let ((a2-0 (if (nonzero? (-> obj actors))
                  (-> obj actors length)
                  0
                  )
              )
        )
    (cond
      ((not (-> obj level entity))
       (set! (-> obj level entity) (new 'loading-level 'entity-links-array a2-0))
       )
      ((< (-> obj level entity allocated-length) a2-0)
       (format
         0
         "ERROR: Attempting to rebirth level ~A with incorrect entity table size ~D/~D~%"
         (-> obj level)
         a2-0
         (-> obj level entity allocated-length)
         )
       )
      )
    )
  (set! (-> obj level entity length) 0)
  0
  (when (nonzero? (-> obj actors))
    (dotimes (s4-0 (-> obj actors length))
      (let* ((a0-4 (-> obj actor-birth-order s4-0))
             (v1-23 (-> obj actors data (logand a0-4 #xffff) actor))
             )
        (add-to-level! v1-23 *level* (-> obj level) (the-as actor-id (-> v1-23 aid)))
        )
      )
    )
  (let ((s4-1 (-> obj cameras)))
    (when (nonzero? s4-1)
      (dotimes (s3-0 (-> s4-1 length))
        (birth! (-> s4-1 s3-0))
        )
      )
    )
  (let ((s4-2 (-> obj level status)))
    (set! (-> obj level status) 'active)
    (dotimes (s3-1 (-> *level* length))
      (let ((s2-0 (-> *level* level s3-1)))
        (when (= (-> s2-0 status) 'active)
          (when (nonzero? (-> s2-0 bsp actor-groups))
            (countdown (s1-0 (-> s2-0 bsp actor-groups length))
              (let ((s0-0 (-> s2-0 bsp actor-groups s1-0)))
                (set! sv-16 0)
                (while (< sv-16 (-> s0-0 length))
                  (if (not (-> s0-0 data sv-16 actor))
                      (set! (-> s0-0 data sv-16 actor) (entity-by-aid (-> s0-0 data sv-16 id)))
                      )
                  (set! sv-16 (+ sv-16 1))
                  )
                )
              )
            )
          )
        )
      )
    (set! (-> obj level status) s4-2)
    )
  (.mfc0 v1-74 Count)
  (let ((a3-2 (- v1-74 s5-0)))
    (format 0 "Done ~S in ~D~%" "birth" a3-2)
    )
  (none)
  )