;;-*-Lisp-*-
(in-package goal)

;; name: relocate.gc
;; name in dgo: relocate
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(defmethod relocate process ((obj process) (arg0 int))
  (let ((v1-0 *kernel-context*))
    (set! (-> v1-0 relocating-process) obj)
    (set! (-> v1-0 relocating-min) (the-as int (&-> obj type)))
    (set! (-> v1-0 relocating-max)
          (the-as int (+ (+ (-> obj allocated-length) -4 (-> process size)) (the-as int obj)))
          )
    (set! (-> v1-0 relocating-offset) arg0)
    )
  (&+! (-> obj ppointer 0) arg0)
  (let ((v1-5 (-> obj entity)))
    (if (and v1-5 (= (-> v1-5 extra process) obj))
        (&+! (-> v1-5 extra process) arg0)
        )
    )
  (let ((v1-7 (-> obj connection-list next1)))
    (while (the-as connection v1-7)
      (let ((a0-14 (-> v1-7 prev1)))
        (if (and (>= (the-as int a0-14) (-> *kernel-context* relocating-min))
                 (< (the-as int a0-14) (-> *kernel-context* relocating-max))
                 )
            (&+! (-> v1-7 prev1) arg0)
            )
        )
      (let ((a0-19 (-> (the-as connection v1-7) param1)))
        (if (and (>= (the-as int a0-19) (-> *kernel-context* relocating-min))
                 (< (the-as int a0-19) (-> *kernel-context* relocating-max))
                 )
            (&+! (-> (the-as connection v1-7) param1) arg0)
            )
        )
      (let ((a0-24 (-> (the-as connection v1-7) param2)))
        (if (and (>= a0-24 (-> *kernel-context* relocating-min)) (< a0-24 (-> *kernel-context* relocating-max)))
            (+! (-> (the-as connection v1-7) param2) arg0)
            )
        )
      (let ((a0-29 (-> (the-as connection v1-7) param3)))
        (if (and (>= a0-29 (-> *kernel-context* relocating-min)) (< a0-29 (-> *kernel-context* relocating-max)))
            (+! (-> (the-as connection v1-7) param3) arg0)
            )
        )
      (set! v1-7 (-> (the-as connection v1-7) next1))
      )
    )
  (let ((v1-10 (-> obj self)))
    (if (and (>= (the-as int v1-10) (-> *kernel-context* relocating-min))
             (< (the-as int v1-10) (-> *kernel-context* relocating-max))
             )
        (&+! (-> obj self) arg0)
        )
    )
  (let ((v1-15 (-> obj ppointer)))
    (if (and (>= (the-as int v1-15) (-> *kernel-context* relocating-min))
             (< (the-as int v1-15) (-> *kernel-context* relocating-max))
             )
        (&+! (-> obj ppointer) arg0)
        )
    )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; Don't remove this cast
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (let ((s4-0 (the-as basic (&+ (-> obj heap-base) 4))))
    (while (< (the-as int s4-0) (the-as int (-> obj heap-cur)))
      (relocate s4-0 arg0)
      (&+! s4-0 (logand -16 (+ (asize-of s4-0) 15)))
      )
    )
  (&+! (-> obj main-thread) arg0)
  (&+! (-> obj top-thread) arg0)
  (&+! (-> obj heap-base) arg0)
  (&+! (-> obj heap-cur) arg0)
  (&+! (-> obj heap-top) arg0)
  (let ((a2-4 (asize-of obj))
        (a1-22 (&-> obj type))
        )
    (cond
      ((>= arg0 0)
       (qmem-copy->! (&+ a1-22 arg0) a1-22 a2-4)
       )
      ((< a2-4 2560)
       (qmem-copy<-! (&+ a1-22 arg0) a1-22 a2-4)
       )
      (else
        (ultimate-memcpy (&+ a1-22 arg0) a1-22 (the-as uint a2-4))
        )
      )
    )
  (set! (-> *kernel-context* relocating-process) #f)
  (&+ obj arg0)
  )

(defmethod relocate cpu-thread ((obj cpu-thread) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

;; WARN: Return type mismatch process vs process-drawable.
(defmethod relocate process-drawable ((obj process-drawable) (arg0 int))
  (let ((v1-0 *kernel-context*))
    (set! (-> v1-0 relocating-process) obj)
    (set! (-> v1-0 relocating-min) (the-as int (&-> obj type)))
    (set! (-> v1-0 relocating-max)
          (the-as int (+ (+ (-> obj allocated-length) -4 (-> process size)) (the-as int obj)))
          )
    (set! (-> v1-0 relocating-offset) arg0)
    )
  (let ((a0-6 (-> obj nav)))
    (if (and (nonzero? a0-6) a0-6)
        (relocate a0-6 arg0)
        )
    )
  (if (nonzero? (-> obj root))
      (&+! (-> obj root) arg0)
      )
  (if (nonzero? (-> obj node-list))
      (&+! (-> obj node-list) arg0)
      )
  (if (nonzero? (-> obj draw))
      (&+! (-> obj draw) arg0)
      )
  (if (nonzero? (-> obj skel))
      (&+! (-> obj skel) arg0)
      )
  (if (nonzero? (-> obj align))
      (&+! (-> obj align) arg0)
      )
  (if (nonzero? (-> obj path))
      (&+! (-> obj path) arg0)
      )
  (if (nonzero? (-> obj vol))
      (&+! (-> obj vol) arg0)
      )
  (if (nonzero? (-> obj fact))
      (&+! (-> obj fact) arg0)
      )
  (if (nonzero? (-> obj link))
      (&+! (-> obj link) arg0)
      )
  (if (nonzero? (-> obj part))
      (&+! (-> obj part) arg0)
      )
  (if (nonzero? (-> obj water))
      (&+! (-> obj water) arg0)
      )
  (if (nonzero? (-> obj sound))
      (&+! (-> obj sound) arg0)
      )
  (if (nonzero? (-> obj carry))
      (&+! (-> obj carry) arg0)
      )
  (if (nonzero? (-> obj rbody))
      (&+! (-> obj rbody) arg0)
      )
  (the-as process-drawable ((method-of-type process relocate) obj arg0))
  )

(defmethod relocate collide-shape ((obj collide-shape) (arg0 int))
  (&+! (-> obj process) arg0)
  (&+! (-> obj root-prim) arg0)
  obj
  )

;; WARN: Return type mismatch collide-shape vs collide-shape-moving.
(defmethod relocate collide-shape-moving ((obj collide-shape-moving) (arg0 int))
  (if (-> obj dynam)
      (&+! (-> obj dynam) arg0)
      )
  (the-as collide-shape-moving ((method-of-type collide-shape relocate) obj arg0))
  )

(defmethod relocate collide-shape-prim ((obj collide-shape-prim) (arg0 int))
  (&+! (-> obj cshape) arg0)
  obj
  )

(defmethod relocate collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 int))
  (&+! (-> obj cshape) arg0)
  (set! (-> obj child) (the-as (inline-array collide-shape-prim) (&+ (the-as pointer (-> obj child)) arg0)))
  obj
  )

(defmethod relocate fact-info ((obj fact-info) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate draw-control ((obj draw-control) (arg0 int))
  (&+! (-> obj skeleton) arg0)
  (&+! (-> obj process) arg0)
  (when (-> obj ripple)
    (if (-> obj ripple query)
        (&+! (-> obj ripple query) arg0)
        )
    (&+! (-> obj ripple) arg0)
    )
  (let ((v1-14 (-> obj shadow-ctrl)))
    (if (and (>= (the-as int v1-14) (-> *kernel-context* relocating-min))
             (< (the-as int v1-14) (-> *kernel-context* relocating-max))
             )
        (&+! (-> obj shadow-ctrl) arg0)
        )
    )
  obj
  )

(defmethod relocate joint-control ((obj joint-control) (arg0 int))
  (if (-> obj effect)
      (&+! (-> obj effect) arg0)
      )
  (if (-> obj top-anim)
      (&+! (-> obj top-anim) arg0)
      )
  (&+! (-> obj root-channel) arg0)
  (countdown (v1-10 (-> obj allocated-length))
    (&+! (-> obj channel v1-10 parent) arg0)
    )
  obj
  )

(defmethod relocate cspace-array ((obj cspace-array) (arg0 int))
  (countdown (v1-0 (-> obj length))
    (let ((a2-2 (-> obj data v1-0)))
      (if (-> a2-2 parent)
          (&+! (-> a2-2 parent) arg0)
          )
      (&+! (-> a2-2 bone) arg0)
      (let ((a3-6 (-> a2-2 param1)))
        (if (and (>= (the-as int a3-6) (-> *kernel-context* relocating-min))
                 (< (the-as int a3-6) (-> *kernel-context* relocating-max))
                 )
            (&+! (-> a2-2 param1) arg0)
            )
        )
      (let ((a3-11 (-> a2-2 param2)))
        (if (and (>= (the-as int a3-11) (-> *kernel-context* relocating-min))
                 (< (the-as int a3-11) (-> *kernel-context* relocating-max))
                 )
            (&+! (-> a2-2 param2) arg0)
            )
        )
      )
    )
  obj
  )

(defmethod relocate path-control ((obj path-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate vol-control ((obj vol-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate water-control ((obj water-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate actor-link-info ((obj actor-link-info) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate align-control ((obj align-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate joint-mod ((obj joint-mod) (arg0 int))
  (&+! (-> obj process) arg0)
  (&+! (-> obj joint) arg0)
  obj
  )

(defmethod relocate joint-mod-wheel ((obj joint-mod-wheel) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate joint-mod-ik ((obj joint-mod-ik) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate effect-control ((obj effect-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod relocate sparticle-launch-control ((obj sparticle-launch-control) (arg0 int))
  (&+! (-> obj proc) arg0)
  (countdown (v1-2 (-> obj length))
    (let* ((a0-4 (-> obj data v1-2))
           (a2-0 (-> a0-4 center))
           )
      (if (and (>= (the-as int a2-0) (-> *kernel-context* relocating-min))
               (< (the-as int a2-0) (-> *kernel-context* relocating-max))
               )
          (&+! (-> a0-4 center) arg0)
          )
      )
    )
  (forall-particles-with-key
    obj
    (lambda ((arg0 sparticle-system) (arg1 sparticle-cpuinfo))
      (let ((v1-1 (-> *kernel-context* relocating-offset)))
        (set! (-> arg1 key) (the-as sparticle-launch-control (+ (the-as int (-> arg1 key)) v1-1)))
        (if (-> arg1 binding)
            (set! (-> arg1 binding) (the-as sparticle-launch-state (+ (the-as int (-> arg1 binding)) v1-1)))
            )
        )
      0
      (none)
      )
    #t
    #t
    )
  obj
  )

;; WARN: Return type mismatch process vs camera-master.
(defmethod relocate camera-master ((obj camera-master) (arg0 int))
  (if (nonzero? (-> obj water-drip))
      (&+! (-> obj water-drip) arg0)
      )
  (the-as camera-master ((method-of-type process relocate) obj arg0))
  )

;; WARN: Return type mismatch process vs time-of-day-proc.
(defmethod relocate time-of-day-proc ((obj time-of-day-proc) (arg0 int))
  (if (nonzero? (-> obj sun))
      (&+! (-> obj sun) arg0)
      )
  (if (nonzero? (-> obj green-sun))
      (&+! (-> obj green-sun) arg0)
      )
  (if (nonzero? (-> obj moon))
      (&+! (-> obj moon) arg0)
      )
  (the-as time-of-day-proc ((method-of-type process relocate) obj arg0))
  )

;; WARN: Return type mismatch process vs part-tracker.
(defmethod relocate part-tracker ((obj part-tracker) (arg0 int))
  (if (nonzero? (-> obj root))
      (&+! (-> obj root) arg0)
      )
  (if (nonzero? (-> obj part))
      (&+! (-> obj part) arg0)
      )
  (the-as part-tracker ((method-of-type process relocate) obj arg0))
  )

;; WARN: Return type mismatch process vs part-spawner.
(defmethod relocate part-spawner ((obj part-spawner) (arg0 int))
  (if (nonzero? (-> obj root))
      (&+! (-> obj root) arg0)
      )
  (if (nonzero? (-> obj part))
      (&+! (-> obj part) arg0)
      )
  (if (nonzero? (-> obj sound))
      (&+! (-> obj sound) arg0)
      )
  (the-as part-spawner ((method-of-type process relocate) obj arg0))
  )

;; WARN: Return type mismatch process vs lightning-tracker.
(defmethod relocate lightning-tracker ((obj lightning-tracker) (arg0 int))
  (if (nonzero? (-> obj root))
      (&+! (-> obj root) arg0)
      )
  (if (nonzero? (-> obj lightning))
      (&+! (-> obj lightning) arg0)
      )
  (the-as lightning-tracker ((method-of-type process relocate) obj arg0))
  )

;; WARN: Return type mismatch process-drawable vs manipy.
(defmethod relocate manipy ((obj manipy) (arg0 int))
  (if (nonzero? (-> obj joint 0))
      (&+! (-> obj joint 0) arg0)
      )
  (if (nonzero? (-> obj joint 1))
      (&+! (-> obj joint 1) arg0)
      )
  (if (nonzero? (-> obj joint 2))
      (&+! (-> obj joint 2) arg0)
      )
  (if (nonzero? (-> obj joint 3))
      (&+! (-> obj joint 3) arg0)
      )
  (the-as manipy ((method-of-type process-drawable relocate) obj arg0))
  )
