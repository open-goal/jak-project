;;-*-Lisp-*-
(in-package goal)

;; name: drawable-tree.gc
;; name in dgo: drawable-tree
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(defmethod draw drawable-tree-array ((obj drawable-tree-array) (arg0 drawable-tree-array) (arg1 display-frame))
  (case (-> *level* draw-level *draw-index* display?)
    (('special #f)
     )
    (else
      (dotimes (idx (-> obj length))
        (draw (-> obj trees idx) (-> arg0 trees idx) arg1)
        )
      )
    )
  0
  (none)
  )

(defmethod collect-stats drawable-tree-array ((obj drawable-tree-array))
  (dotimes (idx (-> obj length))
    (collect-stats (-> obj trees idx))
    )
  0
  (none)
  )

(defmethod debug-draw drawable-tree-array ((obj drawable-tree-array) (arg0 drawable) (arg1 display-frame))
  (dotimes (idx (-> obj length))
    (debug-draw (-> obj trees idx) (-> (the-as drawable-tree-array arg0) trees idx) arg1)
    )
  0
  (none)
  )

(defmethod unpack-vis drawable-tree ((obj drawable-tree) (arg0 (pointer int8)) (arg1 (pointer int8)))
  (local-vars (t5-1 uint))
  (let* ((v1-0 (the-as drawable-inline-array-node (-> obj data 0)))
         (a3-1 (/ (-> v1-0 data 0 id) 8))
         (t0-0 (-> v1-0 length))
         (v1-1 (&+ arg0 a3-1))
         (a3-3 (/ (+ t0-0 7) 8))
         )
    (dotimes (t0-1 a3-3)
      (let ((t1-0 (-> arg1 0)))
        (set! arg1 (&-> arg1 1))
        (set! (-> v1-1 0) t1-0)
        )
      (set! v1-1 (&-> v1-1 1))
      )
    )
  (let ((v1-5 (+ (-> obj length) -1)))
    (when (nonzero? v1-5)
      (dotimes (a3-5 v1-5)
        (let* ((t0-4 (-> obj data a3-5))
               (t2-0 (the-as drawable-inline-array-node (-> obj data (+ a3-5 1))))
               (t1-5 (/ (-> (the-as drawable-inline-array-node t0-4) data 0 id) 8))
               (t2-2 (/ (-> t2-0 data 0 id) 8))
               (t0-5 (-> (the-as drawable-inline-array-node t0-4) length))
               (t1-6 (&+ arg0 t1-5))
               (t2-3 (the-as object (&+ arg0 t2-2)))
               )
          (loop
            (let ((t3-0 (-> t1-6 0)))
              (set! t1-6 (&-> t1-6 1))
              (let ((t4-0 128))
                (label cfg-7)
                (b! (zero? (logand t3-0 t4-0)) cfg-9 :delay (set! t5-1 (the-as uint (-> arg1 0))))
                (set! arg1 (&-> arg1 1))
                (set! (-> (the-as (pointer int8) t2-3) 0) (the-as int t5-1))
                (label cfg-9)
                (+! t0-5 -1)
                (b! (zero? t0-5) cfg-12 :delay (shift-arith-right-32 t4-0 t4-0 1))
                (b! (nonzero? (the-as uint t4-0)) cfg-7 :delay (set! t2-3 (&-> (the-as (pointer int8) t2-3) 1)))
                )
              )
            )
          )
        (label cfg-12)
        (nop!)
        0
        )
      )
    )
  arg1
  )
