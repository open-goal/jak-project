;;-*-Lisp-*-
(in-package goal)

;; name: script.gc
;; name in dgo: script
;; dgos: ENGINE, GAME

(declare-type script-form structure)
(define-extern *script-form* (inline-array script-form))

(with-pp

;; DECOMP BEGINS

(defun command-get-int ((arg0 object) (arg1 int))
  (cond
    ((null? arg0)
     (empty)
     arg1
     )
    ((type? arg0 binteger)
     (the-as int (/ (the-as int arg0) 8))
     )
    ((type? arg0 bfloat)
     (the int (-> (the-as bfloat arg0) data))
     )
    (else
      (empty)
      arg1
      )
    )
  )

(defun command-get-float ((arg0 object) (arg1 float))
  (cond
    ((null? arg0)
     (empty)
     arg1
     )
    ((type? arg0 binteger)
     (the float (/ (the-as int arg0) 8))
     )
    ((type? arg0 bfloat)
     (-> (the-as bfloat arg0) data)
     )
    (else
      (empty)
      arg1
      )
    )
  )

;; WARN: Return type mismatch int vs time-frame.
(defun command-get-time ((arg0 object) (arg1 int))
  (the-as time-frame (cond
                       ((null? arg0)
                        (empty)
                        arg1
                        )
                       ((and (pair? arg0) (= (car arg0) 'seconds))
                        (the int (* 300.0 (command-get-float (car (cdr arg0)) 0.0)))
                        )
                       ((and (pair? arg0) (= (car arg0) 'frame-time))
                        (the int (* 5.0000005 (command-get-float (car (cdr arg0)) 0.0)))
                        )
                       ((and (pair? arg0) (= (car arg0) 'frame-time-30))
                        (the int (* 10.000001 (command-get-float (car (cdr arg0)) 0.0)))
                        )
                       ((and (pair? arg0) (= (car arg0) 'frame-range))
                        (let ((f30-3 (command-get-float (car (cdr arg0)) 0.0))
                              (f28-0 (command-get-float (car (cdr (cdr arg0))) 0.0))
                              (f0-9 (command-get-float (car (cdr (cdr (cdr arg0)))) 0.0))
                              )
                          (if (= f0-9 0.0)
                              (set! f0-9 30.0)
                              )
                          (the int (* 300.0 (/ (- f28-0 f30-3) f0-9)))
                          )
                        )
                       ((type? arg0 binteger)
                        (the-as int (/ (the-as int arg0) 8))
                        )
                       ((type? arg0 bfloat)
                        (the int (-> (the-as (pointer float) arg0) 0))
                        )
                       (else
                         (empty)
                         arg1
                         )
                       )
          )
  )

(defun command-get-param ((arg0 object) (arg1 object))
  (cond
    ((null? arg0)
     arg1
     )
    ((and (pair? arg0) (= (car arg0) 'seconds))
     (the int (* 300.0 (command-get-float (car (cdr arg0)) 0.0)))
     )
    ((and (pair? arg0) (= (car arg0) 'meters))
     (* 4096.0 (command-get-float (car (cdr arg0)) 0.0))
     )
    ((and (pair? arg0) (= (car arg0) 'deg))
     (* 182.04445 (command-get-float (car (cdr arg0)) 0.0))
     )
    ((and (pair? arg0) (= (car arg0) 'static-vectorm))
     (let ((s4-0 (the-as object (new 'static 'vector4))))
       (set-vector!
         (the-as vector4 s4-0)
         (* 4096.0 (command-get-float (car (cdr arg0)) 0.0))
         (* 4096.0 (command-get-float (car (cdr (cdr arg0))) 0.0))
         (* 4096.0 (command-get-float (car (cdr (cdr (cdr arg0)))) 0.0))
         1.0
         )
       s4-0
       )
     )
    ((type? arg0 binteger)
     (/ (the-as int arg0) 8)
     )
    ((type? arg0 bfloat)
     (-> (the-as (pointer float) arg0) 0)
     )
    (else
      arg0
      )
    )
  )

(defun command-get-quoted-param ((arg0 object) (arg1 object))
  (if (and (pair? arg0) (= (car arg0) 'quote))
      (command-get-param (car (cdr arg0)) arg1)
      (command-get-param arg0 arg1)
      )
  )

;; WARN: Return type mismatch object vs process.
;; ERROR: Failed load: (set! v1-23 (l.wu 0)) at op 104
;; WARN: Using new Jak 2 rtype-of
(defun command-get-process ((arg0 object) (arg1 process))
  (with-pp
    (set! arg1
          (cond
            ((or (null? arg0) (not arg0))
             (empty)
             arg1
             )
            ((or (type? arg0 process) (= (rtype-of arg0) actor-group))
             (the-as process arg0)
             )
            ((type? arg0 entity-actor)
             (-> (the-as entity-actor arg0) extra process)
             )
            ((= arg0 'target)
             *target*
             )
            ((= arg0 'sidekick)
             (when *target*
               (let ((v1-11 (-> *target* sidekick)))
                 (if v1-11
                     (the-as process (-> v1-11 0 self))
                     )
                 )
               )
             )
            ((= arg0 'parent)
             (let ((v1-14 (-> pp parent)))
               (if v1-14
                   (the-as process (-> v1-14 0 self))
                   )
               )
             )
            ((= arg0 'camera)
             *camera*
             )
            ((= arg0 '*task-manager*)
             (let ((v1-19 (-> *setting-control* user-current exclusive-task)))
               (when v1-19
                 (let ((a0-9 (-> *task-manager-engine* alive-list next0)))
                   *task-manager-engine*
                   (let ((a1-5 (-> (the-as connection a0-9) next0)))
                     (while (!= a0-9 (-> *task-manager-engine* alive-list-end))
                       (when (= (-> (the-as game-task-node-info (-> (the-as connection a0-9) param2)) task) v1-19)
                         (set! arg1 (the-as process (-> (the-as connection a0-9) param1)))
                         (goto cfg-87)
                         )
                       (set! a0-9 (the-as connection a1-5))
                       *task-manager-engine*
                       (set! a1-5 (-> a1-5 next0))
                       )
                     )
                   )
                 )
               )
             (let ((v1-23 (-> *task-manager-engine* alive-list next0)))
               *task-manager-engine*
               (-> (the-as connection v1-23) next0)
               (while (!= v1-23 (-> *task-manager-engine* alive-list-end))
                 (set! arg1 (the-as process (-> (the-as connection v1-23) param1)))
                 (b! #t cfg-87 :delay (nop!))
                ;;  (the-as none 0)
                ;;  (the-as none *task-manager-engine*)
                ;;  (the-as none 0)
                ;;  (the-as none 0)
                ;;  (set! v1-23 (the-as connectable (l.wu 0)))
                 )
               )
             (the-as process #f)
             )
            ((type? arg0 string)
             (set! arg1 (process-by-ename (the-as string arg0)))
             (cond
               (arg1
                 (empty)
                 arg1
                 )
               ((-> *setting-control* user-current movie)
                (let ((s5-1 (ppointer->process (-> *setting-control* user-current movie 0 child))))
                  (while s5-1
                    (when (name= arg0 (-> s5-1 name))
                      (set! arg1 (the-as process s5-1))
                      (goto cfg-87)
                      )
                    (set! s5-1 (ppointer->process (-> s5-1 brother)))
                    )
                  )
                (let ((s5-2 (ppointer->process (-> *setting-control* user-current movie 0 child))))
                  (while s5-2
                    (let* ((s3-0 s5-2)
                           (s4-0 (if (type? s3-0 process-drawable)
                                     (the-as process-drawable s3-0)
                                     )
                                 )
                           )
                      (format (clear *temp-string*) "~S-lod0" arg0)
                      (let ((s3-2 *temp-string*))
                        (when (and s4-0
                                   (nonzero? (-> s4-0 draw))
                                   (or (and (nonzero? (-> s4-0 draw art-group)) (string= (the-as string arg0) (-> s4-0 draw art-group name)))
                                       (and (nonzero? (-> s4-0 draw jgeo)) (string= s3-2 (-> s4-0 draw jgeo name)))
                                       )
                                   )
                          (format 0 "WARNING: command-get-process returning art-group or jgeo named ~A~%" arg0)
                          (set! arg1 s4-0)
                          (goto cfg-87)
                          )
                        )
                      )
                    (set! s5-2 (ppointer->process (-> s5-2 brother)))
                    )
                  )
                (the-as process #f)
                )
               (else
                 (let ((v1-64 (process-by-name (the-as string arg0) *active-pool*)))
                   (if v1-64
                       v1-64
                       )
                   )
                 )
               )
             )
            (else
              (empty)
              arg1
              )
            )
          )
    (label cfg-87)
    (the-as process arg1)
    )
  )

;; WARN: Return type mismatch object vs entity.
(defun command-get-entity ((search object) (fallback entity))
  "- If `search` is a [[process]] - return it's `entity`
- If `search` is an [[entity]] - return it
- If `search` is a [[string]] - return the result of [[entity-by-name]]
- If `search` is [[null?]] or [[empty]] or if no other condition passes, return `fallback`"
  (the-as entity (cond
                   ((null? search)
                    (empty)
                    fallback
                    )
                   ((type? search process)
                    (-> (the-as process search) entity)
                    )
                   ((type? search entity)
                    (the-as entity search)
                    )
                   ((type? search string)
                    (entity-by-name (the-as string search))
                    )
                   (else
                     (empty)
                     fallback
                     )
                   )
          )
  )

;; WARN: Using new Jak 2 rtype-of
(defun command-get-trans ((arg0 object) (arg1 vector))
  (cond
    ((or (not arg0) (null? arg0))
     (empty)
     arg1
     )
    ((= arg0 'null)
     *null-vector*
     )
    ((= arg0 'target)
     (target-pos 0)
     )
    ((= (rtype-of arg0) string)
     (let ((v1-5 (the-as process-drawable (command-get-process arg0 *target*))))
       (cond
         ((and v1-5 (nonzero? (-> v1-5 root)))
          (-> v1-5 root trans)
          )
         (else
           (empty)
           arg1
           )
         )
       )
     )
    ((pair? arg0)
     (let* ((s3-0 (command-get-process (car arg0) *target*))
            (s4-0 (if (type? s3-0 process-drawable)
                      (the-as process-drawable s3-0)
                      )
                  )
            (a1-7 (car (cdr arg0)))
            )
       (cond
         ((and s4-0 (nonzero? (-> s4-0 draw)) (nonzero? (-> s4-0 node-list)))
          (let ((a0-12 (the-as joint (get-art-by-name-method (-> s4-0 draw jgeo) (the-as string a1-7) (the-as type #f)))))
            (cond
              (a0-12
                (-> s4-0 node-list data (+ (-> a0-12 number) 1) bone transform trans)
                )
              (else
                (empty)
                arg1
                )
              )
            )
          )
         (else
           (empty)
           arg1
           )
         )
       )
     )
    (else
      (empty)
      arg1
      )
    )
  )

;; WARN: Using new Jak 2 rtype-of
(defmethod script-context-method-10 script-context ((obj script-context) (arg0 object) (arg1 pair))
  (let* ((s5-0 (rtype-of arg0))
         (s4-0 arg1)
         (s3-0 (car s4-0))
         )
    (while (not (null? s4-0))
      (cond
        ((not s3-0)
         (if (not arg0)
             (return 'symbol)
             )
         )
        (else
          (let ((a1-1 (-> (the-as symbol s3-0) value)))
            (if (type-type? s5-0 (the-as type a1-1))
                (return s3-0)
                )
            )
          )
        )
      (set! s4-0 (cdr s4-0))
      (set! s3-0 (car s4-0))
      )
    )
  #f
  )

;; WARN: Return type mismatch object vs pair.
(defun key-assoc ((arg0 object) (arg1 pair) (arg2 vector4w))
  "TODO [[vector4w]] is probably wrong!"
  (set! (-> arg2 dword 0) (the-as uint 0))
  (let ((v1-0 arg1))
    (while (not (or (null? v1-0) (= (car (car v1-0)) arg0)))
      (+! (-> arg2 dword 0) 1)
      (set! v1-0 (cdr v1-0))
      )
    (the-as pair (if (not (null? v1-0))
                     (car v1-0)
                     )
            )
    )
  )

;; WARN: Using new Jak 2 rtype-of
;; WARN: Using new Jak 2 rtype-of
;; WARN: Using new Jak 2 rtype-of
;; WARN: Using new Jak 2 rtype-of
(defmethod script-context-method-11 script-context ((obj script-context) (arg0 pair) (arg1 pair) (arg2 symbol))
  (local-vars (sv-16 symbol) (sv-20 pair) (sv-24 pair) (sv-28 int) (sv-32 int) (sv-40 pair))
  (let ((s3-0 (cdr arg1)))
    (set! sv-16 (the-as symbol #f))
    (set! sv-20 arg0)
    (set! sv-24 s3-0)
    (set! (-> obj param-count) 0)
    (set! (-> obj expr) arg0)
    (let ((a1-1 (car sv-20))
          (s2-0 (car s3-0))
          )
      (while (not (and (null? sv-20) (null? sv-24)))
        (cond
          ((= s2-0 '&rest)
           (let ((v1-2 (-> obj param-count)))
             (set! (-> obj param v1-2) sv-20)
             (set! (-> obj param-type v1-2) 'pair)
             (set! (-> obj param-count) (+ v1-2 1))
             )
           (return (not sv-16))
           )
          ((= s2-0 '&key)
           (set! sv-28 (-> obj param-count))
           (set! sv-32 0)
           (set! sv-24 (cdr sv-24))
           (let ((v1-11 sv-28))
             (let* ((a0-3 sv-24)
                    (a1-6 (car a0-3))
                    )
               (while (not (null? a0-3))
                 (set! (-> obj param v1-11) (car (cdr (cdr (cdr a1-6)))))
                 (let ((a1-13 (-> obj param v1-11)))
                   (set! (-> obj param-type v1-11) (-> (rtype-of a1-13) symbol))
                   )
                 (+! v1-11 1)
                 (set! a0-3 (cdr a0-3))
                 (set! a1-6 (car a0-3))
                 )
               )
             (set! (-> obj param-count) v1-11)
             )
           (while (not (null? sv-20))
             (set! sv-40 (key-assoc (car sv-20) sv-24 (the-as vector4w (& sv-32))))
             (cond
               (sv-40
                 (set! sv-20 (cdr sv-20))
                 (let* ((v1-18 (car (cdr sv-40)))
                        (s3-1 (if (= v1-18 'eval)
                                  (eval! obj (the-as pair (car sv-20)))
                                  (car sv-20)
                                  )
                              )
                        (s2-1 (+ sv-28 sv-32))
                        )
                   (set! (-> obj param s2-1) s3-1)
                   (let ((v1-29 (script-context-method-10 obj s3-1 (the-as pair (car (cdr (cdr sv-40)))))))
                     (set! (-> obj param-type s2-1) v1-29)
                     (when (not v1-29)
                       (set! sv-16 #t)
                       (if arg2
                           (format
                             0
                             "ERROR: SCRIPT: param ~A = ~A is type ~A, needed type ~A.~%"
                             (car sv-40)
                             s3-1
                             (rtype-of s3-1)
                             (car (cdr (cdr sv-40)))
                             )
                           )
                       )
                     )
                   )
                 )
               (else
                 (set! sv-16 #t)
                 (if arg2
                     (format 0 "ERROR: SCRIPT: found unknown keyword ~A in expression ~A.~%" (car sv-20) arg0)
                     )
                 (set! sv-20 (cdr sv-20))
                 )
               )
             (set! sv-20 (cdr sv-20))
             )
           (return (not sv-16))
           )
          ((null? s2-0)
           (if arg2
               (format 0 "ERROR: SCRIPT: got too many params matching ~A to ~A~%" arg0 s3-0)
               )
           (return #f)
           )
          ((null? a1-1)
           (cond
             ((null? (car (cdr (cdr (cdr s2-0)))))
              (if arg2
                  (format 0 "ERROR: SCRIPT: got too few params matching ~A to ~A~%" arg0 s3-0)
                  )
              (return #f)
              )
             (else
               (let ((v1-62 (-> obj param-count)))
                 (set! (-> obj param v1-62) (car (cdr (cdr (cdr s2-0)))))
                 (let ((a0-28 (-> obj param v1-62)))
                   (set! (-> obj param-type v1-62) (-> (rtype-of a0-28) symbol))
                   )
                 (set! (-> obj param-count) (+ v1-62 1))
                 )
               (set! sv-24 (cdr sv-24))
               )
             )
           )
          (else
            (let* ((v1-67 (car (cdr s2-0)))
                   (s0-0 (if (= v1-67 'eval)
                             (eval! obj (the-as pair a1-1))
                             a1-1
                             )
                         )
                   (s1-0 (-> obj param-count))
                   )
              (set! (-> obj param s1-0) s0-0)
              (let ((v1-74 (script-context-method-10 obj s0-0 (the-as pair (car (cdr (cdr s2-0)))))))
                (set! (-> obj param-type s1-0) v1-74)
                (when (not v1-74)
                  (set! sv-16 #t)
                  (if arg2
                      (format
                        0
                        "ERROR: SCRIPT: param ~A = ~A is type ~A, needed type ~A.~%"
                        (car s2-0)
                        s0-0
                        (rtype-of s0-0)
                        (car (cdr (cdr s2-0)))
                        )
                      )
                  )
                )
              (set! (-> obj param-count) (+ s1-0 1))
              )
            (set! sv-20 (cdr sv-20))
            (set! sv-24 (cdr sv-24))
            )
          )
        (set! a1-1 (car sv-20))
        (set! s2-0 (car sv-24))
        )
      )
    )
  (not sv-16)
  )

;; WARN: Using new Jak 2 rtype-of
(defmethod eval! script-context ((obj script-context) (arg0 pair))
  (let ((s4-0 (the-as object #f)))
    (set! (-> obj expr) arg0)
    (case (rtype-of arg0)
      ((pair)
       (let ((a2-0 (car arg0)))
         (cond
           ((null? arg0)
            (set! s4-0 '())
            )
           (else
             (let ((s3-0 (-> *script-form* 0)))
               (while (nonzero? (-> s3-0 name))
                 (when (= a2-0 (-> s3-0 name))
                   (let ((s2-0 (new 'stack-no-clear 'script-context)))
                     (set! (-> s2-0 load-state) (-> obj load-state))
                     (set! (-> s2-0 key) (-> obj key))
                     (set! (-> s2-0 process) (-> obj process))
                     (set! (-> s2-0 trans) (-> obj trans))
                     (set! (-> s2-0 side-effect?) (-> obj side-effect?))
                     (set! (-> s2-0 got-error?) #f)
                     (cond
                       ((script-context-method-11 s2-0 arg0 (-> s3-0 spec) #t)
                        (set! (-> s2-0 expr) arg0)
                        (set! s4-0 ((-> s3-0 func) s2-0))
                        )
                       (else
                         (set! (-> s2-0 got-error?) #t)
                         )
                       )
                     (set! (-> obj got-error?) (or (-> obj got-error?) (-> s2-0 got-error?)))
                     )
                   (goto cfg-23)
                   )
                 (&+! s3-0 12)
                 )
               )
             (format 0 "ERROR: SCRIPT: taking the value of unknown symbol ~A in ~A for application.~%" a2-0 arg0)
             (set! (-> obj got-error?) #t)
             )
           )
         )
       (label cfg-23)
       s4-0
       )
      ((symbol)
       (let ((s4-1 (the-as symbol arg0)))
         (cond
           ((string-prefix= "GAME_TASK_" (symbol->string s4-1))
            (let ((gp-1 (c-string->game-task (symbol->string s4-1))))
              (if (= gp-1 (game-task unknown))
                  (format 0 "ERROR: SCRIPT: taking the value of unknown game-task ~A.~%" arg0)
                  )
              (set! s4-0 (* gp-1 8))
              )
            )
           ((= s4-1 'MINIMAP_FLAG_MINIMAP)
            (set! s4-0 1024)
            )
           ((= s4-1 'FACT_SUPER_SKILL_INC)
            (set! s4-0 (* (the int (-> *FACT-bank* super-skill-inc)) 8))
            )
           ((= s4-1 'self)
            (set! s4-0 (-> obj process))
            )
           ((= s4-1 'key)
            (set! s4-0 (-> obj key))
            )
           ((= s4-1 '*time-of-day*)
            (set! s4-0 (ppointer->process *time-of-day*))
            )
           ((= s4-1 '*task-manager*)
            (set! s4-0 (command-get-process s4-1 *target*))
            )
           (else
             (set! s4-0 (-> s4-1 value))
             )
           )
         )
       s4-0
       )
      (else
        arg0
        )
      )
    )
  )

(define *script-form* (the-as (inline-array script-form) (malloc 'global 1536)))

(let ((v1-10 (-> *script-form* 0)))
  (set! (-> v1-10 name) 'quote)
  (set! (-> v1-10 spec) '((return macro (object)) (function macro (symbol)) (value macro (object))))
  (set! (-> v1-10 func) (lambda ((arg0 script-context)) (-> arg0 param 1)))
  )

(let ((v1-12 (-> *script-form* 1)))
  (set! (-> v1-12 name) 'meters)
  (set! (-> v1-12 spec) '((return macro (float)) (function macro (symbol)) (value eval (bfloat binteger))))
  (set! (-> v1-12 func)
        (lambda ((arg0 script-context)) (the-as meters (* 4096.0 (command-get-float (-> arg0 param 1) 0.0))))
        )
  )

(let ((v1-14 (-> *script-form* 2)))
  (set! (-> v1-14 name) 'seconds)
  (set! (-> v1-14 spec) '((return macro (integer)) (function macro (symbol)) (value eval (bfloat binteger))))
  (set! (-> v1-14 func)
        (lambda ((arg0 script-context)) (the time-frame (* 300.0 (command-get-float (-> arg0 param 1) 0.0))))
        )
  )

(let ((v1-16 (-> *script-form* 3)))
  (set! (-> v1-16 name) 'float)
  (set! (-> v1-16 spec) '((return macro (float)) (function macro (symbol)) (value eval (bfloat binteger))))
  (set! (-> v1-16 func) (lambda ((arg0 script-context)) (command-get-float (-> arg0 param 1) 0.0)))
  )

(let ((v1-18 (-> *script-form* 4)))
  (set! (-> v1-18 name) 'int)
  (set! (-> v1-18 spec) '((return macro (integer)) (function macro (symbol)) (value eval (bfloat binteger))))
  (set! (-> v1-18 func) (lambda ((arg0 script-context)) (command-get-int (-> arg0 param 1) 0)))
  )

(let ((v1-20 (-> *script-form* 5)))
  (set! (-> v1-20 name) 'begin)
  (set! (-> v1-20 spec) '((return macro (object)) (function macro (symbol)) &rest body))
  (set! (-> v1-20 func) (lambda ((arg0 script-context)) (let ((v0-0 (the-as object #f)))
                                                          (let* ((s5-0 (-> arg0 param 1))
                                                                 (a1-0 (car (the-as pair s5-0)))
                                                                 )
                                                            (while (not (null? s5-0))
                                                              (set! v0-0 (eval! arg0 (the-as pair a1-0)))
                                                              (set! s5-0 (cdr s5-0))
                                                              (set! a1-0 (car (the-as pair s5-0)))
                                                              )
                                                            )
                                                          (the-as pair v0-0)
                                                          )
                                )
        )
  )

(let ((v1-22 (-> *script-form* 6)))
  (set! (-> v1-22 name) 'print)
  (set! (-> v1-22 spec) '((return macro (object)) (function macro (symbol)) (value eval (object))))
  (set! (-> v1-22 func) (lambda ((arg0 script-context)) (if (-> arg0 side-effect?)
                                                            (printl (-> arg0 param 1))
                                                            (-> arg0 param 1)
                                                            )
                                )
        )
  )

(let ((v1-24 (-> *script-form* 7)))
  (set! (-> v1-24 name) 'if)
  (set! (-> v1-24 spec) '((return macro (object))
                          (function macro (symbol))
                          (condition eval (object))
                          (if macro
                              (object)
                              )
                          (else
                            macro
                            (object)
                            #f
                            )
                          )
        )
  (set! (-> v1-24 func)
        (lambda ((arg0 script-context)) (the-as pair (if (-> arg0 param 1)
                                                         (eval! arg0 (the-as pair (-> arg0 param 2)))
                                                         (eval! arg0 (the-as pair (-> arg0 param 3)))
                                                         )
                                                )
                )
        )
  )

(let ((v1-26 (-> *script-form* 8)))
  (set! (-> v1-26 name) 'not)
  (set! (-> v1-26 spec) '((return macro (object)) (function macro (symbol)) (condition eval (object))))
  (set! (-> v1-26 func) (lambda ((arg0 script-context)) (not (-> arg0 param 1))))
  )

(let ((v1-28 (-> *script-form* 9)))
  (set! (-> v1-28 name) 'and)
  (set! (-> v1-28 spec) '((return macro (object)) (function macro (symbol)) &rest body))
  (set! (-> v1-28 func) (lambda ((arg0 script-context)) (let ((s5-0 (-> arg0 param 1))
                                                              (v0-0 (the-as object #f))
                                                              )
                                                          (let ((a1-0 (car (the-as pair s5-0))))
                                                            (while (not (null? s5-0))
                                                              (set! v0-0 (eval! arg0 (the-as pair a1-0)))
                                                              (if (not v0-0)
                                                                  (return (the-as pair #f))
                                                                  )
                                                              (set! s5-0 (cdr s5-0))
                                                              (set! a1-0 (car (the-as pair s5-0)))
                                                              )
                                                            )
                                                          (the-as pair v0-0)
                                                          )
                                )
        )
  )

(let ((v1-30 (-> *script-form* 10)))
  (set! (-> v1-30 name) 'or)
  (set! (-> v1-30 spec) '((return macro (object)) (function macro (symbol)) &rest body))
  (set! (-> v1-30 func) (lambda ((arg0 script-context))
                          (let ((s5-0 (-> arg0 param 1)))
                            (let ((a1-0 (car (the-as pair s5-0))))
                              (while (not (null? s5-0))
                                (let ((v1-2 (eval! arg0 (the-as pair a1-0))))
                                  (if v1-2
                                      (return (the-as pair v1-2))
                                      )
                                  )
                                (set! s5-0 (cdr s5-0))
                                (set! a1-0 (car (the-as pair s5-0)))
                                )
                              )
                            )
                          (the-as pair #f)
                          )
        )
  )

(let ((v1-32 (-> *script-form* 11)))
  (set! (-> v1-32 name) 'when)
  (set! (-> v1-32 spec)
        '((return macro (object)) (function macro (symbol)) (condition eval (object)) &rest body)
        )
  (set! (-> v1-32 func) (lambda ((arg0 script-context)) (let ((v0-0 (the-as object #f)))
                                                          (when (-> arg0 param 1)
                                                            (let* ((s5-0 (-> arg0 param 2))
                                                                   (a1-0 (car (the-as pair s5-0)))
                                                                   )
                                                              (while (not (null? s5-0))
                                                                (set! v0-0 (eval! arg0 (the-as pair a1-0)))
                                                                (set! s5-0 (cdr s5-0))
                                                                (set! a1-0 (car (the-as pair s5-0)))
                                                                )
                                                              )
                                                            )
                                                          (the-as pair v0-0)
                                                          )
                                )
        )
  )

(let ((v1-34 (-> *script-form* 12)))
  (set! (-> v1-34 name) 'unless)
  (set! (-> v1-34 spec)
        '((return macro (object)) (function macro (symbol)) (condition eval (object)) &rest body)
        )
  (set! (-> v1-34 func) (lambda ((arg0 script-context)) (let ((v0-0 (the-as object #f)))
                                                          (when (not (-> arg0 param 1))
                                                            (let* ((s5-0 (-> arg0 param 2))
                                                                   (a1-0 (car (the-as pair s5-0)))
                                                                   )
                                                              (while (not (null? s5-0))
                                                                (set! v0-0 (eval! arg0 (the-as pair a1-0)))
                                                                (set! s5-0 (cdr s5-0))
                                                                (set! a1-0 (car (the-as pair s5-0)))
                                                                )
                                                              )
                                                            )
                                                          (the-as pair v0-0)
                                                          )
                                )
        )
  )

(let ((v1-36 (-> *script-form* 13)))
  (set! (-> v1-36 name) 'cond)
  (set! (-> v1-36 spec) '((return macro (object)) (function macro (symbol)) &rest body))
  (set! (-> v1-36 func)
        (lambda ((arg0 script-context)) (let ((gp-0 (the-as object #f)))
                                          (let* ((s4-0 (-> arg0 param 1))
                                                 (s3-0 (car (the-as pair s4-0)))
                                                 )
                                            (while (not (null? s4-0))
                                              (when (pair? s3-0)
                                                (when (or (= s3-0 'else) (eval! arg0 (the-as pair (car s3-0))))
                                                  (let* ((s4-1 (cdr s3-0))
                                                         (a1-1 (car s4-1))
                                                         )
                                                    (while (not (null? s4-1))
                                                      (set! gp-0 (eval! arg0 (the-as pair a1-1)))
                                                      (set! s4-1 (cdr s4-1))
                                                      (set! a1-1 (car s4-1))
                                                      )
                                                    )
                                                  (set! gp-0 gp-0)
                                                  (goto cfg-14)
                                                  )
                                                )
                                              (set! s4-0 (cdr s4-0))
                                              (set! s3-0 (car (the-as pair s4-0)))
                                              )
                                            )
                                          (label cfg-14)
                                          (the-as pair gp-0)
                                          )
                )
        )
  )

(let ((v1-38 (-> *script-form* 14)))
  (set! (-> v1-38 name) 'set!)
  (set! (-> v1-38 spec)
        '((return macro (object)) (function macro (symbol)) (symbol macro (symbol)) (value eval (object)))
        )
  (set! (-> v1-38 func)
        (lambda ((arg0 script-context)) (when (-> arg0 side-effect?)
                                          (let ((v0-0 (-> arg0 param 2)))
                                            (set! (-> (the-as symbol (-> arg0 param 1)) value) v0-0)
                                            v0-0
                                            )
                                          )
                )
        )
  )

(let ((v1-40 (-> *script-form* 15)))
  (set! (-> v1-40 name) 'eval)
  (set! (-> v1-40 spec) '((return macro (object)) (function macro (symbol)) (value eval (object))))
  (set! (-> v1-40 func)
        (lambda ((arg0 script-context)) (the-as pair (if (-> arg0 side-effect?)
                                                         (eval! arg0 (the-as pair (-> arg0 param 1)))
                                                         )
                                                )
                )
        )
  )

(let ((v1-42 (-> *script-form* 16)))
  (set! (-> v1-42 name) 'apply)
  (set! (-> v1-42 spec) '((return macro (object)) (function macro (symbol)) (value eval (function))))
  (set! (-> v1-42 func)
        (lambda ((arg0 script-context)) (if (-> arg0 side-effect?)
                                            ((the-as (function script-context symbol) (-> arg0 param 1)) arg0)
                                            )
                )
        )
  )

(let ((v1-44 (-> *script-form* 17)))
  (set! (-> v1-44 name) '=)
  (set! (-> v1-44 spec)
        '((return macro (object))
          (function macro (symbol))
          (test1 eval (bfloat binteger))
          (test2 eval (bfloat binteger))
          )
        )
  (set! (-> v1-44 func)
        (lambda ((arg0 script-context))
          (= (command-get-float (-> arg0 param 1) 0.0) (command-get-float (-> arg0 param 2) 0.0))
          )
        )
  )

(let ((v1-46 (-> *script-form* 18)))
  (set! (-> v1-46 name) '<=)
  (set! (-> v1-46 spec)
        '((return macro (object))
          (function macro (symbol))
          (test1 eval (bfloat binteger))
          (test2 eval (bfloat binteger))
          )
        )
  (set! (-> v1-46 func)
        (lambda ((arg0 script-context))
          (>= (command-get-float (-> arg0 param 2) 0.0) (command-get-float (-> arg0 param 1) 0.0))
          )
        )
  )

(let ((v1-48 (-> *script-form* 19)))
  (set! (-> v1-48 name) '<)
  (set! (-> v1-48 spec)
        '((return macro (object))
          (function macro (symbol))
          (test1 eval (bfloat binteger))
          (test2 eval (bfloat binteger))
          )
        )
  (set! (-> v1-48 func)
        (lambda ((arg0 script-context))
          (< (command-get-float (-> arg0 param 1) 0.0) (command-get-float (-> arg0 param 2) 0.0))
          )
        )
  )

(let ((v1-50 (-> *script-form* 20)))
  (set! (-> v1-50 name) 'eq?)
  (set! (-> v1-50 spec)
        '((return macro (object)) (function macro (symbol)) (test1 eval (object)) (test2 eval (object)))
        )
  (set! (-> v1-50 func)
        (lambda ((arg0 script-context)) (let ((gp-0 (-> arg0 param 1))
                                              (s5-0 (-> arg0 param 2))
                                              )
                                          (if (and (type? gp-0 string) (type? s5-0 string))
                                              (string= (the-as string gp-0) (the-as string s5-0))
                                              (= gp-0 s5-0)
                                              )
                                          )
                )
        )
  )

(let ((v1-52 (-> *script-form* 21)))
  (set! (-> v1-52 name) 'unbox)
  (set! (-> v1-52 spec) '((return macro (object)) (function macro (symbol)) (value eval (bfloat binteger))))
  (set! (-> v1-52 func) (lambda ((arg0 script-context)) (cond
                                                          ((not (logtest? (the-as int (-> arg0 param 1)) 7))
                                                           (/ (the-as int (-> arg0 param 1)) 8)
                                                           )
                                                          (else
                                                            (let ((v1-3 bfloat)
                                                                  (a1-0 (-> arg0 param 1))
                                                                  )
                                                              (if (= (rtype-of a1-0) v1-3)
                                                                  (-> (the-as bfloat (-> arg0 param 1)) data)
                                                                  (-> arg0 param 1)
                                                                  )
                                                              )
                                                            )
                                                          )
                                )
        )
  )

(defun level-from-heap ((arg0 int))
  (dotimes (v1-0 (-> *level* length))
    (let ((a1-3 (-> *level* level v1-0)))
      (when (= (-> a1-3 status) 'active)
        (let ((a3-1 (-> a1-3 heap base))
              (a2-3 (-> a1-3 heap top-base))
              )
          (if (and (>= arg0 (the-as int a3-1)) (< arg0 (the-as int a2-3)))
              (return a1-3)
              )
          )
        )
      )
    )
  (the-as level #f)
  )

(let ((v1-55 (-> *script-form* 22)))
  (set! (-> v1-55 name) 'want-vis)
  (set! (-> v1-55 spec) '((return macro (none)) (function macro (symbol)) (level eval (symbol))))
  (set! (-> v1-55 func) (the-as
                          (function script-context object)
                          (lambda ((arg0 script-context))
                            (if (and (-> arg0 side-effect?) (-> *level* border?))
                                (want-vis-level (-> arg0 load-state) (the-as symbol (-> arg0 param 1)))
                                )
                            (none)
                            )
                          )
        )
  )

(let ((v1-57 (-> *script-form* 23)))
  (set! (-> v1-57 name) 'want-load)
  (set! (-> v1-57 spec) '((return macro (none)) (function macro (symbol)) &rest levels))
  (set! (-> v1-57 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (let ((s5-0 6)
                  (a0-1 (-> arg0 param 1))
                  )
              (cond
                ((>= s5-0 ((method-of-type (rtype-of a0-1) length) a0-1))
                 (when (and (-> arg0 side-effect?)
                            (-> *level* border?)
                            (let ((s5-1 (-> *setting-control* user-current exclusive-load)))
                              (or (not s5-1) (let ((v1-9 (level-from-heap (the-as int (-> arg0 key)))))
                                               (and v1-9 (= (-> v1-9 name) s5-1))
                                               )
                                  )
                              )
                            )
                   (let ((s5-2 (new 'static 'boxed-array :type symbol :length 0 :allocated-length 6)))
                     (dotimes (s4-0 6)
                       (let ((a1-3 (ref (-> arg0 param 1) s4-0)))
                         (set! (-> s5-2 s4-0) (the-as symbol (if (not (null? a1-3))
                                                                 (eval! arg0 (the-as pair a1-3))
                                                                 )
                                                      )
                               )
                         )
                       )
                     (want-levels (-> arg0 load-state) (-> s5-2 data))
                     )
                   )
                 )
                (else
                  (format 0 "ERROR: SCRIPT: got too many params to want-load ~A~%" (-> arg0 param 1))
                  (set! (-> arg0 got-error?) #t)
                  )
                )
              )
            0
            (none)
            )
          )
        )
  )

(let ((v1-59 (-> *script-form* 24)))
  (set! (-> v1-59 name) 'want-sound)
  (set! (-> v1-59 spec) '((return macro (none)) (function macro (symbol)) &rest sounds))
  (set! (-> v1-59 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (let ((s5-0 3)
                  (a0-1 (-> arg0 param 1))
                  )
              (cond
                ((>= s5-0 ((method-of-type (rtype-of a0-1) length) a0-1))
                 (when (and (-> arg0 side-effect?)
                            (-> *level* border?)
                            (let ((s5-1 (-> *setting-control* user-current exclusive-load)))
                              (or (not s5-1) (let ((v1-9 (level-from-heap (the-as int (-> arg0 key)))))
                                               (and v1-9 (= (-> v1-9 name) s5-1))
                                               )
                                  )
                              )
                            )
                   (let ((s5-2 (new 'static 'boxed-array :type symbol :length 0 :allocated-length 3)))
                     (dotimes (s4-0 3)
                       (let ((a1-3 (ref (-> arg0 param 1) s4-0)))
                         (set! (-> s5-2 s4-0) (the-as symbol (if (not (null? a1-3))
                                                                 (eval! arg0 (the-as pair a1-3))
                                                                 )
                                                      )
                               )
                         )
                       )
                     (want-sound-banks (-> arg0 load-state) (-> s5-2 data))
                     )
                   )
                 )
                (else
                  (format 0 "ERROR: SCRIPT: got too many params to want-sound ~A~%" (-> arg0 param 1))
                  (set! (-> arg0 got-error?) #t)
                  )
                )
              )
            0
            (none)
            )
          )
        )
  )

(let ((v1-61 (-> *script-form* 25)))
  (set! (-> v1-61 name) 'want-display)
  (set! (-> v1-61 spec)
        '((return macro (none)) (function macro (symbol)) (level eval (symbol)) (mode eval (symbol) display))
        )
  (set! (-> v1-61 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (if (and (-> arg0 side-effect?)
                     (-> *level* border?)
                     (let ((s5-0 (-> *setting-control* user-current exclusive-load)))
                       (or (not s5-0) (let ((v1-5 (level-from-heap (the-as int (-> arg0 key)))))
                                        (and v1-5 (= (-> v1-5 name) s5-0))
                                        )
                           )
                       )
                     )
                (want-display-level (-> arg0 load-state) (the-as symbol (-> arg0 param 1)) (the-as symbol (-> arg0 param 2)))
                )
            0
            (none)
            )
          )
        )
  )

(let ((v1-63 (-> *script-form* 26)))
  (set! (-> v1-63 name) 'want-force-vis)
  (set! (-> v1-63 spec)
        '((return macro (none)) (function macro (symbol)) (level eval (symbol)) (mode eval (symbol) #t))
        )
  (set! (-> v1-63 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (if (and (-> arg0 side-effect?) (-> *level* border?))
                (want-force-vis (-> arg0 load-state) (the-as symbol (-> arg0 param 1)) (the-as symbol (-> arg0 param 2)))
                )
            0
            (none)
            )
          )
        )
  )

(let ((v1-65 (-> *script-form* 27)))
  (set! (-> v1-65 name) 'want-force-inside)
  (set! (-> v1-65 spec)
        '((return macro (none)) (function macro (symbol)) (level eval (symbol)) (mode eval (symbol) #t))
        )
  (set! (-> v1-65 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (if (and (-> arg0 side-effect?) (-> *level* border?))
                (want-force-inside (-> arg0 load-state) (the-as symbol (-> arg0 param 1)) (the-as symbol (-> arg0 param 2)))
                )
            0
            (none)
            )
          )
        )
  )

(let ((v1-67 (-> *script-form* 28)))
  (set! (-> v1-67 name) 'want-continue)
  (set! (-> v1-67 spec) '((return macro (none)) (function macro (symbol)) (continue-point eval (string))))
  (set! (-> v1-67 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (when (and (-> arg0 side-effect?) (-> *setting-control* user-current allow-continue))
              (set-continue! *game-info* (the-as basic (-> arg0 param 1)) #f)
              (send-event *target* 'want-continue (-> arg0 param 1))
              )
            0
            (none)
            )
          )
        )
  )

(let ((v1-69 (-> *script-form* 29)))
  (set! (-> v1-69 name) 'want-anim)
  (set! (-> v1-69 spec) '((return macro (none)) (function macro (symbol)) (name eval (string))))
  (set! (-> v1-69 func) (the-as (function script-context object) (lambda ((arg0 script-context))
                                                                   "we want to preload this anim."
                                                                   (if (-> arg0 side-effect?)
                                                                       (gui-control-method-12
                                                                         *gui-control*
                                                                         (-> arg0 process)
                                                                         (gui-channel art-load)
                                                                         (gui-action queue)
                                                                         (the-as string (-> arg0 param 1))
                                                                         0
                                                                         -1.0
                                                                         (new 'static 'sound-id)
                                                                         )
                                                                       )
                                                                   0
                                                                   (none)
                                                                   )
                                )
        )
  )

(let ((v1-71 (-> *script-form* 30)))
  (set! (-> v1-71 name) 'send-event)
  (set! (-> v1-71 spec)
        '((return macro (object))
          (function macro (symbol))
          (target eval (string process entity-actor actor-group #f binteger))
          (message eval (symbol))
          &rest
          params
          )
        )
  (set! (-> v1-71 func)
        (lambda ((arg0 script-context))
          (local-vars (sv-96 (function script-context pair object)))
          (the-as
            symbol
            (when (-> arg0 side-effect?)
              (let ((gp-0 (command-get-process (-> arg0 param 1) (the-as process #f)))
                    (s5-0 (new 'stack-no-clear 'event-message-block))
                    (s2-0 (-> arg0 param 3))
                    (s4-0 (the-as object #f))
                    )
                (when gp-0
                  (set! (-> s5-0 from) (process->ppointer (-> arg0 process)))
                  (set! (-> s5-0 message) (the-as symbol (-> arg0 param 2)))
                  (let ((a0-3 s2-0))
                    (set! (-> s5-0 num-params) ((method-of-type (rtype-of a0-3) length) a0-3))
                    )
                  (dotimes (s1-0 (-> s5-0 num-params))
                    (let ((s0-0 arg0))
                      (set! sv-96 (method-of-type script-context eval!))
                      (let ((a1-4 (ref s2-0 s1-0)))
                        (set! (-> s5-0 param s1-0) (the-as uint (sv-96 s0-0 (the-as pair a1-4))))
                        )
                      )
                    )
                  (cond
                    ((= (-> gp-0 type) actor-group)
                     (dotimes (s3-1 (the-as int (-> gp-0 name)))
                       (let ((t9-4 send-event-function)
                             (v1-18 (the-as object (-> (the-as (pointer uint32) (+ (+ (* s3-1 8) 12) (the-as int gp-0))))))
                             )
                         (set! s4-0 (t9-4
                                      (if (the-as uint v1-18)
                                          (-> (the-as entity-actor v1-18) extra process)
                                          )
                                      s5-0
                                      )
                               )
                         )
                       )
                     )
                    (else
                      (set! s4-0 (send-event-function gp-0 s5-0))
                      )
                    )
                  )
                s4-0
                )
              )
            )
          )
        )
  )

(let ((v1-73 (-> *script-form* 31)))
  (set! (-> v1-73 name) 'send-event-attack)
  (set! (-> v1-73 spec)
        '((return macro (object))
          (function macro (symbol))
          (target eval (string process entity-actor actor-group #f binteger))
          (none macro (object))
          &key
          (mode eval (symbol) generic)
          (message eval (symbol) attack)
          )
        )
  (set! (-> v1-73 func)
        (lambda ((arg0 script-context))
          (with-pp
            (the-as
              symbol
              (when (-> arg0 side-effect?)
                (let ((s5-0 (command-get-process (-> arg0 param 1) (the-as process #f)))
                      (v0-0 (the-as object #f))
                      )
                  (when s5-0
                    (cond
                      ((= (-> s5-0 type) actor-group)
                       (dotimes (s4-0 (the-as int (-> s5-0 name)))
                         (let ((a1-1 (new 'stack-no-clear 'event-message-block)))
                           (set! (-> a1-1 from) (process->ppointer pp))
                           (set! (-> a1-1 num-params) 2)
                           (set! (-> a1-1 message) (the-as symbol (-> arg0 param 4)))
                           (set! (-> a1-1 param 0) (the-as uint #f))
                           (let ((v1-6 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                             (let* ((a0-4 *game-info*)
                                    (a2-1 (+ (-> a0-4 attack-id) 1))
                                    )
                               (set! (-> a0-4 attack-id) a2-1)
                               (set! (-> v1-6 id) a2-1)
                               )
                             (set! (-> v1-6 mode) (the-as symbol (-> arg0 param 3)))
                             (set! (-> a1-1 param 1) (the-as uint v1-6))
                             )
                           (let ((t9-1 send-event-function)
                                 (v1-10 (the-as object (-> (the-as (pointer uint32) (+ (+ (* s4-0 8) 12) (the-as int s5-0))))))
                                 )
                             (set! v0-0 (t9-1
                                          (if (the-as uint v1-10)
                                              (-> (the-as entity-actor v1-10) extra process)
                                              )
                                          a1-1
                                          )
                                   )
                             )
                           )
                         )
                       )
                      (else
                        (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
                          (set! (-> a1-2 from) (process->ppointer pp))
                          (set! (-> a1-2 num-params) 2)
                          (set! (-> a1-2 message) (the-as symbol (-> arg0 param 4)))
                          (set! (-> a1-2 param 0) (the-as uint #f))
                          (let ((v1-18 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                            (let* ((a0-8 *game-info*)
                                   (a2-3 (+ (-> a0-8 attack-id) 1))
                                   )
                              (set! (-> a0-8 attack-id) a2-3)
                              (set! (-> v1-18 id) a2-3)
                              )
                            (set! (-> v1-18 mode) (the-as symbol (-> arg0 param 3)))
                            (set! (-> a1-2 param 1) (the-as uint v1-18))
                            )
                          (set! v0-0 (send-event-function s5-0 a1-2))
                          )
                        )
                      )
                    )
                  v0-0
                  )
                )
              )
            )
          )
        )
  )

(let ((v1-75 (-> *script-form* 32)))
  (set! (-> v1-75 name) 'focus-test?)
  (set! (-> v1-75 spec)
        '((return macro (symbol))
          (function macro (symbol))
          (target eval (string process entity-actor actor-group #f binteger))
          &rest
          params
          )
        )
  (set! (-> v1-75 func)
        (lambda ((arg0 script-context))
          (let* ((s4-0 (command-get-process (-> arg0 param 1) (the-as process #f)))
                 (gp-0 (if (type? s4-0 process-focusable)
                           (the-as process-focusable s4-0)
                           )
                       )
                 )
            (when gp-0
              (let* ((s5-1 (-> arg0 param 2))
                     (v1-0 (car (the-as pair s5-1)))
                     )
                (while (not (null? s5-1))
                  (cond
                    ((logtest? (the-as int v1-0) 1)
                     (cond
                       ((= v1-0 'board)
                        (if (logtest? (focus-status board) (-> gp-0 focus-status))
                            (return #t)
                            )
                        )
                       ((= v1-0 'gun)
                        (if (logtest? (focus-status gun) (-> gp-0 focus-status))
                            (return #t)
                            )
                        )
                       ((= v1-0 'mech)
                        (if (logtest? (focus-status mech) (-> gp-0 focus-status))
                            (return #t)
                            )
                        )
                       ((= v1-0 'pilot)
                        (if (logtest? (focus-status pilot) (-> gp-0 focus-status))
                            (return #t)
                            )
                        )
                       ((= v1-0 'grabbed)
                        (if (logtest? (-> gp-0 focus-status) (focus-status grabbed))
                            (return #t)
                            )
                        )
                       ((= v1-0 'indax)
                        (if (logtest? (focus-status indax) (-> gp-0 focus-status))
                            (return #t)
                            )
                        )
                       ((= v1-0 'dark)
                        (if (logtest? (focus-status dark) (-> gp-0 focus-status))
                            (return #t)
                            )
                        )
                       )
                     )
                    (else
                      (format 0 "ERROR: SCRIPT: param bit = ~A is type ~A, needed type ~A.~%" v1-0 (rtype-of v1-0) 'symbol)
                      )
                    )
                  (set! s5-1 (cdr s5-1))
                  (set! v1-0 (car (the-as pair s5-1)))
                  )
                )
              #f
              )
            )
          )
        )
  )

(let ((v1-77 (-> *script-form* 33)))
  (set! (-> v1-77 name) 'game-feature!)
  (set! (-> v1-77 spec)
        '((return macro (none)) (function macro (symbol)) (feature macro (symbol)) (value eval (symbol)))
        )
  (set! (-> v1-77 func) (the-as
                          (function script-context object)
                          (lambda ((arg0 script-context))
                            (case (-> arg0 param 1)
                              (('board)
                               (if (-> arg0 param 2)
                                   (logior! (-> *game-info* features) (game-feature board))
                                   (logclear! (-> *game-info* features) (game-feature board))
                                   )
                               )
                              (else
                                (format 0 "ERROR: SCRIPT: unknown feature type ~A~%" (-> arg0 param 1))
                                )
                              )
                            0
                            (none)
                            )
                          )
        )
  )

(let ((v1-79 (-> *script-form* 34)))
  (set! (-> v1-79 name) 'game-feature?)
  (set! (-> v1-79 spec) '((return macro (boolean)) (function macro (symbol)) (feature macro (symbol))))
  (set! (-> v1-79 func)
        (lambda ((arg0 script-context)) (case (-> arg0 param 1)
                                          (('board)
                                           (logtest? (-> *game-info* features) (game-feature board))
                                           )
                                          (else
                                            (format 0 "ERROR: SCRIPT: unknown feature type ~A~%" (-> arg0 param 1))
                                            #f
                                            )
                                          )
                )
        )
  )

(let ((v1-81 (-> *script-form* 35)))
  (set! (-> v1-81 name) 'entity-status?)
  (set! (-> v1-81 spec)
        '((return macro (symbol))
          (function macro (symbol))
          (target eval (string process entity-actor actor-group #f binteger))
          &rest
          params
          )
        )
  (set! (-> v1-81 func)
        (lambda ((arg0 script-context))
          (let ((v1-0 (command-get-entity (-> arg0 param 1) (the-as entity #f))))
            (when v1-0
              (let* ((gp-1 (-> arg0 param 2))
                     (s5-0 (-> v1-0 extra perm status))
                     (v1-2 (car (the-as pair gp-1)))
                     )
                (while (not (null? gp-1))
                  (cond
                    ((logtest? (the-as int v1-2) 1)
                     (cond
                       ((or (= v1-2 'no-birth) (= v1-2 'dead))
                        (if (logtest? s5-0 (entity-perm-status dead))
                            (return #t)
                            )
                        )
                       ((= v1-2 'subtask-complete)
                        (if (logtest? s5-0 (entity-perm-status subtask-complete bit-12))
                            (return #t)
                            )
                        )
                       )
                     )
                    (else
                      (format 0 "ERROR: SCRIPT: param bit = ~A is type ~A, needed type ~A.~%" v1-2 (rtype-of v1-2) 'symbol)
                      )
                    )
                  (set! gp-1 (cdr gp-1))
                  (set! v1-2 (car (the-as pair gp-1)))
                  )
                )
              #f
              )
            )
          )
        )
  )

(let ((v1-83 (-> *script-form* 36)))
  (set! (-> v1-83 name) 'setting-set)
  (set! (-> v1-83 spec)
        '((return macro (none))
          (function macro (symbol))
          (setting macro (symbol))
          &key
          (mode eval (object))
          (value eval (bfloat))
          (mask eval (binteger))
          )
        )
  (set! (-> v1-83 func)
        (the-as (function script-context object) (lambda ((arg0 script-context))
                                                   "
   '(setting-set bg-a :mode 'abs :value 1.0)
  "
                                                   (if (-> arg0 side-effect?)
                                                       (add-setting
                                                         *setting-control*
                                                         (-> arg0 process)
                                                         (the-as symbol (-> arg0 param 1))
                                                         (-> arg0 param 2)
                                                         (command-get-float (-> arg0 param 3) 0.0)
                                                         (command-get-int (-> arg0 param 4) 0)
                                                         )
                                                       )
                                                   (none)
                                                   )
                )
        )
  )

(let ((v1-85 (-> *script-form* 37)))
  (set! (-> v1-85 name) 'setting-reset)
  (set! (-> v1-85 spec)
        '((return macro (none))
          (function macro (symbol))
          (setting macro (symbol))
          &key
          (mode eval (object))
          (value eval (bfloat))
          (mask eval (binteger))
          )
        )
  (set! (-> v1-85 func)
        (the-as (function script-context object) (lambda ((arg0 script-context))
                                                   (if (-> arg0 side-effect?)
                                                       (set-setting
                                                         *setting-control*
                                                         (-> arg0 process)
                                                         (the-as symbol (-> arg0 param 1))
                                                         (-> arg0 param 2)
                                                         (command-get-float (-> arg0 param 3) 0.0)
                                                         (command-get-int (-> arg0 param 4) 0)
                                                         )
                                                       )
                                                   (none)
                                                   )
                )
        )
  )

(let ((v1-87 (-> *script-form* 38)))
  (set! (-> v1-87 name) 'setting-pers)
  (set! (-> v1-87 spec)
        '((return macro (none))
          (function macro (symbol))
          (setting macro (symbol))
          &key
          (mode eval (object) #f)
          (value macro (bfloat pair) (new 'static 'bfloat))
          (mask eval (binteger) 0)
          (time macro (pair) 0)
          )
        )
  (set! (-> v1-87 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            "
  (setting-pers ambient-volume :mode 'rel :value 0.5)
  "
            (local-vars (sv-16 pair) (sv-24 object) (sv-32 float) (sv-48 float))
            (when (-> arg0 side-effect?)
              (set! sv-16 (-> arg0 expr))
              (set! sv-24 (eval! arg0 (the-as pair (-> arg0 param 5))))
              (set! sv-32 (the-as float (if (pair? (-> arg0 param 3))
                                            (eval! arg0 (the-as pair (-> arg0 param 3)))
                                            (command-get-float (-> arg0 param 3) 0.0)
                                            )
                                  )
                    )
              (let* ((s5-0 *setting-control*)
                     (s4-0 (method-of-object s5-0 persist-with-delay))
                     (s3-0 sv-16)
                     (s2-0 sv-24)
                     (s1-0 (-> arg0 param 1))
                     (s0-0 (-> arg0 param 2))
                     )
                (set! sv-48 sv-32)
                (let ((t2-0 (command-get-int (-> arg0 param 4) 0)))
                  (s4-0 s5-0 (the-as symbol s3-0) (the-as time-frame s2-0) (the-as symbol s1-0) (the-as symbol s0-0) sv-48 t2-0)
                  )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-89 (-> *script-form* 39)))
  (set! (-> v1-89 name) 'setting-unset)
  (set! (-> v1-89 spec) '((return macro (none)) (function macro (symbol)) (setting macro (symbol))))
  (set! (-> v1-89 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (if (-> arg0 side-effect?)
                (remove-setting *setting-control* (-> arg0 process) (the-as symbol (-> arg0 param 1)))
                )
            (none)
            )
          )
        )
  )

(let ((v1-91 (-> *script-form* 40)))
  (set! (-> v1-91 name) 'setting-value)
  (set! (-> v1-91 spec) '((return macro (object)) (function macro (symbol)) (setting macro (symbol))))
  (set! (-> v1-91 func) (lambda ((arg0 script-context))
                          "return the value of a setting."
                          (case (-> arg0 param 1)
                            (('entity-name)
                             (-> *setting-control* cam-current entity-name)
                             )
                            (('airlock)
                             (-> *setting-control* user-current airlock)
                             )
                            (('exclusive-task)
                             (* (-> *setting-control* user-current exclusive-task) 8)
                             )
                            )
                          )
        )
  )

(let ((v1-93 (-> *script-form* 41)))
  (set! (-> v1-93 name) 'setting-update)
  (set! (-> v1-93 spec) '((return macro (none)) (function macro (symbol))))
  (set! (-> v1-93 func) (the-as (function script-context object) (lambda ((arg0 script-context))
                                                                   "update settings"
                                                                   (if (-> arg0 side-effect?)
                                                                       (apply-settings *setting-control*)
                                                                       )
                                                                   0
                                                                   (none)
                                                                   )
                                )
        )
  )

(let ((v1-95 (-> *script-form* 42)))
  (set! (-> v1-95 name) 'sound-play)
  (set! (-> v1-95 spec) '((return macro (none))
                          (function macro (symbol))
                          (name eval (string))
                          &key
                          (volume eval (bfloat binteger) (new 'static 'bfloat :data 1.0))
                          (pitch-mod eval (bfloat binteger) (new 'static 'bfloat))
                          (bend eval (bfloat binteger) (new 'static 'bfloat))
                          (trans eval (vector) #f)
                          (ground-effect (symbol) #t)
                          )
        )
  (set! (-> v1-95 func) (lambda ((arg0 script-context))
                          (when (-> arg0 side-effect?)
                            (let ((s5-0 sound-play-by-name)
                                  (s4-0 (string->sound-name (the-as string (-> arg0 param 1))))
                                  (s3-0 (new-sound-id))
                                  (s2-0 (the int (* 1024.0 (command-get-float (-> arg0 param 2) 0.0))))
                                  (s1-0 (the int (* 1524.0 (command-get-float (-> arg0 param 3) 0.0))))
                                  (t0-0 (the int (* 327.66998 (command-get-float (-> arg0 param 4) 0.0))))
                                  (t1-0 1)
                                  (t2-0 (-> arg0 param 5))
                                  )
                              (set! t2-0 (cond
                                           (t2-0
                                             (empty)
                                             t2-0
                                             )
                                           (else
                                             (-> arg0 trans)
                                             )
                                           )
                                    )
                              (s5-0 s4-0 s3-0 s2-0 s1-0 t0-0 (the-as sound-group t1-0) t2-0)
                              )
                            )
                          )
        )
  )

(let ((v1-97 (-> *script-form* 43)))
  (set! (-> v1-97 name) 'sound-play-loop)
  (set! (-> v1-97 spec)
        '((return macro (none))
          (function macro (symbol))
          (name eval (string))
          &key
          (volume eval (bfloat binteger) (new 'static 'bfloat :data 1.0))
          (pitch-mod eval (bfloat binteger) (new 'static 'bfloat))
          (bend eval (bfloat binteger) (new 'static 'bfloat))
          (trans eval (vector) #f)
          )
        )
  (set! (-> v1-97 func)
        (lambda ((arg0 script-context))
          (when (-> arg0 side-effect?)
            (let ((s3-0 (schedule-callback *sound-loop-engine* (-> arg0 expr) 0)))
              (when s3-0
                (if (zero? (-> s3-0 param-int64 0))
                    (set! (-> s3-0 param-int64 0) (the-as int (new-sound-id)))
                    )
                (let ((s5-0 sound-play-by-name)
                      (s4-0 (string->sound-name (the-as string (-> arg0 param 1))))
                      (s3-1 (-> s3-0 param-int64 0))
                      (s2-0 (the int (* 1024.0 (command-get-float (-> arg0 param 2) 0.0))))
                      (a3-0 (the int (* 1524.0 (command-get-float (-> arg0 param 3) 0.0))))
                      (t0-0 0)
                      (t1-0 1)
                      (t2-0 (-> arg0 param 5))
                      )
                  (set! t2-0 (cond
                               (t2-0
                                 (empty)
                                 t2-0
                                 )
                               (else
                                 (-> arg0 trans)
                                 )
                               )
                        )
                  (s5-0 s4-0 (the-as sound-id s3-1) s2-0 a3-0 t0-0 (the-as sound-group t1-0) t2-0)
                  )
                )
              )
            )
          )
        )
  )

(let ((v1-99 (-> *script-form* 44)))
  (set! (-> v1-99 name) 'blackout)
  (set! (-> v1-99 spec) '((return macro (none)) (function macro (symbol)) (time macro (binteger bfloat pair))))
  (set! (-> v1-99 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (when (-> arg0 side-effect?)
              (let ((a2-0 (if (pair? (-> arg0 param 1))
                              (the-as int (command-get-time (-> arg0 param 1) 1))
                              (the int (* 5.0000005 (the float (command-get-int (-> arg0 param 1) 0))))
                              )
                          )
                    )
                (persist-with-delay *setting-control* 'blackout (the-as time-frame a2-0) 'bg-a-force 'abs 1.0 0)
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-101 (-> *script-form* 45)))
  (set! (-> v1-101 name) 'fadeout)
  (set! (-> v1-101 spec) '((return macro (none)) (function macro (symbol)) (time macro (binteger bfloat pair))))
  (set! (-> v1-101 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (when (-> arg0 side-effect?)
              (let ((gp-0 (command-get-time (-> arg0 param 1) 1)))
                (persist-with-delay
                  *setting-control*
                  'bg-a-speed
                  (+ gp-0 (seconds 1))
                  'bg-a-speed
                  'abs
                  (/ 300.0 (the float gp-0))
                  0
                  )
                (persist-with-delay *setting-control* 'bg-a (+ gp-0 (seconds 1)) 'bg-a 'abs 1.0 0)
                )
              )
            0
            (none)
            )
          )
        )
  )

(let ((v1-103 (-> *script-form* 46)))
  (set! (-> v1-103 name) 'fadein)
  (set! (-> v1-103 spec) '((return macro (none)) (function macro (symbol)) (time macro (binteger bfloat pair))))
  (set! (-> v1-103 func)
        (the-as (function script-context object) (lambda ((arg0 script-context))
                                                   (when (-> arg0 side-effect?)
                                                     (let ((gp-0 (command-get-time (-> arg0 param 1) 1)))
                                                       (set! (-> *setting-control* user-current bg-a) 1.0)
                                                       (apply-settings *setting-control*)
                                                       (persist-with-delay
                                                         *setting-control*
                                                         'bg-a-speed
                                                         (+ gp-0 (seconds 1))
                                                         'bg-a-speed
                                                         'abs
                                                         (/ 300.0 (the float gp-0))
                                                         0
                                                         )
                                                       )
                                                     )
                                                   0
                                                   (none)
                                                   )
                )
        )
  )

(let ((v1-105 (-> *script-form* 47)))
  (set! (-> v1-105 name) 'time-of-day)
  (set! (-> v1-105 spec) '((return macro (none)) (function macro (symbol)) (value eval (binteger bfloat))))
  (set! (-> v1-105 func) (lambda :behavior time-of-day-proc
                           ((arg0 script-context))
                           (when (-> arg0 side-effect?)
                             (let ((v1-1 (command-get-int (-> arg0 param 1) 0)))
                               (cond
                                 ((< v1-1 0)
                                  (send-event (ppointer->process *time-of-day*) 'change 'ratio #x3f800000)
                                  )
                                 (else
                                   (send-event (ppointer->process *time-of-day*) 'change 'hour v1-1)
                                   (send-event (ppointer->process *time-of-day*) 'change 'ratio 0)
                                   )
                                 )
                               )
                             )
                           )
        )
  )

(let ((v1-107 (-> *script-form* 48)))
  (set! (-> v1-107 name) 'time-of-day?)
  (set! (-> v1-107 spec) '((return macro (boolean)) (function macro (symbol)) (value macro (symbol))))
  (set! (-> v1-107 func)
        (lambda :behavior time-of-day-proc
          ((arg0 script-context))
          (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-0 from) (process->ppointer self))
            (set! (-> a1-0 num-params) 0)
            (set! (-> a1-0 message) 'hour)
            (let ((v1-4 (the-as int (send-event-function (ppointer->process *time-of-day*) a1-0)))
                  (a0-3 (-> arg0 param 1))
                  )
              (the-as symbol (cond
                               ((= a0-3 'night)
                                (or (>= v1-4 18) (< v1-4 6))
                                )
                               ((= a0-3 'day)
                                (and (>= v1-4 6) (< v1-4 18))
                                )
                               ((= a0-3 'dawn)
                                (and (>= v1-4 4) (< v1-4 7))
                                )
                               ((= a0-3 'dusk)
                                (and (>= v1-4 16) (< v1-4 19))
                                )
                               (else
                                 (format 0 "ERROR: SCRIPT: unknown time-of-day? test '~A'~%" (-> arg0 param 1))
                                 )
                               )
                      )
              )
            )
          )
        )
  )

(let ((v1-109 (-> *script-form* 49)))
  (set! (-> v1-109 name) 'region-prim)
  (set! (-> v1-109 spec)
        '((return macro (drawable-region-prim)) (function macro (symbol)) (id eval (binteger)))
        )
  (set! (-> v1-109 func)
        (lambda ((arg0 script-context))
          "lookup a region by number and return the region-prim."
          (region-prim-lookup-by-id (command-get-int (-> arg0 param 1) 0) #f (the-as symbol 0))
          )
        )
  )

(let ((v1-111 (-> *script-form* 50)))
  (set! (-> v1-111 name) 'region)
  (set! (-> v1-111 spec)
        '((return macro (drawable-region-prim)) (function macro (symbol)) (id eval (binteger)))
        )
  (set! (-> v1-111 func) (lambda ((arg0 script-context))
                           "lookup a region by number and return the region-prim."
                           (region-lookup-by-id (command-get-int (-> arg0 param 1) 0))
                           )
        )
  )

(let ((v1-113 (-> *script-form* 51)))
  (set! (-> v1-113 name) 'part-tracker)
  (set! (-> v1-113 spec)
        '((return macro (none))
          (function macro (symbol))
          (name eval (string symbol))
          &key
          (entity eval (string process entity-actor drawable-region-prim #f) #f)
          (joint eval (string) #f)
          (track eval (symbol) #f)
          (duration macro (object) 0)
          )
        )
  (set! (-> v1-113 func)
        (lambda ((arg0 script-context))
          " spawn a part tracker.  If the :entity is given, do it at that process's location.  Otherwise use the (-> context process), if not that then the (-> context trans).
  "
          (local-vars
            (a1-14 process-tree)
            (sv-80 sparticle-launch-group)
            (sv-84 process-drawable)
            (sv-88 entity)
            (sv-92 drawable-region-prim)
            (sv-96 matrix)
            (sv-104 int)
            (sv-112 object)
            (sv-120 time-frame)
            )
          (when (-> arg0 side-effect?)
            (if (not (-> arg0 param 2))
                (set! (-> arg0 param 2) (-> arg0 process))
                )
            (set! sv-80 (if (logtest? (the-as int (-> arg0 param 1)) 1)
                            (lookup-part-group-by-name (symbol->string (the-as symbol (-> arg0 param 1))))
                            (lookup-part-group-by-name (the-as string (-> arg0 param 1)))
                            )
                  )
            (let ((gp-0 (command-get-process (-> arg0 param 2) (the-as process #f))))
              (set! sv-84 (if (type? gp-0 process-drawable)
                              (the-as process-drawable gp-0)
                              )
                    )
              )
            (set! sv-88 (the-as entity #f))
            (set! sv-92 (the-as drawable-region-prim #f))
            (set! sv-96 (matrix-identity! (new 'stack-no-clear 'matrix)))
            (set! sv-104 0)
            (set! sv-112 (-> arg0 param 4))
            (set! sv-120 (command-get-time (-> arg0 param 5) 1))
            (let* ((s4-0 sv-80)
                   (gp-1 (if (type? s4-0 sparticle-launch-group)
                             s4-0
                             )
                         )
                   (v1-12 (-> arg0 param 2))
                   (s4-1 (and (= (rtype-of v1-12) string) (string= (the-as string (-> arg0 param 2)) "zero")))
                   )
              (cond
                (gp-1
                  (when (not sv-84)
                    (set! sv-112 #f)
                    (set! sv-88 (command-get-entity (-> arg0 param 2) (the-as entity #f)))
                    (when (not sv-88)
                      (let ((s3-0 (-> arg0 param 2)))
                        (set! sv-92 (if (type? s3-0 drawable-region-prim)
                                        (the-as drawable-region-prim s3-0)
                                        )
                              )
                        )
                      )
                    )
                  (if (and (not sv-84) (and (not sv-88) (-> arg0 param 2) (not s4-1)))
                      (format 0 "ERROR: SCRIPT: part-tracker: unknown entity ~A in:~%~T~A~%" (-> arg0 param 2) (-> arg0 expr))
                      )
                  (when (or sv-84 sv-88 sv-92 (-> arg0 trans) s4-1)
                    (cond
                      ((and sv-84 (nonzero? (-> sv-84 root)))
                       (let ((a1-9 (-> arg0 param 3)))
                         (cond
                           (a1-9
                             (let ((v1-37 (if (nonzero? (-> sv-84 draw))
                                              (the-as joint (get-art-by-name-method (-> sv-84 draw jgeo) (the-as string a1-9) (the-as type #f)))
                                              )
                                          )
                                   )
                               (cond
                                 (v1-37
                                   (set! sv-104 (+ (-> v1-37 number) 1))
                                   (let ((a1-10 (-> sv-84 node-list data sv-104)))
                                     (let* ((v1-46 sv-96)
                                            (t0-0 (-> a1-10 bone transform))
                                            (a0-23 (-> t0-0 quad 0))
                                            (a2-2 (-> t0-0 quad 1))
                                            (a3-1 (-> t0-0 quad 2))
                                            (t0-1 (-> t0-0 trans quad))
                                            )
                                       (set! (-> v1-46 quad 0) a0-23)
                                       (set! (-> v1-46 quad 1) a2-2)
                                       (set! (-> v1-46 quad 2) a3-1)
                                       (set! (-> v1-46 trans quad) t0-1)
                                       )
                                     (vector<-cspace! (-> sv-96 trans) a1-10)
                                     )
                                   )
                                 (else
                                   (format 0 "ERROR: SCRIPT: part-tracker: unknown joint ~A in:~%~T~A~%" (-> arg0 param 3) (-> arg0 expr))
                                   (set! (-> sv-96 trans quad) (-> sv-84 root trans quad))
                                   )
                                 )
                               )
                             )
                           (else
                             (set! (-> sv-96 trans quad) (-> sv-84 root trans quad))
                             )
                           )
                         )
                       )
                      (sv-88
                        (set! (-> sv-96 trans quad) (-> sv-88 extra trans quad))
                        )
                      (sv-92
                        (set! (-> sv-96 trans quad) (-> sv-92 bsphere quad))
                        )
                      (s4-1
                        (set! (-> sv-96 trans quad) (-> *null-vector* quad))
                        )
                      (else
                        (set! (-> sv-96 trans quad) (-> arg0 trans quad))
                        )
                      )
                    )
                  (when (logtest? (-> sv-80 flags) (sp-group-flag screen-space))
                    (let* ((a2-4 sv-96)
                           (a3-3 *identity-matrix*)
                           (v1-67 (-> a3-3 quad 0))
                           (a0-45 (-> a3-3 quad 1))
                           (a1-12 (-> a3-3 quad 2))
                           (a3-4 (-> a3-3 trans quad))
                           )
                      (set! (-> a2-4 quad 0) v1-67)
                      (set! (-> a2-4 quad 1) a0-45)
                      (set! (-> a2-4 quad 2) a1-12)
                      (set! (-> a2-4 trans quad) a3-4)
                      )
                    )
                  (let ((s5-1 (get-process *default-dead-pool* part-tracker #x4000)))
                    (when s5-1
                      (let ((t9-15 (method-of-type part-tracker activate))
                            (a0-47 s5-1)
                            )
                        (set! a1-14 (cond
                                      (sv-112
                                        sv-84
                                        )
                                      (else
                                        (set! a1-14 (ppointer->process (-> *setting-control* user-current movie)))
                                        (cond
                                          (a1-14
                                            (empty)
                                            a1-14
                                            )
                                          (else
                                            *entity-pool*
                                            )
                                          )
                                        )
                                      )
                              )
                        (t9-15
                          (the-as part-tracker a0-47)
                          a1-14
                          (symbol->string (-> part-tracker symbol))
                          (the-as pointer #x70004000)
                          )
                        )
                      (run-now-in-process
                        s5-1
                        part-tracker-init
                        gp-1
                        sv-120
                        #f
                        #f
                        (if sv-112
                            sv-84
                            (the-as process-drawable #f)
                            )
                        (if sv-112
                            sv-104
                            sv-96
                            )
                        )
                      (-> s5-1 ppointer)
                      )
                    )
                  )
                (else
                  (format
                    0
                    "ERROR: SCRIPT: part-tracker: unknown particle group \"~S\" in:~%~T~A~%"
                    (-> arg0 param 1)
                    (-> arg0 expr)
                    )
                  )
                )
              )
            )
          )
        )
  )

(let ((v1-115 (-> *script-form* 52)))
  (set! (-> v1-115 name) 'lightning-tracker)
  (set! (-> v1-115 spec)
        '((return macro (none))
          (function macro (symbol))
          (name eval (string symbol))
          &key
          (from-entity eval (string process entity-actor drawable-region-prim #f) #f)
          (to-entity eval (string process entity-actor drawable-region-prim #f) #f)
          (from-joint eval (string) #f)
          (to-joint eval (string) #f)
          (duration macro (object) 0)
          )
        )
  (set! (-> v1-115 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (local-vars (sv-48 vector) (sv-52 vector) (sv-56 int) (sv-64 int) (sv-72 time-frame) (sv-80 lightning-spec))
            (when (-> arg0 side-effect?)
              (if (not (-> arg0 param 2))
                  (set! (-> arg0 param 2) (-> arg0 process))
                  )
              (if (logtest? (the-as int (-> arg0 param 1)) 1)
                  (set! sv-80 (lookup-lightning-spec-by-name (symbol->string (the-as symbol (-> arg0 param 1)))))
                  (set! sv-80 (lookup-lightning-spec-by-name (the-as string (-> arg0 param 1))))
                  )
              (let* ((s5-0 (command-get-process (-> arg0 param 2) (the-as process #f)))
                     (gp-0 (if (type? s5-0 process-drawable)
                               (the-as process-drawable s5-0)
                               )
                           )
                     (s5-1 (command-get-process (-> arg0 param 3) (the-as process #f)))
                     (s4-0 (if (type? s5-1 process-drawable)
                               (the-as process-drawable s5-1)
                               )
                           )
                     (s0-0 (the-as entity #f))
                     (s1-0 (the-as entity #f))
                     (s5-2 #f)
                     )
                (set! sv-48 (vector-reset! (new 'stack-no-clear 'vector)))
                (set! sv-52 (vector-reset! (new 'stack-no-clear 'vector)))
                (set! sv-56 0)
                (set! sv-64 0)
                (set! sv-72 (command-get-time (-> arg0 param 6) 1))
                (let ((s3-0 (if (type? sv-80 lightning-spec)
                                sv-80
                                )
                            )
                      )
                  (when s3-0
                    (if (not gp-0)
                        (set! s0-0 (command-get-entity (-> arg0 param 2) (the-as entity #f)))
                        )
                    (if (not s4-0)
                        (set! s1-0 (command-get-entity (-> arg0 param 3) (the-as entity #f)))
                        )
                    (when (or (and gp-0 s4-0) (and s0-0 s1-0))
                      (cond
                        ((and gp-0 s4-0)
                         (set! s5-2 #t)
                         (let ((s0-1 (-> arg0 param 4))
                               (s1-1 (-> arg0 param 5))
                               )
                           (cond
                             (s0-1
                               (let ((v1-21 (the-as joint (get-art-by-name-method (-> gp-0 draw jgeo) (the-as string s0-1) (the-as type #f)))))
                                 (cond
                                   (v1-21
                                     (set! sv-56 (+ (-> v1-21 number) 1))
                                     (let ((a1-9 (-> gp-0 node-list data sv-56)))
                                       (vector<-cspace! sv-48 a1-9)
                                       )
                                     )
                                   (else
                                     (format 0 "ERROR: SCRIPT: lightning-tracker: unknown from-joint ~A in:~%~T~A~%" s0-1 (-> arg0 expr))
                                     (set! (-> sv-48 quad) (-> gp-0 root trans quad))
                                     )
                                   )
                                 )
                               )
                             (else
                               (set! (-> sv-48 quad) (-> gp-0 root trans quad))
                               )
                             )
                           (cond
                             (s1-1
                               (let ((v1-32 (the-as joint (get-art-by-name-method (-> s4-0 draw jgeo) (the-as string s1-1) (the-as type #f)))))
                                 (cond
                                   (v1-32
                                     (set! sv-64 (+ (-> v1-32 number) 1))
                                     (let ((a1-12 (-> s4-0 node-list data sv-64)))
                                       (vector<-cspace! sv-52 a1-12)
                                       )
                                     )
                                   (else
                                     (format 0 "ERROR: SCRIPT: lightning-tracker: unknown to-joint ~A in:~%~T~A~%" s1-1 (-> arg0 expr))
                                     (set! (-> sv-52 quad) (-> s4-0 root trans quad))
                                     )
                                   )
                                 )
                               )
                             (else
                               (set! (-> sv-52 quad) (-> s4-0 root trans quad))
                               )
                             )
                           )
                         )
                        ((and s0-0 s1-0)
                         (set! (-> sv-48 quad) (-> s0-0 extra trans quad))
                         (set! (-> sv-52 quad) (-> s1-0 extra trans quad))
                         )
                        )
                      )
                    (process-spawn
                      lightning-tracker
                      :init lightning-tracker-init
                      s3-0
                      sv-72
                      #f
                      (cond
                        (s5-2
                          (empty)
                          gp-0
                          )
                        (else
                          (the-as process-drawable #f)
                          )
                        )
                      (if s5-2
                          sv-56
                          sv-48
                          )
                      (if s5-2
                          sv-64
                          sv-52
                          )
                      :to (cond
                        (s5-2
                          (empty)
                          s4-0
                          )
                        (else
                          (let ((v1-48 (-> *setting-control* user-current movie)))
                            (set! s4-0 (if v1-48
                                           (the-as process-drawable (-> v1-48 0 self))
                                           )
                                  )
                            )
                          (cond
                            (s4-0
                              (empty)
                              s4-0
                              )
                            (else
                              (the-as process-drawable *entity-pool*)
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-117 (-> *script-form* 53)))
  (set! (-> v1-117 name) 'joint-eval)
  (set! (-> v1-117 spec)
        '((return macro (none))
          (function macro (symbol))
          (lambda eval (function))
          &key
          (entity eval (string process entity-actor #f) #f)
          (joint eval (string) #f)
          )
        )
  (set! (-> v1-117 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            " call a (lambda (process vector cspace)) on the specified location.

   e.g `(joint-eval ,(lambda ((proc process) (trans vector) (cs cspace)) (format #t \"~A ~`vector`P ~`cspace`P~%\" proc trans cs)) :entity *target* :joint \"neckB\")

   proc - the process or #f
   trans - the position specified (will always be true)
   cs - the cspace, or #f

  "
            (when (-> arg0 side-effect?)
              (if (not (-> arg0 param 2))
                  (set! (-> arg0 param 2) (-> arg0 process))
                  )
              (let* ((s5-0 (-> arg0 param 1))
                     (gp-0 (if (type? s5-0 function)
                               (the-as (function process vector cspace none) s5-0)
                               )
                           )
                     (s3-0 (command-get-process (-> arg0 param 2) (the-as process #f)))
                     (s5-1 (if (type? s3-0 process-drawable)
                               (the-as process-drawable s3-0)
                               )
                           )
                     (v1-5 (the-as entity #f))
                     )
                (let ((s3-1 (the-as object #f)))
                  (if (not s5-1)
                      (set! v1-5 (command-get-entity (-> arg0 param 2) (the-as entity #f)))
                      )
                  (if (or s5-1 v1-5 (-> arg0 trans))
                      (gp-0
                        s5-1
                        (cond
                          ((and s5-1 (nonzero? (-> s5-1 draw)) (nonzero? (-> s5-1 node-list)))
                           (let ((a1-5 (-> arg0 param 3)))
                             (cond
                               (a1-5
                                 (let ((v1-8 (the-as joint (get-art-by-name-method (-> s5-1 draw jgeo) (the-as string a1-5) (the-as type #f)))))
                                   (cond
                                     (v1-8
                                       (set! s3-1 (-> s5-1 node-list data (+ (-> v1-8 number) 1)))
                                       (vector<-cspace! (new 'stack-no-clear 'vector) (the-as cspace s3-1))
                                       )
                                     (else
                                       (format 0 "ERROR: SCRIPT: joint-eval: unknown joint ~A in:~%~T~A~%" (-> arg0 param 3) (-> arg0 expr))
                                       (set! s3-1 (-> s5-1 node-list data))
                                       (-> s5-1 root trans)
                                       )
                                     )
                                   )
                                 )
                               (else
                                 (set! s3-1 (-> s5-1 node-list data))
                                 (-> s5-1 root trans)
                                 )
                               )
                             )
                           )
                          (v1-5
                            (-> v1-5 extra trans)
                            )
                          (else
                            (-> arg0 trans)
                            )
                          )
                        (the-as cspace s3-1)
                        )
                      (format 0 "ERROR: SCRIPT: joint-eval: unknown entity ~A in:~%~T~A~%" (-> arg0 param 2) (-> arg0 expr))
                      )
                  )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-119 (-> *script-form* 54)))
  (set! (-> v1-119 name) 'auto-save)
  (set! (-> v1-119 spec) '((return macro (none)) (function macro (symbol)) (value eval (symbol))))
  (set! (-> v1-119 func) (the-as
                           (function script-context object)
                           (lambda ((arg0 script-context))
                             (if (-> arg0 side-effect?)
                                 (auto-save-command (the-as symbol (-> arg0 param 1)) 0 0 *default-pool* #f)
                                 )
                             (none)
                             )
                           )
        )
  )

(let ((v1-121 (-> *script-form* 55)))
  (set! (-> v1-121 name) 'teleport)
  (set! (-> v1-121 spec) '((return macro (none)) (function macro (symbol))))
  (set! (-> v1-121 func) (lambda ((arg0 script-context)) (when (-> arg0 side-effect?)
                                                           (let ((v0-0 #t))
                                                             (set! *teleport* v0-0)
                                                             v0-0
                                                             )
                                                           )
                                 )
        )
  )

(let ((v1-123 (-> *script-form* 56)))
  (set! (-> v1-123 name) 'scene-play)
  (set! (-> v1-123 spec) '((return macro (none)) (function macro (symbol)) (name eval (string pair))))
  (set! (-> v1-123 func) (lambda ((arg0 script-context))
                           (if (and (-> arg0 side-effect?)
                                    *target*
                                    (not *scene-player*)
                                    (zero? (logand (-> *target* focus-status) (focus-status dead)))
                                    )
                               (process-spawn scene-player :init scene-player-init (-> arg0 param 1) #t #f)
                               )
                           )
        )
  )

(let ((v1-125 (-> *script-form* 57)))
  (set! (-> v1-125 name) 'kill)
  (set! (-> v1-125 spec)
        '((return macro (none))
          (function macro (symbol))
          (entity eval (string entity-actor process #f))
          &key
          (store eval (symbol) #t)
          )
        )
  (set! (-> v1-125 func)
        (lambda ((arg0 script-context))
          "Store an entity's state in the load-state and then kill him and set him to be dead."
          (local-vars (v0-0 entity-perm-status) (v1-5 int))
          (when (-> arg0 side-effect?)
            (let* ((s5-0 (-> arg0 load-state))
                   (s3-0 (command-get-entity (-> arg0 param 1) (the-as entity #f)))
                   (gp-0 (if (type? s3-0 entity-actor)
                             s3-0
                             )
                         )
                   )
              (when gp-0
                (let ((a0-4 (res-lump-struct gp-0 'name structure)))
                  (cond
                    ((-> arg0 param 2)
                     (dotimes (v1-4 256)
                       (when (not (-> s5-0 object-name v1-4))
                         (set! (-> s5-0 object-name v1-4) (the-as string a0-4))
                         (set! (-> s5-0 object-status v1-4) (the-as basic (-> gp-0 extra perm status)))
                         (set! v1-5 v1-4)
                         (goto cfg-12)
                         )
                       )
                     (set! v1-5 -1)
                     (label cfg-12)
                     (when (>= v1-5 0)
                       (if (-> gp-0 extra process)
                           (kill! gp-0)
                           )
                       (set! v0-0 (logior (-> gp-0 extra perm status) (entity-perm-status dead)))
                       (set! (-> gp-0 extra perm status) v0-0)
                       v0-0
                       )
                     )
                    (else
                      (if (-> gp-0 extra process)
                          (kill! gp-0)
                          )
                      (set! v0-0 (logior (-> gp-0 extra perm status) (entity-perm-status dead)))
                      (set! (-> gp-0 extra perm status) v0-0)
                      v0-0
                      )
                    )
                  )
                )
              )
            )
          )
        )
  )

(let ((v1-127 (-> *script-form* 58)))
  (set! (-> v1-127 name) 'alive)
  (set! (-> v1-127 spec)
        '((return macro (none))
          (function macro (symbol))
          (entity eval (string entity-actor process #f))
          &key
          (store eval (symbol) #t)
          )
        )
  (set! (-> v1-127 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            "Store an entity's state in the load-state and then force him to be alive."
            (local-vars (v1-12 int))
            (when (-> arg0 side-effect?)
              (let* ((s5-0 (-> arg0 load-state))
                     (s3-0 (command-get-entity (-> arg0 param 1) (the-as entity #f)))
                     (gp-0 (if (type? s3-0 entity-actor)
                               s3-0
                               )
                           )
                     )
                (when gp-0
                  (cond
                    ((-> arg0 param 2)
                     (dotimes (s4-1 256)
                       (when (not (-> s5-0 object-name s4-1))
                         (set! (-> s5-0 object-name s4-1) (res-lump-struct gp-0 'name string))
                         (set! (-> s5-0 object-status s4-1) (the-as basic (-> gp-0 extra perm status)))
                         (set! v1-12 s4-1)
                         (goto cfg-12)
                         )
                       )
                     (set! v1-12 -1)
                     (label cfg-12)
                     (when (>= v1-12 0)
                       (entity-birth-no-kill gp-0)
                       (let ((v1-16 (-> gp-0 extra process)))
                         (when v1-16
                           (logclear! (-> v1-16 mask) (process-mask actor-pause))
                           (logclear! (-> v1-16 mask) (-> *kernel-context* prevent-from-run))
                           )
                         )
                       )
                     )
                    (else
                      (entity-birth-no-kill gp-0)
                      )
                    )
                  )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-129 (-> *script-form* 59)))
  (set! (-> v1-129 name) 'restore)
  (set! (-> v1-129 spec)
        '((return macro (none)) (function macro (symbol)) (entity eval (string entity-actor process #f)))
        )
  (set! (-> v1-129 func)
        (lambda ((arg0 script-context))
          "restore an entity's state fromt he load-state storage.  Will reset him if he is alive."
          (when (-> arg0 side-effect?)
            (let* ((gp-0 (-> arg0 load-state))
                   (s4-0 (command-get-entity (-> arg0 param 1) (the-as entity #f)))
                   (s5-0 (if (type? s4-0 entity-actor)
                             s4-0
                             )
                         )
                   )
              (when s5-0
                (let ((s3-0 (res-lump-struct s5-0 'name structure)))
                  (dotimes (s4-1 256)
                    (when (string= (-> gp-0 object-name s4-1) (the-as string s3-0))
                      (set! (-> s5-0 extra perm status) (the-as entity-perm-status (-> gp-0 object-status s4-1)))
                      (if (-> s5-0 extra process)
                          (kill! s5-0)
                          )
                      (set! (-> gp-0 object-name s4-1) #f)
                      (return #f)
                      )
                    )
                  )
                #f
                )
              )
            )
          )
        )
  )

(let ((v1-131 (-> *script-form* 60)))
  (set! (-> v1-131 name) 'special)
  (set! (-> v1-131 spec)
        '((return macro (none))
          (function macro (symbol))
          (entity eval (string entity-actor process #f))
          (value eval (symbol))
          )
        )
  (set! (-> v1-131 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            "make a guy special or not."
            (when (-> arg0 side-effect?)
              (let* ((s5-0 (command-get-entity (-> arg0 param 1) (the-as entity #f)))
                     (a0-3 (if (type? s5-0 entity-actor)
                               (the-as entity-actor s5-0)
                               )
                           )
                     )
                (if a0-3
                    (toggle-status a0-3 (entity-perm-status bit-7) (the-as symbol (-> arg0 param 2)))
                    )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-133 (-> *script-form* 61)))
  (set! (-> v1-133 name) 'save)
  (set! (-> v1-133 spec) '((return macro (none)) (function macro (symbol))))
  (set! (-> v1-133 func) (lambda ((arg0 script-context))
                           "make changes permanent."
                           (when (-> arg0 side-effect?)
                             (mem-copy! (&-> *backup-load-state* type) (&-> (-> arg0 load-state) type) 2168)
                             (set! (-> *backup-load-state* command-list) '())
                             (dotimes (v1-5 256)
                               (if (-> *backup-load-state* object-name v1-5)
                                   (set! (-> *backup-load-state* object-name v1-5) #f)
                                   )
                               )
                             #f
                             )
                           )
        )
  )

(let ((v1-135 (-> *script-form* 62)))
  (set! (-> v1-135 name) 'task-close!)
  (set! (-> v1-135 spec) '((return macro (none)) (function macro (symbol)) (task eval (binteger string))))
  (set! (-> v1-135 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            "close a task stage."
            (when (-> arg0 side-effect?)
              (cond
                ((not (logtest? (the-as int (-> arg0 param 1)) 7))
                 (task-node-close! (the-as game-task-node (command-get-int (-> arg0 param 1) 0)))
                 )
                (else
                  (let ((s5-1 (-> arg0 param 1)))
                    (let ((s4-0 (-> *game-info* sub-task-list)))
                      (dotimes (s3-0 (-> s4-0 length))
                        (when (nonzero? s3-0)
                          (let ((s2-0 (-> s4-0 s3-0)))
                            (when (string= (the-as string s5-1) (-> s2-0 name))
                              (close! s2-0 'event)
                              (return 0)
                              )
                            )
                          )
                        )
                      )
                    (format 0 "ERROR: SCRIPT: unknown task-node ~A in command ~A.~%" s5-1 (-> arg0 expr))
                    )
                  )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-137 (-> *script-form* 63)))
  (set! (-> v1-137 name) 'task-open!)
  (set! (-> v1-137 spec) '((return macro (none)) (function macro (symbol)) (task eval (binteger string))))
  (set! (-> v1-137 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            "close a task stage."
            (when (-> arg0 side-effect?)
              (cond
                ((not (logtest? (the-as int (-> arg0 param 1)) 7))
                 (task-node-open! (the-as game-task-node (command-get-int (-> arg0 param 1) 0)))
                 )
                (else
                  (let ((s5-1 (-> arg0 param 1)))
                    (let ((s4-0 (-> *game-info* sub-task-list)))
                      (dotimes (s3-0 (-> s4-0 length))
                        (when (nonzero? s3-0)
                          (let ((s2-0 (-> s4-0 s3-0)))
                            (when (string= (the-as string s5-1) (-> s2-0 name))
                              (open! s2-0 'event)
                              (return 0)
                              )
                            )
                          )
                        )
                      )
                    (format 0 "ERROR: SCRIPT: unknown task-node ~A in command ~A.~%" s5-1 (-> arg0 expr))
                    )
                  )
                )
              )
            (none)
            )
          )
        )
  )

(let ((v1-139 (-> *script-form* 64)))
  (set! (-> v1-139 name) 'task-complete?)
  (set! (-> v1-139 spec) '((return macro (none)) (function macro (symbol)) (task eval (binteger))))
  (set! (-> v1-139 func)
        (lambda ((arg0 script-context))
          "test whether the need resolution stage of a task is closed (actually tests the bit array)"
          (task-complete? *game-info* (the-as game-task (command-get-int (-> arg0 param 1) 0)))
          )
        )
  )

(let ((v1-141 (-> *script-form* 65)))
  (set! (-> v1-141 name) 'task-closed?)
  (set! (-> v1-141 spec) '((return macro (boolean)) (function macro (symbol)) (task eval (binteger string))))
  (set! (-> v1-141 func)
        (lambda ((arg0 script-context))
          "test whether the need resolution stage of a task is closed (actually tests the bit array)"
          (cond
            ((not (logtest? (the-as int (-> arg0 param 1)) 7))
             (task-node-closed? (the-as game-task-node (command-get-int (-> arg0 param 1) 0)))
             )
            (else
              (let ((s5-1 (-> arg0 param 1)))
                (let ((s4-0 (-> *game-info* sub-task-list)))
                  (dotimes (s3-0 (-> s4-0 length))
                    (when (nonzero? s3-0)
                      (let ((s2-0 (-> s4-0 s3-0)))
                        (if (string= (the-as string s5-1) (-> s2-0 name))
                            (return (logtest? (-> s2-0 flags) (game-task-node-flag closed)))
                            )
                        )
                      )
                    )
                  )
                (format 0 "ERROR: SCRIPT: unknown task-node ~A in command ~A.~%" s5-1 (-> arg0 expr))
                )
              )
            )
          #f
          )
        )
  )

(let ((v1-143 (-> *script-form* 66)))
  (set! (-> v1-143 name) 'task-open?)
  (set! (-> v1-143 spec) '((return macro (boolean)) (function macro (symbol)) (task eval (string))))
  (set! (-> v1-143 func)
        (lambda ((arg0 script-context))
          "test whether the need resolution stage of a task is closed (actually tests the bit array)"
          (let ((s5-0 (-> arg0 param 1)))
            (let ((s4-0 (-> *game-info* sub-task-list))
                  (s3-0 0)
                  )
              (while (< s3-0 (-> s4-0 length))
                (when (nonzero? s3-0)
                  (let ((v1-5 (-> s4-0 s3-0)))
                    (if (string= (the-as string s5-0) (-> v1-5 name))
                        (return (task-node-open? (the-as game-task-node s3-0)))
                        )
                    )
                  )
                (set! s3-0 (+ s3-0 1))
                )
              )
            (format 0 "ERROR: SCRIPT: unknown task-node ~A in command ~A.~%" s5-0 (-> arg0 expr))
            )
          #f
          )
        )
  )

(let ((v1-145 (-> *script-form* 67)))
  (set! (-> v1-145 name) 'play-task)
  (set! (-> v1-145 spec) '((return macro (none)) (function macro (symbol)) (task eval (binteger))))
  (set! (-> v1-145 func) (lambda ((arg0 script-context))
                           "set the attributes for a task."
                           (if (-> arg0 side-effect?)
                               (play-task (the-as game-task (command-get-int (-> arg0 param 1) 0)) 'debug #f)
                               )
                           )
        )
  )

(let ((v1-147 (-> *script-form* 68)))
  (set! (-> v1-147 name) 'task-manager)
  (set! (-> v1-147 spec)
        '((return macro (process))
          (function macro (symbol))
          &key
          (type macro (symbol) task-manager)
          (level macro (symbol) #f)
          )
        )
  (set! (-> v1-147 func)
        (lambda ((arg0 script-context))
          "set the attributes for a task."
          (when (-> arg0 side-effect?)
            (let* ((s4-0 (-> arg0 key))
                   (gp-0 (if (type? s4-0 game-task-node-info)
                             (the-as game-task-node-info s4-0)
                             )
                         )
                   (s3-0 (-> (the-as symbol (-> arg0 param 1)) value))
                   (s4-1 (if (type? s3-0 type)
                             s3-0
                             )
                         )
                   (s5-1 (-> arg0 param 2))
                   )
              (set! s5-1 (cond
                           (s5-1
                             (empty)
                             s5-1
                             )
                           (else
                             (if (and gp-0 (-> gp-0 info))
                                 (-> gp-0 info level)
                                 )
                             )
                           )
                    )
              (cond
                ((and gp-0 (-> gp-0 info) s4-1 (or (not s5-1) (= (level-status *level* (the-as symbol s5-1)) 'active)))
                 (when (not (handle->process (-> gp-0 info manager)))
                   (let* ((s4-2 (get-process *default-dead-pool* (the-as type s4-1) #x4000))
                          (v0-0
                            (the-as object (ppointer->handle (when s4-2
                                                               (let ((t9-4 (method-of-type process activate)))
                                                                 (t9-4 s4-2 *entity-pool* (-> gp-0 name) (the-as pointer #x70004000))
                                                                 )
                                                               (run-now-in-process s4-2 task-manager-init-by-other gp-0 s5-1)
                                                               (-> s4-2 ppointer)
                                                               )
                                                             )
                                    )
                            )
                          )
                     (set! (-> gp-0 info manager) (the-as handle v0-0))
                     v0-0
                     )
                   )
                 )
                (*debug-segment*
                  (format 0 "ERROR: SCRIPT: could not spawn task-manager for node ~A level ~A~%" gp-0 s5-1)
                  )
                )
              )
            )
          )
        )
  )

(let ((v1-149 (-> *script-form* 69)))
  (set! (-> v1-149 name) 'water)
  (set! (-> v1-149 spec) '((return macro (pair))
                           (function macro (symbol))
                           (mode macro (symbol))
                           (data eval (object))
                           (params macro (pair))
                           )
        )
  (set! (-> v1-149 func) (lambda :behavior process
                           ((arg0 script-context))
                           "define a water volume.  command does nothing, just defines the syntax."
                           (-> arg0 expr)
                           )
        )
  )

(let ((v1-151 (-> *script-form* 70)))
  (set! (-> v1-151 name) 'movie?)
  (set! (-> v1-151 spec) '((return macro (boolean)) (function macro (symbol))))
  (set! (-> v1-151 func) (lambda ((arg0 script-context)) (movie?)))
  )

(let ((v1-153 (-> *script-form* 71)))
  (set! (-> v1-153 name) 'demo?)
  (set! (-> v1-153 spec) '((return macro (boolean)) (function macro (symbol))))
  (set! (-> v1-153 func) (lambda ((arg0 script-context)) "are we in demo?" (demo?)))
  )

(let ((v1-155 (-> *script-form* 72)))
  (set! (-> v1-155 name) 'scene-player?)
  (set! (-> v1-155 spec) '((return macro (boolean)) (function macro (symbol))))
  (set! (-> v1-155 func)
        (lambda ((arg0 script-context))
          "test whether the need resolution stage of a task is closed (actually tests the bit array)"
          (if *scene-player*
              #t
              #f
              )
          )
        )
  )

(let ((v1-157 (-> *script-form* 73)))
  (set! (-> v1-157 name) 'talker-spawn)
  (set! (-> v1-157 spec) '((return macro (binteger)) (function macro (symbol)) (message eval (string))))
  (set! (-> v1-157 func)
        (the-as (function script-context object) (lambda :behavior process
                                                   ((arg0 script-context))
                                                   (if (-> arg0 side-effect?)
                                                       (* (talker-spawn-func
                                                            (string->talker-speech (the-as string (-> arg0 param 1)))
                                                            *entity-pool*
                                                            (target-pos 0)
                                                            (the-as region (-> arg0 key))
                                                            )
                                                          8
                                                          )
                                                       0
                                                       )
                                                   (none)
                                                   )
                )
        )
  )

(let ((v1-159 (-> *script-form* 74)))
  (set! (-> v1-159 name) 'mark-played!)
  (set! (-> v1-159 spec) '((return macro (none)) (function macro (symbol)) (message eval (string))))
  (set! (-> v1-159 func) (the-as
                           (function script-context object)
                           (lambda :behavior process
                             ((arg0 script-context))
                             (when (-> arg0 side-effect?)
                               (let ((a0-2 (string->talker-speech (the-as string (-> arg0 param 1)))))
                                 (if a0-2
                                     (play-communicator-speech! a0-2)
                                     )
                                 )
                               )
                             0
                             (none)
                             )
                           )
        )
  )

(let ((v1-161 (-> *script-form* 75)))
  (set! (-> v1-161 name) 'yes-play!)
  (set! (-> v1-161 spec)
        '((return macro (none)) (function macro (symbol)) (message eval (string)) (count eval (binteger bfloat)))
        )
  (set! (-> v1-161 func) (the-as
                           (function script-context object)
                           (lambda :behavior process
                             ((arg0 script-context))
                             (when (-> arg0 side-effect?)
                               (let ((s5-0 (string->talker-speech (the-as string (-> arg0 param 1))))
                                     (a1-1 (command-get-int (-> arg0 param 2) 0))
                                     )
                                 (if s5-0
                                     (talker-speech-class-method-12 s5-0 a1-1)
                                     )
                                 )
                               )
                             0
                             (none)
                             )
                           )
        )
  )

(let ((v1-163 (-> *script-form* 76)))
  (set! (-> v1-163 name) 'no-play!)
  (set! (-> v1-163 spec)
        '((return macro (none)) (function macro (symbol)) (message eval (string)) (count eval (binteger bfloat)))
        )
  (set! (-> v1-163 func) (the-as
                           (function script-context object)
                           (lambda :behavior process
                             ((arg0 script-context))
                             (when (-> arg0 side-effect?)
                               (let ((s5-0 (string->talker-speech (the-as string (-> arg0 param 1))))
                                     (a1-1 (command-get-int (-> arg0 param 2) 0))
                                     )
                                 (if s5-0
                                     (talker-speech-class-method-13 s5-0 a1-1)
                                     )
                                 )
                               )
                             0
                             (none)
                             )
                           )
        )
  )

(let ((v1-165 (-> *script-form* 77)))
  (set! (-> v1-165 name) 'endlessfall)
  (set! (-> v1-165 spec) '((return macro (object)) (function macro (symbol))))
  (set! (-> v1-165 func) (lambda :behavior process
                           ((arg0 script-context))
                           (when (-> arg0 side-effect?)
                             (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
                               (set! (-> a1-0 from) (process->ppointer self))
                               (set! (-> a1-0 num-params) 2)
                               (set! (-> a1-0 message) 'attack-invinc)
                               (set! (-> a1-0 param 0) (the-as uint #f))
                               (let ((v1-4 (new 'static 'attack-info :mask (attack-info-mask mode id))))
                                 (set! (-> v1-4 id) (the-as uint 2))
                                 (set! (-> v1-4 mode) 'endlessfall)
                                 (set! (-> a1-0 param 1) (the-as uint v1-4))
                                 )
                               (send-event-function *target* a1-0)
                               )
                             )
                           )
        )
  )

(let ((v1-167 (-> *script-form* 78)))
  (set! (-> v1-167 name) 'birth-pickup)
  (set! (-> v1-167 spec)
        '((return macro (process))
          (function macro (symbol))
          (trans macro (vector symbol string pair))
          (pickup macro (symbol))
          (amount eval (bfloat binteger))
          &key
          (flags macro (pair) ('()))
          )
        )
  (set! (-> v1-167 func)
        (lambda ((arg0 script-context))
          (when (-> arg0 side-effect?)
            (let* ((v1-1 (-> arg0 param 2))
                   (s5-0 (cond
                           ((= v1-1 'board)
                            28
                            )
                           ((= v1-1 'skill)
                            22
                            )
                           (else
                             0
                             )
                           )
                         )
                   )
              (cond
                ((nonzero? s5-0)
                 (let ((s4-0 (new 'static 'fact-info)))
                   (set! (-> s4-0 options) (actor-option))
                   (let* ((v1-2 (-> arg0 param 4))
                          (a0-3 (car (the-as pair v1-2)))
                          )
                     (while (not (null? v1-2))
                       (cond
                         ((= a0-3 'suck-in)
                          (logior! (-> s4-0 options) (actor-option suck-in))
                          )
                         ((= a0-3 'auto-pickup)
                          (logior! (-> s4-0 options) (actor-option auto-pickup))
                          )
                         )
                       (set! v1-2 (cdr v1-2))
                       (set! a0-3 (car (the-as pair v1-2)))
                       )
                     )
                   (ppointer->process (birth-pickup-at-point
                                        (command-get-trans (-> arg0 param 1) (-> arg0 trans))
                                        (the-as pickup-type s5-0)
                                        (command-get-float (-> arg0 param 3) 0.0)
                                        #t
                                        *entity-pool*
                                        s4-0
                                        )
                                      )
                   )
                 )
                (else
                  (format 0 "ERROR: SCRIPT: could not spawn pickup, unknown type ~A~%" (-> arg0 param 2))
                  )
                )
              )
            )
          )
        )
  )

(let ((v1-169 (-> *script-form* 79)))
  (set! (-> v1-169 name) 'test-pickup)
  (set! (-> v1-169 spec) '((return macro (binteger)) (function macro (symbol)) (pickup macro (symbol))))
  (set! (-> v1-169 func)
        (lambda ((arg0 script-context)) (case (-> arg0 param 1)
                                          (('gem)
                                           (* (the int (the float (send-event *target* 'test-pickup 21))) 8)
                                           )
                                          (else
                                            0
                                            )
                                          )
                )
        )
  )

(let ((v1-171 (-> *script-form* 80)))
  (set! (-> v1-171 name) 'get-alert-level)
  (set! (-> v1-171 spec) '((return macro (binteger)) (function macro (symbol))))
  (set! (-> v1-171 func) (lambda :behavior process
                           ((arg0 script-context))
                           (let ((a1-0 (new 'stack-no-clear 'event-message-block)))
                             (set! (-> a1-0 from) (process->ppointer self))
                             (set! (-> a1-0 num-params) 0)
                             (set! (-> a1-0 message) 'get-alert-level)
                             (let ((v1-2 (send-event-function *traffic-manager* a1-0)))
                               (if v1-2
                                   (* (the-as int v1-2) 8)
                                   0
                                   )
                               )
                             )
                           )
        )
  )

(let ((v1-173 (-> *script-form* 81)))
  (set! (-> v1-173 name) 'pause)
  (set! (-> v1-173 spec) '((return macro (none)) (function macro (symbol))))
  (set! (-> v1-173 func) (lambda ((arg0 script-context)) (set-master-mode 'pause) 0))
  )

(let ((v1-175 (-> *script-form* 82)))
  (set! (-> v1-175 name) 'camera-smush)
  (set! (-> v1-175 spec) '((return macro (none))
                           (function macro (symbol))
                           &key
                           (size macro (binteger bfloat pair) (meters (new 'static 'bfloat :data 0.1)))
                           (duration macro (binteger bfloat pair) (seconds (new 'static 'bfloat :data 0.25)))
                           )
        )
  (set! (-> v1-175 func) (lambda ((arg0 script-context))
                           (if (-> arg0 side-effect?)
                               (activate!
                                 *camera-smush-control*
                                 (the-as float (command-get-param (-> arg0 param 1) #f))
                                 15
                                 (the-as int (command-get-time (-> arg0 param 2) 1))
                                 1.0
                                 0.98
                                 (-> *display* camera-clock)
                                 )
                               )
                           0
                           )
        )
  )

(let ((v1-177 (-> *script-form* 83)))
  (set! (-> v1-177 name) 'show-hud)
  (set! (-> v1-177 spec) '((return macro (none)) (function macro (symbol)) (name eval (symbol))))
  (set! (-> v1-177 func) (lambda ((arg0 script-context))
                           (if (-> arg0 side-effect?)
                               (show-hud (-> arg0 param 1))
                               )
                           0
                           )
        )
  )

(let ((v1-179 (-> *script-form* 84)))
  (set! (-> v1-179 name) 'fma-sphere)
  (set! (-> v1-179 spec)
        '((return macro (none))
          (function macro (symbol))
          (mode macro (pair))
          &key
          (entity eval (string process entity-actor #f) #f)
          (joint eval (string) #f)
          (duration macro (object) (frame-time 0))
          (sphere eval (binteger #f) #f)
          (danger eval (binteger #f) #f)
          )
        )
  (set! (-> v1-179 func)
        (the-as
          (function script-context object)
          (lambda ((arg0 script-context))
            (local-vars
              (a1-7 process-tree)
              (sv-16 object)
              (sv-20 int)
              (sv-24 process-drawable)
              (sv-32 int)
              (sv-40 time-frame)
              (sv-48 object)
              (sv-52 object)
              )
            (when (-> arg0 side-effect?)
              (set! sv-16 (-> arg0 param 1))
              (set! sv-20 0)
              (let ((s5-0 (command-get-process (-> arg0 param 2) (the-as process #f))))
                (set! sv-24 (if (type? s5-0 process-drawable)
                                (the-as process-drawable s5-0)
                                )
                      )
                )
              (set! sv-32 -1)
              (set! sv-40 (command-get-time (-> arg0 param 4) 1))
              (set! sv-48 (-> arg0 param 5))
              (set! sv-52 (-> arg0 param 6))
              (let* ((s5-1 sv-16)
                     (a2-0 (car (the-as pair s5-1)))
                     )
                (while (not (null? s5-1))
                  (case a2-0
                    (('nav)
                     (set! sv-20 (logior sv-20 1))
                     )
                    (('kill-once)
                     (set! sv-20 (logior sv-20 2))
                     )
                    (('danger)
                     (set! sv-20 (logior sv-20 4))
                     )
                    (('deadly-overlap)
                     (set! sv-20 (logior sv-20 8))
                     )
                    (else
                      (format 0 "ERROR: SCRIPT: unknown fma-sphere-mode ~A~%" a2-0)
                      )
                    )
                  (set! s5-1 (cdr s5-1))
                  (set! a2-0 (car (the-as pair s5-1)))
                  )
                )
              (when (and sv-24 (and (nonzero? (-> sv-24 draw)) (nonzero? (-> sv-24 node-list))))
                (let ((a1-4 (-> arg0 param 3)))
                  (when a1-4
                    (let ((v1-31 (the-as joint (get-art-by-name-method (-> sv-24 draw jgeo) (the-as string a1-4) (the-as type #f)))))
                      (if v1-31
                          (set! sv-32 (+ (-> v1-31 number) 1))
                          (format 0 "ERROR: SCRIPT: joint-eval: unknown joint ~A in:~%~T~A~%" (-> arg0 param 3) (-> arg0 expr))
                          )
                      )
                    )
                  )
                )
              (let ((gp-1 (get-process *default-dead-pool* fma-sphere #x4000)))
                (when gp-1
                  (let ((t9-7 (method-of-type fma-sphere activate))
                        (a0-14 gp-1)
                        )
                    (set! a1-7 (cond
                                 (sv-24
                                   sv-24
                                   )
                                 (else
                                   (set! a1-7 (ppointer->process (-> *setting-control* user-current movie)))
                                   (cond
                                     (a1-7
                                       (empty)
                                       a1-7
                                       )
                                     (else
                                       *entity-pool*
                                       )
                                     )
                                   )
                                 )
                          )
                    (t9-7 (the-as fma-sphere a0-14) a1-7 (symbol->string (-> fma-sphere symbol)) (the-as pointer #x70004000))
                    )
                  (run-now-in-process gp-1 fma-sphere-init-by-other sv-20 sv-24 sv-32 sv-40 sv-48 sv-52)
                  (-> gp-1 ppointer)
                  )
                )
              )
            0
            (none)
            )
          )
        )
  )

(let ((v1-182 (new 'global 'script-context (the-as basic (process->ppointer pp)) pp (the-as vector #f))))
  (set! (-> v1-182 side-effect?) #f)
  (set! *syntax-context* v1-182)
  )

(define *script-context*
  (new 'global 'script-context (the-as basic (process->ppointer pp)) pp (the-as vector #f))
  )

)
