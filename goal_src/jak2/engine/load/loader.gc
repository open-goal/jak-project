;;-*-Lisp-*-
(in-package goal)

;; name: loader.gc
;; name in dgo: loader
;; dgos: ENGINE, GAME

(define-extern art-group-load-check (function string kheap int art-group))

;; DECOMP BEGINS

(defmethod mem-usage subtitle-range ((obj subtitle-range) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 73 (-> arg0 length)))
  (set! (-> arg0 data 72 name) "subtitle")
  (+! (-> arg0 data 72 count) 1)
  (let ((v1-6 (asize-of obj)))
    (+! (-> arg0 data 72 used) v1-6)
    (+! (-> arg0 data 72 total) (logand -16 (+ v1-6 15)))
    )
  obj
  )


;; WARN: Return type mismatch symbol vs load-dir.
(defmethod mem-usage load-dir ((obj load-dir) (arg0 memory-usage-block) (arg1 int))
  (set! (-> arg0 length) (max 85 (-> arg0 length)))
  (set! (-> arg0 data 84 name) "array")
  (+! (-> arg0 data 84 count) 1)
  (let ((v1-6 (asize-of obj)))
    (+! (-> arg0 data 84 used) v1-6)
    (+! (-> arg0 data 84 total) (logand -16 (+ v1-6 15)))
    )
  (set! (-> arg0 length) (max 85 (-> arg0 length)))
  (set! (-> arg0 data 84 name) "array")
  (set! (-> arg0 data 84 count) (-> arg0 data 84 count))
  (let ((v1-15 (asize-of (-> obj string-array))))
    (+! (-> arg0 data 84 used) v1-15)
    (+! (-> arg0 data 84 total) (logand -16 (+ v1-15 15)))
    )
  (set! (-> arg0 length) (max 85 (-> arg0 length)))
  (set! (-> arg0 data 84 name) "array")
  (set! (-> arg0 data 84 count) (-> arg0 data 84 count))
  (let ((v1-24 (asize-of (-> obj data-array))))
    (+! (-> arg0 data 84 used) v1-24)
    (+! (-> arg0 data 84 total) (logand -16 (+ v1-24 15)))
    )
  (dotimes (s3-0 (-> obj data-array length))
    (mem-usage (-> obj data-array s3-0) arg0 arg1)
    )
  (the-as load-dir #f)
  )

(defmethod load-to-heap-by-name load-dir-art-group ((obj load-dir-art-group) (arg0 string) (arg1 symbol) (arg2 kheap) (arg3 int))
  (let ((s5-0 (-> obj string-array)))
    (dotimes (s3-0 (-> s5-0 length))
      (when (string= arg0 (-> s5-0 s3-0))
        (when arg1
          (let ((v1-4 (art-group-load-check arg0 arg2 arg3)))
            (if v1-4
                (set! (-> obj art-group-array s3-0) v1-4)
                )
            )
          )
        (return (-> obj art-group-array s3-0))
        )
      )
    (let ((v0-2 (art-group-load-check arg0 arg2 arg3)))
      (when v0-2
        (set! (-> s5-0 (-> s5-0 length)) arg0)
        (set! (-> obj art-group-array (-> s5-0 length)) v0-2)
        (+! (-> s5-0 length) 1)
        (+! (-> obj art-group-array length) 1)
        )
      v0-2
      )
    )
  )

(defmethod set-loaded-art load-dir-art-group ((obj load-dir-art-group) (arg0 art-group))
  (let ((s4-0 (-> obj string-array)))
    (dotimes (s3-0 (-> s4-0 length))
      (when (string= (-> arg0 name) (-> s4-0 s3-0))
        (set! (-> obj art-group-array s3-0) arg0)
        (set! arg0 (-> obj art-group-array s3-0))
        (goto cfg-7)
        )
      )
    (set! (-> s4-0 (-> s4-0 length)) (-> arg0 name))
    (set! (-> obj art-group-array (-> s4-0 length)) arg0)
    (+! (-> s4-0 length) 1)
    )
  (+! (-> obj art-group-array length) 1)
  (label cfg-7)
  arg0
  )

(defun drawable-load ((arg0 drawable) (arg1 kheap))
  ;; (local-vars (sp-0 pointer))
  (cond
    ((type? arg0 string)
     ; (the-as none sp-0)
     ; (if (< (the-as uint sp-0) (the-as uint *stack-top*))
     ;     (set! sp-0 (&+ *kernel-sp* -1024))
     ;     )
     (let ((s5-1 (loado (the-as string arg0) arg1)))
       (if (and s5-1 (type? s5-1 drawable))
           (login (the-as drawable s5-1))
           )
       )
     )
    ((type? arg0 drawable)
     (login arg0)
     )
    )
  )

(defun art-load ((arg0 string) (arg1 kheap))
  ; (local-vars (sp-0 pointer))
  ; (the-as none sp-0)
  ; (if (< (the-as uint sp-0) (the-as uint *stack-top*))
  ;     (set! sp-0 (&+ *kernel-sp* -1024))
  ;     )
  (let ((s5-0 (loado arg0 arg1)))
    (if (type? s5-0 art)
        (login (the-as art s5-0))
        (the-as art #f)
        )
    )
  )

(defun art-group-load-check ((arg0 string) (arg1 kheap) (arg2 int))
  ; (local-vars (sp-0 pointer))
  (when *debug-segment*
    ; (the-as none sp-0)
    ; (if (< (the-as uint sp-0) (the-as uint *stack-top*))
    ;     (set! sp-0 (&+ *kernel-sp* -1024))
    ;     )
    (let ((s3-1 (loado (make-file-name (file-kind art-group) arg0 arg2 #f) arg1)))
      (cond
        ((not s3-1)
         (format 0 "ERROR: art-group ~A is not a valid file.~%" arg0)
         (the-as art-group #f)
         )
        ((not (type? s3-1 art-group))
         (format 0 "ERROR: art-group ~A is not a art-group.~%" arg0)
         (the-as art-group #f)
         )
        ((not (file-info-correct-version? (-> (the-as art-group s3-1) info) (file-kind art-group) arg2))
         (the-as art-group #f)
         )
        (else
          (login (the-as art-group s3-1))
          )
        )
      )
    )
  )

(defmethod print external-art-buffer ((obj external-art-buffer))
  (format
    #t
    "#<~A ~S ~D ~A @ #x~X>"
    (-> obj type)
    (-> obj pending-load-file)
    (-> obj pending-load-file-part)
    (-> obj status)
    obj
    )
  obj
  )

(defun external-art-buffer-init ((arg0 external-art-buffer))
  (let ((v1-0 (-> arg0 heap)))
    (set! (-> v1-0 base) (the-as pointer (+ #x84000 (* #x3dc00 (-> arg0 index)))))
    (set! (-> v1-0 current) (-> v1-0 base))
    (set! (-> v1-0 top-base) (&+ (-> v1-0 base) #x3dc00))
    (set! (-> v1-0 top) (-> v1-0 top-base))
    )
  0
  )

(defmethod set-pending-file external-art-buffer ((obj external-art-buffer) (arg0 string) (arg1 int) (arg2 handle) (arg3 float))
  (set! (-> obj pending-load-file) arg0)
  (set! (-> obj pending-load-file-part) arg1)
  (set! (-> obj pending-load-file-owner) arg2)
  (set! (-> obj pending-load-file-priority) arg3)
  0
  )

(defmethod unlock! external-art-buffer ((obj external-art-buffer))
  (set! (-> obj locked?) #f)
  0
  )

(defmethod inactive? external-art-buffer ((obj external-art-buffer))
  (!= (-> obj status) 'active)
  )

(defmethod file-status external-art-buffer ((obj external-art-buffer) (arg0 string) (arg1 int))
  (when (and (name= (-> obj pending-load-file) arg0) (= (-> obj pending-load-file-part) arg1))
    (if (and (name= (-> obj load-file) arg0) (= (-> obj load-file-part) arg1))
        (-> obj status)
        'pending
        )
    )
  )

(defmethod link-art! art-group ((obj art-group))
  (when obj
    (countdown (s5-0 (-> obj length))
      (let* ((s3-0 (-> obj data s5-0))
             (s4-0 (if (type? s3-0 art-joint-anim)
                       (the-as art-joint-anim s3-0)
                       )
                   )
             (s2-0 #f)
             )
        (when s4-0
          (let ((s3-1 LEVEL_TOTAL))
            (while (begin (label cfg-24) (nonzero? s3-1))
              (+! s3-1 -1)
              (let ((v1-8 (get-art-group-by-name (-> *level* level s3-1) (-> s4-0 master-art-group-name))))
                (when v1-8
                  (countdown (a0-5 (-> v1-8 length))
                    (if (= (-> v1-8 data a0-5) s4-0)
                        (goto cfg-24)
                        )
                    )
                  (cond
                    ((and (< (-> s4-0 master-art-group-index) (-> v1-8 length))
                          (not (-> v1-8 data (-> s4-0 master-art-group-index)))
                          )
                     (set! (-> v1-8 data (-> s4-0 master-art-group-index)) s4-0)
                     (set! s2-0 #t)
                     )
                    (else
                      (countdown (a0-17 (-> v1-8 length))
                        (when (not (-> v1-8 data a0-17))
                          (set! (-> v1-8 data a0-17) s4-0)
                          (set! s2-0 #t)
                          (goto cfg-24)
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          (if (not s2-0)
              (format 0 "ERROR: ~A could not find a master slot to link for ~A.~%" (-> obj name) s4-0)
              )
          )
        )
      )
    )
  obj
  )

(defmethod unlink-art! art-group ((obj art-group))
  (when obj
    (countdown (s5-0 (-> obj length))
      (let* ((s3-0 (-> obj data s5-0))
             (s4-0 (if (type? s3-0 art-joint-anim)
                       (the-as art-joint-anim s3-0)
                       )
                   )
             (s3-1 #f)
             )
        (when s4-0
          (let ((s2-0 LEVEL_TOTAL))
            (while (begin (label cfg-13) (nonzero? s2-0))
              (+! s2-0 -1)
              (let ((v1-8 (get-art-group-by-name (-> *level* level s2-0) (-> s4-0 master-art-group-name))))
                (when v1-8
                  (countdown (a0-5 (-> v1-8 length))
                    (when (= s4-0 (-> v1-8 data a0-5))
                      (set! (-> v1-8 data a0-5) #f)
                      (set! s3-1 #t)
                      (goto cfg-13)
                      )
                    )
                  )
                )
              )
            )
          (if (not s3-1)
              (format 0 "ERROR: ~A could not find a master slot to unlink for ~A.~%" (-> obj name) s4-0)
              )
          )
        )
      )
    )
  0
  )

(defmethod link-file external-art-buffer ((obj external-art-buffer) (arg0 art-group))
  (when arg0
    (link-art! arg0)
    (set! (-> obj art-group) arg0)
    )
  arg0
  )

(defmethod unlink-file external-art-buffer ((obj external-art-buffer) (arg0 art-group))
  (when arg0
    (unlink-art! arg0)
    (set! (-> obj art-group) #f)
    )
  0
  )

;; WARN: Found some very strange gotos. Check result carefully, this is not well tested.
(defmethod update external-art-buffer ((obj external-art-buffer))
  (when (or (not (name= (-> obj pending-load-file) (-> obj load-file)))
            (!= (-> obj pending-load-file-part) (-> obj load-file-part))
            )
    (when (not (handle->process (-> obj pending-load-file-owner)))
      (set! (-> obj pending-load-file) #f)
      (set! (-> obj pending-load-file-part) -1)
      (set! (-> obj pending-load-file-owner) (the-as handle #f))
      (set! (-> obj pending-load-file-priority) 100000000.0)
      )
    (when (= (-> obj status) 'initialize)
      ((-> obj init-heap) obj)
      (set! (-> obj status) 'inactive)
      )
    (cond
      ((-> obj load-file)
       (if (= (-> obj status) 'loading)
           (str-load-cancel)
           )
       (set! (-> obj load-file) #f)
       (set! (-> obj load-file-part) -1)
       (set! (-> obj load-file-owner) (the-as handle #f))
       (set! (-> obj load-file-priority) 100000000.0)
       )
      (else
        (set! (-> obj load-file) (-> obj pending-load-file))
        (set! (-> obj load-file-part) (-> obj pending-load-file-part))
        (set! (-> obj load-file-owner) (-> obj pending-load-file-owner))
        (set! (-> obj load-file-priority) (-> obj pending-load-file-priority))
        )
      )
    )
  (label cfg-18)
  (cond
    ((-> obj load-file)
     (case (-> obj status)
       (('active 'reserved)
        )
       (('error)
        (set! (-> obj status) 'inactive)
        (set! (-> obj load-file) #f)
        (set! (-> obj load-file-part) -1)
        (set! (-> obj load-file-owner) (the-as handle #f))
        (set! (-> obj load-file-priority) 100000000.0)
        (set! (-> obj pending-load-file) #f)
        (set! (-> obj pending-load-file-part) -1)
        (set! (-> obj pending-load-file-owner) (the-as handle #f))
        (set! (-> obj pending-load-file-priority) 100000000.0)
        (set! (-> obj art-group) #f)
        )
       (('inactive)
        (let ((v1-31 (-> obj heap)))
          (set! (-> v1-31 current) (-> v1-31 base))
          )
        (cond
          ((string= (-> obj load-file) "reserved")
           (cond
             ((-> *art-control* reserve-buffer)
              (format 0 "ERROR: trying double reserve ~A when ~A is reserved~%" obj (-> *art-control* reserve-buffer))
              )
             (else
               (set! (-> obj status) 'reserved)
               (set! (-> *art-control* reserve-buffer) obj)
               )
             )
           )
          ((and (!= (-> *level* loading-level) (-> *level* default-level)) (< 81920.0 (-> obj load-file-priority)))
           )
          ((let ((v1-44 (logand -64 (&+ (-> obj heap current) 63))))
             (str-load (-> obj load-file) (-> obj load-file-part) v1-44 (&- (-> obj heap top) (the-as uint v1-44)))
             )
           (set! (-> obj status) 'loading)
           0
           )
          )
        )
       (('loading)
        (case (str-load-status (&-> obj len))
          (('error)
           (set! (-> obj status) 'error)
           )
          (('busy)
           )
          (else
            (set! (-> obj buf) (logand -64 (&+ (-> obj heap current) 63)))
            (set! (-> obj status) 'loaded)
            (goto cfg-18)
            )
          )
        )
       (('loaded)
        (let ((a0-34 (-> obj buf)))
          (cond
            ((-> obj login?)
             (set! (-> obj art-group) (the-as art-group (link a0-34 (-> obj load-file data) (-> obj len) (-> obj heap) 0)))
             (let ((s4-0 (-> obj art-group))
                   (s3-0 (-> obj load-file))
                   )
               (cond
                 ((not s4-0)
                  (format 0 "ERROR: art-group ~A part ~D is not a valid file.~%" s3-0 (-> obj load-file-part))
                  (set! (-> obj status) 'error)
                  )
                 ((not (type? s4-0 art-group))
                  (format 0 "ERROR: art-group ~A part ~D is not a art-group.~%" s3-0 (-> obj load-file-part))
                  (set! (-> obj status) 'error)
                  )
                 ((not (file-info-correct-version? (-> s4-0 info) (file-kind art-group) 0))
                  (set! (-> obj status) 'error)
                  )
                 (else
                   (login s4-0)
                   (set! (-> obj status) 'locked)
                   )
                 )
               )
             )
            (else
              (set! (-> obj status) 'locked)
              (set! (-> obj art-group) (the-as art-group a0-34))
              )
            )
          )
        )
       (('locked)
        (when (and (not (-> obj locked?)) (handle->process (-> obj load-file-owner)))
          (if (-> obj login?)
              (link-file obj (-> obj art-group))
              )
          (if (-> obj other)
              (set! (-> obj other locked?) #t)
              )
          (set! (-> obj status) 'active)
          (goto cfg-18)
          )
        )
       )
     )
    (else
      (case (-> obj status)
        (('initialize)
         )
        (('reserved)
         (cond
           ((= (-> *art-control* reserve-buffer) obj)
            (set! (-> *art-control* reserve-buffer) #f)
            (set! (-> obj status) 'inactive)
            )
           (else
             (format 0 "ERROR: trying tro free ~A when ~A is reserved~%" obj (-> *art-control* reserve-buffer))
             )
           )
         )
        (('active)
         (if (-> obj login?)
             (unlink-file obj (-> obj art-group))
             )
         (let ((v1-86 (-> obj heap)))
           (set! (-> v1-86 current) (-> v1-86 base))
           )
         (set! (-> obj art-group) #f)
         (set! (-> obj status) 'inactive)
         (when (and (-> obj other) (-> obj other locked?))
           (unlock! (-> obj other))
           (update (-> obj other))
           )
         )
        (else
          (let ((v1-96 (-> obj heap)))
            (set! (-> v1-96 current) (-> v1-96 base))
            )
          (set! (-> obj art-group) #f)
          (set! (-> obj status) 'inactive)
          )
        )
      )
    )
  0
  )

(define *preload-spool-anims* #t)

(defmethod file-status external-art-control ((obj external-art-control) (arg0 string) (arg1 int))
  (dotimes (s3-0 2)
    (let ((v1-3 (file-status (-> obj buffer s3-0) arg0 arg1)))
      (if v1-3
          (return v1-3)
          )
      )
    )
  #f
  )

(defmethod update external-art-control ((obj external-art-control) (arg0 symbol))
  (if (nonzero? (-> obj reserve-buffer-count))
      (spool-push obj "reserved" 0 *dproc* (if (-> obj reserve-buffer)
                                               -110.0
                                               -0.5
                                               )
                  )
      )
  (dotimes (v1-5 2)
    (set! (-> obj buffer v1-5 frame-lock) #f)
    )
  (dotimes (v1-8 3)
    (set! (-> obj rec v1-8 anim-name) #f)
    )
  (dotimes (s4-0 2)
    (let ((s3-0 (-> obj rec s4-0)))
      (when (-> s3-0 name)
        (dotimes (s2-0 2)
          (when (and (file-status (-> obj buffer s2-0) (-> s3-0 name) (-> s3-0 parts)) (not (-> obj buffer s2-0 frame-lock)))
            (set! (-> obj buffer s2-0 frame-lock) #t)
            (set! (-> s3-0 anim-name) (-> obj buffer s2-0))
            (set! (-> obj buffer s2-0 pending-load-file-owner) (-> s3-0 owner))
            (set! (-> obj buffer s2-0 load-file-owner) (-> s3-0 owner))
            (set! (-> obj buffer s2-0 pending-load-file-priority) (-> s3-0 priority))
            (set! (-> obj buffer s2-0 load-file-priority) (-> s3-0 priority))
            (goto cfg-24)
            )
          )
        )
      )
    (label cfg-24)
    )
  (dotimes (s4-1 2)
    (let ((s3-1 (-> obj rec s4-1)))
      (when (and (-> s3-1 name) (not (-> s3-1 anim-name)))
        (if (and (not *preload-spool-anims*) (>= (-> s3-1 priority) 0.0))
            (goto cfg-46)
            )
        (dotimes (s2-1 2)
          (when (not (-> obj buffer s2-1 frame-lock))
            (set! (-> obj buffer s2-1 frame-lock) #t)
            (set-pending-file (-> obj buffer s2-1) (-> s3-1 name) (-> s3-1 parts) (-> s3-1 owner) (-> s3-1 priority))
            (set! (-> s3-1 anim-name) (-> obj buffer s2-1))
            (goto cfg-46)
            )
          )
        )
      )
    (label cfg-46)
    )
  (when (not (-> obj reserve-buffer))
    (let ((s4-2 (-> obj rec 0 anim-name)))
      (if (and s4-2
               (-> (the-as external-art-buffer s4-2) locked?)
               (not (string= (-> (the-as external-art-buffer s4-2) pending-load-file) "reserved"))
               (not (string= (-> (the-as external-art-buffer s4-2) other pending-load-file) "reserved"))
               )
          (set-pending-file
            (-> (the-as external-art-buffer s4-2) other)
            (the-as string #f)
            -1
            (the-as handle #f)
            100000000.0
            )
          )
      )
    )
  (dotimes (s4-3 2)
    (update (-> obj buffer s4-3))
    )
  (let ((s4-4 (-> obj queue-stream)))
    (set! (-> s4-4 length) 0)
    (dotimes (s3-2 3)
      (when (-> obj rec s3-2 name)
        (mem-copy! (&-> (-> s4-4 (-> s4-4 length)) type) (&-> (-> obj rec s3-2) type) 44)
        (+! (-> s4-4 length) 1)
        )
      )
    )
  (when (and arg0 *display-art-control*)
    (dotimes (s5-1 3)
      (let ((t9-8 format)
            (a0-27 *stdcon*)
            (a1-8 "rec ~d ~S ~D ~f ~A~%")
            (a2-5 s5-1)
            (a3-3 (-> obj rec s5-1 name))
            (t0-3 (-> obj rec s5-1 parts))
            (t1-0 (-> obj rec s5-1 priority))
            (v1-121 (handle->process (-> obj rec s5-1 owner)))
            )
        (t9-8 a0-27 a1-8 a2-5 a3-3 t0-3 t1-0 (if v1-121
                                                 (-> v1-121 name)
                                                 )
              )
        )
      )
    (dotimes (s5-2 2)
      (let ((t9-9 format)
            (a0-28 *stdcon*)
            (a1-9 "buf ~d ~C ~S ~D ~A ~A~%")
            (a2-6 s5-2)
            (a3-4 (if (-> obj buffer s5-2 locked?)
                      108
                      32
                      )
                  )
            (t0-4 (-> obj buffer s5-2 pending-load-file))
            (t1-1 (-> obj buffer s5-2 pending-load-file-part))
            (t2-5 (-> obj buffer s5-2 status))
            (v1-142 (handle->process (-> obj buffer s5-2 pending-load-file-owner)))
            )
        (t9-9 a0-28 a1-9 a2-6 a3-4 t0-4 t1-1 t2-5 (if v1-142
                                                      (-> v1-142 name)
                                                      )
              )
        )
      )
    (format *stdcon* " a: ~S~%" (-> obj active-stream))
    )
  0
  )

(defmethod none-reserved? external-art-control ((obj external-art-control))
  (zero? (-> obj reserve-buffer-count))
  )

(defmethod reserve-alloc external-art-control ((obj external-art-control))
  (cond
    ((or (nonzero? (-> obj dma-reserve-buffer-count)) (= *master-mode* 'progress))
     (set! (-> obj dma-reserve-buffer-count) 1)
     (when (and (-> *bigmap* drawing-flag) (zero? (-> *blit-displays-work* count-down)))
       (let ((v1-8 (-> obj dma-reserve-heap)))
         (set! (-> v1-8 base) (logand -64 (&+ (&+ (-> *display* frames 1 global-buf end) -252992) 63)))
         (set! (-> v1-8 current) (-> v1-8 base))
         (set! (-> v1-8 top-base) (&+ (-> v1-8 base) #x3dc00))
         (set! (-> v1-8 top) (-> v1-8 top-base))
         )
       (set! (-> *display* frames 1 global-buf end) (-> obj dma-reserve-heap base))
       (-> obj dma-reserve-heap)
       )
     )
    (else
      (set! (-> obj reserve-buffer-count) 1)
      (if (and (-> obj reserve-buffer) (not (check-busy *load-str-rpc*)))
          (-> obj reserve-buffer heap)
          )
      )
    )
  )

(defmethod reserve-free external-art-control ((obj external-art-control) (arg0 kheap))
  (cond
    ((nonzero? (-> obj dma-reserve-buffer-count))
     (set! (-> obj dma-reserve-buffer-count) 0)
     (let ((v1-3 (-> *display* frames 1 global-buf)))
       (set! (-> v1-3 end) (&-> v1-3 data-buffer (-> v1-3 allocated-length)))
       )
     )
    ((and (zero? (-> obj reserve-buffer-count)) (zero? (-> obj dma-reserve-buffer-count)))
     (format 0 "ERROR: illegal attempt to free a buffer #x~X which had not been reserved (none reserved).~%" arg0)
     )
    ((not (-> obj reserve-buffer))
     (set! (-> obj reserve-buffer-count) 0)
     0
     )
    ((= (-> obj reserve-buffer heap) arg0)
     (set-pending-file (-> obj reserve-buffer) (the-as string #f) -1 (the-as handle #f) 100000000.0)
     (update (-> obj reserve-buffer))
     (set! (-> obj reserve-buffer-count) 0)
     0
     )
    (else
      (format 0 "ERROR: illegal attempt to free a buffer #x~X which had not been reserved (buffer unknown).~%" arg0)
      )
    )
  0
  )

(defmethod clear-rec external-art-control ((obj external-art-control))
  (dotimes (v1-0 3)
    (set! (-> obj rec v1-0 type) spool-anim)
    (set! (-> obj rec v1-0 name) #f)
    (set! (-> obj rec v1-0 priority) 100000000.0)
    (set! (-> obj rec v1-0 owner) (the-as handle #f))
    )
  (set! (-> obj frame-mask) (the-as uint (-> *setting-control* user-current process-mask)))
  0
  )

(defmethod spool-push external-art-control ((obj external-art-control) (arg0 string) (arg1 int) (arg2 process) (arg3 float))
  (when (and (= arg3 -99.0) arg2)
    (let ((a0-2 (target-pos 0)))
      (set! arg3 (vector-vector-distance a0-2 (-> (the-as process-drawable arg2) root trans)))
      )
    )
  (cond
    ((and (= arg1 (-> obj rec 0 parts)) (name= arg0 (-> obj rec 0 name)))
     (if (>= arg3 (-> obj rec 0 priority))
         (return (the-as int #f))
         )
     (mem-copy! (&-> (-> obj rec) 0 type) (&-> (-> obj rec 1) type) 44)
     (mem-copy! (&-> (-> obj rec 1) type) (&-> (-> obj rec 2) type) 44)
     (set! (-> obj rec 2 name) #f)
     (set! (-> obj rec 2 owner) (the-as handle #f))
     )
    ((and (= arg1 (-> obj rec 1 parts)) (name= arg0 (-> obj rec 1 name)))
     (if (>= arg3 (-> obj rec 1 priority))
         (return (the-as int #f))
         )
     (mem-copy! (&-> (-> obj rec 1) type) (&-> (-> obj rec 2) type) 44)
     (set! (-> obj rec 2 name) #f)
     (set! (-> obj rec 2 owner) (the-as handle #f))
     )
    ((and (= arg1 (-> obj rec 2 parts)) (name= arg0 (-> obj rec 2 name)))
     (if (>= arg3 (-> obj rec 2 priority))
         (return (the-as int #f))
         )
     (set! (-> obj rec 2 name) #f)
     (set! (-> obj rec 2 owner) (the-as handle #f))
     )
    )
  (cond
    ((< arg3 (-> obj rec 0 priority))
     (mem-copy! (&-> (-> obj rec 2) type) (&-> (-> obj rec 1) type) 44)
     (mem-copy! (&-> (-> obj rec 1) type) (&-> (-> obj rec) 0 type) 44)
     (set! (-> obj rec 0 name) arg0)
     (set! (-> obj rec 0 parts) arg1)
     (set! (-> obj rec 0 priority) arg3)
     (set! (-> obj rec 0 owner) (process->handle arg2))
     )
    ((< arg3 (-> obj rec 1 priority))
     (mem-copy! (&-> (-> obj rec 2) type) (&-> (-> obj rec 1) type) 44)
     (set! (-> obj rec 1 name) arg0)
     (set! (-> obj rec 1 parts) arg1)
     (set! (-> obj rec 1 priority) arg3)
     (set! (-> obj rec 1 owner) (process->handle arg2))
     )
    ((< arg3 (-> obj rec 2 priority))
     (set! (-> obj rec 2 name) arg0)
     (set! (-> obj rec 2 parts) arg1)
     (set! (-> obj rec 2 priority) arg3)
     (set! (-> obj rec 2 owner) (process->handle arg2))
     )
    )
  0
  )

(deftype spooler-block (basic)
  ((anim             spool-anim                          :offset-assert   4)
   (idle             art-joint-anim                      :offset-assert   8)
   (exit             art-joint-anim                      :offset-assert  12)
   (break-func       (function process-drawable object)  :offset-assert  16)
   (part             int32                               :offset-assert  20)
   (part-audio-start float                               :offset-assert  24)
   (old-status       uint16                              :offset-assert  28)
   (old-pos          int32                               :offset-assert  32)
   (good-time        time-frame                          :offset-assert  40)
   (old-time         time-frame                          :offset-assert  48)
   (good-count       int32                               :offset-assert  56)
   (sid              sound-id                            :offset-assert  60)
   (real-start-time  time-frame                          :offset-assert  64)
   (paused?          symbol                              :offset-assert  72)
   )
  :method-count-assert 9
  :size-assert         #x4c
  :flag-assert         #x90000004c
  (:methods
    (new (symbol type art-joint-anim (function process-drawable symbol)) _type_ 0)
    )
  )


(defbehavior ja-play-spooled-anim process-drawable ((arg0 spool-anim) (arg1 art-joint-anim) (arg2 art-joint-anim) (arg3 (function process-drawable symbol)))
  (local-vars (v0-59 int) (sv-176 int))
  (let ((s2-0 arg2)
        (s1-0 arg3)
        (gp-0 (new 'stack 'spooler-block arg2 arg3))
        )
    (let ((s5-0 gp-0))
      (set! (-> s5-0 anim) arg0)
      (set! (-> s5-0 idle) arg1)
      (set! (-> s5-0 exit) s2-0)
      (set! (-> s5-0 break-func) s1-0)
      (set! (-> s5-0 part-audio-start) -17.0)
      (set! (-> s5-0 old-status) (the-as uint (-> self skel status)))
      (set! (-> s5-0 old-pos) -2)
      (set! (-> s5-0 sid) (new-sound-id))
      (set! (-> s5-0 paused?) #f)
      )
    (let ((v1-7
            (lookup-gui-connection *gui-control* self (gui-channel art-load) (-> gp-0 anim name) (new 'static 'sound-id))
            )
          )
      (if v1-7
          (set! (-> gp-0 sid) (-> v1-7 id))
          )
      )
    (if (!= self *target*)
        (send-event *target* 'movie)
        )
    (backup-load-state-and-set-cmds *load-state* (-> gp-0 anim command-list))
    (logior! (-> self skel status) (joint-control-status sync-math spooling spooling-not-last-block))
    (talker-surpress!)
    (apply-settings *setting-control*)
    (when (or (and (-> *setting-control* user-current spooling)
                   (or (< 2 (-> gp-0 anim parts))
                       (not (string= (-> *setting-control* user-current spool-anim name) (-> gp-0 anim name)))
                       )
                   )
              (logtest? (-> *art-control* frame-mask) 28)
              (!= *master-mode* 'game)
              )
      (cond
        ((-> gp-0 idle)
         (when (!= (ja-group) (-> gp-0 idle))
           (ja-channel-push! 1 (seconds 0.05))
           (ja :group! (-> gp-0 idle) :num! min)
           )
         )
        (else
          (ja-channel-set! 0)
          )
        )
      (while (or (and (-> *setting-control* user-current spooling)
                      (or (< 2 (-> gp-0 anim parts))
                          (not (string= (-> *setting-control* user-current spool-anim name) (-> gp-0 anim name)))
                          )
                      )
                 (logtest? (-> *art-control* frame-mask) 28)
                 (!= *master-mode* 'game)
                 )
        (format #t "WARNING: ---------------------> loader stall on lock~%")
        (if ((-> gp-0 break-func) self)
            (goto cfg-130)
            )
        (gui-control-method-12
          *gui-control*
          self
          (gui-channel art-load)
          (gui-action queue)
          (-> gp-0 anim name)
          (-> gp-0 part)
          -9.0
          (-> gp-0 sid)
          )
        (suspend)
        (if (-> gp-0 idle)
            (ja :num! (loop!))
            )
        )
      )
    (set-setting! 'spooling (process->ppointer self) 0.0 0)
    (set-setting! 'spool-anim (-> gp-0 anim) 0.0 0)
    (apply-settings *setting-control*)
    (set! (-> gp-0 old-time) (current-time))
    (while (< (-> gp-0 part) (-> gp-0 anim parts))
      (when (> (-> gp-0 part) 0)
        (while (let ((v1-99 (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))))
                 (not (or (= v1-99 'active) (= v1-99 'locked)))
                 )
          (if ((-> gp-0 break-func) self)
              (goto cfg-130)
              )
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-0 anim name)
            (+ (-> gp-0 part) -1)
            -20.0
            (-> gp-0 sid)
            )
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-0 anim name)
            (-> gp-0 part)
            -10.0
            (-> gp-0 sid)
            )
          (when (and (not (-> gp-0 paused?)) (< (-> *setting-control* user-current movie-skip-frame) 0.0))
            (format
              #t
              "WARNING: ---------------------> loader pre stall on art ~S ~D ~A~%"
              (-> gp-0 anim name)
              (-> gp-0 part)
              (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))
              )
            (set! (-> gp-0 paused?) #t)
            (if (nonzero? (-> gp-0 part))
                (sound-pause (-> gp-0 sid))
                )
            )
          (suspend)
          )
        )
      (gui-control-method-12
        *gui-control*
        self
        (gui-channel art-load)
        (gui-action queue)
        (-> gp-0 anim name)
        (-> gp-0 part)
        -20.0
        (-> gp-0 sid)
        )
      (update *gui-control* #f)
      (update *art-control* #f)
      (gui-control-method-12
        *gui-control*
        self
        (gui-channel art-load)
        (gui-action queue)
        (-> gp-0 anim name)
        (-> gp-0 part)
        -20.0
        (-> gp-0 sid)
        )
      (when (!= (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part)) 'active)
        (cond
          ((-> gp-0 idle)
           (when (!= (ja-group) (-> gp-0 idle))
             (ja-channel-set! 1)
             (ja :group! (-> gp-0 idle) :num! min)
             )
           )
          (else
            (ja-channel-set! 0)
            )
          )
        (while (!= (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part)) 'active)
          (if ((-> gp-0 break-func) self)
              (goto cfg-130)
              )
          (gui-control-method-12
            *gui-control*
            self
            (gui-channel art-load)
            (gui-action queue)
            (-> gp-0 anim name)
            (-> gp-0 part)
            -20.0
            (-> gp-0 sid)
            )
          (when (not (-> gp-0 paused?))
            (format
              #t
              "WARNING: ---------------------> loader stall on art ~S ~D ~A~%"
              (-> gp-0 anim name)
              (-> gp-0 part)
              (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))
              )
            (set! (-> gp-0 paused?) #t)
            (if (nonzero? (-> gp-0 part))
                (sound-pause (-> gp-0 sid))
                )
            )
          (suspend)
          (if (-> gp-0 idle)
              (ja :num! (loop!))
              )
          )
        )
      (when (-> gp-0 paused?)
        (set! (-> gp-0 paused?) #f)
        (sound-continue (-> gp-0 sid))
        (format
          #t
          "WARNING: ---------------------> loader release lock on art ~S ~D ~A~%"
          (-> gp-0 anim name)
          (-> gp-0 part)
          (file-status *art-control* (-> gp-0 anim name) (-> gp-0 part))
          )
        )
      (gui-control-method-12
        *gui-control*
        self
        (gui-channel art-load)
        (gui-action queue)
        (-> gp-0 anim name)
        (-> gp-0 part)
        -20.0
        (-> gp-0 sid)
        )
      (let ((s5-8 (get-art-by-name (-> self draw art-group) (the-as string (-> gp-0 anim anim-name)) art-joint-anim)))
        (cond
          (s5-8
            (ja-channel-set! 1)
            (ja-no-eval :group! s5-8 :num! (seek! (the float (+ (-> s5-8 frames num-frames) -1))) :frame-num 0.0)
            (when (zero? (-> gp-0 part))
              (str-play-async (-> gp-0 anim name) (-> gp-0 sid))
              (set! (-> *art-control* active-stream) (-> gp-0 anim name))
              )
            (let* ((f30-0 (* 0.05859375 (-> s5-8 speed)))
                   (f28-0 (+ (-> gp-0 part-audio-start) (/ (the float (+ (-> s5-8 frames num-frames) -1)) f30-0)))
                   )
              (set! sv-176 (current-str-pos (-> gp-0 sid)))
              (set! (-> gp-0 good-time) (current-time))
              (until (>= (the float v0-59) f28-0)
                (if (= (-> self skel root-channel 0) (-> self skel channel))
                    (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
                    )
                (if (or ((-> gp-0 break-func) self)
                        (and (<= sv-176 0) (>= (- (current-time) (-> gp-0 good-time)) (seconds 4)))
                        (and (< 300 (-> gp-0 good-count)) (<= sv-176 0))
                        )
                    (goto cfg-130)
                    )
                (gui-control-method-12
                  *gui-control*
                  self
                  (gui-channel art-load)
                  (gui-action queue)
                  (-> gp-0 anim name)
                  (-> gp-0 part)
                  -20.0
                  (-> gp-0 sid)
                  )
                (if (< (+ (-> gp-0 part) 1) (-> gp-0 anim parts))
                    (gui-control-method-12
                      *gui-control*
                      self
                      (gui-channel art-load)
                      (gui-action queue)
                      (-> gp-0 anim name)
                      (+ (-> gp-0 part) 1)
                      -10.0
                      (-> gp-0 sid)
                      )
                    (logclear! (-> self skel status) (joint-control-status spooling-not-last-block))
                    )
                (execute-commands-up-to *load-state* (ja-aframe-num 0))
                (cond
                  ((and (< (-> gp-0 old-pos) sv-176) (< -1 sv-176))
                   (+! (-> gp-0 good-count) (- (current-time) (-> self clock old-frame-counter)))
                   (set! (-> gp-0 good-time) (current-time))
                   )
                  (else
                    0
                    )
                  )
                (set! (-> gp-0 old-pos) sv-176)
                (set! (-> gp-0 old-time) (current-time))
                (suspend)
                (let* ((f26-0 (* (- (the float (current-str-pos (-> gp-0 sid))) (-> gp-0 part-audio-start)) f30-0))
                       (f0-16 (if (str-id-is-playing? (the-as int (-> gp-0 sid)))
                                  (fmax 0.0 (fmin f26-0 (the float (+ (-> (ja-group) frames num-frames) -1))))
                                  (fmax 0.0 (fmin (ja-frame-num 0) (the float (+ (-> (ja-group) frames num-frames) -1))))
                                  )
                              )
                       )
                  (ja-no-eval :num! (seek!) :frame-num f0-16)
                  )
                (set! v0-59 (current-str-pos (-> gp-0 sid)))
                (set! sv-176 v0-59)
                )
              (set! (-> gp-0 part-audio-start) f28-0)
              )
            (logclear! (-> self skel status) (joint-control-status valid-spooled-frame))
            )
          (else
            (format
              0
              "ERROR: <asg> ~A in spool anim loop for ~A ~D, but not loaded.~%" ;; fixed missing %.
              self
              (-> gp-0 anim name)
              (-> gp-0 part)
              )
            (goto cfg-130)
            )
          )
        )
      (+! (-> gp-0 part) 1)
      )
    (+! (-> gp-0 part) -1)
    (label cfg-130)
    (ja-abort-spooled-anim (-> gp-0 anim) (-> gp-0 exit) (-> gp-0 part))
    )
  0
  )

(defbehavior ja-abort-spooled-anim process-drawable ((arg0 spool-anim) (arg1 art-joint-anim) (arg2 int))
  (let ((s3-0 (new 'static 'sound-id)))
    (let ((v1-1
            (lookup-gui-connection *gui-control* self (gui-channel art-load) (-> arg0 name) (new 'static 'sound-id))
            )
          )
      (when v1-1
        (set! s3-0 (-> v1-1 id))
        (set! (-> v1-1 action) (gui-action abort))
        )
      )
    (if (zero? s3-0)
        (return (the-as int #f))
        )
    (str-play-stop (-> arg0 name) s3-0)
    )
  (restore-load-state-and-cleanup *load-state*)
  (set! (-> *art-control* active-stream) #f)
  (logclear! (-> self skel status) (joint-control-status spooling spooling-not-last-block))
  (if (not (logtest? (-> self skel status) (joint-control-status sync-math)))
      (logclear! (-> self skel status) (joint-control-status sync-math))
      )
  (cond
    ((and arg1 (>= arg2 0))
     (ja-channel-push! 1 (seconds 0.03))
     (set! (-> self skel root-channel 0 frame-group) arg1)
     (while (!= (-> self skel root-channel 0) (-> self skel channel))
       (gui-control-method-12
         *gui-control*
         self
         (gui-channel art-load)
         (gui-action queue)
         (-> arg0 name)
         arg2
         -20.0
         (new 'static 'sound-id)
         )
       (suspend)
       (ja :num! (seek!))
       )
     )
    (else
      (ja-channel-set! 0)
      )
    )
  (remove-setting! 'spooling)
  (remove-setting! 'spool-anim)
  0
  )


(defmethod print gui-connection ((obj gui-connection))
  (format #t "#<gc ~12S ~2D ~6D ~6,,0f ~7S ~8S " (-> obj name)
                                                 (-> obj anim-part)
                                                 (-> obj id)
                                                 (-> obj priority)
                                                 (enum->string gui-channel (-> obj channel))
                                                 (enum->string gui-action (-> obj action)))
  (format #t " ~6S <@ #x~A>" (enum->string gui-status (get-status *gui-control* (-> obj id))) obj)
  obj
  )

(defmethod channel-id-set! gui-control ((obj gui-control) (arg0 gui-connection) (arg1 sound-id))
  (set! (-> obj ids (-> arg0 channel)) arg1)
  0
  )

(defmethod lookup-gui-connection gui-control ((obj gui-control) (arg0 process) (arg1 gui-channel) (arg2 string) (arg3 sound-id))
  (let ((s1-0 (the-as gui-connection (-> obj engine alive-list next0))))
    (-> obj engine)
    (let ((s0-0 (-> s1-0 next0)))
      (while (!= s1-0 (-> obj engine alive-list-end))
        (if (and (or (= arg1 (gui-channel none)) (= (-> s1-0 channel) arg1))
                 (or (not arg0) (= (-> arg0 type) scene-player) (= arg0 (get-process s1-0)))
                 (or (not arg2) (string= arg2 (-> s1-0 name)))
                 (or (zero? arg3) (= (-> s1-0 id) arg3))
                 )
            (return s1-0)
            )
        (set! s1-0 (the-as gui-connection s0-0))
        (-> obj engine)
        (set! s0-0 (-> s0-0 next0))
        )
      )
    )
  (countdown (s1-1 32)
    (let ((s0-1 (-> obj connections s1-1)))
      (if (and (nonzero? (-> s0-1 id))
               (or (= arg1 (gui-channel none)) (= (-> s0-1 channel) arg1))
               (and (or (not arg0) (= (-> arg0 type) scene-player) (= arg0 (handle->process (-> s0-1 handle))))
                    (or (not arg2) (string= arg2 (-> s0-1 name)))
                    (or (zero? arg3) (= (-> s0-1 id) arg3))
                    )
               )
          (return s0-1)
          )
      )
    )
  (the-as gui-connection #f)
  )

;; WARN: Return type mismatch int vs sound-id.
(defmethod lookup-gui-connection-id gui-control ((obj gui-control) (arg0 string) (arg1 gui-channel) (arg2 gui-action))
  (let ((s2-0 (the-as gui-connection (-> obj engine alive-list next0))))
    (-> obj engine)
    (let ((s1-0 (-> s2-0 next0)))
      (while (!= s2-0 (-> obj engine alive-list-end))
        (if (and (or (= arg1 (gui-channel none)) (= arg1 (-> s2-0 channel)))
                 (or (= arg2 (gui-action none)) (= arg2 (-> s2-0 action)))
                 (or (not arg0) (string= arg0 (-> s2-0 name)))
                 )
            (return (-> s2-0 id))
            )
        (set! s2-0 (the-as gui-connection s1-0))
        (-> obj engine)
        (set! s1-0 (-> s1-0 next0))
        )
      )
    )
  (countdown (s2-1 32)
    (let ((s1-1 (-> obj connections s2-1)))
      (if (and (nonzero? (-> s1-1 id))
               (or (= arg1 (gui-channel none)) (= arg1 (-> s1-1 channel)))
               (or (= arg2 (gui-action none)) (= arg2 (-> s1-1 action)))
               (or (not arg0) (string= arg0 (-> s1-1 name)))
               )
          (return (-> s1-1 id))
          )
      )
    )
  (the-as sound-id 0)
  )

(defmethod set-falloff! gui-control ((obj gui-control) (arg0 sound-id) (arg1 symbol) (arg2 int) (arg3 int) (arg4 int))
  (when (nonzero? arg0)
    (let ((v1-2 (lookup-gui-connection *gui-control* (the-as process #f) (gui-channel none) (the-as string #f) arg0)))
      (when v1-2
        (if arg1
            (logior! (-> v1-2 flags) (gui-connection-flags gcf1))
            )
        (when (>= arg2 0)
          (logior! (-> v1-2 flags) (gui-connection-flags fo-min))
          (set! (-> v1-2 fo-min) arg2)
          )
        (when (>= arg3 0)
          (logior! (-> v1-2 flags) (gui-connection-flags fo-max))
          (set! (-> v1-2 fo-max) arg3)
          )
        (when (>= arg4 0)
          (logior! (-> v1-2 flags) (gui-connection-flags fo-curve))
          (set! (-> v1-2 fo-curve) arg4)
          )
        v1-2
        )
      )
    )
  )

;; WARN: Return type mismatch object vs symbol.
;; WARN: disable def twice: 34. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod gui-control-method-18 gui-control ((obj gui-control) (arg0 gui-channel))
  (let ((v1-0 arg0))
    (the-as
      symbol
      (cond
        ((or (= v1-0 (gui-channel message)) (= v1-0 (gui-channel notice)) (= v1-0 (gui-channel notice-low)))
         (not (or (logtest? (-> *art-control* frame-mask) 28) (!= *master-mode* 'game)))
         )
        ((= v1-0 (gui-channel query))
         (and (not (or (logtest? (-> *art-control* frame-mask) 28) (!= *master-mode* 'game)))
              (and *target* (not (logtest? (-> *target* focus-status) (focus-status dead hit))))
              )
         )
        (else
          #t
          )
        )
      )
    )
  )

(defmethod handle-command gui-control ((obj gui-control) (arg0 gui-channel) (arg1 gui-channel) (arg2 symbol) (arg3 gui-connection))
  (let ((s5-0 (-> obj ids arg1)))
    (cond
      ((nonzero? s5-0)
       (case arg2
         (('wait)
          (if (nonzero? (get-status obj s5-0))
              (return #f)
              )
          )
         (('stop 'priority-stop)
          (when (nonzero? (-> obj ids arg1))
            (let ((s2-0 (lookup-gui-connection obj (the-as process #f) arg1 (the-as string #f) s5-0)))
              (when (and s2-0 (or (= arg2 'priority) (= s2-0 arg3) (and arg3 (< (-> arg3 priority) (-> s2-0 priority)))))
                (stop-str obj s2-0)
                (cond
                  ((= (shr (the-as int arg1) 4) 5)
                   (set! (-> obj times arg1)
                         (the-as time-frame (max (-> obj times arg1) (+ (-> *display* base-clock frame-counter) (seconds 0.1))))
                         )
                   (set! (-> s2-0 action) (gui-action hidden))
                   )
                  ((= arg1 (gui-channel query))
                   (set! (-> s2-0 action) (gui-action play))
                   )
                  (else
                    (set! (-> s2-0 action) (gui-action hidden))
                    )
                  )
                )
              )
            )
          (if (nonzero? (get-status obj s5-0))
              (return #f)
              )
          )
         (('hide)
          (let ((v1-34 (lookup-gui-connection obj (the-as process #f) arg1 (the-as string #f) s5-0)))
            (when (and v1-34 (!= (-> v1-34 action) 8))
              (set-action!
                obj
                (gui-action hide)
                s5-0
                (gui-channel none)
                (gui-action none)
                (the-as string #f)
                (the-as (function gui-connection symbol) #f)
                (the-as process #f)
                )
              (set! (-> obj times arg1)
                    (the-as time-frame (max (-> obj times arg1) (+ (-> *display* base-clock frame-counter) (seconds 0.1))))
                    )
              )
            )
          (if (nonzero? (get-status obj s5-0))
              (return #f)
              )
          )
         )
       )
      ((< (-> *display* base-clock frame-counter) (-> obj times arg1))
       (if (= arg2 'wait)
           (return #f)
           )
       )
      )
    )
  #t
  )

(defmethod handle-command-list gui-control ((obj gui-control) (arg0 gui-channel) (arg1 gui-connection))
  (local-vars (sv-16 int) (sv-32 int) (sv-48 int))
  (let ((gp-0 #t))
    (cond
      ((or (not (gui-control-method-18 obj arg0)) (< (-> *display* base-clock frame-counter) (-> obj times arg0)))
       #f
       )
      ((not (null? (-> obj cmd arg0)))
       (let* ((s2-0 (-> obj cmd arg0))
              (v1-9 (car s2-0))
              )
         (while (not (null? s2-0))
           (let ((a2-1 (the-as gui-channel (/ (the-as int (car v1-9)) 8)))
                 (s1-0 (cdr v1-9))
                 )
             (case a2-1
               (((gui-channel hud))
                (let ((s0-0 80))
                  (set! sv-16 90)
                  (while (>= (the-as uint sv-16) (the-as uint s0-0))
                    (if (not (handle-command obj arg0 (the-as gui-channel s0-0) (the-as symbol s1-0) arg1))
                        (set! gp-0 #f)
                        )
                    (+! s0-0 1)
                    )
                  )
                )
               (((gui-channel screen))
                (let ((s0-1 66))
                  (set! sv-32 70)
                  (while (>= (the-as uint sv-32) (the-as uint s0-1))
                    (if (not (handle-command obj arg0 (the-as gui-channel s0-1) (the-as symbol s1-0) arg1))
                        (set! gp-0 #f)
                        )
                    (+! s0-1 1)
                    )
                  )
                )
               (((gui-channel voice))
                (let ((s0-2 18))
                  (set! sv-48 32)
                  (while (>= (the-as uint sv-48) (the-as uint s0-2))
                    (if (not (handle-command obj arg0 (the-as gui-channel s0-2) (the-as symbol s1-0) arg1))
                        (set! gp-0 #f)
                        )
                    (+! s0-2 1)
                    )
                  )
                )
               (else
                 (if (not (handle-command obj arg0 a2-1 (the-as symbol s1-0) arg1))
                     (set! gp-0 #f)
                     )
                 )
               )
             )
           (set! s2-0 (cdr s2-0))
           (set! v1-9 (car s2-0))
           )
         )
       gp-0
       )
      )
    )
  )

;; WARN: Return type mismatch int vs gui-status.
(defmethod get-status gui-control ((obj gui-control) (arg0 sound-id))
  (let ((gp-0 (the-as gui-connection #f)))
    (if (zero? arg0)
        (return (gui-status unknown))
        )
    (let ((v1-4 (-> obj engine alive-list next0)))
      (-> obj engine)
      (let ((a0-3 (-> v1-4 next0)))
        (while (!= v1-4 (-> obj engine alive-list-end))
          (when (= arg0 (-> (the-as gui-connection v1-4) id))
            (set! gp-0 (the-as gui-connection v1-4))
            (goto cfg-15)
            )
          (set! v1-4 a0-3)
          (-> obj engine)
          (set! a0-3 (-> a0-3 next0))
          )
        )
      )
    #t
    (countdown (v1-10 32)
      (let ((a0-7 (-> obj connections v1-10)))
        (when (= arg0 (-> a0-7 id))
          (set! gp-0 a0-7)
          (goto cfg-15)
          )
        )
      )
    (label cfg-15)
    (the-as
      gui-status
      (cond
        ((= (-> gp-0 channel) (gui-channel movie))
         (cond
           ((= (-> gp-0 id) (-> obj ids (-> gp-0 channel)))
            3
            )
           ((handle-command-list obj (-> gp-0 channel) gp-0)
            2
            )
           (else
             1
             )
           )
         )
        ((let ((v1-22 (shr (the-as int (-> gp-0 channel)) 4)))
           (or (= v1-22 1) (= v1-22 2))
           )
         (case (-> gp-0 action)
           (((gui-action queue) (gui-action play) (gui-action playing) (gui-action fade) (gui-action stop))
            (cond
              (gp-0
                (dotimes (s4-0 4)
                  (when (and (string-charp= (-> gp-0 name) (the-as (pointer uint8) (-> *sound-iop-info* stream-name s4-0)))
                             (or (= (-> gp-0 id) (-> *sound-iop-info* stream-id s4-0)) (zero? (-> *sound-iop-info* stream-id s4-0)))
                             (logtest? (-> *sound-iop-info* stream-status s4-0) (stream-status ststatus-one ststatus-six))
                             (if (and (>= (the-as uint (-> gp-0 channel)) (the-as uint 16))
                                      (>= (the-as uint 17) (the-as uint (-> gp-0 channel)))
                                      )
                                 (= (file-status *art-control* (-> gp-0 name) (the-as int (-> gp-0 anim-part))) 'active)
                                 #t
                                 )
                             )
                    (cond
                      ((logtest? (-> *sound-iop-info* stream-status s4-0) (stream-status ststatus-four))
                       (return (gui-status active))
                       )
                      ((logtest? (-> *sound-iop-info* stream-status s4-0) (stream-status ststatus-nine))
                       (return (gui-status stop))
                       )
                      ((or (= (-> gp-0 id) (-> obj ids (-> gp-0 channel))) (handle-command-list obj (-> gp-0 channel) gp-0))
                       (return (gui-status ready))
                       )
                      (else
                        (return (gui-status pending))
                        )
                      )
                    (the-as none 0)
                    )
                  )
                1
                )
              (else
                0
                )
              )
            )
           (else
             0
             )
           )
         )
        ((= (shr (the-as int (-> gp-0 channel)) 4) 5)
         (cond
           ((= (-> gp-0 id) (-> obj ids (-> gp-0 channel)))
            (if (or (= (-> gp-0 action) (gui-action hide)) (= (-> gp-0 action) (gui-action hidden)))
                4
                3
                )
            )
           ((handle-command-list obj (-> gp-0 channel) gp-0)
            2
            )
           (else
             1
             )
           )
         )
        (else
          (case (shr (the-as int (-> gp-0 channel)) 4)
            ((4 5)
             (cond
               ((= (-> gp-0 id) (-> obj ids (-> gp-0 channel)))
                3
                )
               ((handle-command-list obj (-> gp-0 channel) gp-0)
                2
                )
               (else
                 1
                 )
               )
             )
            (else
              0
              )
            )
          )
        )
      )
    )
  )

(defmethod set-action! gui-control ((obj gui-control)
                                  (arg0 gui-action)
                                  (arg1 sound-id)
                                  (arg2 gui-channel)
                                  (arg3 gui-action)
                                  (arg4 string)
                                  (arg5 (function gui-connection symbol))
                                  (arg6 process)
                                  )
  (local-vars (sv-16 gui-action) (sv-17 gui-action) (sv-20 string) (sv-24 (function gui-connection symbol)))
  (set! sv-16 arg0)
  (set! sv-17 arg3)
  (set! sv-20 arg4)
  (set! sv-24 arg5)
  (let ((s1-0 (the-as gui-connection (-> obj engine alive-list next0))))
    (-> obj engine)
    (let ((s0-0 (-> s1-0 next0)))
      (while (!= s1-0 (-> obj engine alive-list-end))
        (when (and (or (= arg1 1) (= arg1 (-> s1-0 id)))
                   (or (= arg2 (gui-channel none)) (= arg2 (-> s1-0 channel)))
                   (or (= sv-17 (gui-action none)) (= sv-17 (-> s1-0 action)))
                   (or (not sv-20) (string= sv-20 (-> s1-0 name)))
                   (or (not arg5) (arg5 s1-0))
                   (or (not arg6) (= arg6 (get-process s1-0)))
                   )
          (cond
            ((and (= sv-16 (gui-action hide)) (!= (-> obj ids (-> s1-0 channel)) (-> s1-0 id)))
             (set! (-> s1-0 action) (gui-action hidden))
             )
            ((and (= sv-16 (gui-action play)) (= (-> s1-0 action) (gui-action playing)))
             )
            (else
              (set! (-> s1-0 action) sv-16)
              ;; pc port note : fixed naughty dog bug here. was 'play instead of (gui-action play)
              (if (and (= sv-16 (gui-action play)) (handle-command-list obj (-> s1-0 channel) s1-0))
                  (channel-id-set! obj s1-0 (-> s1-0 id))
                  )
              )
            )
          )
        (set! s1-0 (the-as gui-connection s0-0))
        (-> obj engine)
        (set! s0-0 (-> s0-0 next0))
        )
      )
    )
  0
  )

;; WARN: Return type mismatch int vs sound-id.
(defmethod add-process gui-control ((obj gui-control)
                                  (arg0 process)
                                  (arg1 gui-channel)
                                  (arg2 gui-action)
                                  (arg3 string)
                                  (arg4 float)
                                  (arg5 time-frame)
                                  )
  (local-vars
    (sv-16 int)
    (sv-20 gui-connection)
    (sv-32 gui-connection)
    (sv-48 gui-connection)
    (sv-64 gui-connection)
    (sv-80 int)
    )
  (set! sv-32 (the-as gui-connection #f))
  (set! sv-48 (the-as gui-connection (-> obj engine alive-list next0)))
  (-> obj engine)
  (set! sv-64 (the-as gui-connection (-> sv-48 next0)))
  (while (!= sv-48 (-> obj engine alive-list-end))
    (when (and (= arg1 (-> (the-as gui-connection sv-48) channel))
               (string= arg3 (-> (the-as gui-connection sv-48) name))
               (= (get-process sv-48) arg0)
               )
      (set! sv-32 (the-as gui-connection sv-48))
      (goto cfg-12)
      )
    (set! sv-48 (the-as gui-connection sv-64))
    (-> obj engine)
    (set! sv-64 (the-as gui-connection (-> sv-64 next0)))
    )
  (label cfg-12)
  (when (not sv-32)
    (set! sv-16 0)
    (set! sv-80 32)
    (while (nonzero? sv-80)
      (set! sv-80 (+ sv-80 -1))
      (set! sv-20 (-> obj connections sv-80))
      (if (and (nonzero? (-> sv-20 id))
               (= arg1 (-> sv-20 channel))
               (string= arg3 (-> sv-20 name))
               (>= (-> sv-20 priority) -1.0)
               )
          (set! sv-16 (the-as int (-> sv-20 id)))
          )
      )
    (if (zero? sv-16)
        (set! sv-16 (the-as int (new-sound-id)))
        )
    (set! sv-32 (the-as gui-connection (add-connection (-> obj engine) arg0 arg4 0 arg3 sv-16)))
    sv-32
    )
  (the-as sound-id (cond
                     (sv-32
                       (set! (-> sv-32 priority) arg4)
                       (set! (-> sv-32 channel) arg1)
                       (set! (-> sv-32 action) arg2)
                       (set! (-> sv-32 param2) (the-as int arg3))
                       (set! (-> sv-32 hold-time) arg5)
                       (set! (-> sv-32 flags) (gui-connection-flags gcf0))
                       (set! (-> sv-32 fade) (the-as uint 0))
                       (the-as int (-> (the-as gui-connection sv-32) id))
                       )
                     (else
                       (format 0 "ERROR: could not connection ~A to gui engine.~%" arg0)
                       0
                       )
                     )
          )
  )

(defmethod remove-process gui-control ((obj gui-control) (arg0 process) (arg1 gui-channel))
  (let ((s3-0 (the-as gui-connection (-> obj engine alive-list next0))))
    (-> obj engine)
    (let ((s2-0 (-> s3-0 next0)))
      (while (!= s3-0 (-> obj engine alive-list-end))
        (if (and (= arg1 (-> s3-0 channel)) (= arg0 (get-process s3-0)))
            (move-to-dead s3-0)
            )
        (set! s3-0 (the-as gui-connection s2-0))
        (-> obj engine)
        (set! s2-0 (-> s2-0 next0))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs sound-id.
(defmethod gui-control-method-12 gui-control ((obj gui-control)
                                            (arg0 process)
                                            (arg1 gui-channel)
                                            (arg2 gui-action)
                                            (arg3 string)
                                            (arg4 int)
                                            (arg5 float)
                                            (arg6 sound-id)
                                            )
  (local-vars
    (sv-16 gui-connection)
    (sv-20 int)
    (sv-24 gui-connection)
    (sv-28 process-drawable)
    (sv-32 int)
    (sv-48 sound-id)
    )
  (set! sv-48 arg6)
  (set! sv-16 (the-as gui-connection #f))
  (set! sv-20 0)
  (set! sv-32 32)
  (while (nonzero? sv-32)
    (set! sv-32 (+ sv-32 -1))
    (set! sv-24 (-> obj connections sv-32))
    (when (and (nonzero? (-> sv-24 id))
               (= arg1 (-> sv-24 channel))
               (let ((v1-14 (handle->process (-> sv-24 handle))))
                 (and (or (= v1-14 arg0) (= (-> arg0 type) scene-player) (and v1-14 (= (-> v1-14 type) scene-player)))
                      (and (string= arg3 (-> sv-24 name)) (= arg4 (-> sv-24 anim-part)))
                      )
                 )
               )
      (when (< (-> sv-24 priority) arg5)
        (set! (-> sv-24 time-stamp) (-> obj update-time))
        (return (-> sv-24 id))
        )
      (set! sv-16 sv-24)
      (goto cfg-44)
      )
    )
  (countdown (v1-33 32)
    (let ((a0-15 (-> obj connections v1-33)))
      (when (or (zero? (-> a0-15 id)) (not (handle->process (-> a0-15 handle))))
        (set! sv-16 a0-15)
        (set! (-> sv-16 param3) 0)
        (set! (-> sv-16 flags) (gui-connection-flags))
        (goto cfg-44)
        )
      )
    )
  (label cfg-44)
  (the-as sound-id (cond
                     (sv-16
                       (when (zero? (-> (the-as gui-connection sv-16) id))
                         (when (zero? sv-20)
                           (let ((v1-46 (lookup-gui-connection obj arg0 arg1 arg3 (new 'static 'sound-id))))
                             (if v1-46
                                 (set! sv-20 (the-as int (-> v1-46 id)))
                                 )
                             )
                           )
                         (if (zero? sv-20)
                             (set! sv-20 (the-as int sv-48))
                             )
                         (set! (-> sv-16 param3) (if (nonzero? sv-20)
                                                     sv-20
                                                     (the-as int (new-sound-id))
                                                     )
                               )
                         )
                       (when (= arg5 -99.0)
                         (let ((s2-1 arg0))
                           (set! sv-28 (if (type? s2-1 process-drawable)
                                           (the-as process-drawable s2-1)
                                           )
                                 )
                           )
                         (set! arg5 (if sv-28
                                        (vector-vector-distance (target-pos 0) (-> sv-28 root trans))
                                        -1.0
                                        )
                               )
                         )
                       (set! (-> sv-16 time-stamp) (-> obj update-time))
                       (set! (-> sv-16 handle) (process->handle arg0))
                       (set! (-> sv-16 priority) arg5)
                       (set! (-> sv-16 channel) arg1)
                       (set! (-> sv-16 action) arg2)
                       (set! (-> sv-16 anim-part) (the-as uint arg4))
                       (set! (-> sv-16 param2) (the-as int arg3))
                       (set! (-> sv-16 fade) (the-as uint 0))
                       (the-as int (-> (the-as gui-connection sv-16) id))
                       )
                     (else
                       0
                       )
                     )
          )
  )

(defmethod gui-control-method-21 gui-control ((obj gui-control) (arg0 gui-connection) (arg1 vector))
  (case (shr (the-as int (-> arg0 channel)) 4)
    ((1 2)
     (let ((s5-0 (-> obj spool-connections)))
       (case (-> arg0 action)
         (((gui-action queue) (gui-action play) (gui-action playing) (gui-action fade))
          (let ((f30-0 (-> arg0 priority)))
            (when (= f30-0 -99.0)
              (let* ((s2-0 (get-process arg0))
                     (v1-10 (if (type? s2-0 process-drawable)
                                (the-as process-drawable s2-0)
                                )
                            )
                     )
                (set! f30-0 (cond
                              ((= (-> arg0 id) (-> obj ids (-> arg0 channel)))
                               -1.0
                               )
                              (v1-10
                                (vector-vector-distance arg1 (-> v1-10 root trans))
                                )
                              (else
                                -1.0
                                )
                              )
                      )
                )
              )
            (dotimes (s4-1 4)
              (cond
                ((>= (-> s5-0 s4-1 priority) f30-0)
                 (let ((s3-1 s4-1))
                   (while (< s3-1 4)
                     (when (= (-> s5-0 s3-1 id) (-> arg0 id))
                       (let ((s2-1 s3-1))
                         (while (< s2-1 3)
                           (mem-copy! (the-as pointer (-> s5-0 s2-1)) (the-as pointer (-> s5-0 (+ s2-1 1))) 48)
                           (+! s2-1 1)
                           )
                         )
                       (set! (-> s5-0 3 param2) (the-as int ""))
                       (set! (-> s5-0 3 priority) 100000000.0)
                       )
                     (+! s3-1 1)
                     )
                   )
                 (let ((s3-2 3))
                   (while (!= s3-2 s4-1)
                     (mem-copy! (the-as pointer (-> s5-0 s3-2)) (the-as pointer (-> s5-0 (+ s3-2 -1))) 48)
                     (+! s3-2 -1)
                     )
                   )
                 (mem-copy! (the-as pointer (-> s5-0 s4-1)) (the-as pointer arg0) 48)
                 (set! (-> s5-0 s4-1 priority) f30-0)
                 (goto cfg-42)
                 )
                ((= (-> s5-0 s4-1 id) (-> arg0 id))
                 (goto cfg-42)
                 )
                )
              )
            )
          )
         )
       )
     )
    )
  (label cfg-42)
  0
  )

(defmethod stop-str gui-control ((obj gui-control) (arg0 gui-connection))
  (case (shr (the-as int (-> arg0 channel)) 4)
    ((1 2)
     (if (= (get-status obj (-> arg0 id)) (gui-status active))
         (str-play-stop (-> arg0 name) (-> arg0 id))
         )
     )
    )
  (if (= (-> obj ids (-> arg0 channel)) (-> arg0 id))
      (channel-id-set! obj arg0 (new 'static 'sound-id))
      )
  0
  )

;; pc port note : added for debugging
(#when PC_PORT
(define *gui-kick-str* #f))

(defmethod gui-control-method-22 gui-control ((obj gui-control) (arg0 gui-connection) (arg1 process) (arg2 symbol))
  (local-vars (v1-66 symbol) (v1-143 symbol))
  (with-pp
    (when (and (>= (the-as uint (-> arg0 channel)) (the-as uint 16))
               (>= (the-as uint 17) (the-as uint (-> arg0 channel)))
               )
      (case (-> arg0 action)
        (((gui-action queue))
         (spool-push *art-control* (-> arg0 name) (the-as int (-> arg0 anim-part)) arg1 (-> arg0 priority))
         (if (and (logtest? (-> arg0 flags) (gui-connection-flags gcf0))
                  (= (get-status obj (-> arg0 id)) (gui-status active))
                  )
             (set! (-> arg0 action) (gui-action playing))
             )
         )
        )
      )
    (let ((v1-16 (-> arg0 action)))
      (b! (!= v1-16 (gui-action play)) cfg-39 :delay (empty-form))
      (if (handle-command-list obj (-> arg0 channel) arg0)
          (channel-id-set! obj arg0 (-> arg0 id))
          )
      (b!
        (not (or (not (gui-control-method-18 obj (-> arg0 channel))) (= (get-status obj (-> arg0 id)) (gui-status stop)))
             )
        cfg-27
        :delay (empty-form)
        )
      (if (= (-> obj ids (-> arg0 channel)) (-> arg0 id))
          (channel-id-set! obj arg0 (new 'static 'sound-id))
          )
      (if (and arg2 (or (< (shr (the-as int (-> arg0 channel)) 4) (the-as uint 4))
                        (= (get-status obj (-> arg0 id)) (gui-status stop))
                        )
               )
          (move-to-dead arg0)
          )
      (b! #t cfg-38 :delay (nop!))
      (label cfg-27)
      (let ((v1-40 (-> arg0 id)))
        (b! (!= (-> obj ids (-> arg0 channel)) v1-40) cfg-38 :delay (empty-form))
        )
      (let ((v1-43 (get-status obj (-> arg0 id))))
        (b! (!= v1-43 (gui-status ready)) cfg-36 :delay (empty-form))
        (case (shr (the-as int (-> arg0 channel)) 4)
          ((1 2)
           (if (#if PC_PORT (or *gui-kick-str* (not (paused?)))
                            (not (paused?)))
               (str-play-async (-> arg0 name) (-> arg0 id))
               )
           )
          )
        (b! #t cfg-38 :delay (nop!))
        (label cfg-36)
        (b! (!= v1-43 (gui-status active)) cfg-38 :delay (empty-form))
        )
      (set! (-> arg0 action) (gui-action playing))
      (label cfg-38)
      (b! #t cfg-139 :delay (nop!))
      (label cfg-39)
      (b! (not (or (= v1-16 (gui-action playing)) (= v1-16 (gui-action fade)))) cfg-117 :delay (empty-form))
      (b!
        (not (and (= (get-status obj (-> arg0 id)) (gui-status active))
                  (gui-control-method-18 obj (-> arg0 channel))
                  (or (= (-> arg0 action) (gui-action playing)) (< (-> arg0 fade) (the-as uint 30)))
                  )
             )
        cfg-106
        :delay (nop!)
        )
      (channel-id-set! obj arg0 (-> arg0 id))
      (set! (-> obj times 0) 0)
      (let ((v1-64 (shr (the-as int (-> arg0 channel)) 4)))
        (set! v1-66
              (and (or (= v1-64 1) (= v1-64 2))
                   (not (and (>= (the-as uint (-> arg0 channel)) (the-as uint 16))
                             (>= (the-as uint 17) (the-as uint (-> arg0 channel)))
                             )
                        )
                   (begin
                     (dotimes (s3-0 4)
                       (when (and (string-charp= (-> arg0 name) (the-as (pointer uint8) (-> *sound-iop-info* stream-name s3-0)))
                                  (= (-> arg0 id) (-> *sound-iop-info* stream-id s3-0))
                                  (logtest? (-> *sound-iop-info* stream-status s3-0) (stream-status ststatus-six))
                                  )
                         (set! v1-66 #t)
                         (goto cfg-73)
                         )
                       )
                     #f
                     )
                   )
              )
        )
      (label cfg-73)
      (cond
        ((not v1-66)
         (when (and (logtest? (-> arg0 flags) (gui-connection-flags gcf1 fo-curve fo-min fo-max))
                    (logtest? (-> arg0 flags) (gui-connection-flags gcf0))
                    )
           (let* ((s5-1 (get-process arg0))
                  (s4-1 (if (type? s5-1 process-drawable)
                            s5-1
                            )
                        )
                  )
             (when (and s4-1 (nonzero? (-> (the-as process-drawable s4-1) root)))
               (when *sound-player-enable*
                 (let ((s5-2 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
                   (set! (-> s5-2 command) (sound-command set-param))
                   (set! (-> s5-2 id) (-> arg0 id))
                   (let ((a1-24 (-> (the-as process-drawable s4-1) root trans)))
                     (let ((s4-2 (the-as process-drawable pp)))
                       (when (= a1-24 #t)
                         (if (and s4-2 (type? s4-2 process-drawable) (nonzero? (-> s4-2 root)))
                             (set! a1-24 (-> s4-2 root trans))
                             (set! a1-24 (the-as vector #f))
                             )
                         )
                       )
                     (sound-trans-convert (the-as vector3w (-> s5-2 params trans)) a1-24)
                     )
                   (set! (-> s5-2 params fo-curve) (-> arg0 fo-curve))
                   (set! (-> s5-2 params fo-min) (-> arg0 fo-min))
                   (set! (-> s5-2 params fo-max) (-> arg0 fo-max))
                   (set! (-> s5-2 params mask) (the-as uint 0))
                   (if (logtest? (-> arg0 flags) (gui-connection-flags gcf1))
                       (logior! (-> s5-2 params mask) 32)
                       )
                   (if (logtest? (-> arg0 flags) (gui-connection-flags fo-curve))
                       (logior! (-> s5-2 params mask) 256)
                       )
                   (if (logtest? (-> arg0 flags) (gui-connection-flags fo-min))
                       (logior! (-> s5-2 params mask) 64)
                       )
                   (if (logtest? (-> arg0 flags) (gui-connection-flags fo-max))
                       (logior! (-> s5-2 params mask) 128)
                       )
                   )
                 )
               )
             )
           )
         (when (= (-> arg0 action) (gui-action fade))
           (set! (-> arg0 fade) (the-as uint (seekl (the-as int (-> arg0 fade)) 30 1)))
           (when *sound-player-enable*
             (let ((s5-3 (the-as sound-rpc-set-param (get-sound-buffer-entry))))
               (set! (-> s5-3 command) (sound-command set-param))
               (set! (-> s5-3 id) (-> arg0 id))
               (set! (-> s5-3 params volume) (the int (* 1024.0 (lerp-scale 1.0 0.0 (the float (-> arg0 fade)) 0.0 30.0))))
               (set! (-> s5-3 params mask) (the-as uint 1))
               (-> s5-3 id)
               )
             )
           )
         )
        (else
          (label cfg-106)
          (when (= (-> obj ids (-> arg0 channel)) (-> arg0 id))
            (channel-id-set! obj arg0 (new 'static 'sound-id))
            (set! (-> obj times (-> arg0 channel)) (+ (-> *display* base-clock frame-counter) (-> arg0 hold-time)))
            )
          (b! (not arg2) cfg-113 :likely-delay (set! v1-143 arg2))
          (let ((a0-75 (< (shr (the-as int (-> arg0 channel)) 4) (the-as uint 4))))
            (b! a0-75 cfg-113 :likely-delay (set! v1-143 a0-75))
            )
          (set! v1-143 (= (get-status obj (-> arg0 id)) (gui-status stop)))
          (label cfg-113)
          (if v1-143
              (move-to-dead arg0)
              (set! (-> arg0 action) (gui-action play))
              )
          )
        )
      (b! #t cfg-139 :delay (nop!))
      (label cfg-117)
      (b! (!= v1-16 (gui-action stop)) cfg-121 :delay (empty-form))
      (stop-str obj arg0)
      (if arg2
          (move-to-dead arg0)
          )
      (b! #t cfg-139 :delay (nop!))
      (label cfg-121)
      (cond
        ((= v1-16 (gui-action abort))
         (if (= (-> obj ids (-> arg0 channel)) (-> arg0 id))
             (channel-id-set! obj arg0 (new 'static 'sound-id))
             )
         (if arg2
             (move-to-dead arg0)
             )
         )
        ((= v1-16 (gui-action hide))
         )
        ((= v1-16 (gui-action hidden))
         (cond
           ((or (< (shr (the-as int (-> arg0 channel)) 4) (the-as uint 4))
                (= (get-status obj (-> arg0 id)) (gui-status stop))
                )
            (stop-str obj arg0)
            (if arg2
                (move-to-dead arg0)
                )
            )
           (else
             (if (= (-> obj ids (-> arg0 channel)) (-> arg0 id))
                 (channel-id-set! obj arg0 (new 'static 'sound-id))
                 )
             )
           )
         )
        )
      )
    (label cfg-139)
    0
    (none)
    )
  )

(defmethod update gui-control ((obj gui-control) (arg0 symbol))
  (set! (-> obj ids 65)
        (the-as sound-id (if (and (>= (-> *display* base-clock frame-counter) (-> *game-info* blackout-time))
                                  (= (-> *setting-control* user-current bg-a) 0.0)
                                  (= (-> *setting-control* user-current bg-a-force) 0.0)
                                  )
                             0
                             1
                             )
                )
        )
  (let ((s4-0 (target-pos 0)))
    (dotimes (v1-8 4)
      (set! (-> obj spool-connections v1-8 param2) (the-as int #f))
      (set! (-> obj spool-connections v1-8 param3) 0)
      (set! (-> obj spool-connections v1-8 priority) 100000000.0)
      )
    (let ((s3-0 (the-as gui-connection (-> obj engine alive-list next0))))
      (-> obj engine)
      (let ((s2-0 (-> s3-0 next0)))
        (while (!= s3-0 (-> obj engine alive-list-end))
          (gui-control-method-21 obj s3-0 s4-0)
          (case (-> s3-0 action)
            (((gui-action playing))
             (channel-id-set! obj s3-0 (-> s3-0 id))
             )
            )
          (set! s3-0 (the-as gui-connection s2-0))
          (-> obj engine)
          (set! s2-0 (-> s2-0 next0))
          )
        )
      )
    (let ((s3-1 (-> obj update-time)))
      (countdown (s2-1 32)
        (let ((s1-0 (-> obj connections s2-1)))
          (when (nonzero? (-> s1-0 id))
            (cond
              ((= (-> s1-0 time-stamp) s3-1)
               (gui-control-method-21 obj s1-0 s4-0)
               )
              (else
                (if (= (-> obj ids (-> s1-0 channel)) (-> s1-0 id))
                    (channel-id-set! obj s1-0 (new 'static 'sound-id))
                    )
                (set! (-> s1-0 param3) 0)
                0
                )
              )
            )
          )
        )
      )
    )
  (let ((s4-1 (new 'stack-no-clear 'array 'sound-id 4))
        (s3-2 0)
        )
    (let ((s2-2 (-> *setting-control* user-current movie-name)))
      (dotimes (s1-1 4)
        (set! (-> s4-1 s1-1) (-> obj spool-connections s1-1 id))
        (when (and (-> obj spool-connections s1-1 name) (case (-> obj spool-connections s1-1 channel)
                                                          (((gui-channel art-load) (gui-channel art-load-next))
                                                           #t
                                                           )
                                                          )
                   )
          (set! s3-2 (logior s3-2 (ash 1 s1-1)))
          (if (and s2-2 (string= (-> obj spool-connections s1-1 name) (the-as string s2-2)))
              (set! s3-2 (logior s3-2 (ash 1 (+ s1-1 4))))
              )
          )
        )
      )
    (let* ((t9-6 str-play-queue)
           (v1-69 (-> obj spool-connections 0 name))
           (a0-32 (if v1-69
                      v1-69
                      )
                  )
           (v1-70 (-> obj spool-connections 1 name))
           (a1-7 (if v1-70
                     v1-70
                     )
                 )
           (v1-71 (-> obj spool-connections 2 name))
           (a2-4 (if v1-71
                     v1-71
                     )
                 )
           (v1-72 (-> obj spool-connections 3 name))
           )
      (t9-6
        a0-32
        a1-7
        a2-4
        (if v1-72
            v1-72
            )
        s4-1
        (the-as pointer s3-2)
        )
      )
    )
  (-> obj engine)
  (let ((a0-33 (the-as connection (-> obj engine alive-list-end prev0))))
    (-> obj engine)
    (let ((s4-2 (-> a0-33 prev0)))
      (while (!= a0-33 (-> obj engine alive-list))
        (gui-control-method-22 obj (the-as gui-connection a0-33) (get-process a0-33) #t)
        (set! a0-33 (the-as connection s4-2))
        (-> obj engine)
        (set! s4-2 (-> s4-2 prev0))
        )
      )
    )
  (countdown (s4-3 32)
    (let ((v1-91 (-> obj connections s4-3)))
      (if (nonzero? (-> v1-91 id))
          (gui-control-method-22 obj v1-91 (handle->process (-> v1-91 handle)) #f)
          )
      )
    )
  (when arg0
    (when *display-art-control*
      (dotimes (s5-1 4)
        (let ((a3-4 (-> obj spool-connections s5-1)))
          (if (-> a3-4 name)
              (format *stdcon* "~D: ~`gui-connection`P~%" s5-1 a3-4)
              )
          )
        )
      (dotimes (s5-2 4)
        (format
          *stdcon*
          "~0KCh ~D: ~8D ~5X ~6D ~G~1K~%"
          s5-2
          (-> *sound-iop-info* stream-id-int32 s5-2)
          (-> *sound-iop-info* stream-status s5-2)
          (-> *sound-iop-info* stream-position s5-2)
          (-> *sound-iop-info* stream-name s5-2)
          )
        )
      )
    (when *display-gui-control*
      (-> obj engine)
      (let ((a2-12 (-> obj engine alive-list-end prev0)))
        (-> obj engine)
        (let ((s5-3 (-> a2-12 prev0)))
          (while (!= a2-12 (-> obj engine alive-list))
            (format *stdcon* "c: ~`gui-connection`P~%" a2-12)
            (set! a2-12 s5-3)
            (-> obj engine)
            (set! s5-3 (-> s5-3 prev0))
            )
          )
        )
      (countdown (s5-4 32)
        (let ((a2-13 (-> obj connections s5-4)))
          (if (nonzero? (-> a2-13 id))
              (format *stdcon* "l: ~`gui-connection`P~%" a2-13)
              )
          )
        )
      )
    )
  (set! (-> obj update-time) (-> *display* base-clock frame-counter))
  0
  )

(defmethod new gui-control ((allocation symbol) (type-to-make type) (arg0 int))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 engine) ((method-of-type engine new) allocation engine 'gui-control arg0 gui-connection))
    (dotimes (v1-3 32)
      (set! (-> gp-0 connections v1-3 handle) (the-as handle #f))
      )
    (dotimes (v1-6 96)
      (set! (-> gp-0 cmd v1-6) '())
      )
    (set! (-> gp-0 cmd 64) '((64 . wait) (65 . wait) (66 . stop) (95 . stop)))
    (set! (-> gp-0 cmd 66)
          '((64 . wait)
            (65 . wait)
            (68 . wait)
            (71 . wait)
            (67 . wait)
            (66 . wait)
            (69 . wait)
            (83 . hide)
            (84 . hide)
            (85 . hide)
            )
          )
    (set! (-> gp-0 cmd 67)
          '((64 . wait)
            (65 . wait)
            (68 . wait)
            (71 . wait)
            (67 . wait)
            (66 . wait)
            (69 . wait)
            (83 . hide)
            (84 . hide)
            (85 . hide)
            (82 . hide)
            )
          )
    (set! (-> gp-0 cmd 68)
          '((65 . wait) (68 . wait) (67 . wait) (66 . wait) (69 . wait) (83 . hide) (84 . hide) (85 . hide) (82 . hide))
          )
    (set! (-> gp-0 cmd 71)
          '((65 . wait) (71 . wait) (67 . wait) (66 . wait) (69 . wait) (83 . hide) (84 . hide) (85 . hide) (82 . hide))
          )
    (set! (-> gp-0 cmd 69) '((65 . wait) (71 . wait) (67 . wait) (66 . wait)))
    (set! (-> gp-0 cmd 70) '((65 . wait) (90 . hide) (91 . hide) (81 . hide) (80 . hide)))
    ;; added this one
    (set! (-> gp-0 cmd (gui-channel subtitle-pc)) '(((the binteger (gui-channel blackout)) . wait)
                                                    ))
    (set! (-> gp-0 cmd 80) '((64 . wait) (65 . wait) (80 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 81) '((64 . wait) (65 . wait) (81 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 82) '((64 . wait) (65 . wait) (67 . wait) (71 . wait) (69 . wait) (82 . wait)))
    (set! (-> gp-0 cmd 83)
          '((64 . wait) (65 . wait) (67 . wait) (71 . wait) (69 . wait) (66 . wait) (83 . wait) (84 . hide) (85 . hide))
          )
    (set! (-> gp-0 cmd 84)
          '((64 . wait) (65 . wait) (67 . wait) (71 . wait) (69 . wait) (66 . wait) (83 . wait) (84 . wait))
          )
    (set! (-> gp-0 cmd 85)
          '((64 . wait) (65 . wait) (67 . wait) (71 . wait) (69 . wait) (66 . wait) (83 . wait) (85 . wait))
          )
    (set! (-> gp-0 cmd 86) '((64 . wait) (65 . wait) (86 . wait)))
    (set! (-> gp-0 cmd 87) '((64 . wait) (65 . wait) (87 . wait)))
    (set! (-> gp-0 cmd 88) '((64 . wait) (65 . wait) (88 . wait)))
    (set! (-> gp-0 cmd 89) '((64 . wait) (65 . wait) (89 . wait)))
    (set! (-> gp-0 cmd 90) '((64 . wait) (65 . wait) (90 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 91) '((64 . wait) (65 . wait) (91 . wait) (70 . wait)))
    (set! (-> gp-0 cmd 16) '((16 . wait)))
    (set! (-> gp-0 cmd 17) '((17 . wait)))
    (set! (-> gp-0 cmd 18) '((18 . wait)))
    (set! (-> gp-0 cmd 32) '((64 . wait) (32 . wait)))
    (set! (-> gp-0 cmd 30) '((64 . wait) (30 . wait)))
    (set! (-> gp-0 cmd 33) '((64 . wait) (33 . wait)))
    (set! (-> gp-0 cmd 34) '((64 . wait) (34 . wait)))
    (set! (-> gp-0 cmd 20) '((64 . wait) (20 . wait) (19 . wait) (29 . wait)))
    (set! (-> gp-0 cmd 19) '((64 . wait) (20 . wait) (19 . wait) (29 . wait)))
    (set! (-> gp-0 cmd 29) '((64 . wait) (20 . wait) (19 . wait) (29 . wait)))
    (set! (-> gp-0 cmd 21) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 22) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 23) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 24) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 25) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 27) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 26) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 28) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 31) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    (set! (-> gp-0 cmd 35) '((64 . wait)
                             (21 . wait)
                             (22 . wait)
                             (23 . wait)
                             (24 . wait)
                             (25 . wait)
                             (27 . wait)
                             (26 . wait)
                             (28 . wait)
                             (31 . wait)
                             (35 . wait)
                             )
          )
    gp-0
    )
  )

(kmemopen global "gui-controls")

(define *gui-control* (new 'global 'gui-control 64))

(if (zero? *art-control*)
    (set! *art-control* (new 'global 'external-art-control))
    )

(kmemclose)
