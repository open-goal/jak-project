;;-*-Lisp-*-
(in-package goal)

;; name: editable-player.gc
;; name in dgo: editable-player
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

;; this file is debug only
(declare-file (debug))

(defun cleanup-selection ((arg0 editable-array))
  (let* ((v1-0 (-> arg0 length))
         (a0-1 0)
         (a1-2 (-> arg0 data a0-1))
         )
    (while (< a0-1 v1-0)
      (if a1-2
          (logclear! (-> a1-2 flags) (editable-flag mark))
          )
      (+! a0-1 1)
      (set! a1-2 (-> arg0 data a0-1))
      )
    )
  (let* ((s5-0 (-> arg0 length))
         (s4-0 0)
         (a0-2 (-> arg0 data s4-0))
         )
    (while (< s4-0 s5-0)
      (if (and a0-2 (logtest? (-> a0-2 flags) (editable-flag selected)))
          (editable-method-29 a0-2 (editable-filter))
          )
      (+! s4-0 1)
      (set! a0-2 (-> arg0 data s4-0))
      )
    )
  0
  (none)
  )

;; WARN: Function insert-box has a return type of none, but the expression builder found a return statement.
(defun insert-box ((arg0 editable-array) (arg1 vector))
  (if (not (-> arg0 region))
      (set! (-> arg0 region) (new 'debug 'editable-region))
      )
  (let ((f30-0 (* 4096.0 (-> arg0 edit-param0)))
        (s3-0 (new 'stack-no-clear 'vector))
        (s5-0 (new 'stack-no-clear 'array 'int32 8))
        )
    (let ((s4-0 (-> arg0 region)))
      (if (= f30-0 0.0)
          (set! f30-0 40960.0)
          )
      (dotimes (s1-0 8)
        (set! (-> s5-0 s1-0) (editable-array-method-11 arg0))
        (set! (-> arg0 data (-> s5-0 s1-0)) (the-as editable #t))
        )
      (dotimes (v1-13 8)
        (when (< (-> s5-0 v1-13) 0)
          (dotimes (v1-14 8)
            (set! (-> arg0 data (-> s5-0 v1-14)) #f)
            )
          (return #f)
          )
        )
      (set! (-> s3-0 quad) (-> arg1 quad))
      (set! (-> s3-0 y) (- (-> s3-0 y) f30-0))
      (set! (-> s3-0 x) (- (-> s3-0 x) f30-0))
      (set! (-> s3-0 z) (- (-> s3-0 z) f30-0))
      (set! (-> arg0 data (-> s5-0 0)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (set! (-> s3-0 y) (- (-> s3-0 y) f30-0))
      (+! (-> s3-0 x) f30-0)
      (set! (-> s3-0 z) (- (-> s3-0 z) f30-0))
      (set! (-> arg0 data (-> s5-0 1)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (set! (-> s3-0 y) (- (-> s3-0 y) f30-0))
      (set! (-> s3-0 x) (- (-> s3-0 x) f30-0))
      (+! (-> s3-0 z) f30-0)
      (set! (-> arg0 data (-> s5-0 2)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (set! (-> s3-0 y) (- (-> s3-0 y) f30-0))
      (+! (-> s3-0 x) f30-0)
      (+! (-> s3-0 z) f30-0)
      (set! (-> arg0 data (-> s5-0 3)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (+! (-> s3-0 y) f30-0)
      (set! (-> s3-0 x) (- (-> s3-0 x) f30-0))
      (set! (-> s3-0 z) (- (-> s3-0 z) f30-0))
      (set! (-> arg0 data (-> s5-0 4)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (+! (-> s3-0 y) f30-0)
      (+! (-> s3-0 x) f30-0)
      (set! (-> s3-0 z) (- (-> s3-0 z) f30-0))
      (set! (-> arg0 data (-> s5-0 5)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (+! (-> s3-0 y) f30-0)
      (set! (-> s3-0 x) (- (-> s3-0 x) f30-0))
      (+! (-> s3-0 z) f30-0)
      (set! (-> arg0 data (-> s5-0 6)) (new 'debug 'editable-point s3-0 s4-0))
      (set! (-> s3-0 quad) (-> arg1 quad))
      (+! (-> s3-0 y) f30-0)
      (+! (-> s3-0 x) f30-0)
      (+! (-> s3-0 z) f30-0)
      (set! (-> arg0 data (-> s5-0 7)) (new 'debug 'editable-point s3-0 s4-0))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (select-editable! (-> arg0 data (-> s5-0 0)) #t)
      (select-editable! (-> arg0 data (-> s5-0 1)) #t)
      (select-editable! (-> arg0 data (-> s5-0 2)) #t)
      (select-editable! (-> arg0 data (-> s5-0 3)) #t)
      (set! (-> arg0 region) s4-0)
      (editable-array-method-9 arg0 (editable-command insert-face) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (select-editable! (-> arg0 data (-> s5-0 4)) #t)
      (select-editable! (-> arg0 data (-> s5-0 5)) #t)
      (select-editable! (-> arg0 data (-> s5-0 6)) #t)
      (select-editable! (-> arg0 data (-> s5-0 7)) #t)
      (set! (-> arg0 region) s4-0)
      (editable-array-method-9 arg0 (editable-command insert-face) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command flip-side) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (select-editable! (-> arg0 data (-> s5-0 0)) #t)
      (select-editable! (-> arg0 data (-> s5-0 2)) #t)
      (select-editable! (-> arg0 data (-> s5-0 4)) #t)
      (select-editable! (-> arg0 data (-> s5-0 6)) #t)
      (set! (-> arg0 region) s4-0)
      (editable-array-method-9 arg0 (editable-command insert-face) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (select-editable! (-> arg0 data (-> s5-0 1)) #t)
      (select-editable! (-> arg0 data (-> s5-0 3)) #t)
      (select-editable! (-> arg0 data (-> s5-0 5)) #t)
      (select-editable! (-> arg0 data (-> s5-0 7)) #t)
      (set! (-> arg0 region) s4-0)
      (editable-array-method-9 arg0 (editable-command insert-face) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command flip-side) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (select-editable! (-> arg0 data (-> s5-0 0)) #t)
      (select-editable! (-> arg0 data (-> s5-0 1)) #t)
      (select-editable! (-> arg0 data (-> s5-0 4)) #t)
      (select-editable! (-> arg0 data (-> s5-0 5)) #t)
      (set! (-> arg0 region) s4-0)
      (editable-array-method-9 arg0 (editable-command insert-face) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command flip-side) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (select-editable! (-> arg0 data (-> s5-0 2)) #t)
      (select-editable! (-> arg0 data (-> s5-0 3)) #t)
      (select-editable! (-> arg0 data (-> s5-0 6)) #t)
      (select-editable! (-> arg0 data (-> s5-0 7)) #t)
      (set! (-> arg0 region) s4-0)
      (editable-array-method-9 arg0 (editable-command insert-face) (the-as editable-array #f))
      (editable-array-method-9 arg0 (editable-command select-none) (the-as editable-array #f))
      (set! (-> arg0 region) s4-0)
      )
    (dotimes (s4-1 8)
      (select-editable! (-> arg0 data (-> s5-0 s4-1)) #t)
      )
    )
  (editable-array-method-9 arg0 (editable-command select-current-owner) (the-as editable-array #f))
  0
  (none)
  )

(defun execute-select ((arg0 editable-array) (arg1 editable-command) (arg2 editable-array))
  (case arg1
    (((editable-command select-none))
     (let* ((s5-1 (-> arg0 length))
            (s4-0 0)
            (a0-2 (-> arg0 data s4-0))
            )
       (while (< s4-0 s5-1)
         (if (and a0-2 (logtest? (-> a0-2 flags) (editable-flag selected)))
             (select-editable! a0-2 #f)
             )
         (+! s4-0 1)
         (set! a0-2 (-> arg0 data s4-0))
         )
       )
     (if (not (-> arg0 region-lock?))
         (set! (-> arg0 region) #f)
         )
     )
    (((editable-command select-all))
     (let* ((s5-2 (-> arg0 length))
            (s4-1 0)
            (a0-4 (-> arg0 data s4-1))
            )
       (while (< s4-1 s5-2)
         (if (and a0-4 (or (and (logtest? (-> a0-4 region filter) (-> arg0 filter 0))
                                (logtest? (-> a0-4 region filter) (-> arg0 filter 1))
                                )
                           (logtest? (-> a0-4 flags) (editable-flag selected))
                           )
                  )
             (select-editable! a0-4 #t)
             )
         (+! s4-1 1)
         (set! a0-4 (-> arg0 data s4-1))
         )
       )
     )
    (((editable-command select-one))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((a0-7 arg0)
            (t9-4 (method-of-object a0-7 editable-array-method-10))
            (a1-12 (new 'stack-no-clear 'vector))
            )
       (set! (-> a1-12 x) (-> arg2 edit-plane-normal x))
       (set! (-> a1-12 y) (-> arg2 edit-plane-normal y))
       (set! (-> a1-12 z) 0.0)
       (set! (-> a1-12 w) 1.0)
       (let ((s4-3 (t9-4 a0-7 a1-12 0)))
         (editable-array-method-9 arg0 (editable-command select-none) arg2)
         (when s4-3
           (select-editable! s4-3 #t)
           (if (not (-> arg0 region-lock?))
               (set! (-> arg0 region) (-> s4-3 region))
               )
           )
         )
       )
     )
    (((editable-command select-toggle))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((a0-12 arg0)
            (t9-9 (method-of-object a0-12 editable-array-method-10))
            (a1-16 (new 'stack-no-clear 'vector))
            )
       (set! (-> a1-16 x) (-> arg2 edit-plane-normal x))
       (set! (-> a1-16 y) (-> arg2 edit-plane-normal y))
       (set! (-> a1-16 z) 0.0)
       (set! (-> a1-16 w) 1.0)
       (let ((s5-3 (t9-9 a0-12 a1-16 1)))
         (when s5-3
           (select-editable! s5-3 'toggle)
           (if (and (logtest? (-> s5-3 flags) (editable-flag selected)) (not (-> arg0 region-lock?)))
               (set! (-> arg0 region) (-> s5-3 region))
               )
           )
         )
       )
     )
    (((editable-command select-region))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((a0-16 arg0)
            (t9-13 (method-of-object a0-16 editable-array-method-10))
            (a1-19 (new 'stack-no-clear 'vector))
            )
       (set! (-> a1-19 x) (-> arg2 edit-plane-normal x))
       (set! (-> a1-19 y) (-> arg2 edit-plane-normal y))
       (set! (-> a1-19 z) 0.0)
       (set! (-> a1-19 w) 1.0)
       (let ((s4-6 (t9-13 a0-16 a1-19 0)))
         (editable-array-method-9 arg0 (editable-command select-none) arg2)
         (when s4-6
           (select-editable! s4-6 #t)
           (set! (-> arg0 backup-region) (-> arg0 region))
           (set! (-> arg0 region) (-> s4-6 region))
           (editable-array-method-9 arg0 (editable-command select-current-region) arg2)
           (if (-> arg0 region-lock?)
               (set! (-> arg0 region) (-> arg0 backup-region))
               )
           )
         )
       )
     )
    (((editable-command select-face))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((a0-22 arg0)
            (t9-19 (method-of-object a0-22 editable-array-method-10))
            (a1-24 (new 'stack-no-clear 'vector))
            )
       (set! (-> a1-24 x) (-> arg2 edit-plane-normal x))
       (set! (-> a1-24 y) (-> arg2 edit-plane-normal y))
       (set! (-> a1-24 z) 0.0)
       (set! (-> a1-24 w) 1.0)
       (let ((s4-8 (t9-19 a0-22 a1-24 0)))
         (editable-array-method-9 arg0 (editable-command select-none) arg2)
         (when s4-8
           (select-editable! s4-8 #t)
           (set! (-> arg0 backup-region) (-> arg0 region))
           (set! (-> arg0 region) (-> s4-8 region))
           (editable-array-method-9 arg0 (editable-command select-current-face) arg2)
           (if (-> arg0 region-lock?)
               (set! (-> arg0 region) (-> arg0 backup-region))
               )
           )
         )
       )
     )
    (((editable-command select-prim))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((a0-28 arg0)
            (t9-25 (method-of-object a0-28 editable-array-method-10))
            (a1-29 (new 'stack-no-clear 'vector))
            )
       (set! (-> a1-29 x) (-> arg2 edit-plane-normal x))
       (set! (-> a1-29 y) (-> arg2 edit-plane-normal y))
       (set! (-> a1-29 z) 0.0)
       (set! (-> a1-29 w) 1.0)
       (let ((s4-10 (t9-25 a0-28 a1-29 0)))
         (editable-array-method-9 arg0 (editable-command select-none) arg2)
         (when s4-10
           (select-editable! s4-10 #t)
           (set! (-> arg0 backup-region) (-> arg0 region))
           (set! (-> arg0 region) (-> s4-10 region))
           (editable-array-method-9 arg0 (editable-command select-current-prim) arg2)
           (if (-> arg0 region-lock?)
               (set! (-> arg0 region) (-> arg0 backup-region))
               )
           )
         )
       )
     )
    (((editable-command select-current-region))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (when (-> arg0 region)
       (let ((s4-12 (-> arg0 region)))
         (editable-array-method-9 arg0 (editable-command select-none) arg2)
         (set! (-> arg0 region) s4-12)
         )
       (let* ((s5-4 (-> arg0 length))
              (s4-13 0)
              (a0-35 (-> arg0 data s4-13))
              )
         (while (< s4-13 s5-4)
           (when (and a0-35 (or (and (logtest? (-> a0-35 region filter) (-> arg0 filter 0))
                                     (logtest? (-> a0-35 region filter) (-> arg0 filter 1))
                                     )
                                (logtest? (-> a0-35 flags) (editable-flag selected))
                                )
                      )
             (if (= (-> arg0 region) (-> a0-35 region))
                 (select-editable! a0-35 #t)
                 )
             )
           (+! s4-13 1)
           (set! a0-35 (-> arg0 data s4-13))
           )
         )
       )
     )
    (((editable-command select-current-owner))
     (let* ((s5-5 (-> arg0 length))
            (s4-14 0)
            (v1-121 (-> arg0 data s4-14))
            )
       (while (< s4-14 s5-5)
         (when (and v1-121 (logtest? (-> v1-121 flags) (editable-flag selected)))
           (let* ((s3-6 (-> v1-121 owner))
                  (a0-40 (car s3-6))
                  )
             (while (not (null? s3-6))
               (select-editable! (the-as editable a0-40) #t)
               (set! s3-6 (cdr s3-6))
               (set! a0-40 (car s3-6))
               )
             )
           )
         (+! s4-14 1)
         (set! v1-121 (-> arg0 data s4-14))
         )
       )
     )
    (((editable-command select-current-face))
     (let* ((s5-6 (-> arg0 length))
            (s4-15 0)
            (v1-134 (-> arg0 data s4-15))
            )
       (while (< s4-15 s5-6)
         (when (and v1-134 (logtest? (-> v1-134 flags) (editable-flag selected)))
           (let* ((s3-7 (-> v1-134 owner))
                  (a0-45 (car s3-7))
                  )
             (while (not (null? s3-7))
               (select-editable! (the-as editable a0-45) #t)
               (set! s3-7 (cdr s3-7))
               (set! a0-45 (car s3-7))
               )
             )
           )
         (+! s4-15 1)
         (set! v1-134 (-> arg0 data s4-15))
         )
       )
     (let* ((s5-7 (-> arg0 length))
            (s4-16 0)
            (s3-8 (-> arg0 data s4-16))
            )
       (while (< s4-16 s5-7)
         (when (and s3-8 (or (and (logtest? (-> s3-8 region filter) (-> arg0 filter 0))
                                  (logtest? (-> s3-8 region filter) (-> arg0 filter 1))
                                  )
                             (logtest? (-> s3-8 flags) (editable-flag selected))
                             )
                    )
           (let* ((s2-0 (-> s3-8 owner))
                  (v1-155 (car s2-0))
                  )
             (while (not (null? s2-0))
               (if (logtest? (-> (the-as editable v1-155) flags) (editable-flag selected))
                   (select-editable! s3-8 #t)
                   )
               (set! s2-0 (cdr s2-0))
               (set! v1-155 (car s2-0))
               )
             )
           )
         (+! s4-16 1)
         (set! s3-8 (-> arg0 data s4-16))
         )
       )
     )
    (((editable-command select-current-prim))
     (countdown (s5-8 10)
       (let* ((s4-17 (-> arg0 length))
              (s3-9 0)
              (v1-169 (-> arg0 data s3-9))
              )
         (while (< s3-9 s4-17)
           (when (and v1-169 (logtest? (-> v1-169 flags) (editable-flag selected)))
             (let* ((s2-1 (-> v1-169 owner))
                    (a0-58 (car s2-1))
                    )
               (while (not (null? s2-1))
                 (select-editable! (the-as editable a0-58) #t)
                 (set! s2-1 (cdr s2-1))
                 (set! a0-58 (car s2-1))
                 )
               )
             )
           (+! s3-9 1)
           (set! v1-169 (-> arg0 data s3-9))
           )
         )
       (let* ((s4-18 (-> arg0 length))
              (s3-10 0)
              (s2-2 (-> arg0 data s3-10))
              )
         (while (< s3-10 s4-18)
           (when (and s2-2 (or (and (logtest? (-> s2-2 region filter) (-> arg0 filter 0))
                                    (logtest? (-> s2-2 region filter) (-> arg0 filter 1))
                                    )
                               (logtest? (-> s2-2 flags) (editable-flag selected))
                               )
                      )
             (let* ((s1-0 (-> s2-2 owner))
                    (v1-190 (car s1-0))
                    )
               (while (not (null? s1-0))
                 (if (logtest? (-> (the-as editable v1-190) flags) (editable-flag selected))
                     (select-editable! s2-2 #t)
                     )
                 (set! s1-0 (cdr s1-0))
                 (set! v1-190 (car s1-0))
                 )
               )
             )
           (+! s3-10 1)
           (set! s2-2 (-> arg0 data s3-10))
           )
         )
       )
     )
    (((editable-command cancel))
     (editable-array-method-13 arg0 (the-as uint 0) (the-as basic 0) (the-as string #f))
     )
    (((editable-command pick-target))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((a0-71 arg0)
            (t9-41 (method-of-object a0-71 editable-array-method-10))
            (a1-58 (new 'stack-no-clear 'vector))
            )
       (set! (-> a1-58 x) (-> arg2 edit-plane-normal x))
       (set! (-> a1-58 y) (-> arg2 edit-plane-normal y))
       (set! (-> a1-58 z) 0.0)
       (set! (-> a1-58 w) 1.0)
       (let ((v1-208 (t9-41 a0-71 a1-58 0)))
         (when v1-208
           (set! (-> arg0 target) v1-208)
           (editable-array-method-9 arg0 (the-as editable-command (-> arg0 target-command)) arg2)
           )
         )
       )
     (editable-array-method-13 arg0 (the-as uint 0) (the-as basic 0) (the-as string #f))
     )
    (((editable-command pick-loc) (editable-command pick-yes-no))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (editable-array-method-9 arg0 (the-as editable-command (-> arg0 target-command)) arg2)
     (editable-array-method-13 arg0 (the-as uint 0) (the-as basic 0) (the-as string #f))
     )
    (((editable-command edit-plane-clear))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (set! (-> arg0 edit-plane) #f)
     (editable-array-method-16 arg0)
     )
    (((editable-command edit-plane-set))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (cond
       ((-> arg0 target)
        (let ((s5-11 (-> arg0 target)))
          (set! (-> arg0 edit-plane) (the-as editable-plane (if (type? s5-11 editable-plane)
                                                                s5-11
                                                                )
                                             )
                )
          )
        (editable-array-method-16 arg0)
        )
       (else
         (editable-array-method-14
           arg0
           (the-as (function symbol) (lambda ((arg0 editable)) (type? arg0 editable-plane)))
           #f
           )
         (cond
           ((>= (-> arg0 selection length) 1)
            (set! (-> arg0 edit-plane) (the-as editable-plane (-> arg0 selection 0)))
            (editable-array-method-16 arg0)
            )
           (else
             (editable-array-method-13 arg0 (the-as uint 14) (the-as basic 45) "pick the plane to edit-from")
             )
           )
         )
       )
     )
    (((editable-command print-region-info))
     (let ((s5-12 (-> arg0 region)))
       (when s5-12
         (format #t "~%~%region-~D~%~%" (-> s5-12 id))
         (let ((a2-35 (-> s5-12 on-enter)))
           (if a2-35
               (format #t "(on-enter ~S)~%" a2-35)
               )
           )
         (let ((a2-36 (-> s5-12 on-inside)))
           (if a2-36
               (format #t "(on-inside ~S)~%" a2-36)
               )
           )
         (let ((a2-37 (-> s5-12 on-exit)))
           (if a2-37
               (format #t "(on-exit ~S)~%" a2-37)
               )
           )
         (format #t "~%~%")
         )
       )
     (format #t "~%selected:~%")
     (let* ((s5-13 (-> arg0 length))
            (s4-23 0)
            (a2-38 (-> arg0 data s4-23))
            )
       (while (< s4-23 s5-13)
         (if (and a2-38 (logtest? (-> a2-38 flags) (editable-flag selected)))
             (format #t "~A~%" a2-38)
             )
         (+! s4-23 1)
         (set! a2-38 (-> arg0 data s4-23))
         )
       )
     (format #t "~%~%")
     )
    (else
      (return #f)
      )
    )
  #t
  )

(defun execute-mouse-move ((arg0 editable-array) (arg1 editable-command) (arg2 editable-array))
  (local-vars (f0-6 float) (f0-18 float) (f0-29 float))
  (case arg1
    (((editable-command camera-tumble))
     (set-setting! 'mouse-input 'abs #t 0)
     (let ((s5-0 (new-stack-vector0))
           (f30-0 0.0)
           )
       (let* ((s4-0 (-> arg0 length))
              (s3-0 0)
              (a0-3 (-> arg0 data s3-0))
              )
         (while (< s3-0 s4-0)
           (when (and a0-3 (logtest? (-> a0-3 flags) (editable-flag selected)))
             (vector+! s5-0 s5-0 (edit-get-trans a0-3))
             (set! f30-0 (+ 1.0 f30-0))
             )
           (+! s3-0 1)
           (set! a0-3 (-> arg0 data s3-0))
           )
         )
       (cond
         ((= f30-0 0.0)
          (remove-setting! 'mouse-tumble-point)
          )
         (else
           (vector-float/! s5-0 s5-0 f30-0)
           (set-setting! 'mouse-tumble-point 'abs s5-0 0)
           )
         )
       )
     )
    (((editable-command camera-xy))
     (set-setting! 'mouse-input 'abs #t 0)
     )
    (((editable-command camera-xz))
     (set-setting! 'mouse-input 'abs #t 0)
     )
    (((editable-command drag-move-x))
     (let ((v1-25 (-> arg2 level-offset))
           (a0-12 (-> arg2 edit-plane-normal))
           (s5-1 (new-stack-vector0))
           (s4-1 (-> *math-camera* trans))
           )
       0.0
       (let* ((f0-4 (- (-> v1-25 x) (-> a0-12 x)))
              (f1-2 (- (-> v1-25 y) (-> a0-12 y)))
              (f30-1 (if (< (fabs f1-2) (fabs f0-4))
                         f0-4
                         f1-2
                         )
                     )
              )
         (if (< (-> *math-camera* camera-rot vector 0 x) 0.0)
             (set! f30-1 (- f30-1))
             )
         (let* ((s3-1 (-> arg0 length))
                (s2-1 0)
                (s1-2 (-> arg0 data s2-1))
                )
           (while (< s2-1 s3-1)
             (when (and s1-2 (logtest? (-> s1-2 flags) (editable-flag selected)))
               (set! f0-6 (cond
                            ((-> arg0 move-lock?)
                             (-> arg0 move-speed)
                             )
                            (else
                              (vector-! s5-1 (edit-get-trans s1-2) s4-1)
                              (let ((f0-9 (* 0.00390625 f30-1 (vector-length s5-1))))
                                (set! f0-6 (fmax -40960.0 (fmin 40960.0 f0-9)))
                                )
                              (set! (-> arg0 move-speed) f0-6)
                              (set! (-> arg0 move-lock?) #t)
                              f0-6
                              )
                            )
                     )
               (set-vector! s5-1 f0-6 0.0 0.0 0.0)
               (editable-method-15 s1-2 s5-1 56)
               )
             (+! s2-1 1)
             (set! s1-2 (-> arg0 data s2-1))
             )
           )
         )
       )
     (cleanup-selection arg0)
     )
    (((editable-command drag-move-y))
     (let ((v1-54 (-> arg2 level-offset))
           (a0-20 (-> arg2 edit-plane-normal))
           (s5-2 (new-stack-vector0))
           (s4-2 (-> *math-camera* trans))
           )
       0.0
       (let* ((f0-16 (- (-> v1-54 x) (-> a0-20 x)))
              (f1-8 (- (-> v1-54 y) (-> a0-20 y)))
              (f30-2 (if (< (fabs f1-8) (fabs f0-16))
                         f0-16
                         f1-8
                         )
                     )
              )
         (if (< (-> *math-camera* camera-rot vector 1 y) 0.0)
             (set! f30-2 (- f30-2))
             )
         (let* ((s3-2 (-> arg0 length))
                (s2-2 0)
                (s1-3 (-> arg0 data s2-2))
                )
           (while (< s2-2 s3-2)
             (when (and s1-3 (logtest? (-> s1-3 flags) (editable-flag selected)))
               (set! f0-18 (cond
                             ((-> arg0 move-lock?)
                              (-> arg0 move-speed)
                              )
                             (else
                               (vector-! s5-2 (edit-get-trans s1-3) s4-2)
                               (let ((f0-21 (* 0.00390625 f30-2 (vector-length s5-2))))
                                 (set! f0-18 (fmax -40960.0 (fmin 40960.0 f0-21)))
                                 )
                               (set! (-> arg0 move-speed) f0-18)
                               (set! (-> arg0 move-lock?) #t)
                               f0-18
                               )
                             )
                     )
               (set-vector! s5-2 0.0 f0-18 0.0 0.0)
               (editable-method-15 s1-3 s5-2 56)
               )
             (+! s2-2 1)
             (set! s1-3 (-> arg0 data s2-2))
             )
           )
         )
       )
     (cleanup-selection arg0)
     )
    (((editable-command drag-move-z))
     (let ((v1-83 (-> arg2 level-offset))
           (a0-28 (-> arg2 edit-plane-normal))
           (s5-3 (new-stack-vector0))
           (s4-3 (-> *math-camera* trans))
           )
       0.0
       (let* ((f0-27 (- (-> v1-83 x) (-> a0-28 x)))
              (f1-15 (- (-> v1-83 y) (-> a0-28 y)))
              (f30-3 (if (< (fabs f1-15) (fabs f0-27))
                         f0-27
                         f1-15
                         )
                     )
              )
         (if (>= (-> *math-camera* camera-rot vector 0 z) 0.0)
             (set! f30-3 (- f30-3))
             )
         (let* ((s3-3 (-> arg0 length))
                (s2-3 0)
                (s1-4 (-> arg0 data s2-3))
                )
           (while (< s2-3 s3-3)
             (when (and s1-4 (logtest? (-> s1-4 flags) (editable-flag selected)))
               (set! f0-29 (cond
                             ((-> arg0 move-lock?)
                              (-> arg0 move-speed)
                              )
                             (else
                               (vector-! s5-3 (edit-get-trans s1-4) s4-3)
                               (let ((f0-32 (* 0.00390625 f30-3 (vector-length s5-3))))
                                 (set! (-> arg0 move-speed) f0-32)
                                 (set! f0-29 (fmax -40960.0 (fmin 40960.0 f0-32)))
                                 )
                               (set! (-> arg0 move-lock?) #t)
                               f0-29
                               )
                             )
                     )
               (set-vector! s5-3 0.0 0.0 f0-29 0.0)
               (editable-method-15 s1-4 s5-3 56)
               )
             (+! s2-3 1)
             (set! s1-4 (-> arg0 data s2-3))
             )
           )
         )
       )
     (cleanup-selection arg0)
     )
    (((editable-command drag-move-xz))
     (let ((s5-4 (-> arg2 level-offset))
           (s4-4 (-> arg2 edit-plane-normal))
           (s3-4 (new 'stack-no-clear 'vector))
           )
       (set! (-> s3-4 x) 0.0)
       (set! (-> s3-4 y) 1.0)
       (set! (-> s3-4 z) 0.0)
       (set! (-> s3-4 w) 1.0)
       (let* ((s2-4 (new-stack-vector0))
              (s1-5 (-> arg0 length))
              (s0-6 0)
              (a0-36 (-> arg0 data s0-6))
              )
         (while (< s0-6 s1-5)
           (when (and a0-36 (logtest? (-> a0-36 flags) (editable-flag selected)))
             (if (= (-> s2-4 w) 0.0)
                 (editable-method-20 a0-36 s5-4 s4-4 s3-4 s2-4)
                 (editable-method-15 a0-36 s2-4 56)
                 )
             )
           (+! s0-6 1)
           (set! a0-36 (-> arg0 data s0-6))
           )
         )
       )
     (cleanup-selection arg0)
     )
    (((editable-command drag-move-xy))
     (let ((s5-5 (-> arg2 level-offset))
           (s4-5 (-> arg2 edit-plane-normal))
           (s3-5 (-> *math-camera* inv-camera-rot vector 2))
           (s2-5 (new-stack-vector0))
           )
       (set! (-> s3-5 y) 0.0)
       (vector-normalize! s3-5 1.0)
       (let* ((s1-6 (-> arg0 length))
              (s0-7 0)
              (a0-40 (-> arg0 data s0-7))
              )
         (while (< s0-7 s1-6)
           (when (and a0-40 (logtest? (-> a0-40 flags) (editable-flag selected)))
             (if (= (-> s2-5 w) 0.0)
                 (editable-method-20 a0-40 s5-5 s4-5 s3-5 s2-5)
                 (editable-method-15 a0-40 s2-5 56)
                 )
             )
           (+! s0-7 1)
           (set! a0-40 (-> arg0 data s0-7))
           )
         )
       )
     (cleanup-selection arg0)
     )
    (else
      (return #f)
      )
    )
  #t
  )

(defun execute-move ((arg0 editable-array) (arg1 editable-command) (arg2 editable-array))
  (case arg1
    (((editable-command drag-resize))
     (let ((s4-0 (new 'stack-no-clear 'vector)))
       (set! (-> s4-0 x) (* 100.0 (- (-> arg2 edit-plane-normal x) (-> arg2 level-offset x))))
       (set! (-> s4-0 y) 0.0)
       (set! (-> s4-0 z) 0.0)
       (set! (-> s4-0 w) 1.0)
       (let* ((s5-1 (-> arg0 length))
              (s3-0 0)
              (a0-2 (-> arg0 data s3-0))
              )
         (while (< s3-0 s5-1)
           (if (and a0-2 (logtest? (-> a0-2 flags) (editable-flag selected)))
               (editable-method-17 a0-2 s4-0)
               )
           (+! s3-0 1)
           (set! a0-2 (-> arg0 data s3-0))
           )
         )
       )
     )
    (((editable-command refresh-filter))
     (let* ((s5-2 (-> arg0 length))
            (s4-1 0)
            (s3-1 (-> arg0 data s4-1))
            )
       (while (< s4-1 s5-2)
         (if (and s3-1 (-> s3-1 region))
             (set! (-> s3-1 region filter) (editable-region-method-12 (-> s3-1 region)))
             )
         (+! s4-1 1)
         (set! s3-1 (-> arg0 data s4-1))
         )
       )
     )
    (((editable-command resize))
     (let ((s5-3 (new 'stack-no-clear 'vector)))
       (set! (-> s5-3 x) 0.0)
       (set! (-> s5-3 y) (* 4096.0 (-> arg0 edit-param0)))
       (set! (-> s5-3 z) 0.0)
       (set! (-> s5-3 w) 1.0)
       (let* ((s4-2 (-> arg0 length))
              (s3-2 0)
              (a0-7 (-> arg0 data s3-2))
              )
         (while (< s3-2 s4-2)
           (if (and a0-7 (logtest? (-> a0-7 flags) (editable-flag selected)))
               (editable-method-17 a0-7 s5-3)
               )
           (+! s3-2 1)
           (set! a0-7 (-> arg0 data s3-2))
           )
         )
       )
     )
    (((editable-command insert-sphere))
     (let ((s4-3 (editable-array-method-11 arg0)))
       (when (>= s4-3 0)
         (if (and (-> arg0 region) (-> arg0 region locked))
             (set! (-> arg0 region) (new 'debug 'editable-region))
             )
         (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
         (let* ((a2-3 (editable-array-method-17 arg0 (new 'stack-no-clear 'vector) (-> arg2 edit-plane-normal)))
                (s3-4 (new 'debug 'editable-sphere a2-3 2048.0 (-> arg0 region)))
                )
           (set! (-> arg0 data s4-3) s3-4)
           (editable-array-method-9 arg0 (editable-command select-none) arg2)
           (select-editable! s3-4 #t)
           )
         )
       )
     )
    (((editable-command insert-point))
     (let ((s4-4 (editable-array-method-11 arg0)))
       (when (>= s4-4 0)
         (if (and (-> arg0 region) (-> arg0 region locked))
             (set! (-> arg0 region) (new 'debug 'editable-region))
             )
         (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
         (let* ((a2-7 (editable-array-method-17 arg0 (new 'stack-no-clear 'vector) (-> arg2 edit-plane-normal)))
                (s3-6 (new 'debug 'editable-point a2-7 (-> arg0 region)))
                )
           (set! (-> arg0 data s4-4) s3-6)
           (editable-array-method-9 arg0 (editable-command select-none) arg2)
           (select-editable! s3-6 #t)
           )
         )
       )
     )
    (((editable-command insert-sample))
     (let ((s4-5 (editable-array-method-11 arg0)))
       (when (>= s4-5 0)
         (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
         (let* ((a2-11 (editable-array-method-17 arg0 (new 'stack-no-clear 'vector) (-> arg2 edit-plane-normal)))
                (s3-8 (new 'debug 'editable-sample a2-11 *editable-sample-region*))
                )
           (set! (-> arg0 data s4-5) s3-8)
           (editable-array-method-9 arg0 (editable-command select-none) arg2)
           (select-editable! s3-8 #t)
           )
         )
       )
     )
    (((editable-command insert-sample-camera))
     (let ((s4-6 (editable-array-method-11 arg0)))
       (when (>= s4-6 0)
         (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
         (let ((s3-11 (new 'debug 'editable-sample (math-camera-pos) *editable-sample-region*)))
           (set! (-> arg0 data s4-6) s3-11)
           (editable-array-method-9 arg0 (editable-command select-none) arg2)
           (select-editable! s3-11 #t)
           )
         )
       )
     )
    (((editable-command insert-light))
     (let ((s4-7 (editable-array-method-11 arg0)))
       (when (>= s4-7 0)
         (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
         (let* ((a2-18 (editable-array-method-17 arg0 (new 'stack-no-clear 'vector) (-> arg2 edit-plane-normal)))
                (s3-13 (new 'debug 'editable-light a2-18 2048.0 *editable-light-region*))
                )
           (set! (-> arg0 data s4-7) s3-13)
           (editable-array-method-9 arg0 (editable-command select-none) arg2)
           (select-editable! s3-13 #t)
           (editable-method-23 s3-13)
           )
         (update-light-hash *light-hash*)
         )
       )
     )
    (((editable-command insert-entity))
     (let ((s4-8 (editable-array-method-11 arg0)))
       (when (>= s4-8 0)
         (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
         (let* ((a2-22 (editable-array-method-17 arg0 (new 'stack-no-clear 'vector) (-> arg2 edit-plane-normal)))
                (s3-15 (new 'debug 'editable-entity a2-22 *editable-entity-region*))
                )
           (set! (-> arg0 data s4-8) s3-15)
           (editable-array-method-9 arg0 (editable-command select-none) arg2)
           (select-editable! s3-15 #t)
           )
         )
       )
     )
    (((editable-command insert-box))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (if (and (-> arg0 region) (-> arg0 region locked))
         (set! (-> arg0 region) (new 'debug 'editable-region))
         )
     (let ((a1-42 (editable-array-method-17 arg0 (new 'stack-no-clear 'vector) (-> arg2 edit-plane-normal))))
       (insert-box arg0 a1-42)
       )
     )
    (((editable-command insert-face))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (if (and (-> arg0 region) (-> arg0 region locked))
         (set! (-> arg0 region) (new 'debug 'editable-region))
         )
     (let ((s4-11 (editable-array-method-11 arg0)))
       0
       (editable-array-method-14
         arg0
         (the-as
           (function symbol)
           (lambda ((arg0 editable) (arg1 symbol)) (and (type? arg0 editable-point) (= (-> arg0 region) arg1)))
           )
         (the-as symbol (-> arg0 region))
         )
       (let ((s5-5 (-> arg0 selection length)))
         (cond
           ((= s5-5 1)
            (cond
              ((and (-> arg0 target) (type? (-> arg0 target) editable-point) (= (-> arg0 target region) (-> arg0 region)))
               (set! (-> arg0 selection 1) (-> arg0 target))
               (+! (-> arg0 selection length) 1)
               (+! s5-5 1)
               )
              (else
                (editable-array-method-13 arg0 (the-as uint 14) (the-as basic 33) "pick the point to complete the face")
                (return #f)
                )
              )
            )
           ((and (>= s5-5 2) (>= 6 s5-5))
            )
           (else
             (format
               0
               "ERROR: face can only be inserted if there are 2-6 points selected in the current region, got ~D.~%"
               s5-5
               )
             (return #f)
             )
           )
         (when (>= s4-11 0)
           (let ((s3-17 (new 'debug 'editable-face (-> arg0 region))))
             (set! (-> arg0 data s4-11) s3-17)
             (dotimes (s4-12 s5-5)
               (set! (-> s3-17 vertex s4-12) (the-as editable-point (-> arg0 selection s4-12)))
               (set! (-> arg0 selection s4-12 owner) (cons s3-17 (-> arg0 selection s4-12 owner)))
               )
             (set! (-> s3-17 length) s5-5)
             (select-editable! s3-17 #t)
             (editable-method-28 s3-17 (editable-filter load))
             (editable-method-29 s3-17 (editable-filter load))
             )
           )
         )
       )
     )
    (((editable-command insert-plane))
     (if (and (-> arg0 region) (-> arg0 region locked))
         (set! (-> arg0 region) (new 'debug 'editable-region))
         )
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let ((s3-18 (editable-array-method-11 arg0)))
       0
       (editable-array-method-14
         arg0
         (the-as
           (function symbol)
           (lambda ((arg0 editable) (arg1 symbol)) (and (type? arg0 editable-point) (= (-> arg0 region) arg1)))
           )
         (the-as symbol (-> arg0 region))
         )
       (let ((s5-7 (-> arg0 selection length)))
         (cond
           ((= s5-7 1)
            (cond
              ((and (-> arg0 target) (type? (-> arg0 target) editable-point) (= (-> arg0 target region) (-> arg0 region)))
               (set! (-> arg0 selection 1) (-> arg0 target))
               (+! (-> arg0 selection length) 1)
               (+! s5-7 1)
               )
              (else
                (editable-array-method-13 arg0 (the-as uint 14) (the-as basic 34) "pick the point to complete the plane")
                (return #f)
                )
              )
            )
           ((= s5-7 2)
            )
           (else
             (format
               0
               "ERROR: plane can only be inserted if there are 2 points selected in the current region, got ~D.~%"
               s5-7
               )
             (return #f)
             )
           )
         (when (>= s3-18 0)
           (let ((s4-14 (new 'debug 'editable-plane (-> arg0 region))))
             (set! (-> arg0 data s3-18) s4-14)
             (dotimes (s3-19 s5-7)
               (set! (-> s4-14 vertex s3-19) (the-as editable-point (-> arg0 selection s3-19)))
               (set! (-> arg0 selection s3-19 owner) (cons s4-14 (-> arg0 selection s3-19 owner)))
               )
             (set! (-> s4-14 length) s5-7)
             (select-editable! s4-14 #t)
             (editable-method-28 s4-14 (editable-filter load))
             (editable-method-29 s4-14 (editable-filter load))
             )
           )
         )
       )
     )
    (else
      (return #f)
      )
    )
  #t
  )

(defmethod editable-array-method-9 editable-array ((obj editable-array) (arg0 editable-command) (arg1 editable-array))
  (if (execute-select obj arg0 arg1)
      (return #f)
      )
  (if (execute-move obj arg0 arg1)
      (return #f)
      )
  (if (execute-mouse-move obj arg0 arg1)
      (return #f)
      )
  (cond
    ((= arg0 (editable-command copy))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (set! (-> obj selection length) 0)
     (let* ((s4-2 (-> obj length))
            (s3-1 0)
            (s2-0 (-> obj data s3-1))
            )
       (while (< s3-1 s4-2)
         (when (and s2-0 (logtest? (-> s2-0 flags) (editable-flag selected)))
           (editable-method-27 s2-0 obj)
           (when (= (-> s2-0 type) editable-light)
             (editable-method-23 s2-0)
             (update-light-hash *light-hash*)
             )
           )
         (+! s3-1 1)
         (set! s2-0 (-> obj data s3-1))
         )
       )
     (editable-array-method-9 obj (editable-command select-none) arg1)
     (let ((s5-1 (the-as editable-region #f)))
       (dotimes (s4-3 (-> obj selection length))
         (let ((a0-13 (-> obj selection s4-3)))
           (when (and a0-13 (logtest? s4-3 1))
             (set! s5-1 (-> a0-13 region))
             (select-editable! a0-13 #t)
             )
           )
         )
       (if (not (-> obj region-lock?))
           (set! (-> obj region) s5-1)
           )
       )
     )
    ((= arg0 (editable-command copy-region))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (when (and (-> obj region) (not (-> obj region locked)))
       (editable-array-method-9 obj (editable-command select-current-region) arg1)
       (let ((v1-52 (copy (-> obj region) 'debug)))
         (set! (-> v1-52 id) (the-as uint 0))
         (set! (-> v1-52 changed) #t)
         (set! (-> obj region) v1-52)
         )
       (editable-array-method-9 obj (editable-command copy) arg1)
       )
     )
    ((= arg0 (editable-command delete))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((s5-3 (-> obj length))
            (s4-6 0)
            (s3-3 (-> obj data s4-6))
            )
       (while (< s4-6 s5-3)
         (when (and s3-3 (logtest? (-> s3-3 flags) (editable-flag selected)))
           (editable-array-method-15 obj s3-3)
           (when (= (-> s3-3 type) editable-light)
             (editable-method-23 s3-3)
             (update-light-hash *light-hash*)
             )
           )
         (+! s4-6 1)
         (set! s3-3 (-> obj data s4-6))
         )
       )
     (if (not (-> obj region-lock?))
         (set! (-> obj region) #f)
         )
     )
    ((= arg0 (editable-command delete-region))
     (when (-> obj region)
       (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
       (when (!= (-> obj region) *editable-light-region*)
         (editable-array-method-9 obj (editable-command select-current-region) arg1)
         (editable-array-method-9 obj (editable-command delete) arg1)
         (set! (-> obj region) #f)
         )
       )
     )
    ((= arg0 (editable-command snap-to-ground))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((s5-5 (new 'stack-no-clear 'vector))
            (s4-9 (-> obj length))
            (s3-5 0)
            (s2-1 (-> obj data s3-5))
            )
       (while (< s3-5 s4-9)
         (when (and s2-1 (logtest? (-> s2-1 flags) (editable-flag selected)))
           (if (editable-method-11 s2-1 s5-5)
               (editable-method-19 s2-1 s5-5)
               )
           )
         (+! s3-5 1)
         (set! s2-1 (-> obj data s3-5))
         )
       )
     )
    ((= arg0 (editable-command snap-y))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (cond
       ((-> obj target)
        (let* ((s5-7 (edit-get-trans (-> obj target)))
               (s4-11 (-> obj length))
               (s3-6 0)
               (a0-37 (-> obj data s3-6))
               )
          (while (< s3-6 s4-11)
            (if (and a0-37 (logtest? (-> a0-37 flags) (editable-flag selected)))
                (edit-coord! a0-37 s5-7 (editable-flag y no-plane-snap))
                )
            (+! s3-6 1)
            (set! a0-37 (-> obj data s3-6))
            )
          )
        )
       (else
         (editable-array-method-13 obj (the-as uint 14) (the-as basic 41) "pick the editable to use the y from")
         )
       )
     )
    ((= arg0 (editable-command snap-xz))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (cond
       ((-> obj target)
        (let* ((s5-9 (edit-get-trans (-> obj target)))
               (s4-13 (-> obj length))
               (s3-7 0)
               (a0-41 (-> obj data s3-7))
               )
          (while (< s3-7 s4-13)
            (if (and a0-41 (logtest? (-> a0-41 flags) (editable-flag selected)))
                (edit-coord! a0-41 s5-9 (editable-flag x z no-plane-snap))
                )
            (+! s3-7 1)
            (set! a0-41 (-> obj data s3-7))
            )
          )
        )
       (else
         (editable-array-method-13 obj (the-as uint 14) (the-as basic 40) "pick the editable to use the xz from")
         )
       )
     )
    ((= arg0 (editable-command region-set))
     (when (and (-> obj region) (not (-> obj region locked)))
       (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
       (let* ((s5-11 (-> obj length))
              (s4-15 0)
              (a0-44 (-> obj data s4-15))
              )
         (while (< s4-15 s5-11)
           (if (and a0-44 (logtest? (-> a0-44 flags) (editable-flag selected)))
               (editable-method-21 a0-44 (-> obj region))
               )
           (+! s4-15 1)
           (set! a0-44 (-> obj data s4-15))
           )
         )
       )
     )
    ((= arg0 (editable-command region-add))
     (when (and (-> obj region) (not (-> obj region locked)))
       (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
       (if (-> obj target)
           (editable-method-21 (-> obj target) (-> obj region))
           (editable-array-method-13 obj (the-as uint 14) (the-as basic 49) "pick the editable to add to current region")
           )
       )
     )
    ((= arg0 (editable-command region-new))
     (let ((v1-175 (new 'debug 'editable-region)))
       (if (and (-> obj region) (not (-> obj region locked)))
           (set! (-> v1-175 tree) (-> obj region tree))
           )
       (set! (-> obj region) v1-175)
       )
     (editable-array-method-9 obj (editable-command region-set) arg1)
     )
    ((= arg0 (editable-command flip-side))
     (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
     (let* ((s5-14 (-> obj length))
            (s4-18 0)
            (a0-58 (-> obj data s4-18))
            )
       (while (< s4-18 s5-14)
         (if (and a0-58 (logtest? (-> a0-58 flags) (editable-flag selected)))
             (editable-method-24 a0-58)
             )
         (+! s4-18 1)
         (set! a0-58 (-> obj data s4-18))
         )
       )
     )
    ((= arg0 (editable-command rotate-level))
     (let* ((f0-1 (* 182.04445 (-> obj edit-param0)))
            (s5-15 (matrix-rotate-y! (new 'stack-no-clear 'matrix) f0-1))
            (s4-19 (-> obj length))
            (s3-8 0)
            (a0-60 (-> obj data s3-8))
            )
       (while (< s3-8 s4-19)
         (if (and a0-60 region (= (-> a0-60 region level) (-> obj level)))
             (editable-method-18 a0-60 (-> obj level-offset) s5-15)
             )
         (+! s3-8 1)
         (set! a0-60 (-> obj data s3-8))
         )
       )
     )
    ((= arg0 (editable-command translate-y-level))
     (let ((s5-16 (new 'stack-no-clear 'vector)))
       (set! (-> s5-16 x) 0.0)
       (set! (-> s5-16 y) (* 4096.0 (-> obj edit-param0)))
       (set! (-> s5-16 z) 0.0)
       (set! (-> s5-16 w) 1.0)
       (let* ((s4-20 (-> obj length))
              (s3-9 0)
              (a0-61 (-> obj data s3-9))
              )
         (while (< s3-9 s4-20)
           (if (and a0-61 region (= (-> a0-61 region level) (-> obj level)))
               (editable-method-15 a0-61 s5-16 56)
               )
           (+! s3-9 1)
           (set! a0-61 (-> obj data s3-9))
           )
         )
       )
     )
    ((= arg0 (editable-command save))
     (let* ((s5-17 (-> obj length))
            (s4-21 0)
            (v1-231 (-> obj data s4-21))
            )
       (while (< s4-21 s5-17)
         (if (and v1-231 (-> v1-231 region))
             (editable-region-method-9 (-> v1-231 region) obj 0 0)
             )
         (+! s4-21 1)
         (set! v1-231 (-> obj data s4-21))
         )
       )
     (editable-region-method-9 *editable-sample-region* obj 0 0)
     (editable-region-method-9 *editable-light-region* obj 0 0)
     (editable-region-method-9 *editable-entity-region* obj 0 0)
     )
    ((= arg0 (editable-command load))
     (editable-array-method-9 obj (editable-command select-none) arg1)
     (dotimes (v1-248 (-> obj length))
       (set! (-> obj data v1-248) #f)
       )
     (set! (-> obj length) 0)
     (let* ((s5-18 obj)
            (s4-22 (method-of-object s5-18 editable-array-method-12))
            (v1-253 (level-get-target-inside *level*))
            )
       (s4-22 s5-18 (the-as editable-array (if v1-253
                                               (-> v1-253 info dbname)
                                               #f
                                               )
                            )
              )
       )
     (editable-array-method-9 obj (editable-command update-game) (the-as editable-array #f))
     )
    ((= arg0 (editable-command update-game))
    ;; TODO - waiting for lights/light-hash to be done
    ;;  (reset-light-hash *light-hash*)
    ;;  (let* ((s5-19 (-> obj length))
    ;;         (s4-23 0)
    ;;         (a0-76 (-> obj data s4-23))
    ;;         )
    ;;    (while (< s4-23 s5-19)
    ;;      (if a0-76
    ;;          (editable-method-23 a0-76)
    ;;          )
    ;;      (+! s4-23 1)
    ;;      (set! a0-76 (-> obj data s4-23))
    ;;      )
    ;;    )
    ;;  (update-light-hash *light-hash*)
     )
    ((or (= arg0 (editable-command exit)) (= arg0 (editable-command kill)))
     (deactivate self)
     )
    )
  #f
  )

(defmethod deactivate editable-player ((obj editable-player))
  (dotimes (v1-0 (-> *level* length))
    (let ((a1-3 (-> *level* level v1-0)))
      (if (= (-> a1-3 status) 'active)
          (set! (-> a1-3 light-hash) (-> a1-3 bsp light-hash))
          )
      )
    )
  (set! *editable* (the-as (pointer editable-player) #f))
  (set! *external-cam-mode* (-> obj external-cam-mode))
  ((method-of-type process-drawable deactivate) obj)
  (none)
  )

;; WARN: Return type mismatch process-drawable vs editable-player.
(defmethod relocate editable-player ((obj editable-player) (arg0 int))
  (let ((v1-0 *kernel-context*))
    (set! (-> v1-0 relocating-process) obj)
    (set! (-> v1-0 relocating-min) (the-as int (&-> obj type)))
    (set! (-> v1-0 relocating-max)
          (the-as int (+ (+ (-> obj allocated-length) -4 (-> process size)) (the-as int obj)))
          )
    (set! (-> v1-0 relocating-offset) arg0)
    )
  (let ((v1-2 (-> obj current)))
    (if (and (>= (the-as int v1-2) (-> *kernel-context* relocating-min))
             (< (the-as int v1-2) (-> *kernel-context* relocating-max))
             )
        (&+! (-> obj current) arg0)
        )
    )
  (the-as editable-player ((method-of-type process-drawable relocate) obj arg0))
  )

(defmethod editable-player-method-21 editable-player ((obj editable-player))
  (set! *display-region-marks* #f)
  (let* ((s5-0 (-> obj current length))
         (s4-0 0)
         (a0-2 (-> obj current data s4-0))
         )
    (while (< s4-0 s5-0)
      (if (and a0-2 (or (and (logtest? (-> a0-2 region filter) (-> obj current filter 0))
                             (logtest? (-> a0-2 region filter) (-> obj current filter 1))
                             )
                        (logtest? (-> a0-2 flags) (editable-flag selected))
                        )
               )
          (editable-method-10 a0-2)
          )
      (+! s4-0 1)
      (set! a0-2 (-> obj current data s4-0))
      )
    )
  (when #t
    (format *stdcon* "~0K")
    (format *stdcon* "~16S~16S~16S~%" "Left button" "Middle button" "Right button")
    (format
      *stdcon*
      "~16S~16S~16S~%"
      (editable-command->string
        (if (and (nonzero? (-> obj command 1)) (or (zero? (-> obj command 0)) (logtest? (-> *mouse* button0-abs 0) 1)))
            (the-as editable-command (-> obj command 1))
            (the-as editable-command (-> obj command 0))
            )
        )
      (editable-command->string
        (if (and (nonzero? (-> obj command 5)) (or (zero? (-> obj command 4)) (logtest? (-> *mouse* button0-abs 0) 4)))
            (the-as editable-command (-> obj command 5))
            (the-as editable-command (-> obj command 4))
            )
        )
      (editable-command->string
        (if (and (nonzero? (-> obj command 3)) (or (zero? (-> obj command 2)) (logtest? (-> *mouse* button0-abs 0) 2)))
            (the-as editable-command (-> obj command 3))
            (the-as editable-command (-> obj command 2))
            )
        )
      )
    (let* ((s5-2 (-> obj current length))
           (s4-2 0)
           (v1-35 (-> obj current data s4-2))
           )
      (while (< s4-2 s5-2)
        (when (and v1-35 (logtest? (-> v1-35 flags) (editable-flag selected)))
          (let ((s3-1 (-> v1-35 name)))
            (if (not (string-prefix= "undefined" s3-1))
                (format *stdcon* "~s~%" s3-1)
                )
            )
          )
        (+! s4-2 1)
        (set! v1-35 (-> obj current data s4-2))
        )
      )
    (when (!= *master-mode* 'menu)
      (let ((a2-5 (-> obj current target-message)))
        (if a2-5
            (format *stdcon* "~%~3L~S~0L~%" a2-5)
            )
        )
      (when (cpad-hold? 1 triangle)
        (let* ((s5-3 (-> obj current length))
               (s4-3 0)
               (a0-29 (-> obj current data s4-3))
               )
          (while (< s4-3 s5-3)
            (when (and a0-29 (or (and (logtest? (-> a0-29 region filter) (-> obj current filter 0))
                                      (logtest? (-> a0-29 region filter) (-> obj current filter 1))
                                      )
                                 (logtest? (-> a0-29 flags) (editable-flag selected))
                                 )
                       )
              (if (and (-> a0-29 region) (!= (-> a0-29 type) editable-point))
                  (editable-region-method-11 (-> a0-29 region) (edit-get-trans a0-29) (if (cpad-hold? 1 circle)
                                                                                          1
                                                                                          0
                                                                                          )
                                             )
                  )
              )
            (+! s4-3 1)
            (set! a0-29 (-> obj current data s4-3))
            )
          )
        (format *stdcon* "~%")
        (cond
          ((-> obj current region)
           (let ((s5-4 (-> obj current region)))
             (format
               *stdcon*
               "~%region: region-~D ~S ~S~S~%"
               (-> s5-4 id)
               (-> s5-4 level)
               (-> s5-4 tree)
               (if (-> s5-4 changed)
                   " (modified)"
                   ""
                   )
               )
             (format *stdcon* "     (on-enter   ~S)~%" (-> s5-4 on-enter))
             (format *stdcon* "     (on-inside  ~S)~%" (-> s5-4 on-inside))
             (format *stdcon* "     (on-exit    ~S)~%" (-> s5-4 on-exit))
             )
           )
          (else
            (format *stdcon* "no region~%")
            )
          )
        (when (-> obj current edit-plane)
          (let ((a2-13 (-> obj current edit-plane)))
            (format *stdcon* "~%edit-plane: ~A~%" a2-13)
            )
          )
        (format *stdcon* "~%selected:~%")
        (let* ((s5-5 (-> obj current length))
               (s4-4 0)
               (a2-14 (-> obj current data s4-4))
               )
          (while (< s4-4 s5-5)
            (if (and a2-14 (logtest? (-> a2-14 flags) (editable-flag selected)))
                (format *stdcon* "  ~A~%" a2-14)
                )
            (+! s4-4 1)
            (set! a2-14 (-> obj current data s4-4))
            )
          )
        )
      )
    (format *stdcon* "~1K~%")
    )
  0
  (none)
  )

(defstate idle (editable-player)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (the-as
      object
      (case event-type
        (('execute)
         (let ((a2-1 (-> event param 0)))
           (case a2-1
             ((28 27 35 29 31 32)
              (the-as object (editable-array-method-13
                               (-> self current)
                               (the-as uint 15)
                               (the-as basic a2-1)
                               "click on the point to insert at (up target, down camera)"
                               )
                      )
              )
             ((51 1 47 36 55 56)
              (if (not (-> self left-handed))
                  (the-as object (editable-array-method-13
                                   (-> self current)
                                   (the-as uint 16)
                                   (the-as basic a2-1)
                                   "press x to confirm, square to cancel"
                                   )
                          )
                  (the-as object (editable-array-method-13
                                   (-> self current)
                                   (the-as uint 16)
                                   (the-as basic a2-1)
                                   "press down to confirm, left to cancel"
                                   )
                          )
                  )
              )
             (else
               (editable-array-method-9 (-> self current) (the-as editable-command a2-1) (the-as editable-array *mouse*))
               )
             )
           )
         )
        (('exit)
         (the-as object (deactivate self))
         )
        (('menu)
         (set! v0-0 (+ (-> self clock frame-counter) (the-as time-frame (-> event param 0))))
         (set! (-> self close-menu-time) (the-as time-frame v0-0))
         v0-0
         )
        (('on-enter 'on-exit 'on-inside)
         (let ((s4-0 (-> self current region)))
           (when s4-0
             (let ((gp-1 (-> event param 0)))
               (set! (-> *syntax-context* got-error?) #f)
               (eval! *syntax-context* (the-as pair gp-1))
               (when (not (-> *syntax-context* got-error?))
                 (set! (-> s4-0 changed) #t)
                 (cond
                   ((= event-type 'on-enter)
                    (set! (-> s4-0 on-enter) (the-as string gp-1))
                    )
                   ((= event-type 'on-inside)
                    (set! (-> s4-0 on-inside) (the-as string gp-1))
                    )
                   ((= event-type 'on-exit)
                    (set! (-> s4-0 on-exit) (the-as string gp-1))
                    )
                   )
                 )
               )
             (set! v0-0 (editable-region-method-12 s4-0))
             (set! (-> s4-0 filter) (the-as editable-filter v0-0))
             v0-0
             )
           )
         )
        (('select)
         (let ((gp-2 (-> event param 0)))
           (editable-array-method-9 (-> self current) (editable-command select-none) (the-as editable-array #f))
           (let* ((s5-1 (-> self current length))
                  (s4-1 0)
                  (a0-36 (-> self current data s4-1))
                  )
             (while (< s4-1 s5-1)
               (when (and a0-36 (or (and (logtest? (-> a0-36 region filter) (-> self current filter 0))
                                         (logtest? (-> a0-36 region filter) (-> self current filter 1))
                                         )
                                    (logtest? (-> a0-36 flags) (editable-flag selected))
                                    )
                          )
                 (when (and (-> a0-36 region) (= gp-2 (-> a0-36 region id)))
                   (set! (-> self current region) (-> a0-36 region))
                   (select-editable! a0-36 #t)
                   )
                 )
               (+! s4-1 1)
               (set! a0-36 (-> self current data s4-1))
               )
             )
           )
         #f
         )
        (('name)
         (let* ((s5-2 (-> self current length))
                (s4-2 0)
                (s3-0 (-> self current data s4-2))
                )
           (while (< s4-2 s5-2)
             (when (and s3-0 (logtest? (-> s3-0 flags) (editable-flag selected)))
               (let ((v1-60 (if (type? s3-0 editable)
                                s3-0
                                )
                            )
                     )
                 (when v1-60
                   (set! (-> v1-60 name) (the-as string (-> event param 0)))
                   (logior! (-> v1-60 flags) (editable-flag changed))
                   (let ((v1-61 (-> v1-60 region)))
                     (if v1-61
                         (set! (-> v1-61 changed) #t)
                         )
                     )
                   )
                 )
               )
             (+! s4-2 1)
             (set! s3-0 (-> self current data s4-2))
             )
           )
         #f
         )
        (('level)
         (let ((gp-3 (lookup-level-info (the-as symbol (-> event param 0)))))
           (when (-> gp-3 dbname)
             (let* ((s5-3 (-> self current length))
                    (s4-3 0)
                    (s3-1 (-> self current data s4-3))
                    )
               (while (< s4-3 s5-3)
                 (when (and s3-1 (logtest? (-> s3-1 flags) (editable-flag selected)))
                   (let ((v1-73 (if (type? s3-1 editable)
                                    s3-1
                                    )
                                )
                         )
                     (when (and v1-73 (-> v1-73 region))
                       (set! (-> v1-73 region level) (the-as string (-> gp-3 dbname)))
                       (set! (-> v1-73 region changed) #t)
                       )
                     )
                   )
                 (+! s4-3 1)
                 (set! s3-1 (-> self current data s4-3))
                 )
               )
             #f
             )
           )
         )
        (('get-level)
         (-> self current level)
         )
        (('direction)
         (let* ((f30-0 (the-as float (-> event param 0)))
                (f28-0 (the-as float (-> event param 1)))
                (f26-0 (the-as float (-> event param 2)))
                (f24-0 (if (and (zero? (-> event param 0)) (zero? (-> event param 1)) (zero? (-> event param 2)))
                           0.0
                           1.0
                           )
                       )
                (gp-4 (-> self current length))
                (s5-4 0)
                (s4-4 (-> self current data s5-4))
                )
           (while (< s5-4 gp-4)
             (when (and s4-4 (logtest? (-> s4-4 flags) (editable-flag selected)))
               (let ((s3-2 (if (type? s4-4 editable-light)
                               (the-as editable-light s4-4)
                               )
                           )
                     )
                 (when s3-2
                   (set-vector! (-> s3-2 direction) f30-0 f28-0 f26-0 f24-0)
                   (vector-normalize! (-> s3-2 direction) 1.0)
                   (logior! (-> s3-2 flags) (editable-flag changed))
                   (let ((a0-73 (-> s3-2 region)))
                     (if a0-73
                         (set! (-> a0-73 changed) #t)
                         )
                     )
                   )
                 )
               )
             (+! s5-4 1)
             (set! s4-4 (-> self current data s5-4))
             )
           )
         #f
         )
        (('color)
         (let* ((f30-1 (the-as float (-> event param 0)))
                (f28-1 (the-as float (-> event param 1)))
                (f26-1 (the-as float (-> event param 2)))
                (f24-1 (the-as float (-> event param 3)))
                (gp-5 (-> self current length))
                (s5-5 0)
                (s4-5 (-> self current data s5-5))
                )
           (while (< s5-5 gp-5)
             (when (and s4-5 (logtest? (-> s4-5 flags) (editable-flag selected)))
               (let ((v1-114 (if (type? s4-5 editable-light)
                                 (the-as editable-light s4-5)
                                 )
                             )
                     )
                 (when v1-114
                   (set-vector! (-> v1-114 color) f30-1 f28-1 f26-1 f24-1)
                   (logior! (-> v1-114 flags) (editable-flag changed))
                   (let ((v1-115 (-> v1-114 region)))
                     (if v1-115
                         (set! (-> v1-115 changed) #t)
                         )
                     )
                   )
                 )
               )
             (+! s5-5 1)
             (set! s4-5 (-> self current data s5-5))
             )
           )
         #f
         )
        (('param)
         (let ((s5-6 (-> event param 0))
               (f30-2 (the-as float (-> event param 1)))
               )
           (when (and (>= (the-as int s5-6) 0) (>= 2 (the-as int s5-6)))
             (let* ((gp-6 (-> self current length))
                    (s4-6 0)
                    (s3-3 (-> self current data s4-6))
                    )
               (while (< s4-6 gp-6)
                 (when (and s3-3 (logtest? (-> s3-3 flags) (editable-flag selected)))
                   (let ((v1-129 (if (type? s3-3 editable-light)
                                     s3-3
                                     )
                                 )
                         )
                     (when v1-129
                       (set! (-> (the-as editable-light (+ (* s5-6 4) (the-as uint v1-129))) decay-start) f30-2)
                       (logior! (-> v1-129 flags) (editable-flag changed))
                       (let ((v1-130 (-> v1-129 region)))
                         (if v1-130
                             (set! (-> v1-130 changed) #t)
                             )
                         )
                       )
                     )
                   )
                 (+! s4-6 1)
                 (set! s3-3 (-> self current data s4-6))
                 )
               )
             #f
             )
           )
         )
        )
      )
    )
  :trans (behavior ()
    (let ((gp-0 (-> self current)))
      (set! (-> gp-0 move-lock?) #f)
      (when (cpad-pressed? 1 start)
        (when (!= *master-mode* 'menu)
          (set-master-mode 'menu)
          (logclear! (-> *cpad-list* cpads 1 button0-abs 0) (pad-buttons start))
          (logclear! (-> *cpad-list* cpads 1 button0-rel 0) (pad-buttons start))
          )
        )
      (when (or (and (= *master-mode* 'menu)
                     (> (-> self close-menu-time) 0)
                     (>= (-> self clock frame-counter) (-> self close-menu-time))
                     )
                (cpad-pressed? 1 start)
                )
        (debug-menu-context-send-msg *editable-menu-context* (debug-menu-msg deactivate) (debug-menu-dest activation))
        (set-master-mode 'game)
        (set! (-> self close-menu-time) 0)
        0
        )
      (debug-menus-handler *editable-menu-context*)
      (set-setting! 'cpad1-skip-buttons 'abs #t 0)
      (set-setting! 'mouse-input 'abs #f 0)
      (when (!= *master-mode* 'menu)
        (cond
          ((and (or (cpad-hold? 1 l2) (cpad-hold? 1 r2))
                (or (and (cpad-hold? 1 left) (not (-> self left-handed))) (and (cpad-hold? 1 square) (-> self left-handed)))
                )
           (set! (-> self command 0) (the-as function 48))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 47))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 49))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((and (or (cpad-hold? 1 l2) (cpad-hold? 1 r2))
                (or (and (cpad-hold? 1 right) (not (-> self left-handed))) (and (cpad-hold? 1 circle) (-> self left-handed)))
                )
           (set! (-> self command 0) (the-as function 52))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 36))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 37))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((and (or (cpad-hold? 1 l2) (cpad-hold? 1 r2))
                (or (and (cpad-hold? 1 up) (not (-> self left-handed))) (and (cpad-hold? 1 triangle) (-> self left-handed)))
                )
           (set! (-> self command 0) (the-as function 6))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 53))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 42))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((and (or (cpad-hold? 1 l2) (cpad-hold? 1 r2))
                (or (and (cpad-hold? 1 down) (not (-> self left-handed))) (and (cpad-hold? 1 x) (-> self left-handed)))
                )
           (set! (-> self command 0) (the-as function 29))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 30))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 32))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((or (cpad-hold? 1 l2) (cpad-hold? 1 r2))
           (set! (-> self command 0) (the-as function 0))
           (set! (-> self command 1) (the-as function 24))
           (set! (-> self command 2) (the-as function 0))
           (set! (-> self command 3) (the-as function 26))
           (set! (-> self command 4) (the-as function 0))
           (set! (-> self command 5) (the-as function 25))
           )
          ((and (cpad-hold? 1 up)
                (cpad-hold? 1 left)
                (or (and (cpad-hold? 1 up) (not (-> self left-handed))) (and (cpad-hold? 1 triangle) (-> self left-handed)))
                )
           (set! (-> self command 0) (the-as function 3))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 9))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 8))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((or (and (cpad-hold? 1 left) (not (-> self left-handed))) (and (cpad-hold? 1 square) (-> self left-handed)))
           (set! (-> self command 0) (the-as function 0))
           (set! (-> self command 1) (the-as function 20))
           (set! (-> self command 2) (the-as function 0))
           (set! (-> self command 3) (the-as function 22))
           (set! (-> self command 4) (the-as function 0))
           (set! (-> self command 5) (the-as function 21))
           )
          ((or (and (cpad-hold? 1 right) (not (-> self left-handed))) (and (cpad-hold? 1 circle) (-> self left-handed)))
           (set! (-> self command 0) (the-as function 31))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 27))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 28))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((or (and (cpad-hold? 1 up) (not (-> self left-handed))) (and (cpad-hold? 1 triangle) (-> self left-handed)))
           (set! (-> self command 0) (the-as function 3))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 4))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 7))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          ((or (and (cpad-hold? 1 down) (not (-> self left-handed))) (and (cpad-hold? 1 x) (-> self left-handed)))
           (set! (-> self command 0) (the-as function 33))
           (set! (-> self command 1) (the-as function 0))
           (set! (-> self command 2) (the-as function 35))
           (set! (-> self command 3) (the-as function 0))
           (set! (-> self command 4) (the-as function 34))
           (set! (-> self command 5) (the-as function 0))
           0
           )
          (else
            (set! (-> self command 0) (the-as function 0))
            (set! (-> self command 1) (the-as function 18))
            (set! (-> self command 2) (the-as function 0))
            (set! (-> self command 3) (the-as function 23))
            (set! (-> self command 4) (the-as function 0))
            (set! (-> self command 5) (the-as function 19))
            )
          )
        (case (-> self current target-mode)
          ((14 15)
           (set! (-> self command 0) (the-as function (-> self current target-mode)))
           )
          ((16)
           (when (!= *master-mode* 'menu)
             (cond
               ((not (-> self left-handed))
                (cond
                  ((cpad-hold? 1 x)
                   (logclear! (-> *cpad-list* cpads 1 button0-abs 0) (pad-buttons x))
                   (logclear! (-> *cpad-list* cpads 1 button0-rel 0) (pad-buttons x))
                   (editable-array-method-9
                     gp-0
                     (the-as editable-command (-> self current target-mode))
                     (the-as editable-array *mouse*)
                     )
                   )
                  ((cpad-pressed? 1 square)
                   (logclear! (-> *cpad-list* cpads 1 button0-abs 0) (pad-buttons square))
                   (logclear! (-> *cpad-list* cpads 1 button0-rel 0) (pad-buttons square))
                   (editable-array-method-9 gp-0 (editable-command cancel) (the-as editable-array *mouse*))
                   )
                  )
                )
               (else
                 (cond
                   ((cpad-hold? 1 down)
                    (logclear! (-> *cpad-list* cpads 1 button0-abs 0) (pad-buttons down))
                    (logclear! (-> *cpad-list* cpads 1 button0-rel 0) (pad-buttons down))
                    (editable-array-method-9
                      gp-0
                      (the-as editable-command (-> self current target-mode))
                      (the-as editable-array *mouse*)
                      )
                    )
                   ((cpad-pressed? 1 left)
                    (logclear! (-> *cpad-list* cpads 1 button0-abs 0) (pad-buttons left))
                    (logclear! (-> *cpad-list* cpads 1 button0-rel 0) (pad-buttons left))
                    (editable-array-method-9 gp-0 (editable-command cancel) (the-as editable-array *mouse*))
                    )
                   )
                 )
               )
             )
           )
          )
        (if (logtest? (-> *mouse* button0-rel 0) 1)
            (editable-array-method-9 gp-0 (the-as editable-command (-> self command 0)) (the-as editable-array *mouse*))
            )
        (if (logtest? (-> *mouse* button0-abs 0) 1)
            (editable-array-method-9 gp-0 (the-as editable-command (-> self command 1)) (the-as editable-array *mouse*))
            )
        (if (logtest? (-> *mouse* button0-rel 0) 2)
            (editable-array-method-9 gp-0 (the-as editable-command (-> self command 2)) (the-as editable-array *mouse*))
            )
        (if (logtest? (-> *mouse* button0-abs 0) 2)
            (editable-array-method-9 gp-0 (the-as editable-command (-> self command 3)) (the-as editable-array *mouse*))
            )
        (when (logtest? (-> *mouse* button0-rel 0) 4)
          (let ((a2-11 (-> self command 4)))
            (case a2-11
              ((36)
               (if (not (-> self left-handed))
                   (editable-array-method-13 gp-0 (the-as uint 16) a2-11 "press x to confirm, square to cancel")
                   (editable-array-method-13 gp-0 (the-as uint 16) a2-11 "press down to confirm, left to cancel")
                   )
               )
              (else
                (editable-array-method-9 gp-0 (the-as editable-command a2-11) (the-as editable-array *mouse*))
                )
              )
            )
          )
        (if (logtest? (-> *mouse* button0-abs 0) 4)
            (editable-array-method-9 gp-0 (the-as editable-command (-> self command 5)) (the-as editable-array *mouse*))
            )
        )
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  :post (behavior ()
    (editable-player-method-21 self)
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defbehavior editable-player-init editable-player ((arg0 symbol))
  (set! *editable-temp-id* 0)
  (set! *display-profile* #f)
  (set! *display-entity-errors* #f)
  (set! *display-actor-marks* #f)
  (logclear! (-> self mask) (process-mask freeze pause menu))
  (set! (-> self clock) (-> *display* real-clock))
  (set! (-> self current) (new 'debug 'editable-array 4096))
  (add-setting! 'mouse #t 0 0)
  (add-setting! 'cursor #t 0 0)
  (set! (-> self select-command) (the-as function 3))
  (set! (-> self move-command) (the-as function 18))
  (set! (-> self extra-command) (the-as function 23))
  (set! (-> self left-handed) #f)
  (set! (-> self light-names) #f)
  (set! (-> self command 0) (-> self select-command))
  (set! (-> self command 1) (the-as function 0))
  (set! (-> self command 2) (the-as function 0))
  (set! (-> self command 3) (-> self extra-command))
  (set! (-> self command 4) (the-as function 0))
  (set! (-> self command 5) (-> self move-command))
  (let* ((s5-0 (-> self current))
         (s4-0 (method-of-object s5-0 editable-array-method-12))
         (s3-0 (if arg0
                   (lookup-level-info arg0)
                   )
               )
         (gp-1 (level-get-target-inside *level*))
         (a1-5 (cond
                 (s3-0
                   (let ((gp-2 (level-get *level* (-> s3-0 dbname))))
                     (when gp-2
                       (format 0 "setting level~d ~s to *light-hash*~%" (-> gp-2 index) (-> gp-2 name))
                       (set! (-> gp-2 light-hash) *light-hash*)
                       )
                     )
                   (-> s3-0 dbname)
                   )
                 (gp-1
                   (let ((s3-1 (level-get *level* (-> gp-1 info dbname))))
                     (when s3-1
                       (format 0 "setting level~d ~s to *light-hash*~%" (-> s3-1 index) (-> s3-1 name))
                       (set! (-> s3-1 light-hash) *light-hash*)
                       )
                     )
                   (-> gp-1 info dbname)
                   )
                 )
               )
         )
    (s4-0 s5-0 (the-as editable-array a1-5))
    )
  (set! *editable* (the-as (pointer editable-player) (process->ppointer self)))
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (set! (-> self external-cam-mode) *external-cam-mode*)
  (set! *external-cam-mode* 'pad-1)
  (editable-array-method-9 (-> self current) (editable-command update-game) (the-as editable-array #f))
  (go-virtual idle)
  (none)
  )

(define *editable-menu-context* (new 'debug 'debug-menu-context))

(set! (-> *editable-menu-context* joypad-number) 1)

;; WARN: Return type mismatch object vs none.
(defun editable-menu-command ((arg0 int))
  (send-event (ppointer->process *editable*) 'execute (/ arg0 8))
  (send-event (ppointer->process *editable*) 'menu 90)
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defun editable-menu-command-no-close ((arg0 int))
  (send-event (ppointer->process *editable*) 'execute (/ arg0 8))
  (none)
  )

;; WARN: Return type mismatch object vs symbol.
(defun dm-region-tree-pick-func ((arg0 symbol) (arg1 debug-menu-msg))
  (when (= arg1 (debug-menu-msg press))
    (when (and *editable* (-> *editable* 0 current region))
      (let ((s5-0 (-> *editable* 0 current region)))
        (set! (-> s5-0 tree) (the-as string arg0))
        (set! (-> s5-0 changed) #t)
        (set! (-> s5-0 filter) (editable-region-method-12 s5-0))
        )
      )
    )
  (the-as
    symbol
    (and *editable* (-> *editable* 0 current region) (= arg0 (-> *editable* 0 current region tree)))
    )
  )

(defun dm-editable-flag-pick-func ((arg0 editable-flag) (arg1 debug-menu-msg))
  (when *editable*
    (let ((gp-0 (/ (the-as int arg0) 8)))
      (editable-array-method-14 (-> *editable* 0 current) true-func #f)
      (when (= arg1 (debug-menu-msg press))
        (let* ((v1-10 (-> *editable* 0 current length))
               (a0-2 0)
               (a1-4 (-> *editable* 0 current data a0-2))
               )
          (while (< a0-2 v1-10)
            (if (and a1-4 (logtest? (-> a1-4 flags) (editable-flag selected)))
                (logxor! (-> a1-4 flags) (the-as uint gp-0))
                )
            (+! a0-2 1)
            (set! a1-4 (-> *editable* 0 current data a0-2))
            )
          )
        )
      (and (>= (-> *editable* 0 current selection length) 1)
           (logtest? (-> *editable* 0 current selection 0 flags) gp-0)
           )
      )
    )
  )

(defun dm-editable-filter0-pick-func ((arg0 editable-filter) (arg1 debug-menu-msg))
  (when *editable*
    (let ((v1-1 (/ (the-as int arg0) 8)))
      (if (= arg1 (debug-menu-msg press))
          (logxor! (-> *editable* 0 current filter 0) (the-as uint v1-1))
          )
      (logtest? (-> *editable* 0 current filter 0) v1-1)
      )
    )
  )

(defun dm-editable-filter1-pick-func ((arg0 editable-filter) (arg1 debug-menu-msg))
  (when *editable*
    (let ((v1-1 (/ (the-as int arg0) 8)))
      (if (= arg1 (debug-menu-msg press))
          (logxor! (-> *editable* 0 current filter 1) (the-as uint v1-1))
          )
      (logtest? (-> *editable* 0 current filter 1) v1-1)
      )
    )
  )

(defun dm-editable-light-float-func ((arg0 int) (arg1 debug-menu-msg) (arg2 float) (arg3 float))
  (cond
    ((not *editable*)
     arg3
     )
    ((= arg1 (debug-menu-msg press))
     (let* ((s4-0 (-> *editable* 0 current length))
            (s3-0 0)
            (s2-0 (-> *editable* 0 current data s3-0))
            )
       (while (< s3-0 s4-0)
         (when (and s2-0 (logtest? (-> s2-0 flags) (editable-flag selected)))
           (let ((a0-7 (if (type? s2-0 editable-light)
                           s2-0
                           )
                       )
                 )
             (when (the-as editable a0-7)
               (set! (-> (&+ (the-as (pointer float) a0-7) (/ arg0 8)) 0) arg2)
               (logior! (-> (the-as editable a0-7) flags) (editable-flag changed))
               (let ((v1-15 (-> (the-as editable a0-7) region)))
                 (if v1-15
                     (set! (-> v1-15 changed) #t)
                     )
                 )
               (update-light-sphere-from-editable-light (the-as editable-light a0-7))
               )
             )
           )
         (+! s3-0 1)
         (set! s2-0 (-> *editable* 0 current data s3-0))
         )
       )
     (the-as float #f)
     )
    (else
      (let ((f30-0 arg3))
        (let* ((s5-1 (-> *editable* 0 current length))
               (s4-1 0)
               (s3-1 (-> *editable* 0 current data s4-1))
               )
          (while (< s4-1 s5-1)
            (when (and s3-1 (logtest? (-> s3-1 flags) (editable-flag selected)))
              (let ((v1-29 (if (type? s3-1 editable-light)
                               s3-1
                               )
                           )
                    )
                (if (the-as editable v1-29)
                    (set! f30-0 (-> (&+ (the-as (pointer float) v1-29) (/ arg0 8)) 0))
                    )
                )
              )
            (+! s4-1 1)
            (set! s3-1 (-> *editable* 0 current data s4-1))
            )
          )
        f30-0
        )
      )
    )
  )

(defun dm-cam-externalize2 ((arg0 symbol) (arg1 debug-menu-msg))
  (when (= arg1 (debug-menu-msg press))
    (cond
      ((= arg0 'reset)
       (if (!= *external-cam-mode* 'locked)
           (external-cam-reset!)
           )
       )
      ((= arg0 'allow-z)
       (set! *external-cam-options* (logxor *external-cam-options* (external-cam-option allow-z)))
       )
      ((= *external-cam-mode* arg0)
       (set! *external-cam-mode* #f)
       )
      (else
        (if (not *external-cam-mode*)
            (external-cam-reset!)
            )
        (set! *external-cam-mode* arg0)
        )
      )
    )
  (if (= arg0 'allow-z)
      (logtest? *external-cam-options* (external-cam-option allow-z))
      (= *external-cam-mode* arg0)
      )
  )

(defun dm-editable-boolean-toggle-pick-func ((arg0 int) (arg1 debug-menu-msg))
  (cond
    (*editable*
      (let ((v1-3 (&+ (the-as (pointer symbol) (-> *editable* 0)) (/ arg0 8))))
        (if (= arg1 (debug-menu-msg press))
            (set! (-> v1-3 0) (not (-> v1-3 0)))
            )
        (-> v1-3 0)
        )
      )
    (else
      #f
      )
    )
  )

(defun editable-menu-context-make-menus ((arg0 debug-menu-context))
  (debug-menu-make-from-template
    arg0
    '(main-menu
       "Editable"
       (flag "Cam 1" pad-1 dm-cam-externalize2)
       (flag "Left Handed" 212 dm-editable-boolean-toggle-pick-func)
       (menu
         "Insert"
         (function "Sphere" 27 editable-menu-command)
         (function "Point" 28 editable-menu-command)
         (function "Sample" 29 editable-menu-command)
         (function "Light" 31 editable-menu-command)
         (function "Entity" 32 editable-menu-command)
         (function "Face" 33 editable-menu-command)
         (function "Plane" 34 editable-menu-command)
         (function "Box" 35 editable-menu-command)
         (function "Edit-Plane Set" 45 editable-menu-command)
         (function "Edit-Plane Clear" 46 editable-menu-command)
         )
       (menu
         "Select"
         (function "None" 6 editable-menu-command)
         (function "All" 5 editable-menu-command)
         (function "Owner" 10 editable-menu-command)
         (function "Current Region" 11 editable-menu-command)
         (function "Current Face" 12 editable-menu-command)
         (function "Current Prim" 13 editable-menu-command)
         )
       (menu
         "Selection"
         (function "Copy" 37 editable-menu-command)
         (function "Delete" 36 editable-menu-command)
         (function "Flip Side" 42 editable-menu-command)
         (function "Snap to Ground" 39 editable-menu-command)
         (function "Snap XZ" 40 editable-menu-command)
         (function "Snap Y" 41 editable-menu-command)
         (function "Resize to Param" 38 editable-menu-command)
         (function "Set to current Region" 43 editable-menu-command)
         (function "Set to new Region" 44 editable-menu-command)
         (flag "No Save" 2 dm-editable-flag-pick-func)
         (flag "Top Set" 512 dm-editable-flag-pick-func)
         (flag "Bot Set" 1024 dm-editable-flag-pick-func)
         )
       (menu
         "Region"
         (function "Print Info" 53 editable-menu-command)
         (function "Copy" 48 editable-menu-command)
         (function "Delete" 47 editable-menu-command)
         (function "Add to current Region" 49 editable-menu-command)
         (flag
           "Region Lock"
           #f
           ,(lambda ((arg0 int) (arg1 float) (arg2 float))
              (if (= (the-as int arg1) 4)
                  (set! (-> *editable* 0 current region-lock?) (not (-> *editable* 0 current region-lock?)))
                  )
              (-> *editable* 0 current region-lock?)
              )
           )
         (flag "Camera" camera dm-region-tree-pick-func)
         (flag "Target" target dm-region-tree-pick-func)
         (flag "Water" water dm-region-tree-pick-func)
         (flag "Data" data dm-region-tree-pick-func)
         (flag "City Vis" city_vis dm-region-tree-pick-func)
         )
       (menu
         "Filter"
         (flag "None" 1 dm-editable-filter0-pick-func)
         (flag "Unknown" 2 dm-editable-filter0-pick-func)
         (flag "Sound" 4 dm-editable-filter0-pick-func)
         (flag "Part" 8 dm-editable-filter0-pick-func)
         (flag "Load" 64 dm-editable-filter0-pick-func)
         (flag "User Setting" 16 dm-editable-filter0-pick-func)
         (flag "Cam Setting" 32 dm-editable-filter0-pick-func)
         (flag "Camera" 256 dm-editable-filter1-pick-func)
         (flag "Target" 512 dm-editable-filter1-pick-func)
         (flag "Water" 1024 dm-editable-filter1-pick-func)
         (flag "Data" 2048 dm-editable-filter1-pick-func)
         (flag "Sample" 8192 dm-editable-filter1-pick-func)
         (flag "Light" 16384 dm-editable-filter1-pick-func)
         (flag "Entity" 32768 dm-editable-filter1-pick-func)
         (flag "City Vis" 4096 dm-editable-filter1-pick-func)
         )
       (menu
         "Light"
         (flag "Show Light Names" 216 dm-editable-boolean-toggle-pick-func)
         (float-var
           "Red"
           60
           dm-editable-light-float-func
           2
           (new 'static 'bfloat :data 0.00390625)
           #t
           0
           (new 'static 'bfloat :data 1.9921875)
           0
           )
         (float-var
           "Green"
           64
           dm-editable-light-float-func
           2
           (new 'static 'bfloat :data 0.00390625)
           #t
           0
           (new 'static 'bfloat :data 1.9921875)
           0
           )
         (float-var
           "Blue"
           68
           dm-editable-light-float-func
           2
           (new 'static 'bfloat :data 0.00390625)
           #t
           0
           (new 'static 'bfloat :data 1.9921875)
           0
           )
         (float-var
           "Palette Index"
           72
           dm-editable-light-float-func
           2
           (new 'static 'bfloat :data 1.0)
           #t
           (new 'static 'bfloat :data -1.0)
           (new 'static 'bfloat :data 7.0)
           0
           )
         (float-var "Decay Start" 76 dm-editable-light-float-func 2 (new 'static 'bfloat :data 0.00390625) #t 0 1 0)
         (float-var
           "Ambient Point Ratio"
           80
           dm-editable-light-float-func
           2
           (new 'static 'bfloat :data 0.00390625)
           #t
           0
           1
           0
           )
         (float-var "Brightness" 84 dm-editable-light-float-func 2 (new 'static 'bfloat :data 0.00390625) #t 0 1 0)
         )
       (float-var
         "Param"
         #f
         ,(lambda ((arg0 int) (arg1 float) (arg2 float)) (cond
                                                           ((= (the-as int arg1) 4)
                                                            (if (and *editable* (nonzero? *editable*))
                                                                (set! (-> *editable* 0 current edit-param0) arg2)
                                                                )
                                                            )
                                                           ((or (not *editable*) (zero? *editable*))
                                                            0.0
                                                            )
                                                           (else
                                                             (-> *editable* 0 current edit-param0)
                                                             )
                                                           )
                  )
         3
         (new 'static 'bfloat :data 0.5)
         #t
         0
         500
         1
         )
       (function "Rotate Level" 55 editable-menu-command)
       (function "Trans Y Level" 56 editable-menu-command)
       (function "Revert" 51 editable-menu-command)
       (function "Save" 50 editable-menu-command-no-close)
       (function "Update Game" 52 editable-menu-command-no-close)
       (function "Cancel" 17 editable-menu-command)
       (function "Exit" 1 editable-menu-command)
       )
    )
  arg0
  )

(editable-menu-context-make-menus *editable-menu-context*)

;; WARN: Function insert-sample-camera has a return type of none, but the expression builder found a return statement.
(defun insert-sample-camera ((arg0 symbol))
  (cond
    (level
      (let ((s5-0 sql-query))
        (format
          (clear *temp-string*)
          "select translate_x,translate_y,translate_z,level_info_id from level_info where name='~S'"
          arg0
          )
        (let ((s5-1 (s5-0 *temp-string*)))
          (cond
            ((and (= (-> s5-1 error) 'select) (= (-> s5-1 len) 4))
             (let ((f26-0 (* 4096.0 (string->float (-> s5-1 data 0))))
                   (f28-0 (* 4096.0 (string->float (-> s5-1 data 1))))
                   (f30-3 (* 4096.0 (string->float (-> s5-1 data 2))))
                   (s5-2 (string->int (-> s5-1 data 3)))
                   (s3-0 (math-camera-pos))
                   (s4-1 (clear *temp-string*))
                   )
               (format
                 s4-1
                 "insert into sample_point set level_info_id=~D,x=~f,y=~f,z=~f,source='manual'"
                 s5-2
                 (* 0.00024414062 (- (-> s3-0 x) f26-0))
                 (* 0.00024414062 (- (-> s3-0 y) f28-0))
                 (* 0.00024414062 (- (-> s3-0 z) f30-3))
                 )
               (let ((a2-2 (sql-query s4-1)))
                 (cond
                   ((= (-> a2-2 error) 'modify)
                    (format
                      (clear s4-1)
                      "update level_info set last_update=last_update, sample_point_update=NULL where level_info_id=~D"
                      s5-2
                      )
                    (let ((a2-4 (sql-query s4-1)))
                      (when (!= (-> a2-4 error) 'modify)
                        (format 0 "ERROR: sql: modify error ~A~%" a2-4)
                        (return #f)
                        )
                      )
                    (sound-play-by-spec (static-sound-spec "beep" :fo-curve 1) (new-sound-id) (the-as vector #t))
                    (format #t "EDITABLE: saved camera sample point for level ~A~%" arg0)
                    )
                   (else
                     (format 0 "ERROR: sql: insert error ~A~%" a2-2)
                     )
                   )
                 )
               )
             )
            (else
              (format 0 "ERROR: sql: select error ~A~%" s5-1)
              )
            )
          )
        )
      )
    (else
      (format 0 "ERROR: EDITABLE: no current level~%")
      )
    )
  0
  (none)
  )

(define *debug-hook* (cons
                       (lambda ()
                         (when (and *debug-segment* *manual-sample-point*)
                           (when (cpad-pressed? 1 select)
                             (cond
                               (*editable*
                                 )
                               ((not *artist-fix-visible*)
                                (insert-sample-camera (-> (level-get-target-inside *level*) info dbname))
                                )
                               (else
                                 (dotimes (gp-1 (-> *level* length))
                                   (let ((v1-14 (-> *level* level gp-1)))
                                     (when (= (-> v1-14 status) 'active)
                                       (if (not (logtest? *fix-visible-level-mask* (ash 1 (-> v1-14 index))))
                                           (insert-sample-camera (-> v1-14 name))
                                           )
                                       )
                                     )
                                   )
                                 )
                               )
                             )
                           )
                         (none)
                         )
                       *debug-hook*
                       )
        )
