;;-*-Lisp-*-
(in-package goal)

;; name: editable.gc
;; name in dgo: editable
;; dgos: ENGINE, GAME

;; og:ignore-form:editable-face-method-27
;; og:ignore-form:editable-face-method-29
;; og:ignore-form:editable-plane-method-27
;; og:ignore-form:editable-array-method-12
;; og:ignore-form:defmethod edit-get-distance editable-face
;; og:ignore-form:defmethod edit-get-distance editable-plane

;; DECOMP BEGINS

;; this file is debug only
(declare-file (debug))
(when *debug-segment*
(defmethod new editable-region ((allocation symbol) (type-to-make type))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 changed) #t)
    (set! (-> gp-0 locked) #f)
    (let ((v1-4 (level-get-target-inside *level*)))
      (set! (-> gp-0 level) (the-as string (if v1-4
                                               (-> v1-4 info dbname)
                                               )
                                    )
            )
      )
    (set! (-> gp-0 tree) (the-as string 'camera))
    (set! (-> gp-0 on-enter) #f)
    (set! (-> gp-0 on-exit) #f)
    (set! (-> gp-0 on-inside) #f)
    (set! (-> gp-0 filter) (editable-region-method-12 gp-0))
    gp-0
    )
  )

(defmethod print editable-region ((obj editable-region))
  (format #t "#<~A region-~D ~A ~A @ #x~X>" (-> obj type) (-> obj id) (-> obj level) (-> obj tree) obj)
  obj
  )

(defmethod editable-region-method-10 editable-region ((obj editable-region) (arg0 int))
  (local-vars (sv-16 string) (sv-32 string))
  (when (nonzero? (-> obj id))
    (let ((s5-0 (clear *temp-string*)))
      (format s5-0 "delete from region_sphere where region_id=~D" (-> obj id))
      (let ((a2-1 (sql-query s5-0)))
        (when (!= (-> a2-1 error) 'modify)
          (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-1 obj)
          (return #t)
          )
        )
      (clear s5-0)
      (format s5-0 "select region_face_id from region_face where region_id=~D" (-> obj id))
      (let ((s3-0 (sql-query s5-0)))
        (when (!= (-> s3-0 error) 'select)
          (format 0 "ERROR: sql: face select error ~A for ~A~%" s3-0 obj)
          (return #t)
          )
        (when (> (-> s3-0 len) 0)
          (clear s5-0)
          (format s5-0 "delete from region_point where region_face_id in (")
          (dotimes (s2-0 (-> s3-0 len))
            (cond
              ((zero? s2-0)
               (let ((s1-0 format)
                     (s0-0 s5-0)
                     )
                 (set! sv-16 "~D")
                 (let ((a2-4 (string->int (the-as string (-> s3-0 data s2-0)))))
                   (s1-0 s0-0 sv-16 a2-4)
                   )
                 )
               )
              (else
                (let ((s1-1 format)
                      (s0-1 s5-0)
                      )
                  (set! sv-32 ",~D")
                  (let ((a2-5 (string->int (the-as string (-> s3-0 data s2-0)))))
                    (s1-1 s0-1 sv-32 a2-5)
                    )
                  )
                )
              )
            )
          (format s5-0 ")")
          (let ((a2-6 (sql-query s5-0)))
            (when (!= (-> a2-6 error) 'modify)
              (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-6 obj)
              (return #t)
              )
            )
          )
        )
      (clear s5-0)
      (format s5-0 "delete from region_face where region_id=~D" (-> obj id))
      (let ((a2-8 (sql-query s5-0)))
        (when (!= (-> a2-8 error) 'modify)
          (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-8 obj)
          (return #t)
          )
        )
      (when (zero? arg0)
        (clear s5-0)
        (format s5-0 "delete from region where region_id=~D" (-> obj id))
        (let ((a2-10 (sql-query s5-0)))
          (when (!= (-> a2-10 error) 'modify)
            (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-10 obj)
            (return #t)
            )
          )
        )
      )
    )
  #f
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod editable-region-method-11 editable-region ((obj editable-region) (arg0 vector) (arg1 int))
  (local-vars (sv-32 vector2h))
  (set! sv-32 (new 'stack 'vector2h))
  (add-debug-x #t (bucket-id debug-no-zbuf1) arg0 (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0)))
  (let ((s3-0 add-debug-text-3d)
        (s2-0 #t)
        (s1-0 318)
        )
    (format (clear *temp-string*) "region-~D~%" (-> obj id))
    (s3-0 s2-0 (the-as bucket-id s1-0) *temp-string* arg0 (font-color #dadada) sv-32)
    )
  (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
  (when (>= arg1 1)
    (let ((s4-1 (-> obj on-enter)))
      (when s4-1
        (let ((s3-1 add-debug-text-3d)
              (s2-1 #t)
              (s1-1 318)
              )
          (format (clear *temp-string*) "(on-enter ~S)" s4-1)
          (s3-1 s2-1 (the-as bucket-id s1-1) *temp-string* arg0 (font-color #dadada) sv-32)
          )
        (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
        )
      )
    (let ((s4-2 (-> obj on-inside)))
      (when s4-2
        (let ((s3-2 add-debug-text-3d)
              (s2-2 #t)
              (s1-2 318)
              )
          (format (clear *temp-string*) "(on-inside ~S)" s4-2)
          (s3-2 s2-2 (the-as bucket-id s1-2) *temp-string* arg0 (font-color #dadada) sv-32)
          )
        (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
        )
      )
    (let ((s5-1 (-> obj on-exit)))
      (when s5-1
        (let ((s4-3 add-debug-text-3d)
              (s3-3 #t)
              (s2-3 318)
              )
          (format (clear *temp-string*) "(on-exit ~S)" s5-1)
          (s4-3 s3-3 (the-as bucket-id s2-3) *temp-string* arg0 (font-color #dadada) sv-32)
          )
        (set! (-> sv-32 y) (the-as int (+ (-> sv-32 y) 8)))
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs editable-filter.
(defmethod editable-region-method-12 editable-region ((obj editable-region))
  (let* ((s5-0 0)
         (s4-0 (lambda ((arg0 string)) (let ((gp-0 0))
                                         (when (not (type? arg0 string))
                                           (format (clear *temp-string*) "~A" arg0)
                                           (set! arg0 *temp-string*)
                                           )
                                         (if (>= (string-position "(sound-play" arg0) 0)
                                             (set! gp-0 (logior gp-0 4))
                                             )
                                         (if (>= (string-position "(part-tracker" arg0) 0)
                                             (set! gp-0 (logior gp-0 8))
                                             )
                                         (if (>= (string-position "(want-" arg0) 0)
                                             (set! gp-0 (logior gp-0 64))
                                             )
                                         (if (>= (string-position "(setting-" arg0) 0)
                                             (set! gp-0 (logior gp-0 16))
                                             )
                                         (if (>= (string-position "(water" arg0) 0)
                                             (set! gp-0 (logior gp-0 128))
                                             )
                                         gp-0
                                         )
                       )
               )
         (v0-3
           (logior (logior (logior s5-0 (s4-0 (-> obj on-inside))) (s4-0 (-> obj on-enter))) (s4-0 (-> obj on-exit)))
           )
         )
    (when (zero? v0-3)
      (if (and (not (-> obj on-inside)) (not (-> obj on-enter)) (not (-> obj on-exit)))
          (set! v0-3 1)
          (set! v0-3 2)
          )
      )
    (case (-> obj tree)
      (('target)
       (set! v0-3 (logior v0-3 512))
       )
      (('camera)
       (set! v0-3 (logior v0-3 256))
       )
      (('data)
       (set! v0-3 (logior v0-3 2048))
       )
      (('water)
       (set! v0-3 (logior v0-3 1024))
       )
      (('city_vis)
       (set! v0-3 4096)
       )
      (('sample)
       (set! v0-3 8192)
       )
      (('light)
       (set! v0-3 #x4000)
       )
      (('entity)
       (set! v0-3 #x8000)
       )
      )
    (the-as editable-filter v0-3)
    )
  )

(defmethod editable-method-23 editable ((obj editable))
  #t
  )

(defmethod editable-method-28 editable ((obj editable) (arg0 editable-filter))
  (let* ((s5-0 (-> obj owner))
         (a0-1 (car s5-0))
         )
    (while (not (null? s5-0))
      (editable-method-28 (the-as editable a0-1) arg0)
      (set! s5-0 (cdr s5-0))
      (set! a0-1 (car s5-0))
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs symbol.
(defmethod editable-method-29 editable ((obj editable) (arg0 editable-filter))
  (let* ((s5-0 (-> obj owner))
         (a0-1 (car s5-0))
         )
    (while (not (null? s5-0))
      (editable-method-29 (the-as editable a0-1) arg0)
      (set! s5-0 (cdr s5-0))
      (set! a0-1 (car s5-0))
      )
    )
  (the-as symbol 0)
  )

(defmethod editable-method-21 editable ((obj editable) (arg0 editable-region))
  (when (not (and (-> obj region) (-> obj region locked)))
    (if arg0
        (set! (-> arg0 changed) #t)
        )
    (if (-> obj region)
        (set! (-> obj region changed) #t)
        )
    (logior! (-> obj flags) (editable-flag changed))
    (set! (-> obj region) arg0)
    )
  0
  (none)
  )

;; WARN: Return type mismatch int vs rgba.
(defmethod get-color editable ((obj editable) (arg0 int))
  "Returns the [[rgba]] that corresponds to the type of [[editable]] TODO - document the colors"
  (the-as rgba (cond
                 ((and (logtest? (-> obj flags) (editable-flag selected))
                       (< (mod (-> *display* real-clock frame-counter) 60) 30)
                       )
                  (the-as int (-> (new 'static 'array uint64 1 #x80ffffff) 0))
                  )
                 ((logtest? (-> obj flags) (editable-flag no-save))
                  (shl #x80ff 16)
                  )
                 ((= (-> obj type) editable-point)
                  (the-as int (-> (new 'static 'array uint64 1 #x800080ff) 0))
                  )
                 ((= (-> obj type) editable-sample)
                  (the-as int (-> (new 'static 'array uint64 1 #x80ff8000) 0))
                  )
                 ((= (-> obj type) editable-light)
                  (the-as int (-> (new 'static 'array uint64 1 #x80ff0080) 0))
                  )
                 ((= (-> obj type) editable-entity)
                  (the-as int (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
                  )
                 (else
                   (the-as int (-> (new 'static 'array uint64 1 #x800000ff) 0))
                   )
                 )
          )
  )

(defmethod editable-method-10 editable ((obj editable))
  (when (logtest? (-> obj flags) (editable-flag selected))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (when (editable-method-11 obj s5-0)
        (set! (-> s5-0 y) (-> s5-0 y))
        (add-debug-x #t (bucket-id debug-no-zbuf1) s5-0 (the-as rgba (-> (new 'static 'array uint64 1 #x80ffffff) 0)))
        )
      )
    (add-debug-x
      #t
      (bucket-id debug-no-zbuf1)
      (edit-get-trans obj)
      (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
      )
    )
  0
  (none)
  )

(defmethod select-editable! editable ((obj editable) (arg0 symbol))
  (case arg0
    (('toggle)
     (logxor! (-> obj flags) (editable-flag selected))
     )
    ((#f)
     (logclear! (-> obj flags) (editable-flag selected))
     )
    (else
      (logior! (-> obj flags) (editable-flag selected))
      )
    )
  0
  (none)
  )

(defmethod edit-get-distance editable ((obj editable) (arg0 vector))
  "Returns the distance from the camera to the [[editable]], or -1.0"
  -1.0
  )

(defmethod editable-method-20 editable ((obj editable) (arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (local-vars (sv-48 vector) (sv-52 vector))
  (set! sv-48 (new 'stack-no-clear 'vector))
  (set! sv-52 (new 'stack-no-clear 'vector))
  (let ((s4-0 (edit-get-trans obj)))
    (reverse-transform-point! sv-48 s4-0 arg2 arg0)
    (reverse-transform-point! sv-52 s4-0 arg2 arg1)
    (vector-! arg3 sv-52 sv-48)
    (vector-! (new 'stack-no-clear 'vector) s4-0 (-> *math-camera* trans))
    )
  (if (< 20480.0 (vector-length arg3))
      (vector-normalize! arg3 20480.0)
      )
  (editable-method-15 obj arg3 56)
  0
  (none)
  )

(defmethod editable-method-11 editable ((obj editable) (arg0 vector))
  (with-pp
    (let ((s5-0 (new 'stack 'collide-query)))
      (set! (-> s5-0 start-pos quad) (-> (edit-get-trans obj) quad))
      (set-vector! (-> s5-0 move-dist) 0.0 -204800.0 0.0 1.0)
      (let ((v1-5 s5-0))
        (set! (-> v1-5 radius) 40.96)
        (set! (-> v1-5 collide-with)
              (collide-spec backgnd crate obstacle hit-by-player-list hit-by-others-list collectable pusher)
              )
        (set! (-> v1-5 ignore-process0) pp)
        (set! (-> v1-5 ignore-process1) #f)
        (set! (-> v1-5 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-5 action-mask) (collide-action solid))
        )
      (when (>= (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
        (set! (-> arg0 quad) (-> s5-0 best-other-tri intersect quad))
        #t
        )
      )
    )
  )

(defmethod editable-method-24 editable ((obj editable))
  0
  (none)
  )

(defmethod editable-method-17 editable ((obj editable) (arg0 vector))
  0
  (none)
  )

(defmethod editable-method-22 editable ((obj editable) (arg0 editable-array) (arg1 int) (arg2 int))
  #t
  )

(defmethod editable-method-15 editable ((obj editable) (arg0 vector) (arg1 int))
  0
  (none)
  )

(defmethod edit-coord! editable ((obj editable) (arg0 vector) (arg1 editable-flag))
  0
  (none)
  )

(defmethod editable-method-18 editable ((obj editable) (arg0 vector) (arg1 matrix))
  0
  (none)
  )

(defmethod edit-get-trans editable ((obj editable))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  *null-vector*
  )

(defmethod editable-method-19 editable ((obj editable) (arg0 vector))
  0
  (none)
  )

(defmethod editable-method-26 editable ((obj editable) (arg0 editable) (arg1 editable-array))
  0
  (none)
  )

(defmethod editable-method-25 editable ((obj editable) (arg0 editable-array))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (let* ((s4-0 (-> obj owner))
         (a0-3 (car s4-0))
         )
    (while (not (null? s4-0))
      (editable-method-26 (the-as editable a0-3) obj arg0)
      (set! s4-0 (cdr s4-0))
      (set! a0-3 (car s4-0))
      )
    )
  0
  (none)
  )

(defmethod editable-method-27 editable ((obj editable) (arg0 editable-array))
  (local-vars (s4-0 editable))
  (let ((v1-0 0))
    (while (< v1-0 (-> arg0 selection length))
      (when (= obj (-> arg0 selection v1-0))
        (set! s4-0 (-> arg0 selection (+ v1-0 1)))
        (goto cfg-10)
        )
      (+! v1-0 2)
      )
    )
  (let ((s3-0 (editable-array-method-11 arg0)))
    (set! s4-0 (when (>= s3-0 0)
                 (set! s4-0 (copy obj 'debug))
                 (let ((v1-9 (-> arg0 region)))
                   (if v1-9
                       (set! (-> s4-0 region) v1-9)
                       )
                   )
                 (set! (-> s4-0 region changed) #t)
                 (logior! (-> obj flags) (editable-flag changed))
                 (set! (-> s4-0 id) (the-as uint 0))
                 (set! (-> s4-0 owner) '())
                 (select-editable! s4-0 #f)
                 (let ((s2-0 (new 'debug 'string 32 (the-as string #f))))
                   (format s2-0 "undefined-~d" *editable-temp-id*)
                   (set! (-> s4-0 name) s2-0)
                   )
                 (set! *editable-temp-id* (+ *editable-temp-id* 1))
                 (set! (-> arg0 data s3-0) s4-0)
                 (set! (-> arg0 selection (-> arg0 selection length)) obj)
                 (set! (-> arg0 selection (+ (-> arg0 selection length) 1)) s4-0)
                 (+! (-> arg0 selection length) 2)
                 s4-0
                 )
          )
    )
  (label cfg-10)
  s4-0
  )

(defmethod print editable-point ((obj editable-point))
  (format
    #t
    "#<~A~S~m ~m ~m :r ~m"
    (-> obj type)
    (if (logtest? (-> obj flags) (editable-flag changed))
        " (m)"
        ""
        )
    (-> obj trans x)
    (-> obj trans y)
    (-> obj trans z)
    (-> obj radius)
    )
  (format #t " @ #x~X>" obj)
  obj
  )

;; WARN: Function (method 28 editable-point) has a return type of none, but the expression builder found a return statement.
(defmethod editable-method-28 editable-point ((obj editable-point) (arg0 editable-filter))
  (if (logtest? arg0 (editable-filter water-command))
      (return #f)
      )
  (let ((s4-0 (-> *editable* 0 current)))
    (cond
      ((logtest? (-> obj flags) (editable-flag top-set))
       (let* ((s3-0 (-> s4-0 length))
              (s2-0 0)
              (a0-1 (-> s4-0 data s2-0))
              )
         (while (< s2-0 s3-0)
           (if (and a0-1 (= (-> a0-1 region) (-> obj region)) (logtest? (-> a0-1 flags) (editable-flag top-set)))
               (edit-coord! a0-1 (-> obj trans) (editable-flag y no-update))
               )
           (+! s2-0 1)
           (set! a0-1 (-> s4-0 data s2-0))
           )
         )
       )
      ((logtest? (-> obj flags) (editable-flag bot-set))
       (let* ((s3-1 (-> s4-0 length))
              (s2-1 0)
              (a0-2 (-> s4-0 data s2-1))
              )
         (while (< s2-1 s3-1)
           (if (and a0-2 (= (-> a0-2 region) (-> obj region)) (logtest? (-> a0-2 flags) (editable-flag bot-set)))
               (edit-coord! a0-2 (-> obj trans) (editable-flag y no-update))
               )
           (+! s2-1 1)
           (set! a0-2 (-> s4-0 data s2-1))
           )
         )
       )
      )
    )
  ((the-as (function editable-point editable-command none) (find-parent-method editable-point 28))
   obj
   (the-as editable-command arg0)
   )
  0
  (none)
  )

(defmethod editable-method-15 editable-point ((obj editable-point) (arg0 vector) (arg1 int))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (vector+! (-> obj trans) (-> obj trans) arg0)
  (editable-method-28 obj (the-as editable-filter arg1))
  0
  (none)
  )

(defmethod edit-coord! editable-point ((obj editable-point) (arg0 vector) (arg1 editable-flag))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (logtest? arg1 (editable-flag x))
      (set! (-> obj trans x) (-> arg0 x))
      )
  (if (logtest? arg1 (editable-flag y))
      (set! (-> obj trans y) (-> arg0 y))
      )
  (if (logtest? arg1 (editable-flag z))
      (set! (-> obj trans z) (-> arg0 z))
      )
  (editable-method-28 obj (the-as editable-filter arg1))
  0
  (none)
  )

(defmethod edit-get-trans editable-point ((obj editable-point))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  (-> obj trans)
  )

(defmethod editable-method-18 editable-point ((obj editable-point) (arg0 vector) (arg1 matrix))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) (-> obj trans) arg0)))
    (vector-matrix*! s4-1 s4-1 arg1)
    (vector+! (-> obj trans) s4-1 arg0)
    )
  0
  (none)
  )

(defmethod editable-method-10 editable-point ((obj editable-point))
  (let* ((s5-0 vector-vector-distance)
         (a0-1 (math-camera-pos))
         (a1-0 (-> obj trans))
         (f0-1 (- (s5-0 a0-1 a1-0) (-> obj radius)))
         (s2-0 (cond
                 ((logtest? (-> obj flags) (editable-flag selected))
                  6
                  )
                 ((>= f0-1 983040.0)
                  3
                  )
                 ((>= f0-1 491520.0)
                  4
                  )
                 ((>= f0-1 245760.0)
                  5
                  )
                 (else
                   6
                   )
                 )
               )
         )
    (add-debug-sphere-from-table
      (bucket-id debug2)
      (-> obj trans)
      (-> obj radius)
      (get-color obj (the-as int a1-0))
      s2-0
      )
    )
  ((method-of-type editable editable-method-10) obj)
  (none)
  )

(defmethod edit-get-distance editable-point ((obj editable-point) (arg0 vector))
  "Returns the distance from the camera to the [[editable]], or -1.0"
  (let ((a0-1 (new 'stack-no-clear 'sphere))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> a0-1 quad) (-> obj trans quad))
    (set! (-> a0-1 r) (-> obj radius))
    (when (sphere-in-view-frustum? a0-1)
      (reverse-transform-point! s5-0 (-> obj trans) (-> *math-camera* inv-camera-rot vector 2) arg0)
      (let ((f0-1 (vector-vector-distance (edit-get-trans obj) s5-0)))
        (if (>= (-> obj radius) f0-1)
            (return f0-1)
            )
        )
      )
    )
  -1.0
  )

(defmethod editable-method-19 editable-point ((obj editable-point) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (let ((s4-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj trans))))
    (vector-normalize! s4-1 (-> obj radius))
    (vector-! (-> obj trans) arg0 s4-1)
    )
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

(defmethod editable-method-22 editable-point ((obj editable-point) (arg0 editable-array) (arg1 int) (arg2 int))
  (case arg1
    ((2)
     (let ((s3-0 (clear *temp-string*)))
       (format
         s3-0
         "insert into region_point set region_face_id=LAST_INSERT_ID(),idx=~D,x=~f,y=~f,z=~f"
         arg2
         (- (-> obj trans x) (-> arg0 level-offset x))
         (- (-> obj trans y) (-> arg0 level-offset y))
         (- (-> obj trans z) (-> arg0 level-offset z))
         )
       (let ((a0-5 (sql-query s3-0)))
         (when (= (-> a0-5 error) 'modify)
           (logclear! (-> obj flags) (editable-flag changed))
           #t
           )
         )
       )
     )
    (else
      #t
      )
    )
  )

(defmethod editable-method-17 editable-sphere ((obj editable-sphere) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (= (-> arg0 y) 0.0)
      (+! (-> obj radius) (-> arg0 x))
      (set! (-> obj radius) (-> arg0 y))
      )
  (if (< (-> obj radius) 0.0)
      (set! (-> obj radius) 0.0)
      )
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

(defmethod editable-method-22 editable-sphere ((obj editable-sphere) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((gp-0 (clear *temp-string*)))
    (format
      gp-0
      "insert into region_sphere set region_id=~D,x=~f,y=~f,z=~f,r=~f"
      (-> obj region id)
      (- (-> obj trans x) (-> arg0 level-offset x))
      (- (-> obj trans y) (-> arg0 level-offset y))
      (- (-> obj trans z) (-> arg0 level-offset z))
      (-> obj radius)
      )
    (= (-> (sql-query gp-0) error) 'modify)
    )
  )

(defmethod editable-method-22 editable-sample ((obj editable-sample) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((s5-0 (clear *temp-string*)))
    (format
      s5-0
      "insert into sample_point set level_info_id=~D,x=~f,y=~f,z=~f,source='manual'"
      (-> arg0 level-info-id)
      (* 0.00024414062 (- (-> obj trans x) (-> arg0 level-offset x)))
      (* 0.00024414062 (- (-> obj trans y) (-> arg0 level-offset y)))
      (* 0.00024414062 (- (-> obj trans z) (-> arg0 level-offset z)))
      )
    (let ((a0-4 (sql-query s5-0)))
      (when (= (-> a0-4 error) 'modify)
        (logclear! (-> obj flags) (editable-flag changed))
        #t
        )
      )
    )
  )

(defmethod print editable-light ((obj editable-light))
  (format
    #t
    "#<~A~S ~S ~m ~m ~m"
    (-> obj type)
    (if (logtest? (-> obj flags) (editable-flag changed))
        " (m)"
        ""
        )
    (-> obj name)
    (-> obj trans x)
    (-> obj trans y)
    (-> obj trans z)
    )
  (format #t " :r ~m @ #x~X>" (-> obj radius) obj)
  obj
  )

(defmethod editable-method-23 editable-light ((obj editable-light))
  (let ((v1-0 *light-hash*))
    (let* ((a2-0 (-> v1-0 num-lights))
           (a1-1 (-> v1-0 light-sphere-array a2-0))
           )
      (set! (-> a1-1 name) (-> obj name))
      (set! (-> a1-1 decay-start) (-> obj decay-start))
      (set! (-> a1-1 ambient-point-ratio) (-> obj ambient-point-ratio))
      (set! (-> a1-1 brightness) (-> obj brightness))
      (set! (-> a1-1 bsphere quad) (-> obj trans quad))
      (set! (-> a1-1 bsphere w) (-> obj radius))
      (set! (-> a1-1 direction quad) (-> obj direction quad))
      (set! (-> a1-1 color quad) (-> obj color quad))
      (set! (-> a1-1 palette-index) (the int (-> obj color w)))
      )
    (+! (-> v1-0 num-lights) 1)
    )
  #t
  )

(defun update-light-sphere-from-editable-light ((arg0 editable-light))
  (let ((v1-0 (lookup-light-sphere-by-name (-> arg0 name) *light-hash*)))
    (when v1-0
      (set! (-> v1-0 name) (-> arg0 name))
      (set! (-> v1-0 decay-start) (-> arg0 decay-start))
      (set! (-> v1-0 ambient-point-ratio) (-> arg0 ambient-point-ratio))
      (set! (-> v1-0 brightness) (-> arg0 brightness))
      (set! (-> v1-0 bsphere quad) (-> arg0 trans quad))
      (set! (-> v1-0 bsphere w) (-> arg0 radius))
      (set! (-> v1-0 direction quad) (-> arg0 direction quad))
      (set! (-> v1-0 color quad) (-> arg0 color quad))
      (set! (-> v1-0 palette-index) (the int (-> arg0 color w)))
      )
    )
  (none)
  )

(defmethod editable-method-17 editable-light ((obj editable-light) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (= (-> arg0 y) 0.0)
      (+! (-> obj radius) (-> arg0 x))
      (set! (-> obj radius) (-> arg0 y))
      )
  (if (< (-> obj radius) 0.0)
      (set! (-> obj radius) 0.0)
      )
  (update-light-sphere-from-editable-light obj)
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

(defmethod editable-method-15 editable-light ((obj editable-light) (arg0 vector) (arg1 int))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (vector+! (-> obj trans) (-> obj trans) arg0)
  (update-light-sphere-from-editable-light obj)
  (editable-method-28 obj (the-as editable-filter arg1))
  0
  (none)
  )

;; WARN: Function (method 25 editable-light) has a return type of none, but the expression builder found a return statement.
(defmethod editable-method-25 editable-light ((obj editable-light) (arg0 editable-array))
  ((the-as (function editable-light editable-array none) (find-parent-method editable-light 25)) obj arg0)
  (when (nonzero? (-> obj id))
    (let ((s5-1 (clear *temp-string*)))
      (format s5-1 "delete from light where light_id=~D" (-> obj id))
      (let ((a2-1 (sql-query s5-1)))
        (when (!= (-> a2-1 error) 'modify)
          (format 0 "ERROR: sql: modify error ~A for ~A~%" a2-1 obj)
          (return 0)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod editable-method-22 editable-light ((obj editable-light) (arg0 editable-array) (arg1 int) (arg2 int))
  (cond
    ((logtest? (-> obj flags) (editable-flag changed))
     (let ((s5-0 (clear *temp-string*)))
       (when (zero? (-> obj id))
         (format s5-0 "insert into light set level_name='~S'" (-> obj region level))
         (let ((s3-0 (sql-query s5-0)))
           (when (= (-> s3-0 error) 'modify)
             (let ((v1-7 (sql-query "select LAST_INSERT_ID()")))
               (when (= (-> v1-7 error) 'select)
                 (set! (-> obj id) (the-as uint (string->int (the-as string (-> v1-7 data 0)))))
                 (goto cfg-8)
                 )
               )
             )
           (format 0 "ERROR: sql: id insert error ~A for ~A~%" s3-0 obj)
           )
         (return #f)
         (label cfg-8)
         (let ((s3-1 (new 'debug 'string 32 (the-as string #f))))
           (format s3-1 "light-~d" (-> obj id))
           (set! (-> obj name) s3-1)
           )
         )
       (format (clear s5-0) "update light set level_name='~S', name='~S'" (-> obj region level) (-> obj name))
       (format
         s5-0
         ", pos_x=~f, pos_y=~f, pos_z=~f, r=~f"
         (* 0.00024414062 (- (-> obj trans x) (-> arg0 level-offset x)))
         (* 0.00024414062 (- (-> obj trans y) (-> arg0 level-offset y)))
         (* 0.00024414062 (- (-> obj trans z) (-> arg0 level-offset z)))
         (* 0.00024414062 (-> obj radius))
         )
       (if (= (-> obj direction w) 0.0)
           (format s5-0 ", dir_x=0.0, dir_y=0.0, dir_z=0.0")
           (format s5-0 ", dir_x=~f, dir_y=~f, dir_z=~f" (-> obj direction x) (-> obj direction y) (-> obj direction z))
           )
       (format
         s5-0
         ", color0_r=~f, color0_g=~f, color0_b=~f, color0_a=~f"
         (-> obj color x)
         (-> obj color y)
         (-> obj color z)
         (-> obj color w)
         )
       (format
         s5-0
         ", decay_start=~f, ambient_point_ratio=~f, brightness=~f"
         (-> obj decay-start)
         (-> obj ambient-point-ratio)
         (-> obj brightness)
         )
       (format s5-0 " where light_id=~D" (-> obj id))
       (let ((a0-21 (sql-query s5-0)))
         (when (= (-> a0-21 error) 'modify)
           (logclear! (-> obj flags) (editable-flag changed))
           #t
           )
         )
       )
     )
    (else
      #t
      )
    )
  )

(defmethod editable-method-10 editable-light ((obj editable-light))
  (if (!= (-> obj direction w) 0.0)
      (add-debug-vector
        #t
        (bucket-id debug-no-zbuf1)
        (edit-get-trans obj)
        (-> obj direction)
        (* -1.2 (-> obj radius))
        (the-as rgba (-> (new 'static 'array uint64 1 #x80ff00ff) 0))
        )
      )
  (when (-> *editable* 0 light-names)
    (let ((s5-1 add-debug-text-3d)
          (s4-1 #t)
          (s3-1 318)
          )
      (format (clear *temp-string*) "~S~%" (-> obj name))
      (s5-1 s4-1 (the-as bucket-id s3-1) *temp-string* (-> obj trans) (font-color #dadada) (the-as vector2h #f))
      )
    )
  ((method-of-type editable-sphere editable-method-10) obj)
  (none)
  )

;; WARN: Return type mismatch object vs vector.
(defmethod edit-get-trans editable-face ((obj editable-face))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  "The center of the obj."
  (the-as vector (cond
                   ((>= (-> obj length) 3)
                    (let ((s5-0 (new 'static 'vector)))
                      (set! (-> s5-0 quad) (the-as uint128 0))
                      (vector+! s5-0 s5-0 (edit-get-trans (-> obj vertex 0)))
                      (vector+! s5-0 s5-0 (edit-get-trans (-> obj vertex 1)))
                      (vector+! s5-0 s5-0 (edit-get-trans (-> obj vertex 2)))
                      (vector-float*! s5-0 s5-0 0.33333334)
                      )
                    )
                   ((>= (-> obj length) 2)
                    (let ((s5-1 (new 'static 'vector)))
                      (set! (-> s5-1 quad) (the-as uint128 0))
                      (vector+! s5-1 s5-1 (edit-get-trans (-> obj vertex 0)))
                      (vector+! s5-1 s5-1 (edit-get-trans (-> obj vertex 1)))
                      (vector-float*! s5-1 s5-1 0.5)
                      )
                    )
                   (else
                     *null-vector*
                     )
                   )
          )
  )

(defmethod editable-method-22 editable-face ((obj editable-face) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((s4-0 (clear *temp-string*)))
    (format s4-0 "insert into region_face set kind='face',region_id=~D" (-> obj region id))
    (if (logtest? (-> obj flags) (editable-flag orient))
        (format s4-0 ",flags='orient'")
        )
    (let ((a0-5 (sql-query s4-0)))
      (if (!= (-> a0-5 error) 'modify)
          (return #f)
          )
      )
    )
  (dotimes (s4-1 (-> obj length))
    (editable-method-22 (-> obj vertex s4-1) arg0 2 s4-1)
    )
  (logclear! (-> obj flags) (editable-flag changed))
  #t
  )

(defmethod editable-method-25 editable-face ((obj editable-face) (arg0 editable-array))
  (dotimes (s4-0 (-> obj length))
    (let ((s3-0 (-> obj vertex s4-0)))
      (set! (-> s3-0 owner) (delete! obj (-> s3-0 owner)))
      )
    )
  ((the-as (function editable-face editable-array none) (find-parent-method editable-face 25)) obj arg0)
  (none)
  )

(defmethod editable-method-26 editable-face ((obj editable-face) (arg0 editable) (arg1 editable-array))
  (-> obj length)
  (countdown (v1-1 (-> obj length))
    (when (= (-> obj vertex v1-1) arg0)
      (let ((a0-5 v1-1)
            (a1-2 (+ (-> obj length) -2))
            )
        (while (>= a1-2 a0-5)
          (set! (-> obj vertex a0-5) (-> obj vertex (+ a0-5 1)))
          (+! a0-5 1)
          )
        )
      (+! (-> obj length) -1)
      )
    )
  (if (< (-> obj length) 3)
      (editable-array-method-15 arg1 obj)
      )
  ((method-of-type editable editable-method-26) obj arg0 arg1)
  (none)
  )

(defmethod editable-method-27 editable-face ((obj editable-face) (arg0 editable-array))
  (let ((gp-1
          ((the-as (function editable-face editable-array editable) (find-parent-method editable-face 27)) obj arg0)
          )
        )
    (dotimes (s4-0 (-> (the-as editable-face gp-1) length))
      (let ((v1-3 (editable-method-27 (the-as editable-face (l.wu (+ (* s4-0 4) (the-as int gp-1) 60))) arg0))
            (a0-5 (+ (* s4-0 4) (the-as int gp-1)))
            )
        (s.w! (+ a0-5 60) v1-3)
        )
      (let ((v0-3 (cons gp-1 (-> (the-as editable-face (+ (* s4-0 4) (the-as int gp-1))) vertex 0 owner)))
            (v1-10 (l.wu (+ (* s4-0 4) (the-as int gp-1) 60)))
            )
        (s.w! (+ v1-10 16) v0-3)
        )
      )
    gp-1
    )
  )

(defmethod editable-method-24 editable-face ((obj editable-face))
  (logxor! (-> obj flags) (editable-flag orient))
  (editable-face-method-31 obj (-> obj normal))
  (logior! (-> obj flags) (editable-flag changed))
  (set! (-> obj region changed) #t)
  0
  (none)
  )

(defmethod editable-face-method-30 editable-face ((obj editable-face) (arg0 (inline-array vector)))
  (let ((v1-0 (-> obj length)))
    (cond
      ((or (zero? v1-0) (= v1-0 1))
       0
       )
      ((= v1-0 2)
       (let ((s4-0 (edit-get-trans (-> obj vertex 0)))
             (v1-3 (edit-get-trans (-> obj vertex 1)))
             )
         (set! (-> arg0 0 quad) (-> s4-0 quad))
         (set! (-> arg0 1 quad) (-> s4-0 quad))
         (set! (-> arg0 1 y) (-> v1-3 y))
         (set! (-> arg0 2 quad) (-> v1-3 quad))
         (set! (-> arg0 2 y) (-> s4-0 y))
         (set! (-> arg0 3 quad) (-> v1-3 quad))
         )
       4
       )
      (else
        (dotimes (s4-1 (-> obj length))
          (set! (-> arg0 s4-1 quad) (-> (edit-get-trans (-> obj vertex s4-1)) quad))
          )
        (-> obj length)
        )
      )
    )
  )

(defmethod editable-face-method-31 editable-face ((obj editable-face) (arg0 vector))
  (let ((s4-0 (new 'stack-no-clear 'matrix)))
    (dotimes (v1-0 6)
      (set! (-> s4-0 vector v1-0 quad) (the-as uint128 0))
      )
    (if (>= (editable-face-method-30 obj (the-as (inline-array vector) s4-0)) 3)
        (normal-of-plane arg0 (the-as vector (-> s4-0 vector)) (-> s4-0 vector 1) (-> s4-0 vector 2))
        )
    )
  (if (logtest? (-> obj flags) (editable-flag orient))
      (vector-negate! arg0 arg0)
      )
  arg0
  )

(defmethod editable-method-10 editable-face ((obj editable-face))
  (local-vars (sv-112 int))
  (let ((gp-0 (new 'stack-no-clear 'inline-array 'vector 6)))
    (dotimes (v1-0 6)
      (set! (-> gp-0 v1-0 quad) (the-as uint128 0))
      )
    (set! sv-112 (editable-face-method-30 obj gp-0))
    (when (>= sv-112 3)
      (let ((s1-0 (editable-face-method-31 obj (new 'stack-no-clear 'vector))))
        (add-debug-vector
          #t
          (bucket-id debug-no-zbuf1)
          (edit-get-trans obj)
          s1-0
          (meters 2)
          (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
          )
        )
      (when (logtest? (-> obj flags) (editable-flag selected))
        (dotimes (s4-1 sv-112)
          (let ((s3-1 add-debug-text-3d)
                (s2-1 #t)
                (s1-1 318)
                )
            (format (clear *temp-string*) "~D" s4-1)
            (s3-1
              s2-1
              (the-as bucket-id s1-1)
              *temp-string*
              (-> gp-0 s4-1)
              (if (logtest? (-> obj flags) (editable-flag orient))
                  (font-color yellow-#f3f300)
                  (font-color #dadada)
                  )
              (the-as vector2h #f)
              )
            )
          )
        )
      (add-debug-bound
        324
        (the-as transform gp-0)
        sv-112
        (if (logtest? (-> obj flags) (editable-flag orient))
            (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
            (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
            )
        (if (zero? (logand (-> obj flags) (editable-flag orient)))
            (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
            (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
            )
        (if (logtest? (-> obj flags) (editable-flag selected))
            1
            0
            )
        )
      )
    )
  0
  (none)
  )

(defmethod edit-get-trans editable-plane ((obj editable-plane))
  "Returns the `trans` [[vector]] or [[*null-vector*]]"
  (if (>= (-> obj length) 1)
      (edit-get-trans (-> obj vertex 0))
      *null-vector*
      )
  )

(defmethod editable-method-22 editable-plane ((obj editable-plane) (arg0 editable-array) (arg1 int) (arg2 int))
  (let ((s4-0 (clear *temp-string*)))
    (format
      s4-0
      "insert into region_face set kind='plane',region_id=~D,radius=~f"
      (-> obj region id)
      (-> obj radius)
      )
    (let ((a0-4 (sql-query s4-0)))
      (if (!= (-> a0-4 error) 'modify)
          (return #f)
          )
      )
    )
  (dotimes (s4-1 (-> obj length))
    (editable-method-22 (-> obj vertex s4-1) arg0 2 s4-1)
    )
  (logclear! (-> obj flags) (editable-flag changed))
  #t
  )

(defmethod editable-method-25 editable-plane ((obj editable-plane) (arg0 editable-array))
  (dotimes (s4-0 (-> obj length))
    (let ((s3-0 (-> obj vertex s4-0)))
      (set! (-> s3-0 owner) (delete! obj (-> s3-0 owner)))
      )
    )
  ((the-as (function editable-plane editable-array none) (find-parent-method editable-plane 25)) obj arg0)
  (none)
  )

(defmethod editable-method-26 editable-plane ((obj editable-plane) (arg0 editable) (arg1 editable-array))
  (editable-array-method-15 arg1 obj)
  ((method-of-type editable editable-method-26) obj arg0 arg1)
  (none)
  )

(defmethod editable-method-27 editable-plane ((obj editable-plane) (arg0 editable-array))
  (let ((gp-1
          ((the-as (function editable-plane editable-array editable) (find-parent-method editable-plane 27)) obj arg0)
          )
        )
    (dotimes (s4-0 (-> (the-as editable-plane gp-1) length))
      (let ((v1-3 (editable-method-27 (-> (the-as editable-plane (+ (* s4-0 4) (the-as int gp-1))) vertex 0) arg0))
            (a0-5 (+ (* s4-0 4) (the-as int gp-1)))
            )
        (s.w! (+ a0-5 28) v1-3)
        )
      (let ((v0-3 (cons gp-1 (-> (the-as editable-plane (+ (* s4-0 4) (the-as int gp-1))) vertex 0 owner)))
            (v1-10 (l.wu (+ (* s4-0 4) (the-as int gp-1) 28)))
            )
        (s.w! (+ v1-10 16) v0-3)
        )
      )
    gp-1
    )
  )

(defmethod editable-method-24 editable-plane ((obj editable-plane))
  (let ((s5-1
          (vector-! (new 'stack-no-clear 'vector) (edit-get-trans (-> obj vertex 1)) (edit-get-trans (-> obj vertex 0)))
          )
        )
    (edit-coord! (-> obj vertex 1) (vector-! s5-1 (edit-get-trans (-> obj vertex 0)) s5-1) (editable-flag x y z))
    )
  (set! (-> obj region changed) #t)
  (logior! (-> obj flags) (editable-flag changed))
  0
  (none)
  )

(defmethod editable-plane-method-30 editable-plane ((obj editable-plane) (arg0 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (case (-> obj length)
      ((2)
       (let* ((v1-2 (editable-plane-method-31 obj (new 'stack-no-clear 'vector)))
              (s5-1 (vector-cross!
                      (new 'stack-no-clear 'vector)
                      v1-2
                      (if (< 0.7 (fabs (vector-dot v1-2 (new 'static 'vector :z 1.0 :w 1.0))))
                          (new 'static 'vector :x 1.0 :w 1.0)
                          (new 'static 'vector :z 1.0 :w 1.0)
                          )
                      )
                    )
              (s4-1 (vector-cross! (new 'stack-no-clear 'vector) s5-1 v1-2))
              (f30-0 (-> obj radius))
              )
         (let ((v1-4 (edit-get-trans (-> obj vertex 0))))
           (let ((a0-6 (-> arg0 vector)))
             (let ((a1-6 v1-4)
                   (a2-1 s5-1)
                   (f0-1 f30-0)
                   )
               (.lvf vf2 (&-> a2-1 quad))
               (.lvf vf1 (&-> a1-6 quad))
               (let ((a1-7 f0-1))
                 (.mov vf3 a1-7)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-6 0 quad) vf4)
             )
           (let ((a0-7 (-> arg0 vector)))
             (let ((a1-8 (-> arg0 vector))
                   (a2-2 s4-1)
                   (f0-2 (- f30-0))
                   )
               (.lvf vf2 (&-> a2-2 quad))
               (.lvf vf1 (&-> a1-8 0 quad))
               (let ((a1-9 f0-2))
                 (.mov vf3 a1-9)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-7 0 quad) vf4)
             )
           (let ((a0-8 (-> arg0 vector 1)))
             (let ((a1-10 v1-4)
                   (a2-3 s5-1)
                   (f0-3 (- f30-0))
                   )
               (.lvf vf2 (&-> a2-3 quad))
               (.lvf vf1 (&-> a1-10 quad))
               (let ((a1-11 f0-3))
                 (.mov vf3 a1-11)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-8 quad) vf4)
             )
           (let ((a0-9 (-> arg0 vector 1)))
             (let ((a1-12 (-> arg0 vector 1))
                   (a2-4 s4-1)
                   (f0-4 (- f30-0))
                   )
               (.lvf vf2 (&-> a2-4 quad))
               (.lvf vf1 (&-> a1-12 quad))
               (let ((a1-13 f0-4))
                 (.mov vf3 a1-13)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-9 quad) vf4)
             )
           (let ((a0-10 (-> arg0 vector 2)))
             (let ((a1-14 v1-4)
                   (a2-5 s5-1)
                   (f0-5 f30-0)
                   )
               (.lvf vf2 (&-> a2-5 quad))
               (.lvf vf1 (&-> a1-14 quad))
               (let ((a1-15 f0-5))
                 (.mov vf3 a1-15)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-10 quad) vf4)
             )
           (let ((a0-11 (-> arg0 vector 2)))
             (let ((a1-16 (-> arg0 vector 2))
                   (a2-6 s4-1)
                   (f0-6 f30-0)
                   )
               (.lvf vf2 (&-> a2-6 quad))
               (.lvf vf1 (&-> a1-16 quad))
               (let ((a1-17 f0-6))
                 (.mov vf3 a1-17)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-11 quad) vf4)
             )
           (let ((a0-12 (-> arg0 trans)))
             (let ((f0-7 (- f30-0)))
               (.lvf vf2 (&-> s5-1 quad))
               (.lvf vf1 (&-> v1-4 quad))
               (let ((v1-5 f0-7))
                 (.mov vf3 v1-5)
                 )
               )
             (.add.x.vf vf4 vf0 vf0 :mask #b1000)
             (.mul.x.vf acc vf2 vf3)
             (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
             (.svf (&-> a0-12 quad) vf4)
             )
           )
         (let ((v1-6 (-> arg0 trans)))
           (let ((a0-13 (-> arg0 trans)))
             (.lvf vf2 (&-> s4-1 quad))
             (.lvf vf1 (&-> a0-13 quad))
             )
           (let ((a0-14 f30-0))
             (.mov vf3 a0-14)
             )
           (.add.x.vf vf4 vf0 vf0 :mask #b1000)
           (.mul.x.vf acc vf2 vf3)
           (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
           (.svf (&-> v1-6 quad) vf4)
           )
         )
       4
       )
      (else
        0
        )
      )
    )
  )

(defmethod editable-plane-method-31 editable-plane ((obj editable-plane) (arg0 vector))
  (case (-> obj length)
    ((2)
     (let ((s3-0 (-> obj vertex 0))
           (a0-1 (-> obj vertex 1))
           )
       (vector-! arg0 (edit-get-trans a0-1) (edit-get-trans s3-0))
       )
     (vector-normalize! arg0 1.0)
     )
    )
  arg0
  )

(defmethod editable-method-10 editable-plane ((obj editable-plane))
  (let ((gp-0 (new 'stack-no-clear 'matrix)))
    (dotimes (v1-0 4)
      (set! (-> gp-0 vector v1-0 quad) (the-as uint128 0))
      )
    (let ((s4-0 (editable-plane-method-30 obj gp-0)))
      (when (>= s4-0 3)
        (add-debug-line
          #t
          (bucket-id debug-no-zbuf1)
          (edit-get-trans (-> obj vertex 0))
          (edit-get-trans (-> obj vertex 1))
          (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
          #f
          (the-as rgba -1)
          )
        (add-debug-bound
          324
          (the-as transform gp-0)
          s4-0
          (if (logtest? (-> obj flags) (editable-flag orient))
              (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
              (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
              )
          (if (zero? (logand (-> obj flags) (editable-flag orient)))
              (the-as rgba (-> (new 'static 'array uint64 1 #x800000ff) 0))
              (the-as rgba (-> (new 'static 'array uint64 1 #x8000ffff) 0))
              )
          (if (logtest? (-> obj flags) (editable-flag selected))
              1
              0
              )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod editable-method-17 editable-plane ((obj editable-plane) (arg0 vector))
  (let ((v1-0 (-> obj region)))
    (if v1-0
        (set! (-> v1-0 changed) #t)
        )
    )
  (logior! (-> obj flags) (editable-flag changed))
  (if (= (-> arg0 y) 0.0)
      (+! (-> obj radius) (-> arg0 x))
      (set! (-> obj radius) (-> arg0 y))
      )
  (if (< (-> obj radius) 0.0)
      (set! (-> obj radius) 0.0)
      )
  (editable-method-28 obj (editable-filter load))
  0
  (none)
  )

;; WARN: Return type mismatch (array editable) vs editable-array.
(defmethod relocate editable-array ((obj editable-array) (arg0 int))
  (the-as editable-array (when (nonzero? (-> obj selection))
                           (let ((v0-0 (&+ (-> obj selection) arg0)))
                             (set! (-> obj selection) v0-0)
                             v0-0
                             )
                           )
          )
  )

(defmethod length editable-array ((obj editable-array))
  (-> obj length)
  )

;; WARN: Return type mismatch uint vs int.
(defmethod asize-of editable-array ((obj editable-array))
  (the-as int (+ (-> obj type size) (* (-> obj allocated-length) 4)))
  )

(defmethod editable-array-method-11 editable-array ((obj editable-array))
  (dotimes (v1-0 (-> obj length))
    (if (not (-> obj data v1-0))
        (return v1-0)
        )
    )
  (when (< (-> obj length) (-> obj allocated-length))
    (+! (-> obj length) 1)
    (return (+ (-> obj length) -1))
    )
  -1
  )

(defmethod editable-array-method-10 editable-array ((obj editable-array) (arg0 vector) (arg1 int))
  (when (or (!= (-> arg0 x) (-> *editable-work* last-x)) (!= (-> arg0 y) (-> *editable-work* last-y)))
    (set! (-> *editable-work* last-found) 0)
    (set! (-> *editable-work* last-x) (-> arg0 x))
    (set! (-> *editable-work* last-y) (-> arg0 y))
    )
  4095996000.0
  (let ((s5-0 (the-as editable #f)))
    (set! (-> *editable-work* num-found) 0)
    (let* ((s2-0 (-> obj length))
           (s1-0 0)
           (s0-0 (-> obj data s1-0))
           )
      (while (< s1-0 s2-0)
        (when (and s0-0 (or (and (logtest? (-> s0-0 region filter) (-> obj filter 0))
                                 (logtest? (-> s0-0 region filter) (-> obj filter 1))
                                 )
                            (logtest? (-> s0-0 flags) (editable-flag selected))
                            )
                   )
          (let ((f0-5 (edit-get-distance s0-0 arg0)))
            (when (>= f0-5 0.0)
              (set! (-> *editable-work* found (-> *editable-work* num-found)) s0-0)
              (set! (-> *editable-work* dists (-> *editable-work* num-found)) (the-as uint f0-5))
              (if (< (-> *editable-work* num-found) 255)
                  (+! (-> *editable-work* num-found) 1)
                  )
              )
            )
          )
        (+! s1-0 1)
        (set! s0-0 (-> obj data s1-0))
        )
      )
    (countdown (v1-43 (-> *editable-work* num-found))
      (when (> v1-43 0)
        (countdown (a0-12 v1-43)
          (when (< (the-as float (-> *editable-work* dists v1-43)) (the-as float (-> *editable-work* dists a0-12)))
            (let ((a1-10 (-> *editable-work* found v1-43))
                  (f0-7 (-> *editable-work* dists v1-43))
                  )
              (set! (-> *editable-work* found v1-43) (-> *editable-work* found a0-12))
              (set! (-> *editable-work* dists v1-43) (-> *editable-work* dists a0-12))
              (set! (-> *editable-work* found a0-12) a1-10)
              (set! (-> *editable-work* dists a0-12) f0-7)
              )
            )
          )
        )
      )
    (when (nonzero? (-> *editable-work* num-found))
      (when (>= (-> *editable-work* last-found) (-> *editable-work* num-found))
        (set! (-> *editable-work* last-found) 0)
        0
        )
      (set! s5-0 (cond
                   ((zero? arg1)
                    (set! s5-0 (-> *editable-work* found (-> *editable-work* last-found)))
                    (+! (-> *editable-work* last-found) 1)
                    s5-0
                    )
                   (else
                     (-> *editable-work* found 0)
                     )
                   )
            )
      )
    s5-0
    )
  )

;; WARN: Return type mismatch (array editable) vs none.
(defmethod editable-array-method-14 editable-array ((obj editable-array) (arg0 (function symbol)) (arg1 symbol))
  (let ((gp-0 (-> obj selection)))
    (set! (-> gp-0 length) 0)
    (let* ((s2-0 (-> obj length))
           (s1-0 0)
           (s0-0 (-> obj data s1-0))
           )
      (while (< s1-0 s2-0)
        (when (and s0-0 (logtest? (-> s0-0 flags) (editable-flag selected)))
          (when (arg0)
            (set! (-> gp-0 (-> gp-0 length)) s0-0)
            (+! (-> gp-0 length) 1)
            )
          )
        (+! s1-0 1)
        (set! s0-0 (-> obj data s1-0))
        )
      )
    )
  (none)
  )

(defmethod editable-array-method-15 editable-array ((obj editable-array) (arg0 editable))
  (let ((gp-0 (-> arg0 region)))
    (when gp-0
      (editable-method-25 arg0 obj)
      (let* ((v1-3 (-> obj length))
             (a0-2 0)
             (a1-4 (-> obj data a0-2))
             )
        (while (< a0-2 v1-3)
          (if (and a1-4 (= arg0 a1-4))
              (set! (-> obj data a0-2) #f)
              )
          (+! a0-2 1)
          (set! a1-4 (-> obj data a0-2))
          )
        )
      (let* ((v1-6 (-> obj length))
             (a0-3 0)
             (a1-14 (-> obj data a0-3))
             )
        (while (< a0-3 v1-6)
          (if (and a1-14 (= (-> a1-14 region) gp-0) (!= a1-14 arg0))
              (goto cfg-21)
              )
          (+! a0-3 1)
          (set! a1-14 (-> obj data a0-3))
          )
        )
      (editable-region-method-10 gp-0 0)
      )
    )
  (label cfg-21)
  0
  (none)
  )

(defmethod editable-array-method-13 editable-array ((obj editable-array) (arg0 uint) (arg1 basic) (arg2 string))
  (set! (-> obj target) #f)
  (set! (-> obj target-mode) arg0)
  (set! (-> obj target-command) arg1)
  (set! (-> obj target-message) arg2)
  0
  (none)
  )

(defmethod editable-array-method-16 editable-array ((obj editable-array))
  (cond
    ((-> obj edit-plane)
     (editable-plane-method-31 (-> obj edit-plane) (-> obj edit-plane-normal))
     (set! (-> obj edit-plane-center quad) (-> (edit-get-trans (-> obj edit-plane vertex 0)) quad))
     )
    (else
      (vector-negate! (-> obj edit-plane-normal) (-> *math-camera* inv-camera-rot vector 2))
      (let ((v1-9 (vector-float*! (-> obj edit-plane-center) (-> *math-camera* inv-camera-rot vector 2) 24576.0)))
        (vector+! (the-as vector v1-9) (the-as vector v1-9) (-> *math-camera* trans))
        )
      )
    )
  0
  (none)
  )

(defmethod editable-array-method-17 editable-array ((obj editable-array) (arg0 vector) (arg1 vector))
  (cond
    ((and (cpad-hold? 0 up) *target*)
     (set! (-> arg0 quad) (-> (get-trans *target* 0) quad))
     )
    ((and (cpad-hold? 0 down) *camera*)
     (set! (-> arg0 quad) (-> (math-camera-pos) quad))
     )
    (else
      (editable-array-method-16 obj)
      (reverse-transform-point! arg0 (-> obj edit-plane-center) (-> obj edit-plane-normal) arg1)
      )
    )
  arg0
  )

(when (zero? *editable-sample-region*)
  (let ((v1-4 (new 'debug 'editable-region)))
    (set! (-> v1-4 locked) #t)
    (set! (-> v1-4 changed) #f)
    (set! (-> v1-4 tree) (the-as string 'sample))
    (set! (-> v1-4 filter) (editable-filter sample))
    (set! *editable-sample-region* v1-4)
    )
  (let ((v1-6 (new 'debug 'editable-region)))
    (set! (-> v1-6 locked) #t)
    (set! (-> v1-6 changed) #f)
    (set! (-> v1-6 tree) (the-as string 'light))
    (set! (-> v1-6 filter) (editable-filter light))
    (set! *editable-light-region* v1-6)
    )
  (let ((v0-84 (new 'debug 'editable-region)))
    (set! (-> v0-84 locked) #t)
    (set! (-> v0-84 changed) #f)
    (set! (-> v0-84 tree) (the-as string 'entity))
    (set! (-> v0-84 filter) (editable-filter entity))
    (set! *editable-entity-region* v0-84)
    )
  )

)
