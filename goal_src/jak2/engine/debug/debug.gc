;;-*-Lisp-*-
(in-package goal)

;; name: debug.gc
;; name in dgo: debug
;; dgos: ENGINE, GAME

;; This file contains functions for debug drawing.
;; In general, the 3d functions draw using the camera and the 2d functions draw in screen coordinates.
;; Most functions take a boolean as their first argument. If the boolean is set to #f, it will skip drawing the point.

(define-extern draw-string (function string dma-buffer font-context draw-string-result))
(define-extern debug-set-camera-pos-rot! (function vector matrix vector))
(define-extern lookup-texture-by-id (function texture-id texture))
(define-extern adgif-shader<-texture-simple! (function adgif-shader texture adgif-shader))

;; DECOMP BEGINS

(defun transform-float-point ((in vector) (out vector4w))
  "Transform point in and store the result in out.
   This uses the cached vf register transformation matrix
   Note that the input/output order of the arguments is swapped from usual"
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (.lvf vf5 (&-> in quad))
    (.mul.w.vf acc vf4 vf5)
    (.add.mul.x.vf acc vf1 vf5 acc)
    (.add.mul.y.vf acc vf2 vf5 acc)
    (.add.mul.z.vf vf5 vf3 vf5 acc)
    (.div.vf Q vf9 vf5 :fsf #b0 :ftf #b11)
    (.wait.vf)
    (.mul.vf vf5 vf5 Q :mask #b111)
    (.add.vf vf5 vf5 vf8)
    (.max.x.vf vf5 vf5 vf0 :mask #b1000)
    (.min.x.vf vf5 vf5 vf6 :mask #b1000)
    (vftoi4.xyzw vf5 vf5)
    (.svf (&-> out quad) vf5)
    out
    )
  )


;;;;;;;;;;;;;;;;;;
;; Debug Draw
;;;;;;;;;;;;;;;;;;

;; All of these functions are super slow and probably very old.
;; They do a DMA packet per thing drawn.

(defun-debug add-debug-point ((enable-draw symbol) (bucket bucket-id) (pt vector))
  "Draw a point.
   The point is actually a pretty large square with some weird rgb gradient."
  (if (not enable-draw)
      (return #f)
      )
  (let ((s5-0 (new 'stack 'vector4w-2))
        (pt-copy (new 'stack-no-clear 'vector))
        )
    (set! (-> pt-copy quad) (-> pt quad))
    (set! (-> pt-copy w) 1.0)
    (when (transform-point-qword! (the-as vector4w (-> s5-0 vector)) pt-copy)
      (let* ((buf (-> *display* frames (-> *display* on-screen) debug-buf))
             (tag-start (-> buf base))
             )
        (let ((a0-5 (the-as (pointer uint64) (-> buf base))))
          (let* ((a1-3 buf)
                 (a3-0 (the-as dma-packet (-> a1-3 base)))
                 )
            (set! (-> a3-0 dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
            (set! (-> a3-0 vif0) (new 'static 'vif-tag))
            (set! (-> a3-0 vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1))
            (set! (-> a1-3 base) (&+ (the-as pointer a3-0) 16))
            )
          (let* ((a1-4 buf)
                 (a3-2 (the-as gs-gif-tag (-> a1-4 base)))
                 )
            (set! (-> a3-2 tag)
                  (new 'static 'gif-tag64
                    :nloop #x1
                    :eop #x1
                    :pre #x1
                    :prim (new 'static 'gs-prim :prim (gs-prim-type tri-strip) :iip #x1 :abe #x1)
                    :nreg #x8
                    )
                  )
            (set! (-> a3-2 regs)
                  (new 'static 'gif-tag-regs
                    :regs0 (gif-reg-id rgbaq)
                    :regs1 (gif-reg-id xyzf2)
                    :regs2 (gif-reg-id rgbaq)
                    :regs3 (gif-reg-id xyzf2)
                    :regs4 (gif-reg-id rgbaq)
                    :regs5 (gif-reg-id xyzf2)
                    :regs6 (gif-reg-id rgbaq)
                    :regs7 (gif-reg-id xyzf2)
                    )
                  )
            (set! (-> a1-4 base) (&+ (the-as pointer a3-2) 16))
            )
          (set! (-> s5-0 vector 1 x) 255)
          (set! (-> s5-0 vector 1 y) 128)
          (set! (-> s5-0 vector 1 z) 128)
          (set! (-> s5-0 vector 1 w) 128)
          (set! (-> s5-0 vector 0 y) (the-as int (+ (-> s5-0 vector 0 y) 288)))
          (let* ((a1-11 buf)
                 (a3-4 (the-as vector4w-2 (-> a1-11 base)))
                 )
            (set! (-> a3-4 vector 0 quad) (-> s5-0 vector 1 quad))
            (set! (-> a3-4 vector 1 quad) (-> s5-0 vector 0 quad))
            (set! (-> a1-11 base) (&+ (the-as pointer a3-4) 32))
            )
          (set! (-> s5-0 vector 0 x) (the-as int (+ (-> s5-0 vector 0 x) -256)))
          (set! (-> s5-0 vector 0 y) (the-as int (+ (-> s5-0 vector 0 y) -288)))
          (set! (-> s5-0 vector 1 x) 128)
          (set! (-> s5-0 vector 1 y) 255)
          (let* ((a1-18 buf)
                 (a3-6 (the-as vector4w-2 (-> a1-18 base)))
                 )
            (set! (-> a3-6 vector 0 quad) (-> s5-0 vector 1 quad))
            (set! (-> a3-6 vector 1 quad) (-> s5-0 vector 0 quad))
            (set! (-> a1-18 base) (&+ (the-as pointer a3-6) 32))
            )
          (set! (-> s5-0 vector 0 x) (the-as int (+ (-> s5-0 vector 0 x) 512)))
          (set! (-> s5-0 vector 1 y) 128)
          (set! (-> s5-0 vector 1 z) 255)
          (let* ((a1-23 buf)
                 (a3-8 (the-as vector4w-2 (-> a1-23 base)))
                 )
            (set! (-> a3-8 vector 0 quad) (-> s5-0 vector 1 quad))
            (set! (-> a3-8 vector 1 quad) (-> s5-0 vector 0 quad))
            (set! (-> a1-23 base) (&+ (the-as pointer a3-8) 32))
            )
          (set! (-> s5-0 vector 0 x) (the-as int (+ (-> s5-0 vector 0 x) -256)))
          (set! (-> s5-0 vector 0 y) (the-as int (+ (-> s5-0 vector 0 y) -288)))
          (set! (-> s5-0 vector 1 x) 255)
          (set! (-> s5-0 vector 1 y) 128)
          (let* ((a3-10 buf)
                 (a1-30 (the-as vector4w-2 (-> a3-10 base)))
                 )
            (set! (-> a1-30 vector 0 quad) (-> s5-0 vector 1 quad))
            (set! (-> a1-30 vector 1 quad) (-> s5-0 vector 0 quad))
            (set! (-> a3-10 base) (&+ (the-as pointer a1-30) 32))
            )
          (let ((a3-14 (/ (the-as int (+ (- -16 (the-as int a0-5)) (the-as int (-> buf base)))) 16)))
            (cond
              ((nonzero? a3-14)
               (logior! (-> a0-5 0) (shr (shl a3-14 48) 48))
               (logior! (-> a0-5 1) (shl (shr (shl a3-14 48) 48) 32))
               )
              (else
                (set! (-> buf base) a0-5)
                )
              )
            )
          )
        (let ((tag-end (-> buf base)))
          (let ((a0-6 (the-as dma-packet (-> buf base))))
            (set! (-> a0-6 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> a0-6 vif0) (new 'static 'vif-tag))
            (set! (-> a0-6 vif1) (new 'static 'vif-tag))
            (set! (-> buf base) (&+ (the-as pointer a0-6) 16))
            )
          (dma-bucket-insert-tag
            (-> *display* frames (-> *display* on-screen) bucket-group)
            bucket
            tag-start
            (the-as (pointer dma-tag) tag-end)
            )
          )
        )
      )
    )
  #f
  )

;;(define-extern debug-line-clip? (function vector vector vector vector symbol))

;; TODO: doesn't actually do any clipping.
(defun debug-line-clip? ((arg0 vector) (arg1 vector) (arg2 vector) (arg3 vector))
  (vector-copy! arg0 arg2)
  (vector-copy! arg1 arg3)
  #t
  )

(defun-debug internal-draw-debug-line ((bucket bucket-id) (start vector) (end vector) (start-color rgba) (mode symbol) (end-color rgba))
  "Draw a debug line from p0 to p1. Mode can be:
   'fade, 'fade-depth, or #f.
   end-color can be -1 to just use the same color.
   "
  (local-vars (sv-128 vector) (sv-144 vector))
  (let ((var-start-color start-color)
        (var-mode mode)
        (var-end-color end-color)
        )
    (let ((buf (-> *display* frames (-> *display* on-screen) debug-buf)))
      (if (< (the-as uint (shr (+ (&- (-> buf end) (the-as uint (-> buf base))) 15) 4)) (the-as uint #x8000))
          (return (the-as pointer #f))
          )
      )
    (if (or (= var-end-color -1) (= var-end-color (new 'static 'rgba :r #xff :g #xff :b #xff :a #xff)))
        (set! var-end-color var-start-color)
        )
    (case var-mode
      (('fade)
       (set! var-end-color (new 'static 'rgba
                             :r (shr (-> var-end-color r) 1)
                             :g (shr (-> var-end-color g) 1)
                             :b (shr (-> var-end-color b) 1)
                             :a (-> var-end-color a)
                             )
             )
       )
      )
    (let ((s4-0 (new 'stack 'vector4w-2))
          (s3-0 (new 'stack 'vector4w-2))
          )
      (set! sv-128 (new 'stack-no-clear 'vector))
      (set! sv-144 (new 'stack-no-clear 'vector))
      (when (debug-line-clip? sv-128 sv-144 start end)
        (set! (-> sv-128 w) 1.0)
        (set! (-> sv-144 w) 1.0)
        (when (and (transform-point-qword! (the-as vector4w (-> s4-0 vector)) sv-128)
                   (transform-point-qword! (-> s4-0 vector 1) sv-144)
                   )
          (let* ((buf2 (-> *display* frames (-> *display* on-screen) debug-buf))
                 (tag-start (-> buf2 base))
                 )
            (let ((a0-28 (the-as (pointer uint64) (-> buf2 base))))
              (let* ((pkt1 (the-as dma-packet (-> buf2 base))))
                (set! (-> pkt1 dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
                (set! (-> pkt1 vif0) (new 'static 'vif-tag))
                (set! (-> pkt1 vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1))
                (set! (-> buf2 base) (&+ (the-as pointer pkt1) 16))
                )
              (let* ((giftag (the-as gs-gif-tag (-> buf2 base))))
                (set! (-> giftag tag)
                      (new 'static 'gif-tag64
                        :nloop #x1
                        :eop #x1
                        :pre #x1
                        :prim (new 'static 'gs-prim :prim (gs-prim-type line) :iip #x1 :abe #x1)
                        :nreg #x4
                        )
                      )
                (set! (-> giftag regs)
                      (new 'static 'gif-tag-regs
                        :regs0 (gif-reg-id rgbaq)
                        :regs1 (gif-reg-id xyzf2)
                        :regs2 (gif-reg-id rgbaq)
                        :regs3 (gif-reg-id xyzf2)
                        )
                      )
                (set! (-> buf2 base) (&+ (the-as pointer giftag) 16))
                )
              (case var-mode
                (('fade-depth)
                 (let ((f0-3 (fmax 0.2 (fmin 1.0 (* 0.00000005960465 (the float (-> s4-0 vector 0 z)))))))
                   (set! (-> s3-0 vector 0 x) (the int (* (the float (-> var-start-color r)) f0-3)))
                   (set! (-> s3-0 vector 0 y) (the int (* (the float (-> var-start-color g)) f0-3)))
                   (set! (-> s3-0 vector 0 z) (the int (* (the float (-> var-start-color b)) f0-3)))
                   )
                 (set! (-> s3-0 vector 0 w) (the-as int (-> var-start-color a)))
                 )
                (else
                  (set! (-> s3-0 vector 0 x) (the-as int (-> var-start-color r)))
                  (set! (-> s3-0 vector 0 y) (the-as int (-> var-start-color g)))
                  (set! (-> s3-0 vector 0 z) (the-as int (-> var-start-color b)))
                  (set! (-> s3-0 vector 0 w) (the-as int (-> var-start-color a)))
                  )
                )
              (cond
                ((= var-mode 'fade-depth)
                 (let ((f0-7 (fmax 0.2 (fmin 1.0 (* 0.00000005960465 (the float (-> s4-0 vector 1 z)))))))
                   (set! (-> s3-0 vector 1 x) (the int (* (the float (-> var-end-color r)) f0-7)))
                   (set! (-> s3-0 vector 1 y) (the int (* (the float (-> var-end-color g)) f0-7)))
                   (set! (-> s3-0 vector 1 z) (the int (* (the float (-> var-end-color b)) f0-7)))
                   )
                 (set! (-> s3-0 vector 1 w) (the-as int (-> var-end-color a)))
                 )
                (else
                  (set! (-> s3-0 vector 1 x) (the-as int (-> var-end-color r)))
                  (set! (-> s3-0 vector 1 y) (the-as int (-> var-end-color g)))
                  (set! (-> s3-0 vector 1 z) (the-as int (-> var-end-color b)))
                  (set! (-> s3-0 vector 1 w) (the-as int (-> var-end-color a)))
                  )
                )
              (set! (-> s4-0 vector 0 z) (the-as int (+ (-> s4-0 vector 0 z) -8192)))
              (set! (-> s4-0 vector 1 z) (the-as int (+ (-> s4-0 vector 1 z) -8192)))
              (let* ((a1-50 (the-as (inline-array vector4w-2) (-> buf2 base))))
                (set! (-> a1-50 0 vector 0 quad) (-> s3-0 vector 0 quad))
                (set! (-> a1-50 0 vector 1 quad) (-> s4-0 vector 0 quad))
                (set! (-> a1-50 1 vector 0 quad) (-> s3-0 vector 1 quad))
                (set! (-> a1-50 1 vector 1 quad) (-> s4-0 vector 1 quad))
                (set! (-> buf2 base) (&+ (the-as pointer a1-50) 64))
                )
              (let ((a3-11 (/ (the-as int (+ (- -16 (the-as int a0-28)) (the-as int (-> buf2 base)))) 16)))
                (cond
                  ((nonzero? a3-11)
                   (logior! (-> a0-28 0) (shr (shl a3-11 48) 48))
                   (logior! (-> a0-28 1) (shl (shr (shl a3-11 48) 48) 32))
                   )
                  (else
                    (set! (-> buf2 base) a0-28)
                    )
                  )
                )
              )
            (let ((tag-end (-> buf2 base)))
              (let ((pkt2 (the-as dma-packet (-> buf2 base))))
                (set! (-> pkt2 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
                (set! (-> pkt2 vif0) (new 'static 'vif-tag))
                (set! (-> pkt2 vif1) (new 'static 'vif-tag))
                (set! (-> buf2 base) (&+ (the-as pointer pkt2) 16))
                )
              (dma-bucket-insert-tag
                (-> *display* frames (-> *display* on-screen) bucket-group)
                bucket
                tag-start
                (the-as (pointer dma-tag) tag-end)
                )
              )
            )
          )
        )
      )
    )
  )

(defun-debug internal-draw-debug-text-3d ((bucket bucket-id) (text string) (position vector) (color font-color) (screen-offset vector2h))
  "Draw text at the given location (in 3D), with a 2D offset."
  (let ((screen-pos (new 'stack-no-clear 'vector4w)))
    (set! (-> screen-pos quad) (the-as uint128 0))
    (when (transform-point-qword! screen-pos position)
      (let* ((buf (-> *display* frames (-> *display* on-screen) debug-buf))
             (tag-start (-> buf base))
             )
        (let ((font-ctx (new
                          'stack
                          'font-context
                          *font-default-matrix*
                          (the-as int (+ (-> screen-offset x) -1792 (/ (-> screen-pos x) 16)))
                          (the-as int (+ (-> screen-offset y) -1855 (/ (-> screen-pos y) 16)))
                          0.0
                          color
                          (font-flags shadow kerning)
                          )
                        )
              )
          (let ((v1-10 font-ctx))
            (set! (-> v1-10 origin z) (the float (/ (-> screen-pos z) 16)))
            )
          (draw-string text buf font-ctx)
          )
        (let ((tag-end (-> buf base)))
          (let ((pkt (the-as dma-packet (-> buf base))))
            (set! (-> pkt dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> pkt vif0) (new 'static 'vif-tag))
            (set! (-> pkt vif1) (new 'static 'vif-tag))
            (set! (-> buf base) (&+ (the-as pointer pkt) 16))
            )
          (dma-bucket-insert-tag
            (-> *display* frames (-> *display* on-screen) bucket-group)
            bucket
            tag-start
            (the-as (pointer dma-tag) tag-end)
            )
          )
        )
      )
    )
  )

(defun-debug add-debug-outline-triangle ((enable symbol) (bucket bucket-id) (p0 vector) (p1 vector) (p2 vector) (color rgba))
  "Draw outline of a triangle using lines."
  (when enable
    (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
    (add-debug-line #t bucket p1 p2 color #f (the-as rgba -1))
    (add-debug-line #t bucket p2 p0 color #f (the-as rgba -1))
    )
  #f
  )

(defun-debug add-debug-triangle-normal ((enable symbol) (bucket bucket-id) (p0 vector) (p1 vector) (p2 vector) (color rgba))
  "Draw the normal of a triangle, with length of 1 meter."
  (when enable
    (let ((s4-0 (new 'stack-no-clear 'vector))
          (s3-0 (vector-3pt-cross! (new 'stack-no-clear 'vector) p0 p1 p2))
          )
      (vector-float/! s3-0 s3-0 (* 0.00024414062 (vector-length s3-0)))
      (vector+! s4-0 p0 p1)
      (vector+! s4-0 s4-0 p2)
      (vector-float/! s4-0 s4-0 3.0)
      (vector+! s3-0 s3-0 s4-0)
      (add-debug-line #t bucket s4-0 s3-0 color #f (the-as rgba -1))
      )
    )
  #f
  )

(defun-debug add-debug-flat-triangle ((enable symbol) (bucket bucket-id) (p0 vector) (p1 vector) (p2 vector) (color rgba))
  "Draw a triangle with flat shading"
  (if (not enable)
      (return #f)
      )
  (let ((s5-0 (new 'stack 'vector4w-3))
        (s4-0 (new 'stack 'vector4w-3))
        (a1-3 (new 'stack-no-clear 'vector))
        (s2-0 (new 'stack-no-clear 'vector))
        (s1-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> a1-3 quad) (-> p0 quad))
    (set! (-> s2-0 quad) (-> p1 quad))
    (set! (-> s1-0 quad) (-> p2 quad))
    (set! (-> a1-3 w) 1.0)
    (set! (-> s2-0 w) 1.0)
    (set! (-> s1-0 w) 1.0)
    (when (and (transform-point-qword! (-> s5-0 vector 0) a1-3)
               (transform-point-qword! (-> s5-0 vector 1) s2-0)
               (transform-point-qword! (-> s5-0 vector 2) s1-0)
               )
      (let* ((buf (-> *display* frames (-> *display* on-screen) debug-buf))
             (tag-start (-> buf base))
             )
        (let ((a0-12 (the-as (pointer uint64) (-> buf base))))
          (let* ((pkt1 (the-as dma-packet (-> buf base))))
            (set! (-> pkt1 dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
            (set! (-> pkt1 vif0) (new 'static 'vif-tag))
            (set! (-> pkt1 vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1))
            (set! (-> buf base) (&+ (the-as pointer pkt1) 16))
            )
          (let* ((giftag (the-as gs-gif-tag (-> buf base))))
            (set! (-> giftag tag)
                  (new 'static 'gif-tag64
                    :nloop #x1
                    :eop #x1
                    :pre #x1
                    :prim (new 'static 'gs-prim :prim (gs-prim-type tri) :iip #x1 :abe #x1)
                    :nreg #x6
                    )
                  )
            (set! (-> giftag regs)
                  (new 'static 'gif-tag-regs
                    :regs0 (gif-reg-id rgbaq)
                    :regs1 (gif-reg-id xyzf2)
                    :regs2 (gif-reg-id rgbaq)
                    :regs3 (gif-reg-id xyzf2)
                    :regs4 (gif-reg-id rgbaq)
                    :regs5 (gif-reg-id xyzf2)
                    )
                  )
            (set! (-> buf base) (&+ (the-as pointer giftag) 16))
            )
          (set! (-> s4-0 vector 0 x) (the-as int (-> color r)))
          (set! (-> s4-0 vector 0 y) (the-as int (-> color g)))
          (set! (-> s4-0 vector 0 z) (the-as int (-> color b)))
          (set! (-> s4-0 vector 0 w) (the-as int (-> color a)))
          (set! (-> s5-0 vector 0 z) (the-as int (+ (-> s5-0 vector 0 z) -8192)))
          (set! (-> s5-0 vector 1 z) (the-as int (+ (-> s5-0 vector 1 z) -8192)))
          (set! (-> s5-0 vector 2 z) (the-as int (+ (-> s5-0 vector 2 z) -8192)))
          (let* ((a3-5 (the-as (inline-array vector) (-> buf base))))
            (set! (-> a3-5 0 quad) (-> s4-0 vector 0 quad))
            (set! (-> a3-5 1 quad) (-> s5-0 vector 0 quad))
            (set! (-> a3-5 2 quad) (-> s4-0 vector 0 quad))
            (set! (-> a3-5 3 quad) (-> s5-0 vector 1 quad))
            (set! (-> a3-5 4 quad) (-> s4-0 vector 0 quad))
            (set! (-> a3-5 5 quad) (-> s5-0 vector 2 quad))
            (set! (-> buf base) (&+ (the-as pointer a3-5) 96))
            )
          (let ((a1-25 (/ (the-as int (+ (- -16 (the-as int a0-12)) (the-as int (-> buf base)))) 16)))
            (cond
              ((nonzero? a1-25)
                (logior! (-> a0-12 0) (shr (shl a1-25 48) 48))
                (logior! (-> a0-12 1) (shl (shr (shl a1-25 48) 48) 32))
                )
              (else
                (set! (-> buf base) a0-12)
                )
              )
            )
          )
        (let ((tag-end (-> buf base)))
          (let ((pkt2 (the-as dma-packet (-> buf base))))
            (set! (-> pkt2 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> pkt2 vif0) (new 'static 'vif-tag))
            (set! (-> pkt2 vif1) (new 'static 'vif-tag))
            (set! (-> buf base) (&+ (the-as pointer pkt2) 16))
            )
          (dma-bucket-insert-tag
            (-> *display* frames (-> *display* on-screen) bucket-group)
            bucket
            tag-start
            (the-as (pointer dma-tag) tag-end)
            )
          )
        )
      )
    )
  #f
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Buffered debug draw
;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Some of the debug draw stuff just adds a line to a list of lines to draw.
;; This is used when pausing - the actual calls to debug-draw-line won't happen, but
;; we won't clear the debug draw buffer so they will still be drawn.

(when *debug-segment*

(deftype debug-line (structure)
  ((flags  int32             :offset-assert   0)
   (bucket bucket-id         :offset-assert   4)
   (v1     vector    :inline :offset-assert  16)
   (v2     vector    :inline :offset-assert  32)
   (color  rgba              :offset-assert  48)
   (mode   symbol            :offset-assert  52)
   (color2 rgba              :offset-assert  56)
   )
  :method-count-assert 9
  :size-assert         #x3c
  :flag-assert         #x90000003c
  )

(defmethod inspect debug-line ((obj debug-line))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'debug-line)
  (format #t "~1Tflags: ~D~%" (-> obj flags))
  (format #t "~1Tbucket: ~D~%" (-> obj bucket))
  (format #t "~1Tv1: #<vector @ #x~X>~%" (-> obj v1))
  (format #t "~1Tv2: #<vector @ #x~X>~%" (-> obj v2))
  (format #t "~1Tcolor: ~D~%" (-> obj color))
  (format #t "~1Tmode: ~A~%" (-> obj mode))
  (format #t "~1Tcolor2: ~D~%" (-> obj color2))
  (label cfg-4)
  obj
  )

(deftype debug-text-3d (structure)
  ((flags  int32              :offset-assert   0)
   (bucket bucket-id          :offset-assert   4)
   (pos    vector     :inline :offset-assert  16)
   (color  font-color         :offset-assert  32)
   (offset vector2h   :inline :offset-assert  36)
   (str    string             :offset-assert  40)
   )
  :method-count-assert 9
  :size-assert         #x2c
  :flag-assert         #x90000002c
  )

(defmethod inspect debug-text-3d ((obj debug-text-3d))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj 'debug-text-3d)
  (format #t "~1Tflags: ~D~%" (-> obj flags))
  (format #t "~1Tbucket: ~D~%" (-> obj bucket))
  (format #t "~1Tpos: #<vector @ #x~X>~%" (-> obj pos))
  (format #t "~1Tcolor: ~D~%" (-> obj color))
  (format #t "~1Toffset: #<vector2h @ #x~X>~%" (-> obj offset))
  (format #t "~1Tstr: ~A~%" (-> obj str))
  (label cfg-4)
  obj
  )

(deftype debug-tracking-thang (basic)
  ((length           int32  :offset-assert   4)
   (allocated-length int32  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )

(defmethod inspect debug-tracking-thang ((obj debug-tracking-thang))
  (when (not obj)
    (set! obj obj)
    (goto cfg-4)
    )
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~1Tlength: ~D~%" (-> obj length))
  (format #t "~1Tallocated-length: ~D~%" (-> obj allocated-length))
  (label cfg-4)
  obj
  )

(define *debug-lines* (the-as (inline-array debug-line) (malloc 'debug #x100000)))
(define *debug-lines-trk* (new 'debug 'debug-tracking-thang))

(set! (-> *debug-lines-trk* allocated-length) #x4000)

(define *debug-text-3ds* (the-as (inline-array debug-text-3d) (malloc 'debug #x6000)))
(define *debug-text-3d-trk* (new 'debug 'debug-tracking-thang))

(set! (-> *debug-text-3d-trk* allocated-length) 512)

(dotimes (gp-0 (-> *debug-text-3d-trk* allocated-length))
  (set! (-> *debug-text-3ds* gp-0 str) (new 'debug 'string 80 (the-as string #f)))
  )

)

(defun-debug get-debug-line ()
  "Allocate a debug-line from the list."
  (cond
    ((< (-> *debug-lines-trk* length) (-> *debug-lines-trk* allocated-length))
     (+! (-> *debug-lines-trk* length) 1)
     (-> *debug-lines* (+ (-> *debug-lines-trk* length) -1))
     )
    (else
      (the-as debug-line #f)
      )
    )
  )

(defun-debug get-debug-text-3d ()
  "Allocate a debug text 3d from the list."
  (cond
    ((< (-> *debug-text-3d-trk* length) (-> *debug-text-3d-trk* allocated-length))
     (+! (-> *debug-text-3d-trk* length) 1)
     (-> *debug-text-3ds* (+ (-> *debug-text-3d-trk* length) -1))
     )
    (else
      (the-as debug-text-3d #f)
      )
    )
  )

(defun-debug debug-reset-buffers ()
  "Clear all allocated debug things"
  (set! (-> *debug-lines-trk* length) 0)
  (set! (-> *debug-text-3d-trk* length) 0)
  (set! *debug-draw-pauseable* #f)
  #f
  )

(defun-debug debug-draw-buffers ()
  "Draw all debug lines and debug text."
  (dotimes (i (-> *debug-lines-trk* length))
    (let ((line (-> *debug-lines* i)))
      (internal-draw-debug-line
        (-> line bucket)
        (-> line v1)
        (-> line v2)
        (-> line color)
        (-> line mode)
        (-> line color2)
        )
      )
    )
  (dotimes (j (-> *debug-text-3d-trk* length))
    (let ((text-3d (-> *debug-text-3ds* j)))
      (internal-draw-debug-text-3d
        (-> text-3d bucket)
        (-> text-3d str)
        (-> text-3d pos)
        (-> text-3d color)
        (-> text-3d offset)
        )
      )
    )
  #f
  )

(defun-debug add-debug-line ((enable symbol)
                   (bucket bucket-id)
                   (start vector)
                   (end vector)
                   (start-color rgba)
                   (mode symbol)
                   (end-color rgba)
                   )
  "Draw a debug line between p0 and p1, in 3D."
  (when enable
    (cond
      (*debug-draw-pauseable*
        (let ((line (get-debug-line)))
          (when line
            (set! (-> line bucket) bucket)
            (set! (-> line v1 quad) (-> start quad))
            (set! (-> line v2 quad) (-> end quad))
            (set! (-> line color) start-color)
            (set! (-> line color2) end-color)
            (set! (-> line mode) mode)
            )
          )
        )
      (else
        (internal-draw-debug-line bucket start end start-color mode end-color)
        )
      )
    )
  #f
  )

(defun-debug add-debug-line2d ((enable symbol) (bucket bucket-id) (start vector) (end vector) (color vector))
  "Draw a line in screen coordinates"
  (if (not enable)
      (return #f)
      )
  (let* ((buf (-> *display* frames (-> *display* on-screen) debug-buf))
         (tag-start (-> buf base))
         )
    (let ((p0 (new 'stack 'vector4w))
          (p1 (new 'stack 'vector4w))
          )
      (set! (-> p0 quad) (-> start quad))
      (set! (-> p1 quad) (-> end quad))
      (set! (-> p0 x) (* (+ (-> p0 x) 2048) 16))
      (set! (-> p0 y) (* -16 (- 2048 (-> p0 y))))
      (set! (-> p0 z) #x7fffff)
      (set! (-> p1 x) (* (+ (-> p1 x) 2048) 16))
      (set! (-> p1 y) (* -16 (- 2048 (-> p1 y))))
      (set! (-> p1 z) #x7fffff)
      (let ((a0-18 (the-as (pointer uint64) (-> buf base))))
        (let* ((a1-7 buf)
               (a2-3 (the-as dma-packet (-> a1-7 base)))
               )
          (set! (-> a2-3 dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
          (set! (-> a2-3 vif0) (new 'static 'vif-tag))
          (set! (-> a2-3 vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1))
          (set! (-> a1-7 base) (&+ (the-as pointer a2-3) 16))
          )
        (let* ((a1-8 buf)
               (giftag (the-as gs-gif-tag (-> a1-8 base)))
               )
          (set! (-> giftag tag)
                (new 'static 'gif-tag64
                  :nloop #x1
                  :eop #x1
                  :pre #x1
                  :prim (new 'static 'gs-prim :prim (gs-prim-type line) :iip #x1 :abe #x1)
                  :nreg #x4
                  )
                )
          (set! (-> giftag regs)
                (new 'static 'gif-tag-regs
                  :regs0 (gif-reg-id rgbaq)
                  :regs1 (gif-reg-id xyzf2)
                  :regs2 (gif-reg-id rgbaq)
                  :regs3 (gif-reg-id xyzf2)
                  )
                )
          (set! (-> a1-8 base) (&+ (the-as pointer giftag) 16))
          )
        (let* ((a1-9 buf)
               (v0 (the-as vector4w-2 (-> a1-9 base)))
               )
          (set! (-> v0 vector 0 quad) (-> color quad))
          (set! (-> v0 vector 1 quad) (-> p0 quad))
          (set! (-> a1-9 base) (&+ (the-as pointer v0) 32))
          )
        (let* ((a1-10 buf)
               (v1 (the-as vector4w-2 (-> a1-10 base)))
               )
          (set! (-> v1 vector 0 quad) (-> color quad))
          (set! (-> v1 vector 1 quad) (-> p1 quad))
          (set! (-> a1-10 base) (&+ (the-as pointer v1) 32))
          )
        (let ((a1-14 (/ (the-as int (+ (- -16 (the-as int a0-18)) (the-as int (-> buf base)))) 16)))
          (cond
            ((nonzero? a1-14)
             (logior! (-> a0-18 0) (shr (shl a1-14 48) 48))
             (logior! (-> a0-18 1) (shl (shr (shl a1-14 48) 48) 32))
             )
            (else
              (set! (-> buf base) a0-18)
              )
            )
          )
        )
      )
    (let ((tag-end (-> buf base)))
      (let ((v1-12 (the-as dma-packet (-> buf base))))
        (set! (-> v1-12 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
        (set! (-> v1-12 vif0) (new 'static 'vif-tag))
        (set! (-> v1-12 vif1) (new 'static 'vif-tag))
        (set! (-> buf base) (&+ (the-as pointer v1-12) 16))
        )
      (dma-bucket-insert-tag
        (-> *display* frames (-> *display* on-screen) bucket-group)
        bucket
        tag-start
        (the-as (pointer dma-tag) tag-end)
        )
      )
    )
  #f
  )

(defun-debug add-debug-box ((enable symbol) (bucket bucket-id) (c1 vector) (c2 vector) (color rgba))
  "Draw an axis-aligned box"
  (let ((p0 (new-stack-vector0)))
    (set! (-> p0 quad) (-> c1 quad))
    (let ((p1 (new-stack-vector0)))
      (set! (-> p1 quad) (-> c1 quad))
      (when enable
        (set! (-> p1 x) (-> c2 x))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 x) (-> c1 x))
        (set! (-> p1 y) (-> c2 y))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 y) (-> c1 y))
        (set! (-> p1 z) (-> c2 z))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p0 y) (-> c2 y))
        (set! (-> p1 y) (-> c2 y))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 z) (-> c1 z))
        (set! (-> p1 x) (-> c2 x))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 y) (-> c1 y))
        (set! (-> p0 x) (-> c2 x))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p0 quad) (-> c2 quad))
        (set! (-> p1 quad) (-> c2 quad))
        (set! (-> p1 x) (-> c1 x))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 x) (-> c2 x))
        (set! (-> p1 y) (-> c1 y))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 y) (-> c2 y))
        (set! (-> p1 z) (-> c1 z))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p0 y) (-> c1 y))
        (set! (-> p1 y) (-> c1 y))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 z) (-> c2 z))
        (set! (-> p1 x) (-> c1 x))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        (set! (-> p1 y) (-> c2 y))
        (set! (-> p0 x) (-> c1 x))
        (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
        )
      )
    )
  #f
  )

(defun-debug add-debug-box-with-transform ((enable symbol) (bucket bucket-id) (box bounding-box) (trans matrix) (color rgba))
  "Draw an oriented box"
  (b! (not enable) cfg-5 :delay (nop!))
  (let ((points (new 'stack-no-clear 'inline-array 'vector 8)))
    (let ((corners (new 'stack-no-clear 'inline-array 'vector 2))
          (point (new 'stack-no-clear 'vector))
          )
      (set! (-> corners 0 quad) (-> box min quad))
      (set! (-> corners 1 quad) (-> box max quad))
      (set! (-> point w) 1.0)
      (dotimes (i 8)
        (set! (-> point x) (-> corners (logand i 1) x))
        (set! (-> point y) (-> corners (logand (/ i 2) 1) y))
        (set! (-> point z) (-> corners (logand (/ i 4) 1) z))
        (let ((a0-5 (-> points i)))
          (vector-matrix*! a0-5 point trans)
          )
        )
      )
    (add-debug-line #t bucket (-> points 0) (-> points 1) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 1) (-> points 3) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 3) (-> points 2) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 2) (-> points 0) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 4) (-> points 5) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 5) (-> points 7) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 7) (-> points 6) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 6) (-> points 4) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 0) (-> points 4) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 1) (-> points 5) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 3) (-> points 7) color #f (the-as rgba -1))
    (add-debug-line #t bucket (-> points 2) (-> points 6) color #f (the-as rgba -1))
    )
  (label cfg-5)
  (the-as symbol 0)
  )

(defun-debug add-debug-x ((enable symbol) (bucket bucket-id) (position vector) (color rgba))
  "Draw an X in the xz plane"
  (if (not enable)
      (return #f)
      )
  (let ((p0 (new-stack-vector0))
        (p1 (new-stack-vector0))
        )
    (vector+! p0 position (new 'static 'vector :x -1228.8))
    (vector+! p1 position (new 'static 'vector :x 1228.8))
    (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
    (vector+! p0 position (new 'static 'vector :z -1228.8))
    (vector+! p1 position (new 'static 'vector :z 1228.8))
    (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
    )
  #f
  )

(defun-debug add-debug-cross ((enable symbol) (bucket bucket-id) (position vector) (radius float))
  "Draw an XYZ coordinate cross"
  (if (not enable)
      (return #f)
      )
  (let ((p0 (new-stack-vector0))
        (p1 (new-stack-vector0))
        )
    (let ((a1-1 p0)
          (v1-2 position)
          (a0-1 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-1 x) (- radius))
      (set! (-> a0-1 y) 0.0)
      (set! (-> a0-1 z) 0.0)
      (set! (-> a0-1 w) 1.0)
      (vector+! a1-1 v1-2 a0-1)
      )
    (let ((a1-3 p1)
          (v1-3 position)
          (a0-2 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-2 x) radius)
      (set! (-> a0-2 y) 0.0)
      (set! (-> a0-2 z) 0.0)
      (set! (-> a0-2 w) 1.0)
      (vector+! a1-3 v1-3 a0-2)
      )
    (add-debug-line #t bucket p0 p1 *color-red* #f (the-as rgba -1))
    (let ((a1-6 p0)
          (v1-4 position)
          (a0-4 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-4 x) 0.0)
      (set! (-> a0-4 y) (- radius))
      (set! (-> a0-4 z) 0.0)
      (set! (-> a0-4 w) 1.0)
      (vector+! a1-6 v1-4 a0-4)
      )
    (let ((a1-8 p1)
          (v1-5 position)
          (a0-5 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-5 x) 0.0)
      (set! (-> a0-5 y) radius)
      (set! (-> a0-5 z) 0.0)
      (set! (-> a0-5 w) 1.0)
      (vector+! a1-8 v1-5 a0-5)
      )
    (add-debug-line #t bucket p0 p1 *color-green* #f (the-as rgba -1))
    (let ((a1-11 p0)
          (v1-6 position)
          (a0-7 (new 'stack-no-clear 'vector))
          )
      (set! (-> a0-7 x) 0.0)
      (set! (-> a0-7 y) 0.0)
      (set! (-> a0-7 z) (- radius))
      (set! (-> a0-7 w) 1.0)
      (vector+! a1-11 v1-6 a0-7)
      )
    (let ((a0-8 p1)
          (v1-7 (new 'stack-no-clear 'vector))
          )
      (set! (-> v1-7 x) 0.0)
      (set! (-> v1-7 y) 0.0)
      (set! (-> v1-7 z) radius)
      (set! (-> v1-7 w) 1.0)
      (vector+! a0-8 position v1-7)
      )
    (add-debug-line #t bucket p0 p1 *color-blue* #f (the-as rgba -1))
    )
  #f
  )

(defun-debug add-debug-text-3d ((enable symbol)
                      (bucket bucket-id)
                      (text string)
                      (position vector)
                      (color font-color)
                      (screen-offset vector2h)
                      )
  "Draw text at the given point. screen-offset can be #f."
  (when enable
    (cond
      (*debug-draw-pauseable*
        (let ((v1-2 (get-debug-text-3d)))
          (when v1-2
            (set! (-> v1-2 flags) 0)
            (set! (-> v1-2 bucket) bucket)
            (set! (-> v1-2 pos quad) (-> position quad))
            (cond
              (screen-offset
                (set! (-> v1-2 offset x) (the-as int (-> screen-offset x)))
                (set! (-> v1-2 offset y) (the-as int (-> screen-offset y)))
                )
              (else
                (set! (-> v1-2 offset x) 0)
                (set! (-> v1-2 offset y) 0)
                0
                )
              )
            (set! (-> v1-2 color) color)
            (let ((a0-6 0)
                  (a1-2 (-> text data))
                  (v1-4 (-> v1-2 str data))
                  )
              (while (and (nonzero? (-> a1-2 0)) (< a0-6 79))
                (set! (-> v1-4 0) (-> a1-2 0))
                (set! a1-2 (&-> a1-2 1))
                (set! v1-4 (&-> v1-4 1))
                (+! a0-6 1)
                )
              (set! (-> v1-4 0) (the-as uint 0))
              )
            0
            )
          )
        )
      (else
        (internal-draw-debug-text-3d bucket text position color (cond
                                                                  (screen-offset
                                                                    (empty)
                                                                    screen-offset
                                                                    )
                                                                  (else
                                                                    (new 'static 'vector2h)
                                                                    )
                                                                  )
                                     )
        )
      )
    )
  #f
  )

(defun-debug add-debug-sphere-with-transform ((enable symbol) (bucket bucket-id) (position vector) (radius meters) (trans matrix) (color rgba))
  "Transform the given point by the given transform, then draw a debug sphere there.
   The orientation of the debug sphere itself is not changed by the transform, just its origin."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (when enable
      (.lvf vf5 (&-> position quad))
      (.lvf vf1 (&-> trans vector 0 quad))
      (.lvf vf2 (&-> trans vector 1 quad))
      (.lvf vf3 (&-> trans vector 2 quad))
      (.lvf vf4 (&-> trans trans quad))
      (.mul.w.vf acc vf4 vf0)
      (.add.mul.x.vf acc vf1 vf5 acc)
      (.add.mul.y.vf acc vf2 vf5 acc)
      (.add.mul.z.vf vf5 vf3 vf5 acc)
      (let ((position-transformed (new 'stack-no-clear 'vector)))
        (.svf (&-> position-transformed quad) vf5)
        (add-debug-sphere enable bucket position-transformed radius color)
        )
      )
    #f
    )
  )

(defun-debug add-debug-sphere ((enable symbol) (bucket bucket-id) (position vector) (radius meters) (color rgba))
  "Add a debug sphere at the given point."
  (if enable
      (add-debug-sphere-from-table bucket position radius color 6)
      )
  #f
  )

(defun-debug add-debug-text-sphere ((enable symbol) (bucket bucket-id) (position vector) (radius meters) (text string) (color rgba))
  "Add a debug sphere at the given point, with some text. The color is for the sphere - the text is color 0."
  (add-debug-sphere enable bucket position radius color)
  (add-debug-text-3d enable bucket text position (font-color default-#cddbcd) (the-as vector2h #f))
  #f
  )

(defun-debug add-debug-spheres ((enable symbol) (bucket bucket-id) (origins (inline-array vector)) (count int) (color rgba))
  "Add a bunch of spheres. The radius is taken from the w component of the origin."
  (when enable
    (let ((origin (-> origins 0)))
      (countdown (i count)
        (add-debug-sphere #t bucket origin (-> origin w) color)
        (&+! origin 16)
        )
      )
    )
  #f
  )

(defun-debug add-debug-line-sphere ((enable symbol) (bucket bucket-id) (position vector) (forward vector) (arg4 float) (color rgba))
  (local-vars
    (var-bucket bucket-id)
    (var-position vector)
    (var-forward vector)
    (var-arg4 float)
    (var-color rgba)
    (mat matrix)
    (forward-length float)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (b! (not enable) cfg-8 :delay (nop!))
    (set! var-bucket bucket)
    (set! var-position position)
    (set! var-forward forward)
    (set! var-arg4 arg4)
    (set! var-color color)
    (set! mat (new 'stack-no-clear 'matrix))
    (set! forward-length (vector-length var-forward))
    (let ((mat-forward (new 'stack-no-clear 'vector))
          (mat-down (new 'stack-no-clear 'vector))
          )
      (vector-normalize-copy! mat-forward var-forward 1.0)
      (vector-reset! mat-down)
      (let* ((f0-2 (-> mat-forward y))
             (f0-4 (* f0-2 f0-2))
             (f1-0 (-> mat-forward z))
             )
        (if (< f0-4 (* f1-0 f1-0))
            (set! (-> mat-down y) -1.0)
            (set! (-> mat-down z) -1.0)
            )
        )
      (forward-down->inv-matrix mat mat-forward mat-down)
      )
    (set! (-> mat trans quad) (-> var-position quad))
    (set! (-> mat trans w) 1.0)
    (let ((gp-1 (new 'static 'inline-array vector 3
                  (new 'static 'vector :y 0.5877 :z 0.951 :w 0.951)
                  (new 'static 'vector :x 0.5877 :z -0.5877 :w -0.951)
                  (new 'static 'vector :x -0.951 :y -0.5878)
                  )
                )
          (s5-1 (new 'static 'inline-array vector 3
                  (new 'static 'vector :x 1.0 :y 0.809 :z 0.3089 :w -0.3088)
                  (new 'static 'vector :x -0.809 :y -1.0 :z -0.809 :w -0.309)
                  (new 'static 'vector :x 0.3089 :y 0.8089)
                  )
                )
          (s4-0 (new 'stack-no-clear 'vector))
          (s3-0 (new 'stack-no-clear 'vector))
          (s2-0 (new 'stack-no-clear 'vector))
          (s1-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s1-0 z) 0.0)
      (set! (-> s1-0 w) 1.0)
      (set! (-> s1-0 x) (* var-arg4 (-> s5-1 2 y)))
      (set! (-> s1-0 y) (* var-arg4 (-> gp-1 2 y)))
      (vector-matrix*! s3-0 s1-0 mat)
      (dotimes (i 10)
        (set! (-> s4-0 quad) (-> s3-0 quad))
        (set! (-> s1-0 x) (* var-arg4 (-> (&-> s5-1 0 data i) 0)))
        (set! (-> s1-0 y) (* var-arg4 (-> (&-> gp-1 0 data i) 0)))
        (vector-matrix*! s3-0 s1-0 mat)
        (add-debug-line #t var-bucket s4-0 s3-0 var-color #f (the-as rgba -1))
        (let ((v1-26 s2-0))
          (let ((a0-10 s3-0)
                (a1-7 (-> mat vector 2))
                (f0-18 forward-length)
                )
            (.lvf vf2 (&-> a1-7 quad))
            (.lvf vf1 (&-> a0-10 quad))
            (let ((a0-11 f0-18))
              (.mov vf3 a0-11)
              )
            )
          (.add.x.vf vf4 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf2 vf3)
          (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
          (.svf (&-> v1-26 quad) vf4)
          )
        (add-debug-line #t var-bucket s3-0 s2-0 var-color #f (the-as rgba -1))
        (let ((v1-27 s4-0))
          (let ((a0-13 s4-0)
                (a1-10 (-> mat vector 2))
                (f0-19 forward-length)
                )
            (.lvf vf2 (&-> a1-10 quad))
            (.lvf vf1 (&-> a0-13 quad))
            (let ((a0-14 f0-19))
              (.mov vf3 a0-14)
              )
            )
          (.add.x.vf vf4 vf0 vf0 :mask #b1000)
          (.mul.x.vf acc vf2 vf3)
          (.add.mul.w.vf vf4 vf1 vf0 acc :mask #b111)
          (.svf (&-> v1-27 quad) vf4)
          )
        (add-debug-line #t var-bucket s4-0 s2-0 var-color #f (the-as rgba -1))
        )
      )
    (label cfg-8)
    0
    (none)
    )
  )

(defun-debug add-debug-circle ((enable symbol) (bucket bucket-id) (position vector) (radius float) (color rgba) (orientation matrix))
  (local-vars (i int) (sv-64 vector) (sv-80 vector))
  "Draw a 2D circle in 3D. orientation may be #f, which will default to drawing in the xz plane."
  (if (not enable)
      (return #f)
      )
  (let ((angle 0.0)
        (line-start (new-stack-vector0))
        (line-end (new-stack-vector0))
        )
    (set! i 0)
    (while (< i 12)
      (set! sv-64 line-start)
      (set! (-> sv-64 x) (* radius (cos angle)))
      (set! (-> sv-64 y) 0.0)
      (set! (-> sv-64 z) (* radius (sin angle)))
      (set! (-> sv-64 w) 1.0)
      (set! angle (+ 5461.3335 angle))
      (set! sv-80 line-end)
      (set! (-> sv-80 x) (* radius (cos angle)))
      (set! (-> sv-80 y) 0.0)
      (set! (-> sv-80 z) (* radius (sin angle)))
      (set! (-> sv-80 w) 1.0)
      (when orientation
        (vector-matrix*! line-start line-start orientation)
        (vector-matrix*! line-end line-end orientation)
        )
      (vector+! line-start line-start position)
      (vector+! line-end line-end position)
      (add-debug-line #t bucket line-start line-end color #f (the-as rgba -1))
      (set! i (+ i 1))
      )
    )
  #f
  )

(defun-debug add-debug-vector ((enable symbol) (bucket bucket-id) (position vector) (direction vector) (length meters) (color rgba))
  "Draw a ray from the given position, direction, and length."
  (if (not enable)
      (return #f)
      )
  (let ((line-end (new-stack-vector0)))
    (set! (-> line-end x) (+ (-> position x) (* (-> direction x) length)))
    (set! (-> line-end y) (+ (-> position y) (* (-> direction y) length)))
    (set! (-> line-end z) (+ (-> position z) (* (-> direction z) length)))
    (add-debug-line #t bucket position line-end color #f (the-as rgba -1))
    )
  #f
  )

(defun-debug add-debug-matrix ((enable symbol) (bucket bucket-id) (mat matrix) (line-length meters))
  "Draw the rotation vectors of a matrix at its position."
  (add-debug-vector enable bucket (-> mat trans) (-> mat vector 0) line-length (new 'static 'rgba :r #xff :a #x80))
  (add-debug-vector enable bucket (-> mat trans) (-> mat vector 1) line-length (new 'static 'rgba :g #xff :a #x80))
  (add-debug-vector enable bucket (-> mat trans) (-> mat vector 2) line-length (new 'static 'rgba :b #xff :a #x80))
  mat
  )

(defun-debug add-debug-rot-matrix ((enable symbol) (bucket bucket-id) (mat matrix) (position vector))
  "Draw the rotation vectors of a matrix at the given position."
  (add-debug-vector enable bucket position (-> mat vector 0) (meters 2.0) (new 'static 'rgba :r #xff :a #x80))
  (add-debug-vector enable bucket position (-> mat vector 1) (meters 2.0) (new 'static 'rgba :g #xff :a #x80))
  (add-debug-vector enable bucket position (-> mat vector 2) (meters 2.0) (new 'static 'rgba :b #xff :a #x80))
  mat
  )

(defun-debug add-debug-quaternion ((enable symbol) (bucket bucket-id) (position vector) (quat quaternion))
  "Converts the quaternion to a matrix and draw its rotation vectors at the given position."
  (when enable
    (let ((mat (quaternion->matrix (new 'stack-no-clear 'matrix) quat)))
      (add-debug-rot-matrix enable bucket mat position)
      )
    )
  (none)
  )

(defun-debug add-debug-cspace ((enable symbol) (bucket bucket-id) (csp cspace))
  "Draw the cspace bone transformation matrix."
  (add-debug-matrix enable bucket (-> csp bone transform) (meters 2.0))
  csp
  )

(defun-debug add-debug-yrot-vector ((enable symbol) (bucket bucket-id) (position vector) (angle float) (line-length float) (color rgba))
  "From the given position, draw a vector along the xz plane with the given angle around the Y-axis."
  (local-vars (var-angle float))
  (set! var-angle angle)
  (let ((var-line-length line-length)
        (var-color color)
        )
    (if (not enable)
        (return #f)
        )
    (let ((line-start (new-stack-vector0)))
      (set-vector!
        line-start
        (+ (-> position x) (* (sin var-angle) var-line-length))
        (-> position y)
        (+ (-> position z) (* (cos var-angle) var-line-length))
        1.0
        )
      (add-debug-line enable bucket line-start position var-color #f (the-as rgba -1))
      )
    )
  #f
  )

(defun-debug add-debug-arc ((enable symbol)
                  (bucket bucket-id)
                  (position vector)
                  (start-angle float)
                  (end-angle float)
                  (radius float)
                  (color rgba)
                  (orientation matrix)
                  )
  "Draw an arc with the given start and end angle. orientation may be #f, which defaults to drawing along the xz plane."
  (local-vars (line-start vector) (line-end vector) (i int) (sv-96 vector) (sv-112 vector))
  (if (not enable)
      (return #f)
      )
  (let ((angle start-angle))
    (set! line-start (new 'stack-no-clear 'vector))
    (set! (-> line-start quad) (the-as uint128 0))
    (set! line-end (new 'stack-no-clear 'vector))
    (set! (-> line-end quad) (the-as uint128 0))
    (set! i 0)
    (while (< i 12)
      (set! sv-96 line-start)
      (set! (-> sv-96 x) (* radius (sin angle)))
      (set! (-> sv-96 y) 0.0)
      (set! (-> sv-96 z) (* radius (cos angle)))
      (set! (-> sv-96 w) 1.0)
      (+! angle (the float (/ (the int (- end-angle start-angle)) 12)))
      (set! sv-112 line-end)
      (set! (-> sv-112 x) (* radius (sin angle)))
      (set! (-> sv-112 y) 0.0)
      (set! (-> sv-112 z) (* radius (cos angle)))
      (set! (-> sv-112 w) 1.0)
      (when orientation
        (vector-matrix*! line-start line-start orientation)
        (vector-matrix*! line-end line-end orientation)
        )
      (vector+! line-start line-start position)
      (vector+! line-end line-end position)
      (add-debug-line #t bucket line-start line-end color #f (the-as rgba -1))
      (cond
        ((zero? i)
         (add-debug-line #t bucket line-start position color #f (the-as rgba -1))
         )
        ((= i 11)
         (add-debug-line #t bucket line-end position color #f (the-as rgba -1))
         )
        )
      (set! i (+ i 1))
      )
    )
  #f
  )

(defun-debug add-debug-curve ((enable symbol)
                    (bucket bucket-id)
                    (cverts (inline-array vector))
                    (num-cverts int)
                    (knots (pointer float))
                    (num-knots int)
                    (color rgba)
                    )
  "Draw a curve as a series of lines."
  (local-vars (p1 vector) (iterations int) (i int))
  (if (not enable)
      (return #f)
      )
  (let ((p0 (new-stack-vector0)))
    (set! p1 (new 'stack-no-clear 'vector))
    (set! (-> p1 quad) (the-as uint128 0))
    (set! iterations (* num-cverts 4))
    (curve-evaluate! p1 (-> knots 0) cverts num-cverts knots num-knots)
    (set! i 0)
    (while (< i iterations)
      (set! (-> p0 quad) (-> p1 quad))
      (curve-evaluate! p1 (/ (the float (+ i 1)) (the float iterations)) cverts num-cverts knots num-knots)
      (add-debug-line #t bucket p0 p1 color #f (the-as rgba -1))
      (set! i (+ i 1))
      )
    )
  #f
  )

(defun-debug add-debug-curve2 ((enable symbol) (bucket bucket-id) (curve curve) (color rgba) (arg4 symbol))
  "Draw a curve as a series of lines."
  (if enable
      (add-debug-curve
        #t
        bucket
        (-> curve cverts)
        (-> curve num-cverts)
        (-> curve knots)
        (-> curve num-knots)
        color
        )
      )
  #f
  )

(defun-debug add-debug-points ((enable symbol)
                     (bucket bucket-id)
                     (points (inline-array vector))
                     (num-points int)
                     (color rgba)
                     (y-override float)
                     (highlight int)
                     )
  "For each point, draw an X along the xz plane with the index of the point above it as text.
   If y-override is not 0.0, the Y-coordinate of each point will use its value instead.
   Specify highlight as the index of a point that should be drawn as a white X instead of using
   the given color."
  (local-vars (position vector))
  (when enable
    (dotimes (i num-points)
      (set! position (new 'stack-no-clear 'vector))
      (set! (-> position quad) (the-as uint128 0))
      (set! (-> position quad) (-> points i quad))
      (if (!= y-override 0.0)
          (set! (-> position y) y-override)
          )
      (format (clear *temp-string*) "~d" i)
      (add-debug-text-3d #t bucket *temp-string* position (the-as font-color 1) (the-as vector2h #f))
      (let ((a3-2 (if (= i highlight)
                      (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
                      color
                      )
                  )
            )
        (add-debug-x #t bucket position a3-2)
        )
      )
    )
  #f
  )

(defun-debug debug-percent-bar ((enable symbol) (bucket bucket-id) (x int) (y int) (percentage float) (color rgba) (width int) (height int))
  "Draw a rectangular percentage bar at the given location."
  (local-vars (sv-16 int) (sv-32 float))
  (set! sv-16 y)
  (set! sv-32 percentage)
  (let ((s2-0 color)
        (s1-0 width)
        (s3-0 height)
        )
    (if (not enable)
        (return #f)
        )
    (let* ((buf (-> *display* frames (-> *display* on-screen) debug-buf))
           (tag-start (-> buf base))
           )
      (draw-sprite2d-xy buf x sv-16 s1-0 s3-0 (new 'static 'rgba :a #x40))
      (draw-sprite2d-xy buf x (+ sv-16 2) (the int (* sv-32 (the float s1-0))) (+ s3-0 -4) s2-0)
      (let ((tag-end (-> buf base)))
        (let ((pkt (the-as dma-packet (-> buf base))))
          (set! (-> pkt dma) (new 'static 'dma-tag :id (dma-tag-id next)))
          (set! (-> pkt vif0) (new 'static 'vif-tag))
          (set! (-> pkt vif1) (new 'static 'vif-tag))
          (set! (-> buf base) (&+ (the-as pointer pkt) 16))
          )
        (dma-bucket-insert-tag
          (-> *display* frames (-> *display* on-screen) bucket-group)
          bucket
          tag-start
          (the-as (pointer dma-tag) tag-end)
          )
        )
      )
    )
  #f
  )

(defun-debug debug-pad-display ((pad cpad-info))
  "Call each frame to draw the history of stick 0 as a series of fading points."
  (let ((stick-history (new 'static 'inline-array vector 32
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         (new 'static 'vector)
                         )
                       )
        )
    (countdown (i 31)
      (let ((a0-3 (-> stick-history i quad)))
        (set! (-> stick-history (+ i 1) quad) a0-3)
        )
      )
    (set! (-> stick-history 0 x) (* (sin (-> pad stick0-dir)) (-> pad stick0-speed)))
    (set! (-> stick-history 0 y) (* (cos (-> pad stick0-dir)) (-> pad stick0-speed)))
    (dotimes (j 32)
      (let* ((buf (-> *display* frames (-> *display* on-screen) debug-buf))
             (tag-start (-> buf base))
             )
        (draw-sprite2d-xy
          buf
          (the int (* 120.0 (-> stick-history j x)))
          (the int (* 144.0 (-> stick-history j y)))
          10
          10
          (new 'static 'rgba :a #x80 :r (- 255 (* 7 j)))
          )
        (let ((tag-end (-> buf base)))
          (let ((pkt (the-as dma-packet (-> buf base))))
            (set! (-> pkt dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> pkt vif0) (new 'static 'vif-tag))
            (set! (-> pkt vif1) (new 'static 'vif-tag))
            (set! (-> buf base) (&+ (the-as pointer pkt) 16))
            )
          (dma-bucket-insert-tag
            (-> *display* frames (-> *display* on-screen) bucket-group)
            (bucket-id bucket-324)
            tag-start
            (the-as (pointer dma-tag) tag-end)
            )
          )
        )
      )
    )
  #f
  )

(defun-debug add-debug-light ((enable symbol) (bucket bucket-id) (light light) (position vector) (text string))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (if (not enable)
        (return #f)
        )
    (when (!= (-> light extra x) 0.0)
      (add-debug-vector
        enable
        bucket
        position
        (-> light direction)
        (meters 3.0)
        (new 'static 'rgba :r #xff :g #xff :b #xff :a #x80)
        )
      (let ((sphere-pos (new-stack-vector0)))
        (let ((v1-3 (-> light direction)))
          (let ((a0-3 (* 12288.0 (-> light extra x))))
            (.mov vf7 a0-3)
            )
          (.lvf vf5 (&-> v1-3 quad))
          )
        (.lvf vf4 (&-> position quad))
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.x.vf acc vf5 vf7 :mask #b111)
        (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
        (.svf (&-> sphere-pos quad) vf6)
        (let ((color-rgba (logior (logior (logior (shr (shl (the int (* 128.0 (-> light color w))) 56) 32)
                                                  (shr (shl (the int (* 128.0 (-> light color z))) 56) 40)
                                                  )
                                          (shr (shl (the int (* 128.0 (-> light color y))) 56) 48)
                                          )
                                  (shr (shl (the int (* 128.0 (-> light color x))) 56) 56)
                                  )
                          )
              )
          (format (clear *temp-string*) "~S ~,,2f" text (-> light extra x))
          (let ((t0-2 *temp-string*))
            (add-debug-text-sphere enable bucket sphere-pos (* 2048.0 (-> light extra x)) t0-2 (the-as rgba color-rgba))
            )
          )
        )
      )
    #f
    )
  )

(defun-debug add-debug-lights ((enable symbol) (bucket bucket-id) (lights (inline-array light)) (position vector))
  (if (not enable)
      (return #f)
      )
  (add-debug-light enable bucket (-> lights 0) position "dir0")
  (add-debug-light enable bucket (-> lights 1) position "dir1")
  (add-debug-light enable bucket (-> lights 2) position "dir2")
  (add-debug-light enable bucket (-> lights 3) position "ambi")
  #f
  )

(define-extern drawable-frag-count (function drawable int))
(defun-debug drawable-frag-count ((drbl drawable))
  (let ((count 0))
    (cond
      ((not drbl)
       )
      ((type? drbl drawable-group)
       (dotimes (i (-> (the-as drawable-group drbl) length))
         (+! count (drawable-frag-count (-> (the-as drawable-group drbl) data i)))
         )
       )
      (else
        (+! count 1)
        )
      )
    count
    )
  )

(defmethod inspect debug-vertex-stats ((obj debug-vertex-stats))
  (format #t "[~8x] ~A~%" obj (-> obj type))
  (format #t "~Tlength: ~D~%" (-> obj length))
  (format #t "~Tpos-count: ~D~%" (-> obj pos-count))
  (format #t "~Tdata[~D]: @ #x~X~%" (-> obj length) (-> obj vertex))
  (dotimes (s5-0 (-> obj length))
    (let ((s4-0 (-> obj vertex s5-0)))
      (format
        #t
        "  ~D : trans: ~D ~D ~D ~D"
        s5-0
        (-> s4-0 trans x)
        (-> s4-0 trans y)
        (-> s4-0 trans z)
        (-> s4-0 trans w)
        )
      (format #t "   st: ~D ~D~%" (-> s4-0 st x) (-> s4-0 st y))
      (format
        #t
        "       col: ~X   norm: ~D ~D ~D~%"
        (-> s4-0 color)
        (-> s4-0 normal x)
        (-> s4-0 normal y)
        (-> s4-0 normal z)
        )
      )
    )
  obj
  )

(defun-debug history-init ((history pos-history) (num-points int))
  (set! (-> history num-points) num-points)
  (set! (-> history points) (the-as (inline-array vector) #f))
  history
  )

(defun-debug history-draw-and-update ((history pos-history) (draw symbol) (pos vector))
  (if (and draw (not (-> history points)))
      (set! (-> history points) (the-as (inline-array vector) (malloc 'debug (* (-> history num-points) 16))))
      )
  (when (-> history points)
    (set! (-> history points (-> history h-first) quad) (-> pos quad))
    (+! (-> history h-first) 1)
    (when (>= (-> history h-first) (-> history num-points))
      (set! (-> history h-first) 0)
      0
      )
    )
  (when draw
    (dotimes (i (+ (-> history num-points) -1))
      (if (!= (+ i 1) (-> history h-first))
          (add-debug-line
            #t
            (bucket-id bucket-318)
            (-> history points i)
            (-> history points (+ i 1))
            (new 'static 'rgba :r #x80 :g #xc0 :b #x80 :a #x80)
            #f
            (the-as rgba -1)
            )
          )
      )
    )
  #f
  )


;;;;;;;;;;;;;;;;;;
;; Misc Debug
;;;;;;;;;;;;;;;;;;

(defun-debug dma-timeout-cam ()
  (let ((pos (new-stack-vector0))
        (rot (new-stack-matrix0))
        )
    (set! (-> pos x) -666764.4)
    (set! (-> pos y) 21102.984)
    (set! (-> pos z) 51613.348)
    (set! (-> pos w) 1.0)
    (set! (-> rot vector 0 x) -0.911)
    (set! (-> rot vector 0 y) 0.0)
    (set! (-> rot vector 0 z) 0.4122)
    (set! (-> rot vector 0 w) 0.0)
    (set! (-> rot vector 1 x) -0.0984)
    (set! (-> rot vector 1 y) 0.971)
    (set! (-> rot vector 1 z) -0.2174)
    (set! (-> rot vector 1 w) 0.0)
    (set! (-> rot vector 2 x) -0.4003)
    (set! (-> rot vector 2 y) -0.2387)
    (set! (-> rot vector 2 z) -0.8847)
    (set! (-> rot vector 2 w) 0.0)
    (set! (-> rot trans x) 0.0)
    (set! (-> rot trans y) 0.0)
    (set! (-> rot trans z) 0.0)
    (set! (-> rot trans w) 1.0)
    (debug-set-camera-pos-rot! pos rot)
    )
  )

(defun-debug display-file-info ()
  (when (and *display-file-info* (!= *master-mode* 'menu))
    (dotimes (i (-> *level* length))
      (let ((level (-> *level* level i)))
        (when (= (-> level status) 'active)
          (let ((bsp (-> level bsp)))
            (format *stdcon* "file name: ~S~%" (-> bsp info file-name))
            (format *stdcon* "version: ~D.~D~%" (-> bsp info major-version) (-> bsp info minor-version))
            (format *stdcon* "maya file: ~S~%" (-> bsp info maya-file-name))
            (format *stdcon* "mdb file: ~S~%" (-> bsp info mdb-file-name))
            (format *stdcon* "~S" (-> bsp info tool-debug))
            )
          )
        )
      )
    )
  0
  )

(defun-debug add-debug-cursor ((enable symbol) (bucket bucket-id) (x int) (y int) (arg4 int))
  (when enable
    (let* ((buf (-> *display* frames (-> *display* on-screen) global-buf))
           (tag-start (-> buf base))
           )
      (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
      (let ((v1-7 arg4))
        (draw-string-xy
          "X"
          buf
          (+ x -5)
          (+ y -4)
          (cond
            ((= v1-7 1)
             (font-color precursor-#ec3b00)
             )
            ((= v1-7 2)
             (font-color yellow-#f3f300)
             )
            ((= v1-7 4)
             (font-color green-#3df23d)
             )
            (else
              (font-color default-#cddbcd)
              )
            )
          (font-flags shadow)
          )
        )
      (let ((tag-end (-> buf base)))
        (let ((pkt (the-as dma-packet (-> buf base))))
          (set! (-> pkt dma) (new 'static 'dma-tag :id (dma-tag-id next)))
          (set! (-> pkt vif0) (new 'static 'vif-tag))
          (set! (-> pkt vif1) (new 'static 'vif-tag))
          (set! (-> buf base) (&+ (the-as pointer pkt) 16))
          )
        (dma-bucket-insert-tag
          (-> *display* frames (-> *display* on-screen) bucket-group)
          bucket
          tag-start
          (the-as (pointer dma-tag) tag-end)
          )
        )
      )
    )
  0
  (none)
  )


;;;;;;;;;;;;;;;;;;
;; Boundary Debug
;;;;;;;;;;;;;;;;;;

;; TODO: missing a bunch of functions here

(define-extern init-boundary-regs (function none))

(defun-debug add-boundary-shader ((tex-id texture-id) (buf dma-buffer))
  (let ((tex (lookup-texture-by-id tex-id)))
    (when tex
      (let* ((v1-0 buf)
             (giftag (the-as gs-gif-tag (-> v1-0 base)))
             )
        (set! (-> giftag tag) (new 'static 'gif-tag64 :nloop #x1 :nreg #x5))
        (set! (-> giftag regs) (new 'static 'gif-tag-regs
                                 :regs0 (gif-reg-id a+d)
                                 :regs1 (gif-reg-id a+d)
                                 :regs2 (gif-reg-id a+d)
                                 :regs3 (gif-reg-id a+d)
                                 :regs4 (gif-reg-id a+d)
                                 )
              )
        (set! (-> v1-0 base) (&+ (the-as pointer giftag) 16))
        )
      (let ((shader (the-as adgif-shader (-> buf base))))
        (adgif-shader<-texture-simple! shader tex)
        (set! (-> shader alpha) (new 'static 'gs-alpha :b #x1 :d #x1))
        (set! (-> shader tex0 tfx) 0)
        (set! (-> shader tex1 mmag) 0)
        (set! (-> shader clamp) (new 'static 'gs-clamp))
        )
      0
      (&+! (-> buf base) 80)
      )
    )
  (none)
  )


;;;;;;;;;;;;;;;;;;
;; More Misc
;;;;;;;;;;;;;;;;;;

(define-extern cpu-delay (function int none))

(define-extern qword-read-time (function (array uint128) int int))

;; Returns whether some workaround for an EE memory controller bug is enabled.
(define-extern bugfix? (function symbol))
