;;-*-Lisp-*-
(in-package goal)

;; name: sky-tng.gc
;; name in dgo: sky-tng
;; dgos: ENGINE, GAME

#|@file
Sky renderer.
this render is much more complicated than the jak 1 version.
there's a lot of weird tricks to store values in the VF registers, and a lot of asm,
so a lot of this is in C++.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Large Polygon Renderer
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

there's a special "large polygon renderer" that handles clipping
and ps2-specific texture perspective stuff.
the way it subdivides is extremely strange, and not well understood, but it works well with the
Direct renderer in C++.
this renderer is also used for drawing debug regions and some parts of the ocean near the horizon.

there's a lot of state stored in vf registers, so we have to be very careful with this.

VF registers for large polygon
vf13: fog
vf14: hmge
vf23: 0?
vf24: texture offset (stored in xy, zw are 0),
vf25: hvdf-offset
vf26: inv-hmge
vf27: giftag
vf28: cam 3 (premultiplied by hmge)
vf29: cam 2 (premultiplied by hmge)
vf30: cam 1 (premultiplied by hmge)
vf31: cam 0 (premultiplied by hmge)
|#

;; TODO: cloud drawing is disabled.

;; DECOMP BEGINS

;; set the xy component of vf24 (texture offset for large poly renderer) to values / 65,536
(def-mips2c set-tex-offset (function int int none))

;; added function to sneak a value into vf23.
;; the use of this value is unknown
(def-mips2c set-sky-vf23-value (function int none))

;; there's also a set-sky-vf27 already defined that lets us set the vf27 used by sky C++ code.

;; draw-large-polygon is not called from GOAL directly, but it does clipping/dma generation for large polygons.

;; clip-polygon-against-positive-hyperplane and clip-polygon-against-negative-hyperplane are both
;; helpers called by draw-large-polygon

;; these two functions are the interface between the sky and large polygon renderer: these set up inputs to
;; draw-large-polygon and call it, sending data to the given dma-buffer.
;; these require vf registers to be set up.
(def-mips2c render-sky-quad (function (inline-array sky-vertex) dma-buffer none))
(def-mips2c render-sky-tri (function (inline-array sky-vertex) dma-buffer none))

(defun close-sky-buffer ((arg0 dma-buffer))
  "Terminate dma from large polygon renderer. This should be called after the last
   call to render-sky-tri/quad."
  (nop!)
  (let ((v1-0 #x8000)
        (v0-0 (-> arg0 base))
        )
    (set! (-> (the-as (pointer uint128) v0-0)) (the uint128 0))
    (nop!)
    (set! (-> (the-as (pointer int32) v0-0)) v1-0)
    (let ((v0-1 (&+ v0-0 16)))
      ;; to save like 1 instruction they put this in the delay slot of the jr-ra
      ;;(.jr ra-0)
      (set! (-> arg0 base) v0-1)
      )
    )
  (none)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sky Update
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod update-matrix sky-work ((obj sky-work) (arg0 matrix))
  "Update the projection matrix for sky drawing.
   The input matrix should not include perepctive.
   This function will apply the current math camera's perspective."
  (rlet ((vf0 :class vf))
    (init-vf0-vector)
    (let ((v1-0 (-> obj cam-mat)))
      (let* ((a0-1 v1-0)
             (t0-0 arg0)
             (a1-1 (-> t0-0 vector 0 quad))
             (a2-0 (-> t0-0 vector 1 quad))
             (a3-0 (-> t0-0 vector 2 quad))
             (t0-1 (-> t0-0 trans quad))
             )
        (set! (-> a0-1 vector 0 quad) a1-1)
        (set! (-> a0-1 vector 1 quad) a2-0)
        (set! (-> a0-1 vector 2 quad) a3-0)
        (set! (-> a0-1 trans quad) t0-1)
        )
      (.svf (&-> v1-0 trans quad) vf0)
      (matrix*! v1-0 v1-0 (-> *math-camera* perspective))
      )
    0
    (none)
    )
  )

(defmethod update-template-colors sky-work ((obj sky-work))
  "Update skybox colors from level/mood."
  (let ((v1-1 (-> *time-of-day-context* current-fog erase-color))
        (a0-2 (-> *level* default-level mood-context current-sky-color))
        )
    (dotimes (a1-0 12)
      (set! (-> sky-base-polygons a1-0 col quad) (-> v1-1 quad))
      (set! (-> sky-roof-polygons a1-0 col quad) (-> a0-2 quad))
      )
    )
  0
  (none)
  )

(defmethod update-time-and-speed sky-work ((obj sky-work) (arg0 float) (arg1 float))
  "Update based on the given time. Time is used to place suns/moon at the right spot, speed is used to scroll clouds."
  (if (and (level-get-target-inside *level*) (= (-> (level-get-target-inside *level*) info taskname) 'nest))
      (set! arg1 (* 10.0 arg1))
      )
  (sky-make-sun-data obj 0 arg0)
  (sky-make-sun-data obj 1 arg0)
  (sky-make-moon-data obj arg0)
  (+! (-> obj off-s) (the int (* -8.0 arg1)))
  (+! (-> obj off-t) (the int (* 2.0 arg1)))
  (set! (-> obj time) arg0)
  0
  (none)
  )

;; method 16
;; init-regs-for-boundary-draw
;;  set up vf registers for drawing large polygons
; (defmethod init-regs-for-large-polygon-draw sky-work ((obj sky-work))
;   (local-vars (v1-1 float))
;   (rlet ((vf0 :class vf)
;          (vf13 :class vf)
;          (vf14 :class vf)
;          (vf23 :class vf)
;          (vf24 :class vf)
;          (vf25 :class vf)
;          (vf26 :class vf)
;          (vf28 :class vf)
;          (vf29 :class vf)
;          (vf30 :class vf)
;          (vf31 :class vf)
;          )
;     (init-vf0-vector)
;     (let ((v1-0 *math-camera*)
;           (a1-0 (new-stack-vector0))
;           )
;       (let ((a2-0 (-> obj cam-mat)))
;         (set! (-> a1-0 quad) (-> v1-0 hvdf-off quad))
          ;; interestingly, they cheat the height of the sky by 1, possibly to avoid a "gap"
          ;; on the horizon. (but they use the wrong position if it's using other camera)
;         (if (< 0.0 (-> v1-0 trans y))
;             (set! (-> a1-0 y) 2049.0)
;             (set! (-> a1-0 y) 2047.0)
;             )
;         (set-vector! (-> obj fog) (-> v1-0 pfog0) (-> v1-0 fog-min) (-> v1-0 fog-max) 3071.0)
;         (.lvf vf31 (&-> a2-0 vector 0 quad))
;         (.lvf vf30 (&-> a2-0 vector 1 quad))
;         (.lvf vf29 (&-> a2-0 vector 2 quad))
;         (.lvf vf28 (&-> a2-0 trans quad))
;         )
;       (.lvf vf14 (&-> v1-0 hmge-scale quad))
;       (.lvf vf26 (&-> v1-0 inv-hmge-scale quad))
;       (.lvf vf25 (&-> a1-0 quad))
;       )
;     (.lvf vf13 (&-> obj fog quad))
;     (.mul.vf vf31 vf31 vf14)
;     (.mul.vf vf30 vf30 vf14)
;     (.mul.vf vf29 vf29 vf14)
;     (.mul.vf vf28 vf28 vf14)
;     (.mov.vf vf25 vf0 :mask #b100)
;     (.mov.vf vf24 vf0)
;     (.mov.vf vf23 vf0)
;     (.mov v1-1 vf23)
;     0
;     (none)
;     )
;   )
(defmethod-mips2c "(method 16 sky-work)" 16 sky-work)


;; very similar to the above, but sets things up for other sky asm stuff (not large-polygon)
;; VF registers for sky
;; vf13: fog
;; vf14: hmge
;; vf23: 0?
;; vf25: hvdf-offset (no off-by-one hack applied)
;; vf26: some weird scale thing in w.
;; vf28: cam 3
;; vf29: cam 2
;; vf30: cam 1
;; vf31: cam 0

; (defmethod init-regs-for-sky-asm sky-work ((obj sky-work))
;   (local-vars (v1-2 float))
;   (rlet ((vf0 :class vf)
;          (vf13 :class vf)
;          (vf14 :class vf)
;          (vf23 :class vf)
;          (vf25 :class vf)
;          (vf26 :class vf)
;          (vf28 :class vf)
;          (vf29 :class vf)
;          (vf30 :class vf)
;          (vf31 :class vf)
;          )
;     (init-vf0-vector)
;     (let ((a1-0 *math-camera*))
;       (let ((v1-0 (-> obj cam-mat)))
;         (.lvf vf31 (&-> v1-0 vector 0 quad))
;         (.lvf vf30 (&-> v1-0 vector 1 quad))
;         (.lvf vf29 (&-> v1-0 vector 2 quad))
;         (.lvf vf28 (&-> v1-0 trans quad))
;         )
;       (.lvf vf14 (&-> a1-0 hmge-scale quad))
;       (.lvf vf25 (&-> a1-0 hvdf-off quad))
;       (.lvf vf13 (&-> obj fog quad))
;       (.mov.vf vf25 vf0 :mask #b100)
;       (.mov.vf vf23 vf0)
;       (let ((v1-1 (new-stack-vector0)))
;         (set! (-> v1-1 w) (fmin 1.0 (/ 11650.845 (-> a1-0 fov))))
;         (.lvf vf26 (&-> v1-1 quad))
;         )
;       )
;     (.mov v1-2 vf26)
;     0
;     (none)
;     )
;   )
(defmethod-mips2c "(method 17 sky-work)" 17 sky-work)


(defmethod update-colors-for-time sky-work ((obj sky-work) (arg0 float))
  "Update sky colors for the given time."
  0
  0
  0.0
  (let ((s5-0 *no-cloud-mood-color-table*))
    (let ((s3-0 (-> *level* default-level mood-context))
          (s4-0 (new 'stack-no-clear 'vector))
          )
      (let* ((v1-3 (the int arg0))
             (f0-4 (- arg0 (the float v1-3)))
             (f1-3 (- 1.0 f0-4))
             (a0-3 (/ v1-3 24))
             (a1-2 (-> *mood-interp-table* hour (- v1-3 (* 24 a0-3))))
             (a0-6 (-> a1-2 snapshot1))
             (v1-7 (-> a1-2 snapshot2))
             (f0-6 (+ (* f1-3 (-> a1-2 morph-start)) (* f0-4 (-> a1-2 morph-end))))
             )
        (cond
          ((= a0-6 v1-7)
           (set! (-> obj sun0-color quad) (-> s5-0 data a0-6 lgt-color quad))
           )
          (else
            (let ((a1-5 (-> s5-0 data a0-6))
                  (v1-11 (-> s5-0 data v1-7))
                  )
              (vector4-lerp! (the-as vector (-> obj sun0-color)) (-> a1-5 lgt-color) (-> v1-11 lgt-color) f0-6)
              )
            )
          )
        )
      (set! (-> obj sun0-color-lower quad) (-> s3-0 times 1 quad))
      (set! (-> obj ambi-color-lower quad) (-> s3-0 times 0 quad))
      (set-vector! s4-0 1.9921875 1.9921875 1.9921875 1.0)
      (vector4-lerp!
        (the-as vector (-> obj ambi-color))
        (the-as vector (-> obj ambi-color-lower))
        s4-0
        (-> *mood-control* lightning-flash)
        )
      )
    (set! (-> obj sun0-color quad) (-> obj sun0-color quad))
    (set! (-> obj sun1-color quad) (-> s5-0 data 7 lgt-color quad))
    (set! (-> obj moon-color quad) (-> s5-0 data 6 lgt-color quad))
    )
  0
  (none)
  )

(defmethod cloud-vtx-light-update sky-work ((obj sky-work) (arg0 vector) (arg1 vector) (arg2 cloud-lights) (arg3 vector) (arg4 vector))
  "Update lighting for cloud mesh vertex."
  (let ((s5-0 (new 'stack-no-clear 'vector4)))
    (let* ((f0-1 (vector-dot (-> arg2 sun0-normal) arg1))
           (f1-1 (vector-dot (-> arg2 sun1-normal) arg1))
           (f2-1 (vector-dot (-> arg2 moon-normal) arg1))
           (f0-2 (fmax 0.0 f0-1))
           (f30-0 (fmax 0.0 f1-1))
           (f28-0 (fmax 0.0 f2-1))
           )
      (set! (-> s5-0 quad) (-> arg4 quad))
      (vector4-madd! s5-0 s5-0 (the-as vector4 arg3) f0-2)
      (vector4-madd! s5-0 s5-0 (the-as vector4 (-> arg2 sun1-color)) f30-0)
      (vector4-madd! s5-0 s5-0 (the-as vector4 (-> arg2 moon-color)) f28-0)
      )
    (vector4-scale! s5-0 s5-0 128.0)
    (set! (-> arg0 x) (fmax 0.0 (fmin 255.0 (-> s5-0 x))))
    (set! (-> arg0 y) (fmax 0.0 (fmin 255.0 (-> s5-0 y))))
    (set! (-> arg0 z) (fmax 0.0 (fmin 255.0 (-> s5-0 z))))
    )
  0
  (none)
  )

(defmethod cloud-vtx-tex-update sky-work ((obj sky-work) (arg0 vector) (arg1 vector) (arg2 vector) (arg3 cloud-lights))
  "Update texture stq for cloud mesh vertex."
  (let ((s5-0 (new 'stack-no-clear 'vector4))
        (s2-0 (new 'stack-no-clear 'vector4))
        (s4-0 (new 'stack-no-clear 'vector4))
        (f28-0 0.00390625)
        (f30-0 0.015625)
        )
    (set! (-> arg0 quad) (-> arg1 quad))
    (vector--float*! (the-as vector s5-0) arg2 (-> arg3 sun0-normal) 9.0)
    (vector--float*! (the-as vector s2-0) arg2 (-> arg3 sun1-normal) 9.0)
    (vector--float*! (the-as vector s4-0) arg2 (-> arg3 moon-normal) 9.0)
    (vector4-scale! s5-0 s5-0 (* (-> arg3 sun0-scale) f28-0))
    (vector4-madd! s5-0 s5-0 s2-0 (* 0.25 f28-0 (-> arg3 sun1-scale)))
    (vector4-madd! s5-0 s5-0 s4-0 (* (-> arg3 moon-scale) f28-0))
    (+! (-> arg0 x) (fmax (fmin (-> s5-0 x) f30-0) (- f30-0)))
    (+! (-> arg0 y) (fmax (fmin (-> s5-0 z) f30-0) (- f30-0)))
    )
  0
  (none)
  )

(defmethod adjust-cloud-lighting sky-work ((obj sky-work))
  "Apply lighting to cloud vertices"
  (let ((s5-0 *cloud-vert-array*)
        (s4-0 (-> obj cloud-lights))
        )
    (set! (-> s4-0 sun0-normal quad) (-> obj upload-data sun 0 pos quad))
    (set! (-> s4-0 sun1-normal quad) (-> obj upload-data sun 1 pos quad))
    (set! (-> s4-0 moon-normal quad) (-> obj upload-data moon pos quad))
    (vector-normalize! (-> s4-0 sun0-normal) 1.0)
    (vector-normalize! (-> s4-0 sun1-normal) 1.0)
    (vector-normalize! (-> s4-0 moon-normal) 1.0)
    (set! (-> s4-0 sun0-scale) (fmax 0.0 (fmin 1.0 (* 8.0 (+ 0.125 (-> s4-0 sun0-normal y))))))
    (set! (-> s4-0 sun1-scale) (fmax 0.0 (fmin 1.0 (* 8.0 (+ 0.125 (-> s4-0 sun1-normal y))))))
    (set! (-> s4-0 moon-scale) (fmax 0.0 (fmin 1.0 (* 8.0 (+ 0.125 (-> s4-0 moon-normal y))))))
    (let ((s1-0 (-> s4-0 ambi-color))
          (s2-0 (-> s4-0 ambi-color-lower))
          (s3-0 (-> obj sun0-color-lower))
          )
      (let ((f30-0 (- 1.0 (fmax 0.0 (fmin 0.75 (* 4.0 (-> s4-0 moon-normal y))))))
            (f28-0 (* 0.3333 (fmax 0.0 (fmin 1.0 (+ -1.0 (* 8.0 (-> s4-0 sun0-normal y)))))))
            )
        (vector4-scale! (the-as vector4 s2-0) (the-as vector4 (-> obj ambi-color-lower)) f30-0)
        (vector4-madd! (the-as vector4 s2-0) (the-as vector4 s2-0) (the-as vector4 s3-0) f28-0)
        (vector4-scale! (the-as vector4 s1-0) (the-as vector4 (-> obj ambi-color)) f30-0)
        (vector4-madd! (the-as vector4 s1-0) (the-as vector4 s1-0) (the-as vector4 s3-0) f28-0)
        )
      (vector4-scale!
        (the-as vector4 (-> s4-0 sun0-color))
        (the-as vector4 (-> obj sun0-color))
        (-> s4-0 sun0-scale)
        )
      (vector4-scale!
        (the-as vector4 (-> s4-0 sun1-color))
        (the-as vector4 (-> obj sun1-color))
        (* 0.5 (-> s4-0 sun1-scale))
        )
      (vector4-scale!
        (the-as vector4 (-> s4-0 moon-color))
        (the-as vector4 (-> obj moon-color))
        (-> s4-0 moon-scale)
        )
      (vector4-scale! (the-as vector4 (-> s4-0 sun0-color-lower)) (the-as vector4 s3-0) (-> s4-0 sun0-scale))
      )
    (dotimes (s3-1 100)
      (let ((s2-1 (-> s5-0 data s3-1)))
        (cloud-vtx-light-update obj (-> s2-1 col) (-> s2-1 nrm) s4-0 (-> s4-0 sun0-color) (-> s4-0 ambi-color))
        (cloud-vtx-light-update
          obj
          (-> s2-1 col2)
          (-> s2-1 nrm2)
          s4-0
          (-> s4-0 sun0-color-lower)
          (-> s4-0 ambi-color-lower)
          )
        (cloud-vtx-tex-update obj (-> s2-1 stq2) (-> s2-1 stq) (-> s2-1 pos) s4-0)
        )
      )
    )
  0
  (none)
  )

(defmethod cloud-vtx1-to-sky sky-work ((obj sky-work) (arg0 sky-vertex) (arg1 cloud-vertex))
  "Convert a cloud vertex to a sky vertex, using the 'normal' stq/col"
  (set! (-> arg0 pos quad) (-> arg1 pos quad))
  (set! (-> arg0 stq quad) (-> arg1 stq quad))
  (set! (-> arg0 col quad) (-> arg1 col quad))
  (none)
  )

(defmethod cloud-vtx2-to-sky sky-work ((obj sky-work) (arg0 sky-vertex) (arg1 cloud-vertex))
  "Convert a cloud vertex to a sky vertex, using the '2' stq/col"
  (set! (-> arg0 pos quad) (-> arg1 pos quad))
  (set! (-> arg0 stq quad) (-> arg1 stq2 quad))
  (set! (-> arg0 col quad) (-> arg1 col2 quad))
  (none)
  )

(defmethod draw-clouds sky-work ((obj sky-work) (arg0 dma-buffer))
  "Draw the cloud layer using large polygon renderer
   Assumes that init-regs-for-large-polygon-draw was already called."
  (local-vars (v1-19 float) (sv-16 cloud-vert-array) (sv-20 (inline-array sky-vertex)) (sv-32 int))
  (rlet ((vf23 :class vf)
         (vf27 :class vf)
         )

    ;; set up for sky DMA:
    (let* ((v1-0 arg0)
           (a0-1 (the-as dma-packet (-> v1-0 base)))
           )
      (set! (-> a0-1 dma) (new 'static 'dma-tag :qwc #x7 :id (dma-tag-id cnt)))
      (set! (-> a0-1 vif0) (new 'static 'vif-tag))
      (set! (-> a0-1 vif1) (new 'static 'vif-tag :imm #x7 :cmd (vif-cmd direct) :msk #x1))
      (set! (-> v1-0 base) (the-as pointer (&+ a0-1 16)))
      )
    (let* ((v1-1 arg0)
           (a0-3 (the-as gs-gif-tag (-> v1-1 base)))
           )
      (set! (-> a0-3 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x6))
      (set! (-> a0-3 regs) GIF_REGS_ALL_AD)
      (set! (-> v1-1 base) (the-as pointer (&+ a0-3 16)))
      )
    (let* ((s4-0 arg0)
           (s3-0 (-> s4-0 base))
           )
      (set! (-> (the-as (pointer gs-test) s3-0) 0) (new 'static 'gs-test
                                                     :ate #x1
                                                     :atst (gs-atest greater-equal)
                                                     :aref #x50
                                                     :afail #x1
                                                     :zte #x1
                                                     :ztst (gs-ztest greater-equal)
                                                     )
            )
      (set! (-> (the-as (pointer gs-reg64) s3-0) 1) (gs-reg64 test-1))
      (set! (-> (the-as (pointer gs-tex0) s3-0) 2) (new 'static 'gs-tex0
                                                     :tbp0 #x100
                                                     :tbw #x2
                                                     :psm #x1b
                                                     :tcc #x1
                                                     :cbp #x300
                                                     :cld #x1
                                                     :th (log2 128)
                                                     :tw (log2 128)
                                                     )
            )
      (set! (-> (the-as (pointer gs-reg64) s3-0) 3) (gs-reg64 tex0-1))
      (set! (-> (the-as (pointer gs-tex1) s3-0) 4) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
      (set! (-> (the-as (pointer gs-reg64) s3-0) 5) (gs-reg64 tex1-1))
      (set! (-> (the-as (pointer gs-clamp) s3-0) 6) (new 'static 'gs-clamp))
      (set! (-> (the-as (pointer gs-reg64) s3-0) 7) (gs-reg64 clamp-1))
      (set! (-> (the-as (pointer gs-alpha) s3-0) 8) (new 'static 'gs-alpha :b #x1 :d #x1))
      (set! (-> (the-as (pointer gs-reg64) s3-0) 9) (gs-reg64 alpha-1))
      (set! (-> (the-as (pointer uint64) s3-0) 10) (the-as uint 0))
      (set! (-> (the-as (pointer gs-reg64) s3-0) 11) (gs-reg64 texflush))
      (set! (-> s4-0 base) (&+ s3-0 96))
      )

    ;; set regs for large polygon renderer
    ;(init-regs-for-large-polygon-draw obj) ;; hack hack hack hack hack!
    ;;(.lvf vf27 (&-> obj giftag-roof quad))
    (set-sky-vf27 (&-> obj giftag-roof quad))
    (set-sky-vf23-value #x43c80000)
    ; (let ((v1-18 #x43c80000))
    ;   (.mov vf23 v1-18)
    ;   )
    ;(.mov v1-19 vf23)
    (set-tex-offset (the-as int (-> obj off-s)) (the-as int (-> obj off-t)))

    ;; convert cloud vertices to sky.
    (let ((s4-1 (the-as object (-> arg0 base))))
      (&+! (-> arg0 base) 16)
      (set! sv-16 *cloud-vert-array*)
      (set! sv-20 *cloud-poly*)
      (dotimes (s3-1 9)
        (dotimes (s2-2 9)
          (let ((s1-0 (+ (* 10 s3-1) s2-2)))
            (set! sv-32 (+ (* 9 s3-1) s2-2))
            (let ((s0-0 (+ s2-2 81 (* 9 s3-1))))
              (cloud-vtx1-to-sky obj (-> sv-20 (* sv-32 4)) (-> sv-16 data s1-0))
              (cloud-vtx1-to-sky obj (-> sv-20 (+ (* sv-32 4) 1)) (-> sv-16 data (+ s1-0 1)))
              (cloud-vtx1-to-sky obj (-> sv-20 (+ (* sv-32 4) 2)) (-> sv-16 data (+ s1-0 11)))
              (cloud-vtx1-to-sky obj (-> sv-20 (+ (* sv-32 4) 3)) (-> sv-16 data (+ s1-0 10)))
              (cloud-vtx2-to-sky obj (-> sv-20 (* s0-0 4)) (-> sv-16 data s1-0))
              (cloud-vtx2-to-sky obj (-> sv-20 (+ (* s0-0 4) 1)) (-> sv-16 data (+ s1-0 1)))
              (cloud-vtx2-to-sky obj (-> sv-20 (+ (* s0-0 4) 2)) (-> sv-16 data (+ s1-0 11)))
              (cloud-vtx2-to-sky obj (-> sv-20 (+ (* s0-0 4) 3)) (-> sv-16 data (+ s1-0 10)))
              )
            )
          )
        )
      ;; do large polygon rendering!
      (dotimes (s5-1 162)
        (render-sky-quad (the-as (inline-array sky-vertex) (-> sv-20 (* s5-1 4))) arg0)
        )
      ;; finish.
      (close-sky-buffer arg0)
      (let ((v1-81 (/ (the-as int (+ (- -16 (the-as int s4-1)) (the-as int (-> arg0 base)))) 16)))
        (set! (-> (the-as dma-packet s4-1) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc v1-81))
        (set! (-> (the-as dma-packet s4-1) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet s4-1) vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1 :imm v1-81))
        )
      )
    0
    (none)
    )
  )

(defmethod apply-haze-light sky-work ((obj sky-work) (arg0 vector) (arg1 vector) (arg2 haze-lights))
  "Apply haze lights to a vertex."
  (let ((s5-0 (new 'stack-no-clear 'vector4)))
    (let* ((f0-1 (vector-dot (-> arg2 sun0-normal) arg1))
           (f1-1 (vector-dot (-> arg2 sun1-normal) arg1))
           (f2-1 (vector-dot (-> arg2 moon-normal) arg1))
           (f0-2 (fmax 0.0 f0-1))
           (f30-0 (fmax 0.0 f1-1))
           (f28-0 (fmax 0.0 f2-1))
           )
      (set! (-> s5-0 quad) (-> arg2 ambi-color quad))
      (vector4-madd! s5-0 s5-0 (the-as vector4 (-> arg2 sun0-color)) f0-2)
      (vector4-madd! s5-0 s5-0 (the-as vector4 (-> arg2 sun1-color)) f30-0)
      (vector4-madd! s5-0 s5-0 (the-as vector4 (-> arg2 moon-color)) f28-0)
      )
    (vector4-scale! s5-0 s5-0 128.0)
    (set! (-> arg0 x) (fmax 0.0 (fmin 255.0 (-> s5-0 x))))
    (set! (-> arg0 y) (fmax 0.0 (fmin 255.0 (-> s5-0 y))))
    (set! (-> arg0 z) (fmax 0.0 (fmin 255.0 (-> s5-0 z))))
    )
  0
  (none)
  )

(defmethod adjust-haze-lighting sky-work ((obj sky-work))
  "Adjust lighting for haze."
  (let ((s5-0 *haze-vert-array*)
        (s4-0 (-> obj haze-lights))
        )
    (set! (-> s4-0 sun0-normal quad) (-> obj upload-data sun 0 pos quad))
    (set! (-> s4-0 sun1-normal quad) (-> obj upload-data sun 1 pos quad))
    (set! (-> s4-0 moon-normal quad) (-> obj upload-data moon pos quad))
    (vector-normalize! (-> s4-0 sun0-normal) 1.0)
    (vector-normalize! (-> s4-0 sun1-normal) 1.0)
    (vector-normalize! (-> s4-0 moon-normal) 1.0)
    (set! (-> s4-0 sun0-scale) (fmax 0.0 (fmin 1.0 (* 8.0 (+ 0.125 (-> s4-0 sun0-normal y))))))
    (set! (-> s4-0 sun1-scale) (fmax 0.0 (fmin 1.0 (* 8.0 (+ 0.125 (-> s4-0 sun1-normal y))))))
    (set! (-> s4-0 moon-scale) (fmax 0.0 (fmin 1.0 (* 8.0 (+ 0.125 (-> s4-0 moon-normal y))))))
    (let ((a0-10 (-> s4-0 ambi-color)))
      (-> obj sun0-color-lower)
      (let ((f0-7 (- 1.0 (fmax 0.0 (fmin 0.75 (* 4.0 (-> s4-0 moon-normal y)))))))
        (* 0.3333 (fmax 0.0 (fmin 1.0 (+ -1.0 (* 8.0 (-> s4-0 sun0-normal y))))))
        (vector4-scale! (the-as vector4 a0-10) (the-as vector4 (-> obj ambi-color)) f0-7)
        )
      )
    (vector4-scale!
      (the-as vector4 (-> s4-0 sun0-color))
      (the-as vector4 (-> obj sun0-color))
      (-> s4-0 sun0-scale)
      )
    (vector4-scale!
      (the-as vector4 (-> s4-0 sun1-color))
      (the-as vector4 (-> obj sun1-color))
      (* 0.5 (-> s4-0 sun1-scale))
      )
    (vector4-scale!
      (the-as vector4 (-> s4-0 moon-color))
      (the-as vector4 (-> obj moon-color))
      (-> s4-0 moon-scale)
      )
    (dotimes (s3-0 36)
      (let ((v1-25 (-> s5-0 data s3-0)))
        (apply-haze-light obj (-> v1-25 col) (-> v1-25 nrm) s4-0)
        )
      )
    )
  0
  (none)
  )

(defmethod haze-vtx-to-sky sky-work ((obj sky-work) (arg0 sky-vertex) (arg1 sky-vertex) (arg2 haze-vertex))
  "Convert haze vertex to sky format."
  (set! (-> arg0 pos quad) (-> arg2 pos quad))
  (set! (-> arg0 col quad) (-> arg2 col quad))
  (set! (-> arg0 col w) 128.0)
  (set! (-> arg1 pos quad) (-> arg2 pos quad))
  (set! (-> arg1 col quad) (-> arg2 col quad))
  (set! (-> arg1 pos y) 3.0)
  (set! (-> arg1 col w) 0.0)
  0
  (none)
  )

(defmethod draw-haze sky-work ((obj sky-work) (arg0 dma-buffer))
  "Draw haze using large polygon renderer.
   Calls init-regs-for-large-polygon-draw."
  (local-vars (sv-16 haze-vert-array) (sv-20 (inline-array sky-vertex)))

  ;; set up dma
  (rlet ((vf27 :class vf))
    (let* ((v1-0 arg0)
           (a0-1 (the-as object (-> v1-0 base)))
           )
      (set! (-> (the-as dma-packet a0-1) dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
      (set! (-> (the-as dma-packet a0-1) vif0) (new 'static 'vif-tag))
      (set! (-> (the-as dma-packet a0-1) vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
      (set! (-> v1-0 base) (the-as pointer (&+ (the-as dma-packet a0-1) 16)))
      )
    (let* ((v1-1 arg0)
           (a0-3 (the-as object (-> v1-1 base)))
           )
      (set! (-> (the-as gs-gif-tag a0-3) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
      (set! (-> (the-as gs-gif-tag a0-3) regs) GIF_REGS_ALL_AD)
      (set! (-> v1-1 base) (&+ (the-as pointer a0-3) 16))
      )
    (let* ((v1-2 arg0)
           (a0-5 (-> v1-2 base))
           )
      (set! (-> (the-as (pointer gs-alpha) a0-5) 0) (new 'static 'gs-alpha :b #x1 :d #x1))
      (set! (-> (the-as (pointer gs-reg64) a0-5) 1) (gs-reg64 alpha-1))
      (set! (-> v1-2 base) (&+ a0-5 16))
      )
    ;; set up polygon regs
    (init-regs-for-large-polygon-draw obj)
    ;(.lvf vf27 (&-> obj giftag-haze quad))
    (set-sky-vf27 (&-> obj giftag-haze quad))

    ;; convert to sky format
    (let ((s4-0 (the-as object (-> arg0 base))))
      (&+! (-> arg0 base) 16)
      (set! sv-16 *haze-vert-array*)
      (set! sv-20 *haze-poly*)
      (dotimes (s3-0 35)
        (haze-vtx-to-sky obj (-> sv-20 (* s3-0 4)) (-> sv-20 (+ (* s3-0 4) 1)) (-> sv-16 data s3-0))
        (haze-vtx-to-sky obj (-> sv-20 (+ (* s3-0 4) 3)) (-> sv-20 (+ (* s3-0 4) 2)) (-> sv-16 data (+ s3-0 1)))
        )
      (haze-vtx-to-sky obj (-> sv-20 140) (-> sv-20 141) (-> sv-16 data 35))
      (haze-vtx-to-sky obj (-> sv-20 143) (-> sv-20 142) (the-as haze-vertex (-> sv-16 data)))
      ;; draw!
      (dotimes (s5-1 36)
        (render-sky-quad (the-as (inline-array sky-vertex) (-> sv-20 (* s5-1 4))) arg0)
        )
      ;; finish up.
      (close-sky-buffer arg0)
      (let ((v1-41 (/ (the-as int (+ (- -16 (the-as int s4-0)) (the-as int (-> arg0 base)))) 16)))
        (set! (-> (the-as dma-packet s4-0) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc v1-41))
        (set! (-> (the-as dma-packet s4-0) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet s4-0) vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1 :imm v1-41))
        )
      )
    0
    (none)
    )
  )

;; sky dma method:
;; generates dma for sun or moon (no large polygon)
;; assumes sky registers are set up (not polygon)
(defmethod-mips2c "(method 28 sky-work)" 28 sky-work) ;; first sun (normal)
(defmethod-mips2c "(method 29 sky-work)" 29 sky-work) ;; green sun
(defmethod-mips2c "(method 30 sky-work)" 30 sky-work) ;; moon

(defmethod setup-stars sky-work ((obj sky-work) (arg0 matrix) (arg1 sky-upload-data))
  "Prepare for star drawing."
  (set! (-> arg0 vector 2 quad) (-> arg1 sun 0 pos quad))
  (vector-normalize! (-> arg0 vector 2) 1.0)
  (vector-cross! (the-as vector (-> arg0 vector)) *z-vector* (-> arg0 vector 2))
  (vector-normalize! (the-as vector (-> arg0 vector)) 1.0)
  (vector-cross! (-> arg0 vector 1) (-> arg0 vector 2) (the-as vector (-> arg0 vector)))
  (vector-normalize! (-> arg0 vector 1) 1.0)
  (let ((s4-1 (new 'stack-no-clear 'vector)))
    (set! (-> s4-1 quad) (-> arg1 sun 0 pos quad))
    (vector-normalize! s4-1 -1.0)
    (let ((f0-1 (fmax 0.0 (fmin 1.0 (* 20.0 (+ 0.05 (-> s4-1 y)))))))
      (dotimes (v1-7 16)
        (let ((f1-4 (* (- 128.0 (* 8.0 (the float v1-7))) f0-1)))
          (set-vector! (-> obj star-colors v1-7) (the int f1-4) (the int f1-4) (the int f1-4) 128)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod-mips2c "(method 32 sky-work)" 32 sky-work) ;; stars transform
(defmethod-mips2c "(method 33 sky-work)" 33 sky-work) ;; stars dma

(defmethod draw-roof sky-work ((obj sky-work) (arg0 dma-buffer))
  "Draw the roof of the sky box. Uses large-polygon renderer."
  (rlet ((vf27 :class vf))
    ;; GS setup
    (let* ((v1-0 arg0)
           (a0-1 (the-as object (-> v1-0 base)))
           )
      (set! (-> (the-as dma-packet a0-1) dma) (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt)))
      (set! (-> (the-as dma-packet a0-1) vif0) (new 'static 'vif-tag))
      (set! (-> (the-as dma-packet a0-1) vif1) (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1))
      (set! (-> v1-0 base) (the-as pointer (&+ (the-as dma-packet a0-1) 16)))
      )
    (let* ((v1-1 arg0)
           (a0-3 (the-as object (-> v1-1 base)))
           )
      (set! (-> (the-as gs-gif-tag a0-3) tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x3))
      (set! (-> (the-as gs-gif-tag a0-3) regs) GIF_REGS_ALL_AD)
      (set! (-> v1-1 base) (&+ (the-as pointer a0-3) 16))
      )
    (let* ((v1-2 arg0)
           (a0-5 (-> v1-2 base))
           )
      (set! (-> (the-as (pointer gs-zbuf) a0-5) 0) (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24)))
      (set! (-> (the-as (pointer gs-reg64) a0-5) 1) (gs-reg64 zbuf-1))
      (set! (-> (the-as (pointer gs-test) a0-5) 2)
            (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always))
            )
      (set! (-> (the-as (pointer gs-reg64) a0-5) 3) (gs-reg64 test-1))
      (set! (-> (the-as (pointer gs-alpha) a0-5) 4) (new 'static 'gs-alpha :b #x1 :d #x1))
      (set! (-> (the-as (pointer gs-reg64) a0-5) 5) (gs-reg64 alpha-1))
      (set! (-> v1-2 base) (&+ a0-5 48))
      )
    ;; large polygon reg setup
    (init-regs-for-large-polygon-draw obj)
    ; (.lvf vf27 (&-> obj giftag-base quad))
    (set-sky-vf27 (&-> obj giftag-base quad))

    ;; draw!
    (let ((s5-1 (the-as object (-> arg0 base))))
      (&+! (-> arg0 base) 16)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-roof-polygons 0)) arg0)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-roof-polygons 3)) arg0)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-roof-polygons 6)) arg0)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-roof-polygons 9)) arg0)
      (close-sky-buffer arg0)
      (let ((v1-14 (/ (the-as int (+ (- -16 (the-as int s5-1)) (the-as int (-> arg0 base)))) 16)))
        (set! (-> (the-as dma-packet s5-1) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc v1-14))
        (set! (-> (the-as dma-packet s5-1) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet s5-1) vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1 :imm v1-14))
        )
      )
    0
    (none)
    )
  )

(defmethod draw-base sky-work ((obj sky-work) (arg0 dma-buffer))
  "Draw the base of the sky box. Uses large-polygon renderer."
  (rlet ((vf27 :class vf))
    (let* ((v1-0 arg0)
           (a1-1 (the-as dma-packet (-> v1-0 base)))
           )
      (set! (-> a1-1 dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
      (set! (-> a1-1 vif0) (new 'static 'vif-tag))
      (set! (-> a1-1 vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
      (set! (-> v1-0 base) (the-as pointer (&+ a1-1 16)))
      )
    (let* ((v1-1 arg0)
           (a1-3 (the-as gs-gif-tag (-> v1-1 base)))
           )
      (set! (-> a1-3 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
      (set! (-> a1-3 regs) GIF_REGS_ALL_AD)
      (set! (-> v1-1 base) (the-as pointer (&+ a1-3 16)))
      )
    (let* ((v1-2 arg0)
           (a1-5 (-> v1-2 base))
           )
      (set! (-> (the-as (pointer gs-test) a1-5) 0)
            (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always))
            )
      (set! (-> (the-as (pointer gs-reg64) a1-5) 1) (gs-reg64 test-1))
      (set! (-> v1-2 base) (&+ a1-5 16))
      )
    (let ((s5-0 (the-as object (-> arg0 base))))
      (&+! (-> arg0 base) 16)
      ;(.lvf vf27 (&-> obj giftag-base quad))
      (set-sky-vf27 (&-> obj giftag-base quad))
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-base-polygons 0)) arg0)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-base-polygons 3)) arg0)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-base-polygons 6)) arg0)
      (render-sky-tri (the-as (inline-array sky-vertex) (-> sky-base-polygons 9)) arg0)
      (close-sky-buffer arg0)
      (let ((v1-12 (/ (the-as int (+ (- -16 (the-as int s5-0)) (the-as int (-> arg0 base)))) 16)))
        (set! (-> (the-as dma-packet s5-0) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc v1-12))
        (set! (-> (the-as dma-packet s5-0) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet s5-0) vif1) (new 'static 'vif-tag :cmd (vif-cmd direct) :msk #x1 :imm v1-12))
        )
      )
    0
    (none)
    )
  )

(defmethod draw-fog sky-work ((obj sky-work) (arg0 dma-buffer))
  (let ((s4-0 (-> *sky-texture-anim-array* array-data 8 tex)))
    (when s4-0
      (let* ((v1-3 arg0)
             (a0-1 (the-as dma-packet (-> v1-3 base)))
             )
        (set! (-> a0-1 dma) (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt)))
        (set! (-> a0-1 vif0) (new 'static 'vif-tag))
        (set! (-> a0-1 vif1) (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1))
        (set! (-> v1-3 base) (the-as pointer (&+ a0-1 16)))
        )
      (let* ((v1-4 arg0)
             (a0-3 (the-as gs-gif-tag (-> v1-4 base)))
             )
        (set! (-> a0-3 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x5))
        (set! (-> a0-3 regs) GIF_REGS_ALL_AD)
        (set! (-> v1-4 base) (the-as pointer (the-as gs-gif-tag (&+ a0-3 16))))
        )
      (let* ((s3-0 arg0)
             (s2-0 (-> s3-0 base))
             )
        (set! (-> (the-as (pointer gs-tex0) s2-0) 0)
              (new 'static 'gs-tex0
                :tcc #x1
                :cld #x1
                :psm (the-as int (-> s4-0 psm))
                :cpsm (-> s4-0 clutpsm)
                :cbp (-> s4-0 clutdest)
                :th (log2 (-> s4-0 h))
                :tw (log2 (-> s4-0 w))
                :tbw (-> s4-0 width 0)
                :tbp0 (-> s4-0 dest 0)
                )
              )
        (set! (-> (the-as (pointer gs-reg64) s2-0) 1) (gs-reg64 tex0-1))
        (set! (-> (the-as (pointer gs-tex1) s2-0) 2) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
        (set! (-> (the-as (pointer gs-reg64) s2-0) 3) (gs-reg64 tex1-1))
        (set! (-> (the-as (pointer gs-test) s2-0) 4)
              (new 'static 'gs-test
                :ate #x1
                :atst (gs-atest greater-equal)
                :aref #x70
                :afail #x3
                :zte #x1
                :ztst (gs-ztest greater-equal)
                )
              )
        (set! (-> (the-as (pointer gs-reg64) s2-0) 5) (gs-reg64 test-1))
        (set! (-> (the-as (pointer gs-clamp) s2-0) 6)
              (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp))
              )
        (set! (-> (the-as (pointer gs-reg64) s2-0) 7) (gs-reg64 clamp-1))
        (set! (-> (the-as (pointer gs-alpha) s2-0) 8) (new 'static 'gs-alpha :b #x1 :d #x1))
        (set! (-> (the-as (pointer gs-reg64) s2-0) 9) (gs-reg64 alpha-1))
        (set! (-> s3-0 base) (&+ s2-0 80))
        )
      )
    )
  (let* ((v1-26 (the-as (inline-array qword) (-> arg0 base)))
         (f0-0 (-> *fog-texture-work* min-corner y))
         (f4-0 (- (-> *fog-texture-work* max-corner y) f0-0))
         (f3-0 (/ (- (-> *fog-texture-work* corner 1 y) f0-0) f4-0))
         (f2-0 (/ (- (-> *fog-texture-work* corner 0 y) f0-0) f4-0))
         (f1-7 (/ (- (-> *fog-texture-work* corner 3 y) f0-0) f4-0))
         (f0-2 (/ (- (-> *fog-texture-work* corner 2 y) f0-0) f4-0))
         (a0-28 6400)
         )
    (set! (-> v1-26 0 quad) (-> obj fog-tmpl dma-vif quad))
    (set! (-> v1-26 1 quad) (-> obj fog-tmpl quad 1))
    (set-vector! (-> v1-26 2 vector4w) #x80 #x80 #x80 #x80)
    (set-vector! (-> v1-26 3 vector) f3-0 0.0 1.0 0.0)
    (set-vector! (-> v1-26 4 vector4w) #x7000 #x7300 a0-28 0)
    (set-vector! (-> v1-26 5 vector) f2-0 0.0 1.0 0.0)
    (set-vector! (-> v1-26 6 vector4w) #x9000 #x7300 a0-28 0)
    (set-vector! (-> v1-26 7 vector) f1-7 0.0 1.0 0.0)
    (set-vector! (-> v1-26 8 vector4w) #x7000 #x8d00 a0-28 0)
    (set-vector! (-> v1-26 9 vector) f0-2 0.0 1.0 0.0)
    (set-vector! (-> v1-26 10 vector4w) #x9000 #x8d00 a0-28 0)
    )
  (&+! (-> arg0 base) 176)
  0
  (none)
  )

(defmethod draw sky-work ((obj sky-work))
  (let ((v1-0 *time-of-day-context*)
        (a0-1 #f)
        )
    (dotimes (a1-0 (-> *level* length))
      (let ((a2-3 (-> *level* level a1-0)))
        (when (= (-> a2-3 status) 'active)
          (if (-> a2-3 info sky)
              (set! a0-1 #t)
              )
          )
        )
      )
    (cond
      ((and a0-1
            (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask sky))
            (logtest? (-> *texture-pool* texture-enable-user) (texture-enable-mask sky))
            )
       (let ((gp-0 (-> *display* frames (-> *display* on-screen) global-buf base)))
         (let ((a1-7 (if (-> v1-0 use-camera-other)
                         (-> *math-camera* camera-rot-other)
                         (-> *math-camera* camera-rot)
                         )
                     )
               )
           (update-matrix obj a1-7)
           )
         (update-template-colors obj)
         (adjust-haze-lighting obj)
         (adjust-cloud-lighting obj)
         (let ((s4-0 (the-as object *fake-scratchpad-data*)))
           (mem-copy! (the-as pointer s4-0) (the-as pointer obj) #x2760)
           (setup-stars (the-as sky-work s4-0) (-> (the-as sky-work s4-0) star-mat) (-> obj upload-data))
           (if (nonzero? (-> (the-as sky-work s4-0) star-colors 0 x))
               (stars-transform-asm (the-as sky-work s4-0))
               )
           (let* ((s3-0 (-> *display* frames (-> *display* on-screen) global-buf))
                  (s5-1 (-> s3-0 base))
                  )
             (draw-roof (the-as sky-work s4-0) s3-0)
             (init-regs-for-sky-asm (the-as sky-work s4-0))
             (if (nonzero? (-> (the-as sky-work s4-0) star-colors 0 x))
                 (stars-dma (the-as sky-work s4-0) s3-0)
                 )
             (sun-dma (the-as sky-work s4-0) s3-0)
             (green-sun-dma (the-as sky-work s4-0) s3-0)
             (moon-dma (the-as sky-work s4-0) s3-0)
             (draw-haze (the-as sky-work s4-0) s3-0)
             (when (nonzero? *sky-texture-anim-array*) ;; added check
               ; (draw-clouds (the-as sky-work s4-0) s3-0) ;; DISABLED!
               )
             (draw-base (the-as sky-work s4-0) s3-0)
             (when (nonzero? *sky-texture-anim-array*) ;; added check
               ;(draw-fog (the-as sky-work s4-0) s3-0)
               )
             (let ((a3-5 (-> s3-0 base)))
               (let ((v1-45 (the-as dma-packet (-> s3-0 base))))
                 (set! (-> v1-45 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
                 (set! (-> v1-45 vif0) (new 'static 'vif-tag))
                 (set! (-> v1-45 vif1) (new 'static 'vif-tag))
                 (set! (-> s3-0 base) (the-as pointer (&+ v1-45 16)))
                 )
               (dma-bucket-insert-tag
                 (-> *display* frames (-> *display* on-screen) bucket-group)
                 (bucket-id sky-draw)
                 s5-1
                 (the-as (pointer dma-tag) a3-5)
                 )
               )
             )
           )
         (let ((v1-52 *dma-mem-usage*))
           (when (nonzero? v1-52)
             (set! (-> v1-52 length) (max 89 (-> v1-52 length)))
             (set! (-> v1-52 data 88 name) "sky")
             (+! (-> v1-52 data 88 count) 1)
             (+! (-> v1-52 data 88 used)
                 (&- (-> *display* frames (-> *display* on-screen) global-buf base) (the-as uint gp-0))
                 )
             (set! (-> v1-52 data 88 total) (-> v1-52 data 88 used))
             )
           )
         )
       )
      (else
        (let* ((s4-1 (-> *display* frames (-> *display* on-screen) global-buf))
               (gp-1 (-> s4-1 base))
               )
          (cond
            ((-> *blit-displays-work* menu-mode)
             (let ((f0-0 (-> *blit-displays-work* progress-interp)))
               (let* ((a0-43 s4-1)
                      (a1-30 (the-as dma-packet (-> a0-43 base)))
                      )
                 (set! (-> a1-30 dma) (new 'static 'dma-tag :qwc #x8 :id (dma-tag-id cnt)))
                 (set! (-> a1-30 vif0) (new 'static 'vif-tag))
                 (set! (-> a1-30 vif1) (new 'static 'vif-tag :imm #x8 :cmd (vif-cmd direct) :msk #x1))
                 (set! (-> a0-43 base) (the-as pointer (&+ a1-30 16)))
                 )
               (let* ((a0-44 s4-1)
                      (a1-32 (the-as gs-gif-tag (-> a0-44 base)))
                      )
                 (set! (-> a1-32 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x7))
                 (set! (-> a1-32 regs) GIF_REGS_ALL_AD)
                 (set! (-> a0-44 base) (the-as pointer (&+ a1-32 16)))
                 )
               (let* ((a0-45 s4-1)
                      (a1-34 (-> a0-45 base))
                      )
                 (set! (-> (the-as (pointer gs-zbuf) a1-34) 0) (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24)))
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 1) (gs-reg64 zbuf-1))
                 (set! (-> (the-as (pointer gs-test) a1-34) 2)
                       (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always))
                       )
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 3) (gs-reg64 test-1))
                 (set! (-> (the-as (pointer gs-alpha) a1-34) 4) (new 'static 'gs-alpha))
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 5) (gs-reg64 alpha-1))
                 (set! (-> (the-as (pointer gs-tex0) a1-34) 6)
                       (new 'static 'gs-tex0 :tbp0 #x4c0 :tbw #x8 :tw #x9 :th #x9 :tcc #x1)
                       )
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 7) (gs-reg64 tex0-1))
                 (set! (-> (the-as (pointer gs-tex1) a1-34) 8) (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 9) (gs-reg64 tex1-1))
                 (set! (-> (the-as (pointer gs-clamp) a1-34) 10)
                       (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp))
                       )
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 11) (gs-reg64 clamp-1))
                 (set! (-> (the-as (pointer uint64) a1-34) 12) (the-as uint 0))
                 (set! (-> (the-as (pointer gs-reg64) a1-34) 13) (gs-reg64 texflush))
                 (set! (-> a0-45 base) (&+ a1-34 112))
                 )
               (let ((a2-40 (the-as (inline-array qword) (-> s4-1 base)))
                     (a3-7 #x7000)
                     (t0-1 #x7300)
                     (a0-46 #x7800)
                     (a1-36 #x7980)
                     )
                 (set! (-> a2-40 0 quad) (-> obj draw-tmpl2 dma-vif quad))
                 (set! (-> a2-40 1 quad) (-> obj draw-tmpl2 quad 1))
                 (set-vector! (-> a2-40 2 vector4w) 128 128 128 128)
                 (set-vector! (-> a2-40 3 vector4w) 8 8 0 0)
                 (set-vector! (-> a2-40 4 vector4w) a3-7 t0-1 0 0)
                 (set-vector! (-> a2-40 5 vector4w) 8200 6664 0 0)
                 (set-vector! (-> a2-40 6 vector4w) a0-46 a1-36 0 0)
                 )
               (&+! (-> s4-1 base) 112)
               (let ((t0-4 (the-as (inline-array qword) (-> s4-1 base)))
                     (a2-42 #x8000)
                     (a3-9 #x8000)
                     (a0-49 #x9000)
                     (a1-37 #x8d00)
                     )
                 (set! (-> t0-4 0 quad) (-> obj draw-tmpl2 dma-vif quad))
                 (set! (-> t0-4 1 quad) (-> obj draw-tmpl2 quad 1))
                 (set-vector! (-> t0-4 2 vector4w) 128 128 128 128)
                 (set-vector! (-> t0-4 3 vector4w) 8 8 0 0)
                 (set-vector! (-> t0-4 4 vector4w) a2-42 a3-9 0 0)
                 (set-vector! (-> t0-4 5 vector4w) 8200 6664 0 0)
                 (set-vector! (-> t0-4 6 vector4w) a0-49 a1-37 0 0)
                 (&+! (-> s4-1 base) 112)
                 (let* ((t0-8 s4-1)
                        (t1-11 (the-as dma-packet (-> t0-8 base)))
                        )
                   (set! (-> t1-11 dma) (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt)))
                   (set! (-> t1-11 vif0) (new 'static 'vif-tag))
                   (set! (-> t1-11 vif1) (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1))
                   (set! (-> t0-8 base) (the-as pointer (&+ t1-11 16)))
                   )
                 (let* ((t0-9 s4-1)
                        (t1-13 (the-as gs-gif-tag (-> t0-9 base)))
                        )
                   (set! (-> t1-13 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x3))
                   (set! (-> t1-13 regs) GIF_REGS_ALL_AD)
                   (set! (-> t0-9 base) (the-as pointer (&+ t1-13 16)))
                   )
                 (let* ((t0-10 s4-1)
                        (t1-15 (-> t0-10 base))
                        )
                   (set! (-> (the-as (pointer gs-alpha) t1-15) 0) (new 'static 'gs-alpha :b #x1 :d #x1))
                   (set! (-> (the-as (pointer gs-reg64) t1-15) 1) (gs-reg64 alpha-1))
                   (set! (-> (the-as (pointer gs-tex0) t1-15) 2)
                         (new 'static 'gs-tex0 :tbp0 #x3300 :tbw #x8 :tw #x9 :th #x9 :tcc #x1)
                         )
                   (set! (-> (the-as (pointer gs-reg64) t1-15) 3) (gs-reg64 tex0-1))
                   (set! (-> (the-as (pointer uint64) t1-15) 4) (the-as uint 0))
                   (set! (-> (the-as (pointer gs-reg64) t1-15) 5) (gs-reg64 texflush))
                   (set! (-> t0-10 base) (&+ t1-15 48))
                   )
                 (let ((t0-11 (the-as (inline-array qword) (-> s4-1 base))))
                   (set! (-> t0-11 0 quad) (-> obj draw-tmpl2 dma-vif quad))
                   (set! (-> t0-11 1 quad) (-> obj draw-tmpl2 quad 1))
                   (set-vector! (-> t0-11 2 vector4w) 128 128 128 80)
                   (set-vector! (-> t0-11 3 vector4w) 0 0 0 0)
                   (set-vector! (-> t0-11 4 vector4w) a2-42 a3-9 0 0)
                   (set-vector! (-> t0-11 5 vector4w) 2048 1664 0 0)
                   (set-vector! (-> t0-11 6 vector4w) a0-49 a1-37 0 0)
                   )
                 )
               (&+! (-> s4-1 base) 112)
               (let* ((a0-52 s4-1)
                      (a1-38 (the-as dma-packet (-> a0-52 base)))
                      )
                 (set! (-> a1-38 dma) (new 'static 'dma-tag :qwc #x2 :id (dma-tag-id cnt)))
                 (set! (-> a1-38 vif0) (new 'static 'vif-tag))
                 (set! (-> a1-38 vif1) (new 'static 'vif-tag :imm #x2 :cmd (vif-cmd direct) :msk #x1))
                 (set! (-> a0-52 base) (the-as pointer (&+ a1-38 16)))
                 )
               (let* ((a0-53 s4-1)
                      (a1-40 (the-as gs-gif-tag (-> a0-53 base)))
                      )
                 (set! (-> a1-40 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x1))
                 (set! (-> a1-40 regs) GIF_REGS_ALL_AD)
                 (set! (-> a0-53 base) (the-as pointer (&+ a1-40 16)))
                 )
               (let* ((a0-54 s4-1)
                      (a1-42 (-> a0-54 base))
                      )
                 (set! (-> (the-as (pointer gs-alpha) a1-42) 0) (new 'static 'gs-alpha))
                 (set! (-> (the-as (pointer gs-reg64) a1-42) 1) (gs-reg64 alpha-1))
                 (set! (-> a0-54 base) (&+ a1-42 16))
                 )
               (let ((a0-57 (the int (+ 128.0 (* 32.0 f0-0))))
                     (a1-46 (the int (- 128.0 (* 16.0 f0-0))))
                     (a2-55 (the int (- 128.0 (* 96.0 f0-0))))
                     )
                 (when (or (!= (-> v1-0 filter x) 1.0) (!= (-> v1-0 filter y) 1.0) (!= (-> v1-0 filter z) 1.0))
                   (set! a0-57 128)
                   (set! a1-46 128)
                   (set! a2-55 128)
                   )
                 (let ((v1-57 3328)
                       (a3-16 6656)
                       )
                   (dotimes (t0-12 16)
                     (let ((t1-22 (the-as (inline-array qword) (-> s4-1 base)))
                           (t3-0 (* (+ (* t0-12 32) 1792) 16))
                           (t2-36 (* (+ (* (+ t0-12 1) 32) 1792) 16))
                           )
                       (let ((t5-0 (* (+ (* t0-12 16) 256) 16))
                             (t4-5 (* (+ (* (+ t0-12 1) 16) 256) 16))
                             )
                         (set! (-> t1-22 0 quad) (-> obj draw-tmpl2 dma-vif quad))
                         (set! (-> t1-22 1 quad) (-> obj draw-tmpl2 quad 1))
                         (set-vector! (-> t1-22 2 vector4w) a0-57 a1-46 a2-55 128)
                         (set-vector! (-> t1-22 3 vector4w) (+ t5-0 8) (+ v1-57 24) 0 0)
                         (set-vector! (-> t1-22 4 vector4w) t3-0 #x7300 0 0)
                         (set-vector! (-> t1-22 5 vector4w) (+ t4-5 8) (+ a3-16 24) 0 0)
                         )
                       (set-vector! (-> t1-22 6 vector4w) t2-36 #x8d00 0 0)
                       )
                     (&+! (-> s4-1 base) 112)
                     )
                   )
                 (let* ((v1-60 s4-1)
                        (a3-17 (the-as dma-packet (-> v1-60 base)))
                        )
                   (set! (-> a3-17 dma) (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt)))
                   (set! (-> a3-17 vif0) (new 'static 'vif-tag))
                   (set! (-> a3-17 vif1) (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1))
                   (set! (-> v1-60 base) (the-as pointer (&+ a3-17 16)))
                   )
                 (let* ((v1-61 s4-1)
                        (a3-19 (the-as gs-gif-tag (-> v1-61 base)))
                        )
                   (set! (-> a3-19 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x3))
                   (set! (-> a3-19 regs) GIF_REGS_ALL_AD)
                   (set! (-> v1-61 base) (the-as pointer (&+ a3-19 16)))
                   )
                 (let* ((v1-62 s4-1)
                        (a3-21 (-> v1-62 base))
                        )
                   (set! (-> (the-as (pointer gs-alpha) a3-21) 0) (new 'static 'gs-alpha :b #x1 :d #x1))
                   (set! (-> (the-as (pointer gs-reg64) a3-21) 1) (gs-reg64 alpha-1))
                   (set! (-> (the-as (pointer gs-tex0) a3-21) 2)
                         (new 'static 'gs-tex0 :tbp0 #x4c0 :tbw #x8 :tw #x9 :th #x9 :tcc #x1)
                         )
                   (set! (-> (the-as (pointer gs-reg64) a3-21) 3) (gs-reg64 tex0-1))
                   (set! (-> (the-as (pointer uint64) a3-21) 4) (the-as uint 0))
                   (set! (-> (the-as (pointer gs-reg64) a3-21) 5) (gs-reg64 texflush))
                   (set! (-> v1-62 base) (&+ a3-21 48))
                   )
                 (let ((v1-63 (the-as (inline-array qword) (-> s4-1 base))))
                   (set! (-> v1-63 0 quad) (-> obj draw-tmpl2 dma-vif quad))
                   (set! (-> v1-63 1 quad) (-> obj draw-tmpl2 quad 1))
                   (set-vector! (-> v1-63 2 vector4w) a0-57 a1-46 a2-55 (the int (- 128.0 (* 48.0 f0-0))))
                   (set-vector! (-> v1-63 3 vector4w) 0 24 0 0)
                   (set-vector! (-> v1-63 4 vector4w) #x7000 #x7300 0 0)
                   (set-vector! (-> v1-63 5 vector4w) 8192 6680 0 0)
                   (set-vector! (-> v1-63 6 vector4w) #x9000 #x8d00 0 0)
                   )
                 )
               )
             (&+! (-> s4-1 base) 112)
             (seek!
               (-> *blit-displays-work* progress-interp)
               (-> *blit-displays-work* progress-interp-dest)
               (-> *blit-displays-work* progress-interp-speed)
               )
             )
            (else
              (let* ((a0-66 s4-1)
                     (a1-53 (the-as dma-packet (-> a0-66 base)))
                     )
                (set! (-> a1-53 dma) (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt)))
                (set! (-> a1-53 vif0) (new 'static 'vif-tag))
                (set! (-> a1-53 vif1) (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1))
                (set! (-> a0-66 base) (the-as pointer (&+ a1-53 16)))
                )
              (let* ((a0-67 s4-1)
                     (a1-55 (the-as gs-gif-tag (-> a0-67 base)))
                     )
                (set! (-> a1-55 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x3))
                (set! (-> a1-55 regs) GIF_REGS_ALL_AD)
                (set! (-> a0-67 base) (the-as pointer (&+ a1-55 16)))
                )
              (let* ((a0-68 s4-1)
                     (a1-57 (-> a0-68 base))
                     )
                (set! (-> (the-as (pointer gs-zbuf) a1-57) 0) (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24)))
                (set! (-> (the-as (pointer gs-reg64) a1-57) 1) (gs-reg64 zbuf-1))
                (set! (-> (the-as (pointer gs-test) a1-57) 2)
                      (new 'static 'gs-test :ate #x1 :atst (gs-atest always) :zte #x1 :ztst (gs-ztest always))
                      )
                (set! (-> (the-as (pointer gs-reg64) a1-57) 3) (gs-reg64 test-1))
                (set! (-> (the-as (pointer gs-rgbaq) a1-57) 4) (new 'static 'gs-rgbaq
                                                                 :q 1.0
                                                                 :a (the int (-> v1-0 current-fog erase-color w))
                                                                 :b (the int (-> v1-0 current-fog erase-color z))
                                                                 :g (the int (-> v1-0 current-fog erase-color y))
                                                                 :r (the int (-> v1-0 current-fog erase-color x))
                                                                 )
                      )
                (set! (-> (the-as (pointer gs-reg64) a1-57) 5) (gs-reg64 rgbaq))
                (set! (-> a0-68 base) (&+ a1-57 48))
                )
              (let ((v1-78 (the-as (inline-array qword) (-> s4-1 base))))
                (set! (-> v1-78 0 quad) (-> obj sprite-tmpl dma-vif quad))
                (set! (-> v1-78 1 quad) (-> obj sprite-tmpl quad 1))
                )
              (&+! (-> s4-1 base) 32)
              (let ((v1-81 (the-as (inline-array qword) (-> s4-1 base))))
                (set-vector! (-> v1-81 0 vector4w) #x7000 #x7300 0 0)
                (set-vector! (-> v1-81 1 vector4w) #x9000 #x8d00 0 0)
                )
              (&+! (-> s4-1 base) 32)
              )
            )
          (let ((a3-35 (-> s4-1 base)))
            (let ((v1-85 (the-as dma-packet (-> s4-1 base))))
              (set! (-> v1-85 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
              (set! (-> v1-85 vif0) (new 'static 'vif-tag))
              (set! (-> v1-85 vif1) (new 'static 'vif-tag))
              (set! (-> s4-1 base) (the-as pointer (&+ v1-85 16)))
              )
            (dma-bucket-insert-tag
              (-> *display* frames (-> *display* on-screen) bucket-group)
              (bucket-id sky-draw)
              gp-1
              (the-as (pointer dma-tag) a3-35)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )
