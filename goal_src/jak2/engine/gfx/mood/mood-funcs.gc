;;-*-Lisp-*-
(in-package goal)

;; name: mood-funcs.gc
;; name in dgo: mood-funcs
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(defbehavior update-mood-default time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  0
  (none)
  )

(defun get-sphere-interp ((arg0 sphere) (arg1 vector) (arg2 float) (arg3 float))
  (let ((v1-0 (new 'stack-no-clear 'vector)))
    0.0
    (set! (-> v1-0 quad) (-> arg0 quad))
    (vector-! v1-0 arg1 v1-0)
    (let ((f1-0 (vector-length v1-0)))
      (/ (fmax 0.0 (fmin (- f1-0 arg2) arg3)) arg3)
      )
    )
  )

(deftype ruins-states (structure)
  ((light  light-state        :inline :offset-assert   0)
   (spec-0 sp-field-init-spec         :offset-assert   8)
   (spec-1 sp-field-init-spec         :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


;; WARN: Return type mismatch sp-field-init-spec vs none.
(defun init-mood-ruins ((arg0 mood-context))
  (let ((gp-0 (the-as ruins-states (-> arg0 state))))
    (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
    (let ((a0-1 (-> *part-id-table* 1)))
      (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-0) (get-field-spec-by-id a0-1 (sp-field-id spt-a)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 2)))
      (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 spec-1) (get-field-spec-by-id a0-2 (sp-field-id spt-a)))
          )
      )
    )
  (none)
  )

(defbehavior update-mood-ruins time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as (pointer float) (-> arg0 state))))
      (update-mood-light arg0 6 0 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> (the-as ruins-states gp-1) spec-0))
          (set! (-> (the-as ruins-states gp-1) spec-0 initial-valuef)
                (* 32.0 (-> (the-as ruins-states gp-1) light fade))
                )
          )
      (if (nonzero? (-> (the-as ruins-states gp-1) spec-1))
          (set! (-> (the-as ruins-states gp-1) spec-1 initial-valuef)
                (* 8.0 (-> (the-as ruins-states gp-1) light fade))
                )
          )
      )
    )
  0
  (none)
  )

(deftype strip-states (structure)
  ((light0 light-state        :inline :offset-assert   0)
   (light1 light-state        :inline :offset-assert   8)
   (spec-0 sp-field-init-spec         :offset-assert  16)
   (spec-1 sp-field-init-spec         :offset-assert  20)
   )
  :method-count-assert 9
  :size-assert         #x18
  :flag-assert         #x900000018
  )


;; WARN: Return type mismatch sp-field-init-spec vs uint.
(defun init-mood-strip ((arg0 mood-context))
  (let ((gp-0 (the-as strip-states (-> arg0 state))))
    (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
    (let ((a0-1 (-> *part-id-table* 3)))
      (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-0) (get-field-spec-by-id a0-1 (sp-field-id spt-a)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 4)))
      (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
      (the-as uint (when (nonzero? a0-2)
                     (let ((v0-1 (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
                       (set! (-> gp-0 spec-1) v0-1)
                       v0-1
                       )
                     )
              )
      )
    )
  )

(defbehavior update-mood-strip time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (set! (-> arg0 times 5 w) 1.0)
    (let ((s4-1 (the-as (pointer float) (-> arg0 state))))
      (if (task-complete? *game-info* (game-task strip-grenade))
          (update-mood-light arg0 6 0 0.875 0.25 8.0 0.0 2.0)
          (update-mood-light arg0 6 0 0.875 0.25 20.0 0.0 2.0)
          )
      (update-mood-light arg0 7 8 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> (the-as strip-states s4-1) spec-0))
          (set! (-> (the-as strip-states s4-1) spec-0 initial-valuef)
                (* 32.0 (-> (the-as strip-states s4-1) light1 fade))
                )
          )
      (if (nonzero? (-> (the-as strip-states s4-1) spec-1))
          (set! (-> (the-as strip-states s4-1) spec-1 initial-valuef)
                (* 8.0 (-> (the-as strip-states s4-1) light1 fade))
                )
          )
      )
    )
  0
  (none)
  )

(deftype ctywide-states (structure)
  ((light light-state  :inline :offset-assert   0)
   (flame flames-state :inline :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xf
  :flag-assert         #x90000000f
  )


(defbehavior update-mood-ctywide time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    (update-mood-flames arg0 6 2 8 0.5 0.0009765625 1.5)
    )
  0
  (none)
  )

(defbehavior update-mood-copy-ctywide time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((v1-1 (level-get *level* 'ctywide)))
    (cond
      ((and v1-1 (= (-> v1-1 status) 'active))
       (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
       )
      (else
        (update-mood-ctywide arg0 arg1 arg2)
        (if (or (>= arg1 18.0) (>= 6.0 arg1))
            (set! (-> arg0 times 5 w) 1.0)
            )
        )
      )
    )
  0
  (none)
  )

(deftype ctyind-states (structure)
  ((light light-state :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(defbehavior update-mood-ctyind time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (set! (-> arg0 times 6 w) 1.0)
    (let ((f0-1 0.5))
      (let ((f1-0 1.0))
        (cond
          ((or (>= 6.0 arg1) (>= arg1 18.0))
           (set! f0-1 f1-0)
           )
          ((and (< 6.0 arg1) (< arg1 7.0))
           (+! f0-1 (* (- f1-0 f0-1) (- 7.0 arg1)))
           )
          ((and (< 17.0 arg1) (< arg1 18.0))
           (+! f0-1 (* (- f1-0 f0-1) (+ -17.0 arg1)))
           )
          )
        )
      (set! (-> arg0 times 7 w) f0-1)
      )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    )
  0
  (none)
  )

(deftype ctysluma-states (structure)
  ((light           light-state        :inline :offset-assert   0)
   (neon            light-state        :inline :offset-assert   8)
   (flame           flames-state       :inline :offset-assert  16)
   (spec-0          sp-field-init-spec         :offset-assert  24)
   (spec-1          sp-field-init-spec         :offset-assert  28)
   (neon-min-bright float                      :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  )


(defun init-mood-ctysluma ((arg0 mood-context))
  (let ((gp-0 (the-as ctysluma-states (-> arg0 state))))
    (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
    (let ((a0-1 (-> *part-id-table* 5)))
      (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-0) (get-field-spec-by-id a0-1 (sp-field-id spt-a)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 6)))
      (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 spec-1) (get-field-spec-by-id a0-2 (sp-field-id spt-a)))
          )
      )
    (set! (-> gp-0 neon-min-bright) (rand-vu-float-range 0.8 1.0))
    )
  )

(defbehavior update-mood-ctysluma time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (!= arg2 -1)
             (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as ctysluma-states (-> arg0 state))))
      (update-mood-flames arg0 6 1 16 0.5 0.001953125 2.0)
      (update-mood-light arg0 7 8 (-> gp-1 neon-min-bright) 0.0 arg1 32.0 2.0)
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> gp-1 spec-0))
          (set! (-> gp-1 spec-0 initial-valuef) (* 32.0 (-> gp-1 light fade)))
          )
      (if (nonzero? (-> gp-1 spec-1))
          (set! (-> gp-1 spec-1 initial-valuef) (* 8.0 (-> gp-1 light fade)))
          )
      (if (not (paused?))
          (set! (-> gp-1 neon-min-bright) (rand-vu-float-range 0.8 1.0))
          )
      )
    )
  0
  (none)
  )

(deftype ctyslumb-states (structure)
  ((light  light-state        :inline :offset-assert   0)
   (flame  flames-state       :inline :offset-assert   8)
   (spec-0 sp-field-init-spec         :offset-assert  16)
   (spec-1 sp-field-init-spec         :offset-assert  20)
   )
  :method-count-assert 9
  :size-assert         #x18
  :flag-assert         #x900000018
  )


;; WARN: Return type mismatch sp-field-init-spec vs uint.
(defun init-mood-ctyslumb ((arg0 mood-context))
  (let ((gp-0 (-> arg0 state)))
    (set! (-> gp-0 4) (the-as uint 0))
    (set! (-> gp-0 5) (the-as uint 0))
    (let ((a0-1 (-> *part-id-table* 7)))
      (set! (-> gp-0 4) (the-as uint 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 4) (the-as uint (get-field-spec-by-id a0-1 (sp-field-id spt-a))))
          )
      )
    (let ((a0-2 (-> *part-id-table* 8)))
      (set! (-> gp-0 5) (the-as uint 0))
      (the-as uint (when (nonzero? a0-2)
                     (let ((v0-1 (get-field-spec-by-id a0-2 (sp-field-id spt-a))))
                       (set! (-> gp-0 5) (the-as uint v0-1))
                       v0-1
                       )
                     )
              )
      )
    )
  )

(defbehavior update-mood-ctyslumb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as ctyslumb-states (-> arg0 state))))
      (update-mood-flames arg0 6 1 8 0.5 0.001953125 2.0)
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 7 w) 1.0)
      (if (nonzero? (-> s5-1 spec-0))
          (set! (-> s5-1 spec-0 initial-valuef) (* 32.0 (-> s5-1 light fade)))
          )
      (if (nonzero? (-> s5-1 spec-1))
          (set! (-> s5-1 spec-1 initial-valuef) (* 8.0 (-> s5-1 light fade)))
          )
      )
    )
  0
  (none)
  )

(deftype ctyslumc-states (structure)
  ((light  light-state        :inline :offset-assert   0)
   (spec-0 sp-field-init-spec         :offset-assert   8)
   (spec-1 sp-field-init-spec         :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


;; WARN: Return type mismatch sp-field-init-spec vs none.
(defun init-mood-ctyslumc ((arg0 mood-context))
  (let ((gp-0 (the-as ctyslumc-states (-> arg0 state))))
    (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
    (let ((a0-1 (-> *part-id-table* 9)))
      (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-0) (get-field-spec-by-id a0-1 (sp-field-id spt-a)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 10)))
      (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 spec-1) (get-field-spec-by-id a0-2 (sp-field-id spt-a)))
          )
      )
    )
  (none)
  )

(defbehavior update-mood-ctyslumc time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as ctyslumc-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (if (nonzero? (-> gp-1 spec-0))
          (set! (-> gp-1 spec-0 initial-valuef) (* 32.0 (-> gp-1 light fade)))
          )
      (if (nonzero? (-> gp-1 spec-1))
          (set! (-> gp-1 spec-1 initial-valuef) (* 8.0 (-> gp-1 light fade)))
          )
      )
    )
  0
  (none)
  )

(deftype ctyport-states (structure)
  ((light           light-state        :inline :offset-assert   0)
   (spec-0          sp-field-init-spec         :offset-assert   8)
   (neon-min-bright float                      :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


;; WARN: Return type mismatch sp-field-init-spec vs uint.
(defun init-mood-ctyport ((arg0 mood-context))
  (let ((gp-0 (the-as ctyport-states (-> arg0 state))))
    (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
    (let ((a0-1 (-> *part-id-table* 11)))
      (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
      (the-as uint (when (nonzero? a0-1)
                     (let ((v0-0 (get-field-spec-by-id a0-1 (sp-field-id spt-r))))
                       (set! (-> gp-0 spec-0) v0-0)
                       v0-0
                       )
                     )
              )
      )
    )
  )

(defun init-mood-ctyport-no-part ((arg0 mood-context))
  (set! (-> (the-as ctyport-states (-> arg0 state)) spec-0) (the-as sp-field-init-spec 0))
  0
  (none)
  )

(defbehavior update-mood-ctyport time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (!= arg2 -1)
             (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as ctyport-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (if (= (-> s5-1 neon-min-bright) 0.0)
                                    0.0
                                    1.0
                                    )
            )
      (if (nonzero? (-> s5-1 spec-0))
          (set! (-> s5-1 spec-0 initial-valuef) (-> s5-1 neon-min-bright))
          )
      (set! (-> arg0 times 7 w) 1.0)
      (when (not (paused?))
        (if (< (mod (-> *display* part-clock frame-counter) 600) 300)
            (set! (-> s5-1 neon-min-bright) 0.0)
            (set! (-> s5-1 neon-min-bright) (rand-vu-float-range 128.0 255.0))
            )
        )
      )
    )
  0
  (none)
  )

(deftype ctymarka-states (structure)
  ((light light-state :inline :offset-assert   0)
   (blink float               :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defbehavior update-mood-ctymarka time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (-> arg0 state)))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (the-as float (-> gp-1 2)))
      (set! (-> arg0 times 7 w) 0.75)
      (when (not (paused?))
        (let ((v1-11 (-> *display* part-clock frame-counter)))
          (if (< (* 0.2 (the float (mod v1-11 600))) 60.0)
              (set! (-> gp-1 2) (the-as uint 0.0))
              (set! (-> gp-1 2) (the-as uint 1.0))
              )
          )
        )
      )
    )
  0
  (none)
  )

(deftype ctymarkb-states (structure)
  ((light light-state :inline :offset-assert   0)
   (blink float               :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defbehavior update-mood-ctymarkb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (!= arg2 -1)
             (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as ctymarkb-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (-> gp-1 blink))
      (set! (-> arg0 times 7 w) 0.75)
      (when (not (paused?))
        (let* ((v1-12 (-> *display* part-clock frame-counter))
               (f0-3 (* 0.2 (the float (mod v1-12 300))))
               )
          (cond
            ((< f0-3 15.0)
             (set! (-> gp-1 blink) (* 0.06666667 f0-3))
             )
            ((< 45.0 f0-3)
             (set! (-> gp-1 blink) (* 0.06666667 (- 60.0 f0-3)))
             )
            (else
              (set! (-> gp-1 blink) 1.0)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(deftype palcab-states (structure)
  ((light        light-state       :inline :offset-assert   0)
   (turret-value float                     :offset-assert   8)
   (electricity  electricity-state :inline :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(defun init-mood-palcab ((arg0 mood-context))
  (let ((v1-0 (the-as object (-> arg0 state))))
    (set! (-> (the-as palcab-states v1-0) electricity scale) 1.0)
    )
  )

(defbehavior update-mood-palcab time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (!= arg2 -1)
             (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s4-1 (the-as palcab-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (-> s4-1 turret-value))
      (update-mood-electricity arg0 7 12 0.8 1.0)
      (if (not (paused?))
          (set! (-> s4-1 turret-value) (fmax 0.0 (+ -0.2 (-> s4-1 turret-value))))
          )
      )
    (let ((a0-9 (new 'stack-no-clear 'sphere))
          (a1-3 (-> *math-camera* trans))
          )
      (let ((v1-12 a0-9))
        (set! (-> v1-12 x) 786432.0)
        (set! (-> v1-12 y) 1818624.0)
        (set! (-> v1-12 z) 2498560.0)
        (set! (-> v1-12 r) 1.0)
        )
      (let ((f0-8 (- 1.0 (get-sphere-interp a0-9 a1-3 1024000.0 2048000.0))))
        (update-mood-weather! *mood-control* (+ 0.25 (* 0.75 f0-8)) (+ 0.5 (* 0.5 f0-8)) 30.0 30.0)
        )
      )
    )
  0
  (none)
  )

(defun set-palcab-turret-flash! ((arg0 float))
  (let ((v1-1 (level-get *level* 'palcab)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as palcab-states v1-2) turret-value) arg0)
        )
      )
    )
  )

(deftype stadium-states (structure)
  ((light light-state  :inline :offset-assert   0)
   (flame flames-state :inline :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xf
  :flag-assert         #x90000000f
  )


(defun update-stadium-lights ((arg0 mood-context))
  (let ((a1-0 (-> arg0 light-group))
        (gp-0 (-> arg0 light-group 2))
        )
    (mem-copy! (the-as pointer gp-0) (the-as pointer a1-0) 192)
    (set! (-> gp-0 dir0 extra x) 0.0)
    (set! (-> gp-0 dir1 extra x) 0.0)
    (set! (-> gp-0 dir2 extra x) 0.0)
    )
  0
  (none)
  )

(defbehavior update-mood-stadium time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (update-stadium-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    (update-mood-flames arg0 6 1 8 0.5 0.001953125 2.0)
    (set! (-> arg0 times 7 w) 1.0)
    )
  0
  (none)
  )

(defbehavior update-mood-copy-stadium time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((v1-1 (level-get *level* 'stadium)))
    (cond
      ((and v1-1 (= (-> v1-1 status) 'active))
       (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
       )
      (else
        (copy-mood-exterior arg0)
        (update-stadium-lights arg0)
        (if (or (>= arg1 18.0) (>= 6.0 arg1))
            (set! (-> arg0 times 5 w) 1.0)
            )
        )
      )
    )
  0
  (none)
  )

(deftype stadiumb-states (structure)
  ((light        light-state :inline :offset-assert   0)
   (shield-count float               :offset-assert   8)
   (shield       float               :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(defun update-stadiumb-lights ((arg0 mood-context))
  (let ((gp-0 (-> arg0 light-group)))
    (let ((a0-1 (-> arg0 light-group 1)))
      (mem-copy! (the-as pointer a0-1) (the-as pointer gp-0) 192)
      )
    (set! (-> gp-0 0 dir0 extra x) 0.0)
    (set! (-> gp-0 0 dir1 extra x) 0.0)
    (set! (-> gp-0 0 dir2 extra x) 0.0)
    )
  0
  (none)
  )

(defbehavior update-mood-stadiumb time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (update-stadiumb-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as stadiumb-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (-> gp-1 shield))
      (set! (-> arg0 times 7 w) 1.0)
      (when (not (paused?))
        (+! (-> gp-1 shield-count) (* 262144.0 (-> self clock seconds-per-frame)))
        (set! (-> gp-1 shield) (+ 0.875 (* 0.125 (cos (-> gp-1 shield-count)))))
        )
      )
    )
  0
  (none)
  )

(deftype skatea-states (structure)
  ((light light-state  :inline :offset-assert   0)
   (flame flames-state :inline :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xf
  :flag-assert         #x90000000f
  )


(defbehavior update-mood-skatea time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    (update-mood-flames arg0 6 1 8 0.5 0.0009765625 1.5)
    (set! (-> arg0 times 7 w) 1.0)
    )
  0
  (none)
  )

(deftype ltentout-states (structure)
  ((light light-state  :inline :offset-assert   0)
   (flame flames-state :inline :offset-assert   8)
   (totem flames-state :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x17
  :flag-assert         #x900000017
  )


(defun update-ltentout-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group 2)))
    (set-vector! (-> v1-0 dir0 color) 0.822 0.694 0.613 1.0)
    (set-vector! (-> v1-0 ambi color) 0.21 0.188 0.163 1.0)
    )
  0
  (none)
  )

(defbehavior update-mood-ltentout time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (update-ltentout-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    (update-mood-flames arg0 6 1 8 0.75 0.0009765625 2.0)
    (update-mood-flames arg0 7 1 16 0.333 0.001953125 2.0)
    )
  0
  (none)
  )

(deftype mountain-states (structure)
  ((light0 light-state        :inline :offset-assert   0)
   (light1 light-state        :inline :offset-assert   8)
   (spec-0 sp-field-init-spec         :offset-assert  16)
   (spec-1 sp-field-init-spec         :offset-assert  20)
   (spec-2 sp-field-init-spec         :offset-assert  24)
   (spec-3 sp-field-init-spec         :offset-assert  28)
   (spec-4 sp-field-init-spec         :offset-assert  32)
   (spec-5 sp-field-init-spec         :offset-assert  36)
   (spec-6 sp-field-init-spec         :offset-assert  40)
   )
  :method-count-assert 9
  :size-assert         #x2c
  :flag-assert         #x90000002c
  )


;; WARN: Return type mismatch sp-field-init-spec vs uint.
(defun init-mood-mountain ((arg0 mood-context))
  (let ((gp-0 (the-as mountain-states (-> arg0 state))))
    (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-2) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-3) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-4) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-5) (the-as sp-field-init-spec 0))
    (set! (-> gp-0 spec-6) (the-as sp-field-init-spec 0))
    (let ((a0-1 (-> *part-id-table* 12)))
      (set! (-> gp-0 spec-0) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-1)
          (set! (-> gp-0 spec-0) (get-field-spec-by-id a0-1 (sp-field-id spt-a)))
          )
      )
    (let ((a0-2 (-> *part-id-table* 13)))
      (set! (-> gp-0 spec-1) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-2)
          (set! (-> gp-0 spec-1) (get-field-spec-by-id a0-2 (sp-field-id spt-a)))
          )
      )
    (let ((a0-3 (-> *part-id-table* 14)))
      (set! (-> gp-0 spec-2) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-3)
          (set! (-> gp-0 spec-2) (get-field-spec-by-id a0-3 (sp-field-id spt-a)))
          )
      )
    (let ((a0-4 (-> *part-id-table* 15)))
      (set! (-> gp-0 spec-3) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-4)
          (set! (-> gp-0 spec-3) (get-field-spec-by-id a0-4 (sp-field-id spt-a)))
          )
      )
    (let ((a0-5 (-> *part-id-table* 16)))
      (set! (-> gp-0 spec-4) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-5)
          (set! (-> gp-0 spec-4) (get-field-spec-by-id a0-5 (sp-field-id spt-a)))
          )
      )
    (let ((a0-6 (-> *part-id-table* 17)))
      (set! (-> gp-0 spec-5) (the-as sp-field-init-spec 0))
      (if (nonzero? a0-6)
          (set! (-> gp-0 spec-5) (get-field-spec-by-id a0-6 (sp-field-id spt-a)))
          )
      )
    (let ((a0-7 (-> *part-id-table* 18)))
      (set! (-> gp-0 spec-6) (the-as sp-field-init-spec 0))
      (the-as uint (when (nonzero? a0-7)
                     (let ((v0-6 (get-field-spec-by-id a0-7 (sp-field-id spt-a))))
                       (set! (-> gp-0 spec-6) v0-6)
                       v0-6
                       )
                     )
              )
      )
    )
  )

(defbehavior update-mood-mountain time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as mountain-states (-> arg0 state))))
      (update-mood-light arg0 5 0 0.875 0.25 2.0 0.0 1.0)
      (update-mood-light arg0 6 8 1.0 0.0 arg1 0.0 1.0)
      (set! (-> arg0 times 7 w) 1.0)
      (let* ((f0-1 (-> arg0 times 5 w))
             (f1-1 (* 24.0 f0-1))
             (f0-2 (* 20.0 f0-1))
             )
        (if (nonzero? (-> gp-1 spec-0))
            (set! (-> gp-1 spec-0 initial-valuef) f1-1)
            )
        (if (nonzero? (-> gp-1 spec-1))
            (set! (-> gp-1 spec-1 initial-valuef) f0-2)
            )
        (if (nonzero? (-> gp-1 spec-2))
            (set! (-> gp-1 spec-2 initial-valuef) f0-2)
            )
        (if (nonzero? (-> gp-1 spec-3))
            (set! (-> gp-1 spec-3 initial-valuef) f0-2)
            )
        (if (nonzero? (-> gp-1 spec-4))
            (set! (-> gp-1 spec-4 initial-valuef) f0-2)
            )
        (if (nonzero? (-> gp-1 spec-5))
            (set! (-> gp-1 spec-5 initial-valuef) f0-2)
            )
        (if (nonzero? (-> gp-1 spec-6))
            (set! (-> gp-1 spec-6 initial-valuef) f0-2)
            )
        )
      )
    )
  0
  (none)
  )

(deftype forest-states (structure)
  ((light light-state :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(defbehavior update-mood-forest time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 0.875 0.25 2.0 0.0 1.0)
    )
  0
  (none)
  )

(deftype atoll-states (structure)
  ((light     light-state :inline :offset-assert   0)
   (explosion float               :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defun init-mood-atoll ((arg0 mood-context))
  (let ((v1-0 (the-as object (-> arg0 state))))
    (set! (-> (the-as atoll-states v1-0) explosion) 0.0)
    )
  )

(defbehavior update-mood-atoll time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s4-1 (the-as atoll-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 7 w) (-> s4-1 explosion))
      (if (not (paused?))
          (seek! (-> s4-1 explosion) 0.0 (* 2.0 (-> self clock seconds-per-frame)))
          )
      )
    )
  0
  (none)
  )

(defun set-atoll-explosion! ((arg0 float))
  (let ((v1-1 (level-get *level* 'atoll)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as atoll-states v1-2) explosion) arg0)
        )
      )
    )
  )

(defbehavior update-mood-atollext time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior-ambi arg0 #t)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (set-vector! (-> arg0 times 1) 1.0 1.0 1.0 1.0)
    (set! (-> arg0 times 2 w) 0.0)
    (set! (-> arg0 times 3 w) 0.0)
    (set! (-> arg0 times 4 w) 0.0)
    (set! (-> arg0 times 5 w) 0.0)
    (set! (-> arg0 times 6 w) 0.0)
    (set! (-> arg0 times 7 w) 0.0)
    )
  0
  (none)
  )

(deftype drill-states (structure)
  ((fire-floor      float                       :offset-assert   0)
   (fire-floor-fade float                       :offset-assert   4)
   (fire-floor-flag symbol                      :offset-assert   8)
   (flame           flames-state      :inline   :offset-assert  12)
   (electricity     electricity-state 2 :inline :offset-assert  20)
   (pulse           pulse-state       :inline   :offset         52)
   (light-flag      basic                       :offset-assert  56)
   )
  :method-count-assert 9
  :size-assert         #x3c
  :flag-assert         #x90000003c
  )


(defun init-mood-drill ((arg0 mood-context))
  (set! (-> (the-as drill-states (-> arg0 state)) light-flag) #f)
  #f
  )

(defun update-drill-lights ((arg0 mood-context))
  (let ((a1-0 (-> arg0 light-group))
        (s5-0 (-> arg0 light-group 1))
        (gp-0 (-> arg0 light-group 2))
        )
    (mem-copy! (the-as pointer s5-0) (the-as pointer a1-0) 192)
    (let ((a0-2 (new 'static 'vector :x 0.902 :y 0.675)))
      (vector+float*! (the-as vector (-> s5-0 ambi color)) (the-as vector (-> s5-0 ambi color)) a0-2 0.3)
      )
    (let ((v1-2 (-> gp-0 dir0)))
      (set! (-> v1-2 direction x) 0.0)
      (set! (-> v1-2 direction y) 1.0)
      (set! (-> v1-2 direction z) 0.0)
      (set! (-> v1-2 direction w) 1.0)
      )
    (set-vector! (-> gp-0 dir0 color) 0.3 0.3 0.35 1.0)
    (set-vector! (-> gp-0 ambi color) 0.3 0.3 0.35 1.0)
    (set! (-> gp-0 dir0 extra x) 0.5)
    (set! (-> gp-0 ambi extra x) 0.5)
    )
  0
  (none)
  )

(defbehavior update-mood-drill time-of-day-proc ((arg0 mood-context) (arg1 object) (arg2 int))
  (copy-mood-exterior-ambi arg0 #t)
  (update-drill-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as drill-states (-> arg0 state))))
      (update-mood-electricity arg0 2 20 0.75 1.0)
      (update-mood-electricity arg0 3 36 0.75 1.0)
      (set! (-> arg0 times 5 w) 1.0)
      (set! (-> arg0 times 4 w) (-> gp-1 fire-floor))
      (update-mood-flames arg0 6 1 12 0.9 0.0009765625 2.0)
      (if (and (task-node-closed? (game-task-node drill-mech-smash-consoles))
               (not (task-node-closed? (game-task-node drill-mech-resolution)))
               )
          (update-mood-pulse arg0 7 52 0.75 0.25 (* 65536.0 (-> self clock seconds-per-frame)) 16384.0)
          )
      (when (not (paused?))
        (if (-> gp-1 fire-floor-flag)
            (seek! (-> gp-1 fire-floor-fade) 1.5 (* 3.0 (-> self clock seconds-per-frame)))
            (seek! (-> gp-1 fire-floor-fade) 0.5 (* 3.0 (-> self clock seconds-per-frame)))
            )
        (set! (-> gp-1 fire-floor)
              (+ (-> gp-1 fire-floor-fade) (* (-> gp-1 fire-floor-fade) (rand-vu-float-range 0.0 0.1)))
              )
        )
      )
    )
  0
  (none)
  )

(defun set-drill-fire-floor! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'drillmid)))
    (if v1-1
        (set! (-> (the-as drill-states (-> v1-1 mood-context state)) fire-floor-flag) arg0)
        )
    )
  (let ((v1-4 (level-get *level* 'drillb)))
    (when v1-4
      (set! (-> (the-as drill-states (-> v1-4 mood-context state)) fire-floor-flag) arg0)
      arg0
      )
    )
  )

(defun set-drill-electricity-scale! ((arg0 float) (arg1 int))
  (let ((v1-1 (level-get *level* 'drill)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as drill-states v1-2) electricity arg1 scale) arg0)
        )
      )
    )
  (let ((v1-5 (level-get *level* 'drillmid)))
    (when v1-5
      (let ((v1-6 (the-as object (-> v1-5 mood-context state))))
        (set! (-> (the-as drill-states v1-6) electricity arg1 scale) arg0)
        )
      )
    )
  )

(defbehavior update-mood-drillmnt time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior-ambi arg0 #t)
  (update-drill-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 *math-camera*))
      (set! (-> arg0 times 5 w) 1.0)
      (if (not (paused?))
          (quaternion-rotate-y!
            (-> s5-1 quat-other)
            (-> s5-1 quat-other)
            (* 273.06668 (-> self clock seconds-per-frame))
            )
          )
      )
    )
  0
  (none)
  )

(deftype drillb-states (structure)
  ((fire-floor      float               :offset-assert   0)
   (fire-floor-fade float               :offset-assert   4)
   (fire-floor-flag symbol              :offset-assert   8)
   (pulse           pulse-state :inline :offset-assert  12)
   (light-flag      symbol              :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(defun init-mood-drillb ((arg0 mood-context))
  (set! (-> (the-as drillb-states (-> arg0 state)) light-flag) #f)
  #f
  )

(defbehavior update-mood-drillb time-of-day-proc ((arg0 mood-context))
  (copy-mood-exterior-ambi arg0 #f)
  (update-drill-lights arg0)
  (cond
    ((< (the-as uint 8) (the-as uint (-> *time-of-day-context* mode)))
     (palette-select-special arg0)
     )
    (else
      (let ((gp-0 (the-as drillb-states (-> arg0 state))))
        (set! (-> arg0 times 1 w) 1.0)
        (set! (-> arg0 times 4 w) (-> gp-0 fire-floor))
        (if (and (task-node-closed? (game-task-node drill-mech-smash-consoles))
                 (not (task-node-closed? (game-task-node drill-mech-resolution)))
                 )
            (update-mood-pulse arg0 7 12 0.75 0.25 (* 65536.0 (-> self clock seconds-per-frame)) 16384.0)
            )
        (when (not (paused?))
          (if (-> gp-0 fire-floor-flag)
              (seek! (-> gp-0 fire-floor-fade) 1.5 (* 3.0 (-> self clock seconds-per-frame)))
              (seek! (-> gp-0 fire-floor-fade) 0.5 (* 3.0 (-> self clock seconds-per-frame)))
              )
          (set! (-> gp-0 fire-floor)
                (+ (-> gp-0 fire-floor-fade) (* (-> gp-0 fire-floor-fade) (rand-vu-float-range 0.0 0.1)))
                )
          )
        )
      )
    )
  0
  (none)
  )

(deftype casboss-states (structure)
  ((light     light-state :inline :offset-assert   0)
   (explosion float               :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defun update-casboss-lights ((arg0 mood-context))
  (let ((s4-0 (-> arg0 light-group 1))
        (s5-0 (-> arg0 light-group 2))
        (gp-0 (-> arg0 light-group 3))
        )
    (let ((v1-0 (-> s4-0 dir0)))
      (set! (-> v1-0 direction x) 0.707)
      (set! (-> v1-0 direction y) -0.5)
      (set! (-> v1-0 direction z) 0.707)
      (set! (-> v1-0 direction w) 1.0)
      )
    (vector-normalize! (the-as vector (-> s4-0 dir0)) 1.0)
    (set-vector! (-> s4-0 dir0 color) 0.0 1.9921875 0.0 1.0)
    (set! (-> s4-0 dir0 extra x) 1.0)
    (set! (-> s4-0 ambi extra x) 0.0)
    (set-vector! (-> s5-0 ambi color) 0.3 0.3 0.5 1.0)
    (set! (-> s5-0 dir0 extra x) 0.0)
    (set! (-> s5-0 ambi extra x) 1.0)
    (let ((v1-5 (-> gp-0 dir0)))
      (set! (-> v1-5 direction x) 0.6499)
      (set! (-> v1-5 direction y) 0.7134)
      (set! (-> v1-5 direction z) 0.2619)
      (set! (-> v1-5 direction w) 1.0)
      )
    (set-vector! (-> gp-0 dir0 color) 0.65 0.575 0.575 1.0)
    (let ((v1-7 (-> gp-0 dir1)))
      (set! (-> v1-7 direction x) -0.6499)
      (set! (-> v1-7 direction y) 0.7134)
      (set! (-> v1-7 direction z) -0.2619)
      (set! (-> v1-7 direction w) 1.0)
      )
    (set-vector! (-> gp-0 dir1 color) 0.75 0.6 0.5 1.0)
    (set-vector! (-> gp-0 ambi color) 0.2 0.2 0.25 1.0)
    (set! (-> gp-0 dir0 extra x) 0.65)
    (set! (-> gp-0 dir1 extra x) 1.0)
    (set! (-> gp-0 ambi extra x) 0.7)
    )
  )

(defbehavior update-mood-casboss time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (update-casboss-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s4-1 (the-as casboss-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) 1.0)
      (set! (-> arg0 times 7 w) 0.0)
      (if (not (paused?))
          (set! (-> s4-1 explosion) (- (-> s4-1 explosion) (-> self clock seconds-per-frame)))
          )
      )
    )
  0
  (none)
  )

(defun set-casboss-explosion! ()
  (let ((v1-1 (level-get *level* 'ctywide)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as casboss-states v1-2) explosion) 1.0)
        )
      )
    )
  )

(deftype caspad-states (structure)
  ((light       light-state :inline :offset-assert   0)
   (red         float               :offset-assert   8)
   (white       float               :offset-assert  12)
   (white-count int32               :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(defbehavior update-mood-caspad time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as caspad-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (-> gp-1 red))
      (set! (-> arg0 times 7 w) (-> gp-1 white))
      (set! (-> arg0 times 5 w) 1.0)
      (when (not (paused?))
        (let* ((v1-11 (-> *display* part-clock frame-counter))
               (f0-4 (* 0.006666667 (the float (mod v1-11 150))))
               )
          (set! (-> gp-1 red) (+ 0.75 (* 0.25 (cos (* 65536.0 f0-4)))))
          )
        (when (<= (-> gp-1 white-count) 0)
          (set! (-> gp-1 white) (rand-vu-float-range 0.85 1.05))
          (set! (-> gp-1 white-count) 2)
          )
        (+! (-> gp-1 white-count) -1)
        )
      )
    )
  0
  (none)
  )

(deftype palout-states (structure)
  ((light light-state  :inline :offset-assert   0)
   (flame flames-state :inline :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xf
  :flag-assert         #x90000000f
  )


(defun init-mood-palout ((arg0 mood-context))
  (let ((v0-0 (-> *math-camera* trans-other)))
    (set! (-> v0-0 x) 760754.2)
    (set! (-> v0-0 y) 0.0)
    (set! (-> v0-0 z) 2471944.2)
    (set! (-> v0-0 w) 1.0)
    v0-0
    )
  )

(defbehavior update-mood-palout time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior-ambi arg0 #t)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
    (update-mood-flames arg0 6 2 8 0.5 0.0009765625 1.5)
    (let ((gp-1 *math-camera*))
      (if (not (paused?))
          (quaternion-rotate-y!
            (-> gp-1 quat-other)
            (-> gp-1 quat-other)
            (* 273.06668 (-> self clock seconds-per-frame))
            )
          )
      )
    )
  0
  (none)
  )

(deftype palroof-states (structure)
  ((electricity electricity-state 2 :inline :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x20
  :flag-assert         #x900000020
  )


(defun init-mood-palroof ((arg0 mood-context))
  (let ((v1-0 (the-as palroof-states (-> arg0 state))))
    (set! (-> v1-0 electricity 0 scale) 1.0)
    (set! (-> v1-0 electricity 1 scale) 1.0)
    )
  )

(defbehavior update-mood-palroof time-of-day-proc ((arg0 mood-context) (arg1 object) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (-> arg0 state)
    (set! (-> arg0 times 7 w) 1.0)
    (update-mood-electricity arg0 5 0 1.2 1.7)
    (update-mood-electricity arg0 6 16 1.2 1.7)
    )
  0
  (none)
  )

(defun set-palroof-electricity-scale! ((arg0 float) (arg1 int))
  (let ((v1-1 (level-get *level* 'palroof)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as palroof-states v1-2) electricity arg1 scale) arg0)
        )
      )
    )
  )

(deftype palent-states (structure)
  ((flame        flames-state :inline :offset-assert   0)
   (turret-value float                :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defbehavior update-mood-palent time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as palent-states (-> arg0 state))))
      (update-mood-flames arg0 6 1 0 0.75 0.00048828125 2.0)
      (set! (-> arg0 times 5 w) (-> s5-1 turret-value))
      (set! (-> arg0 times 7 w) 1.0)
      (if (not (paused?))
          (set! (-> s5-1 turret-value) (fmax 0.0 (+ -0.025 (-> s5-1 turret-value))))
          )
      )
    )
  0
  (none)
  )

(defun set-palent-turret-flash! ((arg0 float))
  (let ((v1-1 (level-get *level* 'palent)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as palent-states v1-2) turret-value) (* 0.5 arg0))
        )
      )
    )
  )

(deftype nest-states (structure)
  ((light       light-state :inline :offset-assert   0)
   (green-flag  symbol              :offset-assert   8)
   (green       float               :offset-assert  12)
   (green-noise float               :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(defun init-mood-nest ((arg0 mood-context))
  (set! (-> (the-as nest-states (-> arg0 state)) green-flag) #f)
  #f
  )

(defun update-nest-lights ((arg0 mood-context))
  (let ((a2-0 (new 'stack-no-clear 'vector4)))
    (set-vector! a2-0 0.53660715 0.26964286 1.0 1.0)
    (vector4-mul! (the-as vector4 (-> arg0 current-fog)) (the-as vector4 (-> arg0 current-fog)) a2-0)
    )
  (mem-copy! (the-as pointer (-> arg0 light-group 1)) (the-as pointer (-> arg0 light-group)) 192)
  )

(defbehavior update-mood-nest time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (update-nest-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((s5-1 (the-as nest-states (-> arg0 state))))
      (when (not (paused?))
        (cond
          ((-> s5-1 green-flag)
           (set! (-> s5-1 green) (fmin 1.9 (+ (-> s5-1 green) (* 2.0 (-> self clock seconds-per-frame)))))
           (set! (-> s5-1 green-noise) (rand-vu-float-range 0.0 (-> s5-1 green)))
           )
          (else
            (set! (-> s5-1 green) (fmax 0.0 (- (-> s5-1 green) (* 2.0 (-> self clock seconds-per-frame)))))
            (set! (-> s5-1 green-noise) 0.0)
            )
          )
        )
      (update-mood-light arg0 5 0 1.0 0.25 20.0 0.0 1.0)
      (set! (-> arg0 times 6 w) (+ (-> s5-1 green) (-> s5-1 green-noise)))
      )
    )
  0
  (none)
  )

(defun set-nest-green-flag! ((arg0 symbol))
  (let ((v1-1 (level-get *level* 'nest)))
    (when v1-1
      (set! (-> (the-as nest-states (-> v1-1 mood-context state)) green-flag) arg0)
      arg0
      )
    )
  )

(deftype village1-states (structure)
  ((interp      float   :offset-assert   0)
   (interp-flag symbol  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(defun init-mood-village1 ((arg0 mood-context))
  (let ((v1-0 (the-as village1-states (-> arg0 state))))
    (set! (-> v1-0 interp) 0.0)
    (set! (-> v1-0 interp-flag) #f)
    )
  #f
  )

(defun update-village1-lights ((arg0 mood-context))
  (let ((v1-0 (-> arg0 light-group)))
    (set! (-> v1-0 0 dir0 extra x) (* 0.5 (-> v1-0 0 dir0 extra x)))
    (set! (-> v1-0 0 dir1 extra x) (* 0.5 (-> v1-0 0 dir1 extra x)))
    (set! (-> v1-0 0 dir2 extra x) (* 0.5 (-> v1-0 0 dir2 extra x)))
    (set! (-> v1-0 0 ambi extra x) (* 0.75 (-> v1-0 0 ambi extra x)))
    )
  )

(defbehavior update-mood-village1 time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (update-village1-lights arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((gp-1 (the-as village1-states (-> arg0 state))))
      (let ((f0-0 (-> gp-1 interp)))
        (set! (-> arg0 times 6 w) (- 1.0 f0-0))
        (set! (-> arg0 times 7 w) f0-0)
        (if (!= f0-0 0.0)
            (set-filter-color! (- 1.0 (* 0.25 f0-0)) (- 1.0 (* 0.5 f0-0)) 1.0)
            )
        )
      (when (not (paused?))
        (if (-> gp-1 interp-flag)
            (seek! (-> gp-1 interp) 1.0 (* 0.5 (-> self clock seconds-per-frame)))
            )
        )
      )
    )
  0
  (none)
  )

(defbehavior update-mood-copy-village1 time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (let ((v1-1 (level-get *level* 'village1)))
    (if (and v1-1 (= (-> v1-1 status) 'active))
        (mem-copy! (the-as pointer arg0) (the-as pointer (-> v1-1 mood-context)) 1968)
        )
    )
  0
  (none)
  )

(defun clear-village1-interp! ()
  (let ((v1-1 (level-get *level* 'village1)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as village1-states v1-2) interp) 0.0)
        (set! (-> (the-as village1-states v1-2) interp-flag) #f)
        )
      #f
      )
    )
  )

(defun set-village1-interp! ()
  (let ((v1-1 (level-get *level* 'village1)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state)))
            (v0-1 #t)
            )
        (set! (-> (the-as village1-states v1-2) interp-flag) v0-1)
        v0-1
        )
      )
    )
  )

(deftype consite-states (structure)
  ((light light-state :inline :offset-assert   0)
   (flash float               :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(defbehavior update-mood-consite time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((f0-0 0.5))
      (let ((f1-0 1.0))
        (cond
          ((or (>= 6.0 arg1) (>= arg1 18.0))
           (set! f0-0 f1-0)
           )
          ((and (< 6.0 arg1) (< arg1 7.0))
           (+! f0-0 (* (- f1-0 f0-0) (- 7.0 arg1)))
           )
          ((and (< 17.0 arg1) (< arg1 18.0))
           (+! f0-0 (* (- f1-0 f0-0) (+ -17.0 arg1)))
           )
          )
        )
      (set! (-> arg0 times 7 w) f0-0)
      )
    (let ((s4-1 (the-as consite-states (-> arg0 state))))
      (update-mood-light arg0 5 0 1.0 0.0 arg1 0.0 2.0)
      (set! (-> arg0 times 6 w) (-> s4-1 flash))
      (if (not (paused?))
          (set! (-> s4-1 flash) (fmax 0.0 (- (-> s4-1 flash) (* 2.0 (-> self clock seconds-per-frame)))))
          )
      )
    )
  0
  (none)
  )

(defun set-consite-flash! ()
  (let ((v1-1 (level-get *level* 'consite)))
    (when v1-1
      (let ((v1-2 (the-as object (-> v1-1 mood-context state))))
        (set! (-> (the-as consite-states v1-2) flash) 2.0)
        )
      )
    )
  )

(deftype mincan-states (structure)
  ((beams float 2 :offset-assert   0)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(defbehavior update-mood-mincan time-of-day-proc ((arg0 mood-context) (arg1 float) (arg2 int))
  (copy-mood-exterior arg0)
  (when (and (= (-> *level* level arg2 status) 'active)
             (< (the-as uint (-> *time-of-day-context* mode)) (the-as uint 9))
             )
    (let ((v1-7 (the-as mincan-states (-> arg0 state))))
      (set! (-> arg0 times 5 w) (-> v1-7 beams 0))
      (set! (-> arg0 times 6 w) (-> v1-7 beams 1))
      )
    )
  0
  (none)
  )

(defun set-mincan-beam! ((arg0 int) (arg1 float))
  (let ((v1-1 (level-get *level* 'mincan)))
    (when v1-1
      (let ((v1-2 (-> v1-1 mood-context state)))
        (set! (-> (the-as mincan-states (+ (* arg0 4) (the-as int v1-2))) beams 0) arg1)
        )
      )
    )
  )
