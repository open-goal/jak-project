;;-*-Lisp-*-
(in-package goal)

;; name: foreground.gc
;; name in dgo: foreground
;; dgos: ENGINE, GAME

(defenum merc-mode
  :type int32
  (merc 0)
  (emerc 1)
  (mercneric 2)
  (eye 3)
  )


(def-mips2c foreground-draw-hud (function draw-control dma-buffer float none))

;; DECOMP BEGINS

(define foreground-vu0-block (new 'static 'vu-function))

(define *bucket-map* (new 'static 'array bucket-id-16 200
                       (bucket-id-16 merc-l0-tfrag)
                       (bucket-id-16 emerc-l0-tfrag)
                       (bucket-id-16 gmerc-l0-tfrag)
                       (bucket-id-16 tex-l0-tfrag)
                       (bucket-id-16 merc-l0-pris)
                       (bucket-id-16 emerc-l0-pris)
                       (bucket-id-16 gmerc-l0-pris)
                       (bucket-id-16 tex-l0-pris)
                       (bucket-id-16 merc-l0-shrub)
                       (bucket-id-16 emerc-l0-shrub)
                       (bucket-id-16 gmerc-l0-shrub)
                       (bucket-id-16 tex-l0-shrub)
                       (bucket-id-16 merc-l0-alpha)
                       (bucket-id-16 emerc-l0-alpha)
                       (bucket-id-16 gmerc-l0-alpha)
                       (bucket-id-16 tex-l0-alpha)
                       (bucket-id-16 merc-l0-water)
                       (bucket-id-16 merc-l0-water)
                       (bucket-id-16 gmerc-l0-water)
                       (bucket-id-16 tex-l0-water)
                       (bucket-id-16 merc-l0-pris)
                       (bucket-id-16 emerc-l0-pris)
                       (bucket-id-16 gmerc-l0-pris)
                       (bucket-id-16 tex-l0-pris)
                       (bucket-id-16 merc-l0-pris2)
                       (bucket-id-16 emerc-l0-pris2)
                       (bucket-id-16 gmerc-l0-pris2)
                       (bucket-id-16 tex-l0-pris2)
                       (bucket-id-16 merc-l1-tfrag)
                       (bucket-id-16 emerc-l1-tfrag)
                       (bucket-id-16 gmerc-l1-tfrag)
                       (bucket-id-16 tex-l1-tfrag)
                       (bucket-id-16 merc-l1-pris)
                       (bucket-id-16 emerc-l1-pris)
                       (bucket-id-16 gmerc-l1-pris)
                       (bucket-id-16 tex-l1-pris)
                       (bucket-id-16 merc-l1-shrub)
                       (bucket-id-16 emerc-l1-shrub)
                       (bucket-id-16 gmerc-l1-shrub)
                       (bucket-id-16 tex-l1-shrub)
                       (bucket-id-16 merc-l1-alpha)
                       (bucket-id-16 emerc-l1-alpha)
                       (bucket-id-16 gmerc-l1-alpha)
                       (bucket-id-16 tex-l1-alpha)
                       (bucket-id-16 merc-l1-water)
                       (bucket-id-16 merc-l1-water)
                       (bucket-id-16 gmerc-l1-water)
                       (bucket-id-16 tex-l1-water)
                       (bucket-id-16 merc-l1-pris)
                       (bucket-id-16 emerc-l1-pris)
                       (bucket-id-16 gmerc-l1-pris)
                       (bucket-id-16 tex-l1-pris)
                       (bucket-id-16 merc-l1-pris2)
                       (bucket-id-16 emerc-l1-pris2)
                       (bucket-id-16 gmerc-l1-pris2)
                       (bucket-id-16 tex-l1-pris2)
                       (bucket-id-16 merc-l2-tfrag)
                       (bucket-id-16 emerc-l2-tfrag)
                       (bucket-id-16 gmerc-l2-tfrag)
                       (bucket-id-16 tex-l2-tfrag)
                       (bucket-id-16 merc-l2-pris)
                       (bucket-id-16 emerc-l2-pris)
                       (bucket-id-16 gmerc-l2-pris)
                       (bucket-id-16 tex-l2-pris)
                       (bucket-id-16 merc-l2-shrub)
                       (bucket-id-16 emerc-l2-shrub)
                       (bucket-id-16 gmerc-l2-shrub)
                       (bucket-id-16 tex-l2-shrub)
                       (bucket-id-16 merc-l2-alpha)
                       (bucket-id-16 emerc-l2-alpha)
                       (bucket-id-16 gmerc-l2-alpha)
                       (bucket-id-16 tex-l2-alpha)
                       (bucket-id-16 merc-l2-water)
                       (bucket-id-16 merc-l2-water)
                       (bucket-id-16 gmerc-l2-water)
                       (bucket-id-16 tex-l2-water)
                       (bucket-id-16 merc-l2-pris)
                       (bucket-id-16 emerc-l2-pris)
                       (bucket-id-16 gmerc-l2-pris)
                       (bucket-id-16 tex-l2-pris)
                       (bucket-id-16 merc-l2-pris2)
                       (bucket-id-16 emerc-l2-pris2)
                       (bucket-id-16 gmerc-l2-pris2)
                       (bucket-id-16 tex-l2-pris2)
                       (bucket-id-16 merc-l3-tfrag)
                       (bucket-id-16 emerc-l3-tfrag)
                       (bucket-id-16 gmerc-l3-tfrag)
                       (bucket-id-16 tex-l3-tfrag)
                       (bucket-id-16 merc-l3-pris)
                       (bucket-id-16 emerc-l3-pris)
                       (bucket-id-16 gmerc-l3-pris)
                       (bucket-id-16 tex-l3-pris)
                       (bucket-id-16 merc-l3-shrub)
                       (bucket-id-16 emerc-l3-shrub)
                       (bucket-id-16 gmerc-l3-shrub)
                       (bucket-id-16 tex-l3-shrub)
                       (bucket-id-16 merc-l3-alpha)
                       (bucket-id-16 emerc-l3-alpha)
                       (bucket-id-16 gmerc-l3-alpha)
                       (bucket-id-16 tex-l3-alpha)
                       (bucket-id-16 merc-l3-water)
                       (bucket-id-16 merc-l3-water)
                       (bucket-id-16 gmerc-l3-water)
                       (bucket-id-16 tex-l3-water)
                       (bucket-id-16 merc-l3-pris)
                       (bucket-id-16 emerc-l3-pris)
                       (bucket-id-16 gmerc-l3-pris)
                       (bucket-id-16 tex-l3-pris)
                       (bucket-id-16 merc-l3-pris2)
                       (bucket-id-16 emerc-l3-pris2)
                       (bucket-id-16 gmerc-l3-pris2)
                       (bucket-id-16 tex-l3-pris2)
                       (bucket-id-16 merc-l4-tfrag)
                       (bucket-id-16 emerc-l4-tfrag)
                       (bucket-id-16 gmerc-l4-tfrag)
                       (bucket-id-16 tex-l4-tfrag)
                       (bucket-id-16 merc-l4-pris)
                       (bucket-id-16 emerc-l4-pris)
                       (bucket-id-16 gmerc-l4-pris)
                       (bucket-id-16 tex-l4-pris)
                       (bucket-id-16 merc-l4-shrub)
                       (bucket-id-16 emerc-l4-shrub)
                       (bucket-id-16 gmerc-l4-shrub)
                       (bucket-id-16 tex-l4-shrub)
                       (bucket-id-16 merc-l4-alpha)
                       (bucket-id-16 emerc-l4-alpha)
                       (bucket-id-16 gmerc-l4-alpha)
                       (bucket-id-16 tex-l4-alpha)
                       (bucket-id-16 merc-l4-water)
                       (bucket-id-16 merc-l4-water)
                       (bucket-id-16 gmerc-l4-water)
                       (bucket-id-16 tex-l4-water)
                       (bucket-id-16 merc-l4-pris)
                       (bucket-id-16 emerc-l4-pris)
                       (bucket-id-16 gmerc-l4-pris)
                       (bucket-id-16 tex-l4-pris)
                       (bucket-id-16 merc-l4-pris2)
                       (bucket-id-16 emerc-l4-pris2)
                       (bucket-id-16 gmerc-l4-pris2)
                       (bucket-id-16 tex-l4-pris2)
                       (bucket-id-16 merc-l5-tfrag)
                       (bucket-id-16 emerc-l5-tfrag)
                       (bucket-id-16 gmerc-l5-tfrag)
                       (bucket-id-16 tex-l5-tfrag)
                       (bucket-id-16 merc-l5-pris)
                       (bucket-id-16 emerc-l5-pris)
                       (bucket-id-16 gmerc-l5-pris)
                       (bucket-id-16 tex-l5-pris)
                       (bucket-id-16 merc-l5-shrub)
                       (bucket-id-16 emerc-l5-shrub)
                       (bucket-id-16 gmerc-l5-shrub)
                       (bucket-id-16 tex-l5-shrub)
                       (bucket-id-16 merc-l5-alpha)
                       (bucket-id-16 emerc-l5-alpha)
                       (bucket-id-16 gmerc-l5-alpha)
                       (bucket-id-16 tex-l5-alpha)
                       (bucket-id-16 merc-l5-water)
                       (bucket-id-16 merc-l5-water)
                       (bucket-id-16 gmerc-l5-water)
                       (bucket-id-16 tex-l5-water)
                       (bucket-id-16 merc-l5-pris)
                       (bucket-id-16 emerc-l5-pris)
                       (bucket-id-16 gmerc-l5-pris)
                       (bucket-id-16 tex-l5-pris)
                       (bucket-id-16 merc-l5-pris2)
                       (bucket-id-16 emerc-l5-pris2)
                       (bucket-id-16 gmerc-l5-pris2)
                       (bucket-id-16 tex-l5-pris2)
                       (bucket-id-16 merc-lcom-tfrag)
                       (bucket-id-16 emerc-lcom-tfrag)
                       (bucket-id-16 gmerc-lcom-tfrag)
                       (bucket-id-16 tex-lcom-tfrag)
                       (bucket-id-16 merc-lcom-pris)
                       (bucket-id-16 emerc-lcom-pris)
                       (bucket-id-16 gmerc-lcom-pris)
                       (bucket-id-16 tex-lcom-pris)
                       (bucket-id-16 merc-lcom-shrub)
                       (bucket-id-16 emerc-lcom-shrub)
                       (bucket-id-16 gmerc-lcom-shrub)
                       (bucket-id-16 tex-lcom-shrub)
                       (bucket-id-16 merc-lcom-pris)
                       (bucket-id-16 emerc-lcom-pris)
                       (bucket-id-16 gmerc-lcom-pris)
                       (bucket-id-16 tex-lcom-pris)
                       (bucket-id-16 merc-lcom-water)
                       (bucket-id-16 merc-lcom-water)
                       (bucket-id-16 gmerc-lcom-water)
                       (bucket-id-16 tex-lcom-water)
                       (bucket-id-16 merc-lcom-pris)
                       (bucket-id-16 emerc-lcom-pris)
                       (bucket-id-16 gmerc-lcom-pris)
                       (bucket-id-16 tex-lcom-pris)
                       (bucket-id-16 merc-lcom-pris2)
                       (bucket-id-16 emerc-lcom-pris2)
                       (bucket-id-16 gmerc-lcom-pris2)
                       (bucket-id-16 tex-lcom-pris2)
                       (bucket-id-16 bucket-0)
                       (bucket-id-16 bucket-0)
                       (bucket-id-16 bucket-0)
                       (bucket-id-16 bucket-0)
                       )
        )

(defun vu1-bucket-map ((arg0 int) (arg1 int) (arg2 merc-mode))
  "level, tex, mode -> bucket."
  (the-as bucket-id (-> *bucket-map* (+ (+ (* 28 arg0) (* arg1 4)) (the-as int arg2))))
  )

(defun generic-bucket-state-init ((arg0 generic-bucket-state))
  "Generic buckets double buffer across models and store their state in generic-bucket-state.
   Reset a state for the first transfer"
  (set! (-> arg0 gifbuf-adr) (the-as uint 837))
  (set! (-> arg0 inbuf-adr) (the-as uint 9))
  (none)
  )

(defun mercneric-chain-init ((arg0 mercneric-chain) (arg1 bucket-id))
  "Initialize a mercneric chain. (generic chain specific to merc)"
  (set! (-> arg0 first) (the-as uint 0))
  (set! (-> arg0 next) (the-as uint 0))
  (set! (-> arg0 vu1-bucket) arg1)
  (generic-bucket-state-init (-> arg0 state))
  (none)
  )

(defun foreground-init ()
  (let ((gp-0 (scratchpad-object foreground-work)))
    (vu-lights-default! *default-lights*)
    ;; upload foreground vu0.
    ; (let ((s5-0 *vu0-dma-list*))
    ;   (let ((v1-1 s5-0))
    ;     (set! (-> v1-1 base) (-> v1-1 data))
    ;     (set! (-> v1-1 end) (&-> v1-1 data-buffer (-> v1-1 allocated-length)))
    ;     )
    ;   (dma-buffer-add-vu-function s5-0 foreground-vu0-block 0)
    ;   (let* ((v1-2 s5-0)
    ;          (a0-6 (the-as object (-> v1-2 base)))
    ;          )
    ;     (set! (-> (the-as dma-packet a0-6) dma) (new 'static 'dma-tag :id (dma-tag-id end)))
    ;     (set! (-> (the-as (pointer uint64) a0-6) 1) (the-as uint 0))
    ;     (set! (-> v1-2 base) (&+ (the-as pointer a0-6) 16))
    ;     )
    ;   (.sync.l)
    ;   (dma-buffer-send-chain (the-as dma-bank-source #x10008000) s5-0)
    ;   )
    ;; set up templates
    (set! (-> gp-0 next-tmpl dma) (new 'static 'dma-tag :id (dma-tag-id next)))
    (set! (-> gp-0 next-tmpl vif0) (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl)))
    (set! (-> gp-0 next-tmpl vif1) (new 'static 'vif-tag :imm #x404 :cmd (vif-cmd stcycl)))

    ;; stash drawing map
    (let ((v1-7 *level*))
      (dotimes (a0-9 LEVEL_TOTAL)
        (set! (-> gp-0 draw-index-map a0-9) (-> v1-7 draw-index-map a0-9))
        )
      )

    ;; bucket lookups, set up chains.
    (dotimes (s5-1 LEVEL_TOTAL)
      (let ((s4-0 (-> gp-0 grid level-buckets s5-1)))
        (dotimes (s3-0 7)
          (let ((s1-0 (-> s4-0 data s3-0)))
            (set! (-> s1-0 merc first) (the-as dma-packet 0))
            (set! (-> s1-0 merc patch) (the-as dma-packet 0))
            (set! (-> s1-0 merc vu1-bucket) (vu1-bucket-map s5-1 s3-0 (merc-mode merc)))
            (set! (-> s1-0 emerc first) (the-as dma-packet 0))
            (set! (-> s1-0 emerc patch) (the-as dma-packet 0))
            (set! (-> s1-0 emerc vu1-bucket) (vu1-bucket-map s5-1 s3-0 (merc-mode emerc)))
            (mercneric-chain-init (-> s1-0 mercneric) (vu1-bucket-map s5-1 s3-0 (merc-mode mercneric)))
            )
          )
        )
      )
    ;; warp chain init.
    (mercneric-chain-init (-> gp-0 grid warp-chain) (bucket-id gmerc-warp))
    )
  (none)
  )

(defun texscroll-make-request ((arg0 merc-effect))
  (with-pp
    (let* ((v1-1 (-> *foreground* texscroll requests))
           (a1-0 (the-as structure (-> arg0 extra-info)))
           (a1-1 (the-as
                   mei-texture-scroll
                   (+ (the-as uint a1-0) (* (-> (the-as merc-extra-info a1-0) texture-scroll-offset) 16))
                   )
                 )
           )
      (when (< v1-1 32)
        (let* ((a3-1 (the-as int (-> pp clock integral-frame-counter)))
               (a2-3 (-> a1-1 time-factor))
               (t0-2 (+ (ash 1 a2-3) -1))
               )
          (if (zero? (-> a1-1 scroll-dir))
              (set! a3-1 (- a3-1))
              )
          (let ((a2-5 (ash (ash (logand a3-1 t0-2) (- 12 (the-as int (-> a1-1 st-int-scale)))) (- (the-as int a2-3)))))
            (when (!= a2-5 (-> a1-1 cached-time))
              (set! (-> a1-1 time-delta) (the-as uint (- a2-5 (the-as int (-> a1-1 cached-time)))))
              (set! (-> a1-1 cached-time) (the-as uint a2-5))
              (set! (-> *foreground* texscroll effects v1-1) arg0)
              (+! (-> *foreground* texscroll requests) 1)
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

(defun texscroll-execute ()
  (dotimes (v1-0 (-> *foreground* texscroll requests))
    (let* ((a2-0 (-> *foreground* texscroll effects v1-0))
           (a0-2 (-> a2-0 frag-count))
           (a1-1 (the-as structure (-> a2-0 extra-info)))
           (a1-2 (the-as
                   mei-texture-scroll
                   (+ (the-as uint a1-1) (* (-> (the-as merc-extra-info a1-1) texture-scroll-offset) 16))
                   )
                 )
           (t1-0 (the-as object (-> a2-0 frag-geo)))
           (a2-1 (the-as object (-> a2-0 frag-ctrl)))
           )
      (dotimes (a3-2 (the-as int a0-2))
        (let ((t0-4 (&+
                      (the-as pointer t1-0)
                      (logand (* (+ (-> (the-as merc-fragment-control a2-1) unsigned-four-count) 3) 4) #xfff0)
                      )
                    )
              )
          (let ((t2-2 (+ (-> (the-as merc-fragment t1-0) header mat1-cnt)
                         (-> (the-as merc-fragment t1-0) header mat2-cnt)
                         (-> (the-as merc-fragment t1-0) header mat3-cnt)
                         )
                      )
                )
            (-> a1-2 time-delta)
            (let* ((t1-3 (&+ t0-4 9))
                   (t2-4 (&+ t1-3 (* (the-as uint 12) t2-2)))
                   (t3-3 (-> a1-2 time-delta))
                   )
              (nop!)
              (label cfg-3)
              (let ((t4-0 (-> (the-as (pointer int8) t1-3))))
                (nop!)
                (nop!)
                (nop!)
                (let ((t4-1 (+ t4-0 t3-3)))
                  (&+! t1-3 12)
                  (b! (!= (the-as (pointer int8) t1-3) t2-4) cfg-3 :delay (set! (-> (the-as (pointer int8) t1-3) -12) t4-1))
                  )
                )
              )
            )
          (set! t1-0 (&+
                       (&+ t0-4 (logand (* (+ (-> (the-as merc-fragment-control a2-1) lump-four-count) 3) 4) #xfff0))
                       (* (-> (the-as merc-fragment-control a2-1) fp-qwc) 16)
                       )
                )
          )
        (set! a2-1 (+ (the-as int a2-1) (* (-> (the-as merc-fragment-control a2-1) mat-xfer-count) 2) 4))
        )
      )
    )
  (set! (-> *foreground* texscroll requests) 0)
  0
  (none)
  )

(defun vu-lights<-light-group! ((arg0 vu-lights) (arg1 light-group))
  (local-vars (v1-0 uint128) (v1-1 uint128) (a2-1 uint128) (t0-1 uint128) (t1-1 uint128))
  (rlet ((vf0 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (nop!)
    ;; ????????
    (let ((a3-0 (the-as uint128 (new 'static 'vector :x 1.0 :y 1.0 :z 1.0 :w 1.0))))
      (nop!)
      (let ((a2-0 (-> arg1 dir0 direction quad)))   ;; a2-0 = l0.dir
        (nop!)
        (let ((t1-0 (-> arg1 dir1 direction quad))) ;; t1-0 = l1.dir
          (nop!)
          (.lvf vf4 (&-> arg1 dir0 color quad))     ;; vf4 = l0.col
          (.pextlw v1-0 t1-0 a2-0)                  ;;
          (let ((t0-0 (-> arg1 dir2 direction quad)))
            (.pextuw a2-1 t1-0 a2-0)
            (.lvf vf8 (&-> arg1 dir0 extra quad))
            (.pextlw t1-1 a3-0 t0-0)
            (.lvf vf5 (&-> arg1 dir1 color quad))
            (.pextuw t0-1 a3-0 t0-0)
            )
          )
        )
      )
    (.lvf vf9 (&-> arg1 dir1 extra quad))
    (let ((a3-1 (the uint128 (make-u128 t1-1 v1-0))))
      (.lvf vf6 (&-> arg1 dir2 color quad))
      (.pcpyud v1-1 v1-0 t1-1)
      (.lvf vf10 (&-> arg1 dir2 extra quad))
      (let ((a2-2 (the uint128 (make-u128 t0-1 a2-1))))
        (.lvf vf7 (&-> arg1 ambi color quad))
        (.mul.x.vf vf4 vf4 vf8)
        (.lvf vf11 (&-> arg1 ambi extra quad))
        (.mul.x.vf vf5 vf5 vf9)
        (set! (-> arg0 direction 0 quad) (the-as uint128 a3-1))
        (.mul.x.vf vf6 vf6 vf10)
        (set! (-> arg0 direction 1 quad) v1-1)
        (.mul.x.vf vf7 vf7 vf11)
        (set! (-> arg0 direction 2 quad) (the-as uint128 a2-2))
        )
      )
    (.min.x.vf vf4 vf0 vf0 :mask #b1000)
    (nop!)
    (.min.x.vf vf5 vf0 vf0 :mask #b1000)
    (nop!)
    (.min.x.vf vf6 vf0 vf0 :mask #b1000)
    (nop!)
    (.max.w.vf vf7 vf0 vf0 :mask #b1000)
    (nop!)
    (nop!)
    (.svf (&-> arg0 color 0 quad) vf4)
    (nop!)
    (.svf (&-> arg0 color 1 quad) vf5)
    (nop!)
    (.svf (&-> arg0 color 2 quad) vf6)
    (nop!)
    (.svf (&-> arg0 ambient quad) vf7)
    0
    (none)
    )
  )

(defun foreground-add-mtx-calc ((arg0 bone-calculation) (arg1 (inline-array pris-mtx)) (arg2 bone-calc-flags))
  (let ((t2-0 (-> (scratchpad-object foreground-work) regs))
        (v1-1 *bone-calculation-list*)
        (a3-0 arg0)
        )
    (let ((t0-0 (-> t2-0 joint-ptr))
          (t1-0 (-> t2-0 bone-ptr))
          (t2-1 (-> t2-0 num-bones))
          (t3-0 a3-0)
          )
      (set! (-> t3-0 flags) arg2)
      (set! (-> t3-0 num-bones) t2-1)
      (set! (-> t3-0 matrix-area) arg1)
      (set! (-> t3-0 joints) t0-0)
      (set! (-> t3-0 bones) t1-0)
      (set! (-> t3-0 next) (the-as bone-calculation 0))
      )
    (if (nonzero? (-> v1-1 next))
        (set! (-> v1-1 next next) a3-0)
        )
    (if (zero? (-> v1-1 first))
        (set! (-> v1-1 first) a3-0)
        )
    (set! (-> v1-1 next) a3-0)
    )
  (&+ arg0 48)
  )

(defun foreground-wrapup ()
  (let ((gp-0 (scratchpad-object foreground-work)))
    (dotimes (s5-0 LEVEL_TOTAL)
      (let ((s4-0 (-> gp-0 grid level-buckets s5-0)))
        (dotimes (s3-0 7)
          (let ((s2-0 (-> s4-0 data s3-0)))
            (when (nonzero? (-> s2-0 merc first))
              (let* ((v1-9 (-> gp-0 regs dma-buf))
                     (a3-0 (-> v1-9 base))
                     )
                (let ((a0-0 (-> s2-0 merc patch)))
                  (if (nonzero? a0-0)
                      (set! (-> a0-0 dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (the-as int a3-0)))
                      )
                  )
                (let ((a0-1 (the-as dma-packet (-> v1-9 base))))
                  (set! (-> a0-1 dma) (new 'static 'dma-tag :id (dma-tag-id next)))
                  (set! (-> a0-1 vif0) (new 'static 'vif-tag))
                  (set! (-> a0-1 vif1) (new 'static 'vif-tag))
                  (set! (-> v1-9 base) (the-as pointer (&+ a0-1 16)))
                  )
                (dma-bucket-insert-tag
                  (-> *display* frames (-> *display* on-screen) bucket-group)
                  (-> s2-0 merc vu1-bucket)
                  (the-as pointer (-> s2-0 merc first))
                  (the-as (pointer dma-tag) a3-0)
                  )
                )
              )
            (when (nonzero? (-> s2-0 emerc first))
              (let* ((v1-18 (-> gp-0 regs dma-buf))
                     (a3-1 (-> v1-18 base))
                     )
                (let ((a0-5 (-> s2-0 emerc patch)))
                  (if (nonzero? a0-5)
                      (set! (-> a0-5 dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (the-as int a3-1)))
                      )
                  )
                (let ((a0-6 (the-as object (-> v1-18 base))))
                  (set! (-> (the-as dma-packet a0-6) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
                  (set! (-> (the-as dma-packet a0-6) vif0) (new 'static 'vif-tag))
                  (set! (-> (the-as dma-packet a0-6) vif1) (new 'static 'vif-tag))
                  (set! (-> v1-18 base) (&+ (the-as pointer a0-6) 16))
                  )
                (dma-bucket-insert-tag
                  (-> *display* frames (-> *display* on-screen) bucket-group)
                  (-> s2-0 emerc vu1-bucket)
                  (the-as pointer (-> s2-0 emerc first))
                  (the-as (pointer dma-tag) a3-1)
                  )
                )
              )
            )
          )
        )
      )
    (quad-copy! (the-as pointer (-> *foreground* foreground-grid)) (the-as pointer (-> gp-0 grid)) 149)
    )
  0
  (none)
  )

(define *default-shadow-settings* (new 'static 'shadow-settings
                                    :shadow-dir (new 'static 'vector :x -0.4226 :y -0.9063 :w 409600.0)
                                    :bot-plane (new 'static 'plane :y 1.0 :w 37683.2)
                                    :top-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                    :fade-dist 409600.0
                                    )
        )

;; todo foreground-shadow
;;(define-extern foreground-shadow (function draw-control (inline-array pris-mtx) pointer pointer))
(defun foreground-shadow ((draw-ctrl draw-control) (arg1 (inline-array pris-mtx)) (arg2 pointer))
  (local-vars (shadow-settings shadow-settings))
  (let ((shadow-geo (-> draw-ctrl shadow))
        (dist (-> (scratchpad-object foreground-work) distance w))
        )
    (set! shadow-settings
          (cond
            ((-> draw-ctrl shadow-ctrl)
             (set! shadow-settings (-> draw-ctrl shadow-ctrl settings))
             (let ((t1-2 (the-as vector (+ (the-as uint (the-as vector (-> draw-ctrl skeleton bones 0 transform trans)))
                                           (* (the-as uint 80) (-> draw-ctrl shadow-joint-index))
                                           )
                                 )
                         )
                   )
               (set! (-> shadow-settings center x) (-> t1-2 x))
               (set! (-> shadow-settings center y) (-> t1-2 y))
               (set! (-> shadow-settings center z) (-> t1-2 z))
               )
             shadow-settings
             )
            (else
              *default-shadow-settings*
              )
            )
          )
    (let ((t1-5 (-> shadow-settings flags)))
      (-> draw-ctrl cur-lod)
      (when (not (logtest? t1-5 (shadow-flags disable-fade)))
        (if (< (-> shadow-settings fade-dist) dist)
            (set! t1-5 (logior t1-5 (shadow-flags disable-draw)))
            )
        )
      (when (not (logtest? t1-5 (shadow-flags disable-draw)))
        (cond
          ((zero? (-> shadow-geo version))
           (let ((t1-6 (* (-> shadow-geo num-joints) 8))
                 (t2-5 (&-> shadow-geo total-qwc))
                 (t4-0 (-> shadow-geo total-qwc))
                 )
             0
             (let ((a3-2 (the-as object arg2)))
               (set! (-> (the-as shadow-dma-packet a3-2) tag dma) (new 'static 'dma-tag :qwc #x5 :id (dma-tag-id cnt)))
               (set! (-> (the-as shadow-dma-packet a3-2) tag vif0) (the-as vif-tag t4-0))
               (set! (-> (the-as shadow-dma-packet a3-2) tag vif1) (new 'static 'vif-tag))
               (let ((t0-11 (-> *shadow-globals* bucket (-> shadow-settings shadow-type))))
                 (let ((t3-2 (-> t0-11 next)))
                   (if (nonzero? t3-2)
                       (set! (-> (the-as (pointer shadow-dma-packet) t3-2) 0) (the-as shadow-dma-packet a3-2))
                       )
                   )
                 (if (zero? (-> t0-11 first))
                     (set! (-> t0-11 first) (the-as pointer a3-2))
                     )
                 (let ((t3-7 (&-> (the-as shadow-dma-packet a3-2) tag vif1)))
                   (let ((t5-1 (the-as object (-> (the-as shadow-dma-packet a3-2) settings)))
                         (t6-0 (-> shadow-settings center quad))
                         (t7-0 (-> shadow-settings shadow-dir quad))
                         (t8-0 (-> shadow-settings bot-plane quad))
                         (t9-0 (-> shadow-settings top-plane quad))
                         (v1-4 (-> shadow-settings flag-vector quad))
                         )
                     (set! (-> (the-as (inline-array vector) t5-1) 0 quad) t6-0)
                     (set! (-> (the-as (inline-array vector) t5-1) 1 quad) t7-0)
                     (set! (-> (the-as (inline-array vector) t5-1) 2 quad) t8-0)
                     (set! (-> (the-as (inline-array vector) t5-1) 3 quad) t9-0)
                     (set! (-> (the-as (inline-array vector) t5-1) 4 quad) v1-4)
                     )
                   (let ((v1-7
                           (the-as
                             vector
                             (+ (the-as uint (the-as vector (-> draw-ctrl skeleton bones 0 transform trans)))
                                (* (the-as uint 80) (-> draw-ctrl shadow-joint-index))
                                )
                             )
                           )
                         )
                     (set! (-> (the-as shadow-dma-packet a3-2) settings center x) (-> v1-7 x))
                     (set! (-> (the-as shadow-dma-packet a3-2) settings center y) (-> v1-7 y))
                     (set! (-> (the-as shadow-dma-packet a3-2) settings center z) (-> v1-7 z))
                     )
                   (set! (-> (the-as shadow-dma-packet a3-2) geo-ref dma)
                         (new 'static 'dma-tag :id (dma-tag-id ref) :addr (the-as int t2-5) :qwc t4-0)
                         )
                   (set! (-> (the-as shadow-dma-packet a3-2) geo-ref vif0) (new 'static 'vif-tag))
                   (set! (-> (the-as shadow-dma-packet a3-2) geo-ref vif1) (new 'static 'vif-tag))
                   (set! (-> (the-as shadow-dma-packet a3-2) mtx-ref dma)
                         (new 'static 'dma-tag :id (dma-tag-id ref) :addr (the-as int (-> arg1 2)) :qwc t1-6)
                         )
                   (set! (-> (the-as shadow-dma-packet a3-2) mtx-ref vif0) (new 'static 'vif-tag))
                   (set! (-> (the-as shadow-dma-packet a3-2) mtx-ref vif1) (new 'static 'vif-tag))
                   (set! (-> (the-as shadow-dma-packet a3-2) end-tag dma) (new 'static 'dma-tag :id (dma-tag-id end)))
                   (set! (-> (the-as shadow-dma-packet a3-2) end-tag vif0) (new 'static 'vif-tag))
                   (set! (-> (the-as shadow-dma-packet a3-2) end-tag vif1) (new 'static 'vif-tag))
                   (set! arg2 (&+ arg2 144))
                   (set! (-> t0-11 next) t3-7)
                   )
                 )
               )
             )
           )
          (else
            (let ((t0-13 (* (-> shadow-geo num-joints) 8)))
              (dotimes (t1-7 (the-as int (-> shadow-geo num-fragments)))
                (let ((t4-1 (-> shadow-geo frags t1-7 header))
                      (t6-1 (-> shadow-geo frags t1-7 qwc))
                      )
                  0
                  (let ((t2-11 (the-as object arg2)))
                    (set! (-> (the-as shadow-dma-packet t2-11) tag dma) (new 'static 'dma-tag :qwc #x5 :id (dma-tag-id cnt)))
                    (set! (-> (the-as shadow-dma-packet t2-11) tag vif0) (the-as vif-tag t6-1))
                    (set! (-> (the-as shadow-dma-packet t2-11) tag vif1) (new 'static 'vif-tag))
                    (let ((t3-12 (-> *shadow-globals* bucket (-> shadow-settings shadow-type))))
                      (let ((t5-4 (-> t3-12 next)))
                        (if (nonzero? t5-4)
                            (set! (-> (the-as (pointer shadow-dma-packet) t5-4) 0) (the-as shadow-dma-packet t2-11))
                            )
                        )
                      (if (zero? (-> t3-12 first))
                          (set! (-> t3-12 first) (the-as pointer t2-11))
                          )
                      (let ((t5-9 (&-> (the-as shadow-dma-packet t2-11) tag vif1)))
                        (let ((t7-2 (the-as object (-> (the-as shadow-dma-packet t2-11) settings)))
                              (t8-1 (-> shadow-settings center quad))
                              (t9-1 (-> shadow-settings shadow-dir quad))
                              (plane (-> shadow-settings bot-plane quad)) ; (.lq ra-0 32 shadow-settings)
                              )
                          (let ((gp-0 (-> shadow-settings top-plane quad))
                                (s5-0 (-> shadow-settings flag-vector quad))
                                )
                            (set! (-> (the-as (inline-array vector) t7-2) 0 quad) t8-1)
                            (set! (-> (the-as (inline-array vector) t7-2) 1 quad) t9-1)
                            (set! (-> (the-as (inline-array vector) t7-2) 2 quad) plane) ; (the-as uint128 ra-0)
                            (set! (-> (the-as (inline-array vector) t7-2) 3 quad) gp-0)
                            (set! (-> (the-as (inline-array vector) t7-2) 4 quad) s5-0)
                            )
                          )
                        (let ((t7-5
                                (the-as
                                  vector
                                  (+ (the-as uint (the-as vector (-> draw-ctrl skeleton bones 0 transform trans)))
                                     (* (the-as uint 80) (-> draw-ctrl shadow-joint-index))
                                     )
                                  )
                                )
                              )
                          (set! (-> (the-as shadow-dma-packet t2-11) settings center x) (-> t7-5 x))
                          (set! (-> (the-as shadow-dma-packet t2-11) settings center y) (-> t7-5 y))
                          (set! (-> (the-as shadow-dma-packet t2-11) settings center z) (-> t7-5 z))
                          )
                        (set! (-> (the-as shadow-dma-packet t2-11) geo-ref dma)
                              (new 'static 'dma-tag :id (dma-tag-id ref) :addr (the-as int t4-1) :qwc t6-1)
                              )
                        (set! (-> (the-as shadow-dma-packet t2-11) geo-ref vif0) (new 'static 'vif-tag))
                        (set! (-> (the-as shadow-dma-packet t2-11) geo-ref vif1) (new 'static 'vif-tag))
                        (set! (-> (the-as shadow-dma-packet t2-11) mtx-ref dma)
                              (new 'static 'dma-tag :id (dma-tag-id ref) :addr (the-as int (-> arg1 2)) :qwc t0-13)
                              )
                        (set! (-> (the-as shadow-dma-packet t2-11) mtx-ref vif0) (new 'static 'vif-tag))
                        (set! (-> (the-as shadow-dma-packet t2-11) mtx-ref vif1) (new 'static 'vif-tag))
                        (set! (-> (the-as shadow-dma-packet t2-11) end-tag dma) (new 'static 'dma-tag :id (dma-tag-id end)))
                        (set! (-> (the-as shadow-dma-packet t2-11) end-tag vif0) (new 'static 'vif-tag))
                        (set! (-> (the-as shadow-dma-packet t2-11) end-tag vif1) (new 'static 'vif-tag))
                        (&+! arg2 144)
                        (set! (-> t3-12 next) t5-9)
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  arg2
  )

(defun foreground-generic-merc-death ((arg0 draw-control) (arg1 generic-merc-ctrl))
  "Modify a generic-merc-ctrl to set up merc-death effect."

  ;; possibly disable drawing if requested
  (when (and (>= (the-as int (- (-> arg0 death-timer-org) (-> arg0 death-timer)))
                 (the-as int (-> arg0 death-draw-overlap))
                 )
             (!= (-> arg0 death-draw-overlap) 255)
             )
    (set! (-> arg1 header display-triangles) (the-as uint 0))
    0
    )

  ;; update the vertices that we're querying.
  (when (not (paused?))
    (let ((v1-6 (+ (-> arg0 death-vertex-skip) (rand-vu-int-count (the-as int (-> arg0 death-vertex-skip))))))
      (set! (-> arg1 header death-vertex-skip) v1-6)
      (set! (-> arg1 header death-effect) (-> arg0 death-effect))
      (set! (-> arg1 header death-start-vertex)
            (/ (* v1-6 (- (-> arg0 death-timer-org) (-> arg0 death-timer))) (-> arg0 death-timer-org))
            )
      )
    )
  (none)
  )

(defun foreground-generic-merc-add-fragments ((arg0 merc-effect) (arg1 pointer) (arg2 mercneric-chain))
  "Add fragments from a merc-effect to the generic chain."
  (let ((v1-0 (-> arg0 frag-geo))
        (a3-0 (the-as structure (-> arg0 frag-ctrl)))
        (a0-1 (-> arg0 frag-count))
        )

    ;; loop over fragments, adding matrix refs.
    (dotimes (t0-0 (the-as int a0-1))
      (let ((t1-2 (+ (* (-> (the-as merc-fragment-control a3-0) mat-xfer-count) 2) 4))
            (t2-0 (-> v1-0 header mm-quadword-size))
            )
        (set! (-> (the-as dma-packet arg1) dma)
              (new 'static 'dma-tag :id (dma-tag-id ref) :addr (the-as int v1-0) :qwc t2-0)
              )
        (set! (-> (the-as dma-packet arg1) vif0) (new 'static 'vif-tag))
        (set! (-> (the-as dma-packet arg1) vif1) (new 'static 'vif-tag))
        (when (nonzero? t0-0)
          (set! (-> (the-as (pointer int32) (-> arg2 next)) 0) (the-as int arg1))
          (set! (-> arg2 next) (the-as uint (&+ arg1 12)))
          )
        (let ((a1-1 (the-as object (&+ arg1 16))))
          (dotimes (t3-6 (the-as int (-> (the-as merc-fragment-control a3-0) mat-xfer-count)))
            (let ((t5-4
                    (-> (scratchpad-object foreground-work)
                        regs
                        mtxs
                        (-> (the-as merc-fragment-control a3-0) mat-dest-data t3-6 matrix-number)
                        )
                    )
                  )
              (set! (-> (the-as dma-packet a1-1) dma)
                    (new 'static 'dma-tag :qwc #x7 :id (dma-tag-id ref) :addr (the-as int t5-4))
                    )
              )
            (set! (-> (the-as dma-packet a1-1) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a1-1) vif1) (new 'static 'vif-tag))
            (set! a1-1 (&+ (the-as pointer a1-1) 16))
            )
          (set! (-> (the-as dma-packet a1-1) dma) (new 'static 'dma-tag :id (dma-tag-id end)))
          (set! (-> (the-as dma-packet a1-1) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet a1-1) vif1) (new 'static 'vif-tag))
          (set! arg1 (&+ (the-as pointer a1-1) 16))
          )
        (set! a3-0 (&+ a3-0 t1-2))
        (set! v1-0 (the-as merc-fragment (+ (the-as uint v1-0) (* t2-0 16))))
        )
      )
    )
  arg1
  )

(def-mips2c foreground-generic-merc (function draw-control pointer int pointer))

(def-mips2c foreground-merc (function draw-control (inline-array pris-mtx) pointer int int object pointer))

(define-extern foreground-emerc (function draw-control (inline-array pris-mtx) pointer object int int pointer))

;; todo foreground-emerc
(defun foreground-emerc ((arg0 draw-control) (arg1 (inline-array pris-mtx)) (arg2 pointer) (arg3 object) (arg4 int) (arg5 int))
  arg2
  )

(def-mips2c foreground-check-longest-edge-asm (function draw-control float symbol))

(defun foreground-ripple ((arg0 draw-control) (arg1 merc-ctrl) (arg2 pointer) (arg3 int))
  (local-vars (v1-6 uint) (t0-0 pointer))
  (let* ((gp-0 (-> arg0 ripple))
         (f0-0 (-> (scratchpad-object foreground-work) regs dist))
         (f1-3 (/ (- (-> gp-0 far-fade-dist) f0-0) (- (-> gp-0 far-fade-dist) (-> gp-0 close-fade-dist))))
         (f1-5 (fmax 0.0 (fmin 1.0 f1-3)))
         (f0-3 f1-5)
         (f30-0 (* f1-5 (-> gp-0 global-scale)))
         )
    (set! (-> gp-0 faded-scale) f30-0)
    (let ((f1-8 (/ f30-0 (* 128.0 (-> arg1 header xyz-scale)))))
      0
      (let ((v1-5 (-> (scratchpad-object foreground-work) regs num-bones)))
        ;;(.sll v1-6 v1-5 7)
        (set! v1-6 (shl v1-5 7))
        )

      (let ((a0-1 (scratchpad-object foreground-work)))
        ;;(.addu t0-0 arg2 v1-6)
        (set! t0-0 (&+ arg2 v1-6))
        (let ((v1-7 arg2)
              (s5-0 t0-0)
              )
          (set! (-> a0-1 regs mtxs) (the-as (inline-array pris-mtx) v1-7))
          (let ((a0-3 (-> *bone-calculation-list* next)))
            (logior! (-> a0-3 flags) (bone-calc-flags write-ripple-data))
            (set! (-> a0-3 ripple-scale) f30-0)
            (set! (-> a0-3 ripple-y-scale) f1-8)
            (set! (-> a0-3 ripple-normal-scale) (* f0-3 (-> gp-0 individual-normal-scale)))
            (set! (-> a0-3 ripple-area) (the-as (inline-array vector) v1-7))
            )
          (if (not (and (= f30-0 0.0) (= (-> gp-0 last-frame-scale) 0.0)))
              (ripple-make-request (the-as ripple-wave (-> gp-0 waveform)) (-> arg1 effect arg3))
              )
          (set! (-> gp-0 last-frame-scale) f30-0)
          (the-as pointer s5-0)
          )
        )
      )
    )
  )


(defun pc-merc-blend-shape ((pd process-drawable) (blerc-weights-out (pointer float)))
  "PC implementation to get blerc weights as floats and avoid the u16 rounding.
   Returns #f if there is no blerc running, which means that we should use base positions.
   If things work correctly, the original implementation would try to restore weights of 0
   after the animation finishes - it leaves `blend-shape-valid` set after `blend-shape` is cleared
   causing one more round of merc-blend-shape to run with hardcoded weights of 0.
   "
  (when (or (not (-> pd skel))
            (zero? (-> pd skel))
            )
    (return #f)
    )

  ;; grab the currently playing animatoin
  (let* ((jc-channel (-> pd skel root-channel 0))
         (anim (-> jc-channel frame-group))
         (got-weights #f)
         )
    (when (and anim ;; we have an anim
               (> (-> pd skel active-channels) 0) ;; there are channels running
               (zero? (-> pd draw cur-lod))       ;; using high lod
               (logtest? (-> pd skel status) (joint-control-status blend-shape)) ;; blend shape is on
               )
      (cond
        ;; first, see if we have an override:
        ((and (-> pd skel override) (!= (-> pd skel override 0) 0.0))
         ;; we do! copy from there.
         (let* ((mctrl (-> pd draw mgeo))
                (num-targets (-> mctrl header blend-target-count))
                (override-array (-> pd skel override))
                )
           (set! got-weights #t)
           (dotimes (i num-targets)
             (set! (-> blerc-weights-out i) (* 8192.0 (-> override-array (+ i 1))))
             )
           )
         )
        (else
          ;; otherwise, do the animation
          (let ((shape-anim (-> anim blend-shape-anim)))
            (when shape-anim
              (let ((mctrl (-> pd draw mgeo)))
                (let* ((num-targets (-> mctrl header blend-target-count))
                       (frame-f (-> jc-channel frame-num))
                       ;; round down to the integer frame
                       (frame-i (the int frame-f))
                       (frame-1-data (the (pointer uint8) (&+ shape-anim (* frame-i num-targets))))
                       )
                  (cond
                    ;; check if there's a frame after this
                    ((< frame-i (the-as int (+ (-> anim frames num-frames) -1)))
                     ;; there is, interpolate between them.
                     ;; this is rewritten to use floats, but still use the same scaling as the s16 weights.
                     (let* ((frame-2-data (&+ frame-1-data num-targets))
                            (frame-2-mult (* 64.0 (- frame-f (the float frame-i))))
                            (frame-1-mult (- 64.0 frame-2-mult))
                            )
                       (set! got-weights #t)
                       (dotimes (i num-targets)
                         ;; key difference: this is floats
                         (set! (-> blerc-weights-out i)
                               (+ (* (the float (- (-> frame-1-data i) 64)) frame-1-mult)
                                  (* (the float (- (-> frame-2-data i) 64)) frame-2-mult)
                                  )
                               )
                         )
                       )
                     )
                    (else
                      ;; at the last frame, nothing to interpolate.
                      (set! got-weights #t)
                      (dotimes (a3-7 num-targets)
                        (set! (-> blerc-weights-out a3-7) (the float (* (+ (-> (the-as (pointer uint8) (&+ frame-1-data a3-7))) -64) 64)))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
  got-weights

    )
  )

(defenum pc-merc-bits
  :type uint8
  :bitfield #t
  (update-verts 0)
  (disable-fog 1)
  (pc-blerc 2)
  )

(deftype pc-merc-flags (structure)
  ((enable-mask uint64)
   (ignore-alpha-mask uint64)
   (effect-count uint8)
   (bit-flags pc-merc-bits)
   )
  )

(defun pc-merc-draw-request ((dc draw-control) (dma-buf pointer) (matrix-buf pointer) (tex-idx int) (update-verts symbol) (blercs (pointer float)))
  "Send a request to PC Merc2 to draw the given object.
   Only draws the effects which match this texture index.
   Just places a single big dma packet, you have to patch the end yourself.
   If update-verts is set to #t, tell the PC renderer to use EE version of vertices.
   If update-verts is set to 'blerc, tell the PC renderer to use the included blerc weights
   to modify the vertices."
  (let ((start-packet (the-as dma-packet dma-buf))
        (qwc-total 0))
    (set! (-> start-packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
    (set! (-> start-packet vif0) (new 'static 'vif-tag))
    (set! (-> start-packet vif1) (new 'static 'vif-tag :cmd (vif-cmd pc-port)))
    (set! dma-buf (the pointer (&+ start-packet 16)))

    ;; NAME: 128 char, 8 qw
    (let ((data-ptr (the-as (pointer uint128) dma-buf)))
      (charp<-string (the (pointer uint8) (&-> data-ptr 0)) (-> dc mgeo name))
      )
    (&+! dma-buf (* 16 8))
    (+! qwc-total 8)

    ;; LIGHTS:
    (quad-copy! dma-buf (the pointer (-> (-> *foreground* merc-bucket-info) light)) 7)
    (&+! dma-buf (* 16 7))
    (+! qwc-total 7)


    (let ((matrix-slot-string (the (pointer uint8) dma-buf)) ;; matrix slot list (so PC knows what order they come in)
          (enable-mask 0)
          (ignore-alpha-mask 0)
          (matrix-out-idx 0)
          )
      (&+! dma-buf (* 16 8))
      (+! qwc-total 8)
      ;; flag of matrices we've already transferred and can de-dup
      (let ((transferred-matrices (new 'stack-no-clear 'array 'uint8 128)))
        (dotimes (i 128) (set! (-> transferred-matrices i) 0))

        (let ((merc-ctrl (-> dc lod-set lod (-> dc cur-lod) geo)))
          ;; loop to: grab matrices and populate flags
          (dotimes (effect-idx (-> merc-ctrl header effect-count))

            ;; check to skip fragment. only draw if:
            ;; We want to use "merc"
            ;; We aren't disabled (new feature in jak 2)
            ;; We match the texture index for the bucket.
            (when (and (zero? (-> (-> *foreground* merc-bucket-info) effect effect-idx merc-path))
                       (zero? (-> (-> *foreground* merc-bucket-info) effect effect-idx disable-draw))
                       (= tex-idx (-> merc-ctrl effect effect-idx texture-index))
                       )
              ;; set enable bit for pc render
              (logior! enable-mask (ash 1 effect-idx))
              ;; set alpha bit for pc render
              (when (nonzero? (-> (-> *foreground* merc-bucket-info) effect effect-idx ignore-alpha))
                (logior! ignore-alpha-mask (ash 1 effect-idx))
                )
              (let* ((effect (-> merc-ctrl effect effect-idx))
                     (frag (-> effect frag-ctrl))
                     )
                ;; iterate over fragments
                (dotimes (frag-idx (-> effect frag-count))
                  ;; matrices
                  (dotimes (mat-xfer-idx (-> frag mat-xfer-count))
                    (let ((mat-idx (-> frag mat-dest-data mat-xfer-idx matrix-number)))
                      (if (>= mat-idx 128) ;; pc merc2 limit
                          (break!)
                          )
                      (when (zero? (-> transferred-matrices mat-idx))
                        ;; transfer it.
                        (set! (-> transferred-matrices mat-idx) 1)
                        (set! (-> matrix-slot-string matrix-out-idx) mat-idx)
                        (+! matrix-out-idx 1)
                        (set! (-> (the (pointer pointer) dma-buf)) (&+ matrix-buf (* 128 mat-idx)))
                        (&+! dma-buf 16)
                        (+! qwc-total 1)
                        )
                      )
                    )
                  (&+! frag (* 2 (-> frag mat-xfer-count)))
                  (&+! frag (size-of merc-fragment-control))
                  )
                )
              )
            ) ;; end effect loop

          ;; end matrix string
          (while (< matrix-out-idx 128)
            (set! (-> matrix-slot-string matrix-out-idx) #xff)
            (+! matrix-out-idx 1)
            )

          ;; flags
          (let ((flags (the (pc-merc-flags) dma-buf)))
            (set! (-> flags effect-count) (-> merc-ctrl header effect-count))
            (set! (-> flags bit-flags) (the pc-merc-bits 0))
            (when update-verts
              (if (= update-verts 'blerc)
                  (logior! (-> flags bit-flags) (pc-merc-bits pc-blerc))
                  (logior! (-> flags bit-flags) (pc-merc-bits update-verts))
                  )
              )
            (when (logtest? (-> dc status) (draw-control-status disable-fog))
              (logior! (-> flags bit-flags) (pc-merc-bits disable-fog))
              )
            (set! (-> flags enable-mask) enable-mask)
            (set! (-> flags ignore-alpha-mask) ignore-alpha-mask)
            )
          (&+! dma-buf (* 16 2))
          (+! qwc-total 2)

          ;; include blerc weights.
          (when (= update-verts 'blerc)
            (mem-copy! dma-buf blercs (* 40 4))
            (&+! dma-buf (* 40 4))
            (+! qwc-total 10)
            )

          ;; fades
          (let ((fades (the (pointer uint32) dma-buf)))
            (dotimes (i (-> merc-ctrl header effect-count))
              (set! (-> fades i) (the-as uint (-> (-> *foreground* merc-bucket-info) effect i color-fade)))
              )
            )

          (let ((num-fades (/ (+ (-> merc-ctrl header effect-count) 3) 4)))
            (&+! dma-buf (* 16 num-fades))
            (+! qwc-total num-fades)
            )

          ;; merc ptrs
          (let ((merc-ptrs (the (pointer object) dma-buf)))
            (dotimes (i (-> merc-ctrl header effect-count))
              (set! (-> merc-ptrs i) (-> merc-ctrl effect i))
              )
            )
          (let ((num-fades (/ (+ (-> merc-ctrl header effect-count) 3) 4)))
            (&+! dma-buf (* 16 num-fades))
            (+! qwc-total num-fades)
            )
          )
        )
      )

    (set! (-> start-packet dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc qwc-total))
    dma-buf
    )
  )

(defun pc-draw-bones ((dc draw-control) (dma-buf pointer) (matrix-buf pointer))
  "Add a dma packet to tell the PC renderer which model we are renderering."
  (let* ((use-flags (new 'stack-no-clear 'array 'uint8 7))
         (blerc-weights (new 'stack-no-clear 'array 'float 40))
         (mctrl (-> dc mgeo))
         (buckets (-> (scratchpad-object foreground-work) grid level-buckets (-> (scratchpad-object foreground-work) draw-index-map (-> dc level-index))))
         (has-ripple-or-texscroll #f)
         (uses-fp-blerc (and *use-fp-blerc* (pc-merc-blend-shape (the process-drawable (-> dc process)) blerc-weights)))
         )
    ;; mark all as unused, until we see a use
    (dotimes (i 7) (set! (-> use-flags i) 0))

    ;; look for uses.
    (dotimes (i (-> mctrl header effect-count))
      ;;(format 0 "effect ~d, texture ~d~%" i (-> mctrl effect i texture-index))
      (when (= 0 (-> *foreground* merc-bucket-info effect i merc-path))
        (set! (-> use-flags (-> mctrl effect i texture-index)) 1)
        (when (logtest? (-> (-> dc lod-set lod (-> dc cur-lod) geo) effect i effect-bits) (effect-bits ripple texscroll))
          (set! has-ripple-or-texscroll #t)
          )
        )
      )

    ;; loop over texture groupe
    (dotimes (i 7)
      (when (nonzero? (-> use-flags i))
        ;; this one is used, update the model for pc.
        ;; create dma-packet to send the name:
        (let ((packet (the-as dma-packet dma-buf))
              (vertex-update #f)
              )
          (when has-ripple-or-texscroll
            (set! vertex-update #t)
            )
          (when uses-fp-blerc
            (set! vertex-update 'blerc)
            )

          ;; if the fp blerc is disabled, handle blerc with normal modified vertices.
          (unless *use-fp-blerc*
            (let* ((pd (the process-drawable (-> dc process)))
                   (jc (-> pd skel)))
              (when (nonzero? jc)
                (when (logtest? (-> jc status) (joint-control-status blend-shape-valid))
                  (set! vertex-update #t)
                  )
                )
              )
            )

         ; (format 0 "~D weights: ~X~%" i blerc-weights)

          (set! dma-buf (pc-merc-draw-request dc dma-buf matrix-buf i vertex-update blerc-weights))

          ;; create a patch packet
          (let ((patch-packet (the-as dma-packet dma-buf)))
            (set! (-> patch-packet dma) (the-as dma-tag #x20000000))
            (set! (-> patch-packet vif0) (new 'static 'vif-tag))
            (set! (-> patch-packet vif1) (new 'static 'vif-tag))
            (set! dma-buf (the pointer (&+ patch-packet 16)))

            ;; now, the confusing splice stuff
            (let ((merc-chain (-> buckets data i merc)))
              ;; first step: set first, if we are the first thing to draw.
              (when (zero? (-> merc-chain first))
                  (set! (-> merc-chain first) packet)
                  )

              ;; second step: patch the last thing that was drawn
              (when (nonzero? (-> merc-chain patch))
                (let ((patch-addr (+ 4 (the-as int (-> merc-chain patch)))))
                  (set! (-> (the (pointer dma-packet) patch-addr)) packet)
                  )
                )

              ;; third step: update patch to point to our packet.
              (set! (-> merc-chain patch) patch-packet)

              )
            )
          )

        )
      )
    )
  dma-buf
  )

(defun foreground-draw ((dc draw-control) (dma-buf dma-buffer) (dist-in float))
  (local-vars (fg-work foreground-work) (a0-92 uint))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         (acc :class vf)
         )
        ;;(.lui fg-work 28672)
        (set! fg-work (scratchpad-object foreground-work))
        (with-pc
          (when (-> *pc-settings* force-envmap?)
              (set! dist-in 0.0)))
        (let* ((bone-calc (the-as bone-calculation (-> dma-buf base)))
               (matrix-mem (the-as object (&+ (the-as pointer bone-calc) 64)))
               )
          (let ((a3-0 (logand (the-as int matrix-mem) 48)))
            (b! (zero? a3-0) cfg-2 :delay (nop!))
            (set! matrix-mem (&- (&+ (the-as pointer matrix-mem) 64) (the-as uint a3-0)))
            )
          (label cfg-2)
          (let* ((num-bones (+ (-> dc mgeo num-joints) 3))
                 (bone-mem-size (* num-bones 128))
                 )
            (let ((fg-regs (-> (scratchpad-object foreground-work) regs)))
              (set! (-> fg-regs joint-ptr) (the-as (inline-array joint) (-> dc jgeo data 0)))
              (set! (-> fg-regs bone-ptr) (-> dc skeleton bones))
              (set! (-> fg-regs num-bones) (the-as uint num-bones))
              (set! (-> fg-regs dist) dist-in)
              (set! (-> fg-regs dma-buf) dma-buf)
              (set! (-> fg-regs level-buckets)
                    (-> (scratchpad-object foreground-work)
                        grid
                        level-buckets
                        (-> (scratchpad-object foreground-work) draw-index-map (-> dc level-index))
                        )
                    )
              )
            (let ((matrix-mem2 matrix-mem)
                  (bflags 0)
                  )
              (let ((f-regs (-> (scratchpad-object foreground-work) regs))
                    (bone-list *bone-calculation-list*)
                    (calc-to-add bone-calc)
                    )
                (let ((jnt (-> f-regs joint-ptr))
                      (bn (-> f-regs bone-ptr))
                      (count (-> f-regs num-bones))
                      (calc calc-to-add)
                      )
                  (set! (-> calc flags) (the-as bone-calc-flags bflags))
                  (set! (-> calc num-bones) count)
                  (set! (-> calc matrix-area) (the-as (inline-array pris-mtx) matrix-mem2))
                  (set! (-> calc joints) jnt)
                  (set! (-> calc bones) bn)
                  (set! (-> calc next) (the-as bone-calculation 0))
                  )
                (if (nonzero? (-> bone-list next))
                    (set! (-> bone-list next next) calc-to-add)
                    )
                (if (zero? (-> bone-list first))
                    (set! (-> bone-list first) calc-to-add)
                    )
                (set! (-> bone-list next) calc-to-add)
                )
              (&+ bone-calc 48)
              (let ((dma-ptr (the-as pointer (+ (the-as uint matrix-mem) bone-mem-size))))
                (set! (-> fg-work regs mtxs) (the-as (inline-array pris-mtx) matrix-mem))
                (let ((bucket-info (-> *foreground* merc-bucket-info)))
                  (when (= (-> dc data-format) (draw-control-data-format merc))
                    (let ((fg-lights (-> (scratchpad-object foreground-work) lights))
                          (rotated-light-out (-> bucket-info light))
                          )
                      (let ((inv-cam-rot (-> *math-camera* inv-camera-rot)))
                        (nop!)
                        (nop!)
                        (.lvf vf4 (&-> inv-cam-rot quad 0))
                        (nop!)
                        (.lvf vf5 (&-> inv-cam-rot quad 1))
                        (nop!)
                        (.lvf vf6 (&-> inv-cam-rot quad 2))
                        )
                      (nop!)
                      (.lvf vf1 (&-> fg-lights direction 0 quad))
                      (nop!)
                      (.lvf vf2 (&-> fg-lights direction 1 quad))
                      (nop!)
                      (.lvf vf3 (&-> fg-lights direction 2 quad))
                      ;; (.vcallms 0)
                      ;  mulax.xyzw ACC, vf01, vf04
                      (.mul.x.vf acc vf1 vf4)
                      ;  madday.xyzw ACC, vf02, vf04
                      (.add.mul.y.vf acc vf2 vf4 acc)
                      ;  maddz.xyzw vf07, vf03, vf04
                      (.add.mul.z.vf vf7 vf3 vf4 acc)
                      ;  mulax.xyzw ACC, vf01, vf05
                      (.mul.x.vf acc vf1 vf5)
                      ;  madday.xyzw ACC, vf02, vf05
                      (.add.mul.y.vf acc vf2 vf5 acc)
                      ;  maddz.xyzw vf08, vf03, vf05
                      (.add.mul.z.vf vf8 vf3 vf5 acc)
                      ;  mulax.xyzw ACC, vf01, vf06
                      (.mul.x.vf acc vf1 vf6)
                      ;  madday.xyzw ACC, vf02, vf06 :e
                      (.add.mul.y.vf acc vf2 vf6 acc)
                      ;  maddz.xyzw vf09, vf03, vf06
                      (.add.mul.z.vf vf9 vf3 vf6 acc)

                      (let ((a1-9 (-> fg-lights color 0 quad)))
                        (nop!)
                        (let ((a2-6 (-> fg-lights color 1 quad)))
                          (nop!)
                          (let ((a3-4 (-> fg-lights color 2 quad)))
                            (nop!)
                            (let ((a0-6 (-> fg-lights ambient quad)))
                              (nop!)
                              (set! (-> rotated-light-out color 0 quad) a1-9)
                              (nop!)
                              (set! (-> rotated-light-out color 1 quad) a2-6)
                              (nop!)
                              (set! (-> rotated-light-out color 2 quad) a3-4)
                              (nop!)
                              (set! (-> rotated-light-out ambient quad) a0-6)
                              )
                            )
                          )
                        )
                      (nop!)
                      (.nop.vf)
                      (nop!)
                      (.svf (&-> rotated-light-out direction 0 quad) vf7)
                      (nop!)
                      (.svf (&-> rotated-light-out direction 1 quad) vf8)
                      (nop!)
                      (.svf (&-> rotated-light-out direction 2 quad) vf9)
                      (nop!)
                      (set! (-> rotated-light-out fade-flags) (the-as uint 0))
                      )
                    (set! (-> (scratchpad-object foreground-work) regs merc-used) (the-as uint 0))
                    (set! (-> (scratchpad-object foreground-work) regs emerc-used) (the-as uint 0))
                    (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 0))
                    (set! (-> bucket-info needs-clip) (if (logtest? (-> dc status) (draw-control-status close-to-screen))
                                                          1
                                                          0
                                                          )
                          )
                    (set! (-> bucket-info need-mercprime-if-merc) 0)
                    (set! (-> bucket-info must-use-mercneric-for-clip) 0)
                    (when (logtest? (-> dc status) (draw-control-status close-to-screen))
                      (cond
                        ((logtest? (-> dc status) (draw-control-status force-vu1))
                         (set! (-> bucket-info need-mercprime-if-merc) 1)
                         )
                        ((nonzero? (-> dc longest-edge))
                         (if (foreground-check-longest-edge-asm dc (-> (scratchpad-object foreground-work) regs dist))
                             (set! (-> bucket-info need-mercprime-if-merc) 1)
                             (set! (-> bucket-info must-use-mercneric-for-clip) 1)
                             )
                         )
                        (else
                          (set! (-> bucket-info must-use-mercneric-for-clip) 1)
                          )
                        )
                      )
                    (let ((geo (-> dc lod-set lod (-> dc cur-lod) geo)))
                      (let ((effect-mask (-> dc effect-mask)))
                        (dotimes (effect-idx (the-as int (-> geo header effect-count)))
                          (cond
                            ((= (logand effect-mask 1) 1)
                             (set! (-> bucket-info effect effect-idx disable-draw) (the-as uint 1))
                             )
                            ((begin
                               (set! (-> bucket-info effect effect-idx disable-draw) (the-as uint 0))
                               (set! (-> bucket-info effect effect-idx disable-envmap) (the-as uint 0))
                               (when (logtest? (-> geo effect effect-idx effect-bits) (effect-bits texscroll))
                                 (let* ((extra (the-as structure (-> geo effect effect-idx extra-info)))
                                        (tex-scroll-info
                                          (the-as
                                            mei-texture-scroll
                                            (+ (the-as uint extra) (* (-> (the-as merc-extra-info extra) texture-scroll-offset) 16))
                                            )
                                          )
                                        )
                                   (if (< (-> (scratchpad-object foreground-work) regs dist) (-> tex-scroll-info max-dist))
                                       (texscroll-make-request (-> geo effect effect-idx))
                                       )
                                   )
                                 )
                               (when (and (logtest? (-> geo effect effect-idx effect-bits) (effect-bits ripple)) (-> dc ripple))
                                   (set! dma-ptr (foreground-ripple dc geo dma-ptr effect-idx))
                                   )
                               (nonzero? (-> dc death-timer))
                               )
                             (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 2))
                             (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 1))
                             )
                            ((logtest? (-> geo effect effect-idx effect-bits) (effect-bits force-mercneric))
                             (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 2))
                             (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 1))
                             )
                            ((and (logtest? (-> geo effect effect-idx effect-usage) 1)
                                  (zero? (logand (-> dc global-effect) (draw-control-global-effect disable-envmap)))
                                  )
                             0.0
                             (let* ((ei (the-as structure (-> geo effect effect-idx extra-info)))
                                    (tint-info
                                      (the-as mei-envmap-tint (+ (the-as uint ei) (* (-> (the-as merc-extra-info ei) envmap-tint-offset) 16)))
                                      )
                                    (t-fade-0 (-> tint-info fade0))
                                    (t-fade-1 (-> tint-info fade1))
                                    (t-interp (+ (* t-fade-0 (-> (scratchpad-object foreground-work) regs dist)) t-fade-1))
                                    (t-amount (fmax 0.0 (fmin 1.0 t-interp)))
                                    )
                               (cond
                                 ((or (nonzero? (-> bucket-info must-use-mercneric-for-clip))
                                      (or (< 0.0 t-amount) (logtest? (-> geo effect effect-idx effect-bits) (effect-bits cross-fade)))
                                      )
                                  (let ((a0-33 (&-> tint-info tint))
                                        (v1-74 (the-as object (-> bucket-info effect effect-idx)))
                                        )
                                    (let ((a1-17 (-> *time-of-day-context* current-env-color)))
                                      (if (and (logtest? (-> geo effect effect-idx effect-bits) (effect-bits cross-fade))
                                               (logtest? (-> dc status) (draw-control-status warp-cross-fade))
                                               )
                                          (set! t-amount (* 0.0078125 (the float (- 128 (the-as int (-> dc force-fade)))) t-amount))
                                          )
                                      (cond
                                        ((logtest? (-> geo effect effect-idx effect-bits) (effect-bits ignore-tod-for-envmap-tint))
                                         (dotimes (a1-18 3)
                                           (set! (-> (the-as (pointer int8) (&+ (the-as pointer v1-74) a1-18)))
                                                 (the int (* t-amount (the float (-> (the-as (pointer uint8) (&+ a0-33 a1-18)) 0))))
                                                 )
                                           )
                                         )
                                        (else
                                          (let ((f0-7 (* 0.0078125 t-amount)))
                                            (dotimes (a2-27 3)
                                              (set! (-> (the-as (pointer int8) (&+ (the-as pointer v1-74) a2-27)))
                                                    (the int (* f0-7 (-> a1-17 data a2-27) (the float (-> (the-as (pointer uint8) (&+ a0-33 a2-27)) 0))))
                                                    )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    (set! (-> (the-as merc-effect-bucket-info v1-74) alpha) (the-as uint 128))
                                    )
                                  ;(format 0 "envmap stat: ~A ~A~%" (-> dc process name) (logtest? (-> geo effect effect-idx effect-bits) (effect-bits emerc)))
                                  (cond
                                    ((and (logtest? (-> dc status) (draw-control-status force-vu1))
                                          (logtest? (-> geo effect effect-idx effect-bits) (effect-bits emerc))
                                          )
                                     (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 1))
                                     (set! (-> (scratchpad-object foreground-work) regs emerc-used) (the-as uint 1))
                                     )
                                    (else
                                      (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 2))
                                      (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 1))
                                      (if (logtest? (-> dc status) (draw-control-status force-fade))
                                          (set! (-> bucket-info light fade-int) (-> dc force-fade))
                                          )
                                      )
                                    )

                                  (set! (-> bucket-info effect effect-idx ignore-alpha)
                                        (the-as uint (if (logtest? (-> geo effect effect-idx effect-bits) (effect-bits ignore-alpha))
                                                         1
                                                         0
                                                         )
                                                )
                                        )
                                  )
                                 ((logtest? (-> dc status) (draw-control-status force-fade))
                                  (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 2))
                                  (set! (-> bucket-info effect effect-idx ignore-alpha)
                                        (the-as uint (if (logtest? (-> geo effect effect-idx effect-bits) (effect-bits ignore-alpha))
                                                         1
                                                         0
                                                         )
                                                )
                                        )
                                  (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 1))
                                  (set! (-> bucket-info light fade-int) (-> dc force-fade))
                                  )
                                 (else
                                   (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 0))
                                   (set! (-> bucket-info effect effect-idx ignore-alpha) (the-as uint 1))
                                   (set! (-> (scratchpad-object foreground-work) regs merc-used) (the-as uint 1))
                                   )
                                 )
                               )
                             ) ;; end if envmap

                            (else
                              (cond
                                ((logtest? (-> geo effect effect-idx effect-bits) (effect-bits cross-fade))
                                 (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 2))
                                 (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 1))
                                 )
                                ((or (logtest? (-> dc status) (draw-control-status force-fade))
                                     (nonzero? (-> bucket-info must-use-mercneric-for-clip))
                                     )
                                 (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 2))
                                 (if (logtest? (-> dc global-effect) (draw-control-global-effect disable-envmap))
                                     (set! (-> bucket-info effect effect-idx disable-envmap) (the-as uint 1))
                                     )
                                 (set! (-> (scratchpad-object foreground-work) regs mercneric-used) (the-as uint 1))
                                 )
                                (else
                                  (set! (-> bucket-info effect effect-idx merc-path) (the-as uint 0))
                                  (set! (-> (scratchpad-object foreground-work) regs merc-used) (the-as uint 1))
                                  )
                                )
                              (set! (-> bucket-info effect effect-idx ignore-alpha)
                                    (the-as
                                      uint
                                      (if (or (logtest? (-> geo effect effect-idx effect-bits) (effect-bits ignore-alpha))
                                              (logtest? (-> dc global-effect) (draw-control-global-effect disable-envmap))
                                              )
                                          1
                                          0
                                          )
                                      )
                                    )
                              )
                            )
                          (set! effect-mask (shr effect-mask 1))
                          )
                        )

                      ;; reassign for PC. For the most part, we reassign everything to merc. The exceptions are:
                      ;; - "warp" effect is on: this special effect isn't supported by PC merc
                      ;; - "death" effect is on: this requires the renderer to return transformed vertices.
                      ;; - using the warp bucket. - there's no merc warp bucket, so we have to use generic here.
                      ;; NOTE: we don't listen to force-mercneric because I believe we handle this case correctly
                      ;; in extract_merc.cpp by checking the trans bit. This can be enabled, but texture uploads
                      ;; for at least water aren't hooked up to the PC texture system.
                      (when (or (nonzero? (-> (scratchpad-object foreground-work) regs mercneric-used))
                                (nonzero? (-> (scratchpad-object foreground-work) regs emerc-used))
                                )

                        ;; technically we should use generic for ripple query, but the only user is dark eco,
                        ;; which doesn't actually do anything with the result of the query.
                        (when #t ;;(not (and (-> dc ripple) (-> dc ripple query)))
                          (set! (-> (scratchpad-object foreground-work) regs mercneric-used) 0)
                          (set! (-> (scratchpad-object foreground-work) regs emerc-used) 0)
                          (set! (-> (scratchpad-object foreground-work) regs merc-used) 1)
                          (dotimes (effect-idx (the-as int (-> geo header effect-count)))
                            (cond
                              ((or (logtest? (-> geo effect effect-idx effect-bits) (effect-bits cross-fade))
                                   (logtest? (-> geo effect effect-idx effect-bits) (effect-bits force-mercneric))
                                   (= (-> geo effect effect-idx texture-index) (tpage-category warp))
                                   (nonzero? (-> dc death-timer))
                                   )

                               ; (if (logtest? (-> geo effect effect-idx effect-bits) (effect-bits cross-fade))
                               ;     (format *stdcon* "[fg] ~S to generic 1~%" (-> dc process name))
                               ;   )
                               ; (if (= (-> geo effect effect-idx texture-index) (tpage-category warp))
                               ;     (format *stdcon* "[fg] ~S to generic 2~%" (-> dc process name))
                               ;   )
                               ; (if (nonzero? (-> dc death-timer))
                               ;     (format *stdcon* "[fg] ~S to generic 3~%" (-> dc process name))
                               ;   )
                               (set! (-> bucket-info effect effect-idx merc-path) 2)
                               (set! (-> (scratchpad-object foreground-work) regs mercneric-used) 1)
                               )
                              (else
                                (set! (-> bucket-info effect effect-idx merc-path) 0)
                                )
                              )

                            (when (logtest? (-> geo effect effect-idx effect-usage) 1)
                              (set! (-> bucket-info effect effect-idx ignore-alpha) 1)
                              )
                            )
                          )
                        )



                      (when (nonzero? (-> (scratchpad-object foreground-work) regs mercneric-used))
                        (if (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask generic))
                            (set! dma-ptr (foreground-generic-merc dc dma-ptr 0))
                            )
                        )
                      (if (-> dc shadow)
                          (set! dma-ptr (foreground-shadow dc (-> (scratchpad-object foreground-work) regs mtxs) dma-ptr))
                          )
                      (when (nonzero? (-> (scratchpad-object foreground-work) regs merc-used))
                        (when (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask merc))
                          (let ((merc-fade-int 0)
                                (fade-enable #f)
                                )
                            (cond
                              ((logtest? (-> geo effect 0 effect-bits) (effect-bits no-fade-out))
                               (set! fade-enable #f)
                               )
                              ((logtest? (-> dc status) (draw-control-status force-fade))
                               (set! merc-fade-int (the-as int (-> dc force-fade)))
                               (set! fade-enable #t)
                               )
                              ((= (-> dc cur-lod) (-> dc lod-set max-lod))
                               (let ((dist-until-gone
                                       (- (-> dc lod-set lod (-> dc cur-lod) dist) (-> (scratchpad-object foreground-work) regs dist))
                                       )
                                     )
                                 (if (< dist-until-gone 81920.0)
                                     (set! fade-enable #t)
                                     )
                                 (set! merc-fade-int (the int (* 0.0015625 dist-until-gone)))
                                 )
                               )
                              )
                            (when fade-enable
                              (let ((v1-159 (min 128 (max 0 merc-fade-int)))
                                    (a0-84 (-> bucket-info light))
                                    )
                                (set! (-> a0-84 fade-flags) (the-as uint 0.00000000000000000000000000000000000000000014))
                                (set! (-> a0-84 fade-int) (the-as uint v1-159))
                                )
                              )
                            )

                          ;; added
                          (set! dma-ptr (pc-draw-bones dc dma-ptr (the pointer (-> (scratchpad-object foreground-work) regs mtxs))))

                          ; (if (nonzero? (-> bucket-info need-mercprime-if-merc))
                          ;     (set! dma-ptr (foreground-merc dc (-> (scratchpad-object foreground-work) regs mtxs) dma-ptr 32 17 bucket-info))
                          ;     (set! dma-ptr (foreground-merc dc (-> (scratchpad-object foreground-work) regs mtxs) dma-ptr 35 20 bucket-info))
                          ;     )
                          )
                        )
                      )
                    (when (nonzero? (-> (scratchpad-object foreground-work) regs emerc-used))
                      (if (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask emerc))
                          (set! dma-ptr (foreground-emerc dc (-> (scratchpad-object foreground-work) regs mtxs) dma-ptr 29 19 bflags))
                          )
                      )
                    (when (nonzero? (-> dc death-timer))
                      (when (not (paused?))
                        (+! (-> dc death-timer) -1)
                        (if (>= (the-as uint 1) (-> dc death-timer))
                            (send-event (-> dc process) 'death-end dc)
                            )
                        )
                      )
                    )
                  )
                (let ((v1-186 (logand (the-as int dma-ptr) 48)))
                  0
                  (b! (zero? v1-186) cfg-128 :delay (set! a0-92 (the-as uint #x20000000)))
                  ;; (s.q! (the-as object dma-ptr) a0-92)
                  (set! (-> (the (pointer uint128) dma-ptr) 0) (the uint128 a0-92))

                  (let ((a0-93 (the-as object dma-ptr)))
                    (set! dma-ptr (the-as pointer (+ (- (the-as int dma-ptr) (the-as uint v1-186)) 64)))
                    ;; (s.w! (+ a0-93 4) (the-as int dma-ptr))
                    (set! (-> (the (pointer int32) (+ (the-as uint a0-93) 4))) (the-as int dma-ptr))
                    )
                  )
                (label cfg-128)
                (set! (-> (scratchpad-object foreground-work) regs dma-buf base)
                      (the-as pointer (logand (the-as int dma-ptr) #xfffffff))
                      )
                )
              )
            )
          )
        0
        (none)
        )
  )


;; todo foreground-draw-hud

;; changed to perm and added multiplier.
(define-perm *foreground-draw-engine* engine (new 'global 'engine 'draw PROCESS_HEAP_MAX connection))
