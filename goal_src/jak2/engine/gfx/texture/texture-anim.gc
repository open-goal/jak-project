;;-*-Lisp-*-
(in-package goal)

;; name: texture-anim.gc
;; name in dgo: texture-anim
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

;; The "texture animation" system modifies a texture according to a series of layers.

(define *texture-anim-work*
  (new 'static 'texture-anim-work
    :erase-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif0 (new 'static 'gif-tag64
        :nloop #x1
        :eop #x1
        :pre #x1
        :prim (new 'static 'gs-prim :prim (gs-prim-type sprite))
        :nreg #x3
        )
      :gif1 (new 'static 'gif-tag-regs :regs0 (gif-reg-id rgbaq) :regs1 (gif-reg-id xyz2) :regs2 (gif-reg-id xyz2))
      )
    :draw-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #xa :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #xa :cmd (vif-cmd direct) :msk #x1)
        )
      :gif0 (new 'static 'gif-tag64
        :nloop #x1
        :eop #x1
        :pre #x1
        :prim (new 'static 'gs-prim :prim (gs-prim-type tri-strip) :tme #x1 :abe #x1)
        :nreg #x9
        )
      :gif1 (new 'static 'gif-tag-regs
        :regs0 (gif-reg-id rgbaq)
        :regs1 (gif-reg-id st)
        :regs2 (gif-reg-id xyz2)
        :regs3 (gif-reg-id st)
        :regs4 (gif-reg-id xyz2)
        :regs5 (gif-reg-id st)
        :regs6 (gif-reg-id xyz2)
        :regs7 (gif-reg-id st)
        :regs8 (gif-reg-id xyz2)
        )
      )
    :draw2-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif0 (new 'static 'gif-tag64
        :nloop #x1
        :eop #x1
        :pre #x1
        :prim (new 'static 'gs-prim :prim (gs-prim-type sprite) :tme #x1)
        :nreg #x5
        )
      :gif1 (new 'static 'gif-tag-regs
        :regs0 (gif-reg-id rgbaq)
        :regs1 (gif-reg-id st)
        :regs2 (gif-reg-id xyz2)
        :regs3 (gif-reg-id st)
        :regs4 (gif-reg-id xyz2)
        )
      )
    :fill-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x4 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x4 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif0 (new 'static 'gif-tag64
        :nloop #x1
        :eop #x1
        :pre #x1
        :prim (new 'static 'gs-prim :prim (gs-prim-type sprite))
        :nreg #x3
        )
      :gif1 (new 'static 'gif-tag-regs :regs0 (gif-reg-id rgbaq) :regs1 (gif-reg-id xyz2) :regs2 (gif-reg-id xyz2))
      )
    :adgif-tmpl (new 'static 'dma-gif-packet
      :dma-vif (new 'static 'dma-packet
        :dma (new 'static 'dma-tag :qwc #x6 :id (dma-tag-id cnt))
        :vif1 (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd direct) :msk #x1)
        )
      :gif0 (new 'static 'gif-tag64 :nloop #x5 :eop #x1 :nreg #x1)
      :gif1 (new 'static 'gif-tag-regs :regs0 (gif-reg-id a+d))
      )
    :corner0 (new 'static 'vector :x -0.5 :y -0.5 :w 1.0)
    :corner1 (new 'static 'vector :x 0.5 :y -0.5 :w 1.0)
    :corner2 (new 'static 'vector :x -0.5 :y 0.5 :w 1.0)
    :corner3 (new 'static 'vector :x 0.5 :y 0.5 :w 1.0)
    :const (new 'static 'vector :x 128.0 :z 1.9921 :w 1.0)
    :random (new 'static 'inline-array vector4w 8
      (new 'static 'vector4w :x #x17181920 :y #x13141516 :z -1995435758 :w #x1234567)
      (new 'static 'vector4w :x #x23878237 :y #x32048778 :z -1740074601 :w -2021050320)
      (new 'static 'vector4w :x #x62024762 :y -1876389256 :z #x28724781 :w #x68712983)
      (new 'static 'vector4w :x #x62176128 :y #x12387487 :z #x12780983 :w -2139999882)
      (new 'static 'vector4w :x #x34987239 :y #x78699872 :z -2087161499 :w #x1982397)
      (new 'static 'vector4w :x -1737344873 :y -1742502109 :z #x20987293 :w #x62102981)
      (new 'static 'vector4w :x -2110229208 :y -2022559591 :z -1743517309 :w #x29874310)
      (new 'static 'vector4w :x -2030034041 :y -1743611880 :z -2094950384 :w #x71623790)
      )
    )
  )

(defun texture-anim-layer-interp ((arg0 texture-anim-layer) (arg1 float))
  "Interpolate between start and end, and store the results in layer's interpolated-vectors array."
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (set! (-> *texture-anim-work* const y)
          (/ (- arg1 (-> arg0 start-time)) (- (-> arg0 end-time) (-> arg0 start-time)))
          )
    (.lvf vf1 (&-> *texture-anim-work* const quad))
    (.lvf vf2 (&-> arg0 start-color quad))
    (.lvf vf3 (&-> arg0 start-vectors 1 quad))
    (.lvf vf4 (&-> arg0 start-vectors 2 quad))
    (.lvf vf5 (&-> arg0 start-qs quad))
    (.lvf vf6 (&-> arg0 start-vectors 4 quad))
    (.lvf vf7 (&-> arg0 end-color quad))
    (.lvf vf8 (&-> arg0 end-scale-offset quad))
    (.lvf vf9 (&-> arg0 end-vectors 2 quad))
    (.lvf vf10 (&-> arg0 end-qs quad))
    (.lvf vf11 (&-> arg0 end-vectors 4 quad))
    (.sub.vf vf7 vf7 vf2)
    (.sub.vf vf8 vf8 vf3)
    (.sub.vf vf9 vf9 vf4)
    (.sub.vf vf10 vf10 vf5)
    (.sub.vf vf11 vf11 vf6)
    (.mul.y.vf acc vf7 vf1)
    (.add.mul.w.vf vf2 vf2 vf0 acc)
    (.mul.y.vf acc vf8 vf1)
    (.add.mul.w.vf vf3 vf3 vf0 acc)
    (.mul.y.vf acc vf9 vf1)
    (.add.mul.w.vf vf4 vf4 vf0 acc)
    (.mul.y.vf acc vf10 vf1)
    (.add.mul.w.vf vf5 vf5 vf0 acc)
    (.mul.y.vf acc vf11 vf1)
    (.add.mul.w.vf vf6 vf6 vf0 acc)
    (.max.x.vf vf2 vf2 vf0)
    (.min.z.vf vf2 vf2 vf1)
    (.svf (&-> arg0 interpolated-color quad) vf2)
    (.svf (&-> arg0 interpolated-scale-offset quad) vf3)
    (.svf (&-> arg0 interpolated-st-scale-offset quad) vf4)
    (.svf (&-> arg0 interpolated-qs quad) vf5)
    (.svf (&-> arg0 interpolated-rot quad) vf6)
    (none)
    )
  )

(defun texture-anim-layer-add-shader ((arg0 dma-buffer) (arg1 texture-anim-layer) (arg2 int))
  "Add DMA to set the GS to use the given shader. This can be used to read from the texture."
  (let ((s5-0 (-> arg1 tex)))
    (if s5-0
        (dma-buffer-add-gs-set arg0
                               (tex0-1 (new 'static 'gs-tex0
                                         :cld #x1
                                         :psm (the-as int (-> s5-0 psm))
                                         :cpsm (-> s5-0 clutpsm)
                                         :cbp (-> s5-0 clutdest)
                                         :tcc arg2
                                         :th (log2 (-> s5-0 h))
                                         :tw (log2 (-> s5-0 w))
                                         :tbw (-> s5-0 width 0)
                                         :tbp0 (-> s5-0 dest 0)
                                         )
                                       )
                               (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1))
                               (test-1 (-> arg1 test))
                               (clamp-1 (-> arg1 clamp))
                               (alpha-1 (-> arg1 alpha))
                               )
        )
    )
  (none)
  )

(defun texture-anim-layer-add-clut-shader ((arg0 dma-buffer) (arg1 texture-anim-layer) (arg2 int))
  "Add DMA to set the GS to use the clut as a ct32 texture. This is used to abuse the GS to blend cluts by pretending they are ct32's."
  (let ((a1-1 (-> arg1 tex)))
    (if a1-1
        (dma-buffer-add-gs-set arg0
                               (tex0-1 (new 'static 'gs-tex0 :tbw #x1 :tw #x4 :th #x4 :tcc arg2 :tbp0 (-> a1-1 clutdest)))
                               (tex1-1 (new 'static 'gs-tex1))
                               (test-1 (new 'static 'gs-test :ate #x1 :afail #x1 :zte #x1 :ztst (gs-ztest always)))
                               (clamp-1 (new 'static 'gs-clamp :wms (gs-tex-wrap-mode clamp) :wmt (gs-tex-wrap-mode clamp)))
                               (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1))
                               )
        )
    )
  (none)
  )

(defun texture-anim-layer-draw ((dma-buf dma-buffer) (width int) (height int) (layer texture-anim-layer))
  "Add DMA to do a rectangular draw.
   Uses the interpolated quantities for sizes/rotations/positions.
   Always draws a tristrip with two triangles.
   "
  (local-vars (v1-27 float) (sv-224 matrix) (sv-228 matrix) (sv-232 matrix) (sv-236 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 (the-as (pointer uint128) (-> dma-buf base))))
      (set! (-> s4-0 0) (-> *texture-anim-work* draw-tmpl dma-vif quad))
      (set! (-> s4-0 1) (-> *texture-anim-work* draw-tmpl quad 1))
      (set! sv-224 (new 'stack-no-clear 'matrix))
      (set! sv-228 (new 'stack-no-clear 'matrix))
      (set! sv-232 (new 'stack-no-clear 'matrix))
      (let ((v1-7 (new 'stack-no-clear 'matrix)))
        (set! (-> v1-7 quad 0) (the-as uint128 0))
        (set! sv-236 v1-7)
        )
      (let ((s3-0 *texture-anim-work*))
        (.lvf vf1 (&-> s3-0 const quad))
        (.lvf vf2 (&-> layer interpolated-color quad))
        (.mul.x.vf vf2 vf2 vf1)
        (.ftoi.vf vf2 vf2)
        (.svf (&-> s4-0 2) vf2)
        (matrix-rotate-z! sv-224 (-> layer interpolated-rot x))
        (set! (-> sv-236 vector 0 x) (* (-> layer interpolated-scale-offset x) (the float width)))
        (set! (-> sv-236 vector 0 y) (* (-> layer interpolated-scale-offset y) (the float height)))
        (matrix-scale! sv-232 (the-as vector sv-236))
        (matrix*! sv-224 sv-232 sv-224)
        (set! (-> sv-224 trans x) (+ 2048.0 (* (-> layer interpolated-scale-offset z) (the float width))))
        (set! (-> sv-224 trans y) (+ 2048.0 (* (-> layer interpolated-scale-offset w) (the float height))))
        (set! (-> sv-224 trans z) 1048575.94)
        (matrix-rotate-z! sv-228 (-> layer interpolated-rot y))
        (set! (-> sv-236 vector 0 x) (-> layer interpolated-st-scale-offset x))
        (set! (-> sv-236 vector 0 y) (-> layer interpolated-st-scale-offset y))
        (matrix-scale! sv-232 (the-as vector sv-236))
        (matrix*! sv-228 sv-232 sv-228)
        (set! (-> sv-228 trans x) (-> layer interpolated-st-scale-offset z))
        (set! (-> sv-228 trans y) (-> layer interpolated-st-scale-offset w))
        (.lvf vf11 (&-> sv-224 quad 0))
        (.lvf vf12 (&-> sv-224 quad 1))
        (.lvf vf14 (&-> sv-224 trans quad))
        (.lvf vf15 (&-> sv-228 quad 0))
        (.lvf vf16 (&-> sv-228 quad 1))
        (.lvf vf18 (&-> sv-228 trans quad))
        (.lvf vf7 (&-> s3-0 corner0 quad))
        (.lvf vf8 (&-> s3-0 corner1 quad))
        (.lvf vf9 (&-> s3-0 corner2 quad))
        (.lvf vf10 (&-> s3-0 corner3 quad))
        )
      (.lvf vf19 (&-> layer interpolated-qs quad))
      (.mul.x.vf acc vf11 vf7)
      (.add.mul.y.vf acc vf12 vf7 acc)
      (.add.mul.w.vf vf3 vf14 vf0 acc)
      (.mul.x.vf acc vf11 vf8)
      (.add.mul.y.vf acc vf12 vf8 acc)
      (.add.mul.w.vf vf4 vf14 vf0 acc)
      (.mul.x.vf acc vf11 vf9)
      (.add.mul.y.vf acc vf12 vf9 acc)
      (.add.mul.w.vf vf5 vf14 vf0 acc)
      (.mul.x.vf acc vf11 vf10)
      (.add.mul.y.vf acc vf12 vf10 acc)
      (.add.mul.w.vf vf6 vf14 vf0 acc)
      (.mul.x.vf acc vf15 vf7)
      (.add.mul.y.vf acc vf16 vf7 acc)
      (.add.mul.w.vf vf7 vf18 vf0 acc)
      (vftoi4.xyzw vf3 vf3)
      (.mul.x.vf acc vf15 vf8)
      (.add.mul.y.vf acc vf16 vf8 acc)
      (.add.mul.w.vf vf8 vf18 vf0 acc)
      (vftoi4.xyzw vf4 vf4)
      (.mul.x.vf acc vf15 vf9)
      (.add.mul.y.vf acc vf16 vf9 acc)
      (.add.mul.w.vf vf9 vf18 vf0 acc)
      (vftoi4.xyzw vf5 vf5)
      (.mul.x.vf acc vf15 vf10)
      (.add.mul.y.vf acc vf16 vf10 acc)
      (.add.mul.w.vf vf10 vf18 vf0 acc)
      (vftoi4.xyzw vf6 vf6)
      (.add.x.vf vf7 vf0 vf19 :mask #b100)
      (.add.y.vf vf8 vf0 vf19 :mask #b100)
      (.add.z.vf vf9 vf0 vf19 :mask #b100)
      (.add.w.vf vf10 vf0 vf19 :mask #b100)
      (.mul.z.vf vf7 vf7 vf7 :mask #b11)
      (.mul.z.vf vf8 vf8 vf8 :mask #b11)
      (.mul.z.vf vf9 vf9 vf9 :mask #b11)
      (.mul.z.vf vf10 vf10 vf10 :mask #b11)
      (.svf (&-> s4-0 3) vf7)
      (.svf (&-> s4-0 4) vf3)
      (.svf (&-> s4-0 5) vf8)
      (.svf (&-> s4-0 6) vf4)
      (.svf (&-> s4-0 7) vf9)
      (.svf (&-> s4-0 8) vf5)
      (.svf (&-> s4-0 9) vf10)
      (.svf (&-> s4-0 10) vf6)
      )
    (.mov v1-27 vf6)
    (&+! (-> dma-buf base) 176)
    (none)
    )
  )

(defun default-texture-anim-layer-func ((dma-buf dma-buffer) (arg1 uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Apply texture animation layer. This interpolates the layer given the time, sets up the GS to _read_ from the given texture, then
   does the draw."
  (when (and (>= time (-> layer start-time)) (>= (-> layer end-time) time))
    (texture-anim-layer-interp layer time)
    (when (!= (-> layer interpolated-color w) 0.0)
      (texture-anim-layer-add-shader dma-buf layer 1)
      (texture-anim-layer-draw dma-buf width height layer)
      )
    )
  0
  )

(defun blend-clut-texture-anim-layer-func ((dma-buf dma-buffer) (arg1 uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Apply texture animation layer to the clut. This interpolates the layer, sets up the GS to _read_ from the given texture's
   clut as a 16x16 psm32, then does the draw."
  (when (and (>= time (-> layer start-time)) (>= (-> layer end-time) time))
    (texture-anim-layer-interp layer time)
    (when (!= (-> layer interpolated-color w) 0.0)
      (texture-anim-layer-add-clut-shader dma-buf layer 0)
      (texture-anim-layer-draw dma-buf 16 16 layer)
      )
    )
  0
  )

(defun move-rg-to-ba-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Some cursed texture drawing."
  (-> layer tex)
  (let ((tw (log2 (* width 2)))
        (th (log2 height))
        (tbp (-> layer tex dest 0))
        (tbw (/ (+ (* width 2) 63) 64))
        (fbmask #x3fff)
        )
    (dma-buffer-add-gs-set-flusha dma-buf
                                  (xyoffset-1 (new 'static 'gs-xy-offset))
                                  (frame-1 (new 'static 'gs-frame :psm (gs-psm ct16) :fbmsk fbmask :fbw tbw :fbp fbp-to-draw))
                                  (scissor-1 (new 'static 'gs-scissor :scax1 (+ width -1) :scay1 (+ height -1)))
                                  (test-1 (new 'static 'gs-test :ate #x1 :afail #x1 :zte #x1 :ztst (gs-ztest always)))
                                  (alpha-1 (new 'static 'gs-alpha :a #x2 :b #x2 :c #x2 :fix #x80))
                                  (tex0-1 (new 'static 'gs-tex0 :psm #x2 :tcc #x1 :tfx #x1 :th th :tw tw :tbw tbw :tbp0 tbp))
                                  (fba-1 0)
                                  (texa (new 'static 'gs-texa :ta1 #x80))
                                  (tex1-1 (new 'static 'gs-tex1 :lcm #x1))
                                  (texflush 0)
                                  (prim (new 'static 'gs-prim :prim (gs-prim-type sprite) :tme #x1 :abe #x1 :fst #x1))
                                  )
    (let ((a3-4 height))
      (dotimes (t0-7 (/ width 16))
        (dma-buffer-add-gs-set dma-buf
                               (uv (new 'static 'gs-uv :v #x8 :u (+ (* t0-7 256) 8)))
                               (xyz2 (new 'static 'gs-xyz :x (+ (* t0-7 256) 128)))
                               (uv (new 'static 'gs-uv :u (+ (* t0-7 256) 136) :v (+ (* a3-4 16) 8)))
                               (xyz2 (new 'static 'gs-xyz :y (* a3-4 16) :x (+ (* t0-7 256) 256)))
                               )
        )
      )
    (let ((t1-40 (/ width 64)))
      (dma-buffer-add-gs-set dma-buf
                             (frame-1 (new 'static 'gs-frame :psm (gs-psm ct16) :fbmsk fbmask :fbw tbw :fbp (+ fbp-to-draw t1-40)))
                             (tex0-1 (new 'static 'gs-tex0 :psm #x2 :tcc #x1 :tfx #x1 :th th :tw tw :tbw tbw :tbp0 (+ tbp (* t1-40 32))))
                             (prim (new 'static 'gs-prim :prim (gs-prim-type sprite) :tme #x1 :abe #x1 :fst #x1))
                             )
      )
    )
  (dotimes (v1-8 (/ width 16))
    (dma-buffer-add-gs-set dma-buf
                           (uv (new 'static 'gs-uv :v #x8 :u (+ (* v1-8 256) 8)))
                           (xyz2 (new 'static 'gs-xyz :x (+ (* v1-8 256) 128)))
                           (uv (new 'static 'gs-uv :u (+ (* v1-8 256) 136) :v (+ (* height 16) 8)))
                           (xyz2 (new 'static 'gs-xyz :y (* height 16) :x (+ (* v1-8 256) 256)))
                           )
    )

  ;; manually done from the stuff below.
  (dma-buffer-add-gs-set-flusha dma-buf
                                (xyoffset-1 (new 'static 'gs-xy-offset :ofx #x7000 :ofy #x7300))
                                (frame-1 (new 'static 'gs-frame :fbw (/ (+ width 63) 64) :fbp fbp-to-draw))
                                )
  #|
  ;; not sure why this doesn't become a macro
  (let* ((v1-11 dma-buf)
         (a0-15 (the-as dma-packet (-> v1-11 base)))
         )
    (set! (-> a0-15 dma) (new 'static 'dma-tag :qwc #x3 :id (dma-tag-id cnt)))
    (set! (-> a0-15 vif0) (new 'static 'vif-tag :cmd (vif-cmd flusha) :msk #x1))
    (set! (-> a0-15 vif1) (new 'static 'vif-tag :imm #x3 :cmd (vif-cmd direct) :msk #x1))
    (set! (-> v1-11 base) (the-as pointer (&+ a0-15 16)))
    )
  (let* ((v1-12 dma-buf)
         (a0-17 (the-as gs-gif-tag (-> v1-12 base)))
         )
    (set! (-> a0-17 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x2))
    (set! (-> a0-17 regs) GIF_REGS_ALL_AD)
    (set! (-> v1-12 base) (the-as pointer (&+ a0-17 16)))
    )
  (let ((v1-13 (-> dma-buf base)))
    (set! (-> (the-as (pointer gs-xy-offset) v1-13) 0) (new 'static 'gs-xy-offset :ofx #x7000 :ofy #x7300))
    (set! (-> (the-as (pointer gs-reg64) v1-13) 1) (gs-reg64 xyoffset-1))
    (set! (-> (the-as (pointer gs-frame) v1-13) 2)
          (new 'static 'gs-frame :fbw (/ (+ width 63) 64) :fbp fbp-to-draw)
          )
    (set! (-> (the-as (pointer gs-reg64) v1-13) 3) (gs-reg64 frame-1))
    (set! (-> dma-buf base) (&+ v1-13 32))
    )
    |#
  0
  )

(defun fill-rgb-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Layer function to just draw RGB. This uses a full size sprite and ignores the offset/rotations."
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         )
    (let ((s5-0 (/ (+ width 63) 64)))
      ;; set frame to mask alpha
      (dma-buffer-add-gs-set-flusha dma-buf
                                    (frame-1 (new 'static 'gs-frame :fbmsk #xff000000 :fbw s5-0 :fbp fbp-to-draw))
                                    (texflush 0)
                                    )
      ;; make sure interp is up to date
      (texture-anim-layer-interp layer time)
      ;; sprite coordinates.
      (let ((v1-4 (-> dma-buf base))
            (a3-1 2048)
            (a2-5 2048)
            (a0-8 (+ width 2048))
            (a1-15 (+ height 2048))
            )
        (set! (-> (the-as (pointer uint128) v1-4)) (-> *texture-anim-work* fill-tmpl dma-vif quad))
        (set! (-> (the-as (pointer uint128) v1-4) 1) (-> *texture-anim-work* fill-tmpl quad 1))
        (.lvf vf1 (&-> *texture-anim-work* const quad))
        (.lvf vf2 (&-> layer interpolated-color quad))
        (.mul.x.vf vf2 vf2 vf1)
        (.ftoi.vf vf2 vf2)
        (.svf (&-> (the-as (pointer uint128) v1-4) 2) vf2)
        (set-vector! (the-as vector4w (&+ v1-4 48)) (* a3-1 16) (* a2-5 16) 0 0)
        (set-vector! (the-as vector4w (&+ v1-4 64)) (* a0-8 16) (* a1-15 16) 0 0)
        )
      (&+! (-> dma-buf base) 80)
      ;; reset frame.
      (dma-buffer-add-gs-set-flusha dma-buf
                                    (frame-1 (new 'static 'gs-frame :fbw s5-0 :fbp fbp-to-draw))
                                    (texflush 0)
                                    )
      ; (let* ((v1-8 dma-buf)
      ;        (a0-11 (the-as dma-packet (-> v1-8 base)))
      ;        )
      ;   (set! (-> a0-11 dma) (new 'static 'dma-tag :qwc #x3 :id (dma-tag-id cnt)))
      ;   (set! (-> a0-11 vif0) (new 'static 'vif-tag :cmd (vif-cmd flusha) :msk #x1))
      ;   (set! (-> a0-11 vif1) (new 'static 'vif-tag :imm #x3 :cmd (vif-cmd direct) :msk #x1))
      ;   (set! (-> v1-8 base) (the-as pointer (&+ a0-11 16)))
      ;   )
      ; (let* ((v1-9 dma-buf)
      ;        (a0-13 (the-as gs-gif-tag (-> v1-9 base)))
      ;        )
      ;   (set! (-> a0-13 tag) (new 'static 'gif-tag64 :nloop #x1 :eop #x1 :nreg #x2))
      ;   (set! (-> a0-13 regs) GIF_REGS_ALL_AD)
      ;   (set! (-> v1-9 base) (the-as pointer (&+ a0-13 16)))
      ;   )
      ; (let ((v1-10 (-> dma-buf base)))
      ;   (set! (-> (the-as (pointer gs-frame) v1-10) 0) (new 'static 'gs-frame :fbw s5-0 :fbp fbp-to-draw))
      ;   (set! (-> (the-as (pointer gs-reg64) v1-10) 1) (gs-reg64 frame-1))
      ;   (set! (-> (the-as (pointer uint64) v1-10) 2) (the-as uint 0))
      ;   (set! (-> (the-as (pointer gs-reg64) v1-10) 3) (gs-reg64 texflush))
      ;   (set! (-> dma-buf base) (&+ v1-10 32))
      ;   )
      )
    0
    )
  )

(defun update-texture-anim ((bucket bucket-id) (anim-array texture-anim-array))
  "Generate all DMA to update all textures in the given list for the given bucket."
  (local-vars (tex-height int) (fbp-for-tex uint) (layer-idx int))
  (with-pp
    (if (-> *blit-displays-work* menu-mode)
        (return #f)
        )
    (with-dma-buffer-add-bucket ((dma-buf (-> *display* frames (-> *display* on-screen) global-buf))
                                 bucket
                                 )
      ;; loop over animated textures. Each will produce a single texture.
      (dotimes (anim-idx (-> anim-array length))
        (let* ((anim (-> anim-array array-data anim-idx))
               (dest-tex (-> anim tex))
               )
          (when dest-tex
            0
            (let ((tex-width (-> dest-tex w)))
              (set! tex-height (-> dest-tex h))
              (cond
                ((or (= (-> dest-tex psm) (gs-psm ct32)) (= (-> dest-tex psm) (gs-psm mt8h)))
                 ;; animating the actual texture data.
                 (set! fbp-for-tex (shr (-> dest-tex dest 0) 5))
                 fbp-for-tex
                 )
                (else
                  ;; animating the clut.
                  (set! fbp-for-tex (shr (-> dest-tex clutdest) 5))
                  (set! tex-width 16)
                  (set! tex-height 16)
                  tex-height
                  )
                )
              (when (and (nonzero? tex-width) (nonzero? tex-height))
                ;; configure for drawing to this texture.
                (dma-buffer-add-gs-set-flusha dma-buf
                                              (scissor-1 (new 'static 'gs-scissor :scax1 (+ tex-width -1) :scay1 (+ tex-height -1)))
                                              (xyoffset-1 (new 'static 'gs-xy-offset :ofx #x8000 :ofy #x8000))
                                              ;; setting fbp here is what makes it draw to the texture, not frambeuffer.
                                              (frame-1 (new 'static 'gs-frame :fbw (/ (+ tex-width 63) 64) :fbp fbp-for-tex))
                                              (test-1 (-> anim test))
                                              (alpha-1 (-> anim alpha))
                                              (clamp-1 (-> anim clamp))
                                              (texa (new 'static 'gs-texa :ta0 #x80 :ta1 #x80))
                                              (zbuf-1 (new 'static 'gs-zbuf :zbp #x130 :psm (gs-psm ct24) :zmsk #x1))
                                              (texflush 0)
                                              )
                ;; erase whatever was here previously
                (let ((a1-32 (-> dma-buf base))
                      (a3-0 2048)
                      (a2-7 2048)
                      (v1-25 (+ tex-width 2048))
                      (a0-16 (+ tex-height 2048))
                      )
                  (set! (-> (the-as (pointer uint128) a1-32)) (-> *texture-anim-work* erase-tmpl dma-vif quad))
                  (set! (-> (the-as (pointer uint128) a1-32) 1) (-> *texture-anim-work* erase-tmpl quad 1))
                  (set-vector!
                    (the-as vector4w (&+ a1-32 32))
                    (the-as int (-> anim color r))
                    (the-as int (-> anim color g))
                    (the-as int (-> anim color b))
                    (the-as int (-> anim color a))
                    )
                  (set-vector! (the-as vector4w (&+ a1-32 48)) (* a3-0 16) (* a2-7 16) #xffffff 0)
                  (set-vector! (the-as vector4w (&+ a1-32 64)) (* v1-25 16) (* a0-16 16) #xffffff 0)
                  )
                (&+! (-> dma-buf base) 80)
                )

              ;; this animated texture may overlap with other textures from other pages.
              ;; we're writing over this from outside of the usual texture page upload system.
              ;; so we should manually clear the id arrays for our pages, to make sure the texture
              ;; system re-uploads textures if needed.
              (let ((v1-32 (/ (the-as int fbp-for-tex) 2))
                    (a0-19 (* (/ (+ tex-width 63) 64) (/ (+ tex-height 63) 64)))
                    )
                (if (and (logtest? fbp-for-tex 1) (< 32 tex-width))
                    (+! a0-19 1)
                    )
                (dotimes (a1-43 a0-19)
                  (set! (-> *texture-pool* ids (+ v1-32 a1-43)) (the-as uint 0))
                  )
                )

              ;; loop over layers
              (set! layer-idx 0)
              (while (< layer-idx (the-as int (-> anim num-layers)))
                (let ((layer (-> anim data layer-idx)))
                  ;; generate DMA for this layer's effect
                  ((-> layer func) dma-buf fbp-for-tex tex-width tex-height layer (-> anim frame-time))
                  )
                (set! layer-idx (+ layer-idx 1))
                )
              )
            ;; some sort of final function (TODO args here)
            (if (-> anim func)
                ((-> anim func) (the-as texture-anim dma-buf))
                )

            ;; advance animation.
            (when (not (paused?))
              (let ((f0-2 (+ (-> anim frame-time) (* (-> anim frame-delta) (-> pp clock seconds-per-frame))))
                    (f1-2 (-> anim frame-mod))
                    )
                (set! (-> anim frame-time) (- f0-2 (* (the float (the int (/ f0-2 f1-2))) f1-2)))
                )
              (if (< (-> anim frame-time) 0.0)
                  (+! (-> anim frame-time) (-> anim frame-mod))
                  )
              )
            )
          )
        )

      ;; reset GS registers - we messed with frame/scissor.
      (reset-display-gs-state *display* dma-buf)
      )
    0
    (none)
    )
  )

(defun no-alpha-texture-anim-layer-func ((dma-buf dma-buffer) (fbp-to-draw uint) (width int) (height int) (layer texture-anim-layer) (time float))
  "Like others, but the tcc value is 0"
  (when (and (>= time (-> layer start-time)) (>= (-> layer end-time) time))
    (texture-anim-layer-interp layer time)
    (when (!= (-> layer interpolated-color w) 0.0)
      (texture-anim-layer-add-shader dma-buf layer 0)
      (texture-anim-layer-draw dma-buf width height layer)
      )
    )
  0
  )

;; todo copy-alpha-texture-anim-layer-func
;; todo copy-clut-alpha-texture-anim-layer-func
;; todo set-alpha-texture-anim-layer-func
;; todo set-clut-alpha-texture-anim-layer-func

(defun dest-texture-init ((tex-anim texture-anim))
  "Set up the texture object to hold the destination (result) texture."
  (let ((dest-tex (new 'loading-level 'texture)))
    (let ((size (the int (-> tex-anim extra x))))
      (let ((dest (the int (-> tex-anim extra y))))
        (set! (-> tex-anim tex) dest-tex)
        (set! (-> dest-tex w) size)
        (set! (-> dest-tex h) size)
        (set! (-> dest-tex num-mips) (the-as uint 1))
        (set! (-> dest-tex psm) (gs-psm ct32))
        (set! (-> dest-tex dest 0) (the-as uint (* dest 32)))
        )
      (set! (-> dest-tex width 0) (the-as uint (/ (+ size 63) 64)))
      )
    (set! (-> dest-tex masks data 0 mask quad) (the-as uint128 0))
    (set! (-> dest-tex masks data 1 mask quad) (the-as uint128 0))
    (set! (-> dest-tex masks data 2 mask quad) (the-as uint128 0))
    )
  0
  0
  (none)
  )

(defun src-texture-init ((layer texture-anim-layer))
  "Allocate a texture object to hold a source texture. This is only used for source textures that are generated at runtime,
   like random noise. Layers may include a reference to an existing texture instead."
  (let ((tex (new 'loading-level 'texture)))
    (let ((size (the int (-> layer extra x))))
      (let ((addr (the int (-> layer extra y))))
        (set! (-> layer tex) tex)
        (set! (-> tex w) size)
        (set! (-> tex h) size)
        (set! (-> tex num-mips) (the-as uint 1))
        (set! (-> tex psm) (gs-psm ct32))
        (set! (-> tex dest 0) (the-as uint (* addr 32)))
        )
      (set! (-> tex width 0) (the-as uint (/ (+ size 63) 64)))
      )
    (set! (-> tex masks data 0 mask quad) (the-as uint128 0))
    (set! (-> tex masks data 1 mask quad) (the-as uint128 0))
    (set! (-> tex masks data 2 mask quad) (the-as uint128 0))
    )
  0
  0
  (none)
  )