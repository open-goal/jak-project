;;-*-Lisp-*-
(in-package goal)

;; name: lightning.gc
;; name in dgo: lightning
;; dgos: ENGINE, GAME

(define-extern lightning-fractal-gen (function (inline-array vector) int int float lightning-spec none))
(define-extern lightning-trail-fractal-gen (function (inline-array vector) (inline-array vector) int int float lightning-spec none))

;; DECOMP BEGINS

(kmemopen global "part-tables")

(define *lightning-spec-id-table* (new 'global 'boxed-array lightning-spec 128))

(kmemclose)

(define *lightning-gcf*
  (new 'static 'gcf-control
    :giftag (new 'static 'generic-gif-tag :data (new 'static 'array uint32 4 #x302ec000 #x302e4000 #x412 #x0))
    :adnops (new 'static 'inline-array gs-adcmd 2
      (new 'static 'gs-adcmd :word (new 'static 'array uint32 4 #x0 #x0 #x7f #x0))
      (new 'static 'gs-adcmd :word (new 'static 'array uint32 4 #x0 #x0 #x7f #x0))
      )
    )
  )

(defun lightning-fractal-gen ((arg0 (inline-array vector)) (arg1 int) (arg2 int) (arg3 float) (arg4 lightning-spec))
  (local-vars (sv-16 vector) (sv-32 vector))
  (when (< 1 (- arg2 arg1))
    (let ((s1-0 (/ (+ arg1 arg2) 2)))
      (set! sv-16 (-> arg0 arg1))
      (set! sv-32 (-> arg0 arg2))
      (let ((s0-0 (-> arg0 s1-0)))
        (let* ((f30-0 (* 0.5 (+ (-> sv-16 x) (-> sv-32 x))))
               (f28-0 arg3)
               (f26-0 -0.5)
               (v1-12 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-13 (the-as number (logior #x3f800000 v1-12)))
               )
          (set! (-> s0-0 x) (+ f30-0 (* f28-0 (+ f26-0 (+ -1.0 (the-as float v1-13))))))
          )
        (let* ((f30-1 (* 0.5 (+ (-> sv-16 y) (-> sv-32 y))))
               (f28-1 arg3)
               (f26-1 -0.5)
               (v1-19 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-20 (the-as number (logior #x3f800000 v1-19)))
               )
          (set! (-> s0-0 y) (+ f30-1 (* f28-1 (+ f26-1 (+ -1.0 (the-as float v1-20))))))
          )
        (let* ((f30-2 (* 0.5 (+ (-> sv-16 z) (-> sv-32 z))))
               (f28-2 arg3)
               (f26-2 -0.5)
               (v1-26 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-27 (the-as number (logior #x3f800000 v1-26)))
               )
          (set! (-> s0-0 z) (+ f30-2 (* f28-2 (+ f26-2 (+ -1.0 (the-as float v1-27))))))
          )
        )
      (lightning-fractal-gen arg0 arg1 s1-0 (* arg3 (-> arg4 reduction)) arg4)
      (lightning-fractal-gen arg0 s1-0 arg2 (* arg3 (-> arg4 reduction)) arg4)
      )
    )
  0
  (none)
  )

(defun lightning-uniform-gen ((arg0 (inline-array vector)) (arg1 int) (arg2 int) (arg3 float) (arg4 lightning-spec))
  (local-vars (sv-32 vector))
  (let ((s4-0 (-> arg0 arg1))
        (s3-0 (-> arg0 arg2))
        (f30-0 (/ 1.0 (the float (- arg2 arg1))))
        (f28-0 0.0)
        (s2-0 (new-stack-vector0))
        (s1-0 arg1)
        (s0-0 arg2)
        )
    (while (>= s0-0 s1-0)
      (vector-lerp! (-> arg0 s1-0) s4-0 s3-0 f28-0)
      (set! sv-32 s2-0)
      (let* ((f26-0 0.4)
             (f24-0 -0.5)
             (v1-7 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-8 (the-as number (logior #x3f800000 v1-7)))
             )
        (set! (-> sv-32 x) (* f26-0 (+ f24-0 (+ -1.0 (the-as float v1-8))) arg3))
        )
      (let* ((f26-1 0.4)
             (f24-1 -0.5)
             (v1-13 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-14 (the-as number (logior #x3f800000 v1-13)))
             )
        (set! (-> sv-32 y) (* f26-1 (+ f24-1 (+ -1.0 (the-as float v1-14))) arg3))
        )
      (let* ((f26-2 0.4)
             (f24-2 -0.5)
             (v1-19 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
             (v1-20 (the-as number (logior #x3f800000 v1-19)))
             )
        (set! (-> sv-32 z) (* f26-2 (+ f24-2 (+ -1.0 (the-as float v1-20))) arg3))
        )
      (set! (-> sv-32 w) 1.0)
      (vector+! (-> arg0 s1-0) (-> arg0 s1-0) s2-0)
      (+! f28-0 f30-0)
      (+! s1-0 1)
      )
    )
  0
  (none)
  )

(defun lightning-trail-uniform-gen ((arg0 (inline-array vector)) (arg1 (inline-array vector)) (arg2 float) (arg3 int))
  (let ((s2-0 (new 'stack-no-clear 'vector)))
    (dotimes (s1-0 arg3)
      (let ((s0-0 s2-0))
        (let* ((f30-0 0.4)
               (f28-0 -0.5)
               (v1-3 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-4 (the-as number (logior #x3f800000 v1-3)))
               )
          (set! (-> s0-0 x) (* f30-0 (+ f28-0 (+ -1.0 (the-as float v1-4))) arg2))
          )
        (let* ((f30-1 0.4)
               (f28-1 -0.5)
               (v1-9 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-10 (the-as number (logior #x3f800000 v1-9)))
               )
          (set! (-> s0-0 y) (* f30-1 (+ f28-1 (+ -1.0 (the-as float v1-10))) arg2))
          )
        (let* ((f30-2 0.4)
               (f28-2 -0.5)
               (v1-15 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-16 (the-as number (logior #x3f800000 v1-15)))
               )
          (set! (-> s0-0 z) (* f30-2 (+ f28-2 (+ -1.0 (the-as float v1-16))) arg2))
          )
        (set! (-> s0-0 w) 1.0)
        )
      (vector+! (-> arg0 s1-0) (-> arg1 s1-0) s2-0)
      )
    )
  #f
  )

(defun lightning-trail-fractal-gen ((arg0 (inline-array vector))
                           (arg1 (inline-array vector))
                           (arg2 int)
                           (arg3 int)
                           (arg4 float)
                           (arg5 lightning-spec)
                           )
  (local-vars (sv-80 vector) (sv-96 vector) (sv-112 vector) (sv-128 vector) (sv-144 vector))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (when (< 1 (- arg3 arg2))
      (let ((s0-0 (/ (+ arg2 arg3) 2)))
        (set! sv-96 (new 'stack-no-clear 'vector))
        (let ((v1-5 (-> arg0 arg2))
              (a0-3 (-> arg1 arg2))
              )
          (.lvf vf4 (&-> v1-5 quad))
          (.lvf vf5 (&-> a0-3 quad))
          )
        (.mov.vf vf6 vf0 :mask #b1000)
        (.sub.vf vf6 vf4 vf5 :mask #b111)
        (.svf (&-> sv-96 quad) vf6)
        (set! sv-112 (new 'stack-no-clear 'vector))
        (let ((v1-9 (-> arg0 arg3))
              (a0-5 (-> arg1 arg3))
              )
          (.lvf vf4 (&-> v1-9 quad))
          (.lvf vf5 (&-> a0-5 quad))
          )
        (.mov.vf vf6 vf0 :mask #b1000)
        (.sub.vf vf6 vf4 vf5 :mask #b111)
        (.svf (&-> sv-112 quad) vf6)
        (set! sv-144 (new 'stack-no-clear 'vector))
        (set! sv-128 (new 'stack-no-clear 'vector))
        (set! sv-80 sv-144)
        (let* ((f30-0 arg4)
               (f28-0 -0.5)
               (v1-15 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-16 (the-as number (logior #x3f800000 v1-15)))
               )
          (set! (-> sv-80 x) (* f30-0 (+ f28-0 (+ -1.0 (the-as float v1-16)))))
          )
        (let* ((f30-1 arg4)
               (f28-1 -0.5)
               (v1-20 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-21 (the-as number (logior #x3f800000 v1-20)))
               )
          (set! (-> sv-80 y) (* f30-1 (+ f28-1 (+ -1.0 (the-as float v1-21)))))
          )
        (let* ((f30-2 arg4)
               (f28-2 -0.5)
               (v1-25 (/ (the-as int (rand-uint31-gen *random-generator*)) 256))
               (v1-26 (the-as number (logior #x3f800000 v1-25)))
               )
          (set! (-> sv-80 z) (* f30-2 (+ f28-2 (+ -1.0 (the-as float v1-26)))))
          )
        (set! (-> sv-80 w) 1.0)
        (let ((v1-31 sv-128)
              (a0-15 sv-128)
              )
          (.mov.vf vf6 vf0 :mask #b1000)
          (.lvf vf4 (&-> sv-96 quad))
          (.lvf vf5 (&-> sv-112 quad))
          (.add.vf vf6 vf4 vf5 :mask #b111)
          (.svf (&-> a0-15 quad) vf6)
          (vector-float*! v1-31 a0-15 0.5)
          )
        (let ((v1-33 sv-144))
          (let ((a0-16 sv-144))
            (.mov.vf vf6 vf0 :mask #b1000)
            (.lvf vf4 (&-> a0-16 quad))
            )
          (.lvf vf5 (&-> sv-128 quad))
          (.add.vf vf6 vf4 vf5 :mask #b111)
          (.svf (&-> v1-33 quad) vf6)
          )
        (let ((v1-35 (-> arg0 s0-0)))
          (let ((a0-19 (-> arg1 s0-0)))
            (.mov.vf vf6 vf0 :mask #b1000)
            (.lvf vf4 (&-> a0-19 quad))
            )
          (.lvf vf5 (&-> sv-144 quad))
          (.add.vf vf6 vf4 vf5 :mask #b111)
          (.svf (&-> v1-35 quad) vf6)
          )
        (lightning-trail-fractal-gen arg0 arg1 arg2 s0-0 (* arg4 (-> arg5 reduction)) arg5)
        (lightning-trail-fractal-gen arg0 arg1 s0-0 arg3 (* arg4 (-> arg5 reduction)) arg5)
        )
      )
    0
    (none)
    )
  )

(deftype lightning-globals (structure)
  ((gcf-buf uint16  :offset-assert   0)
   (vtx-buf uint16  :offset-assert   2)
   )
  :method-count-assert 9
  :size-assert         #x4
  :flag-assert         #x900000004
  )


(defun gs-packed-rgba-lerp! ((arg0 gs-packed-rgba) (arg1 rgba) (arg2 rgba) (arg3 float))
  (local-vars (v1-0 uint128) (v1-1 uint128) (a1-1 uint128) (a1-2 uint128))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (.pextlb v1-0 0 arg1)
    (.pextlb a1-1 0 arg2)
    (.pextlh v1-1 0 v1-0)
    (.pextlh a1-2 0 a1-1)
    (.mov vf1 v1-1)
    (.mov vf2 a1-2)
    (.mov vf3 arg3)
    (.itof.vf vf1 vf1)
    (.itof.vf vf2 vf2)
    (.mul.w.vf acc vf1 vf0)
    (.add.mul.x.vf acc vf2 vf3 acc)
    (.sub.mul.x.vf vf1 vf1 vf3 acc)
    (.ftoi.vf vf1 vf1)
    (.svf (&-> arg0 quad) vf1)
    arg0
    )
  )

;; WARN: Return type mismatch int vs rgba.
(defun rgba-lerp ((arg0 rgba) (arg1 rgba) (arg2 rgba))
  (local-vars
    (v0-0 uint128)
    (v1-0 uint128)
    (v1-1 uint128)
    (a0-1 uint128)
    (a0-2 uint128)
    (a1-1 uint128)
    (a2-1 uint128)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (init-vf0-vector)
    (.pextlb v1-0 0 arg0)
    (.pextlb a0-1 0 arg1)
    (.pextlh v1-1 0 v1-0)
    (.pextlh a0-2 0 a0-1)
    (.mov vf1 v1-1)
    (.mov vf2 a0-2)
    (.mov vf3 arg2)
    (.itof.vf vf1 vf1)
    (.itof.vf vf2 vf2)
    (.mul.w.vf acc vf1 vf0)
    (.add.mul.x.vf acc vf2 vf3 acc)
    (.sub.mul.x.vf vf1 vf1 vf3 acc)
    (.ftoi.vf vf3 vf1)
    (.mov a1-1 vf3)
    (.ppach a2-1 (the-as uint128 0) a1-1)
    (.ppacb v0-0 (the-as uint128 0) a2-1)
    (the-as rgba v0-0)
    )
  )

(defbehavior lightning-fade process ((arg0 lightning-control))
  (local-vars (v0-1 int) (sv-16 rgba))
  (let ((f0-0 (-> arg0 spec fade-time)))
    (-> arg0 process 0 clock)
    (cond
      ((< (-> arg0 state counter) f0-0)
       (+! (-> arg0 state counter) (* 300.0 (-> self clock seconds-per-frame)))
       (let ((gp-0 (-> arg0 state)))
         (let* ((s5-0 (-> arg0 spec))
                (f30-0 (fmax 0.0 (fmin 1.0 (* (- 1.0 (/ (-> gp-0 counter) f0-0)) (-> s5-0 fade-start-factor)))))
                )
           (set! sv-16 (-> s5-0 fade-to-color))
           (set! (-> gp-0 start-color) (rgba-lerp sv-16 (-> s5-0 start-color) (the-as rgba f30-0)))
           (set! v0-1 (the-as int (rgba-lerp sv-16 (-> s5-0 end-color) (the-as rgba f30-0))))
           )
         (set! (-> gp-0 end-color) (the-as rgba v0-1))
         )
       )
      (else
        (let ((v1-9 arg0))
          (set! v0-1 0)
          (let ((a0-4 (!= v0-1 (-> v1-9 state mode))))
            (case v0-1
              ((3)
               (if a0-4
                   (set! (-> v1-9 state counter) 0.0)
                   )
               )
              ((1)
               (set! (-> v1-9 state start-color) (-> v1-9 spec start-color))
               (set! (-> v1-9 state end-color) (-> v1-9 spec end-color))
               )
              )
            )
          (set! (-> v1-9 state mode) (the-as lightning-mode v0-1))
          )
        )
      )
    )
  v0-1
  )

(defun lightning-update ((arg0 lightning-control))
  (local-vars
    (sv-16 lightning-spec)
    (sv-20 vector-array)
    (sv-24 vector-array)
    (sv-28 vector-array)
    (sv-32 symbol)
    (sv-36 clock)
    )
  (let* ((gp-0 (-> arg0 state points-to-draw))
         (s4-0 (+ gp-0 -1))
         (s5-0 (-> arg0 state))
         )
    (set! sv-16 (-> arg0 spec))
    (set! sv-20 (-> s5-0 line))
    (set! sv-24 (-> s5-0 meet))
    (set! sv-28 (-> s5-0 path))
    (set! sv-32 (= (-> s5-0 mode) (lightning-mode lm1)))
    (set! sv-36 (-> arg0 process 0 clock))
    (when (not (or (= (-> sv-36 time-adjust-ratio) 0.0) (< gp-0 2)))
      (when (logtest? (-> sv-16 flags) (lightning-spec-flags size-from-adjust-dist))
        (let ((f1-1 (vector-vector-distance (the-as vector (-> sv-24 data)) (-> sv-24 data s4-0))))
          (set! (-> s5-0 box-size)
                (* (-> sv-16 box-size) (fmax 1.0 (fmin 5.0 (/ f1-1 (* 4096.0 (the float (-> sv-16 adjust-distance)))))))
                )
          )
        )
      (set! (-> s5-0 counter) (fmax 0.0 (- (-> s5-0 counter) (-> sv-36 time-adjust-ratio))))
      (when sv-32
        (set! (-> s5-0 mode) (lightning-mode lm2))
        (set! (-> s5-0 counter) 0.0)
        )
      (when (>= 0.0 (-> s5-0 counter))
        (let ((v1-33 (-> sv-16 rand-func)))
          (cond
            ((or (zero? v1-33) (= v1-33 1))
             (let ((v1-35 (-> sv-16 rand-func)))
               (cond
                 ((zero? v1-35)
                  (lightning-fractal-gen (-> sv-24 data) 0 s4-0 (-> s5-0 box-size) sv-16)
                  )
                 ((= v1-35 1)
                  (lightning-uniform-gen (-> sv-24 data) 0 s4-0 (-> s5-0 box-size) sv-16)
                  )
                 )
               )
             (when sv-32
               (dotimes (v1-43 gp-0)
                 (set! (-> sv-20 data v1-43 quad) (-> sv-24 data v1-43 quad))
                 )
               )
             )
            ((or (= v1-33 2) (= v1-33 3))
             (case (-> sv-16 rand-func)
               ((2)
                (set! (-> sv-24 data 0 quad) (-> sv-28 data 0 quad))
                (set! (-> sv-24 data s4-0 quad) (-> sv-28 data s4-0 quad))
                (lightning-trail-fractal-gen (-> sv-24 data) (-> sv-28 data) 0 s4-0 (-> s5-0 box-size) sv-16)
                )
               (else
                 (lightning-trail-uniform-gen (-> sv-24 data) (-> sv-28 data) (-> s5-0 box-size) gp-0)
                 )
               )
             (when sv-32
               (dotimes (v1-63 gp-0)
                 (set! (-> sv-20 data v1-63 quad) (-> sv-28 data v1-63 quad))
                 )
               )
             )
            )
          )
        (set! (-> s5-0 counter) (the float (-> sv-16 merge-count)))
        )
      (let ((f0-14 (fmax 0.0 (fmin 1.0 (* (-> sv-16 merge-factor) (-> sv-36 time-adjust-ratio))))))
        (dotimes (v1-72 gp-0)
          (let* ((a1-21 (-> sv-20 data v1-72))
                 (a2-7 (-> sv-24 data v1-72))
                 (a0-31 a1-21)
                 )
            (set! (-> a0-31 x) (+ (-> a1-21 x) (* f0-14 (- (-> a2-7 x) (-> a1-21 x)))))
            (set! (-> a0-31 y) (+ (-> a1-21 y) (* f0-14 (- (-> a2-7 y) (-> a1-21 y)))))
            (set! (-> a0-31 z) (+ (-> a1-21 z) (* f0-14 (- (-> a2-7 z) (-> a1-21 z)))))
            )
          )
        )
      #f
      )
    )
  )

(defun lightning-draw ((arg0 dma-buffer) (arg1 lightning-control) (arg2 lightning-globals))
  (local-vars
    (sv-16 math-camera)
    (sv-20 (inline-array gcf-vertex))
    (sv-24 lightning-spec)
    (sv-28 float)
    (sv-32 texture)
    (sv-48 vector-array)
    (sv-64 int)
    (sv-80 int)
    (sv-96 int)
    (sv-112 int)
    (sv-128 int)
    (sv-144 int)
    (sv-160 int)
    (sv-176 gcf-control)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf17 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 *math-camera*)
    (set! sv-20 (the-as (inline-array gcf-vertex) *gsf-buffer*))
    (let* ((s3-0 (-> arg1 state points-to-draw))
           (s2-0 (+ s3-0 -1))
           (s1-0 *lightning-gcf*)
           (s0-0 (-> sv-16 camera-rot))
           )
      (set! sv-32 (lookup-texture-by-id (-> arg1 spec texture)))
      (set! sv-48 (-> arg1 state line))
      (set! sv-24 (-> arg1 spec))
      (when (< 1 s3-0)
        (set! sv-64 0)
        (while (< sv-64 2)
          (set! sv-28 (/ 1.0 (the float s2-0)))
          (cond
            ((logtest? (-> sv-24 flags) (lightning-spec-flags lsf0))
             (set! sv-80 0)
             (while (< sv-80 (* s3-0 2))
               (cond
                 ((not (logtest? sv-80 1))
                  (gs-packed-rgba-lerp!
                    (-> sv-20 sv-80 clr)
                    (-> arg1 state start-color)
                    (-> arg1 state end-color)
                    (* (the float (/ sv-80 2)) sv-28)
                    )
                  (let ((v1-25 (-> sv-20 sv-80)))
                    (set! (-> v1-25 tex x) 0)
                    (set! (-> v1-25 tex y) (* (/ 4096 s3-0) (/ sv-80 2)))
                    (set! (-> v1-25 tex z) 4096)
                    (set! (-> v1-25 tex w) 0)
                    )
                  )
                 (else
                   (gs-packed-rgba-lerp!
                     (-> sv-20 sv-80 clr)
                     (-> arg1 state start-color)
                     (-> arg1 state end-color)
                     (* (the float (/ sv-80 2)) sv-28)
                     )
                   (let ((v1-35 (-> sv-20 sv-80)))
                     (set! (-> v1-35 tex x) 4096)
                     (set! (-> v1-35 tex y) (* (/ 4096 s3-0) (/ sv-80 2)))
                     (set! (-> v1-35 tex z) 4096)
                     (set! (-> v1-35 tex w) 0)
                     )
                   )
                 )
               (set! sv-80 (+ sv-80 1))
               )
             )
            ((logtest? (-> sv-24 flags) (lightning-spec-flags lsf1))
             (dotimes (v1-45 (* s3-0 2))
               (cond
                 ((not (logtest? v1-45 1))
                  (let ((a0-26 (-> sv-20 v1-45)))
                    (set! (-> a0-26 tex x) 0)
                    (set! (-> a0-26 tex y) (* (/ 4096 s3-0) (/ v1-45 2)))
                    (set! (-> a0-26 tex z) 4096)
                    (set! (-> a0-26 tex w) 0)
                    )
                  )
                 (else
                   (let ((a0-30 (-> sv-20 v1-45)))
                     (set! (-> a0-30 tex x) 4096)
                     (set! (-> a0-30 tex y) (* (/ 4096 s3-0) (/ v1-45 2)))
                     (set! (-> a0-30 tex z) 4096)
                     (set! (-> a0-30 tex w) 0)
                     )
                   )
                 )
               )
             (dotimes (v1-48 (* s2-0 2))
               (set! (-> sv-20 v1-48 clr x) (the-as int (-> arg1 state start-color r)))
               (set! (-> sv-20 v1-48 clr y) (the-as int (-> arg1 state start-color g)))
               (set! (-> sv-20 v1-48 clr z) (the-as int (-> arg1 state start-color b)))
               (set! (-> sv-20 v1-48 clr w) (the-as int (-> arg1 state start-color a)))
               )
             (dotimes (v1-51 2)
               (let ((a0-45 (+ v1-51 (* s2-0 2))))
                 (set! (-> sv-20 a0-45 clr x) (the-as int (-> arg1 state end-color r)))
                 (set! (-> sv-20 a0-45 clr y) (the-as int (-> arg1 state end-color g)))
                 (set! (-> sv-20 a0-45 clr z) (the-as int (-> arg1 state end-color b)))
                 (set! (-> sv-20 a0-45 clr w) (the-as int (-> arg1 state end-color a)))
                 )
               )
             )
            ((logtest? (-> sv-24 flags) (lightning-spec-flags lsf2))
             (dotimes (v1-58 (* s3-0 2))
               (cond
                 ((not (logtest? v1-58 1))
                  (let ((a0-52 (-> sv-20 v1-58)))
                    (set! (-> a0-52 tex x) 0)
                    (set! (-> a0-52 tex y) (* (/ 4096 s3-0) (/ v1-58 2)))
                    (set! (-> a0-52 tex z) 4096)
                    (set! (-> a0-52 tex w) 0)
                    )
                  )
                 (else
                   (let ((a0-56 (-> sv-20 v1-58)))
                     (set! (-> a0-56 tex x) 4096)
                     (set! (-> a0-56 tex y) (* (/ 4096 s3-0) (/ v1-58 2)))
                     (set! (-> a0-56 tex z) 4096)
                     (set! (-> a0-56 tex w) 0)
                     )
                   )
                 )
               )
             (dotimes (v1-61 (* (+ s3-0 -2) 2))
               (let ((a0-58 (+ v1-61 2)))
                 (set! (-> sv-20 a0-58 clr x) (the-as int (-> arg1 state start-color r)))
                 (set! (-> sv-20 a0-58 clr y) (the-as int (-> arg1 state start-color g)))
                 (set! (-> sv-20 a0-58 clr z) (the-as int (-> arg1 state start-color b)))
                 (set! (-> sv-20 a0-58 clr w) (the-as int (-> arg1 state start-color a)))
                 )
               )
             (dotimes (v1-64 2)
               (let ((a0-63 v1-64))
                 (set! (-> sv-20 a0-63 clr x) (the-as int (-> arg1 state end-color r)))
                 (set! (-> sv-20 a0-63 clr y) (the-as int (-> arg1 state end-color g)))
                 (set! (-> sv-20 a0-63 clr z) (the-as int (-> arg1 state end-color b)))
                 (set! (-> sv-20 a0-63 clr w) (the-as int (-> arg1 state end-color a)))
                 )
               )
             (dotimes (v1-67 2)
               (let ((a0-67 (+ v1-67 (* s2-0 2))))
                 (set! (-> sv-20 a0-67 clr x) (the-as int (-> arg1 state end-color r)))
                 (set! (-> sv-20 a0-67 clr y) (the-as int (-> arg1 state end-color g)))
                 (set! (-> sv-20 a0-67 clr z) (the-as int (-> arg1 state end-color b)))
                 (set! (-> sv-20 a0-67 clr w) (the-as int (-> arg1 state end-color a)))
                 )
               )
             )
            )
          (let ((f0-8 (-> sv-24 radius))
                (f1-4 0.5)
                (v1-73 (the-as object (&-> (the-as (inline-array vector) sv-48) 0 w)))
                (a0-71 (the-as object (-> sv-20 0)))
                (a1-82 (the-as object (-> sv-20 1)))
                )
            1
            (.lvf vf1 (&-> s0-0 quad 0))
            (.lvf vf2 (&-> s0-0 quad 1))
            (.lvf vf3 (&-> s0-0 quad 2))
            (.lvf vf4 (&-> s0-0 trans quad))
            (let ((a2-44 f0-8))
              (.mov vf8 a2-44)
              )
            (let ((a2-45 f1-4))
              (.mov vf17 a2-45)
              )
            (.add.x.vf vf17 vf0 vf8 :mask #b10)
            (.add.w.vf vf17 vf0 vf0 :mask #b100)
            (.add.w.vf vf17 vf17 vf0 :mask #b100)
            (dotimes (a2-46 s3-0)
              (.lvf vf8 (&-> (the-as (inline-array vector) v1-73) 0 quad))
              (.mul.w.vf acc vf4 vf0 :mask #b111)
              (.add.mul.x.vf acc vf1 vf8 acc :mask #b111)
              (.add.mul.y.vf acc vf2 vf8 acc :mask #b111)
              (.add.mul.z.vf vf8 vf3 vf8 acc :mask #b111)
              (.add.x.vf vf6 vf8 vf0)
              (b! (zero? sv-64) cfg-44 :delay (.add.x.vf vf7 vf8 vf0))
              (.add.y.vf vf6 vf6 vf17 :mask #b10)
              (b! #t cfg-45 :delay (.sub.y.vf vf7 vf7 vf17 :mask #b10))
              (label cfg-44)
              (.add.y.vf vf6 vf6 vf17 :mask #b1)
              (.sub.y.vf vf7 vf7 vf17 :mask #b1)
              (label cfg-45)
              (.svf (&-> (the-as (pointer uint128) a1-82) 2) vf6)
              (.svf (&-> (the-as (pointer uint128) a0-71) 2) vf7)
              (set! a1-82 (&+ (the-as pointer a1-82) 96))
              (set! a0-71 (&+ (the-as pointer a0-71) 96))
              (.add.x.vf vf9 vf8 vf0)
              (set! v1-73 (-> (the-as (inline-array vector) v1-73) 1))
              )
            )
          (set! sv-96 s2-0)
          (set! sv-112 0)
          (while (> sv-96 0)
            (if (< 40 sv-96)
                (set! sv-128 40)
                (set! sv-128 sv-96)
                )
            (set! sv-144 (+ sv-128 1))
            (set! sv-160 12)
            (let* ((v1-83 arg0)
                   (a0-73 (the-as object (-> v1-83 base)))
                   )
              (set! (-> (the-as dma-packet a0-73) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc sv-160))
              (set! (-> (the-as dma-packet a0-73) vif0) (new 'static 'vif-tag))
              (set! (-> (the-as dma-packet a0-73) vif1)
                    (new 'static 'vif-tag :cmd (vif-cmd unpack-v4-32) :imm (shr (shl (-> arg2 gcf-buf) 54) 54) :num sv-160)
                    )
              (set! (-> v1-83 base) (the-as pointer (&+ (the-as dma-packet a0-73) 16)))
              )
            (set! sv-176 (the-as gcf-control (-> arg0 base)))
            (let* ((v1-86 (-> sv-176 matrix))
                   (a3-31 (-> sv-16 perspective))
                   (a0-76 (-> a3-31 quad 0))
                   (a1-88 (-> a3-31 quad 1))
                   (a2-58 (-> a3-31 quad 2))
                   (a3-32 (-> a3-31 trans quad))
                   )
              (set! (-> v1-86 quad 0) a0-76)
              (set! (-> v1-86 quad 1) a1-88)
              (set! (-> v1-86 quad 2) a2-58)
              (set! (-> v1-86 trans quad) a3-32)
              )
            (quad-copy! (the-as pointer (-> sv-176 giftag)) (the-as pointer (-> s1-0 giftag)) 3)
            (set! (-> sv-176 giftag qword vector4w w) 1)
            (set! (-> sv-176 num-dps) (the-as uint (* sv-144 2)))
            (set! (-> sv-176 kick-offset) (the-as uint 0))
            (adgif-shader<-texture-simple! (the-as adgif-shader (-> sv-176 shader)) sv-32)
            (adgif-shader-update! (the-as adgif-shader (-> sv-176 shader)) sv-32)
            (set! (-> sv-176 shader 0 shader alpha) (new 'static 'gs-alpha :b #x2 :d #x1 :fix #x80))
            (set! (-> sv-176 shader 0 shader tex0 tfx) 0)
            (set! (-> sv-176 shader 0 pos) (the-as uint 0))
            (set! (-> sv-176 shader 0 num) (the-as uint (+ #x8000 (* sv-144 2))))
            (&+! (-> arg0 base) (* sv-160 16))
            (let* ((v1-104 arg0)
                   (a0-90 (the-as object (-> v1-104 base)))
                   )
              (set! (-> (the-as dma-packet a0-90) dma) (new 'static 'dma-tag :id (dma-tag-id cnt) :qwc (* 6 sv-144)))
              (set! (-> (the-as dma-packet a0-90) vif0) (new 'static 'vif-tag))
              (set! (-> (the-as dma-packet a0-90) vif1)
                    (new 'static 'vif-tag :cmd (vif-cmd unpack-v4-32) :imm (shr (shl (-> arg2 vtx-buf) 54) 54) :num (* 6 sv-144))
                    )
              (set! (-> v1-104 base) (the-as pointer (&+ (the-as dma-packet a0-90) 16)))
              )
            (quad-copy! (-> arg0 base) (the-as pointer (-> sv-20 sv-112)) (* 6 sv-144))
            (&+! (-> arg0 base) (* 96 sv-144))
            (let* ((v1-109 arg0)
                   (a0-95 (the-as object (-> v1-109 base)))
                   )
              (set! (-> (the-as dma-packet a0-95) dma) (new 'static 'dma-tag :id (dma-tag-id cnt)))
              (set! (-> (the-as dma-packet a0-95) vif0) (new 'static 'vif-tag))
              (set! (-> (the-as dma-packet a0-95) vif1) (new 'static 'vif-tag :imm #x6 :cmd (vif-cmd mscal) :msk #x1))
              (set! (-> v1-109 base) (the-as pointer (&+ (the-as dma-packet a0-95) 16)))
              )
            (set! (-> arg2 gcf-buf) (- 1704 (the-as int (-> arg2 gcf-buf))))
            (+! (-> arg2 vtx-buf) 279)
            (if (< (the-as uint 567) (-> arg2 vtx-buf))
                (set! (-> arg2 vtx-buf) (the-as uint 9))
                )
            (set! sv-96 (- sv-96 sv-128))
            (set! sv-112 (+ sv-112 (* sv-128 2)))
            sv-112
            )
          (set! sv-64 (+ sv-64 1))
          )
        #f
        )
      )
    )
  )

(defun-debug lightning-start ((arg0 float) (arg1 float))
  (let ((gp-0 (get-process *default-dead-pool* lightning-tracker #x4000)))
    (when gp-0
      (let ((t9-1 (method-of-type lightning-tracker activate)))
        (t9-1
          (the-as lightning-tracker gp-0)
          *entity-pool*
          (symbol->string (-> lightning-tracker symbol))
          (the-as pointer #x70004000)
          )
        )
      (let ((t9-2 run-function-in-process)
            (a0-3 gp-0)
            (a1-3 lightning-tracker-init)
            (a2-4 (new 'static 'lightning-spec
                    :name #f
                    :flags (lightning-spec-flags lsf1)
                    :start-color (new 'static 'rgba :r #x80 :g #x80 :b #x80 :a #x80)
                    :end-color (new 'static 'rgba :r #x80 :a #x80)
                    :fade-to-color (new 'static 'rgba :r #xbf :b #x8f :a #x5)
                    :fade-start-factor 0.2
                    :fade-time 120.0
                    :texture (new 'static 'texture-id :index #x83 :page #xc)
                    :reduction 0.42
                    :num-points 16
                    :box-size 32768.0
                    :merge-factor 0.5
                    :merge-count 2
                    :radius 2048.0
                    :duration 18000.0
                    :sound #f
                    )
                  )
            (a3-1 0)
            (t0-0 #f)
            (t1-0 #f)
            (t2-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> t2-0 x) arg0)
        (set! (-> t2-0 y) 0.0)
        (set! (-> t2-0 z) arg1)
        (set! (-> t2-0 w) 1.0)
        (let ((t3-0 (new 'stack-no-clear 'vector)))
          (set! (-> t3-0 x) arg0)
          (set! (-> t3-0 y) 262144.0)
          (set! (-> t3-0 z) arg1)
          (set! (-> t3-0 w) 1.0)
          ((the-as (function object object object object object object object object none) t9-2)
           a0-3
           a1-3
           a2-4
           a3-1
           t0-0
           t1-0
           t2-0
           t3-0
           )
          )
        )
      (-> gp-0 ppointer)
      )
    )
  )

(define *lightning-globals* (new 'global 'lightning-globals))

(define *lightning* #t)

;; WARN: Failed store: (s.w! (+ v1-31 8) 0) at op 89
;; WARN: Failed store: (s.w! (+ v1-31 12) 0) at op 90
(defun lightning-draw-all ()
  (when (and *lightning* (not (-> *blit-displays-work* menu-mode)))
    (when (logtest? (-> *display* vu1-enable-user) (vu1-renderer-mask generic))
      (let ((s5-0 *lightning-engine*))
        (when (> (length s5-0) 0)
          (with-dma-buffer-add-bucket ((s4-0 (-> *display* frames (-> *display* on-screen) global-buf))
                                       (bucket-id bucket-315)
                                       )
            (let ((s3-0 *lightning-globals*))
              (let ((v1-17 s3-0))
                (set! (-> v1-17 gcf-buf) (the-as uint 837))
                (set! (-> v1-17 vtx-buf) (the-as uint 9))
                )
              (let* ((v1-19 (-> s5-0 alive-list next0))
                     (s2-0 (-> v1-19 next0))
                     )
                (while (!= v1-19 (-> s5-0 alive-list-end))
                  (let* ((s1-0 (-> (the-as connection v1-19) param1))
                         (s0-0 (-> (the-as dma-buffer s1-0) data-buffer 0))
                         )
                    (when (not (paused?))
                      (case s0-0
                        ((1 2)
                         (lightning-update (the-as lightning-control s1-0))
                         )
                        ((3)
                         (lightning-fade (the-as lightning-control s1-0))
                         )
                        )
                      )
                    (if (or (= s0-0 2) (= s0-0 3))
                        (lightning-draw s4-0 (the-as lightning-control s1-0) s3-0)
                        )
                    )
                  (set! v1-19 s2-0)
                  (set! s2-0 (-> s2-0 next0))
                  )
                )
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defun unlink-lightning-spec-by-heap ((arg0 kheap))
  (let* ((v1-0 *lightning-spec-id-table*)
         (a2-0 (-> v1-0 length))
         (a1-0 (-> arg0 base))
         (a0-1 (-> arg0 top-base))
         )
    (while (nonzero? a2-0)
      (+! a2-0 -1)
      (let ((a3-2 (-> v1-0 a2-0)))
        (when (and (>= (the-as int a3-2) (the-as int a1-0)) (< (the-as int a3-2) (the-as int a0-1)))
          (set! (-> v1-0 a2-0) (the-as lightning-spec 0))
          0
          )
        )
      )
    )
  0
  (none)
  )
