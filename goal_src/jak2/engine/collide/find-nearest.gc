;;-*-Lisp-*-
(in-package goal)

;; name: find-nearest.gc
;; name in dgo: find-nearest
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(deftype search-info (structure)
  ((point        vector           :inline :offset-assert   0)
   (best-point   vector           :inline :offset-assert  16)
   (match-handle handle                   :offset-assert  32)
   (match        basic                    :offset-assert  40)
   (best         float                    :offset-assert  44)
   (radius       float                    :offset-assert  48)
   (rating       search-info-flag         :offset-assert  52)
   (require      search-info-flag         :offset-assert  56)
   (mask         search-info-flag         :offset-assert  60)
   (rot-base     vector           :inline :offset-assert  64)
   (ack-point    vector           :inline :offset-assert  80)
   (rot-range    float                    :offset-assert  96)
   )
  :method-count-assert 9
  :size-assert         #x64
  :flag-assert         #x900000064
  )


(define *search-info* (new 'global 'search-info))

(defun find-nearest-attackable ((arg0 vector) (arg1 float) (arg2 uint) (arg3 uint) (arg4 vector) (arg5 vector) (arg6 float))
  (let ((gp-0 *search-info*))
    (set! (-> gp-0 match) #f)
    (set! (-> gp-0 point quad) (-> arg0 quad))
    (set! (-> gp-0 radius) arg1)
    (set! (-> gp-0 best) 1000000000000000000000.0)
    (set! (-> gp-0 rating) (search-info-flag))
    (set! (-> gp-0 require) (the-as search-info-flag arg3))
    (set! (-> gp-0 mask) (the-as search-info-flag arg2))
    (set! (-> gp-0 rot-base quad) (-> arg4 quad))
    (if arg5
        (set! (-> gp-0 ack-point quad) (-> arg5 quad))
        (set! (-> gp-0 ack-point quad) (-> gp-0 rot-base quad))
        )
    (set! (-> gp-0 rot-range) (if (= arg6 65536.0)
                                  -2.0
                                  arg6
                                  )
          )
    (iterate-process-tree
      *entity-pool*
      (lambda ((arg0 process-drawable))
        (with-pp
          (when (and (logtest? (process-mask crate enemy collectable guard) (-> arg0 mask))
                     (not (logtest? (process-mask no-track) (-> arg0 mask)))
                     )
            (let* ((gp-0 *search-info*)
                   (s4-0 arg0)
                   (s5-0 (if (type? s4-0 process-drawable)
                             s4-0
                             )
                         )
                   )
              (when s5-0
                (let* ((s4-1 (-> s5-0 root))
                       (s3-0 (if (type? s4-1 collide-shape)
                                 s4-1
                                 )
                             )
                       )
                  (when s3-0
                    (let* ((s4-2 (the-as structure (-> (the-as collide-shape s3-0) root-prim prim-core)))
                           (f30-0 (- (vector-vector-distance (-> gp-0 point) (the-as vector s4-2))
                                     (-> (the-as collide-prim-core s4-2) world-sphere w)
                                     )
                                  )
                           )
                      (let* ((s1-0 s5-0)
                             (s2-0 (if (type? s1-0 process-focusable)
                                       s1-0
                                       )
                                   )
                             )
                        (if (and (type? s2-0 process-focusable)
                                 s2-0
                                 s2-0
                                 (not (logtest? (-> (the-as process-focusable s2-0) focus-status) (focus-status disable dead)))
                                 )
                            (set! s4-2 (get-trans (the-as process-focusable s2-0) 3))
                            )
                        )
                      (when (nonzero? (-> (the-as collide-shape s3-0) root-prim prim-core collide-as))
                        (let ((s3-1 0))
                          0.0
                          (let* ((s2-1 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (the-as vector s4-2) (-> gp-0 point)) 1.0))
                                 (f28-0 (cond
                                          ((logtest? (-> gp-0 mask) (search-info-flag prefer-xz))
                                           (fabs (deg-diff (vector-y-angle (-> gp-0 rot-base)) (vector-y-angle s2-1)))
                                           )
                                          ((logtest? (-> gp-0 mask) (search-info-flag prefer-angle))
                                           (- -9999.0 (vector-dot s2-1 (-> gp-0 rot-base)))
                                           )
                                          ((logtest? (-> gp-0 mask) (search-info-flag prefer-center))
                                           (* f30-0 (fmax 0.01 (- 1.0 (vector-dot s2-1 (-> gp-0 rot-base)))))
                                           )
                                          (else
                                            f30-0
                                            )
                                          )
                                        )
                                 )
                            (cond
                              ((logtest? (-> gp-0 mask) (search-info-flag cull-angle))
                               (if (< (vector-dot s2-1 (-> gp-0 rot-base)) (cos (-> gp-0 rot-range)))
                                   (return (the-as object #f))
                                   )
                               )
                              ((logtest? (-> gp-0 mask) (search-info-flag cull-xz))
                               (if (< (-> gp-0 rot-range) (fabs (deg-diff (vector-y-angle (-> gp-0 rot-base)) (vector-y-angle s2-1))))
                                   (return (the-as object #f))
                                   )
                               )
                              )
                            (when (logtest? (-> gp-0 mask) (search-info-flag back-point))
                              (if (< (vector-dot
                                       (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (the-as vector s4-2) (-> gp-0 ack-point)) 1.0)
                                       (-> gp-0 rot-base)
                                       )
                                     0.0
                                     )
                                  (return (the-as object #f))
                                  )
                              )
                            (when (logtest? (-> gp-0 mask) (search-info-flag combo))
                              (if (not (send-event s5-0 'combo))
                                  (return (the-as object #f))
                                  )
                              )
                            (when (logtest? (-> gp-0 mask) (search-info-flag check-track))
                              (if (not (send-event s5-0 'track #f))
                                  (return (the-as object #f))
                                  )
                              )
                            (if (logtest? (process-mask enemy guard) (-> s5-0 mask))
                                (set! s3-1 (logior s3-1 2))
                                )
                            (if (logtest? (process-mask crate) (-> s5-0 mask))
                                (set! s3-1 (logior s3-1 1))
                                )
                            (if (and (nonzero? (-> s5-0 draw)) (logtest? (-> s5-0 draw status) (draw-control-status on-screen)))
                                (set! s3-1 (logior s3-1 4))
                                )
                            (let ((s3-2 (logand (the-as search-info-flag s3-1) (-> gp-0 mask))))
                              (when (and (>= s3-2 (the-as int (-> gp-0 rating)))
                                         (or (zero? (-> gp-0 require)) (logtest? (the-as search-info-flag s3-2) (-> gp-0 require)))
                                         (< f28-0 (-> gp-0 best))
                                         (< f30-0 (-> gp-0 radius))
                                         )
                                (when (logtest? (-> gp-0 mask) (search-info-flag probe))
                                  (let ((a1-17 (new 'stack-no-clear 'collide-query)))
                                    (set! (-> a1-17 start-pos quad) (-> gp-0 ack-point quad))
                                    (vector-! (-> a1-17 move-dist) (the-as vector s4-2) (-> gp-0 ack-point))
                                    (let ((v1-92 a1-17))
                                      (set! (-> v1-92 radius) 1228.8)
                                      (set! (-> v1-92 collide-with) (collide-spec backgnd))
                                      (set! (-> v1-92 ignore-process0) pp)
                                      (set! (-> v1-92 ignore-process1) #f)
                                      (set! (-> v1-92 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
                                      (set! (-> v1-92 action-mask) (collide-action solid))
                                      )
                                    (let ((f0-16 (fill-and-probe-using-line-sphere *collide-cache* a1-17)))
                                      (if (and (>= f0-16 0.0) (< f0-16 1.0))
                                          (return (the-as object #f))
                                          )
                                      )
                                    )
                                  )
                                (set! (-> gp-0 match) s5-0)
                                (set! (-> gp-0 best) f28-0)
                                (set! (-> gp-0 rating) (the-as search-info-flag s3-2))
                                s3-2
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      *null-kernel-context*
      )
    (-> gp-0 match)
    )
  )

;; ERROR: Stack slot load at 720 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 752 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 720 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 752 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 720 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 720 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 752 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 720 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 752 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 720 mismatch: defined as size 4, got size 16
(defun find-nearest-focusable ((arg0 (array collide-shape))
                      (arg1 vector)
                      (arg2 float)
                      (arg3 search-info-flag)
                      (arg4 search-info-flag)
                      (arg5 vector)
                      (arg6 vector)
                      (arg7 float)
                      )
  (local-vars
    (sv-704 (function float float float))
    (sv-720 float)
    (sv-736 (function float float float))
    (sv-752 float)
    )
  (with-pp
    (let ((gp-0 *search-info*))
      (set! (-> gp-0 match) #f)
      (set! (-> gp-0 point quad) (-> arg1 quad))
      (set! (-> gp-0 radius) arg2)
      (set! (-> gp-0 best) 1000000000000000000000.0)
      (set! (-> gp-0 rating) (search-info-flag))
      (set! (-> gp-0 require) arg4)
      (set! (-> gp-0 mask) arg3)
      (set! (-> gp-0 rot-base quad) (-> arg5 quad))
      (if arg6
          (set! (-> gp-0 ack-point quad) (-> arg6 quad))
          (set! (-> gp-0 ack-point quad) (-> gp-0 rot-base quad))
          )
      (set! arg7 (cond
                   ((= arg7 65536.0)
                    -2.0
                    )
                   (else
                     (empty)
                     arg7
                     )
                   )
            )
      (set! (-> gp-0 rot-range) arg7)
      (let ((s4-0 (-> arg0 length)))
        (while (begin (label cfg-89) (nonzero? s4-0))
          (+! s4-0 -1)
          (let* ((s1-0 (-> arg0 s4-0))
                 (s2-0 (-> s1-0 process))
                 (s3-0 (if (type? s2-0 process-focusable)
                           s2-0
                           )
                       )
                 )
            (when (and (and s3-0 (not (logtest? (-> (the-as process-focusable s3-0) focus-status) (focus-status disable dead))))
                       (and (logtest? (process-mask crate enemy collectable guard) (-> s3-0 mask))
                            (not (logtest? (process-mask no-track) (-> s3-0 mask)))
                            )
                       )
              (let* ((s2-1 (get-trans (the-as process-focusable s3-0) 3))
                     (f30-0 (- (vector-vector-distance (-> gp-0 point) s2-1) (-> s2-1 w)))
                     )
                (when (nonzero? (-> s1-0 root-prim prim-core collide-as))
                  (let ((s1-1 0))
                    0.0
                    (let* ((s0-0 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s2-1 (-> gp-0 point)) 1.0))
                           (f28-0 (cond
                                    ((logtest? (-> gp-0 mask) (search-info-flag prefer-xz))
                                     (set! sv-704 deg-diff)
                                     (set! sv-720 (vector-y-angle (-> gp-0 rot-base)))
                                     (let ((a1-7 (vector-y-angle s0-0)))
                                       (fabs (sv-704 sv-720 a1-7))
                                       )
                                     )
                                    ((logtest? (-> gp-0 mask) (search-info-flag prefer-angle))
                                     (- -9999.0 (vector-dot s0-0 (-> gp-0 rot-base)))
                                     )
                                    ((logtest? (-> gp-0 mask) (search-info-flag prefer-center))
                                     (* f30-0 (fmax 0.01 (- 1.0 (vector-dot s0-0 (-> gp-0 rot-base)))))
                                     )
                                    (else
                                      f30-0
                                      )
                                    )
                                  )
                           )
                      (cond
                        ((logtest? (-> gp-0 mask) (search-info-flag cull-angle))
                         (cond
                           ((< (-> gp-0 rot-range) 14563.556)
                            (let* ((f26-0 (vector-dot (vector-! (new 'stack-no-clear 'vector) s2-1 (-> gp-0 point)) (-> gp-0 rot-base)))
                                   (s0-2 (vector+float*! (new 'stack-no-clear 'vector) (-> gp-0 point) (-> gp-0 rot-base) f26-0))
                                   )
                              (if (< (* f26-0 (tan (-> gp-0 rot-range))) (- (vector-vector-distance s0-2 s2-1) (-> s2-1 w)))
                                  (goto cfg-89)
                                  )
                              )
                            )
                           (else
                             (if (< (vector-dot s0-0 (-> gp-0 rot-base)) (cos (-> gp-0 rot-range)))
                                 (return (the-as basic #f))
                                 )
                             )
                           )
                         )
                        ((logtest? (-> gp-0 mask) (search-info-flag cull-xz))
                         (let ((f26-3 (-> gp-0 rot-range)))
                           (set! sv-736 deg-diff)
                           (set! sv-752 (vector-y-angle (-> gp-0 rot-base)))
                           (let ((a1-10 (vector-y-angle s0-0)))
                             (if (< f26-3 (fabs (sv-736 sv-752 a1-10)))
                                 (goto cfg-89)
                                 )
                             )
                           )
                         )
                        )
                      (when (logtest? (-> gp-0 mask) (search-info-flag back-point))
                        (if (< (vector-dot
                                 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) s2-1 (-> gp-0 ack-point)) 1.0)
                                 (-> gp-0 rot-base)
                                 )
                               0.0
                               )
                            (goto cfg-89)
                            )
                        )
                      (when (logtest? (-> gp-0 mask) (search-info-flag combo))
                        (if (not (send-event s3-0 'combo))
                            (goto cfg-89)
                            )
                        )
                      (when (logtest? (-> gp-0 mask) (search-info-flag check-track))
                        (if (not (send-event s3-0 'track #f))
                            (goto cfg-89)
                            )
                        )
                      (if (logtest? (process-mask enemy guard) (-> s3-0 mask))
                          (set! s1-1 (logior s1-1 2))
                          )
                      (if (logtest? (process-mask crate) (-> s3-0 mask))
                          (set! s1-1 (logior s1-1 1))
                          )
                      (if (and (nonzero? (-> s3-0 draw)) (logtest? (-> s3-0 draw status) (draw-control-status on-screen)))
                          (set! s1-1 (logior s1-1 4))
                          )
                      (let ((s1-2 (logand (the-as search-info-flag s1-1) (-> gp-0 mask))))
                        (when (and (>= s1-2 (the-as int (-> gp-0 rating)))
                                   (or (zero? (-> gp-0 require)) (logtest? (the-as search-info-flag s1-2) (-> gp-0 require)))
                                   (< f28-0 (-> gp-0 best))
                                   (< f30-0 (-> gp-0 radius))
                                   )
                          (when (logtest? (-> gp-0 mask) (search-info-flag probe))
                            (let ((a1-15 (new 'stack-no-clear 'collide-query)))
                              (set! (-> a1-15 start-pos quad) (-> gp-0 ack-point quad))
                              (vector-! (-> a1-15 move-dist) s2-1 (-> gp-0 ack-point))
                              (let ((v1-112 a1-15))
                                (set! (-> v1-112 radius) 1228.8)
                                (set! (-> v1-112 collide-with) (collide-spec backgnd))
                                (set! (-> v1-112 ignore-process0) pp)
                                (set! (-> v1-112 ignore-process1) #f)
                                (set! (-> v1-112 ignore-pat)
                                      (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1)
                                      )
                                (set! (-> v1-112 action-mask) (collide-action solid))
                                )
                              (let ((f0-29 (fill-and-probe-using-line-sphere *collide-cache* a1-15)))
                                (if (and (>= f0-29 0.0) (< f0-29 1.0))
                                    (goto cfg-89)
                                    )
                                )
                              )
                            )
                          (set! (-> gp-0 match) s3-0)
                          (set! (-> gp-0 best) f28-0)
                          (set! (-> gp-0 rating) (the-as search-info-flag s1-2))
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      (-> gp-0 match)
      )
    )
  )
