;;-*-Lisp-*-
(in-package goal)

;; name: collide-shape-rider.gc
;; name in dgo: collide-shape-rider
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(defmethod on-platform collide-shape ((obj collide-shape) (arg0 collide-shape) (arg1 collide-query))
  (let ((v1-0 arg1))
    (set! (-> v1-0 best-dist) 0.0)
    (set! (-> v1-0 best-my-prim) #f)
    (set! (-> v1-0 num-spheres) (the-as uint #f))
    )
  (set! (-> arg1 best-dist) 122.88)
  (let ((s5-0 (-> obj root-prim))
        (s4-0 (-> arg0 root-prim))
        )
    (when (and (logtest? (-> s5-0 prim-core collide-with) (-> s4-0 prim-core collide-as))
               (logtest? (-> s5-0 prim-core action) (collide-action rideable))
               (logtest? (-> s4-0 prim-core action) (collide-action can-ride))
               )
      (let ((f0-4 (- (- (vector-vector-distance (the-as vector (-> s5-0 prim-core)) (the-as vector (-> s4-0 prim-core)))
                        (-> s5-0 prim-core world-sphere w)
                        )
                     (-> s4-0 prim-core world-sphere w)
                     )
                  )
            )
        (if (< f0-4 122.88)
            (on-platform-test s5-0 s4-0 arg1 f0-4)
            )
        )
      )
    )
  (< (-> arg1 best-dist) 122.88)
  )

;; WARN: Return type mismatch object vs none.
(defmethod on-platform-test collide-shape-prim ((obj collide-shape-prim) (arg0 collide-shape-prim) (arg1 collide-query) (arg2 float))
  (format 0 "ERROR: collide-shape-prim::on-platform-test was called illegally!~%")
  (none)
  )

(defmethod on-platform-test collide-shape-prim-group ((obj collide-shape-prim-group) (arg0 collide-shape-prim) (arg1 collide-query) (arg2 float))
  (let ((s4-0 (-> arg0 prim-core collide-as))
        (s3-0 (-> obj child 0))
        )
    (countdown (s2-0 (-> obj num-children))
      (when (and (logtest? (-> s3-0 prim-core collide-with) s4-0)
                 (logtest? (-> s3-0 prim-core action) (collide-action rideable))
                 )
        (let ((f0-2 (- (- (vector-vector-distance (the-as vector (-> s3-0 prim-core)) (the-as vector (-> arg0 prim-core)))
                          (-> s3-0 prim-core world-sphere w)
                          )
                       (-> arg0 prim-core world-sphere w)
                       )
                    )
              )
          (if (< f0-2 122.88)
              (on-platform-test s3-0 arg0 arg1 f0-2)
              )
          )
        )
      (&+! s3-0 80)
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch pat-surface vs none.
(defmethod on-platform-test collide-shape-prim-mesh ((obj collide-shape-prim-mesh) (arg0 collide-shape-prim) (arg1 collide-query) (arg2 float))
  (case (-> arg0 type)
    ((collide-shape-prim-group)
     (let ((s4-0 (-> obj prim-core collide-with))
           (s3-0 (-> (the-as collide-shape-prim-group arg0) child 0))
           (s2-1 (the-as object (-> (the-as collide-shape-prim-group arg0) num-children)))
           )
       (while (nonzero? (the-as uint s2-1))
         (set! s2-1 (+ (the-as uint s2-1) -1))
         (when (and (logtest? s4-0 (-> s3-0 prim-core collide-as))
                    (logtest? (-> s3-0 prim-core action) (collide-action can-ride))
                    )
           (let ((f0-2 (- (- (vector-vector-distance (the-as vector (-> obj prim-core)) (the-as vector (-> s3-0 prim-core)))
                             (-> obj prim-core world-sphere w)
                             )
                          (-> s3-0 prim-core world-sphere w)
                          )
                       )
                 )
             (if (< f0-2 122.88)
                 (on-platform-test obj s3-0 arg1 f0-2)
                 )
             )
           )
         (&+! s3-0 80)
         )
       )
     )
    ((collide-shape-prim-sphere)
     (let ((s3-1 (-> obj mesh)))
       (when s3-1
         (let ((v1-13 (populate-for-prim-mesh *collide-mesh-cache* obj)))
           (when v1-13
             (let* ((s4-1 (new 'stack-no-clear 'collide-tri-result))
                    (f0-4 (sphere-on-platform-test
                            s3-1
                            (the-as collide-mesh-cache-tri (-> v1-13 tris))
                            s4-1
                            (the-as vector (-> arg0 prim-core))
                            (-> arg1 best-dist)
                            )
                          )
                    )
               (when (< f0-4 (-> arg1 best-dist))
                 (set! (-> arg1 best-dist) f0-4)
                 (set! (-> arg1 best-my-prim) obj)
                 (set! (-> arg1 num-spheres) (the-as uint arg0))
                 (set! (-> arg1 best-other-tri vertex 0 quad) (-> s4-1 vertex 0 quad))
                 (set! (-> arg1 best-other-tri vertex 1 quad) (-> s4-1 vertex 1 quad))
                 (set! (-> arg1 best-other-tri vertex 2 quad) (-> s4-1 vertex 2 quad))
                 (set! (-> arg1 best-other-tri intersect quad) (-> s4-1 intersect quad))
                 (set! (-> arg1 best-other-tri normal quad) (-> s4-1 normal quad))
                 (set! (-> arg1 best-other-tri pat) (-> s4-1 pat))
                 )
               )
             )
           )
         )
       )
     )
    )
  (none)
  )

(defmethod add-rider collide-rider-pool ((obj collide-rider-pool) (arg0 handle))
  (let ((v1-0 (-> obj alloc-count)))
    (cond
      ((< v1-0 20)
       (let ((v0-0 (-> obj riders v1-0)))
         (set! (-> obj alloc-count) (+ v1-0 1))
         (set! (-> v0-0 rider-handle) arg0)
         (set! (-> v0-0 sticky-prim) #f)
         v0-0
         )
       )
      (else
        (format 0 "ERROR: <SW> *collide-rider-pool*:  exceeded max # of riders!~%")
        (the-as collide-rider #f)
        )
      )
    )
  )

;; WARN: Return type mismatch joint-control-status vs symbol.
(defmethod detect-riders! collide-shape ((obj collide-shape))
  (local-vars (v0-7 joint-control-status) (a2-5 float) (a2-12 float))
  (rlet ((vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         )
    (set! (-> obj num-riders) (the-as uint 0))
    (set! (-> obj riders) (the-as (inline-array collide-rider) #f))
    (let* ((s4-0 (-> obj root-prim))
           (s5-0 (-> s4-0 prim-core collide-with))
           )
      (set! *actor-list-length* 0)
      (if (logtest? s5-0 (collide-spec hit-by-others-list))
          (set! *actor-list-length*
                (fill-actor-list-for-sphere *actor-hash* (the-as sphere (-> s4-0 prim-core)) *actor-list* 256)
                )
          )
      (when (logtest? s5-0 (collide-spec player-list))
        (let ((a0-2 (-> *collide-player-list* alive-list next0)))
          *collide-player-list*
          (let ((v1-11 (-> a0-2 next0)))
            (while (!= a0-2 (-> *collide-player-list* alive-list-end))
              (let* ((a0-3 (-> (the-as connection a0-2) param1))
                     (a1-1 (-> (the-as collide-shape a0-3) root-prim))
                     )
                (when (logtest? s5-0 (-> a1-1 prim-core collide-as))
                  (let ((a1-2 (-> a1-1 prim-core)))
                    (let ((a2-4 a1-2)
                          (a3-1 (-> s4-0 prim-core))
                          )
                      (.lvf vf2 (&-> a2-4 world-sphere quad))
                      (.lvf vf3 (&-> a3-1 world-sphere quad))
                      )
                    (.sub.vf vf1 vf3 vf2)
                    (.mul.vf vf1 vf1 vf1)
                    (.add.y.vf vf1 vf1 vf1 :mask #b1)
                    (.add.z.vf vf1 vf1 vf1 :mask #b1)
                    (.mov a2-5 vf1)
                    (let ((f0-0 a2-5)
                          (f1-1 (+ (-> a1-2 world-sphere w) (-> s4-0 prim-core world-sphere w)))
                          )
                      (when (< f0-0 (* f1-1 f1-1))
                        (when (< *actor-list-length* 256)
                          (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-3))
                          (set! *actor-list-length* (+ *actor-list-length* 1))
                          )
                        )
                      )
                    )
                  )
                )
              (set! a0-2 v1-11)
              *collide-player-list*
              (set! v1-11 (-> v1-11 next0))
              )
            )
          )
        )
      (when (logtest? s5-0 (collide-spec hit-by-player-list))
        (let ((a0-5 (-> *collide-hit-by-player-list* alive-list next0)))
          *collide-hit-by-player-list*
          (let ((v1-19 (-> a0-5 next0)))
            (while (!= a0-5 (-> *collide-hit-by-player-list* alive-list-end))
              (let* ((a0-6 (-> (the-as connection a0-5) param1))
                     (a1-13 (-> (the-as collide-shape a0-6) root-prim))
                     )
                (when (logtest? s5-0 (-> a1-13 prim-core collide-as))
                  (let ((a1-14 (-> a1-13 prim-core)))
                    (let ((a2-11 a1-14)
                          (a3-2 (-> s4-0 prim-core))
                          )
                      (.lvf vf2 (&-> a2-11 world-sphere quad))
                      (.lvf vf3 (&-> a3-2 world-sphere quad))
                      )
                    (.sub.vf vf1 vf3 vf2)
                    (.mul.vf vf1 vf1 vf1)
                    (.add.y.vf vf1 vf1 vf1 :mask #b1)
                    (.add.z.vf vf1 vf1 vf1 :mask #b1)
                    (.mov a2-12 vf1)
                    (let ((f0-1 a2-12)
                          (f1-5 (+ (-> a1-14 world-sphere w) (-> s4-0 prim-core world-sphere w)))
                          )
                      (when (< f0-1 (* f1-5 f1-5))
                        (when (< *actor-list-length* 256)
                          (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-6))
                          (set! *actor-list-length* (+ *actor-list-length* 1))
                          )
                        )
                      )
                    )
                  )
                )
              (set! a0-5 v1-19)
              *collide-hit-by-player-list*
              (set! v1-19 (-> v1-19 next0))
              )
            )
          )
        )
      (dotimes (s4-1 *actor-list-length*)
        (let* ((s3-0 (-> *actor-list* s4-1))
               (v1-24 (-> s3-0 root-prim))
               )
          (when (logtest? s5-0 (-> v1-24 prim-core collide-as))
            (when (and (logtest? (-> v1-24 prim-core action) (collide-action can-ride)) (!= (-> obj process) (-> s3-0 process)))
              (let ((s2-0 (new 'stack-no-clear 'collide-query)))
                (when (on-platform obj s3-0 s2-0)
                  (let ((s5-1 (add-rider *collide-rider-pool* (process->handle (-> s3-0 process)))))
                    (when s5-1
                      (+! (-> obj num-riders) 1)
                      (if (not (-> obj riders))
                          (set! (-> obj riders) (the-as (inline-array collide-rider) s5-1))
                          )
                      (let ((a0-15 (-> s2-0 best-my-prim)))
                        (set! (-> s5-1 sticky-prim) a0-15)
                        (let ((s1-0 (-> obj process node-list data (-> a0-15 transform-index) bone transform)))
                          (set! (-> s5-1 prim-ry) (matrix-y-angle s1-0))
                          (let ((s2-1 (new 'stack-no-clear 'matrix)))
                            (matrix-4x4-inverse! s2-1 s1-0)
                            (set! (-> s3-0 trans w) 1.0)
                            (vector-matrix*! (-> s5-1 rider-local-pos) (-> s3-0 trans) s2-1)
                            )
                          )
                        )
                      (send-event (-> obj process) 'ridden s5-1)
                      )
                    )
                  (set! s5-0 (-> obj root-prim prim-core collide-with))
                  )
                )
              )
            )
          )
        )
      )
    (let ((v1-58 (-> obj process skel)))
      (the-as
        symbol
        (when (nonzero? v1-58)
          (cond
            ((or (> (-> obj num-riders) 0) (logtest? (-> obj root-prim prim-core action) (collide-action edge-grabbed)))
             (set! v0-7 (logior (-> v1-58 status) (joint-control-status sync-math)))
             (set! (-> v1-58 status) v0-7)
             )
            (else
              (set! v0-7 (logclear (-> v1-58 status) (joint-control-status sync-math)))
              (set! (-> v1-58 status) v0-7)
              )
            )
          v0-7
          )
        )
      )
    )
  )

;; WARN: Return type mismatch int vs symbol.
(defmethod pull-riders! collide-shape ((obj collide-shape))
  (let ((s5-0 (-> obj riders)))
    (when s5-0
      (let ((s4-0 (new 'stack-no-clear 'pull-rider-info)))
        (countdown (s3-0 (-> obj num-riders))
          (let* ((v1-2 (-> s5-0 s3-0))
                 (a0-1 (-> v1-2 rider-handle))
                 )
            (when (handle->process a0-1)
              (set! (-> s4-0 rider) v1-2)
              (set! (-> s4-0 rider-cshape)
                    (the-as collide-shape-moving (-> (the-as process-drawable (-> a0-1 process 0)) root))
                    )
              (let ((a0-5 (-> v1-2 sticky-prim)))
                (when a0-5
                  (let ((s2-0 (-> obj process node-list data (-> a0-5 transform-index) bone transform)))
                    (let ((s1-0 (-> s4-0 rider-dest)))
                      (vector-matrix*! s1-0 (-> v1-2 rider-local-pos) s2-0)
                      (vector-float*! s1-0 s1-0 (/ 1.0 (-> s1-0 w)))
                      )
                    (set! (-> s4-0 rider-delta-ry) (deg- (matrix-y-angle s2-0) (-> s4-0 rider prim-ry)))
                    )
                  (pull-rider! obj s4-0)
                  )
                )
              )
            )
          )
        )
      )
    )
  (the-as symbol 0)
  )

;; WARN: Return type mismatch object vs none.
(defmethod pull-rider! collide-shape ((obj collide-shape) (arg0 pull-rider-info))
  (local-vars (at-0 int))
  (with-pp
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((gp-0 (-> arg0 rider-cshape)))
        (let ((s2-0 (new 'stack-no-clear 'vector))
              (s3-0 (new 'stack-no-clear 'vector))
              )
          (set! (-> s3-0 quad) (-> gp-0 trans quad))
          (vector-! s2-0 (-> arg0 rider-dest) s3-0)
          (cond
            ((logtest? (-> obj root-prim prim-core action) (collide-action pull-rider-can-collide))
             (let ((s1-0 (-> obj root-prim prim-core collide-as)))
               (set! (-> obj root-prim prim-core collide-as) (collide-spec))
               (let ((a2-0 (new 'stack-no-clear 'collide-query)))
                 (set! (-> a2-0 collide-with) (-> gp-0 root-prim prim-core collide-with))
                 (set! (-> a2-0 ignore-process0) (-> gp-0 process))
                 (set! (-> a2-0 ignore-process1) #f)
                 (set! (-> a2-0 ignore-pat) (-> gp-0 pat-ignore-mask))
                 (set! (-> a2-0 action-mask) (collide-action solid))
                 (fill-cache-for-shape gp-0 (+ 8192.0 (vector-length s2-0)) a2-0)
                 )
               (set! (-> obj root-prim prim-core collide-as) s1-0)
               )
             (let ((s1-1 (new 'stack-no-clear 'vector)))
               (set! (-> s1-1 quad) (-> s2-0 quad))
               (let ((v1-19 s1-1))
                 (.lvf vf1 (&-> s1-1 quad))
                 (let ((f0-2 (-> pp clock frames-per-second)))
                   (.mov at-0 f0-2)
                   )
                 (.mov vf2 at-0)
                 (.mov.vf vf1 vf0 :mask #b1000)
                 (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                 (.svf (&-> v1-19 quad) vf1)
                 )
               (cond
                 ((type? gp-0 collide-shape-moving)
                  (let ((s2-1 (-> gp-0 status)))
                    (integrate-and-collide! gp-0 s1-1)
                    (set! (-> gp-0 status) s2-1)
                    )
                  )
                 (else
                   (integrate-and-collide! gp-0 s1-1)
                   )
                 )
               )
             )
            (else
              (move-by-vector! gp-0 s2-0)
              )
            )
          (when (type? gp-0 collide-shape-moving)
            (let ((v1-26 (new 'stack-no-clear 'vector)))
              (vector-! v1-26 (-> gp-0 trans) s3-0)
              (vector-float*! (-> gp-0 rider-last-move) v1-26 (-> pp clock frames-per-second))
              )
            (let ((f0-4 (vector-length (-> gp-0 rider-last-move))))
              (if (< (-> obj rider-max-momentum) f0-4)
                  (vector-normalize! (-> gp-0 rider-last-move) (-> obj rider-max-momentum))
                  )
              )
            (set! (-> gp-0 rider-time) (-> gp-0 process clock frame-counter))
            )
          )
        (let ((f0-6 (-> arg0 rider-delta-ry)))
          (if (!= f0-6 0.0)
              (send-event (-> gp-0 process) 'rotate-y-angle f0-6)
              )
          )
        )
      (none)
      )
    )
  )
