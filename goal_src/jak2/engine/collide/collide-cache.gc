;;-*-Lisp-*-
(in-package goal)

;; name: collide-cache.gc
;; name in dgo: collide-cache
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

(defmethod reset collide-cache ((obj collide-cache))
  (set! (-> obj num-tris) 0)
  (set! (-> obj num-prims) 0)
  (set! (-> obj ignore-processes 0) #f)
  (set! (-> obj ignore-processes 1) #f)
  (set! *already-printed-exeeded-max-cache-tris* #f)
  0
  (none)
  )

(defmethod fill-from-bg collide-cache ((obj collide-cache)
                                     (arg0 (function collide-hash int collide-list collide-query int))
                                     (arg1 (function collide-cache collide-list collide-query none))
                                     (arg2 collide-query)
                                     )
  (set! *already-printed-exeeded-max-cache-tris* #f)
  (set! (-> *collide-list* num-items) 0)
  (if *collide-list-boxes*
      (add-debug-box
        #t
        (bucket-id debug2)
        (the-as vector (-> arg2 bbox))
        (-> arg2 bbox max)
        (new 'static 'rgba :g #xff :b #xff :a #x80)
        )
      )
  (dotimes (s2-0 (-> *level* length))
    (let ((v1-7 (-> *level* level s2-0)))
      (if (= (-> v1-7 status) 'active)
          (arg0 (-> v1-7 bsp collide-hash) 0 *collide-list* arg2)
          )
      )
    )
  (when (> (-> *collide-list* num-items) 0)
    (arg1 *collide-cache* *collide-list* arg2)
    (let ((a0-8 (-> obj num-tris)))
      (when (> a0-8 0)
        (let ((v1-16 (-> obj prims))
              (a1-6 *collide-shape-prim-backgnd*)
              )
          (set! (-> v1-16 0 num-tris) (the-as uint a0-8))
          (set! (-> v1-16 0 prim) a1-6)
          (set! (-> obj num-prims) 1)
          (set! (-> v1-16 0 first-tri) (the-as uint 0))
          (set! (-> v1-16 0 ccache) obj)
          (set! (-> v1-16 0 prim-core world-sphere quad) (-> a1-6 prim-core world-sphere quad))
          (set! (-> v1-16 0 prim-core quad 1) (-> a1-6 prim-core quad 1))
          )
        )
      )
    )
  0
  (none)
  )

(defmethod fill-from-water collide-cache ((obj collide-cache) (arg0 water-control))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (when (= (-> obj num-prims) 100)
      (if (= *cheat-mode* 'debug)
          (format 0 "ERROR: Exceeded max number of collide-cache prims!~%")
          )
      (return #f)
      )
    (when (< 460 (+ (-> obj num-tris) 2))
      (if (= *cheat-mode* 'debug)
          (print-exceeded-max-cache-tris)
          )
      (return #f)
      )
    (when (not (and (logtest? (-> arg0 flags) (water-flags active))
                  (logtest? (-> arg0 flags) (water-flags can-ground))
                  (logtest? (-> arg0 flags) (water-flags swim-ground under-water))
                  (logtest? (water-flags over-water) (-> arg0 flags))
                  (not (logtest? (water-flags jump-out) (-> arg0 flags)))
                  )
             )
        (return #f)
        )
    (let ((v1-24 (-> arg0 collide-height)))
      (.lvf vf1 (&-> obj collide-box min quad))
      (.lvf vf3 (&-> obj collide-box max quad))
      (let ((a2-6 (-> obj num-prims-u32))
            (a3-4 (the-as (inline-array collide-cache-tri) (-> obj tris (-> obj num-tris))))
            )
        (.mov vf5 v1-24)
        (.add.x.vf vf1 vf0 vf5 :mask #b10)
        (set! (-> a3-4 0 clear-flags) (the-as uint128 0))
        (set! (-> a3-4 0 prim-index) a2-6)
        (.add.x.vf vf3 vf0 vf5 :mask #b10)
        (set! (-> a3-4 1 clear-flags) (the-as uint128 0))
        (set! (-> a3-4 1 prim-index) a2-6)
        (.mov.vf vf2 vf1)
        (.mov.vf vf4 vf1)
        (.add.z.vf vf2 vf0 vf3 :mask #b100)
        (.add.x.vf vf4 vf0 vf3 :mask #b1)
        (.svf (&-> a3-4 0 vertex 0 quad) vf1)
        (.svf (&-> a3-4 0 vertex 1 quad) vf2)
        (.svf (&-> a3-4 0 vertex 2 quad) vf3)
        (set! (-> a3-4 0 pat) (new 'static 'pat-surface :material (pat-material waterbottom)))
        (set! (-> a3-4 0 collide-ptr) arg0)
        (.svf (&-> a3-4 1 vertex 0 quad) vf1)
        (.svf (&-> a3-4 1 vertex 1 quad) vf3)
        (.svf (&-> a3-4 1 vertex 2 quad) vf4)
        (set! (-> a3-4 1 pat) (new 'static 'pat-surface :material (pat-material waterbottom)))
        (set! (-> a3-4 1 collide-ptr) arg0)
        )
      )
    (let ((v1-27 *collide-shape-prim-water*)
          (a1-5 (-> obj prims (-> obj num-prims)))
          )
      (set! (-> a1-5 first-tri) (the-as uint (-> obj num-tris)))
      (set! (-> a1-5 num-tris) (the-as uint 2))
      (set! (-> a1-5 prim) v1-27)
      (set! (-> a1-5 ccache) obj)
      (set! (-> a1-5 prim-core world-sphere quad) (-> v1-27 prim-core world-sphere quad))
      (set! (-> a1-5 prim-core quad 1) (-> v1-27 prim-core quad 1))
      )
    (+! (-> obj num-prims) 1)
    (+! (-> obj num-tris) 2)
    0
    (none)
    )
  )

(defmethod fill-using-bounding-box collide-cache ((obj collide-cache) (arg0 collide-query))
  (rlet ((vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (+! (-> *collide-stats* calls) 1)
    (new 'static 'vector :x 0.5)
    (nop!)
    (nop!)
    (let ((v1-4 (-> arg0 collide-with-s32)))
      (nop!)
      (let ((a0-2 (-> arg0 ignore-process0)))
        (nop!)
        (let ((a1-1 (-> arg0 ignore-process1)))
          (nop!)
          (let ((a2-0 (-> arg0 ignore-pat-s32)))
            (nop!)
            (.lvf vf1 (&-> arg0 bbox min quad))
            (nop!)
            (.lvf vf2 (&-> arg0 bbox max quad))
            (nop!)
            (set! (-> obj ignore-processes 0) (the-as process a0-2))
            (nop!)
            (set! (-> obj ignore-processes 1) (the-as process a1-1))
            (.mov.vf vf1 vf0 :mask #b1000)
            (nop!)
            (.mov.vf vf2 vf0 :mask #b1000)
            (set! (-> obj ignore-mask) (the-as pat-surface a2-0))
            )
          )
        )
      (.ftoi.vf vf3 vf1)
      (nop!)
      (.ftoi.vf vf4 vf2)
      (set! (-> obj num-tris) 0)
      (nop!)
      (.svf (&-> obj collide-box min quad) vf1)
      (nop!)
      (.svf (&-> obj collide-box max quad) vf2)
      (nop!)
      (.svf (&-> obj collide-box4w min quad) vf3)
      (nop!)
      (.svf (&-> obj collide-box4w max quad) vf4)
      (nop!)
      (.svf (&-> arg0 bbox4w min quad) vf3)
      (nop!)
      (.svf (&-> arg0 bbox4w max quad) vf4)
      (nop!)
      (set! (-> obj num-prims) 0)
      (nop!)
      (set! (-> obj collide-with) (the-as collide-spec v1-4))
      )
    0
    (when (logtest? (-> arg0 collide-with) (collide-spec backgnd))
      (fill-from-bg
        obj
        (method-of-type collide-hash fill-collide-list-from-box)
        collide-list-fill-bg-using-box
        arg0
        )
      (+! (-> *collide-stats* output) (-> obj num-tris))
      )
    (when (logtest? (-> arg0 collide-with) (collide-spec water))
      (let ((v1-18 (-> arg0 ignore-process0)))
        (if v1-18
            (fill-from-water obj (-> (the-as process-drawable v1-18) water))
            )
        )
      )
    (if (logtest? (-> arg0 collide-with) (collide-spec hit-by-player-list hit-by-others-list player-list))
        (fill-from-fg-boxes obj)
        )
    0
    (none)
    )
  )

(defmethod fill-using-line-sphere collide-cache ((obj collide-cache) (arg0 collide-query))
  (local-vars (v1-11 uint) (v1-20 float))
  (rlet ((acc :class vf)
         (Q :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf10 :class vf)
         (vf11 :class vf)
         (vf12 :class vf)
         (vf13 :class vf)
         (vf14 :class vf)
         (vf15 :class vf)
         (vf16 :class vf)
         (vf17 :class vf)
         (vf18 :class vf)
         (vf19 :class vf)
         (vf2 :class vf)
         (vf20 :class vf)
         (vf22 :class vf)
         (vf23 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         (vf9 :class vf)
         )
    (init-vf0-vector)
    (+! (-> *collide-stats* calls) 1)
    (let ((v1-3 0))
      (if (< (fabs (-> arg0 move-dist x)) 4096.0)
          (+! v1-3 1)
          )
      (if (< (fabs (-> arg0 move-dist y)) 4096.0)
          (+! v1-3 1)
          )
      (if (< (fabs (-> arg0 move-dist z)) 4096.0)
          (+! v1-3 1)
          )
      (when (< 1 v1-3)
        (set-from-point-offset-pad! (-> arg0 bbox) (-> arg0 start-pos) (-> arg0 move-dist) (-> arg0 radius))
        (fill-using-bounding-box obj arg0)
        (b! #t cfg-47 :delay (nop!))
        (the-as none 0)
        (nop!)
        )
      )
    (nop!)
    (let ((v1-10 (-> arg0 ignore-pat-s32)))
      (nop!)
      (let ((a0-14 (-> arg0 ignore-process0)))
        (nop!)
        (let ((a1-3 (-> arg0 ignore-process1)))
          (nop!)
          (let ((a2-1 (-> arg0 collide-with-s32)))
            (nop!)
            (.lvf vf9 (&-> arg0 exit-planes 0 quad))
            (nop!)
            (.lvf vf3 (&-> arg0 move-dist quad))
            (nop!)
            (.mov.vf vf13 vf0)
            (nop!)
            (.lvf vf1 (&-> arg0 start-pos quad))
            (.mul.vf vf8 vf3 vf3)
            (nop!)
            (.add.vf vf2 vf1 vf3)
            (set! (-> obj ignore-mask) (the-as pat-surface v1-10))
            (.add.y.vf vf8 vf8 vf8 :mask #b1)
            (set! (-> obj num-tris) 0)
            (.min.vf vf4 vf1 vf2)
            (set! (-> obj num-prims) 0)
            (.max.vf vf5 vf1 vf2)
            (set! (-> obj collide-with) (the-as collide-spec a2-1))
            )
          (.sub.w.vf vf10 vf0 vf9 :mask #b111)
          (set! (-> obj ignore-processes 0) (the-as process a0-14))
          (.add.z.vf vf8 vf8 vf8 :mask #b1)
          (set! (-> obj ignore-processes 1) (the-as process a1-3))
          )
        )
      )
    (.sub.w.vf vf4 vf4 vf9 :mask #b111)
    (nop!)
    (.add.w.vf vf5 vf5 vf9 :mask #b111)
    (nop!)
    (.ftoi.vf vf15 vf10)
    (nop!)
    (.isqrt.vf Q vf0 vf8 :fsf #b11 :ftf #b0)
    (nop!)
    (.add.w.vf vf11 vf0 vf9 :mask #b111)
    (nop!)
    (nop!)
    (nop!)
    (nop!)
    (.svf (&-> arg0 local-box4w min quad) vf15)
    (.ftoi.vf vf6 vf4)
    (.svf (&-> obj collide-box min quad) vf4)
    (.ftoi.vf vf7 vf5)
    (.svf (&-> obj collide-box max quad) vf5)
    (nop!)
    (.svf (&-> arg0 bbox min quad) vf4)
    (nop!)
    (.svf (&-> arg0 bbox max quad) vf5)
    (nop!)
    (.svf (&-> obj collide-box4w min quad) vf6)
    (nop!)
    (.svf (&-> obj collide-box4w max quad) vf7)
    (nop!)
    (.svf (&-> arg0 bbox4w min quad) vf6)
    (nop!)
    (.svf (&-> arg0 bbox4w max quad) vf7)
    (.wait.vf)
    (nop!)
    (.add.vf vf8 vf0 Q :mask #b1)
    (nop!)
    (.mul.x.vf vf12 vf3 vf8)
    (nop!)
    (.nop.vf)
    (nop!)
    (.div.vf Q vf0 vf8 :fsf #b11 :ftf #b0)
    (nop!)
    (.mul.vf vf22 vf12 vf12)
    (nop!)
    (.abs.vf vf23 vf12)
    (nop!)
    (.add.y.vf vf22 vf22 vf22 :mask #b1)
    (.mov v1-11 vf23)
    (.wait.vf)
    (nop!)
    (.add.vf vf8 vf0 Q :mask #b1)
    (nop!)
    (b! (zero? v1-11) cfg-12 :likely-delay (.add.z.vf vf13 vf0 vf12 :mask #b1))
    (.sub.y.vf vf13 vf0 vf12 :mask #b1)
    (nop!)
    (.isqrt.vf Q vf0 vf22 :fsf #b11 :ftf #b0)
    (nop!)
    (.add.x.vf vf13 vf0 vf12 :mask #b10)
    (nop!)
    (.wait.vf)
    (nop!)
    (.mul.vf vf13 vf13 Q :mask #b11)
    (nop!)
    (label cfg-12)
    (.outer.product.a.vf acc vf12 vf13)
    (nop!)
    (.add.x.vf vf11 vf11 vf8 :mask #b1)
    (nop!)
    (.outer.product.b.vf vf14 vf13 vf12 acc)
    (nop!)
    (.ftoi.vf vf16 vf11)
    (nop!)
    (.mov.vf vf17 vf12)
    (nop!)
    (.mov.vf vf18 vf13)
    (nop!)
    (.mov.vf vf19 vf14)
    (nop!)
    (.mov.vf vf17 vf0 :mask #b1110)
    (.svf (&-> arg0 local-box4w max quad) vf16)
    (.mov.vf vf18 vf0 :mask #b1101)
    (nop!)
    (.mov.vf vf19 vf0 :mask #b1011)
    (nop!)
    (.add.x.vf vf17 vf17 vf13 :mask #b10)
    (nop!)
    (.add.y.vf vf18 vf18 vf12 :mask #b1)
    (nop!)
    (.add.z.vf vf19 vf19 vf12 :mask #b1)
    (nop!)
    (.add.x.vf vf17 vf17 vf14 :mask #b100)
    (nop!)
    (.add.y.vf vf18 vf18 vf14 :mask #b100)
    (nop!)
    (.add.z.vf vf19 vf19 vf13 :mask #b10)
    (nop!)
    (.mul.x.vf acc vf17 vf1)
    (nop!)
    (.add.mul.y.vf acc vf18 vf1 acc)
    (.svf (&-> arg0 inv-mat quad 0) vf17)
    (.add.mul.z.vf vf20 vf19 vf1 acc)
    (.svf (&-> arg0 inv-mat quad 1) vf18)
    (.sub.vf vf20 vf0 vf20)
    (.svf (&-> arg0 inv-mat quad 2) vf19)
    (nop!)
    (.svf (&-> arg0 inv-mat trans quad) vf20)
    (set! (-> arg0 rlength x) (if (= (-> arg0 move-dist x) 0.0)
                                  0.0
                                  (/ 1.0 (-> arg0 move-dist x))
                                  )
          )
    (set! (-> arg0 rlength y) (if (= (-> arg0 move-dist y) 0.0)
                                  0.0
                                  (/ 1.0 (-> arg0 move-dist y))
                                  )
          )
    (set! (-> arg0 rlength z) (if (= (-> arg0 move-dist z) 0.0)
                                  0.0
                                  (/ 1.0 (-> arg0 move-dist z))
                                  )
          )
    (let ((f0-19 1.0))
      (.lvf vf1 (&-> (-> arg0 move-dist) quad))
      (.add.w.vf vf2 vf0 vf0 :mask #b1)
      (.mul.vf vf1 vf1 vf1)
      (.mul.x.vf acc vf2 vf1 :mask #b1)
      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
      (.mov v1-20 vf1)
      (set! (-> arg0 rlength w) (/ f0-19 v1-20))
      )
    (set! (-> arg0 exit-planes 0 x) (if (< 0.0 (-> arg0 move-dist x))
                                        0.0
                                        100000000000000000000000000000000000000.0
                                        )
          )
    (set! (-> arg0 exit-planes 0 y) (if (< 0.0 (-> arg0 move-dist y))
                                        0.0
                                        100000000000000000000000000000000000000.0
                                        )
          )
    (set! (-> arg0 exit-planes 0 z) (if (< 0.0 (-> arg0 move-dist z))
                                        0.0
                                        100000000000000000000000000000000000000.0
                                        )
          )
    (set! (-> arg0 exit-planes 1 x) (if (< (-> arg0 move-dist x) 0.0)
                                        0.0
                                        100000000000000000000000000000000000000.0
                                        )
          )
    (set! (-> arg0 exit-planes 1 y) (if (< (-> arg0 move-dist y) 0.0)
                                        0.0
                                        100000000000000000000000000000000000000.0
                                        )
          )
    (set! (-> arg0 exit-planes 1 z) (if (< (-> arg0 move-dist z) 0.0)
                                        0.0
                                        100000000000000000000000000000000000000.0
                                        )
          )
    (when (logtest? (-> arg0 collide-with) (collide-spec backgnd))
      (fill-from-bg
        obj
        (method-of-type collide-hash fill-collide-list-from-line-sphere)
        collide-list-fill-bg-using-line-sphere
        arg0
        )
      (+! (-> *collide-stats* output) (-> obj num-tris))
      )
    (when (logtest? (-> arg0 collide-with) (collide-spec water))
      (let ((a1-5 (-> (the-as process-drawable (-> arg0 ignore-process0)) water)))
        (if (nonzero? a1-5)
            (fill-from-water obj a1-5)
            )
        )
      )
    (if (logtest? (-> arg0 collide-with) (collide-spec hit-by-player-list hit-by-others-list player-list))
        (fill-from-fg-line-sphere obj arg0)
        )
    0
    (label cfg-47)
    (none)
    )
  )

(defmethod fill-from-fg-boxes collide-cache ((obj collide-cache))
  (let ((s5-0 (-> obj collide-with)))
    (set! *actor-list-length* 0)
    (if (logtest? s5-0 (collide-spec hit-by-others-list))
        (set! *actor-list-length* (fill-actor-list-for-box *actor-hash* (-> obj collide-box) *actor-list* 256))
        )
    (when (logtest? s5-0 (collide-spec player-list))
      (let ((a0-2 (-> *collide-player-list* alive-list next0)))
        *collide-player-list*
        (let ((v1-13 (-> a0-2 next0)))
          (while (!= a0-2 (-> *collide-player-list* alive-list-end))
            (let* ((a0-3 (-> (the-as connection a0-2) param1))
                   (a1-1 (-> (the-as collide-shape a0-3) root-prim))
                   )
              (when (logtest? s5-0 (-> a1-1 prim-core collide-as))
                (let ((a1-2 (-> a1-1 prim-core)))
                  (when (and (>= (+ (-> a1-2 world-sphere x) (-> a1-2 world-sphere w)) (-> obj collide-box min x))
                             (>= (-> obj collide-box max x) (- (-> a1-2 world-sphere x) (-> a1-2 world-sphere w)))
                             (>= (+ (-> a1-2 world-sphere y) (-> a1-2 world-sphere w)) (-> obj collide-box min y))
                             (>= (-> obj collide-box max y) (- (-> a1-2 world-sphere y) (-> a1-2 world-sphere w)))
                             (>= (+ (-> a1-2 world-sphere z) (-> a1-2 world-sphere w)) (-> obj collide-box min z))
                             (>= (-> obj collide-box max z) (- (-> a1-2 world-sphere z) (-> a1-2 world-sphere w)))
                             )
                    (when (< *actor-list-length* 256)
                      (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-3))
                      (set! *actor-list-length* (+ *actor-list-length* 1))
                      )
                    )
                  )
                )
              )
            (set! a0-2 v1-13)
            *collide-player-list*
            (set! v1-13 (-> v1-13 next0))
            )
          )
        )
      )
    (when (logtest? s5-0 (collide-spec hit-by-player-list))
      (let ((a0-5 (-> *collide-hit-by-player-list* alive-list next0)))
        *collide-hit-by-player-list*
        (let ((v1-21 (-> a0-5 next0)))
          (while (!= a0-5 (-> *collide-hit-by-player-list* alive-list-end))
            (let* ((a0-6 (-> (the-as connection a0-5) param1))
                   (a1-13 (-> (the-as collide-shape a0-6) root-prim))
                   )
              (when (logtest? s5-0 (-> a1-13 prim-core collide-as))
                (let ((a1-14 (-> a1-13 prim-core)))
                  (when (and (>= (+ (-> a1-14 world-sphere x) (-> a1-14 world-sphere w)) (-> obj collide-box min x))
                             (>= (-> obj collide-box max x) (- (-> a1-14 world-sphere x) (-> a1-14 world-sphere w)))
                             (>= (+ (-> a1-14 world-sphere y) (-> a1-14 world-sphere w)) (-> obj collide-box min y))
                             (>= (-> obj collide-box max y) (- (-> a1-14 world-sphere y) (-> a1-14 world-sphere w)))
                             (>= (+ (-> a1-14 world-sphere z) (-> a1-14 world-sphere w)) (-> obj collide-box min z))
                             (>= (-> obj collide-box max z) (- (-> a1-14 world-sphere z) (-> a1-14 world-sphere w)))
                             )
                    (when (< *actor-list-length* 256)
                      (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape a0-6))
                      (set! *actor-list-length* (+ *actor-list-length* 1))
                      )
                    )
                  )
                )
              )
            (set! a0-5 v1-21)
            *collide-hit-by-player-list*
            (set! v1-21 (-> v1-21 next0))
            )
          )
        )
      )
    (dotimes (s4-0 *actor-list-length*)
      (let ((v1-26 (-> *actor-list* s4-0)))
        (when (logtest? s5-0 (-> v1-26 root-prim prim-core collide-as))
          (let ((a0-13 (-> v1-26 process)))
            (if (not (or (= a0-13 (-> obj ignore-processes 0)) (= a0-13 (-> obj ignore-processes 1))))
                (add-fg-prim-using-box (-> v1-26 root-prim) obj)
                )
            )
          )
        )
      )
    )
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod add-fg-prim-using-box collide-shape-prim ((obj collide-shape-prim) (arg0 collide-cache))
  (format 0 "ERROR: Illegal collide-shape-prim type passed to collide-shape-prim::add-fg-prim-using-box!~%")
  (none)
  )

(defmethod-mips2c "(method 10 collide-shape-prim-mesh)" 10 collide-shape-prim-mesh)

(defmethod-mips2c "(method 10 collide-shape-prim-sphere)" 10 collide-shape-prim-sphere)

(defmethod-mips2c "(method 10 collide-shape-prim-group)" 10 collide-shape-prim-group)

(defmethod fill-from-fg-line-sphere collide-cache ((obj collide-cache) (arg0 collide-query))
  (local-vars (v1-9 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 (-> arg0 collide-with)))
      (set! *actor-list-length* 0)
      (if (logtest? s4-0 (collide-spec hit-by-others-list))
          (set! *actor-list-length* (fill-actor-list-for-line-sphere
                                      *actor-hash*
                                      (-> arg0 start-pos)
                                      (-> arg0 move-dist)
                                      (-> arg0 radius)
                                      *actor-list*
                                      256
                                      -1
                                      )
                )
          )
      (let ((f30-0 0.0)
            (s3-0 (new 'stack-no-clear 'matrix))
            )
        (.lvf vf1 (&-> (-> arg0 move-dist) quad))
        (.add.w.vf vf2 vf0 vf0 :mask #b1)
        (.mul.vf vf1 vf1 vf1)
        (.mul.x.vf acc vf2 vf1 :mask #b1)
        (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
        (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
        (.mov v1-9 vf1)
        (let ((f0-1 v1-9))
          (if (< 0.0 f0-1)
              (set! f30-0 (/ 1.0 f0-1))
              )
          )
        (when (logtest? s4-0 (collide-spec player-list))
          (let ((v1-17 (-> *collide-player-list* alive-list next0)))
            *collide-player-list*
            (let ((s2-0 (-> v1-17 next0)))
              (while (!= v1-17 (-> *collide-player-list* alive-list-end))
                (let* ((s1-0 (-> (the-as connection v1-17) param1))
                       (v1-18 (-> (the-as collide-shape s1-0) root-prim))
                       )
                  (when (logtest? s4-0 (-> v1-18 prim-core collide-as))
                    (let ((s0-0 (-> v1-18 prim-core)))
                      (vector-! (-> s3-0 vector 1) (the-as vector s0-0) (-> arg0 start-pos))
                      (let* ((f1-2 (* (vector-dot (-> arg0 move-dist) (-> s3-0 vector 1)) f30-0))
                             (f0-6 (fmax 0.0 (fmin 1.0 f1-2)))
                             )
                        (vector+float*! (the-as vector (-> s3-0 vector)) (-> arg0 start-pos) (-> arg0 move-dist) f0-6)
                        )
                      (let ((f0-7 (vector-vector-distance-squared (the-as vector (-> s3-0 vector)) (the-as vector s0-0)))
                            (f1-5 (+ (-> arg0 radius) (-> s0-0 world-sphere w)))
                            )
                        (when (< f0-7 (* f1-5 f1-5))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape s1-0))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! v1-17 s2-0)
                *collide-player-list*
                (set! s2-0 (-> s2-0 next0))
                )
              )
            )
          )
        (when (logtest? s4-0 (collide-spec hit-by-player-list))
          (let ((v1-38 (-> *collide-hit-by-player-list* alive-list next0)))
            *collide-hit-by-player-list*
            (let ((s2-1 (-> v1-38 next0)))
              (while (!= v1-38 (-> *collide-hit-by-player-list* alive-list-end))
                (let* ((s1-1 (-> (the-as connection v1-38) param1))
                       (v1-39 (-> (the-as collide-shape s1-1) root-prim))
                       )
                  (when (logtest? s4-0 (-> v1-39 prim-core collide-as))
                    (let ((s0-1 (-> v1-39 prim-core)))
                      (vector-! (-> s3-0 vector 1) (the-as vector s0-1) (-> arg0 start-pos))
                      (let* ((f1-8 (* (vector-dot (-> arg0 move-dist) (-> s3-0 vector 1)) f30-0))
                             (f0-11 (fmax 0.0 (fmin 1.0 f1-8)))
                             )
                        (vector+float*! (the-as vector (-> s3-0 vector)) (-> arg0 start-pos) (-> arg0 move-dist) f0-11)
                        )
                      (let ((f0-12 (vector-vector-distance-squared (the-as vector (-> s3-0 vector)) (the-as vector s0-1)))
                            (f1-11 (+ (-> arg0 radius) (-> s0-1 world-sphere w)))
                            )
                        (when (< f0-12 (* f1-11 f1-11))
                          (when (< *actor-list-length* 256)
                            (set! (-> *actor-list* *actor-list-length*) (the-as collide-shape s1-1))
                            (set! *actor-list-length* (+ *actor-list-length* 1))
                            )
                          )
                        )
                      )
                    )
                  )
                (set! v1-38 s2-1)
                *collide-hit-by-player-list*
                (set! s2-1 (-> s2-1 next0))
                )
              )
            )
          )
        )
      (dotimes (s3-1 *actor-list-length*)
        (let ((v1-58 (-> *actor-list* s3-1)))
          (when (logtest? s4-0 (-> v1-58 root-prim prim-core collide-as))
            (let ((a0-37 (-> v1-58 process)))
              (if (not (or (= a0-37 (-> obj ignore-processes 0)) (= a0-37 (-> obj ignore-processes 1))))
                  (add-fg-prim-using-line-sphere (-> v1-58 root-prim) obj arg0)
                  )
              )
            )
          )
        )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod add-fg-prim-using-line-sphere collide-shape-prim ((obj collide-shape-prim) (arg0 collide-cache) (arg1 object))
  (format
    0
    "ERROR: Illegal collide-shape-prim type passed to collide-shape-prim::add-fg-prim-using-line-sphere!~%"
    )
  (none)
  )

(defmethod-mips2c "(method 11 collide-shape-prim-mesh)" 11 collide-shape-prim-mesh)

(defmethod-mips2c "(method 11 collide-shape-prim-sphere)" 11 collide-shape-prim-sphere)

(defmethod-mips2c "(method 11 collide-shape-prim-group)" 11 collide-shape-prim-group)

(defmethod fill-and-probe-using-line-sphere collide-cache ((obj collide-cache) (arg0 collide-query))
  (fill-using-line-sphere obj arg0)
  (probe-using-line-sphere obj arg0)
  )

(deftype collide-puls-work (structure)
  ((ignore-pat pat-surface         :offset-assert   0)
   (bsphere    sphere      :inline :offset-assert  16)
   (move-dist  vector      :inline :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x30
  :flag-assert         #x900000030
  )


(defmethod probe-using-line-sphere collide-cache ((obj collide-cache) (arg0 collide-query))
  (rlet ((vf0 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (new 'stack-no-clear 'collide-cache-tri)))
      (.lvf vf4 (&-> arg0 exit-planes 0 quad))
      (.lvf vf3 (&-> arg0 start-pos quad))
      (.lvf vf2 (&-> arg0 move-dist quad))
      (set! (-> s5-0 vertex 0 x) (the-as float (-> arg0 ignore-pat)))
      (.mul.w.vf vf3 vf0 vf4 :mask #b1000)
      (.svf (&-> s5-0 vertex 2 quad) vf2)
      (.svf (&-> s5-0 vertex 1 quad) vf3)
      (let ((s4-0 (the-as object (-> obj prims)))
            (f30-0 -100000000.0)
            )
        (countdown (s3-0 (-> obj num-prims))
          (when (and (logtest? (-> arg0 collide-with) (-> (the-as collide-cache-prim s4-0) prim-core collide-as))
                     (logtest? (-> arg0 action-mask) (-> (the-as collide-cache-prim s4-0) prim-core action))
                     )
            (cond
              ((>= (the-as int (-> (the-as collide-cache-prim s4-0) prim-core prim-type)) 0)
               (let ((f0-0 ((method-of-type collide-cache-prim resolve-moving-sphere-tri)
                            (the-as collide-cache-prim s4-0)
                            (the-as collide-tri-result arg0)
                            (the-as collide-prim-core (-> s5-0 vertex 1))
                            (-> s5-0 vertex 2)
                            f30-0
                            (collide-action solid)
                            )
                           )
                     )
                 (if (>= f0-0 0.0)
                     (set! f30-0 f0-0)
                     )
                 )
               )
              (else
                (when (not (logtest? (-> arg0 ignore-pat)
                                     (-> (the-as collide-shape-prim-sphere (-> (the-as collide-cache-prim s4-0) prim)) pat)
                                     )
                           )
                  (let ((f0-1 ((method-of-type collide-cache-prim resolve-moving-sphere-sphere)
                               (the-as collide-cache-prim s4-0)
                               (the-as collide-tri-result arg0)
                               (the-as collide-prim-core (-> s5-0 vertex 1))
                               (-> s5-0 vertex 2)
                               f30-0
                               (collide-action solid)
                               )
                              )
                        )
                    (if (>= f0-1 0.0)
                        (set! f30-0 f0-1)
                        )
                    )
                  )
                )
              )
            )
          (set! s4-0 (-> (the-as (inline-array collide-cache-prim) s4-0) 1))
          )
        f30-0
        )
      )
    )
  )

(deftype lsmi-work (structure)
  ((best-u      float                 :offset-assert   0)
   (orig-best-u float                 :offset-assert   4)
   (action      uint32                :offset-assert   8)
   (cquery      collide-query :inline :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x22c
  :flag-assert         #x90000022c
  )


(defmethod-mips2c "(method 9 collide-cache-prim)" 9 collide-cache-prim)

(defmethod-mips2c "(method 10 collide-cache-prim)" 10 collide-cache-prim)

(defmethod fill-and-probe-using-spheres collide-cache ((obj collide-cache) (arg0 collide-query))
  (fill-using-spheres obj arg0)
  (probe-using-spheres obj arg0)
  )

(defmethod fill-using-spheres collide-cache ((obj collide-cache) (arg0 collide-query))
  (new 'stack-no-clear 'bounding-box)
  (set-from-spheres!
    (-> arg0 bbox)
    (the-as (inline-array sphere) (-> arg0 best-dist))
    (the-as int (-> arg0 num-spheres))
    )
  (fill-using-bounding-box obj arg0)
  (none)
  )

(defmethod-mips2c "(method 17 collide-cache)" 17 collide-cache)

(defmethod-mips2c "(method 9 collide-puss-work)" 9 collide-puss-work)

(defmethod-mips2c "(method 10 collide-puss-work)" 10 collide-puss-work)


