;;-*-Lisp-*-
(in-package goal)

;; name: fma-sphere.gc
;; name in dgo: fma-sphere
;; dgos: ENGINE, GAME

;; +++fma-sphere-mode
(defenum fma-sphere-mode
  :type uint32
  :bitfield #t
  (nav 0)
  (kill-once 1)
  (danger 2)
  (deadly-overlap 3))
;; ---fma-sphere-mode

(declare-type fma-sphere process-drawable)

;; DECOMP BEGINS

(deftype fma-sphere (process-drawable)
  ((root         collide-shape               :override)
   (first-time?  symbol                      :offset-assert 200)
   (mode         fma-sphere-mode             :offset-assert 204)
   (track-handle handle                      :offset-assert 208)
   (track-joint  int32                       :offset-assert 216)
   (attack-id    uint32                      :offset-assert 220)
   (duration     time-frame                  :offset-assert 224)
   (sphere       sphere              :inline :offset-assert 240)
   (danger       traffic-danger-info :inline :offset-assert 256)
   )
  :heap-base #xc0
  :method-count-assert 21
  :size-assert         #x136
  :flag-assert         #x1500c00136
  (:methods
    (idle () _type_ :state 20)
    )
  )


(defmethod run-logic? fma-sphere ((obj fma-sphere))
  (or (logtest? *display-scene-control* (scene-controls display-controls))
      (and *display-nav-marks* (logtest? (-> obj mode) (fma-sphere-mode nav)))
      (logtest? (-> obj mode) (fma-sphere-mode deadly-overlap))
      (>= (-> obj track-joint) 0)
      (-> obj first-time?)
      )
  )

(defstate idle (fma-sphere)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touched)
       (let ((v1-1 (-> event param 0)))
         (when v1-1
           (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
             (set! (-> a1-2 from) (process->ppointer self))
             (set! (-> a1-2 num-params) 2)
             (set! (-> a1-2 message) 'attack)
             (set! (-> a1-2 param 0) v1-1)
             (let ((v1-2 (new 'static 'attack-info :mask (attack-info-mask mode id attacker-velocity damage knock))))
               (set! (-> v1-2 id) (-> self attack-id))
               (set! (-> v1-2 mode) 'eco-red)
               (set! (-> v1-2 attacker-velocity quad) (-> self root transv quad))
               (set! (-> v1-2 damage) 2.0)
               (set! (-> v1-2 knock) (the-as uint 2))
               (set! (-> a1-2 param 1) (the-as uint v1-2))
               )
             (send-event-function proc a1-2)
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (set! (-> self first-time?) #f)
    (if (logtest? (-> self mode) (fma-sphere-mode kill-once))
        (send-event *traffic-manager* 'kill-traffic-sphere (-> self sphere))
        )
    (none)
    )
  :trans (behavior ()
    (local-vars (at-0 int))
    (rlet ((vf0 :class vf)
           (vf1 :class vf)
           (vf2 :class vf)
           )
      (init-vf0-vector)
      (let ((v1-0 (-> self duration)))
        (if (and (nonzero? v1-0) (>= (- (current-time) (-> self state-time)) v1-0))
            (go empty-state)
            )
        )
      (let ((v1-5 (-> self track-joint)))
        (when (>= v1-5 0)
          (let ((a2-0 (handle->process (-> self track-handle)))
                (gp-0 (new 'stack-no-clear 'vector))
                )
            (when a2-0
              (set! (-> gp-0 quad) (-> self sphere quad))
              (set! (-> gp-0 w) 1.0)
              (vector-matrix*! gp-0 gp-0 (-> (the-as process-drawable a2-0) node-list data v1-5 bone transform))
              (let ((v1-9 (-> self root)))
                (vector-! (-> v1-9 transv) gp-0 (-> v1-9 trans))
                (let ((a0-12 (-> v1-9 transv)))
                  (.lvf vf1 (&-> (-> v1-9 transv) quad))
                  (let ((f0-1 (-> self clock frames-per-second)))
                    (.mov at-0 f0-1)
                    )
                  (.mov vf2 at-0)
                  (.mov.vf vf1 vf0 :mask #b1000)
                  (.mul.x.vf vf1 vf1 vf2 :mask #b111)
                  (.svf (&-> a0-12 quad) vf1)
                  )
                )
              (move-to-point! (-> self root) gp-0)
              (set! (-> self danger sphere x) (-> gp-0 x))
              (set! (-> self danger sphere y) (-> gp-0 y))
              (set! (-> self danger sphere z) (-> gp-0 z))
              )
            )
          )
        )
      (if (logtest? (-> self mode) (fma-sphere-mode danger))
          (send-event *traffic-manager* 'add-danger-sphere (-> self danger))
          )
      (when (logtest? (-> self mode) (fma-sphere-mode deadly-overlap))
        (let ((a1-10 (new 'stack-no-clear 'overlaps-others-params)))
          (set! (-> a1-10 options) (overlaps-others-options))
          (set! (-> a1-10 collide-with-filter) (the-as collide-spec -1))
          (set! (-> a1-10 tlist) *touching-list*)
          (find-overlapping-shapes (-> self root) a1-10)
          )
        )
      (if (or (logtest? *display-scene-control* (scene-controls display-controls))
              (and *display-nav-marks* (logtest? (-> self mode) (fma-sphere-mode nav)))
              )
          (add-debug-sphere
            #t
            (bucket-id debug2)
            (-> self root trans)
            (-> self sphere r)
            (new 'static 'rgba :r #x80 :g #x40 :a #x80)
            )
          )
      (none)
      )
    )
  :code (the-as (function none :behavior fma-sphere) sleep-code)
  )

;; WARN: Return type mismatch object vs none.
(defbehavior fma-sphere-init-by-other fma-sphere ((arg0 fma-sphere-mode) (arg1 process-drawable) (arg2 int) (arg3 time-frame) (arg4 vector) (arg5 vector))
  (set! (-> self mode) arg0)
  (set! (-> self first-time?) #t)
  (set! (-> self duration) arg3)
  (cond
    ((and arg1 (>= arg2 0))
     (set! (-> self track-joint) arg2)
     (set! (-> self track-handle) (process->handle arg1))
     )
    (else
      (set! (-> self track-joint) -1)
      (set! (-> self track-handle) (the-as handle #f))
      )
    )
  (cond
    (arg5
      (mem-copy! (the-as pointer (-> self danger)) (the-as pointer arg5) 54)
      (cond
        (arg4
          (set! (-> self sphere quad) (-> arg4 quad))
          (set! (-> self danger sphere quad) (-> arg4 quad))
          )
        (else
          (set! (-> self sphere quad) (-> self danger sphere quad))
          )
        )
      )
    (arg4
      (set! (-> self sphere quad) (-> arg4 quad))
      (when (logtest? (-> self mode) (fma-sphere-mode danger))
        (set! (-> self danger sphere quad) (-> arg4 quad))
        (set! (-> self danger velocity quad) (the-as uint128 0))
        (set! (-> self danger notify-radius) (+ 40960.0 (-> self sphere r)))
        (set! (-> self danger danger-level) 1.0)
        (set! (-> self danger decay-rate) 0.0)
        (set! (-> self danger flags) (traffic-danger-flags tdf0))
        (set! (-> self danger danger-type) (traffic-danger-type tdt4))
        )
      )
    (else
      (format 0 "ERROR: Initializing an fma-sphere without a sphere or danger info!~%")
      (go empty-state)
      )
    )
  (let ((gp-1 (new 'process 'collide-shape self (collide-list-enum hit-by-player))))
    (let ((v1-24 (new 'process 'collide-shape-prim-sphere gp-1 (the-as uint 0))))
      (set! (-> v1-24 prim-core collide-as) (collide-spec obstacle))
      (set-vector! (-> v1-24 local-sphere) 0.0 0.0 0.0 4096.0)
      (set! (-> gp-1 total-prims) (the-as uint 1))
      (set! (-> gp-1 root-prim) v1-24)
      )
    (set! (-> gp-1 nav-radius) (* 0.75 (-> gp-1 root-prim local-sphere w)))
    (let ((v1-27 (-> gp-1 root-prim)))
      (set! (-> gp-1 backup-collide-as) (-> v1-27 prim-core collide-as))
      (set! (-> gp-1 backup-collide-with) (-> v1-27 prim-core collide-with))
      )
    (set! (-> self root) gp-1)
    )
  (let ((gp-2 (-> self root)))
    (set! (-> gp-2 nav-radius) (-> self sphere r))
    (set! (-> gp-2 root-prim local-sphere w) (-> self sphere r))
    (set! (-> gp-2 trans quad) (-> self sphere quad))
    (set! (-> gp-2 trans w) 1.0)
    (vector-identity! (-> gp-2 scale))
    (quaternion-identity! (-> gp-2 quat))
    (cond
      ((logtest? (-> self mode) (fma-sphere-mode deadly-overlap))
       (set! (-> gp-2 event-self) 'touched)
       (let ((v1-35 (-> gp-2 root-prim)))
         (set! (-> v1-35 prim-core collide-with) (collide-spec crate civilian enemy hit-by-others-list))
         (logior! (-> v1-35 prim-core action) (collide-action deadly))
         )
       )
      (else
        (let ((v1-36 (-> gp-2 root-prim)))
          (set! (-> v1-36 prim-core collide-as) (collide-spec))
          (set! (-> v1-36 prim-core collide-with) (collide-spec))
          )
        0
        )
      )
    (update-transforms gp-2)
    )
  (logclear! (-> self mask) (process-mask actor-pause enemy))
  (when (logtest? (-> self mode) (fma-sphere-mode nav))
    (let ((a0-32 (find-nearest-nav-mesh (-> self root trans) (the-as float #x7f800000))))
      (cond
        (a0-32
          (add-process-drawable-to-navmesh a0-32 self #f)
          )
        (else
          (format 0 "ERROR: fma-sphere-init-by-other: failed to find nearest nav-mesh!~%")
          (go empty-state)
          )
        )
      )
    )
  (when (logtest? (-> self mode) (fma-sphere-mode deadly-overlap))
    (let* ((v1-53 *game-info*)
           (a0-35 (+ (-> v1-53 attack-id) 1))
           )
      (set! (-> v1-53 attack-id) a0-35)
      (set! (-> self attack-id) a0-35)
      )
    )
  (go-virtual idle)
  (none)
  )
