;;-*-Lisp-*-
(in-package goal)

;; name: joint-mod.gc
;; name in dgo: joint-mod
;; dgos: ENGINE, GAME

(define-extern real-joint-mod-gun-look-at-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-gun-look-at-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-foot-rot-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-look-at-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-polar-look-at-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-world-look-at-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-rotate-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-scale-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-joint-set-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-joint-set-world-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-joint-set*-handler (function cspace transformq none :behavior process))
(define-extern joint-mod-joint-set*-world-handler (function cspace transformq none :behavior process))

;; DECOMP BEGINS

;; WARN: Return type mismatch matrix vs none.
;; WARN: Function joint-mod-ik-callback has a return type of none, but the expression builder found a return statement.
;; ERROR: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defbehavior joint-mod-ik-callback process ((arg0 cspace) (arg1 transformq))
  (local-vars
    (f0-24 float)
    (sv-736 vector)
    (sv-752 vector)
    (sv-768 vector)
    (sv-784 vector)
    (sv-800 (function quaternion vector vector quaternion))
    (sv-816 quaternion)
    (sv-832 vector)
    (sv-848 vector)
    (sv-864 vector)
    (sv-880 vector)
    (sv-896 vector)
    (sv-912 quaternion)
    (sv-928 quaternion)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (the-as joint-mod-ik (-> arg0 param1))))
      (-> arg0 param2)
      (cspace<-parented-transformq-joint! arg0 arg1)
      (cond
        ((logtest? (-> gp-0 flags) (joint-mod-ik-flags enable))
         (+! (-> gp-0 blend) (* 4.0 (-> self clock seconds-per-frame)))
         (if (< 1.0 (-> gp-0 blend))
             (set! (-> gp-0 blend) 1.0)
             )
         )
        (else
          (set! (-> gp-0 blend) (- (-> gp-0 blend) (* 4.0 (-> self clock seconds-per-frame))))
          (if (< (-> gp-0 blend) 0.0)
              (set! (-> gp-0 blend) 0.0)
              )
          )
        )
      (if (= (-> gp-0 blend) 0.0)
          (return #f)
          )
      (let ((s5-0 (-> arg0 parent bone transform))
            (s4-1 (-> arg0 bone transform))
            )
        (new 'stack-no-clear 'matrix)
        (new 'stack-no-clear 'matrix)
        (let ((s3-0 (new 'stack-no-clear 'vector)))
          (matrix->trans s5-0 s3-0)
          (set! (-> s5-0 trans quad) (-> s3-0 quad))
          (matrix->trans s4-1 s3-0)
          (set! (-> s4-1 trans quad) (-> s3-0 quad))
          )
        (let* ((a2-0 (-> gp-0 shoulder-matrix-no-ik))
               (a3-0 s5-0)
               (v1-22 (-> a3-0 quad 0))
               (a0-7 (-> a3-0 quad 1))
               (a1-3 (-> a3-0 quad 2))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> a2-0 quad 0) v1-22)
          (set! (-> a2-0 quad 1) a0-7)
          (set! (-> a2-0 quad 2) a1-3)
          (set! (-> a2-0 trans quad) a3-1)
          )
        (let* ((a2-1 (-> gp-0 elbow-matrix-no-ik))
               (a3-2 s4-1)
               (v1-23 (-> a3-2 quad 0))
               (a0-8 (-> a3-2 quad 1))
               (a1-4 (-> a3-2 quad 2))
               (a3-3 (-> a3-2 trans quad))
               )
          (set! (-> a2-1 quad 0) v1-23)
          (set! (-> a2-1 quad 1) a0-8)
          (set! (-> a2-1 quad 2) a1-4)
          (set! (-> a2-1 trans quad) a3-3)
          )
        (set! sv-752 (new 'stack-no-clear 'vector))
        (set! sv-736 (new 'stack-no-clear 'vector))
        (let ((s0-0 (new 'stack-no-clear 'vector))
              (s1-0 (new 'stack-no-clear 'vector))
              (s3-1 (new 'stack-no-clear 'vector))
              )
          0.0
          0.0
          (set! (-> sv-752 quad) (-> s5-0 trans quad))
          (set! (-> sv-736 quad) (-> s4-1 trans quad))
          (let ((a1-5 s0-0))
            (let ((v1-28 sv-736))
              (let ((a0-13 (-> s4-1 vector 1)))
                (let ((a2-2 (-> gp-0 hand-dist)))
                  (.mov vf7 a2-2)
                  )
                (.lvf vf5 (&-> a0-13 quad))
                )
              (.lvf vf4 (&-> v1-28 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-5 quad) vf6)
            )
          (if (-> gp-0 callback)
              ((-> gp-0 callback) gp-0 s5-0 s4-1 s0-0)
              )
          (set! (-> s1-0 quad) (-> gp-0 handle-pos quad))
          (let ((f30-0 (vector-vector-distance sv-752 sv-736))
                (f0-12 (vector-vector-distance sv-736 s0-0))
                (s2-1 (vector-! (new 'stack-no-clear 'vector) s1-0 sv-752))
                )
            (vector-length s2-1)
            (+ -4.096 f0-12 f30-0)
            (let ((f0-15 (+ 4.096 (fabs (- f30-0 f0-12)))))
              (cond
                ((< f0-15 f0-15)
                 (vector-normalize! s2-1 f0-15)
                 (vector+! s1-0 sv-752 s2-1)
                 )
                ((< f0-15 f0-15)
                 (vector-normalize! s2-1 f0-15)
                 (vector+! s1-0 sv-752 s2-1)
                 )
                )
              )
            )
          (let ((s2-3 (vector-! (new 'stack-no-clear 'vector) sv-736 sv-752)))
            (set! sv-784 (new 'stack-no-clear 'vector))
            (.lvf vf4 (&-> s0-0 quad))
            (.lvf vf5 (&-> sv-736 quad))
            (.mov.vf vf6 vf0 :mask #b1000)
            (.sub.vf vf6 vf4 vf5 :mask #b111)
            (.svf (&-> sv-784 quad) vf6)
            (set! sv-832 (new 'stack-no-clear 'vector))
            (let ((v1-49 sv-752))
              (.lvf vf4 (&-> s0-0 quad))
              (.lvf vf5 (&-> v1-49 quad))
              )
            (.mov.vf vf6 vf0 :mask #b1000)
            (.sub.vf vf6 vf4 vf5 :mask #b111)
            (.svf (&-> sv-832 quad) vf6)
            (let ((s0-1 (new 'stack-no-clear 'vector)))
              (.lvf vf4 (&-> s1-0 quad))
              (.lvf vf5 (&-> sv-752 quad))
              (.mov.vf vf6 vf0 :mask #b1000)
              (.sub.vf vf6 vf4 vf5 :mask #b111)
              (.svf (&-> s0-1 quad) vf6)
              (set! sv-928 (new 'stack-no-clear 'quaternion))
              (let ((s1-1 (new 'stack-no-clear 'quaternion)))
                (let ((f26-0 (vector-length s2-3))
                      (f24-0 (vector-length sv-784))
                      (f30-1 (vector-length s0-1))
                      )
                  (set! sv-768 (new 'stack-no-clear 'vector))
                  (let* ((f28-0 (vector-vector-angle-safe s2-3 sv-784))
                         (f0-17 (fmax -1.0 (fmin 1.0 (/ (- (- (* f30-1 f30-1) (* f26-0 f26-0)) (* f24-0 f24-0)) (* 2.0 f24-0 f26-0)))))
                         (f26-1 (acos f0-17))
                         )
                    (cond
                      ((= f28-0 0.0)
                       (set! (-> sv-768 quad) (-> s4-1 vector (-> gp-0 elbow-rotation-axis) quad))
                       (when (logtest? (-> gp-0 flags) (joint-mod-ik-flags elbow-rot-neg))
                         (vector-negate! sv-768 sv-768)
                         (set! f26-1 (- f26-1))
                         )
                       (set! (-> s3-1 quad) (-> s4-1 vector (-> gp-0 elbow-pole-vector-axis) quad))
                       (if (logtest? (-> gp-0 flags) (joint-mod-ik-flags elbow-trans-neg))
                           (vector-negate! s3-1 s3-1)
                           )
                       )
                      (else
                        (vector-cross! sv-768 s2-3 sv-784)
                        (vector-!
                          s3-1
                          s2-3
                          (vector-float*! (new 'stack-no-clear 'vector) sv-832 (/ (vector-dot sv-832 s2-3) (vector-dot sv-832 sv-832)))
                          )
                        )
                      )
                    (vector-normalize! s3-1 1.0)
                    (vector-normalize! sv-768 1.0)
                    (let ((t9-14 quaternion-vector-angle!)
                          (a0-44 sv-928)
                          (a2-5 (- f26-1 f28-0))
                          )
                      (t9-14 a0-44 sv-768 a2-5)
                      )
                    )
                  (vector-orient-by-quat! sv-784 sv-784 sv-928)
                  (let ((v1-74 sv-832))
                    (let ((a0-46 s2-3))
                      (.mov.vf vf6 vf0 :mask #b1000)
                      (.lvf vf4 (&-> a0-46 quad))
                      )
                    (.lvf vf5 (&-> sv-784 quad))
                    (.add.vf vf6 vf4 vf5 :mask #b111)
                    (.svf (&-> v1-74 quad) vf6)
                    )
                  (set! sv-800 quaternion-from-two-vectors!)
                  (set! sv-816 s1-1)
                  (let ((t9-16 vector-normalize-copy!)
                        (a0-48 (new 'stack-no-clear 'vector))
                        (a2-7 1.0)
                        )
                    (set! sv-848 (t9-16 a0-48 sv-832 a2-7))
                    )
                  (let ((a2-9 (vector-normalize-copy! (new 'stack-no-clear 'vector) s0-1 1.0)))
                    (sv-800 sv-816 sv-848 a2-9)
                    )
                  (vector-orient-by-quat! s2-3 s2-3 s1-1)
                  (set! sv-864 (vector-normalize-copy! (new 'stack-no-clear 'vector) s2-3 1.0))
                  (let* ((v1-76 (vector-normalize-copy! (new 'stack-no-clear 'vector) s0-1 1.0))
                         (f0-23 (-> sv-864 x))
                         (f1-16 (-> sv-864 y))
                         (f2-6 (-> sv-864 z))
                         (f3-5 (-> v1-76 x))
                         (f4-0 (-> v1-76 y))
                         (f5-0 (-> v1-76 z))
                         )
                    ; (.mula.s f0-23 f3-5)
                    ; (.madda.s f1-16 f4-0)
                    ; (.madd.s f0-24 f2-6 f5-0)
                    (set! f0-24 (+ (* f0-23 f3-5) (* f1-16 f4-0) (* f2-6 f5-0)))
                    )
                  (let ((f0-26 (fabs f0-24)))
                    (if (< 0.98 f0-26)
                        (vector-orient-by-quat! s2-3 s3-1 s1-1)
                        )
                    )
                  (set! sv-880 (new 'stack-no-clear 'vector))
                  (set! sv-896 (new 'stack-no-clear 'vector))
                  (new 'stack-no-clear 'vector)
                  (* f30-1 f30-1)
                  )
                (set! sv-912 (new 'stack-no-clear 'quaternion))
                (vector-flatten! sv-880 s2-3 s0-1)
                (vector-flatten! sv-896 s3-1 s0-1)
                (vector-normalize! sv-880 1.0)
                (vector-normalize! sv-896 1.0)
                (quaternion-from-two-vectors! sv-912 sv-880 sv-896)
                (let ((t9-28 quaternion*!)
                      (a0-63 s1-1)
                      (a2-17 s1-1)
                      )
                  (t9-28 a0-63 sv-912 a2-17)
                  )
                (quaternion-pseudo-slerp! sv-928 *unity-quaternion* sv-928 (-> gp-0 blend))
                (quaternion-pseudo-slerp! s1-1 *unity-quaternion* s1-1 (-> gp-0 blend))
                (let ((a2-20 (quaternion->matrix (new 'stack-no-clear 'matrix) sv-928))
                      (gp-1 (new 'stack-no-clear 'vector))
                      )
                  (set! (-> gp-1 quad) (-> s4-1 trans quad))
                  (matrix*! s4-1 s4-1 a2-20)
                  (set! (-> s4-1 trans quad) (-> gp-1 quad))
                  )
                (let ((s3-2 (quaternion->matrix (new 'stack-no-clear 'matrix) s1-1))
                      (a2-21 (matrix-4x4-inverse! (new 'stack-no-clear 'matrix) s5-0))
                      (gp-2 (new 'stack-no-clear 'matrix))
                      )
                  (set! (-> gp-2 quad 0) (-> s5-0 trans quad))
                  (matrix*! s4-1 s4-1 a2-21)
                  (matrix*! s5-0 s5-0 s3-2)
                  (set! (-> s5-0 trans quad) (-> gp-2 quad 0))
                  )
                )
              )
            )
          )
        (matrix*! s4-1 s4-1 s5-0)
        )
      )
    (none)
    )
  )

(defmethod new joint-mod-ik ((allocation symbol) (type-to-make type) (arg0 process-drawable) (arg1 int) (arg2 float))
  (let ((v0-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> v0-0 process) arg0)
    (set! (-> v0-0 hand-dist) arg2)
    (set! (-> v0-0 elbow-pole-vector-axis) (the-as uint 0))
    (logclear! (-> v0-0 flags) (joint-mod-ik-flags elbow-trans-neg))
    (set! (-> v0-0 elbow-rotation-axis) (the-as uint 2))
    (logclear! (-> v0-0 flags) (joint-mod-ik-flags elbow-rot-neg))
    (set! (-> v0-0 callback) #f)
    (set! (-> v0-0 blend) 0.0)
    (logclear! (-> v0-0 flags) (joint-mod-ik-flags enable))
    (let ((a0-5 (-> arg0 node-list data arg1)))
      (set! (-> a0-5 param0) joint-mod-ik-callback)
      (set! (-> a0-5 param1) v0-0)
      (set! (-> a0-5 param2) (the-as basic arg1))
      )
    v0-0
    )
  )

(defmethod handle-copy! joint-mod-ik ((obj joint-mod-ik) (arg0 vector))
  (set! (-> obj handle-pos quad) (-> arg0 quad))
  0
  (none)
  )

(defmethod enable-set! joint-mod-ik ((obj joint-mod-ik) (arg0 symbol))
  (if arg0
      (logior! (-> obj flags) (joint-mod-ik-flags enable))
      (logclear! (-> obj flags) (joint-mod-ik-flags enable))
      )
  0
  (none)
  )

(defbehavior real-joint-mod-gun-look-at-handler process ((arg0 cspace) (arg1 transformq))
  (local-vars
    (sv-16 joint-mod)
    (sv-64 vector)
    (sv-96 quaternion)
    (sv-160 vector)
    (sv-164 vector)
    (sv-168 vector)
    (sv-172 symbol)
    )
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (set! sv-16 (the-as joint-mod (-> arg0 param1)))
    (let ((a0-1 (-> arg1 scale)))
      (let ((v1-1 (-> arg1 scale))
            (a2-1 (-> sv-16 scale))
            )
        (.lvf vf4 (&-> v1-1 quad))
        (.lvf vf5 (&-> a2-1 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.vf vf6 vf4 vf5 :mask #b111)
      (.svf (&-> a0-1 quad) vf6)
      )
    (cspace<-parented-transformq-joint! arg0 arg1)
    (let ((s5-0 (-> arg0 bone transform)))
      (let ((s4-0 (matrix->quat s5-0 (new 'stack-no-clear 'quaternion))))
        (set! sv-64 (matrix->trans s5-0 (new 'stack-no-clear 'vector)))
        (quaternion-rotate-y! s4-0 s4-0 (-> sv-16 twist z))
        (set! sv-96 (quaternion-copy! (new 'stack-no-clear 'quaternion) s4-0))
        (when (!= (-> sv-16 flex-blend) 0.0)
          (set! sv-160 (vector-y-quaternion! (new 'stack-no-clear 'vector) sv-96))
          (set! sv-164 (vector-z-quaternion! (new 'stack-no-clear 'vector) sv-96))
          (set! sv-168 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> sv-16 target) sv-64) 1.0))
          (set! sv-172 (the-as symbol #f))
          (let* ((f30-0 (vector-y-angle sv-164))
                 (a0-13 (vector-flatten! (new 'stack-no-clear 'vector) sv-168 sv-160))
                 (f0-2 (vector-y-angle a0-13))
                 (f0-3 (deg-diff f30-0 f0-2))
                 (f30-1 (* f0-3 (-> sv-16 blend)))
                 )
            (let ((f28-0 (fmax (fmin f30-1 (-> sv-16 twist-max y)) (- (-> sv-16 twist-max y)))))
              (if (or (!= f30-1 f28-0) (= (-> sv-16 blend) 0.0))
                  (logclear! (-> sv-16 track-mode) (track-mode lock-on))
                  )
              (cond
                ((or (< (-> sv-16 ignore-angle) (fabs f0-3))
                     (< (-> sv-16 twist-max w) (vector-vector-distance (-> sv-16 target) sv-64))
                     )
                 (set! f30-1 0.0)
                 (set! f28-0 0.0)
                 (set! sv-172 #t)
                 )
                ((< 5461.3335 (fabs (deg-diff f30-1 f28-0)))
                 (set! (-> sv-16 blend) 0.0001)
                 )
                ((< 182.04445 (fabs (deg-diff f30-1 f28-0)))
                 (logclear! (-> sv-16 track-mode) (track-mode track-x))
                 )
                )
              (if (or (and (logtest? (-> sv-16 track-mode) (track-mode track-y)) (= f30-1 f28-0))
                      (< (-> sv-16 twist-max y) (fabs (-> sv-16 twist y)))
                      )
                  (set! (-> sv-16 twist y)
                        (deg-seek (-> sv-16 twist y) f28-0 (* (fabs (deg-diff f28-0 (-> sv-16 twist y)))
                                                              (if (logtest? (-> sv-16 track-mode) (track-mode lock-on))
                                                                  1.0
                                                                  (-> sv-16 twist-speed-y)
                                                                  )
                                                              (-> self clock time-adjust-ratio)
                                                              )
                                  )
                        )
                  )
              )
            (if (and (< (fabs (deg-diff f30-1 (-> sv-16 twist y))) 728.1778) (and (not sv-172) (!= (-> sv-16 blend) 0.0)))
                (logior! (-> sv-16 track-mode) (track-mode lock-on))
                )
            )
          (quaternion-rotate-local-y! sv-96 sv-96 (-> sv-16 twist y))
          (let* ((s3-1 (vector-x-quaternion! (new 'stack-no-clear 'vector) sv-96))
                 (f30-2 (vector-x-angle sv-164))
                 (s3-2 (vector-flatten! (new 'stack-no-clear 'vector) sv-168 s3-1))
                 (f0-24 (vector-x-angle s3-2))
                 (f30-3 (fmax
                          (fmin (* (- (deg-diff f30-2 f0-24)) (-> sv-16 blend)) (-> sv-16 twist-max x))
                          (- (-> sv-16 twist-max x))
                          )
                        )
                 )
            (if (or (< (vector-dot s3-2 sv-164) 0.1)
                    (< (-> sv-16 twist-max z) (vector-vector-distance (-> sv-16 target) sv-64))
                    )
                (set! f30-3 0.0)
                )
            (if (or (logtest? (-> sv-16 track-mode) (track-mode track-x))
                    (< (-> sv-16 twist-max x) (fabs (-> sv-16 twist x)))
                    )
                (set! (-> sv-16 twist x)
                      (deg-seek (-> sv-16 twist x) f30-3 (* (fabs (deg-diff f30-3 (-> sv-16 twist x)))
                                                            (if (logtest? (-> sv-16 track-mode) (track-mode lock-on))
                                                                1.0
                                                                (-> sv-16 twist-speed-x)
                                                                )
                                                            (-> self clock time-adjust-ratio)
                                                            )
                                )
                      )
                )
            )
          (quaternion-rotate-x! sv-96 sv-96 (-> sv-16 twist x))
          (quaternion-normalize! (quaternion*! sv-96 sv-96 (-> sv-16 quat)))
          )
        (let ((a1-27 (quaternion-slerp! (new 'stack-no-clear 'quaternion) s4-0 sv-96 (-> sv-16 flex-blend))))
          (matrix<-quat s5-0 a1-27)
          )
        )
      (let ((f30-4 (-> sv-16 trans x))
            (s4-1 (-> s5-0 vector 1))
            (v1-97 (vector<-matrix! (new 'stack-no-clear 'vector) s5-0))
            )
        (let ((f0-43 (- f30-4 (-> v1-97 y))))
          (if (< 614.4 (fabs f0-43))
              (+! (-> sv-16 trans z) (* 8.0 f0-43))
              )
          )
        (+! (-> sv-16 trans z) (* -260.0 (-> self clock seconds-per-frame) (-> sv-16 trans y)))
        (let ((f0-48 (-> sv-16 trans y)))
          (+! (-> sv-16 trans y) (* (-> sv-16 trans z) (-> self clock seconds-per-frame)))
          (set! (-> sv-16 trans y) (* 0.95 (-> sv-16 trans y)))
          (when (< (* f0-48 (-> sv-16 trans y)) 0.0)
            (set! (-> sv-16 trans y) 0.0)
            (set! (-> sv-16 trans z) 0.0)
            )
          )
        (cond
          ((< 409.6 (-> sv-16 trans y))
           (set! (-> sv-16 trans y) 409.6)
           (set! (-> sv-16 trans z) 0.0)
           )
          ((< (-> sv-16 trans y) -409.6)
           (set! (-> sv-16 trans y) -409.6)
           (set! (-> sv-16 trans z) 0.0)
           )
          )
        (set! (-> sv-16 trans x) (-> v1-97 y))
        (let ((f0-60 (* (-> sv-16 trans y) (-> sv-16 flex-blend))))
          (if (!= f0-60 0.0)
              (vector+float*! (-> s5-0 trans) v1-97 s4-1 f0-60)
              )
          )
        )
      )
    (if (-> sv-16 parented-scale?)
        (set-vector! (-> arg0 bone scale) 1.0 1.0 1.0 1.0)
        )
    0
    (none)
    )
  )

(defbehavior joint-mod-gun-look-at-handler process ((arg0 cspace) (arg1 transformq))
  (real-joint-mod-gun-look-at-handler arg0 arg1)
  (none)
  )

(defbehavior joint-mod-foot-rot-handler process ((arg0 cspace) (arg1 transformq))
  (let ((s5-0 (the-as joint-mod (-> arg0 param1)))
        (gp-0 (-> arg0 bone transform))
        )
    (cspace<-parented-transformq-joint! arg0 arg1)
    (let ((s3-0 (-> s5-0 target))
          (s4-0 (-> s5-0 twist-max))
          )
      1.0
      (when (< 8192.0 (vector-vector-angle-safe s3-0 s4-0))
        (let* ((a1-4 (vector-normalize! (vector-cross! (new 'stack-no-clear 'vector) s3-0 s4-0) 1.0))
               (a2-1 (quaternion-vector-angle! (new 'stack-no-clear 'quaternion) a1-4 8192.0))
               )
          (vector-orient-by-quat! s4-0 s3-0 a2-1)
          )
        )
      (let* ((f0-4 (/ (vector-dot *up-vector* (-> s5-0 joint bone transform vector 1))
                      (vector-length (-> s5-0 joint bone transform vector 1))
                      )
                   )
             (f30-1 (lerp-scale 0.0 1.0 f0-4 0.85 1.0))
             )
        (vector-deg-slerp (-> s5-0 twist) (-> s5-0 twist) s4-0 0.3)
        (set! (-> s4-0 quad) (-> s5-0 twist quad))
        (seek! (-> s5-0 blend) (-> s5-0 flex-blend) (* 4.0 (-> self clock seconds-per-frame)))
        (let ((s3-1 (matrix->scale gp-0 (new 'stack-no-clear 'vector))))
          (let ((s2-0 (matrix->quat gp-0 (new 'stack-no-clear 'quaternion)))
                (s0-0 (matrix->trans gp-0 (new 'stack-no-clear 'vector)))
                )
            (set! (-> gp-0 vector 1 quad) (-> s5-0 twist-max quad))
            (vector-cross! (-> gp-0 vector 2) (the-as vector (-> gp-0 vector)) (-> gp-0 vector 1))
            (vector-cross! (the-as vector (-> gp-0 vector)) (-> gp-0 vector 1) (-> gp-0 vector 2))
            (set! (-> gp-0 vector 0 w) 0.0)
            (set! (-> gp-0 vector 1 w) 0.0)
            (set! (-> gp-0 vector 2 w) 0.0)
            (let ((s1-0 (matrix->quat gp-0 (new 'stack-no-clear 'quaternion))))
              (let* ((f0-14 (vector-dot s4-0 (vector-! (new 'stack-no-clear 'vector) s0-0 (-> s5-0 trans))))
                     (f0-15 (lerp-scale 1.0 0.0 f0-14 819.2 2048.0))
                     )
                (seek!
                  (-> s5-0 polar-internal-tilt-max)
                  (* (-> s5-0 blend) f0-15 f30-1)
                  (* 15.0 (-> self clock seconds-per-frame))
                  )
                )
              (quaternion-slerp! s1-0 s2-0 s1-0 (-> s5-0 polar-internal-tilt-max))
              (matrix<-quat gp-0 s1-0)
              )
            )
          (matrix<-scale gp-0 s3-1)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod new joint-mod ((allocation symbol) (type-to-make type) (arg0 joint-mod-mode) (arg1 process-drawable) (arg2 int))
  (let ((gp-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> gp-0 process) arg1)
    (set! (-> gp-0 joint) (-> arg1 node-list data arg2))
    (mode-set! gp-0 arg0)
    (set-vector! (-> gp-0 twist-max) 8192.0 11832.889 0.0 1.0)
    (set! (-> gp-0 twist-speed-x) 0.1)
    (set! (-> gp-0 twist-speed-y) 0.1)
    (set! (-> gp-0 twist-min-x) (-> gp-0 twist-max x))
    (set! (-> gp-0 twist-min-y) (-> gp-0 twist-max y))
    (set! (-> gp-0 up) (the-as uint 1))
    (set! (-> gp-0 nose) (the-as uint 2))
    (set! (-> gp-0 ear) (the-as uint 0))
    (set! (-> gp-0 base-joint) (the-as uint arg2))
    (set! (-> gp-0 base-nose) (the-as uint 2))
    (set! (-> gp-0 max-dist) 122880.0)
    (set! (-> gp-0 ignore-angle) 65536.0)
    (set! (-> gp-0 flex-blend) 1.0)
    (set! (-> gp-0 shutting-down?) #f)
    (set-vector! (-> gp-0 scale) 1.0 1.0 1.0 1.0)
    (set! (-> gp-0 parented-scale?) #f)
    (quaternion-identity! (-> gp-0 quat))
    gp-0
    )
  )

;; WARN: Return type mismatch joint-mod vs none.
(defmethod mode-set! joint-mod ((obj joint-mod) (arg0 joint-mod-mode))
  (set! (-> obj mode) arg0)
  (let ((v1-0 (-> obj joint)))
    (case arg0
      (((joint-mod-mode flex-blend))
       (set! (-> v1-0 param0) #f)
       (set! (-> obj blend) 0.0)
       (set! (-> obj flex-blend) 1.0)
       )
      (((joint-mod-mode reset))
       (set! (-> v1-0 param0) #f)
       (set! (-> obj blend) 0.0)
       (set! (-> obj shutting-down?) #f)
       )
      (((joint-mod-mode look-at))
       (let ((a0-4 v1-0))
         (set! (-> a0-4 param0) joint-mod-look-at-handler)
         (set! (-> a0-4 param1) obj)
         )
       )
      (((joint-mod-mode gun-look-at))
       (let ((a0-5 v1-0))
         (set! (-> a0-5 param0) joint-mod-gun-look-at-handler)
         (set! (-> a0-5 param1) obj)
         )
       )
      (((joint-mod-mode foot-rot))
       (set-vector! (-> obj twist) 0.0 1.0 0.0 1.0)
       (let ((a0-7 v1-0))
         (set! (-> a0-7 param0)
               (lambda ((arg0 cspace) (arg1 transformq)) (joint-mod-foot-rot-handler arg0 arg1) (none))
               )
         (set! (-> a0-7 param1) obj)
         )
       )
      (((joint-mod-mode world-look-at))
       (let ((a0-8 v1-0))
         (set! (-> a0-8 param0) joint-mod-world-look-at-handler)
         (set! (-> a0-8 param1) obj)
         )
       )
      (((joint-mod-mode polar-look-at))
       (let ((a0-9 v1-0))
         (set! (-> a0-9 param0) joint-mod-polar-look-at-handler)
         (set! (-> a0-9 param1) obj)
         )
       (set! (-> obj polar-internal-tilt-max) 32768.0)
       (set! (-> obj polar-internal-radius) 32768.0)
       (set! (-> obj polar-external-tilt-max) 32768.0)
       (set! (-> obj polar-external-radius) 32768.0)
       )
      (((joint-mod-mode rotate))
       (let ((a0-11 v1-0))
         (set! (-> a0-11 param0) joint-mod-rotate-handler)
         (set! (-> a0-11 param1) obj)
         )
       (set! (-> obj blend) 1.0)
       )
      (((joint-mod-mode rotate2))
       (let ((a0-13 v1-0))
         (set! (-> a0-13 param0) joint-mod-rotate-handler)
         (set! (-> a0-13 param1) obj)
         )
       (set! (-> obj blend) 1.0)
       )
      (((joint-mod-mode joint-set))
       (let ((a0-15 v1-0))
         (set! (-> a0-15 param0) joint-mod-joint-set-handler)
         (set! (-> a0-15 param1) obj)
         )
       (vector-reset! (-> obj trans))
       (quaternion-identity! (-> obj quat))
       (set-vector! (-> obj scale) 1.0 1.0 1.0 1.0)
       )
      (((joint-mod-mode joint-set-world))
       (let ((a0-18 v1-0))
         (set! (-> a0-18 param0) joint-mod-joint-set-world-handler)
         (set! (-> a0-18 param1) obj)
         )
       (vector-reset! (-> obj trans))
       (quaternion-identity! (-> obj quat))
       (set-vector! (-> obj scale) 1.0 1.0 1.0 1.0)
       (set! (-> obj flex-blend) 1.0)
       )
      (((joint-mod-mode joint-set*))
       (let ((a0-25 v1-0))
         (set! (-> a0-25 param0) joint-mod-joint-set*-handler)
         (set! (-> a0-25 param1) obj)
         )
       (vector-reset! (-> obj trans))
       (quaternion-identity! (-> obj quat))
       (set-vector! (-> obj scale) 1.0 1.0 1.0 1.0)
       )
      (((joint-mod-mode joint-set*-world))
       (let ((a0-29 v1-0))
         (set! (-> a0-29 param0) joint-mod-joint-set*-world-handler)
         (set! (-> a0-29 param1) obj)
         )
       (vector-reset! (-> obj trans))
       (quaternion-identity! (-> obj quat))
       (set-vector! (-> obj scale) 1.0 1.0 1.0 1.0)
       )
      )
    )
  (none)
  )

;; WARN: Return type mismatch joint-mod vs none.
(defmethod shut-down joint-mod ((obj joint-mod))
  (set! (-> obj shutting-down?) #t)
  (set! (-> obj blend) 0.0)
  (none)
  )

(defmethod twist-set! joint-mod ((obj joint-mod) (arg0 float) (arg1 float) (arg2 float))
  (if arg0
      (set! (-> obj twist x) arg0)
      )
  (if arg1
      (set! (-> obj twist y) arg1)
      )
  (if arg2
      (set! (-> obj twist z) arg2)
      )
  (-> obj twist)
  )

(defmethod trs-set! joint-mod ((obj joint-mod) (arg0 vector) (arg1 quaternion) (arg2 vector))
  (if arg0
      (set! (-> obj trans quad) (-> arg0 quad))
      )
  (if arg1
      (quaternion-copy! (-> obj quat) arg1)
      )
  (if arg2
      (set! (-> obj scale quad) (-> arg2 quad))
      )
  0
  (none)
  )

(defmethod target-set! joint-mod ((obj joint-mod) (arg0 vector))
  (if (= (-> obj mode) (joint-mod-mode reset))
      (mode-set! obj (joint-mod-mode look-at))
      )
  (let ((f0-0 (vector-vector-distance (-> obj process root trans) arg0)))
    (set! (-> obj shutting-down?) #f)
    (set! (-> obj target quad) (-> arg0 quad))
    (if (< f0-0 (-> obj max-dist))
        (set! (-> obj blend) 1.0)
        (set! (-> obj blend) 0.0)
        )
    )
  0
  (none)
  )

(define last-try-to-look-at-data (new 'global 'try-to-look-at-info))

(defmethod look-at! joint-mod ((obj joint-mod) (arg0 vector) (arg1 symbol) (arg2 process))
  (when (= arg1 'attacking)
    (let* ((s2-0 arg2)
           (s1-0 (if (type? s2-0 process-drawable)
                     (the-as process-drawable s2-0)
                     )
                 )
           )
      (when s1-0
        (let* ((s0-0 (-> s1-0 fact))
               (s2-1 (if (type? s0-0 fact-info-enemy)
                         (the-as fact-info-enemy s0-0)
                         )
                     )
               )
          (when s2-1
            (when (< (vector-vector-distance (-> obj process root trans) (-> s1-0 root trans)) (-> s2-1 cam-notice-dist))
              (set! (-> obj notice-time) (current-time))
              (set! (-> last-try-to-look-at-data who) (process->handle arg2))
              (if (< (-> last-try-to-look-at-data vert) (-> s2-1 cam-vert))
                  (set! (-> last-try-to-look-at-data vert) (-> s2-1 cam-vert))
                  )
              (if (< (-> last-try-to-look-at-data horz) (-> s2-1 cam-horz))
                  (set! (-> last-try-to-look-at-data horz) (-> s2-1 cam-horz))
                  )
              )
            )
          )
        )
      )
    )
  (let ((f30-0 (vector-vector-distance (-> obj process root trans) arg0)))
    (if (logtest? (process-mask enemy) (-> arg2 mask))
        (+! (-> obj loock-at-count) (the int (lerp-scale 256.0 0.0 f30-0 20480.0 204800.0)))
        )
    (when (and (or (= (-> obj blend) 0.0)
                   (or (< f30-0 (vector-vector-distance (-> obj process root trans) (-> obj target))) (= arg1 'force))
                   )
               (< f30-0 (-> obj max-dist))
               )
      (if (= (-> obj mode) (joint-mod-mode reset))
          (mode-set! obj (joint-mod-mode look-at))
          )
      (set! (-> obj target quad) (-> arg0 quad))
      (set! (-> obj blend) 1.0)
      (set! (-> obj shutting-down?) #f)
      )
    )
  0
  (none)
  )

;; ERROR: Stack slot load at 176 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 176 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 176 mismatch: defined as size 4, got size 16
;; ERROR: Stack slot load at 176 mismatch: defined as size 4, got size 16
;; ERROR: Unsupported inline assembly instruction kind - [mula.s f0, f3]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f1, f4]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f0, f2, f5]
(defbehavior joint-mod-look-at-handler process ((arg0 cspace) (arg1 transformq))
  (local-vars (f0-1 float) (sv-80 symbol) (sv-144 vector) (sv-160 vector) (sv-176 float))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((gp-0 (the-as joint-mod (-> arg0 param1))))
      (cspace<-parented-transformq-joint! arg0 arg1)
      (let ((s1-0 (vector-normalize-copy!
                    (new 'stack-no-clear 'vector)
                    (-> gp-0 process node-list data 0 bone transform vector 1)
                    1.0
                    )
                  )
            (s2-0 (matrix->trans (-> arg0 bone transform) (new 'stack-no-clear 'vector)))
            (s3-0 (vector-normalize! (-> arg0 bone transform vector (-> gp-0 nose)) 1.0))
            (s0-0 (vector-normalize! (-> arg0 bone transform vector (-> gp-0 ear)) 1.0))
            )
        (set! sv-144 (vector-normalize!
                       (vector-cross!
                         (new 'stack-no-clear 'vector)
                         (-> arg0 bone transform vector (-> gp-0 up))
                         (-> arg0 bone transform vector (-> gp-0 nose))
                         )
                       1.0
                       )
              )
        (let ((s2-1 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> gp-0 target) s2-0) 1.0)))
          (set! sv-160 (-> gp-0 process node-list data (-> gp-0 base-joint) bone transform vector (-> gp-0 base-nose)))
          (set! sv-80 (the-as symbol #f))
          (let ((f0-0 (-> sv-144 x))
                (f1-0 (-> sv-144 y))
                (f2-0 (-> sv-144 z))
                (f3-0 (-> s0-0 x))
                (f4-0 (-> s0-0 y))
                (f5-0 (-> s0-0 z))
                )
            ; (.mula.s f0-0 f3-0)
            ; (.madda.s f1-0 f4-0)
            ; (.madd.s f0-1 f2-0 f5-0)
            (set! f0-1 (+ (* f0-0 f3-0) (* f1-0 f4-0) (* f2-0 f5-0)))
            )
          (if (< f0-1 0.0)
              (set! sv-80 #t)
              )
          (let* ((f30-0 (vector-y-angle s3-0))
                 (a0-18 (vector-flatten! (new-stack-vector0) s2-1 s1-0))
                 (f0-3 (vector-y-angle a0-18))
                 (f30-1 (deg-diff f30-0 f0-3))
                 (f0-4 (if (= (-> gp-0 base-joint) (+ (-> arg0 joint number) 1))
                           0.0
                           (deg-diff (vector-y-angle s3-0) (vector-y-angle sv-160))
                           )
                       )
                 )
            (if (< (-> gp-0 ignore-angle) (fabs f30-1))
                (set! f30-1 0.0)
                )
            (let ((f30-2
                    (fmax
                      (fmin (* f30-1 (-> gp-0 blend) (-> gp-0 flex-blend)) (+ (-> gp-0 twist-max y) (* f0-4 (-> gp-0 flex-blend))))
                      (+ (- (-> gp-0 twist-max y)) (* f0-4 (-> gp-0 flex-blend)))
                      )
                    )
                  )
              (when (and (-> gp-0 shutting-down?) (< (fabs (- (-> gp-0 twist y) f30-2)) 18.204445))
                (if (and (= (-> gp-0 scale x) 1.0) (= (-> gp-0 scale y) 1.0) (= (-> gp-0 scale z) 1.0))
                    (mode-set! gp-0 (joint-mod-mode reset))
                    (mode-set! gp-0 (joint-mod-mode rotate2))
                    )
                )
              (let ((s1-2 deg-seek)
                    (s0-2 (-> gp-0 twist y))
                    )
                (set! sv-176 f30-2)
                (let ((a2-3 (* (fabs (deg-diff f30-2 (-> gp-0 twist y))) (-> gp-0 twist-speed-y) (-> self clock time-adjust-ratio)))
                      )
                  (set! (-> gp-0 twist y) (s1-2 s0-2 sv-176 a2-3))
                  )
                )
              )
            )
          0.0
          (let ((f0-25 (if sv-80
                           (- (-> gp-0 twist y))
                           (-> gp-0 twist y)
                           )
                       )
                (v1-49 (-> gp-0 up))
                )
            (cond
              ((zero? v1-49)
               (quaternion-rotate-x! (-> arg1 quat) (-> arg1 quat) f0-25)
               )
              ((= v1-49 1)
               (quaternion-rotate-local-y! (-> arg1 quat) (-> arg1 quat) f0-25)
               )
              (else
                (quaternion-rotate-z! (-> arg1 quat) (-> arg1 quat) f0-25)
                )
              )
            )
          (let* ((s1-3
                   (vector-normalize-copy!
                     (new 'stack-no-clear 'vector)
                     (the-as vector (-> gp-0 process node-list data 0 bone transform))
                     1.0
                     )
                   )
                 (f30-3 (vector-x-angle s3-0))
                 (s2-2 (vector-flatten! (new-stack-vector0) s2-1 s1-3))
                 (f0-26 (vector-x-angle s2-2))
                 (f0-32
                   (fmax
                     (fmin (* (- (deg-diff f30-3 f0-26)) (-> gp-0 blend) (-> gp-0 flex-blend)) (-> gp-0 twist-max x))
                     (- (-> gp-0 twist-max x))
                     )
                   )
                 )
            (if (< (vector-dot s2-2 s3-0) 0.1)
                (set! f0-32 0.0)
                )
            (set! (-> gp-0 twist x)
                  (deg-seek
                    (-> gp-0 twist x)
                    f0-32
                    (* (fabs (deg-diff f0-32 (-> gp-0 twist x))) (-> gp-0 twist-speed-x) (-> self clock time-adjust-ratio))
                    )
                  )
            )
          )
        )
      (let ((v1-60 (-> gp-0 ear)))
        (cond
          ((zero? v1-60)
           (quaternion-rotate-x! (-> arg1 quat) (-> arg1 quat) (-> gp-0 twist x))
           )
          ((= v1-60 1)
           (quaternion-rotate-local-y! (-> arg1 quat) (-> arg1 quat) (-> gp-0 twist x))
           )
          (else
            (quaternion-rotate-z! (-> arg1 quat) (-> arg1 quat) (-> gp-0 twist x))
            )
          )
        )
      (vector+! (-> arg1 trans) (-> arg1 trans) (-> gp-0 trans))
      (quaternion-normalize! (quaternion*! (-> arg1 quat) (-> arg1 quat) (-> gp-0 quat)))
      (let ((a1-36 (-> arg1 scale)))
        (let ((v1-63 (-> arg1 scale))
              (a0-46 (-> gp-0 scale))
              )
          (.lvf vf4 (&-> v1-63 quad))
          (.lvf vf5 (&-> a0-46 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.vf vf6 vf4 vf5 :mask #b111)
        (.svf (&-> a1-36 quad) vf6)
        )
      (cspace<-parented-transformq-joint! arg0 arg1)
      (if (-> gp-0 parented-scale?)
          (set-vector! (-> arg0 bone scale) 1.0 1.0 1.0 1.0)
          )
      (if (and (= (-> gp-0 process type) target) (!= (-> gp-0 blend) 0.0))
          (add-debug-text-sphere
            *display-target-marks*
            (bucket-id debug-no-zbuf1)
            (-> gp-0 target)
            (meters 0.2)
            "look"
            (new 'static 'rgba :r #xff :g #xff :a #x80)
            )
          )
      )
    0
    (none)
    )
  )

;; WARN: Return type mismatch symbol vs none.
(defbehavior joint-mod-polar-look-at-guts process ((arg0 cspace) (arg1 transformq))
  (let ((gp-0 (the-as joint-mod (-> arg0 param1))))
    (cspace<-parented-transformq-joint! arg0 arg1)
    (let ((s3-0 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 bone transform vector 2) 1.0))
          (s1-0 (vector-normalize!
                  (vector-! (new 'stack-no-clear 'vector) (-> gp-0 target) (-> arg0 bone transform trans))
                  1.0
                  )
                )
          (s4-0 (new 'stack-no-clear 'matrix))
          )
      (let ((s2-0 (new 'stack-no-clear 'vector)))
        (vector-normalize-copy! (the-as vector (-> s4-0 vector)) (the-as vector (-> arg0 bone transform)) 1.0)
        (vector-normalize-copy! (-> s4-0 vector 1) (-> arg0 bone transform vector 1) 1.0)
        (vector-normalize-copy! (-> s4-0 vector 2) (-> arg0 bone transform vector 2) 1.0)
        (set-vector! (-> s4-0 trans) 0.0 0.0 0.0 1.0)
        (matrix-transpose! s4-0 s4-0)
        (set-vector! (-> s4-0 trans) 0.0 0.0 0.0 1.0)
        (vector-matrix*! s2-0 s1-0 s4-0)
        (let* ((t9-8 asin)
               (f0-8 (-> s2-0 x))
               (f0-10 (* f0-8 f0-8))
               (f1-0 (-> s2-0 y))
               (f28-0 (t9-8 (sqrtf (+ f0-10 (* f1-0 f1-0)))))
               (f30-0 (atan (-> s2-0 y) (-> s2-0 x)))
               )
          (if (< (-> s2-0 z) 0.0)
              (set! f28-0 (- 32768.0 f28-0))
              )
          (set! (-> gp-0 polar-internal-radius) f28-0)
          (cond
            ((< 16384.0 f30-0)
             (set! (-> gp-0 polar-internal-tilt-max) (- 32768.0 f30-0))
             (if (and (< (-> gp-0 polar-external-radius) f28-0) (< 0.0 (-> gp-0 polar-external-tilt-max)))
                 (set! f30-0 (fmax f30-0 (- 32768.0 (-> gp-0 polar-external-tilt-max))))
                 )
             )
            ((< f30-0 -16384.0)
             (set! (-> gp-0 polar-internal-tilt-max) (- -32768.0 f30-0))
             (if (and (< (-> gp-0 polar-external-radius) f28-0) (< (-> gp-0 polar-external-tilt-max) 0.0))
                 (set! f30-0 (fmin f30-0 (- -32768.0 (-> gp-0 polar-external-tilt-max))))
                 )
             )
            ((< 0.0 f30-0)
             (set! (-> gp-0 polar-internal-tilt-max) f30-0)
             (if (and (< (-> gp-0 polar-external-radius) f28-0) (< 0.0 (-> gp-0 polar-external-tilt-max)))
                 (set! f30-0 (fmin f30-0 (-> gp-0 polar-external-tilt-max)))
                 )
             )
            (else
              (set! (-> gp-0 polar-internal-tilt-max) f30-0)
              (if (and (< (-> gp-0 polar-external-radius) f28-0) (< (-> gp-0 polar-external-tilt-max) 0.0))
                  (set! f30-0 (fmax f30-0 (-> gp-0 polar-external-tilt-max)))
                  )
              )
            )
          (let* ((f0-38 (sin f30-0))
                 (f26-0 (* f0-38 f0-38))
                 (f0-40 (cos f30-0))
                 (f0-42 (* f0-40 f0-40))
                 )
            32768.0
            (let ((f0-44 (cond
                           ((< 16384.0 f30-0)
                            (+ (* f26-0 (-> gp-0 twist-max x)) (* f0-42 (-> gp-0 twist-min-y)))
                            )
                           ((< f30-0 -16384.0)
                            (+ (* f26-0 (-> gp-0 twist-min-x)) (* f0-42 (-> gp-0 twist-min-y)))
                            )
                           ((< 0.0 f30-0)
                            (+ (* f26-0 (-> gp-0 twist-max x)) (* f0-42 (-> gp-0 twist-max y)))
                            )
                           (else
                             (+ (* f26-0 (-> gp-0 twist-min-x)) (* f0-42 (-> gp-0 twist-max y)))
                             )
                           )
                         )
                  )
              (if (< f0-44 f28-0)
                  (set! f28-0 f0-44)
                  )
              )
            )
          (let ((f28-1 (cos f28-0)))
            (set-vector! s2-0 (cos f30-0) (sin f30-0) 0.0 1.0)
            (let ((t9-15 vector-normalize!)
                  (a0-19 s2-0)
                  (f0-52 1.0)
                  (f1-22 f28-1)
                  )
              (t9-15 a0-19 (sqrtf (- f0-52 (* f1-22 f1-22))))
              )
            (set! (-> s2-0 z) f28-1)
            )
          )
        (matrix-transpose! s4-0 s4-0)
        (vector-matrix*! s2-0 s2-0 s4-0)
        (matrix-from-two-vectors! s4-0 s3-0 s2-0)
        )
      (let ((s2-1 (vector-normalize-copy! (new 'stack-no-clear 'vector) (-> arg0 bone transform vector 1) -1.0))
            (s3-1 (matrix->trans (-> arg0 bone transform) (new 'stack-no-clear 'vector)))
            )
        (set-vector! (-> arg0 bone transform trans) 0.0 0.0 0.0 1.0)
        (matrix*! (-> arg0 bone transform) (-> arg0 bone transform) s4-0)
        (matrix-remove-z-rot (-> arg0 bone transform) s2-1)
        (set! (-> arg0 bone transform trans quad) (-> s3-1 quad))
        )
      )
    (if (and (= (-> gp-0 process type) target) (!= (-> gp-0 blend) 0.0))
        (add-debug-text-sphere
          *display-target-marks*
          (bucket-id debug-no-zbuf1)
          (-> gp-0 target)
          (meters 0.2)
          "look"
          (new 'static 'rgba :r #xff :g #xff :a #x80)
          )
        )
    )
  (none)
  )

(defbehavior joint-mod-polar-look-at-handler process ((arg0 cspace) (arg1 transformq))
  (joint-mod-polar-look-at-guts arg0 arg1)
  0
  (none)
  )

(defbehavior joint-mod-world-look-at-handler process ((arg0 cspace) (arg1 transformq))
  (local-vars (sv-48 vector) (sv-52 vector) (sv-56 vector))
  (let ((gp-0 (the-as joint-mod (-> arg0 param1))))
    (let ((s5-0 (-> arg0 bone transform)))
      (cspace<-parented-transformq-joint! arg0 arg1)
      (set! sv-48 (vector-normalize-copy!
                    (new 'stack-no-clear 'vector)
                    (-> gp-0 process node-list data 0 bone transform vector 1)
                    1.0
                    )
            )
      (set! sv-52 (vector-normalize! (-> s5-0 vector (-> gp-0 nose)) 1.0))
      (set! sv-56 (vector-normalize! (vector-! (new 'stack-no-clear 'vector) (-> gp-0 target) (-> s5-0 trans)) 1.0))
      (let* ((f30-0 (vector-y-angle sv-52))
             (a0-7 (vector-flatten! (new-stack-vector0) sv-56 sv-48))
             (f0-0 (vector-y-angle a0-7))
             (f0-1 (deg-diff f30-0 f0-0))
             )
        (if (< (-> gp-0 ignore-angle) (fabs f0-1))
            (set! f0-1 0.0)
            )
        (let ((f0-5
                (fmax (fmin (* f0-1 (-> gp-0 blend) (-> gp-0 flex-blend)) (-> gp-0 twist-max y)) (- (-> gp-0 twist-max y)))
                )
              )
          (set! (-> gp-0 twist y) (deg-seek
                                    (-> gp-0 twist y)
                                    f0-5
                                    (* (fmax 1.0 (* (fabs (deg-diff f0-5 (-> gp-0 twist y))) (-> gp-0 twist-speed-y)))
                                       (-> self clock time-adjust-ratio)
                                       )
                                    )
                )
          )
        )
      (when (!= (-> gp-0 twist y) 0.0)
        (let ((a2-3 (matrix-rotate-y! (new 'stack-no-clear 'matrix) (-> gp-0 twist y)))
              (s4-2 (-> s5-0 trans quad))
              )
          (matrix*! s5-0 s5-0 a2-3)
          (set! (-> s5-0 trans quad) s4-2)
          )
        )
      (let* ((s4-3 (vector-normalize-copy!
                     (new 'stack-no-clear 'vector)
                     (the-as vector (-> gp-0 process node-list data 0 bone transform))
                     1.0
                     )
                   )
             (f30-2 (vector-x-angle sv-52))
             (s4-4 (vector-flatten! (new-stack-vector0) sv-56 s4-3))
             (f0-15 (vector-x-angle s4-4))
             (f0-21 (fmax
                      (fmin (* (- (deg-diff f30-2 f0-15)) (-> gp-0 blend) (-> gp-0 flex-blend)) (-> gp-0 twist-max x))
                      (- (-> gp-0 twist-max x))
                      )
                    )
             )
        (if (< (vector-dot s4-4 sv-52) 0.1)
            (set! f0-21 0.0)
            )
        (set! (-> gp-0 twist x) (deg-seek
                                  (-> gp-0 twist x)
                                  f0-21
                                  (* (fmax 1.0 (* (fabs (deg-diff f0-21 (-> gp-0 twist x))) (-> gp-0 twist-speed-x)))
                                     (-> self clock time-adjust-ratio)
                                     )
                                  )
              )
        )
      (when (!= (-> gp-0 twist x) 0.0)
        (let* ((v1-25 (-> gp-0 ear))
               (a1-17 ((cond
                         ((zero? v1-25)
                          matrix-rotate-x!
                          )
                         ((= v1-25 1)
                          matrix-rotate-y!
                          )
                         (else
                           matrix-rotate-z!
                           )
                         )
                       (new 'stack-no-clear 'matrix)
                       (-> gp-0 twist x)
                       )
                      )
               )
          (matrix*! s5-0 a1-17 s5-0)
          )
        )
      )
    (if (and (= (-> gp-0 process type) target) (!= (-> gp-0 blend) 0.0))
        (add-debug-text-sphere
          *display-target-marks*
          (bucket-id debug-no-zbuf1)
          (-> gp-0 target)
          (meters 0.2)
          "look"
          (new 'static 'rgba :r #xff :g #xff :a #x80)
          )
        )
    )
  0
  (none)
  )

(defbehavior joint-mod-rotate-handler process ((arg0 cspace) (arg1 transformq))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (the-as joint-mod (-> arg0 param1))))
      (let ((s3-0 (new 'static 'inline-array quaternion 3
                    (new 'static 'quaternion :x 1.0 :w 1.0)
                    (new 'static 'quaternion :y 1.0 :w 1.0)
                    (new 'static 'quaternion :z 1.0 :w 1.0)
                    )
                  )
            )
        (if (not (logtest? (-> s5-0 track-mode) (track-mode no-trans)))
            (vector+! (-> arg1 trans) (-> arg1 trans) (-> s5-0 trans))
            )
        (when (not (logtest? (-> s5-0 track-mode) (track-mode no-rotate)))
          (let* ((v1-9 (-> s3-0 (-> s5-0 ear)))
                 (a1-4 (quaternion-axis-angle!
                         (new 'stack-no-clear 'quaternion)
                         (-> v1-9 x)
                         (-> v1-9 y)
                         (-> v1-9 z)
                         (* (-> s5-0 twist x) (-> s5-0 blend) (-> s5-0 flex-blend))
                         )
                       )
                 )
            (quaternion-normalize! (quaternion*! (-> arg1 quat) a1-4 (-> arg1 quat)))
            )
          (let* ((v1-13 (-> s3-0 (-> s5-0 up)))
                 (a1-6 (quaternion-axis-angle!
                         (new 'stack-no-clear 'quaternion)
                         (-> v1-13 x)
                         (-> v1-13 y)
                         (-> v1-13 z)
                         (* (-> s5-0 twist y) (-> s5-0 blend) (-> s5-0 flex-blend))
                         )
                       )
                 )
            (quaternion-normalize! (quaternion*! (-> arg1 quat) a1-6 (-> arg1 quat)))
            )
          (let* ((v1-17 (-> s3-0 (-> s5-0 nose)))
                 (a1-8 (quaternion-axis-angle!
                         (new 'stack-no-clear 'quaternion)
                         (-> v1-17 x)
                         (-> v1-17 y)
                         (-> v1-17 z)
                         (* (-> s5-0 twist z) (-> s5-0 blend) (-> s5-0 flex-blend))
                         )
                       )
                 )
            (quaternion-normalize! (quaternion*! (-> arg1 quat) a1-8 (-> arg1 quat)))
            )
          )
        )
      (when (not (logtest? (-> s5-0 track-mode) (track-mode no-scale)))
        (let ((a1-9 (-> arg1 scale)))
          (let ((v1-22 (-> arg1 scale))
                (a0-11 (-> s5-0 scale))
                )
            (.lvf vf4 (&-> v1-22 quad))
            (.lvf vf5 (&-> a0-11 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.vf vf6 vf4 vf5 :mask #b111)
          (.svf (&-> a1-9 quad) vf6)
          )
        )
      (cspace<-parented-transformq-joint! arg0 arg1)
      (if (-> s5-0 parented-scale?)
          (set-vector! (-> arg0 bone scale) 1.0 1.0 1.0 1.0)
          )
      )
    0
    (none)
    )
  )

(defbehavior joint-mod-scale-handler process ((arg0 cspace) (arg1 transformq))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (the-as joint-mod (-> arg0 param1))))
      (let ((a2-0 (-> arg1 scale)))
        (let ((v1-0 (-> arg1 scale))
              (a0-1 (-> s5-0 scale))
              )
          (.lvf vf4 (&-> v1-0 quad))
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.vf vf6 vf4 vf5 :mask #b111)
        (.svf (&-> a2-0 quad) vf6)
        )
      (cspace<-parented-transformq-joint! arg0 arg1)
      (if (-> s5-0 parented-scale?)
          (set-vector! (-> arg0 bone scale) 1.0 1.0 1.0 1.0)
          )
      )
    0
    (none)
    )
  )

(defbehavior joint-mod-joint-set-handler process ((arg0 cspace) (arg1 transformq))
  (let ((s4-0 (the-as joint-mod (-> arg0 param1))))
    (if (not (logtest? (-> s4-0 track-mode) (track-mode no-trans)))
        (set! (-> arg1 trans quad) (-> s4-0 trans quad))
        )
    (if (not (logtest? (-> s4-0 track-mode) (track-mode no-rotate)))
        (quaternion-copy! (-> arg1 quat) (-> s4-0 quat))
        )
    (if (not (logtest? (-> s4-0 track-mode) (track-mode no-scale)))
        (set! (-> arg1 scale quad) (-> s4-0 scale quad))
        )
    )
  (cspace<-parented-transformq-joint! arg0 arg1)
  0
  (none)
  )

;; WARN: Function joint-mod-joint-set-world-handler has a return type of none, but the expression builder found a return statement.
(defbehavior joint-mod-joint-set-world-handler process ((arg0 cspace) (arg1 transformq))
  (cspace<-parented-transformq-joint! arg0 arg1)
  (let ((s5-0 (the-as joint-mod (-> arg0 param1)))
        (s4-0 (matrix->trans (-> arg0 bone transform) (new 'stack-no-clear 'vector)))
        )
    (let ((s3-0 (new 'stack-no-clear 'vector)))
      (if (>= 0.0 (-> s5-0 flex-blend))
          (return #f)
          )
      (cond
        ((logtest? (-> s5-0 track-mode) (track-mode no-scale))
         (set! (-> s3-0 quad) (-> arg1 scale quad))
         )
        ((>= (-> s5-0 flex-blend) 1.0)
         (set! (-> s3-0 quad) (-> s5-0 scale quad))
         )
        (else
          (vector-lerp! s3-0 (-> arg1 scale) (-> s5-0 scale) (-> s5-0 flex-blend))
          )
        )
      (cond
        ((logtest? (-> s5-0 track-mode) (track-mode no-rotate))
         )
        ((>= (-> s5-0 flex-blend) 1.0)
         (quaternion->matrix (-> arg0 bone transform) (-> s5-0 quat))
         )
        (else
          (let ((v1-15 (new 'stack-no-clear 'vector)))
            (set! (-> v1-15 quad) (-> arg1 scale quad))
            (set! (-> v1-15 x) (/ 1.0 (-> v1-15 x)))
            (set! (-> v1-15 y) (/ 1.0 (-> v1-15 y)))
            (set! (-> v1-15 z) (/ 1.0 (-> v1-15 z)))
            (vector-float*!
              (the-as vector (-> arg0 bone transform))
              (the-as vector (-> arg0 bone transform))
              (-> v1-15 x)
              )
            (vector-float*! (-> arg0 bone transform vector 1) (-> arg0 bone transform vector 1) (-> v1-15 y))
            (vector-float*! (-> arg0 bone transform vector 2) (-> arg0 bone transform vector 2) (-> v1-15 z))
            )
          (let ((a1-12 (matrix->quaternion (new 'stack-no-clear 'quaternion) (-> arg0 bone transform))))
            (quaternion->matrix
              (-> arg0 bone transform)
              (quaternion-slerp! (new 'stack-no-clear 'quaternion) a1-12 (-> s5-0 quat) (-> s5-0 flex-blend))
              )
            )
          )
        )
      (cond
        ((logtest? (-> s5-0 track-mode) (track-mode no-rotate))
         (vector-normalize! (the-as vector (-> arg0 bone transform)) (-> s3-0 x))
         (vector-normalize! (-> arg0 bone transform vector 1) (-> s3-0 y))
         (vector-normalize! (-> arg0 bone transform vector 2) (-> s3-0 z))
         )
        (else
          (vector-float*! (the-as vector (-> arg0 bone transform)) (the-as vector (-> arg0 bone transform)) (-> s3-0 x))
          (vector-float*! (-> arg0 bone transform vector 1) (-> arg0 bone transform vector 1) (-> s3-0 y))
          (vector-float*! (-> arg0 bone transform vector 2) (-> arg0 bone transform vector 2) (-> s3-0 z))
          )
        )
      )
    (set! (-> arg0 bone transform vector 0 w) 0.0)
    (set! (-> arg0 bone transform vector 1 w) 0.0)
    (set! (-> arg0 bone transform vector 2 w) 0.0)
    (cond
      ((logtest? (-> s5-0 track-mode) (track-mode no-trans))
       (set! (-> arg0 bone transform trans quad) (-> s4-0 quad))
       )
      ((>= (-> s5-0 flex-blend) 1.0)
       (set! (-> arg0 bone transform trans quad) (-> s5-0 trans quad))
       (set! (-> arg0 bone transform trans w) 1.0)
       )
      (else
        (vector-lerp! (-> arg0 bone transform trans) s4-0 (-> s5-0 trans) (-> s5-0 flex-blend))
        (set! (-> arg0 bone transform trans w) 1.0)
        )
      )
    )
  0
  (none)
  )

(defbehavior joint-mod-joint-set*-handler process ((arg0 cspace) (arg1 transformq))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (let ((s5-0 (the-as joint-mod (-> arg0 param1))))
      (if (not (logtest? (-> s5-0 track-mode) (track-mode no-trans)))
          (vector+! (-> arg1 trans) (-> arg1 trans) (-> s5-0 trans))
          )
      (if (not (logtest? (-> s5-0 track-mode) (track-mode no-rotate)))
          (quaternion-normalize! (quaternion*! (-> arg1 quat) (-> arg1 quat) (-> s5-0 quat)))
          )
      (when (not (logtest? (-> s5-0 track-mode) (track-mode no-scale)))
        (let ((a1-4 (-> arg1 scale)))
          (let ((v1-11 (-> arg1 scale))
                (a0-4 (-> s5-0 scale))
                )
            (.lvf vf4 (&-> v1-11 quad))
            (.lvf vf5 (&-> a0-4 quad))
            )
          (.add.x.vf vf6 vf0 vf0 :mask #b1000)
          (.mul.vf vf6 vf4 vf5 :mask #b111)
          (.svf (&-> a1-4 quad) vf6)
          )
        )
      (cspace<-parented-transformq-joint! arg0 arg1)
      (if (-> s5-0 parented-scale?)
          (set-vector! (-> arg0 bone scale) 1.0 1.0 1.0 1.0)
          )
      )
    0
    (none)
    )
  )

(defbehavior joint-mod-joint-set*-world-handler process ((arg0 cspace) (arg1 transformq))
  (cspace<-parented-transformq-joint! arg0 arg1)
  (let ((s5-0 (the-as joint-mod (-> arg0 param1))))
    (let ((s3-0 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> s5-0 quat)))
          (s4-0 (matrix->trans (-> arg0 bone transform) (new 'stack-no-clear 'vector)))
          )
      (vector-reset! (-> arg0 bone transform trans))
      (set! (-> arg0 bone transform trans w) 1.0)
      (vector-float*! (the-as vector (-> s3-0 vector)) (the-as vector (-> s3-0 vector)) (-> s5-0 scale x))
      (vector-float*! (-> s3-0 vector 1) (-> s3-0 vector 1) (-> s5-0 scale y))
      (vector-float*! (-> s3-0 vector 2) (-> s3-0 vector 2) (-> s5-0 scale z))
      (set! (-> s3-0 vector 0 w) 0.0)
      (set! (-> s3-0 vector 1 w) 0.0)
      (set! (-> s3-0 vector 2 w) 0.0)
      (matrix*! (-> arg0 bone transform) (-> arg0 bone transform) s3-0)
      (vector+! (-> arg0 bone transform trans) s4-0 (-> s5-0 trans))
      )
    (if (-> s5-0 parented-scale?)
        (set-vector! (-> arg0 bone scale) 1.0 1.0 1.0 1.0)
        )
    )
  0
  (none)
  )
