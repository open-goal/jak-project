;;-*-Lisp-*-
(in-package goal)

;; name: aligner.gc
;; name in dgo: aligner
;; dgos: ENGINE, GAME

;; og:manually-modified:defmethod compute-alignment! align-control

;; DECOMP BEGINS

(defmethod compute-alignment! align-control ((obj align-control))
  (local-vars (a0-10 symbol) (s7-0 none) (ra-0 int))
  (rlet ((vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         )
    (init-vf0-vector)
    (update-anim-data (-> obj process skel))
    (let ((s5-0 (-> obj process skel active-channels)))
      (dotimes (s4-0 (the-as int s5-0))
        (let* ((a0-4 (-> obj process skel channel s4-0))
               (v1-7 (-> a0-4 frame-group))
               )
          (case (-> a0-4 command)
            (((joint-control-command stack) (joint-control-command stack1))
             )
            (else
              (when (!= (-> v1-7 type) art-joint-anim)
                (go process-drawable-art-error "align joint-anim")
                (abandon-thread)
                0
                )
              )
            )
          )
        )
      )
    (let* ((a0-9 (-> obj process skel root-channel 0))
           (v1-18 (-> a0-9 frame-group))
           (f0-0 (-> a0-9 frame-num))
           )
      (= (-> a0-9 num-func) num-func-loop!)
      (cond
        ((or (not v1-18) (!= (-> obj frame-group) v1-18))
         (set! a0-10 #t)
         )
        ((= (-> a0-9 num-func) num-func-loop!)
         (set! a0-10 (< (* (-> a0-9 param 0) (- f0-0 (-> obj frame-num))) 0.0))
         )
        (else
          (set! a0-10 (= f0-0 0.0))
          )
        )
      (if a0-10
          (logior! (-> obj flags) (align-flags disabled))
          (logclear! (-> obj flags) (align-flags disabled))
          )
      (set! (-> obj frame-group) v1-18)
      (set! (-> obj frame-num) f0-0)
      )
    (mem-copy! (the-as pointer (-> obj transform 1)) (the-as pointer (-> obj transform)) 48)
    (quaternion-copy! (the-as quaternion (-> obj transform 1 rot)) (-> obj align quat))
    (set! (-> obj transform 1 scale quad) (-> obj align scale quad))
    (let* ((a2-5 (-> obj matrix 1))
           (a3-0 (-> obj matrix))
           (v1-21 (-> a3-0 0 quad 0))
           (a0-19 (-> a3-0 0 quad 1))
           (a1-13 (-> a3-0 0 quad 2))
           (a3-1 (-> a3-0 0 trans quad))
           )
      (set! (-> a2-5 quad 0) v1-21)
      (set! (-> a2-5 quad 1) a0-19)
      (set! (-> a2-5 quad 2) a1-13)
      (set! (-> a2-5 trans quad) a3-1)
      )
    (let ((s5-1 (-> obj process node-list data 1)))
      (cspace<-matrix-no-push-joint! s5-1 (-> obj process skel))
      (let* ((v1-25 (-> obj matrix))
             (a3-2 (-> s5-1 bone transform))
             (a0-22 (-> a3-2 quad 0))
             (a1-15 (-> a3-2 quad 1))
             (a2-6 (-> a3-2 quad 2))
             (a3-3 (-> a3-2 trans quad))
             )
        (set! (-> v1-25 0 quad 0) a0-22)
        (set! (-> v1-25 0 quad 1) a1-15)
        (set! (-> v1-25 0 quad 2) a2-6)
        (set! (-> v1-25 0 trans quad) a3-3)
        )
      (let ((v1-26 (-> obj transform)))
        (let ((a0-24 (-> s5-1 bone transform trans))
              (a1-18 (-> obj process root scale))
              )
          (.lvf vf4 (&-> a0-24 quad))
          (.lvf vf5 (&-> a1-18 quad))
          )
        (.add.x.vf vf6 vf0 vf0 :mask #b1000)
        (.mul.vf vf6 vf4 vf5 :mask #b111)
        (.svf (&-> v1-26 0 trans quad) vf6)
        )
      )
    (vector-!
      (the-as vector (-> obj delta))
      (the-as vector (-> obj transform))
      (the-as vector (-> obj transform 1))
      )
    (set-vector!
      (-> obj align scale)
      (vector-length (the-as vector (-> obj matrix)))
      (vector-length (-> obj matrix 0 vector 1))
      (vector-length (-> obj matrix 0 vector 2))
      1.0
      )
    (vector-! (-> obj delta scale) (-> obj align scale) (-> obj transform 1 scale))
    (let ((a2-7 (matrix-inv-scale! (new 'stack-no-clear 'matrix) (-> obj align scale))))
      (quaternion-normalize!
        (matrix->quaternion (-> obj align quat) (matrix*! a2-7 (the-as matrix (-> obj matrix)) a2-7))
        )
      )
    (let ((a1-27 (quaternion-inverse! (new 'stack-no-clear 'quaternion) (the-as quaternion (-> obj transform 1 rot)))))
      (quaternion-normalize! (quaternion*! (-> obj delta quat) a1-27 (-> obj align quat)))
      )
    (-> obj delta)
    )
  )

;; WARN: Return type mismatch (inline-array transform) vs transform.
(defmethod first-transform align-control ((obj align-control))
  "@returns The first of the two [[transforms]] held by the object"
  (the-as transform (-> obj transform))
  )

(defmethod second-transform align-control ((obj align-control))
  "@returns The second of the two [[transforms]] held by the object"
  (-> obj transform 1)
  )

(defmethod align! align-control ((obj align-control) (options align-opts) (x float) (y float) (z float))
  "As long as [[align-flags::0]] is not set call [[process-drawable::16]] on the process being controlled
using the arguments passed to construct a [[vector]] - <`x`, `y`, `z`, 1.0>

@returns the `root` of the [[process-drawable]] after the method returns
@see [[process-drawable::16]]"
  (when (not (logtest? (-> obj flags) (align-flags disabled)))
    (let* ((process (-> obj process))
           (method-call (method-of-object process apply-alignment))
           (transform (-> obj delta))
           (data (new 'stack-no-clear 'vector))
           )
      (set! (-> data x) x)
      (set! (-> data y) y)
      (set! (-> data z) z)
      (set! (-> data w) 1.0)
      (method-call process options transform data)
      )
    )
  (-> obj process root)
  )

(defmethod set-and-limit-velocity trsqv ((obj trsqv) (unkBitfield int) (limit vector) (arg2 float))
  "TODO - arg1 is an bitfield of some sort"
  (let ((transv (-> obj transv)))
    (when (logtest? unkBitfield 4)
      (set! (-> transv x) (-> limit x))
      (set! (-> transv z) (-> limit z))
      (let* ((v1-2 limit)
             (f0-8
               (fmin
                 (* (sqrtf (+ (* (-> v1-2 x) (-> v1-2 x)) (* (-> v1-2 z) (-> v1-2 z)))) (-> self clock frames-per-second))
                 arg2
                 )
               )
             )
        (vector-xz-normalize! transv f0-8)
        )
      )
    )
  obj
  )

(defmethod align-vel-and-quat-only! align-control ((obj align-control) (arg0 align-opts) (arg1 vector) (arg2 int) (arg3 float) (arg4 float))
  (when (not (logtest? (-> obj flags) (align-flags disabled)))
    (let ((s5-0 (-> obj delta)))
      (let ((a0-1 (-> obj process root transv)))
        (if (logtest? arg0 (align-opts adjust-y-vel))
            (set! (-> a0-1 y) (* (-> s5-0 trans y) arg3 (-> self clock frames-per-second)))
            )
        (when (logtest? arg0 (align-opts adjust-xz-vel))
          (set! (-> a0-1 x) (-> arg1 x))
          (set! (-> a0-1 z) (-> arg1 z))
          (let* ((v1-11 arg1)
                 (f0-9 (sqrtf (+ (* (-> v1-11 x) (-> v1-11 x)) (* (-> v1-11 z) (-> v1-11 z)))))
                 (v1-13 (-> s5-0 trans))
                 (f0-11 (* (fmin f0-9 (* (sqrtf (+ (* (-> v1-13 x) (-> v1-13 x)) (* (-> v1-13 z) (-> v1-13 z)))) arg4))
                           (-> self clock frames-per-second)
                           )
                        )
                 (t9-0 vector-xz-normalize!)
                 )
            (set! (-> obj last-speed) f0-11)
            (t9-0 a0-1 f0-11)
            )
          )
        )
      (if (logtest? arg0 (align-opts adjust-quat))
          (quaternion-normalize! (quaternion*! (-> obj process root quat) (-> obj process root quat) (-> s5-0 quat)))
          )
      )
    )
  (-> obj process root)
  )
