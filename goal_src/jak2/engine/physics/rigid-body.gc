;;-*-Lisp-*-
(in-package goal)

;; name: rigid-body.gc
;; name in dgo: rigid-body
;; dgos: GAME, COMMON

(deftype rb-work (structure)
  ((cquery collide-query :inline)
   (mat-1 matrix :inline :offset 544)
   (vec-2 vector :inline :offset 608)
   (vec-5 vector :inline :offset 624)
   (vec-3 vector :inline :offset 640)
   (float-4 float :offset 656)
   (pat-id pat-surface :offset 660)
   (rbody rigid-body :offset 664)
   (prim-id int32 :offset 668)
   (vec-1 vector :inline :offset 672)
   (quat-1 quaternion :inline)
   (vec-8 vector :inline :offset 704)
   (vec-4 vector :inline :offset 720)
   (vec-6 vector :inline)
   (vec-7 vector :inline)
   (vec-9 vector :inline)
   (float-2 float :offset 784)
   (float-3 float)
   (dt float :offset 792)
   (float-1 float)
   (cnt int8 :offset 800)
   )
  )

;; DECOMP BEGINS

(deftype rigid-body-work (structure)
  ((max-ang-momentum float  :offset-assert   0)
   (max-ang-velocity float  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(define *rigid-body-work* (new 'static 'rigid-body-work))

(defmethod new rigid-body-control ((allocation symbol) (type-to-make type) (arg0 process))
  (let ((v0-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> v0-0 process) arg0)
    v0-0
    )
  )

(defmethod relocate rigid-body-control ((obj rigid-body-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod rigid-body-info-method-9 rigid-body-info ((obj rigid-body-info))
  (let ((f24-0 (-> obj mass))
        (f28-0 (-> obj inertial-tensor-box 0))
        (f30-0 (-> obj inertial-tensor-box 1))
        (f26-0 (-> obj inertial-tensor-box 2))
        )
    (let ((f0-0 f24-0))
      (set! (-> obj inv-mass) (/ 1.0 f0-0))
      )
    (matrix-identity! (-> obj inertial-tensor))
    (matrix-identity! (-> obj inv-inertial-tensor))
    (let ((f0-4 (* 0.083333336 f24-0)))
      (let* ((f1-1 f30-0)
             (f1-3 (* f1-1 f1-1))
             (f2-0 f26-0)
             )
        (set! (-> obj inertial-tensor vector 0 x) (* f0-4 (+ f1-3 (* f2-0 f2-0))))
        )
      (let ((f1-6 f28-0))
        (set! (-> obj inertial-tensor vector 1 y) (* f0-4 (+ (* f1-6 f1-6) (* f26-0 f26-0))))
        )
      (set! (-> obj inertial-tensor vector 2 z) (* f0-4 (+ (* f28-0 f28-0) (* f30-0 f30-0))))
      )
    )
  (let ((f0-6 (-> obj inertial-tensor vector 0 x)))
    (set! (-> obj inv-inertial-tensor vector 0 x) (/ 1.0 f0-6))
    )
  (let ((f0-9 (-> obj inertial-tensor vector 1 y)))
    (set! (-> obj inv-inertial-tensor vector 1 y) (/ 1.0 f0-9))
    )
  (let ((f0-12 (-> obj inertial-tensor vector 2 z)))
    (set! (-> obj inv-inertial-tensor vector 2 z) (/ 1.0 f0-12))
    )
  0
  (none)
  )

(defmethod clear-force-torque! rigid-body ((obj rigid-body))
  (set! (-> obj force quad) (the-as uint128 0))
  (set! (-> obj torque quad) (the-as uint128 0))
  0
  (none)
  )

(defmethod clear-momentum! rigid-body ((obj rigid-body))
  (set! (-> obj lin-momentum quad) (the-as uint128 0))
  (set! (-> obj ang-momentum quad) (the-as uint128 0))
  0
  (none)
  )

(defmethod rigid-body-method-24 rigid-body ((obj rigid-body))
  (when #t
    (quaternion->matrix (-> obj matrix) (-> obj rotation))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (vector-rotate*! s5-0 (-> obj info cm-offset-joint) (-> obj matrix))
      (vector-! (-> obj matrix trans) (-> obj position) s5-0)
      )
    )
  0
  (none)
  )

(defmethod rigid-body-method-26 rigid-body ((obj rigid-body) (arg0 vector) (arg1 quaternion))
  (let ((s3-0 (new 'stack-no-clear 'inline-array 'vector 8)))
    (quaternion->matrix (the-as matrix (-> s3-0 1)) arg1)
    (vector-rotate*! (-> s3-0 0) (-> obj info cm-offset-joint) (the-as matrix (-> s3-0 1)))
    (vector+! (-> obj position) arg0 (-> s3-0 0))
    )
  (quaternion-copy! (-> obj rotation) arg1)
  (quaternion-normalize! (-> obj rotation))
  (rigid-body-method-24 obj)
  0
  (none)
  )

(defmethod rigid-body-method-25 rigid-body ((obj rigid-body) (arg0 rigid-body-info) (arg1 vector) (arg2 quaternion) (arg3 function))
  (set! (-> obj work) *rigid-body-work*)
  (set! (-> obj info) arg0)
  (set! (-> obj force-callback) (the-as (function object float none) arg3))
  (rigid-body-info-method-9 (-> obj info))
  (let ((v1-3 obj))
    (set! (-> v1-3 force quad) (the-as uint128 0))
    (set! (-> v1-3 torque quad) (the-as uint128 0))
    )
  0
  (clear-momentum! obj)
  (rigid-body-method-26 obj arg1 arg2)
  (rigid-body-method-13 obj)
  0
  (none)
  )

(defmethod rigid-body-method-22 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj position))))
    (vector-cross! arg1 (-> obj ang-velocity) v1-1)
    )
  (vector+! arg1 arg1 (-> obj lin-velocity))
  arg1
  )

(defun matrix-3x3-triple-transpose-product ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (let ((s5-0 (new 'stack-no-clear 'inline-array 'matrix 3)))
    (let* ((v1-0 (-> s5-0 0))
           (a3-0 arg1)
           (a0-1 (-> a3-0 quad 0))
           (a1-1 (-> a3-0 quad 1))
           (a2-1 (-> a3-0 quad 2))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-0 quad 0) a0-1)
      (set! (-> v1-0 quad 1) a1-1)
      (set! (-> v1-0 quad 2) a2-1)
      (set! (-> v1-0 trans quad) a3-1)
      )
    (vector-reset! (-> s5-0 0 trans))
    (matrix-transpose! (-> s5-0 1) (-> s5-0 0))
    (matrix*! (-> s5-0 2) arg2 (-> s5-0 0))
    (matrix*! arg0 (-> s5-0 1) (-> s5-0 2))
    )
  arg0
  )

(defmethod rigid-body-method-12 rigid-body ((obj rigid-body) (arg0 float))
  (local-vars (v1-6 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a2-0 (-> obj lin-momentum)))
      (let ((v1-0 (-> obj lin-momentum)))
        (let ((a0-1 (-> obj force)))
          (let ((a3-0 arg0))
            (.mov vf7 a3-0)
            )
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.lvf vf4 (&-> v1-0 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a2-0 quad) vf6)
      )
    (let ((a2-1 (-> obj ang-momentum)))
      (let ((v1-1 (-> obj ang-momentum)))
        (let ((a0-2 (-> obj torque)))
          (let ((a1-1 arg0))
            (.mov vf7 a1-1)
            )
          (.lvf vf5 (&-> a0-2 quad))
          )
        (.lvf vf4 (&-> v1-1 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a2-1 quad) vf6)
      )
    (let* ((f0-3 (* 500000000.0 (-> obj info mass)))
           (f1-1 f0-3)
           (f1-3 (* f1-1 f1-1))
           )
      (.lvf vf1 (&-> (-> obj ang-momentum) quad))
      (.add.w.vf vf2 vf0 vf0 :mask #b1)
      (.mul.vf vf1 vf1 vf1)
      (.mul.x.vf acc vf2 vf1 :mask #b1)
      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
      (.mov v1-6 vf1)
      (if (< f1-3 v1-6)
          (vector-normalize! (-> obj ang-momentum) f0-3)
          )
      )
    (set! (-> obj force quad) (the-as uint128 0))
    (set! (-> obj torque quad) (the-as uint128 0))
    0
    0
    (none)
    )
  )

(defmethod rigid-body-method-13 rigid-body ((obj rigid-body))
  (let ((v1-0 (-> obj info)))
    (vector-float*! (-> obj lin-velocity) (-> obj lin-momentum) (-> v1-0 inv-mass))
    (matrix-3x3-triple-transpose-product (-> obj inv-i-world) (-> obj matrix) (-> v1-0 inv-inertial-tensor))
    )
  (vector-rotate*! (-> obj ang-velocity) (-> obj ang-momentum) (-> obj inv-i-world))
  0
  (none)
  )

(defmethod rigid-body-method-14 rigid-body ((obj rigid-body) (arg0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (-> obj position)))
      (let ((v1-0 (-> obj position)))
        (let ((a0-1 (-> obj lin-velocity)))
          (let ((a2-0 arg0))
            (.mov vf7 a2-0)
            )
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.lvf vf4 (&-> v1-0 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a1-1 quad) vf6)
      )
    (let ((s4-0 (new 'stack-no-clear 'quaternion)))
      (set! (-> (the-as vector (&-> s4-0 x)) quad) (-> obj ang-velocity quad))
      (set! (-> s4-0 w) 0.0)
      (quaternion*! s4-0 s4-0 (-> obj rotation))
      (quaternion-float*! s4-0 s4-0 0.5)
      (+! (-> obj rotation x) (* (-> s4-0 x) arg0))
      (+! (-> obj rotation y) (* (-> s4-0 y) arg0))
      (+! (-> obj rotation z) (* (-> s4-0 z) arg0))
      (+! (-> obj rotation w) (* (-> s4-0 w) arg0))
      )
    (quaternion-normalize! (-> obj rotation))
    (rigid-body-method-24 obj)
    0
    (none)
    )
  )

(defun damping-time-adjust ((arg0 float) (arg1 float))
  (let ((f0-0 0.0)
        (f1-0 1.0)
        (f2-2 (* (+ -1.0 arg0) arg1))
        (f3-2 0.016666668)
        )
    (fmax f0-0 (+ f1-0 (* f2-2 (/ 1.0 f3-2))))
    )
  )

(defmethod rigid-body-method-9 rigid-body ((obj rigid-body) (arg0 collide-shape-moving) (arg1 float))
  (rigid-body-method-12 obj arg1)
  (let ((v1-2 (-> obj info)))
    (let* ((a0-2 (-> obj lin-momentum))
           (a1-2 (-> obj lin-momentum))
           (f3-0 (-> v1-2 linear-damping))
           (f2-0 arg1)
           (f0-0 0.0)
           (f1-0 1.0)
           (f2-1 (* (+ -1.0 f3-0) f2-0))
           (f3-2 0.016666668)
           )
      (vector-float*! a0-2 a1-2 (fmax f0-0 (+ f1-0 (* f2-1 (/ 1.0 f3-2)))))
      )
    (let* ((a0-4 (-> obj ang-momentum))
           (a1-3 (-> obj ang-momentum))
           (f3-5 (-> v1-2 angular-damping))
           (f2-3 arg1)
           (f0-3 0.0)
           (f1-2 1.0)
           (f2-4 (* (+ -1.0 f3-5) f2-3))
           (f3-7 0.016666668)
           )
      (vector-float*! a0-4 a1-3 (fmax f0-3 (+ f1-2 (* f2-4 (/ 1.0 f3-7)))))
      )
    )
  (rigid-body-method-13 obj)
  (if (logtest? (-> obj flags) (rigid-body-flag enable-collision))
      (collide-shape-moving-method-63 arg0 obj arg1)
      (rigid-body-method-14 obj arg1)
      )
  0
  (none)
  )

(defmethod collide-with-all-collide-cache-prims collide-shape-moving ((obj collide-shape-moving) (arg0 matrix) (arg1 collide-query))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         (vf8 :class vf)
         )
    (init-vf0-vector)
    (let ((s4-0 *collide-cache*)
          (s3-0 (-> obj root-prim))
          (s2-0 1)
          )
      (b! (nonzero? (-> s3-0 prim-core prim-type)) cfg-2 :delay (empty-form))
      (let ((v1-2 s3-0))
        (set! s3-0 (-> (the-as collide-shape-prim-group v1-2) child 0))
        (set! s2-0 (the-as int (-> v1-2 specific 0)))
        )
      (label cfg-2)
      (b! #t cfg-13 :delay (nop!))
      (label cfg-3)
      (+! s2-0 -1)
      (let ((v1-4 -1))
        (b! (!= (-> s3-0 prim-core prim-type) v1-4) cfg-12 :delay (nop!))
        )
      (.lvf vf5 (&-> s3-0 local-sphere quad))
      (.lvf vf1 (&-> arg0 quad 0))
      (.lvf vf2 (&-> arg0 quad 1))
      (.lvf vf3 (&-> arg0 quad 2))
      (.lvf vf4 (&-> arg0 trans quad))
      (.lvf vf6 (&-> s3-0 prim-core world-sphere quad))
      (.mul.x.vf acc vf1 vf5)
      (.add.mul.y.vf acc vf2 vf5 acc)
      (.add.mul.z.vf acc vf3 vf5 acc)
      (.add.mul.w.vf vf7 vf4 vf0 acc :mask #b111)
      (.sub.vf vf8 vf7 vf6 :mask #b111)
      (.svf (&-> arg1 move-dist quad) vf8)
      (let ((s1-0 (the-as collide-cache-prim (-> s4-0 prims))))
        (countdown (s0-0 (-> s4-0 num-prims))
          (when (logtest? (-> s3-0 prim-core collide-with) (-> s1-0 prim-core collide-as))
            (if (>= (the-as int (-> s1-0 prim-core prim-type)) 0)
                (collide-with-collide-cache-prim-mesh s3-0 arg1 s1-0)
                (collide-with-collide-cache-prim-sphere s3-0 arg1 s1-0)
                )
            )
          (&+! s1-0 48)
          )
        )
      (label cfg-12)
      (&+! s3-0 80)
      (label cfg-13)
      (b! (nonzero? s2-0) cfg-3 :delay (nop!))
      )
    0
    (none)
    )
  )

(defun transform-rigid-body-prims ((arg0 collide-shape-prim) (arg1 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 arg0)
          (a0-1 1)
          )
      (when (= (-> v1-0 prim-core prim-type) (prim-type group))
        (let ((a0-2 (the-as collide-shape-prim-group v1-0)))
          (set! v1-0 (-> a0-2 child 0))
          (set! a0-1 (the-as int (-> a0-2 num-children)))
          )
        )
      (while (nonzero? a0-1)
        (+! a0-1 -1)
        (.lvf vf5 (&-> v1-0 local-sphere quad))
        (.lvf vf1 (&-> arg1 quad 0))
        (.lvf vf2 (&-> arg1 quad 1))
        (.lvf vf3 (&-> arg1 quad 2))
        (.lvf vf4 (&-> arg1 trans quad))
        (.mul.x.vf acc vf1 vf5)
        (.add.mul.y.vf acc vf2 vf5 acc)
        (.add.mul.z.vf acc vf3 vf5 acc)
        (.add.mul.w.vf vf5 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-0 prim-core world-sphere quad) vf5)
        (&+! v1-0 80)
        )
      )
    #f
    )
  )

(defmethod collide-shape-moving-method-63 collide-shape-moving ((obj collide-shape-moving) (arg0 rigid-body) (arg1 float))
  (local-vars (s3-0 rigid-body))
  (with-pp
    (rlet ((acc :class vf)
           (Q :class vf)
           (vf0 :class vf)
           (vf6 :class vf)
           (vf7 :class vf)
           (vf8 :class vf)
           (vf9 :class vf)
           )
      (init-vf0-vector)
      (let ((s5-0 (new 'stack-no-clear 'rb-work)))
        (set! (-> s5-0 dt) arg1)
        (set! (-> s5-0 float-1) 1.0)
        (set! (-> s5-0 cnt) 0)
        (until (not (and (< 0.05 (-> s5-0 float-1)) (< (-> s5-0 cnt) (the-as int (-> obj max-iteration-count)))))
          (set! (-> s5-0 cquery best-dist) -100000000.0)
          (set! (-> s5-0 cquery best-my-prim) #f)
          (set! (-> s5-0 cquery num-spheres) (the-as uint #f))
          (set! (-> s5-0 vec-1 quad) (-> arg0 position quad))
          (quaternion-copy! (-> s5-0 quat-1) (-> arg0 rotation))
          (rigid-body-method-14 arg0 (* (-> s5-0 float-1) (-> s5-0 dt)))
          (mem-copy! (the-as pointer (-> s5-0 mat-1)) (the-as pointer (-> arg0 matrix)) 64)
          (set! (-> arg0 position quad) (-> s5-0 vec-1 quad))
          (quaternion-copy! (-> arg0 rotation) (-> s5-0 quat-1))
          (rigid-body-method-24 arg0)
          (transform-rigid-body-prims (-> obj root-prim) (-> arg0 matrix))
          (collide-with-all-collide-cache-prims obj (-> s5-0 mat-1) (-> s5-0 cquery))
          (let ((f30-0 (-> s5-0 cquery best-dist)))
            (b! (>= f30-0 0.0) cfg-3 :delay #f)
            (rigid-body-method-14 arg0 (* (-> s5-0 float-1) (-> s5-0 dt)))
            (rigid-body-method-13 arg0)
            (transform-rigid-body-prims (-> obj root-prim) (-> arg0 matrix))
            (set! (-> s5-0 float-1) 0.0)
            (b! #t cfg-44 :delay (nop!))
            (label cfg-3)
            (update-from-step-size *touching-list* f30-0)
            (rigid-body-method-14 arg0 (* (-> s5-0 float-1) (-> s5-0 dt) f30-0))
            )
          (rigid-body-method-13 arg0)
          (transform-rigid-body-prims (-> obj root-prim) (-> arg0 matrix))
          (mem-copy! (the-as pointer (-> s5-0 mat-1)) (the-as pointer (-> arg0 matrix)) 64)
          (set! s3-0 (the-as rigid-body #f))
          (b! (not (-> s5-0 cquery num-spheres)) cfg-12 :delay (empty-form))
          (let ((a0-20 (-> (the-as collide-shape-prim (-> s5-0 cquery num-spheres)) cshape process)))
            (b! (zero? (-> a0-20 rbody)) cfg-12 :delay (empty-form))
            (set! s3-0 (-> a0-20 rbody state))
            (b! (not (logtest? (-> s3-0 flags) (rigid-body-flag active))) cfg-11 :delay (nop!))
            (b! (logtest? (-> s3-0 flags) (rigid-body-flag enable-physics)) cfg-10 :delay (empty-form))
            (send-event a0-20 'enable-physics)
            )
          (label cfg-10)
          (b! #t cfg-12 :delay (nop!))
          (label cfg-11)
          (set! s3-0 (the-as rigid-body #f))
          (label cfg-12)
          (let ((v1-37 (-> s5-0 cquery best-my-prim)))
            (.lvf vf7 (&-> (-> s5-0 cquery) best-other-tri intersect quad))
            (.lvf vf6 (&-> v1-37 prim-core world-sphere quad))
            (.sub.vf vf8 vf6 vf7)
            (.mul.vf vf9 vf8 vf8 :mask #b111)
            (.mul.x.vf acc vf0 vf9 :mask #b1000)
            (.add.mul.y.vf acc vf0 vf9 acc :mask #b1000)
            (.add.mul.z.vf vf9 vf0 vf9 acc :mask #b1000)
            (.isqrt.vf Q vf0 vf9 :fsf #b11 :ftf #b11)
            (.mov.vf vf8 vf0 :mask #b1000)
            (.wait.vf)
            (.mul.vf vf8 vf8 Q :mask #b111)
            (.nop.vf)
            (.nop.vf)
            (.nop.vf)
            (.svf (&-> s5-0 vec-5 quad) vf8)
            (.svf (&-> s5-0 vec-2 quad) vf7)
            (set! (-> s5-0 prim-id) (the-as int (-> v1-37 prim-id)))
            )
          (rigid-body-method-22 arg0 (-> s5-0 vec-2) (-> s5-0 vec-3))
          (b! (not s3-0) cfg-14 :delay (empty-form))
          (rigid-body-method-13 s3-0)
          (rigid-body-method-22 s3-0 (-> s5-0 vec-2) (-> s5-0 vec-4))
          (vector-! (-> s5-0 vec-3) (-> s5-0 vec-3) (-> s5-0 vec-4))
          (label cfg-14)
          (set! (-> s5-0 float-4) 0.0)
          (set! (-> s5-0 float-2) (+ -409.6 (vector-dot (-> s5-0 vec-3) (-> s5-0 vec-5))))
          (set! (-> s5-0 float-3) 0.0)
          (b! (>= (-> s5-0 float-2) 0.0) cfg-39)
          (vector-! (-> s5-0 vec-6) (-> s5-0 vec-2) (-> arg0 position))
          (vector-cross! (-> s5-0 vec-7) (-> s5-0 vec-6) (-> s5-0 vec-5))
          (vector-rotate*! (-> s5-0 vec-7) (-> s5-0 vec-7) (-> arg0 inv-i-world))
          (vector-cross! (-> s5-0 vec-7) (-> s5-0 vec-7) (-> s5-0 vec-6))
          (set! (-> s5-0 float-3) (+ (-> arg0 info inv-mass) (vector-dot (-> s5-0 vec-5) (-> s5-0 vec-7))))
          (let ((f30-1 (-> arg0 info bounce-factor)))
            (cond
              (s3-0
                (vector-! (-> s5-0 vec-6) (-> s5-0 vec-2) (-> s3-0 position))
                (vector-cross! (-> s5-0 vec-7) (-> s5-0 vec-6) (-> s5-0 vec-5))
                (vector-rotate*! (-> s5-0 vec-7) (-> s5-0 vec-7) (-> s3-0 inv-i-world))
                (vector-cross! (-> s5-0 vec-7) (-> s5-0 vec-7) (-> s5-0 vec-6))
                (+! (-> s5-0 float-3) (+ (-> s3-0 info inv-mass) (vector-dot (-> s5-0 vec-5) (-> s5-0 vec-7))))
                (set! f30-1 (fmax
                              (fmax f30-1 (-> s3-0 info bounce-factor))
                              (* (-> arg0 info bounce-mult-factor) (-> s3-0 info bounce-mult-factor))
                              )
                      )
                )
              (else
                )
              )
            (set! (-> s5-0 float-4) (* (+ 1.0 f30-1) (/ (- (-> s5-0 float-2)) (-> s5-0 float-3))))
            )
          (vector-float*! (-> s5-0 vec-8) (-> s5-0 vec-5) (-> s5-0 float-4))
          (let ((f30-2 (-> arg0 info mass)))
            (if s3-0
                (set! f30-2 (fmin f30-2 (-> s3-0 info mass)))
                )
            (vector+float*! (-> s5-0 vec-9) (-> s5-0 vec-3) (-> s5-0 vec-5) (- (-> s5-0 float-2)))
            (vector-normalize! (-> s5-0 vec-9) 1.0)
            (let ((f0-31 (* -1.0 (fmin
                                   (* (vector-dot (-> s5-0 vec-9) (-> s5-0 vec-3)) f30-2)
                                   (* (-> arg0 info friction-factor) (-> s5-0 float-4))
                                   )
                            )
                         )
                  )
              (vector+float*! (-> s5-0 vec-8) (-> s5-0 vec-8) (-> s5-0 vec-9) f0-31)
              )
            )
          (rigid-body-method-18 arg0 (-> s5-0 vec-2) (-> s5-0 vec-8))
          (when s3-0
            (vector-float*! (-> s5-0 vec-8) (-> s5-0 vec-8) -1.0)
            (rigid-body-method-18 s3-0 (-> s5-0 vec-2) (-> s5-0 vec-8))
            )
          (rigid-body-method-12 arg0 1.0)
          (rigid-body-method-13 arg0)
          (let ((f30-3 (-> s5-0 cquery best-dist)))
            (when (< f30-3 0.0001)
              (vector+float*! (-> arg0 position) (-> arg0 position) (-> s5-0 vec-5) 40.96)
              (rigid-body-method-24 arg0)
              )
            (set! (-> s5-0 float-1) (- (-> s5-0 float-1) (* f30-3 (-> s5-0 float-1))))
            )
          (set! (-> s5-0 pat-id) (-> s5-0 cquery best-other-tri pat))
          (let ((v1-103 pp))
            (let ((a0-49 (the-as object (-> s5-0 cquery num-spheres))))
              (if (the-as uint a0-49)
                  (set! v1-103 (-> (the-as collide-shape-prim-mesh a0-49) cshape process))
                  )
              )
            (set! (-> s5-0 rbody) s3-0)
            (send-event (-> obj process) 'impact-impulse :from v1-103 (-> s5-0 vec-2))
            )
          (b! (not s3-0) cfg-32 :delay (empty-form))
          (rigid-body-method-12 s3-0 1.0)
          (rigid-body-method-13 s3-0)
          (let ((s2-0 (-> (the-as collide-shape-prim-mesh (-> s5-0 cquery num-spheres)) cshape)))
            (transform-rigid-body-prims (-> s2-0 root-prim) (-> s3-0 matrix))
            (vector-float*! (-> s5-0 vec-5) (-> s5-0 vec-5) -1.0)
            (vector-float*! (-> s5-0 vec-3) (-> s5-0 vec-3) -1.0)
            (set! (-> s5-0 rbody) arg0)
            (send-event (-> s2-0 process) 'impact-impulse :from (-> obj process) (-> s5-0 vec-2))
            )
          (label cfg-32)
          (+! (-> s5-0 cnt) 1)
          )
        (b! #t cfg-42 :delay (nop!))
        (label cfg-39)
        (b! (not s3-0) cfg-41 :delay (empty-form))
        (set! (-> arg0 blocked-by) (-> (the-as collide-shape-prim-mesh (-> s5-0 cquery num-spheres)) cshape process))
        0
        (label cfg-41)
        (vector+float*! (-> arg0 position) (-> arg0 position) (-> s5-0 vec-5) 40.96)
        (rigid-body-method-24 arg0)
        0
        (label cfg-42)
        (when (< 0.0 (-> s5-0 float-1))
          (rigid-body-method-14 arg0 (* (-> s5-0 float-1) (-> s5-0 dt)))
          (rigid-body-method-13 arg0)
          (transform-rigid-body-prims (-> obj root-prim) (-> arg0 matrix))
          (set! (-> s5-0 float-1) 0.0)
          )
        (label cfg-44)
        (let ((f0-47 (* (- 1.0 (-> s5-0 float-1)) (-> s5-0 dt))))
          (set! (-> arg0 time-remaining) (- (-> arg0 time-remaining) f0-47))
          )
        )
      0
      (none)
      )
    )
  )

(defmethod rigid-body-method-15 rigid-body ((obj rigid-body) (arg0 collide-shape-moving) (arg1 float))
  (local-vars
    (sv-576 vector)
    (sv-624 vector)
    (sv-628 vector)
    (sv-632 float)
    (sv-704 vector)
    (sv-708 vector)
    (sv-712 vector)
    (sv-716 vector)
    )
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (-> obj work)
    (let ((s4-0 (-> obj info))
          (s3-0 (new 'stack-no-clear 'collide-query))
          (f30-0 1.0)
          (s2-0 0)
          )
      (set! (-> s3-0 start-pos quad) (-> obj position quad))
      (let ((v1-3 s3-0))
        (set! (-> v1-3 radius) (-> arg0 root-prim prim-core world-sphere w))
        (set! (-> v1-3 collide-with) (-> arg0 root-prim prim-core collide-with))
        (set! (-> v1-3 ignore-process0) #f)
        (set! (-> v1-3 ignore-process1) #f)
        (set! (-> v1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
        (set! (-> v1-3 action-mask) (collide-action solid))
        )
      (until (>= s2-0 4)
        (vector-float*! (-> s3-0 move-dist) (-> obj lin-velocity) (* f30-0 arg1))
        (let ((f28-0 (probe-using-line-sphere *collide-cache* s3-0)))
          (b! (>= f28-0 0.0) cfg-3)
          (rigid-body-method-14 obj (* f30-0 arg1))
          (b! #t cfg-9 :delay (nop!))
          (label cfg-3)
          (rigid-body-method-14 obj (* f30-0 arg1 f28-0))
          (set! sv-576 (new 'stack-no-clear 'vector))
          (set! sv-624 (new 'stack-no-clear 'vector))
          (set! sv-628 (new 'stack-no-clear 'vector))
          (vector-! sv-576 (-> obj position) (-> s3-0 best-other-tri intersect))
          (vector-normalize! sv-576 1.0)
          (set! sv-632 (vector-dot sv-576 (-> obj lin-momentum)))
          (when (< sv-632 0.0)
            (vector-float*! sv-624 sv-576 sv-632)
            (vector-! sv-628 (-> obj lin-momentum) sv-624)
            (vector-float*! sv-628 sv-628 (- 1.0 (-> s4-0 friction-factor)))
            (vector-float*! sv-624 sv-624 (- (-> s4-0 bounce-factor)))
            (vector+! (-> obj lin-momentum) sv-628 sv-624)
            (vector-float*! (-> obj lin-velocity) (-> obj lin-momentum) (-> s4-0 inv-mass))
            )
          (b! (>= f28-0 0.0001) cfg-7 :delay #f)
          (vector+float*! (-> obj position) (-> obj position) sv-576 409.6)
          (label cfg-7)
          (set! sv-704 (new 'stack-no-clear 'vector))
          (set! sv-708 (new 'stack-no-clear 'vector))
          (set! sv-712 (new 'stack-no-clear 'vector))
          (set! sv-716 (new 'stack-no-clear 'vector))
          (vector-! sv-704 (-> s3-0 best-other-tri intersect) (-> obj position))
          (rigid-body-method-22 obj (-> s3-0 best-other-tri intersect) sv-708)
          (vector+float*! sv-708 sv-708 sv-576 (- (vector-dot sv-708 sv-576)))
          (vector-float*! sv-712 sv-708 (* -1.0 (-> s4-0 mass) (-> s4-0 friction-factor)))
          (vector-cross! sv-716 sv-704 sv-712)
          (let ((a1-20 (-> obj ang-momentum)))
            (let ((v1-46 (-> obj ang-momentum)))
              (let ((a0-27 sv-716))
                (let ((a2-6 1.0))
                  (.mov vf7 a2-6)
                  )
                (.lvf vf5 (&-> a0-27 quad))
                )
              (.lvf vf4 (&-> v1-46 quad))
              )
            (.add.x.vf vf6 vf0 vf0 :mask #b1000)
            (.mul.x.vf acc vf5 vf7 :mask #b111)
            (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
            (.svf (&-> a1-20 quad) vf6)
            )
          (vector-rotate*! (-> obj ang-velocity) (-> obj ang-momentum) (-> obj inv-i-world))
          (set! f30-0 (* f30-0 (- 1.0 f28-0)))
          )
        (+! s2-0 1)
        )
      )
    (label cfg-9)
    0
    0
    (none)
    )
  )

(defmethod rigid-body-method-18 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (vector+! (-> obj force) (-> obj force) arg1)
  (let ((a3-1 (new 'stack-no-clear 'vector))
        (v1-1 (new 'stack-no-clear 'vector))
        )
    (vector-! a3-1 arg0 (-> obj position))
    (vector-cross! v1-1 a3-1 arg1)
    (vector+! (-> obj torque) (-> obj torque) v1-1)
    )
  0
  (none)
  )

(defmethod rigid-body-method-21 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector) (arg2 float))
  (vector+! (-> obj force) (-> obj force) arg1)
  (let* ((t0-2 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj position)))
         (v1-3 (vector-cross! (new 'stack-no-clear 'vector) t0-2 arg1))
         )
    (let ((f0-0 (vector-length t0-2)))
      (if (< arg2 f0-0)
          (vector-float*! v1-3 v1-3 (/ arg2 f0-0))
          )
      )
    (vector+! (-> obj torque) (-> obj torque) v1-3)
    )
  0
  (none)
  )

(defmethod rigid-body-method-19 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (-> obj work)
    (vector-rotate*! s4-0 arg1 (-> obj matrix))
    (vector-rotate*! s5-0 arg0 (-> obj matrix))
    (vector+! s5-0 s5-0 (-> obj position))
    (rigid-body-method-18 obj s5-0 s4-0)
    )
  0
  (none)
  )

(defmethod rigid-body-method-20 rigid-body ((obj rigid-body) (arg0 vector))
  (vector+! (-> obj force) (-> obj force) arg0)
  0
  (none)
  )

(defmethod rigid-body-method-23 rigid-body ((obj rigid-body) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-rotate*! gp-0 (-> obj info cm-offset-joint) (-> obj matrix))
    (vector-! arg0 (-> obj position) gp-0)
    )
  arg0
  )

(defmethod print-force-torque rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  force ~M ~M ~M" (-> obj force x) (-> obj force y) (-> obj force z))
  (format arg0 "  torque ~M ~M ~M~%" (-> obj torque x) (-> obj torque y) (-> obj torque z))
  0
  (none)
  )

(defmethod print-momentum rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  lin-mom ~M ~M ~M" (-> obj lin-momentum x) (-> obj lin-momentum y) (-> obj lin-momentum z))
  (format arg0 "  ang-mom ~M ~M ~M~%" (-> obj ang-momentum x) (-> obj ang-momentum y) (-> obj ang-momentum z))
  0
  (none)
  )

(defmethod print-velocity rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  lin-vel ~M ~M ~M" (-> obj lin-velocity x) (-> obj lin-velocity y) (-> obj lin-velocity z))
  (format arg0 "  ang-vel ~f ~f ~f~%" (-> obj ang-velocity x) (-> obj ang-velocity y) (-> obj ang-velocity z))
  0
  (none)
  )

(defmethod print-position-rotation rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  position ~M ~M ~M" (-> obj position x) (-> obj position y) (-> obj position z))
  (format
    arg0
    "  rotation ~f ~f ~f ~f~%"
    (-> obj rotation x)
    (-> obj rotation y)
    (-> obj rotation z)
    (-> obj rotation w)
    )
  0
  (none)
  )

(defmethod print-physics rigid-body ((obj rigid-body) (arg0 object))
  (print-force-torque obj arg0)
  (print-position-rotation obj arg0)
  (print-momentum obj arg0)
  (print-velocity obj arg0)
  0
  (none)
  )

;; WARN: Return type mismatch int vs object.
(defmethod rigid-body-control-method-10 rigid-body-control ((obj rigid-body-control) (arg0 rigid-body-object) (arg1 float) (arg2 float))
  (let* ((s4-1 (max 1 (min 4 (+ (the int (* 0.9999 (/ arg1 arg2))) 1))))
         (f30-0 (/ arg1 (the float s4-1)))
         (s3-0 (-> obj state force-callback))
         )
    (while (nonzero? s4-1)
      (+! s4-1 -1)
      (s3-0 arg0 f30-0)
      (let ((v1-2 obj)
            (a1-2 (-> arg0 root-override-2))
            (f0-4 f30-0)
            )
        (rigid-body-method-9 (-> v1-2 state) a1-2 f0-4)
        )
      )
    )
  (the-as object 0)
  )

(defmethod rigid-body-method-11 rigid-body ((obj rigid-body) (arg0 collide-shape-moving))
  (quaternion-copy! (-> arg0 quat) (-> obj rotation))
  (rigid-body-method-23 obj (-> arg0 trans))
  (set! (-> arg0 transv quad) (-> obj lin-velocity quad))
  0
  (none)
  )

(defmethod get-inv-mass rigid-body-object ((obj rigid-body-object))
  (-> obj info inv-mass)
  )

(defmethod rigid-body-object-method-35 rigid-body-object ((obj rigid-body-object))
  (let ((a0-1 (-> obj info name)))
    (when (nonzero? a0-1)
      (set! (-> obj info) (the-as rigid-body-object-constants (-> a0-1 value)))
      (set! (-> obj rbody state info) (the-as rigid-body-info (&-> (-> obj info) mass)))
      )
    )
  ((method-of-type rigid-body-info rigid-body-info-method-9) (the-as rigid-body-info (&-> (-> obj info) mass)))
  (set! (-> obj rbody state force-callback) (method-of-object obj rigid-body-object-method-29))
  0
  (none)
  )

(defmethod rigid-body-object-method-50 rigid-body-object ((obj rigid-body-object) (arg0 float))
  (when (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    (when (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force))
      (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force))
      (vector-float*! (-> obj player-force) (-> obj player-force) (/ 1.0 arg0))
      )
    (let ((v1-10 (-> obj rbody))
          (a1-1 (-> obj player-force-position))
          (a2-2 (-> obj player-force))
          )
      (rigid-body-method-18 (-> v1-10 state) a1-1 a2-2)
      )
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-29 rigid-body-object ((obj rigid-body-object) (arg0 float))
  (let ((a1-1 (new 'stack-no-clear 'vector)))
    (vector-reset! a1-1)
    (set! (-> a1-1 y) (* -1.0 (-> obj info gravity) (-> obj rbody state info mass)))
    (rigid-body-method-20 (-> obj rbody state) a1-1)
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-30 rigid-body-object ((obj rigid-body-object))
  (with-pp
    (rigid-body-control-method-10 (-> obj rbody) obj (-> pp clock seconds-per-frame) (-> obj max-time-step))
    (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    0
    (none)
    )
  )

(defmethod rigid-body-object-method-51 rigid-body-object ((obj rigid-body-object))
  (rigid-body-control-method-10 (-> obj rbody) obj (-> obj rbody state time-remaining) (-> obj max-time-step))
  0
  (none)
  )

(defmethod rigid-body-object-method-52 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
  0
  (none)
  )

(defmethod rigid-body-object-method-34 rigid-body-object ((obj rigid-body-object))
  (go (method-of-object obj idle))
  0
  (none)
  )

(defmethod rigid-body-object-method-31 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-object-constants))
  (set! (-> obj info) arg0)
  (set! (-> obj rbody) (new 'process 'rigid-body-control obj))
  (update-transforms (-> obj root-override-2))
  (rigid-body-method-25
    (-> obj rbody state)
    (the-as rigid-body-info (&-> (-> obj info) mass))
    (-> obj root-override-2 trans)
    (-> obj root-override-2 quat)
    (method-of-object obj rigid-body-object-method-29)
    )
  (rigid-body-object-method-35 obj)
  (set! (-> obj max-time-step) (-> arg0 max-time-step))
  (set! (-> obj root-override-2 max-iteration-count) (the-as uint 4))
  (let ((v1-15 (-> obj skel root-channel 0)))
    (set! (-> v1-15 num-func) num-func-identity)
    (set! (-> v1-15 frame-num) 0.0)
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-32 rigid-body-object ((obj rigid-body-object))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (pusher-init s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root-override-2) s5-0)
    )
  0
  (none)
  )

(define *rigid-body-object-constants* (new 'static 'rigid-body-object-constants
                                        :mass 2.0
                                        :inv-mass 0.5
                                        :cm-joint (new 'static 'vector :w 1.0)
                                        :linear-damping 1.0
                                        :angular-damping 1.0
                                        :bounce-factor 0.5
                                        :friction-factor 0.1
                                        :inertial-tensor-x (meters 4)
                                        :inertial-tensor-y (meters 4)
                                        :inertial-tensor-z (meters 4)
                                        :max-time-step 0.033333335
                                        :gravity (meters 80)
                                        :idle-distance (meters 50)
                                        :attack-force-scale 1.0
                                        :name '*rigid-body-object-constants*
                                        )
        )

(defmethod rigid-body-object-method-33 rigid-body-object ((obj rigid-body-object))
  (rigid-body-object-method-31 obj *rigid-body-object-constants*)
  0
  (none)
  )

(defmethod init-from-entity! rigid-body-object ((obj rigid-body-object) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (rigid-body-object-method-32 obj)
  (process-drawable-from-entity! obj arg0)
  (rigid-body-object-method-33 obj)
  (rigid-body-object-method-34 obj)
  0
  (none)
  )

(defmethod rigid-body-object-method-36 rigid-body-object ((obj rigid-body-object))
  0
  (none)
  )

(defmethod rigid-body-object-method-37 rigid-body-object ((obj rigid-body-object))
  (rigid-body-object-method-30 obj)
  (rigid-body-object-method-36 obj)
  (let ((v1-4 (-> obj rbody))
        (a1-0 (-> obj root-override-2))
        )
    (rigid-body-method-11 (-> v1-4 state) a1-0)
    )
  (transform-post)
  0
  (none)
  )

(defmethod rigid-body-object-method-40 rigid-body-object ((obj rigid-body-object))
  (logior! (-> obj flags) (rigid-body-object-flag enable-collision))
  (let ((v1-3 (-> obj root-override-2 root-prim)))
    (set! (-> v1-3 prim-core collide-as) (-> obj root-override-2 backup-collide-as))
    (set! (-> v1-3 prim-core collide-with) (-> obj root-override-2 backup-collide-with))
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-41 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj flags) (rigid-body-object-flag enable-collision))
  (let ((v1-3 (-> obj root-override-2 root-prim)))
    (set! (-> v1-3 prim-core collide-as) (collide-spec))
    (set! (-> v1-3 prim-core collide-with) (collide-spec))
    )
  0
  0
  (none)
  )

(defmethod rigid-body-object-method-38 rigid-body-object ((obj rigid-body-object))
  (when (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
    (logior! (-> obj rbody state flags) (rigid-body-flag enable-physics))
    (rigid-body-method-26 (-> obj rbody state) (-> obj root-override-2 trans) (-> obj root-override-2 quat))
    (vector-float*! (-> obj rbody state lin-momentum) (-> obj root-override-2 transv) (-> obj info mass))
    (vector-reset! (-> obj rbody state ang-momentum))
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-39 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj rbody state flags) (rigid-body-flag enable-physics))
  0
  (none)
  )

(defmethod rigid-body-object-method-42 rigid-body-object ((obj rigid-body-object))
  (logior! (-> obj flags) (rigid-body-object-flag disturbed))
  (set! (-> obj disturbed-time) (-> self clock frame-counter))
  (if (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
      (rigid-body-object-method-38 obj)
      )
  0
  (none)
  )

(defmethod rigid-body-object-method-43 rigid-body-object ((obj rigid-body-object))
  (go (method-of-object obj active))
  0
  (none)
  )

(defmethod apply-damage rigid-body-object ((obj rigid-body-object) (arg0 float) (arg1 matrix))
  0
  (none)
  )

(defmethod rigid-body-object-method-45 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-impact))
  0
  (none)
  )

(defmethod rigid-body-object-method-49 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-impact) (arg1 touching-shapes-entry))
  (set! (-> arg0 rbody) #f)
  (set! (-> arg0 prim-id) (the-as uint 0))
  (vector-reset! (-> arg0 normal))
  (vector-reset! (-> arg0 velocity))
  (set! (-> arg0 point quad) (-> obj root-override-2 trans quad))
  (when arg1
    (let ((s3-0 (-> arg1 head)))
      (when s3-0
        (get-intersect-point (-> arg0 point) s3-0 (-> obj root-override-2) arg1)
        (let ((s5-1 (get-touched-prim s3-0 (-> obj root-override-2) arg1)))
          (when s5-1
            (set! (-> arg0 prim-id) (-> s5-1 prim-id))
            (vector-! (-> arg0 normal) (-> arg0 point) (the-as vector (-> s5-1 prim-core)))
            (vector-normalize! (-> arg0 normal) 1.0)
            (vector+float*!
              (-> arg0 point)
              (the-as vector (-> s5-1 prim-core))
              (-> arg0 normal)
              (-> s5-1 prim-core world-sphere w)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-47 rigid-body-object ((obj rigid-body-object)
                                                        (arg0 process-drawable)
                                                        (arg1 attack-info)
                                                        (arg2 touching-shapes-entry)
                                                        (arg3 penetrate)
                                                        )
  (local-vars (f0-2 float))
  (when arg2
    (let ((s5-0 (new 'stack-no-clear 'rigid-body-impact)))
      (rigid-body-object-method-49 obj s5-0 arg2)
      (if (logtest? (attack-info-mask attacker-velocity) (-> arg1 mask))
          (set! (-> s5-0 velocity quad) (-> arg1 attacker-velocity quad))
          (vector-! (-> s5-0 velocity) (-> s5-0 point) (-> arg0 root trans))
          )
      0.0
      0.0
      (let ((f1-0 (cond
                    ((logtest? (penetrate enemy-yellow-shot) arg3)
                     (set! f0-2 8192.0)
                     0.025
                     )
                    ((logtest? (penetrate jak-yellow-shot jak-blue-shot) arg3)
                     (set! f0-2 8192.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-red-shot) arg3)
                     (set! f0-2 16384.0)
                     0.05
                     )
                    ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg3)
                     (set! f0-2 81920.0)
                     1.5
                     )
                    ((logtest? arg3 (penetrate punch))
                     (set! f0-2 40960.0)
                     0.1
                     )
                    ((logtest? arg3 (penetrate flop spin))
                     (set! f0-2 20480.0)
                     0.05
                     )
                    (else
                      (set! f0-2 8192.0)
                      0.01
                      )
                    )
                  )
            )
        (set! (-> s5-0 impulse) (* f0-2 (-> obj info attack-force-scale)))
        (apply-damage obj (* 0.667 f1-0) (the-as matrix s5-0))
        )
      (rigid-body-object-method-42 obj)
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (set! (-> s4-1 quad) (-> s5-0 velocity quad))
        (vector-normalize! s4-1 1.0)
        (vector-float*! s4-1 s4-1 (-> s5-0 impulse))
        (let ((v1-46 (-> obj rbody))
              (a1-6 (-> s5-0 point))
              (a2-3 s4-1)
              )
          (rigid-body-method-18 (-> v1-46 state) a1-6 a2-3)
          )
        (let ((v1-49 (-> obj rbody))
              (f0-7 1.0)
              )
          (rigid-body-method-12 (-> v1-49 state) f0-7)
          )
        (rigid-body-method-13 (-> obj rbody state))
        (when #t
          (add-debug-x #t (bucket-id debug-no-zbuf1) (-> s5-0 point) *color-blue*)
          (add-debug-vector #t (bucket-id debug-no-zbuf1) (-> s5-0 point) s4-1 (meters 0.00024414062) *color-blue*)
          )
        )
      (rigid-body-object-method-45 obj s5-0)
      )
    (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
        (rigid-body-object-method-43 obj)
        )
    #t
    )
  )

(defmethod rigid-body-object-method-48 rigid-body-object ((obj rigid-body-object) (arg0 process-focusable) (arg1 touching-shapes-entry))
  (local-vars (v1-2 symbol))
  (b! (not (logtest? (process-mask target crate enemy) (-> arg0 mask))) cfg-5 :likely-delay (set! v1-2 #t))
  (b! (not (logtest? (-> arg0 mask) (process-mask target))) cfg-5 :likely-delay (set! v1-2 #f))
  (set! v1-2 (logtest? (focus-status dangerous pilot) (-> arg0 focus-status)))
  (label cfg-5)
  (b! v1-2 cfg-17 :delay (nop!))
  (let ((s5-0 (new 'stack-no-clear 'rigid-body-impact))
        (s4-0 (new 'stack-no-clear 'vector))
        (f30-0 (get-inv-mass arg0))
        )
    (rigid-body-object-method-49 obj s5-0 arg1)
    (cond
      ((logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics))
       (let ((v1-14 (-> obj rbody))
             (a1-3 (-> s5-0 point))
             (a2-2 (-> s5-0 velocity))
             )
         (rigid-body-method-22 (-> v1-14 state) a1-3 a2-2)
         )
       )
      (else
        (set! (-> s5-0 velocity quad) (-> obj root-override-2 transv quad))
        )
      )
    (let ((v1-18 (-> arg0 root-override)))
      (set! (-> s4-0 quad) (-> v1-18 transv quad))
      (vector-! (-> s5-0 velocity) (-> v1-18 transv) (-> s5-0 velocity))
      )
    (let ((f0-1 (vector-dot (-> s5-0 velocity) (-> s5-0 normal))))
      (when (< f0-1 0.0)
        (set! (-> s5-0 impulse) (/ f0-1 (+ f30-0 (-> obj info inv-mass))))
        (vector+float*! s4-0 s4-0 (-> s5-0 normal) (* -3.1 f30-0 (-> s5-0 impulse)))
        (set! (-> s4-0 y) (fmax (* 49152.0 f30-0) (-> s4-0 y)))
        (rigid-body-object-method-42 obj)
        (let ((a2-4 (new 'stack-no-clear 'vector)))
          (vector-float*! a2-4 (-> s5-0 normal) (-> s5-0 impulse))
          (let ((v1-31 (-> obj rbody))
                (a1-8 (-> s5-0 point))
                )
            (rigid-body-method-18 (-> v1-31 state) a1-8 a2-4)
            )
          )
        (let ((v1-34 (-> obj rbody))
              (f0-10 1.0)
              )
          (rigid-body-method-12 (-> v1-34 state) f0-10)
          )
        (rigid-body-method-13 (-> obj rbody state))
        (when #f
          (add-debug-x #t (bucket-id debug-no-zbuf1) (-> s5-0 point) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (-> s5-0 point)
            (-> s5-0 normal)
            (- (-> s5-0 impulse))
            *color-blue*
            )
          )
        (rigid-body-object-method-45 obj s5-0)
        (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
            (rigid-body-object-method-43 obj)
            )
        )
      )
    )
  (label cfg-17)
  #t
  )

(defmethod rigid-body-object-method-46 rigid-body-object ((obj rigid-body-object) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact-impulse)
     (let ((s5-1 (-> arg3 param 0)))
       (if (!= obj arg0)
           (rigid-body-object-method-42 obj)
           )
       (rigid-body-object-method-45 obj (the-as rigid-body-impact s5-1))
       )
     (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
         (rigid-body-object-method-43 obj)
         )
     )
    (('touched)
     (if (= obj *debug-actor*)
         (format *stdcon* "rigid-body-object got touched~%")
         )
     (when (zero? (-> arg0 rbody))
       (let ((s3-0 (if (type? arg0 process-focusable)
                       (the-as process-focusable arg0)
                       )
                   )
             )
         (when s3-0
           (when (logtest? (-> s3-0 mask) (process-mask target))
             (logior! (-> obj flags) (rigid-body-object-flag player-touching))
             (set! (-> obj player-touch-time) (-> self clock frame-counter))
             (rigid-body-object-method-42 obj)
             )
           (if (not (logtest? (-> s3-0 mask) (process-mask target)))
               (rigid-body-object-method-48 obj s3-0 (the-as touching-shapes-entry (-> arg3 param 0)))
               )
           )
         )
       )
     )
    (('attack)
     (let ((s3-1 (the-as attack-info (-> arg3 param 1)))
           (t0-1 (get-penetrate-using-from-attack-event arg0 arg3))
           )
       (when (!= (-> s3-1 id) (-> obj incoming-attack-id))
         (set! (-> obj incoming-attack-id) (-> s3-1 id))
         (rigid-body-object-method-47 obj arg0 s3-1 (the-as touching-shapes-entry (-> arg3 param 0)) t0-1)
         )
       )
     )
    (('edge-grabbed 'pilot-edge-grab)
     (let ((s5-2 (the-as object (-> arg3 param 0))))
       (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force)))
         (let ((a0-25 (if (type? arg0 process-focusable)
                          (the-as process-focusable arg0)
                          )
                      )
               )
           (when a0-25
             (let ((f0-1 (/ 163840.0 (get-inv-mass a0-25))))
               (logior! (-> obj flags) (rigid-body-object-flag player-touching player-edge-grabbing player-contact-force))
               (set! (-> obj player-force-position quad) (-> (the-as attack-info s5-2) attacker-velocity quad))
               (vector-reset! (-> obj player-force))
               (set! (-> obj player-force y) (* -1.0 f0-1))
               )
             )
           )
         )
       )
     (zero? (logand (-> obj focus-status) (focus-status dead inactive)))
     )
    (('ridden)
     (let ((v1-45 (the-as object (-> arg3 param 0))))
       (when (the-as uint v1-45)
         (let* ((s5-3 (handle->process (-> (the-as focus v1-45) handle)))
                (a0-34 (if (type? s5-3 process-focusable)
                           (the-as process-focusable s5-3)
                           )
                       )
                )
           (when (and a0-34
                      (logtest? (-> a0-34 mask) (process-mask target))
                      (zero? (logand (-> a0-34 focus-status) (focus-status on-water under-water)))
                      )
             (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force)))
               (logior! (-> obj flags) (rigid-body-object-flag player-touching player-standing-on player-contact-force))
               (set! (-> obj player-force-position quad) (-> a0-34 root-override trans quad))
               (vector-reset! (-> obj player-force))
               (let ((f0-4 (/ 163840.0 (get-inv-mass a0-34)))
                     (f1-1 1.0)
                     )
                 (set! (-> obj player-force y) (* -1.0 f0-4 f1-1))
                 )
               )
             )
           )
         )
       )
     )
    (('bonk)
     (when #t
       (let ((a0-38 (if (type? arg0 process-focusable)
                        (the-as process-focusable arg0)
                        )
                    )
             )
         (when a0-38
           (logior! (-> obj flags) (rigid-body-object-flag player-touching player-impulse-force))
           (set! (-> obj player-force-position quad) (-> a0-38 root-override trans quad))
           (let ((f30-2 (* 0.00012207031 (the-as float (-> arg3 param 1))))
                 (f0-9 (/ 163840.0 (get-inv-mass a0-38)))
                 )
             (vector-reset! (-> obj player-force))
             (set! (-> obj player-force y) (* -0.1 f0-9 f30-2))
             )
           )
         )
       )
     )
    (('enable-physics)
     (rigid-body-object-method-42 obj)
     )
    )
  (none)
  )

(defbehavior rigid-body-object-event-handler rigid-body-object ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (rigid-body-object-method-46 self (the-as process-drawable arg0) arg1 arg2 arg3)
  (none)
  )

(defstate idle (rigid-body-object)
  :virtual #t
  :trans (behavior ()
    (if (and *target* (and (>= (-> self info idle-distance)
                               (vector-vector-distance (-> self root-override-2 trans) (-> *target* control trans))
                               )
                           (zero? (logand (focus-status teleporting) (-> *target* focus-status)))
                           )
             )
        (go-virtual active)
        )
    (none)
    )
  :code (the-as (function none :behavior rigid-body-object) sleep-code)
  :post (the-as (function none :behavior rigid-body-object) ja-post)
  )

(defstate active (rigid-body-object)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior rigid-body-object)
    rigid-body-object-event-handler
    )
  :trans (behavior ()
    (if (or (not *target*)
            (or (< (+ 4096.0 (-> self info idle-distance))
                   (vector-vector-distance (-> self root-override-2 trans) (-> *target* control trans))
                   )
                (logtest? (focus-status teleporting) (-> *target* focus-status))
                )
            )
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior rigid-body-object) sleep-code)
  :post (behavior ()
    (rigid-body-object-method-37 self)
    (none)
    )
  )
