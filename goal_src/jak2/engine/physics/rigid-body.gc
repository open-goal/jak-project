;;-*-Lisp-*-
(in-package goal)

;; name: rigid-body.gc
;; name in dgo: rigid-body
;; dgos: GAME, COMMON

;; og:ignore-form:rigid-body-object-method-48
;; og:ignore-form:rigid-body-method-15
;; og:ignore-form:collide-shape-moving-method-63
;; og:ignore-form:collide-shape-moving-method-67

;; DECOMP BEGINS

(deftype rigid-body-work (structure)
  ((max-ang-momentum float  :offset-assert   0)
   (max-ang-velocity float  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )


(define *rigid-body-work* (new 'static 'rigid-body-work))

(defmethod new rigid-body-control ((allocation symbol) (type-to-make type) (arg0 process))
  (let ((v0-0 (object-new allocation type-to-make (the-as int (-> type-to-make size)))))
    (set! (-> v0-0 process) arg0)
    v0-0
    )
  )

(defmethod relocate rigid-body-control ((obj rigid-body-control) (arg0 int))
  (&+! (-> obj process) arg0)
  obj
  )

(defmethod rigid-body-info-method-9 rigid-body-info ((obj rigid-body-info))
  (let ((f24-0 (-> obj mass))
        (f28-0 (-> obj inertial-tensor-box 0))
        (f30-0 (-> obj inertial-tensor-box 1))
        (f26-0 (-> obj inertial-tensor-box 2))
        )
    (let ((f0-0 f24-0))
      (set! (-> obj inv-mass) (/ 1.0 f0-0))
      )
    (matrix-identity! (-> obj inertial-tensor))
    (matrix-identity! (-> obj inv-inertial-tensor))
    (let ((f0-4 (* 0.083333336 f24-0)))
      (let* ((f1-1 f30-0)
             (f1-3 (* f1-1 f1-1))
             (f2-0 f26-0)
             )
        (set! (-> obj inertial-tensor vector 0 x) (* f0-4 (+ f1-3 (* f2-0 f2-0))))
        )
      (let ((f1-6 f28-0))
        (set! (-> obj inertial-tensor vector 1 y) (* f0-4 (+ (* f1-6 f1-6) (* f26-0 f26-0))))
        )
      (set! (-> obj inertial-tensor vector 2 z) (* f0-4 (+ (* f28-0 f28-0) (* f30-0 f30-0))))
      )
    )
  (let ((f0-6 (-> obj inertial-tensor vector 0 x)))
    (set! (-> obj inv-inertial-tensor vector 0 x) (/ 1.0 f0-6))
    )
  (let ((f0-9 (-> obj inertial-tensor vector 1 y)))
    (set! (-> obj inv-inertial-tensor vector 1 y) (/ 1.0 f0-9))
    )
  (let ((f0-12 (-> obj inertial-tensor vector 2 z)))
    (set! (-> obj inv-inertial-tensor vector 2 z) (/ 1.0 f0-12))
    )
  0
  (none)
  )

(defmethod clear-force-torque! rigid-body ((obj rigid-body))
  (set! (-> obj force quad) (the-as uint128 0))
  (set! (-> obj torque quad) (the-as uint128 0))
  0
  (none)
  )

(defmethod clear-momentum! rigid-body ((obj rigid-body))
  (set! (-> obj lin-momentum quad) (the-as uint128 0))
  (set! (-> obj ang-momentum quad) (the-as uint128 0))
  0
  (none)
  )

(defmethod rigid-body-method-24 rigid-body ((obj rigid-body))
  (when #t
    (quaternion->matrix (-> obj matrix) (-> obj rotation))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (vector-rotate*! s5-0 (-> obj info cm-offset-joint) (-> obj matrix))
      (vector-! (-> obj matrix trans) (-> obj position) s5-0)
      )
    )
  0
  (none)
  )

(defmethod rigid-body-method-26 rigid-body ((obj rigid-body) (arg0 vector) (arg1 quaternion))
  (let ((s3-0 (new 'stack-no-clear 'inline-array 'vector 8)))
    (quaternion->matrix (the-as matrix (-> s3-0 1)) arg1)
    (vector-rotate*! (-> s3-0 0) (-> obj info cm-offset-joint) (the-as matrix (-> s3-0 1)))
    (vector+! (-> obj position) arg0 (-> s3-0 0))
    )
  (quaternion-copy! (-> obj rotation) arg1)
  (quaternion-normalize! (-> obj rotation))
  (rigid-body-method-24 obj)
  0
  (none)
  )

(defmethod rigid-body-method-25 rigid-body ((obj rigid-body) (arg0 rigid-body-info) (arg1 vector) (arg2 quaternion) (arg3 function))
  (set! (-> obj work) *rigid-body-work*)
  (set! (-> obj info) arg0)
  (set! (-> obj force-callback) (the-as (function object float none) arg3))
  (rigid-body-info-method-9 (-> obj info))
  (let ((v1-3 obj))
    (set! (-> v1-3 force quad) (the-as uint128 0))
    (set! (-> v1-3 torque quad) (the-as uint128 0))
    )
  0
  (clear-momentum! obj)
  (rigid-body-method-26 obj arg1 arg2)
  (rigid-body-method-13 obj)
  0
  (none)
  )

(defmethod rigid-body-method-22 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj position))))
    (vector-cross! arg1 (-> obj ang-velocity) v1-1)
    )
  (vector+! arg1 arg1 (-> obj lin-velocity))
  arg1
  )

(defun matrix-3x3-triple-transpose-product ((arg0 matrix) (arg1 matrix) (arg2 matrix))
  (let ((s5-0 (new 'stack-no-clear 'inline-array 'matrix 3)))
    (let* ((v1-0 (-> s5-0 0))
           (a3-0 arg1)
           (a0-1 (-> a3-0 vector 0 quad))
           (a1-1 (-> a3-0 vector 1 quad))
           (a2-1 (-> a3-0 vector 2 quad))
           (a3-1 (-> a3-0 trans quad))
           )
      (set! (-> v1-0 vector 0 quad) a0-1)
      (set! (-> v1-0 vector 1 quad) a1-1)
      (set! (-> v1-0 vector 2 quad) a2-1)
      (set! (-> v1-0 trans quad) a3-1)
      )
    (vector-reset! (-> s5-0 0 trans))
    (matrix-transpose! (-> s5-0 1) (-> s5-0 0))
    (matrix*! (-> s5-0 2) arg2 (-> s5-0 0))
    (matrix*! arg0 (-> s5-0 1) (-> s5-0 2))
    )
  arg0
  )

(defmethod rigid-body-method-12 rigid-body ((obj rigid-body) (arg0 float))
  (local-vars (v1-6 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a2-0 (-> obj lin-momentum)))
      (let ((v1-0 (-> obj lin-momentum)))
        (let ((a0-1 (-> obj force)))
          (let ((a3-0 arg0))
            (.mov vf7 a3-0)
            )
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.lvf vf4 (&-> v1-0 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a2-0 quad) vf6)
      )
    (let ((a2-1 (-> obj ang-momentum)))
      (let ((v1-1 (-> obj ang-momentum)))
        (let ((a0-2 (-> obj torque)))
          (let ((a1-1 arg0))
            (.mov vf7 a1-1)
            )
          (.lvf vf5 (&-> a0-2 quad))
          )
        (.lvf vf4 (&-> v1-1 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a2-1 quad) vf6)
      )
    (let* ((f0-3 (* 500000000.0 (-> obj info mass)))
           (f1-1 f0-3)
           (f1-3 (* f1-1 f1-1))
           )
      (.lvf vf1 (&-> (-> obj ang-momentum) quad))
      (.add.w.vf vf2 vf0 vf0 :mask #b1)
      (.mul.vf vf1 vf1 vf1)
      (.mul.x.vf acc vf2 vf1 :mask #b1)
      (.add.mul.y.vf acc vf2 vf1 acc :mask #b1)
      (.add.mul.z.vf vf1 vf2 vf1 acc :mask #b1)
      (.mov v1-6 vf1)
      (if (< f1-3 v1-6)
          (vector-normalize! (-> obj ang-momentum) f0-3)
          )
      )
    (set! (-> obj force quad) (the-as uint128 0))
    (set! (-> obj torque quad) (the-as uint128 0))
    0
    0
    (none)
    )
  )

(defmethod rigid-body-method-13 rigid-body ((obj rigid-body))
  (let ((v1-0 (-> obj info)))
    (vector-float*! (-> obj lin-velocity) (-> obj lin-momentum) (-> v1-0 inv-mass))
    (matrix-3x3-triple-transpose-product (-> obj inv-i-world) (-> obj matrix) (-> v1-0 inv-inertial-tensor))
    )
  (vector-rotate*! (-> obj ang-velocity) (-> obj ang-momentum) (-> obj inv-i-world))
  0
  (none)
  )

(defmethod rigid-body-method-14 rigid-body ((obj rigid-body) (arg0 float))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         (vf6 :class vf)
         (vf7 :class vf)
         )
    (init-vf0-vector)
    (let ((a1-1 (-> obj position)))
      (let ((v1-0 (-> obj position)))
        (let ((a0-1 (-> obj lin-velocity)))
          (let ((a2-0 arg0))
            (.mov vf7 a2-0)
            )
          (.lvf vf5 (&-> a0-1 quad))
          )
        (.lvf vf4 (&-> v1-0 quad))
        )
      (.add.x.vf vf6 vf0 vf0 :mask #b1000)
      (.mul.x.vf acc vf5 vf7 :mask #b111)
      (.add.mul.w.vf vf6 vf4 vf0 acc :mask #b111)
      (.svf (&-> a1-1 quad) vf6)
      )
    (let ((s4-0 (new 'stack-no-clear 'quaternion)))
      (set! (-> (the-as vector (&-> s4-0 x)) quad) (-> obj ang-velocity quad))
      (set! (-> s4-0 w) 0.0)
      (quaternion*! s4-0 s4-0 (-> obj rotation))
      (quaternion-float*! s4-0 s4-0 0.5)
      (+! (-> obj rotation x) (* (-> s4-0 x) arg0))
      (+! (-> obj rotation y) (* (-> s4-0 y) arg0))
      (+! (-> obj rotation z) (* (-> s4-0 z) arg0))
      (+! (-> obj rotation w) (* (-> s4-0 w) arg0))
      )
    (quaternion-normalize! (-> obj rotation))
    (rigid-body-method-24 obj)
    0
    (none)
    )
  )

(defun damping-time-adjust ((arg0 float) (arg1 float))
  (let ((f0-0 0.0)
        (f1-0 1.0)
        (f2-2 (* (+ -1.0 arg0) arg1))
        (f3-2 0.016666668)
        )
    (fmax f0-0 (+ f1-0 (* f2-2 (/ 1.0 f3-2))))
    )
  )

(defmethod rigid-body-method-9 rigid-body ((obj rigid-body) (arg0 collide-shape-moving) (arg1 float))
  (rigid-body-method-12 obj arg1)
  (let ((v1-2 (-> obj info)))
    (let* ((a0-2 (-> obj lin-momentum))
           (a1-2 (-> obj lin-momentum))
           (f3-0 (-> v1-2 linear-damping))
           (f2-0 arg1)
           (f0-0 0.0)
           (f1-0 1.0)
           (f2-1 (* (+ -1.0 f3-0) f2-0))
           (f3-2 0.016666668)
           )
      (vector-float*! a0-2 a1-2 (fmax f0-0 (+ f1-0 (* f2-1 (/ 1.0 f3-2)))))
      )
    (let* ((a0-4 (-> obj ang-momentum))
           (a1-3 (-> obj ang-momentum))
           (f3-5 (-> v1-2 angular-damping))
           (f2-3 arg1)
           (f0-3 0.0)
           (f1-2 1.0)
           (f2-4 (* (+ -1.0 f3-5) f2-3))
           (f3-7 0.016666668)
           )
      (vector-float*! a0-4 a1-3 (fmax f0-3 (+ f1-2 (* f2-4 (/ 1.0 f3-7)))))
      )
    )
  (rigid-body-method-13 obj)
  (if (logtest? (-> obj flags) (rigid-body-flag enable-collision))
      ((method-of-object arg0 collide-shape-moving-method-63))
      (rigid-body-method-14 obj arg1)
      )
  0
  (none)
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defun transform-rigid-body-prims ((arg0 collide-shape-prim) (arg1 matrix))
  (rlet ((acc :class vf)
         (vf0 :class vf)
         (vf1 :class vf)
         (vf2 :class vf)
         (vf3 :class vf)
         (vf4 :class vf)
         (vf5 :class vf)
         )
    (init-vf0-vector)
    (let ((v1-0 arg0)
          (a0-1 1)
          )
      (when (= (-> v1-0 prim-core prim-type) (prim-type group))
        (let ((a0-2 (the-as collide-shape-prim-group v1-0)))
          (set! v1-0 (-> a0-2 child 0))
          (set! a0-1 (the-as int (-> a0-2 num-children)))
          )
        )
      (while (nonzero? a0-1)
        (+! a0-1 -1)
        (.lvf vf5 (&-> v1-0 local-sphere quad))
        (.lvf vf1 (&-> arg1 vector 0 quad))
        (.lvf vf2 (&-> arg1 vector 1 quad))
        (.lvf vf3 (&-> arg1 vector 2 quad))
        (.lvf vf4 (&-> arg1 trans quad))
        (.mul.x.vf acc vf1 vf5)
        (.add.mul.y.vf acc vf2 vf5 acc)
        (.add.mul.z.vf acc vf3 vf5 acc)
        (.add.mul.w.vf vf5 vf4 vf0 acc :mask #b111)
        (.svf (&-> v1-0 prim-core world-sphere quad) vf5)
        (&+! v1-0 80)
        )
      )
    #f
    )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod rigid-body-method-18 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (vector+! (-> obj force) (-> obj force) arg1)
  (let ((a3-1 (new 'stack-no-clear 'vector))
        (v1-1 (new 'stack-no-clear 'vector))
        )
    (vector-! a3-1 arg0 (-> obj position))
    (vector-cross! v1-1 a3-1 arg1)
    (vector+! (-> obj torque) (-> obj torque) v1-1)
    )
  0
  (none)
  )

(defmethod rigid-body-method-21 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector) (arg2 float))
  (vector+! (-> obj force) (-> obj force) arg1)
  (let* ((t0-2 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj position)))
         (v1-3 (vector-cross! (new 'stack-no-clear 'vector) t0-2 arg1))
         )
    (let ((f0-0 (vector-length t0-2)))
      (if (< arg2 f0-0)
          (vector-float*! v1-3 v1-3 (/ arg2 f0-0))
          )
      )
    (vector+! (-> obj torque) (-> obj torque) v1-3)
    )
  0
  (none)
  )

(defmethod rigid-body-method-19 rigid-body ((obj rigid-body) (arg0 vector) (arg1 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        )
    (-> obj work)
    (vector-rotate*! s4-0 arg1 (-> obj matrix))
    (vector-rotate*! s5-0 arg0 (-> obj matrix))
    (vector+! s5-0 s5-0 (-> obj position))
    (rigid-body-method-18 obj s5-0 s4-0)
    )
  0
  (none)
  )

(defmethod rigid-body-method-20 rigid-body ((obj rigid-body) (arg0 vector))
  (vector+! (-> obj force) (-> obj force) arg0)
  0
  (none)
  )

(defmethod rigid-body-method-23 rigid-body ((obj rigid-body) (arg0 vector))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (vector-rotate*! gp-0 (-> obj info cm-offset-joint) (-> obj matrix))
    (vector-! arg0 (-> obj position) gp-0)
    )
  arg0
  )

(defmethod print-force-torque rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  force ~M ~M ~M" (-> obj force x) (-> obj force y) (-> obj force z))
  (format arg0 "  torque ~M ~M ~M~%" (-> obj torque x) (-> obj torque y) (-> obj torque z))
  0
  (none)
  )

(defmethod print-momentum rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  lin-mom ~M ~M ~M" (-> obj lin-momentum x) (-> obj lin-momentum y) (-> obj lin-momentum z))
  (format arg0 "  ang-mom ~M ~M ~M~%" (-> obj ang-momentum x) (-> obj ang-momentum y) (-> obj ang-momentum z))
  0
  (none)
  )

(defmethod print-velocity rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  lin-vel ~M ~M ~M" (-> obj lin-velocity x) (-> obj lin-velocity y) (-> obj lin-velocity z))
  (format arg0 "  ang-vel ~f ~f ~f~%" (-> obj ang-velocity x) (-> obj ang-velocity y) (-> obj ang-velocity z))
  0
  (none)
  )

(defmethod print-position-rotation rigid-body ((obj rigid-body) (arg0 object))
  (format arg0 "  position ~M ~M ~M" (-> obj position x) (-> obj position y) (-> obj position z))
  (format
    arg0
    "  rotation ~f ~f ~f ~f~%"
    (-> obj rotation x)
    (-> obj rotation y)
    (-> obj rotation z)
    (-> obj rotation w)
    )
  0
  (none)
  )

(defmethod print-physics rigid-body ((obj rigid-body) (arg0 object))
  (print-force-torque obj arg0)
  (print-position-rotation obj arg0)
  (print-momentum obj arg0)
  (print-velocity obj arg0)
  0
  (none)
  )

;; WARN: Return type mismatch int vs object.
(defmethod rigid-body-control-method-10 rigid-body-control ((obj rigid-body-control) (arg0 rigid-body-object) (arg1 float) (arg2 float))
  (let* ((s4-1 (max 1 (min 4 (+ (the int (* 0.9999 (/ arg1 arg2))) 1))))
         (f30-0 (/ arg1 (the float s4-1)))
         (s3-0 (-> obj state force-callback))
         )
    (while (nonzero? s4-1)
      (+! s4-1 -1)
      (s3-0 arg0 f30-0)
      (let ((v1-2 obj)
            (a1-2 (-> arg0 root-override-2))
            (f0-4 f30-0)
            )
        (rigid-body-method-9 (-> v1-2 state) a1-2 f0-4)
        )
      )
    )
  (the-as object 0)
  )

(defmethod rigid-body-method-11 rigid-body ((obj rigid-body) (arg0 collide-shape-moving))
  (quaternion-copy! (-> arg0 quat) (-> obj rotation))
  (rigid-body-method-23 obj (-> arg0 trans))
  (set! (-> arg0 transv quad) (-> obj lin-velocity quad))
  0
  (none)
  )

(defmethod process-focusable-method-26 rigid-body-object ((obj rigid-body-object))
  (-> obj info inv-mass)
  )

(defmethod rigid-body-object-method-35 rigid-body-object ((obj rigid-body-object))
  (let ((a0-1 (-> obj info name)))
    (when (nonzero? a0-1)
      (set! (-> obj info) (the-as rigid-body-object-constants (-> a0-1 value)))
      (set! (-> obj rbody state info) (the-as rigid-body-info (&-> (-> obj info) mass)))
      )
    )
  ((method-of-type rigid-body-info rigid-body-info-method-9) (the-as rigid-body-info (&-> (-> obj info) mass)))
  (set! (-> obj rbody state force-callback)
        (the-as (function object float none) (method-of-object obj rigid-body-object-method-29))
        )
  0
  (none)
  )

(defmethod rigid-body-object-method-50 rigid-body-object ((obj rigid-body-object) (arg0 float))
  (when (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    (when (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force))
      (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force))
      (vector-float*! (-> obj player-force) (-> obj player-force) (/ 1.0 arg0))
      )
    (let ((v1-10 (-> obj rbody))
          (a1-1 (-> obj player-force-position))
          (a2-2 (-> obj player-force))
          )
      (rigid-body-method-18 (-> v1-10 state) a1-1 a2-2)
      )
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-29 rigid-body-object ((obj rigid-body-object))
  (let ((a1-0 (new 'stack-no-clear 'vector)))
    (vector-reset! a1-0)
    (set! (-> a1-0 y) (* -1.0 (-> obj info gravity) (-> obj rbody state info mass)))
    (rigid-body-method-20 (-> obj rbody state) a1-0)
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-30 rigid-body-object ((obj rigid-body-object))
  (with-pp
    (rigid-body-control-method-10 (-> obj rbody) obj (-> pp clock seconds-per-frame) (-> obj max-time-step))
    (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
    0
    (none)
    )
  )

(defmethod rigid-body-object-method-51 rigid-body-object ((obj rigid-body-object))
  (rigid-body-control-method-10 (-> obj rbody) obj (-> obj rbody state time-remaining) (-> obj max-time-step))
  0
  (none)
  )

(defmethod rigid-body-object-method-52 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj flags) (rigid-body-object-flag player-impulse-force player-contact-force))
  0
  (none)
  )

(defmethod rigid-body-object-method-34 rigid-body-object ((obj rigid-body-object))
  (go (method-of-object obj idle))
  0
  (none)
  )

(defmethod rigid-body-object-method-31 rigid-body-object ((obj rigid-body-object) (arg0 rigid-body-object-constants))
  (set! (-> obj info) arg0)
  (set! (-> obj rbody) (new 'process 'rigid-body-control obj))
  (collide-shape-method-46 (-> obj root-override-2))
  (rigid-body-method-25
    (-> obj rbody state)
    (the-as rigid-body-info (&-> (-> obj info) mass))
    (-> obj root-override-2 trans)
    (-> obj root-override-2 quat)
    (method-of-object obj rigid-body-object-method-29)
    )
  (rigid-body-object-method-35 obj)
  (set! (-> obj max-time-step) (-> arg0 max-time-step))
  (set! (-> obj root-override-2 max-iteration-count) (the-as uint 4))
  (let ((v1-15 (-> obj skel root-channel 0)))
    (set! (-> v1-15 num-func) num-func-identity)
    (set! (-> v1-15 frame-num) 0.0)
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-32 rigid-body-object ((obj rigid-body-object))
  (let ((s5-0 (new 'process 'collide-shape-moving obj (collide-list-enum hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction) nothing)
    (let ((s4-0 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> s4-0 prim-core collide-as) (collide-spec pusher))
      (set! (-> s4-0 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set! (-> s4-0 transform-index) 3)
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 12288.0)
      (set! (-> s5-0 total-prims) (the-as uint 1))
      (set! (-> s5-0 root-prim) s4-0)
      )
    (collide-shape-method-54 s5-0)
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-16 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-16 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-16 prim-core collide-with))
      )
    (set! (-> obj root-override-2) s5-0)
    )
  0
  (none)
  )

(define *rigid-body-object-constants* (new 'static 'rigid-body-object-constants
                                        :mass 2.0
                                        :inv-mass 0.5
                                        :cm-joint-w 1.0
                                        :linear-damping 1.0
                                        :angular-damping 1.0
                                        :bounce-factor 0.5
                                        :friction-factor 0.1
                                        :inertial-tensor-x (meters 4)
                                        :inertial-tensor-y (meters 4)
                                        :inertial-tensor-z (meters 4)
                                        :max-time-step 0.033333335
                                        :gravity (meters 80)
                                        :idle-distance (meters 50)
                                        :attack-force-scale 1.0
                                        :name '*rigid-body-object-constants*
                                        )
        )

(defmethod rigid-body-object-method-33 rigid-body-object ((obj rigid-body-object))
  (rigid-body-object-method-31 obj *rigid-body-object-constants*)
  0
  (none)
  )

(defmethod init-from-entity! rigid-body-object ((obj rigid-body-object) (arg0 entity-actor))
  (rigid-body-object-method-32 obj)
  (process-drawable-from-entity! obj arg0)
  (rigid-body-object-method-33 obj)
  (rigid-body-object-method-34 obj)
  0
  (none)
  )

(defmethod rigid-body-object-method-36 rigid-body-object ()
  0
  (none)
  )

(defmethod rigid-body-object-method-37 rigid-body-object ((obj rigid-body-object))
  (rigid-body-object-method-30 obj)
  ((method-of-object obj rigid-body-object-method-36))
  (let ((v1-4 (-> obj rbody))
        (a1-0 (-> obj root-override-2))
        )
    (rigid-body-method-11 (-> v1-4 state) a1-0)
    )
  (transform-post)
  0
  (none)
  )

(defmethod rigid-body-object-method-40 rigid-body-object ((obj rigid-body-object))
  (logior! (-> obj flags) (rigid-body-object-flag enable-collision))
  (let ((v1-3 (-> obj root-override-2 root-prim)))
    (set! (-> v1-3 prim-core collide-as) (-> obj root-override-2 backup-collide-as))
    (set! (-> v1-3 prim-core collide-with) (-> obj root-override-2 backup-collide-with))
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-41 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj flags) (rigid-body-object-flag enable-collision))
  (let ((v1-3 (-> obj root-override-2 root-prim)))
    (set! (-> v1-3 prim-core collide-as) (collide-spec))
    (set! (-> v1-3 prim-core collide-with) (collide-spec))
    )
  0
  0
  (none)
  )

(defmethod rigid-body-object-method-38 rigid-body-object ((obj rigid-body-object))
  (when (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
    (logior! (-> obj rbody state flags) (rigid-body-flag enable-physics))
    (rigid-body-method-26 (-> obj rbody state) (-> obj root-override-2 trans) (-> obj root-override-2 quat))
    (vector-float*! (-> obj rbody state lin-momentum) (-> obj root-override-2 transv) (-> obj info mass))
    (vector-reset! (-> obj rbody state ang-momentum))
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-39 rigid-body-object ((obj rigid-body-object))
  (logclear! (-> obj rbody state flags) (rigid-body-flag enable-physics))
  0
  (none)
  )

(defmethod rigid-body-object-method-42 rigid-body-object ((obj rigid-body-object))
  (logior! (-> obj flags) (rigid-body-object-flag disturbed))
  (set! (-> obj disturbed-time) (-> self clock frame-counter))
  (if (not (logtest? (-> obj rbody state flags) (rigid-body-flag enable-physics)))
      (rigid-body-object-method-38 obj)
      )
  0
  (none)
  )

(defmethod rigid-body-object-method-43 rigid-body-object ((obj rigid-body-object))
  (go (method-of-object obj active))
  0
  (none)
  )

(defmethod rigid-body-object-method-44 rigid-body-object ((obj rigid-body-object) (arg0 float))
  0
  (none)
  )

(defmethod rigid-body-object-method-45 rigid-body-object ()
  0
  (none)
  )

(defmethod rigid-body-object-method-49 rigid-body-object ((obj rigid-body-object) (arg0 matrix) (arg1 touching-shapes-entry))
  (set! (-> arg0 trans z) (the-as float #f))
  (set! (-> arg0 trans w) 0.0)
  (vector-reset! (-> arg0 vector 1))
  (vector-reset! (-> arg0 vector 2))
  (set! (-> arg0 vector 0 quad) (-> obj root-override-2 trans quad))
  (when arg1
    (let ((s3-0 (-> arg1 head)))
      (when s3-0
        (get-intersect-point (the-as vector (-> arg0 vector)) s3-0 (-> obj root-override-2) arg1)
        (let ((s5-1 (touching-prims-entry-method-10 s3-0 (-> obj root-override-2) arg1)))
          (when s5-1
            (set! (-> arg0 trans w) (the-as float (-> s5-1 prim-id)))
            (vector-! (-> arg0 vector 1) (the-as vector (-> arg0 vector)) (the-as vector (-> s5-1 prim-core)))
            (vector-normalize! (-> arg0 vector 1) 1.0)
            (vector+float*!
              (the-as vector (-> arg0 vector))
              (the-as vector (-> s5-1 prim-core))
              (-> arg0 vector 1)
              (-> s5-1 prim-core world-sphere w)
              )
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod rigid-body-object-method-47 rigid-body-object ((obj rigid-body-object) (arg0 process-drawable) (arg1 attack-info) (arg2 object) (arg3 penetrate))
  (local-vars (f0-2 float))
  (when arg2
    (let ((s5-0 (new 'stack-no-clear 'matrix)))
      (rigid-body-object-method-49 obj s5-0 (the-as touching-shapes-entry arg2))
      (if (logtest? (attack-info-mask attacker-velocity) (-> arg1 mask))
          (set! (-> s5-0 vector 2 quad) (-> arg1 attacker-velocity quad))
          (vector-! (-> s5-0 vector 2) (the-as vector (-> s5-0 vector)) (-> arg0 root trans))
          )
      0.0
      0.0
      (let ((f1-0 (cond
                    ((logtest? (penetrate enemy-yellow-shot) arg3)
                     (set! f0-2 8192.0)
                     0.025
                     )
                    ((logtest? (penetrate jak-yellow-shot jak-blue-shot) arg3)
                     (set! f0-2 8192.0)
                     0.05
                     )
                    ((logtest? (penetrate jak-red-shot) arg3)
                     (set! f0-2 16384.0)
                     0.05
                     )
                    ((logtest? (penetrate explode jak-dark-shot enemy-dark-shot) arg3)
                     (set! f0-2 81920.0)
                     1.5
                     )
                    ((logtest? arg3 (penetrate punch))
                     (set! f0-2 40960.0)
                     0.1
                     )
                    ((logtest? arg3 (penetrate flop spin))
                     (set! f0-2 20480.0)
                     0.05
                     )
                    (else
                      (set! f0-2 8192.0)
                      0.01
                      )
                    )
                  )
            )
        (set! (-> s5-0 trans x) (* f0-2 (-> obj info attack-force-scale)))
        (rigid-body-object-method-44 obj (* 0.667 f1-0))
        )
      (rigid-body-object-method-42 obj)
      (let ((s4-1 (new 'stack-no-clear 'vector)))
        (set! (-> s4-1 quad) (-> s5-0 vector 2 quad))
        (vector-normalize! s4-1 1.0)
        (vector-float*! s4-1 s4-1 (-> s5-0 trans x))
        (let ((v1-46 (-> obj rbody))
              (a1-6 (-> s5-0 vector))
              (a2-3 s4-1)
              )
          (rigid-body-method-18 (-> v1-46 state) (the-as vector a1-6) a2-3)
          )
        (let ((v1-49 (-> obj rbody))
              (f0-7 1.0)
              )
          (rigid-body-method-12 (-> v1-49 state) f0-7)
          )
        (rigid-body-method-13 (-> obj rbody state))
        (when #t
          (add-debug-x #t (bucket-id debug-no-zbuf1) (the-as vector (-> s5-0 vector)) *color-blue*)
          (add-debug-vector
            #t
            (bucket-id debug-no-zbuf1)
            (the-as vector (-> s5-0 vector))
            s4-1
            (meters 0.00024414062)
            *color-blue*
            )
          )
        )
      )
    ((method-of-object obj rigid-body-object-method-45))
    (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
        (rigid-body-object-method-43 obj)
        )
    #t
    )
  )

;; ERROR: function was not converted to expressions. Cannot decompile.

(defmethod rigid-body-object-method-46 rigid-body-object ((obj rigid-body-object) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('impact-impulse)
     (-> arg3 param 0)
     (if (!= obj arg0)
         (rigid-body-object-method-42 obj)
         )
     ((method-of-object obj rigid-body-object-method-45))
     (if (and (-> obj next-state) (= (-> obj next-state name) 'idle))
         (rigid-body-object-method-43 obj)
         )
     )
    (('touched)
     (if (= obj *debug-actor*)
         (format *stdcon* "rigid-body-object got touched~%")
         )
     (when (zero? (-> arg0 rbody))
       (let ((s3-0 (if (type? arg0 process-focusable)
                       arg0
                       )
                   )
             )
         (when s3-0
           (when (logtest? (-> s3-0 mask) (process-mask target))
             (logior! (-> obj flags) (rigid-body-object-flag player-touching))
             (set! (-> obj player-touch-time) (-> self clock frame-counter))
             (rigid-body-object-method-42 obj)
             )
           (if (not (logtest? (-> s3-0 mask) (process-mask target)))
               (rigid-body-object-method-48 obj s3-0 (-> arg3 param 0))
               )
           )
         )
       )
     )
    (('attack)
     (let ((s3-1 (the-as attack-info (-> arg3 param 1)))
           (t0-1 (get-penetrate-using-from-attack-event arg0 arg3))
           )
       (when (!= (-> s3-1 id) (-> obj incoming-attack-id))
         (set! (-> obj incoming-attack-id) (-> s3-1 id))
         (rigid-body-object-method-47 obj arg0 s3-1 (-> arg3 param 0) t0-1)
         )
       )
     )
    (('edge-grabbed 'pilot-edge-grab)
     (let ((s5-2 (the-as object (-> arg3 param 0))))
       (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force)))
         (let ((a0-25 (if (type? arg0 process-focusable)
                          (the-as process-focusable arg0)
                          )
                      )
               )
           (when a0-25
             (let ((f0-1 (/ 163840.0 (process-focusable-method-26 a0-25))))
               (logior! (-> obj flags) (rigid-body-object-flag player-touching player-edge-grabbing player-contact-force))
               (set! (-> obj player-force-position quad) (-> (the-as attack-info s5-2) attacker-velocity quad))
               (vector-reset! (-> obj player-force))
               (set! (-> obj player-force y) (* -1.0 f0-1))
               )
             )
           )
         )
       )
     (zero? (logand (-> obj focus-status) (focus-status dead inactive)))
     )
    (('ridden)
     (let ((v1-45 (the-as object (-> arg3 param 0))))
       (when (the-as uint v1-45)
         (let* ((s5-3 (handle->process (-> (the-as focus v1-45) handle)))
                (a0-34 (if (type? s5-3 process-focusable)
                           (the-as process-focusable s5-3)
                           )
                       )
                )
           (when (and a0-34
                      (logtest? (-> a0-34 mask) (process-mask target))
                      (zero? (logand (-> a0-34 focus-status) (focus-status on-water under-water)))
                      )
             (when (not (logtest? (-> obj flags) (rigid-body-object-flag player-impulse-force)))
               (logior! (-> obj flags) (rigid-body-object-flag player-touching player-standing-on player-contact-force))
               (set! (-> obj player-force-position quad) (-> a0-34 root-override trans quad))
               (vector-reset! (-> obj player-force))
               (let ((f0-4 (/ 163840.0 (process-focusable-method-26 a0-34)))
                     (f1-1 1.0)
                     )
                 (set! (-> obj player-force y) (* -1.0 f0-4 f1-1))
                 )
               )
             )
           )
         )
       )
     )
    (('bonk)
     (when #t
       (let ((a0-38 (if (type? arg0 process-focusable)
                        (the-as process-focusable arg0)
                        )
                    )
             )
         (when a0-38
           (logior! (-> obj flags) (rigid-body-object-flag player-touching player-impulse-force))
           (set! (-> obj player-force-position quad) (-> a0-38 root-override trans quad))
           (let ((f30-2 (* 0.00012207031 (the-as float (-> arg3 param 1))))
                 (f0-9 (/ 163840.0 (process-focusable-method-26 a0-38)))
                 )
             (vector-reset! (-> obj player-force))
             (set! (-> obj player-force y) (* -0.1 f0-9 f30-2))
             )
           )
         )
       )
     )
    (('enable-physics)
     (rigid-body-object-method-42 obj)
     )
    )
  (none)
  )

(defbehavior rigid-body-object-event-handler rigid-body-object ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (rigid-body-object-method-46 self (the-as process-drawable arg0) arg1 arg2 arg3)
  (none)
  )

(defstate idle (rigid-body-object)
  :virtual #t
  :trans (behavior ()
    (if (and *target* (and (>= (-> self info idle-distance)
                               (vector-vector-distance (-> self root-override-2 trans) (-> *target* control trans))
                               )
                           (zero? (logand (focus-status teleporting) (-> *target* focus-status)))
                           )
             )
        (go-virtual active)
        )
    (none)
    )
  :code (the-as (function none :behavior rigid-body-object) sleep-code)
  :post (the-as (function none :behavior rigid-body-object) ja-post)
  )

(defstate active (rigid-body-object)
  :virtual #t
  :event (the-as
    (function process int symbol event-message-block object :behavior rigid-body-object)
    rigid-body-object-event-handler
    )
  :trans (behavior ()
    (if (or (not *target*)
            (or (< (+ 4096.0 (-> self info idle-distance))
                   (vector-vector-distance (-> self root-override-2 trans) (-> *target* control trans))
                   )
                (logtest? (focus-status teleporting) (-> *target* focus-status))
                )
            )
        (go-virtual idle)
        )
    (none)
    )
  :code (the-as (function none :behavior rigid-body-object) sleep-code)
  :post (behavior ()
    (rigid-body-object-method-37 self)
    (none)
    )
  )
