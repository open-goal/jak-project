;;-*-Lisp-*-
(in-package goal)

;; name: enemy.gc
;; name in dgo: enemy
;; dgos: GAME, COMMON

;; DECOMP BEGINS

(defmethod copy-enemy-info! enemy-info ((obj enemy-info) (obj-to-copy enemy-info))
  "Copies the given [[enemy-info]] into the current [[enemy-info]]"
  (mem-copy! (&-> obj type) (&-> obj-to-copy type) 384)
  0
  (none)
  )

(define *enemy-dummy-shadow-control*
  (new 'static 'shadow-control :settings (new 'static 'shadow-settings
                                           :flags (shadow-flags shdf03 disable-draw)
                                           :shadow-dir (new 'static 'vector :y -1.0 :w 614400.0)
                                           :bot-plane (new 'static 'plane :y 1.0 :w 4096.0)
                                           :top-plane (new 'static 'plane :y 1.0 :w -4096.0)
                                           )
                               )
  )

;; WARN: Return type mismatch process-focusable vs enemy.
(defmethod relocate enemy ((obj enemy) (arg0 int))
  (if (nonzero? (-> obj neck))
      (&+! (-> obj neck) arg0)
      )
  (the-as
    enemy
    ((the-as (function process-focusable int process-focusable) (find-parent-method enemy 7)) obj arg0)
    )
  )

(defmethod get-rand-float enemy ((obj enemy))
  "@returns the result of calling [[rand-vu]]"
  (rand-vu)
  )

(defmethod get-rand-float-range enemy ((obj enemy) (low float) (high float))
  "@param low The lower bound of the range (inclusive)
@param high The upper bound of the range (exclusive)
@returns A random float in the specified range"
  (+ low (* (rand-vu) (- high low)))
  )

(defmethod get-rand-int enemy ((obj enemy) (high int))
  "@param high The upper bound of the range (exclusive)
@returns a random integer in the range 0 to `high`
@see [[rand-vu]]"
  (the int (* (rand-vu) (the float high)))
  )

(defmethod get-rand-int-range enemy ((obj enemy) (low int) (high int))
  "@param low The lower bound of the range (inclusive)
@param high The upper bound of the range (exclusive)
@returns A random integer in the specified range"
  (+ low (the int (* (rand-vu) (the float (+ (- 1 low) high)))))
  )

(defmethod rng-hit? enemy ((obj enemy) (chance float))
  "TODO - not the best name
@param chance The value to compare ([[>=]]) with the result from [[rand-vu]].
@returns If `chance` is greater than the random draw"
  (>= chance (rand-vu))
  )

;; WARN: new jak 2 until loop case, check carefully
(defmethod enemy-method-120 enemy ((obj enemy) (arg0 int) (arg1 int))
  "TODO"
  (let ((v1-0 0)
        (s5-0 0)
        )
    (let ((a2-1 1))
      (while (nonzero? arg0)
        (+! arg0 -1)
        (if (not (logtest? arg1 a2-1))
            (+! v1-0 1)
            )
        (set! a2-1 (* a2-1 2))
        )
      )
    (when (> v1-0 0)
      (let ((v1-1 (get-rand-int obj v1-0))
            (a0-1 1)
            )
        (until #f
          (while (logtest? arg1 a0-1)
            (nop!)
            (nop!)
            (+! s5-0 1)
            (set! a0-1 (* a0-1 2))
            )
          (if (zero? v1-1)
              (goto cfg-14)
              )
          (+! v1-1 -1)
          (+! s5-0 1)
          (set! a0-1 (* a0-1 2))
          )
        )
      #f
      )
    (label cfg-14)
    s5-0
    )
  )

(defmethod enemy-method-123 enemy ((obj enemy) (arg0 float))
  "TODO"
  (let* ((v1-5 (-> *display* frames (-> *display* last-screen) run-time))
         (f1-2 (fmax 0.0 (fmin 1.0 (* 0.001 (+ -7000.0 (the float v1-5))))))
         )
    (>= (+ arg0 (* f1-2 (- 1.0 arg0))) (rand-vu))
    )
  )

(defmethod coin-flip? enemy ((obj enemy))
  "@returns The result of a 50/50 RNG roll"
  (zero? (get-rand-int obj 2))
  )

;; WARN: disable def twice: 40. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod run-logic? enemy ((obj enemy))
  (cond
    ((logtest? (-> obj mask) (process-mask actor-pause))
     (let ((draw (-> obj draw)))
       (or (and (nonzero? draw)
                (>= (+ (-> *ACTOR-bank* pause-dist) (-> obj root-override2 pause-adjust-distance))
                    (vector-vector-distance (-> obj root-override2 trans) (camera-pos))
                    )
                (or (logtest? (-> draw status) (draw-control-status on-screen))
                    (not (and (-> obj next-state) (= (-> obj next-state name) 'idle)))
                    )
                )
           (and (nonzero? (-> obj skel)) (!= (-> obj skel root-channel 0) (-> obj skel channel)))
           (and (nonzero? draw) (logtest? (-> draw status) (draw-control-status uninited)))
           )
       )
     )
    (else
      #t
      )
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defmethod enemy-method-53 enemy ((obj enemy) (proc-focus process-focusable))
  "TODO"
  (the-as symbol (and proc-focus (!= obj proc-focus) (collide-check? (-> obj focus) proc-focus)))
  )

(defmethod get-trans enemy ((obj enemy) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (let ((s4-0 (-> obj root-override2)))
    (cond
      ((zero? arg0)
       (-> s4-0 trans)
       )
      ((and (= arg0 1) (type? s4-0 collide-shape-moving))
       (-> s4-0 gspot-pos)
       )
      ((= arg0 2)
       (vector<-cspace! (new 'static 'vector) (-> obj node-list data (-> obj enemy-info look-at-joint)))
       )
      ((= arg0 3)
       (let ((v0-0 (vector<-cspace! (new 'static 'vector) (-> obj node-list data (-> obj enemy-info bullseye-joint)))))
         (set! (-> v0-0 w) (-> obj root-override2 root-prim prim-core world-sphere w))
         v0-0
         )
       )
      (else
        (-> s4-0 trans)
        )
      )
    )
  )

(defmethod enemy-method-124 enemy ((obj enemy))
  "TODO"
  (let* ((v1-0 (-> obj enemy-info))
         (v0-0 (if (logtest? (enemy-flag use-trigger) (-> obj enemy-flags))
                   (-> v1-0 recover-gnd-collide-with)
                   (-> v1-0 gnd-collide-with)
                   )
               )
         )
    (set! (-> obj gnd-collide) (the-as uint v0-0))
    v0-0
    )
  )

(defmethod get-penetrate-info enemy ((obj enemy))
  "@returns the allowed way(s) this enemy can take damage
@see [[penetrate]] and [[penetrated-by-all&hit-points->penetrated-by]]"
  (penetrated-by-all&hit-points->penetrated-by (-> obj penetrated-by-all) (-> obj hit-points))
  )

(defmethod get-water-height enemy ((obj enemy))
  (-> obj water-surface-height)
  )

(defmethod enemy-method-54 enemy ((obj enemy))
  (let ((s4-0 (-> obj root-override2)))
    (when (>= (-> obj water-max-height) (-> s4-0 trans y))
      (let ((s5-0 (new 'stack-no-clear 'water-info)))
        (water-info-init! s4-0 s5-0 (collide-action solid semi-solid))
        (let ((s3-0 (-> s5-0 flags)))
          (when (logtest? (water-flags touch-water) s3-0)
            (set! (-> obj enemy-flags) (logior (enemy-flag directed-ready) (-> obj enemy-flags)))
            (set! (-> obj water-surface-height) (-> s5-0 trans y))
            (when (not (focus-test? obj touch-water under-water))
              (let ((s2-0 (new 'stack-no-clear 'vector)))
                (set! (-> s2-0 quad) (-> obj root-override2 trans quad))
                (set! (-> s2-0 y) (+ 409.6 (-> s5-0 trans y)))
                (let ((s1-0 (get-process *default-dead-pool* part-tracker #x4000)))
                  (when s1-0
                    (let ((t9-2 (method-of-type part-tracker activate)))
                      (t9-2
                        (the-as part-tracker s1-0)
                        *entity-pool*
                        (symbol->string (-> part-tracker symbol))
                        (the-as pointer #x70004000)
                        )
                      )
                    (let ((t9-3 run-function-in-process)
                          (a0-8 s1-0)
                          (a1-3 part-tracker-init)
                          (a2-5 (-> *part-group-id-table* 121))
                          (a3-1 0)
                          (t0-0 #f)
                          (t1-0 #f)
                          (t2-0 #f)
                          (t3-0 *launch-matrix*)
                          )
                      (set! (-> t3-0 trans quad) (-> s2-0 quad))
                      ((the-as (function object object object object object object object object none) t9-3)
                       a0-8
                       a1-3
                       a2-5
                       a3-1
                       t0-0
                       t1-0
                       t2-0
                       t3-0
                       )
                      )
                    (-> s1-0 ppointer)
                    )
                  )
                )
              (cond
                ((logtest? s3-0 (water-flags dark-eco))
                 (sound-play "eco-splash")
                 (send-event obj 'instant-death)
                 )
                (else
                  (sound-play "splash")
                  )
                )
              )
            (logior! (-> obj focus-status) (focus-status touch-water))
            (let* ((v1-32 (-> s4-0 root-prim prim-core))
                   (f0-5 (+ (-> v1-32 world-sphere y) (-> v1-32 world-sphere w)))
                   )
              (if (focus-test? obj under-water)
                  (set! f0-5 (+ -819.2 f0-5))
                  )
              (if (< f0-5 (-> s5-0 trans y))
                  (logior! (-> obj focus-status) (focus-status under-water))
                  (logclear! (-> obj focus-status) (focus-status under-water))
                  )
              )
            (return (the-as enemy-flag #f))
            )
          )
        )
      )
    )
  (logclear! (-> obj focus-status) (focus-status touch-water under-water))
  (when (not (logtest? (enemy-flag use-trigger) (-> obj enemy-flags)))
    (let ((v0-9 (logclear (-> obj enemy-flags) (enemy-flag directed-ready))))
      (set! (-> obj enemy-flags) v0-9)
      v0-9
      )
    )
  )

(defmethod track-target! enemy ((self enemy))
  "Does a lot of various things relating to interacting with the target
- tracks when the enemy was last drawn
- looks at the target and handles attacking
@TODO Not extremely well understood yet"
  (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
      (set! (-> self last-draw-time) (current-time))
      )
  (enemy-method-129 self)
  (if (logtest? (enemy-flag use-trigger) (-> self enemy-flags))
      (enemy-method-100 self)
      )
  (when *target*
    (target-look-at-me! :trans (the-as vector (-> self root-override2 root-prim prim-core))
                        :message (if (logtest? (-> self enemy-flags) (enemy-flag use-notice-distance))
                                      'attacking
                                      ))
    )
  (when (nonzero? (-> self neck))
    (when (logtest? (-> self enemy-flags) (enemy-flag lock-focus))
      (let ((a0-9 (handle->process (-> self focus handle))))
        (if a0-9
            (target-set! (-> self neck) (get-trans (the-as process-focusable a0-9) 2))
            )
        )
      )
    )
  (when (and (logtest? (-> self enemy-flags) (enemy-flag attackable-backup))
             (>= (- (current-time) (-> self auto-reset-penetrate-time)) (seconds 0.1))
             )
    (logclear! (-> self enemy-flags) (enemy-flag attackable-backup))
    (set! (-> self root-override2 penetrated-by) (get-penetrate-info self))
    (let ((v1-48 0))
      (if (logtest? (penetrate knocked) (-> self root-override2 penetrate-using))
          (set! v1-48 (logior (shl 1 32) v1-48))
          )
      (set! (-> self root-override2 penetrate-using) (the-as penetrate v1-48))
      )
    )
  (if (logtest? (-> self enemy-flags) (enemy-flag look-at-focus))
      (enemy-method-136 self)
      )
  (if (logtest? (enemy-flag trackable-backup directed-ready) (-> self enemy-flags))
      (enemy-method-54 self)
      )
  (if (and *debug-segment* (-> self enemy-info debug-draw-neck) (nonzero? (-> self neck)))
      (joint-mod-debug-draw (-> self neck))
      )
  (ja-post)
  0
  (none)
  )

(defmethod enemy-method-136 enemy ((obj enemy))
  (when (or (>= (- (current-time) (-> obj hit-focus-time)) (seconds 2))
            (and (handle->process (-> obj focus handle))
                 (not (logtest? (-> (the-as process-focusable (handle->process (-> obj focus handle))) focus-status)
                                (focus-status disable dead ignore grabbed)
                                )
                      )
                 )
            )
    (let ((v0-0 (logclear (-> obj enemy-flags) (enemy-flag look-at-focus))))
      (set! (-> obj enemy-flags) v0-0)
      v0-0
      )
    )
  )

;; WARN: Return type mismatch int vs penetrate.
(defun get-penetrate-using-from-attack-event ((arg0 process-drawable) (arg1 event-message-block))
  (let ((v1-0 (the-as attack-info (-> arg1 param 1))))
    (if (logtest? (attack-info-mask penetrate-using) (-> v1-0 mask))
        (return (the-as penetrate (-> v1-0 penetrate-using)))
        )
    )
  (let* ((gp-0 arg0)
         (v1-3 (if (type? gp-0 process-drawable)
                   gp-0
                   )
               )
         )
    (when v1-3
      (let* ((gp-1 (-> v1-3 root))
             (v1-4 (if (type? gp-1 collide-shape)
                       (the-as collide-shape gp-1)
                       )
                   )
             )
        (if v1-4
            (return (the-as penetrate (logior (-> v1-4 penetrate-using) (penetrate generic-attack))))
            )
        )
      )
    )
  (the-as penetrate 2)
  )

;; WARN: Return type mismatch process vs process-focusable.
(defmethod get-enemy-target enemy ((obj enemy))
  "@returns the [[process-focusable]] that the enemy is currently focusing on, or [[#f]] otherwise"
  (let ((v0-0 (handle->process (-> obj focus handle))))
    (if (and v0-0
             (not (and v0-0
                       (not (logtest? (-> (the-as process-focusable v0-0) focus-status) (focus-status disable dead ignore grabbed)))
                       )
                  )
             )
        (set! v0-0 (the-as process #f))
        )
    (the-as process-focusable v0-0)
    )
  )

(defmethod enemy-method-63 enemy ((obj enemy) (arg0 process-focusable) (arg1 enemy-aware))
  (if arg1
      (enemy-focus-method-13 (-> obj focus) arg0 arg1)
      (try-update-focus (-> obj focus) arg0 obj)
      )
  )

(defmethod enemy-method-62 enemy ((obj enemy))
  (when (not (logtest? (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
    (let* ((s4-0 (handle->process (-> obj incoming attacker-handle)))
           (s5-0 (if (type? s4-0 process-focusable)
                     s4-0
                     )
                 )
           )
      (when (enemy-method-53 obj (the-as process-focusable s5-0))
        (enemy-method-63 obj (the-as process-focusable s5-0) (the-as enemy-aware #f))
        (logior! (-> obj focus flags) (enemy-flag lock-focus))
        )
      )
    )
  0
  (none)
  )

(defmethod enemy-method-108 enemy ((obj enemy) (arg0 enemy) (arg1 event-message-block))
  (let ((s4-0 (the-as touching-shapes-entry (-> arg1 param 0))))
    (when (and s4-0
               (and (logtest? (-> obj incoming penetrate-using) 4096) (not (logtest? (-> obj incoming penetrate-using) 32)))
               (begin
                 (let ((s3-0 (-> s4-0 head)))
                   (while s3-0
                     (let ((s2-0 (get-touched-prim s3-0 (-> arg0 root-override2) s4-0)))
                       (get-touched-prim s3-0 (-> obj root-override2) s4-0)
                       (when (logtest? (-> s2-0 prim-core action) (collide-action solid semi-solid deadly))
                         (let* ((a0-5 obj)
                                (t9-2 (method-of-object a0-5 enemy-method-104))
                                (a1-3 arg0)
                                (a2-3 s4-0)
                                (v1-13 *game-info*)
                                (a3-1 (+ (-> v1-13 attack-id) 1))
                                )
                           (set! (-> v1-13 attack-id) a3-1)
                           (if (t9-2 a0-5 a1-3 a2-3 a3-1)
                               (return 0)
                               )
                           )
                         )
                       )
                     (set! s3-0 (-> s3-0 next))
                     )
                   )
                 #f
                 )
               )
      )
    )
  0
  )

;; WARN: Return type mismatch object vs none.
(defmethod enemy-method-64 enemy ((obj enemy))
  (let ((v1-1 (-> obj root-override2 root-prim)))
    (set! (-> v1-1 prim-core collide-as) (collide-spec))
    (set! (-> v1-1 prim-core collide-with) (collide-spec))
    )
  0
  (logior! (-> obj draw status) (draw-control-status no-draw))
  (logior! (-> obj focus-status) (focus-status disable))
  (go (method-of-object obj dormant))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod enemy-method-65 enemy ((obj enemy))
  (let ((v1-1 (-> obj root-override2 root-prim)))
    (set! (-> v1-1 prim-core collide-as) (collide-spec))
    (set! (-> v1-1 prim-core collide-with) (collide-spec))
    )
  0
  (logior! (-> obj draw status) (draw-control-status no-draw))
  (logior! (-> obj focus-status) (focus-status disable))
  (go (method-of-object obj dormant-aware))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-stare enemy ((obj enemy))
  (go (method-of-object obj stare))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-stare2 enemy ((obj enemy))
  (go (method-of-object obj stare))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-hostile enemy ((obj enemy))
  (go (method-of-object obj hostile))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-ambush enemy ((obj enemy))
  (go (method-of-object obj ambush))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-flee enemy ((obj enemy))
  (go (method-of-object obj flee))
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-directed enemy ((obj enemy))
  (go (method-of-object obj directed))
  (none)
  )

(defmethod react-to-focus enemy ((obj enemy))
  "@TODO - flesh out docs"
  (let ((s5-0 (-> obj focus aware)))
    (cond
      ((and (= s5-0 (enemy-aware enemy-aware-3)) (get-enemy-target obj))
       (go-hostile obj)
       )
      ((<= (the-as int s5-0) 0)
       (go (method-of-object obj idle))
       )
      ((>= 1 (the-as int s5-0))
       (go (method-of-object obj active))
       )
      ((= s5-0 (enemy-aware unaware))
       (go-flee obj)
       )
      (else
        (go-stare obj)
        )
      )
    )
  (none)
  )

(defmethod enemy-method-93 enemy ((obj enemy))
  (if (logtest? (enemy-flag alert) (-> obj enemy-flags))
      (go-directed obj)
      (react-to-focus obj)
      )
  (none)
  )

(defmethod kill-prefer-falling enemy ((obj enemy))
  "If available in `enemy-info`, [[go]] to the [[die-falling]] state, if not, [[die]]"
  (if (-> obj enemy-info use-die-falling)
      (go (method-of-object obj die-falling))
      (go (method-of-object obj die))
      )
  )

(defmethod enemy-method-135 enemy ((obj enemy) (arg0 int))
  (let ((gp-0 (make-u128 0 0)))
    (let ((v1-0 arg0))
      (cond
        ((zero? v1-0)
         (set! gp-0 (the-as uint (-> obj enemy-info sound-hit)))
         )
        ((= v1-0 1)
         (set! gp-0 (the-as uint (-> obj enemy-info sound-die)))
         )
        )
      )
    (if (nonzero? gp-0)
        (sound-play-by-name (the-as sound-name gp-0) (new-sound-id) 1024 0 0 (sound-group sfx) #t)
        )
    )
  )

(defmethod enemy-method-94 enemy ((obj enemy) (arg0 vector) (arg1 float))
  (let ((s4-0 (vector-z-quaternion! (new 'stack-no-clear 'vector) (-> obj root-override2 quat)))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (set! (-> s5-0 quad) (-> arg0 quad))
    (set! (-> s4-0 y) 0.0)
    (vector-normalize! s4-0 1.0)
    (set! (-> s5-0 y) 0.0)
    (vector-normalize! s5-0 1.0)
    (>= (vector-dot s4-0 s5-0) (cos arg1))
    )
  )

(defmethod enemy-method-95 enemy ((obj enemy) (arg0 vector) (arg1 float))
  (let ((v1-1 (vector-! (new 'stack-no-clear 'vector) arg0 (-> obj root-override2 trans))))
    (enemy-method-94 obj v1-1 arg1)
    )
  )

(defmethod enemy-method-96 enemy ((obj enemy) (arg0 float) (arg1 symbol))
  (let ((a0-2 (handle->process (-> obj focus handle))))
    (cond
      (a0-2
        (let ((s4-1 (vector-!
                      (new 'stack-no-clear 'vector)
                      (get-trans (the-as process-focusable a0-2) 0)
                      (-> obj root-override2 trans)
                      )
                    )
              )
          (enemy-method-94 obj s4-1 arg0)
          )
        )
      (else
        arg1
        )
      )
    )
  )

(defmethod enemy-method-104 enemy ((obj enemy) (arg0 process) (arg1 touching-shapes-entry) (arg2 uint))
  (let ((v1-1 (-> obj enemy-info attack-damage)))
    (if (and (logtest? (-> *game-info* secrets) (game-secrets hero-mode)) (= v1-1 1))
        (set! v1-1 2)
        )
    (let ((a1-2 (new 'stack-no-clear 'event-message-block)))
      (set! (-> a1-2 from) (process->ppointer self))
      (set! (-> a1-2 num-params) 2)
      (set! (-> a1-2 message) 'attack)
      (set! (-> a1-2 param 0) (the-as uint arg1))
      (let ((a0-10 (new 'static 'attack-info :mask (attack-info-mask mode shove-back shove-up id damage knock))))
        (set! (-> a0-10 id) arg2)
        (set! (-> a0-10 shove-back) (-> obj enemy-info attack-shove-back))
        (set! (-> a0-10 shove-up) (-> obj enemy-info attack-shove-up))
        (set! (-> a0-10 mode) (-> obj enemy-info attack-mode))
        (set! (-> a0-10 damage) (the float v1-1))
        (set! (-> a0-10 knock) (the-as uint 8))
        (set! (-> a1-2 param 1) (the-as uint a0-10))
        )
      (when (send-event-function arg0 a1-2)
        (enemy-method-105 obj arg0)
        #t
        )
      )
    )
  )

(defmethod enemy-method-105 enemy ((obj enemy) (arg0 process))
  (when (logtest? (process-mask target bot) (-> arg0 mask))
    (set! (-> obj root-override2 penetrated-by) (the-as penetrate -1))
    (enemy-method-49 obj)
    )
  (let ((s5-0 (if (type? arg0 process-focusable)
                  arg0
                  )
              )
        )
    (when (enemy-method-53 obj (the-as process-focusable s5-0))
      (let ((v1-10 (handle->process (-> obj focus handle))))
        (when (or (= s5-0 v1-10) (and (not (logtest? (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
                                      (or (not v1-10) (not (logtest? (-> obj focus flags) (enemy-flag lock-focus))))
                                      )
                  )
          (enemy-method-63 obj (the-as process-focusable s5-0) (the-as enemy-aware #f))
          (set! (-> obj hit-focus-time) (current-time))
          (let ((v0-3 (logior (-> obj enemy-flags) (enemy-flag look-at-focus))))
            (set! (-> obj enemy-flags) v0-3)
            v0-3
            )
          )
        )
      )
    )
  )

(defmethod enemy-method-49 enemy ((obj enemy))
  (logior! (-> obj enemy-flags) (enemy-flag attackable-backup))
  (let ((v0-0 (current-time)))
    (set! (-> obj auto-reset-penetrate-time) v0-0)
    v0-0
    )
  )

(defmethod enemy-method-50 enemy ((obj enemy) (arg0 vector))
  (set! (-> arg0 quad) (-> obj incoming attack-direction quad))
  (let ((v1-1 arg0))
    (when (= (+ (* (-> v1-1 x) (-> v1-1 x)) (* (-> v1-1 z) (-> v1-1 z))) 0.0)
      (vector-z-quaternion! arg0 (-> obj root-override2 quat))
      (vector-negate-in-place! arg0)
      )
    )
  (set! (-> arg0 y) 0.0)
  (vector-xz-normalize! arg0 1.0)
  )

;; WARN: Return type mismatch int vs uint.
(defmethod enemy-method-131 enemy ((obj enemy) (arg0 int))
  (the-as uint (cond
                 ((logtest? arg0 1024)
                  7
                  )
                 ((logtest? #x1000000 arg0)
                  6
                  )
                 ((logtest? #x4400000 arg0)
                  4
                  )
                 ((logtest? #x800000 arg0)
                  5
                  )
                 ((logtest? #xc0000 arg0)
                  3
                  )
                 ((logtest? #xa200000 arg0)
                  2
                  )
                 ((logtest? arg0 #x4000)
                  1
                  )
                 (else
                   0
                   )
                 )
          )
  )

(defmethod enemy-method-106 enemy ((obj enemy) (arg0 process) (arg1 object) (arg2 int) (arg3 attack-info))
  (set! (-> obj incoming penetrate-using) (the-as uint arg2))
  (set! (-> obj incoming attack-id) (-> arg3 id))
  (let ((v1-3 (if (logtest? (attack-info-mask knock) (-> arg3 mask))
                  (-> arg3 knock)
                  (enemy-method-131 obj arg2)
                  )
              )
        )
    (set! (-> obj incoming knocked-type) (the-as knocked-type v1-3))
    (let ((a0-4 (current-time)))
      (cond
        ((!= v1-3 6)
         (set! (-> obj incoming blue-juggle-count) (the-as uint 0))
         0
         )
        ((>= (- (current-time) (-> obj incoming attack-time)) (seconds 1))
         (set! (-> obj incoming blue-juggle-count) (the-as uint 1))
         )
        (else
          (+! (-> obj incoming blue-juggle-count) 1)
          )
        )
      (set! (-> obj incoming attack-time) a0-4)
      )
    (cond
      ((= v1-3 7)
       (set! (-> obj incoming attack-direction quad) (-> arg3 vector quad))
       )
      (else
        (let ((s3-0 (new 'stack-no-clear 'attack-info)))
          (attack-info-method-9 arg3 s3-0 (the-as process-drawable arg0) obj)
          (set! (-> obj incoming attacker-pos quad) (-> s3-0 intersection quad))
          (set! (-> obj incoming attack-direction quad) (-> s3-0 attacker-velocity quad))
          )
        )
      )
    )
  (set! (-> obj incoming attacker-handle) (process->handle (enemy-method-134 obj arg0 arg3)))
  0
  (none)
  )

(defmethod look-at-target! enemy ((obj enemy) (arg0 enemy-flag))
  "Logic for looking at the target that is locked on, sets some flags and adjusts the neck to look at the target if available
@param flag Reacts to [[enemy-flag::death-start]] and [[enemy-flag::enable-on-active]], see implementation for details"
  (case arg0
    (((enemy-flag lock-focus))
     (logclear! (-> obj enemy-flags) (enemy-flag death-start))
     (logior! (-> obj enemy-flags) (enemy-flag lock-focus))
     )
    (((enemy-flag death-start))
     (logclear! (-> obj enemy-flags) (enemy-flag lock-focus))
     (logior! (-> obj enemy-flags) (enemy-flag death-start))
     )
    )
  (if (nonzero? (-> obj neck))
      (mode-set! (-> obj neck) (joint-mod-mode look-at))
      )
  0
  (none)
  )

(defmethod stop-looking-at-target! enemy ((obj enemy))
  "Will unset [[enemy-flag::death-start]] and [[enemy-flag::lock-focus]] and call [[joint-mod::shut-down]] if applicable"
  (when (nonzero? (-> obj neck))
    (logclear! (-> obj enemy-flags) (enemy-flag lock-focus death-start))
    (shut-down (-> obj neck))
    )
  0
  (none)
  )

(defmethod enemy-method-125 enemy ((obj enemy) (arg0 collide-query) (arg1 collide-spec) (arg2 float) (arg3 float) (arg4 float))
  (when (find-ground (-> obj root-override2) arg0 arg1 arg2 arg3 arg4)
    (let ((v0-1 (-> arg0 best-other-tri pat)))
      (set! (-> obj root-override2 ground-pat) v0-1)
      v0-1
      )
    )
  )

(defmethod enemy-above-ground? enemy ((obj enemy) (arg0 collide-query) (arg1 vector) (arg2 collide-spec) (arg3 float) (arg4 float) (arg5 float))
  "@returns if the enemy is above the ground or not
@see [[above-ground?]]"
  (above-ground? (-> obj root-override2) arg0 arg1 arg2 arg3 arg4 arg5)
  )

(defmethod enemy-method-127 enemy ((obj enemy) (arg0 float) (arg1 float) (arg2 symbol) (arg3 collide-spec))
  (let ((s4-0 (new 'stack-no-clear 'collide-query)))
    (cond
      ((enemy-method-125 obj s4-0 arg3 arg0 arg1 1024.0)
       (let ((s5-1 (-> obj root-override2)))
         (let ((s3-0 (new 'stack-no-clear 'vector)))
           (set! (-> s3-0 quad) (-> obj root-override2 trans quad))
           (set! (-> s3-0 y) (-> s4-0 best-other-tri intersect y))
           (move-to-point! s5-1 s3-0)
           (let ((a0-3 (-> s4-0 best-other-tri normal))
                 (v1-8 (-> s4-0 best-other-tri pat))
                 )
             (set! (-> s5-1 grount-touch-point quad) (-> s3-0 quad))
             (set! (-> s5-1 poly-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 surface-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 local-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 ground-poly-normal quad) (-> a0-3 quad))
             (set! (-> s5-1 poly-pat) v1-8)
             (set! (-> s5-1 cur-pat) v1-8)
             (set! (-> s5-1 ground-pat) v1-8)
             )
           )
         (logior! (-> s5-1 status) (collide-status on-surface on-ground touch-surface))
         )
       #t
       )
      (else
        (let ((v1-11 (-> obj root-override2)))
          (logclear! (-> v1-11 status) (collide-status
                                         on-surface
                                         on-ground
                                         touch-surface
                                         touch-wall
                                         touch-ceiling
                                         touch-actor
                                         on-special-surface
                                         touch-edge
                                         blocked
                                         on-water
                                         impact-surface
                                         touch-background
                                         stuck
                                         glance
                                         )
                     )
          (when (not (logtest? (-> v1-11 root-prim prim-core action) (collide-action no-normal-reset)))
            (let ((a0-12 (-> v1-11 dynam gravity-normal)))
              (set! (-> v1-11 local-normal quad) (-> a0-12 quad))
              (set! (-> v1-11 surface-normal quad) (-> a0-12 quad))
              (set! (-> v1-11 poly-normal quad) (-> a0-12 quad))
              )
            (set! (-> v1-11 coverage) 0.0)
            (set! (-> v1-11 touch-angle) 0.0)
            )
          )
        (if arg2
            (format 0 "WARNING: enemy::move-to-ground: failed to locate ground for ~S!~%" (-> obj name))
            )
        #f
        )
      )
    )
  )

(defmethod enemy-method-128 enemy ((obj enemy) (arg0 vector) (arg1 move-above-ground-params))
  (let ((gp-0 (-> obj root-override2)))
    (set! (-> arg1 on-ground?) #f)
    (set! (-> arg1 do-move?) #t)
    (set! (-> arg1 old-gspot-pos quad) (-> gp-0 gspot-pos quad))
    (set! (-> arg1 old-gspot-normal quad) (-> gp-0 gspot-normal quad))
    (set! (-> gp-0 trans-old-old-old quad) (-> gp-0 trans-old-old quad))
    (set! (-> gp-0 trans-old-old quad) (-> gp-0 trans-old quad))
    (set! (-> gp-0 trans-old quad) (-> gp-0 trans quad))
    (set! (-> gp-0 prev-status) (-> gp-0 status))
    (vector-v+! (-> gp-0 trans) (-> gp-0 trans) arg0)
    (set! (-> arg1 new-pos quad) (-> gp-0 trans quad))
    (let ((s2-0 (new 'stack-no-clear 'collide-query)))
      (cond
        ((enemy-method-125 obj s2-0 (-> arg1 gnd-collide-with) (-> arg1 popup) 81920.0 1024.0)
         (when (>= (-> gp-0 gspot-pos y) (-> arg1 new-pos y))
           (set! (-> arg1 on-ground?) #t)
           (set! (-> arg1 pat) (-> s2-0 best-other-tri pat))
           (set! (-> arg1 new-pos y) (-> s2-0 best-other-tri intersect y))
           (set! (-> gp-0 ground-impact-vel) (- (vector-dot arg0 (-> gp-0 dynam gravity-normal))))
           (set! (-> arg0 y) 0.0)
           )
         )
        (else
          (if (-> arg1 hover-if-no-ground?)
              (set! (-> arg1 new-pos y) (-> gp-0 trans-old y))
              )
          )
        )
      )
    (set! (-> gp-0 trans quad) (-> gp-0 trans-old quad))
    (move-to-point! gp-0 (-> arg1 new-pos))
    (when (logtest? (logand (-> arg1 overlaps-params collide-with-filter)
                            (collide-spec hit-by-player-list hit-by-others-list player-list)
                            )
                    (-> gp-0 root-prim prim-core collide-with)
                    )
      (when (find-overlapping-shapes gp-0 (-> arg1 overlaps-params))
        (when (-> arg1 dont-move-if-overlaps?)
          (set! (-> arg1 do-move?) #f)
          (move-to-point! gp-0 (-> gp-0 trans-old))
          (set! (-> gp-0 gspot-pos quad) (-> arg1 old-gspot-pos quad))
          (set! (-> gp-0 gspot-normal quad) (-> arg1 old-gspot-normal quad))
          )
        )
      )
    (when (-> arg1 do-move?)
      (cond
        ((-> arg1 on-ground?)
         (let ((a1-6 (-> gp-0 gspot-pos))
               (a0-21 (-> gp-0 gspot-normal))
               (v1-39 (-> arg1 pat))
               )
           (set! (-> gp-0 grount-touch-point quad) (-> a1-6 quad))
           (set! (-> gp-0 poly-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 surface-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 local-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 ground-poly-normal quad) (-> a0-21 quad))
           (set! (-> gp-0 poly-pat) v1-39)
           (set! (-> gp-0 cur-pat) v1-39)
           (set! (-> gp-0 ground-pat) v1-39)
           )
         (logior! (-> gp-0 status) (collide-status on-surface on-ground touch-surface))
         )
        (else
          (logclear! (-> gp-0 status) (collide-status
                                        on-surface
                                        on-ground
                                        touch-surface
                                        touch-wall
                                        touch-ceiling
                                        touch-actor
                                        on-special-surface
                                        touch-edge
                                        blocked
                                        on-water
                                        impact-surface
                                        touch-background
                                        stuck
                                        glance
                                        )
                     )
          (when (not (logtest? (-> gp-0 root-prim prim-core action) (collide-action no-normal-reset)))
            (let ((v1-49 (-> gp-0 dynam gravity-normal)))
              (set! (-> gp-0 local-normal quad) (-> v1-49 quad))
              (set! (-> gp-0 surface-normal quad) (-> v1-49 quad))
              (set! (-> gp-0 poly-normal quad) (-> v1-49 quad))
              )
            (set! (-> gp-0 coverage) 0.0)
            (set! (-> gp-0 touch-angle) 0.0)
            )
          )
        )
      )
    )
  0
  (none)
  )

(defmethod enemy-method-111 enemy ((obj enemy))
  (let ((v1-0 (-> obj root-override2)))
    (when (logtest? (-> v1-0 status) (collide-status touch-surface))
      (let ((f0-1 (fmax 0.0 (+ 1.0 (* 60.0 (-> self clock seconds-per-frame) (+ -1.0 (-> obj enemy-info friction)))))))
        (vector-float*! (-> v1-0 transv) (-> v1-0 transv) f0-1)
        )
      0
      )
    )
  0
  (none)
  )

(defmethod init-enemy-collision! enemy ((obj enemy))
  "Initializes the [[collide-shape-moving]] and any ancillary tasks to make the enemy collide properly"
  0
  (none)
  )

(defmethod init-enemy! enemy ((obj enemy))
  "Common method called to initialize the enemy, typically sets up default field values and calls ancillary helper methods"
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod go-idle enemy ((obj enemy))
  (go (method-of-object obj idle))
  (none)
  )

(defmethod set-enemy-info! enemy ((obj enemy) (arg0 enemy-info))
  "In addition to setting the `enemy-info`, also init the `neck-joint` if applicable from it
@param info Set `enemy-info` accordingly"
  (set! (-> obj enemy-info) arg0)
  (when (and (!= (-> obj enemy-info neck-joint) -1) (zero? (-> obj neck)))
    (set! (-> obj neck) (new 'process 'joint-mod (joint-mod-mode flex-blend) obj (-> obj enemy-info neck-joint)))
    (set-vector! (-> obj neck twist-max) 8192.0 8192.0 0.0 1.0)
    (set! (-> obj neck up) (the-as uint 1))
    (set! (-> obj neck nose) (the-as uint 2))
    (set! (-> obj neck ear) (the-as uint 0))
    (set! (-> obj neck max-dist) 102400.0)
    (set! (-> obj neck ignore-angle) 16384.0)
    )
  0
  (none)
  )

(defmethod init-enemy-behaviour-and-stats! enemy ((obj enemy) (arg0 enemy-info))
  "Initializes a bunch of enemy fields related to how they should react, how many hitpoints they should have, etc"
  (local-vars (sv-16 res-tag))
  (when (coin-flip? obj)
    (let ((a0-2 (-> obj node-list data 2)))
      (set! (-> a0-2 param0) (the-as (function cspace transformq none) cspace<-parented-matrix-joint-flip-z!))
      (set! (-> a0-2 param1) #f)
      (set! (-> a0-2 param2) #f)
      )
    (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag dislike-combo) (-> obj enemy-flags))))
    )
  (set! (-> obj mask) (logior (process-mask enemy) (-> obj mask)))
  (logior! (-> obj mask) (process-mask actor-pause))
  (logior! (-> obj enemy-flags) (enemy-flag notice))
  (set-enemy-info! obj arg0)
  (let ((a1-2 (-> obj enemy-info idle-anim-script)))
    (if a1-2
        (idle-control-method-9 (-> obj idle-anim-player) a1-2)
        )
    )
  (if (-> obj draw shadow)
      (set! (-> obj draw shadow-ctrl) (new
                                        'process
                                        'shadow-control
                                        (-> obj enemy-info shadow-min-y)
                                        (-> obj enemy-info shadow-max-y)
                                        (-> obj enemy-info shadow-locus-dist)
                                        (shadow-flags shdf00 shdf04)
                                        245760.0
                                        )
            )
      (set! (-> obj draw shadow-ctrl) *enemy-dummy-shadow-control*)
      )
  (set! (-> obj water-max-height) 8192.0)
  (if (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
      (set! (-> obj hit-points) (* (-> obj enemy-info default-hit-points) 2))
      (set! (-> obj hit-points) (-> obj enemy-info default-hit-points))
      )
  (let* ((v1-38 *game-info*)
         (a0-10 (+ (-> v1-38 attack-id) 1))
         )
    (set! (-> v1-38 attack-id) a0-10)
    (set! (-> obj attack-id) a0-10)
    )
  (let* ((v1-39 *game-info*)
         (a0-12 (+ (-> v1-39 attack-id) 1))
         )
    (set! (-> v1-39 attack-id) a0-12)
    (set! (-> obj persistent-attack-id) a0-12)
    )
  (set! (-> obj incoming attacker-handle) (the-as handle #f))
  (enemy-method-124 obj)
  (set! (-> obj fact-info-override) (new
                                      'process
                                      'fact-info-enemy
                                      obj
                                      (the-as (pointer float) (-> arg0 fact-defaults))
                                      (pickup-type eco-pill-random)
                                      (-> *FACT-bank* default-eco-pill-green-inc)
                                      )
        )
  (let ((a1-5 (if (logtest? (enemy-option multi-focus) (-> obj fact-info-override enemy-options))
                  #x400406
                  #x400402
                  )
              )
        )
    (reset-to-collide-spec (-> obj focus) (the-as collide-spec a1-5))
    )
  (set! sv-16 (new 'static 'res-tag))
  (let ((v1-49 (res-lump-data (-> obj entity) 'actor-groups pointer :tag-ptr (& sv-16))))
    (cond
      ((and v1-49 (nonzero? (-> sv-16 elt-count)))
       (set! (-> obj actor-group) (the-as (pointer actor-group) v1-49))
       (set! (-> obj actor-group-count) (the-as int (-> sv-16 elt-count)))
       )
      (else
        (set! (-> obj actor-group) (the-as (pointer actor-group) #f))
        (set! (-> obj actor-group-count) 0)
        0
        )
      )
    )
  (set! (-> obj on-notice) (res-lump-struct (-> obj entity) 'on-notice symbol))
  (set! (-> obj on-active) (res-lump-struct (-> obj entity) 'on-active symbol))
  (set! (-> obj on-hostile) (res-lump-struct (-> obj entity) 'on-hostile symbol))
  (set! (-> obj on-death) (res-lump-struct (-> obj entity) 'on-death symbol))
  (if (-> obj on-notice)
      (logior! (-> obj enemy-flags) (enemy-flag auto-reset-penetrate))
      )
  (if (-> obj on-active)
      (logior! (-> obj enemy-flags) (enemy-flag jump-check-blocked))
      )
  (if (-> obj on-hostile)
      (logior! (-> obj enemy-flags) (enemy-flag drawn-mirrored))
      )
  (let ((s4-0 (-> obj root-override2)))
    (set! (-> obj penetrated-by-all) (-> s4-0 penetrated-by))
    (set! (-> s4-0 penetrated-by) (get-penetrate-info obj))
    (set! (-> s4-0 event-self) 'touched)
    )
  (set! (-> obj penetrated-flinch) (-> arg0 penetrate-flinch))
  (set! (-> obj penetrated-knocked) (-> arg0 penetrate-knocked))
  (set! (-> obj reaction-time) (the-as time-frame (get-rand-int-range obj 30 180)))
  (let* ((v1-79 (-> obj enemy-flags))
         (a0-28 (-> obj fact-info-override enemy-options))
         (v1-80 (logior (enemy-flag
                          enable-on-active
                          checking-water
                          enable-on-notice
                          look-at-move-dest
                          check-water-backup
                          no-initial-move-to-ground
                          )
                        v1-79
                        )
                )
         )
    (if (logtest? (enemy-option multi-focus) a0-28)
        (set! v1-80 (logior (enemy-flag trackable) v1-80))
        )
    (if (logtest? (enemy-option has-trigger) a0-28)
        (set! v1-80 (logior (enemy-flag called-dying) v1-80))
        )
    (set! (-> obj enemy-flags) v1-80)
    )
  (set! (-> obj mask) (logior (process-mask collectable) (-> obj mask)))
  (if (and (-> obj enemy-info move-to-ground)
           (not (logtest? (enemy-flag vulnerable-backup) (-> obj enemy-flags)))
           (not (logtest? (enemy-option ambush) (-> obj fact-info-override enemy-options)))
           )
      (enemy-method-127 obj 40960.0 40960.0 #t (the-as collide-spec (-> obj gnd-collide)))
      )
  (if (zero? (-> obj draw light-index))
      (set! (-> obj draw light-index) (the-as uint 10))
      )
  0
  (none)
  )

(defbehavior enemy-init-by-other enemy ((arg0 process-drawable) (arg1 transformq))
  (let ((a1-1 (-> arg1 scale x)))
    (if a1-1
        (process-entity-set! self (the-as entity a1-1))
        )
    )
  (if (-> arg1 scale y)
      (set! (-> self enemy-flags) (logior (enemy-flag alert) (-> self enemy-flags)))
      )
  (if (-> arg1 scale z)
      (set! (-> self enemy-flags) (the-as enemy-flag (logior (enemy-flag vulnerable-backup) (-> self enemy-flags))))
      )
  (init-enemy-collision! self)
  (set! (-> self root-override2 trans quad) (-> arg1 trans quad))
  (quaternion-copy! (-> self root-override2 quat) (-> arg1 quat))
  (vector-identity! (-> self root-override2 scale))
  (init-enemy! self)
  (when (> (-> self enemy-info gem-joint) 0)
    (cond
      ((and (or (and (-> self entity) (logtest? (-> self entity extra perm status) (entity-perm-status save)))
                (not (-> self entity))
                )
            (not (or (task-node-closed? (game-task-node city-win-introduction))
                     (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                     )
                 )
            )
       (setup-masks
         (-> self draw)
         (the-as int (-> self enemy-info gem-no-seg))
         (the-as int (-> self enemy-info gem-seg))
         )
       )
      (else
        (setup-masks
          (-> self draw)
          (the-as int (-> self enemy-info gem-seg))
          (the-as int (-> self enemy-info gem-no-seg))
          )
        (add-connection *part-engine* self (-> self enemy-info gem-joint) self 314 (-> self enemy-info gem-offset))
        )
      )
    )
  (let ((v1-43 (-> self fact-info-override enemy-options)))
    (cond
      (*debug-view-anims*
        (go-virtual view-anims)
        )
      ((logtest? (enemy-option dormant) v1-43)
       (enemy-method-64 self)
       )
      ((logtest? (enemy-flag alert) (-> self enemy-flags))
       (go-directed self)
       )
      ((logtest? (enemy-option dormant-aware) v1-43)
       (enemy-method-65 self)
       )
      ((logtest? (enemy-option ambush) (-> self fact-info-override enemy-options))
       (go-ambush self)
       )
      (else
        (go-idle self)
        )
      )
    )
  (none)
  )

(defmethod init-from-entity! enemy ((obj enemy) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (init-enemy-collision! obj)
  (process-drawable-from-entity! obj arg0)
  (init-enemy! obj)
  (when (>= (-> obj enemy-info gem-joint) 0)
    (cond
      ((and (or (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status save)))
                (not (-> obj entity))
                )
            (not (or (task-node-closed? (game-task-node city-win-introduction))
                     (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                     )
                 )
            )
       (setup-masks
         (-> obj draw)
         (the-as int (-> obj enemy-info gem-no-seg))
         (the-as int (-> obj enemy-info gem-seg))
         )
       )
      (else
        (setup-masks
          (-> obj draw)
          (the-as int (-> obj enemy-info gem-seg))
          (the-as int (-> obj enemy-info gem-no-seg))
          )
        (add-connection *part-engine* obj (-> obj enemy-info gem-joint) obj 314 (-> obj enemy-info gem-offset))
        )
      )
    )
  (let ((v1-28 (-> obj fact-info-override enemy-options)))
    (cond
      ((logtest? (enemy-option spawner) v1-28)
       (process-entity-status! obj (entity-perm-status dead) #t)
       (go (method-of-object obj die-fast))
       )
      (*debug-view-anims*
        (go (method-of-object obj view-anims))
        )
      ((logtest? (enemy-option dormant) v1-28)
       (enemy-method-64 obj)
       )
      ((logtest? (enemy-option dormant-aware) v1-28)
       (enemy-method-65 obj)
       )
      (else
        (go-idle obj)
        )
      )
    )
  (none)
  )

(defmethod in-aggro-range? enemy ((obj enemy) (arg0 process-focusable) (arg1 vector))
  "Should the enemy activate.
- if `activate-distance` is `0.0`, always true
- otherwise, check if the provided process is close enough
@param proc The process used to distance check
@returns true/false"
  #t
  )

(defmethod enemy-method-99 enemy ((obj enemy) (arg0 process-focusable))
  #f
  )

(defmethod reset-to-collide-spec enemy-focus ((obj enemy-focus) (arg0 collide-spec))
  (let ((t9-0 (method-of-type focus reset-to-collide-spec)))
    (t9-0 obj arg0)
    )
  (set! (-> obj aware) (enemy-aware enemy-aware-0))
  0
  (none)
  )

;; WARN: Return type mismatch process vs none.
;; WARN: Function (method 129 enemy) has a return type of none, but the expression builder found a return statement.
(defmethod enemy-method-129 enemy ((obj enemy))
  (let ((gp-0 (-> obj focus)))
    (let ((a1-0 (handle->process (-> gp-0 handle))))
      (when a1-0
        (let ((v1-4 (-> obj enemy-flags)))
          (cond
            ((and a1-0 (not (logtest? (-> (the-as process-focusable a1-0) focus-status) (focus-status disable dead))))
             (when (and (logtest? (enemy-flag trackable) v1-4)
                        (not (logtest? (enemy-flag actor-pause-backup) v1-4))
                        (not (logtest? (-> gp-0 flags) (enemy-flag lock-focus)))
                        )
               (enemy-method-97 obj)
               (return #f)
               )
             (let ((v1-14
                     (enemy-method-61
                       obj
                       (the-as int (update-target-awareness! obj (the-as process-focusable a1-0) (the-as enemy-best-focus #f)))
                       )
                     )
                   )
               (set! (-> gp-0 aware) (the-as enemy-aware v1-14))
               (if (>= 1 v1-14)
                   (logclear! (-> gp-0 flags) (enemy-flag lock-focus))
                   )
               )
             (return #f)
             )
            (else
              (clear-focused gp-0)
              )
            )
          )
        )
      )
    (if (!= (-> gp-0 handle) #f)
        (clear-focused gp-0)
        )
    )
  (if (not (logtest? (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
      (enemy-method-97 obj)
      )
  (none)
  )

(defmethod enemy-method-97 enemy ((obj enemy))
  (let ((s4-0 (-> obj focus collide-with))
        (gp-0 (new 'stack-no-clear 'enemy-best-focus))
        )
    (set! (-> gp-0 proc) #f)
    (set! (-> gp-0 rating) 409600000.0)
    (set! (-> gp-0 aware) (enemy-aware enemy-aware-0))
    (when (logtest? s4-0 (collide-spec player-list))
      (let ((v1-4 (-> *collide-player-list* alive-list next0)))
        *collide-player-list*
        (let ((s3-0 (-> v1-4 next0)))
          (while (!= v1-4 (-> *collide-player-list* alive-list-end))
            (let ((v1-5 (the-as collide-shape (-> (the-as connection v1-4) param1))))
              (when (logtest? s4-0 (-> v1-5 root-prim prim-core collide-as))
                (let* ((s2-0 (-> v1-5 process))
                       (a1-1 (if (type? s2-0 process-focusable)
                                 (the-as process-focusable s2-0)
                                 )
                             )
                       )
                  (if (and a1-1 (and a1-1 (not (logtest? (-> a1-1 focus-status) (focus-status disable dead)))) (!= obj a1-1))
                      (update-target-awareness! obj a1-1 gp-0)
                      )
                  )
                )
              )
            (set! v1-4 s3-0)
            *collide-player-list*
            (set! s3-0 (-> s3-0 next0))
            )
          )
        )
      )
    (when (logtest? s4-0 (collide-spec hit-by-player-list hit-by-others-list))
      (when (logtest? s4-0 (collide-spec hit-by-player-list))
        (let ((v1-19 (-> *collide-hit-by-player-list* alive-list next0)))
          *collide-hit-by-player-list*
          (let ((s3-1 (-> v1-19 next0)))
            (while (!= v1-19 (-> *collide-hit-by-player-list* alive-list-end))
              (let ((v1-20 (the-as collide-shape (-> (the-as connection v1-19) param1))))
                (when (logtest? s4-0 (-> v1-20 root-prim prim-core collide-as))
                  (let* ((s2-1 (-> v1-20 process))
                         (a1-3 (if (type? s2-1 process-focusable)
                                   (the-as process-focusable s2-1)
                                   )
                               )
                         )
                    (if (and a1-3 (and a1-3 (not (logtest? (-> a1-3 focus-status) (focus-status disable dead)))) (!= obj a1-3))
                        (update-target-awareness! obj a1-3 gp-0)
                        )
                    )
                  )
                )
              (set! v1-19 s3-1)
              *collide-hit-by-player-list*
              (set! s3-1 (-> s3-1 next0))
              )
            )
          )
        )
      (when (logtest? s4-0 (collide-spec hit-by-others-list))
        (let ((v1-32 (-> *collide-hit-by-others-list* alive-list next0)))
          *collide-hit-by-others-list*
          (let ((s3-2 (-> v1-32 next0)))
            (while (!= v1-32 (-> *collide-hit-by-others-list* alive-list-end))
              (let ((v1-33 (the-as collide-shape (-> (the-as connection v1-32) param1))))
                (when (logtest? s4-0 (-> v1-33 root-prim prim-core collide-as))
                  (let* ((s2-2 (-> v1-33 process))
                         (a1-5 (if (type? s2-2 process-focusable)
                                   (the-as process-focusable s2-2)
                                   )
                               )
                         )
                    (if (and a1-5 (and a1-5 (not (logtest? (-> a1-5 focus-status) (focus-status disable dead)))) (!= obj a1-5))
                        (update-target-awareness! obj a1-5 gp-0)
                        )
                    )
                  )
                )
              (set! v1-32 s3-2)
              *collide-hit-by-others-list*
              (set! s3-2 (-> s3-2 next0))
              )
            )
          )
        )
      )
    (let ((s4-1 (-> gp-0 proc)))
      (when s4-1
        (enemy-method-63
          obj
          (the-as process-focusable s4-1)
          (the-as enemy-aware (enemy-method-61 obj (the-as int (-> gp-0 aware))))
          )
        s4-1
        )
      )
    )
  )

;; WARN: Return type mismatch int vs enemy-aware.
(defmethod update-target-awareness! enemy ((obj enemy) (arg0 process-focusable) (arg1 enemy-best-focus))
  "Checks a variety of criteria to determine the level of awareness the enemy is of the target.  Sets `aware` and related fields as well!
@TODO - flesh out docs
@returns the value that sets `aware`"
  (let ((f30-0 (vector-vector-distance (get-trans arg0 0) (-> obj root-override2 trans)))
        (s3-1 #f)
        (s2-0 #f)
        )
    (cond
      ((< f30-0 (-> obj enemy-info proximity-notice-distance))
       (set! s3-1 #t)
       (set! s2-0 (in-aggro-range? obj arg0 (the-as vector #f)))
       )
      (else
        (let ((f0-1 (the-as float (-> obj enemy-info notice-distance))))
          (if (< 1 (the-as int (-> obj focus aware)))
              (set! f0-1 (+ (the-as meters f0-1) (-> obj enemy-info notice-distance-delta)))
              )
          (when (or (< f30-0 f0-1) (not (logtest? (-> obj enemy-flags) (enemy-flag enable-on-notice))))
            (set! s2-0 (in-aggro-range? obj arg0 (the-as vector #f)))
            (if s2-0
                (set! s3-1 #t)
                )
            )
          )
        )
      )
    (let ((s3-2 (cond
                  (s3-1
                    (cond
                      ((enemy-method-99 obj arg0)
                       4
                       )
                      (s2-0
                        3
                        )
                      (else
                        2
                        )
                      )
                    )
                  ((< f30-0 (-> obj fact-info-override idle-distance))
                   1
                   )
                  (else
                    0
                    )
                  )
                )
          )
      (when (and (> s3-2 0) (logtest? (enemy-flag called-dying) (-> obj enemy-flags)))
        (cond
          ((logtest? (enemy-option idle-til-trigger) (-> obj fact-info-override enemy-options))
           (if (not (enemy-method-130 obj f30-0))
               (set! s3-2 0)
               )
           )
          (else
            (if (and (< 1 s3-2) (not (enemy-method-130 obj f30-0)))
                (set! s3-2 1)
                )
            )
          )
        )
      (when arg1
        (when (and (>= s3-2 (the-as int (-> arg1 aware))) (< f30-0 (-> arg1 rating)))
          (set! (-> arg1 aware) (the-as enemy-aware s3-2))
          (set! (-> arg1 rating) f30-0)
          (set! (-> arg1 proc) arg0)
          )
        )
      (the-as enemy-aware s3-2)
      )
    )
  )

(defmethod enemy-method-130 enemy ((obj enemy) (arg0 float))
  (let* ((v1-0 (-> obj fact-info-override))
         (a2-0 (-> v1-0 trig-mask-count))
         (a3-0 (-> v1-0 trig-mask))
         )
    (dotimes (t0-0 a2-0)
      (let ((t1-1 (the-as int (-> a3-0 t0-0))))
        (if (and (logtest? (the-as uint t1-1) 1) (>= (-> v1-0 trig-dist) arg0))
            (set! t1-1 (the-as int (logand -2 (the-as uint t1-1))))
            )
        (when (logtest? (the-as uint t1-1) 2)
          (let ((t2-8 (-> v1-0 trig-actor-group 0)))
            (countdown (t3-0 (-> t2-8 length))
              (let ((t5-0 (-> t2-8 data t3-0 actor)))
                (when (and t5-0 (logtest? (-> t5-0 extra perm status) (entity-perm-status subtask-complete)))
                  (set! t1-1 (logand -3 t1-1))
                  (goto cfg-17)
                  )
                )
              )
            )
          )
        (label cfg-17)
        (when (zero? t1-1)
          (logclear! (-> obj enemy-flags) (enemy-flag called-dying))
          (return #t)
          )
        )
      )
    )
  #f
  )

(defmethod enemy-method-61 enemy ((obj enemy) (arg0 int))
  (let ((v1-1 (< 1 arg0)))
    (cond
      (v1-1
        (when (not (logtest? (-> obj enemy-flags) (enemy-flag spawn-gem)))
          (logior! (-> obj enemy-flags) (enemy-flag spawn-gem))
          (set! (-> obj notice-time) (current-time))
          )
        (if (and (not (logtest? (-> obj enemy-flags) (enemy-flag chase-startup)))
                 (< (- (current-time) (-> obj notice-time)) (-> obj reaction-time))
                 )
            (set! v1-1 #f)
            )
        )
      (else
        (logclear! (-> obj enemy-flags) (enemy-flag spawn-gem))
        )
      )
    (cond
      (v1-1
        arg0
        )
      ((or (zero? arg0) (>= (- (current-time) (-> obj last-draw-time)) (seconds 2)))
       0
       )
      (else
        1
        )
      )
    )
  )

;; WARN: Return type mismatch none vs object.
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 17]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 28]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 37]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 89]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 105]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 202]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 211]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 274]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 346]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 407]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 413]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 490]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 493]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 530]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 560]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 610]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 641]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 720]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 774]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 807]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 814]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 850]
;; WARN: rewrite_to_get_var got a none typed variable. Is there unreachable code? [OP: 933]
(defmethod general-event-handler enemy ((obj enemy) (arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  "Handles various events for the enemy
@TODO - unsure if there is a pattern for the events and this should have a more specific name"
  (local-vars (s5-5 rgbaf) (sv-432 process) (sv-448 event-message-block))
  (the-as
    object
    (cond
      ((= arg2 'track)
       (and (nonzero? (-> obj hit-points))
            (logtest? (-> obj enemy-flags) (enemy-flag enable-on-active))
            (logtest? (enemy-flag check-water-backup) (-> obj enemy-flags))
            )
       )
      ((= arg2 'combo)
       (and (not (logtest? (enemy-flag multi-focus) (-> obj enemy-flags))) (nonzero? (-> obj hit-points)))
       )
      ((= arg2 'touch)
       (enemy-method-75 obj arg0 arg3)
       )
      ((= arg2 'touched)
       (when (logtest? (-> obj enemy-flags) (enemy-flag attackable-backup))
         (let* ((s3-1 arg0)
                (v1-20 (if (type? s3-1 process-drawable)
                           (the-as process-drawable s3-1)
                           )
                       )
                )
           (when v1-20
             (let* ((s3-2 (-> v1-20 root))
                    (a1-4 (if (type? s3-2 collide-shape)
                              s3-2
                              )
                          )
                    (s3-3 (-> arg3 param 0))
                    )
               (if (and a1-4
                        s3-3
                        ((method-of-type touching-shapes-entry prims-touching-action?)
                         (the-as touching-shapes-entry s3-3)
                         (the-as collide-shape a1-4)
                         (collide-action solid)
                         (collide-action)
                         )
                        ((method-of-type touching-shapes-entry prims-touching-action?)
                         (the-as touching-shapes-entry s3-3)
                         (-> obj root-override2)
                         (collide-action solid)
                         (collide-action)
                         )
                        )
                   (set! (-> obj auto-reset-penetrate-time) (current-time))
                   )
               )
             )
           )
         )
       (enemy-method-76 obj arg0 arg3)
       )
      ((= arg2 'attack-invinc)
       (case (-> (the-as attack-info (-> arg3 param 1)) mode)
         (('endlessfall)
          (let ((v1-31 (-> obj root-override2 root-prim)))
            (set! (-> v1-31 prim-core collide-as) (collide-spec))
            (set! (-> v1-31 prim-core collide-with) (collide-spec))
            )
          0
          (kill-prefer-falling obj)
          )
         )
       )
      ((= arg2 'attack)
       (let ((s2-0 (the-as object (-> arg3 param 1))))
         (when (!= (-> (the-as attack-info s2-0) id) (-> obj incoming attack-id))
           (cond
             ((and (logtest? (-> obj enemy-flags) (enemy-flag enable-on-active))
                   (not (logtest? (-> obj focus-status) (focus-status grabbed)))
                   )
              (let* ((s1-0 obj)
                     (s0-0 (method-of-object s1-0 enemy-method-106))
                     )
                (set! sv-432 arg0)
                (set! sv-448 arg3)
                (let ((a3-3 (get-penetrate-using-from-attack-event (the-as process-drawable arg0) arg3)))
                  (s0-0 s1-0 sv-432 sv-448 (the-as int a3-3) (the-as attack-info s2-0))
                  )
                )
              (send-event (ppointer->process (-> obj parent)) 'child-hit)
              0
              (if (not *debug-unkillable*)
                  (enemy-method-48 obj arg0 arg3)
                  )
              (let ((s2-1 (the-as attack-info (enemy-method-58 obj arg0 arg3))))
                (when s2-1
                  (logclear! (-> obj enemy-flags) (enemy-flag called-dying))
                  (enemy-method-108 obj (the-as enemy arg0) arg3)
                  (let ((a1-13 (new 'stack-no-clear 'event-message-block)))
                    (set! (-> a1-13 from) (process->ppointer arg0))
                    (set! (-> a1-13 num-params) arg1)
                    (set! (-> a1-13 message) (the-as symbol s2-1))
                    (set! (-> a1-13 param 0) (-> arg3 param 0))
                    (set! (-> a1-13 param 1) (-> arg3 param 1))
                    (set! (-> a1-13 param 2) (-> arg3 param 2))
                    (set! (-> a1-13 param 3) (-> arg3 param 3))
                    (set! (-> a1-13 param 4) (-> arg3 param 4))
                    (set! (-> a1-13 param 5) (-> arg3 param 5))
                    (send-event-function obj a1-13)
                    )
                  )
                )
              )
             (else
               (set! (-> obj incoming attack-id) (-> (the-as attack-info s2-0) id))
               (enemy-method-75 obj arg0 arg3)
               )
             )
           )
         )
       )
      ((= arg2 'hit-flinch)
       (when (zero? (-> obj hit-points))
         (logclear! (-> obj mask) (process-mask actor-pause))
         (logclear! (-> obj focus-status) (focus-status dangerous))
         (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice))
         (logior! (-> obj enemy-flags) (enemy-flag chase-startup))
         (logior! (-> obj focus-status) (focus-status hit))
         (if (zero? (-> obj hit-points))
             (logior! (-> obj focus-status) (focus-status dead))
             )
         (logclear! (-> obj enemy-flags) (enemy-flag actor-pause-backup))
         (enemy-method-62 obj)
         (set! (-> obj enemy-flags) (logior (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
         (process-contact-action arg0)
         (send-event arg0 'get-attack-count 1)
         (kill-prefer-falling obj)
         )
       #t
       )
      ((= arg2 'hit-knocked)
       (logclear! (-> obj mask) (process-mask actor-pause))
       (logclear! (-> obj focus-status) (focus-status dangerous))
       (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice))
       (logior! (-> obj enemy-flags) (enemy-flag chase-startup))
       (logior! (-> obj focus-status) (focus-status hit))
       (if (zero? (-> obj hit-points))
           (logior! (-> obj focus-status) (focus-status dead))
           )
       (logclear! (-> obj enemy-flags) (enemy-flag actor-pause-backup))
       (enemy-method-62 obj)
       (set! (-> obj enemy-flags) (logior (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
       (process-contact-action arg0)
       (send-event arg0 'get-attack-count 1)
       (when (zero? (-> obj hit-points))
         (case (-> obj incoming knocked-type)
           (((knocked-type knocked-type-4) (knocked-type knocked-type-6))
            (set! (-> obj incoming knocked-type) (knocked-type knocked-type-0))
            0
            )
           )
         )
       (go (method-of-object obj knocked))
       )
      ((= arg2 'hit)
       (logclear! (-> obj mask) (process-mask actor-pause))
       (logclear! (-> obj focus-status) (focus-status dangerous))
       (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice))
       (logior! (-> obj enemy-flags) (enemy-flag chase-startup))
       (logior! (-> obj focus-status) (focus-status hit))
       (if (zero? (-> obj hit-points))
           (logior! (-> obj focus-status) (focus-status dead))
           )
       (logclear! (-> obj enemy-flags) (enemy-flag actor-pause-backup))
       (enemy-method-62 obj)
       (set! (-> obj enemy-flags) (logior (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
       (process-contact-action arg0)
       (send-event arg0 'get-attack-count 1)
       (if (zero? (-> obj hit-points))
           (kill-prefer-falling obj)
           (go (method-of-object obj hit))
           )
       )
      ((= arg2 'cue-chase)
       (when (and (> (-> obj hit-points) 0)
                  (zero? (-> obj fated-time))
                  (not (logtest? (-> obj focus-status) (focus-status grabbed)))
                  )
         (let ((v1-162 (logtest? (enemy-flag alert) (-> obj enemy-flags))))
           (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice alert victory called-dying))
           (set! (-> obj enemy-flags) (logior (enemy-flag dangerous-backup) (-> obj enemy-flags)))
           (logclear! (-> obj mask) (process-mask actor-pause))
           (cond
             (v1-162
               (if (logtest? (enemy-option ambush) (-> obj fact-info-override enemy-options))
                   (go-ambush obj)
                   (go-hostile obj)
                   )
               )
             ((and (-> obj next-state) (let ((v1-173 (-> obj next-state name)))
                                         (or (= v1-173 'dormant) (= v1-173 'dormant-aware))
                                         )
                   )
              (if (logtest? (enemy-option ambush) (-> obj fact-info-override enemy-options))
                  (go-ambush obj)
                  (go (method-of-object obj notice))
                  )
              )
             )
           )
         #t
         )
       )
      ((= arg2 'cue-wake)
       (when (and (> (-> obj hit-points) 0)
                  (zero? (-> obj fated-time))
                  (not (logtest? (-> obj focus-status) (focus-status grabbed)))
                  )
         (logclear! (-> obj enemy-flags) (enemy-flag alert victory called-dying))
         (if (logtest? (enemy-option ambush) (-> obj fact-info-override enemy-options))
             (go-ambush obj)
             (react-to-focus obj)
             )
         #t
         )
       )
      ((= arg2 'jump)
       (when (and (> (-> obj hit-points) 0)
                  (zero? (-> obj fated-time))
                  (not (logtest? (-> obj focus-status) (focus-status grabbed)))
                  )
         (logclear! (-> obj mask) (process-mask actor-pause))
         (set! (-> obj jump-why) (-> arg3 param 0))
         (set! (-> obj event-param-point quad) (-> (the-as vector (-> arg3 param 1)) quad))
         (go (method-of-object obj jump))
         )
       )
      ((= arg2 'death-start)
       (set! (-> obj enemy-flags) (the-as enemy-flag (logior (enemy-flag recover) (-> obj enemy-flags))))
       (send-event (ppointer->process (-> obj parent)) 'child-die)
       (drop-pickup (-> obj fact-info-override) #t *entity-pool* (-> obj fact-info-override) 0)
       (let ((s5-1 (-> obj on-death)))
         (if s5-1
             (script-eval (the-as pair s5-1) :vector (-> obj root-override2 trans))
             )
         )
       )
      ((= arg2 'death-end)
       (if (-> obj skel effect)
           (logior! (-> obj skel effect flags) (effect-control-flag ecf2))
           )
       (logior! (-> obj draw status) (draw-control-status no-draw))
       (logclear! (-> obj enemy-flags) (enemy-flag enable-on-active checking-water))
       (logclear! (-> obj focus-status) (focus-status dangerous))
       (set! (-> obj enemy-flags) (logclear (-> obj enemy-flags) (enemy-flag check-water)))
       )
      ((= arg2 'instant-death)
       (when (and (> (-> obj hit-points) 0) (zero? (-> obj fated-time)))
         (set! (-> obj hit-points) 0)
         (set! (-> obj root-override2 penetrated-by) (get-penetrate-info obj))
         (let ((s5-2 (enemy-method-50 obj (new 'stack-no-clear 'vector))))
           (vector-z-quaternion! s5-2 (-> obj root-override2 quat))
           (vector-float*! s5-2 s5-2 -1.0)
           (vector-normalize! s5-2 1.0)
           )
         (logclear! (-> obj mask) (process-mask actor-pause))
         (logclear! (-> obj focus-status) (focus-status dangerous))
         (logclear! (-> obj enemy-flags) (enemy-flag enable-on-notice))
         (logior! (-> obj enemy-flags) (enemy-flag chase-startup))
         (logior! (-> obj focus-status) (focus-status hit))
         (if (zero? (-> obj hit-points))
             (logior! (-> obj focus-status) (focus-status dead))
             )
         (logclear! (-> obj enemy-flags) (enemy-flag actor-pause-backup))
         (enemy-method-62 obj)
         (set! (-> obj enemy-flags) (logior (enemy-flag actor-pause-backup) (-> obj enemy-flags)))
         (kill-prefer-falling obj)
         )
       )
      ((= arg2 'die-fast)
       (logior! (-> obj draw status) (draw-control-status no-draw))
       (dispose! obj)
       (send-event (ppointer->process (-> obj parent)) 'child-die)
       (let ((s5-3 (-> obj on-death)))
         (if s5-3
             (script-eval (the-as pair s5-3) :vector (-> obj root-override2 trans))
             )
         )
       (cleanup-for-death obj)
       (go (method-of-object obj die-fast))
       )
      ((= arg2 'victory)
       (if (and (-> obj enemy-info use-victory)
                (not (and (-> obj next-state) (= (-> obj next-state name) 'victory)))
                (> (-> obj hit-points) 0)
                (zero? (-> obj fated-time))
                (not (logtest? (-> obj focus-status) (focus-status grabbed)))
                )
           (go (method-of-object obj victory))
           )
       )
      ((= arg2 'nav-control)
       (if (nonzero? (-> obj nav))
           (-> obj nav)
           )
       )
      ((= arg2 'push-trans)
       (move-by-vector! (-> obj root-override2) (the-as vector (-> arg3 param 0)))
       )
      ((= arg2 'move-trans)
       (move-to-point! (-> obj root-override2) (the-as vector (-> arg3 param 0)))
       )
      ((= arg2 'shadow)
       (cond
         ((-> arg3 param 0)
          (let ((v1-320 (-> obj draw shadow-ctrl)))
            (logclear! (-> v1-320 settings flags) (shadow-flags disable-draw))
            )
          0
          )
         (else
           (let ((v1-323 (-> obj draw shadow-ctrl)))
             (logior! (-> v1-323 settings flags) (shadow-flags disable-draw))
             )
           0
           )
         )
       )
      ((= arg2 'color-effect)
       (case (-> arg3 param 0)
         (('dark)
          (let ((f30-0 (rand-vu-float-range 0.2 1.0)))
            (set-vector! (-> obj draw color-mult) (lerp 1.0 1.0 f30-0) (lerp 1.0 0.0 f30-0) (lerp 1.0 1.0 f30-0) 1.0)
            (set! s5-5 (-> obj draw color-emissive))
            (set! (-> s5-5 x) (lerp 0.0 0.3 f30-0))
            (set! (-> s5-5 y) (lerp 0.0 0.0 f30-0))
            (set! (-> s5-5 z) (lerp 0.0 0.3 f30-0))
            )
          (set! (-> s5-5 w) 1.0)
          s5-5
          )
         ((#f)
          (set-vector! (-> obj draw color-mult) 1.0 1.0 1.0 1.0)
          (set! s5-5 (-> obj draw color-emissive))
          (set! (-> s5-5 quad) (the-as uint128 0))
          s5-5
          )
         )
       )
      )
    )
  )

(defmethod damage-amount-from-attack enemy ((obj enemy) (arg0 process) (arg1 event-message-block))
  "@returns the amount of damage taken from an attack.  This can come straight off the [[attack-info]] or via [[penetrate-using->damage]]"
  (let ((v1-0 (the-as attack-info (-> arg1 param 1))))
    (if (logtest? (attack-info-mask damage) (-> v1-0 mask))
        (the int (-> v1-0 damage))
        (penetrate-using->damage (the-as penetrate (-> obj incoming penetrate-using)))
        )
    )
  )

(defmethod enemy-method-58 enemy ((obj enemy) (arg0 process) (arg1 event-message-block))
  (let ((v1-0 (-> obj incoming penetrate-using)))
    (cond
      ((logtest? (the-as penetrate v1-0) (-> obj penetrated-flinch))
       'hit-flinch
       )
      ((logtest? (the-as penetrate v1-0) (-> obj penetrated-knocked))
       'hit-knocked
       )
      (else
        'hit
        )
      )
    )
  )

(defmethod enemy-method-48 enemy ((obj enemy) (arg0 process) (arg1 event-message-block))
  (let* ((v1-1 (damage-amount-from-attack obj arg0 arg1))
         (s5-0 (-> obj hit-points))
         (s4-1 (max 0 (- s5-0 v1-1)))
         )
    (when (and (zero? s4-1) (nonzero? s5-0) (= (-> obj incoming knocked-type) (knocked-type knocked-type-6)))
      (cond
        ((zero? (-> obj fated-time))
         (set! (-> obj fated-time) (current-time))
         (set! s4-1 1)
         )
        (else
          (if (< (- (current-time) (-> obj fated-time)) (seconds 1))
              (set! s4-1 1)
              )
          )
        )
      )
    (set! (-> obj hit-points) s4-1)
    (if (not (logtest? (-> obj enemy-flags) (enemy-flag attackable-backup)))
        (set! (-> obj root-override2 penetrated-by) (get-penetrate-info obj))
        )
    (- s5-0 s4-1)
    )
  )

(defmethod enemy-method-134 enemy ((obj enemy) (arg0 process) (arg1 attack-info))
  (find-offending-process-focusable arg0 arg1)
  )

(defmethod enemy-method-75 enemy ((obj enemy) (arg0 process) (arg1 event-message-block))
  (let* ((touch-entry (the-as touching-shapes-entry (-> arg1 param 0)))
         (s2-0 arg0)
         (s3-0 (if (type? s2-0 process-focusable)
                   (the-as process-focusable s2-0)
                   )
               )
         )
    (when (and (the-as uint touch-entry) s3-0)
      (cond
        ((and (focus-test? obj dangerous)
              (and s3-0 (not (logtest? (-> s3-0 focus-status) (focus-status disable dead ignore grabbed))))
              ((method-of-type touching-shapes-entry prims-touching-action?)
               touch-entry
               (-> obj root-override2)
               (collide-action deadly)
               (collide-action)
               )
              )
         (let ((a3-2 (if ((method-of-type touching-shapes-entry prims-touching-action?)
                          touch-entry
                          (-> obj root-override2)
                          (collide-action persistent-attack)
                          (collide-action)
                          )
                         (-> obj persistent-attack-id)
                         (-> obj attack-id)
                         )
                     )
               )
           (enemy-method-104 obj arg0 touch-entry a3-2)
           )
         )
        ((and ((method-of-type touching-shapes-entry prims-touching-action?)
               touch-entry
               (-> obj root-override2)
               (collide-action no-standon)
               (collide-action)
               )
              (not (logtest? (-> obj root-override2 penetrated-by) (-> s3-0 root-override penetrate-using)))
              )
         (if (send-shoves (-> obj root-override2) arg0 touch-entry 0.7 6144.0 16384.0)
             (send-event obj 'bouncing-off arg0)
             )
         )
        )
      )
    )
  )

(defmethod enemy-method-76 enemy ((obj enemy) (arg0 process) (arg1 event-message-block))
  (let ((s4-0 (-> arg1 param 0)))
    (when s4-0
      (when (or (and (and (-> obj next-state) (= (-> obj next-state name) 'knocked))
                     (logtest? (process-mask crate) (-> arg0 mask))
                     )
                (and (and (-> obj next-state) (= (-> obj next-state name) 'jump))
                     (logtest? (process-mask target sidekick crate bot) (-> arg0 mask))
                     )
                )
        (when ((method-of-type touching-shapes-entry prims-touching-action?)
               (the-as touching-shapes-entry s4-0)
               (-> obj root-override2)
               (collide-action solid semi-solid deadly)
               (collide-action)
               )
          (let ((a3-2 (if ((method-of-type touching-shapes-entry prims-touching-action?)
                           (the-as touching-shapes-entry s4-0)
                           (-> obj root-override2)
                           (collide-action persistent-attack)
                           (collide-action)
                           )
                          (-> obj persistent-attack-id)
                          (-> obj attack-id)
                          )
                      )
                )
            (enemy-method-104 obj arg0 (the-as touching-shapes-entry s4-0) a3-2)
            )
          )
        )
      )
    )
  )

(defbehavior enemy-event-handler enemy ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (general-event-handler self arg0 arg1 arg2 arg3)
  )

(defbehavior enemy-simple-post enemy ()
  (track-target! self)
  (update-transforms (-> self root-override2))
  0
  (none)
  )

(defbehavior enemy-falling-post enemy ()
  (set! (-> self enemy-flags) (logior (enemy-flag directed) (-> self enemy-flags)))
  (let ((gp-0 (-> self root-override2)))
    (cond
      ((focus-test? self under-water)
       (enemy-method-47 self (-> gp-0 transv))
       )
      (else
        (let ((a1-1 (new-stack-vector0)))
          (vector-v++! (-> gp-0 transv) (compute-acc-due-to-gravity gp-0 a1-1 (-> self enemy-info slip-factor)))
          )
        )
      )
    (let ((a2-1 (new 'stack-no-clear 'collide-query)))
      (set! (-> a2-1 collide-with) (-> gp-0 root-prim prim-core collide-with))
      (set! (-> a2-1 ignore-process0) self)
      (set! (-> a2-1 ignore-process1) #f)
      (set! (-> a2-1 ignore-pat) (logior (new 'static 'pat-surface :noendlessfall #x1) (-> gp-0 pat-ignore-mask)))
      (set! (-> a2-1 action-mask) (collide-action solid))
      (fill-cache-integrate-and-collide gp-0 (-> gp-0 transv) a2-1 (meters 0))
      )
    )
  (enemy-method-111 self)
  (track-target! self)
  (none)
  )

(defmethod enemy-method-47 enemy ((obj enemy) (arg0 vector))
  (with-pp
    (let* ((f2-0 0.8)
           (f0-1 (fmax 0.0 (+ 1.0 (* 60.0 (-> pp clock seconds-per-frame) (+ -1.0 f2-0)))))
           )
      (vector-float*! arg0 arg0 f0-1)
      )
    (set! (-> arg0 y) (+ (-> arg0 y) (* -204800.0 (-> pp clock seconds-per-frame))))
    )
  )

(defbehavior enemy-die-falling-post enemy ()
  (set! (-> self enemy-flags) (logior (enemy-flag directed) (-> self enemy-flags)))
  (let ((gp-0 (-> self root-override2)))
    (if (focus-test? self under-water)
        (enemy-method-47 self (-> gp-0 transv))
        (vector-v++! (-> gp-0 transv) (compute-acc-due-to-gravity gp-0 (new-stack-vector0) 0.0))
        )
    (let ((s4-1 (new 'stack-no-clear 'collide-query))
          (s5-1 (new 'stack-no-clear 'vector))
          )
      (set! (-> s5-1 quad) (-> gp-0 trans quad))
      (vector-v++! s5-1 (-> gp-0 transv))
      (when (find-ground gp-0 s4-1 (-> self enemy-info recover-gnd-collide-with) 8192.0 81920.0 1024.0)
        (when (>= (-> gp-0 gspot-pos y) (-> s5-1 y))
          (set! (-> s5-1 y) (-> gp-0 gspot-pos y))
          (vector-reset! (-> gp-0 transv))
          )
        )
      (move-to-point! gp-0 s5-1)
      )
    )
  (track-target! self)
  0
  (none)
  )

(defstate idle (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (stop-looking-at-target! self)
    (logclear! (-> self enemy-flags) (enemy-flag spawn-gem chase-startup use-notice-distance))
    (logior! (-> self enemy-flags) (enemy-flag enable-on-notice))
    (set! (-> self state-timeout) (seconds 0.5))
    (if (-> self on-notice)
        (logior! (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
        )
    (if (-> self on-active)
        (logior! (-> self enemy-flags) (enemy-flag jump-check-blocked))
        )
    (if (-> self on-hostile)
        (logior! (-> self enemy-flags) (enemy-flag drawn-mirrored))
        )
    (when (not (logtest? (enemy-flag dangerous-backup) (-> self enemy-flags)))
      (if (logtest? (-> self enemy-flags) (enemy-flag notice))
          (logior! (-> self mask) (process-mask actor-pause))
          (logclear! (-> self mask) (process-mask actor-pause))
          )
      )
    (none)
    )
  :trans (behavior ()
    (if (and (>= (- (current-time) (-> self state-time)) (-> self state-timeout))
             (> (the-as int (-> self focus aware)) 0)
             )
        (go-virtual active)
        )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (sleep-code)
    (none)
    )
  :post (behavior ()
    (idle-control-method-10 (-> self idle-anim-player) self)
    (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
        (set! (-> self last-draw-time) (current-time))
        )
    (enemy-method-129 self)
    (ja-post)
    (none)
    )
  )

(defstate dormant (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    ((-> (method-of-type enemy idle) enter))
    (set! (-> self root-override2 nav-flags) (nav-flags))
    (let ((v1-4 (-> self root-override2 root-prim)))
      (set! (-> v1-4 prim-core collide-as) (collide-spec))
      (set! (-> v1-4 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (set! (-> self draw origin quad) (-> self root-override2 trans quad))
    (if (logtest? (enemy-flag alert) (-> self enemy-flags))
        (set! (-> self enemy-flags) (logior (enemy-flag victory) (-> self enemy-flags)))
        )
    (logior! (-> self focus-status) (focus-status disable))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self focus-status) (focus-status disable))
    (let ((v1-3 (-> self root-override2 root-prim)))
      (set! (-> v1-3 prim-core collide-as) (-> self root-override2 backup-collide-as))
      (set! (-> v1-3 prim-core collide-with) (-> self root-override2 backup-collide-with))
      )
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (logclear! (-> self enemy-flags) (enemy-flag victory))
    (logior! (-> self root-override2 nav-flags) (nav-flags has-root-sphere))
    (none)
    )
  :code (the-as (function none :behavior enemy) sleep-code)
  )

(defstate dormant-aware (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (-> (method-of-type enemy dormant) enter)
  :exit (-> (method-of-type enemy dormant) exit)
  :trans (behavior ()
    (when (and (>= (- (current-time) (-> self state-time)) (-> self state-timeout))
               (> (the-as int (-> self focus aware)) 0)
               )
      (if (logtest? (enemy-option ambush) (-> self fact-info-override enemy-options))
          (go-ambush self)
          (go-virtual active)
          )
      )
    (none)
    )
  :code (the-as (function none :behavior enemy) sleep-code)
  :post (behavior ()
    (if (and (nonzero? (-> self draw)) (logtest? (-> self draw status) (draw-control-status on-screen)))
        (set! (-> self last-draw-time) (current-time))
        )
    (enemy-method-129 self)
    (none)
    )
  )

(defstate ambush (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logior! (-> self enemy-flags) (enemy-flag chase-startup))
    (none)
    )
  :code (behavior ()
    (go-virtual notice)
    (none)
    )
  )

(defstate active (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logclear! (-> self enemy-flags) (enemy-flag use-notice-distance))
    (when (logtest? (-> self enemy-flags) (enemy-flag jump-check-blocked))
      (logclear! (-> self enemy-flags) (enemy-flag jump-check-blocked))
      (let ((gp-0 (-> self on-active)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root-override2 trans))
            )
        )
      )
    (when (not (logtest? (enemy-flag dangerous-backup) (-> self enemy-flags)))
      (if (logtest? (-> self enemy-flags) (enemy-flag notice))
          (logior! (-> self mask) (process-mask actor-pause))
          (logclear! (-> self mask) (process-mask actor-pause))
          )
      )
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.1))
      (let ((v1-3 (-> self focus aware)))
        (cond
          ((< (the-as int v1-3) 1)
           (go-virtual idle)
           )
          ((< 1 (the-as int v1-3))
           (go-virtual notice)
           )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (sleep-code)
    (none)
    )
  :post (behavior ()
    (idle-control-method-10 (-> self idle-anim-player) self)
    (enemy-simple-post)
    (none)
    )
  )

(defstate notice (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (let ((v1-3 (logior (-> self enemy-flags) (enemy-flag use-notice-distance))))
      (set! (-> self enemy-flags) (logclear v1-3 (enemy-flag called-dying)))
      )
    (logclear! (-> self mask) (process-mask actor-pause))
    (look-at-target! self (enemy-flag lock-focus))
    (when (logtest? (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
      (logclear! (-> self enemy-flags) (enemy-flag auto-reset-penetrate))
      (let ((gp-0 (-> self on-notice)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root-override2 trans))
            )
        )
      )
    (let ((gp-1 (-> self focus aware)))
      (when (logtest? (-> self enemy-flags) (enemy-flag chase-startup))
        (cond
          ((and (= gp-1 (enemy-aware enemy-aware-3)) (get-enemy-target self))
           (go-hostile self)
           )
          ((= gp-1 (enemy-aware unaware))
           (go-flee self)
           )
          (else
            (go-stare self)
            )
          )
        )
      )
    (logior! (-> self enemy-flags) (enemy-flag chase-startup))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info notice-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info notice-anim))) frames num-frames)
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (vector-! gp-0 (target-pos 0) (-> self root-override2 trans))
        (seek-toward-heading-vec! (-> self root-override2) gp-0 131072.0 (seconds 0.05))
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (react-to-focus self)
    (none)
    )
  :post enemy-simple-post
  )

(defstate hostile (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (look-at-target! self (enemy-flag lock-focus))
    (logior! (-> self enemy-flags) (enemy-flag use-notice-distance))
    (logclear! (-> self enemy-flags) (enemy-flag dangerous-backup))
    (logclear! (-> self mask) (process-mask actor-pause))
    (when (logtest? (-> self enemy-flags) (enemy-flag drawn-mirrored))
      (logclear! (-> self enemy-flags) (enemy-flag drawn-mirrored))
      (let ((gp-0 (-> self on-hostile)))
        (if gp-0
            (script-eval (the-as pair gp-0) :vector (-> self root-override2 trans))
            )
        )
      )
    (none)
    )
  :trans (behavior ()
    (if (and (logtest? (-> self enemy-flags) (enemy-flag look-at-focus)) (-> self enemy-info use-victory))
        (go-virtual victory)
        )
    (let ((gp-0 (-> self focus aware)))
      (when (>= (- (current-time) (-> self state-time)) (-> self reaction-time))
        (cond
          ((or (>= 2 (the-as int gp-0)) (not (get-enemy-target self)))
           (go-stare self)
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data (-> self enemy-info hostile-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    (none)
    )
  :post enemy-simple-post
  )

(defstate stare (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logclear! (-> self mask) (process-mask actor-pause))
    (logclear! (-> self enemy-flags) (enemy-flag dangerous-backup))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.1))
      (let ((gp-0 (-> self focus aware)))
        (cond
          ((>= 1 (the-as int gp-0))
           (go-virtual active)
           )
          ((and (= gp-0 (enemy-aware enemy-aware-3)) (get-enemy-target self))
           (go-hostile self)
           )
          ((= gp-0 (enemy-aware unaware))
           (go-flee self)
           )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1))
          (gp-0 (-> self draw art-group data (-> self enemy-info idle-anim)))
          )
      (until #f
        (ja-no-eval :group! gp-0
                    :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)) f30-0)
                    :frame-num 0.0
                    )
        (until (ja-done? 0)
          (suspend)
          (ja :num! (seek! max f30-0))
          )
        )
      )
    #f
    (none)
    )
  :post enemy-simple-post
  )

(defstate victory (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag look-at-focus))
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info victory-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info victory-anim))) frames num-frames)
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (react-to-focus self)
    (none)
    )
  :post enemy-simple-post
  )

(defstate flee (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (look-at-target! self (enemy-flag lock-focus))
    (logclear! (-> self enemy-flags) (enemy-flag dangerous-backup))
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (-> self reaction-time))
      (if (!= (-> self focus aware) (enemy-aware unaware))
          (go-stare self)
          )
      )
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.2))
    (ja :group! (-> self draw art-group data (-> self enemy-info hostile-anim)))
    (ja :num-func num-func-identity :frame-num 0.0)
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    (none)
    )
  :post enemy-simple-post
  )

(defmethod enemy-method-82 enemy ((obj enemy) (arg0 enemy-jump-info))
  "@abstract"
  #f
  )

(defmethod enemy-method-83 enemy ((obj enemy) (arg0 enemy-jump-info))
  (set! (-> arg0 flags) (the-as uint 1))
  (set! (-> arg0 anim-speed) (get-rand-float-range obj 0.9 1.1))
  (set! (-> arg0 hang-time) 0)
  (set! (-> arg0 dest-pos quad) (-> obj event-param-point quad))
  (set! (-> arg0 start-pos quad) (-> obj root-override2 trans quad))
  (let ((s4-0 (new 'stack-no-clear 'collide-query)))
    (if (enemy-above-ground?
          obj
          s4-0
          (-> arg0 dest-pos)
          (the-as collide-spec (-> obj gnd-collide))
          8192.0
          81920.0
          1024.0
          )
        (set! (-> arg0 dest-pos y) (-> s4-0 best-other-tri intersect y))
        )
    )
  (enemy-method-84 obj arg0)
  (none)
  )

(defmethod enemy-method-84 enemy ((obj enemy) (arg0 enemy-jump-info))
  (let* ((f0-0 (vector-vector-xz-distance (-> arg0 start-pos) (-> arg0 dest-pos)))
         (f0-2 (fmax (-> obj enemy-info jump-height-min) (* (-> obj enemy-info jump-height-factor) f0-0)))
         )
    (setup-from-to-height! (-> arg0 traj) (-> arg0 start-pos) (-> arg0 dest-pos) f0-2 -4.551111)
    )
  (none)
  )

(defmethod enemy-method-86 enemy ((obj enemy))
  (let ((gp-0 (-> obj root-override2)))
    (when (< (-> gp-0 transv y) 0.0)
      (let ((a1-0 (new 'stack-no-clear 'collide-query)))
        (find-ground (-> obj root-override2) a1-0 (the-as collide-spec (-> obj gnd-collide)) 8192.0 81920.0 1024.0)
        )
      (>= (-> gp-0 gspot-pos y) (-> gp-0 trans y))
      )
    )
  )

(defmethod enemy-method-85 enemy ((obj enemy))
  (let* ((v1-0 (-> obj root-override2))
         (f0-0 (-> v1-0 gspot-pos y))
         )
    (if (< (-> v1-0 trans y) f0-0)
        (set! (-> v1-0 trans y) f0-0)
        )
    )
  (set! (-> obj root-override2 transv y) 0.0)
  )

(defmethod enemy-method-92 enemy ((obj enemy) (arg0 int) (arg1 nav-poly))
  "TODO - nav-poly is a guess
@abstract"
  0
  (none)
  )

(defmethod enemy-method-91 enemy ((obj enemy) (arg0 int) (arg1 enemy-jump-info))
  (case arg0
    ((2 3)
     (set! (-> obj enemy-flags) (logior (enemy-flag directed) (-> obj enemy-flags)))
     (let ((f30-0 (the float (-> arg1 hang-time))))
       (let ((a1-3 (compute-trans-at-time (-> arg1 traj) f30-0 (new 'stack-no-clear 'vector))))
         (move-to-point! (-> obj root-override2) a1-3)
         )
       (let ((s5-1 (-> obj root-override2 transv)))
         (compute-transv-at-time (-> arg1 traj) f30-0 s5-1)
         (vector-float*! s5-1 s5-1 300.0)
         )
       )
     )
    )
  0
  (none)
  )

(defmethod enemy-method-89 enemy ((obj enemy) (arg0 enemy-jump-info))
  (let ((a0-1 (-> obj skel root-channel 0)))
    (set! (-> a0-1 param 0) 1.0)
    (joint-control-channel-group! a0-1 (the-as art-joint-anim #f) num-func-loop!)
    )
  (ja-channel-push! 1 (seconds 0.1))
  (let ((a1-3 (-> obj draw art-group data (-> obj enemy-info jump-wind-up-anim)))
        (a0-5 (-> obj skel root-channel 0))
        )
    (set! (-> a0-5 frame-group) (the-as art-joint-anim a1-3))
    (set! (-> a0-5 param 0) (the float (+ (-> (the-as art-joint-anim a1-3) frames num-frames) -1)))
    (set! (-> a0-5 param 1) (-> arg0 anim-speed))
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group! a0-5 (the-as art-joint-anim a1-3) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-87 enemy ((obj enemy) (arg0 enemy-jump-info))
  (let ((s5-0 (-> obj draw art-group data (-> obj enemy-info jump-in-air-anim))))
    (let ((v1-6 (if (> (-> obj skel active-channels) 0)
                    (-> obj skel root-channel 0 frame-group)
                    )
                )
          )
      (cond
        ((and v1-6 (= v1-6 (-> obj draw art-group data (-> obj enemy-info jump-wind-up-anim))))
         (ja-channel-push! 1 0)
         )
        (else
          (let ((a0-10 (-> obj skel root-channel 0)))
            (set! (-> a0-10 param 0) 1.0)
            (joint-control-channel-group! a0-10 (the-as art-joint-anim #f) num-func-loop!)
            )
          (ja-channel-push! 1 (seconds 0.1))
          )
        )
      )
    (let ((a0-12 (-> obj skel root-channel 0)))
      (set! (-> a0-12 frame-group) (the-as art-joint-anim s5-0))
      (set! (-> a0-12 param 0) (the float (+ (-> (the-as art-joint-anim s5-0) frames num-frames) -1)))
      (set! (-> a0-12 param 1) (-> arg0 anim-speed))
      (set! (-> a0-12 frame-num) 0.0)
      (joint-control-channel-group! a0-12 (the-as art-joint-anim s5-0) num-func-seek!)
      )
    )
  #t
  )

(defmethod enemy-method-88 enemy ((obj enemy) (arg0 enemy-jump-info))
  (let ((a0-1 (-> obj skel root-channel 0)))
    (set! (-> a0-1 param 0) 1.0)
    (joint-control-channel-group! a0-1 (the-as art-joint-anim #f) num-func-loop!)
    )
  (ja-channel-push! 1 (seconds 0.075))
  (let ((a1-3 (-> obj draw art-group data (-> obj enemy-info jump-land-anim)))
        (a0-5 (-> obj skel root-channel 0))
        )
    (set! (-> a0-5 frame-group) (the-as art-joint-anim a1-3))
    (set! (-> a0-5 param 0) (the float (+ (-> (the-as art-joint-anim a1-3) frames num-frames) -1)))
    (set! (-> a0-5 param 1) (-> arg0 anim-speed))
    (set! (-> a0-5 frame-num) 0.0)
    (joint-control-channel-group! a0-5 (the-as art-joint-anim a1-3) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-90 enemy ((obj enemy) (arg0 int) (arg1 enemy-jump-info))
  (local-vars (s5-0 symbol))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (not (enemy-method-89 obj arg1))
       )
      ((= v1-0 1)
       (set! s5-0 (ja-done? 0))
       (let ((a0-4 (-> obj skel root-channel 0)))
         (set! (-> a0-4 param 0) (the float (+ (-> a0-4 frame-group frames num-frames) -1)))
         (set! (-> a0-4 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      ((= v1-0 2)
       (enemy-method-87 obj arg1)
       #f
       )
      ((= v1-0 3)
       (set! s5-0 (ja-done? 0))
       (let ((a0-9 (-> obj skel root-channel 0)))
         (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group frames num-frames) -1)))
         (set! (-> a0-9 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      ((= v1-0 4)
       (not (enemy-method-88 obj arg1))
       )
      ((= v1-0 5)
       (set! s5-0 (ja-done? 0))
       (let ((a0-14 (-> obj skel root-channel 0)))
         (set! (-> a0-14 param 0) (the float (+ (-> a0-14 frame-group frames num-frames) -1)))
         (set! (-> a0-14 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-14 (the-as art-joint-anim #f) num-func-seek!)
         )
       (ja-blend-eval)
       s5-0
       )
      (else
        #t
        )
      )
    )
  )

(defstate jump (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logclear! (-> self mask) (process-mask actor-pause))
    (logior! (-> self focus-status) (focus-status dangerous))
    (let* ((v1-6 *game-info*)
           (a0-2 (+ (-> v1-6 attack-id) 1))
           )
      (set! (-> v1-6 attack-id) a0-2)
      (set! (-> self attack-id) a0-2)
      )
    (logclear! (-> self focus-status) (focus-status in-air))
    (none)
    )
  :exit (behavior ()
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'enemy-jump-info)))
      (let ((s5-0 0))
        (enemy-method-83 self gp-0)
        (if (and (-> self enemy-info use-jump-blocked)
                 (logtest? (enemy-flag vulnerable) (-> self enemy-flags))
                 (enemy-method-82 self gp-0)
                 )
            (go-virtual jump-blocked)
            )
        (when (logtest? (-> gp-0 flags) 1)
          (until #f
            (if (enemy-method-90 self s5-0 gp-0)
                (goto cfg-12)
                )
            (enemy-method-91 self s5-0 gp-0)
            (enemy-method-92 self s5-0 (the-as nav-poly gp-0))
            (suspend)
            (set! s5-0 1)
            )
          #f
          )
        )
      (label cfg-12)
      (logclear! (-> self root-override2 status) (collide-status on-surface on-ground touch-surface))
      (let ((s5-1 2))
        (logior! (-> self focus-status) (focus-status in-air))
        (until (enemy-method-86 self)
          (+! (-> gp-0 hang-time) (- (current-time) (-> self clock old-frame-counter)))
          (enemy-method-90 self s5-1 gp-0)
          (enemy-method-91 self s5-1 gp-0)
          (enemy-method-92 self s5-1 (the-as nav-poly gp-0))
          (suspend)
          (set! s5-1 3)
          )
        )
      (logclear! (-> self focus-status) (focus-status in-air))
      (enemy-method-85 self)
      (let ((s5-2 4))
        (until #f
          (if (enemy-method-90 self s5-2 gp-0)
              (goto cfg-19)
              )
          (enemy-method-91 self s5-2 gp-0)
          (enemy-method-92 self s5-2 (the-as nav-poly gp-0))
          (suspend)
          (set! s5-2 5)
          )
        )
      #f
      (label cfg-19)
      (if (logtest? (enemy-flag alert) (-> self enemy-flags))
          ((lambda :behavior enemy
             ((arg0 enemy-jump-info))
             (send-event (ppointer->process (-> self parent)) 'child-jumped)
             (none)
             )
           gp-0
           )
          )
      )
    (enemy-method-93 self)
    (none)
    )
  :post (behavior ()
    (let ((a1-0 (new 'stack-no-clear 'overlaps-others-params)))
      (set! (-> a1-0 options) (overlaps-others-options))
      (set! (-> a1-0 collide-with-filter) (-> self enemy-info overlaps-others-collide-with-filter))
      (set! (-> a1-0 tlist) *touching-list*)
      (find-overlapping-shapes (-> self root-override2) a1-0)
      )
    (enemy-simple-post)
    (none)
    )
  )

(defstate jump-blocked (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (logclear! (-> self mask) (process-mask actor-pause))
    (none)
    )
  :trans (behavior ()
    (when (>= (- (current-time) (-> self state-time)) (seconds 0.5))
      (if (logtest? (enemy-flag alert) (-> self enemy-flags))
          (go-virtual jump)
          (enemy-method-93 self)
          )
      )
    (none)
    )
  :code (behavior ()
    (let ((v1-2 (ja-group)))
      (when (not (and v1-2 (= v1-2 (-> self draw art-group data (-> self enemy-info idle-anim)))))
        (ja-channel-push! 1 (seconds 0.2))
        (ja :group! (-> self draw art-group data (-> self enemy-info idle-anim))
            :num! (identity (rand-vu-float-range 0.0 (the float (+ (-> (ja-group) frames num-frames) -1))))
            )
        )
      )
    (let ((f30-0 (get-rand-float-range self 0.75 1.25)))
      (until #f
        (suspend)
        (ja :num! (loop! f30-0))
        )
      )
    #f
    (none)
    )
  :post enemy-simple-post
  )

(defstate hit (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (stop-looking-at-target! self)
    (logclear! (-> self mask) (process-mask actor-pause))
    (enemy-method-135 self 0)
    (none)
    )
  :code (behavior ()
    (local-vars (v1-37 enemy-flag) (v1-45 enemy-flag))
    (ja-channel-push! 1 (seconds 0.2))
    (let ((f30-0 (get-rand-float-range self 0.9 1.1)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info hit-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info hit-anim))) frames num-frames)
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
        (logior! (-> self focus-status) (focus-status dangerous))
        (logclear! (-> self focus-status) (focus-status dangerous))
        )
    (let ((v1-36 (-> self enemy-flags)))
      (if (logtest? v1-36 (enemy-flag checking-water))
          (set! v1-37 (logior v1-36 (enemy-flag enable-on-active)))
          (set! v1-37 (logclear v1-36 (enemy-flag enable-on-active)))
          )
      )
    (set! (-> self enemy-flags) v1-37)
    (if (logtest? (-> self enemy-flags) (enemy-flag look-at-move-dest))
        (set! (-> self mask) (logior (process-mask collectable) (-> self mask)))
        (logclear! (-> self mask) (process-mask collectable))
        )
    (let ((v1-44 (-> self enemy-flags)))
      (if (logtest? (enemy-flag no-initial-move-to-ground) v1-44)
          (set! v1-45 (logior (enemy-flag check-water-backup) v1-44))
          (set! v1-45 (logclear v1-44 (enemy-flag check-water-backup)))
          )
      )
    (set! (-> self enemy-flags) v1-45)
    (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
    (logclear! (-> self focus-status) (focus-status hit))
    (go-hostile self)
    (none)
    )
  :post enemy-simple-post
  )

;; WARN: Return type mismatch collide-spec vs none.
(defmethod enemy-method-101 enemy ((obj enemy))
  (when (not (logtest? (enemy-flag use-trigger) (-> obj enemy-flags)))
    (set! (-> obj enemy-flags) (logior (enemy-flag use-trigger) (-> obj enemy-flags)))
    (logclear! (-> obj enemy-flags) (enemy-flag directed))
    (enemy-method-124 obj)
    )
  (none)
  )

(defmethod enemy-method-103 enemy ((obj enemy))
  (when (logtest? (enemy-flag use-trigger) (-> obj enemy-flags))
    (logclear! (-> obj enemy-flags) (enemy-flag use-trigger directed))
    (enemy-method-124 obj)
    )
  )

(defmethod enemy-method-102 enemy ((obj enemy))
  #f
  )

;; WARN: Return type mismatch vector vs symbol.
(defmethod enemy-method-100 enemy ((obj enemy))
  (local-vars (v0-1 vector))
  (with-pp
    (when (not (-> obj enemy-info move-to-ground))
      (enemy-method-103 obj)
      (return (the-as symbol #f))
      )
    (when (not (logtest? (enemy-flag directed) (-> obj enemy-flags)))
      (let ((s5-0 (-> obj root-override2)))
        (if (focus-test? obj under-water)
            (enemy-method-47 obj (-> s5-0 transv))
            (+! (-> s5-0 transv y) (* (-> obj enemy-info movement-gravity) (-> pp clock seconds-per-frame)))
            )
        (let ((a2-0 (new 'stack-no-clear 'move-above-ground-params)))
          (let ((v1-16 (-> obj enemy-info)))
            (set! (-> a2-0 gnd-collide-with) (-> v1-16 recover-gnd-collide-with))
            (set! (-> a2-0 popup) 8192.0)
            (set! (-> a2-0 dont-move-if-overlaps?) #t)
            (set! (-> a2-0 hover-if-no-ground?) (-> v1-16 hover-if-no-ground))
            (set! (-> a2-0 overlaps-params options) (overlaps-others-options oo0 oo2))
            (set! (-> a2-0 overlaps-params collide-with-filter) (-> v1-16 overlaps-others-collide-with-filter))
            )
          (set! (-> a2-0 overlaps-params tlist) *touching-list*)
          (-> a2-0 overlaps-params)
          (enemy-method-128 obj (-> s5-0 transv) a2-0)
          )
        )
      )
    (logclear! (-> obj enemy-flags) (enemy-flag directed))
    (if (and (enemy-method-102 obj) (not (logtest? (-> obj focus-status) (focus-status dead))))
        (kill-prefer-falling obj)
        )
    (let ((s5-1 (-> obj root-override2))
          (a1-2 (new 'stack-no-clear 'collide-query))
          (s3-0 (new 'stack-no-clear 'vector))
          (s4-0 (new 'stack-no-clear 'vector))
          )
      (set! (-> s3-0 quad) (-> s5-1 gspot-pos quad))
      (set! (-> s4-0 quad) (-> s5-1 gspot-normal quad))
      (the-as symbol (cond
                       ((find-ground s5-1 a1-2 (-> obj enemy-info gnd-collide-with) 8192.0 81920.0 1024.0)
                        (let ((f0-4 (- (-> s5-1 trans y) (-> s5-1 gspot-pos y))))
                          (when (>= 409.6 (fabs f0-4))
                            (enemy-method-103 obj)
                            (return (the-as symbol #f))
                            v0-1
                            )
                          )
                        )
                       (else
                         (set! (-> s5-1 gspot-pos quad) (-> s3-0 quad))
                         (set! v0-1 (-> s5-1 gspot-normal))
                         (set! (-> v0-1 quad) (-> s4-0 quad))
                         v0-1
                         )
                       )
              )
      )
    )
  )

(defmethod enemy-method-46 enemy ((obj enemy) (arg0 int))
  "@abstract"
  0
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod enemy-method-52 enemy ((obj enemy) (arg0 vector))
  (enemy-method-50 obj arg0)
  (let ((s5-0 (-> obj enemy-info)))
    (case (-> obj incoming knocked-type)
      (((knocked-type knocked-type-2))
       (let ((f30-0 (get-rand-float-range obj 0.0 1.0)))
         (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-hard-vxz-lo) (-> s5-0 knocked-hard-vxz-hi) f30-0))
         (set! (-> arg0 y) (lerp (-> s5-0 knocked-hard-vy-lo) (-> s5-0 knocked-hard-vy-hi) f30-0))
         )
       )
      (((knocked-type knocked-type-1))
       (let ((f30-1 (get-rand-float-range obj 0.0 1.0)))
         (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-medium-vxz-lo) (-> s5-0 knocked-medium-vxz-hi) f30-1))
         (set! (-> arg0 y) (lerp (-> s5-0 knocked-medium-vy-lo) (-> s5-0 knocked-medium-vy-hi) f30-1))
         )
       )
      (((knocked-type knocked-type-3))
       (let ((f30-2 (get-rand-float-range obj 0.0 1.0)))
         (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-huge-vxz-lo) (-> s5-0 knocked-huge-vxz-hi) f30-2))
         (set! (-> arg0 y) (lerp (-> s5-0 knocked-huge-vy-lo) (-> s5-0 knocked-huge-vy-hi) f30-2))
         )
       )
      (((knocked-type knocked-type-4))
       (vector-rotate90-around-y! arg0 arg0)
       (let ((v1-9 (new 'stack-no-clear 'vector)))
         (vector-! v1-9 (-> obj incoming attacker-pos) (-> obj root-override2 trans))
         (set! (-> v1-9 y) 0.0)
         (if (< 0.0 (vector-dot v1-9 arg0))
             (vector-negate! arg0 arg0)
             )
         )
       (let ((f30-3 (get-rand-float-range obj 0.0 1.0)))
         (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-yellow-vxz-lo) (-> s5-0 knocked-yellow-vxz-hi) f30-3))
         (set! (-> arg0 y) (lerp (-> s5-0 knocked-yellow-vy-lo) (-> s5-0 knocked-yellow-vy-hi) f30-3))
         )
       )
      (((knocked-type knocked-type-5))
       (let* ((f1-2 (vector-vector-xz-distance-squared (target-pos 0) (-> obj root-override2 trans)))
              (f0-26 1.0)
              (f2-0 61440.0)
              (f1-3 (fmin f1-2 (* f2-0 f2-0)))
              (f2-3 61440.0)
              (f30-5 (* (- f0-26 (/ f1-3 (* f2-3 f2-3))) (get-rand-float-range obj 0.8 1.0)))
              )
         (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-red-vxz-lo) (-> s5-0 knocked-red-vxz-hi) f30-5))
         (set! (-> arg0 y) (lerp (-> s5-0 knocked-red-vy-lo) (-> s5-0 knocked-red-vy-hi) f30-5))
         )
       )
      (((knocked-type knocked-type-6))
       (let* ((f1-5 (vector-vector-xz-distance-squared (target-pos 0) (-> obj root-override2 trans)))
              (f0-34 1.0)
              (f2-6 122880.0)
              (f1-6 (fmin f1-5 (* f2-6 f2-6)))
              (f2-9 122880.0)
              (f30-7 (* (- f0-34 (/ f1-6 (* f2-9 f2-9))) (get-rand-float-range obj 0.8 1.0)))
              )
         (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-blue-vxz-lo) (-> s5-0 knocked-blue-vxz-hi) f30-7))
         (cond
           ((>= (the-as uint 4) (-> obj incoming blue-juggle-count))
            (set! (-> arg0 y) (lerp (-> s5-0 knocked-blue-vy-lo) (-> s5-0 knocked-blue-vy-hi) f30-7))
            )
           (else
             (if (zero? (get-rand-int obj 3))
                 (set! (-> arg0 y) 40960.0)
                 )
             )
           )
         )
       )
      (((knocked-type knocked-type-7))
       (set! (-> arg0 quad) (-> obj incoming attack-direction quad))
       )
      (else
        (let ((f30-8 (get-rand-float-range obj 0.0 1.0)))
          (vector-float*! arg0 arg0 (lerp (-> s5-0 knocked-soft-vxz-lo) (-> s5-0 knocked-soft-vxz-hi) f30-8))
          (set! (-> arg0 y) (lerp (-> s5-0 knocked-soft-vy-lo) (-> s5-0 knocked-soft-vy-hi) f30-8))
          )
        )
      )
    )
  (none)
  )

(defmethod enemy-method-51 enemy ((obj enemy))
  (let ((f30-0 (quaternion-y-angle (-> obj root-override2 quat))))
    (case (-> obj incoming knocked-type)
      (((knocked-type knocked-type-4) (knocked-type knocked-type-6))
       (let ((a0-5 (handle->process (-> obj focus handle))))
         (when a0-5
           (let ((v1-9 (get-trans (the-as process-focusable a0-5) 0)))
             (set! f30-0
                   (atan (- (-> v1-9 x) (-> obj root-override2 trans x)) (- (-> v1-9 z) (-> obj root-override2 trans z)))
                   )
             )
           )
         )
       )
      (else
        (let* ((v1-13 (-> obj root-override2 transv))
               (f28-0 (atan (-> v1-13 x) (-> v1-13 z)))
               (f1-2 (deg- f30-0 f28-0))
               (f2-0 (fabs f1-2))
               (f0-6 (-> obj enemy-info knocked-seek-ry-clamp))
               )
          (when (and (< f0-6 f2-0) (< f2-0 (- 32768.0 f0-6)))
            (set! f30-0 (+ (cond
                             ((< f2-0 16384.0)
                              (if (>= f1-2 0.0)
                                  f0-6
                                  (- f0-6)
                                  )
                              )
                             ((>= f1-2 0.0)
                              (- 32768.0 f0-6)
                              )
                             (else
                               (+ -32768.0 f0-6)
                               )
                             )
                           f28-0
                           )
                  )
            (if (< f30-0 0.0)
                (set! f30-0 (+ 65536.0 f30-0))
                )
            )
          )
        )
      )
    f30-0
    )
  )

(defmethod enemy-method-77 enemy ((obj enemy) (arg0 (pointer float)))
  (ja-channel-push! 1 0)
  (let ((a1-2 (-> obj draw art-group data (-> obj enemy-info knocked-anim)))
        (a0-4 (-> obj skel root-channel 0))
        )
    (set! (-> a0-4 frame-group) (the-as art-joint-anim a1-2))
    (set! (-> a0-4 param 0) (the float (+ (-> (the-as art-joint-anim a1-2) frames num-frames) -1)))
    (set! (-> a0-4 param 1) (-> arg0 0))
    (set! (-> a0-4 frame-num) 0.0)
    (joint-control-channel-group! a0-4 (the-as art-joint-anim a1-2) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-78 enemy ((obj enemy) (arg0 (pointer float)))
  (let ((v1-4 (-> obj draw art-group data (-> obj enemy-info knocked-land-anim)))
        (a0-3 (-> obj skel root-channel 0))
        )
    (set! (-> a0-3 frame-group) (the-as art-joint-anim v1-4))
    (set! (-> a0-3 param 0) (the float (+ (-> (the-as art-joint-anim v1-4) frames num-frames) -1)))
    (set! (-> a0-3 param 1) (-> arg0 0))
    (set! (-> a0-3 frame-num) 0.0)
    (joint-control-channel-group! a0-3 (the-as art-joint-anim v1-4) num-func-seek!)
    )
  #t
  )

(defmethod enemy-method-80 enemy ((obj enemy) (arg0 enemy-knocked-info))
  (let ((gp-0 (-> obj root-override2)))
    (or (>= (-> arg0 on-surface-count) 3)
        (and (logtest? (-> gp-0 status) (collide-status on-ground)) (>= 16384.0 (-> gp-0 transv y)))
        (and (>= (-> arg0 move-count) 3)
             (let ((f0-1 40.96))
               (>= (* f0-1 f0-1) (vector-vector-distance-squared (-> gp-0 trans-old) (-> gp-0 trans-old-old)))
               )
             (let ((f0-4 40.96))
               (>= (* f0-4 f0-4) (vector-vector-distance-squared (-> gp-0 trans-old-old) (-> gp-0 trans-old-old-old)))
               )
             )
        )
    )
  )

(defmethod enemy-method-81 enemy ((obj enemy))
  (let ((s5-0 (-> obj root-override2))
        (a1-0 (new 'stack-no-clear 'collide-query))
        (gp-0 #t)
        )
    (when (find-ground s5-0 a1-0 (-> obj enemy-info recover-gnd-collide-with) 8192.0 81920.0 1024.0)
      (let ((f0-1 (- (-> s5-0 trans y) (-> s5-0 gspot-pos y))))
        (if (and (>= f0-1 -1228.8) (>= 6144.0 f0-1))
            (set! gp-0 #f)
            )
        )
      )
    gp-0
    )
  )

(defmethod enemy-method-79 enemy ((obj enemy) (arg0 int) (arg1 enemy-knocked-info))
  (local-vars (s5-0 symbol))
  (let ((v1-0 arg0))
    (cond
      ((zero? v1-0)
       (enemy-method-77 obj (the-as (pointer float) arg1))
       (set! s5-0 #f)
       )
      ((= v1-0 1)
       (set! s5-0 (ja-done? 0))
       (let ((a0-4 (-> obj skel root-channel 0)))
         (set! (-> a0-4 param 0) (the float (+ (-> a0-4 frame-group frames num-frames) -1)))
         (set! (-> a0-4 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-4 (the-as art-joint-anim #f) num-func-seek!)
         )
       )
      ((= v1-0 2)
       (set! s5-0 (not (enemy-method-78 obj (the-as (pointer float) arg1))))
       (set! (-> obj incoming blue-juggle-count) (the-as uint 0))
       )
      ((= v1-0 3)
       (set! s5-0 (ja-done? 0))
       (let ((a0-9 (-> obj skel root-channel 0)))
         (set! (-> a0-9 param 0) (the float (+ (-> a0-9 frame-group frames num-frames) -1)))
         (set! (-> a0-9 param 1) (-> arg1 anim-speed))
         (joint-control-channel-group-eval! a0-9 (the-as art-joint-anim #f) num-func-seek!)
         )
       )
      ((= v1-0 4)
       (vector-reset! (-> obj root-override2 transv))
       (set! s5-0 #t)
       )
      (else
        (set! s5-0 #t)
        )
      )
    )
  s5-0
  )

(defstate knocked (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self state-time) (current-time))
    (stop-looking-at-target! self)
    (set! (-> self enemy-flags) (logior (enemy-flag actor-pause-backup) (-> self enemy-flags)))
    (logclear! (-> self mask) (process-mask actor-pause))
    (let* ((v1-8 *game-info*)
           (a0-4 (+ (-> v1-8 attack-id) 1))
           )
      (set! (-> v1-8 attack-id) a0-4)
      (set! (-> self attack-id) a0-4)
      )
    (enemy-method-103 self)
    (if (logtest? (enemy-option knocked-into-water) (-> self fact-info-override enemy-options))
        (set! (-> self enemy-flags) (logior (enemy-flag trackable-backup) (-> self enemy-flags)))
        )
    (let ((v1-16 (-> self root-override2)))
      (logclear! (-> v1-16 status) (collide-status
                                     on-surface
                                     on-ground
                                     touch-surface
                                     touch-wall
                                     touch-ceiling
                                     touch-actor
                                     on-special-surface
                                     touch-edge
                                     blocked
                                     on-water
                                     impact-surface
                                     touch-background
                                     stuck
                                     glance
                                     )
                 )
      (when (not (logtest? (-> v1-16 root-prim prim-core action) (collide-action no-normal-reset)))
        (let ((a0-16 (-> v1-16 dynam gravity-normal)))
          (set! (-> v1-16 local-normal quad) (-> a0-16 quad))
          (set! (-> v1-16 surface-normal quad) (-> a0-16 quad))
          (set! (-> v1-16 poly-normal quad) (-> a0-16 quad))
          )
        (set! (-> v1-16 coverage) 0.0)
        (set! (-> v1-16 touch-angle) 0.0)
        )
      (enemy-method-52 self (-> v1-16 transv))
      )
    (if (>= (-> self enemy-info knocked-seek-ry-clamp) 0.0)
        (set! (-> self desired-angle) (enemy-method-51 self))
        )
    (if (zero? (-> self hit-points))
        (dispose! self)
        (enemy-method-135 self 0)
        )
    (logclear! (-> self focus-status) (focus-status dangerous))
    (if (= (-> self incoming knocked-type) (knocked-type knocked-type-4))
        (logclear! (-> self enemy-flags) (enemy-flag check-water-backup))
        )
    (set! (-> self root-override2 penetrate-using) (penetrate lunge vehicle knocked))
    (enemy-method-49 self)
    (enemy-method-46 self 1)
    (none)
    )
  :exit (behavior ()
    (local-vars (v1-1 enemy-flag) (v1-15 enemy-flag) (v1-23 enemy-flag))
    (let ((v1-0 (-> self enemy-flags)))
      (if (logtest? (enemy-flag enable-on-hostile) v1-0)
          (set! v1-1 (logior (enemy-flag trackable-backup) v1-0))
          (set! v1-1 (logclear v1-0 (enemy-flag trackable-backup)))
          )
      )
    (set! (-> self enemy-flags) v1-1)
    (when (nonzero? (-> self hit-points))
      (set! (-> self root-override2 penetrate-using)
            (the-as penetrate (logclear (-> self root-override2 penetrate-using) (penetrate knocked)))
            )
      (enemy-method-46 self 2)
      (if (logtest? (-> self enemy-flags) (enemy-flag check-water))
          (logior! (-> self focus-status) (focus-status dangerous))
          (logclear! (-> self focus-status) (focus-status dangerous))
          )
      (let ((v1-14 (-> self enemy-flags)))
        (if (logtest? v1-14 (enemy-flag checking-water))
            (set! v1-15 (logior v1-14 (enemy-flag enable-on-active)))
            (set! v1-15 (logclear v1-14 (enemy-flag enable-on-active)))
            )
        )
      (set! (-> self enemy-flags) v1-15)
      (if (logtest? (-> self enemy-flags) (enemy-flag look-at-move-dest))
          (set! (-> self mask) (logior (process-mask collectable) (-> self mask)))
          (logclear! (-> self mask) (process-mask collectable))
          )
      (let ((v1-22 (-> self enemy-flags)))
        (if (logtest? (enemy-flag no-initial-move-to-ground) v1-22)
            (set! v1-23 (logior (enemy-flag check-water-backup) v1-22))
            (set! v1-23 (logclear v1-22 (enemy-flag check-water-backup)))
            )
        )
      (set! (-> self enemy-flags) v1-23)
      (logclear! (-> self enemy-flags) (enemy-flag actor-pause-backup))
      (logclear! (-> self focus-status) (focus-status hit))
      )
    (none)
    )
  :trans (behavior ()
    (if (>= (-> self enemy-info knocked-seek-ry-clamp) 0.0)
        (seek-toward-yaw-angle! (-> self root-override2) (-> self desired-angle) 138353.78 (seconds 0.1))
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'enemy-knocked-info)))
      (let ((s5-0 0))
        (set! (-> gp-0 anim-speed) (get-rand-float-range self 0.9 1.1))
        (set! (-> gp-0 on-surface-count) 0)
        (set! (-> gp-0 move-count) 0)
        (until (enemy-method-80 self gp-0)
          (if (>= (- (current-time) (-> self state-time)) (seconds 2))
              (kill-prefer-falling self)
              )
          (if (logtest? (-> self root-override2 status) (collide-status on-surface))
              (+! (-> gp-0 on-surface-count) 1)
              )
          (enemy-method-79 self s5-0 gp-0)
          (suspend)
          (+! (-> gp-0 move-count) 1)
          (set! s5-0 1)
          )
        )
      (let ((s5-1 2))
        (set! (-> gp-0 land-can-land-time) (current-time))
        (until #f
          (if (logtest? (-> self root-override2 status) (collide-status on-surface))
              (+! (-> gp-0 on-surface-count) 1)
              )
          (if (enemy-method-79 self s5-1 gp-0)
              (goto cfg-15)
              )
          (suspend)
          (+! (-> gp-0 move-count) 1)
          (set! s5-1 3)
          (if (enemy-method-80 self gp-0)
              (set! (-> gp-0 land-can-land-time) (current-time))
              )
          )
        )
      #f
      (label cfg-15)
      (if (and (not (logtest? (enemy-flag recover) (-> self enemy-flags)))
               (or (>= (- (current-time) (-> gp-0 land-can-land-time)) (seconds 0.1))
                   (enemy-method-81 self)
                   (enemy-method-102 self)
                   )
               )
          (kill-prefer-falling self)
          )
      (while (not (enemy-method-79 self 4 gp-0))
        (suspend)
        )
      )
    (enemy-method-101 self)
    (cond
      ((or (zero? (-> self hit-points)) (nonzero? (-> self fated-time)))
       (cond
         ((logtest? (enemy-flag recover) (-> self enemy-flags))
          (set! (-> self hit-points) 0)
          (let ((v1-67 (-> self root-override2 root-prim)))
            (set! (-> v1-67 prim-core collide-as) (collide-spec))
            (set! (-> v1-67 prim-core collide-with) (collide-spec))
            )
          0
          (enemy-method-103 self)
          (send-event self 'death-end)
          (while (-> self child)
            (suspend)
            )
          (cleanup-for-death self)
          )
         (else
           (kill-prefer-falling self)
           )
         )
       )
      (else
        (go-hostile self)
        )
      )
    (none)
    )
  :post enemy-falling-post
  )

(defmethod dispose! enemy ((obj enemy))
  "Cleans-up the enemy and any associated resources. Potentially spawns skull gems"
  (when (not (logtest? (enemy-flag recover-applied-velocity) (-> obj enemy-flags)))
    (set! (-> obj enemy-flags)
          (the-as enemy-flag (logior (enemy-flag recover-applied-velocity) (-> obj enemy-flags)))
          )
    (enemy-method-135 obj 1)
    (when (and (>= (-> obj enemy-info gem-joint) 0)
               (not (logtest? (enemy-flag cam-attack-mode) (-> obj enemy-flags)))
               (or (and (not (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status save))))
                        (-> obj entity)
                        )
                   (task-node-closed? (game-task-node city-win-introduction))
                   (logtest? (-> *game-info* secrets) (game-secrets hero-mode))
                   )
               )
      (set! (-> obj enemy-flags) (logior (enemy-flag cam-attack-mode) (-> obj enemy-flags)))
      (remove-from-process *part-engine* obj)
      (setup-masks
        (-> obj draw)
        (the-as int (-> obj enemy-info gem-no-seg))
        (the-as int (-> obj enemy-info gem-seg))
        )
      (let ((a0-18 (vector<-cspace! (new 'stack-no-clear 'vector) (-> obj node-list data (-> obj enemy-info gem-joint))))
            )
        (birth-pickup-at-point a0-18 (pickup-type gem) 1.0 #t *entity-pool* (-> obj fact-info-override))
        )
      )
    (logclear! (-> obj enemy-flags) (enemy-flag enable-on-active checking-water))
    (logclear! (-> obj focus-status) (focus-status dangerous))
    (logclear! (-> obj enemy-flags) (enemy-flag check-water))
    (logclear! (-> obj mask) (process-mask collectable))
    (logclear! (-> obj enemy-flags) (enemy-flag look-at-move-dest))
    (logclear! (-> obj mask) (process-mask actor-pause))
    (logclear! (-> obj enemy-flags) (enemy-flag notice))
    (logior! (-> obj focus-status) (focus-status dead))
    (if (-> obj skel effect)
        (logior! (-> obj skel effect flags) (effect-control-flag ecf1))
        )
    (stop-looking-at-target! obj)
    )
  (none)
  )

(defstate die (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (dispose! self)
    (let ((v1-3 (-> self root-override2 root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self state-time) (current-time))
    (set! (-> self hit-points) 0)
    (enemy-method-103 self)
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.075))
    (let ((f30-0 (get-rand-float-range self 0.8 1.2)))
      (ja-no-eval :group! (-> self draw art-group data (-> self enemy-info die-anim))
                  :num! (seek!
                    (the float
                         (+ (-> (the-as art-joint-anim (-> self draw art-group data (-> self enemy-info die-anim))) frames num-frames)
                            -1
                            )
                         )
                    f30-0
                    )
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  :post enemy-simple-post
  )

(defmethod enemy-method-133 enemy ((obj enemy))
  (let ((s5-0 (-> obj root-override2))
        (a1-0 (new 'stack-no-clear 'collide-query))
        (gp-0 #t)
        )
    (when (find-ground s5-0 a1-0 (-> obj enemy-info recover-gnd-collide-with) 8192.0 81920.0 1024.0)
      (if (< (- (-> s5-0 trans y) (-> s5-0 gspot-pos y)) 8192.0)
          (set! gp-0 #f)
          )
      )
    gp-0
    )
  )

(defstate die-falling (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (dispose! self)
    (let ((v1-3 (-> self root-override2 root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (set! (-> self hit-points) 0)
    (if (logtest? (enemy-option knocked-into-water) (-> self fact-info-override enemy-options))
        (set! (-> self enemy-flags) (logior (enemy-flag trackable-backup) (-> self enemy-flags)))
        )
    (enemy-method-103 self)
    (none)
    )
  :exit (behavior ()
    (local-vars (v0-0 enemy-flag))
    (let ((v1-0 (-> self enemy-flags)))
      (if (logtest? (enemy-flag enable-on-hostile) v1-0)
          (set! v0-0 (logior (enemy-flag trackable-backup) v1-0))
          (set! v0-0 (logclear v1-0 (enemy-flag trackable-backup)))
          )
      )
    (set! (-> self enemy-flags) v0-0)
    (none)
    )
  :code (behavior ()
    (ja-channel-push! 1 (seconds 0.1))
    (let ((gp-0 (-> self draw art-group data (if (enemy-method-133 self)
                                                 (-> self enemy-info die-falling-anim)
                                                 (-> self enemy-info die-anim)
                                                 )
                    )
                )
          (f30-0 (get-rand-float-range self 0.8 1.2))
          )
      (ja-no-eval :group! gp-0
                  :num! (seek! (the float (+ (-> (the-as art-joint-anim gp-0) frames num-frames) -1)) f30-0)
                  :frame-num 0.0
                  )
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (send-event self 'death-end)
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    (none)
    )
  :post enemy-die-falling-post
  )

(defstate directed (enemy)
  :virtual #t
  :event enemy-event-handler
  :enter (behavior ()
    (set! (-> self enemy-flags) (logior (enemy-flag victory) (-> self enemy-flags)))
    ((-> (method-of-type enemy idle) enter))
    (none)
    )
  :exit (behavior ()
    (logclear! (-> self enemy-flags) (enemy-flag victory))
    (none)
    )
  :code (-> (method-of-type enemy idle) code)
  :post (-> (method-of-type enemy idle) post)
  )

(defstate die-fast (enemy)
  :virtual #t
  :code (the-as (function none :behavior enemy) nothing)
  )

(defstate view-anims (enemy)
  :virtual #t
  :enter (behavior ()
    '()
    (none)
    )
  :trans (behavior ()
    '()
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self draw art-group)))
      (until #f
        (dotimes (s5-0 (-> gp-0 length))
          (let ((s4-0 (-> gp-0 data s5-0)))
            (when (and s4-0 (= (-> s4-0 type) art-joint-anim))
              (ja-channel-set! 1)
              (ja-no-eval :group! s4-0
                          :num! (seek! (the float (+ (-> (the-as art-joint-anim s4-0) frames num-frames) -1)))
                          :frame-num 0.0
                          )
              (until (ja-done? 0)
                (suspend)
                (ja :num! (seek!))
                )
              )
            )
          )
        )
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior enemy) transform-post)
  )

(defbehavior ja-group-index? enemy ((arg0 int))
  (ja-group? (-> self draw art-group data arg0))
  )
