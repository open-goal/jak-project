;;-*-Lisp-*-
(in-package goal)

;; name: pov-camera.gc
;; name in dgo: pov-camera
;; dgos: ENGINE, GAME

;; DECOMP BEGINS

;;-*-Lisp-*-
(in-package goal)

;; definition for method 25 of type pov-camera
(defmethod abort? pov-camera ((obj pov-camera))
  (when (or (and (>= (- (-> self clock frame-counter) (-> obj debounce-start-time)) (seconds 0.2))
                 (cpad-pressed? 0 triangle)
                 )
            (logtest? (-> obj flags) (pov-camera-flag allow-abort))
            )
    (logclear! (-> *cpad-list* cpads 0 button0-abs 0) (pad-buttons triangle))
    (logclear! (-> *cpad-list* cpads 0 button0-rel 0) (pad-buttons triangle))
    (when (logtest? (-> obj flags) (pov-camera-flag notify-of-abort))
      (send-event (handle->process (-> obj notify-handle)) 'notify 'abort-request)
      #t
      )
    )
  )

;; definition for method 26 of type pov-camera
(defmethod target-grabbed? pov-camera ((obj pov-camera))
  (or (not *target*) (process-grab? *target* #f))
  )

;; definition for method 29 of type pov-camera
(defmethod target-released? pov-camera ((obj pov-camera))
  (or (not *target*) (process-release? *target*))
  )

;; failed to figure out what this is:
(defstate pov-camera-startup (pov-camera)
  :virtual #t
  :code (behavior ()
    (go-virtual pov-camera-start-playing)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pov-camera-start-playing (pov-camera)
  :virtual #t
  :code (behavior ()
    (logclear! (-> self mask) (process-mask actor-pause))
    (while (not (target-grabbed? self))
      (suspend)
      )
    (let ((gp-0 0))
      (let ((v1-7 (the-as joint (get-art-by-name-method (-> self draw jgeo) "camera" (the-as type #f)))))
        (if v1-7
            (set! gp-0 (+ (-> v1-7 number) 1))
            )
        )
      (let ((v1-10 (process-spawn othercam self gp-0 #t #t :to self)))
        (send-event (ppointer->process v1-10) 'mask (-> self mask-to-clear))
        )
      )
    (go-virtual pov-camera-playing)
    (none)
    )
  )

;; definition for function pov-camera-play-and-reposition
;; WARN: Return type mismatch int vs none.
(defbehavior pov-camera-play-and-reposition pov-camera ((arg0 art-joint-anim) (arg1 vector) (arg2 float))
  (let ((s4-0 #f))
    (ja-no-eval :group! arg0 :num! (seek! (the float (+ (-> arg0 frames num-frames) -1)) arg2) :frame-num 0.0)
    (until (ja-done? 0)
      (let ((v1-4 (and (not s4-0) (< (the float (+ (-> (ja-group) frames num-frames) -4)) (ja-frame-num 0)))))
        (when v1-4
          (set! s4-0 #t)
          (send-event *camera* 'teleport-to-vector-start-string arg1)
          )
        )
      (suspend)
      (ja :num! (seek! max arg2))
      )
    )
  0
  (none)
  )

;; failed to figure out what this is:
(defstate pov-camera-playing (pov-camera)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('abort)
       (when (logtest? (-> self flags) (pov-camera-flag notify-of-abort))
         (logior! (-> self flags) (pov-camera-flag allow-abort))
         (if (= (-> self anim-name type) string)
             (go-virtual pov-camera-abort)
             )
         )
       )
      )
    )
  :enter (behavior ()
    (set! (-> self debounce-start-time) (-> self clock frame-counter))
    (if (= (-> self anim-name type) string)
        (backup-load-state-and-set-cmds *load-state* (-> self command-list))
        )
    (none)
    )
  :exit (behavior ()
    (if (= (-> self anim-name type) string)
        (restore-load-state-and-cleanup *load-state*)
        )
    (remove-setting! 'music-volume)
    (remove-setting! 'sfx-volume)
    (none)
    )
  :code (behavior ()
    (add-setting! 'music-volume 'rel (-> self music-volume-movie) 0)
    (add-setting! 'sfx-volume 'rel (-> self sfx-volume-movie) 0)
    (cond
      ((= (-> self anim-name type) string)
       (ja-no-eval :group! (ja-group)
                   :num! (seek! (the float (+ (-> (ja-group) frames num-frames) -1)))
                   :frame-num 0.0
                   )
       (until (ja-done? 0)
         (abort? self)
         (suspend)
         (ja :num! (seek!))
         )
       )
      ((= (-> self anim-name type) spool-anim)
       (ja-play-spooled-anim
         (the-as spool-anim (-> self anim-name))
         (the-as art-joint-anim #f)
         (the-as art-joint-anim #f)
         (method-of-object self abort?)
         )
       )
      )
    (go-virtual pov-camera-done-playing)
    (none)
    )
  :post (behavior ()
    (if (= (-> self anim-name type) string)
        (execute-commands-up-to *load-state* (ja-aframe-num 0))
        )
    (ja-post)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pov-camera-abort (pov-camera)
  :virtual #t
  :enter (behavior ()
    (logior! (-> self flags) (pov-camera-flag allow-abort))
    (none)
    )
  :code (behavior ()
    (set-blackout-frames (seconds 0.035))
    (suspend)
    (suspend)
    (go-virtual pov-camera-done-playing)
    (none)
    )
  )

;; failed to figure out what this is:
(defstate pov-camera-done-playing (pov-camera)
  :virtual #t
  :code (behavior ()
    (while (not (target-released? self))
      (suspend)
      )
    (send-event (handle->process (-> self notify-handle)) 'notify 'die)
    (suspend)
    (suspend)
    (cleanup-for-death self)
    (deactivate self)
    (none)
    )
  )

;; definition for method 28 of type pov-camera
;; WARN: Return type mismatch int vs none.
(defmethod pov-camera-method-28 pov-camera ()
  0
  (none)
  )

;; definition for method 27 of type pov-camera
;; WARN: Return type mismatch int vs none.
(defmethod pov-camera-method-27 pov-camera ()
  0
  (none)
  )

;; definition for function pov-camera-init-by-other
;; INFO: Used lq/sq
;; WARN: Return type mismatch object vs none.
(defbehavior pov-camera-init-by-other pov-camera ((arg0 vector) (arg1 skeleton-group) (arg2 string) (arg3 pov-camera-flag) (arg4 process-drawable) (arg5 pair))
  ((method-of-object self pov-camera-method-27))
  (set! (-> *game-info* pov-camera-handle) (process->handle self))
  (set! (-> self flags) arg3)
  (set! (-> self command-list) arg5)
  (set! (-> self music-volume-movie) 100.0)
  (set! (-> self sfx-volume-movie) 100.0)
  (if arg4
      (set! (-> self notify-handle) (process->handle arg4))
      (set! (-> self notify-handle) (the-as handle #f))
      )
  (set! (-> self debounce-start-time) (-> self clock frame-counter))
  (logclear! (-> self mask) (process-mask actor-pause movie enemy platform projectile))
  (set! (-> self root) (new 'process 'trsqv))
  (set! (-> self root trans quad) (-> arg0 quad))
  (when (logtest? (-> self flags) (pov-camera-flag inherit-orientation))
    (let ((v1-21 (if (type? arg4 process-drawable)
                     arg4
                     )
                 )
          )
      (quaternion-copy! (-> self root quat) (-> v1-21 root quat))
      )
    )
  (initialize-skeleton self arg1 (the-as pair 0))
  (logior! (-> self draw status) (draw-control-status no-draw-bounds))
  (logior! (-> self skel status) (joint-control-status sync-math))
  (set! (-> self anim-name) arg2)
  (cond
    ((= (-> arg2 type) string)
     (logior! (-> self skel status) (joint-control-status valid-spooled-frame))
     (let ((s5-1 (get-art-by-name (-> self draw art-group) arg2 art-joint-anim)))
       (if (not s5-1)
           (go process-drawable-art-error arg2)
           )
       (ja-channel-set! 1)
       (set! (-> self skel root-channel 0 frame-group) s5-1)
       )
     )
    ((= (-> arg2 type) spool-anim)
     )
    )
  (set! (-> self mask-to-clear) (process-mask movie enemy platform projectile))
  (set! (-> self event-hook)
        (lambda :behavior pov-camera
          ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
          (the-as object (case arg2
                           (('mask)
                            (let ((v0-0 (the-as number (-> arg3 param 0))))
                              (set! (-> self mask-to-clear) (the-as process-mask v0-0))
                              v0-0
                              )
                            )
                           (('music-movie-volume)
                            (set! (-> self music-volume-movie) (the-as float (-> arg3 param 0)))
                            )
                           (('sfx-movie-volume)
                            (set! (-> self sfx-volume-movie) (the-as float (-> arg3 param 0)))
                            )
                           )
                  )
          )
        )
  ((method-of-object self pov-camera-method-28))
  (go-virtual pov-camera-startup)
  (none)
  )

;; definition for function othercam-calc
(defun othercam-calc ((arg0 float))
  (set! (-> *camera-other-fov* data) (* 2.0 (atan (/ 14.941477 (* 20.3 arg0)) 1.0)))
  )

;; failed to figure out what this is:
(defstate othercam-running (othercam)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (case event-type
      (('die)
       (set! v0-0 #t)
       (set! (-> self die?) (the-as symbol v0-0))
       v0-0
       )
      (('joint)
       (cond
         ((type? (-> event param 0) string)
          (let ((v1-7 (the-as joint (get-art-by-name-method
                                      (-> (the-as process-drawable (-> self hand process 0)) draw jgeo)
                                      (the-as string (-> event param 0))
                                      (the-as type #f)
                                      )
                              )
                      )
                )
            (when v1-7
              (set! v0-0 (+ (-> v1-7 number) 1))
              (set! (-> self cam-joint-index) (the-as int v0-0))
              v0-0
              )
            )
          )
         ((not (logtest? (-> event param 0) 7))
          (set! v0-0 (/ (the-as int (-> event param 0)) 8))
          (set! (-> self cam-joint-index) (the-as int v0-0))
          v0-0
          )
         )
       )
      (('target)
       (set! v0-0 (process->handle (the-as process (-> event param 0))))
       (set! (-> self hand) (the-as handle v0-0))
       v0-0
       )
      (('mask)
       (set! v0-0 (-> event param 0))
       (set! (-> self mask-to-clear) (the-as process-mask v0-0))
       v0-0
       )
      )
    )
  :enter (behavior ()
    (hide-hud-quick #f)
    (case (-> self spooling?)
      (('logo 'scene-player)
       )
      (else
        (add-setting! 'process-mask 'set 0 (-> self mask-to-clear))
        (add-setting! 'movie (process->ppointer self) 0 0)
        (if (not (-> self border-value))
            (add-setting! 'border-mode (-> self border-value) 0 0)
            )
        )
      )
    (set! (-> self had-valid-frame) #f)
    (let ((gp-0 (the-as process-drawable (-> self hand process 0))))
      (vector<-cspace! (-> self old-pos) (-> gp-0 node-list data (-> self cam-joint-index)))
      (let ((v1-20 (-> gp-0 node-list data (-> self cam-joint-index) bone transform)))
        (vector-normalize-copy! (-> self old-mat-z) (-> v1-20 vector 2) -1.0)
        )
      )
    (apply-settings *setting-control*)
    (none)
    )
  :exit (behavior ()
    (remove-setting! 'process-mask)
    (apply-settings *setting-control*)
    (none)
    )
  :code (behavior ()
    (until #f
      (let ((s2-0 (the-as process-drawable (-> self hand process 0))))
        (when (not s2-0)
          (format #t "ERROR<GMJ>: othercam parent invalid~%")
          (deactivate self)
          )
        (set! (-> *camera-other-root* quad) (-> s2-0 root trans quad))
        (let ((s4-0 (-> s2-0 node-list data (-> self cam-joint-index) bone transform))
              (s3-0 (-> s2-0 node-list data (-> self cam-joint-index) bone scale))
              (gp-0 (new 'stack-no-clear 'vector))
              (s5-0 (new 'stack-no-clear 'vector))
              (s1-0
                (or (!= (-> self spooling?) #t) (logtest? (-> s2-0 skel status) (joint-control-status valid-spooled-frame)))
                )
              )
          (vector<-cspace! s5-0 (-> s2-0 node-list data (-> self cam-joint-index)))
          (vector-normalize-copy! gp-0 (-> s4-0 vector 2) -1.0)
          (cond
            ((< (vector-length (-> s4-0 vector 2)) 0.1)
             (set-blackout-frames (seconds 0.017))
             (if (not (logtest? (-> s2-0 draw status) (draw-control-status no-draw no-draw-temp)))
                 (format 0 "ERROR: other camera zero matrix!~%")
                 )
             )
            (s1-0
              (when (not (-> self had-valid-frame))
                (set! (-> self had-valid-frame) (the-as basic #t))
                (set! (-> self old-pos quad) (-> s5-0 quad))
                (set! (-> self old-mat-z quad) (-> gp-0 quad))
                )
              (set! (-> *camera-other-trans* quad) (-> s5-0 quad))
              (vector-normalize-copy!
                (the-as vector (-> *camera-other-matrix* vector))
                (the-as vector (-> s4-0 vector))
                -1.0
                )
              (set! (-> *camera-other-matrix* vector 0 w) 0.0)
              (vector-normalize-copy! (-> *camera-other-matrix* vector 1) (-> s4-0 vector 1) 1.0)
              (set! (-> *camera-other-matrix* vector 1 w) 0.0)
              (vector-normalize-copy! (-> *camera-other-matrix* vector 2) (-> s4-0 vector 2) -1.0)
              (set! (-> *camera-other-matrix* vector 2 w) 0.0)
              (vector-reset! (-> *camera-other-matrix* trans))
              (set! (-> self fov) (othercam-calc (-> s3-0 x)))
              (set! *camera-look-through-other* 2)
              (set! (-> self old-pos quad) (-> s5-0 quad))
              (set! (-> self old-mat-z quad) (-> gp-0 quad))
              )
            )
          )
        )
      (suspend)
      (let ((a0-27 (-> self hand process 0)))
        (when (or (-> self die?) (and (not (-> self survive-anim-end?)) (ja-anim-done? a0-27)))
          (let ((gp-1 (-> self clock frame-counter)))
            (while (and (< (- (-> self clock frame-counter) gp-1) (seconds 60))
                        (or (and (-> self entity) (not (is-object-visible? (-> self level) (-> self entity extra vis-id))))
                            (< 81920.0 (vector-vector-distance (camera-pos) (-> *math-camera* trans)))
                            )
                        )
              (suspend)
              )
            )
          (deactivate self)
          )
        )
      )
    #f
    (none)
    )
  )

;; definition for function othercam-init-by-other
;; WARN: Return type mismatch int vs none.
(defbehavior othercam-init-by-other othercam ((arg0 pov-camera) (arg1 int) (arg2 symbol) (arg3 symbol))
  (set! (-> self spooling?) arg3)
  (case (-> self spooling?)
    (('logo)
     )
    (else
      (set! (-> *game-info* other-camera-handle) (process->handle self))
      )
    )
  (set! (-> self hand) (process->handle arg0))
  (set! (-> self cam-joint-index) arg1)
  (logclear! (-> self mask) (process-mask freeze pause menu actor-pause))
  (set! (-> self border-value) #f)
  (set! (-> self die?) #f)
  (set! (-> self survive-anim-end?) arg2)
  (set! (-> self mask-to-clear) (process-mask movie enemy platform projectile))
  (set! (-> self event-hook) (-> othercam-running event))
  (go othercam-running)
  0
  (none)
  )




