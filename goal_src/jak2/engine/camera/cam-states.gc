;;-*-Lisp-*-
(in-package goal)

;; name: cam-states.gc
;; name in dgo: cam-states
;; dgos: ENGINE, GAME

(define-extern cam-string-code (function vector :behavior camera-slave))

;; DECOMP BEGINS

(defstate cam-really-fixed (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-fixed (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (set! (-> self trans quad) (-> self saved-pt quad))
          (cam-curve-pos (-> self trans) gp-0 (the-as curve #f) #f)
          (when (!= (-> gp-0 w) 0.0)
            (vector-normalize! gp-0 1.0)
            (forward-down->inv-matrix (the-as matrix (-> self tracking)) gp-0 (-> *camera* local-down))
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-fixed-read-entity (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) (-> self trans) 'trans)
       (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
       (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
       (cam-curve-setup (-> self trans))
       ((-> cam-fixed enter))
       )
      (else
        (format #t "ERROR <GMJ>: cam-fixed-read-entity enter without entity~%")
        )
      )
    (go cam-fixed)
    (none)
    )
  :code (behavior ()
    (until #f
      (format *stdcon* "ERROR <GMJ>: stayed in cam-fixed-read-entity~%")
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-pov (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> *camera* settings pov-handle)))
      (set! (-> self blend-from-type) (the-as uint 0))
      (cam-slave-go cam-fixed)
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (vector<-cspace! (-> self trans) (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                                             node-list
                                             data
                                             (-> *camera* settings pov-bone)
                                             )
                         )
        (let* ((v1-6 (-> self tracking))
               (a3-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                         node-list
                         data
                         (-> *camera* settings pov-bone)
                         bone
                         transform
                         )
                     )
               (a0-9 (-> a3-0 quad 0))
               (a1-11 (-> a3-0 quad 1))
               (a2-0 (-> a3-0 quad 2))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> v1-6 inv-mat quad 0) a0-9)
          (set! (-> v1-6 inv-mat quad 1) a1-11)
          (set! (-> v1-6 inv-mat quad 2) a2-0)
          (set! (-> v1-6 inv-mat trans quad) a3-1)
          )
        (vector-reset! (-> self tracking inv-mat trans))
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector-matrix*! gp-0 (-> *camera* settings pov-offset) (the-as matrix (-> self tracking)))
          (vector+! (-> self trans) (-> self trans) gp-0)
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-pov180 (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> *camera* settings pov-handle)))
      (set! (-> self blend-from-type) (the-as uint 0))
      (cam-slave-go cam-fixed)
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          (s4-0 #t)
          )
      (vector<-cspace! gp-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                                node-list
                                data
                                (-> *camera* settings pov-bone)
                                )
                       )
      (let ((v1-13 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                       node-list
                       data
                       (-> *camera* settings pov-bone)
                       bone
                       transform
                       )
                   )
            )
        (vector-normalize-copy! s5-0 (-> v1-13 vector 2) 1.0)
        )
      (until #f
        (when (not (paused?))
          (let ((s0-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                          node-list
                          data
                          (-> *camera* settings pov-bone)
                          bone
                          transform
                          )
                      )
                (s1-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                          node-list
                          data
                          (-> *camera* settings pov-bone)
                          bone
                          scale
                          )
                      )
                (s3-0 (new 'stack-no-clear 'vector))
                )
            (let ((s2-0 (new 'stack-no-clear 'vector)))
              (vector<-cspace!
                s2-0
                (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                    node-list
                    data
                    (-> *camera* settings pov-bone)
                    )
                )
              (vector-normalize-copy! s3-0 (-> s0-0 vector 2) 1.0)
              (set! s4-0
                    (cond
                      ((and (< (vector-vector-distance s2-0 gp-0) 40960.0) (< (cos 3640.889) (vector-dot s5-0 s3-0)))
                       (set! (-> self trans quad) (-> s2-0 quad))
                       (vector-negate! (the-as vector (-> self tracking)) (the-as vector (-> s0-0 vector)))
                       (set! (-> (the-as vector (-> self tracking inv-mat vector 1)) quad) (-> s0-0 vector 1 quad))
                       (vector-negate! (-> self tracking inv-mat vector 2) (-> s0-0 vector 2))
                       (set! (-> self fov) (* 2.0 (atan (/ 12.700255 (* 20.3 (-> s1-0 x))) 1.0)))
                       (vector-float*! (the-as vector (-> self tracking)) (the-as vector (-> self tracking)) (/ 1.0 (-> s1-0 x)))
                       (vector-reset! (-> self tracking inv-mat trans))
                       (if s4-0
                           (set! s4-0 #f)
                           )
                       s4-0
                       )
                      (else
                        #t
                        )
                      )
                    )
              (set! (-> gp-0 quad) (-> s2-0 quad))
              )
            (set! (-> s5-0 quad) (-> s3-0 quad))
            )
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defstate cam-pov-track (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :trans (behavior ()
    (if (or (not (handle->process (-> *camera* settings pov-handle)))
            (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
            )
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (set! (-> self fov) (-> *camera* settings fov))
        (vector<-cspace! (-> self trans) (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                                             node-list
                                             data
                                             (-> *camera* settings pov-bone)
                                             )
                         )
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (let ((a2-0 (new 'stack-no-clear 'matrix)))
            (let* ((v1-8 a2-0)
                   (t0-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                             node-list
                             data
                             (-> *camera* settings pov-bone)
                             bone
                             transform
                             )
                         )
                   (a0-9 (-> t0-0 quad 0))
                   (a1-11 (-> t0-0 quad 1))
                   (a3-0 (-> t0-0 quad 2))
                   (t0-1 (-> t0-0 trans quad))
                   )
              (set! (-> v1-8 quad 0) a0-9)
              (set! (-> v1-8 quad 1) a1-11)
              (set! (-> v1-8 quad 2) a3-0)
              (set! (-> v1-8 trans quad) t0-1)
              )
            (vector-reset! (-> a2-0 trans))
            (vector-matrix*! gp-0 (-> *camera* settings pov-offset) a2-0)
            )
          (vector+! (-> self trans) (-> self trans) gp-0)
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defbehavior cam-standoff-calc-trans camera-slave ()
  (if (-> self tracking no-follow)
      (vector+! (-> self trans) (-> *camera* tpos-curr-adj) (-> self pivot-pt))
      (vector+! (-> self trans) (-> self tracking follow-pt) (-> self pivot-pt))
      )
  )

(defstate cam-standoff (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (cond
                       ((= v1-0 'set-standoff-dist)
                        (vector-normalize! (-> self pivot-pt) (the-as float (-> event param 0)))
                        (cam-standoff-calc-trans)
                        )
                       ((= v1-0 'set-standoff-height)
                        (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
                        (vector--float*!
                          (-> self pivot-pt)
                          (-> self pivot-pt)
                          (-> *camera* local-down)
                          (the-as float (-> event param 0))
                          )
                        (cam-standoff-calc-trans)
                        )
                       (else
                         (the-as vector (cam-standard-event-handler proc arg1 event-type event))
                         )
                       )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (vector-! (-> self pivot-pt) (-> self trans) (-> *camera* tpos-curr-adj))
      (cond
        ((logtest? (-> self options) (cam-slave-options-u32 NO_ROTATE))
         (set! (-> self blend-from-type) (the-as uint 0))
         (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
         0
         )
        (else
          (set! (-> self blend-from-type) (the-as uint 2))
          (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
          )
        )
      )
    (cam-calc-follow! (-> self tracking) (-> self trans) #f)
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (cam-calc-follow! (-> self tracking) (-> self trans) #t)
        (cam-standoff-calc-trans)
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-standoff-read-entity (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (let ((gp-0 (new-stack-vector0))
             (s5-0 (new-stack-vector0))
             )
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) s5-0 'align)
         (vector-! (-> self pivot-pt) gp-0 s5-0)
         )
       (vector+! (-> self trans) (-> *camera* tpos-curr-adj) (-> self pivot-pt))
       (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
       (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
       (if (logtest? (-> self options) (cam-slave-options-u32 NO_ROTATE))
           (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
           (set! (-> self tracking tilt-adjust target)
                 (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                 )
           )
       ((-> cam-standoff enter))
       )
      (else
        (format #t "ERROR <GMJ>: cam-standoff-read-entity enter without entity~%")
        )
      )
    (go cam-standoff)
    (none)
    )
  :code (behavior ()
    (until #f
      (format *stdcon* "ERROR <GMJ>: stayed in cam-standoff-read-entity~%")
      (suspend)
      )
    #f
    (none)
    )
  )

(deftype cam-eye-bank (basic)
  ((rot-speed   float  :offset-assert   4)
   (max-degrees float  :offset-assert   8)
   (max-fov     float  :offset-assert  12)
   (min-fov     float  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_EYE-bank*
  (new 'static 'cam-eye-bank :rot-speed 364.0889 :max-degrees 12743.111 :max-fov 11650.845 :min-fov 6189.511)
  )

(defstate cam-eye (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((v1-3
              (vector-float*! (new-stack-vector0) (-> *camera* local-down) (+ 1024.0 (-> *camera* settings target-height)))
              )
            )
        (vector-! (-> self trans) (-> *camera* tpos-curr) v1-3)
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (set! (-> self fov) 11650.845)
    (none)
    )
  :exit (behavior ()
    (if (and *target*
             (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET))
             (focus-test? *target* in-head)
             )
        (send-event *target* 'end-mode)
        )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (current-time)))
      (until #f
        (when (not (paused?))
          (let ((s4-0 (vector-reset! (new-stack-vector0)))
                (s5-0 (new-stack-matrix0))
                )
            (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
              (let ((f30-0 (analog-input
                             (the-as int (+ (-> *cpad-list* cpads 0 rightx) -256 (-> *cpad-list* cpads 0 leftx)))
                             0.0
                             48.0
                             110.0
                             -1.0
                             )
                           )
                    (f0-0 (analog-input
                            (the-as int (+ (-> *cpad-list* cpads 0 righty) -256 (-> *cpad-list* cpads 0 lefty)))
                            0.0
                            48.0
                            110.0
                            -1.0
                            )
                          )
                    )
                (set! (-> s4-0 y) (- (-> s4-0 y) (* (- f30-0) (-> *CAM_EYE-bank* rot-speed))))
                (set! (-> s4-0 x) (- (-> s4-0 x) (* (- f0-0) (-> *CAM_EYE-bank* rot-speed))))
                )
              )
            (cond
              ((< (-> *CAM_EYE-bank* rot-speed) (-> s4-0 x))
               (set! (-> s4-0 x) (-> *CAM_EYE-bank* rot-speed))
               )
              ((< (-> s4-0 x) (- (-> *CAM_EYE-bank* rot-speed)))
               (set! (-> s4-0 x) (- (-> *CAM_EYE-bank* rot-speed)))
               )
              )
            (cond
              ((< (-> *CAM_EYE-bank* rot-speed) (-> s4-0 y))
               (set! (-> s4-0 y) (-> *CAM_EYE-bank* rot-speed))
               )
              ((< (-> s4-0 y) (- (-> *CAM_EYE-bank* rot-speed)))
               (set! (-> s4-0 y) (- (-> *CAM_EYE-bank* rot-speed)))
               )
              )
            (cond
              ((and (= (-> s4-0 x) 0.0) (= (-> s4-0 y) 0.0))
               (set! gp-0 (current-time))
               )
              (else
                (let ((v1-39 (min 10 (max 1 (- (current-time) gp-0)))))
                  (vector-float*! s4-0 s4-0 (* 0.1 (the float v1-39)))
                  )
                )
              )
            (matrix-axis-angle! s5-0 (-> *camera* local-down) (-> s4-0 y))
            (matrix*! (the-as matrix (-> self tracking)) (the-as matrix (-> self tracking)) s5-0)
            (when (not (logtest? (-> self options) (cam-slave-options-u32 ALLOW_Z_ROT)))
              (if (< (vector-dot (-> self tracking inv-mat vector 1) (-> *camera* local-down)) 0.0)
                  (forward-down->inv-matrix
                    (the-as matrix (-> self tracking))
                    (-> self tracking inv-mat vector 2)
                    (-> *camera* local-down)
                    )
                  (forward-down->inv-matrix
                    (the-as matrix (-> self tracking))
                    (-> self tracking inv-mat vector 2)
                    (vector-negate! (new-stack-vector0) (-> *camera* local-down))
                    )
                  )
              )
            (matrix-axis-angle! s5-0 (the-as vector (-> self tracking)) (- (-> s4-0 x)))
            (matrix*! (the-as matrix (-> self tracking)) (the-as matrix (-> self tracking)) s5-0)
            )
          (when (not (logtest? (-> self options) (cam-slave-options-u32 ALLOW_Z_ROT)))
            (let ((f30-1 (vector-dot (-> *camera* local-down) (-> self tracking inv-mat vector 2))))
              (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
              (when (< (sin (-> *CAM_EYE-bank* max-degrees)) (fabs f30-1))
                (vector--float*!
                  (-> self tracking inv-mat vector 2)
                  (-> self tracking inv-mat vector 2)
                  (-> *camera* local-down)
                  f30-1
                  )
                (vector-normalize! (-> self tracking inv-mat vector 2) (cos (-> *CAM_EYE-bank* max-degrees)))
                (if (< f30-1 0.0)
                    (vector--float*!
                      (-> self tracking inv-mat vector 2)
                      (-> self tracking inv-mat vector 2)
                      (-> *camera* local-down)
                      (sin (-> *CAM_EYE-bank* max-degrees))
                      )
                    (vector+float*!
                      (-> self tracking inv-mat vector 2)
                      (-> self tracking inv-mat vector 2)
                      (-> *camera* local-down)
                      (sin (-> *CAM_EYE-bank* max-degrees))
                      )
                    )
                (vector-cross!
                  (-> self tracking inv-mat vector 1)
                  (-> self tracking inv-mat vector 2)
                  (the-as vector (-> self tracking))
                  )
                (set! (-> self tracking inv-mat vector 1 w) 0.0)
                )
              )
            )
          )
        (let ((v1-70
                (vector-float*! (new-stack-vector0) (-> *camera* local-down) (+ 1024.0 (-> *camera* settings target-height)))
                )
              )
          (vector-! (-> self trans) (-> *camera* tpos-curr) v1-70)
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defstate cam-spline (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (let ((gp-0 (new-stack-vector0)))
         (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
         (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
         (if (logtest? (-> self options) (cam-slave-options-u32 NO_ROTATE))
             (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
             (set! (-> self tracking tilt-adjust target)
                   (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                   )
             )
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
         (cam-curve-setup gp-0)
         )
       (vector-negate! (-> self saved-pt) (-> self spline-offset))
       (let ((a0-8 (res-lump-struct (-> self cam-entity) 'spline-offset structure)))
         (if a0-8
             (vector+! (-> self spline-offset) (-> self spline-offset) (the-as vector a0-8))
             )
         )
       (set! (-> self trans quad) (-> self saved-pt quad))
       (cam-calc-follow! (-> self tracking) (-> self trans) #f)
       (set! (-> self spline-follow-dist) (cam-slave-get-float (-> self cam-entity) 'spline-follow-dist 0.0))
       (cond
         ((< 0.0 (-> self spline-follow-dist))
          (let ((s5-1 (new 'stack-no-clear 'vector))
                (gp-1 (new 'stack-no-clear 'vector))
                )
            (curve-get-pos! s5-1 0.0 (-> self spline-curve))
            (curve-get-pos! gp-1 1.0 (-> self spline-curve))
            (if (< (vector-vector-distance-squared s5-1 (-> self tracking follow-pt))
                   (vector-vector-distance-squared gp-1 (-> self tracking follow-pt))
                   )
                (set! (-> self spline-follow-dist) (- (-> self spline-follow-dist)))
                )
            )
          (set! (-> self spline-tt) (curve-closest-point
                                      (-> self spline-curve)
                                      (-> self tracking follow-pt)
                                      0.5
                                      -4096.0
                                      10
                                      (-> self spline-follow-dist)
                                      )
                )
          )
         (else
           (set! (-> self spline-follow-dist) 0.0)
           )
         )
       (cam-curve-pos (-> self trans) (the-as vector #f) (the-as curve #f) #t)
       (cond
         ((logtest? (-> self options) (cam-slave-options-u32 NO_ROTATE))
          (set! (-> self blend-from-type) (the-as uint 0))
          (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
          0
          )
         (else
           (set! (-> self blend-from-type) (the-as uint 2))
           (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
           )
         )
       )
      (else
        (format #t "ERROR <GMJ>: cam-spline enter without entity~%")
        )
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (cam-calc-follow! (-> self tracking) (-> self trans) #t)
        (new 'stack 'curve)
        (set! (-> self trans quad) (-> self saved-pt quad))
        (cam-curve-pos (-> self trans) (the-as vector #f) (the-as curve #f) #t)
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-decel (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (let ((s5-0 (new-stack-vector0))
              (gp-0 (new-stack-vector0))
              )
          (when (!= (-> *camera* outro-t-step) 0.0)
            (curve-get-pos! s5-0 (parameter-ease-sin-clamp (-> *camera* outro-t)) (-> *camera* outro-curve))
            (+! (-> *camera* outro-t) (* (-> *camera* outro-t-step) (-> self clock time-adjust-ratio)))
            (curve-get-pos! gp-0 (parameter-ease-sin-clamp (-> *camera* outro-t)) (-> *camera* outro-curve))
            (vector-! gp-0 gp-0 s5-0)
            (cond
              ((or (and (< (-> *camera* outro-t-step) 0.0) (>= (-> *camera* outro-exit-value) (-> *camera* outro-t)))
                   (and (< 0.0 (-> *camera* outro-t-step)) (>= (-> *camera* outro-t) (-> *camera* outro-exit-value)))
                   )
               (set! (-> *camera* outro-t) (-> *camera* outro-exit-value))
               (set! (-> *camera* outro-t-step) 0.0)
               (vector+! (-> self velocity) (-> self velocity) gp-0)
               (send-event *camera* 'outro-done)
               )
              (else
                (vector+! (-> self trans) (-> self trans) gp-0)
                )
              )
            )
          )
        (vector-float*! (-> self velocity) (-> self velocity) 0.9)
        (vector+! (-> self trans) (-> self trans) (-> self velocity))
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-endlessfall (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (the-as symbol (cam-standard-event-handler proc arg1 event-type event))
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'cam-vector-seeker))
          (f30-0 (-> self velocity y))
          )
      (let ((a1-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-0 quad) (-> self trans quad))
        (set! (-> a1-0 y) 0.0)
        (set! (-> s5-0 quad) (-> self velocity quad))
        (set! (-> s5-0 y) 0.0)
        (init gp-0 a1-0 81.92 (fmax 819.2 (vector-length s5-0)) 0.75)
        (set! (-> gp-0 vel quad) (-> s5-0 quad))
        )
      (until #f
        (when (not (paused?))
          (set! (-> gp-0 target x) (-> (target-pos 0) x))
          (set! (-> gp-0 target z) (-> (target-pos 0) z))
          (update! gp-0 (the-as vector #f))
          (when (< 819.2 (-> gp-0 max-vel))
            (set! (-> gp-0 max-vel) (* 0.9 (-> gp-0 max-vel)))
            (if (< (-> gp-0 max-vel) 819.2)
                (set! (-> gp-0 max-vel) 819.2)
                )
            )
          (set! f30-0 (* 0.9 f30-0))
          (+! (-> self trans y) f30-0)
          (set! (-> self trans x) (-> gp-0 value x))
          (set! (-> self trans z) (-> gp-0 value z))
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defbehavior cam-circular-position-into-max-angle camera-slave ((arg0 vector) (arg1 vector) (arg2 float))
  (let* ((f30-0 (vector-normalize-ret-len! arg0 1.0))
         (f26-0 (vector-normalize-ret-len! arg1 1.0))
         (f0-1 (vector-dot arg0 arg1))
         (f28-0 (acos f0-1))
         (s4-0 (new 'stack-no-clear 'matrix))
         )
    (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
      (let ((f24-0 (analog-input
                     (the-as int (-> *cpad-list* cpads 0 rightx))
                     128.0
                     32.0
                     110.0
                     (* 8192.0 (-> self clock seconds-per-frame))
                     )
                   )
            (f1-2 (analog-input
                    (the-as int (-> *cpad-list* cpads 0 righty))
                    128.0
                    32.0
                    110.0
                    (* 8192.0 (-> self clock seconds-per-frame))
                    )
                  )
            (s2-0 (new-stack-matrix0))
            )
        (let ((v1-15 (new 'stack-no-clear 'vector)))
          0.0
          (when (< (-> self max-angle-offset) 1820.4445)
            (set! f24-0 0.0)
            (set! f1-2 0.0)
            )
          (if (< (-> self pivot-rad) f30-0)
              (set! f24-0 (- f24-0))
              )
          (vector-cross! v1-15 arg1 arg0)
          (let ((f0-10 (vector-dot v1-15 (-> *camera* local-down))))
            (if (< f1-2 0.0)
                (set! f1-2 (fmax f1-2 (* -0.15 f28-0)))
                )
            (if (< f0-10 0.0)
                (set! f1-2 (- f1-2))
                )
            (let* ((f1-3 (+ f24-0 f1-2))
                   (f1-5
                     (fmin (* 8192.0 (-> self clock seconds-per-frame)) (fmax (* -8192.0 (-> self clock seconds-per-frame)) f1-3))
                     )
                   )
              (cond
                ((and (< 0.0 f1-5) (< 0.0 f0-10) (< (-> self max-angle-curr) f28-0))
                 (set! f1-5 0.0)
                 )
                ((and (< 0.0 f1-5) (< 0.0 f0-10))
                 (set! f1-5 (fmin f1-5 (* 0.15 (- (-> self max-angle-curr) f28-0))))
                 )
                ((and (< f1-5 0.0) (< f0-10 0.0) (< (-> self max-angle-curr) f28-0))
                 (set! f1-5 0.0)
                 )
                ((and (< f1-5 0.0) (< f0-10 0.0))
                 (set! f1-5 (fmax f1-5 (* 0.15 (- f28-0 (-> self max-angle-curr)))))
                 )
                )
              (matrix-axis-angle! s2-0 (-> *camera* local-down) f1-5)
              )
            )
          )
        (vector-matrix*! arg1 arg1 s2-0)
        )
      (let ((f0-16 (vector-dot arg0 arg1)))
        (set! f28-0 (acos f0-16))
        )
      )
    (cond
      ((< (-> self max-angle-curr) f28-0)
       (matrix-from-two-vectors-max-angle!
         s4-0
         arg1
         arg0
         (* (fmin 1.0 (* arg2 (-> self clock time-adjust-ratio))) (- f28-0 (-> self max-angle-curr)))
         )
       (vector-matrix*! arg0 arg1 s4-0)
       )
      ((and (logtest? (-> self options) (cam-slave-options-u32 SAME_SIDE))
            (or (and (>= f26-0 (+ -8192.0 f30-0)) (>= f30-0 (+ -8192.0 (-> self pivot-rad))))
                (and (>= (+ 8192.0 f30-0) f26-0) (>= (+ 8192.0 (-> self pivot-rad)) f30-0))
                )
            )
       (let ((s2-1 (new 'stack-no-clear 'vector)))
         (vector-cross! s2-1 arg1 arg0)
         (vector-normalize! s2-1 1.0)
         (matrix-axis-angle!
           s4-0
           s2-1
           (* (fmin 1.0 (* arg2 (-> self clock time-adjust-ratio))) (- (-> self max-angle-curr) f28-0))
           )
         )
       (vector-matrix*! arg0 arg1 s4-0)
       )
      (else
        (set! (-> arg0 quad) (-> arg1 quad))
        (if (logtest? (-> self options) (cam-slave-options-u32 SHRINK_MAX_ANGLE))
            (set! (-> self max-angle-curr) f28-0)
            )
        )
      )
    )
  (vector-normalize! arg0 (-> self pivot-rad))
  )

(defbehavior cam-circular-position camera-slave ((arg0 symbol))
  (let ((gp-0 (new 'stack-no-clear 'vector)))
    (let ((s5-0 (new 'stack-no-clear 'vector)))
      (if (logtest? (-> self options) (cam-slave-options-u32 SAME_SIDE DRAG))
          (vector-! gp-0 (-> self circular-follow) (-> self pivot-pt))
          (vector-! gp-0 (-> self pivot-pt) (-> self circular-follow))
          )
      (vector-! s5-0 (-> self trans) (-> self pivot-pt))
      (when (not (logtest? (-> self options) (cam-slave-options-u32 MOVE_SPHERICAL)))
        (vector-flatten! gp-0 gp-0 (-> *camera* local-down))
        (vector-flatten! s5-0 s5-0 (-> *camera* local-down))
        )
      (cond
        ((logtest? (-> self options) (cam-slave-options-u32 DRAG))
         (let ((f30-0 (- (vector-length gp-0) (-> self pivot-rad))))
           (when (< 0.0001 (-> *camera-combiner* tracking point-of-interest-blend value))
             (let ((s5-1 (new 'stack-no-clear 'vector))
                   (s3-0 (new 'stack-no-clear 'vector))
                   (s4-1 (new 'stack-no-clear 'vector))
                   )
               0.0
               0.0
               0.0
               (vector-! s5-1 (-> *camera-combiner* tracking looking-interesting) (-> self pivot-pt))
               (vector-normalize-copy! s3-0 gp-0 1.0)
               (let ((f28-0 (vector-dot s5-1 s3-0)))
                 (vector-float*! s4-1 s3-0 f28-0)
                 (let ((f0-11
                         (/ (* (vector-vector-distance s5-1 s4-1) (cos (-> *camera-combiner* fov))) (sin (-> *camera-combiner* fov)))
                         )
                       )
                   (set! f30-0 (fmin f30-0 (if (>= 16384.0 (-> *camera-combiner* fov))
                                               (- f28-0 f0-11)
                                               (+ f28-0 f0-11)
                                               )
                                     )
                         )
                   )
                 )
               )
             )
           (if (>= 0.0 f30-0)
               (vector-reset! gp-0)
               (vector-normalize! gp-0 f30-0)
               )
           )
         )
        ((not arg0)
         (set! (-> self max-angle-curr) (-> self max-angle-offset))
         (cam-circular-position-into-max-angle gp-0 s5-0 1.0)
         )
        (else
          (cam-circular-position-into-max-angle gp-0 s5-0 0.05)
          )
        )
      )
    (vector+! (-> self trans) gp-0 (-> self pivot-pt))
    )
  )

(defbehavior cam-circular-code camera-slave ()
  (set! (-> self pivot-pt quad) (-> self saved-pt quad))
  (cam-curve-pos (-> self pivot-pt) (the-as vector #f) (the-as curve #f) #f)
  (let ((a2-1 (new-stack-vector0)))
    (vector-! a2-1 (-> *camera* tpos-curr-adj) (-> self pivot-pt))
    (vector-! (-> self circular-follow) (-> self circular-follow) (-> self pivot-pt))
    (if (logtest? (-> self options) (cam-slave-options-u32 MOVE_SPHERICAL))
        (v-slrp3!
          (-> self circular-follow)
          (-> self circular-follow)
          a2-1
          (the-as vector #f)
          (* 182.04445 (-> self clock time-adjust-ratio))
          )
        (v-slrp3!
          (-> self circular-follow)
          (-> self circular-follow)
          a2-1
          (-> *camera* local-down)
          (* 182.04445 (-> self clock time-adjust-ratio))
          )
        )
    )
  (vector+! (-> self circular-follow) (-> self circular-follow) (-> self pivot-pt))
  (cam-circular-position #t)
  (if (!= (-> self fov1) 0.0)
      (set! (-> self fov)
            (lerp-clamp
              (-> self fov0)
              (-> self fov1)
              (parameter-ease-sin-clamp (cam-index-method-10 (-> self fov-index) (-> *camera* tpos-curr-adj)))
              )
            )
      )
  )

(defstate cam-circular (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (let ((v1-0 event-type))
      (the-as object (cond
                       ((= v1-0 'teleport)
                        (the-as vector #f)
                        )
                       ((= v1-0 'outro-done)
                        (set! (-> self trans quad) (-> *camera-combiner* trans quad))
                        (cam-circular-position #f)
                        )
                       (else
                         (the-as vector (cam-standard-event-handler proc arg1 event-type event))
                         )
                       )
              )
      )
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      (else
        (let ((gp-0 (new-stack-vector0)))
          (set! (-> (new 'stack-no-clear 'collide-query) best-other-tri vertex 0 quad) (the-as uint128 0))
          (set! (-> self view-off-param) 1.0)
          (set! (-> self circular-follow quad) (-> *camera* tpos-curr-adj quad))
          (set! (-> self max-angle-offset) 0.0)
          (cond
            ((-> self cam-entity)
             (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) (-> self saved-pt) 'pivot)
             (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
             (set! (-> self pivot-rad) (vector-length (vector-! gp-0 gp-0 (-> self saved-pt))))
             (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
             (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
             (set! (-> self tracking tilt-adjust target)
                   (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                   )
             (set! (-> self max-angle-offset) (cam-slave-get-float (-> self cam-entity) 'maxAngle 0.0))
             (if (< (-> self max-angle-offset) 0.0)
                 (set! (-> self max-angle-offset) 0.0)
                 )
             (set! (-> self fov1) (cam-slave-get-float (-> self cam-entity) 'focalPull 0.0))
             (cond
               ((and (!= (-> self fov1) 0.0)
                     (cam-index-method-9 (-> self fov-index) 'focalpull (-> self cam-entity) (-> self saved-pt) (the-as curve #f))
                     )
                (set! (-> self fov0) (-> self fov))
                (set! (-> self fov) (lerp-clamp
                                      (-> self fov0)
                                      (-> self fov1)
                                      (cam-index-method-10 (-> self fov-index) (-> *camera* tpos-curr-adj))
                                      )
                      )
                )
               (else
                 (set! (-> self fov1) 0.0)
                 )
               )
             (set! (-> self spline-follow-dist) (cam-slave-get-float (-> self cam-entity) 'spline-follow-dist 0.0))
             (cam-curve-setup (-> self saved-pt))
             (cond
               ((< 0.0 (-> self spline-follow-dist))
                (let ((a0-17 (new 'stack-no-clear 'vector))
                      (gp-3 (new 'stack-no-clear 'vector))
                      )
                  (curve-get-pos! a0-17 0.0 (-> self spline-curve))
                  (curve-get-pos! gp-3 1.0 (-> self spline-curve))
                  )
                (set! (-> self spline-tt) (curve-closest-point
                                            (-> self spline-curve)
                                            (-> self circular-follow)
                                            0.5
                                            -4096.0
                                            10
                                            (-> self spline-follow-dist)
                                            )
                      )
                (curve-get-pos! (-> self pivot-pt) (-> self spline-tt) (-> self spline-curve))
                )
               (else
                 (set! (-> self spline-follow-dist) 0.0)
                 (set! (-> self pivot-pt quad) (-> self saved-pt quad))
                 (cam-curve-pos (-> self pivot-pt) (the-as vector #f) (the-as curve #f) #f)
                 )
               )
             )
            ((logtest? (-> self options) (cam-slave-options-u32 DRAG))
             (vector-! (-> self pivot-pt) (-> *camera* tpos-curr-adj) (-> self trans))
             (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
             (set! (-> self pivot-rad) (vector-length (-> self pivot-pt)))
             (set! (-> self pivot-pt quad) (-> self trans quad))
             (set! (-> self saved-pt quad) (-> self pivot-pt quad))
             )
            (else
              (vector-! (-> self pivot-pt) (-> *camera* tpos-curr-adj) (-> self trans))
              (vector-float*! (-> self pivot-pt) (-> self pivot-pt) 0.5)
              (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
              (set! (-> self pivot-rad) (vector-length (-> self pivot-pt)))
              (vector+! (-> self pivot-pt) (-> self trans) (-> self pivot-pt))
              (set! (-> self saved-pt quad) (-> self pivot-pt quad))
              )
            )
          )
        (cam-circular-position #f)
        (cond
          ((logtest? (-> self options) (cam-slave-options-u32 NO_ROTATE))
           (set! (-> self blend-from-type) (the-as uint 0))
           (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
           (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
           )
          (else
            (set! (-> self blend-from-type) (the-as uint 2))
            (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
            )
          )
        )
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (if (not (paused?))
          (cam-circular-code)
          )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-lookat (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  )

(deftype cam-string-bank (basic)
  ((los-coll-rad  meters  :offset-assert   4)
   (los-coll-rad2 meters  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(define *CAM_STRING-bank* (new 'static 'cam-string-bank :los-coll-rad (meters 1) :los-coll-rad2 (meters 0.5)))

;; WARN: new jak 2 until loop case, check carefully
(defun cam-string-find-position-rel! ((arg0 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'collide-query))
        (f30-0 0.0)
        (s2-0 (new 'stack-no-clear 'matrix))
        )
    (let ((s1-0 s3-0))
      (set! (-> s1-0 radius) 409.6)
      (set! (-> s1-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
      (set! (-> s1-0 ignore-process0) #f)
      (set! (-> s1-0 ignore-process1) #f)
      (set! (-> s1-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
      (set! (-> s1-0 action-mask) (collide-action solid))
      )
    (vector-flatten! s5-0 (-> *camera-combiner* inv-camera-rot vector 2) (-> *camera* local-down))
    (if (= (vector-normalize-ret-len! s5-0 (- (+ 1024.0 (-> *CAMERA-bank* default-string-min-z)))) 0.0)
        (set! (-> s5-0 z) (+ 1024.0 (-> *CAMERA-bank* default-string-min-z)))
        )
    (vector--float*! s5-0 s5-0 (-> *camera* local-down) (-> *CAMERA-bank* default-string-min-y))
    (set! (-> arg0 quad) (-> s5-0 quad))
    (until #f
      (vector--float*! s4-0 arg0 (-> *camera* local-down) (-> *camera* settings target-height))
      (set! (-> s3-0 start-pos quad) (-> *camera* tpos-curr-adj quad))
      (set! (-> s3-0 move-dist quad) (-> arg0 quad))
      (if (< (fill-and-probe-using-line-sphere *collide-cache* s3-0) 0.0)
          (return #t)
          )
      (set! f30-0 (cond
                    ((>= -32768.0 f30-0)
                     (format #t "cam-string didn't find a spot~%")
                     (set! (-> arg0 quad) (-> s5-0 quad))
                     (return #f)
                     f30-0
                     )
                    ((< 0.0 f30-0)
                     (- f30-0)
                     )
                    (else
                      (- 5461.3335 f30-0)
                      )
                    )
            )
      (matrix-axis-angle! s2-0 (-> *camera* local-down) f30-0)
      (vector-matrix*! arg0 s5-0 s2-0)
      )
    )
  #f
  )

;; WARN: Return type mismatch cam-slave-options-u32 vs cam-slave-options.
(defbehavior cam-string-set-position-rel! camera-slave ((arg0 vector))
  (vector-flatten! (-> self view-flat) arg0 (-> *camera* local-down))
  (set! (-> self min-z-override) (vector-length (-> self view-flat)))
  (vector+! (-> self desired-pos) arg0 (-> *camera* tpos-curr-adj))
  (set! (-> self string-trans quad) (-> self desired-pos quad))
  (tracking-spline-method-10 (-> self position-spline) (-> self desired-pos))
  (vector-reset! (-> self velocity))
  (let ((v0-2 (logclear (-> self options) (cam-slave-options-u32 GOTO_GOOD_POINT))))
    (set! (-> self options) v0-2)
    (the-as cam-slave-options v0-2)
    )
  )

(defun string-push-help ()
  409.6
  )

(defun-debug cam-draw-collide-cache ((arg0 collide-cache))
  (let ((gp-0 (the-as object (-> arg0 tris))))
    (countdown (s5-0 (-> arg0 num-tris))
      (let ((t1-0 #x40000080))
        (add-debug-flat-triangle
          #t
          (bucket-id debug-no-zbuf1)
          (the-as vector (-> (the-as (inline-array collide-cache-tri) gp-0) 0))
          (-> (the-as (inline-array collide-cache-tri) gp-0) 0 vertex 1)
          (-> (the-as (inline-array collide-cache-tri) gp-0) 0 vertex 2)
          (the-as rgba t1-0)
          )
        )
      (set! gp-0 (-> (the-as (inline-array collide-cache-tri) gp-0) 1))
      )
    )
  0
  (none)
  )

(deftype los-dist (structure)
  ((par-dist  float  :offset-assert   0)
   (lat-dist  float  :offset-assert   4)
   (vert-dist float  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(deftype collide-los-dist-info (structure)
  ((min-par float  :offset-assert   0)
   (max-par float  :offset-assert   4)
   (min-lat float  :offset-assert   8)
   (max-lat float  :offset-assert  12)
   (min-vp  float  :offset-assert  16)
   (max-vp  float  :offset-assert  20)
   (min-vn  float  :offset-assert  24)
   (max-vn  float  :offset-assert  28)
   (count   int32  :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  )


(defun dist-info-init ((arg0 collide-los-dist-info))
  (set! (-> arg0 min-par) 1.0)
  (set! (-> arg0 max-par) 0.0)
  (set! (-> arg0 count) 0)
  0
  (none)
  )

(defun dist-info-valid? ((arg0 collide-los-dist-info))
  (>= (-> arg0 max-par) (-> arg0 min-par))
  )

(defun dist-info-append ((arg0 collide-los-dist-info) (arg1 vector))
  (cond
    ((dist-info-valid? arg0)
     (if (< (-> arg1 x) (-> arg0 min-par))
         (set! (-> arg0 min-par) (-> arg1 x))
         )
     (if (< (-> arg0 max-par) (-> arg1 x))
         (set! (-> arg0 max-par) (-> arg1 x))
         )
     (if (< (-> arg1 y) (-> arg0 min-lat))
         (set! (-> arg0 min-lat) (-> arg1 y))
         )
     (if (< (-> arg0 max-lat) (-> arg1 y))
         (set! (-> arg0 max-lat) (-> arg1 y))
         )
     (cond
       ((< (-> arg1 y) 0.0)
        (if (< (-> arg1 z) (-> arg0 min-vn))
            (set! (-> arg0 min-vn) (-> arg1 z))
            )
        (if (< (-> arg0 max-vn) (-> arg1 z))
            (set! (-> arg0 max-vn) (-> arg1 z))
            )
        )
       (else
         (if (< (-> arg1 z) (-> arg0 min-vp))
             (set! (-> arg0 min-vp) (-> arg1 z))
             )
         (if (< (-> arg0 max-vp) (-> arg1 z))
             (set! (-> arg0 max-vp) (-> arg1 z))
             )
         )
       )
     )
    (else
      (set! (-> arg0 min-par) (-> arg1 x))
      (set! (-> arg0 max-par) (-> arg1 x))
      (set! (-> arg0 min-lat) (-> arg1 y))
      (set! (-> arg0 max-lat) (-> arg1 y))
      (set! (-> arg0 min-vp) 0.0)
      (set! (-> arg0 max-vp) 0.0)
      (set! (-> arg0 min-vn) 0.0)
      (set! (-> arg0 max-vn) 0.0)
      (cond
        ((< (-> arg1 y) 0.0)
         (set! (-> arg0 min-vn) (-> arg1 z))
         (set! (-> arg0 max-vn) (-> arg1 z))
         )
        (else
          (set! (-> arg0 min-vp) (-> arg1 z))
          (set! (-> arg0 max-vp) (-> arg1 z))
          )
        )
      )
    )
  (+! (-> arg0 count) 1)
  (none)
  )

(defun dist-info-print ((arg0 collide-los-dist-info) (arg1 string))
  (cond
    ((dist-info-valid? arg0)
     (format
       *stdcon*
       "~S ~2,D mn ~,,2M mx ~,,2M mnl ~,,2M mxl ~,,2M~%"
       arg1
       (-> arg0 count)
       (-> arg0 min-par)
       (-> arg0 max-par)
       (-> arg0 min-lat)
       (-> arg0 max-lat)
       )
     (format
       *stdcon*
       "   mnvp ~,,2M mxvp ~,,2M mnvn ~,,2M mxvn ~,,2M~%"
       (-> arg0 min-vp)
       (-> arg0 max-vp)
       (-> arg0 min-vn)
       (-> arg0 max-vn)
       )
     )
    (else
      (format *stdcon* "~S invalid~%" arg1)
      )
    )
  )

(deftype collide-los-result (structure)
  ((lateral       vector                :inline :offset-assert   0)
   (cw            collide-los-dist-info :inline :offset-assert  16)
   (ccw           collide-los-dist-info :inline :offset-assert  64)
   (straddle      collide-los-dist-info :inline :offset-assert 112)
   (lateral-valid symbol                        :offset-assert 148)
   )
  :method-count-assert 9
  :size-assert         #x98
  :flag-assert         #x900000098
  )


(defun los-cw-ccw ((arg0 (inline-array collide-cache-tri))
          (arg1 vector)
          (arg2 vector)
          (arg3 float)
          (arg4 collide-los-result)
          (arg5 vector)
          (arg6 float)
          )
  (local-vars (sv-128 float) (sv-144 vector) (sv-160 vector) (sv-176 vector) (sv-192 vector) (sv-208 int))
  (with-pp
    (set! sv-128 arg3)
    (let ((gp-0 arg4))
      (set! sv-144 arg5)
      (let ((s4-0 arg6))
        (set! sv-160 (new 'stack-no-clear 'vector))
        (set! sv-176 (new 'stack-no-clear 'vector))
        (let ((s5-0 (new 'stack-no-clear 'matrix)))
          (set! sv-192 (new 'stack-no-clear 'vector))
          (let ((f30-0 0.0)
                (s0-0 #f)
                )
            (set! sv-208 0)
            (while (< sv-208 4)
              (cond
                ((= sv-208 3)
                 (vector-! sv-160 sv-144 (the-as vector (&-> pp stack 432)))
                 (set! (-> s5-0 vector sv-208 z) 0.0)
                 )
                (else
                  (vector-! sv-160 sv-144 (-> arg0 0 vertex sv-208))
                  (set! (-> s5-0 vector sv-208 z) (vector-dot sv-160 (-> *camera* local-down)))
                  (vector-! sv-160 (-> arg0 0 vertex sv-208) (the-as vector (&-> pp stack 432)))
                  )
                )
              (vector-flatten! sv-160 sv-160 (-> *camera* local-down))
              (vector-cross! sv-176 sv-160 arg2)
              (let ((f28-0 (vector-dot sv-176 (-> *camera* local-down))))
                (cond
                  ((< (* f28-0 f30-0) 0.0)
                   (set! s0-0 #t)
                   )
                  ((!= f28-0 0.0)
                   (set! f30-0 f28-0)
                   )
                  )
                (set! (-> s5-0 vector sv-208 x) (vector-dot sv-160 arg2))
                (cond
                  ((= sv-208 3)
                   (vector-! sv-192 sv-144 (the-as vector (&-> pp stack 432)))
                   (vector-flatten! sv-192 sv-192 arg1)
                   )
                  (else
                    (vector--float*! sv-192 sv-160 arg2 (-> s5-0 vector sv-208 x))
                    )
                  )
                (if (< f28-0 0.0)
                    (set! (-> s5-0 vector sv-208 y) (- (vector-length sv-192)))
                    (set! (-> s5-0 vector sv-208 y) (vector-length sv-192))
                    )
                )
              (set! (-> s5-0 vector sv-208 x) (- sv-128 (-> s5-0 vector sv-208 x)))
              (set! sv-208 (+ sv-208 1))
              )
            (cond
              ((and s0-0 (!= (the-as int s4-0) -859915232))
               (dotimes (s4-1 4)
                 (dist-info-append (-> gp-0 straddle) (the-as vector (+ (the-as uint s5-0) (* s4-1 16))))
                 )
               #f
               )
              ((< (-> s5-0 trans y) 0.0)
               (dotimes (s4-2 4)
                 (when (>= (-> s5-0 trans y) (-> s5-0 vector s4-2 y))
                   (set! (-> s5-0 vector s4-2 y) (- (-> s5-0 vector s4-2 y)))
                   (dist-info-append (-> gp-0 ccw) (the-as vector (+ (the-as uint s5-0) (* s4-2 16))))
                   )
                 )
               #f
               )
              (else
                (dotimes (s4-3 4)
                  (if (>= (-> s5-0 vector s4-3 y) (-> s5-0 trans y))
                      (dist-info-append (-> gp-0 cw) (the-as vector (+ (the-as uint s5-0) (* s4-3 16))))
                      )
                  )
                #f
                )
              )
            )
          )
        )
      )
    )
  )

(defun cam-los-spline-collide ((arg0 vector) (arg1 vector) (arg2 pat-surface))
  (let ((s5-0 (new 'stack-no-clear 'collide-query))
        (s4-0 *collide-cache*)
        (f30-0 2.0)
        )
    0.0
    (set! (-> s5-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> s5-0 move-dist) arg1 arg0)
    (let ((v1-4 s5-0))
      (set! (-> v1-4 radius) (-> *CAM_STRING-bank* los-coll-rad2))
      (set! (-> v1-4 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
      (set! (-> v1-4 ignore-process0) #f)
      (set! (-> v1-4 ignore-process1) #f)
      (set! (-> v1-4 ignore-pat) arg2)
      (set! (-> v1-4 action-mask) (collide-action solid))
      )
    (fill-using-line-sphere s4-0 s5-0)
    (let* ((f0-2 (vector-length (-> s5-0 move-dist)))
           (f28-0
             (cond
               ((< f0-2 (-> *CAMERA-bank* min-detectable-velocity))
                0.0
                )
               (else
                 (let* ((f0-3 (/ (* 3.0 (- (-> *CAM_STRING-bank* los-coll-rad2) (-> *CAMERA-bank* collide-move-rad))) f0-2))
                        (f0-4 (- 1.0 f0-3))
                        )
                   (fmin 1.0 (fmax 0.0 f0-4))
                   )
                 )
               )
             )
           (s3-0 (the-as object (-> s4-0 tris)))
           (s2-0 (new 'stack-no-clear 'vector))
           (s1-0 (new 'stack-no-clear 'vector))
           )
      (countdown (s4-1 (-> s4-0 num-tris))
        (let ((f0-7 (moving-sphere-triangle-intersect
                      arg0
                      (-> s5-0 move-dist)
                      (-> *CAM_STRING-bank* los-coll-rad2)
                      (-> (the-as (inline-array collide-cache-tri) s3-0) 0)
                      s2-0
                      s1-0
                      )
                    )
              )
          (cond
            ((or (< f0-7 0.0) (< f28-0 f0-7))
             )
            ((< f0-7 f30-0)
             (set! f30-0 f0-7)
             )
            )
          )
        (set! s3-0 (-> (the-as (inline-array collide-cache-tri) s3-0) 1))
        )
      )
    (if (= (the-as int f30-0) #x40000000)
        (set! f30-0 -1.0)
        )
    f30-0
    )
  )

(defbehavior cam-los-setup-lateral camera-slave ((arg0 collide-los-result) (arg1 vector) (arg2 vector))
  (cond
    ((dist-info-valid? (-> arg0 straddle))
     (let ((f30-0 (-> arg0 straddle min-lat))
           (f28-0 (-> arg0 straddle max-lat))
           )
       (if (dist-info-valid? (-> arg0 cw))
           (set! f28-0 (fmax f28-0 (-> arg0 cw max-lat)))
           )
       (if (dist-info-valid? (-> arg0 ccw))
           (set! f30-0 (fmin f30-0 (- (-> arg0 ccw max-lat))))
           )
       (cond
         ((= (-> self los-state) (slave-los-state ccw))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle stick ccw~%")
              )
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((= (-> self los-state) (slave-los-state cw))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle stick cw~%")
              )
          (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((and (or (< 0.01 (-> arg0 straddle max-vp)) (and (dist-info-valid? (-> arg0 ccw)) (< 0.01 (-> arg0 ccw max-vp))))
               (or (< (-> arg0 straddle min-vp) -0.01) (and (dist-info-valid? (-> arg0 ccw)) (< (-> arg0 ccw min-vp) -0.01)))
               (and (dist-info-valid? (-> arg0 cw)) (or (< (-> arg0 cw max-vp) 0.01) (< -0.01 (-> arg0 cw min-vp))))
               )
          (when (not (dist-info-valid? (-> arg0 ccw)))
            )
          (if (not (dist-info-valid? (-> arg0 cw)))
              (format #t "s diag ccw invalid cw~%")
              )
          (if *display-cam-los-debug*
              (format *stdcon* "straddle diagonal ccw~%")
              )
          (set! (-> self los-state) (slave-los-state ccw))
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((and (or (< 0.01 (-> arg0 straddle max-vn)) (and (dist-info-valid? (-> arg0 cw)) (< 0.01 (-> arg0 cw max-vp))))
               (or (< (-> arg0 straddle min-vn) -0.01) (and (dist-info-valid? (-> arg0 cw)) (< (-> arg0 cw min-vp) -0.01)))
               (and (dist-info-valid? (-> arg0 ccw)) (or (< (-> arg0 ccw max-vp) 0.01) (< -0.01 (-> arg0 ccw min-vp))))
               )
          (if (not (dist-info-valid? (-> arg0 ccw)))
              (format #t "s diag cw invalid ccw~%")
              )
          (when (not (dist-info-valid? (-> arg0 cw)))
            )
          (if *display-cam-los-debug*
              (format *stdcon* "straddle diagonal cw~%")
              )
          (set! (-> self los-state) (slave-los-state cw))
          (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((< f28-0 (- f30-0))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle ccw~%")
              )
          (set! (-> self los-state) (slave-los-state ccw))
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         (else
           (if *display-cam-los-debug*
               (format *stdcon* "straddle cw~%")
               )
           (set! (-> self los-state) (slave-los-state cw))
           (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
           )
         )
       )
     )
    ((and (dist-info-valid? (-> arg0 cw))
          (dist-info-valid? (-> arg0 ccw))
          (< 0.01 (-> arg0 ccw max-vp))
          (< (-> arg0 ccw min-vp) -0.01)
          (or (< (-> arg0 cw max-vp) 0.01) (< -0.01 (-> arg0 cw min-vp)))
          )
     (if *display-cam-los-debug*
         (format *stdcon* "diagonal ccw~%")
         )
     (set! (-> self los-state) (slave-los-state ccw))
     (vector-normalize! arg1 (- (-> *CAM_STRING-bank* los-coll-rad) (-> arg0 ccw min-lat)))
     )
    ((and (dist-info-valid? (-> arg0 cw))
          (dist-info-valid? (-> arg0 ccw))
          (< 0.01 (-> arg0 cw max-vp))
          (< (-> arg0 cw min-vp) -0.01)
          (or (< (-> arg0 ccw max-vp) 0.01) (< -0.01 (-> arg0 ccw min-vp)))
          )
     (if *display-cam-los-debug*
         (format *stdcon* "diagonal cw~%")
         )
     (set! (-> self los-state) (slave-los-state cw))
     (vector-normalize! arg1 (- (-> arg0 cw min-lat) (-> *CAM_STRING-bank* los-coll-rad)))
     )
    ((and (dist-info-valid? (-> arg0 cw)) (dist-info-valid? (-> arg0 ccw)))
     (set! (-> self los-state) (slave-los-state between))
     (vector-normalize! arg1 0.0001)
     )
    ((dist-info-valid? (-> arg0 cw))
     (if *display-cam-los-debug*
         (format *stdcon* "regular cw~%")
         )
     (set! (-> self los-state) (slave-los-state cw))
     (vector-normalize! arg1 (- (-> arg0 cw min-lat) (-> *CAM_STRING-bank* los-coll-rad)))
     )
    ((dist-info-valid? (-> arg0 ccw))
     (if *display-cam-los-debug*
         (format *stdcon* "regular ccw~%")
         )
     (set! (-> self los-state) (slave-los-state ccw))
     (vector-normalize! arg1 (- (-> *CAM_STRING-bank* los-coll-rad) (-> arg0 ccw min-lat)))
     )
    (else
      (set! (-> self los-state) (slave-los-state none))
      (vector-reset! arg1)
      )
    )
  (cond
    ((= (vector-length arg1) 0.0)
     (set! (-> arg0 lateral-valid) #f)
     #f
     )
    (else
      (vector-! (-> arg0 lateral) arg1 arg2)
      (vector-normalize! (-> arg0 lateral) 1.0)
      (let ((v0-44 #t))
        (set! (-> arg0 lateral-valid) v0-44)
        v0-44
        )
      )
    )
  )

;; WARN: Return type mismatch int vs symbol.
;; ERROR: Unsupported inline assembly instruction kind - [mula.s f2, f5]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f3, f6]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f2, f4, f7]
(defbehavior cam-los-collide camera-slave ((arg0 vector) (arg1 vector) (arg2 collide-los-result) (arg3 pat-surface))
  (local-vars
    (s1-3 int)
    (s2-2 int)
    (f2-1 float)
    (sv-768 pat-surface)
    (sv-784 vector)
    (sv-800 vector)
    (sv-816 tracking-point)
    (sv-832 vector)
    )
  (set! sv-768 arg3)
  (dist-info-init (-> arg2 cw))
  (dist-info-init (-> arg2 ccw))
  (dist-info-init (-> arg2 straddle))
  (let ((s1-0 (new 'stack-no-clear 'collide-query))
        (s4-0 (new 'stack-no-clear 'vector))
        (s2-0 (new 'stack-no-clear 'vector))
        )
    (vector-normalize-copy! s2-0 arg1 1.0)
    (vector-flatten! s4-0 arg1 (-> *camera* local-down))
    (let ((s0-0 *collide-cache*)
          (f26-0 (vector-length arg1))
          (f30-0 (vector-normalize-ret-len! s4-0 1.0))
          )
      (set! (-> s1-0 start-pos quad) (-> arg0 quad))
      (set! (-> s1-0 move-dist quad) (-> arg1 quad))
      (let ((v1-5 s1-0))
        (set! (-> v1-5 radius) (-> *CAM_STRING-bank* los-coll-rad))
        (set! (-> v1-5 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
        (set! (-> v1-5 ignore-process0) #f)
        (set! (-> v1-5 ignore-process1) #f)
        (set! (-> v1-5 ignore-pat) sv-768)
        (set! (-> v1-5 action-mask) (collide-action solid))
        )
      (fill-using-line-sphere s0-0 s1-0)
      (let ((s1-1 (the-as object (-> s0-0 tris)))
            (f28-0 (/ 2048.0 f26-0))
            (f26-1 (/ (+ -8192.0 f26-0) f26-0))
            )
        (if (< f26-1 0.0)
            (set! f26-1 0.0)
            )
        (if (< 1.0 f28-0)
            (set! f28-0 1.0)
            )
        (countdown (s0-1 (-> s0-0 num-tris))
          (set! sv-800 (new 'stack-no-clear 'vector))
          (set! sv-784 (new 'stack-no-clear 'vector))
          (let ((f0-7 (moving-sphere-triangle-intersect
                        arg0
                        arg1
                        (-> *CAM_STRING-bank* los-coll-rad)
                        (-> (the-as (inline-array collide-cache-tri) s1-1) 0)
                        sv-800
                        sv-784
                        )
                      )
                )
            (cond
              ((or (< f0-7 0.0) (< 1.0 f0-7))
               )
              ((let ((f1-2 0.0))
                ;;  (let* ((v1-23 arg1)
                ;;         (f2-0 (-> v1-23 x))
                ;;         (f3-0 (-> v1-23 y))
                ;;         (f4-0 (-> v1-23 z))
                ;;         (f5-0 (-> sv-784 x))
                ;;         (f6-0 (-> sv-784 y))
                ;;         (f7-0 (-> sv-784 z))
                ;;         )
                ;;    (.mula.s f2-0 f5-0)
                ;;    (.madda.s f3-0 f6-0)
                ;;    (.madd.s f2-1 f4-0 f7-0)
                ;;    )
                 (set! f2-1 (vector-dot arg1 sv-784))
                 (< f1-2 f2-1)
                 )
               (when (< f28-0 f0-7)
                 (let* ((t1-1 (new 'stack-no-clear 'vector))
                        (t0-1 (new 'stack-no-clear 'vector))
                        (f24-0 (moving-sphere-triangle-intersect
                                 arg0
                                 arg1
                                 (-> *CAM_STRING-bank* los-coll-rad2)
                                 (-> (the-as (inline-array collide-cache-tri) s1-1) 0)
                                 t0-1
                                 t1-1
                                 )
                               )
                        )
                   (los-cw-ccw (the-as (inline-array collide-cache-tri) s1-1) s2-0 s4-0 f30-0 arg2 sv-800 f24-0)
                   (when *debug-segment*
                     (cond
                       ((= (the-as int f24-0) -859915232)
                        (let ((t9-10 cam-debug-add-los-tri)
                              (a0-20 s1-1)
                              (a2-6 (new 'static 'vector :x (the-as float #x80) :w (the-as float #x80)))
                              )
                          (t9-10 (the-as (inline-array collide-cache-tri) a0-20) sv-800 a2-6)
                          )
                        )
                       (else
                         (cam-debug-add-los-tri
                           (the-as (inline-array collide-cache-tri) s1-1)
                           sv-800
                           (new 'static 'vector :x (the-as float #x80) :y (the-as float #x80) :w (the-as float #x80))
                           )
                         )
                       )
                     )
                   )
                 )
               )
              ((< f0-7 f26-1)
               (let* ((t1-3 (new 'stack-no-clear 'vector))
                      (t0-3 (new 'stack-no-clear 'vector))
                      (f24-1 (moving-sphere-triangle-intersect
                               arg0
                               arg1
                               (-> *CAM_STRING-bank* los-coll-rad2)
                               (-> (the-as (inline-array collide-cache-tri) s1-1) 0)
                               t0-3
                               t1-3
                               )
                             )
                      )
                 (los-cw-ccw (the-as (inline-array collide-cache-tri) s1-1) s2-0 s4-0 f30-0 arg2 sv-800 f24-1)
                 (when *debug-segment*
                   (if (= (the-as int f24-1) -859915232)
                       (cam-debug-add-los-tri
                         (the-as (inline-array collide-cache-tri) s1-1)
                         sv-800
                         (new 'static 'vector :y (the-as float #x80) :w (the-as float #x80))
                         )
                       (cam-debug-add-los-tri
                         (the-as (inline-array collide-cache-tri) s1-1)
                         sv-800
                         (new 'static 'vector :z (the-as float #x80) :w (the-as float #x80))
                         )
                       )
                   )
                 )
               )
              )
            )
          (set! s1-1 (-> (the-as (inline-array collide-cache-tri) s1-1) 1))
          )
        )
      )
    )
  (let ((s4-1 (new 'stack-no-clear 'vector)))
    0.0
    (vector-cross! s4-1 arg1 (-> *camera* local-down))
    (cond
      ((!= (-> self los-tgt-spline-pt-incarnation)
           (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
           )
       (when *display-cam-los-debug*
         (format *stdcon* "emergency point jump~%")
         (format 0 "emergency point jump~%")
         )
       (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline used-point))
       (set! (-> self los-tgt-spline-pt-incarnation)
             (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
             )
       (logior! (-> self options) (cam-slave-options-u32 GOTO_GOOD_POINT))
       (set! (-> self good-point quad)
             (-> *camera* target-spline point (-> *camera* target-spline used-point) position quad)
             )
       (set! (-> self los-last-pos quad) (-> self good-point quad))
       (when *debug-segment*
         (let ((a1-22 (new 'stack-no-clear 'vector)))
           (vector-! a1-22 (-> self good-point) (-> self string-trans))
           (cam-collision-record-save (-> self string-trans) a1-22 -3 'jump self)
           )
         )
       (set! (-> self desired-pos quad) (-> self good-point quad))
       (set! (-> self string-trans quad) (-> self good-point quad))
       (vector-! (-> self view-flat) (-> self string-trans) (-> *camera* tpos-curr-adj))
       (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
       (vector-reset! (-> self velocity))
       (let ((f0-11 (vector-length (-> self view-flat))))
         (if (< f0-11 (-> self min-z-override))
             (set! (-> self min-z-override) f0-11)
             )
         )
       )
      (else
        (let ((f30-1
                (cam-los-spline-collide
                  (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> *camera* target-spline end-point))))
                  arg0
                  (the-as pat-surface (camera-master-method-16 *camera* #t))
                  )
                )
              )
          (cond
            ((< f30-1 0.0)
             (if *display-cam-los-debug*
                 (format *stdcon* "good ~f~%" f30-1)
                 )
             (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline end-point))
             (set! (-> self los-tgt-spline-pt-incarnation)
                   (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
                   )
             (set! (-> self los-last-pos quad) (-> arg0 quad))
             )
            ((begin
               (if *display-cam-los-debug*
                   (format
                     *stdcon*
                     "looking vel ~M u ~f pt ~D"
                     (vector-length (-> self velocity))
                     f30-1
                     (-> self los-tgt-spline-pt)
                     )
                   )
               (set! s2-2 (-> self los-tgt-spline-pt))
               (set! s1-3 -134250495)
               (while (and (!= s2-2 -134250495)
                           (begin
                             (let ((s0-3 cam-los-spline-collide))
                               (set! sv-816 (-> (the-as (inline-array tracking-spline) (-> *camera* target-spline)) 0 point s2-2))
                               (set! sv-832 arg0)
                               (let ((a2-21 (camera-master-method-16 *camera* #t)))
                                 (set! f30-1 (s0-3 (the-as vector sv-816) sv-832 (the-as pat-surface a2-21)))
                                 )
                               )
                             (< f30-1 0.0)
                             )
                           )
                 (set! s1-3 s2-2)
                 (set! s2-2 (-> *camera* target-spline point s2-2 next))
                 )
               (and (= s2-2 (-> *camera* target-spline used-point))
                    (!= (-> *camera* target-spline point s2-2 next) -134250495)
                    )
               )
             (when *display-cam-los-debug*
               (format 0 "looking at used point~%")
               (format *stdcon* " at used point~%")
               )
             (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline point s2-2 next))
             (set! (-> self los-tgt-spline-pt-incarnation)
                   (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
                   )
             (logior! (-> self options) (cam-slave-options-u32 GOTO_GOOD_POINT))
             (set! (-> self good-point quad) (-> *camera* target-spline point s2-2 position quad))
             (set! (-> self los-last-pos quad) (-> self good-point quad))
             (when *debug-segment*
               (let ((a1-40 (new 'stack-no-clear 'vector)))
                 (vector-! a1-40 (-> self good-point) (-> self string-trans))
                 (cam-collision-record-save (-> self string-trans) a1-40 -3 'jump self)
                 )
               )
             (set! (-> self desired-pos quad) (-> self good-point quad))
             (set! (-> self string-trans quad) (-> self good-point quad))
             (vector-! (-> self view-flat) (-> self string-trans) (-> *camera* tpos-curr-adj))
             (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
             (vector-reset! (-> self velocity))
             (let ((f0-14 (vector-length (-> self view-flat))))
               (if (< f0-14 (-> self min-z-override))
                   (set! (-> self min-z-override) f0-14)
                   )
               )
             )
            ((!= s1-3 -134250495)
             (if *display-cam-los-debug*
                 (format *stdcon* " ok~%")
                 )
             (set! (-> self los-tgt-spline-pt) s1-3)
             (set! (-> self los-tgt-spline-pt-incarnation)
                   (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
                   )
             (set! (-> self los-last-pos quad) (-> arg0 quad))
             )
            (else
              (if *display-cam-los-debug*
                  (format *stdcon* "~%failed u ~f cur ~D seen ~D tgt-pt ~D~%" f30-1 s2-2 s1-3 (-> self los-tgt-spline-pt))
                  )
              (let ((s3-1 (new 'stack-no-clear 'vector)))
                0.0
                (vector-!
                  s3-1
                  (-> self los-last-pos)
                  (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                  )
                (let ((f28-1 (vector-length s3-1)))
                  (if (= f28-1 0.0)
                      (set! f28-1 0.4096)
                      )
                  (let ((f30-2 (cond
                                 ((and (= (-> self string-vel-dir) 6)
                                       (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity)))
                                       )
                                  (fmin 1.0 (+ 0.001 f30-1))
                                  )
                                 ((= (-> self string-vel-dir) 6)
                                  (fmin 0.9999 f30-1)
                                  )
                                 (else
                                   (fmax 0.001 (+ -0.001 f30-1))
                                   )
                                 )
                               )
                        )
                    (let ((s2-3 (new 'stack-no-clear 'vector)))
                      (vector-!
                        s2-3
                        (-> *camera* tpos-curr-adj)
                        (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                        )
                      (vector-flatten! s2-3 s2-3 (-> *camera* local-down))
                      (cond
                        ((and (< (fabs (- (-> self desired-pos y) (-> self trans y))) 8192.0)
                              (< f28-1 (+ 1024.0 (-> self string-min-val z)))
                              (< (vector-length s2-3) 8192.0)
                              )
                         (set! f30-2 0.0)
                         )
                        ((< f28-1 (+ 1024.0 (-> self string-min-val z)))
                         )
                        ((< (* f28-1 f30-2) (-> self string-min-val z))
                         (set! f30-2 (/ (-> self string-min-val z) f28-1))
                         )
                        )
                      )
                    (when (< 0.0 f30-2)
                      (vector-! s3-1 (-> *camera* tpos-curr) (-> *camera* tpos-old))
                      (vector-!
                        (-> self good-point)
                        (-> self los-last-pos)
                        (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                        )
                      (vector-float*! (-> self good-point) (-> self good-point) f30-2)
                      (vector+!
                        (-> self good-point)
                        (-> self good-point)
                        (the-as vector (+ (the-as uint (-> *camera* target-spline)) (* 48 (-> self los-tgt-spline-pt))))
                        )
                      (set! (-> self los-last-pos quad) (-> self good-point quad))
                      (when *display-cam-los-debug*
                        (format 0 "going because u(~f) > 0 frame ~D~%" f30-2 (current-time))
                        (format *stdcon* " going because u(~f) > 0 frame ~D~%" f30-2 (current-time))
                        )
                      (logior! (-> self options) (cam-slave-options-u32 GOTO_GOOD_POINT))
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    (if *display-cam-los-debug*
        (format
          *stdcon*
          "los-last ~M ~M ~M~%"
          (-> self los-last-pos x)
          (-> self los-last-pos y)
          (-> self los-last-pos z)
          )
        )
    (cam-los-setup-lateral arg2 s4-1 arg1)
    )
  (cond
    ((not (logtest? (-> self options) (cam-slave-options-u32 MOVEMENT_BLOCKED)))
     )
    ((= (-> self string-vel-dir) 5)
     )
    ((and (= (-> self string-vel-dir) 2) (= (-> self los-state) (slave-los-state cw)))
     )
    ((and (= (-> self string-vel-dir) 1) (= (-> self los-state) (slave-los-state ccw)))
     )
    )
  (when *display-cam-los-debug*
    (format *stdcon* "state ~S" (slave-los-state->string (-> self los-state)))
    (cond
      ((zero? (-> self string-vel-dir))
       (format *stdcon* " vzero")
       )
      ((= (-> self string-vel-dir) 2)
       (format *stdcon* " vcw")
       )
      ((= (-> self string-vel-dir) 1)
       (format *stdcon* " vccw")
       )
      ((= (-> self string-vel-dir) 3)
       (format *stdcon* " up")
       )
      ((= (-> self string-vel-dir) 4)
       (format *stdcon* " down")
       )
      ((= (-> self string-vel-dir) 6)
       (format *stdcon* " long")
       )
      ((= (-> self string-vel-dir) 5)
       (format *stdcon* " short")
       )
      )
    (format *stdcon* "~%")
    )
  (when *display-cam-los-info*
    (dist-info-print (-> arg2 cw) "cw   ")
    (dist-info-print (-> arg2 ccw) "ccw  ")
    (dist-info-print (-> arg2 straddle) "strdl")
    )
  (the-as symbol 0)
  )

(defbehavior cam-string-follow camera-slave ()
  (let ((f30-0 (vector-length (-> self view-flat))))
    (cond
      ((logtest? (-> self options) (cam-slave-options-u32 STICKY_ANGLE))
       (let ((gp-0 (new 'stack-no-clear 'vector)))
         (let ((s5-0 (new 'stack-no-clear 'vector)))
           (vector-cross! s5-0 (-> self view-flat) (-> *camera* local-down))
           (vector-normalize! s5-0 1.0)
           (vector-! gp-0 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
           (vector-flatten! gp-0 gp-0 s5-0)
           )
         (if (< (vector-dot gp-0 (-> self view-flat)) 0.0)
             (vector-! (-> self view-flat) (-> self view-flat) gp-0)
             )
         )
       )
      (else
        (let ((v1-10 (new 'stack-no-clear 'vector)))
          (vector-! v1-10 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
          (vector-! (-> self view-flat) (-> self view-flat) v1-10)
          )
        )
      )
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (let* ((f28-0 (vector-length (-> self view-flat)))
           (f0-3 (fmin (-> *camera* string-push-z) (-> self view-off z)))
           (f26-0 (-> self view-off z))
           (f0-4 (fmin f0-3 (-> self min-z-override)))
           )
      (when (logtest? (cam-slave-options WIDE_FOV) (-> *camera* settings slave-options))
        (let ((v1-18 (new-stack-vector0)))
          0.0
          (vector-! v1-18 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
          (let ((f0-6 (vector-length v1-18)))
            (set! f0-4 (lerp-clamp 28672.0 32768.0 (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f0-6)))))
            )
          )
        (set! f26-0 f0-4)
        )
      (set! (-> self fov) (-> *camera* settings fov))
      (cond
        ((< f28-0 f0-4)
         (vector-normalize! (-> self view-flat) f0-4)
         )
        ((and (< f30-0 f28-0)
              (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
              )
         (vector-normalize! (-> self view-flat) f30-0)
         )
        ((< f26-0 f28-0)
         (vector-normalize! (-> self view-flat) f26-0)
         (set! (-> self min-z-override) f26-0)
         f26-0
         )
        (else
          (set! (-> self min-z-override) f28-0)
          f28-0
          )
        )
      )
    )
  )

(defbehavior cam-string-line-of-sight camera-slave ()
  (let ((gp-0 (new 'stack-no-clear 'collide-los-result))
        (s5-0 (new 'stack-no-clear 'vector))
        )
    (new 'stack-no-clear 'collide-query)
    (let ((f30-0 (vector-length (-> self view-flat))))
      (vector--float*! s5-0 (-> *camera* tpos-curr) (-> *camera* local-down) (-> *camera* settings target-height))
      (vector-! s5-0 s5-0 (-> self string-trans))
      (let ((f0-1 (vector-length s5-0)))
        (if (< 2048.0 f0-1)
            (vector-float*! s5-0 s5-0 (/ (+ -2048.0 f0-1) f0-1))
            (vector-reset! s5-0)
            )
        )
      (cam-los-collide (-> self string-trans) s5-0 gp-0 (the-as pat-surface (camera-master-method-16 *camera* #t)))
      (when (-> gp-0 lateral-valid)
        (when (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
          (let ((v1-21 (new 'stack-no-clear 'vector)))
            (vector-! v1-21 (-> *camera* tpos-curr) (-> *camera* tpos-old))
            (if (and (< (-> self string-min-val z) f30-0)
                     (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length v1-21))
                     )
                (set! f30-0 (+ -204.8 f30-0))
                )
            )
          )
        (if (< f30-0 (fmin (-> self string-min-val z) (-> self min-z-override)))
            (set! f30-0 (fmin (-> self string-min-val z) (-> self min-z-override)))
            )
        (if (< f30-0 (-> self min-z-override))
            (set! (-> self min-z-override) f30-0)
            )
        (let ((s4-1 (new 'stack-no-clear 'vector))
              (s5-1 (new 'stack-no-clear 'vector))
              (s3-1 (new 'stack-no-clear 'matrix))
              )
          0.0
          (vector-flatten! s4-1 (-> gp-0 lateral) (-> *camera* local-down))
          (vector-normalize! s4-1 1.0)
          (vector-normalize-copy! s5-1 (-> self view-flat) 1.0)
          (let ((f0-14 (lerp-clamp
                         418.7022
                         364.0889
                         (/ (- f30-0 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))
                         )
                       )
                )
            (matrix-from-two-vectors-max-angle-partial! s3-1 s5-1 s4-1 f0-14 0.5)
            )
          (vector-matrix*! (-> self view-flat) (-> self view-flat) s3-1)
          )
        (vector-normalize! (-> self view-flat) f30-0)
        )
      )
    )
  )

(defun cam-dist-analog-input ((arg0 int) (arg1 float))
  (let ((f0-0 (the-as number 0.0)))
    (cond
      ((< arg0 28)
       (set! f0-0 (- (fmin arg1 (* 0.083333336 (- 28.0 (the float arg0)) arg1))))
       )
      ((< 160 arg0)
       (set! f0-0 (fmin arg1 (* 0.0125 (+ -160.0 (the float arg0)) arg1)))
       )
      )
    (the-as float f0-0)
    )
  )

(defbehavior cam-string-joystick camera-slave ()
  (logclear! (-> self options) (cam-slave-options-u32 PLAYER_MOVING_CAMERA))
  (when (-> self string-relative)
    (let ((s5-0 (new 'stack-no-clear 'vector))
          (gp-0 (new 'stack-no-clear 'vector))
          )
      0.0
      (let ((f30-0 0.5))
        (new 'stack-no-clear 'matrix)
        (vector-flatten! s5-0 (-> self relative-position) (-> *camera* local-down))
        (let ((f0-4
                (acos (/ (vector-dot s5-0 (-> self view-flat)) (* (vector-length s5-0) (vector-length (-> self view-flat)))))
                )
              )
          (if (< 1456.3556 (* f30-0 f0-4))
              (set! f30-0 (/ 1456.3556 f0-4))
              )
          )
        (vector-deg-slerp (-> self view-flat) (-> self view-flat) s5-0 f30-0)
        (set! (-> gp-0 y) (- (vector-dot (-> self relative-position) (-> *camera* local-down))))
        (set! (-> gp-0 z) (vector-length s5-0))
        (set! (-> self view-off y) (lerp (-> self view-off y) (-> gp-0 y) f30-0))
        (set! (-> self view-off z) (lerp (-> self view-off z) (-> gp-0 z) f30-0))
        )
      )
    (vector-normalize! (-> self view-flat) (-> self view-off z))
    (set! (-> self string-min-val y) (-> self view-off y))
    (set! (-> self string-min-val z) (-> self view-off z))
    (set! (-> self string-max-val y) (-> self view-off y))
    (set! (-> self string-max-val z) (-> self view-off z))
    (return (the-as float #f))
    )
  (let ((f28-0 (cam-dist-analog-input (the-as int (-> *cpad-list* cpads 0 righty)) 0.05))
        (f0-22 (/ (- (vector-length (-> self view-flat)) (-> self string-min-val z))
                  (- (-> self string-max-val z) (-> self string-min-val z))
                  )
               )
        (f30-1 (-> self view-off-param))
        )
    (if (logtest? (cam-slave-options-u32 BLOCK_RIGHT_STICK) (-> self options))
        (set! f28-0 0.0)
        )
    (if (-> self have-phony-joystick)
        (set! f28-0 (* 0.05 (-> self phony-joystick-y)))
        )
    (if (and (-> *camera* being-attacked) (< (- (current-time) (-> *camera* attack-start)) (seconds 0.25)))
        (set! f28-0 0.05)
        )
    (when (logtest? (cam-slave-options-u32 GUN_CAM) (-> self options))
      (if (and (or (< (-> *cpad-list* cpads 0 rightx) (the-as uint 64))
                   (< (the-as uint 192) (-> *cpad-list* cpads 0 rightx))
                   )
               (let ((v1-56 (abs (the-as int (+ (-> *cpad-list* cpads 0 righty) -128)))))
                 (< (the-as uint v1-56) (the-as uint 64))
                 )
               )
          (set! f28-0 0.0)
          )
      )
    (if (!= f28-0 0.0)
        (logior! (-> self options) (cam-slave-options-u32 PLAYER_MOVING_CAMERA))
        )
    (let ((f26-0 (fmin 1.0 f0-22)))
      (let ((f0-23 f26-0))
        (when (< f26-0 0.0)
          (let ((f0-26
                  (/ (- (-> self string-min-val z) (vector-length (-> self view-flat))) (* 0.5 (-> self string-min-val z)))
                  )
                )
            (set! f0-23 (fmin 0.75 f0-26))
            )
          )
        (let ((f1-15 (-> self string-min-val y))
              (f2-5 (-> self string-max-val y))
              )
          (set! (-> self view-off y) (lerp f1-15 f2-5 f0-23))
          )
        )
      (when (< f26-0 0.0)
        (let ((v1-71 (new 'stack-no-clear 'vector)))
          (vector-! v1-71 (-> self string-trans) (-> *camera* tpos-curr-adj))
          (let ((f0-32 (- (- (vector-dot v1-71 (-> *camera* local-down))) (-> *camera* settings target-height))))
            (set! (-> self view-off y)
                  (fmin (-> *camera* settings string-cliff-height) (fmax f0-32 (-> self view-off y)))
                  )
            )
          )
        )
      (let ((f0-36 (fmax 0.0 f26-0)))
        (cond
          ((logtest? (-> *camera* settings slave-options) (cam-slave-options BIKE_MODE))
           )
          ((logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG))
           )
          ((and (>= 0.0 f28-0) (>= 0.0 f0-36))
           )
          ((and (>= f28-0 0.0) (>= f0-36 1.0))
           )
          ((and (< 0.0 f28-0)
                (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
                )
           )
          ((and (logtest? (cam-slave-options-u32 GUN_CAM) (-> self options)) (< 0.0 f28-0))
           (set! (-> self string-min-val y)
                 (fmax (-> *camera* settings gun-min-height) (- (-> self string-min-val y) (* 24576.0 f28-0)))
                 )
           (set! (-> self string-max-val y)
                 (fmin
                   (+ 16384.0 (-> self string-min-val y))
                   (fmax (+ 8192.0 (-> self string-min-val y)) (- (-> self string-max-val y) (* 24576.0 f28-0)))
                   )
                 )
           )
          ((and (logtest? (cam-slave-options-u32 GUN_CAM) (-> self options)) (< f28-0 0.0))
           (set! (-> self string-max-val y)
                 (fmin (-> *camera* settings gun-max-height) (- (-> self string-max-val y) (* 24576.0 f28-0)))
                 )
           (set! (-> self string-min-val y)
                 (fmin
                   (+ -8192.0 (-> self string-max-val y))
                   (fmax (+ -16384.0 (-> self string-max-val y)) (- (-> self string-min-val y) (* 24576.0 f28-0)))
                   )
                 )
           )
          ((logtest? (cam-slave-options-u32 GUN_CAM) (-> self options))
           (set! (-> self string-max-val y)
                 (fmax
                   (+ 8192.0 (-> *camera* settings gun-min-height))
                   (fmin (-> *camera* settings gun-max-height) (-> self string-max-val y))
                   )
                 )
           (set! (-> self string-min-val y)
                 (fmax
                   (-> *camera* settings gun-min-height)
                   (fmin (+ -8192.0 (-> *camera* settings gun-max-height)) (-> self string-min-val y))
                   )
                 )
           (set! (-> self string-min-val y) (fmax (+ -16384.0 (-> self string-max-val y)) (-> self string-min-val y)))
           )
          ((< (* 0.05 (- 1.0 f0-36)) f28-0)
           (let ((f0-55 (+ f0-36 (* 0.05 (- 1.0 f0-36)))))
             (set! (-> self view-off-param) (fmax (-> self view-off-param) f0-55))
             (vector-normalize! (-> self view-flat) (lerp (-> self string-min-val z) (-> self string-max-val z) f0-55))
             )
           )
          ((< f28-0 (* 0.05 (- f0-36)))
           (set! (-> self view-off-param) (+ f0-36 (* 0.05 (- f0-36))))
           )
          ((< 0.0 f28-0)
           (let ((f0-57 (+ f0-36 (* f28-0 (-> self clock time-adjust-ratio)))))
             (set! (-> self view-off-param) (fmax (-> self view-off-param) f0-57))
             (vector-normalize! (-> self view-flat) (lerp (-> self string-min-val z) (-> self string-max-val z) f0-57))
             )
           )
          ((< f28-0 0.0)
           (set! (-> self view-off-param) (+ f0-36 (* f28-0 (-> self clock time-adjust-ratio))))
           )
          )
        )
      )
    (cond
      ((logtest? (cam-slave-options-u32 GUN_CAM) (-> self options))
       )
      ((= f28-0 0.0)
       (set! (-> self view-off z) (-> self string-max-val z))
       )
      (else
        (set! (-> self view-off z)
              (lerp (-> self string-min-val z) (-> self string-max-val z) (-> self view-off-param))
              )
        )
      )
    (if (-> *camera* being-attacked)
        (set! (-> self view-off-param) f30-1)
        )
    )
  (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
    (let ((f30-2 (analog-input
                   (the-as int (-> *cpad-list* cpads 0 rightx))
                   128.0
                   32.0
                   110.0
                   (* 182.04445
                      (-> self clock seconds-per-frame)
                      (if (logtest? (cam-slave-options-u32 GUN_CAM) (-> self options))
                          120.0
                          120.0
                          )
                      )
                   )
                 )
          (s4-0 (new-stack-matrix0))
          (gp-3 (new-stack-vector0))
          (s5-3 (new-stack-vector0))
          )
      (if (logtest? (cam-slave-options-u32 BLOCK_RIGHT_STICK) (-> self options))
          (set! f30-2 0.0)
          )
      (if (-> *setting-control* user-default unknowng-symbol-00)
          (set! f30-2 (- f30-2))
          )
      (if (-> self have-phony-joystick)
          (set! f30-2 (* 21845.334 (-> self phony-joystick-x) (-> self clock seconds-per-frame)))
          )
      (when (logtest? (cam-slave-options-u32 ALLOW_SHIFT_BUTTONS) (-> self options))
        (when (logtest? (-> *camera* settings master-options) (cam-master-options READ_BUTTONS))
          (if (cpad-hold? (-> *CAMERA-bank* joypad) r1)
              (+! f30-2 (+ (* 10922.667 (-> self clock seconds-per-frame))
                           (analog-input
                             (the-as int (-> *cpad-list* cpads (-> *CAMERA-bank* joypad) abutton 9))
                             0.0
                             32.0
                             230.0
                             (* 21845.334 (-> self clock seconds-per-frame))
                             )
                           )
                  )
              )
          )
        (when (logtest? (-> *camera* settings master-options) (cam-master-options READ_BUTTONS))
          (if (cpad-hold? (-> *CAMERA-bank* joypad) l1)
              (set! f30-2 (- f30-2 (+ (* 10922.667 (-> self clock seconds-per-frame))
                                      (analog-input
                                        (the-as int (-> *cpad-list* cpads (-> *CAMERA-bank* joypad) abutton 8))
                                        0.0
                                        32.0
                                        230.0
                                        (* 21845.334 (-> self clock seconds-per-frame))
                                        )
                                      )
                             )
                    )
              )
          )
        )
      (cond
        ((and (= (-> self los-state) (slave-los-state ccw)) (< 0.0 f30-2))
         (let ((f0-82
                 (fmax (-> self string-min-val z) (fmin (-> self string-max-val z) (vector-length (-> self view-flat))))
                 )
               )
           (set! f30-2 (* 21845.334 (+ 0.1 (/ (-> self string-min-val z) f0-82)) (-> self clock seconds-per-frame)))
           )
         )
        ((and (= (-> self los-state) (slave-los-state cw)) (< f30-2 0.0))
         (let ((f0-88
                 (fmax (-> self string-min-val z) (fmin (-> self string-max-val z) (vector-length (-> self view-flat))))
                 )
               )
           (set! f30-2 (* -21845.334 (+ 0.1 (/ (-> self string-min-val z) f0-88)) (-> self clock seconds-per-frame)))
           )
         )
        )
      (cond
        ((!= f30-2 0.0)
         (logior! (-> self options) (cam-slave-options-u32 PLAYER_MOVING_CAMERA))
         (matrix-axis-angle! s4-0 (-> *camera* local-down) f30-2)
         (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
         (set! (-> self butt-timer) (the-as uint 0))
         (set! (-> self butt-seek) #f)
         (when (logtest? (cam-slave-options-u32 HAVE_BUTT_HANDLE) (-> self options))
           (kill-persister *setting-control* (the-as engine-pers 'butt-handle) 'butt-handle)
           (logclear! (-> self options) (cam-slave-options-u32 HAVE_BUTT_HANDLE))
           )
         )
        ((or (logtest? (-> self options) (cam-slave-options-u32 BUTT_CAM))
             (let ((s3-0 (handle->process (-> *camera* settings butt-handle))))
               (if (type? s3-0 process-drawable)
                   s3-0
                   )
               )
             )
         (vector-normalize-copy! gp-3 (-> self view-flat) 1.0)
         (let ((v1-283 (handle->process (-> *camera* settings butt-handle))))
           (cond
             (v1-283
               (set! (-> self options) (logior (cam-slave-options-u32 HAVE_BUTT_HANDLE) (-> self options)))
               (let* ((s3-1 (quaternion->matrix (new 'stack-no-clear 'matrix) (-> (the-as process-drawable v1-283) root quat)))
                      (a2-18 (matrix-axis-angle!
                               (new 'stack-no-clear 'matrix)
                               (-> s3-1 vector 1)
                               (+ 32768.0 (-> *camera* settings butt-angle))
                               )
                             )
                      )
                 (vector-matrix*! s5-3 (-> s3-1 vector 2) a2-18)
                 )
               (vector-flatten! s5-3 s5-3 (-> *camera* local-down))
               )
             ((< (- (current-time) (the-as int (-> self butt-timer))) 0)
              (vector-flatten! s5-3 (-> self butt-vector) (-> *camera* local-down))
              )
             (else
               (vector-flatten! s5-3 (-> *camera* tgt-rot-mat vector 2) (-> *camera* local-down))
               )
             )
           )
         (vector-normalize! s5-3 -1.0)
         (when (and (logtest? (cam-slave-options-u32 HAVE_BUTT_HANDLE) (-> self options))
                    (< (cos 910.2222) (vector-dot gp-3 s5-3))
                    )
           (kill-persister *setting-control* (the-as engine-pers 'butt-handle) 'butt-handle)
           (logclear! (-> self options) (cam-slave-options-u32 HAVE_BUTT_HANDLE))
           )
         (matrix-from-two-vectors-max-angle! s4-0 gp-3 s5-3 546.13336)
         (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
         )
        (else
          (logclear! (-> self options) (cam-slave-options-u32 HAVE_BUTT_HANDLE))
          )
        )
      (when (logtest? (-> *camera* settings slave-options) (cam-slave-options BIKE_MODE))
        (vector-normalize-copy! gp-3 (-> self view-flat) 1.0)
        (vector-flatten! s5-3 (-> *camera* tgt-rot-mat vector 2) (-> *camera* local-down))
        (vector-normalize! s5-3 -1.0)
        (let ((f0-97 (acos (vector-dot s5-3 gp-3))))
          (when (and (< (-> self max-angle-offset) f0-97) (< f0-97 32585.955))
            (matrix-from-two-vectors-max-angle!
              s4-0
              gp-3
              s5-3
              (fmin 546.13336 (* 0.5 (- f0-97 (-> self max-angle-offset))))
              )
            (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
            )
          )
        )
      )
    )
  (when (not (logtest? (cam-slave-options WIDE_FOV) (-> *camera* settings slave-options)))
    (let ((f0-101 (vector-length (-> self view-flat))))
      (let ((f1-89 (-> self view-off z)))
        (when (< f1-89 f0-101)
          (vector-float*! (-> self view-flat) (-> self view-flat) (/ f1-89 f0-101))
          (set! (-> self min-z-override) f1-89)
          (set! f0-101 f1-89)
          )
        )
      (if (and (< (-> self joystick-saved-view-off z) f0-101)
               (< (-> self view-off y) (-> self joystick-saved-view-off y))
               )
          (set! (-> self view-off y) (fmin
                                       (-> *camera* settings string-cliff-height)
                                       (fmax (-> self string-min-val y) (-> self joystick-saved-view-off y))
                                       )
                )
          )
      (set! (-> self joystick-saved-view-off y) (-> self view-off y))
      (set! (-> self joystick-saved-view-off z) f0-101)
      f0-101
      )
    )
  )

(defbehavior cam-string-find-hidden camera-slave ()
  (let ((s5-0 (new 'stack-no-clear 'collide-query))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (vector--float*!
      (-> s5-0 move-dist)
      (-> *camera* tpos-curr-adj)
      (-> *camera* local-down)
      (-> *camera* settings target-height)
      )
    (vector-! (-> s5-0 move-dist) (-> s5-0 move-dist) (-> self string-trans))
    (set! (-> s5-0 start-pos quad) (-> self string-trans quad))
    (let ((s4-0 s5-0))
      (set! (-> s4-0 radius) 409.6)
      (set! (-> s4-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
      (set! (-> s4-0 ignore-process0) #f)
      (set! (-> s4-0 ignore-process1) #f)
      (set! (-> s4-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
      (set! (-> s4-0 action-mask) (collide-action solid))
      )
    (cond
      ((< (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
       (set! (-> self time-dist-too-far) (the-as uint 0))
       0
       )
      ((< (-> self time-dist-too-far) (the-as uint 600))
       (+! (-> self time-dist-too-far) 1)
       )
      ((cam-string-find-position-rel! gp-0)
       (cam-string-set-position-rel! gp-0)
       (set! (-> self time-dist-too-far) (the-as uint 0))
       0
       )
      (else
        (format 0 "camera position search failed~%")
        (set! (-> self time-dist-too-far) (the-as uint 0))
        0
        )
      )
    )
  (none)
  )

(defbehavior cam-string-move camera-slave ()
  (vector-! (-> self velocity) (-> self desired-pos) (-> self string-trans))
  (if *display-cam-los-debug*
      (format *stdcon* "vel ~M~%" (vector-length (-> self velocity)))
      )
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (vector-! s3-0 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
    (vector+float*! s5-0 (-> self velocity) s3-0 0.5)
    (vector-normalize! s5-0 1.0)
    (vector-normalize-copy! s4-0 (-> self view-flat) 1.0)
    (vector-cross! gp-0 s4-0 s5-0)
    (cond
      ((and (< (vector-length (-> self velocity)) (-> *CAMERA-bank* min-detectable-velocity))
            (< (vector-length s3-0) (-> *CAMERA-bank* min-detectable-velocity))
            )
       (set! (-> self string-vel-dir) (the-as uint 0))
       0
       )
      ((< (cos 5461.3335) (vector-dot (-> *camera* local-down) s5-0))
       (set! (-> self string-vel-dir) (the-as uint 4))
       )
      ((< (vector-dot (-> *camera* local-down) s5-0) (- (cos 5461.3335)))
       (set! (-> self string-vel-dir) (the-as uint 3))
       )
      ((< (cos 5461.3335) (vector-dot s4-0 s5-0))
       (set! (-> self string-vel-dir) (the-as uint 6))
       )
      ((< (vector-dot s4-0 s5-0) (- (cos 5461.3335)))
       (set! (-> self string-vel-dir) (the-as uint 5))
       )
      ((< (vector-dot (-> *camera* local-down) gp-0) 0.0)
       (set! (-> self string-vel-dir) (the-as uint 1))
       )
      (else
        (set! (-> self string-vel-dir) (the-as uint 2))
        )
      )
    )
  (let ((s5-1 (new 'stack-no-clear 'collide-query)))
    0.0
    (let ((f30-2 1.0)
          (s4-1 (-> s5-1 move-dist))
          (gp-1 0)
          )
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (when *debug-segment*
          (if (>= (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity)))
              (cam-collision-record-save (-> self string-trans) (-> self velocity) -1 'no-hit self)
              )
          )
        (while (and (< 0.01 f30-2)
                    (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (< gp-1 4))
                    )
          (vector-float*! s4-1 (-> self velocity) f30-2)
          (if *debug-segment*
              (cam-collision-record-save (-> self string-trans) s4-1 gp-1 'normal self)
              )
          (let ((f28-0
                  (cond
                    ((logtest? (-> self options) (cam-slave-options-u32 COLLIDE))
                     (set! (-> s5-1 start-pos quad) (-> self string-trans quad))
                     (let ((s2-0 s5-1))
                       (set! (-> s2-0 radius) (-> *CAMERA-bank* collide-move-rad))
                       (set! (-> s2-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
                       (set! (-> s2-0 ignore-process0) #f)
                       (set! (-> s2-0 ignore-process1) #f)
                       (set! (-> s2-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
                       (set! (-> s2-0 action-mask) (collide-action solid))
                       )
                     (fill-and-probe-using-line-sphere *collide-cache* s5-1)
                     )
                    (else
                      -100000000.0
                      )
                    )
                  )
                )
            (if *display-cam-los-debug*
                (format *stdcon* "vp ~f vr ~f r ~f ta ~f~%" (vector-length s4-1) f30-2 (/ (vector-length s4-1) f30-2) f28-0)
                )
            (cond
              ((>= f28-0 0.0)
               (let* ((f1-10 (fmax 0.01 (/ 40.96 (vector-length s4-1))))
                      (f0-22 (fmax 0.0 (- f28-0 f1-10)))
                      )
                 (vector+float*! (-> self string-trans) (-> self string-trans) s4-1 f0-22)
                 )
               (vector-! s3-1 (-> self string-trans) (-> s5-1 best-other-tri intersect))
               (vector-normalize! s3-1 1.0)
               (vector-flatten! (-> self velocity) (-> self velocity) s3-1)
               (set! f30-2 (- f30-2 (* f30-2 f28-0)))
               (+! gp-1 1)
               )
              (else
                (vector+! (-> self string-trans) (-> self string-trans) s4-1)
                (set! f30-2 0.0)
                )
              )
            )
          )
        )
      (cond
        ((zero? gp-1)
         (logclear! (-> self options) (cam-slave-options-u32 MOVEMENT_BLOCKED))
         (if *display-cam-los-debug*
             (format *stdcon* "not blocked~%")
             )
         )
        (else
          (logior! (-> self options) (cam-slave-options-u32 MOVEMENT_BLOCKED))
          (if *display-cam-los-debug*
              (format *stdcon* "blocked ~D ~f~%" gp-1 f30-2)
              )
          (let ((gp-2 (new-stack-vector0))
                (f30-3 (vector-length (-> self view-flat)))
                )
            (vector-! gp-2 (-> self string-trans) (-> *camera* tpos-curr-adj))
            (vector-flatten! gp-2 gp-2 (-> *camera* local-down))
            (let ((f28-1 (vector-length gp-2)))
              (cond
                ((< f28-1 f30-3)
                 (vector-normalize-copy! (-> self view-flat) gp-2 f28-1)
                 (set! (-> self min-z-override) f28-1)
                 )
                (else
                  (vector-normalize-copy! (-> self view-flat) gp-2 f30-3)
                  )
                )
              )
            )
          )
        )
      )
    )
  (when *display-cam-los-debug*
    (let ((v1-105 (new-stack-vector0)))
      (vector-! v1-105 (-> self desired-pos) (-> self string-trans))
      (format *stdcon* "vel ~M~%" (vector-length v1-105))
      )
    )
  )

;; WARN: Return type mismatch float vs vector.
(defbehavior cam-string-code camera-slave ()
  (if *debug-segment*
      (cam-debug-reset-coll-tri)
      )
  (cam-string-follow)
  (if (logtest? (-> self options) (cam-slave-options-u32 LINE_OF_SIGHT))
      (cam-string-line-of-sight)
      )
  (if (not (paused?))
      (cam-string-joystick)
      )
  (let ((gp-0 (new-stack-vector0)))
    (vector--float*!
      gp-0
      (-> self view-flat)
      (-> *camera* local-down)
      (+ (-> *camera* settings target-height) (-> self view-off y))
      )
    (vector+! (-> self desired-pos) (-> *camera* tpos-curr-adj) gp-0)
    )
  (set! (-> self desired-pos y) (fmin (-> self desired-pos y) (-> *camera* settings string-camera-ceiling)))
  (if (logtest? (-> self options) (cam-slave-options-u32 FIND_HIDDEN_TARGET))
      (cam-string-find-hidden)
      )
  (cond
    ((logtest? (-> self options) (cam-slave-options-u32 GOTO_GOOD_POINT))
     (when *debug-segment*
       (let ((a1-1 (new 'stack-no-clear 'vector)))
         (vector-! a1-1 (-> self good-point) (-> self string-trans))
         (cam-collision-record-save (-> self string-trans) a1-1 -2 'jump self)
         )
       )
     (logclear! (-> self options) (cam-slave-options-u32 GOTO_GOOD_POINT))
     (set! (-> self desired-pos quad) (-> self good-point quad))
     (cam-string-move)
     (vector-! (-> self view-flat) (-> self string-trans) (-> *camera* tpos-curr-adj))
     (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
     (let ((f0-4 (vector-length (-> self view-flat))))
       (if (< f0-4 (-> self min-z-override))
           (set! (-> self min-z-override) f0-4)
           )
       )
     )
    (else
      (cam-string-move)
      )
    )
  (tracking-spline-method-17 (-> self position-spline) (-> self string-trans) 0.04096 4096.0 #t)
  (let ((f30-0 (-> self clock clock-ratio)))
    (let ((gp-2 (max 2 (the int (+ 0.5 (-> self clock time-adjust-ratio))))))
      (update-rates! (-> self clock) (/ f30-0 (the float gp-2)))
      (while (nonzero? gp-2)
        (+! gp-2 -1)
        (cond
          ((-> self butt-seek)
           (tracking-spline-method-21 (-> self position-spline) (-> self trans) 163.84 8192.0 0.1)
           (send-event *camera-combiner* 'fast-rot)
           (if (< (-> self position-spline summed-len) 4096.0)
               (set! (-> self butt-seek) #f)
               )
           )
          ((logtest? (cam-slave-options RAPID_TRACKING) (-> *camera* settings slave-options))
           (tracking-spline-method-21 (-> self position-spline) (-> self trans) 4096.0 40960.0 0.1)
           )
          ((and (logtest? (-> *camera* settings slave-options) (cam-slave-options BIKE_MODE))
                (logtest? (-> self options) (cam-slave-options-u32 PLAYER_MOVING_CAMERA))
                )
           (tracking-spline-method-21 (-> self position-spline) (-> self trans) 102.4 4096.0 0.1)
           )
          ((logtest? (-> *camera* settings slave-options) (cam-slave-options BIKE_MODE))
           (tracking-spline-method-21 (-> self position-spline) (-> self trans) 40.96 4096.0 0.1)
           )
          ((logtest? (-> self options) (cam-slave-options-u32 PLAYER_MOVING_CAMERA))
           (tracking-spline-method-21
             (-> self position-spline)
             (-> self trans)
             (-> *camera* settings string-spline-accel-player)
             (-> *camera* settings string-spline-max-move-player)
             0.1
             )
           )
          (else
            (tracking-spline-method-21
              (-> self position-spline)
              (-> self trans)
              (-> *camera* settings string-spline-accel)
              (-> *camera* settings string-spline-max-move)
              0.1
              )
            )
          )
        )
      )
    (the-as vector (update-rates! (-> self clock) f30-0))
    )
  )

(defbehavior set-string-params camera-slave ()
  (when (not (or (-> self string-val-locked) (logtest? (cam-slave-options-u32 GUN_CAM) (-> self options))))
    (set! (-> self string-min-val quad) (-> *camera* string-min value quad))
    (let ((v0-0 (-> self string-max-val)))
      (set! (-> v0-0 quad) (-> *camera* string-max value quad))
      v0-0
      )
    )
  )

(defstate cam-string (camera-slave)
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (local-vars (v0-0 object))
    (let ((v1-0 event-type))
      (the-as
        object
        (cond
          ((= v1-0 'get-behind)
           (set! (-> self butt-timer) (the-as uint (+ (current-time) (seconds 0.25))))
           (set! (-> self butt-seek) (the-as basic #t))
           (set! v0-0 (-> self butt-vector))
           (set! (-> (the-as vector v0-0) quad) (-> (the-as vector (-> event param 0)) quad))
           v0-0
           )
          ((= v1-0 'teleport)
           (let ((gp-0 (new-stack-vector0)))
             (cam-string-find-position-rel! gp-0)
             (cam-string-set-position-rel! gp-0)
             )
           )
          ((= v1-0 'joystick)
           (set! (-> self phony-joystick-x) (the-as float (-> event param 0)))
           (set! (-> self phony-joystick-y) (the-as float (-> event param 1)))
           (set! v0-0 #t)
           (set! (-> self have-phony-joystick) (the-as basic v0-0))
           v0-0
           )
          ((= v1-0 'tween-dist)
           (cond
             ((-> event param 0)
              (set! (-> self string-val-locked) (the-as basic #t))
              (let ((s5-0 (the-as object (-> event param 0)))
                    (gp-1 (the-as object (-> event param 1)))
                    )
                (if (!= (-> (the-as vector s5-0) y) 4095996000.0)
                    (seek!
                      (-> self string-min-val y)
                      (-> (the-as vector s5-0) y)
                      (* (-> (the-as vector s5-0) w) (-> self clock seconds-per-frame))
                      )
                    )
                (if (!= (-> (the-as vector s5-0) z) 4095996000.0)
                    (seek!
                      (-> self string-min-val z)
                      (-> (the-as vector s5-0) z)
                      (* (-> (the-as vector s5-0) w) (-> self clock seconds-per-frame))
                      )
                    )
                (if (!= (-> (the-as vector gp-1) y) 4095996000.0)
                    (seek!
                      (-> self string-max-val y)
                      (-> (the-as vector gp-1) y)
                      (* (-> (the-as vector gp-1) w) (-> self clock seconds-per-frame))
                      )
                    )
                (if (!= (-> (the-as vector gp-1) z) 4095996000.0)
                    (seek!
                      (-> self string-max-val z)
                      (-> (the-as vector gp-1) z)
                      (* (-> (the-as vector gp-1) w) (-> self clock seconds-per-frame))
                      )
                    )
                )
              (set! (-> self string-max-val x) (fmax (-> self string-max-val x) (-> self string-min-val x)))
              (set! (-> self string-max-val y) (fmax (-> self string-max-val y) (-> self string-min-val y)))
              (set! (-> self string-max-val z) (fmax (-> self string-max-val z) (-> self string-min-val z)))
              )
             (else
               (set! (-> self string-val-locked) #f)
               #f
               )
             )
           )
          ((= v1-0 'set-dist)
           (cond
             ((-> event param 0)
              (set! (-> self string-val-locked) (the-as basic #t))
              (set! (-> self string-min-val quad) (-> (the-as vector (-> event param 0)) quad))
              (set! (-> self string-max-val quad) (-> (the-as vector (-> event param 1)) quad))
              (set! (-> self string-max-val x) (fmax (-> self string-max-val x) (-> self string-min-val x)))
              (set! (-> self string-max-val y) (fmax (-> self string-max-val y) (-> self string-min-val y)))
              (set! (-> self string-max-val z) (fmax (-> self string-max-val z) (-> self string-min-val z)))
              )
             (else
               (set! (-> self string-val-locked) #f)
               #f
               )
             )
           )
          ((= v1-0 'relative-position)
           (cond
             ((-> event param 0)
              (set! (-> self string-val-locked) (the-as basic #t))
              (set! (-> self string-relative) (the-as basic #t))
              (set! v0-0 (-> self relative-position))
              (set! (-> (the-as vector v0-0) quad) (-> (the-as vector (-> event param 0)) quad))
              v0-0
              )
             (else
               (set! (-> self string-val-locked) #f)
               (set! (-> self string-relative) #f)
               #f
               )
             )
           )
          ((= v1-0 'set-max-angle-offset)
           (set! (-> self max-angle-offset) (the-as float (-> event param 0)))
           )
          ((= v1-0 'blocked-side?)
           (-> self los-state)
           )
          (else
            (the-as object (cam-standard-event-handler proc arg1 event-type event))
            )
          )
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (if (-> self cam-entity)
          (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
          )
      (vector-reset! (-> self joystick-saved-view-off))
      (set-string-params)
      (set! (-> self string-vel-dir) (the-as uint 0))
      (set! (-> self fov) 11650.845)
      (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline end-point))
      (set! (-> self los-tgt-spline-pt-incarnation)
            (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
            )
      (set! (-> self min-z-override) (-> self string-max-val z))
      (if (!= (-> *camera* outro-t-step) 0.0)
          (set! (-> self min-z-override) (-> self string-min-val z))
          )
      (let ((gp-1 (new-stack-vector0)))
        0.0
        (set! (-> self view-off-param) (-> *camera* view-off-param-save))
        (set! (-> self view-off x) 0.0)
        (let ((f0-7 (-> self string-min-val y))
              (f1-1 (-> self string-max-val y))
              )
          (set! (-> self view-off y) (lerp f0-7 f1-1 (-> self view-off-param)))
          )
        (set! (-> self view-off z)
              (lerp (-> self string-min-val z) (-> self string-max-val z) (-> self view-off-param))
              )
        (let ((f30-0
                (cond
                  ((!= (-> *camera* outro-t-step) 0.0)
                   (curve-get-pos! gp-1 (-> *camera* outro-exit-value) (-> *camera* outro-curve))
                   (vector-! gp-1 gp-1 (-> *camera* tpos-curr-adj))
                   (vector-flatten! (-> self view-flat) gp-1 (-> *camera* local-down))
                   (vector-length (-> self view-flat))
                   )
                  ((-> *camera* settings string-use-startup-vector)
                   (vector-flatten! (-> self view-flat) (-> *camera* settings string-startup-vector) (-> *camera* local-down))
                   (vector-length (-> self view-flat))
                   )
                  (else
                    (vector-flatten! (-> self view-flat) (-> self tracking inv-mat vector 2) (-> *camera* local-down))
                    (vector-negate! (-> self view-flat) (-> self view-flat))
                    (-> self view-off z)
                    )
                  )
                )
              )
          (let ((f1-4 (fmin (-> *camera* string-push-z) (-> self min-z-override)))
                (f0-17 (-> self view-off z))
                )
            (cond
              ((< f30-0 f1-4)
               (set! f30-0 f1-4)
               )
              ((< f0-17 f30-0)
               (set! f30-0 f0-17)
               )
              )
            )
          (vector-normalize! (-> self view-flat) f30-0)
          (let ((f30-1 (/ (- f30-0 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))))
            (if (< 1.0 f30-1)
                (set! f30-1 1.0)
                )
            (if (< f30-1 0.0)
                (set! f30-1 0.0)
                )
            (let ((f0-22 (-> self string-min-val y))
                  (f1-7 (-> self string-max-val y))
                  )
              (set! (-> self view-off y) (lerp f0-22 f1-7 f30-1))
              )
            (set! (-> self view-off z) (lerp (-> self string-min-val z) (-> self string-max-val z) f30-1))
            )
          )
        )
      (vector--float*!
        (-> self desired-pos)
        (-> self view-flat)
        (-> *camera* local-down)
        (+ (-> *camera* settings target-height) (-> self view-off y))
        )
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
      (set! (-> self string-trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (let ((gp-2 (new 'stack-no-clear 'collide-query)))
        (vector--float*!
          (-> gp-2 start-pos)
          (-> *camera* tpos-curr-adj)
          (-> *camera* local-down)
          (-> *camera* settings target-height)
          )
        (vector-! (-> gp-2 move-dist) (-> self string-trans) (-> gp-2 start-pos))
        (let ((s5-0 gp-2))
          (set! (-> s5-0 radius) (-> *CAMERA-bank* collide-move-rad))
          (set! (-> s5-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
          (set! (-> s5-0 ignore-process0) #f)
          (set! (-> s5-0 ignore-process1) #f)
          (set! (-> s5-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
          (set! (-> s5-0 action-mask) (collide-action solid))
          )
        (let ((f0-31 (fill-and-probe-using-line-sphere *collide-cache* gp-2)))
          (when (and (< 0.0 f0-31) (< f0-31 1.0))
            (vector-float*! (-> gp-2 move-dist) (-> gp-2 move-dist) f0-31)
            (vector-flatten! (-> self view-flat) (-> gp-2 move-dist) (-> *camera* local-down))
            (let ((f0-32 (vector-length (-> self view-flat))))
              (cond
                ((< f0-32 8192.0)
                 (let ((gp-3 (new-stack-vector0)))
                   (cam-string-find-position-rel! gp-3)
                   (cam-string-set-position-rel! gp-3)
                   )
                 )
                (else
                  (if (< f0-32 (-> self min-z-override))
                      (set! (-> self min-z-override) f0-32)
                      )
                  (let ((f30-2 (/ (- f0-32 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))))
                    (if (< 1.0 f30-2)
                        (set! f30-2 1.0)
                        )
                    (if (< f30-2 0.0)
                        (set! f30-2 0.0)
                        )
                    (let ((f0-36 (-> self string-min-val y))
                          (f1-16 (-> self string-max-val y))
                          )
                      (set! (-> self view-off y) (lerp f0-36 f1-16 f30-2))
                      )
                    (set! (-> self view-off z) (lerp (-> self string-min-val z) (-> self string-max-val z) f30-2))
                    )
                  (vector--float*!
                    (-> self desired-pos)
                    (-> self view-flat)
                    (-> *camera* local-down)
                    (+ (-> *camera* settings target-height) (-> self view-off y))
                    )
                  (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
                  (set! (-> self string-trans quad) (-> self desired-pos quad))
                  (vector-reset! (-> self velocity))
                  )
                )
              )
            )
          )
        )
      (set! (-> self trans quad) (-> self string-trans quad))
      (set! (-> self los-last-pos quad) (-> self string-trans quad))
      (tracking-spline-method-10 (-> self position-spline) (-> self string-trans))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (set-string-params)
        (cam-string-code)
        (tracking-spline-method-9 (-> self position-spline))
        (set! (-> self have-phony-joystick) #f)
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(deftype cam-stick-bank (basic)
  ((max-z meters  :offset-assert   4)
   (min-z meters  :offset-assert   8)
   (max-y meters  :offset-assert  12)
   (min-y meters  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_STICK-bank*
  (new 'static 'cam-stick-bank :max-z (meters 30) :min-z (meters 5) :max-y (meters 15) :min-y (meters 2))
  )

(defbehavior cam-stick-code camera-slave ()
  (cam-calc-follow! (-> self tracking) (-> self trans) #t)
  (let ((gp-0 (new-stack-vector0)))
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (vector-normalize! (-> self view-flat) (-> self view-off z))
    (vector-! gp-0 (-> self view-flat) (vector-float*! gp-0 (-> *camera* local-down) (-> self view-off y)))
    (vector+! (-> self desired-pos) (-> self tracking follow-pt) gp-0)
    )
  (let ((v1-3 (new-stack-vector0))
        (gp-1 (new-stack-vector0))
        )
    (vector-! v1-3 (-> self desired-pos) (-> self trans))
    (vector-float*! v1-3 v1-3 0.2)
    (vector-! gp-1 v1-3 (-> self velocity))
    (if (< 409.6 (vector-length gp-1))
        (vector-normalize! gp-1 409.6)
        )
    (vector+! (-> self velocity) (-> self velocity) gp-1)
    )
  (let ((gp-2 (new 'stack-no-clear 'collide-query)))
    0.0
    (let ((f30-0 1.0)
          (s5-0 (-> gp-2 move-dist))
          (s4-0 (new-stack-vector0))
          (s3-0 4)
          (s2-0 0)
          )
      (while (and (< 0.01 f30-0)
                  (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (> s3-0 0))
                  )
        (+! s3-0 -1)
        (vector-float*! s5-0 (-> self velocity) f30-0)
        (let ((f28-0
                (cond
                  ((logtest? (-> self options) (cam-slave-options-u32 COLLIDE))
                   (set! (-> gp-2 start-pos quad) (-> self trans quad))
                   (let ((s1-0 gp-2))
                     (set! (-> s1-0 radius) (-> *CAMERA-bank* collide-move-rad))
                     (set! (-> s1-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
                     (set! (-> s1-0 ignore-process0) #f)
                     (set! (-> s1-0 ignore-process1) #f)
                     (set! (-> s1-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
                     (set! (-> s1-0 action-mask) (collide-action solid))
                     )
                   (fill-and-probe-using-line-sphere *collide-cache* gp-2)
                   )
                  (else
                    -100000000.0
                    )
                  )
                )
              )
          (cond
            ((>= f28-0 0.0)
             (vector+float*! (-> self trans) (-> self trans) s5-0 f28-0)
             (set! (-> s4-0 quad) (-> gp-2 best-other-tri normal quad))
             (vector-flatten! (-> self velocity) (-> self velocity) s4-0)
             (set! f30-0 (- f30-0 (* f30-0 f28-0)))
             (set! s2-0 1)
             )
            (else
              (vector+! (-> self trans) (-> self trans) s5-0)
              (set! f30-0 0.0)
              )
            )
          )
        )
      (when (nonzero? s2-0)
        0
        (let ((gp-3 (new-stack-vector0)))
          0.0
          (vector-! gp-3 (-> self trans) (-> self tracking follow-pt))
          (vector-flatten! gp-3 gp-3 (-> *camera* local-down))
          (let ((f0-15 (/ (- (vector-length gp-3) (-> *CAM_STICK-bank* min-z))
                          (- (-> *CAM_STICK-bank* max-z) (-> *CAM_STICK-bank* min-z))
                          )
                       )
                )
            (cond
              ((< f0-15 0.0)
               (set! f0-15 0.0)
               )
              ((< 1.0 f0-15)
               (set! f0-15 1.0)
               )
              )
            (cond
              ((< (- f0-15 (-> self view-off-param)) -0.001)
               (set! (-> self view-off-param) f0-15)
               )
              ((< 0.001 (- f0-15 (-> self view-off-param)))
               (vector-normalize-copy! (-> self view-flat) gp-3 (-> self view-off z))
               )
              )
            )
          )
        )
      )
    )
  (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #t)
  (none)
  )

(defstate cam-stick (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self view-off-param) (-> *camera* view-off-param-save))
      (set! (-> self view-off x) 0.0)
      (set! (-> self view-off y)
            (lerp (-> *CAM_STICK-bank* min-y) (-> *CAM_STICK-bank* max-y) (-> self view-off-param))
            )
      (set! (-> self view-off z)
            (lerp (-> *CAM_STICK-bank* min-z) (-> *CAM_STICK-bank* max-z) (-> self view-off-param))
            )
      (cam-calc-follow! (-> self tracking) (-> self trans) #f)
      (vector-flatten! (-> self view-flat) (-> self tracking inv-mat vector 2) (-> *camera* local-down))
      (vector-negate! (-> self view-flat) (-> self view-flat))
      (vector-normalize! (-> self view-flat) (-> self view-off z))
      (vector--float*! (-> self desired-pos) (-> self view-flat) (-> *camera* local-down) (-> self view-off y))
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> self tracking follow-pt))
      (set! (-> self trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
      )
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (when (not (paused?))
      (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
        (let ((f0-0 (analog-input (the-as int (-> *cpad-list* cpads 0 righty)) 128.0 32.0 110.0 0.05)))
          (cond
            ((< (* 0.05 (- 1.0 (-> self view-off-param))) f0-0)
             (+! (-> self view-off-param) (* 0.05 (- 1.0 (-> self view-off-param))))
             )
            ((< f0-0 (* 0.05 (- (-> self view-off-param))))
             (+! (-> self view-off-param) (* 0.05 (- (-> self view-off-param))))
             )
            (else
              (+! (-> self view-off-param) f0-0)
              )
            )
          )
        )
      (set! (-> self view-off y)
            (lerp (-> *CAM_STICK-bank* min-y) (-> *CAM_STICK-bank* max-y) (-> self view-off-param))
            )
      (set! (-> self view-off z)
            (lerp (-> *CAM_STICK-bank* min-z) (-> *CAM_STICK-bank* max-z) (-> self view-off-param))
            )
      (when (not (logtest? (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
        (let ((f0-16 (analog-input
                       (the-as int (-> *cpad-list* cpads 0 rightx))
                       128.0
                       32.0
                       110.0
                       (* 21845.334 (-> self clock seconds-per-frame))
                       )
                     )
              (gp-0 (new-stack-matrix0))
              (s3-0 (new-stack-vector0))
              (s5-0 (new-stack-vector0))
              (s4-0 (new-stack-vector0))
              )
          (cond
            ((!= f0-16 0.0)
             (matrix-axis-angle! gp-0 (-> *camera* local-down) f0-16)
             (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
             )
            ((logtest? (-> self options) (cam-slave-options-u32 BUTT_CAM))
             (set-vector! s5-0 0.0 0.0 1.0 1.0)
             (vector-normalize-copy! s5-0 (-> self view-flat) 1.0)
             (set! (-> s3-0 quad) (-> (the-as vector (-> *camera* tgt-rot-mat vector 2)) quad))
             (vector-flatten! s3-0 s3-0 (-> *camera* local-down))
             (vector-negate! s3-0 s3-0)
             (set! (-> s4-0 quad) (-> s5-0 quad))
             (vector-normalize-copy! s4-0 s3-0 1.0)
             (matrix-from-two-vectors-max-angle-partial!
               gp-0
               s5-0
               s4-0
               (* 10922.667 (-> self clock seconds-per-frame))
               0.05
               )
             (vector-matrix*! (-> self view-flat) (-> self view-flat) gp-0)
             )
            )
          )
        )
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (if (not (paused?))
          (cam-stick-code)
          )
      (suspend)
      )
    #f
    (none)
    )
  )

(deftype cam-bike-bank (basic)
  ((max-z meters  :offset-assert   4)
   (min-z meters  :offset-assert   8)
   (max-y meters  :offset-assert  12)
   (min-y meters  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_BIKE-bank*
  (new 'static 'cam-bike-bank :max-z (meters 6) :min-z (meters 10) :max-y (meters 3) :min-y (meters 5))
  )

(defbehavior cam-calc-bike-follow! camera-slave ((arg0 cam-rotation-tracker) (arg1 vector) (arg2 symbol))
  (vector-float*! (-> arg0 follow-off) (-> *camera* tgt-face-mat vector 2) 155648.0)
  (vector+! (-> arg0 follow-pt) (-> *camera* tpos-curr-adj) (-> arg0 follow-off))
  (vector--float*!
    (-> arg0 follow-pt)
    (-> arg0 follow-pt)
    (-> *camera* local-down)
    (+ 12288.0 (-> *camera* settings target-height))
    )
  (-> arg0 follow-pt)
  )

(defbehavior cam-bike-code camera-slave ()
  (let ((s4-0 (new-stack-matrix0)))
    (let ((gp-0 (new-stack-vector0))
          (s5-0 (new-stack-vector0))
          )
      (vector-normalize-copy! gp-0 (-> self view-flat) 1.0)
      (vector-flatten! s5-0 (-> *camera* tgt-rot-mat vector 2) (-> *camera* local-down))
      (vector-normalize! s5-0 -1.0)
      (matrix-from-two-vectors-partial-linear! s4-0 gp-0 s5-0 0.2)
      )
    (vector-matrix*! (-> self view-flat) (-> self view-flat) s4-0)
    )
  (let ((gp-1 (new-stack-vector0)))
    0.0
    (vector-! gp-1 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
    (let ((f30-0 (vector-length gp-1)))
      (set! (-> self view-off z) (lerp-clamp
                                   (-> *CAM_BIKE-bank* max-z)
                                   (-> *CAM_BIKE-bank* min-z)
                                   (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f30-0)))
                                   )
            )
      (set! (-> self view-off y) (lerp-clamp
                                   (-> *CAM_BIKE-bank* max-y)
                                   (-> *CAM_BIKE-bank* min-y)
                                   (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f30-0)))
                                   )
            )
      )
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (vector-normalize! (-> self view-flat) (-> self view-off z))
    (vector-! gp-1 (-> self view-flat) (vector-float*! gp-1 (-> *camera* local-down) (-> self view-off y)))
    (vector+! (-> self desired-pos) (-> *camera* tpos-curr-adj) gp-1)
    )
  (let ((v1-19 (new-stack-vector0))
        (gp-2 (new-stack-vector0))
        )
    (vector-! v1-19 (-> self desired-pos) (-> self trans))
    (vector-float*! v1-19 v1-19 0.2)
    (vector-! gp-2 v1-19 (-> self velocity))
    (if (< 409.6 (vector-length gp-2))
        (vector-normalize! gp-2 409.6)
        )
    (vector+! (-> self velocity) (-> self velocity) gp-2)
    )
  (let ((gp-3 (new 'stack-no-clear 'collide-query)))
    0.0
    (let ((f30-1 1.0)
          (s5-3 (-> gp-3 move-dist))
          (s4-3 4)
          )
      (while (and (< 0.01 f30-1)
                  (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (> s4-3 0))
                  )
        (+! s4-3 -1)
        (vector-float*! s5-3 (-> self velocity) f30-1)
        (let ((f28-0
                (cond
                  ((logtest? (-> self options) (cam-slave-options-u32 COLLIDE))
                   (set! (-> gp-3 start-pos quad) (-> self trans quad))
                   (let ((s3-2 gp-3))
                     (set! (-> s3-2 radius) 4096.0)
                     (set! (-> s3-2 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
                     (set! (-> s3-2 ignore-process0) #f)
                     (set! (-> s3-2 ignore-process1) #f)
                     (set! (-> s3-2 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
                     (set! (-> s3-2 action-mask) (collide-action solid))
                     )
                   (fill-and-probe-using-line-sphere *collide-cache* gp-3)
                   )
                  (else
                    -100000000.0
                    )
                  )
                )
              )
          (cond
            ((>= f28-0 0.0)
             (vector+float*! (-> self trans) (-> self trans) s5-3 f28-0)
             (vector-flatten! (-> self velocity) (-> self velocity) (-> gp-3 best-other-tri normal))
             (set! f30-1 (- f30-1 (* f30-1 f28-0)))
             (let ((s3-3 (new-stack-vector0)))
               (vector-! s3-3 (-> self trans) (-> *camera* tpos-curr-adj))
               (vector-flatten! s3-3 s3-3 (-> *camera* local-down))
               (vector-normalize-copy! (-> self view-flat) s3-3 (-> self view-off z))
               )
             )
            (else
              (vector+! (-> self trans) (-> self trans) s5-3)
              (set! f30-1 0.0)
              )
            )
          )
        )
      )
    )
  (cam-calc-bike-follow! (-> self tracking) (-> self trans) #t)
  (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #t)
  (none)
  )

(defstate cam-bike (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set-setting! 'head-offset 'abs (meters 4) 0)
      (set-setting! 'foot-offset 'abs (meters 1) 0)
      (set! (-> self view-off x) 0.0)
      (set! (-> self view-off y) (-> *CAM_BIKE-bank* max-y))
      (set! (-> self view-off z) (-> *CAM_BIKE-bank* max-z))
      (vector-flatten! (-> self view-flat) (-> self tracking inv-mat vector 2) (-> *camera* local-down))
      (vector-negate! (-> self view-flat) (-> self view-flat))
      (vector-normalize! (-> self view-flat) (-> self view-off z))
      (vector--float*! (-> self desired-pos) (-> self view-flat) (-> *camera* local-down) (-> self view-off y))
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
      (set! (-> self trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      (cam-calc-bike-follow! (-> self tracking) (-> self trans) #f)
      (slave-set-rotation! (-> self tracking) (-> self trans) (-> self options) (-> self fov) #f)
      )
    (none)
    )
  :exit (behavior ()
    (remove-setting! 'head-offset)
    (remove-setting! 'foot-offset)
    (none)
    )
  :trans (behavior ()
    (if (not (logtest? (-> *camera* master-options) (cam-master-options-u32 HAVE_TARGET)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (if (not (paused?))
          (cam-bike-code)
          )
      (suspend)
      )
    #f
    (none)
    )
  )
