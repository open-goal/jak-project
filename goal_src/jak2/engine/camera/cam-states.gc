;;-*-Lisp-*-
(in-package goal)

;; name: cam-states.gc
;; name in dgo: cam-states
;; dgos: ENGINE, GAME

;; TODO:
;; og:ignore-form:cam-circular-code
;; og:ignore-form:cam-circular
;; og:ignore-form:cam-bike-code
;; og:ignore-form:cam-stick-code
;; og:ignore-form:cam-string-code
(define-extern cam-string-code (function vector :behavior camera-slave))
;; og:ignore-form:cam-string-line-of-sight
;; og:ignore-form:cam-string-joystick
;; og:ignore-form:cam-circular-code
;; og:ignore-form:cam-circular-position
;; og:ignore-form:cam-los-collide
;; og:ignore-form:cam-stick
;; og:ignore-form:cam-bike

;; DECOMP BEGINS

(defstate cam-really-fixed (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-fixed (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (set! (-> self trans quad) (-> self saved-pt quad))
          (cam-curve-pos (-> self trans) gp-0 (the-as curve #f) #f)
          (when (!= (-> gp-0 w) 0.0)
            (vector-normalize! gp-0 1.0)
            (forward-down->inv-matrix (the-as matrix (-> self tracking)) gp-0 (-> *camera* local-down))
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-fixed-read-entity (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) (-> self trans) 'trans)
       (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
       (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
       (cam-curve-setup (-> self trans))
       ((-> cam-fixed enter))
       )
      (else
        (format #t "ERROR <GMJ>: cam-fixed-read-entity enter without entity~%")
        )
      )
    (go cam-fixed)
    (none)
    )
  :code (behavior ()
    (until #f
      (format *stdcon* "ERROR <GMJ>: stayed in cam-fixed-read-entity~%")
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-pov (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> *camera* settings pov-handle)))
      (set! (-> self blend-from-type) (the-as uint 0))
      (cam-slave-go cam-fixed)
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (vector<-cspace! (-> self trans) (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                                             node-list
                                             data
                                             (-> *camera* settings pov-bone)
                                             )
                         )
        (let* ((v1-6 (-> self tracking))
               (a3-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                         node-list
                         data
                         (-> *camera* settings pov-bone)
                         bone
                         transform
                         )
                     )
               (a0-9 (-> a3-0 vector 0 quad))
               (a1-11 (-> a3-0 vector 1 quad))
               (a2-0 (-> a3-0 vector 2 quad))
               (a3-1 (-> a3-0 trans quad))
               )
          (set! (-> v1-6 inv-mat vector 0 quad) a0-9)
          (set! (-> v1-6 inv-mat vector 1 quad) a1-11)
          (set! (-> v1-6 inv-mat vector 2 quad) a2-0)
          (set! (-> v1-6 inv-mat trans quad) a3-1)
          )
        (vector-reset! (-> self tracking inv-mat trans))
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (vector-matrix*! gp-0 (-> *camera* settings pov-offset) (the-as matrix (-> self tracking)))
          (vector+! (-> self trans) (-> self trans) gp-0)
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-pov180 (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    (none)
    )
  :trans (behavior ()
    (when (not (handle->process (-> *camera* settings pov-handle)))
      (set! (-> self blend-from-type) (the-as uint 0))
      (cam-slave-go cam-fixed)
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'vector))
          (s5-0 (new 'stack-no-clear 'vector))
          (s4-0 #t)
          )
      (vector<-cspace! gp-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                                node-list
                                data
                                (-> *camera* settings pov-bone)
                                )
                       )
      (let ((v1-13 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                       node-list
                       data
                       (-> *camera* settings pov-bone)
                       bone
                       transform
                       )
                   )
            )
        (vector-normalize-copy! s5-0 (-> v1-13 vector 2) 1.0)
        )
      (until #f
        (when (not (paused?))
          (let ((s0-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                          node-list
                          data
                          (-> *camera* settings pov-bone)
                          bone
                          transform
                          )
                      )
                (s1-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                          node-list
                          data
                          (-> *camera* settings pov-bone)
                          bone
                          scale
                          )
                      )
                (s3-0 (new 'stack-no-clear 'vector))
                )
            (let ((s2-0 (new 'stack-no-clear 'vector)))
              (vector<-cspace!
                s2-0
                (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                    node-list
                    data
                    (-> *camera* settings pov-bone)
                    )
                )
              (vector-normalize-copy! s3-0 (-> s0-0 vector 2) 1.0)
              (set! s4-0
                    (cond
                      ((and (< (vector-vector-distance s2-0 gp-0) 40960.0) (< (cos 3640.889) (vector-dot s5-0 s3-0)))
                       (set! (-> self trans quad) (-> s2-0 quad))
                       (vector-negate! (the-as vector (-> self tracking)) (the-as vector (-> s0-0 vector)))
                       (set! (-> (the-as vector (&-> self stack 96)) quad) (-> s0-0 vector 1 quad))
                       (vector-negate! (the-as vector (&-> self stack 112)) (-> s0-0 vector 2))
                       (set! (-> self fov) (* 2.0 (atan (/ 12.700255 (* 20.3 (-> s1-0 x))) 1.0)))
                       (vector-float*! (the-as vector (-> self tracking)) (the-as vector (-> self tracking)) (/ 1.0 (-> s1-0 x)))
                       (vector-reset! (-> self tracking inv-mat trans))
                       (if s4-0
                           (set! s4-0 #f)
                           )
                       s4-0
                       )
                      (else
                        #t
                        )
                      )
                    )
              (set! (-> gp-0 quad) (-> s2-0 quad))
              )
            (set! (-> s5-0 quad) (-> s3-0 quad))
            )
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defstate cam-pov-track (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :trans (behavior ()
    (if (or (not (handle->process (-> *camera* settings pov-handle))) (zero? (logand (-> *camera* master-options) 1)))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (set! (-> self fov) (-> *camera* settings fov))
        (vector<-cspace! (-> self trans) (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                                             node-list
                                             data
                                             (-> *camera* settings pov-bone)
                                             )
                         )
        (let ((gp-0 (new 'stack-no-clear 'vector)))
          (let ((a2-0 (new 'stack-no-clear 'matrix)))
            (let* ((v1-8 a2-0)
                   (t0-0 (-> (the-as pov-camera (-> *camera* settings pov-handle process 0))
                             node-list
                             data
                             (-> *camera* settings pov-bone)
                             bone
                             transform
                             )
                         )
                   (a0-9 (-> t0-0 vector 0 quad))
                   (a1-11 (-> t0-0 vector 1 quad))
                   (a3-0 (-> t0-0 vector 2 quad))
                   (t0-1 (-> t0-0 trans quad))
                   )
              (set! (-> v1-8 vector 0 quad) a0-9)
              (set! (-> v1-8 vector 1 quad) a1-11)
              (set! (-> v1-8 vector 2 quad) a3-0)
              (set! (-> v1-8 trans quad) t0-1)
              )
            (vector-reset! (-> a2-0 trans))
            (vector-matrix*! gp-0 (-> *camera* settings pov-offset) a2-0)
            )
          (vector+! (-> self trans) (-> self trans) gp-0)
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defbehavior cam-standoff-calc-trans camera-slave ()
  (if (-> self tracking no-follow)
      (vector+! (-> self trans) (-> *camera* tpos-curr-adj) (-> self pivot-pt))
      (vector+! (-> self trans) (-> self tracking follow-pt) (-> self pivot-pt))
      )
  )

(defstate cam-standoff (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (cond
                       ((= v1-0 'set-standoff-dist)
                        (vector-normalize! (-> self pivot-pt) (the-as float (-> arg3 param 0)))
                        (cam-standoff-calc-trans)
                        )
                       ((= v1-0 'set-standoff-height)
                        (vector-flatten! (-> self pivot-pt) (-> self pivot-pt) (-> *camera* local-down))
                        (vector--float*!
                          (-> self pivot-pt)
                          (-> self pivot-pt)
                          (-> *camera* local-down)
                          (the-as float (-> arg3 param 0))
                          )
                        (cam-standoff-calc-trans)
                        )
                       (else
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
                       )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (vector-! (-> self pivot-pt) (-> self trans) (-> *camera* tpos-curr-adj))
      (cond
        ((logtest? (-> self options) #x4000)
         (set! (-> self blend-from-type) (the-as uint 0))
         (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
         0
         )
        (else
          (set! (-> self blend-from-type) (the-as uint 2))
          (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
          )
        )
      )
    (cam-calc-follow! (-> self tracking) (-> self trans) #f)
    (none)
    )
  :trans (behavior ()
    (if (zero? (logand (-> *camera* master-options) 1))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (cam-calc-follow! (-> self tracking) (-> self trans) #t)
        (cam-standoff-calc-trans)
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-standoff-read-entity (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (let ((gp-0 (new-stack-vector0))
             (s5-0 (new-stack-vector0))
             )
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) s5-0 'align)
         (vector-! (-> self pivot-pt) gp-0 s5-0)
         )
       (vector+! (-> self trans) (-> *camera* tpos-curr-adj) (-> self pivot-pt))
       (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
       (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
       (if (logtest? (-> self options) #x4000)
           (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
           (set! (-> self tracking tilt-adjust target)
                 (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                 )
           )
       ((-> cam-standoff enter))
       )
      (else
        (format #t "ERROR <GMJ>: cam-standoff-read-entity enter without entity~%")
        )
      )
    (go cam-standoff)
    (none)
    )
  :code (behavior ()
    (until #f
      (format *stdcon* "ERROR <GMJ>: stayed in cam-standoff-read-entity~%")
      (suspend)
      )
    #f
    (none)
    )
  )

(deftype cam-eye-bank (basic)
  ((rot-speed   float  :offset-assert   4)
   (max-degrees float  :offset-assert   8)
   (max-fov     float  :offset-assert  12)
   (min-fov     float  :offset-assert  16)
   )
  :method-count-assert 9
  :size-assert         #x14
  :flag-assert         #x900000014
  )


(define *CAM_EYE-bank*
  (new 'static 'cam-eye-bank :rot-speed 364.0889 :max-degrees 12743.111 :max-fov 11650.845 :min-fov 6189.511)
  )

(defstate cam-eye (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (let ((v1-3
              (vector-float*! (new-stack-vector0) (-> *camera* local-down) (+ 1024.0 (-> *camera* settings target-height)))
              )
            )
        (vector-! (-> self trans) (-> *camera* tpos-curr) v1-3)
        )
      (set! (-> self blend-from-type) (the-as uint 0))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
      0
      )
    (set! (-> self fov) 11650.845)
    (none)
    )
  :exit (behavior ()
    (if (and *target*
             (logtest? (-> *camera* master-options) 1)
             (logtest? (-> *target* focus-status) (focus-status in-head))
             )
        (send-event *target* 'end-mode)
        )
    (none)
    )
  :trans (behavior ()
    (if (zero? (logand (-> *camera* master-options) 1))
        (go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (-> self clock frame-counter)))
      (until #f
        (when (not (paused?))
          (let ((s4-0 (vector-reset! (new-stack-vector0)))
                (s5-0 (new-stack-matrix0))
                )
            (when (zero? (logand (-> *camera* settings master-options) (cam-master-options IGNORE_ANALOG)))
              (let ((f30-0 (analog-input
                             (the-as int (+ (-> *cpad-list* cpads 0 rightx) -256 (-> *cpad-list* cpads 0 leftx)))
                             0.0
                             48.0
                             110.0
                             -1.0
                             )
                           )
                    (f0-0 (analog-input
                            (the-as int (+ (-> *cpad-list* cpads 0 righty) -256 (-> *cpad-list* cpads 0 lefty)))
                            0.0
                            48.0
                            110.0
                            -1.0
                            )
                          )
                    )
                (set! (-> s4-0 y) (- (-> s4-0 y) (* (- f30-0) (-> *CAM_EYE-bank* rot-speed))))
                (set! (-> s4-0 x) (- (-> s4-0 x) (* (- f0-0) (-> *CAM_EYE-bank* rot-speed))))
                )
              )
            (cond
              ((< (-> *CAM_EYE-bank* rot-speed) (-> s4-0 x))
               (set! (-> s4-0 x) (-> *CAM_EYE-bank* rot-speed))
               )
              ((< (-> s4-0 x) (- (-> *CAM_EYE-bank* rot-speed)))
               (set! (-> s4-0 x) (- (-> *CAM_EYE-bank* rot-speed)))
               )
              )
            (cond
              ((< (-> *CAM_EYE-bank* rot-speed) (-> s4-0 y))
               (set! (-> s4-0 y) (-> *CAM_EYE-bank* rot-speed))
               )
              ((< (-> s4-0 y) (- (-> *CAM_EYE-bank* rot-speed)))
               (set! (-> s4-0 y) (- (-> *CAM_EYE-bank* rot-speed)))
               )
              )
            (cond
              ((and (= (-> s4-0 x) 0.0) (= (-> s4-0 y) 0.0))
               (set! gp-0 (-> self clock frame-counter))
               )
              (else
                (let ((v1-39 (min 10 (max 1 (- (-> self clock frame-counter) gp-0)))))
                  (vector-float*! s4-0 s4-0 (* 0.1 (the float v1-39)))
                  )
                )
              )
            (matrix-axis-angle! s5-0 (-> *camera* local-down) (-> s4-0 y))
            (matrix*! (the-as matrix (-> self tracking)) (the-as matrix (-> self tracking)) s5-0)
            (when (zero? (logand (-> self options) 8))
              (if (< (vector-dot (the-as vector (&-> self stack 96)) (-> *camera* local-down)) 0.0)
                  (forward-down->inv-matrix
                    (the-as matrix (-> self tracking))
                    (the-as vector (&-> self stack 112))
                    (-> *camera* local-down)
                    )
                  (forward-down->inv-matrix
                    (the-as matrix (-> self tracking))
                    (the-as vector (&-> self stack 112))
                    (vector-negate! (new-stack-vector0) (-> *camera* local-down))
                    )
                  )
              )
            (matrix-axis-angle! s5-0 (the-as vector (-> self tracking)) (- (-> s4-0 x)))
            (matrix*! (the-as matrix (-> self tracking)) (the-as matrix (-> self tracking)) s5-0)
            )
          (when (zero? (logand (-> self options) 8))
            (let ((f30-1 (vector-dot (-> *camera* local-down) (the-as vector (&-> self stack 112)))))
              (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
              (when (< (sin (-> *CAM_EYE-bank* max-degrees)) (fabs f30-1))
                (vector--float*!
                  (the-as vector (&-> self stack 112))
                  (the-as vector (&-> self stack 112))
                  (-> *camera* local-down)
                  f30-1
                  )
                (vector-normalize! (the-as vector (&-> self stack 112)) (cos (-> *CAM_EYE-bank* max-degrees)))
                (if (< f30-1 0.0)
                    (vector--float*!
                      (the-as vector (&-> self stack 112))
                      (the-as vector (&-> self stack 112))
                      (-> *camera* local-down)
                      (sin (-> *CAM_EYE-bank* max-degrees))
                      )
                    (vector+float*!
                      (the-as vector (&-> self stack 112))
                      (the-as vector (&-> self stack 112))
                      (-> *camera* local-down)
                      (sin (-> *CAM_EYE-bank* max-degrees))
                      )
                    )
                (vector-cross!
                  (the-as vector (&-> self stack 96))
                  (the-as vector (&-> self stack 112))
                  (the-as vector (-> self tracking))
                  )
                (set! (-> self tracking inv-mat vector 1 w) 0.0)
                )
              )
            )
          )
        (let ((v1-70
                (vector-float*! (new-stack-vector0) (-> *camera* local-down) (+ 1024.0 (-> *camera* settings target-height)))
                )
              )
          (vector-! (-> self trans) (-> *camera* tpos-curr) v1-70)
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )

(defstate cam-spline (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (cond
      ((-> self enter-has-run)
       )
      ((-> self cam-entity)
       (let ((gp-0 (new-stack-vector0)))
         (set! (-> self fov) (cam-slave-get-fov (-> self cam-entity)))
         (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
         (if (logtest? (-> self options) #x4000)
             (cam-slave-get-rot (the-as entity-actor (-> self cam-entity)) (the-as matrix (-> self tracking)))
             (set! (-> self tracking tilt-adjust target)
                   (cam-slave-get-float (-> self cam-entity) 'tiltAdjust (-> *CAMERA-bank* default-tilt-adjust))
                   )
             )
         (cam-slave-get-vector-with-offset (the-as entity-actor (-> self cam-entity)) gp-0 'trans)
         (cam-curve-setup gp-0)
         )
       (vector-negate! (-> self saved-pt) (-> self spline-offset))
       (let ((a0-8 (res-lump-struct (-> self cam-entity) 'spline-offset structure)))
         (if a0-8
             (vector+! (-> self spline-offset) (-> self spline-offset) (the-as vector a0-8))
             )
         )
       (set! (-> self trans quad) (-> self saved-pt quad))
       (cam-calc-follow! (-> self tracking) (-> self trans) #f)
       (set! (-> self spline-follow-dist) (cam-slave-get-float (-> self cam-entity) 'spline-follow-dist 0.0))
       (cond
         ((< 0.0 (-> self spline-follow-dist))
          (let ((s5-1 (new 'stack-no-clear 'vector))
                (gp-1 (new 'stack-no-clear 'vector))
                )
            (curve-get-pos! s5-1 0.0 (-> self spline-curve))
            (curve-get-pos! gp-1 1.0 (-> self spline-curve))
            (if (< (vector-vector-distance-squared s5-1 (-> self tracking follow-pt))
                   (vector-vector-distance-squared gp-1 (-> self tracking follow-pt))
                   )
                (set! (-> self spline-follow-dist) (- (-> self spline-follow-dist)))
                )
            )
          (set! (-> self spline-tt) (curve-closest-point
                                      (-> self spline-curve)
                                      (-> self tracking follow-pt)
                                      0.5
                                      -4096.0
                                      10
                                      (-> self spline-follow-dist)
                                      )
                )
          )
         (else
           (set! (-> self spline-follow-dist) 0.0)
           )
         )
       (cam-curve-pos (-> self trans) (the-as vector #f) (the-as curve #f) #t)
       (cond
         ((logtest? (-> self options) #x4000)
          (set! (-> self blend-from-type) (the-as uint 0))
          (set! (-> self blend-to-type) (camera-blend-to-type unknown-0))
          0
          )
         (else
           (set! (-> self blend-from-type) (the-as uint 2))
           (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
           )
         )
       )
      (else
        (format #t "ERROR <GMJ>: cam-spline enter without entity~%")
        )
      )
    (none)
    )
  :trans (behavior ()
    (if (zero? (logand (-> *camera* master-options) 1))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (cam-calc-follow! (-> self tracking) (-> self trans) #t)
        (new 'stack 'curve)
        (set! (-> self trans quad) (-> self saved-pt quad))
        (cam-curve-pos (-> self trans) (the-as vector #f) (the-as curve #f) #t)
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-decel (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self saved-pt quad) (-> self trans quad))
      (set! (-> self blend-from-type) (the-as uint 1))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-1))
      )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (let ((s5-0 (new-stack-vector0))
              (gp-0 (new-stack-vector0))
              )
          (when (!= (-> *camera* outro-t-step) 0.0)
            (curve-get-pos! s5-0 (parameter-ease-sin-clamp (-> *camera* outro-t)) (-> *camera* outro-curve))
            (+! (-> *camera* outro-t) (* (-> *camera* outro-t-step) (-> self clock time-adjust-ratio)))
            (curve-get-pos! gp-0 (parameter-ease-sin-clamp (-> *camera* outro-t)) (-> *camera* outro-curve))
            (vector-! gp-0 gp-0 s5-0)
            (cond
              ((or (and (< (-> *camera* outro-t-step) 0.0) (>= (-> *camera* outro-exit-value) (-> *camera* outro-t)))
                   (and (< 0.0 (-> *camera* outro-t-step)) (>= (-> *camera* outro-t) (-> *camera* outro-exit-value)))
                   )
               (set! (-> *camera* outro-t) (-> *camera* outro-exit-value))
               (set! (-> *camera* outro-t-step) 0.0)
               (vector+! (-> self velocity) (-> self velocity) gp-0)
               (send-event *camera* 'outro-done)
               )
              (else
                (vector+! (-> self trans) (-> self trans) gp-0)
                )
              )
            )
          )
        (vector-float*! (-> self velocity) (-> self velocity) 0.9)
        (vector+! (-> self trans) (-> self trans) (-> self velocity))
        )
      (suspend)
      )
    #f
    (none)
    )
  )

(defstate cam-endlessfall (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (let ((v1-0 arg2))
      (the-as object (if (= v1-0 'teleport)
                         #f
                         (cam-standard-event-handler arg0 arg1 arg2 arg3)
                         )
              )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :code (behavior ()
    (let ((gp-0 (new 'stack-no-clear 'cam-vector-seeker))
          (f30-0 (-> self velocity y))
          )
      (let ((a1-0 (new 'stack-no-clear 'vector))
            (s5-0 (new 'stack-no-clear 'vector))
            )
        (set! (-> a1-0 quad) (-> self trans quad))
        (set! (-> a1-0 y) 0.0)
        (set! (-> s5-0 quad) (-> self velocity quad))
        (set! (-> s5-0 y) 0.0)
        (init gp-0 a1-0 81.92 (fmax 819.2 (vector-length s5-0)) 0.75)
        (set! (-> gp-0 vel quad) (-> s5-0 quad))
        )
      (until #f
        (when (not (paused?))
          (set! (-> gp-0 target x) (-> (target-pos 0) x))
          (set! (-> gp-0 target z) (-> (target-pos 0) z))
          (update! gp-0 (the-as vector #f))
          (when (< 819.2 (-> gp-0 max-vel))
            (set! (-> gp-0 max-vel) (* 0.9 (-> gp-0 max-vel)))
            (if (< (-> gp-0 max-vel) 819.2)
                (set! (-> gp-0 max-vel) 819.2)
                )
            )
          (set! f30-0 (* 0.9 f30-0))
          (+! (-> self trans y) f30-0)
          (set! (-> self trans x) (-> gp-0 value x))
          (set! (-> self trans z) (-> gp-0 value z))
          )
        (suspend)
        )
      )
    #f
    (none)
    )
  )


;; ERROR: function has no type analysis. Cannot decompile.

;; ERROR: failed type prop at 56: Called a function, but we do not know its type
;; WARN: Return type mismatch none vs float.


(defstate cam-lookat (camera-slave)
  :event (the-as
    (function process int symbol event-message-block object :behavior camera-slave)
    cam-standard-event-handler
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :trans (behavior ()
    (if (zero? (logand (-> *camera* master-options) 1))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  )

(deftype cam-string-bank (basic)
  ((los-coll-rad  meters  :offset-assert   4)
   (los-coll-rad2 meters  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(define *CAM_STRING-bank* (new 'static 'cam-string-bank :los-coll-rad (meters 1) :los-coll-rad2 (meters 0.5)))

;; WARN: new jak 2 until loop case, check carefully
(defun cam-string-find-position-rel! ((arg0 vector))
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'collide-query))
        (f30-0 0.0)
        (s2-0 (new 'stack-no-clear 'matrix))
        )
    (let ((s1-0 s3-0))
      (set! (-> s1-0 radius) 409.6)
      (set! (-> s1-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
      (set! (-> s1-0 ignore-process0) #f)
      (set! (-> s1-0 ignore-process1) #f)
      (set! (-> s1-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
      (set! (-> s1-0 action-mask) (collide-action solid))
      )
    (vector-flatten! s5-0 (-> *camera-combiner* inv-camera-rot vector 2) (-> *camera* local-down))
    (if (= (vector-normalize-ret-len! s5-0 (- (+ 1024.0 (-> *CAMERA-bank* default-string-min-z)))) 0.0)
        (set! (-> s5-0 z) (+ 1024.0 (-> *CAMERA-bank* default-string-min-z)))
        )
    (vector--float*! s5-0 s5-0 (-> *camera* local-down) (-> *CAMERA-bank* default-string-min-y))
    (set! (-> arg0 quad) (-> s5-0 quad))
    (until #f
      (vector--float*! s4-0 arg0 (-> *camera* local-down) (-> *camera* settings target-height))
      (set! (-> s3-0 start-pos quad) (-> *camera* tpos-curr-adj quad))
      (set! (-> s3-0 move-dist quad) (-> arg0 quad))
      (if (< (fill-and-probe-using-line-sphere *collide-cache* s3-0) 0.0)
          (return #t)
          )
      (set! f30-0 (cond
                    ((>= -32768.0 f30-0)
                     (format #t "cam-string didn't find a spot~%")
                     (set! (-> arg0 quad) (-> s5-0 quad))
                     (return #f)
                     f30-0
                     )
                    ((< 0.0 f30-0)
                     (- f30-0)
                     )
                    (else
                      (- 5461.3335 f30-0)
                      )
                    )
            )
      (matrix-axis-angle! s2-0 (-> *camera* local-down) f30-0)
      (vector-matrix*! arg0 s5-0 s2-0)
      )
    )
  #f
  )

;; WARN: Return type mismatch uint vs cam-slave-options.
(defbehavior cam-string-set-position-rel! camera-slave ((arg0 vector))
  (vector-flatten! (-> self view-flat) arg0 (-> *camera* local-down))
  (set! (-> self min-z-override) (vector-length (-> self view-flat)))
  (vector+! (-> self desired-pos) arg0 (-> *camera* tpos-curr-adj))
  (set! (-> self string-trans quad) (-> self desired-pos quad))
  (tracking-spline-method-10 (-> self position-spline) (-> self desired-pos))
  (vector-reset! (-> self velocity))
  (let ((v0-2 (logand -4097 (-> self options))))
    (set! (-> self options) v0-2)
    (the-as cam-slave-options v0-2)
    )
  )

(defun string-push-help ()
  409.6
  )

;; WARN: Return type mismatch int vs none.
(defun-debug cam-draw-collide-cache ((arg0 collide-cache))
  (let ((gp-0 (the-as object (-> arg0 tris))))
    (countdown (s5-0 (-> arg0 num-tris))
      (let ((t1-0 #x40000080))
        (add-debug-flat-triangle
          #t
          (bucket-id debug-no-zbuf1)
          (the-as vector (-> (the-as (inline-array collide-cache-tri) gp-0) 0))
          (-> (the-as (inline-array collide-cache-tri) gp-0) 0 vertex 1)
          (-> (the-as (inline-array collide-cache-tri) gp-0) 0 vertex 2)
          (the-as rgba t1-0)
          )
        )
      (set! gp-0 (-> (the-as (inline-array collide-cache-tri) gp-0) 1))
      )
    )
  0
  (none)
  )

(deftype los-dist (structure)
  ((par-dist  float  :offset-assert   0)
   (lat-dist  float  :offset-assert   4)
   (vert-dist float  :offset-assert   8)
   )
  :method-count-assert 9
  :size-assert         #xc
  :flag-assert         #x90000000c
  )


(deftype collide-los-dist-info (structure)
  ((min-par float  :offset-assert   0)
   (max-par float  :offset-assert   4)
   (min-lat float  :offset-assert   8)
   (max-lat float  :offset-assert  12)
   (min-vp  float  :offset-assert  16)
   (max-vp  float  :offset-assert  20)
   (min-vn  float  :offset-assert  24)
   (max-vn  float  :offset-assert  28)
   (count   int32  :offset-assert  32)
   )
  :method-count-assert 9
  :size-assert         #x24
  :flag-assert         #x900000024
  )


;; WARN: Return type mismatch int vs none.
(defun dist-info-init ((arg0 collide-los-dist-info))
  (set! (-> arg0 min-par) 1.0)
  (set! (-> arg0 max-par) 0.0)
  (set! (-> arg0 count) 0)
  0
  (none)
  )

(defun dist-info-valid? ((arg0 collide-los-dist-info))
  (>= (-> arg0 max-par) (-> arg0 min-par))
  )

;; WARN: Return type mismatch int vs none.
(defun dist-info-append ((arg0 collide-los-dist-info) (arg1 vector))
  (cond
    ((dist-info-valid? arg0)
     (if (< (-> arg1 x) (-> arg0 min-par))
         (set! (-> arg0 min-par) (-> arg1 x))
         )
     (if (< (-> arg0 max-par) (-> arg1 x))
         (set! (-> arg0 max-par) (-> arg1 x))
         )
     (if (< (-> arg1 y) (-> arg0 min-lat))
         (set! (-> arg0 min-lat) (-> arg1 y))
         )
     (if (< (-> arg0 max-lat) (-> arg1 y))
         (set! (-> arg0 max-lat) (-> arg1 y))
         )
     (cond
       ((< (-> arg1 y) 0.0)
        (if (< (-> arg1 z) (-> arg0 min-vn))
            (set! (-> arg0 min-vn) (-> arg1 z))
            )
        (if (< (-> arg0 max-vn) (-> arg1 z))
            (set! (-> arg0 max-vn) (-> arg1 z))
            )
        )
       (else
         (if (< (-> arg1 z) (-> arg0 min-vp))
             (set! (-> arg0 min-vp) (-> arg1 z))
             )
         (if (< (-> arg0 max-vp) (-> arg1 z))
             (set! (-> arg0 max-vp) (-> arg1 z))
             )
         )
       )
     )
    (else
      (set! (-> arg0 min-par) (-> arg1 x))
      (set! (-> arg0 max-par) (-> arg1 x))
      (set! (-> arg0 min-lat) (-> arg1 y))
      (set! (-> arg0 max-lat) (-> arg1 y))
      (set! (-> arg0 min-vp) 0.0)
      (set! (-> arg0 max-vp) 0.0)
      (set! (-> arg0 min-vn) 0.0)
      (set! (-> arg0 max-vn) 0.0)
      (cond
        ((< (-> arg1 y) 0.0)
         (set! (-> arg0 min-vn) (-> arg1 z))
         (set! (-> arg0 max-vn) (-> arg1 z))
         )
        (else
          (set! (-> arg0 min-vp) (-> arg1 z))
          (set! (-> arg0 max-vp) (-> arg1 z))
          )
        )
      )
    )
  (+! (-> arg0 count) 1)
  (none)
  )

(defun dist-info-print ((arg0 collide-los-dist-info) (arg1 string))
  (cond
    ((dist-info-valid? arg0)
     (format
       *stdcon*
       "~S ~2,D mn ~,,2M mx ~,,2M mnl ~,,2M mxl ~,,2M~%"
       arg1
       (-> arg0 count)
       (-> arg0 min-par)
       (-> arg0 max-par)
       (-> arg0 min-lat)
       (-> arg0 max-lat)
       )
     (format
       *stdcon*
       "   mnvp ~,,2M mxvp ~,,2M mnvn ~,,2M mxvn ~,,2M~%"
       (-> arg0 min-vp)
       (-> arg0 max-vp)
       (-> arg0 min-vn)
       (-> arg0 max-vn)
       )
     )
    (else
      (format *stdcon* "~S invalid~%" arg1)
      )
    )
  )

(deftype collide-los-result (structure)
  ((lateral       vector                :inline :offset-assert   0)
   (cw            collide-los-dist-info :inline :offset-assert  16)
   (ccw           collide-los-dist-info :inline :offset-assert  64)
   (straddle      collide-los-dist-info :inline :offset-assert 112)
   (lateral-valid symbol                        :offset-assert 148)
   )
  :method-count-assert 9
  :size-assert         #x98
  :flag-assert         #x900000098
  )


;; WARN: Stack slot offset 128 signed mismatch
;; WARN: Stack slot offset 128 signed mismatch
;; WARN: Stack slot offset 128 signed mismatch
;; WARN: Stack slot offset 128 signed mismatch
;; WARN: Stack slot offset 128 signed mismatch
;; WARN: Stack slot offset 128 signed mismatch
;; WARN: Stack slot offset 128 signed mismatch
(defun los-cw-ccw ((arg0 (inline-array collide-cache-tri))
          (arg1 vector)
          (arg2 vector)
          (arg3 float)
          (arg4 collide-los-result)
          (arg5 vector)
          (arg6 float)
          )
  (local-vars (sv-128 float) (sv-144 vector) (sv-160 vector) (sv-176 vector) (sv-192 vector) (sv-208 int))
  (with-pp
    (set! sv-128 arg3)
    (let ((gp-0 arg4))
      (set! sv-144 arg5)
      (let ((s4-0 arg6))
        (set! sv-160 (new 'stack-no-clear 'vector))
        (set! sv-176 (new 'stack-no-clear 'vector))
        (let ((s5-0 (new 'stack-no-clear 'matrix)))
          (set! sv-192 (new 'stack-no-clear 'vector))
          (let ((f30-0 0.0)
                (s0-0 #f)
                )
            (set! sv-208 0)
            (while (< sv-208 4)
              (cond
                ((= sv-208 3)
                 (vector-! sv-160 sv-144 (the-as vector (&-> pp stack 432)))
                 (set! (-> s5-0 vector sv-208 z) 0.0)
                 )
                (else
                  (vector-! sv-160 sv-144 (-> arg0 0 vertex sv-208))
                  (set! (-> s5-0 vector sv-208 z) (vector-dot sv-160 (-> *camera* local-down)))
                  (vector-! sv-160 (-> arg0 0 vertex sv-208) (the-as vector (&-> pp stack 432)))
                  )
                )
              (vector-flatten! sv-160 sv-160 (-> *camera* local-down))
              (vector-cross! sv-176 sv-160 arg2)
              (let ((f28-0 (vector-dot sv-176 (-> *camera* local-down))))
                (cond
                  ((< (* f28-0 f30-0) 0.0)
                   (set! s0-0 #t)
                   )
                  ((!= f28-0 0.0)
                   (set! f30-0 f28-0)
                   )
                  )
                (set! (-> s5-0 vector sv-208 x) (vector-dot sv-160 arg2))
                (cond
                  ((= sv-208 3)
                   (vector-! sv-192 sv-144 (the-as vector (&-> pp stack 432)))
                   (vector-flatten! sv-192 sv-192 arg1)
                   )
                  (else
                    (vector--float*! sv-192 sv-160 arg2 (-> s5-0 vector sv-208 x))
                    )
                  )
                (if (< f28-0 0.0)
                    (set! (-> s5-0 vector sv-208 y) (- (vector-length sv-192)))
                    (set! (-> s5-0 vector sv-208 y) (vector-length sv-192))
                    )
                )
              (set! (-> s5-0 vector sv-208 x) (- sv-128 (-> s5-0 vector sv-208 x)))
              (set! sv-208 (+ sv-208 1))
              )
            (cond
              ((and s0-0 (!= s4-0 -859915232))
               (dotimes (s4-1 4)
                 (dist-info-append (-> gp-0 straddle) (the-as vector (+ (the-as uint s5-0) (* s4-1 16))))
                 )
               #f
               )
              ((< (-> s5-0 trans y) 0.0)
               (dotimes (s4-2 4)
                 (when (>= (-> s5-0 trans y) (-> s5-0 vector s4-2 y))
                   (set! (-> s5-0 vector s4-2 y) (- (-> s5-0 vector s4-2 y)))
                   (dist-info-append (-> gp-0 ccw) (the-as vector (+ (the-as uint s5-0) (* s4-2 16))))
                   )
                 )
               #f
               )
              (else
                (dotimes (s4-3 4)
                  (if (>= (-> s5-0 vector s4-3 y) (-> s5-0 trans y))
                      (dist-info-append (-> gp-0 cw) (the-as vector (+ (the-as uint s5-0) (* s4-3 16))))
                      )
                  )
                #f
                )
              )
            )
          )
        )
      )
    )
  )

(defun cam-los-spline-collide ((arg0 vector) (arg1 vector) (arg2 pat-surface))
  (let ((s5-0 (new 'stack-no-clear 'collide-query))
        (s4-0 *collide-cache*)
        (f30-0 2.0)
        )
    0.0
    (set! (-> s5-0 start-pos quad) (-> arg0 quad))
    (vector-! (-> s5-0 move-dist) arg1 arg0)
    (let ((v1-4 s5-0))
      (set! (-> v1-4 radius) (-> *CAM_STRING-bank* los-coll-rad2))
      (set! (-> v1-4 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
      (set! (-> v1-4 ignore-process0) #f)
      (set! (-> v1-4 ignore-process1) #f)
      (set! (-> v1-4 ignore-pat) arg2)
      (set! (-> v1-4 action-mask) (collide-action solid))
      )
    (fill-using-line-sphere s4-0 s5-0)
    (let* ((f0-2 (vector-length (-> s5-0 move-dist)))
           (f28-0
             (cond
               ((< f0-2 (-> *CAMERA-bank* min-detectable-velocity))
                0.0
                )
               (else
                 (let* ((f0-3 (/ (* 3.0 (- (-> *CAM_STRING-bank* los-coll-rad2) (-> *CAMERA-bank* collide-move-rad))) f0-2))
                        (f0-4 (- 1.0 f0-3))
                        )
                   (fmin 1.0 (fmax 0.0 f0-4))
                   )
                 )
               )
             )
           (s3-0 (the-as object (-> s4-0 tris)))
           (s2-0 (new 'stack-no-clear 'vector))
           (s1-0 (new 'stack-no-clear 'vector))
           )
      (countdown (s4-1 (-> s4-0 num-tris))
        (let ((f0-7 (moving-sphere-triangle-intersect
                      arg0
                      (-> s5-0 move-dist)
                      (-> *CAM_STRING-bank* los-coll-rad2)
                      (-> (the-as (inline-array collide-cache-tri) s3-0) 0)
                      s2-0
                      s1-0
                      )
                    )
              )
          (cond
            ((or (< f0-7 0.0) (< f28-0 f0-7))
             )
            ((< f0-7 f30-0)
             (set! f30-0 f0-7)
             )
            )
          )
        (set! s3-0 (-> (the-as (inline-array collide-cache-tri) s3-0) 1))
        )
      )
    (if (= f30-0 #x40000000)
        (set! f30-0 -1.0)
        )
    f30-0
    )
  )

(defbehavior cam-los-setup-lateral camera-slave ((arg0 collide-los-result) (arg1 vector) (arg2 vector))
  (cond
    ((dist-info-valid? (-> arg0 straddle))
     (let ((f30-0 (-> arg0 straddle min-lat))
           (f28-0 (-> arg0 straddle max-lat))
           )
       (if (dist-info-valid? (-> arg0 cw))
           (set! f28-0 (fmax f28-0 (-> arg0 cw max-lat)))
           )
       (if (dist-info-valid? (-> arg0 ccw))
           (set! f30-0 (fmin f30-0 (- (-> arg0 ccw max-lat))))
           )
       (cond
         ((= (-> self los-state) (slave-los-state ccw))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle stick ccw~%")
              )
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((= (-> self los-state) (slave-los-state cw))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle stick cw~%")
              )
          (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((and (or (< 0.01 (-> arg0 straddle max-vp)) (and (dist-info-valid? (-> arg0 ccw)) (< 0.01 (-> arg0 ccw max-vp))))
               (or (< (-> arg0 straddle min-vp) -0.01) (and (dist-info-valid? (-> arg0 ccw)) (< (-> arg0 ccw min-vp) -0.01)))
               (and (dist-info-valid? (-> arg0 cw)) (or (< (-> arg0 cw max-vp) 0.01) (< -0.01 (-> arg0 cw min-vp))))
               )
          (when (not (dist-info-valid? (-> arg0 ccw)))
            )
          (if (not (dist-info-valid? (-> arg0 cw)))
              (format #t "s diag ccw invalid cw~%")
              )
          (if *display-cam-los-debug*
              (format *stdcon* "straddle diagonal ccw~%")
              )
          (set! (-> self los-state) (slave-los-state ccw))
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((and (or (< 0.01 (-> arg0 straddle max-vn)) (and (dist-info-valid? (-> arg0 cw)) (< 0.01 (-> arg0 cw max-vp))))
               (or (< (-> arg0 straddle min-vn) -0.01) (and (dist-info-valid? (-> arg0 cw)) (< (-> arg0 cw min-vp) -0.01)))
               (and (dist-info-valid? (-> arg0 ccw)) (or (< (-> arg0 ccw max-vp) 0.01) (< -0.01 (-> arg0 ccw min-vp))))
               )
          (if (not (dist-info-valid? (-> arg0 ccw)))
              (format #t "s diag cw invalid ccw~%")
              )
          (when (not (dist-info-valid? (-> arg0 cw)))
            )
          (if *display-cam-los-debug*
              (format *stdcon* "straddle diagonal cw~%")
              )
          (set! (-> self los-state) (slave-los-state cw))
          (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         ((< f28-0 (- f30-0))
          (if *display-cam-los-debug*
              (format *stdcon* "straddle ccw~%")
              )
          (set! (-> self los-state) (slave-los-state ccw))
          (vector-normalize! arg1 (+ f28-0 (-> *CAM_STRING-bank* los-coll-rad)))
          )
         (else
           (if *display-cam-los-debug*
               (format *stdcon* "straddle cw~%")
               )
           (set! (-> self los-state) (slave-los-state cw))
           (vector-normalize! arg1 (- f30-0 (-> *CAM_STRING-bank* los-coll-rad)))
           )
         )
       )
     )
    ((and (dist-info-valid? (-> arg0 cw))
          (dist-info-valid? (-> arg0 ccw))
          (< 0.01 (-> arg0 ccw max-vp))
          (< (-> arg0 ccw min-vp) -0.01)
          (or (< (-> arg0 cw max-vp) 0.01) (< -0.01 (-> arg0 cw min-vp)))
          )
     (if *display-cam-los-debug*
         (format *stdcon* "diagonal ccw~%")
         )
     (set! (-> self los-state) (slave-los-state ccw))
     (vector-normalize! arg1 (- (-> *CAM_STRING-bank* los-coll-rad) (-> arg0 ccw min-lat)))
     )
    ((and (dist-info-valid? (-> arg0 cw))
          (dist-info-valid? (-> arg0 ccw))
          (< 0.01 (-> arg0 cw max-vp))
          (< (-> arg0 cw min-vp) -0.01)
          (or (< (-> arg0 ccw max-vp) 0.01) (< -0.01 (-> arg0 ccw min-vp)))
          )
     (if *display-cam-los-debug*
         (format *stdcon* "diagonal cw~%")
         )
     (set! (-> self los-state) (slave-los-state cw))
     (vector-normalize! arg1 (- (-> arg0 cw min-lat) (-> *CAM_STRING-bank* los-coll-rad)))
     )
    ((and (dist-info-valid? (-> arg0 cw)) (dist-info-valid? (-> arg0 ccw)))
     (set! (-> self los-state) (slave-los-state between))
     (vector-normalize! arg1 0.0001)
     )
    ((dist-info-valid? (-> arg0 cw))
     (if *display-cam-los-debug*
         (format *stdcon* "regular cw~%")
         )
     (set! (-> self los-state) (slave-los-state cw))
     (vector-normalize! arg1 (- (-> arg0 cw min-lat) (-> *CAM_STRING-bank* los-coll-rad)))
     )
    ((dist-info-valid? (-> arg0 ccw))
     (if *display-cam-los-debug*
         (format *stdcon* "regular ccw~%")
         )
     (set! (-> self los-state) (slave-los-state ccw))
     (vector-normalize! arg1 (- (-> *CAM_STRING-bank* los-coll-rad) (-> arg0 ccw min-lat)))
     )
    (else
      (set! (-> self los-state) (slave-los-state none))
      (vector-reset! arg1)
      )
    )
  (cond
    ((= (vector-length arg1) 0.0)
     (set! (-> arg0 lateral-valid) #f)
     #f
     )
    (else
      (vector-! (-> arg0 lateral) arg1 arg2)
      (vector-normalize! (-> arg0 lateral) 1.0)
      (let ((v0-44 #t))
        (set! (-> arg0 lateral-valid) v0-44)
        v0-44
        )
      )
    )
  )

;; WARN: Return type mismatch int vs symbol.
;; ERROR: Unsupported inline assembly instruction kind - [mula.s f2, f5]
;; ERROR: Unsupported inline assembly instruction kind - [madda.s f3, f6]
;; ERROR: Unsupported inline assembly instruction kind - [madd.s f2, f4, f7]

(defbehavior cam-string-follow camera-slave ()
  (let ((f30-0 (vector-length (-> self view-flat))))
    (cond
      ((logtest? (-> self options) #x8000)
       (let ((gp-0 (new 'stack-no-clear 'vector)))
         (let ((s5-0 (new 'stack-no-clear 'vector)))
           (vector-cross! s5-0 (-> self view-flat) (-> *camera* local-down))
           (vector-normalize! s5-0 1.0)
           (vector-! gp-0 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
           (vector-flatten! gp-0 gp-0 s5-0)
           )
         (if (< (vector-dot gp-0 (-> self view-flat)) 0.0)
             (vector-! (-> self view-flat) (-> self view-flat) gp-0)
             )
         )
       )
      (else
        (let ((v1-10 (new 'stack-no-clear 'vector)))
          (vector-! v1-10 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
          (vector-! (-> self view-flat) (-> self view-flat) v1-10)
          )
        )
      )
    (vector-flatten! (-> self view-flat) (-> self view-flat) (-> *camera* local-down))
    (let* ((f28-0 (vector-length (-> self view-flat)))
           (f0-3 (fmin (-> *camera* string-push-z) (-> self view-off z)))
           (f26-0 (-> self view-off z))
           (f0-4 (fmin f0-3 (-> self min-z-override)))
           )
      (when (logtest? (cam-slave-options WIDE_FOV) (-> *camera* settings slave-options))
        (let ((v1-18 (new-stack-vector0)))
          0.0
          (vector-! v1-18 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
          (let ((f0-6 (vector-length v1-18)))
            (set! f0-4 (lerp-clamp 28672.0 32768.0 (parameter-ease-sin-clamp (* 0.00081380206 (+ -409.6 f0-6)))))
            )
          )
        (set! f26-0 f0-4)
        )
      (set! (-> self fov) (-> *camera* settings fov))
      (cond
        ((< f28-0 f0-4)
         (vector-normalize! (-> self view-flat) f0-4)
         )
        ((and (< f30-0 f28-0)
              (or (= (-> self los-state) (slave-los-state ccw)) (= (-> self los-state) (slave-los-state cw)))
              )
         (vector-normalize! (-> self view-flat) f30-0)
         )
        ((< f26-0 f28-0)
         (vector-normalize! (-> self view-flat) f26-0)
         (set! (-> self min-z-override) f26-0)
         f26-0
         )
        (else
          (set! (-> self min-z-override) f28-0)
          f28-0
          )
        )
      )
    )
  )

;; ERROR: function has no type analysis. Cannot decompile.

(defun cam-dist-analog-input ((arg0 int) (arg1 float))
  (let ((f0-0 (the-as number 0.0)))
    (cond
      ((< arg0 28)
       (set! f0-0 (- (fmin arg1 (* 0.083333336 (- 28.0 (the float arg0)) arg1))))
       )
      ((< 160 arg0)
       (set! f0-0 (fmin arg1 (* 0.0125 (+ -160.0 (the float arg0)) arg1)))
       )
      )
    (the-as float f0-0)
    )
  )

;; ERROR: failed type prop at 785: Could not figure out load: (set! v1 (l.wu (+ v1 124)))
;; WARN: Return type mismatch symbol vs vector.
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]
;; ERROR: Unsupported inline assembly instruction kind - [sllv a0, v1, r0]

;; WARN: Return type mismatch int vs none.
(defbehavior cam-string-find-hidden camera-slave ()
  (let ((s5-0 (new 'stack-no-clear 'collide-query))
        (gp-0 (new 'stack-no-clear 'vector))
        )
    (vector--float*!
      (-> s5-0 move-dist)
      (-> *camera* tpos-curr-adj)
      (-> *camera* local-down)
      (-> *camera* settings target-height)
      )
    (vector-! (-> s5-0 move-dist) (-> s5-0 move-dist) (-> self string-trans))
    (set! (-> s5-0 start-pos quad) (-> self string-trans quad))
    (let ((s4-0 s5-0))
      (set! (-> s4-0 radius) 409.6)
      (set! (-> s4-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
      (set! (-> s4-0 ignore-process0) #f)
      (set! (-> s4-0 ignore-process1) #f)
      (set! (-> s4-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
      (set! (-> s4-0 action-mask) (collide-action solid))
      )
    (cond
      ((< (fill-and-probe-using-line-sphere *collide-cache* s5-0) 0.0)
       (set! (-> self time-dist-too-far) (the-as uint 0))
       0
       )
      ((< (-> self time-dist-too-far) (the-as uint 600))
       (+! (-> self time-dist-too-far) 1)
       )
      ((cam-string-find-position-rel! gp-0)
       (cam-string-set-position-rel! gp-0)
       (set! (-> self time-dist-too-far) (the-as uint 0))
       0
       )
      (else
        (format 0 "camera position search failed~%")
        (set! (-> self time-dist-too-far) (the-as uint 0))
        0
        )
      )
    )
  (none)
  )

(defbehavior cam-string-move camera-slave ()
  (vector-! (-> self velocity) (-> self desired-pos) (-> self string-trans))
  (if *display-cam-los-debug*
      (format *stdcon* "vel ~M~%" (vector-length (-> self velocity)))
      )
  (let ((s5-0 (new 'stack-no-clear 'vector))
        (s4-0 (new 'stack-no-clear 'vector))
        (gp-0 (new 'stack-no-clear 'vector))
        (s3-0 (new 'stack-no-clear 'vector))
        )
    (vector-! s3-0 (-> *camera* tpos-curr-adj) (-> *camera* tpos-old-adj))
    (vector+float*! s5-0 (-> self velocity) s3-0 0.5)
    (vector-normalize! s5-0 1.0)
    (vector-normalize-copy! s4-0 (-> self view-flat) 1.0)
    (vector-cross! gp-0 s4-0 s5-0)
    (cond
      ((and (< (vector-length (-> self velocity)) (-> *CAMERA-bank* min-detectable-velocity))
            (< (vector-length s3-0) (-> *CAMERA-bank* min-detectable-velocity))
            )
       (set! (-> self string-vel-dir) (the-as uint 0))
       0
       )
      ((< (cos 5461.3335) (vector-dot (-> *camera* local-down) s5-0))
       (set! (-> self string-vel-dir) (the-as uint 4))
       )
      ((< (vector-dot (-> *camera* local-down) s5-0) (- (cos 5461.3335)))
       (set! (-> self string-vel-dir) (the-as uint 3))
       )
      ((< (cos 5461.3335) (vector-dot s4-0 s5-0))
       (set! (-> self string-vel-dir) (the-as uint 6))
       )
      ((< (vector-dot s4-0 s5-0) (- (cos 5461.3335)))
       (set! (-> self string-vel-dir) (the-as uint 5))
       )
      ((< (vector-dot (-> *camera* local-down) gp-0) 0.0)
       (set! (-> self string-vel-dir) (the-as uint 1))
       )
      (else
        (set! (-> self string-vel-dir) (the-as uint 2))
        )
      )
    )
  (let ((s5-1 (new 'stack-no-clear 'collide-query)))
    0.0
    (let ((f30-2 1.0)
          (s4-1 (-> s5-1 move-dist))
          (gp-1 0)
          )
      (let ((s3-1 (new 'stack-no-clear 'vector)))
        (when *debug-segment*
          (if (>= (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity)))
              (cam-collision-record-save (-> self string-trans) (-> self velocity) -1 'no-hit self)
              )
          )
        (while (and (< 0.01 f30-2)
                    (and (< (-> *CAMERA-bank* min-detectable-velocity) (vector-length (-> self velocity))) (< gp-1 4))
                    )
          (vector-float*! s4-1 (-> self velocity) f30-2)
          (if *debug-segment*
              (cam-collision-record-save (-> self string-trans) s4-1 gp-1 'normal self)
              )
          (let ((f28-0
                  (cond
                    ((logtest? (-> self options) 32)
                     (set! (-> s5-1 start-pos quad) (-> self string-trans quad))
                     (let ((s2-0 s5-1))
                       (set! (-> s2-0 radius) (-> *CAMERA-bank* collide-move-rad))
                       (set! (-> s2-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
                       (set! (-> s2-0 ignore-process0) #f)
                       (set! (-> s2-0 ignore-process1) #f)
                       (set! (-> s2-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
                       (set! (-> s2-0 action-mask) (collide-action solid))
                       )
                     (fill-and-probe-using-line-sphere *collide-cache* s5-1)
                     )
                    (else
                      -100000000.0
                      )
                    )
                  )
                )
            (if *display-cam-los-debug*
                (format *stdcon* "vp ~f vr ~f r ~f ta ~f~%" (vector-length s4-1) f30-2 (/ (vector-length s4-1) f30-2) f28-0)
                )
            (cond
              ((>= f28-0 0.0)
               (let* ((f1-10 (fmax 0.01 (/ 40.96 (vector-length s4-1))))
                      (f0-22 (fmax 0.0 (- f28-0 f1-10)))
                      )
                 (vector+float*! (-> self string-trans) (-> self string-trans) s4-1 f0-22)
                 )
               (vector-! s3-1 (-> self string-trans) (-> s5-1 best-other-tri intersect))
               (vector-normalize! s3-1 1.0)
               (vector-flatten! (-> self velocity) (-> self velocity) s3-1)
               (set! f30-2 (- f30-2 (* f30-2 f28-0)))
               (+! gp-1 1)
               )
              (else
                (vector+! (-> self string-trans) (-> self string-trans) s4-1)
                (set! f30-2 0.0)
                )
              )
            )
          )
        )
      (cond
        ((zero? gp-1)
         (set! (-> self options) (logand -1025 (-> self options)))
         (if *display-cam-los-debug*
             (format *stdcon* "not blocked~%")
             )
         )
        (else
          (logior! (-> self options) 1024)
          (if *display-cam-los-debug*
              (format *stdcon* "blocked ~D ~f~%" gp-1 f30-2)
              )
          (let ((gp-2 (new-stack-vector0))
                (f30-3 (vector-length (-> self view-flat)))
                )
            (vector-! gp-2 (-> self string-trans) (-> *camera* tpos-curr-adj))
            (vector-flatten! gp-2 gp-2 (-> *camera* local-down))
            (let ((f28-1 (vector-length gp-2)))
              (cond
                ((< f28-1 f30-3)
                 (vector-normalize-copy! (-> self view-flat) gp-2 f28-1)
                 (set! (-> self min-z-override) f28-1)
                 )
                (else
                  (vector-normalize-copy! (-> self view-flat) gp-2 f30-3)
                  )
                )
              )
            )
          )
        )
      )
    )
  (when *display-cam-los-debug*
    (let ((v1-105 (new-stack-vector0)))
      (vector-! v1-105 (-> self desired-pos) (-> self string-trans))
      (format *stdcon* "vel ~M~%" (vector-length v1-105))
      )
    )
  )

;; ERROR: failed type prop at 11: Called a function, but we do not know its type
;; WARN: Return type mismatch none vs vector.

(defbehavior set-string-params camera-slave ()
  (when (not (or (-> self string-val-locked) (logtest? #x40000 (-> self options))))
    (set! (-> self string-min-val quad) (-> *camera* string-min value quad))
    (let ((v0-0 (-> self string-max-val)))
      (set! (-> v0-0 quad) (-> *camera* string-max value quad))
      v0-0
      )
    )
  )

(defstate cam-string (camera-slave)
  :event (behavior ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
    (local-vars (v0-0 none))
    (let ((v1-0 arg2))
      (the-as
        object
        (cond
          ((= v1-0 'get-behind)
           (set! (-> self butt-timer) (the-as uint (+ (-> self clock frame-counter) (seconds 0.25))))
           (set! (-> self butt-seek) (the-as basic #t))
           (set! v0-0 (the-as none (-> self butt-vector)))
           (set! (-> (the-as vector v0-0) quad) (-> (the-as vector (-> arg3 param 0)) quad))
           v0-0
           )
          ((= v1-0 'teleport)
           (let ((gp-0 (new-stack-vector0)))
             (cam-string-find-position-rel! gp-0)
             (cam-string-set-position-rel! gp-0)
             )
           )
          ((= v1-0 'joystick)
           (set! (-> self phony-joystick-x) (the-as float (-> arg3 param 0)))
           (set! (-> self phony-joystick-y) (the-as float (-> arg3 param 1)))
           (set! v0-0 (the-as none #t))
           (set! (-> self have-phony-joystick) (the-as basic v0-0))
           v0-0
           )
          ((= v1-0 'tween-dist)
           (cond
             ((-> arg3 param 0)
              (set! (-> self string-val-locked) (the-as basic #t))
              (let ((s5-0 (the-as object (-> arg3 param 0)))
                    (gp-1 (the-as object (-> arg3 param 1)))
                    )
                (if (!= (-> (the-as vector s5-0) y) 4095996000.0)
                    (seek!
                      (-> self string-min-val y)
                      (-> (the-as vector s5-0) y)
                      (* (-> (the-as vector s5-0) w) (-> self clock seconds-per-frame))
                      )
                    )
                (if (!= (-> (the-as vector s5-0) z) 4095996000.0)
                    (seek!
                      (-> self string-min-val z)
                      (-> (the-as vector s5-0) z)
                      (* (-> (the-as vector s5-0) w) (-> self clock seconds-per-frame))
                      )
                    )
                (if (!= (-> (the-as vector gp-1) y) 4095996000.0)
                    (seek!
                      (-> self string-max-val y)
                      (-> (the-as vector gp-1) y)
                      (* (-> (the-as vector gp-1) w) (-> self clock seconds-per-frame))
                      )
                    )
                (if (!= (-> (the-as vector gp-1) z) 4095996000.0)
                    (seek!
                      (-> self string-max-val z)
                      (-> (the-as vector gp-1) z)
                      (* (-> (the-as vector gp-1) w) (-> self clock seconds-per-frame))
                      )
                    )
                )
              (set! (-> self string-max-val x) (fmax (-> self string-max-val x) (-> self string-min-val x)))
              (set! (-> self string-max-val y) (fmax (-> self string-max-val y) (-> self string-min-val y)))
              (let ((f0-31 (fmax (-> self string-max-val z) (-> self string-min-val z))))
                (set! (-> self string-max-val z) f0-31)
                f0-31
                )
              )
             (else
               (set! (-> self string-val-locked) #f)
               #f
               )
             )
           )
          ((= v1-0 'set-dist)
           (cond
             ((-> arg3 param 0)
              (set! (-> self string-val-locked) (the-as basic #t))
              (set! (-> self string-min-val quad) (-> (the-as vector (-> arg3 param 0)) quad))
              (set! (-> self string-max-val quad) (-> (the-as vector (-> arg3 param 1)) quad))
              (set! (-> self string-max-val x) (fmax (-> self string-max-val x) (-> self string-min-val x)))
              (set! (-> self string-max-val y) (fmax (-> self string-max-val y) (-> self string-min-val y)))
              (let ((f0-37 (fmax (-> self string-max-val z) (-> self string-min-val z))))
                (set! (-> self string-max-val z) f0-37)
                f0-37
                )
              )
             (else
               (set! (-> self string-val-locked) #f)
               #f
               )
             )
           )
          ((= v1-0 'relative-position)
           (cond
             ((-> arg3 param 0)
              (set! (-> self string-val-locked) (the-as basic #t))
              (set! (-> self string-relative) (the-as basic #t))
              (set! v0-0 (the-as none (-> self relative-position)))
              (set! (-> (the-as vector v0-0) quad) (-> (the-as vector (-> arg3 param 0)) quad))
              v0-0
              )
             (else
               (set! (-> self string-val-locked) #f)
               (set! (-> self string-relative) #f)
               #f
               )
             )
           )
          ((= v1-0 'set-max-angle-offset)
           (let ((f0-38 (the-as float (-> arg3 param 0))))
             (set! (-> self max-angle-offset) f0-38)
             f0-38
             )
           )
          ((= v1-0 'blocked-side?)
           (-> self los-state)
           )
          (else
            (cam-standard-event-handler arg0 arg1 arg2 arg3)
            )
          )
        )
      )
    )
  :enter (behavior ()
    (when (not (-> self enter-has-run))
      (if (-> self cam-entity)
          (logior! (-> self options) (cam-slave-get-flags (-> self cam-entity) 'flags))
          )
      (vector-reset! (-> self joystick-saved-view-off))
      (set-string-params)
      (set! (-> self string-vel-dir) (the-as uint 0))
      (set! (-> self fov) 11650.845)
      (set! (-> self los-tgt-spline-pt) (-> *camera* target-spline end-point))
      (set! (-> self los-tgt-spline-pt-incarnation)
            (-> *camera* target-spline point (-> self los-tgt-spline-pt) incarnation)
            )
      (set! (-> self min-z-override) (-> self string-max-val z))
      (if (!= (-> *camera* outro-t-step) 0.0)
          (set! (-> self min-z-override) (-> self string-min-val z))
          )
      (let ((gp-1 (new-stack-vector0)))
        0.0
        (set! (-> self view-off-param) (-> *camera* view-off-param-save))
        (set! (-> self view-off x) 0.0)
        (let ((f0-7 (-> self string-min-val y))
              (f1-1 (-> self string-max-val y))
              )
          (set! (-> self view-off y) (lerp f0-7 f1-1 (-> self view-off-param)))
          )
        (set! (-> self view-off z)
              (lerp (-> self string-min-val z) (-> self string-max-val z) (-> self view-off-param))
              )
        (let ((f30-0
                (cond
                  ((!= (-> *camera* outro-t-step) 0.0)
                   (curve-get-pos! gp-1 (-> *camera* outro-exit-value) (-> *camera* outro-curve))
                   (vector-! gp-1 gp-1 (-> *camera* tpos-curr-adj))
                   (vector-flatten! (-> self view-flat) gp-1 (-> *camera* local-down))
                   (vector-length (-> self view-flat))
                   )
                  ((-> *camera* settings string-use-startup-vector)
                   (vector-flatten! (-> self view-flat) (-> *camera* settings string-startup-vector) (-> *camera* local-down))
                   (vector-length (-> self view-flat))
                   )
                  (else
                    (vector-flatten! (-> self view-flat) (the-as vector (&-> self stack 112)) (-> *camera* local-down))
                    (vector-negate! (-> self view-flat) (-> self view-flat))
                    (-> self view-off z)
                    )
                  )
                )
              )
          (let ((f1-4 (fmin (-> *camera* string-push-z) (-> self min-z-override)))
                (f0-17 (-> self view-off z))
                )
            (cond
              ((< f30-0 f1-4)
               (set! f30-0 f1-4)
               )
              ((< f0-17 f30-0)
               (set! f30-0 f0-17)
               )
              )
            )
          (vector-normalize! (-> self view-flat) f30-0)
          (let ((f30-1 (/ (- f30-0 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))))
            (if (< 1.0 f30-1)
                (set! f30-1 1.0)
                )
            (if (< f30-1 0.0)
                (set! f30-1 0.0)
                )
            (let ((f0-22 (-> self string-min-val y))
                  (f1-7 (-> self string-max-val y))
                  )
              (set! (-> self view-off y) (lerp f0-22 f1-7 f30-1))
              )
            (set! (-> self view-off z) (lerp (-> self string-min-val z) (-> self string-max-val z) f30-1))
            )
          )
        )
      (vector--float*!
        (-> self desired-pos)
        (-> self view-flat)
        (-> *camera* local-down)
        (+ (-> *camera* settings target-height) (-> self view-off y))
        )
      (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
      (set! (-> self string-trans quad) (-> self desired-pos quad))
      (vector-reset! (-> self velocity))
      (let ((gp-2 (new 'stack-no-clear 'collide-query)))
        (vector--float*!
          (-> gp-2 start-pos)
          (-> *camera* tpos-curr-adj)
          (-> *camera* local-down)
          (-> *camera* settings target-height)
          )
        (vector-! (-> gp-2 move-dist) (-> self string-trans) (-> gp-2 start-pos))
        (let ((s5-0 gp-2))
          (set! (-> s5-0 radius) (-> *CAMERA-bank* collide-move-rad))
          (set! (-> s5-0 collide-with) (collide-spec backgnd obstacle hit-by-others-list camera-blocker pusher))
          (set! (-> s5-0 ignore-process0) #f)
          (set! (-> s5-0 ignore-process1) #f)
          (set! (-> s5-0 ignore-pat) (the-as pat-surface (camera-master-method-16 *camera* #f)))
          (set! (-> s5-0 action-mask) (collide-action solid))
          )
        (let ((f0-31 (fill-and-probe-using-line-sphere *collide-cache* gp-2)))
          (when (and (< 0.0 f0-31) (< f0-31 1.0))
            (vector-float*! (-> gp-2 move-dist) (-> gp-2 move-dist) f0-31)
            (vector-flatten! (-> self view-flat) (-> gp-2 move-dist) (-> *camera* local-down))
            (let ((f0-32 (vector-length (-> self view-flat))))
              (cond
                ((< f0-32 8192.0)
                 (let ((gp-3 (new-stack-vector0)))
                   (cam-string-find-position-rel! gp-3)
                   (cam-string-set-position-rel! gp-3)
                   )
                 )
                (else
                  (if (< f0-32 (-> self min-z-override))
                      (set! (-> self min-z-override) f0-32)
                      )
                  (let ((f30-2 (/ (- f0-32 (-> self string-min-val z)) (- (-> self string-max-val z) (-> self string-min-val z)))))
                    (if (< 1.0 f30-2)
                        (set! f30-2 1.0)
                        )
                    (if (< f30-2 0.0)
                        (set! f30-2 0.0)
                        )
                    (let ((f0-36 (-> self string-min-val y))
                          (f1-16 (-> self string-max-val y))
                          )
                      (set! (-> self view-off y) (lerp f0-36 f1-16 f30-2))
                      )
                    (set! (-> self view-off z) (lerp (-> self string-min-val z) (-> self string-max-val z) f30-2))
                    )
                  (vector--float*!
                    (-> self desired-pos)
                    (-> self view-flat)
                    (-> *camera* local-down)
                    (+ (-> *camera* settings target-height) (-> self view-off y))
                    )
                  (vector+! (-> self desired-pos) (-> self desired-pos) (-> *camera* tpos-curr-adj))
                  (set! (-> self string-trans quad) (-> self desired-pos quad))
                  (vector-reset! (-> self velocity))
                  )
                )
              )
            )
          )
        )
      (set! (-> self trans quad) (-> self string-trans quad))
      (set! (-> self los-last-pos quad) (-> self string-trans quad))
      (tracking-spline-method-10 (-> self position-spline) (-> self string-trans))
      (set! (-> self blend-from-type) (the-as uint 2))
      (set! (-> self blend-to-type) (camera-blend-to-type unknown-2))
      )
    (none)
    )
  :trans (behavior ()
    (if (zero? (logand (-> *camera* master-options) 1))
        (cam-slave-go cam-free-floating)
        )
    (none)
    )
  :code (behavior ()
    (until #f
      (when (not (paused?))
        (set-string-params)
        (cam-string-code)
        (tracking-spline-method-9 (-> self position-spline))
        (set! (-> self have-phony-joystick) #f)
        )
      (suspend)
      )
    #f
    (none)
    )
  )



(define *CAM_STICK-bank*
  (new 'static 'cam-stick-bank :max-z (meters 30) :min-z (meters 5) :max-y (meters 15) :min-y (meters 2))
  )

;; ERROR: function has no type analysis. Cannot decompile.




(define *CAM_BIKE-bank*
  (new 'static 'cam-bike-bank :max-z (meters 6) :min-z (meters 10) :max-y (meters 3) :min-y (meters 5))
  )

(defbehavior cam-calc-bike-follow! camera-slave ((arg0 cam-rotation-tracker) (arg1 vector) (arg2 symbol))
  (vector-float*! (-> arg0 follow-off) (the-as vector (&-> *camera* stack 320)) 155648.0)
  (vector+! (-> arg0 follow-pt) (-> *camera* tpos-curr-adj) (-> arg0 follow-off))
  (vector--float*!
    (-> arg0 follow-pt)
    (-> arg0 follow-pt)
    (-> *camera* local-down)
    (+ 12288.0 (-> *camera* settings target-height))
    )
  (-> arg0 follow-pt)
  )

;; ERROR: function has no type analysis. Cannot decompile.





