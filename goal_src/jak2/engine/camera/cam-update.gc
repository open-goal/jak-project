;;-*-Lisp-*-
(in-package goal)

;; name: cam-update.gc
;; name in dgo: cam-update
;; dgos: ENGINE, GAME

;; TODO
;; og:ignore-form:update-visible

;; DECOMP BEGINS

(defun plane-from-points ((arg0 (inline-array plane)) (arg1 vector) (arg2 vector) (arg3 vector) (arg4 int))
  (let ((s4-0 (new 'stack-no-clear 'vector)))
    (vector-cross! s4-0 arg1 arg2)
    (vector-normalize! s4-0 1.0)
    (set! (-> s4-0 w) (vector-dot s4-0 arg3))
    (set! (-> (&-> arg0 0 data arg4) 0) (-> s4-0 x))
    (set! (-> (&-> arg0 0 data arg4) 4) (-> s4-0 y))
    (set! (-> (&-> arg0 0 data arg4) 8) (-> s4-0 z))
    (let ((f0-5 (-> s4-0 w)))
      (set! (-> (&-> arg0 0 data arg4) 12) f0-5)
      f0-5
      )
    )
  )

(defun set-point ((arg0 vector) (arg1 float) (arg2 float) (arg3 float))
  (set! (-> arg0 x) arg1)
  (set! (-> arg0 y) arg2)
  (set! (-> arg0 z) arg3)
  (let ((f0-3 1.0))
    (set! (-> arg0 w) f0-3)
    f0-3
    )
  )

(defun update-view-planes ((arg0 math-camera) (arg1 (inline-array plane)) (arg2 float) (arg3 matrix))
  (local-vars (sv-240 vector))
  (when (not *artist-fix-frustum*)
    (let ((s5-0 (new 'stack 'view-frustum)))
      (let ((f30-0 (* arg2 (-> arg0 x-ratio) (-> arg0 d)))
            (f26-0 (* arg2 (-> arg0 y-ratio) (-> arg0 d)))
            (f28-0 (* arg2 (-> arg0 x-ratio) (-> arg0 f)))
            (f24-0 (* arg2 (-> arg0 y-ratio) (-> arg0 f)))
            )
        (set-point (-> s5-0 hither-top-left) (- f30-0) f26-0 (-> arg0 d))
        (set-point (-> s5-0 hither-top-right) f30-0 f26-0 (-> arg0 d))
        (set-point (-> s5-0 hither-bottom-left) (- f30-0) (- f26-0) (-> arg0 d))
        (set-point (-> s5-0 hither-bottom-right) f30-0 (- f26-0) (-> arg0 d))
        (set-point (-> s5-0 yon-top-left) (- f28-0) f24-0 (-> arg0 f))
        (set-point (-> s5-0 yon-top-right) f28-0 f24-0 (-> arg0 f))
        (set-point (-> s5-0 yon-bottom-left) (- f28-0) (- f24-0) (-> arg0 f))
        (set-point (-> s5-0 yon-bottom-right) f28-0 (- f24-0) (-> arg0 f))
        )
      (vector-matrix*! (-> s5-0 hither-top-left) (-> s5-0 hither-top-left) arg3)
      (vector-matrix*! (-> s5-0 hither-top-right) (-> s5-0 hither-top-right) arg3)
      (vector-matrix*! (-> s5-0 hither-bottom-left) (-> s5-0 hither-bottom-left) arg3)
      (vector-matrix*! (-> s5-0 hither-bottom-right) (-> s5-0 hither-bottom-right) arg3)
      (vector-matrix*! (-> s5-0 yon-top-left) (-> s5-0 yon-top-left) arg3)
      (vector-matrix*! (-> s5-0 yon-top-right) (-> s5-0 yon-top-right) arg3)
      (vector-matrix*! (-> s5-0 yon-bottom-left) (-> s5-0 yon-bottom-left) arg3)
      (vector-matrix*! (-> s5-0 yon-bottom-right) (-> s5-0 yon-bottom-right) arg3)
      (when (= arg2 1.0)
        (vector-! (the-as vector (-> *fog-texture-work* corner)) (-> s5-0 yon-top-left) (-> arg3 trans))
        (vector-! (-> *fog-texture-work* corner 1) (-> s5-0 yon-top-right) (-> arg3 trans))
        (vector-! (-> *fog-texture-work* corner 2) (-> s5-0 yon-bottom-left) (-> arg3 trans))
        (vector-! (-> *fog-texture-work* corner 3) (-> s5-0 yon-bottom-right) (-> arg3 trans))
        )
      (let ((s2-1 (new-stack-vector0))
            (s3-1 (new-stack-vector0))
            (s1-0 (new-stack-vector0))
            (s0-0 (new-stack-vector0))
            )
        (set! (-> (new 'stack-no-clear 'vector) quad) (the-as uint128 0))
        (set! sv-240 (new 'stack-no-clear 'vector))
        (set! (-> sv-240 quad) (the-as uint128 0))
        (let ((v1-15 (-> arg3 trans quad)))
          (set! (-> sv-240 quad) v1-15)
          )
        (vector-! s2-1 (-> s5-0 yon-top-left) sv-240)
        (vector-! s3-1 (-> s5-0 yon-top-right) sv-240)
        (vector-! s1-0 (-> s5-0 yon-bottom-left) sv-240)
        (vector-! s0-0 (-> s5-0 yon-bottom-right) sv-240)
        (plane-from-points arg1 s2-1 s1-0 sv-240 0)
        (plane-from-points arg1 s0-0 s3-1 sv-240 1)
        (plane-from-points arg1 s3-1 s2-1 sv-240 2)
        (let ((t9-20 plane-from-points)
              (t0-3 3)
              )
          (t9-20 arg1 s1-0 s0-0 sv-240 t0-3)
          )
        )
      )
    )
  )

(define *update-leaf-when-outside-bsp* #t)

;; ERROR: failed type prop at 290: Could not figure out load: (set! v1 (l.w s3))

(define *save-camera-inv-rot* (new 'global 'matrix))

(matrix-identity! *save-camera-inv-rot*)

(defun move-camera-from-pad ((arg0 math-camera))
  (let ((v1-0 *external-cam-mode*)
        (s5-0 0)
        )
    (cond
      ((= v1-0 'locked)
       (set! v1-0 #f)
       )
      ((= v1-0 'pad-1)
       (set! s5-0 1)
       )
      ((not *camera-combiner*)
       (set! v1-0 'pad-0)
       )
      )
    (when v1-0
      (let ((a2-1
              (vector-negate-in-place! (vector-normalize-copy! (new-stack-vector0) (-> *standard-dynamics* gravity) 1.0))
              )
            )
        (if (= (vector-length a2-1) 0.0)
            (set! (-> a2-1 y) -1.0)
            )
        (if (logtest? *external-cam-options* (external-cam-option allow-z))
            (set! a2-1 (the-as vector #f))
            )
        (cam-free-floating-move *save-camera-inv-rot* (-> arg0 trans) a2-1 s5-0)
        )
      )
    )
  (let* ((a2-2 (-> *math-camera* inv-camera-rot))
         (a3-1 *save-camera-inv-rot*)
         (v1-14 (-> a3-1 vector 0 quad))
         (a0-13 (-> a3-1 vector 1 quad))
         (a1-2 (-> a3-1 vector 2 quad))
         (a3-2 (-> a3-1 trans quad))
         )
    (set! (-> a2-2 vector 0 quad) v1-14)
    (set! (-> a2-2 vector 1 quad) a0-13)
    (set! (-> a2-2 vector 2 quad) a1-2)
    (set! (-> a2-2 trans quad) a3-2)
    )
  arg0
  )

(defun external-cam-reset! ()
  (when (not (movie?))
    (vector-reset! (-> *math-camera* trans))
    (matrix-identity! (-> *math-camera* inv-camera-rot))
    (when *camera-combiner*
      (let* ((v1-7 (-> *math-camera* inv-camera-rot))
             (a3-0 (-> *camera-combiner* inv-camera-rot))
             (a0-2 (-> a3-0 vector 0 quad))
             (a1-0 (-> a3-0 vector 1 quad))
             (a2-0 (-> a3-0 vector 2 quad))
             (a3-1 (-> a3-0 trans quad))
             )
        (set! (-> v1-7 vector 0 quad) a0-2)
        (set! (-> v1-7 vector 1 quad) a1-0)
        (set! (-> v1-7 vector 2 quad) a2-0)
        (set! (-> v1-7 trans quad) a3-1)
        )
      (set! (-> *math-camera* trans quad) (-> *camera-combiner* trans quad))
      )
    )
  0
  (none)
  )

(define *start-timer* (the-as int #f))

(define *timer-value* 0)

(define *start-pos* (new 'global 'vector))

(defun update-camera ()
  (with-pp
    (let ((gp-0 *math-camera*))
      (let* ((a2-0 (-> gp-0 prev-inv-camera-rot))
             (a3-0 (-> gp-0 inv-camera-rot))
             (v1-0 (-> a3-0 vector 0 quad))
             (a0-0 (-> a3-0 vector 1 quad))
             (a1-0 (-> a3-0 vector 2 quad))
             (a3-1 (-> a3-0 trans quad))
             )
        (set! (-> a2-0 vector 0 quad) v1-0)
        (set! (-> a2-0 vector 1 quad) a0-0)
        (set! (-> a2-0 vector 2 quad) a1-0)
        (set! (-> a2-0 trans quad) a3-1)
        )
      (set! (-> gp-0 prev-trans quad) (-> gp-0 trans quad))
      (when *start-timer*
        (when (= *timer-value* 180)
          (format
            #t
            "Player pos = ~F ~F ~F~%"
            (-> *target* control trans x)
            (-> *target* control trans y)
            (-> *target* control trans z)
            )
          (set! (-> *start-pos* quad) (-> *target* control trans quad))
          )
        (when (= *timer-value* 480)
          (format
            #t
            "Player pos = ~F ~F ~F~%"
            (-> *target* control trans x)
            (-> *target* control trans y)
            (-> *target* control trans z)
            )
          (format
            #t
            "Dist = ~F~%"
            (* 0.00024414062 (vector-vector-xz-distance (-> *target* control trans) *start-pos*))
            )
          (set! *start-timer* (the-as int #f))
          )
        (if (< 179 *timer-value*)
            (format *stdcon* "~%~%Time = ~D~%" *timer-value*)
            )
        (set! *timer-value* (+ *timer-value* 1))
        )
      (when (not *start-timer*)
        (set! *timer-value* 0)
        0
        )
      (let ((f0-9 (if (-> *blit-displays-work* menu-mode)
                      11650.845
                      (-> gp-0 fov)
                      )
                  )
            )
        (update-math-camera
          gp-0
          (-> *setting-control* user-current video-mode)
          (-> *setting-control* user-current aspect-ratio)
          f0-9
          )
        )
      (cond
        ((or (= *master-mode* 'pause) (or (= *master-mode* 'freeze) (= *master-mode* 'progress) *progress-process*))
         )
        ((>= *camera-look-through-other* 2)
         (set! *camera-look-through-other* 1)
         )
        ((and (= *camera-look-through-other* 1) (!= *master-mode* 'menu))
         (set! *camera-look-through-other* 0)
         0
         )
        )
      0.0
      (let ((s5-1 (-> pp clock)))
        (set! (-> pp clock) (-> *display* camera-clock))
        (update! *camera-smush-control*)
        (let ((f0-11 (get-no-update *camera-smush-control*)))
          f0-11
          (set! (-> pp clock) s5-1)
          (cond
            (*external-cam-mode*
              (move-camera-from-pad gp-0)
              )
            ((nonzero? *camera-look-through-other*)
             (set! (-> gp-0 fov) (-> *camera-other-fov* data))
             (set! (-> gp-0 trans quad) (-> *camera-other-trans* quad))
             (+! (-> gp-0 trans y) f0-11)
             (let* ((a2-6 (-> gp-0 inv-camera-rot))
                    (a3-5 *camera-other-matrix*)
                    (v1-68 (-> a3-5 vector 0 quad))
                    (a0-29 (-> a3-5 vector 1 quad))
                    (a1-7 (-> a3-5 vector 2 quad))
                    (a3-6 (-> a3-5 trans quad))
                    )
               (set! (-> a2-6 vector 0 quad) v1-68)
               (set! (-> a2-6 vector 1 quad) a0-29)
               (set! (-> a2-6 vector 2 quad) a1-7)
               (set! (-> a2-6 trans quad) a3-6)
               )
             (let* ((v1-69 *save-camera-inv-rot*)
                    (a3-7 *camera-other-matrix*)
                    (a0-30 (-> a3-7 vector 0 quad))
                    (a1-8 (-> a3-7 vector 1 quad))
                    (a2-7 (-> a3-7 vector 2 quad))
                    (a3-8 (-> a3-7 trans quad))
                    )
               (set! (-> v1-69 vector 0 quad) a0-30)
               (set! (-> v1-69 vector 1 quad) a1-8)
               (set! (-> v1-69 vector 2 quad) a2-7)
               (set! (-> v1-69 trans quad) a3-8)
               )
             )
            ((and *camera-combiner* (not *external-cam-mode*))
             (set! (-> gp-0 fov) (-> *camera-combiner* fov))
             (set! (-> gp-0 trans quad) (-> *camera-combiner* trans quad))
             (+! (-> gp-0 trans y) f0-11)
             (let* ((v1-76 (-> gp-0 inv-camera-rot))
                    (a3-9 (-> *camera-combiner* inv-camera-rot))
                    (a0-35 (-> a3-9 vector 0 quad))
                    (a1-9 (-> a3-9 vector 1 quad))
                    (a2-8 (-> a3-9 vector 2 quad))
                    (a3-10 (-> a3-9 trans quad))
                    )
               (set! (-> v1-76 vector 0 quad) a0-35)
               (set! (-> v1-76 vector 1 quad) a1-9)
               (set! (-> v1-76 vector 2 quad) a2-8)
               (set! (-> v1-76 trans quad) a3-10)
               )
             (let* ((v1-77 *save-camera-inv-rot*)
                    (a3-11 (-> *camera-combiner* inv-camera-rot))
                    (a0-37 (-> a3-11 vector 0 quad))
                    (a1-10 (-> a3-11 vector 1 quad))
                    (a2-9 (-> a3-11 vector 2 quad))
                    (a3-12 (-> a3-11 trans quad))
                    )
               (set! (-> v1-77 vector 0 quad) a0-37)
               (set! (-> v1-77 vector 1 quad) a1-10)
               (set! (-> v1-77 vector 2 quad) a2-9)
               (set! (-> v1-77 trans quad) a3-12)
               )
             )
            (*camera*
              (move-camera-from-pad gp-0)
              )
            )
          )
        )
      (matrix-transpose! (-> gp-0 camera-rot) (-> gp-0 inv-camera-rot))
      (cond
        (*camera-no-mip-correction*
          (set! (-> gp-0 fov-correction-factor) 1.0)
          )
        (else
          (let ((f0-16 (fmin 11650.845 (-> gp-0 fov))))
            (set! (-> gp-0 fov-correction-factor) (* 0.00008583069 f0-16))
            )
          )
        )
      (if (< 0.0 (-> gp-0 smooth-t))
          (set! (-> gp-0 smooth-t) (- (-> gp-0 smooth-t) (-> gp-0 smooth-step)))
          )
      (cond
        ((< 0.0 (-> gp-0 smooth-t))
         (let ((s5-2 (new-stack-quaternion0)))
           (matrix->quaternion s5-2 (-> gp-0 inv-camera-rot))
           (quaternion-slerp! s5-2 s5-2 (-> gp-0 inv-camera-rot-smooth-from) (-> gp-0 smooth-t))
           (quaternion->matrix (-> gp-0 inv-camera-rot-smooth) s5-2)
           )
         )
        (else
          (let* ((a2-11 (-> gp-0 inv-camera-rot-smooth))
                 (a3-14 (-> gp-0 inv-camera-rot))
                 (v1-90 (-> a3-14 vector 0 quad))
                 (a0-43 (-> a3-14 vector 1 quad))
                 (a1-15 (-> a3-14 vector 2 quad))
                 (a3-15 (-> a3-14 trans quad))
                 )
            (set! (-> a2-11 vector 0 quad) v1-90)
            (set! (-> a2-11 vector 1 quad) a0-43)
            (set! (-> a2-11 vector 2 quad) a1-15)
            (set! (-> a2-11 trans quad) a3-15)
            )
          )
        )
      (when (and (!= *master-mode* 'menu) *display-camera-info*)
        (format *stdcon* "cam pos ~M ~M ~M~%" (-> gp-0 trans x) (-> gp-0 trans y) (-> gp-0 trans z))
        (let ((v1-95 (-> *setting-control* cam-current)))
          (format
            *stdcon*
            "string info min-l ~M max-l ~M min-h ~M max-h ~M~%"
            (-> v1-95 string-min-length)
            (-> v1-95 string-max-length)
            (-> v1-95 string-min-height)
            (-> v1-95 string-max-height)
            )
          )
        )
      (when (zero? (-> gp-0 reset))
        (let* ((a2-14 (-> gp-0 prev-camera-temp))
               (a3-18 (-> gp-0 camera-temp))
               (v1-99 (-> a3-18 vector 0 quad))
               (a0-48 (-> a3-18 vector 1 quad))
               (a1-18 (-> a3-18 vector 2 quad))
               (a3-19 (-> a3-18 trans quad))
               )
          (set! (-> a2-14 vector 0 quad) v1-99)
          (set! (-> a2-14 vector 1 quad) a0-48)
          (set! (-> a2-14 vector 2 quad) a1-18)
          (set! (-> a2-14 trans quad) a3-19)
          )
        )
      (let ((s3-1 (-> gp-0 camera-temp))
            (s2-0 (-> gp-0 camera-rot))
            (s5-3 (-> gp-0 inv-camera-rot))
            (s4-1 (-> gp-0 trans))
            )
        (let ((s1-0 (new-stack-vector0)))
          (set! (-> s1-0 x) (- (-> s4-1 x)))
          (set! (-> s1-0 y) (- (-> s4-1 y)))
          (set! (-> s1-0 z) (- (-> s4-1 z)))
          (set! (-> s1-0 w) 1.0)
          (vector-matrix*! s1-0 s1-0 s2-0)
          (set! (-> s2-0 trans quad) (-> s1-0 quad))
          )
        (matrix*! s3-1 s2-0 (-> gp-0 perspective))
        (set! (-> s5-3 trans quad) (-> s4-1 quad))
        )
      (when (nonzero? (-> gp-0 reset))
        (let* ((a2-17 (-> gp-0 prev-camera-temp))
               (a3-20 (-> gp-0 camera-temp))
               (v1-105 (-> a3-20 vector 0 quad))
               (a0-51 (-> a3-20 vector 1 quad))
               (a1-21 (-> a3-20 vector 2 quad))
               (a3-21 (-> a3-20 trans quad))
               )
          (set! (-> a2-17 vector 0 quad) v1-105)
          (set! (-> a2-17 vector 1 quad) a0-51)
          (set! (-> a2-17 vector 2 quad) a1-21)
          (set! (-> a2-17 trans quad) a3-21)
          )
        (set! (-> gp-0 reset) 0)
        0
        )
      (let ((f1-10 (-> gp-0 fog-min))
            (f0-37 (-> gp-0 fog-max))
            )
        (let ((f2-0 (-> gp-0 d)))
          (set! (-> *instance-tie-work* hmge-d x) f1-10)
          (set! (-> *instance-tie-work* hmge-d y) f0-37)
          (set! (-> *instance-tie-work* hmge-d z) (* 32.0 f2-0))
          (set! (-> *instance-tie-work* hmge-d w) (* f2-0 (-> gp-0 hmge-scale w)))
          (let ((v1-112 (-> gp-0 hvdf-off quad)))
            (set! (-> *instance-tie-work* hvdf-offset quad) v1-112)
            )
          (set! (-> *instance-shrub-work* hmge-d x) f1-10)
          (set! (-> *instance-shrub-work* hmge-d y) f0-37)
          (set! (-> *instance-shrub-work* hmge-d z) (* 3.0 f2-0))
          (set! (-> *instance-shrub-work* hmge-d w) (* f2-0 (-> gp-0 hmge-scale w)))
          (set! (-> *instance-shrub-work* billboard-const x) (/ (-> gp-0 x-pix) (* f2-0 (-> gp-0 x-ratio))))
          (set! (-> *instance-shrub-work* billboard-const y) (/ (-> gp-0 y-pix) (* f2-0 (-> gp-0 y-ratio))))
          )
        (set! (-> *instance-shrub-work* billboard-const z) f1-10)
        (set! (-> *instance-shrub-work* billboard-const w) f0-37)
        )
      (set! (-> *instance-shrub-work* constants w) (the-as float (-> gp-0 vis-gifs 0 fog0)))
      (let ((a0-53 (-> gp-0 hvdf-off quad)))
        (set! (-> *instance-shrub-work* hvdf-offset quad) a0-53)
        )
      (update-view-planes gp-0 (-> gp-0 plane) 1.0 (-> gp-0 inv-camera-rot))
      (update-view-planes gp-0 (-> gp-0 guard-plane) 4.0 (-> gp-0 inv-camera-rot))
      (let ((t9-20 shrub-make-perspective-matrix)
            (a0-56 (-> gp-0 shrub-mat))
            )
        (-> gp-0 camera-temp)
        (t9-20 a0-56)
        )
      (update-visible gp-0)
      (when (-> *time-of-day-context* use-camera-other)
        (let ((s5-4 (-> gp-0 camera-rot))
              (s4-2 (-> gp-0 camera-rot-other))
              (s3-2 (-> gp-0 inv-camera-rot-other))
              )
          (let ((s2-1 (-> gp-0 camera-temp-other)))
            (quaternion->matrix s4-2 (-> gp-0 quat-other))
            (set! (-> s4-2 trans quad) (-> gp-0 trans-other quad))
            (set! (-> s4-2 trans w) 1.0)
            (matrix*! s4-2 s4-2 s5-4)
            (matrix-inverse-of-rot-trans! s3-2 s4-2)
            (matrix*! s2-1 s4-2 (-> gp-0 perspective))
            )
          (update-view-planes gp-0 (-> gp-0 plane-other) 1.0 s3-2)
          (update-view-planes gp-0 (-> gp-0 guard-plane-other) 4.0 s3-2)
          )
        (shrub-make-perspective-matrix (-> gp-0 shrub-mat-other))
        )
      )
    #f
    )
  )

(defun-debug move-level-by-name ((arg0 symbol) (arg1 float) (arg2 float) (arg3 float))
  (let ((v1-1 (level-get *level* arg0)))
    (when v1-1
      (set! (-> v1-1 info use-camera-other) #t)
      (let ((v0-1 (-> *math-camera* trans-other)))
        (set! (-> v0-1 x) (* 4096.0 arg1))
        (set! (-> v0-1 y) (* 4096.0 arg2))
        (set! (-> v0-1 z) (* 4096.0 arg3))
        (set! (-> v0-1 w) 1.0)
        v0-1
        )
      )
    )
  )




