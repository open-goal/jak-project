;;-*-Lisp-*-
(in-package goal)

;; name: crates.gc
;; name in dgo: crates
;; dgos: ENGINE, GAME

(define-extern process-contact-action (function process none :behavior target))
(define-extern eco-blue-glow (function vector none))

;; DECOMP BEGINS

(defskelgroup skel-crate-krimson crate crate-krimson-lod0-jg crate-idle-ja
              ((crate-krimson-lod0-mg (meters 20)) (crate-krimson-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 1 0 1.6)
              :texture-level 6
              )

(deftype crate-bank (basic)
  ((COLLIDE_YOFF           float  :offset-assert   4)
   (COLLIDE_RADIUS         float  :offset-assert   8)
   (DARKECO_EXPLODE_RADIUS float  :offset-assert  12)
   )
  :method-count-assert 9
  :size-assert         #x10
  :flag-assert         #x900000010
  )


(define *CRATE-bank*
  (new 'static 'crate-bank :COLLIDE_YOFF 4096.0 :COLLIDE_RADIUS 6963.2 :DARKECO_EXPLODE_RADIUS 16384.0)
  )

(deftype crate (process-focusable)
  ((root-override2     collide-shape-moving         :offset        128)
   (smush              smush-control        :inline :offset-assert 208)
   (base               vector               :inline :offset-assert 240)
   (look               symbol                       :offset-assert 256)
   (defense            symbol                       :offset-assert 260)
   (incoming-attack-id uint32                       :offset-assert 264)
   (target             handle                       :offset-assert 272)
   (child-count        int32                        :offset-assert 280)
   (victory-anim       spool-anim                   :offset-assert 284)
   )
  :heap-base #xa0
  :method-count-assert 41
  :size-assert         #x120
  :flag-assert         #x2900a00120
  (:methods
    (hide () _type_ :state 27)
    (idle () _type_ :state 28)
    (die (symbol int) _type_ :state 29)
    (special-contents-die () _type_ :state 30)
    (bounce-on () _type_ :state 31)
    (notice-blue (handle) _type_ :state 32)
    (carry () _type_ :state 33)
    (fall () _type_ :state 34)
    (crate-init! (_type_ entity-actor) none 35)
    (skel-init! (_type_) none 36)
    (params-set! (_type_ symbol symbol) none 37)
    (crate-method-38 (_type_) none 38)
    (smush-update! (_type_) none 39)
    (crate-method-40 (_type_) symbol :behavior crate 40)
    )
  )


(method-set! crate 12 (method-of-type process run-logic?))

(defbehavior crate-post crate ()
  (rider-trans)
  (smush-update! self)
  (rider-post)
  (carry-info-method-9 (-> self carry))
  (none)
  )

(defpart 565
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 16.0)
    (:y (meters 0.5) (meters 1))
    (:scale-x (meters 1.5) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 128.0 32.0)
    (:g 128.0 32.0)
    (:b 128.0 32.0)
    (:a 32.0 16.0)
    (:vel-y (meters 0.016666668) (meters 0.033333335))
    (:rotvel-z (degrees -1.2) (degrees 1.2))
    (:accel-y (meters 0.00066666666))
    (:timer (seconds 0.4))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14 sp-cpuinfo-flag-21))
    (:next-time (seconds 0.1) (seconds 0.197))
    (:next-launcher 566)
    (:conerot-x (degrees 70) (degrees 20))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 566
  :init-specs ((:fade-a -1.0666667))
  )

(defpart 567
  :init-specs ((:texture (new 'static 'texture-id :index #x92 :page #xc))
    (:num 4.0)
    (:y (meters 0.75))
    (:scale-x (meters 6))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.3) (meters 1))
    (:r 192.0)
    (:g 192.0)
    (:b 64.0 128.0)
    (:a 0.0)
    (:scalevel-x (meters 0.009765625))
    (:rotvel-z (degrees -0.15) (degrees 0.3))
    (:scalevel-y (meters 0.009765625))
    (:fade-a 2.1333334)
    (:timer (seconds 0.1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 sp-cpuinfo-flag-21))
    (:next-time (seconds 0.05))
    (:next-launcher 568)
    (:rotate-y (degrees 0))
    )
  )

(defpart 568
  :init-specs ((:fade-a -2.1333334))
  )

(defpart 569
  :init-specs ((:texture (new 'static 'texture-id :index #x29 :page #xc))
    (:num 1.0)
    (:y (meters 1))
    (:scale-x (meters 8))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 196.0)
    (:g 196.0)
    (:b 196.0)
    (:a 28.0)
    (:timer (seconds 0.035))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 sp-cpuinfo-flag-21))
    )
  )

(defpart 570
  :init-specs ((:texture (new 'static 'texture-id :index #xc :page #xc))
    (:num 5.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters 0.25) (meters 1.5))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.6) 2.0 (meters 0.6))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.3))
    (:r 160.0)
    (:g 160.0)
    (:b 160.0)
    (:a 128.0)
    (:vel-y (meters 0.06666667) (meters 0.06666667))
    (:rotvel-x (degrees 1.2))
    (:rotvel-y (degrees 2.4))
    (:rotvel-z (degrees 0) 2 (degrees 2.4))
    (:accel-y (meters -0.0033333334))
    (:friction 0.97)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14 sp-cpuinfo-flag-21))
    (:next-time (seconds 0.25))
    (:next-launcher 571)
    (:conerot-x (degrees 40) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 571
  :init-specs ((:scalevel-x (meters -0.0033333334)) (:scalevel-y :copy scalevel-x) (:fade-a -3.4))
  )

(defpart 572
  :init-specs ((:texture (new 'static 'texture-id :index #xb :page #xc))
    (:num 4.5)
    (:x (meters -0.5) (meters 1))
    (:y (meters 0.25) (meters 1.5))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.3) 1 (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.3))
    (:r 100.0)
    (:g 100.0)
    (:b 100.0)
    (:a 128.0)
    (:vel-y (meters 0.06666667) (meters 0.06666667))
    (:rotvel-x (degrees 1.2))
    (:rotvel-y (degrees 2.4))
    (:rotvel-z (degrees 0) 3 (degrees 2.4))
    (:accel-y (meters -0.0033333334))
    (:friction 0.97)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14 sp-cpuinfo-flag-21))
    (:next-time (seconds 0.25))
    (:next-launcher 571)
    (:conerot-x (degrees 40) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpartgroup group-crate-explode
  :id 124
  :duration (seconds 0.017)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 12)
  :parts ((sp-item 565 :flags (bit7))
    (sp-item 567 :flags (bit7))
    (sp-item 569 :flags (bit7))
    (sp-item 570 :flags (bit7))
    (sp-item 572 :flags (bit7))
    )
  )

(defpartgroup group-crate-steel-explode
  :id 125
  :duration (seconds 0.017)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 12)
  :parts ((sp-item 565) (sp-item 567) (sp-item 569) (sp-item 572) (sp-item 572) (sp-item 572))
  )

(defpartgroup group-dark-eco-box-explosion
  :id 126
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 12)
  :parts ((sp-item 154 :fade-after (meters 100) :period (seconds 2) :length (seconds 0.017) :binding 152)
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 152 :flags (start-dead launch-asap) :binding 153)
    (sp-item 153 :fade-after (meters 80) :falloff-to (meters 100) :flags (start-dead))
    (sp-item 573 :fade-after (meters 160) :period (seconds 2) :length (seconds 0.017))
    (sp-item 155 :period (seconds 2) :length (seconds 0.017))
    (sp-item 156 :fade-after (meters 80) :falloff-to (meters 80) :period (seconds 2) :length (seconds 0.135))
    (sp-item 157 :period (seconds 2) :length (seconds 0.067))
    (sp-item 574 :fade-after (meters 120) :falloff-to (meters 120) :period (seconds 2) :length (seconds 0.067))
    )
  )

(defpart 156
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 6.0)
    (:scale-x (meters 0.2) (meters 0.4))
    (:scale-y :copy scale-x)
    (:r 64.0 128.0)
    (:g 0.0 32.0)
    (:b 96.0 64.0)
    (:a 32.0 96.0)
    (:vel-y (meters 0.026666667) (meters 0.10666667))
    (:scalevel-x (meters -0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:accel-y (meters -0.00016666666) (meters -0.00016666666))
    (:friction 0.9)
    (:timer (seconds 1))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-14))
    (:next-time (seconds 0.1) (seconds 0.097))
    (:next-launcher 575)
    (:conerot-x (degrees 0) (degrees 140))
    (:conerot-y (degrees 0) (degrees 360))
    (:conerot-radius (meters 2) (meters 4))
    )
  )

(defpart 575
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -1.4222223))
  )

(defpart 574
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 3.0)
    (:scale-x (meters 0.2))
    (:rot-z (degrees 0) (degrees 180))
    (:scale-y (meters 8))
    (:r 64.0 192.0)
    (:g 0.0 32.0)
    (:b 128.0 64.0)
    (:a 32.0 64.0)
    (:scalevel-y (meters 0.42666668))
    (:fade-a -1.6)
    (:timer (seconds 0.2))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    )
  )

(defpart 155
  :init-specs ((:texture (new 'static 'texture-id :index #x29 :page #xc))
    (:num 1.0)
    (:scale-x (meters 16))
    (:scale-y :copy scale-x)
    (:r 64.0 192.0)
    (:g 0.0 32.0)
    (:b 128.0 64.0)
    (:a 96.0)
    (:fade-a -1.7454545)
    (:timer (seconds 0.18))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    )
  )

(defpart 157
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 4.0)
    (:scale-x (meters 2.5) (meters 1.5))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0 96.0)
    (:g 0.0 32.0)
    (:b 64.0 32.0)
    (:a 64.0 64.0)
    (:vel-y (meters 0.053333335) (meters 0.013333334))
    (:scalevel-x (meters 0.013333334))
    (:rotvel-z (degrees -0.3) (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.42666668)
    (:accel-y (meters 0.00016666666) (meters 0.00016666666))
    (:friction 0.8)
    (:timer (seconds 1.7))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-14))
    (:conerot-x (degrees 0) (degrees 110))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 154
  :init-specs ((:texture (new 'static 'texture-id :index #x29 :page #xc))
    (:num 16.0)
    (:y (meters 1))
    (:scale-x (meters 0.1))
    (:scale-y :copy scale-x)
    (:a 0.0)
    (:vel-y (meters 0.053333335) (meters 0.026666667))
    (:accel-y (meters -0.00033333333))
    (:friction 0.94)
    (:timer (seconds 0.8))
    (:flags (sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    (:conerot-x (degrees 0) (degrees 140))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 152
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:y (meters 0) (meters 16))
    (:z (meters 0.3) (meters 0.3))
    (:scale-x (meters 0.3) (meters 0.3))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 0.0 96.0)
    (:g 0.0 32.0)
    (:b 64.0 32.0)
    (:a 64.0 64.0)
    (:omega (degrees 0) (degrees 360))
    (:vel-x (meters 0.026666667) (meters 0.10666667))
    (:scalevel-x (meters -0.000909091))
    (:rotvel-z (degrees -0.3) 1 (degrees 0.6))
    (:scalevel-y :copy scalevel-x)
    (:fade-g -0.26666668)
    (:fade-a -0.19393939)
    (:timer (seconds 0.3) (seconds 0.497))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 ready-to-launch sp-cpuinfo-flag-14))
    )
  )

(defpart 153
  :init-specs ((:texture (new 'static 'texture-id :index #xc9 :page #xc))
    (:num 1.0)
    (:scale-x (meters 0.3) (meters 0.1))
    (:scale-y :copy scale-x)
    (:r 32.0 96.0)
    (:g 0.0 32.0)
    (:b 64.0 32.0)
    (:a 32.0 32.0)
    (:scalevel-x (meters -0.0006190476))
    (:scalevel-y :copy scalevel-x)
    (:fade-a -0.01904762)
    (:accel-y (meters -0.000100000005) (meters -0.00015))
    (:timer (seconds 0.1) (seconds 0.997))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14))
    (:next-time (seconds 0.8))
    (:next-launcher 397)
    )
  )

(defpart 573
  :init-specs ((:texture (new 'static 'texture-id :index #xb :page #xc))
    (:num 8.0 16.0)
    (:x (meters -0.5) (meters 1))
    (:y (meters 0.25) (meters 1.5))
    (:z (meters -0.5) (meters 1))
    (:scale-x (meters 0.3) 1 (meters 1))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.3))
    (:r 128.0)
    (:g 64.0 1 32.0)
    (:b 32.0)
    (:a 128.0)
    (:vel-y (meters 0.06666667) (meters 0.06666667))
    (:rotvel-x (degrees 1.2))
    (:rotvel-y (degrees 2.4))
    (:rotvel-z (degrees 0) 3 (degrees 2.4))
    (:accel-y (meters -0.0033333334))
    (:friction 0.97)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-12 sp-cpuinfo-flag-14))
    (:next-time (seconds 0.25))
    (:next-launcher 576)
    (:conerot-x (degrees 40) (degrees 30))
    (:conerot-y (degrees 0) (degrees 360))
    )
  )

(defpart 576
  :init-specs ((:scalevel-x (meters -0.0033333334)) (:scalevel-y :copy scalevel-x) (:fade-a -3.4))
  )

(defbehavior crate-standard-event-handler crate ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('track)
     (not (logtest? (actor-option no-track) (-> self fact options)))
     )
    (('attack)
     (let* ((v1-3 (the-as attack-info (-> arg3 param 1)))
            (s4-0 (-> v1-3 id))
            (s5-0 (-> v1-3 count))
            )
       (case (-> self defense)
         (('iron)
          (case (-> v1-3 mode)
            (('flop 'uppercut 'explode 'eco-yellow 'racer 'board 'tube 'flut-bonk 'flut-attack 'darkjak 'mech-punch)
             (if (and (logtest? (-> self fact options) (actor-option racer-only))
                      (= (-> arg0 type) target)
                      (not (logtest? (focus-status pilot) (-> (the-as target arg0) focus-status)))
                      )
                 (return #f)
                 )
             (send-event arg0 'get-attack-count 1)
             (process-contact-action arg0)
             (set! (-> self target) (process->handle arg0))
             (go-virtual die #f (the-as int s5-0))
             )
            (else
              (when (and (!= s4-0 (-> self incoming-attack-id)) (= (-> self root-override2 trans y) (-> self base y)))
                (if (not (and (demo?) (= (-> *setting-control* user-current language) (language-enum japanese))))
                    (talker-spawn-func (-> *talker-speech* 313) *entity-pool* (target-pos 0) (the-as region #f))
                    )
                (talker-spawn-func (-> *talker-speech* 315) *entity-pool* (target-pos 0) (the-as region #f))
                (set! (-> self incoming-attack-id) s4-0)
                (if (not (!= (-> self smush amp) 0.0))
                    (sound-play "icrate-nobreak")
                    )
                (activate! (-> self smush) 0.1 90 150 1.0 1.0 (-> self clock))
                (go-virtual bounce-on)
                )
              #f
              )
            )
          )
         (('steel)
          (case (-> v1-3 mode)
            (('explode 'eco-yellow 'tube 'flut-bonk 'flut-attack 'racer 'board 'darkjak 'mech-punch)
             (send-event arg0 'get-attack-count 1)
             (when (logtest? (-> self draw status) (draw-control-status on-screen))
               (talker-spawn-func (-> *talker-speech* 316) *entity-pool* (target-pos 0) (the-as region #f))
               (talker-spawn-func (-> *talker-speech* 317) *entity-pool* (target-pos 0) (the-as region #f))
               )
             (process-contact-action arg0)
             (set! (-> self target) (process->handle arg0))
             (go-virtual die #f (the-as int s5-0))
             )
            (else
              (when (and (!= s4-0 (-> self incoming-attack-id)) (= (-> self root-override2 trans y) (-> self base y)))
                (talker-spawn-func (-> *talker-speech* 318) *entity-pool* (target-pos 0) (the-as region #f))
                (set! (-> self incoming-attack-id) s4-0)
                (if (not (!= (-> self smush amp) 0.0))
                    (sound-play "scrate-nobreak")
                    )
                (activate! (-> self smush) 0.1 90 150 1.0 1.0 (-> self clock))
                (go-virtual bounce-on)
                )
              #f
              )
            )
          )
         (('darkeco)
          (let ((a1-36 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-36 from) (process->ppointer self))
            (set! (-> a1-36 num-params) 2)
            (set! (-> a1-36 message) 'attack)
            (set! (-> a1-36 param 0) (-> arg3 param 0))
            (let ((v1-83 (new 'static 'attack-info :mask (attack-info-mask mode id))))
              (let* ((a0-67 *game-info*)
                     (a2-11 (+ (-> a0-67 attack-id) 1))
                     )
                (set! (-> a0-67 attack-id) a2-11)
                (set! (-> v1-83 id) a2-11)
                )
              (set! (-> v1-83 mode) 'darkeco)
              (set! (-> a1-36 param 1) (the-as uint v1-83))
              )
            (send-event-function arg0 a1-36)
            )
          (when (= (-> arg0 type) target)
            (talker-spawn-func (-> *talker-speech* 319) *entity-pool* (target-pos 0) (the-as region #f))
            (talker-spawn-func (-> *talker-speech* 314) *entity-pool* (target-pos 0) (the-as region #f))
            )
          (process-contact-action arg0)
          (set! (-> self target) (process->handle arg0))
          (go-virtual die #f (the-as int s5-0))
          )
         (else
           (-> v1-3 mode)
           (send-event arg0 'get-attack-count 1)
           (process-contact-action arg0)
           (set! (-> self target) (process->handle arg0))
           (go-virtual die #f (the-as int s5-0))
           )
         )
       )
     )
    (('touch)
     (case (-> self defense)
       (('darkeco)
        (let ((a1-42 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-42 from) (process->ppointer self))
          (set! (-> a1-42 num-params) 2)
          (set! (-> a1-42 message) 'attack)
          (set! (-> a1-42 param 0) (-> arg3 param 0))
          (let ((v1-111 (new 'static 'attack-info :mask (attack-info-mask mode id))))
            (let* ((a0-93 *game-info*)
                   (a2-15 (+ (-> a0-93 attack-id) 1))
                   )
              (set! (-> a0-93 attack-id) a2-15)
              (set! (-> v1-111 id) a2-15)
              )
            (set! (-> v1-111 mode) 'darkeco)
            (set! (-> a1-42 param 1) (the-as uint v1-111))
            )
          (send-event-function arg0 a1-42)
          )
        (process-contact-action arg0)
        (set! (-> self target) (process->handle arg0))
        (go-virtual die #f 0)
        )
       )
     )
    (('bonk)
     (when (= (-> self root-override2 trans y) (-> self base y))
       (activate! (-> self smush) -0.1 75 150 1.0 1.0 (-> self clock))
       (go-virtual bounce-on)
       )
     )
    (('wake)
     (let ((v0-1 (the-as object (logclear (-> self mask) (process-mask sleep)))))
       (set! (-> self mask) (the-as process-mask v0-1))
       v0-1
       )
     )
    (('hide)
     (go-virtual hide)
     )
    (('eco-blue)
     (if (not (or (= (-> self defense) 'darkeco)
                  (and (-> self next-state) (let ((v1-131 (-> self next-state name)))
                                              (or (= v1-131 'notice-blue) (= v1-131 'die))
                                              )
                       )
                  (!= (-> self root-override2 trans y) (-> self base y))
                  )
              )
         (go-virtual notice-blue (process->handle arg0))
         )
     )
    (('fall)
     (when (not (and (-> self next-state) (= (-> self next-state name) 'fall)))
       (set! (-> self root-override2 transv quad) (-> (the-as vector (-> arg3 param 0)) quad))
       (go-virtual fall)
       )
     )
    )
  )

(defstate hide (crate)
  :virtual #t
  :code (behavior ()
    (process-entity-status! self (entity-perm-status dead) #f)
    (process-entity-status! self (entity-perm-status subtask-complete) #f)
    (vector+! (-> self draw origin) (-> self root-override2 trans) (-> self draw bounds))
    (set! (-> self draw origin w) (-> self draw bounds w))
    (logior! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-9 (-> (the-as collide-shape-moving (-> self root-override2)) root-prim)))
      (set! (-> v1-9 prim-core collide-as) (collide-spec))
      (set! (-> v1-9 prim-core collide-with) (collide-spec))
      )
    0
    (ja-post)
    (while (or (crate-method-40 self)
               (and (sphere-in-view-frustum? (the-as sphere (-> self draw origin)))
                    (< (vector-vector-distance (camera-pos) (-> self root-override2 trans)) 327680.0)
                    )
               (and *target*
                    (and (>= 40960.0 (vector-vector-distance (-> self root-override2 trans) (-> *target* control trans)))
                         (not (logtest? (focus-status teleporting) (-> *target* focus-status)))
                         )
                    )
               )
      (suspend)
      )
    (logclear! (-> self draw status) (draw-control-status no-draw))
    (let ((v1-29 (-> (the-as collide-shape-moving (-> self root-override2)) root-prim)))
      (set! (-> v1-29 prim-core collide-as)
            (-> (the-as collide-shape-moving (-> self root-override2)) backup-collide-as)
            )
      (set! (-> v1-29 prim-core collide-with)
            (-> (the-as collide-shape-moving (-> self root-override2)) backup-collide-with)
            )
      )
    (go-virtual idle)
    (none)
    )
  )

(defstate idle (crate)
  :virtual #t
  :event crate-standard-event-handler
  :code (behavior ()
    (suspend)
    (update-transforms (the-as collide-shape-moving (-> self root-override2)))
    (carry-info-method-9 (-> self carry))
    (logior! (-> self mask) (process-mask sleep))
    (until #f
      (suspend)
      )
    #f
    (none)
    )
  :post (the-as (function none :behavior crate) ja-post)
  )

(defstate carry (crate)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('carry? 'carry-info)
       (-> self carry)
       )
      (('drop)
       (set! (-> self root-override2 transv quad) (-> (the-as vector (-> event param 1)) quad))
       (go-virtual fall)
       )
      )
    )
  :code (the-as (function none :behavior crate) sleep-code)
  :post (behavior ()
    (ja-post)
    (carry-info-method-9 (-> self carry))
    (carry-info-method-13 (-> self carry))
    (update-transforms (the-as collide-shape-moving (-> self root-override2)))
    (none)
    )
  )

(defstate fall (crate)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('carry-info)
                      (-> self carry)
                      )
                     (('carry? 'pickup)
                      (the-as carry-info #f)
                      )
                     )
            )
    )
  :enter (behavior ()
    (if (handle->process (-> self carry other))
        (drop-impl!
          (the-as carry-info (send-event (handle->process (-> self carry other)) 'carry-info))
          (-> self carry)
          )
        )
    (set! (-> self root-override2 status) (collide-status))
    (set! (-> self root-override2 root-prim local-sphere w) (-> self carry carry-radius))
    (set! (-> self root-override2 root-prim prim-core collide-with)
          (logior (collide-spec backgnd crate obstacle hit-by-others-list pusher)
                  (-> self root-override2 root-prim prim-core collide-with)
                  )
          )
    (none)
    )
  :trans (behavior ()
    (when (and (logtest? (-> (the-as collide-shape-moving (-> self root-override2)) status) (collide-status on-surface))
               (< 0.8 (-> (the-as collide-shape-moving (-> self root-override2)) surface-angle))
               )
      (vector-reset! (-> self root-override2 transv))
      (when (= (vector-length (-> self root-override2 transv)) 0.0)
        (set! (-> (the-as collide-shape-moving (-> self root-override2)) root-prim local-sphere w)
              (-> self carry backup-radius)
              )
        (set! (-> self base quad) (-> self root-override2 trans quad))
        (let ((v1-16 (-> (the-as collide-shape-moving (-> self root-override2)) root-prim)))
          (set! (-> v1-16 prim-core collide-as)
                (-> (the-as collide-shape-moving (-> self root-override2)) backup-collide-as)
                )
          (set! (-> v1-16 prim-core collide-with)
                (-> (the-as collide-shape-moving (-> self root-override2)) backup-collide-with)
                )
          )
        (go-virtual idle)
        )
      )
    (none)
    )
  :code (the-as (function none :behavior crate) sleep-code)
  :post (behavior ()
    (vector-v++!
      (-> self root-override2 transv)
      (compute-acc-due-to-gravity (the-as collide-shape-moving (-> self root-override2)) (new-stack-vector0) 0.0)
      )
    (if (< (-> (the-as collide-shape-moving (-> self root-override2)) dynam gravity-max)
           (vector-length (-> self root-override2 transv))
           )
        (vector-normalize!
          (-> self root-override2 transv)
          (-> (the-as collide-shape-moving (-> self root-override2)) dynam gravity-max)
          )
        )
    (let ((gp-1 (-> self root-override2)))
      (let ((a2-1 (new 'stack-no-clear 'collide-query)))
        (set! (-> gp-1 root-prim type) collide-shape-prim-sphere)
        (set! (-> a2-1 collide-with) (collide-spec backgnd crate obstacle pusher))
        (set! (-> a2-1 ignore-process0) self)
        (set! (-> a2-1 ignore-process1) #f)
        (set! (-> a2-1 ignore-pat) (-> gp-1 pat-ignore-mask))
        (set! (-> a2-1 action-mask) (collide-action solid))
        (fill-cache-integrate-and-collide gp-1 (-> gp-1 transv) a2-1 (meters 0))
        )
      (set! (-> gp-1 root-prim type) collide-shape-prim-mesh)
      )
    (crate-post)
    (none)
    )
  )

(defstate bounce-on (crate)
  :virtual #t
  :event crate-standard-event-handler
  :code (behavior ()
    (while (!= (-> self smush amp) 0.0)
      (suspend)
      )
    (go-virtual idle)
    (none)
    )
  :post crate-post
  )

(defstate notice-blue (crate)
  :virtual #t
  :event crate-standard-event-handler
  :trans (behavior ()
    (cond
      ((not (send-event *target* 'query 'powerup (pickup-type eco-blue)))
       (logior! (-> self mask) (process-mask sleep-code))
       (if (not (!= (-> self smush amp) 0.0))
           (go-virtual idle)
           )
       )
      (else
        (logclear! (-> self mask) (process-mask sleep-code))
        )
      )
    (none)
    )
  :code (behavior ((arg0 handle))
    (set! (-> self target) arg0)
    (until #f
      (let* ((gp-0 (handle->process (-> self target)))
             (v1-3 (if (type? gp-0 process-drawable)
                       gp-0
                       )
                   )
             )
        (when v1-3
          (let* ((gp-1 (-> (the-as process-drawable v1-3) root))
                 (v1-4 (if (type? (the-as collide-shape-moving gp-1) collide-shape)
                           gp-1
                           )
                       )
                 )
            (when v1-4
              (let* ((gp-2 (-> (the-as collide-shape-moving (-> self root-override2)) root-prim prim-core))
                     (a1-3 (-> (the-as collide-shape-moving v1-4) root-prim prim-core))
                     (f30-0 (vector-vector-distance (the-as vector gp-2) (the-as vector a1-3)))
                     )
                (when (and (< f30-0 (-> *FACT-bank* suck-suck-dist)) (!= (-> self defense) 'steel))
                  (logior! (-> self fact options) (actor-option suck-in))
                  (process-contact-action (handle->process (-> self target)))
                  (go-virtual die #f 0)
                  )
                (when (rand-vu-percent? 0.5)
                  (let ((s5-0 (new 'stack-no-clear 'vector)))
                    (set! (-> s5-0 quad) (-> gp-2 world-sphere quad))
                    (dotimes (gp-3 3)
                      (+! (-> s5-0 data gp-3) (rand-vu-float-range -5324.8 5324.8))
                      )
                    (eco-blue-glow s5-0)
                    )
                  )
                (activate!
                  (-> self smush)
                  (lerp-scale
                    (rand-vu-float-range 0.1 0.3)
                    (rand-vu-float-range 0.0 0.02)
                    f30-0
                    (-> *FACT-bank* suck-suck-dist)
                    (-> *FACT-bank* suck-bounce-dist)
                    )
                  60
                  60
                  1.0
                  1.0
                  (-> self clock)
                  )
                )
              )
            )
          )
        )
      (suspend)
      )
    #f
    (none)
    )
  :post crate-post
  )

(defstate die (crate)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (case event-type
      (('touched)
       (case (-> self defense)
         (('darkeco)
          (let ((a1-3 (new 'stack-no-clear 'event-message-block)))
            (set! (-> a1-3 from) (process->ppointer self))
            (set! (-> a1-3 num-params) 2)
            (set! (-> a1-3 message) 'attack)
            (set! (-> a1-3 param 0) (-> event param 0))
            (let ((v1-6 (new 'static 'attack-info :mask (attack-info-mask mode id))))
              (let* ((a2-2 *game-info*)
                     (a3-2 (+ (-> a2-2 attack-id) 1))
                     )
                (set! (-> a2-2 attack-id) a3-2)
                (set! (-> v1-6 id) a3-2)
                )
              (set! (-> v1-6 mode) 'darkeco)
              (set! (-> a1-3 param 1) (the-as uint v1-6))
              )
            (send-event-function proc a1-3)
            )
          )
         )
       )
      )
    )
  :code (behavior ((arg0 symbol) (arg1 int))
    (logior! (-> self focus-status) (focus-status dead))
    (let ((v1-3 (-> (the-as collide-shape (-> self root-override2)) root-prim)))
      (set! (-> v1-3 prim-core collide-as) (collide-spec))
      (set! (-> v1-3 prim-core collide-with) (collide-spec))
      )
    0
    (if (nonzero? (-> self sound))
        (stop! (-> self sound))
        )
    (let ((v1-10 (handle->process (-> self target))))
      (if (and (and v1-10 (= (-> v1-10 type) target) (focus-test? (the-as process-focusable v1-10) flut tube board pilot))
               (and (!= (-> self fact pickup-type) 10) (not arg0))
               )
          (logior! (-> self fact options) (actor-option suck-in))
          )
      )
    (when (not arg0)
      (let ((s5-1 (current-time)))
        (until (>= (- (current-time) s5-1) (seconds 0.04))
          (suspend)
          )
        )
      (logior! (-> self draw status) (draw-control-status no-draw))
      (case (-> self look)
        (('iron)
         (sound-play "icrate-break")
         )
        (('steel)
         (sound-play "scrate-break")
         )
        (('darkeco)
         (sound-play "dcrate-break")
         )
        (else
          (sound-play "wcrate-break")
          )
        )
      (case (-> self defense)
        (('darkeco)
         (let ((f0-0
                 (lerp-scale 1.0 0.0 (vector-vector-distance (-> self root-override2 trans) (target-pos 0)) 8192.0 40960.0)
                 )
               )
           (cpad-set-buzz! (-> *cpad-list* cpads 0) 1 (the int (* 255.0 f0-0)) (seconds 0.3))
           )
         (process-spawn
           touch-tracker
           :init touch-tracker-init
           (-> self root-override2 trans)
           (-> *CRATE-bank* DARKECO_EXPLODE_RADIUS)
           30
           :to self
           )
         )
        )
      (case (-> self look)
        (('darkeco)
         (let ((s5-8 (get-process *default-dead-pool* part-tracker #x4000)))
           (when s5-8
             (let ((t9-17 (method-of-type part-tracker activate)))
               (t9-17 (the-as part-tracker s5-8) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
               )
             (let ((t9-18 run-function-in-process)
                   (a0-34 s5-8)
                   (a1-21 part-tracker-init)
                   (a2-11 (-> *part-group-id-table* 126))
                   (a3-9 0)
                   (t0-6 #f)
                   (t1-4 #f)
                   (t2-4 #f)
                   (t3-0 *launch-matrix*)
                   )
               (set! (-> t3-0 trans quad) (-> self root-override2 trans quad))
               ((the-as (function object object object object object object object object none) t9-18)
                a0-34
                a1-21
                a2-11
                a3-9
                t0-6
                t1-4
                t2-4
                t3-0
                )
               )
             (-> s5-8 ppointer)
             )
           )
         )
        (('steel 'iron)
         (let ((s5-9 (get-process *default-dead-pool* part-tracker #x4000)))
           (when s5-9
             (let ((t9-20 (method-of-type part-tracker activate)))
               (t9-20 (the-as part-tracker s5-9) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
               )
             (let ((t9-21 run-function-in-process)
                   (a0-39 s5-9)
                   (a1-27 part-tracker-init)
                   (a2-14 (-> *part-group-id-table* 125))
                   (a3-11 0)
                   (t0-7 #f)
                   (t1-5 #f)
                   (t2-5 #f)
                   (t3-1 *launch-matrix*)
                   )
               (set! (-> t3-1 trans quad) (-> self root-override2 trans quad))
               ((the-as (function object object object object object object object object none) t9-21)
                a0-39
                a1-27
                a2-14
                a3-11
                t0-7
                t1-5
                t2-5
                t3-1
                )
               )
             (-> s5-9 ppointer)
             )
           )
         )
        (else
          (let ((s5-10 (get-process *default-dead-pool* part-tracker #x4000)))
            (when s5-10
              (let ((t9-23 (method-of-type part-tracker activate)))
                (t9-23 (the-as part-tracker s5-10) self (symbol->string (-> part-tracker symbol)) (the-as pointer #x70004000))
                )
              (let ((t9-24 run-function-in-process)
                    (a0-42 s5-10)
                    (a1-32 part-tracker-init)
                    (a2-17 (-> *part-group-id-table* 124))
                    (a3-13 0)
                    (t0-8 #f)
                    (t1-6 #f)
                    (t2-6 #f)
                    (t3-2 *launch-matrix*)
                    )
                (set! (-> t3-2 trans quad) (-> self root-override2 trans quad))
                ((the-as (function object object object object object object object object none) t9-24)
                 a0-42
                 a1-32
                 a2-17
                 a3-13
                 t0-8
                 t1-6
                 t2-6
                 t3-2
                 )
                )
              (-> s5-10 ppointer)
              )
            )
          )
        )
      )
    (case (-> self fact pickup-type)
      (((pickup-type money)
        (pickup-type buzzer)
        (pickup-type eco-blue)
        (pickup-type eco-yellow)
        (pickup-type eco-red)
        (pickup-type fuel-cell)
        (pickup-type gem)
        (pickup-type skill)
        )
       (go-virtual special-contents-die)
       )
      (((pickup-type health))
       (if (not (demo?))
           (talker-spawn-func (-> *talker-speech* 8) *entity-pool* (target-pos 0) (the-as region #f))
           )
       )
      )
    (drop-pickup (-> self fact) #t *entity-pool* (the-as fact-info #f) arg1)
    (process-entity-status! self (entity-perm-status dead) #t)
    (process-entity-status! self (entity-perm-status subtask-complete) #t)
    (let ((gp-1 (current-time)))
      (until (>= (- (current-time) gp-1) (seconds 5))
        (suspend)
        )
      )
    (when (logtest? (actor-option cond-respawn) (-> self fact options))
      (let ((gp-2 (current-time)))
        (until (>= (- (current-time) gp-2) (seconds 15))
          (suspend)
          )
        )
      (go-virtual hide)
      )
    (none)
    )
  )

(defstate special-contents-die (crate)
  :virtual #t
  :event (behavior ((proc process) (arg1 int) (event-type symbol) (event event-message-block))
    (the-as object (case event-type
                     (('notify)
                      (case (-> event param 0)
                        (('pickup)
                         (let ((gp-0 (-> self entity extra perm)))
                           (logior! (-> gp-0 status) (entity-perm-status bit-5))
                           (set! (-> gp-0 user-int8 1) (min 127 (+ (-> gp-0 user-int8 1) 1)))
                           (+! (-> self child-count) -1)
                           (when (<= (-> self child-count) 0)
                             (if (or (= (-> self defense) 'iron) (= (-> self defense) 'steel))
                                 (process-entity-status! self (entity-perm-status bit-4) #f)
                                 )
                             (process-entity-status! self (entity-perm-status dead) #t)
                             (process-entity-status! self (entity-perm-status subtask-complete) #t)
                             (set! (-> gp-0 user-int8 0) 2)
                             (let ((v0-0 (logclear (-> self mask) (process-mask sleep))))
                               (set! (-> self mask) v0-0)
                               v0-0
                               )
                             )
                           )
                         )
                        )
                      )
                     )
            )
    )
  :trans (-> (method-of-type crate die) trans)
  :code (behavior ()
    (logior! (-> self focus-status) (focus-status dead))
    (when (or (= (-> self fact pickup-type) (pickup-type money))
              (= (-> self fact pickup-type) (pickup-type gem))
              (= (-> self fact pickup-type) (pickup-type skill))
              (= (-> self defense) 'iron)
              (= (-> self defense) 'steel)
              )
      (let ((a0-6 (-> self entity)))
        (if (when a0-6
              (let ((a0-7 (-> a0-6 extra perm task)))
                (if a0-7
                    (= a0-7 (game-task none))
                    )
                )
              )
            (set! (-> self entity extra perm task) (game-task complete))
            )
        )
      )
    (let ((v1-20 (-> (the-as collide-shape-moving (-> self root-override2)) root-prim)))
      (set! (-> v1-20 prim-core collide-as) (collide-spec))
      (set! (-> v1-20 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    (drop-pickup (-> self fact) #t self (the-as fact-info #f) 0)
    (set! (-> self child-count) (+ (process-count self) -1))
    (process-entity-status! self (entity-perm-status bit-4) #t)
    (when (-> self entity)
      (let ((v1-32 (-> self entity extra perm)))
        (logior! (-> v1-32 status) (entity-perm-status bit-5))
        (set! (-> v1-32 user-int8 0) 1)
        )
      )
    (when (-> self child)
      (logior! (-> self mask) (process-mask sleep))
      (suspend)
      (while (-> self child)
        (suspend)
        )
      )
    (none)
    )
  )

(defbehavior crate-init-by-other crate ((arg0 entity) (arg1 vector) (arg2 symbol) (arg3 fact-info-crate))
  (crate-init! self (the-as entity-actor arg0))
  (set! (-> self root-override2 trans quad) (-> arg1 quad))
  (set! (-> self look) arg2)
  (set! (-> self defense) arg2)
  (skel-init! self)
  (when arg3
    (set! (-> self fact pickup-type) (-> arg3 pickup-type))
    (set! (-> self fact pickup-amount) (-> arg3 pickup-spawn-amount))
    (set! (-> self fact options) (-> arg3 options))
    )
  (crate-method-38 self)
  (none)
  )

(defmethod init-from-entity! crate ((obj crate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (crate-init! obj arg0)
  (skel-init! obj)
  (crate-method-38 obj)
  (none)
  )

;; WARN: Return type mismatch crate vs none.
(defmethod crate-init! crate ((obj crate) (arg0 entity-actor))
  "Initialize the [[crate]] with the specified [[entity-actor]]."
  (stack-size-set! (-> obj main-thread) 128)
  (set! (-> obj mask) (logior (process-mask crate) (-> obj mask)))
  (let ((s4-0 (new 'process 'collide-shape-moving obj (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((v1-10 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-10 prim-core collide-as) (collide-spec crate notice-blue-eco-powerup))
      (set! (-> v1-10 prim-core collide-with) (collide-spec jak player-list tobot))
      (set! (-> v1-10 prim-core action) (collide-action solid rideable))
      (set! (-> v1-10 transform-index) 3)
      (set-vector! (-> v1-10 local-sphere) 0.0 3072.0 0.0 (-> *CRATE-bank* COLLIDE_RADIUS))
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-10)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-13 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-13 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-13 prim-core collide-with))
      )
    (set! (-> s4-0 penetrated-by)
          (penetrate
            generic-attack
            lunge
            flop
            punch
            spin
            roll
            uppercut
            bonk
            tube
            vehicle
            flut-attack
            board
            mech
            mech-punch
            dark-skin
            dark-punch
            dark-giant
            knocked
            )
          )
    (set! (-> obj root-override2) s4-0)
    )
  (set! (-> obj fact)
        (new 'process 'fact-info-crate obj (pickup-type eco-pill-random) (-> *FACT-bank* default-eco-pill-green-inc))
        )
  (when (-> obj entity)
    (let ((v1-22 (-> obj entity extra perm)))
      (set! (-> obj fact pickup-amount)
            (fmax 0.0 (- (-> obj fact pickup-amount) (the float (-> v1-22 user-int8 1))))
            )
      )
    )
  (when (and (-> obj entity) (logtest? (-> obj entity extra perm status) (entity-perm-status subtask-complete)))
    (set! (-> obj fact pickup-type) (pickup-type eco-pill-random))
    (set! (-> obj fact pickup-amount) 0.0)
    )
  (when arg0
    (process-drawable-from-entity! obj arg0)
    (logclear! (-> obj mask) (process-mask actor-pause))
    )
  (let ((v1-37
          ((method-of-type res-lump get-property-struct)
           (-> obj entity)
           'crate-type
           'interp
           -1000000000.0
           (the-as structure 'wood)
           (the-as (pointer res-tag) #f)
           *res-static-buf*
           )
          )
        )
    (set! (-> obj look) (the-as symbol v1-37))
    (set! (-> obj defense) (the-as symbol v1-37))
    )
  (set! (-> obj carry)
        (new 'process 'carry-info obj 3 (new 'static 'vector :w 1.0) (new 'static 'vector :y 1.0 :w 1.0) 0.0)
        )
  (set! (-> obj carry max-pull) 3686.4)
  (set! (-> obj carry carry-radius) 3276.8)
  (set! (-> obj target) (the-as handle #f))
  (none)
  )

;; WARN: Return type mismatch crate vs none.
(defmethod skel-init! crate ((obj crate))
  "Initialize the [[crate]]'s skeleton and other parameters based on the crate type."
  (case (-> obj look)
    (('iron)
     (set! (-> (the-as collide-shape-moving (-> obj root-override2)) penetrated-by)
           (penetrate flop uppercut tube vehicle flut-attack board dark-skin explode)
           )
     (initialize-skeleton
       obj
       (the-as skeleton-group (art-group-get-by-name *level* "skel-crate-krimson" (the-as (pointer uint32) #f)))
       (the-as pair 0)
       )
     )
    (('steel)
     (set! (-> (the-as collide-shape-moving (-> obj root-override2)) penetrated-by)
           (penetrate tube vehicle flut-attack board dark-skin explode)
           )
     (initialize-skeleton
       obj
       (the-as skeleton-group (art-group-get-by-name *level* "skel-crate-krimson" (the-as (pointer uint32) #f)))
       (the-as pair 0)
       )
     )
    (('darkeco)
     (when (= (-> obj fact pickup-type) (pickup-type eco-pill-random))
       (set! (-> obj fact pickup-type) (pickup-type none))
       (set! (-> obj fact pickup-amount) 0.0)
       )
     (initialize-skeleton
       obj
       (the-as skeleton-group (art-group-get-by-name *level* "skel-crate-krimson" (the-as (pointer uint32) #f)))
       (the-as pair 0)
       )
     (set-vector! (-> obj draw color-mult) 0.8 0.8 0.8 1.0)
     (set-vector! (-> obj draw color-emissive) 0.2 0.2 0.2 1.0)
     )
    (('none)
     (initialize-skeleton
       obj
       (the-as skeleton-group (art-group-get-by-name *level* "skel-crate-krimson" (the-as (pointer uint32) #f)))
       (the-as pair 0)
       )
     (logior! (-> obj draw status) (draw-control-status no-draw))
     )
    (else
      (initialize-skeleton
        obj
        (the-as skeleton-group (art-group-get-by-name *level* "skel-crate-krimson" (the-as (pointer uint32) #f)))
        (the-as pair 0)
        )
      )
    )
  (set! (-> obj base quad) (-> obj root-override2 trans quad))
  (crate-post)
  (nav-mesh-connect-from-ent obj)
  (none)
  )

;; WARN: Return type mismatch crate vs none.
(defmethod params-set! crate ((obj crate) (arg0 symbol) (arg1 symbol))
  "Set [[crate]] params based on the arguments."
  (if arg0
      (set! (-> obj look) arg0)
      )
  (if arg1
      (set! (-> obj defense) arg1)
      )
  (none)
  )

(defmethod crate-method-38 crate ((obj crate))
  (when (-> obj entity)
    (if (>= (-> obj entity extra perm user-int8 0) 1)
        (go (method-of-object obj die) #t 0)
        )
    )
  (cond
    ((logtest? (actor-option cond-hide) (-> obj fact options))
     (go (method-of-object obj hide))
     )
    ((logtest? (actor-option fall) (-> obj fact options))
     (go (method-of-object obj fall))
     )
    (else
      (go (method-of-object obj idle))
      )
    )
  0
  (none)
  )

(defmethod smush-update! crate ((obj crate))
  (let ((f0-0 (update! (-> obj smush))))
    (set! (-> obj root-override2 scale x) (+ 1.0 (* -0.5 f0-0)))
    (set! (-> obj root-override2 scale y) (+ 1.0 f0-0))
    (set! (-> obj root-override2 scale z) (+ 1.0 (* -0.5 f0-0)))
    )
  0
  (none)
  )

;; WARN: disable def twice: 57. This may happen when a cond (no else) is nested inside of another conditional, but it should be rare.
(defmethod crate-method-40 crate ((obj crate))
  (cond
    ((and (> (-> (the-as fact-info-crate (-> obj fact)) suck-count) 0)
          (< (you-suck-stage *game-info* #f) (-> (the-as fact-info-crate (-> obj fact)) suck-count))
          )
     #t
     )
    ((logtest? (actor-option cond-low-ammo) (-> obj fact options))
     (case (-> obj fact pickup-type)
       (((pickup-type ammo-yellow) (pickup-type ammo-red) (pickup-type ammo-blue) (pickup-type ammo-dark))
        (let ((a1-4 (new 'stack-no-clear 'event-message-block)))
          (set! (-> a1-4 from) (process->ppointer self))
          (set! (-> a1-4 num-params) 1)
          (set! (-> a1-4 message) 'test-pickup)
          (set! (-> a1-4 param 0) (the-as uint (-> obj fact pickup-type)))
          (let ((v1-15 (the-as float (send-event-function *target* a1-4))))
            (or (not v1-15) (< 10.0 v1-15))
            )
          )
        )
       (else
         #f
         )
       )
     )
    (else
      #f
      )
    )
  )

(deftype pickup-spawner (crate)
  ((blocker entity-actor  :offset-assert 288)
   )
  :heap-base #xb0
  :method-count-assert 41
  :size-assert         #x124
  :flag-assert         #x2900b00124
  )


;; WARN: Return type mismatch pickup-spawner vs none.
(defmethod crate-init! pickup-spawner ((obj pickup-spawner) (arg0 entity-actor))
  "Initialize the [[crate]] with the specified [[entity-actor]]."
  (let ((t9-0 (method-of-type crate crate-init!)))
    (t9-0 obj arg0)
    )
  (set! (-> obj look) 'none)
  (set! (-> obj blocker) #f)
  (if (logtest? (-> obj fact options) (actor-option blocked))
      (set! (-> obj blocker) (entity-actor-lookup (-> obj entity) 'alt-actor 0))
      )
  (none)
  )

(defmethod crate-method-38 pickup-spawner ((obj pickup-spawner))
  (go (method-of-object obj idle))
  0
  (none)
  )

(defstate idle (pickup-spawner)
  :virtual #t
  :code (behavior ()
    (until #f
      (if (or (not (-> self blocker))
              (logtest? (-> self blocker extra perm status) (entity-perm-status subtask-complete))
              )
          (go-virtual die #t 0)
          )
      (suspend)
      )
    #f
    (none)
    )
  )
